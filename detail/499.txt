{
    "title": "数学建模常用算法及代码实现", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/yan-cong-52", 
        "https://www.zhihu.com/people/hong-andy-61", 
        "https://www.zhihu.com/people/meng-meng-da-zjiang", 
        "https://www.zhihu.com/people/mo-e-de-xiao-cao-mei", 
        "https://www.zhihu.com/people/jams-lu", 
        "https://www.zhihu.com/people/liu-qing-qing-72-21", 
        "https://www.zhihu.com/people/xu-hua-qing-6", 
        "https://www.zhihu.com/people/frank-57-34", 
        "https://www.zhihu.com/people/xia-kan-kan-41-64", 
        "https://www.zhihu.com/people/roan-g", 
        "https://www.zhihu.com/people/ha-ha-ou-ye-88", 
        "https://www.zhihu.com/people/xing-bi-qi-shi", 
        "https://www.zhihu.com/people/zhang-hao-89-46", 
        "https://www.zhihu.com/people/jia-zai-zhong-47-43", 
        "https://www.zhihu.com/people/kong-xiang-peng-87", 
        "https://www.zhihu.com/people/lao-nai-nai-hua-sheng-mi-ting-hao-chi", 
        "https://www.zhihu.com/people/duan-xing-hao-43", 
        "https://www.zhihu.com/people/nian-you-2", 
        "https://www.zhihu.com/people/lu-liang-54", 
        "https://www.zhihu.com/people/wu-yi-cong-76", 
        "https://www.zhihu.com/people/xiao-yan-59-2-12", 
        "https://www.zhihu.com/people/eeyan-16", 
        "https://www.zhihu.com/people/chen-yuan-jie-16", 
        "https://www.zhihu.com/people/xiezhiije", 
        "https://www.zhihu.com/people/perfect_person", 
        "https://www.zhihu.com/people/tian-tang-zhi-zao-28", 
        "https://www.zhihu.com/people/davidwang-89", 
        "https://www.zhihu.com/people/li-da-hui-76", 
        "https://www.zhihu.com/people/zhu-jie-ci", 
        "https://www.zhihu.com/people/jing-di-zhi-yu-6", 
        "https://www.zhihu.com/people/long-yun-bo-42-49", 
        "https://www.zhihu.com/people/wang-tian-yuan-77", 
        "https://www.zhihu.com/people/duan-xing-99", 
        "https://www.zhihu.com/people/willwinworld", 
        "https://www.zhihu.com/people/xiao-deng-chuang-jiang-hu", 
        "https://www.zhihu.com/people/ren-yi-fei-81-66", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/liucsg", 
        "https://www.zhihu.com/people/shen-hai-57-99", 
        "https://www.zhihu.com/people/andrew-43-11", 
        "https://www.zhihu.com/people/hou-lian-pi-87-92", 
        "https://www.zhihu.com/people/exybean", 
        "https://www.zhihu.com/people/gnsylyj-3", 
        "https://www.zhihu.com/people/li-tian-jue-68", 
        "https://www.zhihu.com/people/pand-54", 
        "https://www.zhihu.com/people/qu-zhi-61-89", 
        "https://www.zhihu.com/people/gzsailor", 
        "https://www.zhihu.com/people/li-kai-63-86", 
        "https://www.zhihu.com/people/louis-89-70", 
        "https://www.zhihu.com/people/shuang-kong-xiao-hun-dun", 
        "https://www.zhihu.com/people/shi-jie-wai-de-deng-huo", 
        "https://www.zhihu.com/people/huang-shou-wei-35", 
        "https://www.zhihu.com/people/huc_zhangjingxin", 
        "https://www.zhihu.com/people/knowing-82", 
        "https://www.zhihu.com/people/feng-41", 
        "https://www.zhihu.com/people/lve-87", 
        "https://www.zhihu.com/people/mango-32-60", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/redboy-79", 
        "https://www.zhihu.com/people/fei-yang-93-49-94", 
        "https://www.zhihu.com/people/chen-fei-22-6", 
        "https://www.zhihu.com/people/allen-sun-14", 
        "https://www.zhihu.com/people/wang-jing-bo-27-88", 
        "https://www.zhihu.com/people/po-sui-shi-jie", 
        "https://www.zhihu.com/people/devilBlood", 
        "https://www.zhihu.com/people/mercy-35", 
        "https://www.zhihu.com/people/cai-xian-ju", 
        "https://www.zhihu.com/people/captain-50-44", 
        "https://www.zhihu.com/people/kevind", 
        "https://www.zhihu.com/people/JJusti", 
        "https://www.zhihu.com/people/yao-jia-qi-97-76", 
        "https://www.zhihu.com/people/xs-mo", 
        "https://www.zhihu.com/people/chenwinter", 
        "https://www.zhihu.com/people/tu-yang-tu-sen-po-78", 
        "https://www.zhihu.com/people/xin-guo-rong-32", 
        "https://www.zhihu.com/people/wen-wen-10-78-69", 
        "https://www.zhihu.com/people/shi-an-an-65", 
        "https://www.zhihu.com/people/zhuang-sheng-meng-die-42", 
        "https://www.zhihu.com/people/gyh-99", 
        "https://www.zhihu.com/people/xiong-jing-95-22", 
        "https://www.zhihu.com/people/zi-zai-ru-feng-25-37", 
        "https://www.zhihu.com/people/james-chang-67", 
        "https://www.zhihu.com/people/qiao-xu-26", 
        "https://www.zhihu.com/people/xu-da-xu-65", 
        "https://www.zhihu.com/people/li-chun-hui-49-63", 
        "https://www.zhihu.com/people/ahaihai", 
        "https://www.zhihu.com/people/hobby-43", 
        "https://www.zhihu.com/people/jing-wei-1989", 
        "https://www.zhihu.com/people/tian-ma-xing-kong-67-86", 
        "https://www.zhihu.com/people/haofeng1", 
        "https://www.zhihu.com/people/liu-jia-yu-29-90", 
        "https://www.zhihu.com/people/arizona-98", 
        "https://www.zhihu.com/people/wang-xi-3-19-65", 
        "https://www.zhihu.com/people/li-ling-12-18-63", 
        "https://www.zhihu.com/people/kan-kai-la", 
        "https://www.zhihu.com/people/hao-qi-bao-bao-88-1", 
        "https://www.zhihu.com/people/yang-ye-79", 
        "https://www.zhihu.com/people/dalingxues", 
        "https://www.zhihu.com/people/alex-zhang-20", 
        "https://www.zhihu.com/people/she-liang", 
        "https://www.zhihu.com/people/seraf-53", 
        "https://www.zhihu.com/people/jiao-huang-89", 
        "https://www.zhihu.com/people/wan-zhu-zhuan", 
        "https://www.zhihu.com/people/donewell", 
        "https://www.zhihu.com/people/jian-zhi-jiu-tian-22", 
        "https://www.zhihu.com/people/gong-sun-yu-long-yong-yuan-zai-ying", 
        "https://www.zhihu.com/people/xingwei-zheng", 
        "https://www.zhihu.com/people/luozhongbin", 
        "https://www.zhihu.com/people/he-he-93-98-27", 
        "https://www.zhihu.com/people/ma-gong-xin", 
        "https://www.zhihu.com/people/er-yue-san-shi-36-86", 
        "https://www.zhihu.com/people/johnny-63-54", 
        "https://www.zhihu.com/people/zi-fei-yu-76-10", 
        "https://www.zhihu.com/people/tu-dou-75-95", 
        "https://www.zhihu.com/people/lee-82-88", 
        "https://www.zhihu.com/people/wu-hao-82-55", 
        "https://www.zhihu.com/people/xia-shan-51-76", 
        "https://www.zhihu.com/people/bar-33", 
        "https://www.zhihu.com/people/yul-47-25", 
        "https://www.zhihu.com/people/xi-hong-shi-ji-dan-mian-46"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/86525700", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 6, 
            "title": "强化学习--贝尔曼方程", 
            "content": "<h2>Bellman方程</h2><p>Bellman方程是强化学习的基础和核心，在介绍强化学习的概念及应用时我们必须对贝尔曼方程有个全面的了解，不然后面的只是将很难理解和掌握，所以在这里我们首先介绍Bellman方程的基础知识。</p><p>首先我们需要弄清楚贝尔曼方程的三个主要概念，策略函数、状态价值函数、状态-动作价值函数（简称为动作价值函数）<sup data-text=\"贝尔曼方程推导\" data-url=\"https://blog.csdn.net/hhy_csdn/article/details/89105908\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>。</p><p><b>策略函数（Policy Function）：</b>策略函数是一个输入为s输出为a的函数表示为 <img src=\"https://www.zhihu.com/equation?tex=%7B%5Cpi%28s%29%7D\" alt=\"{\\pi(s)}\" eeimg=\"1\"/> ，其中s表示状态，a表示动作，策略函数的含义就是在状态s下应该选择的动作a。强化学习的核心问题就是最优化策略函数从而最大化后面介绍的价值函数。</p><p><b>状态价值函数（State Value Function）：</b>前面说过强化学习的核心问题是最优化策略函数，那么如何评价策略函数是最优的呢？状态价值函数是评价策略函数 <img src=\"https://www.zhihu.com/equation?tex=%7B%5Cpi%28s%29%7D\" alt=\"{\\pi(s)}\" eeimg=\"1\"/> 优劣的标准之一，在每个状态s下（ <img src=\"https://www.zhihu.com/equation?tex=s%5Cin%7BS%7D\" alt=\"s\\in{S}\" eeimg=\"1\"/> , <img src=\"https://www.zhihu.com/equation?tex=S\" alt=\"S\" eeimg=\"1\"/> 为所有状态的集合），可以有多个动作a选择( <img src=\"https://www.zhihu.com/equation?tex=a%5Cin%7BA%7D\" alt=\"a\\in{A}\" eeimg=\"1\"/> , <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 为所有动作的集合)，每执行一次动作，系统就会转移到另一个状态（状态有时有多个可能，每种状态都有一个概率转移到就是下文的 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bs%27%7D%7BP_%7Bss%27%7D%5Ea%7D\" alt=\"\\sum_{s&#39;}{P_{ss&#39;}^a}\" eeimg=\"1\"/> ），如何保证所有的动作能使系统全局最优则要定义价值函数，系统的状态价值函数的含义是从当前状态开始到最终状态时系统所获得的累加回报的期望，下一状态的选取依据策略函数（不同的动作a将导致系统转移到不同的状态）。所以系统的状态价值函数和两个因素有关，一个是当前的状态s，另一个是策略 <img src=\"https://www.zhihu.com/equation?tex=%7B%5Cpi%28s%29%7D\" alt=\"{\\pi(s)}\" eeimg=\"1\"/> 。从不同的状态出发，得到的值可能不一样，从同一状态出发使用不同的策略，最后的值也可能不一样。所以建立的状态价值函数一定是建立在不同的策略和起始状态条件下的。状态价值函数的具体形式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+V%5E%7B%5Cpi%7D%28s%29%3DE_%7B%5Cpi%7D%5Cleft%5BR_%7Bt%7D+%7C+s_%7Bt%7D%3Ds%5Cright%5D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} V^{\\pi}(s)=E_{\\pi}\\left[R_{t} | s_{t}=s\\right] \\end{equation}\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=%7BR_%7Bt%7D%3D%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D%7B%5Cgamma%5E%7Bk%7Dr_%7Bt%2Bk%2B1%7D%7D%7D\" alt=\"{R_{t}=\\sum_{k=0}^{\\infty}{\\gamma^{k}r_{t+k+1}}}\" eeimg=\"1\"/> ，其中 <img src=\"https://www.zhihu.com/equation?tex=%7Br_%7Bt%2B1%7D%7D\" alt=\"{r_{t+1}}\" eeimg=\"1\"/> 表示从 <img src=\"https://www.zhihu.com/equation?tex=%7Bs_%7Bt%7D%7D\" alt=\"{s_{t}}\" eeimg=\"1\"/> 转移到 <img src=\"https://www.zhihu.com/equation?tex=%7Bs_%7Bt%2B1%7D%7D\" alt=\"{s_{t+1}}\" eeimg=\"1\"/> 时获得的回报， <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> 是折损因子，取值为 <img src=\"https://www.zhihu.com/equation?tex=0%5Csim1\" alt=\"0\\sim1\" eeimg=\"1\"/> 。可以将上面的状态价值函数的形式表示为递归的形式：</p><p><img src=\"https://www.zhihu.com/equation?tex=%E2%80%8B%5Cbegin%7Bequation%7D+%5Cbegin%7Barray%7D%7Bl%7D%7BV%5E%7B%5Cpi%7D%28s%29%3DE_%7B%5Cpi%7D%5Cleft%5BR_%7Bt%7D+%7C+s_%7Bt%7D%3Ds%5Cright%5D%7D%5C%5C%7B%3DE_%7B%5Cpi%7D%5Cleft%5C%7B%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D+%5Cgamma%5E%7Bk%7D+r_%7Bt%2Bk%2B1%7D+%7C+s_%7Bt%7D%3Ds%5Cright%5C%7D%7D+%5C%5C+%7B%3DE_%7B%5Cpi%7D%5Cleft%5C%7Br_%7Bt%2B1%7D%2B%5Cgamma+%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D+%5Cgamma%5E%7Bk%7D+r_%7Bt%2Bk%2B2%7D+%7C+s_%7Bt%7D%3Ds%5Cright%5C%7D%7D+%5C%5C+%7B%3D%5Csum_%7Ba%7D+%5Cpi%28s%2C+a%29+%5Csum_%7Bs%5E%7B%5Cprime%7D%7D+P_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%5Cleft%5BR_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%2B%5Cgamma+E_%7B%5Cpi%7D%5Cleft%5C%7B%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D%7B%5Cgamma%5E%7Bk%7Dr_%7Bt%2Bk%2B2%7D%7Cs_%7Bt%2B1%7D%3Ds%5E%7B%5Cprime%7D%7D%5Cright%29%5Cright%5D%7D+%5C%5C+%7B%3D%5Csum_%7Ba%7D+%5Cpi%28s%2C+a%29+%5Csum_%7Bs%5E%7B%5Cprime%7D%7D+P_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%5Cleft%5BR_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%2B%5Cgamma+V%5E%7B%5Cpi%7D%5Cleft%28s%5E%7B%5Cprime%7D%5Cright%29%5Cright%5D%7D%5Cend%7Barray%7D+%5Cend%7Bequation%7D\" alt=\"​\\begin{equation} \\begin{array}{l}{V^{\\pi}(s)=E_{\\pi}\\left[R_{t} | s_{t}=s\\right]}\\\\{=E_{\\pi}\\left\\{\\sum_{k=0}^{\\infty} \\gamma^{k} r_{t+k+1} | s_{t}=s\\right\\}} \\\\ {=E_{\\pi}\\left\\{r_{t+1}+\\gamma \\sum_{k=0}^{\\infty} \\gamma^{k} r_{t+k+2} | s_{t}=s\\right\\}} \\\\ {=\\sum_{a} \\pi(s, a) \\sum_{s^{\\prime}} P_{s s^{\\prime}}^{a}\\left[R_{s s^{\\prime}}^{a}+\\gamma E_{\\pi}\\left\\{\\sum_{k=0}^{\\infty}{\\gamma^{k}r_{t+k+2}|s_{t+1}=s^{\\prime}}\\right)\\right]} \\\\ {=\\sum_{a} \\pi(s, a) \\sum_{s^{\\prime}} P_{s s^{\\prime}}^{a}\\left[R_{s s^{\\prime}}^{a}+\\gamma V^{\\pi}\\left(s^{\\prime}\\right)\\right]}\\end{array} \\end{equation}\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=%7BP_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%7D\" alt=\"{P_{s s^{\\prime}}^{a}}\" eeimg=\"1\"/> 表示在选择动作a时，状态由s转移到 <img src=\"https://www.zhihu.com/equation?tex=%7Bs%5E%7B%5Cprime%7D%7D\" alt=\"{s^{\\prime}}\" eeimg=\"1\"/> 的概率，这里要注意，选定了动作之后不代表后面的状态就确定了，根据概率可能有好几种状态可以转移到，如后面的赌徒问题。但是也存在动作确定后，后面只有一种转移可能，这个时候 <img src=\"https://www.zhihu.com/equation?tex=%7BP_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%3D1%7D\" alt=\"{P_{s s^{\\prime}}^{a}=1}\" eeimg=\"1\"/> 。下面用赌徒问题和方格世界的例子来说明这个概念。</p><p>例1：赌徒问题<sup data-text=\"赌徒问题实验报告\" data-url=\"https://wenku.baidu.com/view/d0253055312b3169a451a4f8.html\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup></p><p>一个赌徒利用硬币投掷的反正面结果来赌博。假如投掷结果是硬币的正面朝上，那么他就赢得他所压的赌注，如果是反面朝上，那么他输掉他的赌注。当这个赌徒赢满100美元或者他输掉他所有的钱时，赌博结束。每一轮投掷，赌徒必须取出他资金的一部分作为赌注，赌注金额必须是整数。这个问题可以表述为一个无折扣的、情节式的有穷马尔可夫决策过程。状态就是赌徒所拥有的资金， <img src=\"https://www.zhihu.com/equation?tex=%7Bs%5Cin%5B%7B1%2C2%2C%5Ccdots%2C99%7D%5D%7D\" alt=\"{s\\in[{1,2,\\cdots,99}]}\" eeimg=\"1\"/> ，动作就是下赌注， <img src=\"https://www.zhihu.com/equation?tex=%7Ba%5Cin%5B%7B1%2C2%2C%5Ccdots%2C%5Cmin%7B%28s%2C100-s%29%7D%7D%5D%7D\" alt=\"{a\\in[{1,2,\\cdots,\\min{(s,100-s)}}]}\" eeimg=\"1\"/> 。</p><p>这里的每个动作a就对应2各状态，如当前状态 <img src=\"https://www.zhihu.com/equation?tex=%7Bs%3D50%7D\" alt=\"{s=50}\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%7Ba%3D20%7D\" alt=\"{a=20}\" eeimg=\"1\"/> ,设赌徒每局输赢的概率都为0.5，则下一状态为 <img src=\"https://www.zhihu.com/equation?tex=%7Bs%3D70%7D\" alt=\"{s=70}\" eeimg=\"1\"/> 的概率为0.5，下一状态为 <img src=\"https://www.zhihu.com/equation?tex=%7Bs%3D30%7D\" alt=\"{s=30}\" eeimg=\"1\"/> 的概率也为0.5。</p><p>例2：方格世界</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cbed7fcaca820b3c44fb953c58d18fdf_b.jpg\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"247\" class=\"content_image\" width=\"242\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;242&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"247\" class=\"content_image lazy\" width=\"242\" data-actualsrc=\"https://pic4.zhimg.com/v2-cbed7fcaca820b3c44fb953c58d18fdf_b.jpg\"/><figcaption>图 1.方格世界图</figcaption></figure><p>如图有个 <img src=\"https://www.zhihu.com/equation?tex=%7B4%5Ctimes%7B4%7D%7D\" alt=\"{4\\times{4}}\" eeimg=\"1\"/> 的方格，每个方格都对应一个状态，共有16个状态，每个状态下对应4个动作\t</p><p>A={上，下，左，右 }，当当前状态确定，动作确定之后对应的下一个状态也就确定了。</p><p><b>状态动作价值函数（State-action Value Function）：</b>动作价值函数也称为Q函数，相比于Value Function是对状态的评估，Q Function是对（状态-动作对）的评估，Q值的定义是，给定一个状态 <img src=\"https://www.zhihu.com/equation?tex=%7Bs_%7Bt%7D%7D\" alt=\"{s_{t}}\" eeimg=\"1\"/> ，采取动作 <img src=\"https://www.zhihu.com/equation?tex=%7Ba_%7Bt%7D%7D\" alt=\"{a_{t}}\" eeimg=\"1\"/> 后，按照某一策略 <img src=\"https://www.zhihu.com/equation?tex=%7B%5Cpi_%7Bs%7D%7D\" alt=\"{\\pi_{s}}\" eeimg=\"1\"/> 与环境继续进行交互，得到的累计汇报的期望值。其数学表达形式是：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+Q%5E%7B%5Cpi%7D%28s%2C+a%29%3DE_%7B%5Cpi%7D%5Cleft%5BR_%7Bt%7D+%7C+s_%7Bt%7D%3Ds%2C+a_%7Bt%7D%3Da%5Cright%5D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} Q^{\\pi}(s, a)=E_{\\pi}\\left[R_{t} | s_{t}=s, a_{t}=a\\right] \\end{equation}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+Q%5E%7B%5Cpi%7D%28s%2C+a%29%3DE_%7B%5Cpi%7D%5Cleft%5C%7BR_%7Bt%7D+%7C+s_%7Bt%7D%3Ds%2C+a_%7Bt%7D%3Da%5Cright%5C%7D%3DE_%7B%5Cpi%7D%5Cleft%5C%7B%5Csum_%7Bk%3D0%7D%5E%7B%5Cinfty%7D+%5Cgamma%5E%7Bk%7D+r_%7Bt%2Bk%2B1%7D+%7C+s_%7Bt%7D%3Ds%2C+a_%7Bt%7D%3Da%5Cright%5C%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} Q^{\\pi}(s, a)=E_{\\pi}\\left\\{R_{t} | s_{t}=s, a_{t}=a\\right\\}=E_{\\pi}\\left\\{\\sum_{k=0}^{\\infty} \\gamma^{k} r_{t+k+1} | s_{t}=s, a_{t}=a\\right\\} \\end{equation}\" eeimg=\"1\"/> </p><p>对于状态价值函数和动作价值函数的区别，可以简单的认为，状态函数中，当前状态下选取哪个动作是未知数，需要求出一系列的动作集合（各不同状态下），形成一个完整的策略，然后使状态方程的值最大化，而动作价值函数是当前状态下的动作已知，求余下状态下的动作集合使动作方程的值最大化，具体数学形式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+%5Cbegin%7Baligned%7D+V%5E%7B%2A%7D%28s%29+%26%3D%5Cmax+_%7Ba%7D+E%5Cleft%5C%7Br_%7Bt%2B1%7D%2B%5Cgamma+V%5E%7B%2A%7D%5Cleft%28s_%7Bt%2B1%7D%5Cright%29+%7C+s_%7Bt%7D%3Ds%2C+a_%7Bt%7D%3Da%5Cright%5C%7D+%5C%5C+%26%3D%5Cmax+_%7Ba%7D+%5Csum_%7Bs%5E%7B%5Cprime%7D%7D+P_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%5Cleft%5BR_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%2B%5Cgamma+V%5E%7B%2A%7D%5Cleft%28s%5E%7B%5Cprime%7D%5Cright%29%5Cright%5D+%5Cend%7Baligned%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} \\begin{aligned} V^{*}(s) &amp;=\\max _{a} E\\left\\{r_{t+1}+\\gamma V^{*}\\left(s_{t+1}\\right) | s_{t}=s, a_{t}=a\\right\\} \\\\ &amp;=\\max _{a} \\sum_{s^{\\prime}} P_{s s^{\\prime}}^{a}\\left[R_{s s^{\\prime}}^{a}+\\gamma V^{*}\\left(s^{\\prime}\\right)\\right] \\end{aligned} \\end{equation}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+%5Cbegin%7Baligned%7D+Q%5E%7B%2A%7D%28s%2C+a%29+%26%3DE%5Cleft%5C%7Br_%7Bt%2B1%7D%2B%5Cgamma+%5Cmax+_%7Ba%5E%7B%5Cprime%7D%7D+Q%5E%7B%2A%7D%5Cleft%28s_%7Bt%2B1%7D%2C+a%5E%7B%5Cprime%7D%5Cright%29+%7C+s_%7Bt%7D%3Ds%2C+a_%7Bt%7D%3Da%5Cright%5C%7D+%5C%5C+%26%3D%5Csum_%7Bs%5E%7B%5Cprime%7D%7D+P_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%5Cleft%5BR_%7Bs+s%5E%7B%5Cprime%7D%7D%5E%7Ba%7D%2B%5Cgamma+%5Cmax+_%7Ba%5E%7B%5Cprime%7D%7D+Q%5E%7B%2A%7D%5Cleft%28s%5E%7B%5Cprime%7D%2C+a%5E%7B%5Cprime%7D%5Cright%29%5Cright%5D+%5Cend%7Baligned%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} \\begin{aligned} Q^{*}(s, a) &amp;=E\\left\\{r_{t+1}+\\gamma \\max _{a^{\\prime}} Q^{*}\\left(s_{t+1}, a^{\\prime}\\right) | s_{t}=s, a_{t}=a\\right\\} \\\\ &amp;=\\sum_{s^{\\prime}} P_{s s^{\\prime}}^{a}\\left[R_{s s^{\\prime}}^{a}+\\gamma \\max _{a^{\\prime}} Q^{*}\\left(s^{\\prime}, a^{\\prime}\\right)\\right] \\end{aligned} \\end{equation}\" eeimg=\"1\"/> </p><p><b>动作和状态价值函数的关系</b></p><p>前面我们简单的将状态价值函数和状态-动作价值函数的关系描述为状态价值函数在当前状态的动作是不确定的，  所以它必须考虑到所用动作的情况然后取其期望，而状态-动作价值函数只是考虑特定的动作下的价值。最大化状态价值函数就是求当前状态的最大期望值，而最大化状态-动作价值函数就是求当前状态下一动作能带来的最大回报值，用数学的形式表示如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+V%5E%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%7D%2AQ%5E%7B%5Cpi%7D%28s%2Ca%29+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} V^{\\pi}(s)=\\sum_{a\\in{A}}{\\pi(a|s)}*Q^{\\pi}(s,a) \\end{equation}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+Q%5E%7B%5Cpi%7D%28s%2Ca%29%3DR_%7Bs%7D%5E%7Ba%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} Q^{\\pi}(s,a)=R_{s}^{a}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} \\end{equation}\" eeimg=\"1\"/> </p><p>将公式(1-2)进一步化简可得：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+V%5E%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%2AR_%7Bs%7D%5E%7Ba%7D%7D%2B%5Cgamma%2A%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%7D%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} V^{\\pi}(s)=\\sum_{a\\in{A}}{\\pi(a|s)*R_{s}^{a}}+\\gamma*\\sum_{a\\in{A}}{\\pi(a|s)}\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} \\end{equation}\" eeimg=\"1\"/> </p><p>从上式可以看出状态方程比动作方程考虑了所有动作的情况。</p><p><b>注意：</b></p><p>这里需要注意几个表示价值的符号的意义， <img src=\"https://www.zhihu.com/equation?tex=R_%7Bs%7D%5Ea%E3%80%81R_%7Bss%27%7D%5Ea%E3%80%81R_s%5E%5Cpi\" alt=\"R_{s}^a、R_{ss&#39;}^a、R_s^\\pi\" eeimg=\"1\"/> 。</p><p><img src=\"https://www.zhihu.com/equation?tex=R_%7Bss%27%7D%5Ea%EF%BC%9AR_%7Bss%27%7D%5Ea\" alt=\"R_{ss&#39;}^a：R_{ss&#39;}^a\" eeimg=\"1\"/> 表示的是在状态s下，执行动作a的情况下状态转移到s&#39;时得到的即时奖励。</p><p><img src=\"https://www.zhihu.com/equation?tex=R_%7Bs%7D%5Ea%EF%BC%9AR_%7Bs%7D%5Ea%3D%5Csum_%7Bs%27%7D%7BP_%7Bss%27%7D%5Ea%2AR_%7Bss%27%7D%5Ea%7D\" alt=\"R_{s}^a：R_{s}^a=\\sum_{s&#39;}{P_{ss&#39;}^a*R_{ss&#39;}^a}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=R_%7Bs%7D%5E%5Cpi%EF%BC%9AR_%7Bs%7D%5E%5Cpi%3D%5Csum_%7Ba%7D%7B%5Cpi%28a%7Cs%29%2AR_%7Bs%7D%5Ea%7D\" alt=\"R_{s}^\\pi：R_{s}^\\pi=\\sum_{a}{\\pi(a|s)*R_{s}^a}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面举个例子说明状态价值函数和状态动作价值函数的含义<sup data-text=\"马尔可夫决策过程\" data-url=\"https://zhuanlan.zhihu.com/p/28084942\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-de833d258a5718166bda3591d311ca51_b.jpg\" data-size=\"normal\" data-rawwidth=\"296\" data-rawheight=\"247\" class=\"content_image\" width=\"296\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;296&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"296\" data-rawheight=\"247\" class=\"content_image lazy\" width=\"296\" data-actualsrc=\"https://pic2.zhimg.com/v2-de833d258a5718166bda3591d311ca51_b.jpg\"/><figcaption>图 2.状态价值计算图</figcaption></figure><p>如图2所示，是计算各状态价值的过程，其中设每一个状态下执行某个动作的概率都为0.5，即 <img src=\"https://www.zhihu.com/equation?tex=%5Cpi%28a%7Cs%29%3D0.5\" alt=\"\\pi(a|s)=0.5\" eeimg=\"1\"/> ，折损因子 <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma%3D1\" alt=\"\\gamma=1\" eeimg=\"1\"/> ,根据公式 <img src=\"https://www.zhihu.com/equation?tex=+V%5E%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%2A%5BR_%7Bs%7D%5E%7Ba%7D%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5D\" alt=\" V^{\\pi}(s)=\\sum_{a\\in{A}}{\\pi(a|s)*[R_{s}^{a}}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} ]\" eeimg=\"1\"/> </p><p>进行迭代求解，这里箭头从一个圆直接连接到另一个圆表示执行某动作之后，其能到达的状态只有一种， <img src=\"https://www.zhihu.com/equation?tex=%7BP_%7Bss%27%7D%5Ea%7D%3D1\" alt=\"{P_{ss&#39;}^a}=1\" eeimg=\"1\"/> ，而箭头连接点的分出去三个箭头，表示执行该动作，将有可能到达三种状态，且概率分别为0.2，0.4，0.4。图中， <img src=\"https://www.zhihu.com/equation?tex=R\" alt=\"R\" eeimg=\"1\"/> 表示的是 <img src=\"https://www.zhihu.com/equation?tex=R_%7Bs%7D%5Ea\" alt=\"R_{s}^a\" eeimg=\"1\"/> ，以图中7.4值计算为例：</p><p><img src=\"https://www.zhihu.com/equation?tex=7.4%5Capprox0.5%5Ctimes%2810%2B0%29%2B0.5%5Ctimes%281%2B0.4%5Ctimes2.7%2B0.4%5Ctimes7.4%2B0.2%5Ctimes-1.3%29\" alt=\"7.4\\approx0.5\\times(10+0)+0.5\\times(1+0.4\\times2.7+0.4\\times7.4+0.2\\times-1.3)\" eeimg=\"1\"/> </p><p>对应的状态-动作价值是指在某个状态选取某个特定动作时所获得的价值，如在上述取7.4的状态下，取动作为 <img src=\"https://www.zhihu.com/equation?tex=R%3D10\" alt=\"R=10\" eeimg=\"1\"/> 的动作，此时a确定， <img src=\"https://www.zhihu.com/equation?tex=%5Cpi%28a%7Cs%29%3D1\" alt=\"\\pi(a|s)=1\" eeimg=\"1\"/> ，根据公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+Q%5E%7B%5Cpi%7D%28s%2Ca%29%3DR_%7Bs%7D%5E%7Ba%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} Q^{\\pi}(s,a)=R_{s}^{a}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} \\end{equation}\" eeimg=\"1\"/> </p><p>求得， <img src=\"https://www.zhihu.com/equation?tex=q%3D10%2B0%3D10\" alt=\"q=10+0=10\" eeimg=\"1\"/> 。</p><p>当要求最大状态价值函数和最大状态价值函数时，就是取获得最大价值的动作进行选取，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d0a513a22ffeb3f120154939cb83800e_b.jpg\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"260\" class=\"content_image\" width=\"325\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;325&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"260\" class=\"content_image lazy\" width=\"325\" data-actualsrc=\"https://pic3.zhimg.com/v2-d0a513a22ffeb3f120154939cb83800e_b.jpg\"/><figcaption>图 3.最优状态价值函数</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-958c0faf1c1cbf4369e03f82b74c494b_b.jpg\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"277\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"277\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic4.zhimg.com/v2-958c0faf1c1cbf4369e03f82b74c494b_b.jpg\"/><figcaption>图 4.最优状态-动作价值函数</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "强化学习 (Reinforcement Learning)", 
                    "tagLink": "https://api.zhihu.com/topics/20039099"
                }
            ], 
            "comments": [
                {
                    "userName": "倩雅", 
                    "userLink": "https://www.zhihu.com/people/4cb760142d2367151cb250e9e6510269", 
                    "content": "<p>你好，我有一个疑问，就是在推导过程中，状态s不是变量，st 是t阶段的状态相当于是一个常数，那么为什么st=s，常数在等号的左边，变量在等号的右边？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86544992", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 1, 
            "title": "强化学习--基于模型的动态规划算法", 
            "content": "<p>（注意：本文是一篇学习笔记，文中图片来源于参考中的各博客）</p><p>上一篇中，我们介绍了贝尔曼方程的相关知识，主要是两个价值函数：状态价值函数和状态-动作价值函数，其公式主要的求解公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=+V%5E%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%2A%5BR_%7Bs%7D%5E%7Ba%7D%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5D\" alt=\" V^{\\pi}(s)=\\sum_{a\\in{A}}{\\pi(a|s)*[R_{s}^{a}}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} ]\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+Q%5E%7B%5Cpi%7D%28s%2Ca%29%3DR_%7Bs%7D%5E%7Ba%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5Cend%7Bequation%7D\" alt=\"\\begin{equation} Q^{\\pi}(s,a)=R_{s}^{a}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} \\end{equation}\" eeimg=\"1\"/> </p><p>从上式我们可以看出要求解出价值函数必须要知道五个元素，状态集 <img src=\"https://www.zhihu.com/equation?tex=S\" alt=\"S\" eeimg=\"1\"/> ，动作集 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> ，转移概率 <img src=\"https://www.zhihu.com/equation?tex=P\" alt=\"P\" eeimg=\"1\"/> ，折损因子 <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> ，以及即时奖励 <img src=\"https://www.zhihu.com/equation?tex=R\" alt=\"R\" eeimg=\"1\"/> ，由此可以用五元组表示 <img src=\"https://www.zhihu.com/equation?tex=%3CS%2CA%2CP%2CR%2C%5Cgamma%3E\" alt=\"&lt;S,A,P,R,\\gamma&gt;\" eeimg=\"1\"/> ，当五元组中的五元素全部已知时，此时称模型已知，可以利用动态规划算法的思想对强化学习模型进行求解，当五元组中转移概率 <img src=\"https://www.zhihu.com/equation?tex=P\" alt=\"P\" eeimg=\"1\"/> 即时奖励 <img src=\"https://www.zhihu.com/equation?tex=R\" alt=\"R\" eeimg=\"1\"/> 以及折损因子 <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> 中有未知数时，我们称模型未知，常见的求解无模型强化学习的算法分为蒙特卡洛算法和时间差分算法等，无模型强化学习算法将在下篇介绍，这里主要介绍模型已知的情况。</p><p>当强化学习的模型已知时，通常使用动态规划算法来求解，动态规划算法下又分为策略迭代算法和值迭代算法，如下图所示<sup data-text=\"蒙特卡洛方法\" data-url=\"https://zhuanlan.zhihu.com/p/25743759\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4b0c35cb9ff49c9952692832d84934d_b.jpg\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"456\" data-original=\"https://pic2.zhimg.com/v2-b4b0c35cb9ff49c9952692832d84934d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;456&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"456\" data-original=\"https://pic2.zhimg.com/v2-b4b0c35cb9ff49c9952692832d84934d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4b0c35cb9ff49c9952692832d84934d_b.jpg\"/><figcaption>图 1.算法分类</figcaption></figure><p><b>策略迭代</b></p><p>策略迭代分为两部分，一是策略评估，二是策略改进，策略评估是通过迭代的方法求出所有状态的状态价值函数，策略改进是通过前面求出的状态价值函数利用贪心算法的思想求出一条较优策略（因为贪心算法求出的解往往不是最优的，所有称之为较优）。其伪代码如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3765b11021573961998bfdfe2272d5de_b.jpg\" data-size=\"normal\" data-rawwidth=\"250\" data-rawheight=\"189\" class=\"content_image\" width=\"250\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;250&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"250\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"250\" data-actualsrc=\"https://pic3.zhimg.com/v2-3765b11021573961998bfdfe2272d5de_b.jpg\"/><figcaption>图 2.策略评估算法</figcaption></figure><p>首先介绍如何进行策略评估，策略评估用到的主要公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=+V%5E%7B%5Cpi%7D%28s%29%3D%5Csum_%7Ba%5Cin%7BA%7D%7D%7B%5Cpi%28a%7Cs%29%2A%5BR_%7Bs%7D%5E%7Ba%7D%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%29%7D+%5D\" alt=\" V^{\\pi}(s)=\\sum_{a\\in{A}}{\\pi(a|s)*[R_{s}^{a}}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s)} ]\" eeimg=\"1\"/> </p><p>上一篇已经介绍了这个迭代公式的含义以及推导的过程，这里直接使用这个迭代公式，迭代求出所有状态的值，这里还是以 <img src=\"https://www.zhihu.com/equation?tex=4%5Ctimes4\" alt=\"4\\times4\" eeimg=\"1\"/> 的方格世界为例进行讲解<sup data-text=\"方格世界实践\" data-url=\"https://zhuanlan.zhihu.com/p/28084990\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup>，并给出相应的matlab代码。</p><p>例1：如下图所示方格世界，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cbed7fcaca820b3c44fb953c58d18fdf_b.jpg\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"247\" class=\"content_image\" width=\"242\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;242&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"247\" class=\"content_image lazy\" width=\"242\" data-actualsrc=\"https://pic4.zhimg.com/v2-cbed7fcaca820b3c44fb953c58d18fdf_b.jpg\"/><figcaption>图 3.方格世界图</figcaption></figure><p>状态 <img src=\"https://www.zhihu.com/equation?tex=S\" alt=\"S\" eeimg=\"1\"/> ： <img src=\"https://www.zhihu.com/equation?tex=S_0%2CS_%7B15%7D\" alt=\"S_0,S_{15}\" eeimg=\"1\"/> 终止状态，到达之后，终止动作， <img src=\"https://www.zhihu.com/equation?tex=S_1-S_%7B14%7D\" alt=\"S_1-S_{14}\" eeimg=\"1\"/> 为非终止状态。</p><p>动作 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> ：对非终止状态， 有四个行为，分别为A={东，南，西，北}。</p><p>状态转移概率 <img src=\"https://www.zhihu.com/equation?tex=P\" alt=\"P\" eeimg=\"1\"/> ：对非终止状态，内部非终止状态 <img src=\"https://www.zhihu.com/equation?tex=S_5%2CS_6%2CS_9%2CS_%7B10%7D\" alt=\"S_5,S_6,S_9,S_{10}\" eeimg=\"1\"/> 由于动作确定之后，下一个状态就已经确定，所以状态转移概率为1。但是边缘区，由于不能跳出方格，所以在要跳出方格的情况下，其状态不变。</p><p>即时奖励 R：任何在非终止状态间的转移得到的即时奖励均为-1，进入终止状态即时奖励为0。<br/>衰减系数 γ：1。</p><p>首先初始化所有状态，及状态的初始值为0：</p><div class=\"highlight\"><pre><code class=\"language-matlab\">  <span class=\"n\">S</span><span class=\"p\">=</span><span class=\"n\">int8</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">16</span><span class=\"p\">);</span>\n   <span class=\"c\">%初始化价值函数值</span>\n  <span class=\"n\">V</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">);</span></code></pre></div><p>声明动作空间及动作空间对状态的影响</p><div class=\"highlight\"><pre><code class=\"language-matlab\">   <span class=\"c\">%声明动作空间</span>\n   <span class=\"n\">A</span><span class=\"p\">=[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">];</span>\n   <span class=\"c\">%1--北(上)，2-东（右），3-南（下），4-西（左）</span>\n   <span class=\"c\">%声明动作对状态的影响</span>\n   <span class=\"n\">effect_A</span><span class=\"p\">=[</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">];</span></code></pre></div><p>根据当前状态及动作确定下一个状态</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>next_station<span class=\"p\">=</span><span class=\"nf\">nextStation</span><span class=\"p\">(</span>s,a,effect_A<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">&lt;</span><span class=\"p\">=</span><span class=\"mi\">4</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">a</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"nb\">mod</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">a</span><span class=\"o\">==</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">&gt;</span><span class=\"p\">=</span><span class=\"mi\">13</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">a</span><span class=\"o\">==</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"nb\">mod</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">a</span><span class=\"o\">==</span><span class=\"mi\">4</span><span class=\"p\">)</span>\n      <span class=\"n\">next_station</span><span class=\"p\">=</span><span class=\"n\">s</span><span class=\"p\">;</span>\n  <span class=\"k\">else</span>\n      <span class=\"n\">next_station</span><span class=\"p\">=</span><span class=\"n\">s</span><span class=\"o\">+</span><span class=\"n\">effect_A</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>确定某个状态的价值</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>R<span class=\"p\">=</span><span class=\"nf\">reward</span><span class=\"p\">(</span>s<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"k\">if</span> <span class=\"n\">ismember</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">])</span>\n      <span class=\"n\">R</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"k\">else</span>\n      <span class=\"n\">R</span><span class=\"p\">=</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>确定当前状态所有的下一个状态</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>next_states<span class=\"p\">=</span><span class=\"nf\">all_nextstate</span><span class=\"p\">(</span>s,A,effect_A<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"n\">next_states</span><span class=\"p\">=[];</span>\n  <span class=\"k\">if</span> <span class=\"n\">ismember</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">])</span>\n      <span class=\"n\">next_states</span><span class=\"p\">=[];</span>\n  <span class=\"k\">else</span>\n      <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n          <span class=\"n\">next_station</span><span class=\"p\">=</span><span class=\"n\">nextStation</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">),</span><span class=\"n\">effect_A</span><span class=\"p\">);</span>\n          <span class=\"n\">next_states</span><span class=\"p\">=[</span><span class=\"n\">next_states</span> <span class=\"n\">next_station</span><span class=\"p\">];</span>        \n      <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>更新状态价值函数的代码</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>newValue<span class=\"p\">=</span><span class=\"nf\">updateValue</span><span class=\"p\">(</span>s,A,effect_A,gamma,V<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">      </span><span class=\"n\">next_states</span><span class=\"p\">=</span><span class=\"n\">all_nextstate</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">effect_A</span><span class=\"p\">);</span>\n      <span class=\"n\">newValue</span> <span class=\"p\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"n\">num</span> <span class=\"p\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n      <span class=\"n\">R</span><span class=\"p\">=</span><span class=\"n\">reward</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n      <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">next_states</span><span class=\"p\">)</span>\n            <span class=\"n\">newValue</span> <span class=\"p\">=</span> <span class=\"n\">newValue</span><span class=\"o\">+</span> <span class=\"mf\">1.00</span><span class=\"o\">/</span><span class=\"n\">num</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nb\">gamma</span> <span class=\"o\">*</span> <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">next_states</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)));</span>\n      <span class=\"k\">end</span>\n  <span class=\"k\">end</span></code></pre></div><p>主函数如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>V<span class=\"p\">=</span><span class=\"nf\">Grid_World</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">   </span><span class=\"n\">S</span><span class=\"p\">=</span><span class=\"n\">int8</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">16</span><span class=\"p\">);</span>\n   <span class=\"c\">%初始化价值函数值</span>\n   <span class=\"n\">V</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">);</span>\n   <span class=\"c\">%声明动作空间</span>\n   <span class=\"n\">A</span><span class=\"p\">=[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">];</span>\n   <span class=\"c\">%1--北(上)，2-东（右），3-南（下），4-西（左）</span>\n   <span class=\"c\">%声明动作对状态的影响</span>\n   <span class=\"n\">effect_A</span><span class=\"p\">=[</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n   <span class=\"c\">%声明折损因子</span>\n   <span class=\"nb\">gamma</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n   <span class=\"c\">%确定状态下的所以下一个状态</span>\n   <span class=\"n\">iter_num</span><span class=\"p\">=</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n   <span class=\"n\">V_new</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">);</span>\n   <span class=\"n\">iter</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n   <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"o\">&lt;</span><span class=\"n\">iter_num</span><span class=\"p\">)</span>\n       <span class=\"n\">iter</span><span class=\"p\">=</span><span class=\"n\">iter</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n       <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">V</span><span class=\"p\">)</span>\n           <span class=\"n\">V_new</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">updateValue</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">),</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">effect_A</span><span class=\"p\">,</span><span class=\"nb\">gamma</span><span class=\"p\">,</span><span class=\"n\">V</span><span class=\"p\">);</span>\n       <span class=\"k\">end</span>\n       <span class=\"n\">V</span><span class=\"p\">=</span><span class=\"n\">V_new</span><span class=\"p\">;</span>\n   <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>至此，策略评估的部分就解决了。其结果如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-95fec0da09da5f51e00cb656cf74905b_b.jpg\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"376\" class=\"content_image\" width=\"371\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;371&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"376\" class=\"content_image lazy\" width=\"371\" data-actualsrc=\"https://pic4.zhimg.com/v2-95fec0da09da5f51e00cb656cf74905b_b.jpg\"/><figcaption>图 4.状态价值函数收敛值</figcaption></figure><p>现在我们需要通过策略改进来求解各非终止状态到终止状态的最优解。利用贪心策略，求出每一状态下的最优状态-动作价值函数，用到的公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=+V%5E%7B%5Cpi%7D%28s%29%3D%5Cmax%5Climits_%7Ba%7D%7B%7DR_%7Bs%7D%5E%7Ba%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%27%29%7D+\" alt=\" V^{\\pi}(s)=\\max\\limits_{a}{}R_{s}^{a}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s&#39;)} \" eeimg=\"1\"/> </p><p>求出的结果如下图所示</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4552122a46c74d57402f7f8707b3cbef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"206\" data-rawheight=\"170\" class=\"content_image\" width=\"206\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;206&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"206\" data-rawheight=\"170\" class=\"content_image lazy\" width=\"206\" data-actualsrc=\"https://pic4.zhimg.com/v2-4552122a46c74d57402f7f8707b3cbef_b.jpg\"/></figure><p>箭头所指为最大动作价值函数。</p><p><b>值迭代</b></p><p>策略迭代是先利用状态价值迭代函数求出所有状态的价值之后，再通过贪心算法进行策略改进求解出理想的解，而值迭代是将该状态下的所有可能的动作都求一遍，然后根据求得的动作价值选取最优的动作，用到的公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=+V%5E%7B%5Cpi%7D%28s%29%3D%5Cmax%5Climits_%7Ba%7D%7B%7DR_%7Bs%7D%5E%7Ba%7D%2B%5Cgamma%2A%5Csum_%7Bs%5E%7B%27%7D%7D%7BP_%7Bss%5E%7B%27%7D%7DV%5E%7B%5Cpi%7D%28s%27%29%7D+\" alt=\" V^{\\pi}(s)=\\max\\limits_{a}{}R_{s}^{a}+\\gamma*\\sum_{s^{&#39;}}{P_{ss^{&#39;}}V^{\\pi}(s&#39;)} \" eeimg=\"1\"/> </p><p>两种伪代码如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c56f8c0d7729632f849f4bfd6b9bf8f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1924\" data-rawheight=\"1114\" class=\"origin_image zh-lightbox-thumb\" width=\"1924\" data-original=\"https://pic2.zhimg.com/v2-c56f8c0d7729632f849f4bfd6b9bf8f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1924&#39; height=&#39;1114&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1924\" data-rawheight=\"1114\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1924\" data-original=\"https://pic2.zhimg.com/v2-c56f8c0d7729632f849f4bfd6b9bf8f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c56f8c0d7729632f849f4bfd6b9bf8f9_b.jpg\"/></figure><p>从图中可以看出值迭代的迭代前面部分和策略迭代中的策略评估相似，策略评估是采用期望的方式求值函数，而值迭代是变量每个状态下的所用动作，选取最大的作为值函数。</p><p>修改上面的更新状态价值函数的代码部分</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>newValue<span class=\"p\">=</span><span class=\"nf\">updateValue_v</span><span class=\"p\">(</span>s,A,effect_A,gamma,V<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">      </span><span class=\"n\">next_states</span><span class=\"p\">=</span><span class=\"n\">all_nextstate</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">effect_A</span><span class=\"p\">);</span>\n<span class=\"c\">%       newValue = -inf;</span>\n      <span class=\"n\">R</span><span class=\"p\">=</span><span class=\"n\">reward</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span> <span class=\"n\">ismember</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">16</span><span class=\"p\">])</span>\n          <span class=\"n\">newValue</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"k\">else</span>\n          <span class=\"n\">newValuetemp</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">next_states</span><span class=\"p\">));</span>\n          <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">next_states</span><span class=\"p\">)</span>\n              <span class=\"n\">newValuetemp</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span> <span class=\"p\">(</span><span class=\"n\">R</span> <span class=\"o\">+</span> <span class=\"nb\">gamma</span> <span class=\"o\">*</span> <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">next_states</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)));</span>\n              <span class=\"c\">%             if newValuetemp&gt;newValue</span>\n              <span class=\"c\">%                 newValue=newValuetemp;</span>\n              <span class=\"c\">%             end</span>\n          <span class=\"k\">end</span>\n          <span class=\"n\">newValue</span><span class=\"p\">=</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">newValuetemp</span><span class=\"p\">);</span>\n      <span class=\"k\">end</span>\n  <span class=\"k\">end</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "深度学习（Deep Learning）", 
                    "tagLink": "https://api.zhihu.com/topics/19813032"
                }, 
                {
                    "tag": "动态规划算法", 
                    "tagLink": "https://api.zhihu.com/topics/20304675"
                }, 
                {
                    "tag": "强化学习 (Reinforcement Learning)", 
                    "tagLink": "https://api.zhihu.com/topics/20039099"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82325262", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 2, 
            "title": "softmax实现手写字分类", 
            "content": "<h2>1.导入MNIST的数据</h2><p>在开始时我们需要导入MNIST的数据，MNIST的数据可以从官网上进行下载<b><a href=\"https://link.zhihu.com/?target=http%3A//yann.lecun.com/exdb/mnist/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MNIST数据集</a></b>，MNIST有四个数据集，分别如下：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//yann.lecun.com/exdb/mnist/train-images-idx3-ubyte.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">train-images-idx3-ubyte.gz</a>:  training set images (9912422 bytes)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//yann.lecun.com/exdb/mnist/train-labels-idx1-ubyte.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">train-labels-idx1-ubyte.gz</a>:  training set labels (28881 bytes)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//yann.lecun.com/exdb/mnist/t10k-images-idx3-ubyte.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">t10k-images-idx3-ubyte.gz</a>:   test set images (1648877 bytes)</p><p><a href=\"https://link.zhihu.com/?target=http%3A//yann.lecun.com/exdb/mnist/t10k-labels-idx1-ubyte.gz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">t10k-labels-idx1-ubyte.gz</a>:   test set labels (4542 bytes)</p><p>前两个数据集是训练集，分别是训练集的图片和标签，后两个数据集是测试集，分别是测试集的图片和标签。在第一个数据集中，数据是以2进制给出，其中前128位不包含图片信息，它是关于数据集的一些说明。在图片数据集中（包括数据集和训练集），前面有4个信息，都是由32位二进制数表示，第一个信息是magic number图片位2049，第二个信息是样本数，第三个是行数，第四个是列数。描述如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b7bb4d4d79ee13fdd20d1256760bda61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"863\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb\" width=\"863\" data-original=\"https://pic2.zhimg.com/v2-b7bb4d4d79ee13fdd20d1256760bda61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;863&#39; height=&#39;246&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"863\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"863\" data-original=\"https://pic2.zhimg.com/v2-b7bb4d4d79ee13fdd20d1256760bda61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b7bb4d4d79ee13fdd20d1256760bda61_b.jpg\"/></figure><p>其中训练集样本为60000个，测试集样本为10000个。</p><p>标签数据集，包含两个头文件信息：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8cf35dd611607113afa1e7c3ce0e8f90_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-8cf35dd611607113afa1e7c3ce0e8f90_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;819&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-8cf35dd611607113afa1e7c3ce0e8f90_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8cf35dd611607113afa1e7c3ce0e8f90_b.jpg\"/></figure><p>第一个是magic number，第二个是样本个数。下面是matlab导入图片和标签的函数。</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>images1<span class=\"p\">=</span><span class=\"nf\">loadImage</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">filename</span><span class=\"p\">=</span>&#34;<span class=\"n\">train</span><span class=\"o\">-</span><span class=\"n\">images</span><span class=\"o\">-</span><span class=\"n\">idx3</span><span class=\"o\">-</span><span class=\"n\">ubyte</span>&#34;<span class=\"p\">;</span><span class=\"c\">%将下载的数据解解压后去掉后缀名得到。</span>\n    <span class=\"n\">fid</span><span class=\"p\">=</span><span class=\"n\">fopen</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">,</span>&#34;<span class=\"n\">rb</span>&#34;<span class=\"p\">);</span><span class=\"c\">%打开训练集的图片数据集</span>\n    <span class=\"n\">A</span><span class=\"p\">=</span><span class=\"n\">fread</span><span class=\"p\">(</span><span class=\"n\">fid</span><span class=\"p\">);</span><span class=\"c\">%读取训练集中的数据，读取后，数据按照每个字节（8位二进制）转化成了十进制数。</span>\n    <span class=\"n\">images1</span><span class=\"p\">=</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">17</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">));</span><span class=\"c\">%从17位开始是图片信息</span>\n    <span class=\"n\">num</span><span class=\"p\">=</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">:</span><span class=\"mi\">8</span><span class=\"p\">);</span><span class=\"c\">%第二个头文件，样本个数</span>\n    <span class=\"n\">row</span><span class=\"p\">=</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">:</span><span class=\"mi\">12</span><span class=\"p\">);</span><span class=\"c\">%第三个头文件，行数</span>\n    <span class=\"n\">col</span><span class=\"p\">=</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">13</span><span class=\"p\">:</span><span class=\"mi\">16</span><span class=\"p\">);</span><span class=\"c\">%第四个头文件，列数</span>\n<span class=\"c\">%下面的操作是将32位二进制数转化为十进制</span>\n    <span class=\"n\">num</span><span class=\"p\">=</span><span class=\"n\">dec2hex</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">);</span>\n    <span class=\"n\">row</span><span class=\"p\">=</span><span class=\"n\">dec2hex</span><span class=\"p\">(</span><span class=\"n\">row</span><span class=\"p\">);</span>\n    <span class=\"n\">col</span><span class=\"p\">=</span><span class=\"n\">dec2hex</span><span class=\"p\">(</span><span class=\"n\">col</span><span class=\"p\">);</span>\n    <span class=\"n\">num1</span><span class=\"p\">=[];</span>\n    <span class=\"n\">row1</span><span class=\"p\">=[];</span>\n    <span class=\"n\">col1</span><span class=\"p\">=[];</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">4</span>\n        <span class=\"n\">num1</span><span class=\"p\">=[</span><span class=\"n\">num1</span> <span class=\"n\">num</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n        <span class=\"n\">row1</span><span class=\"p\">=[</span><span class=\"n\">row1</span><span class=\"p\">,</span><span class=\"n\">row</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n        <span class=\"n\">col1</span><span class=\"p\">=[</span><span class=\"n\">col1</span> <span class=\"n\">col</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">num1</span><span class=\"p\">=</span><span class=\"n\">hex2dec</span><span class=\"p\">(</span><span class=\"n\">num1</span><span class=\"p\">);</span>\n    <span class=\"n\">col1</span><span class=\"p\">=</span><span class=\"n\">hex2dec</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">);</span>\n    <span class=\"n\">row1</span><span class=\"p\">=</span><span class=\"n\">hex2dec</span><span class=\"p\">(</span><span class=\"n\">row1</span><span class=\"p\">);</span>\n<span class=\"c\">%将图片数据转化为矩阵形式。</span>\n    <span class=\"n\">images1</span><span class=\"p\">=</span><span class=\"nb\">reshape</span><span class=\"p\">(</span><span class=\"n\">images1</span><span class=\"p\">,</span><span class=\"n\">row1</span><span class=\"p\">,</span><span class=\"n\">col1</span><span class=\"p\">,</span><span class=\"n\">num1</span><span class=\"p\">);</span>\n    <span class=\"n\">images1</span><span class=\"p\">=</span><span class=\"nb\">permute</span><span class=\"p\">(</span><span class=\"n\">images1</span><span class=\"p\">,[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">]);</span>\n    <span class=\"n\">fclose</span><span class=\"p\">(</span><span class=\"n\">fid</span><span class=\"p\">);</span>\n<span class=\"k\">end</span></code></pre></div><p>为了验证转化的是否正确可以利用imwrite函数将矩阵转化为图片看看是否是数字如取第十个矩阵</p><p>a=images1(:,:,50);</p><p>imwrite(uint8(a),&#39;test.tif&#39;)%输出文件名为test.tif。</p><p>%imwrite(mat2gray(a), &#39;test.tif&#39;);</p><p>导入标签：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>labels1<span class=\"p\">=</span><span class=\"nf\">loadLabel</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">filename</span><span class=\"p\">=</span>&#34;<span class=\"n\">train</span><span class=\"o\">-</span><span class=\"n\">labels</span><span class=\"o\">-</span><span class=\"n\">idx1</span><span class=\"o\">-</span><span class=\"n\">ubyte</span>&#34;<span class=\"p\">;</span>\n    <span class=\"n\">fid</span><span class=\"p\">=</span><span class=\"n\">fopen</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"p\">,</span>&#34;<span class=\"n\">rb</span>&#34;<span class=\"p\">);</span>\n    <span class=\"n\">A</span><span class=\"p\">=</span><span class=\"n\">fread</span><span class=\"p\">(</span><span class=\"n\">fid</span><span class=\"p\">);</span>\n    <span class=\"n\">labels1</span><span class=\"p\">=</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">));</span>\n    <span class=\"n\">fclose</span><span class=\"p\">(</span><span class=\"n\">fid</span><span class=\"p\">);</span>\n<span class=\"k\">end</span></code></pre></div><h2>2.softmax分类</h2><p><b>2.1softmax回归模型</b><sup data-text=\"\" data-url=\"http://zh.d2l.ai/chapter_deep-learning-basics/softmax-regression.html\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup></p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bsplit%7D%5Cbegin%7Baligned%7D+o_1+%26%3D+x_1+w_%7B11%7D+%2B+x_2+w_%7B21%7D+%2B+x_3+w_%7B31%7D+%2B+x_4+w_%7B41%7D+%2B+b_1%2C%5C%5C+o_2+%26%3D+x_1+w_%7B12%7D+%2B+x_2+w_%7B22%7D+%2B+x_3+w_%7B32%7D+%2B+x_4+w_%7B42%7D+%2B+b_2%2C%5C%5C+o_3+%26%3D+x_1+w_%7B13%7D+%2B+x_2+w_%7B23%7D+%2B+x_3+w_%7B33%7D+%2B+x_4+w_%7B43%7D+%2B+b_3.+%5Cend%7Baligned%7D%5Cend%7Bsplit%7D\" alt=\"\\begin{split}\\begin{aligned} o_1 &amp;= x_1 w_{11} + x_2 w_{21} + x_3 w_{31} + x_4 w_{41} + b_1,\\\\ o_2 &amp;= x_1 w_{12} + x_2 w_{22} + x_3 w_{32} + x_4 w_{42} + b_2,\\\\ o_3 &amp;= x_1 w_{13} + x_2 w_{23} + x_3 w_{33} + x_4 w_{43} + b_3. \\end{aligned}\\end{split}\" eeimg=\"1\"/> </p><p><b>2.2softmax损失函数</b></p><p>softmax使用交叉熵来计算损失函数</p><p><img src=\"https://www.zhihu.com/equation?tex=H%5Cleft%28%5Cboldsymbol+y%5E%7B%28i%29%7D%2C+%5Cboldsymbol+%7B%5Chat+y%7D%5E%7B%28i%29%7D%5Cright+%29+%3D+-%5Csum_%7Bj%3D1%7D%5Eq+y_j%5E%7B%28i%29%7D+%5Clog+%5Chat+y_j%5E%7B%28i%29%7D\" alt=\"H\\left(\\boldsymbol y^{(i)}, \\boldsymbol {\\hat y}^{(i)}\\right ) = -\\sum_{j=1}^q y_j^{(i)} \\log \\hat y_j^{(i)}\" eeimg=\"1\"/></p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29+%3D+%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5En+H%5Cleft%28%5Cboldsymbol+y%5E%7B%28i%29%7D%2C+%5Cboldsymbol+%7B%5Chat+y%7D%5E%7B%28i%29%7D%5Cright+%29\" alt=\"\\ell(\\boldsymbol{\\Theta}) = \\frac{1}{n} \\sum_{i=1}^n H\\left(\\boldsymbol y^{(i)}, \\boldsymbol {\\hat y}^{(i)}\\right )\" eeimg=\"1\"/> </p><p>可以化简为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cell%28%5Cboldsymbol%7B%5CTheta%7D%29+%3D+-%281%2Fn%29+%5Csum_%7Bi%3D1%7D%5En+%5Clog+%5Chat+y_%7B%7D%5E%7B%28i%29%7D\" alt=\"\\ell(\\boldsymbol{\\Theta}) = -(1/n) \\sum_{i=1}^n \\log \\hat y_{}^{(i)}\" eeimg=\"1\"/> </p><p>matlab实现：%</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"c\">%主函数</span>\n<span class=\"k\">function</span><span class=\"w\"> </span>W<span class=\"p\">=</span><span class=\"nf\">softmax</span><span class=\"p\">(</span>X,y,p<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"o\">~</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">);</span>\n <span class=\"n\">X</span><span class=\"p\">=</span><span class=\"n\">X</span><span class=\"o\">/</span><span class=\"mi\">255</span><span class=\"p\">;</span>\n<span class=\"c\">%   y_hat=net(X*W+b);</span>\n  <span class=\"n\">num_iter</span><span class=\"p\">=</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n  <span class=\"n\">alpha</span><span class=\"p\">=</span><span class=\"mf\">0.01</span><span class=\"p\">;</span>\n  <span class=\"n\">W</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">p</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">num_iter</span>\n      <span class=\"n\">W</span><span class=\"p\">=</span><span class=\"n\">W</span><span class=\"o\">+</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">loss</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"n\">W</span><span class=\"p\">));</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n<span class=\"c\">%模型函数</span>\n<span class=\"k\">function</span><span class=\"w\"> </span>X<span class=\"p\">=</span><span class=\"nf\">net</span><span class=\"p\">(</span>X<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"n\">X</span><span class=\"p\">=</span><span class=\"nb\">exp</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">);</span>\n  <span class=\"n\">total</span><span class=\"p\">=</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n  <span class=\"n\">X</span><span class=\"p\">=</span><span class=\"n\">X</span><span class=\"o\">./</span><span class=\"n\">total</span><span class=\"p\">;</span>\n<span class=\"k\">end</span>\n\n<span class=\"c\">%损失函数</span>\n<span class=\"k\">function</span><span class=\"w\"> </span>Wal<span class=\"p\">=</span><span class=\"nf\">loss</span><span class=\"p\">(</span>X,y,W<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%   y_err=-net(X*W);  </span>\n<span class=\"c\">%   [m,~]=size(X);  </span>\n<span class=\"c\">%   for i=1:m</span>\n<span class=\"c\">%       y_err(i,y(i)+1)=y_err(i,y(i)+1)+1;</span>\n<span class=\"c\">% %       Wal(:,y(i)+1)=Wal(:,y(i)+1)+(-X(i,:)&#39;*exp(X(i,:)*W(:,y(i)+1))+X(i,1)&#39;*sum(exp(X(i,:)*W)))/sum(exp(X(i,:)*W));</span>\n<span class=\"c\">%   end</span>\n<span class=\"c\">%   Wal=X&#39;*y_err;</span>\n<span class=\"c\">%   Wal=Wal/m;</span>\n <span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">);</span>\n <span class=\"n\">Wal</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">);</span>\n <span class=\"k\">for</span> <span class=\"nb\">i</span> <span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n      <span class=\"n\">Wal</span><span class=\"p\">(:,</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"n\">Wal</span><span class=\"p\">(:,</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">X</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"s\">&#39;</span><span class=\"err\">*(-exp(X(i,:)*W(:,y(i)+1))/sum(exp(X(i,:)*W))+1);\n</span><span class=\"err\"> end\n</span><span class=\"err\"> Wal=Wal/m;\n</span><span class=\"err\">end\n</span><span class=\"err\">\n</span><span class=\"err\">%测试函数\n</span><span class=\"err\">function p=test(X,y,W)\n</span><span class=\"err\">  X=X/255;\n</span><span class=\"err\">  y_hat=net(X*W);\n</span><span class=\"err\">  [~,index]=max(y_hat,[],2);\n</span><span class=\"err\">  sum=0;\n</span><span class=\"err\">  for i=1:length(y)\n</span><span class=\"err\">      if index(i)==y(i)+1\n</span><span class=\"err\">          sum=sum+1;\n</span><span class=\"err\">      end\n</span><span class=\"err\">  end\n</span><span class=\"err\">  p=sum/length(y);\n</span><span class=\"err\">end</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "分类算法", 
                    "tagLink": "https://api.zhihu.com/topics/19605693"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81749290", 
            "userName": "haofeng", 
            "userLink": "https://www.zhihu.com/people/61328b588d8bfae5a1c14f2845ba71b3", 
            "upvote": 22, 
            "title": "Python遗传算法求解最短路径问题", 
            "content": "<h2><b>前言</b></h2><p>自从上一篇文章详细讲解了<a href=\"https://zhuanlan.zhihu.com/p/51587062\" class=\"internal\">Python遗传和进化算法工具箱及其在带约束的单目标函数值优化中的应用</a>之后，我经过不断学习工具箱的官方文档以及对源码的研究，逐步更加地掌握如何利用遗传算法求解更多有趣的问题了。</p><p>首先简单回顾一下Python高性能实用型遗传和进化算法工具箱的用法。对于一个优化问题，需要做<b>两个步骤</b>便可进行求解：Step1：自定义问题类；Step2：编写执行脚本调用Geatpy进化算法模板对问题进行求解。在上一篇文章曾“详细”介绍过具体的用法，文章链接：</p><a href=\"https://zhuanlan.zhihu.com/p/51587062\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">haofeng：Python遗传算法工具箱Geatpy的使用（一）求解带约束的单目标优化</a><p>但完整的<b>中文教程</b>可以参考官方文档：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/geatpy%25E6%2595%2599%25E7%25A8%258B/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geatpy教程 - Geatpy</a><p><b>下面切入主题</b>：</p><p>本文的“最短路径问题”专指<b>图的最短路径问题</b>，而且只研究单目标的最短路径问题。（实际上最短路径问题还可以是多目标的），参考用书推荐：《网络模型与多目标遗传算法》。<b>这本书我已经上传到此处，可以直接下载到</b>：</p><a href=\"https://link.zhihu.com/?target=https%3A//download.csdn.net/download/weixin_37790882/11700202\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">download.csdn.net/downl</span><span class=\"invisible\">oad/weixin_37790882/11700202</span><span class=\"ellipsis\"></span></a><p><b>图的最短路径问题从广义上说其实有很多种类型</b>，比如：</p><ul><li>确定起点和终点的有向图和无向图的最短路径问题。</li><li>旅行商最短路径问题。</li><li>车辆配送中的最短路径问题。</li><li>物流中心选址的最短路径问题。</li></ul><p>其中确定起点和终点的<b>无向图</b>的最短路径问题可以延伸为<b>机器人路径规划问题</b>。也就是说，机器人避开障碍物从起点走向终点的那种路径规划问题本质上是一种复杂一些的“<b>确定起点和终点的无向图的最短路径问题</b>”。</p><p>本文主要讲解如何利用<b>遗传算法</b>求解“确定起点和终点的<b>有向图</b>最短路径问题”。对于无向图的，另外再写文章以机器人路径规划作为案例来展开叙述。</p><h2><b>正文</b></h2><p>问题举例：</p><p>以《网络模型与多目标遗传算法》一书中的一个小案例为例，如图所示，当从结点1驶向结点10时，我们经常会考虑怎样选择路径使得花最短的距离达到目的地。此时不需要像旅行商问题（TSP）那样，此类问题不需要要求所有的地点都访问一遍，而只需要想办法用最短的距离从起点走到终点即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c52e45671e506c11f743d1f3372314c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb\" width=\"901\" data-original=\"https://pic2.zhimg.com/v2-c52e45671e506c11f743d1f3372314c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;901&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"901\" data-original=\"https://pic2.zhimg.com/v2-c52e45671e506c11f743d1f3372314c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c52e45671e506c11f743d1f3372314c5_b.jpg\"/></figure><p>书中讲述了两种遗传算法编码方式对上述问题进行求解。</p><p><b>法一</b>：</p><p>利用二进制编码。假设 Xij 是有向图中所有边的一个集合，那么其中一种可行的路径对应的染色体可以是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d7339f6f9ee5be05c075a3cb026cb475_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb\" width=\"813\" data-original=\"https://pic2.zhimg.com/v2-d7339f6f9ee5be05c075a3cb026cb475_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;813&#39; height=&#39;77&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"813\" data-original=\"https://pic2.zhimg.com/v2-d7339f6f9ee5be05c075a3cb026cb475_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d7339f6f9ee5be05c075a3cb026cb475_b.png\"/></figure><p>其中元素为1表示对应的边被“激活”，即最终路径上包含这条边。于是上面的染色体所代表的路径为：1 → 3 → 6 → 7 → 8 → 10。</p><p>这种编码方式最为直观，但有个很大的弊端：在进化过程中染色体往往无法表达一个合法的路径。于是这种情况下需要给遗传算法添加很多约束，此时便增加了遗传算法寻优的难度。</p><p><b>法二</b>：</p><p>利用“基于优先级编码”。这种编码方式是Gen &amp; Lin 在2005年提出的有利于很好地求解图的路径规划问题的编码方法。参考文献：(Lin L, Gen M. Priority-Based Genetic Algorithm for Shortest Path Routing Problem in OSPF[M]// Intelligent and Evolutionary Systems. 2009.)<b>这篇文献可能比较难下载到，我将其上传到这里了，可以直接下载查看</b>：</p><a href=\"https://link.zhihu.com/?target=https%3A//download.csdn.net/download/weixin_37790882/11699834\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">download.csdn.net/downl</span><span class=\"invisible\">oad/weixin_37790882/11699834</span><span class=\"ellipsis\"></span></a><p>下面来详细讲解这种编码方式：</p><p>“基于优先级编码”是一种<b>间接编码方式</b>，这意味着染色体并不能直接表示路径，此时需要利用额外的数据来进行解码，解码后才表示一个路径。这种编码方式有个特点是染色体的每一位上的元素是互不相等的，这意味着这种编码方式具备“排列编码”的特征。（排列编码即比如从1到10的10个数中随机挑选若干个数组成的一个排列。）</p><p>以一条染色体为例，看看“基于优先级编码”的染色体是如何表示有向图中的一条路径的：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-798995c676566d804190a67211f2dc11_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1081\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb\" width=\"1081\" data-original=\"https://pic2.zhimg.com/v2-798995c676566d804190a67211f2dc11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1081&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1081\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1081\" data-original=\"https://pic2.zhimg.com/v2-798995c676566d804190a67211f2dc11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-798995c676566d804190a67211f2dc11_b.png\"/></figure><p>上面这条染色体是遗传算法中随机生成的（并非最优），结点优先级并不是指结点的访问先后顺序，而是结点的优先级，是给后面解码用的。</p><p>解码需要一个集合nodes，用于存储以各结点为起点的有向边的终点，即各个结点下一步可达的结点。本题的集合nodes为：<b>nodes = [[], [2,3], [3,4,5], [5,6], [7,8], [4,6], [7,9], [8,9], [9,10], [10]]</b>。因为python中列表的下标是从0数起的，而本题的结点是从1数起的，为了能直接对应，故上面的nodes的第0号元素设置为[]，表示无意义。解析一下nodes的组成：第1号元素是[2,3]，表示题目的有向图中1号结点下一步可达的结点是2和3。nodes的第2号元素是[3,4,5]，表示2号结点下一步可达的结点是3,4,5。以此类推。</p><p><b>于是上面的染色体[7, 3, 4, 6, 2, 5, 8, 10, 1, 9]的详细解码过程如下</b>：</p><p>从1号结点出发，在nodes中下标为1的元素是[2,3]，表示1号结点下一步可以去2号结点或3号结点。此时从染色体中找到这两个结点对应的优先级分别为3和4，如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-08347b55397dfaa451d2d162d1ea01f2_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb\" width=\"714\" data-original=\"https://pic3.zhimg.com/v2-08347b55397dfaa451d2d162d1ea01f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;714&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"714\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"714\" data-original=\"https://pic3.zhimg.com/v2-08347b55397dfaa451d2d162d1ea01f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-08347b55397dfaa451d2d162d1ea01f2_b.png\"/></figure><p>​从中选出具有更高优先级的结点3作为结点1下一步需要访问的结点。</p><p>紧接着，在nodes中下标为3的元素是[5,6]，表示3号结点下一步可以去5号或6号结点。此时从染色体中找到这两个结点对应的优先级分别为2和5，如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-36d7c2ac685773b07c6615357b6567f8_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-36d7c2ac685773b07c6615357b6567f8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;703&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"106\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-36d7c2ac685773b07c6615357b6567f8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-36d7c2ac685773b07c6615357b6567f8_b.png\"/></figure><p>​从中选出具有更高优先级的结点6作为结点1下一步需要访问的结点。</p><p>以此类推，最终得到完整的访问路径为：1 → 3 → 6 → 7 → 8 → 10。</p><p><b>有了解码得到路径，如何求个体的适应度？</b></p><p>想要求个体的适应度，首先要定一个优化目标。本题是要让路径最短，于是我们便要根据访问结点求出路径长度，把这个作为优化目标。有了优化目标，便可利用基于目标函数值排序的适应度分配（ranking）求出适应度值。当然，这类单目标优化问题也可以直接让个体的适应度等于优化目标函数值（即路径长度）。而路径长度即为访问路径上各条有向边的权值之和。</p><p><b>代码实现</b>：</p><p>首先编写问题类，把待优化模型写在问题类中。然后编写执行脚本，调用“soea_SEGA_templet“（增强精英保留的遗传算法模板）进行进化优化。<b>该算法模板的源码及算法流程详见</b>：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/geatpy-dev/geatpy/blob/master/geatpy/templates/soeas/GA/SEGA/soea_SEGA_templet.py\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/geatpy-dev/g</span><span class=\"invisible\">eatpy/blob/master/geatpy/templates/soeas/GA/SEGA/soea_SEGA_templet.py</span><span class=\"ellipsis\"></span></a><p>由于本题比较简单，故用4个个体、10代的进化即可得到很好的结果。完整的实验代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf-8 -*-\nimport numpy as np\nimport geatpy as ea\nclass MyProblem(ea.Problem): # 继承Problem父类\n    def __init__(self):\n        name = &#39;Shortest_Path&#39; # 初始化name（函数名称，可以随意设置）\n        M = 1 # 初始化M（目标维数）\n        maxormins = [1] # 初始化maxormins（目标最小最大化标记列表，1：最小化该目标；-1：最大化该目标）\n        Dim = 10 # 初始化Dim（决策变量维数）\n        varTypes = [1] * Dim # 初始化varTypes（决策变量的类型，元素为0表示对应的变量是连续的；1表示是离散的）\n        lb = [0] * Dim # 决策变量下界\n        ub = [9] * Dim # 决策变量上界\n        lbin = [1] * Dim # 决策变量下边界\n        ubin = [1] * Dim # 决策变量上边界\n        # 调用父类构造方法完成实例化\n        ea.Problem.__init__(self, name, M, maxormins, Dim, varTypes, lb, ub, lbin, ubin)\n        # 设置每一个结点下一步可达的结点（结点从1开始数，因此列表nodes的第0号元素设为空列表表示无意义）\n        self.nodes = [[], [2,3], [3,4,5], [5,6], [7,8], [4,6], [7,9], [8,9], [9,10], [10]]\n        # 设置有向图中各条边的权重\n        self.weights = {&#39;(1, 2)&#39;:36, &#39;(1, 3)&#39;:27, &#39;(2, 4)&#39;:18, &#39;(2, 5)&#39;:20, &#39;(2, 3)&#39;:13, &#39;(3, 5)&#39;:12, &#39;(3, 6)&#39;:23,\n                         &#39;(4, 7)&#39;:11, &#39;(4, 8)&#39;:32, &#39;(5, 4)&#39;:16, &#39;(5, 6)&#39;:30, &#39;(6, 7)&#39;:12, &#39;(6, 9)&#39;:38, &#39;(7, 8)&#39;:20,\n                         &#39;(7, 9)&#39;:32, &#39;(8, 9)&#39;:15, &#39;(8, 10)&#39;:24, &#39;(9, 10)&#39;:13}\n    def decode(self, priority): # 将优先级编码的染色体解码得到一条从节点1到节点10的可行路径\n        edges = [] # 存储边\n        path = [1] # 结点1是路径起点\n        while not path[-1] == 10: # 开始从起点走到终点\n            currentNode = path[-1] # 得到当前所在的结点编号\n            nextNodes = self.nodes[currentNode] # 获取下一步可达的结点组成的列表\n            chooseNode = nextNodes[np.argmax(priority[np.array(nextNodes) - 1])] # 从NextNodes中选择优先级更高的结点作为下一步要访问的结点，因为结点从1数起，而下标从0数起，因此要减去1\n            path.append(chooseNode)\n            edges.append((currentNode, chooseNode))\n        return path, edges\n    def aimFunc(self, pop): # 目标函数\n        pop.ObjV = np.zeros((pop.sizes, 1)) # 初始化ObjV\n        for i in range(pop.sizes):\n            priority = pop.Phen[i, :]\n            path, edges = self.decode(priority) # 将优先级编码的染色体解码得到访问路径及经过的边\n            pathLen = 0\n            for edge in edges:\n                key = str(edge) # 根据路径得到键值，以便根据键值找到路径对应的长度\n                if not key in self.weights:\n                    raise RuntimeError(&#34;Error in aimFunc: The path is invalid. (当前路径是无效的。)&#34;, path)\n                pathLen += self.weights[key] # 将该段路径长度加入\n            pop.ObjV[i] = pathLen # 计算目标函数值，赋值给pop种群对象的ObjV属性\n        \nif __name__ == &#34;__main__&#34;:\n    problem = MyProblem()                      # 生成问题对象\n    &#34;&#34;&#34;=================================种群设置=================================&#34;&#34;&#34;\n    Encoding = &#39;P&#39;                             # 编码方式\n    NIND = 4                                   # 种群规模\n    Field = ea.crtfld(Encoding, problem.varTypes, problem.ranges, problem.borders) # 创建区域描述器\n    population = ea.Population(Encoding, Field, NIND) # 实例化种群对象（此时种群还没被初始化，仅仅是完成种群对象的实例化）\n    &#34;&#34;&#34;===============================算法参数设置===============================&#34;&#34;&#34;\n    myAlgorithm = ea.soea_SEGA_templet(problem, population) # 实例化一个算法模板对象\n    myAlgorithm.MAXGEN = 10                    # 最大进化代数\n    myAlgorithm.recOper = ea.Xovox(XOVR = 0.8) # 设置交叉算子\n    myAlgorithm.mutOper = ea.Mutinv(Pm = 0.1)  # 设置变异算子\n    myAlgorithm.drawing = 1                    # 设置绘图方式（0：不绘图；1：绘制结果图；2：绘制过程动画）\n    &#34;&#34;&#34;==========================调用算法模板进行种群进化==========================&#34;&#34;&#34;\n    [population, obj_trace, var_trace] = myAlgorithm.run() # 执行算法模板，得到最后一代种群以及进化记录器\n    population.save()                          # 把最后一代种群的信息保存到文件中\n    # 输出结果\n    best_gen = np.argmin(obj_trace[:, 1])      # 记录最优种群是在哪一代\n    best_ObjV = np.min(obj_trace[:, 1])\n    print(&#39;最短路程为：%s&#39;%(best_ObjV))\n    print(&#39;最佳路线为：&#39;)\n    best_journey, edges = problem.decode(var_trace[best_gen, :])\n    for i in range(len(best_journey)):\n        print(int(best_journey[i]), end = &#39; &#39;)\n    print()\n    print(&#39;有效进化代数：%s&#39;%(obj_trace.shape[0]))\n    print(&#39;最优的一代是第 %s 代&#39;%(best_gen + 1))\n    print(&#39;评价次数：%s&#39;%(myAlgorithm.evalsNum))\n    print(&#39;时间已过 %s 秒&#39;%(myAlgorithm.passTime))\n</code></pre></div><p>运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5f81c1c597f3c1002553b077b51d927b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"388\" data-rawheight=\"423\" class=\"content_image\" width=\"388\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;388&#39; height=&#39;423&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"388\" data-rawheight=\"423\" class=\"content_image lazy\" width=\"388\" data-actualsrc=\"https://pic4.zhimg.com/v2-5f81c1c597f3c1002553b077b51d927b_b.jpg\"/></figure><p>​在有向图中表现为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fc11280fd6c187125347c89b75d9b8e8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb\" width=\"908\" data-original=\"https://pic1.zhimg.com/v2-fc11280fd6c187125347c89b75d9b8e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;908&#39; height=&#39;328&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"908\" data-original=\"https://pic1.zhimg.com/v2-fc11280fd6c187125347c89b75d9b8e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fc11280fd6c187125347c89b75d9b8e8_b.jpg\"/></figure><h2><b>后记</b></h2><p><b>值得注意的是</b>：上面题目中的有向图并不存在回路，实际上，复杂的有向图往往会存在许多回路，此时需要进行一定的处理来避免陷入回路当中，即避免一直在回路上“打转”。处理方式有很多，例如在解码过程中对已经访问过的结点的有限度进行惩罚等等。这里暂时就不深入探讨了，待之后讲述无向图最短路径及机器人寻路问题时再展开叙述。</p><p>最后回顾一下<a href=\"https://zhuanlan.zhihu.com/p/51587062\" class=\"internal\">上一篇文章</a>提到的”遗传算法套路“：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-98e7c21a97e304c2ccd7d6d7c5e9b4fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"944\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb\" width=\"944\" data-original=\"https://pic1.zhimg.com/v2-98e7c21a97e304c2ccd7d6d7c5e9b4fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;944&#39; height=&#39;392&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"944\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"944\" data-original=\"https://pic1.zhimg.com/v2-98e7c21a97e304c2ccd7d6d7c5e9b4fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-98e7c21a97e304c2ccd7d6d7c5e9b4fc_b.jpg\"/></figure><p>​该套路实现了具体问题、使用的算法以及所调用的相关算子之间的脱耦。而Geatpy工具箱已经内置了众多进化算法模板类以及相关的算子，直接调用即可。对于实际问题的求解，只需关心如何把问题写在自定义问题类中就好了。</p><p>更多详细的教程可以详见：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/geatpy%25E6%2595%2599%25E7%25A8%258B/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geatpy教程 - Geatpy</a><p>后续我将继续学习和挖掘该工具箱的更多深入的用法。希望这篇文章在帮助自己记录学习点滴之余，也能帮助大家！</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "遗传算法", 
                    "tagLink": "https://api.zhihu.com/topics/19555677"
                }, 
                {
                    "tag": "路径规划", 
                    "tagLink": "https://api.zhihu.com/topics/20206646"
                }
            ], 
            "comments": [
                {
                    "userName": "o.o", 
                    "userLink": "https://www.zhihu.com/people/6291226140ee02867e7b840dd620ca5d", 
                    "content": "我想知道，怎么控制01编码中1的个数？？我的做法是如果后代中1的个数不是我想要的，我就让那个父代一直交叉变异，直到后代1的个数满足为止。但是这样做后，发现一直在交叉变异，就是得不到子代1个数满足条件，咋办呀？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51587062", 
            "userName": "haofeng", 
            "userLink": "https://www.zhihu.com/people/61328b588d8bfae5a1c14f2845ba71b3", 
            "upvote": 30, 
            "title": "Python遗传算法工具箱Geatpy的使用（一）求解带约束的单目标优化", 
            "content": "<p><b>前言</b></p><p>网上有很多博客讲解遗传算法，但是大都只是“点到即止”，虽然给了一些代码实现，但也是“浅尝辄止”，没能很好地帮助大家进行扩展应用，抑或是进行深入的研究。</p><p>这是我的开篇之作~之前没有写博客的习惯，一般是将笔记存本地，但久而久之发现回看不便，而且无法与大家交流和学习。现特此写下开篇之作，若有疏漏之处，敬请指正，谢谢！</p><p>本文对遗传算法的原理进行梳理，相关代码是基于国内高校学生联合团队开源的高性能实用型进化算法工具箱geatpy来实现，部分教程引用了geatpy的官方文档：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/details/%25EF%25BC%258C\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://geatpy.com/index.php/details/</a><p>geatpy官网：</p><a href=\"https://link.zhihu.com/?target=http%3A//www.geatpy.com\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geatpy</a><p>若有错误之处，恳请同志们指正和谅解，谢谢！</p><p>因为是基于geatpy遗传和进化算法工具箱，所以下文的代码部分在执行前，需要安装geatpy：</p><div class=\"highlight\"><pre><code class=\"language-text\">pip install geatpy</code></pre></div><p>安装时会自动根据系统版本匹配下载安装对应的版本。这里就有个小坑：如果最新版Geatpy没有与当前版本相匹配的包的话，会自动下载旧版的包。而旧版的包在Linux和Mac下均不可用。</p><p>安装好后，在Python中输出版本检查是否是最新版（version 2.1.0）：</p><div class=\"highlight\"><pre><code class=\"language-bash\">import geatpy as ea\nprint<span class=\"o\">(</span>ea.__version__<span class=\"o\">)</span></code></pre></div><p>下面切入主题：</p><p>自然界生物在周而复始的繁衍中，基因的重组、变异等，使其不断具有新的性状，以适应复杂多变的环境，从而实现进化。遗传算法精简了这种复杂的遗传过程而抽象出一套数学模型，用较为简单的编码方式来表现复杂的现象，并通过简化的遗传过程来实现对复杂搜索空间的启发式搜索，最终能够在较大的概率下找到全局最优解，同时与生俱来地支持并行计算。</p><p>下图展示了常规遗传算法(左侧) 和某种在并行计算下的遗传算法(右侧) 的流程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a2a2ddea9403d005d697c51ea15ea1b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1141\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb\" width=\"1141\" data-original=\"https://pic3.zhimg.com/v2-a2a2ddea9403d005d697c51ea15ea1b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1141&#39; height=&#39;588&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1141\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1141\" data-original=\"https://pic3.zhimg.com/v2-a2a2ddea9403d005d697c51ea15ea1b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a2a2ddea9403d005d697c51ea15ea1b2_b.jpg\"/></figure><p><b>本文只研究经典的遗传算法，力求最后能够解决各种带约束单目标优化问题，并能够很轻松地进行扩展，让大家不仅学到算法理论，还能轻松地通过“复制粘贴”就能够将相关遗传算法代码结合到各类不同的现实问题的求解当中。</b></p><p>从上面的遗传算法流程图可以直观地看出，遗传算法是有一套完整的“固定套路”的，我们可以把这个“套路”写成一个“算法模板”，即把：种群初始化、计算适应度、选择、重组、变异、生成新一代、记录并输出等等这些基本不需要怎么变的“套路”写在一个函数里面，而经常要变的部分：变量范围、遗传算法参数等写在这个函数外面，对于要求解的目标函数，由于在遗传进化的过程中需要进行调用目标函数进行计算，因此可以把目标函数、约束条件写在另一个函数里面。</p><p>另外我们还可以发现，在遗传算法的“套路”里面，执行的“初始化种群”、“选择”、“重组”、“变异”等等，其实是一个一个的“算子”，在geatpy工具箱里，已经提供现行的多种多样的进化算子了，因此直接调用即可。</p><p>Geatpy工具箱提供一个面向对象的进化算法框架，因此一个完整的遗传算法程序就可以写成这个样子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f118b2396c84edf2321b0a6eab9548da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1241\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"1241\" data-original=\"https://pic3.zhimg.com/v2-f118b2396c84edf2321b0a6eab9548da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1241&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1241\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1241\" data-original=\"https://pic3.zhimg.com/v2-f118b2396c84edf2321b0a6eab9548da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f118b2396c84edf2321b0a6eab9548da_b.jpg\"/></figure><p>关于算法框架的详细介绍可参见：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/geatpy%25E6%2595%2599%25E7%25A8%258B/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geatpy教程</a><p>下面就来详细讲一下相关的理论和代码实现：</p><h2><b>正文</b></h2><h3><b>一. 基础术语：</b></h3><p> 先介绍一下遗传算法的几个基础的术语，分别是：”个体“、”种群“、”编码与解码“、”目标函数值“、”适应度值“。</p><p>1.<b>个体</b>：“个体”其实是一个抽象的概念，与之有关的术语有：</p><p>（1）<b>个体染色体</b>：即对决策变量编码后得到的行向量。</p><p>比如：有两个决策变量x1=1,x2=2，各自用3位的二进制串去表示的话，写成染色体就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-78c5c38d6cd4da92b529ac568ef9fe92_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"134\" data-rawheight=\"44\" class=\"content_image\" width=\"134\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;134&#39; height=&#39;44&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"134\" data-rawheight=\"44\" class=\"content_image lazy\" width=\"134\" data-actualsrc=\"https://pic3.zhimg.com/v2-78c5c38d6cd4da92b529ac568ef9fe92_b.png\"/></figure><p>（2）<b>个体表现型</b>：即对个体染色体进行解码后，得到的直接指代各个控制变量的值的行向量。</p><p> 比如对上面的染色体“0 0 1 0 1 0”进行解码，得到 “1 2”，它就是个体的表现型，可看出该个体存储着两个变量，值分别是1和2。</p><p><b>注意</b>：遗传算法中可以进行“实值编码”，即可以不用二进制编码，直接用变量的实际值来作为染色体。这个时候，个体的染色体数值上是等于个体的表现型的。</p><p>（3）<b>个体可行性</b>：即标识该个体是否是可行解。在遗传算法中，搜索空间内是允许出现非可行解的，此时为了标识哪些是可行解，哪些是非可行解，通常给可行解的个体标记1，非可行解的个体标记0。</p><p>2. <b>种群</b>：“种群”也是一个抽象的概念，与之有关的术语有：</p><p>（1）<b>种群染色体矩阵</b>(Chrom)：它每一行对应一个个体的染色体。此时会发出疑问：一个个体可以有多条染色体吗？答：可以有，但一般没有必要，一条染色体就可以存储很多决策变量的信息了，如果要用到多条染色体，可以用两个种群来表示。</p><p>例如：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8e57703ffc207db8bc20c6e03e50e802_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"342\" data-rawheight=\"120\" class=\"content_image\" width=\"342\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;342&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"342\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"342\" data-actualsrc=\"https://pic3.zhimg.com/v2-8e57703ffc207db8bc20c6e03e50e802_b.jpg\"/></figure><p>它表示有3个个体（因为有3行），因此有3条染色体。此时需要注意：这些染色体代表决策变量的什么值，我们是不知道的，我们也不知道该种群的染色体采用的是什么编码。染色体具体代表了什么，取决于我们采用什么方式去解码。假如我们采用的是二进制的解码方式，并约定上述的种群染色体矩阵中前3列代表第一个决策变量，后3列代表第二个决策变量，那么，该种群染色体就可以解码成：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d9780cea1c82b22539b247e58fa1c4fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"176\" class=\"content_image\" width=\"268\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;268&#39; height=&#39;176&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"176\" class=\"content_image lazy\" width=\"268\" data-actualsrc=\"https://pic3.zhimg.com/v2-d9780cea1c82b22539b247e58fa1c4fe_b.jpg\"/></figure><p>（2）<b>种群表现型矩阵</b>(Phen)：它每一行对应一个个体的表现型。比如上图就是根据Chrom种群染色体矩阵解码得到的种群表现型矩阵。同样地，当种群染色体采用的是“实值编码”时，种群染色体矩阵与表现型矩阵实际上是一样的。</p><p>（3）<b>种群个体违反约束程度矩阵</b>(CV)：它每一行对应一个个体，每一列对应一种约束条件（可以是等式约束或不等式约束）。CV矩阵中元素小于或等于0表示对应个体满足对应的约束条件，大于0则表示不满足，且越大表示违反约束条件的程度越高。比如有两个约束条件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7de534825289e65f39a3b81bf4c378dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"341\" data-rawheight=\"135\" class=\"content_image\" width=\"341\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;341&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"341\" data-rawheight=\"135\" class=\"content_image lazy\" width=\"341\" data-actualsrc=\"https://pic1.zhimg.com/v2-7de534825289e65f39a3b81bf4c378dc_b.jpg\"/></figure><p>如何计算CV矩阵？可以创建两个列向量CV1和CV2，然后把它们左右拼合而成一个CV矩阵。</p><p>假设x1、x2、x3均为存储着种群所有个体的决策变量值的列向量（这里可以利用种群表现型矩阵Phen得到，比如</p><p>x1=Phen[:, [0]]；</p><p>x2=Phen[:, [1]])；</p><p>x3=Phen[:, [2]])，</p><p>这样就可以得到种群所有个体对应的x1、x2和x3）。</p><p>那么：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-809539704f4552e110fbd4bd8e75923e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"189\" class=\"content_image\" width=\"355\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;355&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"355\" data-actualsrc=\"https://pic3.zhimg.com/v2-809539704f4552e110fbd4bd8e75923e_b.jpg\"/></figure><p>比如在某一代中，种群表现型矩阵Phen为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f98d4eebd07b568e857e5ee75fbb465b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic4.zhimg.com/v2-f98d4eebd07b568e857e5ee75fbb465b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic4.zhimg.com/v2-f98d4eebd07b568e857e5ee75fbb465b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f98d4eebd07b568e857e5ee75fbb465b_b.jpg\"/></figure><p>则有：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-05a1d73dc6263f146b7e7383f6b0b395_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"674\" data-original=\"https://pic2.zhimg.com/v2-05a1d73dc6263f146b7e7383f6b0b395_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;674&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"674\" data-original=\"https://pic2.zhimg.com/v2-05a1d73dc6263f146b7e7383f6b0b395_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-05a1d73dc6263f146b7e7383f6b0b395_b.jpg\"/></figure><p>此时CV矩阵的值为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cd2972f8193fc26cefe46e4a9ffc712a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"278\" class=\"content_image\" width=\"373\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;373&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"278\" class=\"content_image lazy\" width=\"373\" data-actualsrc=\"https://pic3.zhimg.com/v2-cd2972f8193fc26cefe46e4a9ffc712a_b.jpg\"/></figure><p>由此可见，第一个个体满足两个约束条件；第二个个体违反了2个约束条件；第三和第四个个体满足第一个约束条件但违反了第二个约束条件。</p><p><b>下面看下如何用代码来生成一个种群染色体矩阵：</b></p><p>代码1. 实整数值种群染色体矩阵的创建：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">geatpy</span> <span class=\"kn\">import</span> <span class=\"n\">crtpc</span>\n<span class=\"n\">help</span><span class=\"p\">(</span><span class=\"n\">crtpc</span><span class=\"p\">)</span> <span class=\"c1\"># 查看帮助</span>\n<span class=\"c1\"># 定义种群规模（个体数目）</span>\n<span class=\"n\">Nind</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>\n<span class=\"n\">Encoding</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;RI&#39;</span> <span class=\"c1\"># 表示采用“实整数编码”，即变量可以是连续的也可以是离散的</span>\n<span class=\"c1\"># 创建“区域描述器”，表明有4个决策变量，范围分别是[-3.1, 4.2], [-2, 2],[0, 1],[3, 3]，</span>\n<span class=\"c1\"># FieldDR第三行[0,0,1,1]表示前两个决策变量是连续型的，后两个变量是离散型的</span>\n<span class=\"n\">FieldDR</span><span class=\"o\">=</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([[</span><span class=\"o\">-</span><span class=\"mf\">3.1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">],</span>\n                  <span class=\"p\">[</span> <span class=\"mf\">4.2</span><span class=\"p\">,</span>  <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">],</span>\n                  <span class=\"p\">[</span> <span class=\"mi\">0</span><span class=\"p\">,</span>    <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">]])</span>\n<span class=\"c1\"># 调用crtri函数创建实数值种群</span>\n<span class=\"n\">Chrom</span><span class=\"o\">=</span><span class=\"n\">crtpc</span><span class=\"p\">(</span><span class=\"n\">Encoding</span><span class=\"p\">,</span> <span class=\"n\">Nind</span><span class=\"p\">,</span> <span class=\"n\">FieldDR</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">Chrom</span><span class=\"p\">)</span></code></pre></div><p>代码1的运行结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5e87ddc0e140f502cf14cb9e33966228_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb\" width=\"834\" data-original=\"https://pic1.zhimg.com/v2-5e87ddc0e140f502cf14cb9e33966228_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;834&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"834\" data-original=\"https://pic1.zhimg.com/v2-5e87ddc0e140f502cf14cb9e33966228_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5e87ddc0e140f502cf14cb9e33966228_b.png\"/></figure><p>这里要插入讲一下“区域描述器”（见代码1中的FieldDR），它是用于描述种群染色体所表示的决策变量的一些信息，如变量范围、连续/离散性。另外还有一种区域描述器(FIeldD)，用于描述二进制/格雷码的种群染色体。FieldDR和FieldD两个合称“Field”，又可以认为它们是“译码矩阵”。FieldDR具有以下的数据结构：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-59dde82220c71a6f0c3b119ed03c7338_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"416\" data-rawheight=\"125\" class=\"content_image\" width=\"416\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;416&#39; height=&#39;125&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"416\" data-rawheight=\"125\" class=\"content_image lazy\" width=\"416\" data-actualsrc=\"https://pic1.zhimg.com/v2-59dde82220c71a6f0c3b119ed03c7338_b.jpg\"/></figure><p>代码1中的FieldDR矩阵的第三行即为这里的varTypes。它如果为0，表示对应的决策变量是连续型的变量；为1表示对应的是离散型变量。</p><p>另一种则是用于二进制/格雷编码种群染色体解码的译码矩阵FieldD，它是具有以下结构的矩阵：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1d3e7e30d03f0ee5aacaa2beee99c56c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"438\" class=\"content_image\" width=\"301\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;301&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"438\" class=\"content_image lazy\" width=\"301\" data-actualsrc=\"https://pic1.zhimg.com/v2-1d3e7e30d03f0ee5aacaa2beee99c56c_b.jpg\"/></figure><p>其中，lens, lb, ub, codes, scales, lbin, ubin, varTypes均为长度等于决策变量个数的行向量。</p><p>lens 包含染色体的每个子染色体的长度。sum(lens) 等于染色体长度。</p><p>lb 和ub 分别代表每个决策变量的上界和下界。</p><p>codes 指明染色体子串用的是二进制编码还是格雷编码。codes[i] = 0 表示第i 个变量使用的是标准二进制编码；codes[i] = 1 表示使用格雷编码。</p><p>scales 指明每个子串用的是算术刻度还是对数刻度。scales[i] = 0 为算术刻度，scales[i] = 1 为对数刻度。对数刻度可以用于变量的范围较大而且不确定的情况，对于大范围的参数边界，对数刻度让搜索可用较少的位数，从而减少了遗传算法的计算量。（注意：当某个变量是对数刻度时，其取值范围中不能有0，即要么上下界都大于0，要么上下界都小于0。）</p><p>lbin 和ubin 指明了变量是否包含其范围的边界。0 表示不包含边界；1 表示包含边界。</p><p>varTypes 指明了决策变量的类型，元素为0 表示对应位置的决策变量是连续型变量；1 表示对应的是离散型变量。</p><p>对于二进制编码，二进制种群的染色体具体代表决策变量的什么含义是不由染色体本身决定的，而是由解码方式决定的。因此在创建二进制种群染色体之初就要设定好译码矩阵（又称“区域描述器”）。</p><p><b>因此，可以通过以下代码构建一个二进制种群染色体矩阵</b>：</p><p>代码2. 二进制种群染色体矩阵的创建：</p><div class=\"highlight\"><pre><code class=\"language-text\">import numpy as np\nfrom geatpy import crtpc\nhelp(crtpc) # 查看帮助\n# 定义种群规模（个体数目）\nNind = 4\nEncoding = &#39;BG&#39; # 表示采用“实整数编码”，即变量可以是连续的也可以是离散的\n# 创建“译码矩阵”\nFieldD = np.array([[3, 2], # 各决策变量编码后所占二进制位数，此时染色体长度为3+2=5\n                   [0, 0], # 各决策变量的范围下界\n                   [7, 3], # 各决策变量的范围上界\n                   [0, 0], # 各决策变量采用什么编码方式(0为二进制编码，1为格雷编码)\n                   [0, 0], # 各决策变量是否采用对数刻度(0为采用算术刻度)\n                   [1, 1], # 各决策变量的范围是否包含下界(对bs2int实际无效，详见help(bs2int))\n                   [1, 1], # 各决策变量的范围是否包含上界(对bs2int实际无效)\n                   [0, 0]])# 表示两个决策变量都是连续型变量（0为连续1为离散）\n# 调用crtri函数创建实数值种群\nChrom=crtpc(Encoding, Nind, FieldD)\nprint(Chrom)</code></pre></div><p>代码2运行结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e518a0921061c12771ea06874bd4b2ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"276\" data-rawheight=\"168\" class=\"content_image\" width=\"276\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;276&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"276\" data-rawheight=\"168\" class=\"content_image lazy\" width=\"276\" data-actualsrc=\"https://pic3.zhimg.com/v2-e518a0921061c12771ea06874bd4b2ea_b.jpg\"/></figure><p><b>3. 编码与解码</b></p><p>对于实整数编码（即上面代码1所创建的实整数种群染色体），它是不需要解码，染色体直接就对应着它所代表的决策变量值。而对于代码2生成的二进制种群染色体矩阵，它需要根据译码矩阵FieldD来进行解码。在代码2后面添加以下语句即可解码：</p><p>代码3（上接代码2）：</p><div class=\"highlight\"><pre><code class=\"language-text\">from geatpy import bs2ri\nhelp(bs2ri)\nPhen = bs2ri(Chrom, FieldD)\nprint(&#39;表现型矩阵 = \\n&#39;, Phen)</code></pre></div><p>运行效果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-138673282f79a1b2159aba3ea99ac067_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"178\" data-rawheight=\"168\" class=\"content_image\" width=\"178\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;178&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"178\" data-rawheight=\"168\" class=\"content_image lazy\" width=\"178\" data-actualsrc=\"https://pic4.zhimg.com/v2-138673282f79a1b2159aba3ea99ac067_b.png\"/></figure><p><b>4.目标函数值</b>：</p><p>种群的目标函数值存在一个矩阵里面(一般命名为ObjV)，它每一行对应一个个体的目标函数值。对于单目标而言，这个目标函数值矩阵只有1列，而对于多目标而言，就有多列了，比如下面就是一个含两个目标的种群目标函数值矩阵：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b387282da95c9ab26def5d476b039d7a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-b387282da95c9ab26def5d476b039d7a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;956&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-b387282da95c9ab26def5d476b039d7a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b387282da95c9ab26def5d476b039d7a_b.jpg\"/></figure><p>（这里Nind表示种群的规模，即种群含多少个个体；Nvar表示决策变量的个数）</p><p>下面来跑一下代码，接着代码3，在对二进制染色体解码成整数值种群后，我们希望计算出f(x,y)=x+y这个目标函数值。同时设置一个等式约束：要求x + y = 3。于是完整代码如下：</p><p>代码4：</p><div class=\"highlight\"><pre><code class=\"language-text\">import numpy as np\nfrom geatpy import crtpc\nfrom geatpy import bs2ri\n\ndef aim(Phen):\n    x = Phen[:, [0]] # 取出种群表现型矩阵的第一列，得到所有个体的决策变量x\n    y = Phen[:, [1]] # 取出种群表现型矩阵的第二列，得到所有个体的决策变量y\n    CV = np.abs(x + y - 3) # 生成种群个体违反约束程度矩阵CV，以处理等式约束：x + y == 3\n    f = x + y # 计算目标函数值\n    return f, CV # 返回目标函数值矩阵\n\n# 定义种群规模（个体数目）\nNind = 4\nEncoding = &#39;BG&#39; # 表示采用“实整数编码”，即变量可以是连续的也可以是离散的\n# 创建“译码矩阵”\nFieldD = np.array([[3, 2], # 各决策变量编码后所占二进制位数，此时染色体长度为3+2=5\n                   [0, 0], # 各决策变量的范围下界\n                   [7, 3], # 各决策变量的范围上界\n                   [0, 0], # 各决策变量采用什么编码方式(0为二进制编码，1为格雷编码)\n                   [0, 0], # 各决策变量是否采用对数刻度(0为采用算术刻度)\n                   [1, 1], # 各决策变量的范围是否包含下界(对bs2int实际无效，详见help(bs2int))\n                   [1, 1], # 各决策变量的范围是否包含上界(对bs2int实际无效)\n                   [0, 0]])# 表示两个决策变量都是连续型变量（0为连续1为离散）\n# 调用crtri函数创建实数值种群\nChrom=crtpc(Encoding, Nind, FieldD)\nprint(&#39;二进制染色体矩阵 = \\n&#39;, Chrom)\n\n# 解码\nPhen = bs2ri(Chrom, FieldD)\nprint(&#39;表现型矩阵 = \\n&#39;, Phen)\n\n# 计算目标函数值矩阵\nObjV, CV = aim(Phen)\nprint(&#39;目标函数值矩阵 = \\n&#39;, ObjV)\nprint(&#39;CV矩阵 = \\n&#39;, CV)</code></pre></div><p>运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dfd2060dadcbfd4aa05ba89e252dc45a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"247\" data-rawheight=\"622\" class=\"content_image\" width=\"247\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;247&#39; height=&#39;622&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"247\" data-rawheight=\"622\" class=\"content_image lazy\" width=\"247\" data-actualsrc=\"https://pic3.zhimg.com/v2-dfd2060dadcbfd4aa05ba89e252dc45a_b.jpg\"/></figure><p>由上面对CV矩阵的描述可知，第三个个体的CV值为0，表示第三个个体满足x+y=3这个等式约束。其他都大于0，表示不满足该约束。</p><p><b>疑问：CV矩阵有什么用呢？</b></p><p><b>答</b>：CV矩阵既可用于标记非可行解，在含约束条件的优化问题中有用，又可用于度量种群个体违反各个约束条件的程度的高低。对于含约束条件的优化问题，我们可以采用罚函数或者是可行性法则来进行处理。罚函数法这里就不展开赘述了，最简单的罚函数可以是直接找到非可行解个体的索引，然后修改其对应的ObjV的目标函数值即可。</p><p>对于可行性法则，它需要计算每个个体违反约束的程度，并把结果保存在种群类的CV矩阵中。CV矩阵的每一行对应一个个体、每一列对应一个约束条件（可以是等式约束也可以是不等式约束），CV矩阵中元素小于或等于0表示对应个体满足对应的约束条件，否则是违反对应的约束条件，大于0的值越大，表示违反约束的程度越高。生成CV标记之后，在后面调用适应度函数计算适应度时，只要把CV矩阵作为函数传入参数传进函数体，就会自动根据CV矩阵所描述的种群个体违反约束程度来计算出合适的种群个体适应度。</p><p><b>5.适应度值</b>：</p><p>适应度值通俗来说就是对种群个体的”生存能力的评价“。对于简单的单目标优化，我们可以简单地把目标函数值直接当作是适应度值（注意：当用geatpy遗传和进化算法工具箱时，则需要对目标函数值加个负号才能简单地把它当作适应度值，因为geatpy遵循的是”目标函数值越小，适应度值越大“的约定。）</p><p>对于多目标优化，则需要根据“非支配排序”或是其他方法来确定种群个体的适应度值，本文不对其展开叙述。</p><p><b>种群适应度</b>(FitnV)：它是一个列向量，每一行代表一个个体的适应度值：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e5d57f87aec0ca466703fa9ece607fb4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"239\" data-rawheight=\"252\" class=\"content_image\" width=\"239\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;239&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"239\" data-rawheight=\"252\" class=\"content_image lazy\" width=\"239\" data-actualsrc=\"https://pic1.zhimg.com/v2-e5d57f87aec0ca466703fa9ece607fb4_b.jpg\"/></figure><p>（这里Nind表示种群的规模，即种群含多少个个体）</p><p>geatpy遗传和进化算法工具箱里面有几个函数可以计算种群个体的适应度 ，分别是：</p><p>ranking、indexing、powing、scaling。具体的用法，可以用help命令查看，如help(ranking)。</p><p>下面接着代码4，利用ranking（基于目标函数值排序的适应度分配）计算种群的适应度：</p><p>代码5（接着代码4）：</p><div class=\"highlight\"><pre><code class=\"language-text\">from geatpy import ranking\nhelp(ranking)\nFitnV = ranking(ObjV, CV)\nprint(&#39;种群适应度矩阵 = \\n&#39;, FitnV)</code></pre></div><p>运行结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e7e0620d9ec3b6e322ef5f1eb8686db5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"219\" data-rawheight=\"156\" class=\"content_image\" width=\"219\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;219&#39; height=&#39;156&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"219\" data-rawheight=\"156\" class=\"content_image lazy\" width=\"219\" data-actualsrc=\"https://pic2.zhimg.com/v2-e7e0620d9ec3b6e322ef5f1eb8686db5_b.jpg\"/></figure><p>分析这个结果我们发现，由于第1、2、4个体违反约束条件，而第三个个体满足约束条件，因此第3个个体的适应度最高。而在第1、2、4个体中，个体1的目标函数值最大，因此适应度最低。可见遵循“最小化目标”的约定，即目标函数值越小，适应度越大。</p><p>好了，基本的术语和用法讲完后，下面讲一下遗传算法的基本算子：</p><h3>二. 遗传算法基本算子：</h3><p>我们不用破费时间去写底层的遗传算子，因为geatpy工具箱提供丰富的进化算子，以下所列算子不仅限于遗传算子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-38dc0506be6c9276de99ed7ff5781507_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic4.zhimg.com/v2-38dc0506be6c9276de99ed7ff5781507_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic4.zhimg.com/v2-38dc0506be6c9276de99ed7ff5781507_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-38dc0506be6c9276de99ed7ff5781507_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-41965401a1364a12d037fff43ce3b935_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"1137\" data-original=\"https://pic2.zhimg.com/v2-41965401a1364a12d037fff43ce3b935_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1137&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1137\" data-original=\"https://pic2.zhimg.com/v2-41965401a1364a12d037fff43ce3b935_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-41965401a1364a12d037fff43ce3b935_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d9a4d931969a13f694b64b1f1ad7cb18_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb\" width=\"786\" data-original=\"https://pic1.zhimg.com/v2-d9a4d931969a13f694b64b1f1ad7cb18_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;786&#39; height=&#39;594&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"786\" data-original=\"https://pic1.zhimg.com/v2-d9a4d931969a13f694b64b1f1ad7cb18_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d9a4d931969a13f694b64b1f1ad7cb18_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-81b6380ffe90155c81721809ebd9479e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"983\" data-rawheight=\"795\" class=\"origin_image zh-lightbox-thumb\" width=\"983\" data-original=\"https://pic3.zhimg.com/v2-81b6380ffe90155c81721809ebd9479e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;983&#39; height=&#39;795&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"983\" data-rawheight=\"795\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"983\" data-original=\"https://pic3.zhimg.com/v2-81b6380ffe90155c81721809ebd9479e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-81b6380ffe90155c81721809ebd9479e_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-53eea0d57edee0c2a734b352f1dcb5c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"931\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"931\" data-original=\"https://pic1.zhimg.com/v2-53eea0d57edee0c2a734b352f1dcb5c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;931&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"931\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"931\" data-original=\"https://pic1.zhimg.com/v2-53eea0d57edee0c2a734b352f1dcb5c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-53eea0d57edee0c2a734b352f1dcb5c0_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c44c6c4c924cb2ec94f16572032c3bf6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"416\" data-rawheight=\"159\" class=\"content_image\" width=\"416\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;416&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"416\" data-rawheight=\"159\" class=\"content_image lazy\" width=\"416\" data-actualsrc=\"https://pic3.zhimg.com/v2-c44c6c4c924cb2ec94f16572032c3bf6_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-edd45f37009be5b498bfc926efa54985_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1074\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"1074\" data-original=\"https://pic2.zhimg.com/v2-edd45f37009be5b498bfc926efa54985_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1074&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1074\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1074\" data-original=\"https://pic2.zhimg.com/v2-edd45f37009be5b498bfc926efa54985_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-edd45f37009be5b498bfc926efa54985_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e343149c0978699a730da76de589acc2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic3.zhimg.com/v2-e343149c0978699a730da76de589acc2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic3.zhimg.com/v2-e343149c0978699a730da76de589acc2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e343149c0978699a730da76de589acc2_b.jpg\"/></figure><p>可以用help(算子名)来查看对应的API文档，查看更详细的用法和例子：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/geatpy-dev/geatpy/tree/master/geatpy/doc/Geatpy-API\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/geatpy-dev/g</span><span class=\"invisible\">eatpy/tree/master/geatpy/doc/Geatpy-API</span><span class=\"ellipsis\"></span></a><p>下面讲一下理论：</p><p><b>1.选择：</b></p><p>在进化算法中存在两个阶段的选择。第一次是常被称为“抽样”的交配个体的选择。这个阶段的选择可以是基于个体适应度的、也可以是完全随机地选择交配个体。一旦个体被选中，那么它们就会参与交叉、变异等进化操作。未被选中的个体不会参与到进化操作中。</p><p>第二次是常被称为“重插入”或“环境选择”的选择，它是指在个体经过交叉、变异等进化操作所形成的子代（或称“育种个体”）后用某种方法来保留到下一代从而形成新一代种群的过程。这个选择过程对应的是生物学中的” 自然选择”。它可以是显性地根据适应度（再次注意：适应度并不等价于目标函数值）来进行选择的，也可以是隐性地根据适应度（即不刻意去计算个体适应度）来选择。例如在多目标优化的NSGA-II 算法中，父代与子代合并后，处于帕累托分层中第一层级的个体以及处于临界层中的<br/>且拥挤距离最大的若干个个体被保留到下一代。这个过程就没有显性地去计算每个个体的适应度。</p><p>经典的选择算子有：“轮盘赌选择”、“随机抽样选择”、“锦标赛选择”、“本地选择”、“截断选择”、“一对一生存者竞争选择”等等，这里不展开叙述了，可以参考：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/2019/07/28/%25E7%25AC%25AC%25E5%259B%259B%25E7%25AB%25A0%25EF%25BC%259A%25E9%2580%2589%25E6%258B%25A9/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">第四章：选择</a><p><b>这里要注意</b>：遗传算法选择出的后代是可以有重复的。</p><p>下面以低级选择函数：锦标赛选择算子(tour)为例，使用help(tour)查看其API，得到：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6026ba7f4f4bf10d0147502082171783_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1093\" data-rawheight=\"658\" class=\"origin_image zh-lightbox-thumb\" width=\"1093\" data-original=\"https://pic4.zhimg.com/v2-6026ba7f4f4bf10d0147502082171783_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1093&#39; height=&#39;658&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1093\" data-rawheight=\"658\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1093\" data-original=\"https://pic4.zhimg.com/v2-6026ba7f4f4bf10d0147502082171783_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6026ba7f4f4bf10d0147502082171783_b.jpg\"/></figure><p>实战演练如下：</p><p>代码6：</p><div class=\"highlight\"><pre><code class=\"language-text\">import numpy as np\nfrom geatpy import tour\n\nhelp(tour)\nFitnV = np.array([[1.2],[0.8],[2.1], [3.2],[0.6],[2.2],[1.7],[0.2]])\nchooseIdx = tour(FitnV, 6)\nprint(&#39;个体的适应度为：\\n&#39;, FitnV)\nprint(&#39;选择出的个体的下标为：\\n&#39;, chooseIdx)</code></pre></div><p>运行结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bdebd5caa29746eeef723ba3357c6e4d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"259\" data-rawheight=\"332\" class=\"content_image\" width=\"259\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;259&#39; height=&#39;332&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"259\" data-rawheight=\"332\" class=\"content_image lazy\" width=\"259\" data-actualsrc=\"https://pic2.zhimg.com/v2-bdebd5caa29746eeef723ba3357c6e4d_b.jpg\"/></figure><p>光这样还不够，这里只是得出了选择个体的下标，如果我们需要得到被选中个体的染色体，同时尝试改用高级选择函数“selecting”来调用低级选择算子“tour”来进行选择，则可以如下操作：</p><p>代码7：</p><div class=\"highlight\"><pre><code class=\"language-text\">import numpy as np\nfrom geatpy import selecting\n\nhelp(selecting)\nChrom=np.array([[1,11,21],\n[2,12,22],\n[3,13,23],\n[4,14,24],\n[5,15,25],\n[6,16,26],\n[7,17,27],\n[8,18,28]])\n\nFitnV = np.array([[1.2],[0.8],[2.1], [3.2],[0.6],[2.2],[1.7],[0.2]])\nSelCh = Chrom[selecting(&#39;tour&#39;, FitnV, 6), :] # 使用&#39;tour&#39;锦标赛选择算子，同时片取Chrom得到所选择个体的染色体\nprint(&#39;个体的适应度为：\\n&#39;, FitnV)\nprint(&#39;选择后得到的种群染色矩阵为：\\n&#39;, SelCh)</code></pre></div><p>代码7运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-933638e359fe381b3a72e1e5ae5b8ec3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"381\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;381&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"381\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic4.zhimg.com/v2-933638e359fe381b3a72e1e5ae5b8ec3_b.jpg\"/></figure><p>将代码7中的&#39;tour&#39;换成工具箱中的其他选择算子的名称（如etour, rws, sus），就可以使用相应的选择算子进行选择。</p><p><b>2.重组</b>：</p><p>在很多的国内教材、博客文章、论文中，只提到“交叉”的概念。事实上，遗传算法的“交叉”是属于“重组”算子里面的。因为交叉算子经常使用，而对于“离散重组”、“中间重组”、“线性重组”等等，因为用的很少，所以我们常常只谈“交叉”算子了。交叉算子实际上是“值互换重组”(Values exchanged recombination)。这里就不展开叙述了，可以参考：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/2019/07/28/%25E7%25AC%25AC%25E4%25BA%2594%25E7%25AB%25A0%25EF%25BC%259A%25E9%2587%258D%25E7%25BB%2584/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">第五章：重组</a><p>与重组有关的遗传算法参数是“重组概率”（对于交叉而言就是“交叉概率”）(Pc)，它是指两个个体的染色体之间发生重组的概率。</p><p>下面以两点交叉(xovdp)为例，类似上面的“tour”那样我们使用help(xovdp)查看其API：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-106cef8d746d07646923620553762d89_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"676\" class=\"origin_image zh-lightbox-thumb\" width=\"956\" data-original=\"https://pic2.zhimg.com/v2-106cef8d746d07646923620553762d89_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;956&#39; height=&#39;676&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"676\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"956\" data-original=\"https://pic2.zhimg.com/v2-106cef8d746d07646923620553762d89_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-106cef8d746d07646923620553762d89_b.jpg\"/></figure><p>代码实战演练如下：</p><p>代码8：</p><div class=\"highlight\"><pre><code class=\"language-text\">from geatpy import xovdp\nimport numpy as np\n\nhelp(xovdp)\nOldChrom=np.array([[1,1,1,1,1],[1,1,1,1,1],[0,0,0,0,0],[0,0,0,0,0]]) #创建一个二进制种群染色体矩阵\nprint(&#39;交叉前种群染色矩阵为：\\n&#39;, OldChrom)\nNewChrom = xovdp(OldChrom, 1) # 设交叉概率为1\nprint(&#39;交叉后种群染色矩阵为：\\n&#39;, NewChrom)</code></pre></div><p>代码8运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9b540c01a930ee2e2c8001d268460f8a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"302\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"302\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-9b540c01a930ee2e2c8001d268460f8a_b.jpg\"/></figure><p>由此可见，xovdp是将前一半个体和后一半个体进行配对交叉的，有人认为应该随机选择交叉个体。事实上，在遗传算法进化过程中，各个位置的个体是什么，本身是随机的，不必要在交叉这里再增添一个随机（当然，可以在执行xovdp两点交叉之前，将种群染色体矩阵按行打乱顺序然后再交叉，从而满足自身需求）。</p><p><b>3.变异</b>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0b4417325f0b4d027d4e97aa5d11c520_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1144\" data-rawheight=\"361\" class=\"origin_image zh-lightbox-thumb\" width=\"1144\" data-original=\"https://pic1.zhimg.com/v2-0b4417325f0b4d027d4e97aa5d11c520_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1144&#39; height=&#39;361&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1144\" data-rawheight=\"361\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1144\" data-original=\"https://pic1.zhimg.com/v2-0b4417325f0b4d027d4e97aa5d11c520_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0b4417325f0b4d027d4e97aa5d11c520_b.jpg\"/></figure><p>下面以均匀突变(mutuni)为例，编写代码实现实数值编码的种群染色体的实值突变，使用help(mutuni)查看API文档。</p><p>代码9：</p><div class=\"highlight\"><pre><code class=\"language-text\">from mutuni import mutuni\nimport numpy as np\n# 自定义种群染色体矩阵，表示有3个个体，且染色体元素直接表示变量的值（即实值编码）\nOldChrom = np.array([[9,10],\n                     [10,10],\n                     [10,10]])\n# 创建区域描述器（又称译码矩阵）\nFieldDR = np.array([[7,8],\n                    [10,10],\n                    [1, 1]])\n# 此处设编码方式为实值编码中的“实整数编码”RI，表示染色体可代表实数和整数\nNewChrom = mutuni(&#39;RI&#39;, OldChrom, FieldDR, 1)\nprint(NewChrom)</code></pre></div><p>代码9的运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8f96433a3eb627e1387751374d181ba5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"120\" class=\"content_image\" width=\"279\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;279&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"279\" data-actualsrc=\"https://pic2.zhimg.com/v2-8f96433a3eb627e1387751374d181ba5_b.jpg\"/></figure><p><b>4.重插入</b>：</p><p>经典遗传算法通过选择、重组和变异后，我们得到的是育种后代，此时育种后代的个体数有可能会跟父代种群的个体数不相同。这时，为了保持种群的规模，这些育种后代可以重新插入到父代中，替换父代种群的一部分个体，或者丢弃一部分育种个体，最终形成新一代种群。前面曾提到过“重插入”也是一种选择，但它是环境选择、是用于生成新一代种群的；而前面在交叉变异之前的选择是用于选择个体参与交叉变异，那个选择常被称作“抽样”。</p><p>现考虑使用精英个体保留的遗传算法“EGA”，则重插入操作如下：</p><p>代码10：</p><div class=\"highlight\"><pre><code class=\"language-text\">from mutuni import mutuni\nimport numpy as np\n# 自定义父代种群染色体（仅作为例子）：\nChrom = np.array([[1.1, 1.3],\n                  [2.4, 1.2],\n                  [3,   2.1],\n                  [4,   3.1]])\n# 若父代个体的适应度为：\nFitnV = np.array([[1],\n                 [2],\n                 [3],\n                 [4]])\n# 考虑采用“精英保留策略”的遗传算法，此时从父代选择出4-1=3个个体，经过交叉变异后假设子代的染色体为：\noffChrom = np.array([[2.1, 2.3],\n                     [2.3, 2.2],\n                     [3.4, 1.1]])\n# 假设直接把目标函数值当作适应度，且认为适应度越大越好。则通过以下代码重插入生成新一代种群：\nbestIdx = np.argmax(FitnV) # 得到父代精英个体的索引\nNewChrom = np.vstack([Chrom[bestIdx, :], offChrom]) # 得到新一代种群的染色体矩阵\nprint(&#39;新一代种群的染色体矩阵为：\\n&#39;, NewChrom)</code></pre></div><p>在“EGA”中，假设父代种群规模为N，则选择出(N-1)个个体进行交叉变异，然后找出父代的精英个体，用着个精英个体和交叉变异得到的子代个体进行“拼合”，得到新一代种群。</p><p>除了这种重插入生成新一代种群的方法外，还有“父子两代个体合并选择”等更优秀的生成新一代种群的方法，这里就不一一赘述了。</p><p>讲完上面的基本术语以及遗传算法基本算子后，我们就可以来利用遗传算法的“套路”编写一个遗传算法求解问题的程序了：</p><h3>三.完整实现遗传算法：</h3><p>上文提到遗传算法程序可以写成这个样子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-09da7a2f2385d687bb9deb84840106ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"531\" class=\"origin_image zh-lightbox-thumb\" width=\"1177\" data-original=\"https://pic4.zhimg.com/v2-09da7a2f2385d687bb9deb84840106ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1177&#39; height=&#39;531&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"531\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1177\" data-original=\"https://pic4.zhimg.com/v2-09da7a2f2385d687bb9deb84840106ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-09da7a2f2385d687bb9deb84840106ef_b.jpg\"/></figure><p>其核心是算法模板类。在遗传算法模板里，我们根据遗传算法的“套路”，进行：初始化种群、目标函数值计算、适应度评价、选择、重组、变异、记录各代最优个体等操作。geatpy工具箱内置有开源的“套路模板”，源代码参见：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/geatpy-dev/geatpy/tree/master/geatpy/source-code/templets\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/geatpy-dev/g</span><span class=\"invisible\">eatpy/tree/master/geatpy/source-code/templets</span><span class=\"ellipsis\"></span></a><p>这些内置算法模板有详细的输入输出参数说明，以及遗传算法整个流程的完整注释，它们可以应对简单或复杂的、单目标优化的、多目标优化的、约束优化的、组合优化的等等的问题。</p><p><b>但为了学习，我这里先不采用框架，直接利用工具箱提供的库函数来写一个带精英个体保留的遗传算法。这样代码量比较大，但有利于入门。</b></p><p>编写代码 11、12，分别放在同一个文件夹下：</p><p>代码11（目标函数aimfuc.py）（这里要回顾一下前面，Phen是种群表现型矩阵，存储的是种群所有个体的表现型，而不是单个个体。因而计算得到的目标函数值矩阵也是包含所有个体的目标函数值）：</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf-8 -*-\n&#34;&#34;&#34;\naimfunc.py - 目标函数文件\n描述:\n    目标：max f = 21.5 + x1 * np.sin(4 * np.pi * x1) + x2 * np.sin(20 * np.pi * x2)\n    约束条件：\n        x1 != 10\n        x2 != 5\n        x1 ∈ [-3, 12.1] # 变量范围是写在遗传算法的参数设置里面\n        x2 ∈ [4.1, 5.8]\n&#34;&#34;&#34;\n\nimport numpy as np\n\ndef aimfunc(Phen, CV):\n    x1 = Phen[:, [0]] # 获取表现型矩阵的第一列，得到所有个体的x1的值\n    x2 = Phen[:, [1]]\n    f = 21.5 + x1 * np.sin(4 * np.pi * x1) + x2 * np.sin(20 * np.pi * x2)\n    exIdx1 = np.where(x1 == 10)[0] # 因为约束条件之一是x1不能为10，这里把x1等于10的个体找到\n    exIdx2 = np.where(x2 == 5)[0]\n    CV[exIdx1] = 1\n    CV[exIdx2] = 1\n    return [f, CV]</code></pre></div><p>然后是编写算法：</p><p>代码12：</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf-8 -*-\n&#34;&#34;&#34;main.py&#34;&#34;&#34;\nimport numpy as np\nimport geatpy as ea # 导入geatpy库\nfrom aimfunc import aimfunc # 导入自定义的目标函数\nimport time\n\n&#34;&#34;&#34;============================变量设置============================&#34;&#34;&#34;\nx1 = [-3, 12.1] # 第一个决策变量范围\nx2 = [4.1, 5.8] # 第二个决策变量范围\nb1 = [1, 1] # 第一个决策变量边界，1表示包含范围的边界，0表示不包含\nb2 = [1, 1] # 第二个决策变量边界，1表示包含范围的边界，0表示不包含\nranges=np.vstack([x1, x2]).T # 生成自变量的范围矩阵，使得第一行为所有决策变量的下界，第二行为上界\nborders=np.vstack([b1, b2]).T # 生成自变量的边界矩阵\nvarTypes = np.array([0, 0]) # 决策变量的类型，0表示连续，1表示离散\n&#34;&#34;&#34;==========================染色体编码设置=========================&#34;&#34;&#34;\nEncoding = &#39;BG&#39; # &#39;BG&#39;表示采用二进制/格雷编码\ncodes = [0, 0] # 决策变量的编码方式，设置两个0表示两个决策变量均使用二进制编码\nprecisions =[4, 4] # 决策变量的编码精度，表示二进制编码串解码后能表示的决策变量的精度可达到小数点后6位\nscales = [0, 0] # 0表示采用算术刻度，1表示采用对数刻度\nFieldD = ea.crtfld(Encoding,varTypes,ranges,borders,precisions,codes,scales) # 调用函数创建译码矩阵\n&#34;&#34;&#34;=========================遗传算法参数设置========================&#34;&#34;&#34;\nNIND      = 100; # 种群个体数目\nMAXGEN    = 200; # 最大遗传代数\nmaxormins = [-1] # 列表元素为1则表示对应的目标函数是最小化，元素为-1则表示对应的目标函数是最大化\nselectStyle = &#39;rws&#39; # 采用轮盘赌选择\nrecStyle  = &#39;xovdp&#39; # 采用两点交叉\nmutStyle  = &#39;mutbin&#39; # 采用二进制染色体的变异算子\npc        = 0.7 # 交叉概率\npm        = 1 # 整条染色体的变异概率（每一位的变异概率=pm/染色体长度）\nLind = int(np.sum(FieldD[0, :])) # 计算染色体长度\nobj_trace = np.zeros((MAXGEN, 2)) # 定义目标函数值记录器\nvar_trace = np.zeros((MAXGEN, Lind)) # 染色体记录器，记录历代最优个体的染色体\n&#34;&#34;&#34;=========================开始遗传算法进化========================&#34;&#34;&#34;\nstart_time = time.time() # 开始计时\nChrom = ea.crtpc(Encoding, NIND, FieldD) # 生成种群染色体矩阵\nvariable = ea.bs2real(Chrom, FieldD) # 对初始种群进行解码\nCV = np.zeros((NIND, 1)) # 初始化一个CV矩阵（此时因为未确定个体是否满足约束条件，因此初始化元素为0，暂认为所有个体是可行解个体）\nObjV, CV = aimfunc(variable, CV) # 计算初始种群个体的目标函数值\nFitnV = ea.ranking(maxormins * ObjV, CV) # 根据目标函数大小分配适应度值\nbest_ind = np.argmax(FitnV) # 计算当代最优个体的序号\n# 开始进化\nfor gen in range(MAXGEN):\n    SelCh = Chrom[ea.selecting(selectStyle,FitnV,NIND-1),:] # 选择\n    SelCh = ea.recombin(recStyle, SelCh, pc) # 重组\n    SelCh = ea.mutate(mutStyle, Encoding, SelCh, pm) # 变异\n    # 把父代精英个体与子代的染色体进行合并，得到新一代种群\n    Chrom = np.vstack([Chrom[best_ind, :], SelCh])\n    Phen = ea.bs2real(Chrom, FieldD) # 对种群进行解码(二进制转十进制)\n    ObjV, CV = aimfunc(Phen, CV) # 求种群个体的目标函数值\n    FitnV = ea.ranking(maxormins * ObjV, CV) # 根据目标函数大小分配适应度值\n    # 记录\n    best_ind = np.argmax(FitnV) # 计算当代最优个体的序号\n    obj_trace[gen,0]=np.sum(ObjV)/ObjV.shape[0] #记录当代种群的目标函数均值\n    obj_trace[gen,1]=ObjV[best_ind] #记录当代种群最优个体目标函数值\n    var_trace[gen,:]=Chrom[best_ind,:] #记录当代种群最优个体的染色体\n# 进化完成\nend_time = time.time() # 结束计时\nea.trcplot(obj_trace, [[&#39;种群个体平均目标函数值&#39;, &#39;种群最优个体目标函数值&#39;]]) # 绘制图像\n&#34;&#34;&#34;============================输出结果============================&#34;&#34;&#34;\nbest_gen = np.argmax(obj_trace[:, [1]])\nprint(&#39;最优解的目标函数值：&#39;, obj_trace[best_gen, 1])\nvariable = ea.bs2real(var_trace[[best_gen], :], FieldD) # 解码得到表现型（即对应的决策变量值）\nprint(&#39;最优解的决策变量值为：&#39;)\nfor i in range(variable.shape[1]):\n    print(&#39;x&#39;+str(i)+&#39;=&#39;,variable[0, i])\nprint(&#39;用时：&#39;, end_time - start_time, &#39;秒&#39;)</code></pre></div><p>执行代码12得到如下结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-32f97227ccdcebdd3427a7b6cf9224f1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"423\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"423\" data-original=\"https://pic2.zhimg.com/v2-32f97227ccdcebdd3427a7b6cf9224f1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;423&#39; height=&#39;398&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"423\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"423\" data-original=\"https://pic2.zhimg.com/v2-32f97227ccdcebdd3427a7b6cf9224f1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-32f97227ccdcebdd3427a7b6cf9224f1_b.jpg\"/></figure><p><b>终于，我们把遗传算法完整地实现了，但扩展性还不够高</b>。下面学习下如何使用Geatpy提供的进化算法框架来求解上述问题，关于使用框架来优化的介绍可详见：</p><a href=\"https://link.zhihu.com/?target=http%3A//geatpy.com/index.php/geatpy%25E6%2595%2599%25E7%25A8%258B/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Geatpy教程</a><p>在这里我们可以回顾以下在本文开头提到的采用遗传算法的“套路”来编程求解问题的基本流程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-33dab6519c73dbfe1f60c0045f2a6ed6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1187\" data-rawheight=\"548\" class=\"origin_image zh-lightbox-thumb\" width=\"1187\" data-original=\"https://pic3.zhimg.com/v2-33dab6519c73dbfe1f60c0045f2a6ed6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1187&#39; height=&#39;548&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1187\" data-rawheight=\"548\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1187\" data-original=\"https://pic3.zhimg.com/v2-33dab6519c73dbfe1f60c0045f2a6ed6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-33dab6519c73dbfe1f60c0045f2a6ed6_b.jpg\"/></figure><p>其中执行脚本和问题类是需要编写的，算法模板类我直接调用Geatpy内置的&#34;soea_EGA_templet&#34;（带精英个体保留的单目标遗传算法模板）。下面开始编写代码：</p><p>代码13：问题类&#34;MyProblem&#34;的编写：</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf-8 -*-\n&#34;&#34;&#34;\nMyProblem.py\n该案例展示了一个简单的连续型决策变量最大化目标的单目标优化问题。\nmax f = x * np.sin(10 * np.pi * x) + 2.0\ns.t.\n-1 &lt;= x &lt;= 2\n&#34;&#34;&#34;\n\nimport numpy as np\nimport geatpy as ea\n\nclass MyProblem(ea.Problem): # 继承Problem父类\n    def __init__(self):\n        name = &#39;MyProblem&#39; # 初始化name（函数名称，可以随意设置）\n        M = 1 # 初始化M（目标维数）\n        maxormins = [-1] # 初始化maxormins（目标最小最大化标记列表，1：最小化该目标；-1：最大化该目标）\n        Dim = 2 # 初始化Dim（决策变量维数）\n        varTypes = [0] * Dim # 初始化varTypes（决策变量的类型，元素为0表示对应的变量是连续的；1表示是离散的）\n        lb = [-3, 4.1] # 决策变量下界\n        ub = [12.1, 5.8] # 决策变量上界\n        lbin = [1] * Dim # 决策变量下边界\n        ubin = [1] * Dim # 决策变量上边界\n        # 调用父类构造方法完成实例化\n        ea.Problem.__init__(self, name, M, maxormins, Dim, varTypes, lb, ub, lbin, ubin)\n    \n    def aimFunc(self, pop): # 目标函数\n        x1 = pop.Phen[:, [0]] # 获取表现型矩阵的第一列，得到所有个体的x1的值\n        x2 = pop.Phen[:, [1]]\n        f = 21.5 + x1 * np.sin(4 * np.pi * x1) + x2 * np.sin(20 * np.pi * x2)\n        exIdx1 = np.where(x1 == 10)[0] # 因为约束条件之一是x1不能为10，这里把x1等于10的个体找到\n        exIdx2 = np.where(x2 == 5)[0]\n        pop.CV[exIdx1] = 1\n        pop.CV[exIdx2] = 1\n        pop.ObjV = f # 计算目标函数值，赋值给pop种群对象的ObjV属性\n   </code></pre></div><p>第二步：编写执行脚本“main.py”</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf-8 -*-\n&#34;&#34;&#34;main.py&#34;&#34;&#34;\nimport numpy as np\nimport geatpy as ea # import geatpy\nfrom MyProblem import MyProblem # 导入自定义问题接口\n\n&#34;&#34;&#34;==================================实例化问题对象================================&#34;&#34;&#34;\nproblem = MyProblem() # 生成问题对象\n&#34;&#34;&#34;==================================种群设置================================&#34;&#34;&#34;\nEncoding = &#39;BG&#39;       # 编码方式\nNIND = 100            # 种群规模\nField = ea.crtfld(Encoding, problem.varTypes, problem.ranges, problem.borders) # 创建区域描述器\npopulation = ea.Population(Encoding, Field, NIND) # 实例化种群对象（此时种群还没被初始化，仅仅是完成种群对象的实例化）\n&#34;&#34;&#34;==================================算法参数设置================================&#34;&#34;&#34;\nmyAlgorithm = ea.soea_EGA_templet(problem, population) # 实例化一个算法模板对象\nmyAlgorithm.MAXGEN = 200 # 最大进化代数\n&#34;&#34;&#34;=======================调用算法模板进行种群进化==============================&#34;&#34;&#34;\n[population, obj_trace, var_trace] = myAlgorithm.run() # 执行算法模板\npopulation.save() # 把最后一代种群的信息保存到文件中\n# 输出结果\nbest_gen = np.argmax(obj_trace[:, 1]) # 记录最优种群是在哪一代\nbest_ObjV = obj_trace[best_gen, 1]\nprint(&#39;最优的目标函数值为：%s&#39;%(best_ObjV))\nprint(&#39;最优的控制变量值为：&#39;)\nfor i in range(var_trace.shape[1]):\n    print(var_trace[best_gen, i])\nprint(&#39;有效进化代数：%s&#39;%(obj_trace.shape[0]))\nprint(&#39;最优的一代是第 %s 代&#39;%(best_gen + 1))\nprint(&#39;评价次数：%s&#39;%(myAlgorithm.evalsNum))\nprint(&#39;时间已过 %s 秒&#39;%(myAlgorithm.passTime))</code></pre></div><p>运行&#34;main.py&#34;执行脚本即可得到以下结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5509c68d749045cf8db5a09b4f3cf2e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"494\" class=\"content_image\" width=\"409\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;409&#39; height=&#39;494&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"494\" class=\"content_image lazy\" width=\"409\" data-actualsrc=\"https://pic3.zhimg.com/v2-5509c68d749045cf8db5a09b4f3cf2e6_b.jpg\"/></figure><p><b>代码解析</b>：在“main.py”执行脚本中，一开始需要实例化一个问题对象。然后是种群对象的实例化。在实例化种群对象前，需要设定种群的编码方式Encoding、种群规模NIND，并且生成区域描述器Field（或称译码矩阵），因为种群类的构造方法中需要至少用到这三个参数（详见“Population.py”中种群类的构造方法）。</p><p>在完成了问题类对象和种群对象的实例化后，将其传入算法模板类的构造方法来实例化一个算法模板对象。这里我实例化的是单目标优化的EGA算法（即带精英个体保留的遗传算法）的模板类对象，即代码中的&#34;soea_EGA_templet&#34;。里面的进化算法具体是如何操作的，可详见</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/geatpy-dev/geatpy/blob/master/geatpy/templates/soeas/GA/EGA/soea_EGA_templet.py\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/geatpy-dev/g</span><span class=\"invisible\">eatpy/blob/master/geatpy/templates/soeas/GA/EGA/soea_EGA_templet.py</span><span class=\"ellipsis\"></span></a><p>采用Geatpy提供的进化算法框架可以既能最大程度地描述清楚所要求解的问题，而且与进化算法是高度脱耦的，即上面在编写问题类的时候完全不需要管后面采用什么算法、采用什么样编码的种群，只需把问题描述清楚即可。</p><p>而且，遗传算法有个好处是：目标函数可以写得相当复杂，可以解决各种复杂的问题，比如神经网络。以BP神经网络为例，可以把神经网络的参数作为决策变量，神经网络的训练误差作为目标函数值，只需把上面的例子修改一下就行了。</p><p>而且，一般而言我们不需要像我刚刚最开始那样刻意去手写进化算法，可以直接调用geatpy内置的算法模板就可以解决问题了。geatpy工具箱提供这些内置的算法模板：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3b88f9ae95d26e8f4cc42e2174860211_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"943\" class=\"origin_image zh-lightbox-thumb\" width=\"561\" data-original=\"https://pic2.zhimg.com/v2-3b88f9ae95d26e8f4cc42e2174860211_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;561&#39; height=&#39;943&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"943\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"561\" data-original=\"https://pic2.zhimg.com/v2-3b88f9ae95d26e8f4cc42e2174860211_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3b88f9ae95d26e8f4cc42e2174860211_b.jpg\"/></figure><p>应用Geatpy求解数学建模、工业设计、资源调度等实际优化问题的的朋友们可以直接使用这些算法模板快速解决各种灵活的优化问题。</p><h3>四.后记：</h3><p>最后十分欣赏由Geatpy团队提供的高性能实用型遗传和进化算法工具箱，它提供开源的进化算法框架为遗传算法求解单目标/多目标优化、约束优化、组合优化等等给出了相当准确和快捷的解决方案。据称，<b>geatpy</b>的运行性能相当的高，远高于matlab的遗传算法工具箱、以及采用JAVA、matlab或者Python编写的一些进化优化平台或框架，比如jMetal、platemo、pymoo、deap等，后面有时间我将进行详细的性能对比实验分析，有相关经验的读者也可以自行对比性能。而且依我的体验来看，这是我网上到处找代码、找资料学习、碰了无数次壁后所看到的比较易学易用的工具箱了。</p><p>最后值得注意的是Geatpy的顶层是面向对象的进化算法框架，底层是面向过程的进化算子。下面放一张<b>geatpy</b>的UML类图、算法调用的层次结构和库函数调用关系图，以此记录方便查看：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6aad67cc5b4db05188c4ed8f2d317ffd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1828\" data-rawheight=\"873\" class=\"origin_image zh-lightbox-thumb\" width=\"1828\" data-original=\"https://pic2.zhimg.com/v2-6aad67cc5b4db05188c4ed8f2d317ffd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1828&#39; height=&#39;873&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1828\" data-rawheight=\"873\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1828\" data-original=\"https://pic2.zhimg.com/v2-6aad67cc5b4db05188c4ed8f2d317ffd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6aad67cc5b4db05188c4ed8f2d317ffd_b.jpg\"/></figure><figure data-size=\"small\"><noscript><img src=\"https://pic2.zhimg.com/v2-25ae3fcdea801d72472b29fa3d64592d_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"910\" data-rawheight=\"923\" class=\"origin_image zh-lightbox-thumb\" width=\"910\" data-original=\"https://pic2.zhimg.com/v2-25ae3fcdea801d72472b29fa3d64592d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;910&#39; height=&#39;923&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"910\" data-rawheight=\"923\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"910\" data-original=\"https://pic2.zhimg.com/v2-25ae3fcdea801d72472b29fa3d64592d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-25ae3fcdea801d72472b29fa3d64592d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c19467c6a1f1fca958ca3854203a9216_b.jpg\" data-size=\"normal\" data-rawwidth=\"1081\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb\" width=\"1081\" data-original=\"https://pic3.zhimg.com/v2-c19467c6a1f1fca958ca3854203a9216_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1081&#39; height=&#39;651&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1081\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1081\" data-original=\"https://pic3.zhimg.com/v2-c19467c6a1f1fca958ca3854203a9216_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c19467c6a1f1fca958ca3854203a9216_b.jpg\"/><figcaption>Geatpy库函数调用图</figcaption></figure><p>下面附一张一位在职的朋友使用犀牛软件(Rhinoceros)结合<b>geatpy</b>工具箱进行产品优化设计的截图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-847ffc2780780099686c3f10f9e78722_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1212\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb\" width=\"1212\" data-original=\"https://pic3.zhimg.com/v2-847ffc2780780099686c3f10f9e78722_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1212&#39; height=&#39;513&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1212\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1212\" data-original=\"https://pic3.zhimg.com/v2-847ffc2780780099686c3f10f9e78722_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-847ffc2780780099686c3f10f9e78722_b.jpg\"/></figure><p>很多工程软件都提供Python接口，当需要用到进化优化时，就可以编写Python代码进行优化了。</p><p>后续我将继续学习和挖掘该工具箱的更多深入的用法。希望这篇文章在帮助自己记录学习点滴之余，也能帮助大家！</p>", 
            "topic": [
                {
                    "tag": "遗传算法", 
                    "tagLink": "https://api.zhihu.com/topics/19555677"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "演化计算", 
                    "tagLink": "https://api.zhihu.com/topics/20682806"
                }
            ], 
            "comments": [
                {
                    "userName": "柳橙", 
                    "userLink": "https://www.zhihu.com/people/cc11d364f03791198285d2469bbf71ea", 
                    "content": "<p>感谢，很详细很有用！</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "柳橙", 
                    "userLink": "https://www.zhihu.com/people/cc11d364f03791198285d2469bbf71ea", 
                    "content": "<p>请问代码13是不是没有贴出来?</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "haofeng", 
                            "userLink": "https://www.zhihu.com/people/61328b588d8bfae5a1c14f2845ba71b3", 
                            "content": "<p>已更新~</p>", 
                            "likes": 0, 
                            "replyToAuthor": "柳橙"
                        }
                    ]
                }, 
                {
                    "userName": "Dookie", 
                    "userLink": "https://www.zhihu.com/people/002d6218af0cbe478fb367801e7053a4", 
                    "content": "<p>官网教程没出哇</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "haofeng", 
                            "userLink": "https://www.zhihu.com/people/61328b588d8bfae5a1c14f2845ba71b3", 
                            "content": "<p>出了，我抓紧时间学习然后更新这篇文章。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Dookie"
                        }
                    ]
                }, 
                {
                    "userName": "街望", 
                    "userLink": "https://www.zhihu.com/people/7dd3110c86a1a1dbb2e7b006c67c8ad3", 
                    "content": "看了这么久的国外文档，能看到中国人自己写的这么优秀的库，太感动了[大哭]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80969579", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 6, 
            "title": "回归预测（1）--线性回归和多项式拟合", 
            "content": "<h2>一 线性回归</h2><p>线性回归，顾名思义是利用线性模型对数据点进行拟合的，常见的广义线性模型如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=f%28x%29%3Dw_1+x_1%2Bw_2+x_2%2B%E2%8B%AF%2Bw_d+x_d%2Bb\" alt=\"f(x)=w_1 x_1+w_2 x_2+⋯+w_d x_d+b\" eeimg=\"1\"/> </p><p>将上面的广义向量模型用向量的形式表示出来如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=+f%28x%29%3D%5Cbm%7Bw%7D%5ET%5Cbm%7BX%7D%2Bb+\" alt=\" f(x)=\\bm{w}^T\\bm{X}+b \" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=%5Cbm%7Bw%7D\" alt=\"\\bm{w}\" eeimg=\"1\"/> 为向量。</p><p>最简单也是最常见的线性回归是最小二乘法</p><h2>1.最小二乘法<sup data-text=\"周志华-机器学习（M）\" data-url=\"\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup></h2><p>最小二乘法是以均方误差为回归任务的性能度量，衡量预测值 <img src=\"https://www.zhihu.com/equation?tex=f%28x%29\" alt=\"f(x)\" eeimg=\"1\"/> 和真实值 <img src=\"https://www.zhihu.com/equation?tex=y\" alt=\"y\" eeimg=\"1\"/> 之间的差值。优化问题就可以用下式表示出来：</p><p><img src=\"https://www.zhihu.com/equation?tex=%28w%5E%2A%2Cb%5E%2A+%29%3Darg%E2%81%A1min%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28f%28x_i+%29-y_i%29%5E2%7D+\" alt=\"(w^*,b^* )=arg⁡min\\sum_{i=1}^{m}{(f(x_i )-y_i)^2} \" eeimg=\"1\"/> </p><p>从字面上理解最小二乘法就是试图找到一条直线，使所有样本到直线上的欧几里得距离之和最小。</p><p>这里有两个参数需要我们求解 <img src=\"https://www.zhihu.com/equation?tex=w%5E%2A\" alt=\"w^*\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=b%5E%2A\" alt=\"b^*\" eeimg=\"1\"/> ,其中 <img src=\"https://www.zhihu.com/equation?tex=b%5E%2A\" alt=\"b^*\" eeimg=\"1\"/> 为标量称为偏置， <img src=\"https://www.zhihu.com/equation?tex=w%5E%2A\" alt=\"w^*\" eeimg=\"1\"/> 为向量，其维数对应数据的维数(即大数据中的特征个数)。求解这两个参数的方法是对其求偏导。</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+E%28w%2C+b%29%7D%7B%5Cpartial+w%7D%3D2%5Cleft%28w+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+x_%7Bi%7D%5E%7B2%7D-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y_%7Bi%7D-b%5Cright%29+x_%7Bi%7D%5Cright%29\" alt=\"\\frac{\\partial E(w, b)}{\\partial w}=2\\left(w \\sum_{i=1}^{m} x_{i}^{2}-\\sum_{i=1}^{m}\\left(y_{i}-b\\right) x_{i}\\right)\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+E%28w%2C+b%29%7D%7B%5Cpartial+b%7D%3D2%5Cleft%28m+b-%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y_%7Bi%7D-w+x_%7Bi%7D%5Cright%29%5Cright%29\" alt=\"\\frac{\\partial E(w, b)}{\\partial b}=2\\left(m b-\\sum_{i=1}^{m}\\left(y_{i}-w x_{i}\\right)\\right)\" eeimg=\"1\"/> </p><p>令上式等于0得到w和b的最优解。</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cmathrm%7Bw%7D%3D%5Cfrac%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+y_%7Bi%7D%5Cleft%28x_%7Bi%7D-%5Coverline%7Bx%7D%5Cright%29%7D%7B%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+x_%7Bi%7D%5E%7B2%7D-%5Cfrac%7B1%7D%7Bm%7D%5Cleft%28%5Csum_%7Bi%3D1%7D%5E%7Bm%7D+x_%7Bi%7D%5Cright%29%5E%7B2%7D%7D\" alt=\"\\mathrm{w}=\\frac{\\sum_{i=1}^{m} y_{i}\\left(x_{i}-\\overline{x}\\right)}{\\sum_{i=1}^{m} x_{i}^{2}-\\frac{1}{m}\\left(\\sum_{i=1}^{m} x_{i}\\right)^{2}}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cmathrm%7Bb%7D%3D%5Cfrac%7B1%7D%7Bm%7D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%5Cleft%28y_%7Bi%7D-w+x_%7Bi%7D%5Cright%29\" alt=\"\\mathrm{b}=\\frac{1}{m} \\sum_{i=1}^{m}\\left(y_{i}-w x_{i}\\right)\" eeimg=\"1\"/> </p><p><b>代码实现：</b></p><p><b>（1）matlab代码</b></p><p>一般的这类问题的求解思路就是找出损失函数，这里我们考虑一般的情况，一般情况下的损失函数为：</p><p><img src=\"https://www.zhihu.com/equation?tex=J%28w%5E%2A%2Cb%5E%2A+%29%3Darg%E2%81%A1min%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28f%28x_i+%29-y_i%29%5E2%7D+%5C%5C%3Dargmin%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%28%7Bf%5E2%28x_i%29%2By_i%5E2-2f%28x_i%29y_i%7D%29\" alt=\"J(w^*,b^* )=arg⁡min\\frac{1}{2m}\\sum_{i=1}^{m}{(f(x_i )-y_i)^2} \\\\=argmin\\frac{1}{2m}\\sum_{i=1}^{m}({f^2(x_i)+y_i^2-2f(x_i)y_i})\" eeimg=\"1\"/> </p><p>再求出梯度（即一阶偏导），对于大多数问题是不能直接求出最大小值的，所以一般会用梯度下降法来求解，设置学习率 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> 进行更新。</p><p>权重<img src=\"https://www.zhihu.com/equation?tex=w\" alt=\"w\" eeimg=\"1\"/> 的梯度：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%28J%28w%5E%2A%2Cb%5E%2A%29%29%7D%7B%5Cpartial%28w%29%7D%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%282f%28x_i%29%5Cpartial%28f%28x_i%29%29-2y_i%5Cpartial%28f%28x_i%29%29%29%7D%5C%5C%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28w%5ETx_ix_i%5ET-%28y_i-b%29x_i%5ET%29%7D\" alt=\"\\frac{\\partial(J(w^*,b^*))}{\\partial(w)}=\\frac{1}{2m}\\sum_{i=1}^{m}{(2f(x_i)\\partial(f(x_i))-2y_i\\partial(f(x_i)))}\\\\=\\frac{1}{m}\\sum_{i=1}^{m}{(w^Tx_ix_i^T-(y_i-b)x_i^T)}\" eeimg=\"1\"/> </p><p>偏置 <img src=\"https://www.zhihu.com/equation?tex=b\" alt=\"b\" eeimg=\"1\"/> 的梯度：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial%28J%28w%5E%2A%2Cb%5E%2A%29%29%7D%7B%5Cpartial%28b%29%7D%3D%5Cfrac%7B1%7D%7B2m%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%282f%28x_i%29%5Cpartial%28f%28x_i%29%29-2y_i%5Cpartial%28f%28x_i%29%29%29%7D%5C%5C%3D%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28w%5ETx_i-y_i%2Bb%29%7D\" alt=\"\\frac{\\partial(J(w^*,b^*))}{\\partial(b)}=\\frac{1}{2m}\\sum_{i=1}^{m}{(2f(x_i)\\partial(f(x_i))-2y_i\\partial(f(x_i)))}\\\\=\\frac{1}{m}\\sum_{i=1}^{m}{(w^Tx_i-y_i+b)}\" eeimg=\"1\"/> </p><p>得到了权重w和偏置b的梯度就可以用梯度下降法来求出合适的w和b了。更新公式如下：</p><p>一般初始化w和b全为1，</p><p><img src=\"https://www.zhihu.com/equation?tex=w%3Dw-%5Calpha%2A%28%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28w%5ETx_ix_i%5ET-%28y_i-b%29x_i%5ET%29%7D%29\" alt=\"w=w-\\alpha*(\\frac{1}{m}\\sum_{i=1}^{m}{(w^Tx_ix_i^T-(y_i-b)x_i^T)})\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=b%3Db-%5Calpha%2A%28%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7B%28w%5ETx_i-y_i%2Bb%29%7D%29\" alt=\"b=b-\\alpha*(\\frac{1}{m}\\sum_{i=1}^{m}{(w^Tx_i-y_i+b)})\" eeimg=\"1\"/> </p><p>matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"c\">%随机生成数据</span>\n<span class=\"n\">clear</span> <span class=\"n\">all</span>\n<span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"mi\">2</span><span class=\"p\">)=</span><span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">[</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"o\">~</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n<span class=\"n\">r</span><span class=\"p\">=</span><span class=\"nb\">randn</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n   <span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">5</span><span class=\"o\">+</span><span class=\"n\">r</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n<span class=\"k\">end</span>\n<span class=\"n\">y</span><span class=\"p\">=</span><span class=\"n\">y</span><span class=\"s\">&#39;;\n</span><span class=\"s\">plot3(x(:,1),x(:,2),y,&#34;b*&#34;)\n</span><span class=\"s\">grid on\n</span><span class=\"s\">\n</span><span class=\"s\">function [w,b]=line_regress(x,y)\n</span><span class=\"s\">   [m,n]=size(x);\n</span><span class=\"s\">   w=zeros(n,1);\n</span><span class=\"s\">    b=1;\n</span><span class=\"s\">   alpha=0.07;\n</span><span class=\"s\">   MAX_DD=1500;\n</span><span class=\"s\">   for i=1:MAX_DD\n</span><span class=\"s\">       h=x*w;\n</span><span class=\"s\">       w=w-alpha*(1/m)*x&#39;</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">);</span>\n        <span class=\"n\">b</span><span class=\"p\">=</span><span class=\"n\">b</span><span class=\"o\">-</span><span class=\"n\">alpha</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">+</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"n\">m</span><span class=\"p\">);</span>\n   <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d8d6f0fab758edc21ef4bc2aec27b0c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"937\" class=\"origin_image zh-lightbox-thumb\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-d8d6f0fab758edc21ef4bc2aec27b0c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1920&#39; height=&#39;937&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"937\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-d8d6f0fab758edc21ef4bc2aec27b0c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d8d6f0fab758edc21ef4bc2aec27b0c1_b.jpg\"/></figure><p><b>（2）python--mxnet库的常规实现</b><sup data-text=\"\" data-url=\"http://zh.d2l.ai/chapter_deep-learning-basics/linear-regression-scratch.html\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">from</span> <span class=\"nn\">mxnet</span> <span class=\"k\">import</span> <span class=\"n\">nd</span>\n<span class=\"kn\">import</span> <span class=\"nn\">mxnet.autograd</span> <span class=\"k\">as</span> <span class=\"nn\">ag</span>\n<span class=\"kn\">from</span> <span class=\"nn\">IPython</span> <span class=\"k\">import</span> <span class=\"n\">display</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n\n<span class=\"c1\">#定义样本和特征数量</span>\n<span class=\"n\">num_sample</span><span class=\"o\">=</span><span class=\"mi\">1000</span>\n<span class=\"n\">num_feature</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"n\">weight</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"o\">-</span><span class=\"mf\">3.4</span><span class=\"p\">]</span>\n<span class=\"n\">b_true</span><span class=\"o\">=</span><span class=\"mf\">4.3</span>\n<span class=\"c1\">#生成随机数据</span>\n<span class=\"n\">feature</span><span class=\"o\">=</span><span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">num_sample</span><span class=\"p\">,</span><span class=\"n\">num_feature</span><span class=\"p\">))</span>\n<span class=\"n\">label</span><span class=\"o\">=</span><span class=\"n\">weight</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">feature</span><span class=\"p\">[:,</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">weight</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">*</span><span class=\"n\">feature</span><span class=\"p\">[:,</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">b_true</span>\n<span class=\"n\">label</span><span class=\"o\">+=</span><span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">label</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n<span class=\"k\">def</span> <span class=\"nf\">svg_fig</span><span class=\"p\">():</span>\n   <span class=\"c1\"># display.set_matplotlib_formats(&#39;svg&#39;)</span>\n  <span class=\"n\">display</span><span class=\"o\">.</span><span class=\"n\">display_svg</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">setfig_size</span><span class=\"p\">(</span><span class=\"n\">figsize</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mf\">3.5</span><span class=\"p\">,</span><span class=\"mf\">2.5</span><span class=\"p\">)):</span>\n    <span class=\"n\">svg_fig</span><span class=\"p\">()</span>\n    <span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">rcParams</span><span class=\"p\">[</span><span class=\"s2\">&#34;figure.figsize&#34;</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">figsize</span>\n<span class=\"n\">setfig_size</span><span class=\"p\">()</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">[:,</span><span class=\"mi\">1</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">asnumpy</span><span class=\"p\">(),</span><span class=\"n\">label</span><span class=\"o\">.</span><span class=\"n\">asnumpy</span><span class=\"p\">(),</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\">#plt.show()</span>\n<span class=\"n\">w</span><span class=\"o\">=</span><span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">num_feature</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,))</span>\n<span class=\"n\">w</span><span class=\"o\">.</span><span class=\"n\">attach_grad</span><span class=\"p\">()</span>\n<span class=\"n\">b</span><span class=\"o\">.</span><span class=\"n\">attach_grad</span><span class=\"p\">()</span>\n<span class=\"k\">def</span> <span class=\"nf\">Linreg</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">):</span>\n    <span class=\"k\">return</span> <span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">dot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">b</span>\n<span class=\"k\">def</span> <span class=\"nf\">squared_loss</span><span class=\"p\">(</span><span class=\"n\">y_hat</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span>  <span class=\"c1\"># 本函数已保存在d2lzh包中方便以后使用</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">y_hat</span> <span class=\"o\">-</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">y_hat</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">))</span> <span class=\"o\">**</span> <span class=\"mi\">2</span> <span class=\"o\">/</span> <span class=\"mi\">2</span>\n<span class=\"k\">def</span> <span class=\"nf\">sgd</span><span class=\"p\">(</span><span class=\"n\">params</span><span class=\"p\">,</span> <span class=\"n\">lr</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"p\">):</span>  <span class=\"c1\"># 本函数已保存在d2lzh包中方便以后使用</span>\n    <span class=\"k\">for</span> <span class=\"n\">param</span> <span class=\"ow\">in</span> <span class=\"n\">params</span><span class=\"p\">:</span>\n        <span class=\"n\">param</span><span class=\"p\">[:]</span> <span class=\"o\">=</span> <span class=\"n\">param</span> <span class=\"o\">-</span> <span class=\"n\">lr</span> <span class=\"o\">*</span> <span class=\"n\">param</span><span class=\"o\">.</span><span class=\"n\">grad</span> <span class=\"o\">/</span> <span class=\"n\">batch_size</span>\n<span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.03</span>\n<span class=\"n\">epochs</span><span class=\"o\">=</span><span class=\"mi\">1000</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">epochs</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">ag</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">():</span>\n        <span class=\"n\">l</span><span class=\"o\">=</span><span class=\"n\">squared_loss</span><span class=\"p\">(</span><span class=\"n\">Linreg</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">,</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">),</span><span class=\"n\">label</span><span class=\"p\">)</span>\n    <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">()</span>\n    <span class=\"n\">sgd</span><span class=\"p\">([</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">],</span><span class=\"n\">alpha</span><span class=\"p\">,</span><span class=\"n\">num_sample</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span></code></pre></div><p><b>（3）python --mxnet库的简单实现</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">from</span> <span class=\"nn\">mxnet</span> <span class=\"k\">import</span> <span class=\"n\">nd</span>\n<span class=\"kn\">import</span> <span class=\"nn\">mxnet.autograd</span> <span class=\"k\">as</span> <span class=\"nn\">ag</span>\n<span class=\"kn\">from</span> <span class=\"nn\">IPython</span> <span class=\"k\">import</span> <span class=\"n\">display</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">import</span> <span class=\"nn\">random</span>\n<span class=\"c1\">#定义样本和特征数量</span>\n<span class=\"n\">num_inputs</span> <span class=\"o\">=</span> <span class=\"mi\">2</span>\n<span class=\"n\">num_feature</span> <span class=\"o\">=</span> <span class=\"mi\">1000</span>\n<span class=\"n\">true_w</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mf\">3.4</span><span class=\"p\">]</span>\n<span class=\"n\">true_b</span> <span class=\"o\">=</span> <span class=\"mf\">4.2</span>\n<span class=\"n\">feature</span> <span class=\"o\">=</span> <span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">num_feature</span><span class=\"p\">,</span> <span class=\"n\">num_inputs</span><span class=\"p\">))</span>\n<span class=\"n\">label</span> <span class=\"o\">=</span> <span class=\"n\">true_w</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">feature</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">true_w</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"n\">feature</span><span class=\"p\">[:,</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">true_b</span>\n<span class=\"n\">label</span> <span class=\"o\">+=</span> <span class=\"n\">nd</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">normal</span><span class=\"p\">(</span><span class=\"n\">scale</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">,</span> <span class=\"n\">shape</span><span class=\"o\">=</span><span class=\"n\">label</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">)</span>\n<span class=\"c1\">#线性回归简洁实现</span>\n<span class=\"c1\">#1.数据处理</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mxnet.gluon</span> <span class=\"k\">import</span> <span class=\"n\">data</span> <span class=\"k\">as</span> <span class=\"n\">gdata</span>\n<span class=\"n\">data</span><span class=\"o\">=</span><span class=\"n\">gdata</span><span class=\"o\">.</span><span class=\"n\">ArrayDataset</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">,</span><span class=\"n\">label</span><span class=\"p\">)</span>\n\n<span class=\"c1\">#2.定义模型</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mxnet.gluon</span> <span class=\"k\">import</span> <span class=\"n\">nn</span>\n<span class=\"n\">net</span><span class=\"o\">=</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Sequential</span><span class=\"p\">()</span>\n<span class=\"n\">net</span><span class=\"o\">.</span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Dense</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mxnet</span> <span class=\"k\">import</span> <span class=\"n\">init</span>\n<span class=\"n\">net</span><span class=\"o\">.</span><span class=\"n\">initialize</span><span class=\"p\">(</span><span class=\"n\">init</span><span class=\"o\">.</span><span class=\"n\">Normal</span><span class=\"p\">(</span><span class=\"n\">sigma</span><span class=\"o\">=</span><span class=\"mf\">0.01</span><span class=\"p\">))</span>\n\n<span class=\"c1\">#3.定义损失函数</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mxnet.gluon</span> <span class=\"k\">import</span> <span class=\"n\">loss</span> <span class=\"k\">as</span> <span class=\"n\">gloss</span>\n<span class=\"n\">loss</span><span class=\"o\">=</span><span class=\"n\">gloss</span><span class=\"o\">.</span><span class=\"n\">L2Loss</span><span class=\"p\">()</span>\n\n<span class=\"c1\">#4.定义训练器</span>\n<span class=\"kn\">from</span> <span class=\"nn\">mxnet</span> <span class=\"k\">import</span> <span class=\"n\">gluon</span>\n<span class=\"n\">trainer</span><span class=\"o\">=</span><span class=\"n\">gluon</span><span class=\"o\">.</span><span class=\"n\">Trainer</span><span class=\"p\">(</span><span class=\"n\">net</span><span class=\"o\">.</span><span class=\"n\">collect_params</span><span class=\"p\">(),</span><span class=\"s1\">&#39;sgd&#39;</span><span class=\"p\">,{</span><span class=\"s1\">&#39;learning_rate&#39;</span><span class=\"p\">:</span><span class=\"mf\">0.03</span><span class=\"p\">})</span>\n<span class=\"n\">epchos</span><span class=\"o\">=</span><span class=\"mi\">1000</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">epchos</span><span class=\"p\">):</span>\n    <span class=\"k\">with</span> <span class=\"n\">ag</span><span class=\"o\">.</span><span class=\"n\">record</span><span class=\"p\">():</span>\n       <span class=\"n\">l</span><span class=\"o\">=</span><span class=\"n\">loss</span><span class=\"p\">(</span><span class=\"n\">net</span><span class=\"p\">(</span><span class=\"n\">feature</span><span class=\"p\">),</span><span class=\"n\">label</span><span class=\"p\">)</span>\n    <span class=\"n\">l</span><span class=\"o\">.</span><span class=\"n\">backward</span><span class=\"p\">()</span>\n    <span class=\"n\">trainer</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">(</span><span class=\"n\">num_feature</span><span class=\"p\">)</span>\n<span class=\"n\">dense</span><span class=\"o\">=</span><span class=\"n\">net</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"n\">w</span><span class=\"o\">=</span><span class=\"n\">dense</span><span class=\"o\">.</span><span class=\"n\">weight</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">()</span>\n<span class=\"n\">b</span><span class=\"o\">=</span><span class=\"n\">dense</span><span class=\"o\">.</span><span class=\"n\">bias</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">,</span><span class=\"n\">b</span><span class=\"p\">)</span></code></pre></div><h2>二 多项式拟合</h2><p>前面的线性回归是一种多元回归问题，每个样本对应于多个特征，在前面的例子中，特征之前的值相差不大，所以没有做特征缩放，实际上严格的执行是需要特征缩放的因为有些特征值之间的量纲不同差距很大，如吴恩达的机器学习系类视频中<sup data-text=\"吴恩达机器学习\" data-url=\"https://www.bilibili.com/video/av50747658/?p=22\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup>的例子，假设房屋的价格和房屋的面积及房屋的卧室数量有关，但是这两个特征之间值相差很大，这个时候直接用上面的线性回归时，将出现问题，所以必须进行特征缩放，一般特征缩放有两种计算方式。</p><p>（1）<b>Z-score normalization</b>，量化后的特征将服从标准正态分布：</p><p><img src=\"https://www.zhihu.com/equation?tex=z+%3D+%5Cfrac%7Bx_i-%5Cmu%7D%7B%5Cdelta%7D\" alt=\"z = \\frac{x_i-\\mu}{\\delta}\" eeimg=\"1\"/> </p><p>（2）<b>Min-Max Scaling</b>，特征量化：</p><p><img src=\"https://www.zhihu.com/equation?tex=z+%3D+%5Cfrac%7Bx_i-min%28x_i%29%7D%7Bmax%28x_i%29-min%28x_i%29%7D\" alt=\"z = \\frac{x_i-min(x_i)}{max(x_i)-min(x_i)}\" eeimg=\"1\"/> </p><p>在大部分的机器学习中用的比较多的时第一种量化方法。</p><p>多项式拟合是一种典型的需要特征缩放的例子，一般解决的是一元多项式的数据拟合问题，形如：</p><p><img src=\"https://www.zhihu.com/equation?tex=y%3Dw_0%2Bw_1%2Ax%2Bw_2%2Ax%5E2%2B%E2%80%A6%2Bw_n%2Ax%5En\" alt=\"y=w_0+w_1*x+w_2*x^2+…+w_n*x^n\" eeimg=\"1\"/> </p><p>多项式拟合也可以看成一种多元线性拟合，将其看为有n个特征的多元线性拟合， <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 为一个特征， <img src=\"https://www.zhihu.com/equation?tex=x%5E2\" alt=\"x^2\" eeimg=\"1\"/> -为一个特征……。</p><p>当 <img src=\"https://www.zhihu.com/equation?tex=x%5Cin%5B1%2C1000%5D\" alt=\"x\\in[1,1000]\" eeimg=\"1\"/> 时， <img src=\"https://www.zhihu.com/equation?tex=x%5E2%5Cin%5B1%2C1000%2C1000%5D\" alt=\"x^2\\in[1,1000,1000]\" eeimg=\"1\"/> , <img src=\"https://www.zhihu.com/equation?tex=x%5E3%5Cin%5B1%2C1000%2C000%2C000%5D\" alt=\"x^3\\in[1,1000,000,000]\" eeimg=\"1\"/> 。</p><p>对其进行缩放后利用线性拟合一样的方法就能求出拟合曲线，matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[w]<span class=\"p\">=</span><span class=\"nf\">ploy_regression</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">num_input</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">num_ploy</span><span class=\"p\">=</span><span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"n\">num_feature</span><span class=\"p\">=</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n    <span class=\"n\">x</span><span class=\"p\">=</span><span class=\"nb\">randn</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">x</span><span class=\"p\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">w</span><span class=\"p\">=</span><span class=\"nb\">randn</span><span class=\"p\">(</span><span class=\"n\">num_ploy</span><span class=\"p\">,</span><span class=\"n\">num_input</span><span class=\"p\">);</span>\n    <span class=\"n\">b</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">X</span><span class=\"p\">=</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"n\">num_feature</span><span class=\"p\">,</span><span class=\"n\">num_ploy</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">num_ploy</span>\n        <span class=\"k\">if</span> <span class=\"nb\">i</span><span class=\"o\">==</span><span class=\"mi\">1</span>\n           <span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">x</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n           <span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.*</span><span class=\"n\">x</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">num_ploy</span>\n<span class=\"c\">%         maxnum=max(X(:,i));</span>\n<span class=\"c\">%         minnum=min(X(:,i));</span>\n\n        <span class=\"n\">meannum</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)=(</span><span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">meannum</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)));</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">epochs</span><span class=\"p\">=</span><span class=\"mi\">1000</span><span class=\"p\">;</span>\n    <span class=\"n\">alpha</span><span class=\"p\">=</span><span class=\"mf\">0.01</span><span class=\"p\">;</span>\n    <span class=\"n\">lamda</span><span class=\"p\">=</span><span class=\"mf\">0.1</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">epochs</span>\n        <span class=\"n\">H</span><span class=\"p\">=</span><span class=\"n\">X</span><span class=\"o\">*</span><span class=\"n\">w</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">;</span>\n        <span class=\"n\">dw</span><span class=\"p\">=</span><span class=\"n\">X</span><span class=\"s\">&#39;</span><span class=\"err\">*(H-y)*(1/num_feature)+(1/num_feature)*lamda*w;\n</span><span class=\"err\">        db=sum(H-y)*(1/num_feature);\n</span><span class=\"err\">        w=w-alpha*dw;\n</span><span class=\"err\">        b=b-alpha*db;\n</span><span class=\"err\">    end\n</span><span class=\"err\">    y1=X*w+b;\n</span><span class=\"err\">    p=polyfit(x,y,3);\n</span><span class=\"err\">    y2=polyval(p,x);\n</span><span class=\"err\">    plot(x,y,&#34;r*&#34;,x,y1,&#34;b-&#34;,x,y2,&#34;g-&#34;)\n</span><span class=\"err\">end</span></code></pre></div><p>结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8977f9c7fabfa13dec3b367a2f869d1a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-8977f9c7fabfa13dec3b367a2f869d1a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-8977f9c7fabfa13dec3b367a2f869d1a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8977f9c7fabfa13dec3b367a2f869d1a_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "回归分析", 
                    "tagLink": "https://api.zhihu.com/topics/19577456"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80813454", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 4, 
            "title": "路径规划算法（1）--Dijkstra和Floyd算法", 
            "content": "<h2>1.Dijkstra算法</h2><p>Dijkstra算法主要用于解决带权重的有向图。其权重只能是正值，不能解决负值问题，其基本思想是利用广度优先搜索的方法，更新起点到各个顶点的最短距离。是一种经典的求单源最短路径的一种方法。其具体做法是定义一个数组 <img src=\"https://www.zhihu.com/equation?tex=T\" alt=\"T\" eeimg=\"1\"/> 保留源点到各顶点的最短距离,和一个数组表示已经遍历出最短路径的数组 <img src=\"https://www.zhihu.com/equation?tex=S\" alt=\"S\" eeimg=\"1\"/> ，以图解算法中的一个图为例说明：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2d9c2f3abcc749aa63202b4d0bb69838_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"505\" data-original=\"https://pic1.zhimg.com/v2-2d9c2f3abcc749aa63202b4d0bb69838_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;505&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"505\" data-original=\"https://pic1.zhimg.com/v2-2d9c2f3abcc749aa63202b4d0bb69838_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2d9c2f3abcc749aa63202b4d0bb69838_b.jpg\"/></figure><p>1为源点，定义数组T</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a040b21dbf7a7f5378dc029d218b24d_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"54\" class=\"origin_image zh-lightbox-thumb\" width=\"509\" data-original=\"https://pic2.zhimg.com/v2-1a040b21dbf7a7f5378dc029d218b24d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;509&#39; height=&#39;54&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"54\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"509\" data-original=\"https://pic2.zhimg.com/v2-1a040b21dbf7a7f5378dc029d218b24d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a040b21dbf7a7f5378dc029d218b24d_b.png\"/></figure><p>S中存入源点1，选取离源点1最近的顶点3，将3存入数组S中，（图所有的边都是正数，所以不存在更近的到3顶点的路线）。找到顶点3能到达的顶点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f37fed14cd3953d2ed37958cc9b216b8_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"375\" data-rawheight=\"48\" class=\"content_image\" width=\"375\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;375&#39; height=&#39;48&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"375\" data-rawheight=\"48\" class=\"content_image lazy\" width=\"375\" data-actualsrc=\"https://pic1.zhimg.com/v2-f37fed14cd3953d2ed37958cc9b216b8_b.png\"/></figure><p>可以看出3-&gt;2的距离为3，1-&gt;3的距离为2，1-&gt;3-&gt;2的距离为2+3=5，小于6更新T中的2为5。3-&gt;4的距离为5，1-&gt;3-&gt;4=2+5=7。更新数组T:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2e1db83d7c70aa191bb8220940c1ede7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"507\" data-rawheight=\"56\" class=\"origin_image zh-lightbox-thumb\" width=\"507\" data-original=\"https://pic4.zhimg.com/v2-2e1db83d7c70aa191bb8220940c1ede7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;507&#39; height=&#39;56&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"507\" data-rawheight=\"56\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"507\" data-original=\"https://pic4.zhimg.com/v2-2e1db83d7c70aa191bb8220940c1ede7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2e1db83d7c70aa191bb8220940c1ede7_b.png\"/></figure><p>选取下一个最短路径且不在数组S中的顶点，如上表可知顶点2的距离最短，将顶点2加入到数组S中，遍历顶点2能到达的顶点</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d445a2eab069c0f885bdee123abe16b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"62\" class=\"content_image\" width=\"265\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;265&#39; height=&#39;62&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"62\" class=\"content_image lazy\" width=\"265\" data-actualsrc=\"https://pic1.zhimg.com/v2-d445a2eab069c0f885bdee123abe16b0_b.jpg\"/></figure><p>2-&gt;4的距离为1，1-&gt;2-&gt;4的距离为5+1=6，小于之前的7，更新数组T:<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0e99586346ec464247e08bf4c6edba09_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"513\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"513\" data-original=\"https://pic2.zhimg.com/v2-0e99586346ec464247e08bf4c6edba09_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;513&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"513\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"513\" data-original=\"https://pic2.zhimg.com/v2-0e99586346ec464247e08bf4c6edba09_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0e99586346ec464247e08bf4c6edba09_b.png\"/></figure><p>至此，得到各订=顶点的最短路径。</p><p>以下图<sup data-text=\"\" data-url=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>为例编写matlab代码：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a937cde0ff2e0d2262b941770ca896f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"433\" data-original=\"https://pic3.zhimg.com/v2-a937cde0ff2e0d2262b941770ca896f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;433&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"433\" data-original=\"https://pic3.zhimg.com/v2-a937cde0ff2e0d2262b941770ca896f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a937cde0ff2e0d2262b941770ca896f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[T,S,path,node]<span class=\"p\">=</span><span class=\"nf\">DJT_2</span><span class=\"p\">(</span>d<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"o\">~</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n      <span class=\"n\">str</span><span class=\"p\">=</span><span class=\"n\">char</span><span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"o\">+</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n      <span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=[];</span>\n      <span class=\"n\">node</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=[];</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">T</span><span class=\"p\">=</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,:);</span>\n  <span class=\"n\">S</span><span class=\"p\">=[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n      <span class=\"p\">[</span><span class=\"o\">~</span><span class=\"p\">,</span><span class=\"n\">index_total</span><span class=\"p\">]=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">);</span>\n     <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">index_total</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n     <span class=\"k\">if</span> <span class=\"o\">~</span><span class=\"n\">ismember</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">S</span><span class=\"p\">)</span>\n         <span class=\"n\">S</span><span class=\"p\">=[</span><span class=\"n\">S</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">];</span>\n         <span class=\"n\">med</span><span class=\"p\">=</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,:);</span>\n         <span class=\"n\">med_index</span><span class=\"p\">=</span><span class=\"nb\">find</span><span class=\"p\">(</span><span class=\"n\">med</span><span class=\"o\">~=</span><span class=\"nb\">inf</span><span class=\"p\">);</span>\n         <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">med_index</span><span class=\"p\">)</span>\n             <span class=\"k\">if</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">med_index</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">))</span><span class=\"o\">&gt;</span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">med_index</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">))</span>\n                 <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">med_index</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">))=</span><span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,</span><span class=\"n\">med_index</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">));</span>\n                 <span class=\"n\">str</span><span class=\"p\">=</span><span class=\"n\">char</span><span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"o\">+</span><span class=\"n\">med_index</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">));</span>\n                 <span class=\"n\">node</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=</span><span class=\"n\">index</span><span class=\"p\">;</span>\n             <span class=\"k\">end</span>\n         <span class=\"k\">end</span>      \n     <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n       <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n           <span class=\"k\">if</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">~=</span><span class=\"nb\">inf</span>\n                 <span class=\"n\">str</span><span class=\"p\">=</span><span class=\"n\">char</span><span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"o\">+</span><span class=\"n\">S</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span> \n                 <span class=\"k\">if</span> <span class=\"o\">~</span><span class=\"nb\">isempty</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">))</span>\n                    <span class=\"n\">str1</span><span class=\"p\">=</span><span class=\"n\">char</span><span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"o\">+</span><span class=\"n\">node</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">));</span>\n                    <span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=[</span><span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str1</span><span class=\"p\">)</span> <span class=\"n\">S</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)];</span>\n                 <span class=\"k\">else</span>\n                    <span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=[</span><span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)</span> <span class=\"n\">S</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)];</span>\n                 <span class=\"k\">end</span>\n           <span class=\"k\">end</span>\n           <span class=\"k\">if</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">~=</span><span class=\"nb\">inf</span>\n                  <span class=\"n\">str</span><span class=\"p\">=</span><span class=\"n\">char</span><span class=\"p\">(</span><span class=\"mi\">96</span><span class=\"o\">+</span><span class=\"nb\">i</span><span class=\"p\">);</span> \n                  <span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)=[</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">path</span><span class=\"p\">.(</span><span class=\"n\">str</span><span class=\"p\">)];</span>\n           <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>d=[inf,inf,10,inf,30,100;</p><p>    inf,inf,5,inf,inf,inf;</p><p>    inf,inf,inf,50,inf,inf;</p><p>    inf,inf,inf,inf,inf,10;</p><p>    inf,inf,inf,20,inf,60;</p><p>    inf,inf,inf,inf,inf,inf];</p><p>带入函数中进行测试得到：</p><p>    a: []</p><p>    b: []</p><p>    c: [1 3]</p><p>    d: [1 5 4]</p><p>    e: [1 5]</p><p>    f: [1 5 4 6]</p><p>1-&gt;3,  1-&gt;5-&gt;4,  1-&gt;5,  1-&gt;5-&gt;4-&gt;6。</p><h2>2.Floyd算法</h2><p>前面介绍的Dijkstra算法可以很好的求解单源权重的路径规划问题，但是当权重存在负数时，则不能很好的解决，对于带负权重边（不存在负权回路）的问题可以应用Floyd算法进行求解。其是一种经典的求多源最短路径的一种方法。Floyd的原理在以下博客中有详细介绍。</p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_35644234/article/details/60875818\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_356442</span><span class=\"invisible\">34/article/details/60875818</span><span class=\"ellipsis\"></span></a><p>matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[d,r]<span class=\"p\">=</span><span class=\"nf\">floyd</span><span class=\"p\">(</span>a<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">n</span><span class=\"p\">=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">d</span><span class=\"p\">=</span><span class=\"n\">a</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n        <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n            <span class=\"n\">r</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)=</span><span class=\"nb\">j</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">r</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"n\">k</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n        <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n            <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n                <span class=\"k\">if</span> <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)</span><span class=\"o\">&lt;</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)</span>\n                    <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)=</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"n\">k</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">);</span>\n                    <span class=\"n\">r</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)=</span><span class=\"n\">r</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"n\">k</span><span class=\"p\">);</span>\n                <span class=\"k\">end</span>\n            <span class=\"k\">end</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">DisplayPath</span><span class=\"p\">(</span>route, start, dest<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"k\">while</span> <span class=\"mi\">1</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">route</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">dest</span><span class=\"p\">)</span> <span class=\"o\">~=</span> <span class=\"n\">dest</span><span class=\"p\">)</span>\n            <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"s\">&#39;V%s -&gt; &#39;</span><span class=\"p\">,</span> <span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">));</span>\n            <span class=\"n\">start</span> <span class=\"p\">=</span> <span class=\"n\">route</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">,</span> <span class=\"n\">dest</span><span class=\"p\">);</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"s\">&#39;V%s -&gt; &#39;</span><span class=\"p\">,</span> <span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">start</span><span class=\"p\">));</span>\n            <span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"s\">&#39;V%s\\n&#39;</span><span class=\"p\">,</span> <span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">dest</span><span class=\"p\">));</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n <span class=\"k\">end</span>\n\n<span class=\"n\">d</span><span class=\"p\">=[</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">30</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n    <span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">;</span>\n    <span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">50</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">;</span>\n    <span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">20</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"mi\">60</span><span class=\"p\">;</span>\n    <span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">,</span><span class=\"nb\">inf</span><span class=\"p\">];</span></code></pre></div><p>继续上一个例子：</p><p>求出:</p><p>d =Inf   Inf    10    50    30    60</p><p>   Inf   Inf     5    55   Inf    65</p><p>   Inf   Inf   Inf    50   Inf    60</p><p>   Inf   Inf   Inf   Inf   Inf    10</p><p>   Inf   Inf   Inf    20   Inf    30</p><p>   Inf   Inf   Inf   Inf   Inf   Inf</p><p>r = 1     2     3     5     5     5</p><p>     1     2     3     3     5     3</p><p>     1     2     3     4     5     4</p><p>     1     2     3     4     5     6</p><p>     1     2     3     4     5     4</p><p>     1     2     3     4     5     6</p><p>当要输出1-&gt;6的路径时调用函数：</p><p>DisplayPath(r, 1, 6)</p><p>输出为：</p><p>V1 -&gt; V5 -&gt; V4 -&gt; V6</p>", 
            "topic": [
                {
                    "tag": "路径规划", 
                    "tagLink": "https://api.zhihu.com/topics/20206646"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }, 
                {
                    "tag": "图论", 
                    "tagLink": "https://api.zhihu.com/topics/19582618"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80756122", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 3, 
            "title": "轨迹生成--三次样条插值", 
            "content": "<p>三次样条插值算法的数学原理和公式推导在这里就不详细展开，主要是其在轨迹生成中的应用，具体了参考以下博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/adamshan/article/details/80696881\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/adamshan/</span><span class=\"invisible\">article/details/80696881</span><span class=\"ellipsis\"></span></a><p>数学公式：</p><p>（1）求出点与点之间的公式： <img src=\"https://www.zhihu.com/equation?tex=h%28i%29%3Dx_%7Bi%2B1%7D-x_%7Bi%7D\" alt=\"h(i)=x_{i+1}-x_{i}\" eeimg=\"1\"/> </p><p>  (2)   计算二次微分值m</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccccc%7D%7B1%7D+%26+%7B0%7D+%26+%7B0%7D+%26+%7B%7D+%26+%7B%5Ccdots%7D+%26+%7B0%7D+%5C%5C+%7Bh_%7B0%7D%7D+%26+%7B2%5Cleft%28h_%7B0%7D%2Bh_%7B1%7D%5Cright%29%7D+%26+%7Bh_%7B1%7D%7D+%26+%7B0%7D+%26+%7B%5Ccdots%7D+%26+%7B0%7D+%5C%5C+%7B0%7D+%26+%7Bh_%7B1%7D%7D+%26+%7B2%5Cleft%28h_%7B1%7D%2Bh_%7B2%7D%5Cright%29%7D+%26+%7Bh_%7B2%7D%7D+%26+%7B0%7D+%26+%7B0%7D+%5C%5C+%7B0%7D+%26+%7B0%7D+%26+%7Bh_%7B2%7D%7D+%26+%7B2%5Cleft%28h_%7B2%7D%2Bh_%7B3%7D%5Cright%29%7D+%26+%7Bh_%7B3%7D%7D+%26+%7B+.+.%7D+%5C%5C+%7B%5Cvdots%7D+%26+%7B%7D+%26+%7B0%7D+%26+%7B%5Cddots%7D+%26+%7B0%7D+%5C%5C+%7B0%7D+%26+%7B%5Ccdots%7D+%26+%7B0%7D+%26+%7B%5Ccdots%7D+%26+%7B2%5Cleft%28h_%7Bn-2%7D%2Bh_%7Bn-1%7D%5Cright%29%7D+%26+%7Bh_%7Bn-1%7D%7D%5C%5C%7B0%7D%26%7B0%7D%26%7B0%7D%26%7B%5Ccdots%7D%26%7B0%7D%26%7B1%7D%5Cend%7Barray%7D%5Cright%5D%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%7Bm_%7B0%7D%7D+%5C%5C+%7Bm_%7B1%7D%7D%5C%5C%7Bm_%7B2%7D%7D+%5C%5C+%7Bm_%7B3%7D%7D+%5C%5C+%7B%5Ccdots%7D+%5C%5C+%7Bm_%7Bn%7D%7D%5Cend%7Barray%7D%5Cright%5D%3D6%5Cleft%5B%5Cbegin%7Barray%7D%7Bc%7D%7B0%7D+%5C%5C+%7B%5Cfrac%7By_%7B2%7D-y_%7B1%7D%7D%7Bh_%7B1%7D%7D-%5Cfrac%7By_%7B1%7D-y_%7B0%7D+%7D%7Bh_%7B0%7D%7D%7D%5C%5C+%7B%5Cfrac%7By_%7B3%7D-y_%7B2%7D%7D%7Bh_%7B2%7D%7D-%5Cfrac%7By_%7B2%7D-y_%7B1%7D%7D%7Bh_%7B1%7D%7D%7D+%5C%5C%7B%5Ccdots%7D%5C%5C+%7B%5Cfrac%7By_%7Bn%7D-y_%7Bn-1%7D%7D%7Bh_%7Bn-1%7D%7D-%5Cfrac%7By_%7Bn-1%7D-y_%7Bn-2%7D%7D%7Bh_%7B2%7D%7D%7D+%5C%5C+%7B0%7D%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{cccccc}{1} &amp; {0} &amp; {0} &amp; {} &amp; {\\cdots} &amp; {0} \\\\ {h_{0}} &amp; {2\\left(h_{0}+h_{1}\\right)} &amp; {h_{1}} &amp; {0} &amp; {\\cdots} &amp; {0} \\\\ {0} &amp; {h_{1}} &amp; {2\\left(h_{1}+h_{2}\\right)} &amp; {h_{2}} &amp; {0} &amp; {0} \\\\ {0} &amp; {0} &amp; {h_{2}} &amp; {2\\left(h_{2}+h_{3}\\right)} &amp; {h_{3}} &amp; { . .} \\\\ {\\vdots} &amp; {} &amp; {0} &amp; {\\ddots} &amp; {0} \\\\ {0} &amp; {\\cdots} &amp; {0} &amp; {\\cdots} &amp; {2\\left(h_{n-2}+h_{n-1}\\right)} &amp; {h_{n-1}}\\\\{0}&amp;{0}&amp;{0}&amp;{\\cdots}&amp;{0}&amp;{1}\\end{array}\\right]\\left[\\begin{array}{c}{m_{0}} \\\\ {m_{1}}\\\\{m_{2}} \\\\ {m_{3}} \\\\ {\\cdots} \\\\ {m_{n}}\\end{array}\\right]=6\\left[\\begin{array}{c}{0} \\\\ {\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0} }{h_{0}}}\\\\ {\\frac{y_{3}-y_{2}}{h_{2}}-\\frac{y_{2}-y_{1}}{h_{1}}} \\\\{\\cdots}\\\\ {\\frac{y_{n}-y_{n-1}}{h_{n-1}}-\\frac{y_{n-1}-y_{n-2}}{h_{2}}} \\\\ {0}\\end{array}\\right]\" eeimg=\"1\"/> </p><p>  (3)计算系数</p><p><img src=\"https://www.zhihu.com/equation?tex=a_i+%3D+y_i\" alt=\"a_i = y_i\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=b_i+%3D+%5Cfrac%7By_%7Bi%2B1%7D+-+y_i%7D%7Bh_i%7D+-+%5Cfrac%7Bh_i%7D%7B2%7Dm_i+-+%5Cfrac%7Bh_i%7D%7B6%7D%28m_%7Bi%2B1%7D+-+m_i%29\" alt=\"b_i = \\frac{y_{i+1} - y_i}{h_i} - \\frac{h_i}{2}m_i - \\frac{h_i}{6}(m_{i+1} - m_i)\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=c_i+%3D+%5Cfrac%7Bm_i%7D%7B2%7D\" alt=\"c_i = \\frac{m_i}{2}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=d_i+%3D+%5Cfrac%7Bm_%7Bi%2B1%7D+-+m_%7Bi%7D%7D%7B6h_i%7D\" alt=\"d_i = \\frac{m_{i+1} - m_{i}}{6h_i}\" eeimg=\"1\"/> </p><p>（4）计算样条函数</p><p><img src=\"https://www.zhihu.com/equation?tex=f_i%28x%29+%3D+a_i+%2B+b_i%28x-x_i%29+%2B+c_i%28x-x_i%29%5E2+%2B+d%28x-x_i%29%5E3\" alt=\"f_i(x) = a_i + b_i(x-x_i) + c_i(x-x_i)^2 + d(x-x_i)^3\" eeimg=\"1\"/> </p><p>matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>y0<span class=\"p\">=</span><span class=\"nf\">three_spline</span><span class=\"p\">(</span>x,y,x0<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"c\">%%计算系数a</span>\n    <span class=\"n\">a</span><span class=\"p\">=</span><span class=\"n\">y</span><span class=\"p\">;</span>\n    <span class=\"n\">n</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span>\n    <span class=\"c\">%%计算插值h</span>\n    <span class=\"n\">h</span><span class=\"p\">=</span><span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"c\">%%计算二次微分值m</span>\n    <span class=\"c\">%计算左边矩阵A</span>\n    <span class=\"n\">A</span><span class=\"p\">=</span><span class=\"n\">cal_A</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"c\">%计算右边矩阵B</span>\n    <span class=\"n\">B</span><span class=\"p\">=</span><span class=\"n\">cal_B</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">,</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">)</span>\n    <span class=\"n\">m</span><span class=\"p\">=</span><span class=\"n\">linsolve</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">B</span><span class=\"p\">);</span>\n    <span class=\"c\">%计算系数b，d</span>\n    <span class=\"p\">[</span><span class=\"n\">b</span><span class=\"p\">,</span><span class=\"n\">d</span><span class=\"p\">]=</span><span class=\"n\">cal_bd</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">);</span>\n    <span class=\"c\">%计算系数c</span>\n    <span class=\"n\">c</span><span class=\"p\">=</span><span class=\"n\">m</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"c\">%计算y0值</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">)</span>\n        <span class=\"n\">t</span><span class=\"p\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n        <span class=\"n\">t</span><span class=\"p\">(</span><span class=\"k\">end</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"n\">x0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n        <span class=\"n\">t</span><span class=\"p\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span>\n        <span class=\"n\">aaa</span><span class=\"p\">=</span><span class=\"nb\">find</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">==</span><span class=\"n\">x0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>  \n        <span class=\"k\">if</span> <span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">aaa</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"mi\">1</span>         \n            <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">aaa</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">aaa</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n        <span class=\"n\">y0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">a</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">))</span><span class=\"o\">+</span><span class=\"n\">c</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">power</span><span class=\"p\">((</span><span class=\"n\">x0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)),</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">d</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">power</span><span class=\"p\">((</span><span class=\"n\">x0</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)),</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>A<span class=\"p\">=</span><span class=\"nf\">cal_A</span><span class=\"p\">(</span>h,n<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"n\">A</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">A</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">)=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n      <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n      <span class=\"n\">A</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)=</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n  <span class=\"k\">end</span>      \n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>B<span class=\"p\">=</span><span class=\"nf\">cal_B</span><span class=\"p\">(</span>y,h,n<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"n\">B</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">2</span><span class=\"p\">:</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"mi\">1</span>\n      <span class=\"n\">B</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n  <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>[b,d]<span class=\"p\">=</span><span class=\"nf\">cal_bd</span><span class=\"p\">(</span>h,m,y<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:(</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">b</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=(</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=(</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">m</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"o\">*</span><span class=\"n\">h</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span></code></pre></div><p>验证：</p><p> x = [-4., -2, 0.0, 2, 4, 6, 10]     y = [1.2, 0.6, 0.0, 1.5, 3.8, 5.0, 3.0]</p><p>x0=-4:0.01:10-0.01</p><p>结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4c32c926ae3f83b2a86d72b5aa127ce7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-4c32c926ae3f83b2a86d72b5aa127ce7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-4c32c926ae3f83b2a86d72b5aa127ce7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4c32c926ae3f83b2a86d72b5aa127ce7_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "插值", 
                    "tagLink": "https://api.zhihu.com/topics/19679796"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }, 
                {
                    "tag": "路径规划", 
                    "tagLink": "https://api.zhihu.com/topics/20206646"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80599187", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 7, 
            "title": "进化算法（3）--粒子群优化算法", 
            "content": "<h2>粒子群优化算法的思路</h2><p>粒子群算法是一种群体智能算法，是基于种群群体提出的进化算法，如鸟群或者鱼群等觅食的行为，鸟群中个每只鸟往四周觅食，有些鸟飞过的地方食物多，有些地方食物少。它们的最终目标是寻找到食物最多的地方，在这个种群中每个个体都有自我认知和共享社会信息的能力，自我认知的能力指每只鸟能够记录自己寻找到的食物最多的地方，社会共享能力指种群直接按可以相互共享信息以找到整个种群找到的食物最多的地方。所以粒子群优化算法需要记录两类信息，一是个体找到的最佳位置 <img src=\"https://www.zhihu.com/equation?tex=pbest_%7Bi%7D\" alt=\"pbest_{i}\" eeimg=\"1\"/> ,二是种群找到的最佳位置 <img src=\"https://www.zhihu.com/equation?tex=gbest\" alt=\"gbest\" eeimg=\"1\"/> 。然后需要用到这两个信息更新自己的飞行方向和速度。更新公式如下：</p><p>速度更新公式： </p><p><img src=\"https://www.zhihu.com/equation?tex=v_%7Bid%7D%5E%7Bk%2B1%7D%3Dw%5Ctimes%7Bv_%7Bid%7D%5E%7Bk%7D%7D%2Bc_%7B1%7D%5Ctimes%7Br_%7B1%7D%5E%7Bk%7D%7D%5Ctimes%7B%28pbest_%7Bid%7D%5E%7Bk%7D-x_%7Bid%7D%5E%7Bk%7D%29%7D%2Bc_%7B2%7D%5Ctimes%7Br_%7B2%7D%5E%7Bk%7D%7D%5Ctimes%7B%28gbest_%7Bd%7D%5E%7Bk%7D-x_%7Bid%7D%5E%7Bk%7D%29%7D\" alt=\"v_{id}^{k+1}=w\\times{v_{id}^{k}}+c_{1}\\times{r_{1}^{k}}\\times{(pbest_{id}^{k}-x_{id}^{k})}+c_{2}\\times{r_{2}^{k}}\\times{(gbest_{d}^{k}-x_{id}^{k})}\" eeimg=\"1\"/> </p><p>位置更新公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=x_%7Bid%7D%5E%7Bk%2B1%7D%3Dx_%7Bid%7D%5E%7Bk%7D%2Bv_%7Bid%7D%5E%7Bk%2B1%7D\" alt=\"x_{id}^{k+1}=x_{id}^{k}+v_{id}^{k+1}\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=k\" alt=\"k\" eeimg=\"1\"/> 表示是上一次迭代的数据， <img src=\"https://www.zhihu.com/equation?tex=k%2B1\" alt=\"k+1\" eeimg=\"1\"/> 表示本次迭代。 <img src=\"https://www.zhihu.com/equation?tex=d\" alt=\"d\" eeimg=\"1\"/> 表示维度(决策变量的个数)。 <img src=\"https://www.zhihu.com/equation?tex=i\" alt=\"i\" eeimg=\"1\"/> 表示种群中的第 <img src=\"https://www.zhihu.com/equation?tex=i\" alt=\"i\" eeimg=\"1\"/> 个元素。</p><p><img src=\"https://www.zhihu.com/equation?tex=pbest_%7Bi%7D%EF%BC%9A\" alt=\"pbest_{i}：\" eeimg=\"1\"/> 记录种群中的个体 <img src=\"https://www.zhihu.com/equation?tex=i\" alt=\"i\" eeimg=\"1\"/> 的经历过的最优解</p><p><img src=\"https://www.zhihu.com/equation?tex=gbest%3A\" alt=\"gbest:\" eeimg=\"1\"/> 记录整个种群遍历出的最优解</p><p><img src=\"https://www.zhihu.com/equation?tex=w%3A\" alt=\"w:\" eeimg=\"1\"/> 惯性因子</p><p><img src=\"https://www.zhihu.com/equation?tex=c_%7B1%7D%3A\" alt=\"c_{1}:\" eeimg=\"1\"/> 自身认知项的学习因子， <img src=\"https://www.zhihu.com/equation?tex=c_%7B1%7D%3D0\" alt=\"c_{1}=0\" eeimg=\"1\"/> 时表示种群没有自我认知能力而只有社会信息。</p><p><img src=\"https://www.zhihu.com/equation?tex=c_%7B2%7D%3A\" alt=\"c_{2}:\" eeimg=\"1\"/> 群体认知项的学习因子， <img src=\"https://www.zhihu.com/equation?tex=c_%7B2%7D%3D0\" alt=\"c_{2}=0\" eeimg=\"1\"/> 时表示种群没有社会信息而只有自我认知能力。</p><p><img src=\"https://www.zhihu.com/equation?tex=r_%7B1%7D%E3%80%81r_%7B2%7D%3A\" alt=\"r_{1}、r_{2}:\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%EF%BC%880%EF%BC%8C1%EF%BC%89\" alt=\"（0，1）\" eeimg=\"1\"/> 之间的随机数。</p><p>种群中个体在迭代更新速度与位置时，应该保证不能超出速度的最大及最小值和位置的最大及最小值。位置的最大及最小值就是决策变量的取值范围，而速度范围的选取即不可太大又不能太小，太大会导致粒子可能偏离最优解，而太小则可能导致陷入局部最优。同样的惯性因子 <img src=\"https://www.zhihu.com/equation?tex=w\" alt=\"w\" eeimg=\"1\"/> 也面临着这种问题，这里主要关心两个数的选取： <img src=\"https://www.zhihu.com/equation?tex=w\" alt=\"w\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=v\" alt=\"v\" eeimg=\"1\"/> </p><p><b>问题1： <img src=\"https://www.zhihu.com/equation?tex=w\" alt=\"w\" eeimg=\"1\"/> 的取值</b><sup data-text=\"\" data-url=\"https://www.jianshu.com/p/7e097bfb6390\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup></p><p>w的选取一种是取固定值，一般在（0.5，0.8）范围内，还有一种是动态策略，目前使用最多的是线性递减权值策略。</p><p><img src=\"https://www.zhihu.com/equation?tex=w%5E%7B%7Bt%7D%7D%3D%28w_%7Bini%7D-w_%7Bend%7D%29%28G_%7Bk%7D-g%29%2FG_%7Bk%7D%2Bw_%7Bend%7D\" alt=\"w^{{t}}=(w_{ini}-w_{end})(G_{k}-g)/G_{k}+w_{end}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=G_%7Bk%7D%3A\" alt=\"G_{k}:\" eeimg=\"1\"/> 最大迭代次数</p><p><img src=\"https://www.zhihu.com/equation?tex=w_%7Binit%7D%3A\" alt=\"w_{init}:\" eeimg=\"1\"/> 初始惯性权重</p><p><img src=\"https://www.zhihu.com/equation?tex=w_%7Bend%7D%3A\" alt=\"w_{end}:\" eeimg=\"1\"/> 迭代值最大进化代数时的惯性权重</p><p><img src=\"https://www.zhihu.com/equation?tex=w_%7Binit%7D%3D0.9\" alt=\"w_{init}=0.9\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=w_%7Bend%7D%3D0.3\" alt=\"w_{end}=0.3\" eeimg=\"1\"/> </p><p><b>问题2： <img src=\"https://www.zhihu.com/equation?tex=v\" alt=\"v\" eeimg=\"1\"/> 的范围</b></p><p>一般的当种群的位置范围设为 <img src=\"https://www.zhihu.com/equation?tex=%5B-x_%7Bdmax%7D%2Cx_%7Bdmax%7D%5D\" alt=\"[-x_{dmax},x_{dmax}]\" eeimg=\"1\"/> 时，速度的范围设为 <img src=\"https://www.zhihu.com/equation?tex=%5B-v_%7Bdmax%7D%2Cv_%7Bdmax%7D%5D\" alt=\"[-v_{dmax},v_{dmax}]\" eeimg=\"1\"/> ,其中： <img src=\"https://www.zhihu.com/equation?tex=v_%7Bdmax%7D%3Dk%5Ctimes%7Bx_%7Bdmax%7D%7D\" alt=\"v_{dmax}=k\\times{x_{dmax}}\" eeimg=\"1\"/> , <img src=\"https://www.zhihu.com/equation?tex=k%5Cin%7B%280.1%2C0.2%29%7D\" alt=\"k\\in{(0.1,0.2)}\" eeimg=\"1\"/> 。</p><p><b>matlab代码实现</b><sup data-text=\"\" data-url=\"https://blog.csdn.net/nightmare_dimple/article/details/74331679\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup>：</p><p>这里依然以单目标遗传算法的例子为例，求解 <img src=\"https://www.zhihu.com/equation?tex=y%3Dx+%2A+%5Csin+%2810+%2A+x%29%2Bx+%2A+%5Ccos+%282+%2A+x%29\" alt=\"y=x * \\sin (10 * x)+x * \\cos (2 * x)\" eeimg=\"1\"/> </p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">PSO</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">f</span><span class=\"p\">=</span> <span class=\"p\">@(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"n\">x</span><span class=\"o\">.*</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">.*</span><span class=\"nb\">cos</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span> <span class=\"c\">% 函数表达式</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">ezplot</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">,[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mf\">0.01</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">]);</span>\n    <span class=\"n\">N</span> <span class=\"p\">=</span> <span class=\"mi\">50</span><span class=\"p\">;</span>                         <span class=\"c\">% 初始种群个数</span>\n    <span class=\"n\">d</span> <span class=\"p\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>                          <span class=\"c\">% 空间维数</span>\n    <span class=\"n\">ger</span> <span class=\"p\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span>                      <span class=\"c\">% 最大迭代次数     </span>\n    <span class=\"n\">limit</span> <span class=\"p\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">];</span>                <span class=\"c\">% 设置位置参数限制</span>\n    <span class=\"n\">vlimit</span> <span class=\"p\">=</span> <span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">0.25</span><span class=\"p\">,</span> <span class=\"mf\">0.25</span><span class=\"p\">];</span>               <span class=\"c\">% 设置速度限制</span>\n    <span class=\"n\">w</span> <span class=\"p\">=</span> <span class=\"mf\">0.8</span><span class=\"p\">;</span>                        <span class=\"c\">% 惯性权重</span>\n    <span class=\"n\">c1</span> <span class=\"p\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>                       <span class=\"c\">% 自我学习因子</span>\n    <span class=\"n\">c2</span> <span class=\"p\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>                       <span class=\"c\">% 群体学习因子 </span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span> <span class=\"p\">=</span> <span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">d</span>\n        <span class=\"n\">x</span> <span class=\"p\">=</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">);</span><span class=\"c\">%初始种群的位置</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">v</span> <span class=\"p\">=</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">);</span>                  <span class=\"c\">% 初始种群的速度</span>\n    <span class=\"n\">xm</span> <span class=\"p\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>                          <span class=\"c\">% 每个个体的历史最佳位置</span>\n    <span class=\"n\">ym</span> <span class=\"p\">=</span> <span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">);</span>                <span class=\"c\">% 种群的历史最佳位置</span>\n    <span class=\"n\">fxm</span> <span class=\"p\">=</span> <span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>               <span class=\"c\">% 每个个体的历史最佳适应度</span>\n    <span class=\"n\">fym</span> <span class=\"p\">=</span> <span class=\"o\">-</span><span class=\"nb\">inf</span><span class=\"p\">;</span>                      <span class=\"c\">% 种群历史最佳适应度</span>\n    <span class=\"n\">hold</span> <span class=\"n\">on</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">xm</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">xm</span><span class=\"p\">),</span> <span class=\"s\">&#39;ro&#39;</span><span class=\"p\">);</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s\">&#39;初始状态图&#39;</span><span class=\"p\">);</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">iter</span> <span class=\"p\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">record</span> <span class=\"p\">=</span> <span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">ger</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>          <span class=\"c\">% 记录器</span>\n    <span class=\"n\">x0</span> <span class=\"p\">=</span> <span class=\"mi\">0</span> <span class=\"p\">:</span> <span class=\"mf\">0.01</span> <span class=\"p\">:</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"n\">iter</span> <span class=\"o\">&lt;</span><span class=\"p\">=</span> <span class=\"n\">ger</span>\n         <span class=\"n\">fx</span> <span class=\"p\">=</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">;</span> <span class=\"c\">% 个体当前适应度   </span>\n         <span class=\"k\">for</span> <span class=\"nb\">i</span> <span class=\"p\">=</span> <span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">N</span>      \n            <span class=\"k\">if</span> <span class=\"n\">fxm</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">fx</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span>\n                <span class=\"n\">fxm</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span> <span class=\"p\">=</span> <span class=\"n\">fx</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>     <span class=\"c\">% 更新个体历史最佳适应度</span>\n                <span class=\"n\">xm</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span> <span class=\"p\">=</span> <span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:);</span>   <span class=\"c\">% 更新个体历史最佳位置</span>\n            <span class=\"k\">end</span> \n         <span class=\"k\">end</span>\n    <span class=\"k\">if</span> <span class=\"n\">fym</span> <span class=\"o\">&lt;</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">fxm</span><span class=\"p\">)</span>\n            <span class=\"p\">[</span><span class=\"n\">fym</span><span class=\"p\">,</span> <span class=\"n\">nmax</span><span class=\"p\">]</span> <span class=\"p\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">fxm</span><span class=\"p\">);</span>   <span class=\"c\">% 更新群体历史最佳适应度</span>\n            <span class=\"n\">ym</span> <span class=\"p\">=</span> <span class=\"n\">xm</span><span class=\"p\">(</span><span class=\"n\">nmax</span><span class=\"p\">,</span> <span class=\"p\">:);</span>      <span class=\"c\">% 更新群体历史最佳位置</span>\n     <span class=\"k\">end</span>\n        <span class=\"n\">v</span> <span class=\"p\">=</span> <span class=\"n\">v</span> <span class=\"o\">*</span> <span class=\"n\">w</span> <span class=\"o\">+</span> <span class=\"n\">c1</span> <span class=\"o\">*</span> <span class=\"nb\">rand</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">xm</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">c2</span> <span class=\"o\">*</span> <span class=\"nb\">rand</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"nb\">repmat</span><span class=\"p\">(</span><span class=\"n\">ym</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">x</span><span class=\"p\">);</span><span class=\"c\">% 速度更新</span>\n        <span class=\"c\">% 边界速度处理</span>\n        <span class=\"n\">v</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&gt;</span> <span class=\"n\">vlimit</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"p\">=</span> <span class=\"n\">vlimit</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n        <span class=\"n\">v</span><span class=\"p\">(</span><span class=\"n\">v</span> <span class=\"o\">&lt;</span> <span class=\"n\">vlimit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">=</span> <span class=\"n\">vlimit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">x</span> <span class=\"p\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"p\">;</span><span class=\"c\">% 位置更新</span>\n        <span class=\"c\">% 边界位置处理</span>\n        <span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&gt;</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">))</span> <span class=\"p\">=</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n        <span class=\"n\">x</span><span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"p\">=</span> <span class=\"n\">limit</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">record</span><span class=\"p\">(</span><span class=\"n\">iter</span><span class=\"p\">)</span> <span class=\"p\">=</span> <span class=\"n\">fym</span><span class=\"p\">;</span><span class=\"c\">%最大值记录</span>\n    <span class=\"c\">%     x0 = 0 : 0.01 : 20;</span>\n    <span class=\"c\">%     plot(x0, f(x0), &#39;b-&#39;, x, f(x), &#39;ro&#39;);title(&#39;状态位置变化&#39;)</span>\n    <span class=\"c\">%     pause(0.1)</span>\n        <span class=\"n\">iter</span> <span class=\"p\">=</span> <span class=\"n\">iter</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">),</span> <span class=\"s\">&#39;b-&#39;</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"s\">&#39;ro&#39;</span><span class=\"p\">)</span>\n        <span class=\"n\">pause</span><span class=\"p\">(</span><span class=\"mf\">0.05</span><span class=\"p\">)</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">);</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">record</span><span class=\"p\">);</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s\">&#39;收敛过程&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x0</span><span class=\"p\">),</span> <span class=\"s\">&#39;b-&#39;</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span> <span class=\"s\">&#39;ro&#39;</span><span class=\"p\">);</span><span class=\"n\">title</span><span class=\"p\">(</span><span class=\"s\">&#39;最终状态位置&#39;</span><span class=\"p\">)</span>\n    <span class=\"nb\">disp</span><span class=\"p\">([</span><span class=\"s\">&#39;最大值：&#39;</span><span class=\"p\">,</span><span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">fym</span><span class=\"p\">)]);</span>\n    <span class=\"nb\">disp</span><span class=\"p\">([</span><span class=\"s\">&#39;变量取值：&#39;</span><span class=\"p\">,</span><span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">ym</span><span class=\"p\">)]);</span>\n<span class=\"k\">end</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0b498066cd6d38762b1f6da1fdf06f27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-0b498066cd6d38762b1f6da1fdf06f27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-0b498066cd6d38762b1f6da1fdf06f27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0b498066cd6d38762b1f6da1fdf06f27_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2db3a14b8090c6e19e4af1283f4619b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-2db3a14b8090c6e19e4af1283f4619b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-2db3a14b8090c6e19e4af1283f4619b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2db3a14b8090c6e19e4af1283f4619b8_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "粒子群优化算法", 
                    "tagLink": "https://api.zhihu.com/topics/20687903"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80323396", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 2, 
            "title": "多元分析（3）--判别分析", 
            "content": "<p>判别分析是根据所研究的个体的观测指标来推断该个体所属类型的一种方法，常见的判别分析有三种：距离判别、贝叶斯（bayes）判别、费舍尔（Fisher）判别。判别式的作用推荐阅读下面的博客：</p><a href=\"https://zhuanlan.zhihu.com/p/33742983\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-39a68de1b740727b40e1f16eede86833_180x120.jpg\" data-image-width=\"893\" data-image-height=\"689\" class=\"internal\">木水小亭：数模系列(7)：Fisher判别分析（Fisher Discriminant Analysis）</a><h2>1.距离判别</h2><p>在计算距离时，我们最常用的欧式距离，但是在统计学中，欧式距离就不适用了，统计学中常用马氏（Mahalanobis）距离来定义“距离”这个概念，马氏距离的计算公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=d%28x%2Cy%29%3D%5Csqrt%7B%28x-y%29%5ET%5CSigma%5E%7B-1%7D%28x-y%29%7D\" alt=\"d(x,y)=\\sqrt{(x-y)^T\\Sigma^{-1}(x-y)}\" eeimg=\"1\"/> </p><p>x,y表示两点， <img src=\"https://www.zhihu.com/equation?tex=%5CSigma\" alt=\"\\Sigma\" eeimg=\"1\"/> 表示协方差。</p><p>当需要计算点与总体的马氏距离时：</p><p><img src=\"https://www.zhihu.com/equation?tex=d%28x%2CA%29%3D%5Csqrt%7B%28x-%5Cmu%29%5ET%5CSigma%5E%7B-1%7D%28x-%5Cmu%29%7D\" alt=\"d(x,A)=\\sqrt{(x-\\mu)^T\\Sigma^{-1}(x-\\mu)}\" eeimg=\"1\"/> , <img src=\"https://www.zhihu.com/equation?tex=%5Cmu\" alt=\"\\mu\" eeimg=\"1\"/> -表示总体的均值。</p><p>先假设有 <img src=\"https://www.zhihu.com/equation?tex=A%2CB\" alt=\"A,B\" eeimg=\"1\"/> 两个总体， <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 总体有 <img src=\"https://www.zhihu.com/equation?tex=n_%7B1%7D\" alt=\"n_{1}\" eeimg=\"1\"/> 个样本， <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"B\" eeimg=\"1\"/> 总体有 <img src=\"https://www.zhihu.com/equation?tex=n_%7B2%7D\" alt=\"n_{2}\" eeimg=\"1\"/> 个样本，每个样本有 <img src=\"https://www.zhihu.com/equation?tex=p\" alt=\"p\" eeimg=\"1\"/> 个特征。现有一个样本 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 判断属于 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 还是 <img src=\"https://www.zhihu.com/equation?tex=B\" alt=\"B\" eeimg=\"1\"/> ,则分别计算 <img src=\"https://www.zhihu.com/equation?tex=x%E5%88%B0A%2CB\" alt=\"x到A,B\" eeimg=\"1\"/>的马氏距离，越小则越靠近。</p><p>我们以matlab自带的数据集fisheriris为例来演示距离判别如何实现分类判别的。具体matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"n\">load</span> <span class=\"n\">fisheriris</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">[biaoji,label_s,t_rate]judge</span><span class=\"p\">(</span>meas,species<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">m</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">species</span><span class=\"p\">);</span>\n    <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">randperm</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span><span class=\"c\">%打乱顺序</span>\n    <span class=\"n\">species1</span><span class=\"p\">=</span><span class=\"n\">species</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">);</span>\n    <span class=\"n\">meas1</span><span class=\"p\">=</span><span class=\"n\">meas</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,:);</span>\n    <span class=\"n\">meas1</span><span class=\"p\">=</span><span class=\"n\">meas1</span><span class=\"p\">(:,</span><span class=\"mi\">3</span><span class=\"p\">:</span><span class=\"mi\">4</span><span class=\"p\">);</span>\n    <span class=\"n\">A</span><span class=\"p\">=[];</span>\n    <span class=\"n\">B</span><span class=\"p\">=[];</span>\n    <span class=\"n\">C</span><span class=\"p\">=[];</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">100</span>\n        <span class=\"k\">if</span> <span class=\"n\">species1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">==</span>&#34;<span class=\"n\">setosa</span>&#34;\n            <span class=\"n\">A</span><span class=\"p\">=[</span><span class=\"n\">A</span><span class=\"p\">;</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n            <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">r</span><span class=\"o\">*</span>&#34;<span class=\"p\">)</span>\n            <span class=\"n\">hold</span> <span class=\"n\">on</span>\n        <span class=\"k\">elseif</span> <span class=\"n\">species1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">==</span>&#34;<span class=\"n\">versicolor</span>&#34;\n            <span class=\"n\">B</span><span class=\"p\">=[</span><span class=\"n\">B</span><span class=\"p\">;</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n            <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">bx</span>&#34;<span class=\"p\">)</span>\n            <span class=\"n\">hold</span> <span class=\"n\">on</span>\n         <span class=\"k\">elseif</span> <span class=\"n\">species1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">==</span>&#34;<span class=\"n\">virginica</span>&#34;\n             <span class=\"n\">C</span><span class=\"p\">=[</span><span class=\"n\">C</span><span class=\"p\">;</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)];</span>\n            <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">g</span><span class=\"o\">+</span>&#34;<span class=\"p\">)</span>\n            <span class=\"n\">hold</span> <span class=\"n\">on</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">Sample</span><span class=\"p\">=</span><span class=\"n\">meas1</span><span class=\"p\">(</span><span class=\"mi\">101</span><span class=\"p\">:</span><span class=\"n\">m</span><span class=\"p\">,:);</span>\n    <span class=\"n\">label_s</span><span class=\"p\">=</span><span class=\"n\">species1</span><span class=\"p\">(</span><span class=\"mi\">101</span><span class=\"p\">:</span><span class=\"n\">m</span><span class=\"p\">,:);</span>\n    <span class=\"n\">label</span><span class=\"p\">=[</span>&#34;<span class=\"n\">setosa</span>&#34;<span class=\"p\">,</span>&#34;<span class=\"n\">versicolor</span>&#34;<span class=\"p\">,</span>&#34;<span class=\"n\">virginica</span>&#34;<span class=\"p\">];</span>\n    <span class=\"n\">biaoji</span><span class=\"p\">=</span><span class=\"n\">distance_d</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">,</span><span class=\"n\">B</span><span class=\"p\">,</span><span class=\"n\">C</span><span class=\"p\">,</span><span class=\"n\">Sample</span><span class=\"p\">,</span><span class=\"n\">label</span><span class=\"p\">);</span>\n    <span class=\"n\">label_s</span><span class=\"p\">=</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">label_s</span><span class=\"p\">);</span>\n    <span class=\"n\">t_sum</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">biaoji</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"n\">biaoji</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"n\">label_s</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span>\n            <span class=\"n\">t_sum</span><span class=\"p\">=</span><span class=\"n\">t_sum</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">t_rate</span><span class=\"p\">=</span><span class=\"n\">t_sum</span><span class=\"o\">/</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">biaoji</span><span class=\"p\">);</span>\n    <span class=\"nb\">disp</span><span class=\"p\">(</span>&#34;判断准确率<span class=\"p\">:</span>&#34;<span class=\"o\">+</span><span class=\"n\">num2str</span><span class=\"p\">(</span><span class=\"n\">t_rate</span><span class=\"p\">));</span>\n<span class=\"k\">end</span>\n\n<span class=\"c\">%距离判别函数</span>\n<span class=\"k\">function</span><span class=\"w\"> </span>biaoji<span class=\"p\">=</span><span class=\"nf\">distance_d</span><span class=\"p\">(</span>A,B,C,Sample,label<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"n\">ma</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span>\n  <span class=\"n\">mb</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span>\n  <span class=\"n\">mc</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">);</span>\n  <span class=\"n\">ca</span><span class=\"p\">=</span><span class=\"n\">cov</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span>\n  <span class=\"n\">cb</span><span class=\"p\">=</span><span class=\"n\">cov</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span>\n  <span class=\"n\">cc</span><span class=\"p\">=</span><span class=\"n\">cov</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">);</span>\n  <span class=\"n\">a</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span>\n  <span class=\"n\">b</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span>\n  <span class=\"n\">c</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">C</span><span class=\"p\">);</span>\n  <span class=\"n\">S</span><span class=\"p\">=((</span><span class=\"n\">a</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">ca</span><span class=\"o\">+</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">cb</span><span class=\"o\">+</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">cc</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"o\">+</span><span class=\"n\">b</span><span class=\"o\">+</span><span class=\"n\">c</span><span class=\"o\">-</span><span class=\"mi\">3</span><span class=\"p\">);</span>\n  <span class=\"n\">n</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">Sample</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n      <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">)=(</span><span class=\"n\">Sample</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">ma</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">Sample</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">ma</span><span class=\"p\">)</span><span class=\"s\">&#39;;\n</span><span class=\"s\">      d(i,2)=(Sample(i,:)-mb)*inv(S)*(Sample(i,:)-mb)&#39;</span><span class=\"p\">;</span>\n      <span class=\"n\">d</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)=(</span><span class=\"n\">Sample</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">mc</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">Sample</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">mc</span><span class=\"p\">)</span><span class=\"s\">&#39;</span><span class=\"err\">;\n</span><span class=\"err\">      index=d(i,:)==min(d(i,:));\n</span><span class=\"err\">      biaoji(i)=label(index);\n</span><span class=\"err\">  end\n</span><span class=\"err\">end</span></code></pre></div><p>输出结果的准确率是92%</p><p>fisheriris：数据包是matlab自带的数据集，包含两个数据集，meas是样本数据，species是样本的标记。</p><h2><b>2.Fisher判别</b></h2><p>Fisher判别的原理与步骤参考上面那篇博客，但是要注意Fisher判别的应用场景，Fisher应用场景是用于线性二类分析。这里补充具体的matlab代码：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>biaoji<span class=\"p\">=</span><span class=\"nf\">fisher</span><span class=\"p\">(</span>A,B,Sample,label<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"c\">%类的均值向量</span>\n    <span class=\"n\">m1</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span>\n    <span class=\"n\">m2</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">);</span>\n    <span class=\"c\">%各类内离散度矩阵</span>\n    <span class=\"n\">s1</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"n\">s2</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">)</span>\n        <span class=\"n\">s1</span><span class=\"p\">=</span><span class=\"n\">s1</span><span class=\"o\">+</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">m1</span><span class=\"p\">)</span><span class=\"s\">&#39;*(A(i,:)-m1);\n</span><span class=\"s\">    end\n</span><span class=\"s\">    for i=1:1:length(B)\n</span><span class=\"s\">        s2=s2+(B(i,:)-m2)&#39;</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)</span><span class=\"o\">-</span><span class=\"n\">m2</span><span class=\"p\">);</span>\n    <span class=\"k\">end</span>\n    <span class=\"c\">%总类内离散矩阵</span>\n    <span class=\"n\">sw</span><span class=\"p\">=</span><span class=\"n\">s1</span><span class=\"o\">+</span><span class=\"n\">s2</span><span class=\"p\">;</span>\n    <span class=\"c\">%投影方向</span>\n    <span class=\"n\">w</span><span class=\"p\">=</span><span class=\"n\">inv</span><span class=\"p\">(</span><span class=\"n\">sw</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">m2</span><span class=\"o\">-</span><span class=\"n\">m1</span><span class=\"p\">)</span><span class=\"s\">&#39;</span><span class=\"err\">;\n</span><span class=\"err\">    %判别函数以及阈值T\n</span><span class=\"err\">    T=0.5*(m1+m2)*w;\n</span><span class=\"err\">    n=length(Sample);\n</span><span class=\"err\">%     x=[1:0.1:5];    \n</span><span class=\"err\">%     yy=-w(1)/w(2)*x;\n</span><span class=\"err\">%     plot(x,yy)\n</span><span class=\"err\">  for i=1:n\n</span><span class=\"err\">     y=Sample(i,:)*w;\n</span><span class=\"err\">     if y&gt;T\n</span><span class=\"err\">          biaoji(i)=label(2);\n</span><span class=\"err\">     else \n</span><span class=\"err\">          biaoji(i)=label(1);\n</span><span class=\"err\">     end\n</span><span class=\"err\">  end\n</span><span class=\"err\">end\n</span><span class=\"err\">\n</span><span class=\"err\">function [biaoji,label_s,t_rate]=judge_F(meas,species)\n</span><span class=\"err\">    species_two=species(1:100);\n</span><span class=\"err\">    m=length(species_two);\n</span><span class=\"err\">    index=randperm(m);%打乱顺序\n</span><span class=\"err\">    species1=species_two(index);\n</span><span class=\"err\">    meas1=meas(index,:);\n</span><span class=\"err\">    meas1=meas1(:,3:4);\n</span><span class=\"err\">    A=[];\n</span><span class=\"err\">    B=[];\n</span><span class=\"err\">    for i=1:80\n</span><span class=\"err\">        if species1(i)==&#34;setosa&#34;\n</span><span class=\"err\">            A=[A;meas1(i,:)];\n</span><span class=\"err\">            plot(meas1(i,1),meas1(i,2),&#34;r*&#34;)\n</span><span class=\"err\">            hold on\n</span><span class=\"err\">        elseif species1(i)==&#34;versicolor&#34;\n</span><span class=\"err\">            B=[B;meas1(i,:)];\n</span><span class=\"err\">            plot(meas1(i,1),meas1(i,2),&#34;bx&#34;)\n</span><span class=\"err\">            hold on\n</span><span class=\"err\">        end\n</span><span class=\"err\">    end\n</span><span class=\"err\">    Sample=meas1(81:m,:);\n</span><span class=\"err\">    label_s=species1(81:m,:);\n</span><span class=\"err\">    label=[&#34;setosa&#34;,&#34;versicolor&#34;];\n</span><span class=\"err\">    biaoji=bayes(A,B,Sample,label);\n</span><span class=\"err\">    label_s=string(label_s);\n</span><span class=\"err\">    t_sum=0;\n</span><span class=\"err\">    for i=1:length(biaoji)\n</span><span class=\"err\">        if biaoji(i)==label_s(i)\n</span><span class=\"err\">            t_sum=t_sum+1;\n</span><span class=\"err\">        end\n</span><span class=\"err\">    end\n</span><span class=\"err\">    t_rate=t_sum/length(biaoji);\n</span><span class=\"err\">    disp(&#34;判断准确率:&#34;+num2str(t_rate));\n</span><span class=\"err\">end</span></code></pre></div><p>注意这里将三个标签拿走了一个变成了一个二分类问题。</p><h2>3.贝叶斯判别</h2><p></p><p></p>", 
            "topic": [
                {
                    "tag": "判别模型", 
                    "tagLink": "https://api.zhihu.com/topics/20687259"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79947845", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 2, 
            "title": "多元分析（2）--对应分析", 
            "content": "<p>对应分析(Correspondence Analysis)也称关联分析、R-Q型因子分析，是R型因子分析和Q型因子分析的结合，是近年新发展起来的一种多元统计分析技术，通过分析由定性变量构成的交互汇总表来揭示变量间的联系。可以揭示同一变量的各个类别之间的差异，以及不同变量各个类别之间的对应关系。主要应用在市场细分、产品定位、地质研究以及计算机工程等领域中。原因在于，它是一种视觉化的数据分析方法，它能够将几组看不出任何联系的数据，通过视觉上可以接受的定位图展现出来。</p><p>Q型分析：样本之间的关系（聚类算法等）R型分析：变量之间的关系（主成分分析、因子分析等）。有时候我们不仅要弄清样本之间和变量之间的关系，还要弄清样本与变量之间的关系，而对应分析就是这样一种分析方法。（变量就是指特征）</p><h2>卡方分布及卡方检验</h2><p><b>卡方分布（ <img src=\"https://www.zhihu.com/equation?tex=%5Cchi%5E2\" alt=\"\\chi^2\" eeimg=\"1\"/> -分布）</b>：理论计算出来的频率与实际收集到的数据统计出来的频率之间总是存在一些偏差，把每一个指定值的偏差以平方的形式加起来，如果这个值比较小，则说明分布拟合得较好，如果这个值很大，则说明实际收集到的数据与目标分布并不相同，需要去寻找其它恰当的分布<sup data-text=\"\" data-url=\"https://zhuanlan.zhihu.com/p/25165318\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>。计算公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cchi%5E2%3D%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%7B%5Cfrac%7B%28f_%7Bi%7D-F_%7Bi%7D%29%5E2%7D%7BF_%7Bi%7D%7D%7D\" alt=\"\\chi^2=\\sum_{i=1}^{n}{\\frac{(f_{i}-F_{i})^2}{F_{i}}}\" eeimg=\"1\"/> </p><p>其中<img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D+\" alt=\"f_{i} \" eeimg=\"1\"/>是实际观察到的量，<img src=\"https://www.zhihu.com/equation?tex=+F_%7Bi%7D+\" alt=\" F_{i} \" eeimg=\"1\"/>是运用目标分布计算出的量。</p><p>通常利用卡方分布去判断变量之间是否独立。判断的步骤如下：</p><p><b>卡方检验步骤：</b>先利用上述公式求出卡方值，再计算自由度 <img src=\"https://www.zhihu.com/equation?tex=V%3D%28n-1%29%2A%28r-1%29\" alt=\"V=(n-1)*(r-1)\" eeimg=\"1\"/> ,其中n为行数，r为列数。确定以多大概率判断相关与不相关。</p><p>有两个假设：</p><p>H0：变量之间相互独立；</p><p>H1：变量之间相互影响；</p><p>例题：假设我们有两个变量，且求出卡方分布为1.7；行数为2，列数也为2，所以：V=1;我们要求概率大于95%才能判断两变量独立，所以取 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha%3D0.05\" alt=\"\\alpha=0.05\" eeimg=\"1\"/> ，知道了V、 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> 以及卡方值就可以通过查卡方表得出结论部分卡方表<sup data-text=\"\" data-url=\"https://blog.csdn.net/snowdroptulip/article/details/78770088\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup>如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-576847a018cc08ebaf3a82a3e2350048_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-576847a018cc08ebaf3a82a3e2350048_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-576847a018cc08ebaf3a82a3e2350048_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-576847a018cc08ebaf3a82a3e2350048_b.jpg\"/></figure><p>第一列为自由度，第一行为 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> ，中间的值是需要和卡方值进行比较的，这里我们查到F=1, <img src=\"https://www.zhihu.com/equation?tex=%5Calpha%3D0.05\" alt=\"\\alpha=0.05\" eeimg=\"1\"/> 的值为3.84，只要卡尔值大于3.84，我们就拒绝假设H0。否则接收假设H0。显然我们的卡方值 <img src=\"https://www.zhihu.com/equation?tex=1.7%3C3.84\" alt=\"1.7&lt;3.84\" eeimg=\"1\"/> ，所以接收假设H0，两者相互独立。</p><h2>对应分析<sup data-text=\"\" data-url=\"https://www.bilibili.com/video/av30822959/?p=26\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup></h2><p>再对数据进行对应分析之前需要先对其进行卡方检验，检验数据之间是否独立，如果数据直接独立的话就没有必要进行对应分析。其卡方公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cchi%5E%7B2%7D+%26%3D%5Csum_%7Bi%3D1%7D%5E%7Br%7D+%5Csum_%7Bj%3D1%7D%5E%7Bc%7D+%5Cfrac%7B%5Cleft%28k_%7Bi+j%7D%5Cright%29-%5Cleft%28%5Cwidehat%7BE%7D%5Cleft%28k_%7Bi+j%7D%5Cright%29%5Cright%5D%5E%7B2%7D%7D%7B%5Cwidehat%7BE%7D%5Cleft%28k_%7Bi+j%7D%5Cright%29%7D+%5C%5C+%26%3D%5Csum_%7Bi%3D1%7D%5E%7Br%7D+%5Csum_%7Bj%3D1%7D%5E%7Bc%7D+%5Cfrac%7B%5Cleft%5B%5Cleft%28k_%7Bi+j%7D-k_%7Bi.%7D%2C+k_%7B.j%7D+%2F+k%5Cright%29%5Cright%5D%5E%7B2%7D%7D%7Bk_%7Bi.%7D+k_%7B.j%7D+%2F+k%7D+%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} \\chi^{2} &amp;=\\sum_{i=1}^{r} \\sum_{j=1}^{c} \\frac{\\left(k_{i j}\\right)-\\left(\\widehat{E}\\left(k_{i j}\\right)\\right]^{2}}{\\widehat{E}\\left(k_{i j}\\right)} \\\\ &amp;=\\sum_{i=1}^{r} \\sum_{j=1}^{c} \\frac{\\left[\\left(k_{i j}-k_{i.}, k_{.j} / k\\right)\\right]^{2}}{k_{i.} k_{.j} / k} \\end{aligned}\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=k_%7Bij%7D\" alt=\"k_{ij}\" eeimg=\"1\"/> 是矩阵中的每个元素，k为所有元素总和， <img src=\"https://www.zhihu.com/equation?tex=k_%7Bi.%7D%E3%80%81k_%7Bj.%7D\" alt=\"k_{i.}、k_{j.}\" eeimg=\"1\"/> 分别表示第i行元素之和及第j列元素之和。</p><p>对应分析的步骤：</p><p>将级联表中的数据以矩阵形式表示出来（数据矩阵X），将数据矩阵转化为频率矩阵P，将频率矩阵再进一步转化为过渡矩阵Z。</p><p><img src=\"https://www.zhihu.com/equation?tex=X%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%7Bx_%7B11%7D%7D+%26+%7Bx_%7B12%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bx_%7B1+p%7D%7D+%5C%5C+%7Bx_%7B21%7D%7D+%26+%7Bx_%7B22%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bx_%7B2+p%7D%7D+%5C%5C+%7B%5Cldots%7D+%26+%7B%5Cldots%7D+%26+%7B%7D+%26+%7B%5Cldots%7D+%5C%5C+%7Bx_%7Bn+1%7D%7D+%26+%7Bx_%7Bn+2%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bx_%7Bn+p%7D%7D%5Cend%7Barray%7D%5Cright%5D+%5CRightarrow+P%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%7Bp_%7B11%7D%7D+%26+%7Bp_%7B12%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bp_%7B1+p%7D%7D+%5C%5C+%7Bp_%7B21%7D%7D+%26+%7Bp_%7B22%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bp_%7B2+p%7D%7D+%5C%5C+%7B%5Cldots%7D+%26+%7B%5Cldots%7D+%26+%7B%7D+%26+%7B%5Cldots%7D+%5C%5C+%7Bp_%7Bn+1%7D%7D+%26+%7Bp_%7Bn+2%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bp_%7Bn+p%7D%7D%5Cend%7Barray%7D%5Cright%5D+%5CRightarrow+Z%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%7Bz_%7B11%7D%7D+%26+%7Bz_%7B12%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bz_%7B1+p%7D%7D+%5C%5C+%7Bz_%7B21%7D%7D+%26+%7Bz_%7B22%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bz_%7B2+p%7D%7D+%5C%5C+%7B%5Cldots%7D+%26+%7B%5Cldots%7D+%26+%7B%5Cldots%7D+%26+%7B%5Cldots%7D+%5C%5C+%7Bz_%7Bn+1%7D%7D+%26+%7Bz_%7Bn+2%7D%7D+%26+%7B%5Cldots%7D+%26+%7Bz_%7Bn+p%7D%7D%5Cend%7Barray%7D%5Cright%5D\" alt=\"X=\\left[\\begin{array}{cccc}{x_{11}} &amp; {x_{12}} &amp; {\\ldots} &amp; {x_{1 p}} \\\\ {x_{21}} &amp; {x_{22}} &amp; {\\ldots} &amp; {x_{2 p}} \\\\ {\\ldots} &amp; {\\ldots} &amp; {} &amp; {\\ldots} \\\\ {x_{n 1}} &amp; {x_{n 2}} &amp; {\\ldots} &amp; {x_{n p}}\\end{array}\\right] \\Rightarrow P=\\left[\\begin{array}{cccc}{p_{11}} &amp; {p_{12}} &amp; {\\ldots} &amp; {p_{1 p}} \\\\ {p_{21}} &amp; {p_{22}} &amp; {\\ldots} &amp; {p_{2 p}} \\\\ {\\ldots} &amp; {\\ldots} &amp; {} &amp; {\\ldots} \\\\ {p_{n 1}} &amp; {p_{n 2}} &amp; {\\ldots} &amp; {p_{n p}}\\end{array}\\right] \\Rightarrow Z=\\left[\\begin{array}{cccc}{z_{11}} &amp; {z_{12}} &amp; {\\ldots} &amp; {z_{1 p}} \\\\ {z_{21}} &amp; {z_{22}} &amp; {\\ldots} &amp; {z_{2 p}} \\\\ {\\ldots} &amp; {\\ldots} &amp; {\\ldots} &amp; {\\ldots} \\\\ {z_{n 1}} &amp; {z_{n 2}} &amp; {\\ldots} &amp; {z_{n p}}\\end{array}\\right]\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=p_%7Bij%7D%3D%7B%5Cfrac%7Bx_%7Bij%7D%7D%7Bsum%28X%29%7D%7D\" alt=\"p_{ij}={\\frac{x_{ij}}{sum(X)}}\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=z_%7Bi+j%7D%3D%5Cleft%28p_%7Bi+j%7D-p_%7Bi+.%7D+p_%7B+.+j%7D%5Cright%29+%2F+%5Csqrt%7Bp_%7Bi+.+p+.+j%7D%7D%3D%5Cleft%28x_%7Bi+j%7D-x_%7Bi+.%7D+x_%7B+.+j%7D+%2F+x_%7B+.+.%7D%5Cright%29+%2F+%5Csqrt%7Bx_%7Bi+.%7D+x_%7B+.+j%7D%7D\" alt=\"z_{i j}=\\left(p_{i j}-p_{i .} p_{ . j}\\right) / \\sqrt{p_{i . p . j}}=\\left(x_{i j}-x_{i .} x_{ . j} / x_{ . .}\\right) / \\sqrt{x_{i .} x_{ . j}}\" eeimg=\"1\"/> 为卡尔分布值。</p><p>变量的协方差矩阵（一般每行表示一个样本，每列代表一中变量或特征）：</p><p><img src=\"https://www.zhihu.com/equation?tex=A%3DZ%27Z\" alt=\"A=Z&#39;Z\" eeimg=\"1\"/> </p><p>样本的协方差矩阵</p><p><img src=\"https://www.zhihu.com/equation?tex=B%3DZZ%27\" alt=\"B=ZZ&#39;\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=A%E5%92%8CB\" alt=\"A和B\" eeimg=\"1\"/> 有如下定理：设A的非零特征值是 <img src=\"https://www.zhihu.com/equation?tex=%5Clambda_%7Bi%7D\" alt=\"\\lambda_{i}\" eeimg=\"1\"/> ,特征向量是 <img src=\"https://www.zhihu.com/equation?tex=u_%7Bi%7D\" alt=\"u_{i}\" eeimg=\"1\"/> 则：</p><p>（1）A与B的所有特征值向量相等。</p><p>（2）B的非零特征值 <img src=\"https://www.zhihu.com/equation?tex=%5Clambda_%7Bi%7D\" alt=\"\\lambda_{i}\" eeimg=\"1\"/> 对应的特征向量是 <img src=\"https://www.zhihu.com/equation?tex=v_%7Bi%7D%3Dzu_%7Bi%7D\" alt=\"v_{i}=zu_{i}\" eeimg=\"1\"/> 。</p><p>计算出A和B的特征值和特征向量之和就要求A和B的因子载荷（对应于R型分析和Q型分析）</p><p><img src=\"https://www.zhihu.com/equation?tex=F%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%7B%5Csqrt%7B%5Clambda_%7B1%7D%7D+u_%7B11%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D%7D+u_%7B12%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D%7D+u_%7B1+m%7D%7D+%5C%5C+%7B%5Csqrt%7B%5Clambda_%7B1%7D%7D+u_%7B21%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D+%7Du_%7B22%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D+%7Du_%7B2+m%7D%7D+%5C%5C+%7B%5Cdots%7D+%26+%7B%5Cdots%7D+%26+%7B%5Cdots%7D+%26+%7B%5Cdots%7D+%5C%5C+%7B%5Csqrt%7B%5Clambda_%7B1%7D+%7Du_%7Bp+1%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D%7D+u_%7Bp+1%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D+%7Du_%7Bp+m%7D%7D%5Cend%7Barray%7D%5Cright%5D\" alt=\"F=\\left[\\begin{array}{cccc}{\\sqrt{\\lambda_{1}} u_{11}} &amp; {\\sqrt{\\lambda_{2}} u_{12}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m}} u_{1 m}} \\\\ {\\sqrt{\\lambda_{1}} u_{21}} &amp; {\\sqrt{\\lambda_{2} }u_{22}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m} }u_{2 m}} \\\\ {\\dots} &amp; {\\dots} &amp; {\\dots} &amp; {\\dots} \\\\ {\\sqrt{\\lambda_{1} }u_{p 1}} &amp; {\\sqrt{\\lambda_{2}} u_{p 1}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m} }u_{p m}}\\end{array}\\right]\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=G%3D%5Cleft%5B%5Cbegin%7Barray%7D%7Bcccc%7D%7B%5Csqrt%7B%5Clambda_%7B1%7D%7D+v_%7B11%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D%7D+v_%7B12%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D%7D+v_%7B1+m%7D%7D+%5C%5C+%7B%5Csqrt%7B%5Clambda_%7B1%7D%7D+v_%7B21%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D+v_%7B22%7D%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D%7D+v_%7B2+m%7D%7D+%5C%5C+%7B%5Ccdots%7D+%26+%7B%5Cdots%7D+%26+%7B%5Ccdots%7D+%26+%7B%5Ccdots%7D+%5C%5C+%7B%5Csqrt%7B%5Clambda_%7B1%7D%7D+v_%7Bn+1%7D%7D+%26+%7B%5Csqrt%7B%5Clambda_%7B2%7D+%7Dv_%7Bn+2%7D%7D+%26+%7B%5Cdots%7D+%26+%7B%5Csqrt%7B%5Clambda_%7Bm%7D%7D+v_%7Bn+m%7D%7D%5Cend%7Barray%7D%5Cright%5D\" alt=\"G=\\left[\\begin{array}{cccc}{\\sqrt{\\lambda_{1}} v_{11}} &amp; {\\sqrt{\\lambda_{2}} v_{12}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m}} v_{1 m}} \\\\ {\\sqrt{\\lambda_{1}} v_{21}} &amp; {\\sqrt{\\lambda_{2} v_{22}}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m}} v_{2 m}} \\\\ {\\cdots} &amp; {\\dots} &amp; {\\cdots} &amp; {\\cdots} \\\\ {\\sqrt{\\lambda_{1}} v_{n 1}} &amp; {\\sqrt{\\lambda_{2} }v_{n 2}} &amp; {\\dots} &amp; {\\sqrt{\\lambda_{m}} v_{n m}}\\end{array}\\right]\" eeimg=\"1\"/> </p><p>其中F是A的因子载荷，G是B的因子载荷。m为非零特征值数量，p为原始数据的列数，n是行数。在选择A和B的因子载荷之前先要进行矩阵稀疏，思想和前面介绍的主成分分析一样，将特征值从大到小排列，看前面k个特征值的重要性（k个特征值之和占总的特征值之和的比重）。</p><p>matlab代码如下<sup data-text=\"\" data-url=\"https://wenku.baidu.com/view/d62b2a693d1ec5da50e2524de518964bcf84d231.html?rec_flag=default&amp;sxts=1566992888463\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"4\">[4]</sup>：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[F,G]<span class=\"p\">=</span><span class=\"nf\">CA</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">   </span><span class=\"n\">x</span><span class=\"p\">=[</span><span class=\"mf\">190.33</span> <span class=\"mf\">43.77</span> <span class=\"mf\">9.73</span> <span class=\"mf\">60.54</span> <span class=\"mf\">49.01</span> <span class=\"mf\">9.04</span><span class=\"p\">;</span>\n       <span class=\"mf\">135.20</span> <span class=\"mf\">36.40</span> <span class=\"mf\">10.47</span> <span class=\"mf\">44.16</span> <span class=\"mf\">13.49</span> <span class=\"mf\">3.94</span><span class=\"p\">;</span>\n       <span class=\"mf\">95.21</span> <span class=\"mf\">22.83</span> <span class=\"mf\">9.30</span> <span class=\"mf\">22.44</span> <span class=\"mf\">22.81</span> <span class=\"mf\">2.80</span><span class=\"p\">;</span>\n       <span class=\"mf\">104.78</span> <span class=\"mf\">25.11</span> <span class=\"mf\">6.40</span> <span class=\"mf\">9.89</span> <span class=\"mf\">18.17</span> <span class=\"mf\">3.25</span><span class=\"p\">;</span>\n       <span class=\"mf\">128.41</span> <span class=\"mf\">27.63</span> <span class=\"mf\">8.94</span> <span class=\"mf\">12.58</span> <span class=\"mf\">23.99</span> <span class=\"mf\">3.27</span><span class=\"p\">;</span>\n       <span class=\"mf\">145.68</span> <span class=\"mf\">32.83</span> <span class=\"mf\">17.79</span> <span class=\"mf\">27.29</span> <span class=\"mf\">39.09</span> <span class=\"mf\">3.47</span><span class=\"p\">;</span>\n       <span class=\"mf\">159.37</span> <span class=\"mf\">33.38</span> <span class=\"mf\">18.37</span> <span class=\"mf\">11.81</span> <span class=\"mf\">25.29</span> <span class=\"mf\">5.22</span><span class=\"p\">;</span>\n       <span class=\"mf\">116.22</span> <span class=\"mf\">29.57</span> <span class=\"mf\">13.24</span> <span class=\"mf\">13.76</span> <span class=\"mf\">21.75</span> <span class=\"mf\">6.04</span><span class=\"p\">;</span>\n       <span class=\"mf\">221.11</span> <span class=\"mf\">38.64</span> <span class=\"mf\">12.53</span> <span class=\"mf\">115.65</span> <span class=\"mf\">50.82</span> <span class=\"mf\">5.89</span><span class=\"p\">;</span>\n       <span class=\"mf\">144.98</span> <span class=\"mf\">29.12</span> <span class=\"mf\">11.67</span> <span class=\"mf\">42.60</span> <span class=\"mf\">27.30</span> <span class=\"mf\">5.74</span><span class=\"p\">;</span>\n       <span class=\"mf\">169.92</span> <span class=\"mf\">32.75</span> <span class=\"mf\">12.72</span> <span class=\"mf\">47.12</span> <span class=\"mf\">34.35</span> <span class=\"mf\">5.00</span><span class=\"p\">;</span>\n       <span class=\"mf\">153.11</span> <span class=\"mf\">23.09</span> <span class=\"mf\">15.62</span> <span class=\"mf\">23.54</span> <span class=\"mf\">18.18</span> <span class=\"mf\">6.39</span><span class=\"p\">;</span>\n       <span class=\"mf\">144.92</span> <span class=\"mf\">21.26</span> <span class=\"mf\">16.96</span> <span class=\"mf\">19.52</span> <span class=\"mf\">21.75</span> <span class=\"mf\">6.73</span><span class=\"p\">;</span>\n       <span class=\"mf\">140.54</span> <span class=\"mf\">21.5</span> <span class=\"mf\">17.64</span> <span class=\"mf\">19.19</span> <span class=\"mf\">15.97</span> <span class=\"mf\">4.94</span><span class=\"p\">;</span>\n       <span class=\"mf\">115.84</span> <span class=\"mf\">30.26</span> <span class=\"mf\">12.20</span> <span class=\"mf\">33.61</span> <span class=\"mf\">33.77</span> <span class=\"mf\">3.85</span><span class=\"p\">;</span>\n       <span class=\"mf\">101.18</span> <span class=\"mf\">23.26</span> <span class=\"mf\">8.46</span> <span class=\"mf\">20.2</span> <span class=\"mf\">20.5</span> <span class=\"mf\">4.3</span><span class=\"p\">];</span>\n   <span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n   <span class=\"c\">%求过渡矩阵</span>\n   <span class=\"n\">Z</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n   <span class=\"n\">S</span><span class=\"p\">=</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(:));</span>\n   <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n       <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n           <span class=\"n\">Z</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)=(</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:))</span><span class=\"o\">*</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"nb\">j</span><span class=\"p\">))</span><span class=\"o\">/</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">sqrt</span><span class=\"p\">(</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:))</span><span class=\"o\">*</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"nb\">j</span><span class=\"p\">)));</span>\n       <span class=\"k\">end</span>\n   <span class=\"k\">end</span>\n   <span class=\"c\">%求变量的协方差矩阵</span>\n   <span class=\"n\">A</span><span class=\"p\">=</span><span class=\"n\">Z</span><span class=\"s\">&#39;*Z;\n</span><span class=\"s\">   %求样本的协方差矩阵\n</span><span class=\"s\">   B=Z*Z&#39;</span><span class=\"p\">;</span>\n      <span class=\"c\">%计算A的特征值和特征向量</span>\n   <span class=\"p\">[</span><span class=\"n\">u</span><span class=\"p\">,</span><span class=\"n\">t</span><span class=\"p\">]=</span><span class=\"n\">eig</span><span class=\"p\">(</span><span class=\"n\">A</span><span class=\"p\">);</span>\n   <span class=\"c\">%求特征值从大到小的比例</span>\n   <span class=\"n\">t1</span><span class=\"p\">=</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">);</span>\n   <span class=\"n\">t_sort</span><span class=\"p\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"p\">,</span><span class=\"s\">&#39;descend&#39;</span><span class=\"p\">);</span>\n   <span class=\"n\">rate</span><span class=\"p\">=</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">t_sort</span><span class=\"p\">)</span><span class=\"o\">./</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">(:));</span>\n   <span class=\"c\">%计算结果为rate =0.7354    0.8780    0.9462    0.9800    1.0000    1.0000</span>\n   <span class=\"c\">%根据rate选几个特征值,这里选前两个</span>\n   <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">rate</span><span class=\"p\">)</span>\n       <span class=\"k\">if</span> <span class=\"n\">rate</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"mf\">0.85</span>\n           <span class=\"n\">num</span><span class=\"p\">=</span><span class=\"nb\">i</span><span class=\"p\">;</span>\n           <span class=\"k\">break</span>\n       <span class=\"k\">end</span>\n   <span class=\"k\">end</span>\n   <span class=\"n\">F</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">num</span><span class=\"p\">);</span>\n   <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">num</span>   \n           <span class=\"n\">F</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">sqrt</span><span class=\"p\">(</span><span class=\"n\">t_sort</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">u</span><span class=\"p\">(:,</span><span class=\"n\">n</span><span class=\"o\">-</span><span class=\"nb\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n   <span class=\"k\">end</span>\n   <span class=\"n\">G</span><span class=\"p\">=</span><span class=\"n\">Z</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"p\">;</span>\n   <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">F</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">F</span><span class=\"p\">(:,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">rx</span>&#34;<span class=\"p\">)</span>\n   <span class=\"n\">grid</span> <span class=\"n\">on</span>\n   <span class=\"n\">hold</span> <span class=\"n\">on</span>\n   <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">G</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">G</span><span class=\"p\">(:,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">b</span><span class=\"o\">*</span>&#34;<span class=\"p\">)</span>\n<span class=\"k\">end</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-65456c2afef7332b33418de6c2d6dd87_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-65456c2afef7332b33418de6c2d6dd87_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-65456c2afef7332b33418de6c2d6dd87_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-65456c2afef7332b33418de6c2d6dd87_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }, 
                {
                    "tag": "数学建模", 
                    "tagLink": "https://api.zhihu.com/topics/19575624"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79854969", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 2, 
            "title": "多元分析（1）--主成分分析", 
            "content": "<h2>主成分分析</h2><p>主成分分析（PCA）是数据降维的一种常见方法，其它常见的方法还有因子分析（FA）,独立成分分析，在进行大数据处理时，因为数据有很多特征，维数过高，不容易进行处理且不能进行可视化，所以一般要对其进行降维，我们都知道在二维平面中的两个点能确定一条直线，在三维平面中，三个点一定能确定一个平面，二维中的直线通过旋转变换可以转化到一个坐标上（一位数据），三维中的平面可以通过旋转转化到一个坐标平面上（二维数据），所以可以说这些确定直线和平面的点直接存在一定的相关关系，且可以通过某种关系将紧密关系的数据转化为经可能少的新变量。主成分分析就是利用这一点。PCA的主要思想是将n维特征映射到k维上，这k维是全新的正交特征也被称为主成分，是在原有n维特征的基础上重新构造出来的k维特征<sup data-text=\"\" data-url=\"https://zhuanlan.zhihu.com/p/37777074\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>，那么如何才能找到这样一组有正交特征的k维数据呢，在主成分分析技术中的思路是在原始坐标轴上顺序的找相互正交的坐标轴，寻找原则是：第一个新坐标轴的方向是始数据中方差最大的方向，第二个新坐标轴选取是与第一个坐标轴正交的平面中使得方差最大的，第三个轴是与第1,2个轴正交的平面中方差最大的。依次类推，可以得到n个这样的坐标轴。通过这种方式获得的新的坐标轴。那么如何才能得到最大差异性的主成分方向呢，就是对n维数据求协方差矩阵，在求出协方差矩阵的特征值和特征向量，选择最大的k个特征值对应的k个特征向量组成转移矩阵，和原始数据相乘得到新的数据。因为求特征值和忒特征向量有两种方式，特征值分解和奇异值分解。所以可以分两种方式进行主成分分析。</p><p><b>特征值分解</b></p><p>介绍特征值分解之前必须先知道矩阵乘法的集合意义，向量与矩阵相乘就是将向量进行旋转和伸缩（对线性变换不太了解的可以观看<b><a href=\"https://link.zhihu.com/?target=https%3A//space.bilibili.com/88461692\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3Blue1Brown</a></b>的视频分析，里面很形象的讲解了线性变换的过程），如果矩阵对某些向量只发生伸缩变换，不产生旋转效果，那么这些向量就称为这个矩阵的特征向量，伸缩的比例就是特征值<sup data-text=\"特征值分解、奇异值分解、PCA概念整理\" data-url=\"https://blog.csdn.net/jinshengtao/article/details/18448355\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup>。特征分解的公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=A+v%3D%5Clambda+v\" alt=\"A v=\\lambda v\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=v\" alt=\"v\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 的特征向量， <img src=\"https://www.zhihu.com/equation?tex=%5Clambda\" alt=\"\\lambda\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 的特征值。特征值从大到小排列表示对应特征向量的重要性。方阵 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 可以进行特征分解：</p><p><img src=\"https://www.zhihu.com/equation?tex=A%3DQ+%5CSigma+Q%5E%7B-1%7D\" alt=\"A=Q \\Sigma Q^{-1}\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=Q\" alt=\"Q\" eeimg=\"1\"/> 是特征向量组成的矩阵， <img src=\"https://www.zhihu.com/equation?tex=%5CSigma\" alt=\"\\Sigma\" eeimg=\"1\"/> 表示对角矩阵，对角线上的排列的是对应的特征值。因为特征值分解只能适用 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 是方阵的情况。所以要引入奇异值分解。</p><p><b>奇异值分解</b></p><p>奇异值分解可以分解 <img src=\"https://www.zhihu.com/equation?tex=m%5Ctimes%7Bn%7D\" alt=\"m\\times{n}\" eeimg=\"1\"/> 阶的矩阵，解决了特征值分解只能分解方阵的缺陷，其分解供公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=A%3DU+%5CSigma+V%5ET+\" alt=\"A=U \\Sigma V^T \" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=U\" alt=\"U\" eeimg=\"1\"/> ( <img src=\"https://www.zhihu.com/equation?tex=m%5Ctimes%7Bm%7D\" alt=\"m\\times{m}\" eeimg=\"1\"/> 阶)和 <img src=\"https://www.zhihu.com/equation?tex=V\" alt=\"V\" eeimg=\"1\"/> ( <img src=\"https://www.zhihu.com/equation?tex=n%5Ctimes%7Bn%7D\" alt=\"n\\times{n}\" eeimg=\"1\"/> 阶)都是正交矩阵，分别称为 <img src=\"https://www.zhihu.com/equation?tex=A\" alt=\"A\" eeimg=\"1\"/> 的左奇异向量矩阵和右奇异向量矩阵。 <img src=\"https://www.zhihu.com/equation?tex=%5CSigma+\" alt=\"\\Sigma \" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=m%5Ctimes%7Bn%7D\" alt=\"m\\times{n}\" eeimg=\"1\"/> 阶矩阵。具体求法是：</p><p><img src=\"https://www.zhihu.com/equation?tex=U\" alt=\"U\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=AA%5ET\" alt=\"AA^T\" eeimg=\"1\"/> 方阵的特征向量， <img src=\"https://www.zhihu.com/equation?tex=V\" alt=\"V\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=A%5ETA\" alt=\"A^TA\" eeimg=\"1\"/> 方阵的特征向量。 <img src=\"https://www.zhihu.com/equation?tex=%5CSigma+\" alt=\"\\Sigma \" eeimg=\"1\"/> 是前面两个方阵非零特征值组成的矩阵。具体求法可以看<b><a href=\"https://link.zhihu.com/?target=https%3A//byjiang.com/2017/11/18/SVD/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">实例</a></b>。</p><h2>主成分分析执行步骤</h2><p>1.首先需要对原始数据进行处理，将原始数据进行单位化，单位化是按特征进行的求出特征的样本方差，每个样本再除上对应的样本方差。样本方差求法如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=S%5E%7B2%7D%3D%5Cfrac%7B1%7D%7Bn-1%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Coverline%7Bx%7D%5Cright%29%5E%7B2%7D\" alt=\"S^{2}=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(x_{i}-\\overline{x}\\right)^{2}\" eeimg=\"1\"/> 其中 <img src=\"https://www.zhihu.com/equation?tex=%5Coverline%7Bx%7D%3D%5Cfrac%7B1%7D%7Bn%7D+%5Csum_%7Bi%3D1%7D%5E%7BN%7D+x_%7Bi%7D\" alt=\"\\overline{x}=\\frac{1}{n} \\sum_{i=1}^{N} x_{i}\" eeimg=\"1\"/> ，这里之所以除上n-1而不是n是为了得到无偏估计。具体解释可以参考知乎问答：<b><a href=\"https://www.zhihu.com/question/20099757\" class=\"internal\">样本估计为啥是除以n-1</a></b>。</p><p>2.去平均值(即去中心化)，即每一位特征减去各自的平均值。</p><p>3.计算协方差矩阵</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Coperatorname%7BCov%7D%28X%2C+Y%29+%26%3DE%5B%28X-E%28X%29%29%28Y-E%28Y%29%29%5D+%5C%5C+%26%3D%5Cfrac%7B1%7D%7Bn-1%7D+%5Csum_%7Bi%3D1%7D%5E%7Bn%7D%5Cleft%28x_%7Bi%7D-%5Coverline%7Bx%7D%5Cright%29%5Cleft%28y_%7Bi%7D-%5Coverline%7By%7D%5Cright%29+%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} \\operatorname{Cov}(X, Y) &amp;=E[(X-E(X))(Y-E(Y))] \\\\ &amp;=\\frac{1}{n-1} \\sum_{i=1}^{n}\\left(x_{i}-\\overline{x}\\right)\\left(y_{i}-\\overline{y}\\right) \\end{aligned}\" eeimg=\"1\"/> </p><p>注意协方差的计算，协方差的计算是按照维度来计算的，即特征，如有矩阵329*9阶，一行表示一个样本供329个样本，每列表示一个特征，上式中，n=329, <img src=\"https://www.zhihu.com/equation?tex=x%2Cy\" alt=\"x,y\" eeimg=\"1\"/> 表示特征， <img src=\"https://www.zhihu.com/equation?tex=%5Coverline%7Bx%7D%2C%5Coverline%7By%7D\" alt=\"\\overline{x},\\overline{y}\" eeimg=\"1\"/> 表示每个特征的均值（329个数的平均值）。</p><p>具体解法可参考下面的matlab代码：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"n\">x</span><span class=\"p\">=</span><span class=\"nb\">round</span><span class=\"p\">(</span><span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">50</span><span class=\"p\">);</span>\n<span class=\"k\">function</span><span class=\"w\"> </span>Z<span class=\"p\">=</span><span class=\"nf\">pca_test</span><span class=\"p\">(</span>x<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">my_mean</span><span class=\"p\">=</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">Z</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n        <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n               <span class=\"n\">Z</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)=</span><span class=\"n\">sum</span><span class=\"p\">((</span><span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">my_mean</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">.*</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">(:,</span><span class=\"nb\">j</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"n\">my_mean</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">)))</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span> \n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n<span class=\"c\">%输出的Z为协方差，这里是10*3阶矩阵，所以协方差为3*3阶</span></code></pre></div><p>4.计算协方差矩阵的特征值和特征向量（特征值和特征向量）</p><p>5.选取择最大的k个特征值对应的k个特征向量组成转移矩阵P，和原始数据X相乘得到新的数据Y。   Y=P*X。</p><h2>matlab实现主成分分析</h2><p>在matlab中有自带的求解pca（主成分分析）的函数pca()<sup data-text=\"\" data-url=\"https://blog.csdn.net/qq_25800311/article/details/83385029\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup>，函数的主要输入是经过单位化的原始数据，去中心化和计算协方差矩阵等步骤都在函数中实现，pca函数还有几个输入参数，但都是可选的（有默认值），如选择计算主成分分析的方式（特征值分解或奇异值分解）等。输出的主要有6个量：</p><p>coeff : 主成分系数 应该就是协方差矩阵的特征向量矩阵(也就是映射矩阵).完整输出的情况下是一个p-by-p 的matrix.每一列都是一个特征向量.按对应的特征值 的大小,从大到小进行排列。</p><p>score: 进行旋转(也就是利用映射矩阵coeff进行)后的结果i.e. score = X * coeff.  n-by-p matrix这里有个坑 如果你使用pca时使用的是默认的中心化(i.e 不对&#39;Centered&#39;设置&#39;false&#39;),拿X *coeff 和score对比的时候, 记得把X中心化后再乘以coeff,之后再和score对比....;同样如果pca使用的是默认值, 恢复的X = score * coeff&#39; (注意转置)是中心化后的数据。</p><p>latent: 主成分方差 也就是各特征向量对应的特征值,从大到小进行排列。</p><p>tsquared :（）。</p><p>explained : 每一个主成分所贡献的比例,可以更直观的选择所需要降维的维数了,不用再用特征值去求了。</p><p>mu: X 按列的均值,当前仅当 &#39;Centered&#39;置于&#39;true&#39;(默认值)时才会返回此变量。</p><h2>matlab代码</h2><p>这里以matlab自带的数据进行仿真说明<sup data-text=\"\" data-url=\"https://blog.csdn.net/ckzhb/article/details/75281727\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"4\">[4]</sup>：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"n\">load</span> <span class=\"n\">cities</span>\n<span class=\"c\">%得到三个数据集</span>\n<span class=\"c\">%ratings 329*9每一行表示一个样本，每一列表示一个特征。</span>\n<span class=\"c\">%单位化样本数据</span>\n<span class=\"n\">std_ratings</span><span class=\"p\">=</span><span class=\"n\">std</span><span class=\"p\">(</span><span class=\"n\">ratings</span><span class=\"p\">);</span><span class=\"c\">%std()函数是对ratings求样本方差，默认是按列求,求出的结果为1*9数组</span>\n<span class=\"n\">one_ratings</span><span class=\"p\">=</span><span class=\"n\">ratings</span><span class=\"o\">./</span><span class=\"p\">(</span><span class=\"n\">std_ratings</span><span class=\"p\">);</span>\n<span class=\"c\">%使用pca函数降维</span>\n<span class=\"p\">[</span><span class=\"n\">coeff</span><span class=\"p\">,</span><span class=\"n\">score</span><span class=\"p\">,</span><span class=\"n\">latent</span><span class=\"p\">,</span><span class=\"n\">tsquare</span><span class=\"p\">,</span><span class=\"n\">explained</span><span class=\"p\">,</span><span class=\"n\">mu</span><span class=\"p\">]=</span> <span class=\"n\">pca</span><span class=\"p\">(</span><span class=\"n\">one_ratings</span><span class=\"p\">);</span>\n<span class=\"c\">%计算选取前k个特征值进行降维后和原数据的准确率</span>\n<span class=\"n\">rate</span><span class=\"p\">=</span><span class=\"n\">cumsum</span><span class=\"p\">(</span><span class=\"n\">latent</span><span class=\"p\">)</span><span class=\"o\">./</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">latent</span><span class=\"p\">);</span><span class=\"c\">%cumsum是累加和函数</span>\n<span class=\"c\">%计算后选取前面7个特征值可获得90%以上的准确率，将329*9的数据降维到329*7</span>\n<span class=\"c\">%选取coeff特征向量的前7列。</span>\n<span class=\"n\">cho</span><span class=\"p\">=</span><span class=\"n\">coeff</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">)</span>\n<span class=\"n\">new_ratings</span><span class=\"p\">=</span><span class=\"n\">ratings</span><span class=\"o\">*</span><span class=\"n\">cho</span><span class=\"p\">;</span>原数据乘上特征向量得到降维后的数据</code></pre></div><p>cities：它使用了衡量美国329个城市生活质量的9个指标：气候、住房、健康、犯罪率、交通、教育、艺术、娱乐和经济。对于各指标，越高表示越好，如高的犯罪指标表示低的犯罪率。它由三个数据集组成，categories是9个特征的字符说明，names是每个样本城市的字符名称，ratings才是我们需要关注的数组。</p><p>std():std函数总共有三个输入参数，其中有两个可选参数<sup data-text=\"\" data-url=\"https://blog.csdn.net/qinze5857/article/details/79156555\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"5\">[5]</sup>，flag--标注求样本方差时是除以n还是n-1,flag=0是除以n－1，flag=1是除以n，dim--表示是按列求还是按行求，dim=1是按照列分dim=2是按照行分 若是三维的矩阵，dim=3就按照第三维来分数据。默认情况下，flag=0,dim=1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/37777074\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/equation.jpg\" data-image-width=\"0\" data-image-height=\"0\" class=\"internal\">Microstrong：主成分分析（PCA）原理详解</a><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/pca-tutorial.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8d64151ceed0eed4d4708d8d9e6374dc_ipico.jpg\" data-image-width=\"598\" data-image-height=\"593\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CodingLabs - PCA的数学原理</a><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/ckzhb/article/details/75281727\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/ckzhb/art</span><span class=\"invisible\">icle/details/75281727</span><span class=\"ellipsis\"></span></a><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_25800311/article/details/83385029\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_258003</span><span class=\"invisible\">11/article/details/83385029</span><span class=\"ellipsis\"></span></a><p></p>", 
            "topic": [
                {
                    "tag": "数据降维", 
                    "tagLink": "https://api.zhihu.com/topics/20010182"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79680261", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 9, 
            "title": "小波分析预测", 
            "content": "<h2><b>泰勒公式</b><sup data-text=\"\" data-url=\"https://charlesliuyx.github.io/2018/02/16/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E6%B3%B0%E5%8B%92%E7%BA%A7%E6%95%B0/\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup></h2><p>泰勒公式的形式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+f%28x%29_%7BT+a+y+l+o+r%7D+%26%3D%5Csum_%7Bn%3D0%7D%5E%7B%5Cinfty%7D+%5Cfrac%7Bf%5E%7B%28n%29%7D%28a%29%7D%7Bn+%21%7D+%5Ctimes%28x-a%29%5E%7Bn%7D+%5C%5C+%26%3Df%28a%29%2B%5Cfrac%7Bf%5E%7B%5Cprime%7D%28a%29%7D%7B1+%21%7D%28x-a%29%2B%5Cfrac%7Bf%5E%7B%282%29%7D%28a%29%7D%7B2+%21%7D%28x-a%29%5E%7B2%7D%2B%5Ccdots%2B%5Cfrac%7Bf%5E%7B%28n%29%7D%28a%29%7D%7Bn+%21%7D%28x-a%29%5E%7Bn%7D%2BR_%7Bn%7D%28x%29+%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} f(x)_{T a y l o r} &amp;=\\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n !} \\times(x-a)^{n} \\\\ &amp;=f(a)+\\frac{f^{\\prime}(a)}{1 !}(x-a)+\\frac{f^{(2)}(a)}{2 !}(x-a)^{2}+\\cdots+\\frac{f^{(n)}(a)}{n !}(x-a)^{n}+R_{n}(x) \\end{aligned}\" eeimg=\"1\"/> </p><p>对于泰勒公式的具体理解，博客<b><a href=\"https://link.zhihu.com/?target=https%3A//charlesliuyx.github.io/2018/02/16/%25E3%2580%2590%25E7%259B%25B4%25E8%25A7%2582%25E8%25AF%25A6%25E8%25A7%25A3%25E3%2580%2591%25E6%25B3%25B0%25E5%258B%2592%25E7%25BA%25A7%25E6%2595%25B0/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">泰勒级数</a></b>：分别从函数角度和集合角度进行了说明，具体可参考这篇博客。</p><h2>欧拉变换<sup data-text=\"\" data-url=\"https://charlesliuyx.github.io/2018/02/18/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E8%AE%A9%E4%BD%A0%E6%B0%B8%E8%BF%9C%E5%BF%98%E4%B8%8D%E4%BA%86%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%E8%A7%A3%E6%9E%90/\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup></h2><p>欧拉公式： <img src=\"https://www.zhihu.com/equation?tex=e%5E%7B%5Cpi+i%7D%2B1%3D0\" alt=\"e^{\\pi i}+1=0\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=e%5E%7B%5Cpi+i%7D\" alt=\"e^{\\pi i}\" eeimg=\"1\"/> 表示沿单位圆旋转 <img src=\"https://www.zhihu.com/equation?tex=180%5E%7B%5Ccirc%7D\" alt=\"180^{\\circ}\" eeimg=\"1\"/> ，至于为啥表示旋转 <img src=\"https://www.zhihu.com/equation?tex=180%5E%7B%5Ccirc%7D\" alt=\"180^{\\circ}\" eeimg=\"1\"/> ，下面进行说明：</p><p>首先需要用到上面介绍的泰勒公式，利用泰勒公式展开 <img src=\"https://www.zhihu.com/equation?tex=e%5E%7Bx%7D\" alt=\"e^{x}\" eeimg=\"1\"/> 、 <img src=\"https://www.zhihu.com/equation?tex=%5Csin+%28x%29\" alt=\"\\sin (x)\" eeimg=\"1\"/> 、 <img src=\"https://www.zhihu.com/equation?tex=%5Ccos+%28x%29\" alt=\"\\cos (x)\" eeimg=\"1\"/> ，展开后如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=e%5E%7Bx%7D%3D1%2Bx%2B%5Cfrac%7B1%7D%7B2+%21%7D+x%5E%7B2%7D%2B%5Cfrac%7B1%7D%7B3+%21%7D+x%5E%7B3%7D%2B%5Ccdots\" alt=\"e^{x}=1+x+\\frac{1}{2 !} x^{2}+\\frac{1}{3 !} x^{3}+\\cdots\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Csin+%28x%29%3Dx-%5Cfrac%7B1%7D%7B3+%21%7D+x%5E%7B3%7D%2B%5Cfrac%7B1%7D%7B5+%21%7D+x%5E%7B5%7D%2B%5Ccdots\" alt=\"\\sin (x)=x-\\frac{1}{3 !} x^{3}+\\frac{1}{5 !} x^{5}+\\cdots\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Ccos+%28x%29%3D1-%5Cfrac%7B1%7D%7B2+%21%7D+x%5E%7B2%7D%2B%5Cfrac%7B1%7D%7B4+%21%7D+x%5E%7B4%7D%2B%5Ccdots\" alt=\"\\cos (x)=1-\\frac{1}{2 !} x^{2}+\\frac{1}{4 !} x^{4}+\\cdots\" eeimg=\"1\"/> </p><p>将 <img src=\"https://www.zhihu.com/equation?tex=x%3Di+%5Ctheta\" alt=\"x=i \\theta\" eeimg=\"1\"/> ，（其中 <img src=\"https://www.zhihu.com/equation?tex=i%3D-1+%5Ctimes-1\" alt=\"i=-1 \\times-1\" eeimg=\"1\"/> ），带入上式进行转换得到：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+e%5E%7Bi+%5Ctheta%7D+%26%3D1%2Bi+%5Ctheta%2B%5Cfrac%7B1%7D%7B2+%21%7D%28i+%5Ctheta%29%5E%7B2%7D%2B%5Cfrac%7B1%7D%7B3+%21%7D%28i+%5Ctheta%29%5E%7B3%7D%2B%5Cfrac%7B1%7D%7B4+%21%7D%28i+%5Ctheta%29%5E%7B4%7D%2B%5Cfrac%7B1%7D%7B5+%21%7D%28i+%5Ctheta%29%5E%7B5%7D%2B%5Ccdots+%5C%5C+%26%3D%5Cleft%281-%5Cfrac%7B%5Ctheta%5E%7B2%7D%7D%7B2+%21%7D%2B%5Cfrac%7B%5Ctheta%5E%7B4%7D%7D%7B4+%21%7D%2B%5Ccdots%5Cright%29%2Bi%5Cleft%28%5Ctheta-%5Cfrac%7B%5Ctheta%5E%7B3%7D%7D%7B3+%21%7D%2B%5Cfrac%7B%5Ctheta%5E%7B5%7D%7D%7B5+%21%7D%2B%5Ccdots%5Cright%29+%5C%5C+%26%3D%5Ccos+%28%5Ctheta%29%2Bi+%5Csin+%28%5Ctheta%29+%5Cend%7Baligned%7D\" alt=\"\\begin{aligned} e^{i \\theta} &amp;=1+i \\theta+\\frac{1}{2 !}(i \\theta)^{2}+\\frac{1}{3 !}(i \\theta)^{3}+\\frac{1}{4 !}(i \\theta)^{4}+\\frac{1}{5 !}(i \\theta)^{5}+\\cdots \\\\ &amp;=\\left(1-\\frac{\\theta^{2}}{2 !}+\\frac{\\theta^{4}}{4 !}+\\cdots\\right)+i\\left(\\theta-\\frac{\\theta^{3}}{3 !}+\\frac{\\theta^{5}}{5 !}+\\cdots\\right) \\\\ &amp;=\\cos (\\theta)+i \\sin (\\theta) \\end{aligned}\" eeimg=\"1\"/> </p><p>得到上式后，就可以可视化表示数据了，以虚数 <img src=\"https://www.zhihu.com/equation?tex=sin+%28%5Ctheta%29+\" alt=\"sin (\\theta) \" eeimg=\"1\"/> 作为纵坐标，以 <img src=\"https://www.zhihu.com/equation?tex=%5Ccos+%28%5Ctheta%29\" alt=\"\\cos (\\theta)\" eeimg=\"1\"/> 作为横坐标。 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/> 表示单位圆逆时针旋转的角度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ea47cb946328f4055bcbb422970db7b2_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-ea47cb946328f4055bcbb422970db7b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-ea47cb946328f4055bcbb422970db7b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ea47cb946328f4055bcbb422970db7b2_b.jpg\"/><figcaption>图 1. 复数坐标</figcaption></figure><p>这就是欧拉公式的坐标旋转变化，坐标的伸缩变化（乘法）可以利用幂函数的特性转化为平移变换（加法）。主要用到幂函数有如下特性： <img src=\"https://www.zhihu.com/equation?tex=a%5E%7Bx%2By%7D%3Da%5E%7Bx%7D+%5Ctimes+a%5E%7By%7D\" alt=\"a^{x+y}=a^{x} \\times a^{y}\" eeimg=\"1\"/> 。到此就有了伸缩和旋转变换。</p><h2><b>傅里叶变换</b></h2><p>傅里叶变换的作用是时域映射到频域，公式如下： <img src=\"https://www.zhihu.com/equation?tex=%5Chat%7Bf%7D%28%5Cxi%29%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D+f%28x%29+e%5E%7B-2+%5Cpi+i+x+%5Cxi%7D+d+x\" alt=\"\\hat{f}(\\xi)=\\int_{-\\infty}^{\\infty} f(x) e^{-2 \\pi i x \\xi} d x\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%5Cxi\" alt=\"\\xi\" eeimg=\"1\"/> 是任意实数，傅里叶变换的具体理解可以参考博客：<b><a href=\"https://link.zhihu.com/?target=https%3A//charlesliuyx.github.io/2018/02/18/%25E3%2580%2590%25E7%259B%25B4%25E8%25A7%2582%25E8%25AF%25A6%25E8%25A7%25A3%25E3%2580%2591%25E8%25AE%25A9%25E4%25BD%25A0%25E6%25B0%25B8%25E8%25BF%259C%25E5%25BF%2598%25E4%25B8%258D%25E4%25BA%2586%25E7%259A%2584%25E5%2582%2585%25E9%2587%258C%25E5%258F%25B6%25E5%258F%2598%25E6%258D%25A2%25E8%25A7%25A3%25E6%259E%2590/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">傅里叶变换</a></b>，这篇博文很清楚的讲解了傅里叶变换的含义，这里不再赘述。</p><p>在matlab中集成了快速傅里叶变换<sup data-text=\"\" data-url=\"https://ww2.mathworks.cn/help/matlab/math/fourier-transforms.html\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup>的函数fft(),我们以下面的例子为例，进行讲解。</p><p>例1：提取函数 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathrm%7By%7D%3D%5Csin+%282+%2A+%5Cpi+%2A+10+%2A+%5Cmathrm%7Bt%7D%29%2B%5Csin+%282+%2A+%5Cpi+%2A+20+%2A+%5Cmathrm%7Bt%7D%29%2B%5Csin+%282+%2A+%5Cpi+%2A+30+%2A+%5Cmathrm%7Bt%7D%29\" alt=\"\\mathrm{y}=\\sin (2 * \\pi * 10 * \\mathrm{t})+\\sin (2 * \\pi * 20 * \\mathrm{t})+\\sin (2 * \\pi * 30 * \\mathrm{t})\" eeimg=\"1\"/> 中的频率分量。</p><p>分析：我们知道函数中含有3个频率向量，分别是10Hz、20Hz、30Hz。现在需要对函数y进行采样，要想成功采样出对于的频率，采样频率必须大于信号频率的两倍，所以本题选用的采样频率必须大于60Hz,采样时间设为10s,则对应的matlab程序如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">test_FFT</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">N</span><span class=\"p\">=</span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"c\">%采样时间</span>\n    <span class=\"n\">F</span><span class=\"p\">=</span><span class=\"mi\">61</span><span class=\"p\">;</span><span class=\"c\">%采样频率</span>\n    <span class=\"n\">x</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">F</span><span class=\"p\">:</span><span class=\"n\">N</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">F</span><span class=\"p\">;</span><span class=\"c\">%时间轴</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">20</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y3</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">30</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y</span><span class=\"p\">=</span><span class=\"n\">y1</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"o\">+</span><span class=\"n\">y3</span><span class=\"p\">;</span>\n    <span class=\"n\">f</span><span class=\"p\">=</span><span class=\"n\">fft</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"c\">%快速傅里叶函数</span>\n    <span class=\"n\">t</span><span class=\"p\">=((</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y3</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n<span class=\"k\">end</span></code></pre></div><p>允许上面的matlab代码得到：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6486fb7a8cba5ddcf37ad33efcae72c1_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-6486fb7a8cba5ddcf37ad33efcae72c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-6486fb7a8cba5ddcf37ad33efcae72c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6486fb7a8cba5ddcf37ad33efcae72c1_b.jpg\"/><figcaption>图 2. 时域信号</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aae16597426c87afd76b9fd7c4b9b542_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-aae16597426c87afd76b9fd7c4b9b542_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-aae16597426c87afd76b9fd7c4b9b542_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aae16597426c87afd76b9fd7c4b9b542_b.jpg\"/><figcaption>图 3.频域信号</figcaption></figure><p>从上面的频域图中可以看出，我们的信号y中包含频率为10Hz，20Hz，30Hz的信号。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结一下前面讲解的傅里叶变换，它有两大主要缺点：第一个就是傅里叶变换只适用于平稳性信号，当信号中存在非平稳信号时将导致提取不出频率分量，关于什么是平稳性信号，什么是非平稳性信号，网上简单的解释有，非平稳信号是指分布参数或者分布律随时间发生变化的信号，相对的平稳信号是指分布参数或者分布律不随时间发生变化的信号。对于这个问题网上有很多讨论，但是很难给出确切的定义。读者可自行百度。但是简单的理解中，周期信号一般为平稳信号，而非周期信号一般为非平稳信号（狭隘理解）。第二个就是在频域图上不能得到对应频率的时间信息。如下如：两个分量中，一个周期随着时间的增大而增加，一个周期随着时间的减小而减小，这两个分量都不是平稳信号，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fdcd1a3628a21d5fe030388bbc36a1e4_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-fdcd1a3628a21d5fe030388bbc36a1e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-fdcd1a3628a21d5fe030388bbc36a1e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fdcd1a3628a21d5fe030388bbc36a1e4_b.jpg\"/><figcaption>图 4. 非平稳信号分量时域图</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-944feeeb0bda452baef04cbc0d72406f_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-944feeeb0bda452baef04cbc0d72406f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-944feeeb0bda452baef04cbc0d72406f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-944feeeb0bda452baef04cbc0d72406f_b.jpg\"/><figcaption>图 5.非平稳信号合成时域图</figcaption></figure><p>绘制上图的matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[x,y,y1,y2]<span class=\"p\">=</span><span class=\"nf\">non_sstation</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mf\">0.01</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"o\">-</span><span class=\"mf\">0.01</span><span class=\"p\">;</span>\n    <span class=\"n\">n</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">t1</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t2</span><span class=\"p\">=</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t3</span><span class=\"p\">=</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t4</span><span class=\"p\">=</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t5</span><span class=\"p\">=</span><span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t</span><span class=\"p\">=[</span><span class=\"n\">t1</span><span class=\"p\">,</span><span class=\"n\">t2</span><span class=\"p\">,</span><span class=\"n\">t3</span><span class=\"p\">,</span><span class=\"n\">t4</span><span class=\"p\">,</span><span class=\"n\">t5</span><span class=\"p\">];</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">y</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n        <span class=\"n\">y1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"o\">-</span><span class=\"n\">t</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">y2</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"o\">-</span><span class=\"n\">t</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">y1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n<span class=\"k\">end</span></code></pre></div><p>下面我们用上述的合成信号加上之前的频率10Hz，20Hz，30Hz的信号后做傅里叶变换，看看有什么结果。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0f6e9c249db29951f89cca1c6ad59207_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-0f6e9c249db29951f89cca1c6ad59207_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-0f6e9c249db29951f89cca1c6ad59207_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0f6e9c249db29951f89cca1c6ad59207_b.jpg\"/><figcaption>图 5. 从非平稳信号提取频率</figcaption></figure><p>matlab代码如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">FFT_func</span><span class=\"p\">(</span>x,y<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">F</span><span class=\"p\">=</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n<span class=\"c\">%     x=0:1/F:N-1/F;</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">20</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y3</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">30</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y11</span><span class=\"p\">=</span><span class=\"n\">y1</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"o\">+</span><span class=\"n\">y3</span><span class=\"o\">+</span><span class=\"n\">y</span><span class=\"p\">;</span>\n    <span class=\"n\">f</span><span class=\"p\">=</span><span class=\"n\">fft</span><span class=\"p\">(</span><span class=\"n\">y11</span><span class=\"p\">);</span>\n    <span class=\"n\">t</span><span class=\"p\">=((</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y3</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n<span class=\"k\">end</span></code></pre></div><p>从图5可以看出，虽然前后有干扰信号，但还是能很好的提取到我们的频率是因为，我们要提取的频率很小，而干扰频率（非平稳频率）很大，当两个接近时在要提取的频率上会产生很大干扰，甚至采集不到的情况。将上述两个代码改为如下：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[x,y,y1,y2]<span class=\"p\">=</span><span class=\"nf\">non_sstation</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">x</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mf\">0.001</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"o\">-</span><span class=\"mf\">0.001</span><span class=\"p\">;</span>\n    <span class=\"n\">n</span><span class=\"p\">=</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">t1</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t2</span><span class=\"p\">=</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t3</span><span class=\"p\">=</span><span class=\"mi\">3</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t4</span><span class=\"p\">=</span><span class=\"mi\">4</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t5</span><span class=\"p\">=</span><span class=\"mi\">5</span><span class=\"o\">*</span><span class=\"nb\">ones</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"o\">/</span><span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">t</span><span class=\"p\">=[</span><span class=\"n\">t1</span><span class=\"p\">,</span><span class=\"n\">t2</span><span class=\"p\">,</span><span class=\"n\">t3</span><span class=\"p\">,</span><span class=\"n\">t4</span><span class=\"p\">,</span><span class=\"n\">t5</span><span class=\"p\">];</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">y</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n        <span class=\"n\">y1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"o\">/</span><span class=\"n\">t</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">y2</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"mi\">500</span><span class=\"o\">/</span><span class=\"n\">t</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"nb\">i</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n        <span class=\"n\">y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">y1</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n    <span class=\"k\">end</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span><span class=\"nf\">FFT_func</span><span class=\"p\">(</span>x,y<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">F</span><span class=\"p\">=</span><span class=\"mi\">1000</span><span class=\"p\">;</span>\n<span class=\"c\">%     x=0:1/F:N-1/F;</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">100</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">200</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y3</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">300</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y11</span><span class=\"p\">=</span><span class=\"n\">y1</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"o\">+</span><span class=\"n\">y3</span><span class=\"o\">+</span><span class=\"n\">y</span><span class=\"p\">;</span>\n    <span class=\"n\">f</span><span class=\"p\">=</span><span class=\"n\">fft</span><span class=\"p\">(</span><span class=\"n\">y11</span><span class=\"p\">);</span>\n    <span class=\"n\">t</span><span class=\"p\">=((</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y3</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n<span class=\"k\">end</span></code></pre></div><p>提取的频率是100Hz、200Hz、300Hz。提取的结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-611c561358899e90e10347fc48a07f3c_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-611c561358899e90e10347fc48a07f3c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-611c561358899e90e10347fc48a07f3c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-611c561358899e90e10347fc48a07f3c_b.jpg\"/><figcaption>图 6. 干扰信号下提取频率</figcaption></figure><p>出现这种情况是因为只知道非平稳信号的频率范围是不行的，还得需要知道频率随时间变化的情况，最简单的方法就是加窗，按照时间分段进行傅里叶变换，这就是短时傅里叶变换的基本思想<sup data-text=\"\" data-url=\"https://zhuanlan.zhihu.com/p/22450818\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"4\">[4]</sup>。每一个时间分段记为 <img src=\"https://www.zhihu.com/equation?tex=t_%7Bi%7D\" alt=\"t_{i}\" eeimg=\"1\"/> ,每一个时间段都可以粗略估计出频谱特性，时间 <img src=\"https://www.zhihu.com/equation?tex=t_%7Bi%7D\" alt=\"t_{i}\" eeimg=\"1\"/> 越短，则时域特性越明显，但是由于点数过少，导致频域特性不精确，在matlab中有集成的函数spectrogram（）可供调用。</p><h2>spectrogram函数</h2><p>首先spectrogram()函数也可以处理平稳信号，以前面的test_FFT()函数中的三个频率提取为例</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>[t,y]<span class=\"p\">=</span><span class=\"nf\">test_FFT</span><span class=\"p\">()</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">N</span><span class=\"p\">=</span><span class=\"mi\">10</span><span class=\"p\">;</span><span class=\"c\">%采样时间</span>\n    <span class=\"n\">F</span><span class=\"p\">=</span><span class=\"mi\">61</span><span class=\"p\">;</span><span class=\"c\">%采样频率</span>\n    <span class=\"n\">x</span><span class=\"p\">=</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">F</span><span class=\"p\">:</span><span class=\"n\">N</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">/</span><span class=\"n\">F</span><span class=\"p\">;</span><span class=\"c\">%时间轴</span>\n    <span class=\"n\">y1</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y2</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">20</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y3</span><span class=\"p\">=</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"nb\">pi</span><span class=\"o\">*</span><span class=\"mi\">30</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n    <span class=\"n\">y</span><span class=\"p\">=</span><span class=\"n\">y1</span><span class=\"o\">+</span><span class=\"n\">y2</span><span class=\"o\">+</span><span class=\"n\">y3</span><span class=\"p\">;</span>\n    <span class=\"n\">f</span><span class=\"p\">=</span><span class=\"n\">fft</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span><span class=\"c\">%快速傅里叶函数</span>\n    <span class=\"n\">t</span><span class=\"p\">=((</span><span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"n\">F</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"nb\">length</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y1</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y2</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y3</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">)</span>\n    <span class=\"n\">grid</span> <span class=\"n\">on</span>\n    <span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"p\">,</span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">));</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">f</span> <span class=\"p\">=</span> <span class=\"n\">spectrogram</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">);</span>\n<span class=\"n\">figure</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">t</span><span class=\"o\">/</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"nb\">abs</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">))</span>\n<span class=\"n\">grid</span> <span class=\"n\">on</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-65ac0f6de4cf5c09fa35d755e61c5dfb_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-65ac0f6de4cf5c09fa35d755e61c5dfb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-65ac0f6de4cf5c09fa35d755e61c5dfb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-65ac0f6de4cf5c09fa35d755e61c5dfb_b.jpg\"/><figcaption>图 7.短时傅里叶提取频率</figcaption></figure><h2>小波分析</h2><p>小波分析也是解决非平稳信号的一种技术，但是和短时傅里叶变换不同，它没有窗口的概念，而是将<b>无限长的三角函数基</b>换成了<b>有限长的会衰减的小波基</b><sup data-text=\"\" data-url=\"https://zhuanlan.zhihu.com/p/22450818\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"4\">[4]</sup>。</p><p><img src=\"https://www.zhihu.com/equation?tex=F%28w%29%3D%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D+f%28t%29+%2A+e%5E%7B-i+w+t%7D+d+t+%5CRightarrow+W+T%28a%2C+%5Ctau%29%3D%5Cfrac%7B1%7D%7B%5Csqrt%7Ba%7D%7D+%5Cint_%7B-%5Cinfty%7D%5E%7B%5Cinfty%7D+f%28t%29+%2A+%5Cpsi%5Cleft%28%5Cfrac%7Bt-%5Ctau%7D%7Ba%7D%5Cright%29+d+t\" alt=\"F(w)=\\int_{-\\infty}^{\\infty} f(t) * e^{-i w t} d t \\Rightarrow W T(a, \\tau)=\\frac{1}{\\sqrt{a}} \\int_{-\\infty}^{\\infty} f(t) * \\psi\\left(\\frac{t-\\tau}{a}\\right) d t\" eeimg=\"1\"/> </p><p>将三角函数基转化为小波基，有两个自变量， <img src=\"https://www.zhihu.com/equation?tex=a\" alt=\"a\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=%5Ctau\" alt=\"\\tau\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%5Ctau\" alt=\"\\tau\" eeimg=\"1\"/> 表示的是平移量，控制小波函数的平移， <img src=\"https://www.zhihu.com/equation?tex=a\" alt=\"a\" eeimg=\"1\"/> 表示的是尺度，控制小波函数的伸缩，利用傅里叶变换只能得到频率谱、而小波变换可以得到时域谱。</p>", 
            "topic": [
                {
                    "tag": "傅里叶变换（Fourier Transform）", 
                    "tagLink": "https://api.zhihu.com/topics/19600515"
                }, 
                {
                    "tag": "小波变换（wavelet transform）", 
                    "tagLink": "https://api.zhihu.com/topics/19621077"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79633186", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 7, 
            "title": "进化算法（2）--多目标遗传算法", 
            "content": "<p>      上一节我们介绍了单目标遗传算法，然而在解决实际的问题时，遇到的大部分问题都不止一个目标函数，这样的多目标问题需要用到多目标遗传算法来求解，本节主要介绍的多目标遗传算法是NSGA-II<sup data-text=\"\" data-url=\"https://www.iitk.ac.in/kangal/Deb_NSGA-II.pdf\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup>（改进的非支配排序算法）,该遗传算法相比于其它的多目标遗传算法有如下优点：</p><ol><li>传统的非支配排序算法的复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathrm%7BO%7D%5Cleft%28%5Cmathrm%7BMN%7D%5E%7B3%7D%5Cright%29\" alt=\"\\mathrm{O}\\left(\\mathrm{MN}^{3}\\right)\" eeimg=\"1\"/> ，而NSGA-II的复杂度为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmathrm%7BO%7D%5Cleft%28%5Cmathrm%7BMN%7D%5E%7B2%7D%5Cright%29\" alt=\"\\mathrm{O}\\left(\\mathrm{MN}^{2}\\right)\" eeimg=\"1\"/> ，其中M为目标函数的个数，N为种群中的个体数。</li><li>引进精英策略，保证某些优良的种群个体在进化过程中不会被丢弃，从而提高了优化结果的精度。</li><li>采用拥挤度和拥挤度比较算子，不但克服了NSGA中需要人为指定共享参数的缺陷，而且将其作为种群中个体间的比较标准，使得准Pareto域中的个体能均匀地扩展到整个Pareto域，保证了种群的多样性。（消除了共享参数）</li></ol><h2>基本概念</h2><p>在介绍NSGA-II算法之前需要先介绍一些基本概念：</p><p><b>Pareto最优解、Pareto支配关系</b><sup data-text=\"\" data-url=\"https://blog.csdn.net/XieNaoban/article/details/88385742#NonDominated_Sorting_Genetic_Algorithm_NSGA_16\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"2\">[2]</sup></p><p>以最小化多目标优化问题为例，设有m个目标优化函数 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%28x%29%2C+i%3D1+%5Cldots+m\" alt=\"f_{i}(x), i=1 \\ldots m\" eeimg=\"1\"/> ,取任意两个决策变量 <img src=\"https://www.zhihu.com/equation?tex=X_%7B1%7D%2C+X_%7B2%7D\" alt=\"X_{1}, X_{2}\" eeimg=\"1\"/> ：</p><p>（1）如对于任意的多目标优化函数（ <img src=\"https://www.zhihu.com/equation?tex=%5Cforall+i+%5Cin%5C%7B1%2C+%5Cldots%2C+m%5C%7D\" alt=\"\\forall i \\in\\{1, \\ldots, m\\}\" eeimg=\"1\"/> ）都有： <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%5Cleft%28%7BX%7D_%7B1%7D%5Cright%29%3Cf_%7Bi%7D%5Cleft%28%7BX%7D_%7B2%7D%5Cright%29\" alt=\"f_{i}\\left({X}_{1}\\right)&lt;f_{i}\\left({X}_{2}\\right)\" eeimg=\"1\"/> 则称 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B1%7D\" alt=\"{X}_{1}\" eeimg=\"1\"/> 支配 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B2%7D\" alt=\"{X}_{2}\" eeimg=\"1\"/> 。（注意这里是以最小化为例的如果是以最大化为例则相反）</p><p>（2）如对于任意的多目标优化函数 <img src=\"https://www.zhihu.com/equation?tex=%5Cforall+i+%5Cin%5C%7B1%2C+%5Cldots%2C+m%5C%7D\" alt=\"\\forall i \\in\\{1, \\ldots, m\\}\" eeimg=\"1\"/> ，满足： <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%5Cleft%28%7BX%7D_%7B1%7D%5Cright%29+%5Cleqslant+f_%7Bi%7D%5Cleft%28%7BX%7D_%7B2%7D%5Cright%29\" alt=\"f_{i}\\left({X}_{1}\\right) \\leqslant f_{i}\\left({X}_{2}\\right)\" eeimg=\"1\"/> 则称 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B1%7D\" alt=\"{X}_{1}\" eeimg=\"1\"/> 弱支配 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B2%7D\" alt=\"{X}_{2}\" eeimg=\"1\"/> 。</p><p>（3）若存在一部分目标函数满足： <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%5Cleft%28%7BX%7D_%7B1%7D%5Cright%29%3Cf_%7Bi%7D%5Cleft%28%7BX%7D_%7B2%7D%5Cright%29\" alt=\"f_{i}\\left({X}_{1}\\right)&lt;f_{i}\\left({X}_{2}\\right)\" eeimg=\"1\"/> ，一部分目标函数满足： <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%5Cleft%28%7BX%7D_%7B1%7D%5Cright%29%3Ef_%7Bi%7D%5Cleft%28%7BX%7D_%7B2%7D%5Cright%29\" alt=\"f_{i}\\left({X}_{1}\\right)&gt;f_{i}\\left({X}_{2}\\right)\" eeimg=\"1\"/> ,则 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B1%7D\" alt=\"{X}_{1}\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B2%7D\" alt=\"{X}_{2}\" eeimg=\"1\"/> 互不支配。</p><p>单一个决策变量没有被支配的解时（ <img src=\"https://www.zhihu.com/equation?tex=%5Cforall+i+%5Cin%5C%7B1%2C+%5Cldots%2C+m%5C%7D\" alt=\"\\forall i \\in\\{1, \\ldots, m\\}\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=%5Cforall+j+%5Cin%5C%7B1%2C+%5Cldots%2C+n%5C%7D\" alt=\"\\forall j \\in\\{1, \\ldots, n\\}\" eeimg=\"1\"/> (n表示有n个决策变量)都有 <img src=\"https://www.zhihu.com/equation?tex=f_%7Bi%7D%5Cleft%28%7BX%7D_%7B1%7D%5Cright%29%3Cf_%7Bi%7D%5Cleft%28%7BX%7D_%7Bj%7D%5Cright%29\" alt=\"f_{i}\\left({X}_{1}\\right)&lt;f_{i}\\left({X}_{j}\\right)\" eeimg=\"1\"/> ）,则 <img src=\"https://www.zhihu.com/equation?tex=%7BX%7D_%7B1%7D\" alt=\"{X}_{1}\" eeimg=\"1\"/> 被称为<b>Pareto最优解</b>。</p><p>所有Pareto最优解构成的面称为<b>Pareto最优面</b>。</p><p><b>Pareto等级的划分</b></p><p>将Pareto最优解的Pareto等级划分为1，将只有一个被支配解（注意是被支配）的决策变量的Pareto等级划分为2，以及类推将有n个被支配解的决策变量Pareto等级划分为n+1。</p><p>基本概念介绍完之后，现在回到NSGA-II算法本身，NSGA-II主要由五大模块组成：<b>种群初始化模块</b>、<b>快速非支配排序模块</b>、<b>拥挤度分配模块</b>、<b>锦标赛选择模块</b>以及<b>精英保留策略模块</b>。</p><p><b>种群初始化模块</b>基本上和单目标遗传算法差不多，但是要保证决策变量是每个目标优化函数的解。如果带约束条件的话还需要考虑约束条件，具体的生成方式依据具体场景而有所不同。这里我们假设种群的大小为N，目标函数个数为M。</p><p><b>快速非支配排序模块</b>的作用就是将前面初始化种群中的N个个体（决策变量）划分Pareto等级，Pareto等级的划分在前面已经介绍过了，就是分别求出N个个体相对于M个目标函数的目标值，再循环比较。伪代码如下<sup data-text=\"\" data-url=\"https://blog.csdn.net/loveC__/article/details/85234886\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"3\">[3]</sup>：</p><div class=\"highlight\"><pre><code class=\"language-text\">for each p∈P:（P为种群，p是种群中的个体）\nS_p∈∅;\nn_p=0;\nfor each q∈P∪q≠p:\n     for  i∈m: (m个目标函数)\n          if all f_i (p)&lt;f_i (q):\n               S_p=S_p∪{q};(增加p的支配集合)\n          else if  all f_i (p)&lt;f_i (q):\n               n_p=n_p+1;(增加p的被支配数)\nif n_p=0:\n         p_rank=1\n        F_1=F_1∪{p}\ni=1;\nwhile F_i≠∅:\nQ=∅;\nfor each p∈F_i:\n   for each q∈S_p:\n          n_q=n_q-1;\n          if  n_q=0:\n              q_rank=i+1;\n              Q=Q∪{q};\n      i=i+1;\nF_i=Q;</code></pre></div><p><b>拥挤度分配模块</b>的作用是保证最后得到的最优种群平铺开来，防止解全部推挤再一起，这样就减少了决策选择的多样性，之前的很多多目标遗传算法<sup data-text=\"\" data-url=\"http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.83.9986&amp;rep=rep1&amp;type=pdf\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"4\">[4]</sup>都采用的共享参数的方式，共享参数需要认为确定，具有一定的主观性，且会引入新的变量导致算法复杂度增加，NSGA-II算法采用拥挤度算子的方式不需额外引入新的变量，其计算是按Pareto等级来分级进行计算的，Pareto等级越高（越接近于1）的个体是我们越想要的，所以按Pareto等级从高到低进行计算，在每一个等级中的计算方式都是一样的，以第1个等级为例，首先将第1等级中的个体组成一个数组，在前面的快速非支配排序模块中，我们已经求出了各个个体对于M个目标函数的值了，现在利用这些个体的目标函数值来求解拥挤度，将等级中所有个体的第一个目标函数值进行排序，选出最大值 <img src=\"https://www.zhihu.com/equation?tex=f_%7B1%7D%28p%29_%7Bmax%7D\" alt=\"f_{1}(p)_{max}\" eeimg=\"1\"/> 和最小值 <img src=\"https://www.zhihu.com/equation?tex=f_%7B1%7D%28p%29_%7Bmin%7D\" alt=\"f_{1}(p)_{min}\" eeimg=\"1\"/> ,其中下标1表示第一个目标函数，如果 <img src=\"https://www.zhihu.com/equation?tex=f_%7B1%7D%28p%29_%7Bmax%7D%3Df_%7B1%7D%28p%29_%7Bmin%7D\" alt=\"f_{1}(p)_{max}=f_{1}(p)_{min}\" eeimg=\"1\"/> ,则 所有个体的<img src=\"https://www.zhihu.com/equation?tex=d_%7B1%7D\" alt=\"d_{1}\" eeimg=\"1\"/> (相对于目标函数1的拥挤度)都设为inf（无穷），否则按照下列公式分别求出：</p><p><img src=\"https://www.zhihu.com/equation?tex=d_%7B1%7D%28p%29%3D%5Cleft%28f_%7B1%7D%28p%2B1%29-f_%7B1%7D%28p-1%29%5Cright%29+%2F%5Cleft%28f_%7B1%2C+%5Cmax+%7D-f_%7B1%2C+%5Cmin+%7D%5Cright%29\" alt=\"d_{1}(p)=\\left(f_{1}(p+1)-f_{1}(p-1)\\right) /\\left(f_{1, \\max }-f_{1, \\min }\\right)\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=f_%7B1%7D%28p%2B1%29\" alt=\"f_{1}(p+1)\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=f_%7B1%7D%28p-1%29\" alt=\"f_{1}(p-1)\" eeimg=\"1\"/> 分别表示个体p在第1个目标函数的值按小到大排序后的的前一个用户的目标函数值和后一个用户的目标函数值。</p><p>按照这种方式求出个体相对于其它几个目标函数的拥挤度之后相加，就得到了个体总的拥挤度。 <img src=\"https://www.zhihu.com/equation?tex=d%28p%29%3Dd_%7B1%7D%28p%29%2B%E2%80%A6%2Bd_%7BM%7D%28p%29\" alt=\"d(p)=d_{1}(p)+…+d_{M}(p)\" eeimg=\"1\"/> 。伪代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">i=1;\nwhile F_i≠∅(第i级非支配层)\n for each j∈m: (m个目标函数)\nfor each p∈F_i:\n    Y_j=Y_j∪{f_j (p)}    \n〖Y_sort〗_j=Sort(Y_j) 从小到达排序\nn=length(〖Y_sort〗_j);\n    f_jmax=max⁡(Y_j) =〖Y_sort〗_j(n);\n f_jmin=min(Y_j)= 〖Y_sort〗_j(0);\nd_j1=inf;\nd_jn=inf;\n for m=2:n-1 ：\n   next_obj  =〖Y_sort〗_j (m+ 1);\n   previous_obj  = 〖Y_sort〗_j (m - 1);\n         if(f_jmin==f_jmax) :\n            d_jm=inf;\n         else \n            d_jm=(next_obj- previous_obj)/ 〖(f〗_jmax-f_jmin);\nd=d+d_j;</code></pre></div><p><b>锦标赛选择模块</b>以及<b>精英保留策略模块</b></p><p>竞标赛选择模块和精英保留策略策略模块都是如何选取最优的个体作为父代进行交叉变异的模块，其实现方法如下：</p><ol><li>将父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%7D\" alt=\"C_{i}\" eeimg=\"1\"/>和子代种群 <img src=\"https://www.zhihu.com/equation?tex=D_%7Bi%7D\" alt=\"D_{i}\" eeimg=\"1\"/> 合成种群 <img src=\"https://www.zhihu.com/equation?tex=R_%7Bi%7D\" alt=\"R_{i}\" eeimg=\"1\"/>  </li><li>根据以下规则从 <img src=\"https://www.zhihu.com/equation?tex=R_%7Bi%7D\" alt=\"R_{i}\" eeimg=\"1\"/> 中生成新的父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%2B1%7D\" alt=\"C_{i+1}\" eeimg=\"1\"/> ：</li></ol><ul><li>根据Pareto等级从低到高的顺序，将整层种群放入父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%2B1%7D\" alt=\"C_{i+1}\" eeimg=\"1\"/> ，直到某一层该层个体不能全部放入父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%2B1%7D\" alt=\"C_{i+1}\" eeimg=\"1\"/> ；</li><li>将该层个体根据拥挤度从大到小排列，依次放入父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%2B1%7D\" alt=\"C_{i+1}\" eeimg=\"1\"/> 中，直到父代种群 <img src=\"https://www.zhihu.com/equation?tex=C_%7Bi%2B1%7D\" alt=\"C_{i+1}\" eeimg=\"1\"/> 填满。</li></ul><p>具体的代码可以参考这篇博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_40434430/article/details/82876572\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_404344</span><span class=\"invisible\">30/article/details/82876572</span><span class=\"ellipsis\"></span></a><p></p>", 
            "topic": [
                {
                    "tag": "遗传算法", 
                    "tagLink": "https://api.zhihu.com/topics/19555677"
                }, 
                {
                    "tag": "MATLAB", 
                    "tagLink": "https://api.zhihu.com/topics/19559252"
                }, 
                {
                    "tag": "数学建模", 
                    "tagLink": "https://api.zhihu.com/topics/19575624"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79264417", 
            "userName": "HappyWang", 
            "userLink": "https://www.zhihu.com/people/43155261b65709d873d18ca6c84902cd", 
            "upvote": 2, 
            "title": "进化算法（1）--单目标遗传算法", 
            "content": "<h2>遗传算法概念</h2><p>       遗传算法是属于进化算法的一种，通过模仿自然界的选择和遗传的特性而演化出的一种优化算法，其优化原理可以概括为，随机产生一个种群（种群大小<i>pop_size</i>自己定义），种群中的每一个个体代表着一个决策变量，将随机生成的<i>pop_size</i>个决策变量带入目标函数求出对应的值，然后根据”优胜劣汰“的准则将值进行筛选，选取“好”的值进入交叉变异，淘汰“坏”的值以达到进化的目的。</p><p>      在计算机程序中，我们经常用‘0&#39;和‘1’序列号来模拟DNA以表示出决策变量的值，而在现实生活中我们需要优化的问题的决策变量往往都是以十进制数的形式表示的，所以我们需要一个模块（定义一个函数<i>translate_DNA）</i>来转换DNA，将十进制数转化为二进制数，或者将二进制数转化为十进制数，得到十进制数之后，带入我们的目标函数，求出对应的值之后我们需要对值（种群）的集合进行筛选判断，什么是“好”的值，什么是“坏”的值，这就是适应度评估，同样的我们可以为它定义一个函数(<i>get_fitness</i>)，具体的评估标准需要根据不同要求而制定。有了评估好坏的标准之后，我们就可以对其进行选择（<i>selection</i>），一般选取的准则是“好”的值选取到的概率大，“坏”的值选取到的概率小，通过不同概率从父代种群中选取个体，但是要保证种群的规模一致，所以需要选取<i>pop_size</i>次，注意每次选取都可以看成是一次独立的行为，所以都一个个体可以多次被选择到。接下来就是交叉变异，将从选择函数（<i>selection</i>）返回的新的种群中的每个个体进行一次交叉配对（模拟自然界生物的交配过程），定义函数<i>crossover来</i>实现交叉配对一般会设置交叉概率，但是通常设为1，就是保证每个个体都能交叉一次，交叉的对象是新的种群中的随机个体，交叉的位置是随机位置。交叉之后每条DNA(种群中的一个个体)，中的每一位都有一定的概率发生变异（<i>mutate</i>），对于‘0’和‘1’的DNA序列，发生变异就是将‘0’变为‘1’，‘1’变为‘0’，因为变异在自然界中是很难发生的，而且变异虽然有一定的概率得到更好的值，但是同样有一定概率得到更差的值，所以一般设置的变异概率都很小（0.001~0.005）。通过N次种群迭代，就能得到较优或最优解。</p><p>       先看一个简单的用遗传算法求解函数最大值的例子。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3a37efe9b7ced757a29b4bb65a2ebce3_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-3a37efe9b7ced757a29b4bb65a2ebce3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-3a37efe9b7ced757a29b4bb65a2ebce3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3a37efe9b7ced757a29b4bb65a2ebce3_b.jpg\"/><figcaption>图 1. 函数图</figcaption></figure><p>例1：求函数 <img src=\"https://www.zhihu.com/equation?tex=y%3Dx+%2A+%5Csin+%2810+%2A+x%29%2Bx+%2A+%5Ccos+%282+%2A+x%29\" alt=\"y=x * \\sin (10 * x)+x * \\cos (2 * x)\" eeimg=\"1\"/> </p><p>1.定义函数模块用于画出曲线图和求函数值</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>f1<span class=\"p\">=</span><span class=\"nf\">fun</span><span class=\"p\">(</span>x<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：决策变量x</span>\n<span class=\"c\">%输出：函数值f1</span>\n     <span class=\"n\">f1</span><span class=\"p\">=</span><span class=\"n\">x</span><span class=\"o\">.*</span><span class=\"nb\">sin</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">x</span><span class=\"o\">.*</span><span class=\"nb\">cos</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">);</span>\n<span class=\"k\">end</span></code></pre></div><p>2.定义DNA转换函数-将DNA的‘0’，‘1’序列转化为十进制数，以便带入上述函数求解</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>pop_dec1<span class=\"p\">=</span><span class=\"nf\">translate_DNA</span><span class=\"p\">(</span>pop,len,DNA_SIZE<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：种群pop</span>\n<span class=\"c\">%      目标函数的决策变量的最大范围len=5</span>\n<span class=\"c\">%      DNA长度</span>\n<span class=\"c\">%输出：十进制数</span>\n    <span class=\"n\">pop_char</span><span class=\"p\">=</span><span class=\"n\">int2str</span><span class=\"p\">(</span><span class=\"n\">pop</span><span class=\"p\">);</span><span class=\"c\">%将整数型转化为字符串</span>\n    <span class=\"n\">pop_dec</span><span class=\"p\">=</span><span class=\"n\">bin2dec</span><span class=\"p\">(</span><span class=\"n\">pop_char</span><span class=\"p\">);</span><span class=\"c\">%将字符串类型表示的二进制数转化为十进制数</span>\n    <span class=\"n\">pop_dec1</span><span class=\"p\">=(</span><span class=\"n\">pop_dec</span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"n\">power</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"n\">DNA_SIZE</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">*</span><span class=\"n\">len</span><span class=\"p\">;</span><span class=\"c\">%将十进制数归一化到1~5之间</span>\n<span class=\"k\">end</span></code></pre></div><p>3.定义适应度函数</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>pred<span class=\"p\">=</span><span class=\"nf\">get_fitness</span><span class=\"p\">(</span>value<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：种群十进制函数值数组value</span>\n<span class=\"c\">%输出：适应度值：pred</span>\n   <span class=\"c\">%定义适应性评估函数，用户评估种群中的个体的好坏（好坏指标自己定义）</span>\n    <span class=\"n\">pred</span><span class=\"p\">=</span><span class=\"n\">value</span><span class=\"o\">+</span><span class=\"mf\">1e-3</span><span class=\"o\">-</span><span class=\"n\">min</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span><span class=\"c\">%这里因为只是找出最大值，所以函数值越大，则越“好”，所以直接取value</span>\n                               <span class=\"c\">%减去最小值是防止出现负数。</span>\n<span class=\"k\">end</span></code></pre></div><p>4.定义选择函数</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>pop<span class=\"p\">=</span><span class=\"nf\">select</span><span class=\"p\">(</span>pop,pred,POP_SIZE<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：种群：pop</span>\n<span class=\"c\">%      适应度值：pred</span>\n<span class=\"c\">%      种群大小：POP_SIZE</span>\n<span class=\"c\">%输出：新种群</span>\n<span class=\"c\">%定义选择函数，选择父方和母方进行交配，适应度越高的越容易被选择到</span>\n    <span class=\"n\">p</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">POP_SIZE</span><span class=\"p\">);</span>\n    <span class=\"n\">p</span><span class=\"p\">=</span><span class=\"n\">pred</span><span class=\"o\">/</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">pred</span><span class=\"p\">);</span>\n    <span class=\"n\">a</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">100</span><span class=\"p\">;</span>\n    <span class=\"n\">idx</span><span class=\"p\">=</span><span class=\"n\">randsrc</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">POP_SIZE</span><span class=\"p\">,[</span><span class=\"n\">a</span><span class=\"p\">;</span><span class=\"n\">p</span><span class=\"p\">]);</span>\n    <span class=\"n\">pop</span><span class=\"p\">=</span> <span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">,:);</span>\n<span class=\"k\">end</span></code></pre></div><p>5.定义交叉函数</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>child<span class=\"p\">=</span><span class=\"nf\">crossover</span><span class=\"p\">(</span>parent,pop,CROSS_RATE<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：新种群中的个体：parent</span>\n<span class=\"c\">%      种群：pop</span>\n<span class=\"c\">%      交叉率：CROSS_RATE</span>\n<span class=\"c\">%输出：子代</span>\n<span class=\"c\">%生成后代函数</span>\n  <span class=\"k\">if</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">&lt;</span><span class=\"n\">CROSS_RATE</span>\n      <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"n\">randi</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">],</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"n\">cross_point</span><span class=\"p\">=</span><span class=\"n\">randi</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">10</span><span class=\"p\">);</span>\n      <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"nb\">find</span><span class=\"p\">(</span><span class=\"n\">cross_point</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"n\">parent</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">)=</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"n\">index</span><span class=\"p\">);</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">child</span><span class=\"p\">=</span><span class=\"n\">parent</span><span class=\"p\">;</span>\n<span class=\"k\">end</span></code></pre></div><p>6.定义变异函数</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>child_mutation<span class=\"p\">=</span><span class=\"nf\">mutate</span><span class=\"p\">(</span>child,MUTATION_RATE,DNA_SIZE<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%输入：子代个体：child</span>\n<span class=\"c\">%      DNA大小：pop</span>\n<span class=\"c\">%      变异率：MUTATION_RATE</span>\n<span class=\"c\">%输出：子代</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">DNA_SIZE</span>\n     <span class=\"k\">if</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">&lt;</span><span class=\"n\">MUTATION_RATE</span>      \n         <span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"mi\">1</span><span class=\"o\">-</span><span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>  \n     <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">child_mutation</span><span class=\"p\">=</span><span class=\"n\">child</span><span class=\"p\">;</span>\n<span class=\"k\">end</span></code></pre></div><p>完整代码见附件：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/ShuminWang1996/mathematical_model/tree/master/general/GA\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-9da9b7534126bf16511d8e31a98e53f1_ipico.jpg\" data-image-width=\"420\" data-image-height=\"420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ShuminWang1996/mathematical_model</a><h2>遗传算法解决TSP问题<sup data-text=\"莫烦python\" data-url=\"https://morvanzhou.github.io/tutorials/machine-learning/evolutionary-algorithm/\" data-draft-node=\"inline\" data-draft-type=\"reference\" data-numero=\"1\">[1]</sup></h2><p>       首先用遗传算法解决不用返回到出发地的旅行商问题，首先考虑DNA的设计，DNA的长度应该与城市的数量对应且每一位对应各个城市的编号，要求编号不重复，而且每个城市编号都包括。</p><p>       用遗传算法解决的关键在于适应度函数的设计，因为旅行商问题是找到最短路径问题（每个城市恰好只到达一次），所以相邻的两个目的地的距离越短，则适应度越高，将所有相邻的目的地的距离相加，则总的和最小的将越容易被选中。</p><p>       交叉和变异，对于交叉，因为，DNA的尺寸和城市的编号有关(DNA的每一位对应一个城市的编号)，而且每个城市恰好都到达一次，所以交叉时必须保持城市的标号都被保留且不重复，为了满足这项要求，我们可以采用如下措施，随机取其中一个父代DNA的对应位，作为子代DNA的前几位，再选取另一个父代对应位(上个父代未选取到的编号对应的位)作为子代DNA的后几位。对于变异，对于可能发生变异的点，其变异表现是与其DNA的某一位发生交换，这样保证了DNA编码的基本要求。</p><p>matlab实现遗传算法TSP代码：</p><div class=\"highlight\"><pre><code class=\"language-matlab\"><span class=\"k\">function</span><span class=\"w\"> </span>pop<span class=\"p\">=</span><span class=\"nf\">generate_pop</span><span class=\"p\">(</span>pop_size,DNA_size<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%该函数用户生成初始种群</span>\n<span class=\"c\">%输入： pop_size是种群大小</span>\n<span class=\"c\">%       DNA_size是DNA长度</span>\n<span class=\"c\">%输出： pop 初始化种群</span>\n   <span class=\"n\">pop</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">pop_size</span><span class=\"p\">,</span><span class=\"n\">DNA_size</span><span class=\"p\">);</span>\n   <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">pop_size</span>\n       <span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)=</span><span class=\"n\">randperm</span><span class=\"p\">(</span><span class=\"n\">DNA_size</span><span class=\"p\">);</span>\n   <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>[line_x,line_y]<span class=\"p\">=</span><span class=\"nf\">translate_DNA</span><span class=\"p\">(</span>pop,city_position<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%    pop_char=int2str(pop);</span>\n<span class=\"c\">%    pop_dec=bin2dec(pop_char);</span>\n<span class=\"c\">%    pop_dec1=(pop_dec/(power(2,DNA_SIZE)-1))*len;</span>\n   <span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">pop</span><span class=\"p\">);</span>\n   <span class=\"n\">line_x</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n   <span class=\"n\">line_y</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n   <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n       <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:);</span>\n       <span class=\"n\">city_coord</span><span class=\"p\">=</span><span class=\"n\">city_position</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">,:);</span>\n       <span class=\"n\">line_x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)=</span><span class=\"n\">city_coord</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n       <span class=\"n\">line_y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)=</span><span class=\"n\">city_coord</span><span class=\"p\">(:,</span><span class=\"mi\">2</span><span class=\"p\">);</span>      \n   <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>[pred,total_distance]<span class=\"p\">=</span><span class=\"nf\">get_fitness</span><span class=\"p\">(</span>line_x,line_y<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%定义适应性评估函数，用户评估种群中的个体的好坏（好坏指标自己定义）</span>\n    <span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">line_x</span><span class=\"p\">);</span>\n    <span class=\"n\">total_distance</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n       <span class=\"n\">total_distance</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"nb\">sqrt</span><span class=\"p\">(</span><span class=\"n\">power</span><span class=\"p\">(</span><span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">line_x</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)),</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"n\">power</span><span class=\"p\">(</span><span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">line_y</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,:)),</span><span class=\"mi\">2</span><span class=\"p\">)));</span>\n    <span class=\"k\">end</span>\n<span class=\"c\">%     pred=exp(n*2/total_distance);</span>\n    <span class=\"n\">pred</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n         <span class=\"n\">pred</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"nb\">exp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">*</span><span class=\"mi\">2</span><span class=\"o\">/</span><span class=\"n\">total_distance</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n    <span class=\"k\">end</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>pop1<span class=\"p\">=</span><span class=\"nf\">select</span><span class=\"p\">(</span>pop,pred<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%定义选择函数，选择父方和母方进行交配，适应度越高的越容易被选择到</span>\n  <span class=\"p\">[</span><span class=\"o\">~</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">pred</span><span class=\"p\">);</span>\n   <span class=\"n\">p</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">);</span>\n   <span class=\"n\">p</span><span class=\"p\">=</span><span class=\"n\">pred</span><span class=\"o\">/</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">pred</span><span class=\"p\">);</span>\n<span class=\"c\">%   a=1:1:m;</span>\n<span class=\"c\">%   idx=randsrc(1,m,[a;p]);</span>\n<span class=\"c\">%   pop1= pop(idx,:);</span>\n  <span class=\"n\">p_sort</span><span class=\"p\">=</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">,</span><span class=\"s\">&#39;descend&#39;</span><span class=\"p\">);</span>\n  <span class=\"n\">idx</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">);</span>\n  <span class=\"n\">idx1</span><span class=\"p\">=</span><span class=\"nb\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">);</span>\n  <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">m</span>\n      <span class=\"n\">idx_arr</span><span class=\"p\">=</span><span class=\"nb\">find</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">==</span><span class=\"n\">p_sort</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">));</span>\n      <span class=\"n\">idx</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">idx_arr</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">idx1</span><span class=\"p\">=</span><span class=\"nb\">repmat</span><span class=\"p\">(</span><span class=\"n\">idx</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">25</span><span class=\"p\">),</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"o\">/</span><span class=\"mi\">25</span><span class=\"p\">);</span>\n  <span class=\"n\">pop1</span><span class=\"p\">=</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">idx1</span><span class=\"p\">,:);</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>child<span class=\"p\">=</span><span class=\"nf\">crossover</span><span class=\"p\">(</span>parent,pop,CROSS_RATE<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"c\">%生成后代函数</span>\n<span class=\"p\">[</span><span class=\"n\">m</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">]=</span><span class=\"nb\">size</span><span class=\"p\">(</span><span class=\"n\">pop</span><span class=\"p\">);</span>\n  <span class=\"k\">if</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">&lt;</span><span class=\"n\">CROSS_RATE</span>\n      <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"n\">randi</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">m</span><span class=\"p\">],</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n      <span class=\"n\">cross_point</span><span class=\"p\">=</span><span class=\"n\">randi</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">],</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">n</span><span class=\"p\">);</span>\n      <span class=\"n\">index</span><span class=\"p\">=</span><span class=\"n\">cross_point</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n      <span class=\"n\">keep_city</span><span class=\"p\">=</span><span class=\"n\">parent</span><span class=\"p\">(</span><span class=\"n\">index</span><span class=\"p\">);</span>\n      <span class=\"n\">swap_city</span><span class=\"p\">=[];</span>\n      <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">n</span>\n          <span class=\"k\">if</span> <span class=\"o\">~</span><span class=\"n\">ismember</span><span class=\"p\">(</span> <span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">),</span><span class=\"n\">keep_city</span><span class=\"p\">)</span>\n              <span class=\"n\">swap_city</span><span class=\"p\">=[</span><span class=\"n\">swap_city</span> <span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">,</span><span class=\"nb\">j</span><span class=\"p\">)];</span>\n          <span class=\"k\">end</span>\n      <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">child</span><span class=\"p\">=[</span><span class=\"n\">keep_city</span> <span class=\"n\">swap_city</span><span class=\"p\">];</span>\n<span class=\"k\">end</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>child_mutation<span class=\"p\">=</span><span class=\"nf\">mutate</span><span class=\"p\">(</span>child,MUTATION_RATE,DNA_size<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">  </span><span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">DNA_size</span>\n     <span class=\"k\">if</span> <span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">&lt;</span><span class=\"n\">MUTATION_RATE</span>      \n        <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"n\">randi</span><span class=\"p\">([</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"n\">DNA_size</span><span class=\"p\">],</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">swap</span><span class=\"p\">=</span><span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">);</span>\n        <span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">i</span><span class=\"p\">)=</span><span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">);</span>\n        <span class=\"n\">child</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">)=</span><span class=\"n\">swap</span><span class=\"p\">;</span>\n     <span class=\"k\">end</span>\n  <span class=\"k\">end</span>\n  <span class=\"n\">child_mutation</span><span class=\"p\">=</span><span class=\"n\">child</span><span class=\"p\">;</span>\n<span class=\"k\">end</span>\n\n<span class=\"n\">city_position</span><span class=\"p\">=</span><span class=\"nb\">rand</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"mi\">20</span><span class=\"p\">;</span>\n\n<span class=\"k\">function</span><span class=\"w\"> </span>[pop,max_pop,max1,F_value]<span class=\"p\">=</span><span class=\"nf\">main</span><span class=\"p\">(</span>city_position<span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">pop_size</span><span class=\"p\">=</span><span class=\"mi\">500</span><span class=\"p\">;</span>\n    <span class=\"n\">DNA_size</span><span class=\"p\">=</span><span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"n\">MUTATION_RATE</span><span class=\"p\">=</span><span class=\"mf\">0.003</span><span class=\"p\">;</span>\n    <span class=\"n\">CROSS_RATE</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">N_GENERATION</span><span class=\"p\">=</span><span class=\"mi\">200</span><span class=\"p\">;</span>\n    <span class=\"c\">%city_position=rand(DNA_size,2);</span>\n    <span class=\"n\">pop</span><span class=\"p\">=</span><span class=\"n\">generate_pop</span><span class=\"p\">(</span><span class=\"n\">pop_size</span><span class=\"p\">,</span><span class=\"n\">DNA_size</span><span class=\"p\">);</span>\n    <span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">city_position</span><span class=\"p\">(:,</span><span class=\"mi\">1</span><span class=\"p\">),</span><span class=\"n\">city_position</span><span class=\"p\">(:,</span><span class=\"mi\">2</span><span class=\"p\">),</span>&#34;<span class=\"n\">filled</span>&#34;<span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"nb\">i</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">N_GENERATION</span>\n        <span class=\"p\">[</span><span class=\"n\">line_x</span><span class=\"p\">,</span><span class=\"n\">line_y</span><span class=\"p\">]=</span><span class=\"n\">translate_DNA</span><span class=\"p\">(</span><span class=\"n\">pop</span><span class=\"p\">,</span><span class=\"n\">city_position</span><span class=\"p\">);</span>\n        <span class=\"p\">[</span><span class=\"n\">pred</span><span class=\"p\">,</span><span class=\"n\">total_distance</span><span class=\"p\">]=</span><span class=\"n\">get_fitness</span><span class=\"p\">(</span><span class=\"n\">line_x</span><span class=\"p\">,</span><span class=\"n\">line_y</span><span class=\"p\">);</span>\n         <span class=\"n\">pop</span><span class=\"p\">=</span><span class=\"n\">select</span><span class=\"p\">(</span><span class=\"n\">pop</span><span class=\"p\">,</span><span class=\"n\">pred</span><span class=\"p\">);</span>  \n        <span class=\"k\">for</span> <span class=\"nb\">j</span><span class=\"p\">=</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"n\">pop_size</span>\n            <span class=\"n\">parent</span><span class=\"p\">=</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">,:);</span>\n            <span class=\"n\">child</span><span class=\"p\">=</span><span class=\"n\">crossover</span><span class=\"p\">(</span><span class=\"n\">parent</span><span class=\"p\">,</span><span class=\"n\">pop1</span><span class=\"p\">,</span><span class=\"n\">CROSS_RATE</span><span class=\"p\">);</span>\n            <span class=\"n\">child_mutation</span><span class=\"p\">=</span><span class=\"n\">mutate</span><span class=\"p\">(</span><span class=\"n\">child</span><span class=\"p\">,</span><span class=\"n\">MUTATION_RATE</span><span class=\"p\">,</span><span class=\"n\">DNA_size</span><span class=\"p\">);</span>\n            <span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"nb\">j</span><span class=\"p\">,:)=</span><span class=\"n\">child_mutation</span><span class=\"p\">;</span>\n        <span class=\"k\">end</span>\n    <span class=\"k\">end</span>\n<span class=\"c\">%   scatter(pop_dec,F_value,&#34;filled&#34;);</span>\n    <span class=\"n\">max1</span><span class=\"p\">=</span><span class=\"nb\">find</span><span class=\"p\">(</span><span class=\"n\">pred</span><span class=\"o\">==</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">pred</span><span class=\"p\">));</span>\n    <span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">line_x</span><span class=\"p\">(</span><span class=\"n\">max1</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),:),</span><span class=\"n\">line_y</span><span class=\"p\">(</span><span class=\"n\">max1</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),:));</span>\n    <span class=\"n\">max_pop</span><span class=\"p\">=</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">max1</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),:);</span>\n    <span class=\"n\">F_value</span><span class=\"p\">=</span><span class=\"n\">total_distance</span><span class=\"p\">(</span><span class=\"n\">max1</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n<span class=\"k\">end</span></code></pre></div><p>运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0784fcb26830af6d8621aa332affa7a6_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-0784fcb26830af6d8621aa332affa7a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-0784fcb26830af6d8621aa332affa7a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0784fcb26830af6d8621aa332affa7a6_b.jpg\"/><figcaption>图 2. TSP路径</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "TSP问题", 
                    "tagLink": "https://api.zhihu.com/topics/20004129"
                }, 
                {
                    "tag": "数学建模", 
                    "tagLink": "https://api.zhihu.com/topics/19575624"
                }, 
                {
                    "tag": "遗传算法", 
                    "tagLink": "https://api.zhihu.com/topics/19555677"
                }
            ], 
            "comments": [
                {
                    "userName": "夏珊", 
                    "userLink": "https://www.zhihu.com/people/8525bd7d0d324972292aba5ea0af86f6", 
                    "content": "好不错😊", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1147882811452215296"
}
