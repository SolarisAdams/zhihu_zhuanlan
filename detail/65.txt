{
    "title": "深入理解c/c++", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/cheng-peng-44-17", 
        "https://www.zhihu.com/people/chenyuecn", 
        "https://www.zhihu.com/people/tianrui007", 
        "https://www.zhihu.com/people/da-ye-37-8", 
        "https://www.zhihu.com/people/da-da-83-97", 
        "https://www.zhihu.com/people/cai-guang-yao", 
        "https://www.zhihu.com/people/huang-mu-shan-93", 
        "https://www.zhihu.com/people/huang-walker", 
        "https://www.zhihu.com/people/walter-32", 
        "https://www.zhihu.com/people/john-24-8", 
        "https://www.zhihu.com/people/lizhanhui", 
        "https://www.zhihu.com/people/wang-jun-56-36", 
        "https://www.zhihu.com/people/zllz-23", 
        "https://www.zhihu.com/people/cai-yue-cheng-95", 
        "https://www.zhihu.com/people/zheng-jinli", 
        "https://www.zhihu.com/people/hong-san-84", 
        "https://www.zhihu.com/people/crr-10-75", 
        "https://www.zhihu.com/people/chen-yi-bo-31-39", 
        "https://www.zhihu.com/people/tang-hong-tao-81-44", 
        "https://www.zhihu.com/people/bneliao", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/remind-41", 
        "https://www.zhihu.com/people/yang-jian-feng-85-30", 
        "https://www.zhihu.com/people/wan-qing-53-32", 
        "https://www.zhihu.com/people/outofmomery", 
        "https://www.zhihu.com/people/qiu-qiu-55-35-58", 
        "https://www.zhihu.com/people/crouchggj", 
        "https://www.zhihu.com/people/xiao-gang-75-81", 
        "https://www.zhihu.com/people/ji-zhi-shao-nian-14", 
        "https://www.zhihu.com/people/blong-zhou", 
        "https://www.zhihu.com/people/18928026221", 
        "https://www.zhihu.com/people/oliver-kahn-60", 
        "https://www.zhihu.com/people/dengwenwu", 
        "https://www.zhihu.com/people/ji-bei-zhi-xing", 
        "https://www.zhihu.com/people/trevor211", 
        "https://www.zhihu.com/people/shao-lin-xiao-zi-24", 
        "https://www.zhihu.com/people/wang-peng-cheng-97-49", 
        "https://www.zhihu.com/people/liu-sir-65-15", 
        "https://www.zhihu.com/people/frandy-cheng", 
        "https://www.zhihu.com/people/chen-chen-76-91-18", 
        "https://www.zhihu.com/people/dao-suan", 
        "https://www.zhihu.com/people/da-zuo-68", 
        "https://www.zhihu.com/people/zhao-guang-65", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/niu-jin-wei-71", 
        "https://www.zhihu.com/people/leung-64", 
        "https://www.zhihu.com/people/appleleaf", 
        "https://www.zhihu.com/people/qiyi", 
        "https://www.zhihu.com/people/shallow-75-50", 
        "https://www.zhihu.com/people/table-young", 
        "https://www.zhihu.com/people/jason-61-44-76", 
        "https://www.zhihu.com/people/nj82930", 
        "https://www.zhihu.com/people/zhao-xiao-5", 
        "https://www.zhihu.com/people/abmin", 
        "https://www.zhihu.com/people/gongmw", 
        "https://www.zhihu.com/people/er-ji-67-23", 
        "https://www.zhihu.com/people/kissweb", 
        "https://www.zhihu.com/people/richard-71-95-83", 
        "https://www.zhihu.com/people/li-xin-meng-96-20", 
        "https://www.zhihu.com/people/qi-yi-ke-97", 
        "https://www.zhihu.com/people/mu-a-hao", 
        "https://www.zhihu.com/people/stuartgates", 
        "https://www.zhihu.com/people/chun-ri-51", 
        "https://www.zhihu.com/people/kidding-iam", 
        "https://www.zhihu.com/people/huo-zai-dang-xia-79", 
        "https://www.zhihu.com/people/jiu-bu-gao-su-ni-42", 
        "https://www.zhihu.com/people/liu-xiao-yao-12", 
        "https://www.zhihu.com/people/jing-wang-43", 
        "https://www.zhihu.com/people/xiao-xin-de-la-bi", 
        "https://www.zhihu.com/people/jiang-wen-ming-15", 
        "https://www.zhihu.com/people/gnepnaur", 
        "https://www.zhihu.com/people/xie-ying-62-9", 
        "https://www.zhihu.com/people/cook-cooller", 
        "https://www.zhihu.com/people/li-yi-jun-7-90", 
        "https://www.zhihu.com/people/zhang-zi-cheng-81", 
        "https://www.zhihu.com/people/leon-38-8", 
        "https://www.zhihu.com/people/gu-xi-38-70", 
        "https://www.zhihu.com/people/li-wei-14-50", 
        "https://www.zhihu.com/people/zephyrer", 
        "https://www.zhihu.com/people/sui-mo-nian-chu-32", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/a-a-a-98", 
        "https://www.zhihu.com/people/EvanCN", 
        "https://www.zhihu.com/people/che-an-28", 
        "https://www.zhihu.com/people/timothy-11", 
        "https://www.zhihu.com/people/wanghenshui", 
        "https://www.zhihu.com/people/he-bing-long", 
        "https://www.zhihu.com/people/viscly", 
        "https://www.zhihu.com/people/programmer_song", 
        "https://www.zhihu.com/people/ling-yiwang", 
        "https://www.zhihu.com/people/wang-zhen-85-71", 
        "https://www.zhihu.com/people/ying-san-ling-luan", 
        "https://www.zhihu.com/people/zhang-zhi-jian-21-13", 
        "https://www.zhihu.com/people/sommermit", 
        "https://www.zhihu.com/people/201511", 
        "https://www.zhihu.com/people/mrmorry-7", 
        "https://www.zhihu.com/people/mr-robot-27", 
        "https://www.zhihu.com/people/dh-chen-53", 
        "https://www.zhihu.com/people/snow_wolf", 
        "https://www.zhihu.com/people/logo-97-75", 
        "https://www.zhihu.com/people/cai-long-67", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/szqh97", 
        "https://www.zhihu.com/people/da-hu-you-85", 
        "https://www.zhihu.com/people/spring-star", 
        "https://www.zhihu.com/people/xu-fei-35-75", 
        "https://www.zhihu.com/people/hello-27-14-13", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/cryonyx", 
        "https://www.zhihu.com/people/wherewindblow", 
        "https://www.zhihu.com/people/uestcpeco", 
        "https://www.zhihu.com/people/NessajHu", 
        "https://www.zhihu.com/people/jin-liang-21-65", 
        "https://www.zhihu.com/people/li-jiang-bo-30", 
        "https://www.zhihu.com/people/han-junpengh", 
        "https://www.zhihu.com/people/YukiSou", 
        "https://www.zhihu.com/people/chen-xiao-dong-72-56", 
        "https://www.zhihu.com/people/fourhu-68", 
        "https://www.zhihu.com/people/wushifu", 
        "https://www.zhihu.com/people/ha-ha-17-96-16", 
        "https://www.zhihu.com/people/li-hong-lin-59-30", 
        "https://www.zhihu.com/people/wang-bing-cao", 
        "https://www.zhihu.com/people/zhi-zhang-86-25", 
        "https://www.zhihu.com/people/zhang-wen-71-57", 
        "https://www.zhihu.com/people/hu-hai-bo-9", 
        "https://www.zhihu.com/people/bruce-ye", 
        "https://www.zhihu.com/people/what-so-", 
        "https://www.zhihu.com/people/tao-de-72", 
        "https://www.zhihu.com/people/yang-jun-yi-98-1", 
        "https://www.zhihu.com/people/cliff-yuan", 
        "https://www.zhihu.com/people/jie-cheng-hao", 
        "https://www.zhihu.com/people/andyflyagain", 
        "https://www.zhihu.com/people/afterlook", 
        "https://www.zhihu.com/people/zu-huai-te", 
        "https://www.zhihu.com/people/leether", 
        "https://www.zhihu.com/people/tan-bin-63-48", 
        "https://www.zhihu.com/people/you-yuan-10", 
        "https://www.zhihu.com/people/camark", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/zhouzhuabin5", 
        "https://www.zhihu.com/people/hangcui", 
        "https://www.zhihu.com/people/cavendish", 
        "https://www.zhihu.com/people/whsanshugong", 
        "https://www.zhihu.com/people/diluga-salome", 
        "https://www.zhihu.com/people/whst", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/huangwang-zuo", 
        "https://www.zhihu.com/people/zhang-yifeng", 
        "https://www.zhihu.com/people/sparrow", 
        "https://www.zhihu.com/people/hao-yu-80", 
        "https://www.zhihu.com/people/lgd-dogv", 
        "https://www.zhihu.com/people/yang-ray-5", 
        "https://www.zhihu.com/people/mai-yue", 
        "https://www.zhihu.com/people/guoqiang-zheng-81", 
        "https://www.zhihu.com/people/lsl-1", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/wudalu", 
        "https://www.zhihu.com/people/xie-xiao-rong-23", 
        "https://www.zhihu.com/people/nilshine", 
        "https://www.zhihu.com/people/ye-de-wen-zhang", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/da-sha-ai-mang-guo", 
        "https://www.zhihu.com/people/hintonic", 
        "https://www.zhihu.com/people/lei-yu-10-27", 
        "https://www.zhihu.com/people/edidada", 
        "https://www.zhihu.com/people/du-du-46-77-99", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/metalsteel", 
        "https://www.zhihu.com/people/gong-fu-72-27", 
        "https://www.zhihu.com/people/huo-hao-97", 
        "https://www.zhihu.com/people/ma-ti-60", 
        "https://www.zhihu.com/people/duan-ji-lue", 
        "https://www.zhihu.com/people/xiao-han-13-60", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/yao-yi-zheng-84", 
        "https://www.zhihu.com/people/duan-fang-liang", 
        "https://www.zhihu.com/people/jiang-zhe-90-35"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/72917950", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 5, 
            "title": "性能分析与优化前传", 
            "content": "<h2>性能分析与优化前传</h2><p>在实际的开发过程中，我们经常会碰到程序的性能问题。性能的分析和优化是后台开发中的一项重要的必备技能呢。此文主要讲linux后台开发过程中的一些必备知识，澄清一些常见误区；讲解一些原理与常用的性能分析命令和工具。另外本系列文章也会解答与澄清一些常见的错误与问题：</p><ol><li>SMP架构和NUM架构有什么区别？NUMA架构下的用户态编程，有必要绑定进程到特定的node或者cpu么？</li><li>超线程技术在硬件上是如何支持的？所谓的“单核双线程”与“多核”有什么物理层面和用户态层面的区别？</li><li><code>cat /proc/cpuinfo</code>的输出中各种cpu core、物理cpu、逻辑cpu有什么区别？</li><li><code>uptime</code>命令输出的负载代表什么含义？对于一个仅仅包含内存计算的死循环，运行1min后，1min内的系统负载一定是1吗？<code>uptime</code>的输出值为多少，意味着系统过载？</li><li>进程的uninteruptable状态表示什么含义? 这种状态下的进程真的不能响应外部信号吗？</li></ol><h2>多处理器体系结构</h2><p>在提升计算机的计算效率方面，主要有两个大的发展方向：1.提升时钟周期，让单位时间内可运行的指令条数尽可能多； 2.提高CPU核数量，使得单位时间可并行执行的CPU指令尽可能多。 第一种发展方向就是不断提升CPU主频，这个方向随着摩尔定律的限制在当前已经到达一个瓶颈，当下主流桌面CPU的主频大概是2.3 Ghz左右。而对于第二种并行化的方向，需要做的是尽可能多增加CPU核心数量，同时增加CPU单个核心可并行的线程数量。</p><p>简单来说，对称多处理器结构 (SMP ： Symmetric Multi-Processor) 和 非一致存储访问结构 (NUMA ： Non-Uniform Memory Access)  的差异仅仅在于CPU与内存的互联方式。SMP架构下，多个CPU与内存是相同的关系，每个CPU能够访问到所有的内存，速度也是没有任何差异的；资源的竞争问题，通过软硬件层面的锁来解决；SMP架构的核心在于共享。而NUMA架构，具有多个CPU模块，每个CPU模块内部，可以认为是一个SMP架构。    NUMA架构中，从CPU的视角而言，内存分为两类：本地内存和远端内存，其中对本地内存的访问要比远端内存要快。NUMA架构与SMP架构的简图如下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8d4123c27a31f0ca572c4dc019cd02d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"949\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb\" width=\"949\" data-original=\"https://pic1.zhimg.com/v2-8d4123c27a31f0ca572c4dc019cd02d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;949&#39; height=&#39;616&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"949\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"949\" data-original=\"https://pic1.zhimg.com/v2-8d4123c27a31f0ca572c4dc019cd02d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8d4123c27a31f0ca572c4dc019cd02d4_b.jpg\"/></figure><p> 关于NUMA中的一些概念，我们将在下文中详细论述。</p><h2>CPU 微体系结构</h2><p><b>传统CPU的组成</b> 从物理角度讲，CPU的构成包括计算单元、寄存器、cache等。一个简单的CPU架构图如图所示。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e02b7a7d74218461bcd31eb15dbca9c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"499\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic2.zhimg.com/v2-e02b7a7d74218461bcd31eb15dbca9c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"499\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic2.zhimg.com/v2-e02b7a7d74218461bcd31eb15dbca9c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e02b7a7d74218461bcd31eb15dbca9c5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于现代CPU而言，指令的执行分为五个步骤：取指令（IF）、指令译码（ID）、执行指令（EX）、访存取数（MEM）、结果写回(RB)。为了增加指令的并行度、提升指令的执行速度，现代处理器广泛用到了流水线技术、并行流水线技术；基于此技术，又诞生了分支预测、指令重排等技术。这就使得CPU的内部结构变得更加复杂。一个典型的CPU组成结构如下图所示。实际上，一个当下的x86架构CPU包含：运算单元（ALU、FPU）、寄存器（PC等控制寄存器、通用寄存器、状态寄存器等）、cache（指令数据cache、TLB、指令缓冲区等）等。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3dd9c41aa656bbf14c4dc2a26f69f71b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"1000\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-3dd9c41aa656bbf14c4dc2a26f69f71b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;1000&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"1000\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-3dd9c41aa656bbf14c4dc2a26f69f71b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3dd9c41aa656bbf14c4dc2a26f69f71b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>超线程技术</b> 简单来说，就是允许一个CPU core同时运行两个线程。CPU内部的资源可以分为如下三种：多副本的资源（例如指令寄存处IP）； 分区使用的资源（例如ROB）；可共享的资源（例如cache）。超线程虽然允许一个cpu core能够同时运行多个线程，但是多个CPU核中，虽然对应的指令寄存器有多个，对应的计算单元只有一个（例如ALU，FPU）。也就是说，如果两个线程运行在同一个核上，而且这两个线程都需要进行浮点运算，那么必然会有一个线程处在“等待”状态。更信息的信息可以参考：<a href=\"https://link.zhihu.com/?target=https%3A//arstechnica.com/features/2002/10/hyperthreading/4/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">超线程技术</a></p><h2>进程的几种状态</h2><p>在传统的OS教材中，将进程的状态分为三种“运行态、就绪态、阻塞态”。在linux系统中，当下进程主要有如下几种状态：</p><p>进程状态 | 解释 | ps命令输出 :-: | :-: | :-: TASK_RUNNING | 运行状态（正在被CPU调度执行或者处在运行队列中等待被执行）| Running TASK_INTERRUPTIBLE | 可中断的睡眠状态。正在等待某个条件满足 | Sleeping TASK_UNINTERRUPTIBLE  | 不可中断的睡眠状态。不会被信号中断 | DiskSleeping EXIT_ZOMBIE | 僵尸状态。进程已经退出，但尚未被父进程或者init进程收尸 | Zombie __TASK_STOPPED | 暂停状态。收到某种信号，运行被停止 | Terminated __TASK_TRACED | 被跟踪状态。进程停止，被另一个进程跟踪 | traced TASK_KILLABLE | 由于不可中断的睡眠状态中，等待的信号有可能永远不会发生，导致进程无法被杀死也不能调度运行，所以2.6.25之后的内核引入了新状态 | D</p><p>注意，当下（2.6.25 kernel之后）的进程状态是可以响应信号的，也可以被kill命令终止。进程之间的几种状态转换图关系如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7ccd99fab29bcb4614e97b9b27870525_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic2.zhimg.com/v2-7ccd99fab29bcb4614e97b9b27870525_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic2.zhimg.com/v2-7ccd99fab29bcb4614e97b9b27870525_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7ccd99fab29bcb4614e97b9b27870525_b.jpg\"/></figure><h2>常用的性能分析命令</h2><h3>架构识别</h3><p>NUMA相关的几个概念有node、socket、core和thread。Socket是一个物理上的概念，指的是主板上的cpu插槽。Node是一个逻辑上的概念，对应于socket。Core就是一个物理cpu, 拥有独立的硬件执行单元。Thread就是超线程的概念，是一个逻辑cpu，共享core上的执行单元。我们输入<code>lscpu</code>得到如下结果：</p><div class=\"highlight\"><pre><code class=\"language-text\">$ lscpu\nCPU(s):                48\nOn-line CPU(s) list:   0-47\nThread(s) per core:    2\nCore(s) per socket:    12\nSocket(s):             2\nNUMA node(s):          2\nL1d cache:             32K\nL1i cache:             32K\nL2 cache:              256K\nL3 cache:              30720K\nNUMA node0 CPU(s):     0-11,24-35\nNUMA node1 CPU(s):     12-23,36-47</code></pre></div><p>这台主机是NUMA架构，一共有两个socket(node)，每个node上有12个cpu core，每个cpu core支持双线程，一共含有的逻辑cpu个数是2 * 12 * 12 = 48.</p><p>当然，我们也可以从<code>cat /proc/cpuinfo</code>的输出结果来详细查看每个逻辑CPU对应的详细参数。其中某个逻辑CPU的输出如下。</p><div class=\"highlight\"><pre><code class=\"language-text\">processor   : 47\nvendor_id   : GenuineIntel\ncpu family  : 6\nmodel       : 79\nmodel name  : Intel(R) Xeon(R) CPU E5-2650 v4 @ 2.20GHz\nstepping    : 1\nmicrocode   : 0xb00001f\ncpu MHz     : 2197.596\ncache size  : 30720 KB\nphysical id : 1\nsiblings    : 24\ncore id     : 13\ncpu cores   : 12\napicid      : 59\ninitial apicid  : 59\nfpu     : yes\nfpu_exception   : yes\ncpuid level : 20\nwp      : yes\nflags       : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc aperfmperf eagerfpu pni pclmulqdq dtes64 ds_cpl vmx smx est tm2 ssse3 fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer aes xsave avx f16c rdrand lahf_lm abm 3dnowprefetch arat epb pln pts dtherm intel_pt tpr_shadow vnmi flexpriority ept vpid fsgsbase tsc_adjust bmi1 hle avx2 smep bmi2 erms invpcid rtm cqm rdseed adx smap xsaveopt cqm_llc cqm_occup_llc cqm_mbm_total cqm_mbm_local\nbogomips    : 4402.55\nclflush size    : 64\ncache_alignment : 64\naddress sizes   : 46 bits physical, 48 bits virtual</code></pre></div><p>其中，processor代表逻辑cpu的编号，siblings表示和这个cpu共享相同本地内存的兄弟cpu的个数，core id表示同一个node下面cpu core的编号，cpu cores表示同一个node下cpu core的数量。另外，我们可以读取到更加详细的信息如下. 从如下的信息中，我们知道：同一个core下的不同逻辑CPU共享了L1/L2缓存，L3缓存是一个node上的物理cpu core共享的。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ cat /sys/devices/system/cpu/cpu0/cache/index0/shared_cpu_list\n0,24\n$ cat /sys/devices/system/cpu/cpu24/cache/index0/shared_cpu_list\n0,24\n$ cat /sys/devices/system/cpu/cpu24/cache/index3/shared_cpu_list\n0-11,24-35\n$ cat /sys/devices/system/cpu/cpu24/cache/index2/shared_cpu_list\n0,24\n$ cat /sys/devices/system/cpu/cpu24/cache/index1/shared_cpu_list\n0,24</code></pre></div><p>结合cpuinfo的输出和这部分信息，我们可以得到大致如下的CPU架构图。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e505b4a83e9d4cf63aa0d303122d0418_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1442\" data-rawheight=\"1169\" class=\"origin_image zh-lightbox-thumb\" width=\"1442\" data-original=\"https://pic1.zhimg.com/v2-e505b4a83e9d4cf63aa0d303122d0418_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1442&#39; height=&#39;1169&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1442\" data-rawheight=\"1169\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1442\" data-original=\"https://pic1.zhimg.com/v2-e505b4a83e9d4cf63aa0d303122d0418_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e505b4a83e9d4cf63aa0d303122d0418_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>另外，我们也可以用<code>numactl --hardware</code>查看numa架构的其他信息(例如每个socket的本地内存数量和访存距离、内存命中率等）。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ numactl --hardware\navailable: 2 nodes (0-1)\nnode 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 24 25 26 27 28 29 30 31 32 33 34 35\nnode 0 size: 130946 MB\nnode 0 free: 20088 MB\nnode 1 cpus: 12 13 14 15 16 17 18 19 20 21 22 23 36 37 38 39 40 41 42 43 44 45 46 47\nnode 1 size: 131072 MB\nnode 1 free: 21241 MB\nnode distances:\nnode   0   1\n  0:  10  21\n  1:  21  10\n\n$ numastat\n                           node0           node1\nnuma_hit            307303747546    380166783764\nnuma_miss              373916124      2846720578\nnuma_foreign          2846720578       373916124\ninterleave_hit            724995          245240\nlocal_node          307301805902    380169646156\nother_node             375857768      2843858186</code></pre></div><h3>系统负载</h3><p>查看系统的负载可以用<code>uptime</code>或者<code>cat /proc/loadavg</code>, 输出如下。<code>uptime</code>的详细探究，可以参考这篇blog。<a href=\"https://link.zhihu.com/?target=http%3A//www.brendangregg.com/blog/2017-08-08/linux-load-averages.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">runtime详细探究</a></p><div class=\"highlight\"><pre><code class=\"language-text\"># taoyuan @ VM_0_8_centos in ~ [23:54:12]\n$ uptime\n 23:54:38 up 37 days, 10:43,  1 user,  load average: 0.18, 0.07, 0.06</code></pre></div><p>另外, 我们可以利用<code>vmstat</code>查看CPU、MEM、IO方面的详细负载情况：</p><div class=\"highlight\"><pre><code class=\"language-text\">$ vmstat\nprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n 7  0 15823084 42162896 184148 163171296    0    0     4    20    0    0  7 15 78  0  0</code></pre></div><p>关于linux系统上load average的输出，我们做如下说明：</p><ol><li>load average输出的是过去1、5、15min内的系统负载，可以简单认为是线程数量</li><li>第一点中的线程数量，是指处于运行状态 + 处于uninterruptible状态（等待disk-io和锁）的线程数量。这也就意味着，系统负载不仅仅是CPU资源的衡量，还包括Disk-IO方面的资源（处于uninterruptible状态的进程很可能在等待磁盘IO）</li><li>这个数值并没有按照CPU的核心数量进行归一化。如果我们按照CPU的（物理）核心数量进行归一化处理，归一化之后的数值超过0.7，那么适当关注程序性能；如果超过1.0，那么应该立即排查相关程序；如果超过5.0，那么此时程序性能应该已经严重下降。</li><li>如果现在起一个死循环，进行纯粹的计算，那么uptime并不会在1min内达到1, 在1min的时候只能达到0.62左右</li><li><code>vmstat</code>的输出中，r对应列的数值，才代表纯粹的CPU负载：处于运行态的进程数量。</li></ol><h2>总结</h2><p>目前主流通用服务器的架构基本都是numa架构，numa架构下有node、cpu core、cpu等三层的概念。可以认为线程是运行在cpu之上的。而线程在调度过程中，有多种状态。其中系统负载综合考量了系统中处在运行态和不可中断睡眠状态的线程数量之和：我们结合load average和系统中的cpu数量，可以衡量当前系统的负载。通过<code>vmstat</code>的输出，我们可以初步确定当前程序的瓶颈所在。</p>", 
            "topic": [
                {
                    "tag": "性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19633850"
                }, 
                {
                    "tag": "计算机体系架构", 
                    "tagLink": "https://api.zhihu.com/topics/19717470"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70140201", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 1, 
            "title": "获取详细的增量代码覆盖率", 
            "content": "<p><b>摘要：</b>为了提升线上服务的稳定性，我们需要进行详细的测试。代码覆盖率是衡量测试（尤其是单元测试）的详细与周全程度的一个重要指标。在软件开发的过程中，我们会关注两方面的内容：某两次提交之间的增量代表的覆盖率；两次提交之间有哪些代码或者分支没有被覆盖。</p><h2>代码覆盖率</h2><p>目前，对于cpp项目的代码覆盖率，我们使用的是gcovr工具。关于工具的使用，我们可以参考<a href=\"https://link.zhihu.com/?target=https%3A//www.gcovr.com/en/stable/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官网</a>. 这里不详细展开，我们这里展示一张gcovr的总体效果图和详细效果图。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4bfa0d2a8d8896691a8e9a29c9ee1558_b.jpg\" data-size=\"normal\" data-rawwidth=\"2728\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb\" width=\"2728\" data-original=\"https://pic1.zhimg.com/v2-4bfa0d2a8d8896691a8e9a29c9ee1558_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2728&#39; height=&#39;816&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"2728\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2728\" data-original=\"https://pic1.zhimg.com/v2-4bfa0d2a8d8896691a8e9a29c9ee1558_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4bfa0d2a8d8896691a8e9a29c9ee1558_b.jpg\"/><figcaption>图1 gcov代码覆盖率</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e4913a5108761ed894cffdaa8c0391a1_b.jpg\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"596\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-e4913a5108761ed894cffdaa8c0391a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;596&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"596\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-e4913a5108761ed894cffdaa8c0391a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e4913a5108761ed894cffdaa8c0391a1_b.jpg\"/><figcaption>图2：单个文件代码覆盖率</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>增量代码覆盖率</h2><p>有了基础的代码覆盖率，我们在此基础上能够得到增量代码的覆盖率，思路如下。</p><ol><li>根据给定的两个git commit，提取对应commit之间的所有commit</li><li>使用git blame，获取这些这些commit新增的代码所在的文件与行数</li><li>解析基础的覆盖率文件：对应的行数是否被覆盖的信息，得出增量代码的覆盖率结果</li></ol><p>详细的代码在<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yukun89/dcovr\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">dcovr</a>. 我们来看一下效果图。其中，图3给出了某两次提交之间的代码覆盖率的总体信息。图4给出了单个文件中详细的覆盖率信息：其中修改过的code在行首加入了&#34;NN&#34;标记，方便检索。有了这部分信息，我们很容易发现，本次修改有哪些代码没有被测试覆盖。从而在review的时候更加小心，或者增加对应的测试。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-45a00e1d4ce4aec375728d217fc70ddb_b.jpg\" data-size=\"normal\" data-rawwidth=\"2712\" data-rawheight=\"786\" class=\"origin_image zh-lightbox-thumb\" width=\"2712\" data-original=\"https://pic4.zhimg.com/v2-45a00e1d4ce4aec375728d217fc70ddb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2712&#39; height=&#39;786&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"2712\" data-rawheight=\"786\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2712\" data-original=\"https://pic4.zhimg.com/v2-45a00e1d4ce4aec375728d217fc70ddb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-45a00e1d4ce4aec375728d217fc70ddb_b.jpg\"/><figcaption>图3：增量代码覆盖率</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bc2d87664e15d05458d1cabb8f96a2b9_b.jpg\" data-size=\"normal\" data-rawwidth=\"1456\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb\" width=\"1456\" data-original=\"https://pic2.zhimg.com/v2-bc2d87664e15d05458d1cabb8f96a2b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1456&#39; height=&#39;514&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1456\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1456\" data-original=\"https://pic2.zhimg.com/v2-bc2d87664e15d05458d1cabb8f96a2b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bc2d87664e15d05458d1cabb8f96a2b9_b.jpg\"/><figcaption>图4：增量代码覆盖率</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }, 
                {
                    "tag": "软件测试", 
                    "tagLink": "https://api.zhihu.com/topics/19562409"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57258399", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 71, 
            "title": "编译-链接-加载 ：ELF文件格式解析", 
            "content": "<p>摘要：对于C++的初学者，经常在程序的编译或者加载过程中遇到很多错误，类似<code>undefined reference to ...</code> 和 <code>GLIBCXX_3.4.20 not found</code> 等。这些错误都涉及到编译器、连接器、加载器的相关知识。本系列文章，将通过一个实例程序，详细介绍一个程序的编译、链接、加载的过程。为了弄清这个过程，本文会简要介绍文本代码到可执行二进制文件的大致过程，同时介绍x86平台上linux系统下ELF文件格式，方便后续详细探讨<b>编译-链接-加载</b>的详细过程。</p><h2>1. 程序的编译与链接过程</h2><p>对于编译型的程序，代码需要经过编译-链接的过程才会生成可执行程序，具体过程如下</p><div class=\"highlight\"><pre><code class=\"language-text\">=====&gt; COMPILATION PROCESS &lt;======\n\n                     |\n                     |----&gt;  Input is Source file(.c)\n                     |\n                     V\n            +=================+\n            |                 |\n            | C Preprocessor  |\n            |                 |\n            +=================+\n                     |\n                     | ---&gt; Pure C file ( comd:cc -E &lt;file.name&gt; )\n                     |\n                     V\n            +=================+\n            |                 |\n            | Lexical Analyzer|\n            |                 |\n            +-----------------+\n            |                 |\n            | Syntax Analyzer |\n            |                 |\n            +-----------------+\n            |                 |\n            | Semantic Analyze|\n            |                 |\n            +-----------------+\n            |                 |\n            | Pre Optimization|\n            |                 |\n            +-----------------+\n            |                 |\n            | Code generation |\n            |                 |\n            +-----------------+\n            |                 |\n            | Post Optimize   |\n            |                 |\n            +=================+\n                     |\n                     |---&gt;  Assembly code (comd: cc -S &lt;file.name&gt; )\n                     |\n                     V\n            +=================+\n            |                 |\n            |   Assembler     |\n            |                 |\n            +=================+\n                     |\n                     |---&gt;  Object file (.obj) (comd: cc -c &lt;file.name&gt;)\n                     |\n                     V\n            +=================+\n            |     Linker      |\n            |      and        |\n            |     loader      |\n            +=================+\n                     |\n                     |---&gt;  Executable (.Exe/a.out) (com:cc &lt;file.name&gt; ) \n                     |\n                     V\n            Executable file(a.out)</code></pre></div><ol><li>预处理：C语言预处理器展开 <b>宏定义、#include、#deine</b> 生成纯C的代码</li><li>编译</li></ol><ul><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>源代码优化：循环优化、无用代码删除等</li><li>代码生成<br/>3. 链接：符号解析、重定位等。注意连接器和加载器的功能区分并不是那么清晰，对于loader而言，也会处理一些链接的工作。</li></ul><p>后文用到的<code>main.cpp</code>内容如下，其他代码都在这里 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/yukun89/draft/tree/master/hello_world/chapter1\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/yukun89/draf</span><span class=\"invisible\">t/tree/master/hello_world/chapter1</span><span class=\"ellipsis\"></span></a></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdlib.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;func.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"n\">global_b</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">global_c</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">global_d</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">];</span>\n<span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">global_e</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">];</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\n    <span class=\"k\">static</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Begin printf &#34;</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"n\">ip</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span>\n    <span class=\"o\">*</span><span class=\"n\">ip</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">global_b</span> <span class=\"o\">=</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ip</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s the value of func is %d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"n\">global_b</span> <span class=\"o\">+</span> <span class=\"n\">global_c</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>2.ELF文件格式</h2><p>与<b>编译-链接-加载</b>相关的ELF文件主要有两种格式：可重定位目标文件（后缀名为<code>.o</code>) 与 可执行目标文件。（另外还有两种是共享库文件 和 coredump文件。）</p><p>分析数据结构之前，我们秉承一个基本原则：<b>结构决定功能</b>；反过来说也成立，设计ELF文件结构，是为了满足特定的功能。这里我们先简要梳理一下，ELF文件应该提供哪些功能？简单来说，ELF文件需要满足可链接、可加载、可执行三大类基本功能，具体来说，包含以下详细功能。</p><ul><li>从<b>可执行</b>的角度讲，程序需要包含指令与数据，也就是说ELF文件中需要存储程序对应的指令和数据</li><li>从<b>可链接</b>的角度讲，需要处理不同编译单元之间的引用问题，所以需要符号解析与重定位相关信息</li><li>从<b>内容组织</b>的角度讲，ELF文件中包含代码、数据、重定位信息等多个section，同时包含这些数据的元数据信息（每个section在文件的起始地址是什么，有多大）。另外，ELF文件格式和其他的任何二进制文件一样，还应该包含一个header，作为所有ELF文件中信息的元数据</li><li>从<b>可加载</b>的角度讲，ELF文件需要指定将那些代码、数据映射到虚拟内存的什么位置</li></ul><p>综上，ELF的文件大致格式如图所示</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b74f40027e37556a417ceed139e54a93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"745\" data-rawheight=\"807\" class=\"origin_image zh-lightbox-thumb\" width=\"745\" data-original=\"https://pic4.zhimg.com/v2-b74f40027e37556a417ceed139e54a93_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;745&#39; height=&#39;807&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"745\" data-rawheight=\"807\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"745\" data-original=\"https://pic4.zhimg.com/v2-b74f40027e37556a417ceed139e54a93_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b74f40027e37556a417ceed139e54a93_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：<code>Section Headers</code>并不在ELF文件的末尾；<code>Program Header table</code>并不存在于每一种ELF文件格式之中。下面我们用linux下的两个命令工具<code>readelf</code>和<code>objdump</code>来详细分析ELF文件中的各个部分。</p><h2>2.1 ELF文件头</h2><p>ELF文件的相关定义在<code>/usr/include/elf.h</code>文件之中，具体ELF文件头的信息如下</p><div class=\"highlight\"><pre><code class=\"language-text\">typedef struct\n{\n  unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */\n  Elf64_Half    e_type;         /* Object file type */\n  Elf64_Half    e_machine;      /* Architecture */\n  Elf64_Word    e_version;      /* Object file version */\n  Elf64_Addr    e_entry;        /* Entry point virtual address */\n  Elf64_Off e_phoff;        /* Program header table file offset */\n  Elf64_Off e_shoff;        /* Section header table file offset */\n  Elf64_Word    e_flags;        /* Processor-specific flags */\n  Elf64_Half    e_ehsize;       /* ELF header size in bytes */\n  Elf64_Half    e_phentsize;        /* Program header table entry size */\n  Elf64_Half    e_phnum;        /* Program header table entry count */\n  Elf64_Half    e_shentsize;        /* Section header table entry size */\n  Elf64_Half    e_shnum;        /* Section header table entry count */\n  Elf64_Half    e_shstrndx;     /* Section header string table index */\n} Elf64_Ehdr;</code></pre></div><p>这里，我们用<code>readelf -h</code>分别查看<code>main.o</code>和<code>main</code>两种不同格式ELF文件的文件头，得到的结果如下</p><div class=\"highlight\"><pre><code class=\"language-text\">ykhuang@0062a6cb7e5e: readelf -h main.o\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2&#39;s complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              REL (Relocatable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x0\n  Start of program headers:          0 (bytes into file)\n  Start of section headers:          1112 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           0 (bytes)\n  Number of program headers:         0\n  Size of section headers:           64 (bytes)\n  Number of section headers:         14\n  Section header string table index: 1\n ykhuang@0062a6cb7e5e : readelf -h main\nELF Header:\n  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00\n  Class:                             ELF64\n  Data:                              2&#39;s complement, little endian\n  Version:                           1 (current)\n  OS/ABI:                            UNIX - System V\n  ABI Version:                       0\n  Type:                              EXEC (Executable file)\n  Machine:                           Advanced Micro Devices X86-64\n  Version:                           0x1\n  Entry point address:               0x400550\n  Start of program headers:          64 (bytes into file)\n  Start of section headers:          4536 (bytes into file)\n  Flags:                             0x0\n  Size of this header:               64 (bytes)\n  Size of program headers:           56 (bytes)\n  Number of program headers:         9\n  Size of section headers:           64 (bytes)\n  Number of section headers:         30\n  Section header string table index: 27</code></pre></div><p>通过以上的内容，我们不难分析，header的主要作用是标识ELF文件中section headers和program headers的位置与大小。header中各个其他字段的解释，我们主要关注以下几点</p><ul><li>Type表示这个ELF文件属于上文说到的哪种（可重定位还是可执行）ELF文件</li><li>程序入口地址<code>Entry point address</code>这一项对于可执行文件才有意义</li><li>因为loader只会加载可执行文件，将文件中的代码和数据映射到虚拟MM，所以只有可执行文件的<code>program headers</code>相关信息才有意义。</li></ul><h2>2.2 ELF文件section</h2><p>ELF文件中的section主要包括：代码段、数据段、重定位段等信息，section对应的数据结构如下</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span>\n<span class=\"p\">{</span>\n  <span class=\"n\">Elf64_Word</span>  <span class=\"n\">sh_name</span><span class=\"p\">;</span>    <span class=\"cm\">/* Section name (string tbl index) */</span>\n  <span class=\"n\">Elf64_Word</span>  <span class=\"n\">sh_type</span><span class=\"p\">;</span>    <span class=\"cm\">/* Section type */</span>\n  <span class=\"n\">Elf64_Xword</span> <span class=\"n\">sh_flags</span><span class=\"p\">;</span>   <span class=\"cm\">/* Section flags */</span>\n  <span class=\"n\">Elf64_Addr</span>  <span class=\"n\">sh_addr</span><span class=\"p\">;</span>    <span class=\"cm\">/* Section virtual addr at execution */</span>\n  <span class=\"n\">Elf64_Off</span> <span class=\"n\">sh_offset</span><span class=\"p\">;</span>    <span class=\"cm\">/* Section file offset */</span>\n  <span class=\"n\">Elf64_Xword</span> <span class=\"n\">sh_size</span><span class=\"p\">;</span>    <span class=\"cm\">/* Section size in bytes */</span>\n  <span class=\"n\">Elf64_Word</span>  <span class=\"n\">sh_link</span><span class=\"p\">;</span>    <span class=\"cm\">/* Link to another section */</span>\n  <span class=\"n\">Elf64_Word</span>  <span class=\"n\">sh_info</span><span class=\"p\">;</span>    <span class=\"cm\">/* Additional section information */</span>\n  <span class=\"n\">Elf64_Xword</span> <span class=\"n\">sh_addralign</span><span class=\"p\">;</span>   <span class=\"cm\">/* Section alignment */</span>\n  <span class=\"n\">Elf64_Xword</span> <span class=\"n\">sh_entsize</span><span class=\"p\">;</span>   <span class=\"cm\">/* Entry size if section holds table */</span>\n<span class=\"p\">}</span> <span class=\"n\">Elf64_Shdr</span><span class=\"p\">;</span>\n</code></pre></div><p>下面，让我们来分别查看可重定位目标文件与可执行目标文件的section信息</p><div class=\"highlight\"><pre><code class=\"language-text\">####可重定位目标文件的信息\n ykhuang@0062a6cb7e5e  ~/project/draft/hello_world/chapter1   master ●  readelf -S -W main.o\nThere are 14 section headers, starting at offset 0x1c0:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .text             PROGBITS        0000000000000000 000040 000063 00  AX  0   0  4\n  [ 2] .rela.text        RELA            0000000000000000 000750 0000c0 18     12   1  8\n  [ 3] .data             PROGBITS        0000000000000000 0000a8 000010 00  WA  0   0  8\n  [ 4] .rela.data        RELA            0000000000000000 000810 000018 18     12   3  8\n  [ 5] .bss              NOBITS          0000000000000000 0000c0 000068 00  WA  0   0 32\n  [ 6] .rodata           PROGBITS        0000000000000000 0000c0 00002e 00   A  0   0  4\n  [ 7] .comment          PROGBITS        0000000000000000 0000ee 00002d 01  MS  0   0  1\n  [ 8] .note.GNU-stack   PROGBITS        0000000000000000 00011b 000000 00      0   0  1\n  [ 9] .eh_frame         PROGBITS        0000000000000000 000120 000038 00   A  0   0  8\n  [10] .rela.eh_frame    RELA            0000000000000000 000828 000018 18     12   9  8\n  [11] .shstrtab         STRTAB          0000000000000000 000158 000066 00      0   0  1\n  [12] .symtab           SYMTAB          0000000000000000 000540 0001b0 18     13  11  8\n  [13] .strtab           STRTAB          0000000000000000 0006f0 00005a 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre></div><p>其中type字段的含义如下：</p><ul><li>PROGBITS： 程序内容，包含代码、数据、调试相关信息</li><li>NOBITS：和PROGBITS类似，唯一不同的是在文件中不占空间，对应的进行内存空间是加载的时候申请的</li><li>SYSTAM/DYNSYM: SYSTAM 表用于普通链接；DYNSYM用于动态链接</li><li>STRTAB：string table，用于section名称、普通的符号名称、动态链接的符号名称。 据此，我们绘制出<code>main.o</code>文件的布局如下：</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-31ff815a3b2bd213146cf31be5ea92b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"744\" class=\"origin_image zh-lightbox-thumb\" width=\"509\" data-original=\"https://pic4.zhimg.com/v2-31ff815a3b2bd213146cf31be5ea92b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;509&#39; height=&#39;744&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"744\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"509\" data-original=\"https://pic4.zhimg.com/v2-31ff815a3b2bd213146cf31be5ea92b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-31ff815a3b2bd213146cf31be5ea92b3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可执行文件的信息比较繁琐，我们大致给出，后续再分析具体每个section的含义与作用。</p><div class=\"highlight\"><pre><code class=\"language-text\">####可执行文件的section信息\n ykhuang@0062a6cb7e5e  ~/project/draft/hello_world/chapter1   master ●  readelf -S -W main\nThere are 30 section headers, starting at offset 0x11b8:\n\nSection Headers:\n  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0\n  [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A  0   0  1\n  [ 2] .note.ABI-tag     NOTE            0000000000400254 000254 000020 00   A  0   0  4\n  [ 3] .note.gnu.build-id NOTE            0000000000400274 000274 000024 00   A  0   0  4\n  [ 4] .gnu.hash         GNU_HASH        0000000000400298 000298 00001c 00   A  5   0  8\n  [ 5] .dynsym           DYNSYM          00000000004002b8 0002b8 0000c0 18   A  6   1  8\n  [ 6] .dynstr           STRTAB          0000000000400378 000378 0000b7 00   A  0   0  1\n  [ 7] .gnu.version      VERSYM          0000000000400430 000430 000010 02   A  5   0  2\n  [ 8] .gnu.version_r    VERNEED         0000000000400440 000440 000020 00   A  6   1  8\n  [ 9] .rela.dyn         RELA            0000000000400460 000460 000018 18   A  5   0  8\n  [10] .rela.plt         RELA            0000000000400478 000478 000060 18   A  5  12  8\n  [11] .init             PROGBITS        00000000004004d8 0004d8 00001a 00  AX  0   0  4\n  [12] .plt              PROGBITS        0000000000400500 000500 000050 10  AX  0   0 16\n  [13] .text             PROGBITS        0000000000400550 000550 000224 00  AX  0   0 16\n  [14] .fini             PROGBITS        0000000000400774 000774 000009 00  AX  0   0  4\n  [15] .rodata           PROGBITS        0000000000400780 000780 00003e 00   A  0   0  8\n  [16] .eh_frame_hdr     PROGBITS        00000000004007c0 0007c0 000044 00   A  0   0  4\n  [17] .eh_frame         PROGBITS        0000000000400808 000808 000134 00   A  0   0  8\n  [18] .init_array       INIT_ARRAY      0000000000600de0 000de0 000008 00  WA  0   0  8\n  [19] .fini_array       FINI_ARRAY      0000000000600de8 000de8 000008 00  WA  0   0  8\n  [20] .jcr              PROGBITS        0000000000600df0 000df0 000008 00  WA  0   0  8\n  [21] .dynamic          DYNAMIC         0000000000600df8 000df8 000200 10  WA  6   0  8\n  [22] .got              PROGBITS        0000000000600ff8 000ff8 000008 08  WA  0   0  8\n  [23] .got.plt          PROGBITS        0000000000601000 001000 000038 08  WA  0   0  8\n  [24] .data             PROGBITS        0000000000601038 001038 000018 00  WA  0   0  8\n  [25] .bss              NOBITS          0000000000601050 001050 000038 00  WA  0   0 16\n  [26] .comment          PROGBITS        0000000000000000 001050 000060 01  MS  0   0  1\n  [27] .shstrtab         STRTAB          0000000000000000 0010b0 000108 00      0   0  1\n  [28] .symtab           SYMTAB          0000000000000000 001938 0006d8 18     29  47  8\n  [29] .strtab           STRTAB          0000000000000000 002010 00028f 00      0   0  1\nKey to Flags:\n  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n  O (extra OS processing required) o (OS specific), p (processor specific)</code></pre></div><h2>2.2.1 代码段(txt)-数据段-只读数据段</h2><p>代码段的信息，我们可以用<code>objdump -s -d main.o</code>具体查看代码段的信息，此处不展开讨论。</p><p>数据段信息如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">ykhuang@0062a6cb7e5e  ~/project/draft/hello_world/chapter1   master ●  objdump -s -d main.o\n\nmain.o:     file format elf64-x86-64\n\nContents of section .text:\n 0000 554889e5 4883ec10 bf040000 00e80000  UH..H...........\n 0010 00004889 45f8488b 45f8c700 01000000  ..H.E.H.E.......\n 0020 488b45f8 8b0089c7 e8000000 00890500  H.E.............\n 0030 000000bf 01000000 e8000000 0089c248  ...............H\n 0040 8b050000 00004889 c6bf0000 0000b800  ......H.........\n 0050 000000e8 00000000 8b050000 000083c0  ................\n 0060 01c9c3                               ...\nContents of section .data:\n 0000 01000000 00000000 00000000 00000000  ................\nContents of section .rodata:\n 0000 01000000 25732074 68652076 616c7565  ....%s the value\n 0010 206f6620 66756e63 20697320 25640a00   of func is %d..\n 0020 42656769 6e207072 696e7466 2000      Begin printf .</code></pre></div><p>查看符号表信息如下 <code>objdump -x main.o</code></p><div class=\"highlight\"><pre><code class=\"language-text\">SYMBOL TABLE:\n0000000000000000 g     O .data  0000000000000004 global_b\n0000000000000000 g     O .rodata    0000000000000004 global_c\n0000000000000000 g     O .bss   0000000000000028 global_d\n0000000000000000 g     F .text  0000000000000063 main</code></pre></div><p>从这里我们可以看出，我们只有依赖符号表，才能知道某个变量存放的具体数值信息。</p><h2>3.其他</h2><p>需要指出的是，ELF文件格式之所以是现在这种结构，是由体系结构和操作系统来决定的。在一些其他的系统上（例如MS-DOS或者IBM system V），编译-链接的中间文件具有完全不同的结构。总体来说，这些二进制文件主要需要满足可链接、可加载、可执行。这里，我们简要列出了另外两种<b>编译-链接-加载</b>相关的文件结构：</p><ul><li>COM(component object model)文件：MS-DOS系统上的可执行文件。只有二进制代码，不包含其他任何信息，代码会自动load到0x100，只支持一个代码段。</li><li><code>a.out</code> 文件：unix上可执行文件的一种，包含<code>header、代码段、数据段、其他段</code>。程序执行的过程主要是<i>“读取文件头； map代码段；map私有数据段； 创建进行栈； 设置寄存器然后跳转到程序开头”</i></li></ul><p>ELF文件是目前linux平台上最通用的一种可<b>链接-加载-执行</b>的文件结构，对于不同的语言，例如C/C++,他们对应的ELF文件格式略微有所不同：C++相对于C编译而成的ELF文件格式有自己独特的section。了解ELF文件格式有利于我们后续详细理解程序的<b>链接-加载-执行过程</b>。</p><p>最后放一下blog地址，欢迎来玩</p><a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com/%3Fp%3D162\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-3e605100caf00ff7f7d8b6b861bec6f8_ipico.jpg\" data-image-width=\"745\" data-image-height=\"807\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">编译-链接-加载：ELF文件格式解析 | 优孚</a><h2>参考：</h2><ol><li>linker &amp;&amp; loader</li><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/3996651/what-is-compiler-linker-loader\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/3996651/what-is-compiler-linker-loader</span><span class=\"ellipsis\"></span></a></li></ol>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }
            ], 
            "comments": [
                {
                    "userName": "打嘴炮", 
                    "userLink": "https://www.zhihu.com/people/500b10a2298d8cabbccb54e2176af21f", 
                    "content": "<p>如何查看代码段信息？可以解释一下吗？</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56751496", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 12, 
            "title": "如何调试没有core文件的coredump", 
            "content": "<p>摘要：在我们往期对coredump的分析中，是依赖于core文件的，而core文件中也几乎包含了程序当前的所有状态（堆栈、内存、寄存器等）。然而在实际的线上环境中，由于core文件太大、保存core文件耗时太久，出于线上系统的稳定性与快速恢复考虑，我们往往不会保留core文件。同时，程序堆栈被破坏的情况下，即使我们保留了core文件，也无法准确获取程序崩溃时准确的上下文信息。本文主要介绍在不保留core文件的情况下，如何获取程序崩溃时候的上下文信息（主要是函数调用栈）。</p><p>原文发表于：<a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">优孚网</a> </p><a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com/%3Fp%3D151\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何调试没有core文件的coredump | 优孚</a><h2>1.coredump原理</h2><p>当程序发生内存越界访问等行为时，会触发OS的保护机制，此时OS会产生一个信号(signal)发送给对应的进程。当进程从内核态到用户态切换时，该进程会处理这个信号。此类信号（比如SEGV）的默认处理行为生成一个coredump文件。</p><p>这里会涉及以下几个问题：</p><ol><li>保存的core文件在什么地方？</li><li>core文件，具体会把进程地址空间的哪些内容保存下来？</li><li>如何控制core文件的大小？</li><li>如果在处理信号的时候，又产生了新的同类信号，该如何处理？</li><li>处理信号的代码，是运行在用户态还是内核态？</li><li>在一个多线程的程序中，是由哪个线程在处理这个信号？</li></ol><p>问题4~问题6是信号处理的相关内容，我们不在这里解释，会在信号处理的章节详细分析。问题1~问题3解释如下</p><ul><li><code>/proc/sys/kernel/core_pattern</code> 指定core文件存储的位置，缺省值是<code>core</code>，表示将core文件存储到当前目录。这个pattern是可以定制的，模式如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">%p  出Core进程的PID\n%u  出Core进程的UID\n%s  造成Core的signal号\n%t  出Core的时间，从1970-01-0100:00:00开始的秒数\n%e  出Core进程对应的可执行文件名</code></pre></div><ul><li><code>/proc/sys/kernel/core_uses_pid</code> 取值是0或者1，表示是否在core文件名字后面加上进程号</li><li><code>/proc/$pid/coredump_filter</code> 设置那些内存会被dump出来</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">bit 0  Dump anonymous private mappings.\n           bit 1  Dump anonymous shared mappings.\n           bit 2  Dump file-backed private mappings.\n           bit 3  Dump file-backed shared mappings.\n           bit 4 (since Linux 2.6.24)\n                  Dump ELF headers.\n           bit 5 (since Linux 2.6.28)\n                  Dump private huge pages.\n           bit 6 (since Linux 2.6.28)\n                  Dump shared huge pages.</code></pre></div><ul><li><code>ulimit  -c</code> 决定save的core文件大小限制</li></ul><h2>2.自定义信号处理函数</h2><p>我们需要在自定义的信号处理函数中打印出程序崩溃时候的活跃函数堆栈信息。这里我们有两种方式：1.使用backtrace等方法，读取进程堆栈上的信息；2.在函数调用的同时，用户自己维护一套数据结构，用于保存函数调用链，在信号处理函数中，将这个函数调用链打印出来。</p><h2>2.1使用backtrace获取函数调用链</h2><p>在<a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com/%3Fp%3D54\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从汇编语言看函数调用</a>和<a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com/%3Fp%3D78\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">栈破坏下的coredump分析方法</a>两篇文章中，我们知道进程堆栈上保存了rbp寄存器对应的list。backtrace本质上就是利用进程堆栈上的数据，推断出来的当前函数调用链。这里我们不分析backtrace的源码，直接给出关键性质的代码。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">dump_trace</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">Signal</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"mi\">200</span><span class=\"p\">;</span>\n    <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">len</span><span class=\"p\">];</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;dump_trace</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nptrs</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">backtrace</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;backtrace</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n    <span class=\"kt\">char</span><span class=\"o\">**</span> <span class=\"n\">buffer_array</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">backtrace_symbols</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"n\">nptrs</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;sig:%d nptrs:%d</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">Signal</span><span class=\"p\">,</span> <span class=\"n\">nptrs</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">buffer_array</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nptrs</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;frame=%d||trace_back=%s||</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">buffer_array</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">buffer_array</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"n\">SIGSEGV</span><span class=\"p\">,</span> <span class=\"n\">dump_trace</span><span class=\"p\">);</span><span class=\"c1\">//注册信号处理函数\n</span></code></pre></div><p>完整的代码可以参考<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yukun89/draft/tree/master/dump\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>。利用signal函数，我们将dump_trace注册为SIGSEGV的信号处理函数，来取代默认的保存core文件的行为。</p><h2>2.2 用户自己维护一个函数调用链</h2><p>为什么我们需要费力自己去维护一个函数调用链而不是直接调用backtrace呢? 因为遇到进程堆栈被写花的时候，我们是无法找到完整的函数调用栈信息的。自己去维护函数调用链的原理如下：维护一个堆栈，在函数调用的时候，将调用的函数入栈；函数调用结束时，将这个函数出栈。这样当coredump发生时，即使进程堆栈被破坏的情况下，这个用户自定义的函数堆栈中依然保存了函数调用链的信息。</p><p>那么如何在函数调用的开始和结束执行对应的操作呢？g++/gcc正好提供了这种功能，能够让我们在函数的开始和结束嵌入对应的代码。我们需要做的仅仅是实现两个预先声明的函数，核心代码如下</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#ifdef __cplusplus\n</span><span class=\"cp\"></span><span class=\"k\">extern</span> <span class=\"s\">&#34;C&#34;</span> <span class=\"p\">{</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>\n<span class=\"kt\">void</span> <span class=\"n\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">no_instrument_function</span><span class=\"p\">))</span>\n<span class=\"n\">__cyg_profile_func_enter</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">this_func</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">call_site</span><span class=\"p\">);</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">__attribute__</span><span class=\"p\">((</span><span class=\"n\">no_instrument_function</span><span class=\"p\">))</span>\n<span class=\"n\">__cyg_profile_func_exit</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">this_func</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">call_site</span><span class=\"p\">);</span>\n\n<span class=\"cp\">#ifdef __cplusplus\n</span><span class=\"cp\"></span><span class=\"p\">};</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span>\n<span class=\"kt\">void</span> <span class=\"nf\">__cyg_profile_func_enter</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">this_func</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">call_site</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"mi\">64</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span>\n    <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">snprintf</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"mi\">60</span><span class=\"p\">,</span> <span class=\"s\">&#34;%p call %p&#34;</span><span class=\"p\">,</span> <span class=\"n\">this_func</span><span class=\"p\">,</span> <span class=\"n\">call_site</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">content</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">);</span>\n    <span class=\"n\">call_list</span><span class=\"p\">.</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">__cyg_profile_func_exit</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">this_func</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">call_site</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">call_list</span><span class=\"p\">.</span><span class=\"n\">pop</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>代码解释：<code>void __cyg_profile_func_enter(void *this_func, void *call_site)</code> 函数有两个参数，第一参数表示调用方的地址，第二个参数表示被调用方的地址。需要注意的有以下几点：</p><ul><li><code>__cyg_profile_func_enter</code>和<code>__cyg_profile_func_exit</code>这两个函数本身是需要设置属性<code>no_instrument_function</code>的；否则会陷入对这两个函数本身的无限递归调用。</li><li>为了将上述代码嵌入到每个函数的开始和结束，需要在编译代码的时候使用特定的编译参数<code>-finstrument-functions</code></li><li>上述代码所在的编译单元是必须不能使用<code>-finstrument-functions</code>的：否则会陷入循环调用(想想为什么)</li></ul><p>相关demo代码的说明在<a href=\"https://link.zhihu.com/?target=https%3A//github.com/yukun89/draft/tree/master/dump\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>，大家可以自行测试。我们只给出函数在crash时候的输出结果。对于文中的地址信息，我们可以使用addr2line获得这些地址对应的源文件地址。</p><div class=\"highlight\"><pre><code class=\"language-text\">sig:11\nframe_0: 0x401172 call 0x4011f0\nframe_1: 0x401172 call 0x4011e1\nframe_2: 0x401172 call 0x4011f0\nframe_3: 0x401172 call 0x4011e1\nframe_4: 0x401172 call 0x4011f0\nframe_5: 0x401172 call 0x40129f\nframe_6: 0x40123e call 0x7f6e0bf52b15</code></pre></div><h2>3.coredump的各种可能性</h2><p>综合前面所讲解的所有coredump的种类，我们总结coredump的各种可能性如下：</p><ol><li>内存访问越界</li><ol><li>下标导致的数组访问越界</li><li>字符串不包含对应结束符导致的越界访问</li><li>使用strcpy, strcat, sprintf, strcmp,strcasecmp等字符串操作函数，将目标字符串读/写爆</li></ol><li>多线程数据未进行加锁保护：STL容器vector、map等都是非线程安全的</li><li>指针相关</li><ol><li>空指针解引用</li><li>非法的指针转化</li><li>use after free</li><li>double free</li></ol><li>堆栈相关</li><ol><li>栈变量过大导致的堆栈溢出</li><li>栈变量的非法写入，导致程序调用栈被破坏无法回溯</li></ol></ol>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }, 
                {
                    "tag": "软件调试", 
                    "tagLink": "https://api.zhihu.com/topics/19660363"
                }
            ], 
            "comments": [
                {
                    "userName": "Peter Porker", 
                    "userLink": "https://www.zhihu.com/people/d213e10f56ed7547d7e327829aa57bb9", 
                    "content": "坤哥厉害", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>志会？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Peter Porker"
                        }, 
                        {
                            "userName": "Peter Porker", 
                            "userLink": "https://www.zhihu.com/people/d213e10f56ed7547d7e327829aa57bb9", 
                            "content": "<a class=\"comment_sticker\" href=\"https://pic2.zhimg.com/v2-fa420fb01533452e9d5f021c52dc6cc5.gif\" data-width=\"\" data-height=\"\">[超得意]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                    "content": "backtrace在信号处理函数里运行是不安全的。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>为什么不安全呢？因为backtrace里面本身会触发core？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "「已注销」"
                        }, 
                        {
                            "userName": "「已注销」", 
                            "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                            "content": "<a href=\"http://link.zhihu.com/?target=https%3A//www.gnu.org/software/libc/manual/html_node/Backtraces.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">gnu.org/software/libc/m</span><span class=\"invisible\">anual/html_node/Backtraces.html</span><span class=\"ellipsis\"></span></a>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/14aac0cd2e17e129478b1101fe540aa8", 
                    "content": "需要用libunwind", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "徐辰", 
                    "userLink": "https://www.zhihu.com/people/630612ff80641e9ec165af192743a792", 
                    "content": "讲道理没有core文件就不算是core dump了。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53885988", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 13, 
            "title": "如何处理栈被破坏导致的crash", 
            "content": "<p>在众多的coredump中，有一类crash调试起来是最麻烦的，那就是“栈被破坏”导致的函数调用回溯结构破坏引发的coredump。本文，主要讲讲这一类crash的成因、原理以及调试方法。</p><h2><b>1. SMTC(show me the code)</b></h2><p>首先，让我们来看一段代码</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">void</span> <span class=\"nf\">fun</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;The %d step begin.</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">a</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"mi\">20</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">fun</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;The %d step end</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">fun</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这段代码的关键在于fun函数会有递归调用，而在参数大于10的时候会导致写入的空间超过了栈上的“合法”内存。我们先来看下这段代码的输出</p><div class=\"highlight\"><pre><code class=\"language-as3\"><span class=\"n\">The</span> <span class=\"mi\">8</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">9</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">10</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">11</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">12</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">13</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">14</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">15</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">16</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">17</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">18</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">19</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">20</span> <span class=\"n\">step</span> <span class=\"n\">begin</span><span class=\"o\">.</span>\n<span class=\"n\">The</span> <span class=\"mi\">20</span> <span class=\"n\">step</span> <span class=\"n\">end</span>\n<span class=\"n\">Segmentation</span> <span class=\"n\">fault</span> <span class=\"o\">(</span><span class=\"n\">core</span> <span class=\"n\">dumped</span><span class=\"o\">)</span>\n</code></pre></div><p>对于输出，我们做简要的解释：</p><ol><li>所有的栈上地址都是合法(此处的合法，指的是操作系统允许写入）的，也就是说即使写入到a[19]这样的非预期地址，也不会crash</li><li>由于栈的增长方向是高地址向低地址，而“写坏”的是“高地址”，也就是说已经申请过的地址。</li><li>栈上与函数调用最相关的数据信息是rip&amp;&amp;esp，而直接导致crash的原因是因为rip被“写坏”，导致执行对应的指令出现问题。</li></ol><h2><b>2.原因详细解释</b></h2><p>首先，我们来回顾一下函数调用过程中的stack数据分布与变化（<a href=\"https://link.zhihu.com/?target=https%3A//yukun89.github.io/2018/12/11/function_call/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">link</a>)。接着看上文的程序输出就明白：在fun函数调用的末尾，需要执行<code>ret</code>指令，也就是说会将地址为<code>rbp+8</code>对应的栈上数据放入<code>rip</code>寄存器中，然后执行<code>rip</code>对应的这一条这令，这里现在是存放的是一个0~19的数字，不是一个合法的指令地址，于是产生了crash。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7174a28a15f5c496edb9eb0df47112fa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"452\" data-original=\"https://pic3.zhimg.com/v2-7174a28a15f5c496edb9eb0df47112fa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;452&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"452\" data-original=\"https://pic3.zhimg.com/v2-7174a28a15f5c496edb9eb0df47112fa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7174a28a15f5c496edb9eb0df47112fa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>也就是说，正常情况下，<code>ebp</code>数据结合栈上的数据实际上构成了一个单向链表，链表头是当前执行的函数，往链表尾部，是对应在各个层次的调用者函数。stack上对应的函数调用链表如上图。看到这里我们可以得出结论：</p><p>1.stack crash 的本质是<code>rbp&amp;&amp;rip</code>的数据错乱导致。而具体crash的位置，取决于<code>rbp</code>和<code>rip</code>对应的数据。另一方面，栈上的数据错乱也不一定导致crash，有可能仅仅是把应该写入变量a的数据写到了变量b。 2.stack crash时，函数的执行已经脱离了出问题的函数。也就是说，A调用B，B函数中产生了栈上空间的错误写入，但是crash往往发生在A函数之中，因为只有B函数对应的汇编代码的最后一句<code>retq</code>执行完毕之后，才会发生crash，此时，程序的控制权在函数A之中。 3.stack crash时，函数调用栈已经被破坏。但是被破坏的是调用栈的头部。这也是唯一值得欣慰的信息了，函数调用栈尾部的信息依然完好无损。而我们可以据此，推测出函数调用的蛛丝马迹。</p><h2><b>3.手动恢复函数调用栈</b></h2><p>需要指出的是，被破坏的函数调用栈部分已经无法得到恢复了。此处我们能恢复的，仅仅是没有被破坏的部分。恢复函数栈的原理也很简单，那就是根据栈空间中的内存内容，找到那个“链表”即可。</p><p>继续使用上文我们对应的coredump文件，我们可以看到，由于函数调用最近的<code>RBP</code>对应的栈上内容已经被破坏，此时我们已经无法用bt指令得到正确的函数栈了。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">Missing</span> <span class=\"n\">separate</span> <span class=\"n\">debuginfos</span><span class=\"p\">,</span> <span class=\"nl\">use</span><span class=\"p\">:</span> <span class=\"n\">debuginfo</span><span class=\"o\">-</span><span class=\"n\">install</span> <span class=\"n\">glibc</span><span class=\"o\">-</span><span class=\"mf\">2.17</span><span class=\"o\">-</span><span class=\"mf\">105.</span><span class=\"n\">el7</span><span class=\"p\">.</span><span class=\"n\">x86_64</span>\n<span class=\"p\">(</span><span class=\"n\">gdb</span><span class=\"p\">)</span> <span class=\"n\">bt</span>\n<span class=\"cp\">#0  0x0000000f0000000e in ?? ()\n</span><span class=\"cp\">#1  0x0000001100000010 in ?? ()\n</span><span class=\"cp\">#2  0x0000001300000012 in ?? ()\n</span><span class=\"cp\">#3  0x0000000100000000 in ?? ()\n</span><span class=\"cp\">#4  0x0000000300000002 in ?? ()\n</span><span class=\"cp\">#5  0x0000000500000004 in ?? ()\n</span></code></pre></div><p>我们知道，函数调用栈在回溯过程中会执行两条关键的指令<code>move %rsp %rsp; pop %rbp</code>。而回溯行为对应的<code>retq</code>指令是在这两条指令之后执行的，此时<code>rsp</code>的值仍然是有效的。所以我们可以根据ESP的值打印出目前栈空间的数据。具体命令<code>x/256xg 0x7ffd79ef9e40(rsp对应的值)</code>和结果如下</p><div class=\"highlight\"><pre><code class=\"language-text\">(gdb) info reg rsp\nrsp            0x7ffd79ef9e40   0x7ffd79ef9e40\n(gdb) x/256xg 0x7ffd79ef9e40\n0x7ffd79ef9e40: 0x0000001100000010  0x0000001300000012\n0x7ffd79ef9e50: 0x0000000100000000  0x0000000300000002\n0x7ffd79ef9e60: 0x0000000500000004  0x0000000700000006\n0x7ffd79ef9e70: 0x0000000900000008  0x000000130000000a\n......\n0x7ffd79efa070: 0x00007fbe1d989d58  0x0000000c00000005\n0x7ffd79efa080: 0x0000000100000000  0x0000000300000002\n0x7ffd79efa090: 0x0000000500000004  0x0000000700000006\n0x7ffd79efa0a0: 0x0000000900000008  0x0000000c0000000a\n0x7ffd79efa0b0: 0x00007ffd79efa100  0x0000000000400583\n0x7ffd79efa0c0: 0x00007fbe1d989d58  0x0000000b00000005\n0x7ffd79efa0d0: 0x0000000100000000  0x0000000300000002\n0x7ffd79efa0e0: 0x0000000500000004  0x0000000700000006\n0x7ffd79efa0f0: 0x0000000900000008  0x0000000b0000000a\n0x7ffd79efa100: 0x00007ffd79efa150  0x0000000000400583\n0x7ffd79efa110: 0x00007fbe1dcfce80  0x0000000a00000000\n0x7ffd79efa120: 0x0000000100000000  0x0000000300000002\n0x7ffd79efa130: 0x0000000500000004  0x0000000700000006\n0x7ffd79efa140: 0x0000000900000008  0x0000000a0040032a\n0x7ffd79efa150: 0x00007ffd79efa1a0  0x0000000000400583\n</code></pre></div><p>这里，函数调用关系比较长，我们以栈开始部分的数据来说明。使用<code>x/256xg 0x7ffd79ef9e40+0x100</code>获取栈跳过<code>rsp</code>开始被写坏的部分数据，得到如下<code>rbp</code>对应的list</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8bddb48d8b529372ce111ff7a60fb7ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1184\" data-rawheight=\"1200\" class=\"origin_image zh-lightbox-thumb\" width=\"1184\" data-original=\"https://pic4.zhimg.com/v2-8bddb48d8b529372ce111ff7a60fb7ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1184&#39; height=&#39;1200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1184\" data-rawheight=\"1200\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1184\" data-original=\"https://pic4.zhimg.com/v2-8bddb48d8b529372ce111ff7a60fb7ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8bddb48d8b529372ce111ff7a60fb7ff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>好了，此时，我们已经找到了这个list，那么如果通过这个list找到函数调用关系呢？</p><h2><b>通过rbpList恢复函数调用关系</b></h2><p>通过《从汇编语言看函数调用》这篇文章，我们已经知道，栈上和<code>rbp</code>相邻的位置，就是对应的<code>rip</code>的值。而知道了<code>rip</code>的值，就能知道对应的代码位置。具体操作如下。</p><p>通过上图，我们根据这个list得到对应的rip-list对应的地址（rbp + 8对应的内容）依次全部为 <code>0x0000000000400583 &gt;&gt; 0x0000000000400583 &gt; ... &gt; 0x00000000004005a7</code>, 如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e5d207908f619d4e50a3e7a1b321e227_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1180\" data-rawheight=\"1424\" class=\"origin_image zh-lightbox-thumb\" width=\"1180\" data-original=\"https://pic4.zhimg.com/v2-e5d207908f619d4e50a3e7a1b321e227_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1180&#39; height=&#39;1424&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1180\" data-rawheight=\"1424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1180\" data-original=\"https://pic4.zhimg.com/v2-e5d207908f619d4e50a3e7a1b321e227_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e5d207908f619d4e50a3e7a1b321e227_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>有了<code>rip</code>地址，接下来只需要找出该地址对应的代码位置即可。这里，我们可以使用<code>addr2line</code>工具来分析代码段地址对应的源代码位置，结果如下。</p><div class=\"highlight\"><pre><code class=\"language-text\">[ykhuang@ykhuang-temp ~]$ addr2line -e test 0x0000000000400583\n/home/ykhuang/test.cpp:13\n[ykhuang@ykhuang-temp ~]$ addr2line -e test 0x00000000004005a7\n/home/ykhuang/test.cpp:19</code></pre></div><p>我们可以看到，这两个地址分别对应源代码的13和19行。 这里分别对应的<code>printf</code>和<code>return 0</code>对应的位置。实际上出问题的位置发生在这两行代码的上一行，因为rip对应的意义是<code>下一条指令的地址</code>. 至此，我们已经得到了部分函数调用关系。实际debug的过程中，我们这也几乎是我们能从一个crash的堆栈上能够获取的全部信息了。有了这部分信息，可以让我们迅速定位问题。当然，结合实际的代码，我们可以从stack中靠近<code>rsp</code>被写坏的数据是什么，来反推和代码的对应关系。</p><h2><b>4.总结</b></h2><p>“栈被写花”导致的crash虽然难以排查，但是我们还是能根据栈上仅存的信息，尽可能缩小“问题”代码所在的位置。这其中的原来就是函数调用过程中函数栈的建立和销毁过程。当然，除此之外，你需要熟悉一些基本的gdb指令（查看内存、反汇编、查看对应寄存器的值等），也需要了解一些汇编指令的实际含义。其实，对于这种crash，还有另外的方式能够保存函数调用栈，我们以后再展开讨论。在实际的生产中，由于crash文件比较大，对crash现场的保存往往采用保存函数调用堆栈的方式。但是这种情况下，函数堆栈是无意义的，所以保存一些栈上数据，有利于我们更快定位问题，毕竟stack空间本来就不大。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>相关文章以后会同步迁移至 </p><a href=\"https://link.zhihu.com/?target=http%3A//www.uufool.com\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">优孚网</a><p></p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }
            ], 
            "comments": [
                {
                    "userName": "他叫你好", 
                    "userLink": "https://www.zhihu.com/people/9f011ec1b68296dce33bcb05b5f33325", 
                    "content": "高二党表示很头大╭(°A°`)╮", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>高二就开始研究这些东西吗</p>", 
                            "likes": 0, 
                            "replyToAuthor": "他叫你好"
                        }
                    ]
                }, 
                {
                    "userName": "火昊", 
                    "userLink": "https://www.zhihu.com/people/8acc67351f84204a77a2049babc61813", 
                    "content": "关注了，最近转行做c相关的，需要学习的地方有很多！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小马", 
                    "userLink": "https://www.zhihu.com/people/3c01c872c6eed0f179b155e57cbd9138", 
                    "content": "感谢分享[谢邀]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "彭望", 
                    "userLink": "https://www.zhihu.com/people/f41771116562ee8634a9b83c51be9ec8", 
                    "content": "有个typo “我们知道，函数调用栈在回溯过程中会执行两条关键的指令move %rsp %rsp; pop %rbp。” 应该是 move %rbp %rsp吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "嗯，多谢指正。笔误写错了", 
                            "likes": 0, 
                            "replyToAuthor": "彭望"
                        }
                    ]
                }, 
                {
                    "userName": "他叫你好", 
                    "userLink": "https://www.zhihu.com/people/9f011ec1b68296dce33bcb05b5f33325", 
                    "content": "高二党表示很头大╭(°A°`)╮", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>高二就开始研究这些东西吗</p>", 
                            "likes": 0, 
                            "replyToAuthor": "他叫你好"
                        }
                    ]
                }, 
                {
                    "userName": "火昊", 
                    "userLink": "https://www.zhihu.com/people/8acc67351f84204a77a2049babc61813", 
                    "content": "关注了，最近转行做c相关的，需要学习的地方有很多！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小马", 
                    "userLink": "https://www.zhihu.com/people/3c01c872c6eed0f179b155e57cbd9138", 
                    "content": "感谢分享[谢邀]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "彭望", 
                    "userLink": "https://www.zhihu.com/people/f41771116562ee8634a9b83c51be9ec8", 
                    "content": "有个typo “我们知道，函数调用栈在回溯过程中会执行两条关键的指令move %rsp %rsp; pop %rbp。” 应该是 move %rbp %rsp吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "嗯，多谢指正。笔误写错了", 
                            "likes": 0, 
                            "replyToAuthor": "彭望"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53885743", 
            "userName": "鱼鲲", 
            "userLink": "https://www.zhihu.com/people/12402b0dbd140ff698679987ee787c96", 
            "upvote": 3, 
            "title": "从汇编语言看C/C++函数调用", 
            "content": "<p></p><h2>从汇编角度理解C/C++函数调用，能够加深我们对代码的理解，提升调试能力。本文主要讲函数调用栈的建立和销毁、call与ret指令的本质、栈变量的申请、函数参数-返回地址-ebp在栈上的相对位置。</h2><h2>1.前言</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">//main.c\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"nf\">bar</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">d</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">foo</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">bar</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">foo</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>编译这段代码，进入gdb，然后对main函数进行反汇编(<code>disassemble main</code>)，得到如下汇编代码.</p><div class=\"highlight\"><pre><code class=\"language-text\">(gdb) disassemble main\nDump of assembler code for function main:\n   0x0000000000400506 &lt;+0&gt;: push   %rbp\n   0x0000000000400507 &lt;+1&gt;: mov    %rsp,%rbp //以上两句，建立了main函数的栈\n=&gt; 0x000000000040050a &lt;+4&gt;: mov    $0x5,%esi \n   0x000000000040050f &lt;+9&gt;: mov    $0x2,%edi // 将实参放入寄存器\n   0x0000000000400514 &lt;+14&gt;:    callq  0x4004e7 &lt;foo&gt;\n   0x0000000000400519 &lt;+19&gt;:    mov    $0x0,%eax\n   0x000000000040051e &lt;+24&gt;:    pop    %rbp // 销毁main函数栈\n   0x000000000040051f &lt;+25&gt;:    retq</code></pre></div><p>此时，我们查看对应寄存器，得到如下结果. 我们可以看到，此时rbp和rsp指向同一个位置，这是在gdb中执行<code>start</code>命令之后，指令所在的位置。</p><div class=\"highlight\"><pre><code class=\"language-text\">(gdb) info registers rbp rsp\nrbp            0x7fffffffe380   0x7fffffffe380\nrsp            0x7fffffffe380   0x7fffffffe380</code></pre></div><p>接下来我们将用这个例子来详细探索函数调用过程中的参数传递、控制转移<code>call</code>、新函数栈的建立、新函数栈的销毁、控制转移的恢复<code>ret</code>. </p><h2>2.进入被调用函数的准备</h2><p><code>40050a</code>~<code>40050f</code>两条指令为函数调用传递参数的过程，我们可以看到是函数参数是倒序传入的：先传入第N个参数，再传入第N-1个参数。(注意，目前64位的机器上，函数参数的传递很少是通过栈进行的。)</p><p>接下来的三行汇编，对应的是实参的传递和对foo函数的调用。下面，我们接着执行几条汇编(<code>si 3</code>)，进入foo函数内部，具体执行如下与解释如下.</p><div class=\"highlight\"><pre><code class=\"language-text\">(gdb) si 3\n(gdb) disassemble foo\n=&gt; 0x00000000004004e7 &lt;+0&gt;: push   %rbp //\n   0x00000000004004e8 &lt;+1&gt;: mov    %rsp,%rbp //新的函数栈的建立\n   0x00000000004004eb &lt;+4&gt;: sub    $0x8,%rsp //申请a和b对应的栈空间\n   0x00000000004004ef &lt;+8&gt;: mov    %edi,-0x4(%rbp) \n   0x00000000004004f2 &lt;+11&gt;:    mov    %esi,-0x8(%rbp) //将传入参数，存放到当前函数栈\n   0x00000000004004f5 &lt;+14&gt;:    mov    -0x8(%rbp),%edx\n   0x00000000004004f8 &lt;+17&gt;:    mov    -0x4(%rbp),%eax\n   0x00000000004004fb &lt;+20&gt;:    mov    %edx,%esi\n   0x00000000004004fd &lt;+22&gt;:    mov    %eax,%edi //将局部变量，放入寄存器\n   0x00000000004004ff &lt;+24&gt;:    callq  0x4004cd &lt;bar&gt;\n   0x0000000000400504 &lt;+29&gt;:    leaveq\n   0x0000000000400505 &lt;+30&gt;:    retq</code></pre></div><h2>call指令</h2><p>注意当指令走到<code>0x00000000004004e7</code>的时候（尚未执行），也就是<code>callq</code>执行刚刚执行完毕，对应寄存器的值如下。 </p><div class=\"highlight\"><pre><code class=\"language-text\">(gdb) info registers rbp rsp\nrbp            0x7fffffffe380   0x7fffffffe380\nrsp            0x7fffffffe378   0x7fffffffe378\n````\n\n和上一次我们查看`rsp/rbp`相比，`rsp`向低地址移动了8位（有数据入栈），结合上下文，这一寄存器的变化只会出现在`callq 0x4004e7`之中。进一步，我们看一下入栈的数据是什么，也就是原来rsp被存放了什么数值。从下面的代码中我们可以看到，原来的rsp上方存放的数值是`callq`之后的指令的地址。\n\n&gt;</code></pre></div><p>(gdb) x/8 0x7fffffffe370 0x7fffffffe370: 0xffffe460  0x00007fff  0x00400519（注意）  0x00000000 0x7fffffffe380: 0x00000000  0x00000000  0xf7a30445  0x00007fff</p><div class=\"highlight\"><pre><code class=\"language-text\">**总结一下：call指令的实际用途：1.push IP 2.通过设置 IP实现指令之间的跳转**\n\n## 3.新函数栈的建立与销毁\n\n### 函数栈的建立\n\n对应`4004e7`~`4004e8`处的汇编指令：重新设置`rsp`和`rbp`.\n\n### 函数中局部变量的申请与赋值\n\n对应的代码位于`4004eb`~`4004f2`. 从这里我们可以看出**1.同一个函数内部，栈变量的申请是同时发生的，但是赋值是逐条执行。2.栈变量的申请，仅仅涉及rsp指针的移动，不会导致segment fault，但是变量的读写，会具体访问到对应的内存，将会触发segment fault**。这里我们来看一个例子，猜一猜，这段代码会crash到哪一行？答案是会crash在`func()`这一行。因为数组`a`对应的空间申请发生在`func()`之前，而调用`func`的时候会将`IP`入栈，而此时，栈已经溢出了。</code></pre></div><p>int func(void) {     int b;     b = 1;     return b; } int main(){     func();     int a[1024<i>1024</i>8];     a[0] = 1;     a[1024<i>1024</i>8 -1] = 1;     return 0; }</p><div class=\"highlight\"><pre><code class=\"language-text\">### 函数栈的销毁\n\n函数栈的销毁涉及两方面：栈上空间的释放与rsp和rbp的重置。我们来看看foo函数末尾对应的汇编指令\n\n&gt; 0x0000000000400504 &lt;+29&gt;: leaveq\n\n继续用`si`来逐条执行对应指令，同时查看这条指令前后rpb和rsp的值如下\n\n&gt;```\n(gdb) disassemble foo\nDump of assembler code for function foo:\n   0x00000000004004e7 &lt;+0&gt;: push   %rbp\n   0x00000000004004e8 &lt;+1&gt;: mov    %rsp,%rbp\n   0x00000000004004eb &lt;+4&gt;: sub    $0x8,%rsp\n   0x00000000004004ef &lt;+8&gt;: mov    %edi,-0x4(%rbp)\n   0x00000000004004f2 &lt;+11&gt;:    mov    %esi,-0x8(%rbp)\n   0x00000000004004f5 &lt;+14&gt;:    mov    -0x8(%rbp),%edx\n   0x00000000004004f8 &lt;+17&gt;:    mov    -0x4(%rbp),%eax\n   0x00000000004004fb &lt;+20&gt;:    mov    %edx,%esi\n   0x00000000004004fd &lt;+22&gt;:    mov    %eax,%edi\n   0x00000000004004ff &lt;+24&gt;:    callq  0x4004cd &lt;bar&gt;\n=&gt; 0x0000000000400504 &lt;+29&gt;:    leaveq\n   0x0000000000400505 &lt;+30&gt;:    retq\nEnd of assembler dump.\n(gdb) info registers rbp rsp\nrbp            0x7fffffffe370   0x7fffffffe370\nrsp            0x7fffffffe368   0x7fffffffe368\n(gdb) si\n0x0000000000400505  9   }\n(gdb) info registers rbp rsp\nrbp            0x7fffffffe380   0x7fffffffe380\nrsp            0x7fffffffe378   0x7fffffffe378\n(gdb) disassemble foo\nDump of assembler code for function foo:\n   0x00000000004004e7 &lt;+0&gt;: push   %rbp\n   0x00000000004004e8 &lt;+1&gt;: mov    %rsp,%rbp\n   0x00000000004004eb &lt;+4&gt;: sub    $0x8,%rsp\n   0x00000000004004ef &lt;+8&gt;: mov    %edi,-0x4(%rbp)\n   0x00000000004004f2 &lt;+11&gt;:    mov    %esi,-0x8(%rbp)\n   0x00000000004004f5 &lt;+14&gt;:    mov    -0x8(%rbp),%edx\n   0x00000000004004f8 &lt;+17&gt;:    mov    -0x4(%rbp),%eax\n   0x00000000004004fb &lt;+20&gt;:    mov    %edx,%esi\n   0x00000000004004fd &lt;+22&gt;:    mov    %eax,%edi\n   0x00000000004004ff &lt;+24&gt;:    callq  0x4004cd &lt;bar&gt;\n   0x0000000000400504 &lt;+29&gt;:    leaveq\n=&gt; 0x0000000000400505 &lt;+30&gt;:    retq</code></pre></div><p>从理论上来说，<code>leaveq</code> 应该正好是入栈的逆向过程<code>mov %rbp %rsp; pop %rbp</code>. </p><h2>控制转移的恢复ret/retq</h2><p>最后我们看看retq执行完毕之后，寄存器前后的变化。</p><blockquote><code>(gdb) info registers rbp rsp rip rbp            0x7fffffffe380   0x7fffffffe380 rsp            0x7fffffffe378   0x7fffffffe378 rip            0x400505 0x400505 &lt;foo+30&gt; (gdb) disassemble foo Dump of assembler code for function foo:    0x00000000004004e7 &lt;+0&gt;: push   %rbp    0x00000000004004e8 &lt;+1&gt;: mov    %rsp,%rbp    0x00000000004004eb &lt;+4&gt;: sub    $0x8,%rsp    0x00000000004004ef &lt;+8&gt;: mov    %edi,-0x4(%rbp)    0x00000000004004f2 &lt;+11&gt;:    mov    %esi,-0x8(%rbp)    0x00000000004004f5 &lt;+14&gt;:    mov    -0x8(%rbp),%edx    0x00000000004004f8 &lt;+17&gt;:    mov    -0x4(%rbp),%eax    0x00000000004004fb &lt;+20&gt;:    mov    %edx,%esi    0x00000000004004fd &lt;+22&gt;:    mov    %eax,%edi    0x00000000004004ff &lt;+24&gt;:    callq  0x4004cd &lt;bar&gt;    0x0000000000400504 &lt;+29&gt;:    leaveq =&gt; 0x0000000000400505 &lt;+30&gt;:    retq End of assembler dump. (gdb) si main () at main.c:13 13      return 0; (gdb) info registers rbp rsp rip rbp            0x7fffffffe380   0x7fffffffe380 rsp            0x7fffffffe380   0x7fffffffe380 rip            0x400519 0x400519 &lt;main+19&gt;</code><br/> </blockquote><p>这里我们得到几点结论： 1. <code>retq</code>指令的调用，导致出栈了一个8位的数，这个就是调用者的下一条指令。 2. <code>retq</code>调用之前，已经处在调用者的栈帧。<code>retq</code>的调用，仅仅是一个栈上保存的地址存放到<code>rip</code>寄存器。 3. 对比<code>main</code>和<code>foo</code>函数的末尾，我们可以看到有细小的差别：<code>main</code>函数栈的销毁仅仅有<code>push %rbp</code>一句，但<code>foo</code>函数的结尾是<code>leaveq</code>。导致这一差别的原因是main函数建立调用栈之后，并没有移动<code>rsp</code>.</p><h2>总结</h2><p>函数调用过程中栈的变化如图 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3a2309b7c5e352898002d61b37ba87cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"959\" data-rawheight=\"621\" class=\"origin_image zh-lightbox-thumb\" width=\"959\" data-original=\"https://pic4.zhimg.com/v2-3a2309b7c5e352898002d61b37ba87cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;959&#39; height=&#39;621&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"959\" data-rawheight=\"621\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"959\" data-original=\"https://pic4.zhimg.com/v2-3a2309b7c5e352898002d61b37ba87cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3a2309b7c5e352898002d61b37ba87cf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以看到子程序调用之前和之后（1&amp;6），函数栈是没有任何变化的，有变化的在于<code>rip</code>等相关寄存器的值；<code>call</code>指令执行之后与<code>ret</code>指令执行之前，函数栈也是相同的，而<code>ret</code>指令之所以能转交控制权，是因为<code>ip</code>的值被保存到栈上。 这里我们可以看到，栈不仅仅有保存的局部变量数据，也有对控制转移指令至关重要的寄存器临时存储。一旦栈被写坏，控制转移指令就无法正常执行。下一节，我们将讲解与栈相关的控制转移指令被写坏的场景。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "汇编语言", 
                    "tagLink": "https://api.zhihu.com/topics/19565122"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1060599489433313280"
}
