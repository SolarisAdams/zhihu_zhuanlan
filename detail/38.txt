{
    "title": "Zero Switch", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/phoebos-sun", 
        "https://www.zhihu.com/people/yang-si-ran", 
        "https://www.zhihu.com/people/mmkkii", 
        "https://www.zhihu.com/people/liufangyi", 
        "https://www.zhihu.com/people/you-bian-you-tiao-gou", 
        "https://www.zhihu.com/people/kitty-19-61", 
        "https://www.zhihu.com/people/jiang-chen-63-39", 
        "https://www.zhihu.com/people/yaozhou", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/shen-yiyang-de-ren-75", 
        "https://www.zhihu.com/people/xiao-shi-ba-99", 
        "https://www.zhihu.com/people/sha-sha-63-2", 
        "https://www.zhihu.com/people/mattos-92", 
        "https://www.zhihu.com/people/xing-dong-liang-19", 
        "https://www.zhihu.com/people/brian-li", 
        "https://www.zhihu.com/people/liu-jia-wei-42-96", 
        "https://www.zhihu.com/people/lan-ren-bu-lan-51", 
        "https://www.zhihu.com/people/zhang-yin-10", 
        "https://www.zhihu.com/people/hao-yixin", 
        "https://www.zhihu.com/people/li-lei-26", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/bing-tang-hu-lu-53-44", 
        "https://www.zhihu.com/people/patrick_nicholas", 
        "https://www.zhihu.com/people/omm-chdn", 
        "https://www.zhihu.com/people/qi-liang-15", 
        "https://www.zhihu.com/people/jouli", 
        "https://www.zhihu.com/people/myuan", 
        "https://www.zhihu.com/people/chris-hsie", 
        "https://www.zhihu.com/people/yt-yt-34", 
        "https://www.zhihu.com/people/lukejfluo", 
        "https://www.zhihu.com/people/irelandken", 
        "https://www.zhihu.com/people/wanghenshui", 
        "https://www.zhihu.com/people/hhui-94", 
        "https://www.zhihu.com/people/suuyaoo", 
        "https://www.zhihu.com/people/mai-wen-jun", 
        "https://www.zhihu.com/people/yan-1", 
        "https://www.zhihu.com/people/yao-rong-zhen", 
        "https://www.zhihu.com/people/opensky-98", 
        "https://www.zhihu.com/people/qichao-tang", 
        "https://www.zhihu.com/people/YukiSou", 
        "https://www.zhihu.com/people/SpectorMercurial", 
        "https://www.zhihu.com/people/DaaaaaD", 
        "https://www.zhihu.com/people/sulvto", 
        "https://www.zhihu.com/people/faceair", 
        "https://www.zhihu.com/people/now-jie", 
        "https://www.zhihu.com/people/sinaean-dean-91", 
        "https://www.zhihu.com/people/hmn212008", 
        "https://www.zhihu.com/people/jimleee", 
        "https://www.zhihu.com/people/liu-meng-yuan-72-95", 
        "https://www.zhihu.com/people/GammaGo", 
        "https://www.zhihu.com/people/wudalu", 
        "https://www.zhihu.com/people/wu-wen-xiao", 
        "https://www.zhihu.com/people/kinglong-29", 
        "https://www.zhihu.com/people/zheng-chuan-jun", 
        "https://www.zhihu.com/people/yang-yu-cun", 
        "https://www.zhihu.com/people/jevon-qiao", 
        "https://www.zhihu.com/people/programjerry", 
        "https://www.zhihu.com/people/wusatosi", 
        "https://www.zhihu.com/people/huang-jun-2-28-38", 
        "https://www.zhihu.com/people/rsysw", 
        "https://www.zhihu.com/people/xiao-shan-qing", 
        "https://www.zhihu.com/people/ll-ma", 
        "https://www.zhihu.com/people/jiang-xue-lei-86", 
        "https://www.zhihu.com/people/graysen", 
        "https://www.zhihu.com/people/yuleqin", 
        "https://www.zhihu.com/people/liu-cheng-94-10", 
        "https://www.zhihu.com/people/boyua", 
        "https://www.zhihu.com/people/eric-zheng-6", 
        "https://www.zhihu.com/people/loner-79-51", 
        "https://www.zhihu.com/people/xu-yi-hang", 
        "https://www.zhihu.com/people/TsuanHM", 
        "https://www.zhihu.com/people/pin-yin-71", 
        "https://www.zhihu.com/people/inextime", 
        "https://www.zhihu.com/people/hen-ji-97", 
        "https://www.zhihu.com/people/james-30", 
        "https://www.zhihu.com/people/shengyinng", 
        "https://www.zhihu.com/people/donewell"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/72605554", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 1, 
            "title": "可控性之二 限流", 
            "content": "<p>限流是一个很迷的话题，毕竟，如果我对自己的系统进行了限流，导致用户请求得不到服务，这难道不是一个很严重的后果吗？显然，要想向一个人介绍限流，就需要先说服这个人，限流的确是有意义的，即使它会导致某些用户得不到服务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>限流涉及三个话题，本文将着重讨论为什么需要限流以及对哪些东西进行限流，如何执行限流将不在讨论中。</p><ul><li>为什么需要限流</li><li>需要对哪些东西进行限流</li><li>如何执行限流</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>为什么需要限流</h2><p>为什么需要限流，这是一个很有意思的问题，因此直观上来讲，一旦我对自己的系统进行了限流，就意味着，在某些情况下，必定有一些正常的用户请求得不到处理就被直接拒绝了。这怎么行，用户会骂我的。为理解这一问题，我们需要理解：</p><p><b>服务提供者的价值在于它每秒钟所能提供的有效服务数</b></p><p>即，一个系统的价值，在于它的有效OPS，何谓有效？能够在T时间内完成的请求是一个有效请求，超过T时间后再完成的请求，对客户的价值就小很多了。比如，用户浏览见面准备购物，如果商品页在1s内完成加载，用户会继续购买；如果超过10s还没有加载完成，用户可能就没有赎买的兴趣了。</p><p>如果你同意上面这句话，我们可以进一步推论：我们的程序应该以提供有效OPS为目标，所有与之与抵触的问题都可以无视。也即：</p><ul><li>如果一个请求在服务端<b>超过T时间</b>还没有完成处理，那么它是无价值的，需要立即丢弃</li><li>如果一个请求在<b>可预期的T时间</b>内无法完成处理，那么它是无价值的，需要立即丢弃</li><li>如果一个请求的处理会<b>导致服务端进入不稳定状态</b>，那么它是有害的，需要立即丢弃</li><li>如果一个请求的处理会<b>导致其他请求的服务时间大于T</b>，那么它是有害的，需要立即丢弃</li></ul><p>上面这四条原则告诉我们，不是所有的请求都有处理的价值的，也即，我们需要对请求进行限流，以保证：</p><ul><li>服务端不会因为资源超限而异常死掉</li><li>服务端不会浪费资源去处理无意义的请求</li><li>服务端完成的请求都是有价值的</li></ul><p>显然，在服务端不死的情况下，才能正常提供服务；在服务端不浪费资源去处理无意义的前提下，才能集中资源去处理更多的有效请求。</p><p>举一些具体的例子：</p><ul><li>假设我们在处理请求A，请求A的处理需要顺序调用服务X/Y/Z，如果在调用服务X时，由于服务X异常，请求T时间才完成，此时，请求A可以立即返回超时，不需要再去调用服务Y与Z，因为大概率下，客户端已经认为请求A超时，并且发起新的重试请求了，这种情况下，服务端继续处理请求A，基本上等同于浪费CPU</li><li>假设我们收到一个新的请求A，但是此时，服务列队中已经堆积了X条请求。根据我们的测试，如果队列深度大于X时，请求延迟会超过T。此时，请求A没有太大的处理价值，因此客户端大概率会超时。</li><li>假设我们收到一个新的请求A，处理它需要分配大量内存，导致内存超限，进而导致进程被kill，显然，请求A是有害的，我们需要立即拒绝。</li><li>不失一般性，假设我们只有一个核，并且使用的是thread per request模式，即每个新请求分配一个线程去处理。这种情况下，当我们接收到一个新的请求A，我们需要分配一个新的线程，然后执行A。这个新的线程的加入，会导致os的running queue进一步变长，进而导致当一个线程ready后的等待时间变长，影响其延迟。在这种情况下，我们需要拒绝这个请求。</li></ul><p>至此，我们应该理解了限流的意义。</p><hr/><h2>对哪些东西进行限流</h2><p>了解了限流的价值后，我们需要确认限流的对象。根据上文所说的限流的目标，我们可以列举同若干需要限流的对象，但它不是一个完整的列表，本质上还是要从限流的目标出发，拒绝所有无价值或者有害的请求，保证服务端的有效服务能力。以下举一些典型的例子：</p><ul><li>内存：每个请求的处理都会占用一定量内存，如果一个请求会使用超限内存，或者可能导致内存超限，请拒绝之。</li><li>线程：严格控制系统的线程数，一个系统可能有数十到数百个线程，但是绝不能有数千个线程。</li><li>带宽：如果一个请求会占用大量带宽，或者导致带宽超限，请及时拒绝。否则，当带宽占用率很高时，丢包现象会很严重，进而导致所有网络请求的延迟上升。</li><li>队列深度（pending请求数）：限制pending的请求数，一方面，每个请求会占用资源，pending请求数越多，资源占用越严重，极端情况下会导致OS资源不足，进而导致OOM这类现象；另一方面，pending请求过多，请求排队现象严重，会导致某些请求处理延迟变高。</li><li>...</li></ul><hr/><p>That&#39;s all。至于如何执行限流，那就因系统而异了，在此不加多说。</p><p>总结两句话：</p><ul><li>服务提供者的价值在于它每秒钟所能提供的有效服务数</li><li>低压力下出高性能</li></ul>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "稳定性", 
                    "tagLink": "https://api.zhihu.com/topics/19803488"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/47225958", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 1, 
            "title": "可控性之一 超时", 
            "content": "<p>工作实在太累，没有什么时间静下心来思考，趁周末写点东西吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先对题目进行一下解释。什么是可控性？一言以蔽之，</p><blockquote>可控性就是：你的应用在任意负载、任意访问模式、任意故障下，其行为是可以预期的。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>具体来说，我们可以看我们的程度看成两个部分：任务与资源，任务是我们的程度需要完成的事情，资源是运行我们的任务所需要的必要媒介，如：内存、CPU、网络、外部服务。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2152835d14212dcaa55e67351e0632d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"920\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb\" width=\"920\" data-original=\"https://pic2.zhimg.com/v2-2152835d14212dcaa55e67351e0632d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;920&#39; height=&#39;768&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"920\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"920\" data-original=\"https://pic2.zhimg.com/v2-2152835d14212dcaa55e67351e0632d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2152835d14212dcaa55e67351e0632d9_b.jpg\"/></figure><p>对于任务，我们即有前台的、面向用户的Connections与Requests，又有后台任务。</p><p>对于资源，我们有内部资源，如CPU、Memory、Network等用于支持程度正常执行的物理资源；也有外部资源，如我们所依赖的第三方服务，我们当前程度的协作者（master/slaves）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可控性即，无论出现什么样的负载（Connections/Requests/Background Task量太大，占用大量资源）、出现什么样的访问模型（Connections/Requests显示任意恶意的访问模式）、出现什么样的故障（Network质量差、外部依赖不可用），我们的任务总是能以一种可预期的方式完成，而不是出现任务无法完成，或者完成的质量较差（如响应延迟非常高）。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>了解了可控性的概念后，我们引入这次文章的主题：超时。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>超时是一个非常通用的概念，大家在写网络相关代码时总是会接触到这个名词。那么，大家有没有想过它的实质是什么？什么情况下我们需要引入超时？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>众所周知，当服务器处理某个任务时，会占用一定的资源，如服务器中，一个连接会占用一定量的内存、一个fd、一个网络地址，甚至在某些情况下还会占据一个线程。那么问题来了，如果这个连接是一个恶意连接，或者它所处理的任务很长时间都无法完成（如，此连接需要访问一个外部服务，都是外部服务非常慢，或者挂了），那么，这个连接将长时间占用它当前所占用的资源。对于同步服务器来说，这会导致一整个线程被占用；对于异步服务器来说，内存、fd、网络地址，在量积累到一定程度时，也是不可忽视的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>显然，我们需要限制此连接对资源的占用。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何限制任务对资源的占用呢？嗯，没错，就是超时。那么，超时是如何限制任务对资源的占用的呢？我们考虑两种情况：</p><ul><li>一个用户连接，被服务器接收后，分配了资源，准备处理；但是，用户一直不发送新的数据过来，造成连接一直处理未ready状态，但是它已经被分配了资源。</li><li>某个请求被处理时，调用某个依赖服务，当是此服务很长时间没有返回（可能是网络差、也可能是慢、也可能是它挂了）。</li></ul><p>显然，在上面两种情况下，我们都需要及时终止任务，释放资源。这就依赖于超时的能力：</p><ul><li><b>检测客户端恶意请求</b></li><li><b>检测依赖服务的偶发故障</b></li></ul><p>进而达到限制任务对资源的占用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>超时的功能讲完了吗？不，没有。由于超时能够检测依赖服务的偶发故障，应用可以及时介入，中断当前请求，然后尝试依赖服务的<b>另外一个实例</b>，从而保证请求的QoS。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>综合来讲，超时是可控性的基本原语之一，它具有以下能力：</p><ul><li>检测客户端恶意请求</li><li>检测依赖服务的偶发故障</li><li>限制任务对资源的占用</li><li>保证任务的QoS</li></ul><p>前两点是超时的基础能力，后两点是效果。</p><hr/><p>在了解了超时的作用后，我们来分析两个具体的例子：基本request-per-thread模式的web服务器与基于NIO的全异步web服务器，嗯，半同步半异步的就不考虑了。</p><hr/><p>对于request-per-thread模式的web服务器，基本上就是一个Acceptor线程，接收到connection后，扔到一个threadpool中去处理。我们一点一点来考虑。</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>Acceptor</li></ol><p>对于Acceptor线程，显然，它可以永久占用它所在的线程，且它是一个长期任务，所以可以不考虑超时。当它接收到一个连接时，注意，此时，我们的服务器收到了一个新的任务，我们需要开始考虑这个任务的资源分配问题，以便它能够被正确的处理，同时，还要保证我们的服务器的状态可控。一般的，Acceptor收到一个新连接时，为其分配了内存、fd等后，要将其提交给线程池，当一个线程来处理。如果线程池已经满了，我们应该怎么办？</p><ul><li>开一个新的线程：不可行！会造成服务器线程数膨胀，最终不可控。（想想服务器有一百个线程和一行个线程，各会怎么样？）</li><li>排队：如果队列过长，会造成用户请求响应延迟过高，QoS无保证。所以，<b>这里需要考虑超时，以保证QoS</b>。</li><li>拒绝：本质上是流控，一方便保证服务器资源不会被过度占用；一方面将选择权交给客户端（它可以自己等待一段时间后重试，也可以负载均衡到另外一台服务器）</li></ul><p>就Acceptor而言，在排队的情况下，需要考虑超时，来保证QoS。通常情况下，可以考虑流控。如果需要做流控的话，这里有一个小优化。Acceptor收到一个connection时，在Acceptor所在线程中处理connection，然后将Acceptor提交给线程池。</p><ul><li>一方面，connection的处理会更快，因为locality较好，且少了一次线程切换。</li><li>一方面，如果线程池已经满了，则Acceptor会排队，内核会自动做流控，直接reset新的socket syn。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>2. Connection处理</p><p>由于是Request-per-thread的模式，每个Connection的处理都会占用一个线程。你应该意识到，这是一个很恐怖的事情，毕竟，我们的服务器有几百个线程就顶了天了，如果Connection长时间占用线程，那将是一个灾难。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们将Connection的处理分成若干阶段，每个出现阻塞的地方都需要考虑超时，以限制资源占用：</p><ul><li>decode：我们需要读socket，decode出用户的request。显然，这里需要阻塞IO，我们需要考虑超时，以避免恶意用户发起连接后，一直不发送请求体，从而达到占用服务器资源的目标。</li><li>计算：全内存任务，无阻塞，可以不考虑超时。当然，如果用户故意构造了一个非常复杂的请求，导致计算它需要很长时间，占用大量CPU，这个时候就需要权衡了。</li><li>访问外部服务：这里面所说的外部服务，一方面包括提供http/rpc接口的服务，一方面也指各类数据库。一般的，访问这类服务，我们需要先从连接池中获取一个连接。然后再使用此连接与服务通信。</li><ul><li>从连接池中获取连接：显然，这需要考虑超时，因此连接池中如果当前没有资源，会出现阻塞。</li><li>与服务通信：显然，这里也需要考虑超时，因此外部服务可能慢、可能挂。</li></ul><li>encode：我们需要写socket，显示，这里面也需要超时。以避免慢客户或者恶意客户长时间占用服务器富贵的线程资源。如果超时，直接reset。</li></ul><hr/><p>接下来考虑全异步的web服务器。为了简单，我们只考虑单线程单Reactor的情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于Acceptor，只有epoll发现fd可读后，才会触发短暂的accept，来将请求从内核取出。因此不会涉及超时的问题。但是有一点值得一提的是，此fd必须是non blocking的。否则，可能出现，epoll发现fd上有新连接过来，但是在正准备调用accept时，此连接又被取消。此时，调用accept发现请求队列中并没有socket，如果acceptor fd是blocking的，就会出现阻塞。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当Acceptor收到一个连接后，我们会为其分配资源，并将其注册到epoll。注意，这里，我们分配了资源（fd、网络地址、socket buffers）。此时，我们实际上仍然需要考虑流控问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对Connection的读写实际上问题与之前类似，也会出现Connection上一直没有请求过来，或者请求过来一半；Connection一直不可写（因为客户端不ready，造成tcp流控）。这两种情况下，我们都需要考虑超时。实际上，不仅如此，即使没有慢客户、恶意用户，我们仍然需要加超时，以避免客户端异常crash，造成服务器没有感知到Connection中断。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虽然全异步场景下，一个服务器可以处理数万甚至数十万数百万的Connection，单个Connection占据的资源看起来微不足道，没有什么必要去限制；但我们仍然要考虑超时问题，考虑资源占用的限制，毕竟，现实情况太残酷，我们要珍惜服务器的每一点资源。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>总结</p><ul><li>所有可能阻塞的地方，请加超时</li><li>所有可能占用服务器资源的任务，请考虑超时</li></ul>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高可用", 
                    "tagLink": "https://api.zhihu.com/topics/19671201"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39541762", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 0, 
            "title": "微优化之九 Batching", 
            "content": "<p>有这样一个公式： <img src=\"https://www.zhihu.com/equation?tex=OPS+%3D+%E5%B9%B6%E5%8F%91%E5%BA%A6+%2A+%E8%AE%A1%E7%AE%97%E7%94%A8%E6%97%B6\" alt=\"OPS = 并发度 * 计算用时\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个公式告诉我们，如果想提供OPS，要么加更多的硬件（CPU、服务器），要么降低单路操作的延迟。那么，问题来了，如何降低单路操作的延迟？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们分两方面来讨论一下</p><ul><li>读：对于读，要降低其延迟，一般方法是缓存，即，在请求真正到来之前，将读请求需要的内容准备好。典型的例子如PageCache/网站静态页面/数据库异构表，如此，我们减少了IO链路，避免了不必要的计算，从而最终降低了读操作的延迟。</li><li>写：对于写，要降低其延迟，一般方法是异步，即，将不必要的步骤放在关键路径之外来做。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>提到降低延迟，还在一个很重要的方法，即并行化。如果，任务X有1，2，3，4四个独立子任务，将并行执行四个任务时，任务X的总延迟会变小。但是要注意的是，这种方法虽然降低了延迟，但是它使用了更多的计算资源来并行，所以公式中的并发度会下降，最终造成整体OPS不变。换一种说法是，任务的延迟降低了，但是任务占用计算资源的总时间没有降低，即，非并行化的方案是任务X占用一个线程40ms的时间，并行化的方案是，任务X占用4个线程各10ms的时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>故事还没有完。以上模型是建立在系统有多个计算资源，并且每个任务在完成之前，一直占用某一计算资源的情况下。对于不可并发执行的一类任务时，此模型即失效，但是，我们仍然可以使用流水线模型来提升其OPS。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果我们的计算资源只支持单并发呢？比如硬盘、网卡。对于此类延迟很高的计算，我们根本没有办法来降低延迟。相反，我们需要接受它延迟高的现实，并在此现实之上来构建我们的系统。一般的，我们需要足够的并发度，打满其任务队列，从而让其一直全功率工作。然而，事情还没有完，仅仅这样并不能充分使用硬件。对于这样高延迟的硬件，每个任务的执行，都会有非业务相关的开销，比如read需要陷入内核、磁盘需要寻道，这些额外开销累积后，会严重影响性能。因此，我们需要聚合任务，从而，多个任务只需要付出一次额外的非业务相关的开销。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>看这样一个例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iomanip&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">_1KB</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">_1MB</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">data_to_write</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"n\">_1MB</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">batch_size</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">do_write</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;batch.txt&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_SYNC</span> <span class=\"o\">|</span> <span class=\"n\">O_DIRECT</span> <span class=\"o\">|</span> <span class=\"n\">O_CREAT</span> <span class=\"o\">|</span> <span class=\"n\">O_APPEND</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">fd</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">batch_size</span><span class=\"p\">];</span>\n    <span class=\"k\">auto</span> <span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">data_to_write</span> <span class=\"o\">/</span> <span class=\"n\">batch_size</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"o\">::</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">setw</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">batch_size</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;: &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">do_write</span><span class=\"o\">&lt;</span><span class=\"n\">_1KB</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_write</span><span class=\"o\">&lt;</span><span class=\"n\">_1MB</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其结果为：</p><div class=\"highlight\"><pre><code class=\"language-text\">    1024: 269577724\n 1048576: 242720</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>再看一个例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;algorithm&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iomanip&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">_1KB</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">_1MB</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n<span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">data_to_write</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"n\">_1MB</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">batch_size</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">do_write</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;batch.txt&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_SYNC</span> <span class=\"o\">|</span> <span class=\"n\">O_DIRECT</span> <span class=\"o\">|</span> <span class=\"n\">O_CREAT</span> <span class=\"o\">|</span> <span class=\"n\">O_APPEND</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">fd</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">batch_size</span><span class=\"p\">];</span>\n    <span class=\"k\">auto</span> <span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">data_to_write</span> <span class=\"o\">/</span> <span class=\"n\">batch_size</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">count</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"o\">::</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"n\">batch_size</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">ts</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">block_size</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">parallel_write</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">concurrency</span> <span class=\"o\">=</span> <span class=\"mi\">64</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;batch.txt&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_SYNC</span> <span class=\"o\">|</span> <span class=\"n\">O_DIRECT</span> <span class=\"o\">|</span> <span class=\"n\">O_CREAT</span> <span class=\"o\">|</span> <span class=\"n\">O_APPEND</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">fd</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"o\">&gt;</span> <span class=\"n\">threads</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span> <span class=\"n\">diff</span><span class=\"p\">(</span><span class=\"n\">concurrency</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">concurrency</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">threads</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">diff</span><span class=\"p\">]{</span>\n            <span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">base</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">data_to_write</span> <span class=\"o\">/</span> <span class=\"n\">concurrency</span><span class=\"p\">);</span>\n            <span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">size_to_read</span> <span class=\"o\">=</span> <span class=\"n\">data_to_write</span> <span class=\"o\">/</span> <span class=\"n\">concurrency</span><span class=\"p\">;</span>\n            <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">block_size</span><span class=\"p\">];</span>\n\n            <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n            <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">size_to_read</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">block_size</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">pwrite</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">),</span> <span class=\"n\">base</span> <span class=\"o\">+</span> <span class=\"n\">i</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n            <span class=\"n\">diff</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">;</span>\n        <span class=\"p\">}));</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">t</span><span class=\"p\">:</span> <span class=\"n\">threads</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"o\">*</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">max_element</span><span class=\"p\">(</span><span class=\"n\">diff</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">diff</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">do_write</span><span class=\"o\">&lt;</span><span class=\"n\">_1MB</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">parallel_write</span><span class=\"o\">&lt;</span><span class=\"n\">_1KB</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>结果是：</p><div class=\"highlight\"><pre><code class=\"language-text\">705653\n61002918</code></pre></div><hr/><p>睡觉！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>PS</p><ol><li>以上三种模型结合起来会更加有趣哦。</li><li>懒得画图，配置图示食用更佳。</li></ol>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19633850"
                }
            ], 
            "comments": [
                {
                    "userName": "opensky", 
                    "userLink": "https://www.zhihu.com/people/333031a1d132970410ba55ead8af8c15", 
                    "content": "公式是否写错了？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "吴乎", 
                            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                            "content": "<p>哦，对，谢谢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "opensky"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39459710", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 3, 
            "title": "微优化之八 Pipeline", 
            "content": "<p>前面的章节多是理论，而这一章则更偏重方法论。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先， 对比三个概念：</p><ul><li>run-to-complete + 线程池</li><li><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Staged_event-driven_architecture\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SEDA</a></li><li>CPU instruction pipeline</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>其中，前两者常常用于服务端开发。后两者都是将一个完整的任务分成若干个阶段，并且，每个阶段使用独立的“硬件”（虚拟的也算，比如线程）。CPU instruction pipeline大家或多或少都知道，通过将一个指令的各个阶段流水线化，它提供了更高的吞吐，虽然每条指令本身的执行时间没有发生变化（可以还稍微变长了一些）。这看起来很神奇，毕竟，我们的OPS提高了！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题来了，CPU instruction pipeline与SEDA的区别在哪里？两者是子集关系吗？思考一下可知，SEDA是一种通用并发处理模式，它用于处理并发任务，在这一点上，它与run-to-complete+线程池的用途相同。而CPU instruction pipeline，它用于处理单个执行流，而不是并发！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>考虑run-to-complete+线程池与SEDA的区别。假设我们有一堆同质的并发任务，每个任务分成三个阶段，每个阶段用时10ms。假设我们总共有三个线程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们使用run-to-complete+线程池模式时，三个线程可以提供的OPS是1000/30 * 3= 100。</p><p>我们使用SEDA，假设三个线程组成链，每个线程负责一个阶段，三个线程可以提供的OPS是1000 / (30 / 3) = 100。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这意味着什么？意味着在处理并发任务时，线程池与SEDA（并发形式的pipeline）没有本质上的区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，为什么CPU instruction pipeline可以提升OPS，而SEDA不能呢？毕竟，两者看起来都是pipeline啊？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其本质在于，CPU instruction pipeline在处理不可并发的任务时，使用了额外的硬件！也即，指令处理的五个阶段中，每个阶段有专门的硬件负责，且这些硬件之间可以独立工作。换成应用层的术语，在处理一个不可并发的任务时，我们将其分成数个阶段，每个阶段用单独的线程来处理。由于任务不可并发，因此，线程池模式无法适用，但是，我们通过另外一种方法增加了线程数，实现了：<b>任务处理延迟不变，但是OPS提升</b>了！</p><hr/><p>下图是将不可并发的任务Pipeline化的示意图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ca735844e81b23b7173961bbe5e179b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1532\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"1532\" data-original=\"https://pic2.zhimg.com/v2-ca735844e81b23b7173961bbe5e179b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1532&#39; height=&#39;398&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1532\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1532\" data-original=\"https://pic2.zhimg.com/v2-ca735844e81b23b7173961bbe5e179b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ca735844e81b23b7173961bbe5e179b1_b.jpg\"/></figure><p>每个阶段是一个独立的线程来执行，每个阶段之间通过消息队列来移交任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>问题又来了，一旦涉及到多实体通信，必然要考虑流控的问题。如果三个阶段处理时间相等，则不需要考虑拥塞问题，整个任务处理的OPS可以提供三倍。而如果有某一阶段处理过慢，其他阶段只能stall。不妨设置三个阶段用时分别为t1/t2/t3，于是，整个系统的OPS提升可以形式化为： <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7B3%7D%7Bti%7D+%2F+%5Cmax%5C%7Bt1%2C+t2%2C+t3%5C%7D\" alt=\"\\sum_{i=1}^{3}{ti} / \\max\\{t1, t2, t3\\}\" eeimg=\"1\"/> 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>分析了t1/t2/t3的绝对大小的影响，我们再来考虑下其相对大小的影响。当三者差别不大的，简单的自旋就可以满足需要的，还可以减少切换带来的开销。但是，如果三者速度差别较大，则使用阻塞队列是一个更好的选择。</p><hr/><p>来看一段代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;chrono&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;boost/lockfree/spsc_queue.hpp&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">queue_size</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">literals</span><span class=\"o\">::</span><span class=\"n\">chrono_literals</span><span class=\"p\">;</span>\n\n<span class=\"k\">auto</span> <span class=\"nf\">now</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">high_resolution_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">pipeline2</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"p\">{};</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n\n            <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">sleep_for</span><span class=\"p\">(</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">milliseconds</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">));</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;pipeline-2:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">pipeline1</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">queue_size</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">sleep_for</span><span class=\"p\">(</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">milliseconds</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">));</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;pipeline-1:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;benchmark &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">x</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ms vs &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">y</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ms</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">;</span>\n\n    <span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">lockfree</span><span class=\"p\">;</span>\n    <span class=\"n\">spsc_queue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">&lt;</span><span class=\"n\">queue_size</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">q</span><span class=\"p\">;</span>\n\n    <span class=\"kr\">thread</span> <span class=\"nf\">a</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">pipeline2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"n\">pipeline1</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">);</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">queue_size</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">sleep_for</span><span class=\"p\">(</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">milliseconds</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">));</span>\n        <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">sleep_for</span><span class=\"p\">(</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">milliseconds</span><span class=\"p\">(</span><span class=\"n\">y</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;non-pipe:  &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">100</span><span class=\"p\">);</span>\n    <span class=\"n\">bench</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>这段代码将一个不可并发的任务分成了两个阶段，两个阶段的用时分别为x/y。我们测试了pipeline形式下与非pipeline形式下的处理时间。Pipeline模式下，两个线程使用spsc通信，出现拥塞是就自旋。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">benchmark 1ms vs 10ms\npipeline-1:1164588517\npipeline-2:10382503731\nnon-pipe:  11534735580\n\nbenchmark 5ms vs 10ms\npipeline-1:5265016746\npipeline-2:10386036324\nnon-pipe:  15644003038\n\nbenchmark 10ms vs 10ms\npipeline-1:10388877083\npipeline-2:10399001125\nnon-pipe:  20756820644\n\nbenchmark 10ms vs 5ms\npipeline-1:10313984625\npipeline-2:10319078419\nnon-pipe:  15639583040\n\nbenchmark 10ms vs 1ms\npipeline-1:10313558976\npipeline-2:10314662356\nnon-pipe:  11529398090\n\nbenchmark 1ms vs 100ms\npipeline-1:1144638848\npipeline-2:102534712471\nnon-pipe:  103702172237\n\nbenchmark 100ms vs 1ms\npipeline-1:102470880332\npipeline-2:102471848358\nnon-pipe:  103694614282</code></pre></div><p>我们来分析几个典型结果：</p><ul><li>1ms vs 10ms：此时，对于第二个阶段，其在10382503731内处理了1024个任务，说明有1024个任务被系统处理完毕，从而，系统OPS为10382503731/1024。对比非pipeline形式，性能提升不显著。</li><li>5ms vs 10ms：此时，系统OPS由第二阶段决定，由于x、y相差比较小，根据公式，性能提升强于1vs10的情况。</li><li>10ms vs 10ms：此时，两个阶段速度匹配，性能有一倍的提升，符合公式。</li><li>10ms vs 1ms：根据公式，其性能提升与1ms vs 10ms相同，但是，每一阶段stall的时间较长，从而消耗了不少CPU。这种情况下，实际上可以采用阻塞队列，而不是自旋。</li></ul><hr/><p>Pipeline的实质是重叠多个硬件，以提供系统性能，典型的有以下两种场景：</p><ul><li>阶段1与阶段2分别执行于两个线程内，两个线程在两个CPU上并发执行，这是<b>重叠多个CPU</b></li><li>阶段1是CPU计算，阶段2是IO操作，这种情况下，通常是使用异步执行，即，阶段1完成任务，然后提交IO任务，并且，不等待IO任务完成，立即开始下一个任务。这是<b>重叠CPU与IO</b></li></ul><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>Pipeline原理其实比较简单，但是，如果有应用于实践，一定要benchmark，确保你的优化真的是个优化，而不是劣化！</p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "优化", 
                    "tagLink": "https://api.zhihu.com/topics/19570512"
                }
            ], 
            "comments": [
                {
                    "userName": "冯杨", 
                    "userLink": "https://www.zhihu.com/people/51a499010986ee95f232bc544476effe", 
                    "content": "<p>CPU pipeline 模式实际实现需要配置硬件吗？这部分没有太理解。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "吴乎", 
                            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                            "content": "<p>CPU执行指令时会使用硬件pipeline来提高吞吐，程序员是无感知的。本篇文章讲得是软件层面的pipeline优化，即将一个任务分成若干个阶段，每个阶段用一个线程来执行。如此，整个任务的延迟会有上升，但是处理这个任务的系统的吞吐实际上是上升了的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "冯杨"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39212819", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 1, 
            "title": "微优化之七 Minimize Mem Footprint", 
            "content": "<p>之前提到过减少不同核之间缓存的同步可以提升性能（<a href=\"https://zhuanlan.zhihu.com/p/38707442\" class=\"internal\">Zero Synchronization</a>）。实际上，缓存的同步不仅仅发生在不同核的缓存之间，还发生在不同级缓存之间，以及缓存与内存之间。为了减少这种形式的同步，我们需要妥善利用的cache的locality，来避免不必要的cache flush与fetch。换一种说法，我们需要最小化内存的footprint，保证我们所访问的内存局限在一定的范围中，并且<b>访问尽量具有locality</b>。这样，我们可以保证我们所需要的数据总是在cache中，毕竟，L2有32MB，如果我们的<b>数据分布足够紧凑</b>，我们几乎可以总是保证最差情况下都能在L2中取得我们的数据，而不需要去L3，甚至于内存。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结下来有两点：</p><ol><li>数据分布要紧凑</li><li>数据访问具有locality</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>举一个老生常谈的例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;list&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;chrono&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">auto</span> <span class=\"nf\">now</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Container</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">Container</span><span class=\"o\">&amp;</span> <span class=\"n\">cont</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">acc</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"nl\">x</span><span class=\"p\">:</span> <span class=\"n\">cont</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">acc</span> <span class=\"o\">+=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">acc</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">constexpr</span> <span class=\"k\">auto</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">32</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">);</span>\n\n    <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"s\">&#34;list&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()));</span>\n    <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"s\">&#34;vect&#34;</span><span class=\"p\">,</span> <span class=\"n\">vec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其结果为：</p><div class=\"highlight\"><pre><code class=\"language-text\">list:92959082:0\nvect:15136051:0</code></pre></div><p>由于vector的locality更好，因此，其cache miss的机率更小，从而能带来更好的效率。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对上面的例子稍微更改一下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;list&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;chrono&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;algorithm&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">auto</span> <span class=\"nf\">now</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Container</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">Container</span><span class=\"o\">&amp;</span> <span class=\"n\">cont</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">acc</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"nl\">x</span><span class=\"p\">:</span> <span class=\"n\">cont</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">acc</span> <span class=\"o\">+=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">acc</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">vec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">acc</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sz</span> <span class=\"o\">=</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sz</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">rand</span><span class=\"p\">()</span> <span class=\"o\">%</span> <span class=\"n\">sz</span><span class=\"p\">;</span>\n        <span class=\"n\">acc</span> <span class=\"o\">+=</span> <span class=\"n\">vec</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;rand:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">acc</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">constexpr</span> <span class=\"k\">auto</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">32</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">vec</span><span class=\"p\">(</span><span class=\"n\">N</span><span class=\"p\">);</span>\n\n    <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"s\">&#34;list&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()));</span>\n    <span class=\"n\">access</span><span class=\"p\">(</span><span class=\"s\">&#34;vect&#34;</span><span class=\"p\">,</span> <span class=\"n\">vec</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>我们得到如下结果：</p><div class=\"highlight\"><pre><code class=\"language-text\">list:92268334:0\nvect:14929516:0\nrand:1027826239:0</code></pre></div><p>显然，失去了locality后，访问性能极速下降。那么，为什么list比rand的结果快呢？因为我们的list的分配是一次性完成后，从而，它的node实际上在heap上也是连续的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在，我们再来验证数据紧凑性的问题。在我的机器上，三层Cache大小分别为：</p><div class=\"highlight\"><pre><code class=\"language-text\">L1d cache:             32K\nL1i cache:             32K\nL2 cache:              256K\nL3 cache:              6M</code></pre></div><p>测试代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;list&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;chrono&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;algorithm&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">auto</span> <span class=\"nf\">now</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">chrono</span><span class=\"o\">::</span><span class=\"n\">steady_clock</span><span class=\"o\">::</span><span class=\"n\">now</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">rand_access</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">msg</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">vec</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">sz</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">acc</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"mi\">16</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">sz</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">auto</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">rand</span><span class=\"p\">()</span> <span class=\"o\">%</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n            <span class=\"n\">acc</span> <span class=\"o\">+=</span> <span class=\"n\">vec</span><span class=\"p\">[</span><span class=\"n\">k</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">now</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">msg</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">).</span><span class=\"n\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">acc</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">K</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"k\">auto</span> <span class=\"n\">M</span> <span class=\"o\">=</span> <span class=\"n\">K</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  1K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  1K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 16K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span> <span class=\"o\">*</span> <span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 32K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span> <span class=\"o\">*</span> <span class=\"mi\">32</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 64K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span> <span class=\"o\">*</span> <span class=\"mi\">64</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;256K&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">K</span> <span class=\"o\">*</span> <span class=\"mi\">256</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  1M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  2M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  4M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">4</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34;  6M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">6</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 16M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 32M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">32</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n    <span class=\"n\">rand_access</span><span class=\"p\">(</span><span class=\"s\">&#34; 64M&#34;</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">M</span> <span class=\"o\">*</span> <span class=\"mi\">64</span><span class=\"p\">),</span> <span class=\"n\">M</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>结果为</p><div class=\"highlight\"><pre><code class=\"language-text\">  1K:271979088:0\n  1K:258435470:0\n 16K:259382284:0\n 32K:259092245:0  // L1\n 64K:259115511:0\n256K:258960959:0  // L2\n  1M:259855369:0\n  2M:263801480:0\n  4M:267030938:0\n  6M:326419998:0  // L3\n 16M:620394358:0\n 32M:674997918:0\n 64M:697818094:0</code></pre></div><p>当数据的容量小于L3的容量（6M）时，其访问速度大致相同，但是大于L3后，性能持续恶化。第一个1K大家无视它吧，分析可能是因为载入指令时额外的开销吧。指令在cache中后，之后变化就不大了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在我的mac运行结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">  1K:195049923:0\n  1K:186170578:0\n 16K:181918908:0\n 32K:177767525:0    // L1\n 64K:187012024:0\n256K:180964474:0    // L2\n  1M:192265686:0\n  2M:192946584:0\n  4M:232831594:0\n  6M:288298239:0\n  8M:411664222:0    // L3\n 16M:647928857:0\n 32M:685557063:0\n 64M:747565275:0</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "内存管理", 
                    "tagLink": "https://api.zhihu.com/topics/19579205"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39212810", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 4, 
            "title": "微优化之六 Zero syscall", 
            "content": "<p>在<a href=\"https://zhuanlan.zhihu.com/p/38771059\" class=\"internal\">用户态操作系统</a>一文中，我们谈论了节约CPU的重要性，其中，一大重要手段就是<a href=\"https://zhuanlan.zhihu.com/p/38702469\" class=\"internal\">Zero Switch</a>，以减少进程抽象与诸多系统调用抽象带来的额外开销。其中，减少系统调用，是减少切换的一个重要手段。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比起进程切换，由于不需要刷TLB、不需要考虑大量的缓存失效、不需要考虑调度延迟，系统调用相对快得多，但是，比起应用级函数调用，其开销就相对比较大了。在进行系统调用时，需要切换内核栈，并且可能涉及到内核级别的动态内存分配，这又进一步增加了Cache miss的可能。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>看一个简单的例子，我们使用多种方法读取一个文件，一是一次读一个page，二是一次读两个page，三是一次读四个page，来观察读取文件所有内容所需要的时间。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">page_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span><span class=\"p\">;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">FILE_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">256</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024ULL</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">prepare</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">stat</span> <span class=\"n\">st</span> <span class=\"p\">{};</span>\n    <span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">st</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span><span class=\"p\">)(</span><span class=\"n\">st</span><span class=\"p\">.</span><span class=\"n\">st_size</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;dd if=/dev/zero of=test bs=4k count=1M oflag=direct&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;create failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">throw_system_error</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_error</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_category</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"n\">size_t</span> <span class=\"n\">N</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">do_read</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_RDONLY</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">page_size</span> <span class=\"o\">*</span> <span class=\"n\">N</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">));</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n            <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">r</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">prepare</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// warmup\n</span><span class=\"c1\"></span>    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;warmup done&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">4</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其结果为</p><div class=\"highlight\"><pre><code class=\"language-text\">warmup done\n1:45935488\n2:33720361\n4:29746433\n2:33712028\n1:44905057</code></pre></div><p>其性能差异比较明显。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>需要注意的时，我们这里执行了一个prepare操作，来预热PageCache，以使得系统调用快速返回。如果直接读磁盘，则性能差距则更加明显。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">page_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span><span class=\"p\">;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">FILE_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">256</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024ULL</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">prepare</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">stat</span> <span class=\"n\">st</span> <span class=\"p\">{};</span>\n    <span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">st</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span><span class=\"p\">)(</span><span class=\"n\">st</span><span class=\"p\">.</span><span class=\"n\">st_size</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;dd if=/dev/zero of=test bs=4k count=1M oflag=direct&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;create failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">throw_system_error</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_error</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_category</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"n\">size_t</span> <span class=\"n\">N</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">do_read</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_RDONLY</span> <span class=\"o\">|</span> <span class=\"n\">O_DIRECT</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"k\">alignas</span><span class=\"p\">(</span><span class=\"n\">page_size</span><span class=\"p\">)</span> <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">page_size</span> <span class=\"o\">*</span> <span class=\"n\">N</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">));</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n            <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">r</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">N</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">prepare</span><span class=\"p\">();</span>\n\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">4</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">do_read</span><span class=\"o\">&lt;</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其结果为</p><div class=\"highlight\"><pre><code class=\"language-text\">1:2383738762\n2:1517357394\n4:1249894002\n2:1675522686\n1:2549290669</code></pre></div><p>一次读一个page与一次读四个page，其性能差可以达到一倍。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>系统调用有其固然开销，但是在想办法优化它时，要先确保自己了解整个场景，并且需要做相应的benchmark，避免劣化。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>下面，举一些例子，来说明Zero syscall在实例开发中的应用：</p><ol><li>IO框架中，当需要唤醒另外一个线程的IO loop时，通常需要写一个eventfd，这涉及到write系统调用。由于io loop在sleep，其他多少生产者可以都需要唤醒它，这会造成多次write系统调用。通过，会使用一个原子变量来记录是否已经唤醒过。可以参见：</li></ol><a href=\"https://link.zhihu.com/?target=https%3A//github.com/netty/netty/blob/3.2/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java%23L143\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/netty/netty/</span><span class=\"invisible\">blob/3.2/src/main/java/org/jboss/netty/channel/socket/nio/NioWorker.java#L143</span><span class=\"ellipsis\"></span></a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/frohoff/jdk8u-jdk/blob/da0da73ab82ed714dc5be94acd2f0d00fbdfe2e9/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java%23L190\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/frohoff/jdk8</span><span class=\"invisible\">u-jdk/blob/da0da73ab82ed714dc5be94acd2f0d00fbdfe2e9/src/solaris/classes/sun/nio/ch/EPollSelectorImpl.java#L190</span><span class=\"ellipsis\"></span></a><p>2. 使用不准确时间，以避免每次获取时间都需要进行一次系统调用：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/nginx/nginx/blob/05f5a7325d939ade37daf1e2d4b34f4e83d49aff/src/event/ngx_event_timer.c%23L72\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/nginx/nginx/</span><span class=\"invisible\">blob/05f5a7325d939ade37daf1e2d4b34f4e83d49aff/src/event/ngx_event_timer.c#L72</span><span class=\"ellipsis\"></span></a><p>3. 使用writev/readv来减少read/write量。</p><p>4. Batch write减少write的系统调用</p><p>5. Cache减少read的系统调用</p><p>6. fd池以减少open/close的系统调用</p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "优化", 
                    "tagLink": "https://api.zhihu.com/topics/19570512"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38771059", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 18, 
            "title": "用户态操作系统之一 Seastar简介", 
            "content": "<h2>引言</h2><p>有一句老生常谈的话：CPU不是瓶颈，网络才是。在此前提下，服务端开发使用什么语言关系并不大，因为CPU还没用用满的情况下，网络就已经满了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然而，世殊事异，这句话的真实性已经大大下降。近几年，存储硬件与网络硬件高速发展，设备IOPS与带宽都是一涨再涨，其延迟甚至已经达到了数us的级别，一次进程切换也不过如此。相比之下，CPU在速度上几乎毫无发展。这就促使着开发者们开始研究各种<b>节约CPU</b>的技术：</p><ul><li>只有单个任务对CPU的需求下降了，CPU才能处理更多的任务，以享受硬件在带宽发展上的红利。</li><li>节约CPU，意味着单个任务的延迟更加短。硬件延迟已经很低了，如果不能降低软件延迟，则无法充分发挥硬件延迟上的红利。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>如何节约CPU</h2><p>想要节约CPU，我们首先需要知道现代CPU的使用方式，以及，哪些操作会占用大量的CPU时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现代CPU已经处于多核时代，我们的程序也是并发的，从而可以充分发挥多核CPU的优势。那么，我们的CPU究竟消耗在了什么地方？</p><ul><li>复制：在进行网络读写时，内核网络栈会从网卡中将数据复制到内核缓冲区中，我们的应用又会从内核网络栈中将数据复制到应用缓冲区中。反之亦然。硬件操作也有类型的情况发生。</li><li>进程切换：一方面，上下文切换的过程本身会消耗CPU；另一方面，正在工作的进程被切换出去再切换回来，会严重增加正在处理任务的延迟。</li><li>系统调用：上下文切换的开销。任务延迟增加。</li><li>中断处理：上下文切换的开销。任务延迟增加。</li><li>数据多核同步（缓存同步）</li><li>锁的开销：锁会引起多核缓存同步开销，严重时需要内核参与，造成上下文切换。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>可以参考以下文章：</p><a href=\"https://zhuanlan.zhihu.com/p/38700468\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">吴乎：微优化之一 Zero Allocation</a><a href=\"https://zhuanlan.zhihu.com/p/38701844\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">吴乎：微优化之二 Zero Branch misprediction</a><a href=\"https://zhuanlan.zhihu.com/p/38702469\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">吴乎：微优化之三 Zero Switch</a><a href=\"https://zhuanlan.zhihu.com/p/38707442\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">吴乎：微优化之四 Zero Synchronization</a><a href=\"https://zhuanlan.zhihu.com/p/38785800\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\"internal\">吴乎：微优化之五 Zero Copy</a><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以上将述问题大致分成三类：</p><ul><li>复制开销：如果整个IO栈不能一体化开发，这个问题很难避免。</li><li>切换开销：操作系统进程抽象固有开销，无法避免，只能尽力减少。</li><li>并发开销：缓存同步与切换开销。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>对于前两类问题，其根本来源都是内核抽象的开销，想要优化掉它，我们必然减少对内核的依赖，即，将内核提供的抽象，上移到应用层中，在应用层中实现这些抽象。典型的例子如：</p><ul><li>用户态TCP/IP栈</li><li>用户态PageCache与Disk IO调度</li><li>用户态线程/用户态调度器</li><li>用户态内存管理</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>对于并发开销，其优化思路则非常多：</p><ul><li>能用原子变量，尽量使用原子变量</li><li>锁分段</li><li>锁分解</li><li>降低锁的频率</li><li>读写锁</li><li>自旋锁</li><li>顺序锁</li><li>RCU</li></ul><p>是不是眼花缭乱？Linux自从进入SMP时代后，从最开始的Big kernel lock，到后来的spinlock，再到后来的RCU，基本每一行代码都要细斟慢酌，以求降低临界区大小，降低锁开销。那么，问题来了，一个工具使用起来如此复杂，是不是我们从一开始就使用了错误的工具，才把整个事情变得那么复杂？</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>并发范式 Share nothing</h2><p>并发编程难在哪里？难在共享数据，正是因为共享数据的存在，我们的才需要用各种手段保护它们，才需要在多个核之间同步数据。如果我们完全禁止共享数据呢？核与核之间只通过消息进程通信，会怎么样？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样的编程范式其实已经存在许多，如：</p><ul><li>Actor：每个Actor是一个独立运行的执行流，多个Actor之间只能通过发送消息来通信，禁止共享数据。</li><li>CSP：大家就理解为是golang提供的并发抽象吧。每个goroutine是一个独立运行的执行流，goroutine之间通过具名的channel进行通信。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>这类并发范式的核心都是Share nothing。此系列文章的主人公Seastar，采用了类似的思想，但是与上面又有很大的不同。Seastar引入了一层非常薄的抽象：它会在每个核上创建一个线程，并将此线程绑定在其上。不同核（线程）之间禁共享数据，只能通过消息队列来传递数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比起Actor与golang，seastar引入的抽象非常薄，它使得程序员可以完整地推断程序的行为，并且没有过重的runtime抽象开销。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>用户态操作系统 Seastar</h2><p>Seastar是一个应用框架，它几乎将操作系统所提供的抽象完整地搬移到了用户态中，以减少操作系统的抽象开销，实现软硬件一体化。</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/scylladb/seastar\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-4ab01b4bf978c25f61ef622861f1321d_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">scylladb/seastar</a><a href=\"https://link.zhihu.com/?target=http%3A//seastar.io/shared-nothing/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">seastar.io/shared-nothi</span><span class=\"invisible\">ng/</span><span class=\"ellipsis\"></span></a><h2>Seastar之执行流抽象</h2><p>可以将Seastar想象成一个支持多核的操作系统，每个核上运行着许多的“进程”，我们之后会使用执行流这个词，以避免混淆。但是与操作系统不同的是，这些执行流有固定的宿主核，每个执行流从头到尾只能在一个核上运行，并且，位于不同核上的执行流之间，只能通过跨核消息来通信。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以这样理解，Seastar将每个核抽象成一台单核计算机，每个单核计算机上运行着许多执行流，一个单核计算机上的多个执行流可以共享数据，不同单核计算机上的执行流只能通过消息来共享数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在考虑Seastar如何提供执行流抽象的。执行流的本质是一系列微任务被链接起来后形成的一个微任务链。为什么是微任务链，而不是一个连续的宏任务？因为，我们的任务通常涉及到IO，而IO并不总是可用的，比如，读一个socket时，其内还没有数据。此时，我们显然需要让出CPU，等待socket可读，才进行接下来的步骤。于是，我们的一个完整的宏任务被拆成了很多微任务，这些微任务被链接起来后，即是我们的宏任务，也即是我们的执行流。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bee58b65546014dc9d0bc5cbc5ee5c2c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic1.zhimg.com/v2-bee58b65546014dc9d0bc5cbc5ee5c2c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic1.zhimg.com/v2-bee58b65546014dc9d0bc5cbc5ee5c2c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-bee58b65546014dc9d0bc5cbc5ee5c2c_b.jpg\"/></figure><p>当然，复杂的微任务甚至可以构造一个有向无环图。这个有向无环图会由Seastar抽象的用户态CPU按照拓扑序来调度执行。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，Seastar是如何将这些微任务链接起来的？一种简单的方法是回调函数，写过js的人应该都理解。一种复杂的方法是提供用户态线程的抽象，即所谓协程，给用户提供一个单协程占用整个CPU的抽象。Seastar提供了另一种抽象，FPC，即future-promise-continuation。FPC使得构造有向无环图更加方便，使用协程的话，还需要提供latch/conditional variable等同步原语，才能构造更加复杂的执行流。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Seastar在每个用户态CPU上运行一个调度器，来调度一系列的微任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Seastar之内存抽象</h2><p>Share-nothing的用户态执行流的抽象降低了切换开销以及同步开销，然而，同一进程内，内存是共享的，分配与释放内存时，依然会有同步的存在。为了避免此问题，Seastar在应用启动时，将整个虚拟地址空间按照CPU核数等分为若干块，每个CPU使用自己的内存块进行内存分配与释放，从而避免同步。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Seastar之文件抽象</h2><p>Seastar是一个异步框架，任何一个核阻塞都会造成核上的待调度的微任务严重超时。然而，令人无奈的是，传统文件系统操作是同步阻塞的。好在AIO的存在解决了这一问题（虽然现在AIO还是一堆坑）。AIO有一些固有的限制，它必须以O_DIRECT方式打开文件，导致不能使用pagecache以及读写必须对齐。为了解决AIO的问题，Seastar维护用户态PageCache，从而实现了Zero copy的文件操作。并且，它维护自己的IO调度策略，从而更好地使用磁盘。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Seastar之用户态网络栈</h2><p>Seastar支持多种形式的网络操作，一是传统的epoll方式，这种方式已经非常成熟，并且在业内有广泛应用。另一种是用户态网络栈+DPDK，从而实现Zero copy与Zero switch的网络操作，进一步提高了网络的性能。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>这是一篇引言性质的文章，介绍的Seastar背后的思想以及简单构成。在后面的章节中，我将进一步剖析Seastar的源码，并且编写一个简化版本的Seastar实现。</p>", 
            "topic": [
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "高性能", 
                    "tagLink": "https://api.zhihu.com/topics/19616380"
                }, 
                {
                    "tag": "服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19554575"
                }
            ], 
            "comments": [
                {
                    "userName": "Qichao Tang", 
                    "userLink": "https://www.zhihu.com/people/e08346b00ad9dd39adf74542c2d39664", 
                    "content": "<p>期待中</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "吴乎", 
                            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                            "content": "<p>忙成狗</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Qichao Tang"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38785800", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 1, 
            "title": "微优化之五 Zero Copy", 
            "content": "<p>Zero copy是一个老生常谈的概念了，其本质是节约CPU，当然，也可能避免了不必要的内存分配，因为在复制的过程中，通常需要分配新的内存来容纳需要复制的数据。一般的，假设CPU每个cycle能复制1个byte（最好情况），那么，笔者现在所用的2.7GHz的笔记本，其吞吐为2.7GB/s。看起来这是一个很大的值，然而：</p><ul><li>考虑到CPU还需要做别的事情，且2.7GB/s是极端最优情况，在现实生活中根本不可能出现。</li><li>25G网卡已经投入使用，100G网卡已经Ready，然而CPU在频率上基本没有任何进步。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，我们如何应用Zero copy优化呢？一般的，实现Zero copy的方式有以下几种：</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>避免层到层之间的数据复制</h2><p>上层调用下层，下层回调上层，通常都会伴随着数据交换，而数据交换又会带来新内存分配与数据复制。比如，</p><ul><li>执行一个socket写时，数据会先被复制到内核缓冲区，再从内核缓冲区复制到网卡。</li><li>执行一个非direct文件读时，在缓存未命中的情况下，内核会先在PageCache中分配对应的cache（内存分配），然后发起外部设备读请求，数据被填充到PageCache中， 会再被复制到用户提供的缓存中。</li><li>使用C stdio时，默认情况下，每个FILE也会维护一个缓存。此缓存的目标是减少系统调用的开销，代价是一次额外的复制。然而幸运的是，它的缓存空间是静态的，不会涉及到额外的内存分配。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>要避免层到层之间的数据复制，你需要对IO链路上的每一步都十分清楚，这样才能有的放矢。</p><ul><li>如何避免socket的复制开销？使用用户态TCP栈，数据直接从网卡进应用内存，直接从应用内存到网卡。</li><li>如何避免磁盘文件的复制开销？使用direct读，一般需要配合应用态缓存。</li><li>如何避免C stdio的复制开销？在对自己的数据模式很了解，以及，了解为C stdio缓存的存在意义的前提下，关闭C stdio的缓存。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>避免数据结构扩张时带来的数据复制</h2><p>一般的，在进行数据交换的时候，如果要处理的数据的单元是固定大小的，我们可以使用一个固定大小的buffer来交换数据。比如daytime协议，我们明确知道服务器返回的应用数据包的大小，因此可以事先分配好一个buffer。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是，很多协议中，数据包是变长的。运气好的，它会在包的开头表明整个包的大小，因此，你可以先读入一个header，了解包的大小，然后分配对应大小的buffer，再将对应payload内容读入。运气不好的，你需要读到某个休止符，比如HTTP中的\\r\\n。此时，显然你需要动态扩容你的buffer（当然，也可以事先决定数据包的最大大小，然后按照最大大小来分配buffer）。然而，在动态扩容的过程中，我们除了要分配新的内存，还需要将旧的内存上的数据重新复制到新的内存上。这个过程类型C std中的realloc。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解决此问题的方法是加一个抽象层：我们不需要一个大的、连续的buffer，我们可以将很多小的buffer组合起来，然后对外提供一个大的、连续buffer的抽象。例子可以参考linux tcp/ip实现中的skbuf。</p><a href=\"https://link.zhihu.com/?target=https%3A//elixir.bootlin.com/linux/latest/source/include/linux/skbuff.h\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">elixir.bootlin.com/linu</span><span class=\"invisible\">x/latest/source/include/linux/skbuff.h</span><span class=\"ellipsis\"></span></a><p class=\"ztext-empty-paragraph\"><br/></p><h2>将复制工作交给其他硬件</h2><p>前面提到，Zero copy的本质是节约CPU，因此，如果由其他硬件来完成复制，不就ok了吗？当然，复制本身的延迟是避免不了的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>典型的硬件复制技术是DMA。现在在内核层已经基本普及了。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>现在来做一个简短的实验。我们从硬盘中读取一个4G的文件，前者使用buffered io（走PageCache），后者使用direct io（不走PageCache），观察其结果：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;condition_variable&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;deque&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">page_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span><span class=\"p\">;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">_4G</span> <span class=\"o\">=</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">prepare</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">stat</span> <span class=\"n\">st</span> <span class=\"p\">{};</span>\n    <span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">st</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span><span class=\"p\">)(</span><span class=\"n\">st</span><span class=\"p\">.</span><span class=\"n\">st_size</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">_4G</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;dd if=/dev/zero of=test bs=4k count=1M oflag=direct&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;create failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">cleanup_pagecache</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;echo 3 &gt; /proc/sys/vm/drop_caches&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;pagecache error&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"n\">ssize_t</span> <span class=\"nf\">do_read</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ssize_t</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"k\">alignas</span><span class=\"p\">(</span><span class=\"n\">page_size</span><span class=\"p\">)</span> <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">page_size</span><span class=\"p\">];</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">_4G</span> <span class=\"o\">-</span> <span class=\"n\">page_size</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">left</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">pread</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">),</span> <span class=\"n\">left</span><span class=\"p\">);</span>\n        <span class=\"k\">auto</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">pread</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">),</span> <span class=\"n\">right</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">y</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">y</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_error</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_category</span><span class=\"p\">());</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">ret</span> <span class=\"o\">+=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"n\">left</span> <span class=\"o\">+=</span> <span class=\"n\">page_size</span><span class=\"p\">;</span>\n        <span class=\"n\">right</span> <span class=\"o\">-=</span> <span class=\"n\">page_size</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">prepare</span><span class=\"p\">();</span>\n    <span class=\"n\">cleanup_pagecache</span><span class=\"p\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">fd1</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd1</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;open f1 failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">do_read</span><span class=\"p\">(</span><span class=\"n\">fd1</span><span class=\"p\">);</span>\n    <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd1</span><span class=\"p\">);</span>\n\n    <span class=\"n\">cleanup_pagecache</span><span class=\"p\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">fd2</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_DIRECT</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd2</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;open f2 failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">do_read</span><span class=\"p\">(</span><span class=\"n\">fd2</span><span class=\"p\">);</span>\n    <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd2</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>以下是5次运行的结果：</p><div class=\"highlight\"><pre><code class=\"language-text\">281478310\n264875664\n\n438343951\n219345451\n\n371735334\n245152052\n\n226060850\n182376507\n\n321271473\n232155090</code></pre></div><p>可以明显看到，dio总是比buffered io要快一些。那么，为什么5次结果差别有一些大呢？性能差在5% ~ 50%之间。初步分析，这可能是PageCache内存分配造成的，第一次运行时，系统中空闲内存较多，因此可以快速分配到内存。而之后的运行中，内存数量变少，因此分配开销也就更加大一些。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>需要注意的是，测试千万别写成这样：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/mman.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;condition_variable&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;deque&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">_4G</span> <span class=\"o\">=</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">prepare</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">stat</span> <span class=\"n\">st</span> <span class=\"p\">{};</span>\n    <span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">st</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">st</span><span class=\"p\">.</span><span class=\"n\">st_size</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;dd if=/dev/zero of=test bs=4k count=1M oflag=direct&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;create failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">cleanup_pagecache</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;echo 3 &gt; /proc/sys/vm/drop_caches&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;pagecache error&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">page_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span><span class=\"p\">;</span>\n\n<span class=\"n\">ssize_t</span> <span class=\"nf\">do_read</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ssize_t</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"k\">alignas</span><span class=\"p\">(</span><span class=\"n\">page_size</span><span class=\"p\">)</span> <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">page_size</span><span class=\"p\">];</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">auto</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">));</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_error</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_category</span><span class=\"p\">());</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">ret</span> <span class=\"o\">+=</span> <span class=\"n\">r</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">prepare</span><span class=\"p\">();</span>\n        <span class=\"n\">cleanup_pagecache</span><span class=\"p\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">fd1</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_RDONLY</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd1</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;open f1 failed&#34;</span><span class=\"p\">};</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">do_read</span><span class=\"p\">(</span><span class=\"n\">fd1</span><span class=\"p\">);</span>\n        <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd1</span><span class=\"p\">);</span>\n\n        <span class=\"n\">cleanup_pagecache</span><span class=\"p\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">fd2</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">open</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"n\">O_DIRECT</span> <span class=\"o\">|</span> <span class=\"n\">O_RDONLY</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fd2</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;open f2 failed&#34;</span><span class=\"p\">};</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">do_read</span><span class=\"p\">(</span><span class=\"n\">fd2</span><span class=\"p\">);</span>\n        <span class=\"o\">::</span><span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd2</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">exception</span><span class=\"o\">&amp;</span> <span class=\"n\">e</span><span class=\"p\">){</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cerr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">e</span><span class=\"p\">.</span><span class=\"n\">what</span><span class=\"p\">()</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">28458403787\n42324506631\n\n27756961490\n43738133258</code></pre></div><p>以上是两次运行的结果（16G文件）。有兴趣的自己思考为什么。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>下面再看看C stdio层的复制开销。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;system_error&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">page_size</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span><span class=\"p\">;</span>\n<span class=\"k\">constexpr</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">FILE_SIZE</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024ULL</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">prepare</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">stat</span> <span class=\"n\">st</span> <span class=\"p\">{};</span>\n    <span class=\"n\">stat</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">st</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span><span class=\"p\">)(</span><span class=\"n\">st</span><span class=\"p\">.</span><span class=\"n\">st_size</span><span class=\"p\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;dd if=/dev/zero of=test bs=4k count=1M oflag=direct&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;create failed&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">cleanup_pagecache</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;echo 3 &gt; /proc/sys/vm/drop_caches&#34;</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">runtime_error</span><span class=\"p\">{</span><span class=\"s\">&#34;pagecache error&#34;</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">throw_system_error</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">throw</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_error</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">system_category</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"n\">size_t</span> <span class=\"n\">N</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span> <span class=\"n\">std_read</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">FILE</span><span class=\"o\">*</span> <span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"n\">fopen</span><span class=\"p\">(</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;r&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">file</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">char</span> <span class=\"n\">_buf</span><span class=\"p\">[</span><span class=\"n\">N</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"o\">?</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"p\">];</span>\n    <span class=\"k\">if</span> <span class=\"nf\">constexpr</span> <span class=\"p\">(</span><span class=\"n\">N</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">setbuf</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">setvbuf</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">,</span> <span class=\"n\">_buf</span><span class=\"p\">,</span> <span class=\"n\">_IOFBF</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"kt\">char</span> <span class=\"n\">buffer</span><span class=\"p\">[</span><span class=\"n\">page_size</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">FILE_SIZE</span><span class=\"p\">;)</span> <span class=\"p\">{</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">fread</span><span class=\"p\">(</span><span class=\"n\">buffer</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">page_size</span><span class=\"p\">,</span> <span class=\"n\">file</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">feof</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ferror</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"n\">fclose</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">);</span>\n            <span class=\"n\">throw_system_error</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">fclose</span><span class=\"p\">(</span><span class=\"n\">file</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">prepare</span><span class=\"p\">();</span>\n\n    <span class=\"c1\">// warmup\n</span><span class=\"c1\"></span>    <span class=\"n\">std_read</span><span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;warmup done&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">unbuffered</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">buffered</span> <span class=\"o\">=</span> <span class=\"mi\">0ULL</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">32</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">unbuffered</span> <span class=\"o\">+=</span> <span class=\"n\">std_read</span><span class=\"o\">&lt;</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n        <span class=\"n\">buffered</span> <span class=\"o\">+=</span> <span class=\"n\">std_read</span><span class=\"o\">&lt;</span><span class=\"n\">page_size</span><span class=\"o\">&gt;</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span>\n        <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;unbuffered: &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">unbuffered</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span>\n        <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;  buffered: &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">buffered</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>运行五次开销如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">unbuffered: 6058006468\n  buffered: 6102535550\n\nunbuffered: 6549785516\n  buffered: 6574015942\n\nunbuffered: 6029860887\n  buffered: 6070637064\n\nunbuffered: 6073452630\n  buffered: 6109679359\n\nunbuffered: 6097918279\n  buffered: 6132306052</code></pre></div><p>可以看到，在没有内存分配开销的前提下，这里的Zero copy带来的性能提升并不显著。这也提示着我们，在进行优化决策时，一定要以benchmark为最终决策依据，不要做无谓的性能优化来浪费时间。</p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38707442", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 8, 
            "title": "微优化之四 Zero Synchronization", 
            "content": "<p>多线程并不是免费的午餐，它只对对它友好的代码才展现出自己强大的能力，而很对它不友好的代码，可以反而出现劣化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>多线程的开销一方面来源于阻塞/调度的开销，另一方面则来源于缓存同步/一致性的开销。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>缓存同步的开销有多大？</h2><p>不妨先考虑单线程的情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一般的读写操作会直接访问L1中的数据，在单线程下，读写L1数据不需要额外的开销（原子变量除外），因此速度很快。看一个例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iomanip&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;atomic&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdint&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">Mutex_int</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span>    <span class=\"n\">m</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Mutex_int</span><span class=\"o\">&amp;</span> <span class=\"k\">operator</span><span class=\"o\">++</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n        <span class=\"o\">++</span><span class=\"n\">v</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"k\">this</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">operator</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">T</span> <span class=\"n\">c</span> <span class=\"p\">{};</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"o\">++</span><span class=\"n\">c</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">setw</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">left</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;uint64_t&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"k\">volatile</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;volatile&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">atomic_uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;atomic&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"n\">Mutex_int</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;mutex&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上述程序分别对普通变量、volatile变量、原子变量、锁同步变量进行了累加性能测试。其中，原子变量与锁同步变量都会触发缓存一致性，造成缓存同步。在我的机器上，其结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t  :61645566:10485760\nvolatile  :44307144:10485760\natomic    :110820339:10485760\nmutex     :231702808:10485760</code></pre></div><p>观察到，原子变量的开销是普通变量的2倍，而锁则是3~4倍。但是，但是，这里的volatile什么鬼？为什么比普通变量还快一些？看了一下汇编：</p><div class=\"highlight\"><pre><code class=\"language-ca65\"> .L47:\n   cmpl   $10485759, -28(%rbp)\n   jg .L46\n   addq   $1, -24(%rbp)\n   addl   $1, -28(%rbp)\n   jmp .L47\n .L46:\n\n.L50:\n   cmpl   $10485759, -28(%rbp)\n   jg .L49\n   movq   -24(%rbp), %rax\n   addq   $1, %rax\n   movq   %rax, -24(%rbp)\n   addl   $1, -28(%rbp)\n   jmp .L50\n.L49</code></pre></div><p>上面是普通变量，下面是volatile，可以看到，volatile的代码理论上应该更慢一些。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的代码是在Linux Ubuntu Intel(R) Core(TM) i5-4460  CPU @ 3.20GHz上测试的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我又在Macbook Pro 2016上测试了下，结果是这样：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t  :20214000:10485760\nvolatile  :24943000:10485760</code></pre></div><p>暂时无视这个问题吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>多线程缓存同步开销</h2><p>考虑多线程上缓存同步的开销。同样，看一段代码。</p><div class=\"highlight\"><pre><code class=\"language-text\">#include &lt;time.h&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;iomanip&gt;\n#include &lt;atomic&gt;\n#include &lt;cstdint&gt;\n#include &lt;mutex&gt;\n\nusing namespace std;\n\nuint64_t rdtsc()\n{\n    timespec t{};\n    clock_gettime(CLOCK_MONOTONIC, &amp;t);\n    return (uint64_t)(t.tv_sec) * (uint64_t)1000000000 + (uint64_t)(t.tv_nsec);\n}\n\nstruct Mutex_int {\n    std::uint64_t v = 0;\n    std::mutex    m;\n\n    Mutex_int&amp; operator++()\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(m);\n        ++v;\n        return *this;\n    }\n\n    operator std::uint64_t()\n    {\n        std::lock_guard&lt;std::mutex&gt; lock(m);\n        return v;\n    }\n};\n\ntemplate &lt;class T&gt;\nvoid run(const char* name)\n{\n    T c {};\n    auto fn = [&amp;c]{\n        for (int i = 0; i &lt; 1000 * 1000 * 5; ++i) {\n            ++c;\n        }\n    };\n\n    auto start = rdtsc();\n    std::thread t1(fn);\n    std::thread t2(fn);\n\n    t1.join();\n    t2.join();\n    auto end = rdtsc();\n    std::cout &lt;&lt; std::setw(10) &lt;&lt; std::left &lt;&lt; name &lt;&lt; &#34;:&#34; &lt;&lt; (end - start) &lt;&lt; &#34;:&#34; &lt;&lt; c &lt;&lt; std::endl;\n}\n\nint main()\n{\n    run&lt;std::uint64_t&gt;(&#34;uint64_t&#34;);\n    run&lt;volatile std::uint64_t&gt;(&#34;volatile&#34;);\n    run&lt;std::atomic_uint64_t&gt;(&#34;atomic&#34;);\n    run&lt;Mutex_int&gt;(&#34;mutex&#34;)\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint64_t  :31662126:5875328\nvolatile  :35481318:5526576\natomic    :222388436:10000000\nmutex     :828010498:10000000</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>需要注意的是，多线程下，同步是必不可少的，并且，volatile不是一个完整的多线程同步工具。因此，不要用它！可以看到，普通变量与volatile变量的结果都是不正确的。而原子变量与互斥保护的变量其结果是正确的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>多线程情况下，数据被两个线程竞争（我的机器是4核的，两个线程会在两个核上跑），数据需要进入L1，并参与MESI进行缓存一致性。也就是说，由于两个线程在争抢数据的写权限，数据所在cacheline会在两个核之间的L1跑来跑去。性能可想而知。而在单线程情况下，如果使用普通变量，数据直接就待在寄存器里面。差一点的情况也是，数据一直待在某一个核的L1中。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>不可预知的同步：cacheline bouncing/false sharing</h2><p>前面的例子中，我们展示了缓存同步的开销，但是在某些场景下，即使代码访问的是两个看起来不相干的变量，仍然会出现缓存同步。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>看如下一段代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iomanip&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;atomic&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdint&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">T</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">alignas</span><span class=\"p\">(</span><span class=\"mi\">64</span><span class=\"p\">)</span> <span class=\"n\">T</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">16</span><span class=\"p\">]</span> <span class=\"p\">{};</span>\n    <span class=\"k\">static_assert</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"s\">&#34;bad&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">static_assert</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">64</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s\">&#34;bad&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">auto</span> <span class=\"n\">fn</span> <span class=\"o\">=</span> <span class=\"p\">[](</span><span class=\"n\">T</span><span class=\"o\">*</span> <span class=\"n\">c</span><span class=\"p\">){</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1000</span> <span class=\"o\">*</span> <span class=\"mi\">1000</span> <span class=\"o\">*</span> <span class=\"mi\">5</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"o\">++</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">c</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">};</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span> <span class=\"n\">t1</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span> <span class=\"n\">t2</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n\n    <span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">setw</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">left</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"sc\">&#39;=&#39;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n    <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kr\">thread</span><span class=\"p\">(</span><span class=\"n\">fn</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]);</span>\n\n    <span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">setw</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">left</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"sc\">&#39;=&#39;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;uint_t&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"k\">volatile</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;volatile&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">atomic_uint64_t</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;atomic&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>其结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">uint_t    :37236331:5000000=5000000\nuint_t    :16245876:5000000=5000000  // no cacheline share\nvolatile  :36773434:5000000=5000000\nvolatile  :11600325:5000000=5000000  // no cacheline share\natomic    :217963216:5000000=5000000\natomic    :39047972:5000000=5000000  // no cacheline share</code></pre></div><p>可以看到，由于两个线程并未访问同一个变量，所以，即使我们不使用原子变量，程序的结果依然是正确的。缓存一致性协议会保证这一点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的代码，对每种类型的变量分别执行了两个测试。在第一种情况中，由于两个线程分别访问的变量位于同一个cacheline中，因此，这条cacheline会不断地在两个线程（这里，由于核数足够，就是两个CPU）之间跳来跳去，即所谓cacheline bouncing。第二种情况中，两个变量并不在一个cacheline中，因此性能会好很多。</p><hr/><p>进程间同步的开销是巨大的，即使用原子变量取代锁，其同步开销一样会比普通变量高很多。这也是为什么现在share-nothing这个概念非常常见的原因。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Zero Synchronization的应用可以看以下两个文档：</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/brpc/brpc/blob/master/docs/cn/bvar.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-9ecaec4015dac2e8ad7a2014b8128e5c_ipico.jpg\" data-image-width=\"420\" data-image-height=\"420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">brpc/brpc</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/scylladb/seastar/wiki/SMP\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/scylladb/sea</span><span class=\"invisible\">star/wiki/SMP</span><span class=\"ellipsis\"></span></a><p></p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": [
                {
                    "userName": "DONEWELL", 
                    "userLink": "https://www.zhihu.com/people/80a8ddf7a51f466f97121bee17cc4c97", 
                    "content": "现在好好写文章的怎么都没人给赞。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Sinaean Dean", 
                    "userLink": "https://www.zhihu.com/people/9a732559bf9621e808d38026bbda71a6", 
                    "content": "<p>对于单线程的情况，如果mutex中间的代码不只是累加，而是比较复杂的操作，是不是mutex引入的时间就变得微不足道了？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "吴乎", 
                            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                            "content": "<p>对。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Sinaean Dean"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38702469", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 3, 
            "title": "微优化之三 Zero Switch", 
            "content": "<p>先列举几个名词：</p><ul><li>无锁队列</li><li>Run to complete</li><li>单线程化</li><li>非阻塞IO</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>这些名词外在体现千差万别，但其实核心都在于，Zero switch，避免上下文切换。上下文切换的影响包括但不限于Flush TLB、Flush L1、等待重新调度、CPU消耗。无论是Cache miss还是等待重新调用，都在很大程度上提升代码的延迟。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>看一个例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;thread&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;mutex&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;condition_variable&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;deque&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;boost/lockfree/spsc_queue.hpp&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">consume</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"p\">{};</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">produce</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">64</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">Mutex_queue</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">m</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">deque</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n\n    <span class=\"kt\">bool</span> <span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1024</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n            <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">bool</span> <span class=\"nf\">pop</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">&amp;</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">();</span>\n            <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">pop_front</span><span class=\"p\">();</span>\n            <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">Blocking_queue</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">m</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">condition_variable</span> <span class=\"n\">not_empty</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">condition_variable</span> <span class=\"n\">not_full</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">deque</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n\n    <span class=\"kt\">bool</span> <span class=\"nf\">push</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_lock</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1024</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">not_full</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n\n        <span class=\"n\">not_empty</span><span class=\"p\">.</span><span class=\"n\">notify_one</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">bool</span> <span class=\"nf\">pop</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">&amp;</span> <span class=\"n\">a</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unique_lock</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"p\">);</span>\n\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">not_empty</span><span class=\"p\">.</span><span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">front</span><span class=\"p\">();</span>\n        <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">pop_front</span><span class=\"p\">();</span>\n\n        <span class=\"n\">not_full</span><span class=\"p\">.</span><span class=\"n\">notify_one</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">consume2</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"p\">{};</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">pop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"k\">break</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">yield</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Q</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">produce2</span><span class=\"p\">(</span><span class=\"n\">Q</span><span class=\"o\">*</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">64</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"n\">this_thread</span><span class=\"o\">::</span><span class=\"n\">yield</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">q</span><span class=\"o\">-&gt;</span><span class=\"n\">push</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">boost</span><span class=\"o\">::</span><span class=\"n\">lockfree</span><span class=\"p\">;</span>\n    <span class=\"n\">spsc_queue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">&lt;</span><span class=\"mi\">1024</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">q</span><span class=\"p\">;</span>\n\n    <span class=\"kr\">thread</span> <span class=\"nf\">a</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">consume</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">q</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"kr\">thread</span> <span class=\"nf\">b</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">produce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">q</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n    <span class=\"n\">Mutex_queue</span> <span class=\"n\">m</span><span class=\"p\">;</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">consume</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">produce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n    <span class=\"n\">Mutex_queue</span> <span class=\"n\">m2</span><span class=\"p\">;</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">consume2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m2</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">produce2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m2</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n    <span class=\"n\">Blocking_queue</span> <span class=\"n\">m3</span><span class=\"p\">;</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">consume</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m3</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">produce</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m3</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n\n    <span class=\"n\">spsc_queue</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">capacity</span><span class=\"o\">&lt;</span><span class=\"mi\">1024</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">m4</span><span class=\"p\">;</span>\n    <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">consume2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m4</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n    <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kr\">thread</span><span class=\"p\">([</span><span class=\"o\">&amp;</span><span class=\"p\">]{</span> <span class=\"n\">produce2</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">m4</span><span class=\"p\">);</span> <span class=\"p\">});</span>\n\n    <span class=\"n\">a</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n    <span class=\"n\">b</span><span class=\"p\">.</span><span class=\"n\">join</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在我的机器上，其结果如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">6820555109   // lockfree + busyloop\n42337648854  // mutex + busyloop\n39011354738  // mutex + yield\n49320860259  // blocking queue\n5574822885   // lockfree + yield</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>简单说明上上述代码，两个线程，一个生产者，一个消费者，通过一个队列进行通信。在第一种情况下，两者使用一个无锁的队列进程通信并busylook；第二种情况下，两者使用一个基于mutex的队列通信并busyloop；第三种情况下，两者使用基于mutex的队列通过并使用yield来减少busyloop；第四种情况下，两者使用阻塞队列来通信；第五种情况下，两者使用无锁列队并使用yield来减少busyloop。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>显然，无锁队列此场景上性能极高。为什么？因此使用mutex时，当加锁失败，线程会被切换出去（阻塞）。lockfree + yield的性能有些出乎意外。猜测是，这里虽然有了yield，但是给予了消费者或者生产者消费或者生产大量对象的机会，潜在地起到了一个batch的作用。为了验证此猜测，我们将队列的大小设置为1。再运行几次，然后发现得到的结果是，lockfree + busyloop很快就结束了，但是lockfree + yield长时间没有响应，且某个CPU使用率一直处于100%，其中的60%以上，都消耗在内核代码中，毕竟，切换也是非常损耗CPU时间的。<br/></p><hr/><p>如何利用Zero switch？这就方法太多了，前面提到的一些名词，都是它的具体应用。但在实际使用中，需要具体问题具体分析，并且<b>建立在benchmark的基础上</b>！</p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "非阻塞", 
                    "tagLink": "https://api.zhihu.com/topics/19618909"
                }
            ], 
            "comments": [
                {
                    "userName": "hello", 
                    "userLink": "https://www.zhihu.com/people/1b9c79fe7985cedc54c4d40cd16ef91c", 
                    "content": "赞，太冷清了。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "初级程序员", 
                    "userLink": "https://www.zhihu.com/people/e45a4f15462c5ea136e43fd26b05df5d", 
                    "content": "谢谢大神分享，受益良多！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Sinaean Dean", 
                    "userLink": "https://www.zhihu.com/people/9a732559bf9621e808d38026bbda71a6", 
                    "content": "<p>数据很有意义，我们现在就是lockfree + yield</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38701844", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 1, 
            "title": "微优化之二 Zero Branch misprediction", 
            "content": "<p>分支预测是一个很重要，但又不那么直观的技术，如果读过Linux内核代码的话，会发现里面所有的if的条件都被包含在likely/unlikely中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为了具体了解分支预测的重要性，看下面一段macrobenchmark。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdint&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;algorithm&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;numeric&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Vec</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">Vec</span><span class=\"o\">&amp;</span> <span class=\"n\">vec</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">vec</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">v</span><span class=\"p\">(</span><span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">64</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">iota</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">rbegin</span><span class=\"p\">(),</span> <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">rend</span><span class=\"p\">(),</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n\n    <span class=\"k\">auto</span> <span class=\"n\">v1</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n    <span class=\"k\">auto</span> <span class=\"n\">v2</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">reverse</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">v1</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">random_shuffle</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">v2</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n\n    <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">);</span>\n    <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">);</span>\n    <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">);</span>\n\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">is_sorted</span><span class=\"p\">(</span><span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">v</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()));</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">is_sorted</span><span class=\"p\">(</span><span class=\"n\">v1</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">v1</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()));</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">is_sorted</span><span class=\"p\">(</span><span class=\"n\">v2</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">v2</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()));</span>\n<span class=\"p\">}</span> \n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>在我的机器上，其运行结果为：</p><div class=\"highlight\"><pre><code class=\"language-text\">11884567629\n15769333277\n29888509785</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>其结果可以用分支预测来解释：对于几乎有序的数据，分支预测可以很好的命中，从而回忆指令执行的速度。而对于完全乱序的数据，分支预测的命中率则会下降很多，进而影响整个排序的性能。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，如何使用分支预测呢？实际上，分支预测是一个比较低层的特性，在高层代码中使用它所能获得的性能提升微乎其微，它更加适用于底层代码，特别是处于循环中的代码。对于这些代码，我们可以使用likely/unlikely，帮助编译器生成更好的指令。</p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38700468", 
            "userName": "吴乎", 
            "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
            "upvote": 2, 
            "title": "微优化之一 Zero Allocation", 
            "content": "<p>避免内存分配是高性能服务器的一项重要技术，毕竟，内存分配是一项开销极大的工作，并且，在多线程环境中，分配内存还涉及到同步开销。几乎所有的高性能服务器都对内存分配做了特别的处理，有自己的内存管理模块，通过缓存、池、静态分配等技术，尽量减少或者完成避免在关键路径上的内存分配。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为了具体了解一下内存分配对性能的影响，我们做一个简单的microbenchmark。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;time.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iomanip&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdint&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cassert&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;algorithm&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;numeric&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"k\">namespace</span> <span class=\"n\">std</span><span class=\"p\">;</span>\n\n<span class=\"n\">uint64_t</span> <span class=\"nf\">rdtsc</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">timespec</span> <span class=\"n\">t</span><span class=\"p\">{};</span>\n    <span class=\"n\">clock_gettime</span><span class=\"p\">(</span><span class=\"n\">CLOCK_MONOTONIC</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">t</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)</span><span class=\"mi\">1000000000</span> <span class=\"o\">+</span> <span class=\"p\">(</span><span class=\"n\">uint64_t</span><span class=\"p\">)(</span><span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">tv_nsec</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"kt\">bool</span> <span class=\"n\">Alloc</span><span class=\"o\">&gt;</span>\n<span class=\"kt\">void</span> <span class=\"n\">run</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">name</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">auto</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">uint64_t</span> <span class=\"n\">c</span> <span class=\"p\">{};</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">1024</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"k\">constexpr</span> <span class=\"p\">(</span><span class=\"n\">Alloc</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"k\">auto</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">c</span> <span class=\"o\">+=</span> <span class=\"o\">*</span><span class=\"n\">t</span><span class=\"p\">;</span>\n            <span class=\"k\">delete</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"o\">++</span><span class=\"n\">c</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">auto</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">rdtsc</span><span class=\"p\">();</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">setw</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">left</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">name</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"kt\">int</span> <span class=\"n\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"nb\">true</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;alloc&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">run</span><span class=\"o\">&lt;</span><span class=\"nb\">false</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;noalloc&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>编译并运行之，在我的机器上输出如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">alloc     :276332405:10485760\nnoalloc   :21717431:10485760</code></pre></div><p>性能有十倍的差距。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>那么，现实世界中是如何利用Zero Allocation技术的呢？</p><ul><li>Per request内存池：在处理一个请求时，在请求开销创建一个小的内存池，在处理这个请求的过程中，所有的内存操作都会在从这个池中进行内存分配。</li><ul><li>Nginx在实现中使用了这种技术。</li></ul><li>静态分配：在应用生命周期开始时，分配好所有对象，并放到freelist中，之后，所有的分配从freelist中进行。这种技术的应用范围更加广阔。</li><ul><li>早期Linux内核中，所有数据结构都是静态分配的</li><li>Redis中event对象是静态分配的</li><li>Nginx中connection/event等都是静态分配的</li></ul><li>对象缓存池：避免内存分配只是基础，毕竟，分配完内存后，我们是需要构造对象的，如果避免掉构造对象，将对象缓存起来，可以在更大程度上减少不必要的工作</li><ul><li>Linux slab</li><li>Database connection pool</li><li>Thread pool</li></ul><li>Per thread内存池</li><li>Per thread缓存：Memcache的内存管理非常具体特色，这也是它比Redis更加稳定的一个重大原因。它的每个线程会有一个对象缓存，并且还提供了LRU机制，同时，为了避免碎片，它也做了额外的设计。值得一看！</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>警告：如果你是Java程序员，请慎用各个进程内缓存技术！</b></p>", 
            "topic": [
                {
                    "tag": "高性能服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19909568"
                }, 
                {
                    "tag": "内存管理", 
                    "tagLink": "https://api.zhihu.com/topics/19579205"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_155826365"
}
