{
    "title": "数字图像处理系列", 
    "description": "有了传统图像处理算法的加持，现代的深度学习才会发挥出更强大的作用", 
    "followers": [
        "https://www.zhihu.com/people/chauncey-chen-85", 
        "https://www.zhihu.com/people/yfl-48", 
        "https://www.zhihu.com/people/jjh-1-6", 
        "https://www.zhihu.com/people/wo-shi-luo-kuai-kuai", 
        "https://www.zhihu.com/people/jerry-skywalker", 
        "https://www.zhihu.com/people/tian-gou-9-68", 
        "https://www.zhihu.com/people/zhao-zhi-an-91", 
        "https://www.zhihu.com/people/lee-87-75", 
        "https://www.zhihu.com/people/mu-tou-ren-87-71", 
        "https://www.zhihu.com/people/bioninja", 
        "https://www.zhihu.com/people/guan-xu-58", 
        "https://www.zhihu.com/people/ceng-li-57-81", 
        "https://www.zhihu.com/people/innerpeace-24-25-99", 
        "https://www.zhihu.com/people/sinarer-zi", 
        "https://www.zhihu.com/people/feng-zhuang-54", 
        "https://www.zhihu.com/people/zl-zl-2", 
        "https://www.zhihu.com/people/li-da-ren-34-32", 
        "https://www.zhihu.com/people/coffgod", 
        "https://www.zhihu.com/people/laoayang", 
        "https://www.zhihu.com/people/mi-yang-36-53", 
        "https://www.zhihu.com/people/wzz-74-1", 
        "https://www.zhihu.com/people/chang-he-luo-ri-11-79", 
        "https://www.zhihu.com/people/zhang-chun-yun-41", 
        "https://www.zhihu.com/people/muzhi-fan", 
        "https://www.zhihu.com/people/xiaojidan", 
        "https://www.zhihu.com/people/eliot-chen-27", 
        "https://www.zhihu.com/people/arch-40", 
        "https://www.zhihu.com/people/jiang-jun-wei-gua-feng-hou-yin-74", 
        "https://www.zhihu.com/people/zhui-guang-zhe-31-54", 
        "https://www.zhihu.com/people/fu-za-ren-zhi-xin-nian-de-hu-li", 
        "https://www.zhihu.com/people/hu-yun-song-22", 
        "https://www.zhihu.com/people/xiao-stre", 
        "https://www.zhihu.com/people/liu-meng-yin-68", 
        "https://www.zhihu.com/people/dong-man-kong-97", 
        "https://www.zhihu.com/people/panda-74-66", 
        "https://www.zhihu.com/people/wang-xian-sheng-94-11", 
        "https://www.zhihu.com/people/carrie-young", 
        "https://www.zhihu.com/people/mo-ming-qi-miao-11-17", 
        "https://www.zhihu.com/people/zhang-yan-jie-39", 
        "https://www.zhihu.com/people/lin-lin-87-38", 
        "https://www.zhihu.com/people/boyuezh", 
        "https://www.zhihu.com/people/fenggege", 
        "https://www.zhihu.com/people/she-tian-lang-28", 
        "https://www.zhihu.com/people/zhangdongrn", 
        "https://www.zhihu.com/people/mo-ran-er-yi", 
        "https://www.zhihu.com/people/tom-zheng-12", 
        "https://www.zhihu.com/people/asmsoffa", 
        "https://www.zhihu.com/people/li-sheng-38-23", 
        "https://www.zhihu.com/people/kong-fan-cheng-37", 
        "https://www.zhihu.com/people/wang-lang-96-64", 
        "https://www.zhihu.com/people/zhangfun", 
        "https://www.zhihu.com/people/zw-huang-19", 
        "https://www.zhihu.com/people/lcx-85", 
        "https://www.zhihu.com/people/gu-jin-feng-30", 
        "https://www.zhihu.com/people/song-shu-kayu", 
        "https://www.zhihu.com/people/young-yang-60-82", 
        "https://www.zhihu.com/people/zhuang-xiao-xian-27", 
        "https://www.zhihu.com/people/lin-de-mou", 
        "https://www.zhihu.com/people/xueyingulang", 
        "https://www.zhihu.com/people/meng-la-la-89", 
        "https://www.zhihu.com/people/youngwater", 
        "https://www.zhihu.com/people/dong-di-58", 
        "https://www.zhihu.com/people/young-chen-47", 
        "https://www.zhihu.com/people/gu-yu-71-65", 
        "https://www.zhihu.com/people/kavin-wang", 
        "https://www.zhihu.com/people/zhang-yun-he-17", 
        "https://www.zhihu.com/people/feng-ling-20-5-18", 
        "https://www.zhihu.com/people/hua-hua-86-34-89", 
        "https://www.zhihu.com/people/DINGKAIMENG", 
        "https://www.zhihu.com/people/cao-jin-58", 
        "https://www.zhihu.com/people/li-hao-80-3", 
        "https://www.zhihu.com/people/penelopenelope", 
        "https://www.zhihu.com/people/michellezh", 
        "https://www.zhihu.com/people/hobby-43", 
        "https://www.zhihu.com/people/dezheng", 
        "https://www.zhihu.com/people/xue-xue-23-54", 
        "https://www.zhihu.com/people/earnshaw", 
        "https://www.zhihu.com/people/wen-wen-48-2", 
        "https://www.zhihu.com/people/pfsang", 
        "https://www.zhihu.com/people/stevie-20", 
        "https://www.zhihu.com/people/chehche", 
        "https://www.zhihu.com/people/zhang-zhao-37-42", 
        "https://www.zhihu.com/people/zk-cumt", 
        "https://www.zhihu.com/people/xian-nai-ka-26", 
        "https://www.zhihu.com/people/123456abcdef-51", 
        "https://www.zhihu.com/people/yun-yun-zhong-sheng-77-28", 
        "https://www.zhihu.com/people/ri-guang-qing-cheng-89-36", 
        "https://www.zhihu.com/people/yuan-xing-mei-zu-2014", 
        "https://www.zhihu.com/people/zine-9-13", 
        "https://www.zhihu.com/people/zhang-liu-tong-92", 
        "https://www.zhihu.com/people/kang-shao-42-46", 
        "https://www.zhihu.com/people/sun00god", 
        "https://www.zhihu.com/people/ace-leung", 
        "https://www.zhihu.com/people/yao-yang-4-61", 
        "https://www.zhihu.com/people/li-jeremy-10", 
        "https://www.zhihu.com/people/xh-lv-11", 
        "https://www.zhihu.com/people/MASTER-of-chaos", 
        "https://www.zhihu.com/people/kong-bang-wa-40", 
        "https://www.zhihu.com/people/spada2067", 
        "https://www.zhihu.com/people/da-mo-cang-ying-98", 
        "https://www.zhihu.com/people/xiao-qiang-46-65", 
        "https://www.zhihu.com/people/guo-bing-21-58", 
        "https://www.zhihu.com/people/hua-lun-xi-ya", 
        "https://www.zhihu.com/people/tangyanhui", 
        "https://www.zhihu.com/people/cao-mei-wei-de-xiang-jiao-77", 
        "https://www.zhihu.com/people/fa-er-ke-ni-si-52", 
        "https://www.zhihu.com/people/boss-j-19", 
        "https://www.zhihu.com/people/arslan-27-67", 
        "https://www.zhihu.com/people/sunhsu", 
        "https://www.zhihu.com/people/liu-yilang-65", 
        "https://www.zhihu.com/people/jian-xiao-80-99", 
        "https://www.zhihu.com/people/mu-yi-83-37-69", 
        "https://www.zhihu.com/people/yuegege", 
        "https://www.zhihu.com/people/chen-jian-hua-70-30", 
        "https://www.zhihu.com/people/jia-xue-feng", 
        "https://www.zhihu.com/people/zhen-bu-sheng-jiu-li", 
        "https://www.zhihu.com/people/zhang-shi-yu-52-98", 
        "https://www.zhihu.com/people/bu-yu-53", 
        "https://www.zhihu.com/people/wang-jing-bo-27-88", 
        "https://www.zhihu.com/people/yugengde1999", 
        "https://www.zhihu.com/people/you-gao-du-de-bei-zi", 
        "https://www.zhihu.com/people/david-li-60-97", 
        "https://www.zhihu.com/people/guo-yu-hao-41-1", 
        "https://www.zhihu.com/people/cheney-49-99", 
        "https://www.zhihu.com/people/zhangsan-97-39", 
        "https://www.zhihu.com/people/mu-yu-lan-feng-16", 
        "https://www.zhihu.com/people/dukai-6", 
        "https://www.zhihu.com/people/zhang-jun-long-4", 
        "https://www.zhihu.com/people/gu-ding-de-tian-yi", 
        "https://www.zhihu.com/people/he-zheng-e", 
        "https://www.zhihu.com/people/li-tao-81-84", 
        "https://www.zhihu.com/people/alex-45-44-1", 
        "https://www.zhihu.com/people/coer-arctan", 
        "https://www.zhihu.com/people/yang-yi-hua-78", 
        "https://www.zhihu.com/people/wang-kang-ming-94", 
        "https://www.zhihu.com/people/chen-jie-77-63", 
        "https://www.zhihu.com/people/carrot-zh", 
        "https://www.zhihu.com/people/magicchuyi", 
        "https://www.zhihu.com/people/lock-caps", 
        "https://www.zhihu.com/people/lv-shi", 
        "https://www.zhihu.com/people/shen-yuan-71-87", 
        "https://www.zhihu.com/people/shuang-zi-xing-xing", 
        "https://www.zhihu.com/people/wu-zhi-10-99", 
        "https://www.zhihu.com/people/ji-guang-pian-yu-29", 
        "https://www.zhihu.com/people/jiang-han-yue-78", 
        "https://www.zhihu.com/people/ke-wu-88", 
        "https://www.zhihu.com/people/qi-lin-44-44", 
        "https://www.zhihu.com/people/da-zhi-ruo-yu-82-47", 
        "https://www.zhihu.com/people/fan-shi-jun-49", 
        "https://www.zhihu.com/people/bill_wu", 
        "https://www.zhihu.com/people/wan-xi-piao-luo", 
        "https://www.zhihu.com/people/libin-sui", 
        "https://www.zhihu.com/people/Steven_Jokes", 
        "https://www.zhihu.com/people/xie-guo-chen-11", 
        "https://www.zhihu.com/people/ybsolar", 
        "https://www.zhihu.com/people/yarqian", 
        "https://www.zhihu.com/people/ai-hua-bi-nu-shen-meng-yao-i", 
        "https://www.zhihu.com/people/liang-liang-25-85", 
        "https://www.zhihu.com/people/deng-chen-97", 
        "https://www.zhihu.com/people/sunrise-14-74", 
        "https://www.zhihu.com/people/peng-xi-27-81", 
        "https://www.zhihu.com/people/lu-nathan-79", 
        "https://www.zhihu.com/people/tinythytigerdaddy", 
        "https://www.zhihu.com/people/woodknight", 
        "https://www.zhihu.com/people/she-liang", 
        "https://www.zhihu.com/people/xkf-41", 
        "https://www.zhihu.com/people/johnny-63-54"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/85829145", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 9, 
            "title": "一文讲解方向梯度直方图（hog）", 
            "content": "<p>目录：</p><ol><li><b>特征描述符</b></li><li><b>方向梯度直方图(hog)</b></li><ol><li><b>图像预处理</b></li><li><b>计算梯度图</b></li><li><b>计算梯度直方图</b></li><li><b>Block 归一化</b></li><li><b>计算HOG特征向量</b></li><li><b>代码实现</b></li></ol></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一、特征描述符</b></h2><p>特征描述符就是通过提取图像的有用信息，并且丢弃无关信息来简化图像的表示。</p><p>HOG特征描述符可以将3通道的彩色图像转换成一定长度的特征向量。</p><p>那么我们就需要定义什么是“有用的”，什么是“无关的”。这里的“有用”，是指对于什么目的有用，显然特征向量对于观察图像是没有用的，但是它对于像图像识别和目标检测这样的任务非常有用。当将这些特征向量输入到类似支持向量机（SVM）这样的图像分类算法中时，会得到较好的结果。</p><p>那什么样的“特征”对分类任务是有用，比如我们想检测出马路上的车道线，那么我们可以通过边缘检测来找到这些车道线，在这种情况下，边缘信息就是“有用的”，而颜色信息是无关的。</p><p>在HOG特征描述符中，梯度方向的分布，也就是梯度方向的直方图被视作特征。图像的梯度(x和y导数)非常有用，因为边缘和拐角(强度突变的区域)周围的梯度幅度很大，并且边缘和拐角比平坦区域包含更多关于物体形状的信息。</p><p>方向梯度直方图(HOG)特征描述符常和线性支持向量机(SVM)配合使用，用于训练高精度的目标分类器。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二、方向梯度直方图(hog)</b></h2><p>接下来讲一下计算图像的HOG特征描述符的具体步骤。</p><p>我们以下面这张图片为例（宽高为100x200）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2ccc671e60031942dca8a129410a0383_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"835\" class=\"content_image\" width=\"384\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;384&#39; height=&#39;835&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"835\" class=\"content_image lazy\" width=\"384\" data-actualsrc=\"https://pic4.zhimg.com/v2-2ccc671e60031942dca8a129410a0383_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、图像预处理</b></p><p>可以对图像进行裁剪，并缩放到固定尺寸。</p><p>灰度处理是可选操作，因为灰度图像和彩色图像都可以用于计算梯度图，对于彩色图像，先对三通道颜色值分别计算梯度，然后取梯度值最大的那个作为该像素的梯度。</p><p>然后进行伽马矫正，调节图像对比度，减少光照对图像的影响（包括光照不均和局部阴影），使过曝或者欠曝的图像恢复正常，更接近人眼看到的图像。</p><p>伽马矫正公式：</p><p><img src=\"https://www.zhihu.com/equation?tex=f%28x%29+%3D+x+%5E+%5Cgamma+%5C%5C\" alt=\"f(x) = x ^ \\gamma \\\\\" eeimg=\"1\"/> </p><p>即输出图像是输入图像的幂函数，指数为 <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> ​。</p><p>代码实现如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;gamma.jpg&#39;</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"n\">img2</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">power</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"o\">/</span><span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">)),</span> <span class=\"mf\">1.5</span><span class=\"p\">)</span></code></pre></div><p><img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> ​越大，图像越暗；为1时，表示没有变化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2、计算梯度图</b></p><p>为了得到梯度直方图，那么首先需要计算水平和垂直梯度，这可以通过使用以下内核过滤图像来实现，分别用于计算水平梯度和垂直梯度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-13f7d8dc5cf43bd204b9f6fc93755bf8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"313\" data-rawheight=\"170\" class=\"content_image\" width=\"313\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;313&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"313\" data-rawheight=\"170\" class=\"content_image lazy\" width=\"313\" data-actualsrc=\"https://pic1.zhimg.com/v2-13f7d8dc5cf43bd204b9f6fc93755bf8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以使用内核大小为1的Sobel算子，来获得相同的结果。</p><p>关于Sobel计算梯度的详细内容，可以去看 <u><a href=\"https://zhuanlan.zhihu.com/p/67197912\" class=\"internal\">这篇文章</a></u>，本文不过多介绍了哈。</p><p>然后再计算x和y方向梯度的合梯度，包括幅值和方向：</p><p><img src=\"https://www.zhihu.com/equation?tex=g+%3D+%5Csqrt+%7Bg_x%5E2+%2B+g_y%5E2%7D+%5C%5C+%5Ctheta+%3D+%5Ctext+%7Barctan%7D+%5Cfrac+%7Bg_y%7D%7Bg_x%7D\" alt=\"g = \\sqrt {g_x^2 + g_y^2} \\\\ \\theta = \\text {arctan} \\frac {g_y}{g_x}\" eeimg=\"1\"/> </p><p>注意：梯度方向会取绝对值，因此得到的角度范围是 [0,180°]。</p><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># Read image</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;runner.jpg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">255.0</span>  <span class=\"c1\"># 归一化</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 计算x和y方向的梯度</span>\n<span class=\"n\">gx</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">Sobel</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">CV_32F</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">ksize</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">gy</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">Sobel</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">CV_32F</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ksize</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 计算合梯度的幅值和方向（角度）</span>\n<span class=\"n\">mag</span><span class=\"p\">,</span> <span class=\"n\">angle</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cartToPolar</span><span class=\"p\">(</span><span class=\"n\">gx</span><span class=\"p\">,</span> <span class=\"n\">gy</span><span class=\"p\">,</span> <span class=\"n\">angleInDegrees</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span></code></pre></div><p>如下分别为x方向梯度图，y方向梯度图，梯度幅值图<code>,</code>梯度方向图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-db0e86f06f7145d93b56851ea0649562_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1541\" data-rawheight=\"849\" class=\"origin_image zh-lightbox-thumb\" width=\"1541\" data-original=\"https://pic3.zhimg.com/v2-db0e86f06f7145d93b56851ea0649562_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1541&#39; height=&#39;849&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1541\" data-rawheight=\"849\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1541\" data-original=\"https://pic3.zhimg.com/v2-db0e86f06f7145d93b56851ea0649562_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-db0e86f06f7145d93b56851ea0649562_b.jpg\"/></figure><p>在每个像素处，梯度有一个大小和一个方向。x方向梯度图会强化垂直边缘特征，y方向梯度图会强化水平边缘特征。这就使得有用的特征（轮廓）得到保留，无关不重要的信息被去除。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、计算梯度直方图</b></p><p>在这一步，我们先把整个图像划分为若干个8x8的小单元，称为cell，并计算每个cell的梯度直方图。这个cell的尺寸也可以是其他值，根据具体的特征而定。</p><p>为什么我们要把图像分成若干个8x8的小单元？</p><p>这是因为对于一整张梯度图，其中的有效特征是非常稀疏的，不但运算量大，而且效果可能还不好。于是我们就使用特征描述符来表示一个更紧凑的特征。一个8x8的小单元就包含了8x8x2 = 128个值，因为每个像素包括梯度的大小和方向。</p><p>现在我们要把这个8x8的小单元用长度为9的数组来表示，这个数组就是梯度直方图。这种表示方法不仅使得特征更加紧凑，而且对单个像素值的变化不敏感，也就是能够抗噪声干扰。</p><p>我们来看一下图片中的一个cell中的梯度：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-809cdb84fe7d3f72c35c4b9873f8bab7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-809cdb84fe7d3f72c35c4b9873f8bab7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;540&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-809cdb84fe7d3f72c35c4b9873f8bab7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-809cdb84fe7d3f72c35c4b9873f8bab7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>中间那张图中的箭头表示梯度，箭头方向表示梯度方向，箭头长度表示梯度大小。</p><p>右图是 8×8 的cell中表示梯度的原始数字，注意角度的范围介于0到180度之间，而不是0到360度， 这被称为“无符号”梯度，因为两个完全相反的方向被认为是相同的。</p><p>现在我们来计算cell中像素的梯度直方图，先将角度范围分成9份，也就是9 bins，每20°为一个单元，也就是这些像素可以根据角度分为9组。将每一份中所有像素对应的梯度值进行累加，可以得到9个数值。直方图就是由这9个数值组成的数组，对应于角度0、20、40、60... 160。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-19b90b8c94c5e16b203845de7b35290f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-19b90b8c94c5e16b203845de7b35290f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;616&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-19b90b8c94c5e16b203845de7b35290f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-19b90b8c94c5e16b203845de7b35290f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>比如上面方向图中蓝圈包围的像素，角度为80度，这个像素对应的幅值为2，所以在直方图80度对应的bin加上2。红圈包围的像素，角度为10度，介于0度和20度之间，其幅值为4，那么这个梯度值就被按比例分给0度和20度对应的bin，也就是各加上2。</p><p>还有一个细节需要注意，如果某个像素的梯度角度大于160度，也就是在160度到180度之间，那么把这个像素对应的梯度值按比例分给0度和160度对应的bin。</p><p>将这 8x8 的cell中所有像素的梯度值加到各自角度对应的bin中，就形成了长度为9的直方图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fe4baf102e5e6add82c1fd9b293718be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"466\" data-original=\"https://pic3.zhimg.com/v2-fe4baf102e5e6add82c1fd9b293718be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;466&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"466\" data-original=\"https://pic3.zhimg.com/v2-fe4baf102e5e6add82c1fd9b293718be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fe4baf102e5e6add82c1fd9b293718be_b.jpg\"/></figure><p>可以看到直方图中，0度和160附近有很大的权重，说明了大多数像素的梯度向上或者向下，也就是这个cell是个横向边缘。</p><p>现在我们就可以用这9个数的梯度直方图来代替原来很大的三维矩阵，即代替了8x8x2个值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4、Block 归一化</b></p><p>HOG将8×8的一个区域作为一个cell，再以2×2个cell作为一组，称为block。由于每个cell有9个值，2×2个cell则有36个值，HOG是通过滑动窗口的方式来得到block的，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2324177420c0a79d48d844b5e124f1f3_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"497\" data-thumbnail=\"https://pic4.zhimg.com/v2-2324177420c0a79d48d844b5e124f1f3_b.jpg\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;497&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"497\" data-thumbnail=\"https://pic4.zhimg.com/v2-2324177420c0a79d48d844b5e124f1f3_b.jpg\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic4.zhimg.com/v2-2324177420c0a79d48d844b5e124f1f3_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在前面的步骤中，我们基于图像的梯度对每个cell创建了一个直方图。</p><p>但是图像的梯度对整体光照非常敏感，比如通过将所有像素值除以2来使图像变暗，那么梯度幅值将减小一半，因此直方图中的值也将减小一半。 理想情况下，我们希望我们的特征描述符不会受到光照变化的影响，那么我们就需要将直方图“归一化” 。</p><p>在说明如何归一化直方图之前，先看看长度为3的向量是如何归一化的。</p><p>假设我们有一个向量 <code>[128,64,32]</code>，向量的长度为 <img src=\"https://www.zhihu.com/equation?tex=%5Csqrt+%7B128%5E2+%2B+64%5E2+%2B+32%5E2%7D%3D146.64\" alt=\"\\sqrt {128^2 + 64^2 + 32^2}=146.64\" eeimg=\"1\"/> ，这叫做向量的L2范数。将这个向量的每个元素除以146.64就得到了归一化向量 <code>[0.87, 0.43, 0.22]</code>。</p><p>现在有一个新向量，是第一个向量的2倍 [128x2, 64x2, 32x2]，也就是 <code>[256, 128, 64]</code>，我们将这个向量进行归一化，你可以看到归一化后的结果与第一个向量归一化后的结果相同。所以，对向量进行归一化可以消除整体光照的影响。</p><p>知道了如何归一化，现在来对block的梯度直方图进行归一化（注意不是cell），一个block有4个直方图，将这4个直方图拼接成长度为36的向量，然后对这个向量进行归一化。</p><p>因为使用的是滑动窗口，滑动步长为8个像素，所以每滑动一次，就在这个窗口上进行归一化计算得到长度为36的向量，并重复这个过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>5、计算HOG特征向量</b></p><p>终于可以计算整个图像的特征描述符了，每滑动一次，一个block就得到一个长度为36的特征向量，那会得到多少个特征向量呢？</p><p>比如上面这个图，将整幅图像划分成cell的个数为8x16，就是横向有8个cell，纵向有16个cell。每个block有2x2个cell的话，那么cell的个数为：(16-1)x(8-1)=105。即有7个水平block和15个竖直block。</p><p>再将这105个block合并，就得到了整个图像的特征描述符，长度为 105×36=3780。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>6、代码实现</h3><p>我们来对图像的 HOG 特征描述符进行可视化。OpenCV 好像没有提供简单的方法可视化 HOG 描述符，所以这里使用python库<code>skimage</code>。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">from</span> <span class=\"nn\">skimage</span> <span class=\"kn\">import</span> <span class=\"n\">feature</span><span class=\"p\">,</span> <span class=\"n\">exposure</span>\n<span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;/home/zxd/Pictures/Selection_018.jpg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">hog_image</span> <span class=\"o\">=</span> <span class=\"n\">feature</span><span class=\"o\">.</span><span class=\"n\">hog</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">orientations</span><span class=\"o\">=</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">pixels_per_cell</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">),</span>\n                    <span class=\"n\">cells_per_block</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">visualize</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># Rescale histogram for better display</span>\n<span class=\"n\">hog_image_rescaled</span> <span class=\"o\">=</span> <span class=\"n\">exposure</span><span class=\"o\">.</span><span class=\"n\">rescale_intensity</span><span class=\"p\">(</span><span class=\"n\">hog_image</span><span class=\"p\">,</span> <span class=\"n\">in_range</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"err\">​</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;img&#39;</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;hog&#39;</span><span class=\"p\">,</span> <span class=\"n\">hog_image_rescaled</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">waitKey</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"s1\">&#39;q&#39;</span><span class=\"p\">)</span></code></pre></div><p>注：使用命令<code>pip install scikit-image</code>来安装 <code>skimage</code>。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里最关键的函数就是 <code>feature.hog</code>，它把上面介绍的几个步骤都替我们完成了，其中有几个关键参数：</p><ul><li><code>image</code>：可以是灰度图或者彩色图；</li><li>orientations`：就是把180度分成几份，也就是bin的数量；</li><li><code>pixels_per_cell</code>：一个cell里包含的像素个数；</li><li><code>cells_per_block</code>：一个block包含的cell个数；</li><li><code>visualize</code>：是否返回一个hog图像用于显示，下面会显示这张图；</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>为了显示效果，我把cell的尺寸改为(16, 16)，对于每一个cell，画出它归一化后的梯度直方图。如下图所示，我们可以很明显的看出一个人的轮廓。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0b4ca40458e8c8c77b1c790a5f822c79_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"769\" data-rawheight=\"860\" class=\"origin_image zh-lightbox-thumb\" width=\"769\" data-original=\"https://pic2.zhimg.com/v2-0b4ca40458e8c8c77b1c790a5f822c79_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;769&#39; height=&#39;860&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"769\" data-rawheight=\"860\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"769\" data-original=\"https://pic2.zhimg.com/v2-0b4ca40458e8c8c77b1c790a5f822c79_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0b4ca40458e8c8c77b1c790a5f822c79_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>参考：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//shartoo.github.io/HOG-feature/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HOG特征详解</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.learnopencv.com/histogram-of-oriented-gradients/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Histogram of Oriented Gradients</a></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>如果觉得有用，就点个赞吧(ง •̀_•́)ง。</p>", 
            "topic": [
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "计算机视觉", 
                    "tagLink": "https://api.zhihu.com/topics/19590195"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83064609", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 21, 
            "title": "角点检测：Harris 与 Shi-Tomasi", 
            "content": "<p></p><p>目录：</p><ol><li><b>图像特征类型</b></li><li><b>Harris 角点检测器</b></li><li><b>Shi-Tomasi 角点检测器</b></li><li><b>OpenCV 代码实现</b></li><ol><li><b>Harris 角点检测</b></li><li><b>Shi-Tomasi 角点检测</b></li></ol><li><b>参考</b></li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2>一、图像特征类型</h2><p>我们都玩过拼图游戏，将大量混乱的小片段进行正确地排列，形成一个完整的图像。</p><p>玩这个游戏的关键点是什么？就是寻找那些区分度比较高的特征片段，它们更容易用于定位。</p><p>那这些有效特征到底是什么？</p><p>回答这个问题之前，先看一下下面这张图片：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f9eeb6af0d32d77a2f4ad0c9887359d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-f9eeb6af0d32d77a2f4ad0c9887359d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-f9eeb6af0d32d77a2f4ad0c9887359d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f9eeb6af0d32d77a2f4ad0c9887359d5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在图像的顶部，给出了它的六个图像片段。我们试试如何在原始图像中找到这些图像片段的确切位置。 </p><p>如果你亲自试过的话，可以发现：</p><ul><li>A和B处于平坦区域，没有什么确切的特征，它们所在的位置有很多种可能；</li><li>C和D要相对简单一些，它们是建筑物的边缘，我们可以找到一个大致的位置，但是要定位到精确的位置仍然很难。所以边缘是更好的特征，但还不够好。</li><li>E和F是建筑的一些角落，可以很容易地发现它们的位置，因为对于建筑物角落这个图像片段，我们不管朝哪个方向移动，这个片段看起来都会不一样。</li></ul><p>简化一下，就可以得到这张图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bb0946575a969ed75783b452e9c0ed1f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"246\" class=\"content_image\" width=\"311\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;311&#39; height=&#39;246&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"246\" class=\"content_image lazy\" width=\"311\" data-actualsrc=\"https://pic4.zhimg.com/v2-bb0946575a969ed75783b452e9c0ed1f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>蓝色矩形表示一个平坦区域，在各方向移动，窗口内像素值没有变化；</li><li>黑色矩形表示一个边缘特征（Edges），如果沿着垂直方向移动(梯度方向)，像素值会发生改变；如果沿着边缘移动(平行于边缘) ，像素值不会发生变化；</li><li>对于红色矩形框来说，它是一个角（Corners），不管你把它朝哪个方向移动，像素值都会发生很大变化。</li></ul><p>三种情况分别如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4cb0479e245d307e6b2ffe07f38067fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb\" width=\"555\" data-original=\"https://pic2.zhimg.com/v2-4cb0479e245d307e6b2ffe07f38067fd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;555&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"555\" data-original=\"https://pic2.zhimg.com/v2-4cb0479e245d307e6b2ffe07f38067fd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4cb0479e245d307e6b2ffe07f38067fd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图像特征提供了图像丰富的信息。角点特征是图像中较好的特征，比边缘特征更好地用于定位。</p><p>对于拼图游戏，我们已经知道了什么是好的特征，但是下一个问题出现了，如何找到这些角点特征。</p><p>找到这些图像特征的过程被称为<b>特征提取</b>，特征提取决定了最终目标识别效果的好坏。</p><p>在图像的所有区域中，那些在所有方向上做微小移动，像素值变化都很大的区域，就是角点特征所在区域。</p><p>检测角点的应用主要有：图像对齐、图像拼接(拍摄全景图)、目标识别、3D重建、运动跟踪等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、Harris 角点检测器</h2><p>在图像处理中，检测角点特征的算法有很多，这里先介绍最常用的，也是最基础的 Harris 角点检测器(Harris Corner Detection)。</p><p>角点是两条边缘的交点，它表示两条边方向改变的地方，所以<b>角点在任意一个方向上做微小移动，都会引起该区域的梯度图的方向和幅值发生很大变化。</b></p><p>也就是一阶导数(即灰度图的梯度)中的局部最大所对应的像素点就是角点。</p><p>于是我们可以利用这一点来检测角点。</p><p>使一个固定尺寸的窗口在图像上某个位置以任意方向做微小滑动，如果窗口内的灰度值（在梯度图上）都有较大的变化，那么这个窗口所在区域就存在角点。</p><p>这样就可以将 Harris 角点检测算法分为以下三步：</p><ol><li>当窗口（小的图像片段）同时向 x 和 y 两个方向移动时，计算窗口内部的像素值变化量 <img src=\"https://www.zhihu.com/equation?tex=E%28u%2C+v%29\" alt=\"E(u, v)\" eeimg=\"1\"/> ；</li><li>对于每个窗口，都计算其对应的一个角点响应函数 R；</li><li>然后对该函数进行阈值处理，如果 R &gt; threshold，表示该窗口对应一个角点特征。</li></ol><p>接下来对每一步进行详细介绍。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.1、第一步</h3><p>如何确定哪些窗口会引起较大的灰度值变化？</p><p>让一个窗口的中心位于灰度图像的一个位置 <img src=\"https://www.zhihu.com/equation?tex=%28x%2C+y%29\" alt=\"(x, y)\" eeimg=\"1\"/> ，这个位置的像素灰度值为 <img src=\"https://www.zhihu.com/equation?tex=I%28x%2C+y%29\" alt=\"I(x, y)\" eeimg=\"1\"/> ，如果这个窗口分别向 x 和 y 方向移动一个小的位移u和v，到一个新的位置 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Bu%2C+y%2Bv%29\" alt=\"(x+u, y+v)\" eeimg=\"1\"/> ，这个位置的像素灰度值就是 <img src=\"https://www.zhihu.com/equation?tex=I%28x%2Bu%2C+y%2Bv%29\" alt=\"I(x+u, y+v)\" eeimg=\"1\"/> 。</p><p><img src=\"https://www.zhihu.com/equation?tex=%5BI%28x%2Bu%2C+y%2Bv%29+-+I%28x%2C+y%29%5D\" alt=\"[I(x+u, y+v) - I(x, y)]\" eeimg=\"1\"/> 就是窗口移动引起的灰度值的变化值。</p><p>设 <img src=\"https://www.zhihu.com/equation?tex=w%28x%2Cy%29\" alt=\"w(x,y)\" eeimg=\"1\"/> 为位置 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Cy%29\" alt=\"(x,y)\" eeimg=\"1\"/> 处的窗口函数，表示窗口内各像素的权重，最简单的就是把窗口内所有像素的权重都设为1。</p><p>有时也会把 <img src=\"https://www.zhihu.com/equation?tex=w%28x%2Cy%29\" alt=\"w(x,y)\" eeimg=\"1\"/> 设定为以窗口中心为原点的高斯分布（二元正态分布）。如果窗口中心点像素是角点，那么窗口移动前后，中心点的灰度值变化非常强烈，所以该点权重系数应该设大一点，表示该点对灰度变化的贡献较大；而离窗口中心（角点）较远的点，这些点的灰度变化比较小，于是将权重系数设小一点，表示该点对灰度变化的贡献较小。</p><p>则窗口在各个方向上移动 <img src=\"https://www.zhihu.com/equation?tex=%28u%2Cv%29\" alt=\"(u,v)\" eeimg=\"1\"/> 所造成的像素灰度值的变化量公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29+%3D+%5Csum%5Climits_%7B%28x%2Cy%29%7D+w%28x%2Cy%29+%5Ctimes+%5BI%28x%2Bu%2C+y%2Bv%29+-+I%28x%2Cy%29%5D%5E2+%5C%5C\" alt=\"E(u,v) = \\sum\\limits_{(x,y)} w(x,y) \\times [I(x+u, y+v) - I(x,y)]^2 \\\\\" eeimg=\"1\"/> </p><p>对于一个角点来说， <img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29\" alt=\"E(u,v)\" eeimg=\"1\"/> 会非常大。因此，我们可以最大化上面这个函数来得到图像中的角点。</p><p>用上面的函数计算 <img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29\" alt=\"E(u,v)\" eeimg=\"1\"/> 会非常慢。因此，我们使用泰勒展开式（只有一阶）来得到这个公式的近似形式。</p><p>对于二维的泰勒展开式公式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=T%28x%2Cy%29+%5Capprox+f%28u%2Cv%29+%2B+%28x-u%29f_x%28u%2Cv%29+%2B+%28y-v%29f_y%28u%2Cv%29+%2B+...+%5C%5C\" alt=\"T(x,y) \\approx f(u,v) + (x-u)f_x(u,v) + (y-v)f_y(u,v) + ... \\\\\" eeimg=\"1\"/></p><p>将 <img src=\"https://www.zhihu.com/equation?tex=%5Cdisplaystyle+I%28u%2Bx%2Cv%2By%29\" alt=\"\\displaystyle I(u+x,v+y)\" eeimg=\"1\"/> 套用上面的公式，可以得到：</p><p><img src=\"https://www.zhihu.com/equation?tex=I%28x%2Bu%2Cy%2Bv%29+%5Capprox+I%28x%2Cy%29+%2B+uI_x+%2B+vI_y+%5C%5C\" alt=\"I(x+u,y+v) \\approx I(x,y) + uI_x + vI_y \\\\\" eeimg=\"1\"/></p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=I_x\" alt=\"I_x\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=I_y\" alt=\"I_y\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=I\" alt=\"I\" eeimg=\"1\"/> 的偏微分，在图像中就是在 x 和 y 方向的<b>梯度图</b>（可以通过<code>cv2.Sobel()</code>来得到）：</p><p><img src=\"https://www.zhihu.com/equation?tex=I_x+%3D+%5Cfrac+%7B%5Cpartial+I%28x%2Cy%29%7D%7B%5Cpartial+x%7D%2C%5C+%5C+I_y+%3D+%5Cfrac+%7B%5Cpartial+I%28x%2Cy%29%7D%7B%5Cpartial+y%7D+%5C%5C\" alt=\"I_x = \\frac {\\partial I(x,y)}{\\partial x},\\ \\ I_y = \\frac {\\partial I(x,y)}{\\partial y} \\\\\" eeimg=\"1\"/> </p><p>接下来继续推导：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D++E%28u%2Cv%29+%26%3D+%5Csum%5Climits_%7B%28x%2Cy%29%7D+w%28x%2Cy%29+%5Ctimes+%5BI%28x%2Cy%29+%2B+uI_x+%2B+vI_y+-+I%28x%2Cy%29%5D%5E2+%5C%5C+%26%3D+%5Csum%5Climits_%7B%28x%2Cy%29%7D+w%28x%2Cy%29+%5Ctimes+%28uI_x+%2B+vI_y%29%5E2+%5C%5C++%26%3D+%5Csum%5Climits_%7B%28x%2Cy%29%7D+w%28x%2Cy%29+%5Ctimes+%28u%5E2I_x%5E2+%2B+v%5E2I_y%5E2+%2B+2uvI_xI_y%29+%5Cend%7Baligned%7D+%5C%5C\" alt=\"\\begin{aligned}  E(u,v) &amp;= \\sum\\limits_{(x,y)} w(x,y) \\times [I(x,y) + uI_x + vI_y - I(x,y)]^2 \\\\ &amp;= \\sum\\limits_{(x,y)} w(x,y) \\times (uI_x + vI_y)^2 \\\\  &amp;= \\sum\\limits_{(x,y)} w(x,y) \\times (u^2I_x^2 + v^2I_y^2 + 2uvI_xI_y) \\end{aligned} \\\\\" eeimg=\"1\"/></p><p>把 u 和 v 拿出来，得到最终的形式：</p><p><img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29+%5Capprox+%5Cbegin%7Bbmatrix%7D+u%2C+v+%5Cend%7Bbmatrix%7D+M+%5Cbegin%7Bbmatrix%7D+u+%5C%5C+v+%5Cend%7Bbmatrix%7D+%5C%5C\" alt=\"E(u,v) \\approx \\begin{bmatrix} u, v \\end{bmatrix} M \\begin{bmatrix} u \\\\ v \\end{bmatrix} \\\\\" eeimg=\"1\"/> </p><p>其中矩阵M为：</p><p><img src=\"https://www.zhihu.com/equation?tex=M+%3D+%5Csum%5Climits_%7B%28x%2Cy%29%7D+w%28x%2Cy%29++%5Cbegin%7Bbmatrix%7D+I_x%5E2+%26+I_xI_y+%5C%5C+I_xI_y+%26+I_y%5E2+%5Cend%7Bbmatrix%7D++%5Crightarrow+R%5E%7B-1%7D+%5Cbegin%7Bbmatrix%7D+%5Clambda_1+%26+0+%5C%5C+0+%26+%5Clambda_2+%5Cend%7Bbmatrix%7D+R++%5C%5C\" alt=\"M = \\sum\\limits_{(x,y)} w(x,y)  \\begin{bmatrix} I_x^2 &amp; I_xI_y \\\\ I_xI_y &amp; I_y^2 \\end{bmatrix}  \\rightarrow R^{-1} \\begin{bmatrix} \\lambda_1 &amp; 0 \\\\ 0 &amp; \\lambda_2 \\end{bmatrix} R  \\\\\" eeimg=\"1\"/> </p><p>最后是把实对称矩阵对角化处理后的结果，可以把R看成旋转因子，其不影响两个正交方向的变化分量。</p><p>经对角化处理后，将两个正交方向的变化分量提取出来，就是 λ1 和 λ2（特征值）。</p><p>公式推导完了，现在回顾一下：</p><p>对于图像的每一个像素点 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Cy%29\" alt=\"(x,y)\" eeimg=\"1\"/> ，对应一个以该像素为中心的窗口 <img src=\"https://www.zhihu.com/equation?tex=w%28x%2Cy%29\" alt=\"w(x,y)\" eeimg=\"1\"/> ，然后该像素平移 <img src=\"https://www.zhihu.com/equation?tex=%28u%2Cy%29\" alt=\"(u,y)\" eeimg=\"1\"/> 得到新的像素点 <img src=\"https://www.zhihu.com/equation?tex=%28x%2Bu%2C+y%2Bv%29\" alt=\"(x+u, y+v)\" eeimg=\"1\"/> ，而 <img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29\" alt=\"E(u,v)\" eeimg=\"1\"/> 就是<b>窗口中所有像素的加权和乘以不同位置像素的灰度差值</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.2、第二步</h3><p>现在我们已经得到 <img src=\"https://www.zhihu.com/equation?tex=E%28u%2Cv%29\" alt=\"E(u,v)\" eeimg=\"1\"/> 的最终形式，别忘了我们的目的是要找到会引起较大的灰度值变化的那些窗口。</p><p>灰度值变化的大小则取决于矩阵M，那么如何找到这些窗口，我们可以使用矩阵的特征值来实现。</p><p>计算每个窗口对应的得分（角点响应函数R）：</p><p><img src=\"https://www.zhihu.com/equation?tex=R+%3D+%5Ctext+%7Bdet%7D%28M%29+-+k+%28%5Ctext+%7Btrace%28M%29%7D%29%5E2+%5C%5C\" alt=\"R = \\text {det}(M) - k (\\text {trace(M)})^2 \\\\\" eeimg=\"1\"/></p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=%5Ctext+%7Bdet%7D%28M%29+%3D+%5Clambda_1+%5Clambda_2\" alt=\"\\text {det}(M) = \\lambda_1 \\lambda_2\" eeimg=\"1\"/> 是矩阵的行列式， <img src=\"https://www.zhihu.com/equation?tex=%5Ctext+%7Btrace%28M%29%7D+%3D+%5Clambda_1+%2B+%5Clambda_2\" alt=\"\\text {trace(M)} = \\lambda_1 + \\lambda_2\" eeimg=\"1\"/> 是矩阵的迹。</p><p>λ1 和 λ2 是矩阵M的特征值， <img src=\"https://www.zhihu.com/equation?tex=k\" alt=\"k\" eeimg=\"1\"/> 是一个经验常数，在范围 (0.04, 0.06) 之间。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.3、第三步</h3><p>根据 R 的值，将这个窗口所在的区域划分为平面、边缘或角点。为了得到最优的角点，我们还可以使用<b>非极大值抑制</b>。</p><p>注意：Harris 检测器具有旋转不变性，但不具有尺度不变性，也就是说尺度变化可能会导致角点变为边缘，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eeb16e97576beaa149b2db469cd82b64_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"135\" class=\"content_image\" width=\"327\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;327&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"135\" class=\"content_image lazy\" width=\"327\" data-actualsrc=\"https://pic1.zhimg.com/v2-eeb16e97576beaa149b2db469cd82b64_b.jpg\"/></figure><p>（插播一句，想要尺度不变特性的话，可以关注SIFT特征）</p><p>因为特征值 λ1 和 λ2 决定了 R 的值，所以我们可以用特征值来决定一个窗口是平面、边缘还是角点：</p><ul><li><b>平面:</b> 该窗口在平坦区域上滑动，窗口内的灰度值基本不会发生变化，所以 <img src=\"https://www.zhihu.com/equation?tex=%7CR%7C\" alt=\"|R|\" eeimg=\"1\"/> 值非常小，在水平和竖直方向的变化量均较小，即 <img src=\"https://www.zhihu.com/equation?tex=I_x\" alt=\"I_x\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=I_y\" alt=\"I_y\" eeimg=\"1\"/> 都较小，那么 λ1 和 λ2 都较小；</li><li><b>边缘:</b> <img src=\"https://www.zhihu.com/equation?tex=R\" alt=\"R\" eeimg=\"1\"/> 值为负数，仅在水平或竖直方向有较大的变化量，即 <img src=\"https://www.zhihu.com/equation?tex=I_x\" alt=\"I_x\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=I_y\" alt=\"I_y\" eeimg=\"1\"/> 只有一个较大，也就是 λ1&gt;&gt;λ2 或 λ2&gt;&gt;λ1；</li><li><b>角点:</b> <img src=\"https://www.zhihu.com/equation?tex=R\" alt=\"R\" eeimg=\"1\"/> 值很大，在水平、竖直两个方向上变化均较大的点，即 <img src=\"https://www.zhihu.com/equation?tex=I_x\" alt=\"I_x\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=I_y\" alt=\"I_y\" eeimg=\"1\"/> 都较大，也就是 λ1 和 λ2 都很大</li></ul><p>用图片表示如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-95cc2824eac2378cc04bf9282dbec912_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"698\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"698\" data-original=\"https://pic3.zhimg.com/v2-95cc2824eac2378cc04bf9282dbec912_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;698&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"698\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"698\" data-original=\"https://pic3.zhimg.com/v2-95cc2824eac2378cc04bf9282dbec912_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-95cc2824eac2378cc04bf9282dbec912_b.jpg\"/></figure><p>Harris 角点检测的结果是带有这些分数 R 的灰度图像，设定一个阈值，分数大于这个阈值的像素就对应角点。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、Shi-Tomasi 角点检测器</h2><p>知道了什么是 Harris 角点检测，后来有大佬在论文《Good_Features_to_Track》中提出了它的改进版——Shi-Tomasi 角点检测，Shi-Tomasi 方法在很多情况下可以得到比 Harris 算法更好的结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Harris 角点检测中每个窗口的分数公式是将矩阵 M 的行列式与 M 的迹相减：</p><p><img src=\"https://www.zhihu.com/equation?tex=R+%3D+%CE%BB_1%CE%BB_2+%E2%88%92+k+%28%CE%BB_1+%2B+%CE%BB_2%29%5E2+%5C%5C\" alt=\"R = λ_1λ_2 − k (λ_1 + λ_2)^2 \\\\\" eeimg=\"1\"/> </p><p>由于 Harris 角点检测算法的稳定性和 k 值有关，而 k 是个经验值，不好设定最佳值。</p><p>Shi-Tomasi 发现，角点的稳定性其实和矩阵 M 的较小特征值有关，于是直接用较小的那个特征值作为分数。这样就不用调整k值了。</p><p>所以 Shi-Tomasi 将分数公式改为如下形式：</p><p><img src=\"https://www.zhihu.com/equation?tex=R+%3D+min+%28%CE%BB_1%2C+%CE%BB_2%29+%5C%5C\" alt=\"R = min (λ_1, λ_2) \\\\\" eeimg=\"1\"/> </p><p>和 Harris 一样，如果该分数大于设定的阈值，我们就认为它是一个角点。</p><p>我们可以把它绘制到 λ1 ～ λ2 空间中，就会得到下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-56a5bd60f1e79bc8b6f0b652dee589bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-56a5bd60f1e79bc8b6f0b652dee589bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-56a5bd60f1e79bc8b6f0b652dee589bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-56a5bd60f1e79bc8b6f0b652dee589bc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>四、OpenCV 代码实现</h2><h3>4.1 Harris 角点检测</h3><p>在opencv中有提供实现 Harris 角点检测的函数 <a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/dd/d1a/group__imgproc__feature.html%23gac1fc3598018010880e370e2f709b4345\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cv2.cornerHarris</a>，我们直接调用的就可以，非常方便。</p><p>函数原型：<code>cv2.cornerHarris(src, blockSize, ksize, k[, dst[, borderType]])</code></p><p>对于每一个像素 (x,y)，在 (blockSize x blockSize) 邻域内，计算梯度图的协方差矩阵 <img src=\"https://www.zhihu.com/equation?tex=M%28x%2Cy%29\" alt=\"M(x,y)\" eeimg=\"1\"/> ，然后通过上面第二步中的角点响应函数得到结果图。图像中的角点可以为该结果图的局部最大值。</p><p>即可以得到输出图中的局部最大值，这些值就对应图像中的角点。</p><p>涉及到几个参数：</p><ul><li><b>src</b> - 输入灰度图像，float32类型</li><li><b>blockSize</b> - 用于角点检测的邻域大小，就是上面提到的窗口的尺寸</li><li><b>ksize</b> - 用于计算梯度图的Sobel算子的尺寸</li><li><b>k</b> - 用于计算角点响应函数的参数k，取值范围常在0.04~0.06之间</li></ul><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span> <span class=\"kn\">as</span> <span class=\"nn\">cv</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"c1\"># detector parameters</span>\n<span class=\"n\">block_size</span> <span class=\"o\">=</span> <span class=\"mi\">5</span>\n<span class=\"n\">sobel_size</span> <span class=\"o\">=</span> <span class=\"mi\">3</span>\n<span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"mf\">0.04</span>\n\n<span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;bird.jpg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">gray_img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2GRAY</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># modify the data type setting to 32-bit floating point </span>\n<span class=\"n\">gray_img</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">float32</span><span class=\"p\">(</span><span class=\"n\">gray_img</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># detect the corners with appropriate values as input parameters</span>\n<span class=\"n\">corners_img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cornerHarris</span><span class=\"p\">(</span><span class=\"n\">gray_img</span><span class=\"p\">,</span> <span class=\"n\">block_size</span><span class=\"p\">,</span> <span class=\"n\">sobel_size</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># result is dilated for marking the corners, not necessary</span>\n<span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"n\">cv</span><span class=\"o\">.</span><span class=\"n\">dilate</span><span class=\"p\">(</span><span class=\"n\">corners_img</span><span class=\"p\">,</span> <span class=\"bp\">None</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Threshold for an optimal value, marking the corners in Green</span>\n<span class=\"n\">image</span><span class=\"p\">[</span><span class=\"n\">corners_img</span><span class=\"o\">&gt;</span><span class=\"mf\">0.01</span><span class=\"o\">*</span><span class=\"n\">corners_img</span><span class=\"o\">.</span><span class=\"nb\">max</span><span class=\"p\">()]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">]</span>\n\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imwrite</span><span class=\"p\">(</span><span class=\"s1\">&#39;new_bird.jpg&#39;</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">)</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.2、Shi-Tomasi 角点检测</h3><p>OpenCV 提供了 Shi-Tomasi 的函数： <b>cv2.goodFeaturesToTrack()</b>，来获取图像中前 N 个最好的角点。</p><p>函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]])</code></pre></div><p>其中的参数如下：</p><ul><li>image：输入灰度图像，float32类型</li><li>maxCorners：返回角点的最大数目，值为0表表示没有设置最大值限制，返回所有检测到的角点。</li><li>qualityLevel：质量系数（小于1.0的正数，一般在0.01-0.1之间），表示可接受角点的最低质量水平。该系数乘以最好的角点分数（也就是上面较小的那个特征值），作为可接受的最小分数；例如，如果最好的角点分数值为1500且质量系数为0.01，那么所有质量分数小于15的角都将被忽略。</li><li>minDistance：角之间最小欧式距离，忽略小于此距离的点。</li><li>corners：输出角点坐标</li><li>mask：可选的感兴趣区域，指定想要检测角点的区域。</li><li>blockSize：默认为3，角点检测的邻域大小（窗口尺寸）</li><li>useHarrisDetector：用于指定角点检测的方法，如果是true则使用Harris角点检测，false则使用Shi Tomasi算法。默认为False。</li><li>k：默认为0.04，Harris角点检测时使用。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>设定好这些参数，函数就能在图像上找到角点。所有低于质量水平的角点都会被忽略，然后再把合格角点按角点质量进行降序排列。</p><p>然后保留质量最高的一个角点，将它附近（最小距离之内）的角点都删掉（类似于非极大值抑制），按这样的方式最后得到 N 个最佳角点。 </p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n\n<span class=\"n\">maxCorners</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">qualityLevel</span> <span class=\"o\">=</span> <span class=\"mf\">0.01</span>\n<span class=\"n\">minDistance</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;bird.jpg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">gray</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span><span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2GRAY</span><span class=\"p\">)</span>\n<span class=\"n\">corners</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">goodFeaturesToTrack</span><span class=\"p\">(</span><span class=\"n\">gray</span><span class=\"p\">,</span> <span class=\"n\">maxCorners</span><span class=\"p\">,</span> <span class=\"n\">qualityLevel</span><span class=\"p\">,</span> <span class=\"n\">minDistance</span><span class=\"p\">)</span>\n\n<span class=\"n\">corners</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">int0</span><span class=\"p\">(</span><span class=\"n\">corners</span><span class=\"p\">)</span>\n<span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"n\">corners</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">.</span><span class=\"n\">ravel</span><span class=\"p\">()</span>\n    <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">circle</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,(</span><span class=\"n\">x</span><span class=\"p\">,</span><span class=\"n\">y</span><span class=\"p\">),</span><span class=\"mi\">2</span><span class=\"p\">,(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">),</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    \n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imwrite</span><span class=\"p\">(</span><span class=\"s1\">&#39;new_bird.jpg&#39;</span><span class=\"p\">,</span> <span class=\"n\">img</span><span class=\"p\">)</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>最后得到的结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5af148b5fbf60ddde518852892f11451_b.jpg\" data-size=\"normal\" data-rawwidth=\"915\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb\" width=\"915\" data-original=\"https://pic2.zhimg.com/v2-5af148b5fbf60ddde518852892f11451_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;915&#39; height=&#39;409&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"915\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"915\" data-original=\"https://pic2.zhimg.com/v2-5af148b5fbf60ddde518852892f11451_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5af148b5fbf60ddde518852892f11451_b.jpg\"/><figcaption>三张图分别为原图，harris图和Shi-Tomasi图</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Harris 和 Shi-Tomasi 都是基于梯度计算的角点检测方法，Shi-Tomasi 的效果要好一些。基于梯度的检测方法有一些缺点: 计算复杂度高，图像中的噪声可以阻碍梯度计算。</p><p>想要提高检测速度的话，可以考虑基于模板的方法：FAST角点检测算法。该算法原理比较简单，但实时性很强。</p><p>有兴趣的同学可以去了解一下。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考：</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/lwzkiller/article/details/54633670\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/lwzkiller</span><span class=\"invisible\">/article/details/54633670</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://zhuanlan.zhihu.com/p/67770305\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/67</span><span class=\"invisible\">770305</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/dc/d0d/tutorial_py_features_harris.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">docs.opencv.org/master/</span><span class=\"invisible\">dc/d0d/tutorial_py_features_harris.html</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/pixel-wise/detect-those-corners-aba0f034078b\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Harris Corner Detection and Shi-Tomasi Corner Detection</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//aishack.in/tutorials/shitomasi-corner-detector/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Shi-Tomasi Corner Detector</a></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p>", 
            "topic": [
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "OpenCV", 
                    "tagLink": "https://api.zhihu.com/topics/19587715"
                }, 
                {
                    "tag": "计算机视觉", 
                    "tagLink": "https://api.zhihu.com/topics/19590195"
                }
            ], 
            "comments": [
                {
                    "userName": "dwenzhao", 
                    "userLink": "https://www.zhihu.com/people/258356ecbd71849ae54fdc8945d85f53", 
                    "content": "OpenCV有库可以支持啊，自己写代码就有些难度了", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "嗯对，不过还是明白内部原理", 
                            "likes": 0, 
                            "replyToAuthor": "dwenzhao"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "对啊，OpenCV才这么火", 
                            "likes": 0, 
                            "replyToAuthor": "dwenzhao"
                        }
                    ]
                }, 
                {
                    "userName": "雨落窗前", 
                    "userLink": "https://www.zhihu.com/people/569808be3f8964b14cb81d1832c09575", 
                    "content": "我看了很多人写的，你写的是最清楚的[赞]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<a href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"990581356149100544\">[干杯]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "雨落窗前"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71606340", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 9, 
            "title": "霍夫线变换", 
            "content": "<p></p><p>目录：</p><ul><li>一、引入极坐标</li><li>二、霍夫线变换实现原理</li><li>三、图像中的霍夫线变换</li><li>四、概率霍夫变换</li><li>五、Python 例子</li><li>六、参考</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>Hough线变换是一种用于检测直线的变换。它最大的优点是，即使是虚线(dashed line)，或者某些部分缺失、被遮挡的直线，也能检测到完整的线条。</p><h2>一、引入极坐标</h2><p>我们经常在直角坐标系中用两个参数表示直线： <img src=\"https://www.zhihu.com/equation?tex=y+%3D+k+x+%2B+b\" alt=\"y = k x + b\" eeimg=\"1\"/> ，其中 k 为斜率(slope)，b为截距(intercept)。但是当直线趋近于垂直x轴时，k值会变得非常大( <img src=\"https://www.zhihu.com/equation?tex=%2B%5Cinfty\" alt=\"+\\infty\" eeimg=\"1\"/> )或非常小( <img src=\"https://www.zhihu.com/equation?tex=-%5Cinfty\" alt=\"-\\infty\" eeimg=\"1\"/> )以至于无法表示该直线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以对于霍夫线变换，常在极坐标中表示一条直线：</p><p>直线在极坐标系下的表达式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%CF%81+%3D+x+%5Ctext+%7Bcos%7D+%5Ctheta+%2B+y+%5Ctext+%7Bsin%7D+%5Ctheta+%5C%5C\" alt=\"ρ = x \\text {cos} \\theta + y \\text {sin} \\theta \\\\\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3d68878264a388c10ececc29c570b3e0_b.jpg\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"552\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-3d68878264a388c10ececc29c570b3e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;552&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"552\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-3d68878264a388c10ececc29c570b3e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3d68878264a388c10ececc29c570b3e0_b.jpg\"/><figcaption>由该图可以看出直线表达式是如何形成的</figcaption></figure><p>（x, y）为直角坐标系中的一个点A，这个表达式就表示经过点（x, y）的所有直线，每条直线所对应的 <img src=\"https://www.zhihu.com/equation?tex=%5Crho\" alt=\"\\rho\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/> ​ 都不相同。</p><p>这里 <img src=\"https://www.zhihu.com/equation?tex=%5Crho\" alt=\"\\rho\" eeimg=\"1\"/>  表示原点到直线的距离，以像素为单位； <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/>  是这条垂直线和水平轴形成的角度。</p><p>所以图像空间的每一个像素点都对应一个这样的正弦表达式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、霍夫线变换实现原理</h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.1、</b>对于某个点 <img src=\"https://www.zhihu.com/equation?tex=%28x_0%EF%BC%8Cy_0%29\" alt=\"(x_0，y_0)\" eeimg=\"1\"/> ，我们可以将穿过该点的所有直线的集合定义为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Crho+%3D+x_0+%E2%8B%85+cos+%28%5Ctheta%29+%2B+y_0+%E2%8B%85+sin+%28%5Ctheta%29+%5C%5C\" alt=\"\\rho = x_0 ⋅ cos (\\theta) + y_0 ⋅ sin (\\theta) \\\\\" eeimg=\"1\"/> </p><p>这意味着其中的每对 <img src=\"https://www.zhihu.com/equation?tex=%28%5Crho%2C+%5Ctheta%29\" alt=\"(\\rho, \\theta)\" eeimg=\"1\"/> 都表示经过 <img src=\"https://www.zhihu.com/equation?tex=%28x_0%2C+y_0%29\" alt=\"(x_0, y_0)\" eeimg=\"1\"/> 的一条直线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.2、</b>给定一个点 <img src=\"https://www.zhihu.com/equation?tex=x_0%3D8%2C+y_0%3D6\" alt=\"x_0=8, y_0=6\" eeimg=\"1\"/> ，我们会得到过该点的一系列直线，将这些直线对应的参数 <img src=\"https://www.zhihu.com/equation?tex=%28%5Crho%2C+%5Ctheta%29\" alt=\"(\\rho, \\theta)\" eeimg=\"1\"/> 值画在 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 平面中，我们可以得到一条正弦曲线（只考虑 <img src=\"https://www.zhihu.com/equation?tex=%5Crho+%3E+0\" alt=\"\\rho &gt; 0\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=0%3C%CE%B8%3C2%CF%80\" alt=\"0&lt;θ&lt;2π\" eeimg=\"1\"/> 的点。）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cec682952fd320483421e10f929abab2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"203\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"203\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic3.zhimg.com/v2-cec682952fd320483421e10f929abab2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面是经过点（8, 6）的所有直线的极坐标表达式中的 <img src=\"https://www.zhihu.com/equation?tex=%28%5Crho%2C+%5Ctheta%29\" alt=\"(\\rho, \\theta)\" eeimg=\"1\"/> 参数所构成的曲线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3.3、</b>我们可以对其他的点进行相同的操作，按照上面的例子，画出另外两点 <img src=\"https://www.zhihu.com/equation?tex=%28x_1%3D4%2C+y_1%3D9%29\" alt=\"(x_1=4, y_1=9)\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=%28x_2%3D12%2C+y_2%3D3%29\" alt=\"(x_2=12, y_2=3)\" eeimg=\"1\"/>  的曲线图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f2c1b6b0a53c6c8e6d94859a94e73d7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"195\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"195\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-f2c1b6b0a53c6c8e6d94859a94e73d7b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果两个不同点所对应的曲线在平面 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 中相交，就意味着两个点属于同一条直线，因为它们有相同的 <img src=\"https://www.zhihu.com/equation?tex=%28%5Crho%2C+%5Ctheta%29\" alt=\"(\\rho, \\theta)\" eeimg=\"1\"/> 参数。</p><p>如上图所示，这三条曲线相交于点(0.925，9.6)，这是参数 <img src=\"https://www.zhihu.com/equation?tex=%28%5Crho%2C+%5Ctheta%29\" alt=\"(\\rho, \\theta)\" eeimg=\"1\"/> 的值，表示 <img src=\"https://www.zhihu.com/equation?tex=%28x_0%2C+y_0%29\" alt=\"(x_0, y_0)\" eeimg=\"1\"/> 、 <img src=\"https://www.zhihu.com/equation?tex=%28x_1%2C+y_1%29\" alt=\"(x_1, y_1)\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=%28x_2%2C+y_2%29\" alt=\"(x_2, y_2)\" eeimg=\"1\"/> 都在这两个参数值所决定的直线上。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们把 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 平面看做霍夫空间， <img src=\"https://www.zhihu.com/equation?tex=%28%5Ctheta%2C+%5Crho%29\" alt=\"(\\theta, \\rho)\" eeimg=\"1\"/>  就是该空间中的点。而极坐标中的一个点就对应霍夫空间中的一条曲线。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、图像中的霍夫线变换</h2><p>知道了霍夫线变换的实现原理，怎么应用于检测图像中的直线呢？上面提到的点在图像中是对应哪些点呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>进行霍夫线变换之前需要先对图像进行<b>canny边缘检测</b>得到二值图，将这个二值图进行霍夫线变换。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们知道这个二值图除了图像中的边缘像素，其他像素的灰度值都为零，即表现黑色。<b>而我们就是要根据这些非零灰度值的像素点（边缘像素），来获取在 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 平面中的曲线。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>就是根据每个边缘像素(x，y)，我们将 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/> 的值从0更改为 <img src=\"https://www.zhihu.com/equation?tex=2%5Cpi\" alt=\"2\\pi\" eeimg=\"1\"/> ，根据公式 <img src=\"https://www.zhihu.com/equation?tex=%5Crho+%3D+x_0+%E2%8B%85+cos+%28%5Ctheta%29+%2B+y_0+%E2%8B%85+sin+%28%5Ctheta%29\" alt=\"\\rho = x_0 ⋅ cos (\\theta) + y_0 ⋅ sin (\\theta)\" eeimg=\"1\"/> ，获得对应的 <img src=\"https://www.zhihu.com/equation?tex=%5Crho\" alt=\"\\rho\" eeimg=\"1\"/> 值。从而获取所有边缘像素在 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 平面的曲线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>得到每个边缘像素的曲线后，通过计算 <img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+-+%5Crho\" alt=\"\\theta - \\rho\" eeimg=\"1\"/> 平面中各交点所在的曲线数量来检测直线。某点相交的曲线越多，意味着该交点所表示的直线具有越多的点，即在图像中直线越长。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们还可以定义阈值，在某点相交的曲线数量大于该阈值，才认为该点在图像中对应一条直线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以要理解霍夫变换最关键的一点就是：</p><p><b>极坐标的点（ </b><img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/><b>-</b><img src=\"https://www.zhihu.com/equation?tex=y\" alt=\"y\" eeimg=\"1\"/><b> 平面） &lt;=&gt; 直角坐标系中的曲线（</b><img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/><b>-</b><img src=\"https://www.zhihu.com/equation?tex=%5Crho\" alt=\"\\rho\" eeimg=\"1\"/><b> 平面）</b></p><p><b>即在图像中一个边缘像素点，经过霍夫变换，变成霍夫空间（<img src=\"https://www.zhihu.com/equation?tex=%5Ctheta\" alt=\"\\theta\" eeimg=\"1\"/>-<img src=\"https://www.zhihu.com/equation?tex=%5Crho\" alt=\"\\rho\" eeimg=\"1\"/> 平面）中的一条正弦曲线。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>四、概率霍夫变换</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>上面介绍的标准霍夫变换，其本质上就是把图像中的边缘像素映射到它的霍夫空间，比如一共有M个边缘像素，则所有的边缘像素都需要进行映射，其运算量和所需内存都会很大。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果只处理图像的m（m&lt;M）个边缘像素点，则这m个边缘像素点的选取是具有一定概率的，因此该方法就是概率霍夫变换。该方法有一个重要的特点就是能够检测出线段，即能够检测出图像中直线的两个端点，从而定位图像中的直线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是概率霍夫变换的简易步骤：</p><ol><li>随机抽取图像中的一个边缘像素点，如果已经被标定为是某一条直线上的点，则继续在剩下的边缘点中随机抽取一个边缘点，直到所有边缘点都抽取完为止；</li><li>对该点进行霍夫变换，并进行累加计算；</li><li>选取在霍夫空间内累加值最大的点，如果该点的值大于阈值，则进行步骤4，否则回到步骤1；</li><li>对于累加值大于阈值的点，从该点出发，沿着图像中的直线的方向位移，从而找到直线的两个端点；</li><li>计算直线的长度，如果大于某个阈值，则被认为是直线并输出。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>五、Python 例子</h2><p>OpenCV 中有霍夫线变换的API，我们直接调用即可。</p><p>原图为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c24700df8cf41ef4b4be0c65e19a478b_b.jpg\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"168\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"168\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-c24700df8cf41ef4b4be0c65e19a478b_b.jpg\"/><figcaption>白底黑线</figcaption></figure><p>我这里用的概率霍夫线变换函数：</p><div class=\"highlight\"><pre><code class=\"language-text\">HoughLinesP(image, rho, theta, threshold)</code></pre></div><ul><li>image：二值图（边缘检测器的输出）；</li><li>rho：距离分辨率，以像素为单位；</li><li>theta：角度分辨率，单位为弧度；</li><li>threshold：交点的最小曲线数量大于阈值，才被视为一条直线。</li><li>maxLineGap：这是一个可选参数，表示两个线段之间的gap小于该值，则进行连接</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">&#34;/home/zxd/Pictures/lines.jpg&#34;</span><span class=\"p\">)</span>\n\n<span class=\"n\">gray</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2GRAY</span><span class=\"p\">)</span>\n<span class=\"c1\"># detecting the edges</span>\n<span class=\"n\">edges</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">Canny</span><span class=\"p\">(</span><span class=\"n\">gray</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"p\">,</span> <span class=\"mi\">200</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># apply probabilistic hough transform for line detection</span>\n<span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">HoughLinesP</span><span class=\"p\">(</span><span class=\"n\">edges</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"mi\">180</span><span class=\"p\">,</span> <span class=\"mi\">30</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># maxLineGap 参数的值为200，则线之间的gap小于200像素就将其进行连接</span>\n<span class=\"n\">lines</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">HoughLinesP</span><span class=\"p\">(</span><span class=\"n\">edges</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">/</span><span class=\"mi\">180</span><span class=\"p\">,</span> <span class=\"n\">threshold</span><span class=\"o\">=</span><span class=\"mi\">30</span><span class=\"p\">,</span> <span class=\"n\">maxLineGap</span><span class=\"o\">=</span><span class=\"mi\">200</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># 得到所有线段的端点</span>\n<span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">lines</span><span class=\"p\">:</span>\n    <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">y1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"n\">y2</span> <span class=\"o\">=</span> <span class=\"n\">line</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n    <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">line</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">y1</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"n\">y2</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">))</span>\n\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;img&#39;</span><span class=\"p\">,</span> <span class=\"n\">img</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">waitKey</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"s1\">&#39;q&#39;</span><span class=\"p\">):</span>\n    <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">destroyAllWindows</span><span class=\"p\">()</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是输出的结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-38f814ef61c16900784bd76c185901c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"184\" class=\"origin_image zh-lightbox-thumb\" width=\"722\" data-original=\"https://pic1.zhimg.com/v2-38f814ef61c16900784bd76c185901c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;722&#39; height=&#39;184&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"184\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"722\" data-original=\"https://pic1.zhimg.com/v2-38f814ef61c16900784bd76c185901c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-38f814ef61c16900784bd76c185901c0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>两者分别为不使用 <code>maxLineGap</code> 参数和使用 <code>maxLineGap</code> 参数的结果图。</p><p>所以即使遇到虚线或者被遮挡的直线，我们也可以使用霍夫线变换来进行直线检测。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>六、参考</h2><p><a href=\"https://zhuanlan.zhihu.com/p/60190848\" class=\"internal\">基于霍夫变换的车道线检测</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/d9/db0/tutorial_hough_lines.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方教程：tutorial hough lines</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/d6/d10/tutorial_py_houghlines.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方教程：tutorial py houghlines</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.learnopencv.com/hough-transform-with-opencv-c-python/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hough Transform with OpenCV</a></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p><p></p>", 
            "topic": [
                {
                    "tag": "OpenCV", 
                    "tagLink": "https://api.zhihu.com/topics/19587715"
                }, 
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67930839", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 40, 
            "title": "RGB、HSV和HSL颜色空间", 
            "content": "<p>目录：</p><ul><li><b> RGB 的局限性</b></li><li><b> HSV 颜色空间</b></li><li><b> HSL 颜色空间</b></li><li><b> HSV 应用例子</b></li><li><b>使用 HSV 图像分割</b></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>RGB 的局限性</h2><p>RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间，比较容易理解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB 颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以，RGB 颜色空间适合于显示系统，却并不适合于图像处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>HSV 颜色空间</h2><p>基于上述理由，在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在 HSV 颜色空间下，比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>HSV 表达彩色图像的方式由三个部分组成：</p><ul><li>Hue（色调、色相）</li><li>Saturation（饱和度、色彩纯净度）</li><li>Value（明度）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>用下面这个圆柱体来表示 HSV 颜色空间，圆柱体的横截面可以看做是一个极坐标系 ，H 用极坐标的极角表示，S 用极坐标的极轴长度表示，V 用圆柱中轴的高度表示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e9f9c843e7d60e8f7aa7de1cd61d1818_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"622\" data-original=\"https://pic1.zhimg.com/v2-e9f9c843e7d60e8f7aa7de1cd61d1818_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;622&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"622\" data-original=\"https://pic1.zhimg.com/v2-e9f9c843e7d60e8f7aa7de1cd61d1818_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e9f9c843e7d60e8f7aa7de1cd61d1818_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Hue 用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置。，表示如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c3c66594da5d4f86de8ed2d2abfdbba1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-c3c66594da5d4f86de8ed2d2abfdbba1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic2.zhimg.com/v2-c3c66594da5d4f86de8ed2d2abfdbba1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c3c66594da5d4f86de8ed2d2abfdbba1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>颜色圆环上所有的颜色都是光谱上的颜色，从红色开始按逆时针方向旋转，Hue=0 表示红色，Hue=120 表示绿色，Hue=240 表示蓝色等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在 GRB中 颜色由三个值共同决定，比如黄色为即 (255,255,0)；在HSV中，黄色只由一个值决定，Hue=60即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>HSV 圆柱体的半边横截面（Hue=60）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-687808eb32ee353fad6663665b09b247_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-687808eb32ee353fad6663665b09b247_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-687808eb32ee353fad6663665b09b247_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-687808eb32ee353fad6663665b09b247_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其中水平方向表示饱和度，饱和度表示颜色接近光谱色的程度。饱和度越高，说明颜色越深，越接近光谱色饱和度越低，说明颜色越浅，越接近白色。饱和度为0表示纯白色。取值范围为0～100%，值越大，颜色越饱和。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>竖直方向表示明度，决定颜色空间中颜色的明暗程度，明度越高，表示颜色越明亮，范围是 0-100%。明度为0表示纯黑色（此时颜色最暗）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以通俗理解为：</p><p>在Hue一定的情况下，饱和度减小，就是往光谱色中添加白色，光谱色所占的比例也在减小，饱和度减为0，表示光谱色所占的比例为零，导致整个颜色呈现白色。</p><p>明度减小，就是往光谱色中添加黑色，光谱色所占的比例也在减小，明度减为0，表示光谱色所占的比例为零，导致整个颜色呈现黑色。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>HSV 对用户来说是一种比较直观的颜色模型。我们可以很轻松地得到单一颜色，即指定颜色角H，并让V=S=1，然后通过向其中加入黑色和白色来得到我们需要的颜色。增加黑色可以减小V而S不变，同样增加白色可以减小S而V不变。例如，要得到深蓝色，V=0.4 S=1 H=240度。要得到浅蓝色，V=1 S=0.4 H=240度。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>HSV 的拉伸对比度增强就是对 S 和 V 两个分量进行归一化(min-max normalize)即可，H 保持不变。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>RGB颜色空间更加面向于工业，而HSV更加面向于用户，大多数做图像识别这一块的都会运用HSV颜色空间，因为HSV颜色空间表达起来更加直观！</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>HLS 颜色空间</h2><p>HLS 和 HSV 比较类似，这里一起介绍。HLS 也有三个分量，hue（色相）、saturation（饱和度）、lightness（亮度）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>HLS 和 HSV 的区别就是最后一个分量不同，HLS 的是 light(亮度)，HSV 的是 value(明度)。可以到这个 <a href=\"https://link.zhihu.com/?target=https%3A//www.w3schools.com/colors/colors_hsl.asp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">网页</a> 尝试一下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>HLS 中的 L 分量为亮度，亮度为100，表示白色，亮度为0，表示黑色；HSV 中的 V 分量为明度，明度为100，表示光谱色，明度为0，表示黑色。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是 HLS 颜色空间圆柱体：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f9c6aba3a4712f13bc60f19309d4a2e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic3.zhimg.com/v2-f9c6aba3a4712f13bc60f19309d4a2e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic3.zhimg.com/v2-f9c6aba3a4712f13bc60f19309d4a2e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f9c6aba3a4712f13bc60f19309d4a2e6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>提取白色物体时，使用 HLS 更方便，因为 HSV 中的Hue里没有白色，白色需要由S和V共同决定（S=0, V=100）。而在 HLS 中，白色仅由亮度L一个分量决定。所以检测白色时使用 HSL 颜色空间更准确。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>将上面这个 HLS 颜色空间图用来测试：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s2\">&#34;hls.jpg&#34;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert BGR to HLS</span>\n<span class=\"n\">imgHLS</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2HLS</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># range of white color in L channel</span>\n<span class=\"c1\"># mask = cv2.inRange(imgHLS[:,:,1], lowerb=250, upperb=255)</span>\n<span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">imgHLS</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">250</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">]))</span>\n\n<span class=\"c1\"># Apply Mask to original image</span>\n<span class=\"n\">white_mask</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">bitwise_and</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">mask</span><span class=\"p\">)</span></code></pre></div><figure data-size=\"small\"><noscript><img src=\"https://pic1.zhimg.com/v2-aa2cae239132437304852b13be156310_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1587\" data-rawheight=\"1187\" class=\"origin_image zh-lightbox-thumb\" width=\"1587\" data-original=\"https://pic1.zhimg.com/v2-aa2cae239132437304852b13be156310_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1587&#39; height=&#39;1187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1587\" data-rawheight=\"1187\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1587\" data-original=\"https://pic1.zhimg.com/v2-aa2cae239132437304852b13be156310_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-aa2cae239132437304852b13be156310_b.jpg\"/></figure><p>注意：在 OpenCV 中 HLS 三个分量的范围为：</p><ul><li>H = [0,179]</li><li>L = [0,255]</li><li>S = [0,255]</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>HSV 应用例子</h2><p>注意：在 OpenCV 中 HSV 三个分量的范围为：</p><ul><li>H = [0,179]</li><li>S = [0,255]</li><li>V = [0,255]</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>获取要跟踪物体颜色的HSV值：</b></p><p>对一个BGR值进行颜色空间转换，得到HSV值。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">blue</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">([[[</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">]]])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">hsv_blue</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">blue</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2HSV</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">hsv_blue</span><span class=\"p\">)</span>\n<span class=\"p\">[[[</span><span class=\"mi\">120</span> <span class=\"mi\">255</span> <span class=\"mi\">255</span><span class=\"p\">]]]</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>为了识别特定颜色的物体，获取到颜色所对应的HSV值很重要，这里说一下获取步骤：</p><p>1、<u><a href=\"https://link.zhihu.com/?target=http%3A//www.jiniannet.com/Page/allcolor\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在线取色器</a></u> 或 <u><a href=\"https://link.zhihu.com/?target=https%3A//www.sojson.com/web/img.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">传图识色</a></u>，可以在这里上传特定颜色的图片，获取这些颜色对应的RGB值。</p><p>2、假设获取到的是这样的数据：<code>#869C90,#899F92,#8A9E92,#8A9F8E</code>，下面将其进行转换得到HSV各通道的数值范围：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">rgb</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#869C90,#899F92,#8A9E92,#8A9F8E&#39;</span>\n\n<span class=\"n\">rgb</span> <span class=\"o\">=</span> <span class=\"n\">rgb</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;,&#39;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># 转换为BGR格式，并将16进制转换为10进制</span>\n<span class=\"n\">bgr</span> <span class=\"o\">=</span> <span class=\"p\">[[</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">:</span><span class=\"mi\">7</span><span class=\"p\">],</span> <span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">:</span><span class=\"mi\">5</span><span class=\"p\">],</span> <span class=\"mi\">16</span><span class=\"p\">),</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">r</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">:</span><span class=\"mi\">3</span><span class=\"p\">],</span> <span class=\"mi\">16</span><span class=\"p\">)]</span> <span class=\"k\">for</span> <span class=\"n\">r</span> <span class=\"ow\">in</span> <span class=\"n\">rgb</span><span class=\"p\">]</span>\n\n<span class=\"c1\"># 转换为HSV格式</span>\n<span class=\"n\">hsv</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">([[</span><span class=\"n\">b</span><span class=\"p\">]]),</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2HSV</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"k\">for</span> <span class=\"n\">b</span> <span class=\"ow\">in</span> <span class=\"n\">bgr</span><span class=\"p\">]</span>\n\n<span class=\"n\">hsv</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">)</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;H:&#39;</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">]),</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">]))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;S:&#39;</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">1</span><span class=\"p\">]))</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;V:&#39;</span><span class=\"p\">,</span> <span class=\"nb\">min</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">2</span><span class=\"p\">]),</span> <span class=\"nb\">max</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,</span> <span class=\"mi\">2</span><span class=\"p\">]))</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>然后对其中的Hue值进行加10和减10（这里的10也可以为其他值，视具体情况而定），得到Hue的范围，还要指定S和V的范围：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ff7ffd6cbef470998cafe9ba68e65efb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-ff7ffd6cbef470998cafe9ba68e65efb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;520&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-ff7ffd6cbef470998cafe9ba68e65efb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ff7ffd6cbef470998cafe9ba68e65efb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最后整个HSV值的上限和下限为 [hue+10，100，100]和 [hue-10，255，255]，S和V的下限值可以根据实际情况设置。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为H=0和H=180都对应红色，所以对于红色的话，需要定义两个范围，并进行取或操作。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"n\">sensitivity</span> <span class=\"o\">=</span> <span class=\"mi\">10</span>\n<span class=\"n\">lower_red_0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">])</span> \n<span class=\"n\">upper_red_0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">])</span>\n<span class=\"n\">lower_red_1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">180</span><span class=\"o\">-</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">])</span> \n<span class=\"n\">upper_red_1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">180</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">])</span>\n\n<span class=\"n\">mask_0</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">,</span> <span class=\"n\">lower_red_0</span><span class=\"p\">,</span> <span class=\"n\">upper_red_0</span><span class=\"p\">)</span>\n<span class=\"n\">mask_1</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">,</span> <span class=\"n\">lower_red_1</span><span class=\"p\">,</span> <span class=\"n\">upper_red_1</span><span class=\"p\">)</span>\n\n<span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">bitwise_or</span><span class=\"p\">(</span><span class=\"n\">mask_0</span><span class=\"p\">,</span> <span class=\"n\">mask_1</span><span class=\"p\">)</span></code></pre></div><p>使用 cv2:inRange() 作为基于颜色的阈值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后就可以使用该 HSV 值范围进行目标物体的提取。</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;compass.jpg&#34;</span>\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Convert BGR to HSV</span>\n<span class=\"n\">hsv</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2HSV</span><span class=\"p\">)</span>\n\n<span class=\"n\">sensitivity</span> <span class=\"o\">=</span> <span class=\"mi\">15</span>\n\n<span class=\"c1\"># define range of blue color in HSV</span>\n<span class=\"n\">lower_blue</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">120</span><span class=\"o\">-</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">])</span>\n<span class=\"n\">upper_blue</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">120</span><span class=\"o\">+</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">])</span>\n<span class=\"c1\"># Threshold the HSV image to get a range of blue color</span>\n<span class=\"n\">mask_blue</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">,</span> <span class=\"n\">lower_blue</span><span class=\"p\">,</span> <span class=\"n\">upper_blue</span><span class=\"p\">)</span>\n\n<span class=\"n\">kernel</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">getStructuringElement</span><span class=\"p\">(</span><span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_RECT</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">,</span><span class=\"mi\">5</span><span class=\"p\">))</span>\n<span class=\"n\">mask_blue</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">morphologyEx</span><span class=\"p\">(</span><span class=\"n\">mask_blue</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_CLOSE</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">)</span>  <span class=\"c1\"># 闭运算</span>\n<span class=\"n\">mask_blue</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">morphologyEx</span><span class=\"p\">(</span><span class=\"n\">mask_blue</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_OPEN</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">)</span>   <span class=\"c1\"># 开运算</span>\n \n<span class=\"c1\"># define range of red color in HSV</span>\n<span class=\"n\">lower_red_0</span><span class=\"p\">,</span> <span class=\"n\">upper_red_0</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">]),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">])</span>\n<span class=\"n\">lower_red_1</span><span class=\"p\">,</span> <span class=\"n\">upper_red_1</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">180</span><span class=\"o\">-</span><span class=\"n\">sensitivity</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">,</span><span class=\"mi\">100</span><span class=\"p\">]),</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">180</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">])</span>\n<span class=\"c1\"># Threshold the HSV image to get a range of red color</span>\n<span class=\"n\">mask_0</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">,</span> <span class=\"n\">lower_red_0</span><span class=\"p\">,</span> <span class=\"n\">upper_red_0</span><span class=\"p\">)</span>\n<span class=\"n\">mask_1</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">inRange</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">,</span> <span class=\"n\">lower_red_1</span><span class=\"p\">,</span> <span class=\"n\">upper_red_1</span><span class=\"p\">)</span>\n<span class=\"n\">mask_red</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">bitwise_or</span><span class=\"p\">(</span><span class=\"n\">mask_0</span><span class=\"p\">,</span> <span class=\"n\">mask_1</span><span class=\"p\">)</span>\n\n<span class=\"n\">mask_red</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">morphologyEx</span><span class=\"p\">(</span><span class=\"n\">mask_red</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_CLOSE</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">)</span>\n<span class=\"n\">mask_red</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">morphologyEx</span><span class=\"p\">(</span><span class=\"n\">mask_red</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_OPEN</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">)</span>\n\n\n<span class=\"c1\"># 合并蓝色mask和红色mask</span>\n<span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">bitwise_or</span><span class=\"p\">(</span><span class=\"n\">mask_blue</span><span class=\"p\">,</span> <span class=\"n\">mask_red</span><span class=\"p\">)</span>\n<span class=\"c1\"># Bitwise-AND mask</span>\n<span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">bitwise_and</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"n\">mask</span><span class=\"p\">)</span>\n\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;image&#39;</span><span class=\"p\">,</span><span class=\"n\">img</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;mask_blue&#39;</span><span class=\"p\">,</span><span class=\"n\">mask_blue</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;mask_red&#39;</span><span class=\"p\">,</span><span class=\"n\">mask_red</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;res&#39;</span><span class=\"p\">,</span><span class=\"n\">res</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">waitKey</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">==</span><span class=\"nb\">ord</span><span class=\"p\">(</span><span class=\"s1\">&#39;q&#39;</span><span class=\"p\">):</span>\n    <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">destroyAllWindows</span><span class=\"p\">()</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>下面分别原图，蓝色掩码，红色掩码，以及蓝色和红色区域。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-257a317b18578ca8e06244e126296947_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb\" width=\"779\" data-original=\"https://pic4.zhimg.com/v2-257a317b18578ca8e06244e126296947_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;779&#39; height=&#39;632&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"779\" data-original=\"https://pic4.zhimg.com/v2-257a317b18578ca8e06244e126296947_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-257a317b18578ca8e06244e126296947_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用 HSV 图像分割</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>有时候也可以利用颜色空间进行图像分割，如果图像的颜色特征比强度特征更好，则可以尝试将其转换为HSV，然后在H通道上进行自适应二值化处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>原图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f642313514806a56d07ba496f098b973_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"158\" class=\"content_image\" width=\"280\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;280&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"158\" class=\"content_image lazy\" width=\"280\" data-actualsrc=\"https://pic4.zhimg.com/v2-f642313514806a56d07ba496f098b973_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是相关源码：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">image</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"n\">img_path</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;img&#39;</span><span class=\"p\">,</span> <span class=\"n\">image</span><span class=\"p\">)</span>\n<span class=\"n\">hsv</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">image</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2HSV</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;hsv&#39;</span><span class=\"p\">,</span> <span class=\"n\">hsv</span><span class=\"p\">[:,:,</span><span class=\"mi\">0</span><span class=\"p\">])</span>\n<span class=\"p\">(</span><span class=\"n\">thresh</span><span class=\"p\">,</span> <span class=\"n\">im_bw</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">threshold</span><span class=\"p\">(</span><span class=\"n\">hsv</span><span class=\"p\">[:,:,</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">THRESH_BINARY</span> <span class=\"o\">|</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">THRESH_OTSU</span><span class=\"p\">)</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imshow</span><span class=\"p\">(</span><span class=\"s1\">&#39;otsu&#39;</span><span class=\"p\">,</span> <span class=\"n\">im_bw</span><span class=\"p\">)</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>对该风景图进行阈值切割后的结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2103b84f679f52a68264aa24937dc6a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"682\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb\" width=\"682\" data-original=\"https://pic1.zhimg.com/v2-2103b84f679f52a68264aa24937dc6a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;682&#39; height=&#39;183&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"682\" data-rawheight=\"183\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"682\" data-original=\"https://pic1.zhimg.com/v2-2103b84f679f52a68264aa24937dc6a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2103b84f679f52a68264aa24937dc6a4_b.jpg\"/></figure><p>左图为H通道的图，右图为我们进行二值化后的图。可以发现我们通过这种方法将图像中的主要三个颜色部分很好地分割开来。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而我们采用对灰度图进行阈值切割的结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-30983f542d7957db4fbc0d622a8faea4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"191\" class=\"origin_image zh-lightbox-thumb\" width=\"675\" data-original=\"https://pic1.zhimg.com/v2-30983f542d7957db4fbc0d622a8faea4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;675&#39; height=&#39;191&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"191\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"675\" data-original=\"https://pic1.zhimg.com/v2-30983f542d7957db4fbc0d622a8faea4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-30983f542d7957db4fbc0d622a8faea4_b.jpg\"/></figure><p>左图为灰度图，右图为我们进行二值化后的图。</p><p>因为图像中的天空是渐变的，所以不管用什么阈值，都会把天空给分成两部分，显然没有转换颜色通道的效果好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.rapidtables.com/web/color/RGB_Color.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RGB Color Codes Chart</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/df/d9d/tutorial_py_colorspaces.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Changing Colorspaces</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/bjbz_cxy/article/details/79701006\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RGB颜色空间和HSV颜色空间详解</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/12943410/opencv-python-single-rather-than-multiple-blob-tracking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenCV Python single blob tracking?</a></p><p><u><a href=\"https://link.zhihu.com/?target=https%3A//realpython.com/python-opencv-color-spaces/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Image Segmentation Using Color Spaces</a></u></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }, 
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "OpenCV", 
                    "tagLink": "https://api.zhihu.com/topics/19587715"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67741538", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 27, 
            "title": "分水岭算法", 
            "content": "<p>分水岭（Watershed）是基于地理形态的分析的图像分割算法，模仿地理结构（比如山川、沟壑，盆地）来实现对不同物体的分类。</p><p>分水岭算法中会用到一个重要的概念——测地线距离。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>测地线距离(Geodesic Distance)</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>测地线距离就是地球表面两点之间的最短路径（可执行路径）的距离，在图论中，Geodesic Distance 就是图中两节点的最短路径的距离，这与平时在几何空间通常用到的 Euclidean Distance（欧氏距离），即两点之间的最短距离有所区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在下图中，两个黑点的 Euclidean Distance 是用虚线所表示的线段的长度 <img src=\"https://www.zhihu.com/equation?tex=d_%7B15%7D\" alt=\"d_{15}\" eeimg=\"1\"/> ，而 Geodesic Distance 作为实际路径的最短距离，其距离应为沿途实线段距离之和的最小值，即 <img src=\"https://www.zhihu.com/equation?tex=d_%7B12%7D%2Bd_%7B23%7D%2Bd_%7B34%7D%2Bd_%7B45%7D\" alt=\"d_{12}+d_{23}+d_{34}+d_{45}\" eeimg=\"1\"/> 。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cd08e58ad43887cd89384ce40160bc55_b.jpg\" data-rawwidth=\"289\" data-rawheight=\"275\" data-size=\"normal\" class=\"content_image\" width=\"289\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;289&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"289\" data-rawheight=\"275\" data-size=\"normal\" class=\"content_image lazy\" width=\"289\" data-actualsrc=\"https://pic2.zhimg.com/v2-cd08e58ad43887cd89384ce40160bc55_b.jpg\"/><figcaption>图1</figcaption></figure><p>在三维曲面空间中两点间的测地距离就是两点间沿着三维曲面的表面走的最短路径。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>分水岭算法</h2><p>图像的灰度空间很像地球表面的整个地理结构，每个像素的灰度值代表高度。其中的灰度值较大的像素连成的线可以看做山脊，也就是分水岭。其中的水就是用于二值化的gray threshold level，二值化阈值可以理解为水平面，比水平面低的区域会被淹没，刚开始用水填充每个孤立的山谷(局部最小值)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当水平面上升到一定高度时，水就会溢出当前山谷，可以通过在分水岭上修大坝，从而避免两个山谷的水汇集，这样图像就被分成2个像素集，一个是被水淹没的山谷像素集，一个是分水岭线像素集。最终这些大坝形成的线就对整个图像进行了分区，实现对图像的分割。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ea8ce5a64e744c8c56c492b03a039265_b.jpg\" data-rawwidth=\"321\" data-rawheight=\"380\" data-size=\"normal\" class=\"content_image\" width=\"321\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;321&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"321\" data-rawheight=\"380\" data-size=\"normal\" class=\"content_image lazy\" width=\"321\" data-actualsrc=\"https://pic2.zhimg.com/v2-ea8ce5a64e744c8c56c492b03a039265_b.jpg\"/><figcaption>图2</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在该算法中，空间上相邻并且灰度值相近的像素被划分为一个区域。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>分水岭算法的整个过程：</p><ol><li>把梯度图像中的所有像素按照灰度值进行分类，并设定一个测地距离阈值。<br/> </li><li>找到灰度值最小的像素点（默认标记为灰度值最低点），让threshold从最小值开始增长，这些点为起始点。<br/> </li><li>水平面在增长的过程中，会碰到周围的邻域像素，测量这些像素到起始点（灰度值最低点）的测地距离，如果小于设定阈值，则将这些像素淹没，否则在这些像素上设置大坝，这样就对这些邻域像素进行了分类。</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c6991b0530dfb7ce0bd50686f40c13dd_b.jpg\" data-rawwidth=\"508\" data-rawheight=\"251\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"508\" data-original=\"https://pic2.zhimg.com/v2-c6991b0530dfb7ce0bd50686f40c13dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;508&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"508\" data-rawheight=\"251\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"508\" data-original=\"https://pic2.zhimg.com/v2-c6991b0530dfb7ce0bd50686f40c13dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c6991b0530dfb7ce0bd50686f40c13dd_b.jpg\"/><figcaption>图3</figcaption></figure><p> 4. 随着水平面越来越高，会设置更多更高的大坝，直到灰度值的最大值，所有区域都在分水岭线上相遇，这些大坝就对整个图像像素的进行了分区。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>整个过程可以查看下面这个动图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ee051f2fc107d248d52a2c6c63fc0e62_b.gif\" data-rawwidth=\"256\" data-rawheight=\"256\" data-size=\"normal\" data-thumbnail=\"https://pic3.zhimg.com/v2-ee051f2fc107d248d52a2c6c63fc0e62_b.jpg\" class=\"content_image\" width=\"256\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;256&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"256\" data-rawheight=\"256\" data-size=\"normal\" data-thumbnail=\"https://pic3.zhimg.com/v2-ee051f2fc107d248d52a2c6c63fc0e62_b.jpg\" class=\"content_image lazy\" width=\"256\" data-actualsrc=\"https://pic3.zhimg.com/v2-ee051f2fc107d248d52a2c6c63fc0e62_b.gif\"/><figcaption>图4</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>用上面的算法对图像进行分水岭运算，由于噪声点或其它因素的干扰，可能会得到密密麻麻的小区域，即图像被分得太细（over-segmented，过度分割），这因为图像中有非常多的局部极小值点，每个点都会自成一个小区域。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其中的解决方法：</p><ol><li>对图像进行高斯平滑操作，抹除很多小的最小值，这些小分区就会合并。</li><li>不从最小值开始增长，可以将相对较高的灰度值像素作为起始点（需要用户手动标记），从标记处开始进行淹没，则很多小区域都会被合并为一个区域，这被称为<b>基于图像标记(mark)的分水岭算法</b>。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>下面三个图分别是原图，分水岭过分割的图以及基于标记的分水岭算法得到的图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-beaec1d85c45ed79e44c2c70a59f8644_b.jpg\" data-rawwidth=\"1200\" data-rawheight=\"300\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-beaec1d85c45ed79e44c2c70a59f8644_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1200\" data-rawheight=\"300\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic1.zhimg.com/v2-beaec1d85c45ed79e44c2c70a59f8644_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-beaec1d85c45ed79e44c2c70a59f8644_b.jpg\"/><figcaption>图5</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其中标记的每个点就相当于分水岭中的注水点，从这些点开始注水使得水平面上升，但是如上图所示，图像中需要分割的区域太多了，手动标记太麻烦，我们可是使用距离转换的方法进行标记，OpenCV中就是使用的这种方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>OpenCV中分水岭算法</b></h2><p>在OpenCV中，我们需要给不同区域贴上不同的标签。用大于1的整数表示我们确定为前景或对象的区域，用1表示我们确定为背景或非对象的区域，最后用0表示我们无法确定的区域。然后应用分水岭算法，我们的标记图像将被更新，更新后的标记图像的边界像素值为-1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面对相互接触的硬币应用距离变换和分水岭分割。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ec78ca34aa805128f831fdbf1d861ba9_b.jpg\" data-rawwidth=\"252\" data-rawheight=\"312\" data-size=\"normal\" class=\"content_image\" width=\"252\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;252&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"252\" data-rawheight=\"312\" data-size=\"normal\" class=\"content_image lazy\" width=\"252\" data-actualsrc=\"https://pic2.zhimg.com/v2-ec78ca34aa805128f831fdbf1d861ba9_b.jpg\"/><figcaption>图6</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>先使用 Otsu&#39;s 二值化对图像进行二值化。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">cv2</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"n\">img</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">imread</span><span class=\"p\">(</span><span class=\"s1\">&#39;coins.png&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">gray</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">cvtColor</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">COLOR_BGR2GRAY</span><span class=\"p\">)</span>\n<span class=\"n\">ret</span><span class=\"p\">,</span> <span class=\"n\">thresh</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">threshold</span><span class=\"p\">(</span><span class=\"n\">gray</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">THRESH_BINARY_INV</span><span class=\"o\">+</span><span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">THRESH_OTSU</span><span class=\"p\">)</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-36233a4566bc8b092bbd51ae7931d50d_b.jpg\" data-rawwidth=\"252\" data-rawheight=\"312\" data-size=\"normal\" class=\"content_image\" width=\"252\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;252&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"252\" data-rawheight=\"312\" data-size=\"normal\" class=\"content_image lazy\" width=\"252\" data-actualsrc=\"https://pic2.zhimg.com/v2-36233a4566bc8b092bbd51ae7931d50d_b.jpg\"/><figcaption>图7</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>先使用开运算去除图像中的细小白色噪点，然后通过腐蚀运算移除边界像素，得到的图像中的白色区域肯定是真实前景，即靠近硬币中心的区域（下面左边的图）；膨胀运算使得一部分背景成为了物体到的边界，得到的图像中的黑色区域肯定是真实背景，即远离硬币的区域（下面中间的图）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>剩下的区域（硬币的边界附近）还不能确定是前景还是背景。可通过膨胀图减去腐蚀图得到，下图中的白色部分为不确定区域（下面右边的图）。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># noise removal</span>\n<span class=\"n\">kernel</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">getStructuringElement</span><span class=\"p\">(</span><span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_RECT</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">))</span>\n<span class=\"n\">opening</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">morphologyEx</span><span class=\"p\">(</span><span class=\"n\">thresh</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">MORPH_OPEN</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">,</span> <span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n\n<span class=\"n\">sure_bg</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">dilate</span><span class=\"p\">(</span><span class=\"n\">opening</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">,</span> <span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># sure background area</span>\n<span class=\"n\">sure_fg</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">erode</span><span class=\"p\">(</span><span class=\"n\">opening</span><span class=\"p\">,</span> <span class=\"n\">kernel</span><span class=\"p\">,</span> <span class=\"n\">iterations</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># sure foreground area</span>\n<span class=\"n\">unknown</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">subtract</span><span class=\"p\">(</span><span class=\"n\">sure_bg</span><span class=\"p\">,</span> <span class=\"n\">sure_fg</span><span class=\"p\">)</span>  <span class=\"c1\"># unknown area</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d8721fc4aac9a4d150ba266b809959ea_b.jpg\" data-rawwidth=\"920\" data-rawheight=\"325\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"920\" data-original=\"https://pic3.zhimg.com/v2-d8721fc4aac9a4d150ba266b809959ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;920&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"920\" data-rawheight=\"325\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"920\" data-original=\"https://pic3.zhimg.com/v2-d8721fc4aac9a4d150ba266b809959ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d8721fc4aac9a4d150ba266b809959ea_b.jpg\"/><figcaption>图8</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>剩下的区域不确定是硬币还是背景，这些区域通常在前景和背景接触的区域(或者两个不同硬币接触的区域)，我们称之为边界。通过分水岭算法应该能找到确定的边界。</p><p>由于硬币之间彼此接触，我们使用另一个确定前景的方法，就是<b>带阈值的距离变换</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面左边的图为得到的<b>距离转换图像</b>，其中每个像素的值为其到最近的背景像素（灰度值为0）的距离，可以看到硬币的中心像素值最大（中心离背景像素最远）。对其进行二值处理就得到了分离的前景图（下面中间的图），白色区域肯定是硬币区域，而且还相互分离，下面右边的图为之前的膨胀图减去中间这个表示前景的图。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># Perform the distance transform algorithm</span>\n<span class=\"n\">dist_transform</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">distanceTransform</span><span class=\"p\">(</span><span class=\"n\">opening</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">DIST_L2</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"c1\"># Normalize the distance image for range = {0.0, 1.0}</span>\n<span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">normalize</span><span class=\"p\">(</span><span class=\"n\">dist_transform</span><span class=\"p\">,</span> <span class=\"n\">dist_transform</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">NORM_MINMAX</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Finding sure foreground area</span>\n<span class=\"n\">ret</span><span class=\"p\">,</span> <span class=\"n\">sure_fg</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">threshold</span><span class=\"p\">(</span><span class=\"n\">dist_transform</span><span class=\"p\">,</span> <span class=\"mf\">0.5</span><span class=\"o\">*</span><span class=\"n\">dist_transform</span><span class=\"o\">.</span><span class=\"nb\">max</span><span class=\"p\">(),</span> <span class=\"mi\">255</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># Finding unknown region</span>\n<span class=\"n\">sure_fg</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">(</span><span class=\"n\">sure_fg</span><span class=\"p\">)</span>\n<span class=\"n\">unknown</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">subtract</span><span class=\"p\">(</span><span class=\"n\">sure_bg</span><span class=\"p\">,</span><span class=\"n\">sure_fg</span><span class=\"p\">)</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-74fe7ffc0e608f00d68790d6a31ec240_b.jpg\" data-rawwidth=\"745\" data-rawheight=\"310\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"745\" data-original=\"https://pic1.zhimg.com/v2-74fe7ffc0e608f00d68790d6a31ec240_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;745&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"745\" data-rawheight=\"310\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"745\" data-original=\"https://pic1.zhimg.com/v2-74fe7ffc0e608f00d68790d6a31ec240_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-74fe7ffc0e608f00d68790d6a31ec240_b.jpg\"/><figcaption>图9</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>现在我们可以确定哪些是硬币区域，哪些是背景区域。然后创建标记(marker，它是一个与原始图像大小相同的矩阵，int32数据类型)，表示其中的每个区域。分水岭算法将标记的0的区域视为不确定区域，将标记为1的区域视为背景区域，将标记大于1的正整数表示我们想得到的前景。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以使用 <a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/d3/dc0/group__imgproc__shape.html%23gaedef8c7340499ca391d459122e51bef5\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cv2.connectedComponents()</a> 来实现这个功能，它是用0标记图像的背景，用大于0的整数标记其他对象。所以我们需要对其进行加一，用1来标记图像的背景。</p><p>cv2.connectedComponents() 将传入图像中的白色区域视为组件（前景）。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># Marker labelling</span>\n<span class=\"n\">ret</span><span class=\"p\">,</span> <span class=\"n\">markers</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">connectedComponents</span><span class=\"p\">(</span><span class=\"n\">sure_fg</span><span class=\"p\">)</span>\n<span class=\"c1\"># Add one to all labels so that sure background is not 0, but 1</span>\n<span class=\"n\">markers</span> <span class=\"o\">=</span> <span class=\"n\">markers</span><span class=\"o\">+</span><span class=\"mi\">1</span>\n<span class=\"c1\"># Now, mark the region of unknown with zero</span>\n<span class=\"n\">markers</span><span class=\"p\">[</span><span class=\"n\">unknown</span><span class=\"o\">==</span><span class=\"mi\">255</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：得到的markers矩阵的元素类型为 int32，要使用 imshow() 进行显示，需要将其转换为 uint8 类型（ markers=np.uint8(markers) ）。</p><p>我们对得到的markers进行显示：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">markers_copy</span> <span class=\"o\">=</span> <span class=\"n\">markers</span><span class=\"o\">.</span><span class=\"n\">copy</span><span class=\"p\">()</span>\n<span class=\"n\">markers_copy</span><span class=\"p\">[</span><span class=\"n\">markers</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">150</span>  <span class=\"c1\"># 灰色表示背景</span>\n<span class=\"n\">markers_copy</span><span class=\"p\">[</span><span class=\"n\">markers</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>    <span class=\"c1\"># 黑色表示背景</span>\n<span class=\"n\">markers_copy</span><span class=\"p\">[</span><span class=\"n\">markers</span><span class=\"o\">&gt;</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">255</span>   <span class=\"c1\"># 白色表示前景</span>\n\n<span class=\"n\">markers_copy</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">uint8</span><span class=\"p\">(</span><span class=\"n\">markers_copy</span><span class=\"p\">)</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-135ab19ab9e321815ee91d24b96b1bca_b.jpg\" data-rawwidth=\"272\" data-rawheight=\"328\" data-size=\"normal\" class=\"content_image\" width=\"272\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;272&#39; height=&#39;328&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"272\" data-rawheight=\"328\" data-size=\"normal\" class=\"content_image lazy\" width=\"272\" data-actualsrc=\"https://pic3.zhimg.com/v2-135ab19ab9e321815ee91d24b96b1bca_b.jpg\"/><figcaption>图10</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>标记图像已经完成了，最后应用分水岭算法。然后标记图像将被修改，边界区域将被标记为-1。</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># 使用分水岭算法执行基于标记的图像分割，将图像中的对象与背景分离</span>\n<span class=\"n\">markers</span> <span class=\"o\">=</span> <span class=\"n\">cv2</span><span class=\"o\">.</span><span class=\"n\">watershed</span><span class=\"p\">(</span><span class=\"n\">img</span><span class=\"p\">,</span> <span class=\"n\">markers</span><span class=\"p\">)</span>\n<span class=\"n\">img</span><span class=\"p\">[</span><span class=\"n\">markers</span><span class=\"o\">==-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">255</span><span class=\"p\">]</span>  <span class=\"c1\"># 将边界标记为红色</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>经过分水岭算法得到的新的标记图像和分割后的图像如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-877c39ea93fcbca282d3740197b68891_b.jpg\" data-rawwidth=\"589\" data-rawheight=\"329\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"589\" data-original=\"https://pic2.zhimg.com/v2-877c39ea93fcbca282d3740197b68891_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;589&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"589\" data-rawheight=\"329\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"589\" data-original=\"https://pic2.zhimg.com/v2-877c39ea93fcbca282d3740197b68891_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-877c39ea93fcbca282d3740197b68891_b.jpg\"/><figcaption>图11</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>任何两个相邻连接的组件不一定被分水岭边界(-1的像素)分开；例如在传递给 watershed 函数的初始标记图像中的物体相互接触。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>我们通过一个例子介绍了分水岭算法的整个过程，主要分为以下几步：</p><ol><li>对图进行灰度化和二值化得到二值图像</li><li>通过膨胀得到确定的背景区域，通过距离转换得到确定的前景区域，剩余部分为不确定区域</li><li>对确定的前景图像进行连接组件处理，得到标记图像</li><li>根据标记图像对原图像应用分水岭算法，更新标记图像</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>参考：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/d3/db4/tutorial_py_watershed.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OpenCV Watershed Algorithm</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.cmm.mines-paristech.fr/~beucher/wtshed.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IMAGE SEGMENTATION AND MATHEMATICAL MORPHOLOGY</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//imagej.net/Classic_Watershed\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Classic Watershed</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/qinguoyi/p/8372157.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">基于标记的分水岭分割算法/OpenCV中距离变换</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/34866092\" class=\"internal\">剪刀手/分水岭分割法</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//es.mathworks.com/company/newsletters/articles/the-watershed-transform-strategies-for-image-segmentation.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Watershed Transform</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.opencv.org/3.4/d2/dbd/tutorial_distance_transform.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">对扑克牌应用分水岭的例子</a></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }, 
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "OpenCV", 
                    "tagLink": "https://api.zhihu.com/topics/19587715"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>希望能讨论一下 给点帮助哈哈哈 已经私信</p><p><br></p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" data-width=\"\" data-height=\"\">[干杯]</a>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>没收到什么私信啊</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "小智", 
                    "userLink": "https://www.zhihu.com/people/423bb340607963e2fe8187034f8c30b6", 
                    "content": "<p># Marker labelling<br>ret, markers = cv2.connectedComponents(sure_fg)<br># Add one to all labels so that sure background is not 0, but 1<br>markers = markers+1<br># Now, mark the region of unknown with zero<br>markers[unknown==255] = 0</p><p><br></p><p>请问这个部分，为什么是unkown==255的位置的元素置0，而且是在加1操作之后</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>通过的connectedComponents得到的markers是用0标记图像的背景，而我们实际想要的是用1标记图像的背景，所以要对markers加一。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "小智"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>图9最右边的图（二值图）表示不确定区域，其中不确定区域的灰度值为255，在markers中将这些灰度值为255的对应像素置为0，因为我们希望markers是用0标记图像的不确定区域。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "小智"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>知乎私信  没收到么</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "数月亮", 
                    "userLink": "https://www.zhihu.com/people/1a24672ad27a50674166ebb22b40cae7", 
                    "content": "<p>谢谢</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "不客气，能帮到你就好", 
                            "likes": 0, 
                            "replyToAuthor": "数月亮"
                        }
                    ]
                }, 
                {
                    "userName": "林夕", 
                    "userLink": "https://www.zhihu.com/people/c77fa0a57f151e20232a5c8c4c4a0fcf", 
                    "content": "<p>分水岭,我硬是没理解懂(后面看了其他博文才懂,这个地址<a href=\"http://link.zhihu.com/?target=https%3A//blog.csdn.net/iracer/article/details/49225823\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/iracer/ar</span><span class=\"invisible\">ticle/details/49225823</span><span class=\"ellipsis\"></span></a>的第一个点和第二点),距离变换我看懂了.我功力还太浅了</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67566843", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 12, 
            "title": "数学形态学操作", 
            "content": "<p>目录</p><ul><li><b>Dilation</b></li><li><b>Erosion</b></li><li><b>Opening</b></li><li><b>Closing</b></li><li><b>形态学梯度</b></li><li><b>顶帽</b></li><li><b>黑帽</b></li><li><b>Hit-and-Miss 转换</b></li><li><b>Pattern Spectrum</b></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>数学形态学（Morphology）中也有类似于卷积中的kernel一样的矩阵，叫做Structuring element（结构元素，下文均称为SE）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在图像处理方面，形态学分为二值形态学和灰度形态学，经常应用到对图像进行分割，细化，抽取骨架，边缘提取，形状分析，角点检测，分水岭算法等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在卷积的kernel中，默认原点是在kernel的中心位置，在SE中原点不一定在中心位置，需要自己定义原点，所以数学形态学的操作是具有方向性的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>默认图像中的前景（目标）为白色，背景为黑色。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>1、Dilation</h3><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.1、binary dilation</b></p><p>二值膨胀就是对一个二值图进行膨胀操作。对一个二值图像进行膨胀操作需要一个SE核，SE核由一个二值矩阵组成，还需要定义一个原点，表示核的核心。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>遍历原图像的每一个像素点，将其与SE核的原点对齐，然后取当前SE中所有1的位置所覆盖下原图中对应的像素中的最大值，用这个最大值替换当前像素值。由于二值图像最大值就是1，所以就是用1替换原点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>只有SE位于前景物体（像素值为1）边缘时，它覆盖的区域内才会同时出现0和1两种不同的像素值，这时把当前像素替换成1。因此膨胀看起来的效果就是让前景物体膨胀了一圈，使得边界向外扩散。对于前景物体中一些细小的断裂处，这些断裂的地方可能会被连接起来。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>膨胀操作使前景边界向外扩张，会增大前景区域。可能会连接不同白色区域，也可以用来填补前景中的空洞，去除黑色噪点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如下面这个图像和SE进行膨胀操作（左下角的绿色1为原点）。将图像根据SE中的每个非零元素进行平移，每个元素都会得到一个像素集合，然后把这几个集合求并集得到最终的结果。如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-29f17f0dbca17f4f3f097fe4a9523661_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"394\" data-rawheight=\"142\" class=\"content_image\" width=\"394\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;394&#39; height=&#39;142&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"394\" data-rawheight=\"142\" class=\"content_image lazy\" width=\"394\" data-actualsrc=\"https://pic2.zhimg.com/v2-29f17f0dbca17f4f3f097fe4a9523661_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>因为绿色1为原点，所以对原图像没做任何操作，蓝色1表示将图像<b>向右</b>平移一位，黄色1表示将图像<b>向右上方</b>平移一位，将这三个集合取<b>并集</b>就得到最后的结果。 </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+1+%26+1+%26+1%5C%5C+1+%26+1+%26+1%5C%5C+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D+%5Coplus+%5Cbegin%7Bbmatrix%7D+0+%26+1%5C%5C+1+%26+1+%5Cend%7Bbmatrix%7D+%3D+%5Cbegin%7Bbmatrix%7D+0+%26+1+%26+1+%26+1%5C%5C+1+%26+1+%26+1+%26+1+%5C%5C+1+%26+1+%26+1+%26+1+%5C%5C+1+%26+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix} \\oplus \\begin{bmatrix} 0 &amp; 1\\\\ 1 &amp; 1 \\end{bmatrix} = \\begin{bmatrix} 0 &amp; 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是一个比较复杂的例子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b26ddd842f498bfd20f471d4f928540a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb\" width=\"577\" data-original=\"https://pic3.zhimg.com/v2-b26ddd842f498bfd20f471d4f928540a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;577&#39; height=&#39;210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"577\" data-original=\"https://pic3.zhimg.com/v2-b26ddd842f498bfd20f471d4f928540a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b26ddd842f498bfd20f471d4f928540a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.2、gray dilation</b></p><p>比如表示灰度图像的信号如下左图表示（灰度值曲线），</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2、Erosion</h3><p>遍历原图像的每一个像素点，将其与SE核的原点对齐，然后取当前SE中所有1的位置所覆盖下原图中对应的像素中的最小值，用这个最小值替换当前像素值。二值图像最小值就是0，所以就是用0替换原点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>只有SE位于前景物体（像素值为1）边缘的时候，它覆盖的区域内才会同时出现0和1两种不同的像素值，这个时候把当前像素替换成0。因此腐蚀看起来的效果就是让前景物体缩小了一圈，使得边界向内收缩。对于前景物体中一些细小的连接处，这些连接处可能会断开。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>腐蚀操作会减小白色区域，去除白色噪点，断开白色细线连接，使前景区域向内收缩。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如下面这个图像和SE进行腐蚀操作（左下角的绿色1为原点）。因为绿色1为原点，所以对原图像没做任何操作，蓝色1表示将图像<b>向左</b>平移一位，黄色1表示将图像<b>向左下方</b>平移一位，将这三个集合取<b>交集</b>就得到最后的结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：在腐蚀中平移的方向和膨胀时相反，而且最后是取交集。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a6d319027b091a97a8a682552103108a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"381\" data-rawheight=\"135\" class=\"content_image\" width=\"381\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;381&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"381\" data-rawheight=\"135\" class=\"content_image lazy\" width=\"381\" data-actualsrc=\"https://pic3.zhimg.com/v2-a6d319027b091a97a8a682552103108a_b.jpg\"/></figure><p>最后的结果为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+1+%26+1+%26+1%5C%5C+1+%26+1+%26+1%5C%5C+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D+%5Cominus+%5Cbegin%7Bbmatrix%7D+0+%26+1%5C%5C+1+%26+1+%5Cend%7Bbmatrix%7D+%3D+%5Cbegin%7Bbmatrix%7D+1+%26+1+%5C%5C+1+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1\\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix} \\ominus \\begin{bmatrix} 0 &amp; 1\\\\ 1 &amp; 1 \\end{bmatrix} = \\begin{bmatrix} 1 &amp; 1 \\\\ 1 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> </p><p>就是说当把SE放到图像中时，SE中的1在图像中也必须全部对应为1，则原点处的值置为1，否则置为0。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是一个比较复杂的例子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3b32877dfb7b36e1539cb9a7748149c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-3b32877dfb7b36e1539cb9a7748149c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;583&#39; height=&#39;217&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-3b32877dfb7b36e1539cb9a7748149c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3b32877dfb7b36e1539cb9a7748149c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3、Opening</h3><p>对图像先做 erosion，然后做 dilation，就称为开运算。数学表示为：<img src=\"https://www.zhihu.com/equation?tex=F+%5Ccirc+K+%3D+%28F+%5Cominus+K%29+%5Coplus+K\" alt=\"F \\circ K = (F \\ominus K) \\oplus K\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>用于消除图像中孤立的，狭小的干扰区域（白色噪点），在纤细连接处分离物体，还会消除较大区域的凸起部分（平滑边界）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在图像的前景区域中，所有比SE小的区域都会被去除：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-173347a10ccfea8cd4d4043cceed2e7d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"513\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"513\" data-original=\"https://pic2.zhimg.com/v2-173347a10ccfea8cd4d4043cceed2e7d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;513&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"513\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"513\" data-original=\"https://pic2.zhimg.com/v2-173347a10ccfea8cd4d4043cceed2e7d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-173347a10ccfea8cd4d4043cceed2e7d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-70aba3c78ab544713053d70948bcf279_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-70aba3c78ab544713053d70948bcf279_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-70aba3c78ab544713053d70948bcf279_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-70aba3c78ab544713053d70948bcf279_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>开运算还可以用于提取水平或竖直线：kernel是水平长条的矩形，可以提取水平线；kernel是竖直长条的矩形，可以提取竖直线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>腐蚀和开运算会使图像的信息丢失（去除白色区域），开运算只是丢弃一些细小前景区域，黑色区域和没有去除的白色区域尽量不发生变化，保留了图像的更多原有特征。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4、Closing</h3><p>对图像先做 dilation，然后做 erosion，就称为闭运算。 数学表式为： <img src=\"https://www.zhihu.com/equation?tex=F+%5Ccdot+K+%3D+%28F+%5Coplus+K%29+%5Cominus+K\" alt=\"F \\cdot K = (F \\oplus K) \\ominus K\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>用来填充物体内细小黑色空洞、连接邻近独立、分散的前景区域、多用在图像修复中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>填充前景中的比SE小的黑色空洞和内凹区域。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0fce20824f91353f0f7c178af37ba058_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb\" width=\"509\" data-original=\"https://pic1.zhimg.com/v2-0fce20824f91353f0f7c178af37ba058_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;509&#39; height=&#39;205&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"509\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"509\" data-original=\"https://pic1.zhimg.com/v2-0fce20824f91353f0f7c178af37ba058_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0fce20824f91353f0f7c178af37ba058_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-88548f7faaa9aaa366fc4a6161c6dcb7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"624\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb\" width=\"624\" data-original=\"https://pic4.zhimg.com/v2-88548f7faaa9aaa366fc4a6161c6dcb7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;624&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"624\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"624\" data-original=\"https://pic4.zhimg.com/v2-88548f7faaa9aaa366fc4a6161c6dcb7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-88548f7faaa9aaa366fc4a6161c6dcb7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>膨胀和闭运算会使图像的信息增加（去除黑色区域），膨胀是整个区域都得到了膨胀，闭运算只是对一些细小前景区域进行填充，白色区域和没有去除的黑色区域尽量不发生变化，保留了图像的较多特征。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>5、形态学梯度</h3><p>形态学梯度（Morphological Gradient）为膨胀图与腐蚀图之差。数学表达式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=dst+%3D+dilate%28src%2C+element%29+-+erode%28src%2C+element%29\" alt=\"dst = dilate(src, element) - erode(src, element)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>对二值图像进行这一操作可以将团块（blob）的边缘突出出来，能够保留物体的边缘轮廓。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个是基本梯度，还有内部梯度和外部梯度，内部梯度是原图减去腐蚀图，外部梯度是膨胀图减去原图，这两者得到的轮廓边都比基本梯度更细。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-30afca9b8f154a34f078a0450136133c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-30afca9b8f154a34f078a0450136133c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-30afca9b8f154a34f078a0450136133c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-30afca9b8f154a34f078a0450136133c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>6、顶帽</h3><p>顶帽运算（Top Hat）为原图像与“开运算“的结果图之差。数学表达式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=dst+%3D+src+-+open%28src%2C+element%29\" alt=\"dst = src - open(src, element)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为开运算带来的结果是放大了裂缝或者消除小白色区域，因此，从原图中减去开运算后的图，得到的效果图突出了比原图轮廓周围的区域更明亮的区域，且这一操作和选择的核的大小相关。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>顶帽运算往往用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景，而微小物品比较有规律的时候，可以使用顶帽运算进行背景提取。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-faa082dfc1c7925df5570ae440dce23f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-faa082dfc1c7925df5570ae440dce23f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-faa082dfc1c7925df5570ae440dce23f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-faa082dfc1c7925df5570ae440dce23f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>7、黑帽</h3><p>黑帽（Black Hat）运算为”闭运算“的结果图与原图像之差。数学表达式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=dst+%3D+close%28src%2C+element%29+-+src\" alt=\"dst = close(src, element) - src\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，且这一操作和选择的核的大小相关。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以，黑帽运算用来分离比邻近点暗一些的斑块。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dbbeeeee0ce1365a73ce05a445d4763b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"649\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"649\" data-original=\"https://pic4.zhimg.com/v2-dbbeeeee0ce1365a73ce05a445d4763b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;649&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"649\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"649\" data-original=\"https://pic4.zhimg.com/v2-dbbeeeee0ce1365a73ce05a445d4763b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dbbeeeee0ce1365a73ce05a445d4763b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h3>8、Hit-and-Miss 转换</h3><p>这个转换的定义如下： </p><p><img src=\"https://www.zhihu.com/equation?tex=F+%5Cotimes+K+%3D+%28F+%5Cominus+K_1%29%5C+%5Ccap+%5C+%28F%5Ec+%5Cominus+K_2%29\" alt=\"F \\otimes K = (F \\ominus K_1)\\ \\cap \\ (F^c \\ominus K_2)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>通过两个Erosion来实现，需要定义两个不同的SE，分别为 k1 和 k2，要求 k1 和 k2 的交集为空，而且这两者都属于 K，即都是 K 的一个子集。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>用数学符号表示为： </p><p><img src=\"https://www.zhihu.com/equation?tex=K_1+%5C+%5Ccap+%5C+K_2+%3D+%5Cvarnothing+%2C%5C+K_1+%5Cin+K%2C%5C+K_2+%5Cin+K\" alt=\"K_1 \\ \\cap \\ K_2 = \\varnothing ,\\ K_1 \\in K,\\ K_2 \\in K\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>K1 对原图像（前景）进行腐蚀；K2 对灰度值翻转后的图像进行腐蚀（ <img src=\"https://www.zhihu.com/equation?tex=F%5Ec\" alt=\"F^c\" eeimg=\"1\"/> 表示原图像的反色图像），即对图像的背景进行操作，最后对这两者进行求交集得到结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以从图像中求取特殊的特征，先在前景中获取这个特征，然后在背景中剔除这个特征。</p><p>特殊的特征包括：</p><ul><li>isolated pixels，孤立像素</li><li>end points，顶点</li><li>contour points，轮廓边缘点</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是一个例子，得到了这些齿轮的轮廓上的点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2a75a03faaacf711d448afe41240f182_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-2a75a03faaacf711d448afe41240f182_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-2a75a03faaacf711d448afe41240f182_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2a75a03faaacf711d448afe41240f182_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用 Hit-and-Miss 变换时，两次腐蚀操作都使用K1，都使用K2，或者使用K1和K2，得到的轮廓的粗细是不一样的：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c1193bd168d4af025d547e3050abaa19_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1037\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb\" width=\"1037\" data-original=\"https://pic2.zhimg.com/v2-c1193bd168d4af025d547e3050abaa19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1037&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1037\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1037\" data-original=\"https://pic2.zhimg.com/v2-c1193bd168d4af025d547e3050abaa19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c1193bd168d4af025d547e3050abaa19_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Hit-or-miss_transform\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hit-or-miss transform</a><a href=\"https://link.zhihu.com/?target=https%3A//homepages.inf.ed.ac.uk/rbf/HIPR2/hitmiss.htm\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hit-and-Miss Transform</a><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p><p></p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }, 
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67197912", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 35, 
            "title": "图像卷积、边缘提取和滤波去噪", 
            "content": "<p>目录</p><ul><li><b>图像卷积</b></li><li><b>图像梯度</b></li><li><b>边缘提取</b></li><ul><li><b>1. Prewitt算子</b></li><li><b>2. Sobel算子</b></li><li><b>3. Laplacian算子</b></li></ul><li><b>平滑去噪</b></li><ul><li><b>1. 高斯滤波</b></li><li><b>2. 均值滤波</b></li><li><b>3. 中值滤波</b></li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>一、图像卷积</h2><p>现在有一张图片 f(x,y) 和一个kernel核 w(a,b)。</p><p><code>卷积</code>(Convolution)：卷积运算就是对于图像 f(x,y) 中的每个像素，将其作为中心像素，计算它及其邻域像素和kernel核 w(a,b)对应位置元素的乘积，然后把结果相加到一起，得到的值就作为该中心像素的新值，这样就完成了一次卷积运算。然后将kernel向下或向左平移一位继续计算每个像素的新值，直到遍历完整个图像。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-46d78ef8021454d852b80c9ef2b59716_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"563\" data-original=\"https://pic3.zhimg.com/v2-46d78ef8021454d852b80c9ef2b59716_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;563&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"563\" data-original=\"https://pic3.zhimg.com/v2-46d78ef8021454d852b80c9ef2b59716_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-46d78ef8021454d852b80c9ef2b59716_b.jpg\"/></figure><p>卷积运算的公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=f+%2A+w+%3D+%5Csum%5Climits_%7B%28a%2C%5C+b%29+%5Cin+w+%5C%5C+%28x-a%2C%5C+y-b%29+%5Cin+f%7D+f%28x-a%2Cy-b%29%5C+w%28a%2Cb%29\" alt=\"f * w = \\sum\\limits_{(a,\\ b) \\in w \\\\ (x-a,\\ y-b) \\in f} f(x-a,y-b)\\ w(a,b)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>还有一个概念是<b>互相关</b>(Cross-correlation)，流程和卷积类似，区别在于卷积在运算前需要把kernel围绕中心旋转180度（即做一次上下翻转(filp)和一次左右翻转），而互相关则不需要。</p><p>互相关的公式如下： </p><p><img src=\"https://www.zhihu.com/equation?tex=f+%5Cotimes+w+%3D+%5Csum%5Climits_%7B%28a%2C%5C+b%29+%5Cin+w+%5C%5C+%28x%2Ba%2C%5C+y%2Bb%29+%5Cin+f%7D+f%28x%2Ba%2Cy%2Bb%29%5C+w%28a%2Cb%29\" alt=\"f \\otimes w = \\sum\\limits_{(a,\\ b) \\in w \\\\ (x+a,\\ y+b) \\in f} f(x+a,y+b)\\ w(a,b)\" eeimg=\"1\"/> </p><p>两者的具体区别可以查看 <a href=\"https://www.zhihu.com/question/32067344\" class=\"internal\">卷积运算和相关运算的区别与物理含义</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>互相关主要用于计算两个图像的相关性（主要用于图像配准）。因为我们平时接触的卷积核大都是关于x轴和y轴对称的，所以卷积和互相关在这种情况下没什么区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>中心像素在图像的边缘时，没有足够的像素与kernel进行运算，有两个方法：</p><ol><li>最外面的一圈像素不进行计算，如果图像非常大，丢掉图像边缘的一圈对结果影响不大。</li><li>更好的办法是人为地在图像四周插入一圈像素（比如最近邻插值）。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>图像的处理结果可能超出值域范围(0-255)，则小于0的值视作0，大于255的视作255就行了。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、图像梯度</h2><p>梯度的方向是函数 f(x,y) 变化最快的方向，当图像中存在边缘时，有一些相邻像素的灰度值变化比较大，即一定有较大的梯度值。所以可以求图像的梯度来确定图像的边缘。</p><p>分别对图像按照x方向和y方向进行求偏导，得到x梯度图和y梯度图。梯度是矢量，存在幅值和方向，下面这个公式表示了图像的梯度： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cnabla+f%3D%5Cbegin%7Bbmatrix%7D+G_%7Bx%7D+%5C%5C+G_%7By%7D+%5Cend%7Bbmatrix%7D+%3D+%5Cbegin%7Bbmatrix%7D+%5Cdfrac%7B%5Cpartial+f%28x%2Cy%29%7D%7B%5Cpartial+x%7D+%5C%5C+%5Cdfrac%7B%5Cpartial+f%28x%2Cy%29%7D%7B%5Cpartial+y%7D+%5Cend%7Bbmatrix%7D\" alt=\"\\nabla f=\\begin{bmatrix} G_{x} \\\\ G_{y} \\end{bmatrix} = \\begin{bmatrix} \\dfrac{\\partial f(x,y)}{\\partial x} \\\\ \\dfrac{\\partial f(x,y)}{\\partial y} \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>梯度的幅值(magnitude)为：</p><p><img src=\"https://www.zhihu.com/equation?tex=mag%28%5Cnabla+f%29+%3D+%5Csqrt%7BG_%7By%7D%5E%7B2%7D+%2B+G_%7Bx%7D%5E%7B2%7D%7D\" alt=\"mag(\\nabla f) = \\sqrt{G_{y}^{2} + G_{x}^{2}}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>梯度的方向(direction)为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Ctheta+%3D+%5Coperatorname%7Barctan%7D+%5Cleft+%28%5Cdfrac%7BG_%7By%7D%7D%7BG_%7Bx%7D%7D+%5Cright%29\" alt=\"\\theta = \\operatorname{arctan} \\left (\\dfrac{G_{y}}{G_{x}} \\right)\" eeimg=\"1\"/> </p><p>梯度方向会取绝对值，因此得到的角度范围是 [0,180°]。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>导数的含义就是计算像素灰度值的变化率，对于离散图像而言，在图像上使用一阶差分来计算相邻像素之间的差值，从而得到图像的梯度。 </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cdfrac+%7B%5Cpartial+f%7D%7B%5Cpartial+x%7D+%3D+f%28x%2B1%2C%5C+y%29+-+f%28x%2C%5C+y%29+%5C%5C+%5Cdfrac+%7B%5Cpartial+f%7D%7B%5Cpartial+y%7D+%3D+f%28x%2C%5C+y%2B1%29+-+f%28x%2C%5C+y%29\" alt=\"\\dfrac {\\partial f}{\\partial x} = f(x+1,\\ y) - f(x,\\ y) \\\\ \\dfrac {\\partial f}{\\partial y} = f(x,\\ y+1) - f(x,\\ y)\" eeimg=\"1\"/> </p><p>也可以使用二阶差分求梯度：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cdfrac+%7B%5Cpartial+f%5E2%7D%7B%5Cpartial+x%5E2%7D+%3D+f%28x%2B1%2C%5C+y%29+%2B+f%28x-1%2C%5C+y%29+-+2+f%28x%2C%5C+y%29+%5C%5C+%5Cdfrac+%7B%5Cpartial+f%5E2%7D%7B%5Cpartial+y%5E2%7D+%3D+f%28x%2C%5C+y%2B1%29+%2B+f%28x%2C%5C+y-1%29+-+2+f%28x%2C%5C+y%29\" alt=\"\\dfrac {\\partial f^2}{\\partial x^2} = f(x+1,\\ y) + f(x-1,\\ y) - 2 f(x,\\ y) \\\\ \\dfrac {\\partial f^2}{\\partial y^2} = f(x,\\ y+1) + f(x,\\ y-1) - 2 f(x,\\ y)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是一个边缘的例子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dbe4e9f6c8049721f462c70af98fcc63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"343\" class=\"content_image\" width=\"352\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;352&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"343\" class=\"content_image lazy\" width=\"352\" data-actualsrc=\"https://pic4.zhimg.com/v2-dbe4e9f6c8049721f462c70af98fcc63_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面是对斜坡区域进行求导，斜坡区域是图像中最常见的区域，因为图片中的大部分边缘都不是突变的而是渐变的，对于斜坡区域，一阶导数将斜坡变成了平坦区域即变成了粗线，二阶导数将斜坡变成了两条中间存在平台区域的细线。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>关于一阶和二阶导数总结如下：</p><ol><li>一阶导数在图像中产生较粗的边缘</li><li>二阶导数对细节更敏感，如细线、噪声等，它提取出来的边缘更细更强(sharp)</li><li>二阶导数在灰度斜坡和灰度台阶过度处会产生双边沿响应</li><li>二阶导数的符号可以确定边缘的过渡是从亮到暗还是从暗到亮</li><li>根据导数提取边缘之前最好对图像做平滑处理，因为导数对噪声比较敏感，尤其是二阶导数</li><li>二阶导数会强化边缘和其他区域的对比度，但是也会将灰度平滑区域的噪声进行放大，使其更明显</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、边缘提取</h2><p>图像梯度用于边缘检测。边缘是像素值发生跃迁的地方，是图像的显著特征之一，在图像特征提取、目标检测等方面都有重要的作用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图像中有灰度值的变化就会有梯度，从而产生边缘，在边缘处，具有变化的强弱及方向。这时一些常见的图像识别算法的基础，比如 hog，sift，都是基于梯度的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>边缘分为三类，<code>step edge</code>、<code>ramp edge</code>和<code>peak edge</code>，下面是三类边缘的及其导数（一阶或者二阶）的形状：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ffef17c7ab91c14b324831765366d663_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic4.zhimg.com/v2-ffef17c7ab91c14b324831765366d663_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic4.zhimg.com/v2-ffef17c7ab91c14b324831765366d663_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ffef17c7ab91c14b324831765366d663_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据不同的图像边缘特征，来决定是使用一阶还是二阶导数来求梯度。对图像求一阶或者高阶导数，会得到一些峰值，当这些峰值超过指定阈值时，则认为这些峰值对应的像素是边缘。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前面说到在图像上可以使用一阶差分来计算相邻像素之间的变化率，我们利用卷积和特定的算子来计算相邻像素的变化率。<b>prewitt算子</b>和<b>sobel算子</b>可以计算相邻三个点之间的变化率。它们用于一阶算子的边缘检测，利用像素点上下、左右相邻点的灰度差求取边缘。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>求梯度有三种卷积核（robert，prewitt，sobel算子），每种卷积核有两个，对图像分别做两次卷积，一个代表水平梯度，一个代表垂直梯度。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3.1、Prewitt算子</h3><p>下面是prewitt的两个算子：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+-1+%26+0+%26+1+%5C%5C+-1+%26+0+%26+1+%5C%5C+-1+%26+0+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} -1 &amp; 0 &amp; 1 \\\\ -1 &amp; 0 &amp; 1 \\\\ -1 &amp; 0 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> ：计算水平梯度，检测垂直边缘</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+-1+%26+-1+%26+-1+%5C%5C+0+%26+0+%26+0+%5C%5C+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} -1 &amp; -1 &amp; -1 \\\\ 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> ：计算垂直梯度，检测水平边缘</p><p>（梯度方向跟边缘方向垂直）</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3.2、Sobel算子</h3><p>Sobel算子是在Prewitt算子的基础上进行改进，增强了中间这个位置的权重：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+-1+%26+0+%26+1+%5C%5C+-2+%26+0+%26+2+%5C%5C+-1+%26+0+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} -1 &amp; 0 &amp; 1 \\\\ -2 &amp; 0 &amp; 2 \\\\ -1 &amp; 0 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> ：计算水平梯度，检测垂直边缘</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+-1+%26+-2+%26+-1+%5C%5C+0+%26+0+%26+0+%5C%5C+1+%26+2+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} -1 &amp; -2 &amp; -1 \\\\ 0 &amp; 0 &amp; 0 \\\\ 1 &amp; 2 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> ：计算垂直梯度，检测水平边缘</p><p>Sobel更强调了和边缘相邻的像素点对边缘的影响。相比较Prewitt算子，Sobel模板能够较好的抑制噪声（平滑）效果。 </p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3.3、Laplacian算子</h3><p>上述两个算子都是通过求一阶导数来计算梯度的，用于线的检测，通常用于边缘检测。在图像处理过程中，除了检测线，有时候也需要检测特殊点，这就需要用二阶导数进行检测，著名的就是拉普拉斯（Laplacian）算子。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对图像求两次导数，公式如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a557f52e5e05146031ce19ec0e02659b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-a557f52e5e05146031ce19ec0e02659b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;752&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-a557f52e5e05146031ce19ec0e02659b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a557f52e5e05146031ce19ec0e02659b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>所以拉普拉斯算子为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+0+%26+1+%26+0+%5C%5C+1+%26+-4+%26+1+%5C%5C+0+%26+1+%26+0+%5Cend%7Bbmatrix%7D+%5C+%5C+%5C+%5C+%5Ctext+or+%5C+%5C+%5C+%5C++%5Cbegin%7Bbmatrix%7D+0+%26+-1+%26+0+%5C%5C+-1+%26+4+%26+-1+%5C%5C+0+%26+-1+%26+0+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} 0 &amp; 1 &amp; 0 \\\\ 1 &amp; -4 &amp; 1 \\\\ 0 &amp; 1 &amp; 0 \\end{bmatrix} \\ \\ \\ \\ \\text or \\ \\ \\ \\  \\begin{bmatrix} 0 &amp; -1 &amp; 0 \\\\ -1 &amp; 4 &amp; -1 \\\\ 0 &amp; -1 &amp; 0 \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面这个拉普拉斯算子提取边缘更明显： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bbmatrix%7D+1+%26+1+%26+1+%5C%5C+1+%26+-8+%26+1+%5C%5C+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D+%5C+%5C+%5C+%5C+%5Ctext+or+%5C+%5C+%5C+%5C++%5Cbegin%7Bbmatrix%7D+-1+%26+-1+%26+-1+%5C%5C+-1+%26+8+%26+-1+%5C%5C+-1+%26+-1+%26+-1+%5Cend%7Bbmatrix%7D\" alt=\"\\begin{bmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; -8 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix} \\ \\ \\ \\ \\text or \\ \\ \\ \\  \\begin{bmatrix} -1 &amp; -1 &amp; -1 \\\\ -1 &amp; 8 &amp; -1 \\\\ -1 &amp; -1 &amp; -1 \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>拉普拉斯算子在边缘检测的应用中并不局限于水平方向或垂直方向，这是Laplacian与soble的区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为一阶二阶导数都能放大孤立点和孤立线（噪声）的影响，所以如果存在噪声，那么一阶二阶导数处理过后的图像将会有更多更大的噪声。所以对图像进行一阶二阶导数运算之前需要先对图像做平滑去噪处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>四、平滑去噪</h2><p>噪声的产生是因为图像中的某些像素的灰度值发生了突变，使得和周围区域不和谐。除噪其实去除高频噪声，使得图像中的噪声像素的灰度值不那么突兀。</p><p>噪声去除有基于卷积（高斯滤波，均值滤波，中值滤波等）和基于形态学（开运算、闭运算）两种方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>用于平滑去噪和图像锐化（之后会介绍）的卷积核所有的元素之和一般要等于1，这是为了原始图像的能量（亮度）守恒。如果滤波器矩阵所有元素之和大于1，那么滤波后的图像就会比原图像更亮，反之，如果小于1，那么得到的图像就会变暗。如果和为0，图像不会完全黑，但只会突出一些边缘。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>从频率域观点来看这些滤波器是一种<b>低通滤波器</b>，高频信号将会去掉，因此可以帮助消除图像尖锐噪声，实现图像平滑，模糊等功能。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.1、高斯滤波</h3><p>高斯滤波就是对整幅图像进行加权平均数的过程，每一个像素点的值，都由其本身和邻域内的其他像素值经过加权平均后得到。高斯滤波时水平和垂直方向呈现高斯分布，更突出了中心点在像素平滑后的权重。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>高斯平滑中的滤波器是一个高斯核，二维零均值高斯函数为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e10f557f18c7088b52622bea1a1a8dbb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"232\" data-rawheight=\"66\" class=\"content_image\" width=\"232\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;232&#39; height=&#39;66&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"232\" data-rawheight=\"66\" class=\"content_image lazy\" width=\"232\" data-actualsrc=\"https://pic4.zhimg.com/v2-e10f557f18c7088b52622bea1a1a8dbb_b.jpg\"/></figure><p>下面是高斯函数的形象表示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5e3bd759d8855c205394f1018be2c6f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"235\" class=\"content_image\" width=\"371\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;371&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"235\" class=\"content_image lazy\" width=\"371\" data-actualsrc=\"https://pic4.zhimg.com/v2-5e3bd759d8855c205394f1018be2c6f7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>常见的3x3高斯核（高斯核的宽和高必须是奇数）为： <img src=\"https://www.zhihu.com/equation?tex=%5Cdfrac%7B1%7D%7B16%7D+%5Cbegin%7Bbmatrix%7D+1+%26+2+%26+1+%5C%5C+2+%26+4+%26+2+%5C%5C+1+%26+2+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\dfrac{1}{16} \\begin{bmatrix} 1 &amp; 2 &amp; 1 \\\\ 2 &amp; 4 &amp; 2 \\\\ 1 &amp; 2 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到高斯核里的值符合高斯分布，中心的值最大，其他值根据距离中心元素的距离递减，用高斯核对图像进行卷积运算，会使图像更模糊（平滑），而模糊的程度由高斯的标准方差  <img src=\"https://www.zhihu.com/equation?tex=%5Csigma\" alt=\"\\sigma\" eeimg=\"1\"/>  决定， <img src=\"https://www.zhihu.com/equation?tex=%5Csigma\" alt=\"\\sigma\" eeimg=\"1\"/> 越大，平滑程度越大。高斯滤波可以有效的从图像中去除高斯噪音。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>高斯函数的值域在(0,1)之间，也就是说高斯核的九个数加起来应该等于1（也就是100%），把 1 这个数分摊到九个像素上，给了中间点更高的百分比。即高斯滤波对高斯核所覆盖的像素点的灰度值做了一个权重平均，中间的点权重大，周围的点权重小。</p><p>因为中心点是正在处理的点，也就是噪声点，给它更多的权重更能保持它自己的特性，从而使得平均运算对周围的像素影响更小。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.2、均值滤波</h3><p>使用进行均值滤波操作来模糊图像。输出图像的每一个像素灰度值是卷积核在输入图像中对应的像素的平均值( 所有像素加权系数相等)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>均值滤波卷积核所覆盖的九个像素点具有同样权重， 该卷积核的作用在于取九个值的平均值代替中间像素值，所以起到的平滑的效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>相比于高斯滤波，它不能很好地保护图像细节，在图像去噪的同时也破坏了图像的细节部分，丢失了图像本身的一些属性，从而使图像变得模糊，不能很好地去除噪声点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>均值滤波的卷积核为： <img src=\"https://www.zhihu.com/equation?tex=%5Cdfrac%7B1%7D%7B9%7D+%5Cbegin%7Bbmatrix%7D+1+%26+1+%26+1+%5C%5C+1+%26+1+%26+1+%5C%5C+1+%26+1+%26+1+%5Cend%7Bbmatrix%7D\" alt=\"\\dfrac{1}{9} \\begin{bmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 1 \\end{bmatrix}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.3、中值滤波</h3><p>高斯滤波和均值滤波对去除高斯噪声的效果比较好，但是在噪声是<b>椒盐噪声</b>而不是高斯噪声，即图像偶尔会出现很大的噪声点的时候，用高斯滤波和均值滤波对图像进行平滑模糊的话，噪声像素是不会被去除的，它们只是转换为更为柔和但仍然可见的散粒。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>椒盐噪声（salt &amp; pepper noise）</b>（散粒噪声）是数字图像的一个常见噪声，所谓椒盐，椒就是黑，盐就是白，椒盐噪声就是在图像上随机出现黑色白色的像素。椒盐噪声是一种因为信号脉冲强度引起的噪声，要对椒盐噪声处理就需要用中值滤波。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其他滤波器都是用计算得到的一个新值来替代中心像素的值，而中值滤波是将周围像素和中心像素九个值进行排序以后，取中间值来替代中心像素。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>中值滤波在一定的条件下可以克服常见线性滤波器带来的图像细节模糊，而且对滤除脉冲干扰及图像扫描噪声非常有效，也常用于保护边缘信息，使得边缘不会被模糊。但是对一些细节多，特别是线、尖顶等细节多的图像不宜采用中值滤波。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>中值滤波器与均值滤波器的比较：在均值滤波器中，由于噪声成分被放入平均计算中，所以输出受到了噪声的影响，但是在中值滤波器中，由于噪声成分很难选上，所以几乎不会影响到输出。因此同样用3x3区域进行处理，中值滤波消除的噪声能力更胜一筹。中值滤波无论是在消除噪声还是保存边缘方面都是一个不错的方法。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面介绍的都是低通滤波器，使用低通滤波器可以图像模糊，去除图像中的高频成分（包括噪音和边界）。有一些去滤波技术不会模糊掉边界，比如<b>双边滤波</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }, 
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }
            ], 
            "comments": [
                {
                    "userName": "橡树", 
                    "userLink": "https://www.zhihu.com/people/44c03e5418ab70c37d1fa27cd88f3770", 
                    "content": "很不错👍", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<a href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"990581356149100544\">[干杯]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "橡树"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66301560", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 7, 
            "title": "直方图与二值化", 
            "content": "<p>目录：</p><ol><li><b>直方图</b></li><li><b>二值化</b><br/><b>2.1 固定阈值二值化</b><br/><b>2.2 自适应阈值二值化</b></li><li><b>OTSU算法</b></li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2>直方图</h2><p>直方图（Histogram）是一个基于灰度值的像素分布函数，丢失了所有的空间信息。横轴是灰度值，纵轴是每个灰度值对应的像素个数。</p><p>根据直方图的横轴对整个直方图做积分就是图像的面积。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>直方图可以帮助分析图像中的灰度变化，进而帮助确定最优二值化的灰度阈值（threshold level）。如果物体与背景的灰度值对比明显，此时灰度直方图就会包含双峰（bimodal histogram），即直方图中一般会有两个峰值，分别为图像的前景和背景。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前景使得某个灰度区间的灰度值的数量急剧增加，就会产生一个峰值，同理背景会使另一个灰度区间的灰度值的数量急剧增加，就产生另外一个峰值，两峰间的谷底对应于物体边缘附近相对较少数目的像素点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这两个峰值之间的最小值一般就是最优二值化的分界点，通过这个分界点可以把前景和背景很好地分割开来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-216554519ef9ddc937300f817ebd1e9d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-216554519ef9ddc937300f817ebd1e9d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-216554519ef9ddc937300f817ebd1e9d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-216554519ef9ddc937300f817ebd1e9d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>有时这两个峰值会有部分重叠，即左侧峰值的下降部分和右侧峰值的上升部分存在叠加。通常可以把自然界的信号看做高斯信号，即一个峰值对应一个高斯信号，当直方图中的两个高斯信号在某个灰度区域叠加的时候，其叠加区就形成了一个圆滑的谷底，就很难找到一个确切的位置（最优二值化的灰度值）把这两个峰值分开。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二值化</h2><p>二值化（binarisation）一般是指灰度二值化，是一种基于灰度直方图的图像分割算法，将图像中的像素分为两类，最终产生一个二值化的图像。适用于物体与背景的灰度值差别比较大的情况。</p><p>二值化算法的初始值被设置为整个图像灰度值的平均值，求取最优二值化的值是这个算法的关键，也就是尽量求取灰度直方图中两个双峰间的最低点。二值化算法分为两种：固定阈值和自适应阈值。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>固定阈值二值化</h3><p>在整个图像中将灰度阈值设置为一个常数，将图像中每个像素的灰度值与该阈值相比较，从而对整个图像进行分割处理。</p><p>如果背景的灰度值在整个图像中可合理地看作为恒定，而且所有物体与背景都具有几乎相同的对比度，那么，只要选择了正确的阈值，使用一个固定的全局阈值一般会有较好的效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>用公式来表示全局阈值： </p><p><img src=\"https://www.zhihu.com/equation?tex=g%28x%2Cy%29%3D+%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+0+%5C+%5C+%5C+%5C+%5C+%5C+f%28x%2Cy%29%3CT+%5C%5C+++1+%5C+%5C+%5C+%5C+%5C+%5C+f%28x%2Cy%29%5Cge++T+%5Cend%7Barray%7D+++%5Cright.+%5Cend%7Bequation%7D\" alt=\"g(x,y)= \\begin{equation}   \\left\\{ \\begin{array}{**lr**} 0 \\ \\ \\ \\ \\ \\ f(x,y)&lt;T \\\\   1 \\ \\ \\ \\ \\ \\ f(x,y)\\ge  T \\end{array}   \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>其中 f(x,y) 是原始图像，g(x,y) 是二值图像，T 是灰度阈值。灰度值小于 T 的像素都设为0，反之都设为1。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>自适应阈值二值化</h3><p>图像背景的灰度值可能过于复杂，物体和背景的对比度在图像中也有变化，一个在图像中某一区域效果良好的阈值在其它区域却可能效果很差。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>用一个二值化的值不能很好地对图像进行分类，可以将图像划分多个子图像（局域），对每个子图像单独设置一个二值化的值，分别做二值化处理，然后将这些子图像进行拼接，实现更加优化的分割。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>OTSU算法</h2><p>OTSU&#39;s 阈值算法又称大津算法、最大类间方差法，该算法是在灰度直方图的基础上用<b>最小二乘法</b>原理推导出来的，是具有统计意义上的最佳分割阈值。核心思想就是使<b>类间方差最大</b>，要求被分割的物体颜色纹理比较紧凑，类内方差小，对于一些文本图像的处理（比如车牌、指纹）效果很好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>基本原理是以最佳阈值将图像的灰度直方图分割成两部分，使两部分之间的方差取得最大值，即分离性最大。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>OTSU&#39;s 算法推导：</b></p><p>设 X 是一幅具有 L 级灰度的图像，其中 i 是像素灰度等级， <img src=\"https://www.zhihu.com/equation?tex=n_i\" alt=\"n_i\" eeimg=\"1\"/> 是该灰度等级的像素个数，i 的值在 0 到 L-1 之间。</p><p>图像的总像素点个数为 <img src=\"https://www.zhihu.com/equation?tex=N%3D%5Csum%5Climits_%7Bi%3D0%7D%5E%7BL-1%7D+n_i\" alt=\"N=\\sum\\limits_{i=0}^{L-1} n_i\" eeimg=\"1\"/> </p><p>第 i 灰度等级的像素在图像中出现的概率为 <img src=\"https://www.zhihu.com/equation?tex=P%28i%29%3D%5Cdfrac+%7Bn_i%7D+%7BN%7D\" alt=\"P(i)=\\dfrac {n_i} {N}\" eeimg=\"1\"/> </p><p>图像的平均灰度级为 <img src=\"https://www.zhihu.com/equation?tex=%5Cmu+%3D+%5Csum%5Climits_%7Bi%3D0%7D%5E%7BL-1%7D+iP%28i%29\" alt=\"\\mu = \\sum\\limits_{i=0}^{L-1} iP(i)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>以阈值 k 将所有的像素分为目标和背景两类。其中 <img src=\"https://www.zhihu.com/equation?tex=C_0\" alt=\"C_0\" eeimg=\"1\"/> 类的像素灰度级为 0 到 k-1， <img src=\"https://www.zhihu.com/equation?tex=C_1\" alt=\"C_1\" eeimg=\"1\"/> 类的像素灰度级为 k 到 L-1。</p><p><img src=\"https://www.zhihu.com/equation?tex=C_0\" alt=\"C_0\" eeimg=\"1\"/> 类像素所占面积的比例为： <img src=\"https://www.zhihu.com/equation?tex=w_0+%3D+%5Csum%5Climits_%7Bi%3D0%7D%5E%7Bk-1%7D+P%28i%29\" alt=\"w_0 = \\sum\\limits_{i=0}^{k-1} P(i)\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=C_1\" alt=\"C_1\" eeimg=\"1\"/> 类像素所占面积的比例为： <img src=\"https://www.zhihu.com/equation?tex=w_1+%3D+1+-+w_0\" alt=\"w_1 = 1 - w_0\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=C_0\" alt=\"C_0\" eeimg=\"1\"/> 类像素的平均灰度为： <img src=\"https://www.zhihu.com/equation?tex=%5Cmu_0+%3D+%5Cmu_0+%28k%29+%2F+w_0\" alt=\"\\mu_0 = \\mu_0 (k) / w_0\" eeimg=\"1\"/> </p><p><img src=\"https://www.zhihu.com/equation?tex=C_1\" alt=\"C_1\" eeimg=\"1\"/> 类像素的平均灰度为： <img src=\"https://www.zhihu.com/equation?tex=%5Cmu_1+%3D+%5Cmu_1+%28k%29+%2F+w_1\" alt=\"\\mu_1 = \\mu_1 (k) / w_1\" eeimg=\"1\"/> </p><p>其中：<img src=\"https://www.zhihu.com/equation?tex=%5Cmu_0+%28k%29+%3D+%5Csum%5Climits_%7Bi%3D0%7D%5E%7Bk-1%7D+iP%28i%29\" alt=\"\\mu_0 (k) = \\sum\\limits_{i=0}^{k-1} iP(i)\" eeimg=\"1\"/> </p><p>​            <img src=\"https://www.zhihu.com/equation?tex=%5Cmu_1+%28k%29+%3D+%5Csum%5Climits_%7Bi%3Dk%7D%5E%7BL-1%7D+iP%28i%29+%3D+1+-+%5Cmu_0+%28k%29\" alt=\"\\mu_1 (k) = \\sum\\limits_{i=k}^{L-1} iP(i) = 1 - \\mu_0 (k)\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>则类间方差公式为： <img src=\"https://www.zhihu.com/equation?tex=%5Cdelta+%5E2%28k%29+%3D+w_0+%28%5Cmu+-+%5Cmu_0%29%5E2+%2B+w_1+%28%5Cmu+-+%5Cmu_1%29%5E2\" alt=\"\\delta ^2(k) = w_0 (\\mu - \\mu_0)^2 + w_1 (\\mu - \\mu_1)^2\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个方程把前景的信息和背景的信息结合在一起，然后令 k 从 0 到 L-1 变化，对图像的所有灰度等级的值进行计算，计算在不同 k 值下的类间方差，使得类间方差最大时的那个 k 值就是所要求的最优二值化阈值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们需要求取灰度直方图中两个双峰间的最低点，但不是所有的图像都一定存在双峰，或者双峰并不明显，或者存在多峰，这个时候就用 OTSU&#39;s 算法来求取最优阈值可能效果不是很好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>参考</p><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/c6b0d22aa2d7\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-154aed0662f09ac19b763cf320726fb5_180x120.jpg\" data-image-width=\"826\" data-image-height=\"299\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Python+OpenCV教程番外篇4：Otsu阈值法</a><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>如果觉得有用，点个赞吧(ง •̀_•́)ง。</p><p></p>", 
            "topic": [
                {
                    "tag": "图像处理", 
                    "tagLink": "https://api.zhihu.com/topics/19556376"
                }, 
                {
                    "tag": "二值化算法", 
                    "tagLink": "https://api.zhihu.com/topics/19592198"
                }
            ], 
            "comments": [
                {
                    "userName": "吉光片羽", 
                    "userLink": "https://www.zhihu.com/people/e83dc59dc39fa1119986817d946ca7d7", 
                    "content": "思想应该就是当图像像素值分布为双峰时，假设左峰对应图像A区域，右峰对应图像B区域，希望寻求一个threshold，使得整个图像区域均值距离A区域距离远且距离B图像距离远，此时，A区域和B区域均值距离远，也就找到一个较好的threshold", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "夏初", 
                    "userLink": "https://www.zhihu.com/people/c348df9f51a880b13fdeaf772ae7cd85", 
                    "content": "<p>借用了你文章里的图片，我会注明出处的。感谢</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>好的</p>", 
                            "likes": 0, 
                            "replyToAuthor": "夏初"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66277747", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 0, 
            "title": "图像基本运算", 
            "content": "<p>目录：</p><ol><li><b>点运算</b><br/><b>1.1、线性点运算</b><br/><b>1.2、分段线性点运算</b><br/><b>1.3、非线性点运算</b></li><li><b>代数运算</b><br/><b>2.1、加法运算</b><br/><b>2.2、减法运算</b></li><li><b>逻辑运算</b></li><li><b>几何运算</b><br/><b>4.1、图像平移(Translation)</b><br/><b>4.2、图像镜像(Mirror)</b><br/><b>4.3、图像旋转(Rotation)</b><br/><b>4.4、图像的缩放(Scale)</b></li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>按图像处理运算的数学特征, 图像基本运算可分为：</p><ul><li>点运算(Point Operation)</li><li>代数运算(Algebra Operation)</li><li>逻辑运算(Logical Operation)</li><li>几何运算(Geometric Operation)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>1、点运算</h3><p>点运算是指对一幅图像中每个像素点的灰度值按一定的映射关系进行运算。它与相邻的像素之间没有运算关系，不会改变图像内像素点之间的空间位置关系。根据映射关系的不同，点运算可以分为线性点运算和非线性点运算两类。</p><p>主要用于调整图像的亮暗程度和对比度。</p><p>设输入图像的灰度为 f(x,y)，输出图像的灰度为 g(x,y)，则点运算可以表示为：</p><p><img src=\"https://www.zhihu.com/equation?tex=g%28x%2C+y%29+%3D+T%5Bf%28x%2C+y%29%5D\" alt=\"g(x, y) = T[f(x, y)]\" eeimg=\"1\"/> </p><p>其中 <b>T[ ]</b> 是<b>灰度变换函数</b>，是对 f 在(x,y)点值的一种数学运算，即点运算是一种像素的逐点运算，是灰度到灰度的映射过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>若令 f(x,y) 和 g(x,y) 在任意点(x,y)的灰度级分别为 r 和 s，则灰度变换函数可简化表示为： <img src=\"https://www.zhihu.com/equation?tex=s+%3D+T%5B+r+%5D\" alt=\"s = T[ r ]\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-69587b17eb156869df4ba147566bb6d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"1123\" data-original=\"https://pic2.zhimg.com/v2-69587b17eb156869df4ba147566bb6d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1123&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1123\" data-original=\"https://pic2.zhimg.com/v2-69587b17eb156869df4ba147566bb6d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-69587b17eb156869df4ba147566bb6d1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当输出图像的灰度值的范围大于输入图像时，图像的对比度增加，如第一幅图所示；灰度变换函数也可以为非线性函数，如上面第二幅图，图像表现为整体变亮。</p><p>所以点运算可以改变图像数据所占据的灰度值范围，从而改善图像显示效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>点运算又称为“灰度变换”，按灰度变换函数 <b>T[ ]</b> 的性质，可将点运算分为：</p><ol><li>灰度变换增强<br/>1.1 线性灰度变换(线性点运算)<br/>1.2 分段线性灰度变换(分段线性点运算)<br/>1.3 非线性灰度变换(非线性点运算)</li><li>直方图增强（基于直方图处理的图像增强）</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.1、线性点运算</h3><p>线性点运算是指输入图像的灰度级与目标图像的灰度级呈线性关系。线性点运算的灰度 变换函数形式可以采用线性方程描述，即：</p><p><img src=\"https://www.zhihu.com/equation?tex=s+%3D+ar+%2B+b\" alt=\"s = ar + b\" eeimg=\"1\"/> </p><p>其中 r 为输入点的灰度值；s 为相应输出点的灰度值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p> a 用于调节对比度，a&gt;1，增加图像对比度（灰度值范围增大），0&lt;a&lt;1，减小图像对比度（灰度值范围减小）。</p><p>b 是一个平移项，对图像的整个灰度值进行平移，用于控制图像亮度。</p><p>如果 a 为负值，暗区域将变亮，亮区域将变暗。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6d92a636e5222f2068c8c44afc931cf2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic3.zhimg.com/v2-6d92a636e5222f2068c8c44afc931cf2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic3.zhimg.com/v2-6d92a636e5222f2068c8c44afc931cf2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6d92a636e5222f2068c8c44afc931cf2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.2、分段线性点运算</h3><p>上面是对政府图像进行同样的运算，我们也可以对不同的灰度值范围进行不同的运算。将感兴趣的灰度范围线性扩展，相对抑制不感兴趣的灰度区域。</p><p>设 f(x,y) 灰度范围为 <img src=\"https://www.zhihu.com/equation?tex=%5B0%2CM_f%5D\" alt=\"[0,M_f]\" eeimg=\"1\"/> ，g(x,y)灰度范围为 <img src=\"https://www.zhihu.com/equation?tex=%5B0%2CM_g%5D\" alt=\"[0,M_g]\" eeimg=\"1\"/> 。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1f12b12f4aecc0f945643769f604a28c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1201\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb\" width=\"1201\" data-original=\"https://pic1.zhimg.com/v2-1f12b12f4aecc0f945643769f604a28c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1201&#39; height=&#39;370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1201\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1201\" data-original=\"https://pic1.zhimg.com/v2-1f12b12f4aecc0f945643769f604a28c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1f12b12f4aecc0f945643769f604a28c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下图为分段线性点运算的应用：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c1a21aaa33df73eb1f3b04f601820b8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"759\" data-original=\"https://pic3.zhimg.com/v2-c1a21aaa33df73eb1f3b04f601820b8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;759&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"759\" data-original=\"https://pic3.zhimg.com/v2-c1a21aaa33df73eb1f3b04f601820b8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c1a21aaa33df73eb1f3b04f601820b8e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.3、非线性点运算</h3><p>非线性点运算的输出灰度级与输入灰度级呈非线性关系，常见的非线性灰度变换为对数变换和幂次变换。</p><p><b>1)、对数变换</b></p><p>对数变换的一般表达式为： <img src=\"https://www.zhihu.com/equation?tex=s+%3D+c%5C+log%281+%2B+r%29\" alt=\"s = c\\ log(1 + r)\" eeimg=\"1\"/> ，其中 c 是一个常数，用来控制图像对比度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-61f769cda8bac21503bc489055020775_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"324\" data-rawheight=\"291\" class=\"content_image\" width=\"324\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;324&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"324\" data-rawheight=\"291\" class=\"content_image lazy\" width=\"324\" data-actualsrc=\"https://pic2.zhimg.com/v2-61f769cda8bac21503bc489055020775_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图所示，低灰度区进行扩展，高灰度区进行压缩。表现为图像加亮、减暗。</p><p>非线性拉伸不是对图像的整个灰度范围进行扩展，而是有选择地对某一灰度值范围进行扩展，其他范围的灰度值则有可能被压缩。</p><p><b>2)、幂次变换</b></p><p>幂次变换的一般形式为： <img src=\"https://www.zhihu.com/equation?tex=s+%3D+c%5C+r%5E%5Cgamma\" alt=\"s = c\\ r^\\gamma\" eeimg=\"1\"/> ，其中 c 和 <img src=\"https://www.zhihu.com/equation?tex=%5Cgamma\" alt=\"\\gamma\" eeimg=\"1\"/> 为正常数。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e2dc8197c4bc392adcf98c6fdea647f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"331\" class=\"content_image\" width=\"355\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;355&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"331\" class=\"content_image lazy\" width=\"355\" data-actualsrc=\"https://pic2.zhimg.com/v2-e2dc8197c4bc392adcf98c6fdea647f5_b.jpg\"/></figure><ul><li><img src=\"https://www.zhihu.com/equation?tex=0+%3C+%5Cgamma+%3C+1\" alt=\"0 &lt; \\gamma &lt; 1\" eeimg=\"1\"/> ，加亮、减暗图像</li><li><img src=\"https://www.zhihu.com/equation?tex=%5Cgamma+%3E+1\" alt=\"\\gamma &gt; 1\" eeimg=\"1\"/> ，加暗、减亮图像</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>2、代数运算</h3><p>代数运算是指将两幅或多幅图像通过对应像素之间的加、减、乘、除运算得到输出图像的方法。</p><p>如果记输入图像为 A(x,y) 和 B(x,y)，输出图像为 C(x,y)，则代数运算有如下四种基本形式：</p><p><img src=\"https://www.zhihu.com/equation?tex=C%28x%2C+y%29+%3D+A%28x%2C+y%29+%2B+B%28x%2C+y%29+%5C%5C+C%28x%2C+y%29+%3D+A%28x%2C+y%29+-+B%28x%2C+y%29+%5C%5C+C%28x%2C+y%29+%3D+A%28x%2C+y%29+%5Ctimes+B%28x%2C+y%29+%5C%5C+C%28x%2C+y%29+%3D+A%28x%2C+y%29+%5Cdiv+B%28x%2C+y%29\" alt=\"C(x, y) = A(x, y) + B(x, y) \\\\ C(x, y) = A(x, y) - B(x, y) \\\\ C(x, y) = A(x, y) \\times B(x, y) \\\\ C(x, y) = A(x, y) \\div B(x, y)\" eeimg=\"1\"/> </p><h3>2.1、加法运算</h3><p>图像的加法运算主要用于：</p><ol><li>去除“叠加性”随机噪音</li><li>生成图像叠加效果</li></ol><p><b>去除“叠加性”随机噪音</b></p><p>对于原图象 f(x,y)，有一个噪音图像集 <img src=\"https://www.zhihu.com/equation?tex=%7B+g_i+%28x+%2Cy%29+%7D\" alt=\"{ g_i (x ,y) }\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=i+%3D1%2C2%2C...%2CM\" alt=\"i =1,2,...,M\" eeimg=\"1\"/> ，其中 <img src=\"https://www.zhihu.com/equation?tex=g_i+%28x+%2Cy%29+%3D+f%28x%2Cy%29+%2B+e_i%28x%2Cy%29\" alt=\"g_i (x ,y) = f(x,y) + e_i(x,y)\" eeimg=\"1\"/> 。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-259a57b23ad723702c6dc453b245c464_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"349\" data-rawheight=\"80\" class=\"content_image\" width=\"349\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;349&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"349\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"349\" data-actualsrc=\"https://pic1.zhimg.com/v2-259a57b23ad723702c6dc453b245c464_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>则 M 个图像的均值为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3eff6f57f71e84f3a7fc2e9368c5762f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"419\" data-rawheight=\"175\" class=\"content_image\" width=\"419\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;419&#39; height=&#39;175&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"419\" data-rawheight=\"175\" class=\"content_image lazy\" width=\"419\" data-actualsrc=\"https://pic4.zhimg.com/v2-3eff6f57f71e84f3a7fc2e9368c5762f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当噪声 <img src=\"https://www.zhihu.com/equation?tex=e_i%28x%2Cy%29\" alt=\"e_i(x,y)\" eeimg=\"1\"/> 为互不相关且均值为0，即图像被一组独立同分布、零均值高斯噪声所污染时，上述图象的均值将减弱噪声。</p><blockquote> 对于原图象 f(x,y)，有一个噪音图像集 <img src=\"https://www.zhihu.com/equation?tex=%7Bg_i%28x%2Cy%29%7D\" alt=\"{g_i(x,y)}\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=i%3D1%2C2...M\" alt=\"i=1,2...M\" eeimg=\"1\"/> ，其中： <img src=\"https://www.zhihu.com/equation?tex=g_i%28x%2Cy%29%3D+f%28x%2Cy%29+%2B+e_i%28x%2Cy%29\" alt=\"g_i(x,y)= f(x,y) + e_i(x,y)\" eeimg=\"1\"/> ，即混入噪声的图像=原始图像+随机噪声。M个图像的均值为： <img src=\"https://www.zhihu.com/equation?tex=g%28x%2Cy%29%3Df%28x%2Cy%29%2B%28e_1%2Be_2%2Be_3%2B...e_i%29%2FM\" alt=\"g(x,y)=f(x,y)+(e_1+e_2+e_3+...e_i)/M\" eeimg=\"1\"/> ，i=M。在求平均值的过程中，图像的静止部分不会改变，而由于图像的噪声是随机性的，各不相同的噪声图案积累的很慢，因此可以通过多幅图像求平均值来降低随机噪声的影响。每幅图像的噪声都来自于同一个互不相关且均值等于零的随机噪声，对多幅图像求平均，可以将噪声降低，得到的图像质量变得更好。<br/> </blockquote><p>此时 <img src=\"https://www.zhihu.com/equation?tex=%5Coverline+g%28x%2Cy%29\" alt=\"\\overline g(x,y)\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=f%28x%2Cy%29\" alt=\"f(x,y)\" eeimg=\"1\"/> 的无偏估计，即 <img src=\"https://www.zhihu.com/equation?tex=E%28%5C+%5Coverline+g%28x%2Cy%29%5C+%29%3Df%28x%2Cy%29\" alt=\"E(\\ \\overline g(x,y)\\ )=f(x,y)\" eeimg=\"1\"/> ，即多幅图像的均值的期望等于无噪声的静态图像。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>自然界中的噪声都是随机存在的，位置大小是会发生变化的，而要拍摄的景物是静态不变的，在非常短的时间内对同一景物拍摄多张照片，然后取平均值，就可以实现降噪的效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以可以利用同一景物的多幅图像取平均来得到一幅噪声减弱的新图像，一般选8幅取平均。</p><p>比如星空下的图像，会有很多噪声：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed16d3e60de17afa1f68bb62c74f730a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-ed16d3e60de17afa1f68bb62c74f730a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;220&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-ed16d3e60de17afa1f68bb62c74f730a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed16d3e60de17afa1f68bb62c74f730a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>生成图象叠加效果</b></p><p>通过加法运算可以得到各种图像合成的效果，也可以用于两张图片的衔接。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a5317c14e59c5cd493431140b93cf13c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb\" width=\"732\" data-original=\"https://pic1.zhimg.com/v2-a5317c14e59c5cd493431140b93cf13c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;732&#39; height=&#39;328&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"732\" data-original=\"https://pic1.zhimg.com/v2-a5317c14e59c5cd493431140b93cf13c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a5317c14e59c5cd493431140b93cf13c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.2、减法运算</h3><p>将同一景物在不同时间拍摄的图像或同一景物在不同波段的图像相减，这就是图像的减法运算。实际中常称为<b>差影法</b>。</p><p>差值图像提供了图像间的差值信息，能用于指导动态监测、运动目标的检测和跟踪、图像背景的消除及目标识别等。</p><p>主要应用举例:</p><ul><li>差影法(检测同一场景两幅图像之间的变化)</li><li>混合图像的分离</li><li>物体移动的检测</li><li>计算图像的梯度</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>差影法</b></p><p>检测同一场景两幅图像之间的变化，假设时刻1的图像为 T1(x, y)，时刻2的图像为 T2(x, y)，则差值为： <img src=\"https://www.zhihu.com/equation?tex=g%28x%2C+y%29+%3D+T2%28x%2C+y%29+-+T1%28x%2C+y%29\" alt=\"g(x, y) = T2(x, y) - T1(x, y)\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-27c3ddd31770dc1589ccfd6ecf12352b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb\" width=\"540\" data-original=\"https://pic4.zhimg.com/v2-27c3ddd31770dc1589ccfd6ecf12352b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;540&#39; height=&#39;161&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"540\" data-original=\"https://pic4.zhimg.com/v2-27c3ddd31770dc1589ccfd6ecf12352b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-27c3ddd31770dc1589ccfd6ecf12352b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>混合图像的分离</b></p><p>将两幅图像进行相减可以去除不需要的叠加性图案。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f412936cb69c1edf835251fa651f53c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic1.zhimg.com/v2-f412936cb69c1edf835251fa651f53c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic1.zhimg.com/v2-f412936cb69c1edf835251fa651f53c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f412936cb69c1edf835251fa651f53c0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>计算图像的梯度</b></p><p>其实就是求灰度的变化率，减法可以看做一种求导，即像素之间做减法可以得到图像的梯度。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3、逻辑运算</h3><p>逻辑运算是指将两幅或多幅图像通过对应像素之间的逻辑与、或、非运算得到输出图像的方法，其主要针对二值图像。</p><p>在进行图像理解与分析时比较有用。运用这种方法可以为图像提供模板，与其他运算方法结合起来可以获得某种特殊的效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4、几何运算</h3><p>几何运算就是改变图像中物体对象(像素)之间的空间关系。从变换性质来分，几何变换可以分为图像的位置变换(平移、镜像、旋转)、形状变换(放大、缩小)以及图像的复合变换等。</p><p>一个几何运算需要两个独立的算法。首先需要一个算法来定义空间变换，用它描述每个像素如何从其初始位置移动到终止位置，即每个像素的运动。其次，需要一个算法用于灰度级的插值。</p><p>图像几何运算的一般定义为：</p><p><img src=\"https://www.zhihu.com/equation?tex=g%28x%2C+y%29+%3D+f%28u%2C+v%29+%3D+f%28p%28x%2C+y%29%2C%5C+q%28x%2C+y%29%29\" alt=\"g(x, y) = f(u, v) = f(p(x, y),\\ q(x, y))\" eeimg=\"1\"/> </p><p>式中, u = p (x, y), v = q(x, y) 唯一地描述了空间变换，即将输入图像 f(u, v) 从 u-v 坐标系变换到 x-y 坐标系。也就是两个坐标系的线性变换，类似于矩阵乘法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.1、图像平移（Translation）</h3><p>图像的平移可以表示为如下形式： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+++%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+x_1+%3D+x_0+%2B+%5CDelta+x+%5C%5C+++y_1+%3D+y_0+%2B+%5CDelta+y+%5Cend%7Barray%7D+++%5Cright.+++%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{   \\begin{array}{**lr**} x_1 = x_0 + \\Delta x \\\\   y_1 = y_0 + \\Delta y \\end{array}   \\right.   \\end{equation}\" eeimg=\"1\"/> </p><p>以矩阵形式表示平移前后的像素关系为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_1+%5C%5C+y_1+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+1+%26+0+%26+%5CDelta+x+%5C%5C+0+%26+1+%26+%5CDelta+y+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x_1 \\\\ y_1 \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} 1 &amp; 0 &amp; \\Delta x \\\\ 0 &amp; 1 &amp; \\Delta y \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c6010dafbd36f11c2f5d318d21e2961c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"256\" class=\"content_image\" width=\"314\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;314&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"256\" class=\"content_image lazy\" width=\"314\" data-actualsrc=\"https://pic1.zhimg.com/v2-c6010dafbd36f11c2f5d318d21e2961c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.2、图像镜像(Mirror)</h3><p>指原始图像相对于某一参照面旋转180°的图像。镜像变换可以分为水平对称、垂直对称等多种变换。对称变换后，图像的宽和高不变。</p><p>设原始图像的宽为 w，高为 h，原始图像中的点为 (x0, y0)，对称变换后的点为 (x1, y1)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>(1) <b>水平镜像</b> (相对于 y 轴翻转)：</p><p>图像的水平镜像的变换公式如下： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+x_1+%3D+-x_0+%2B+w+%5C%5C+++y_1+%3D+y_0+%5Cend%7Barray%7D+++%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**lr**} x_1 = -x_0 + w \\\\   y_1 = y_0 \\end{array}   \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>就是保持 y 坐标不变，x 坐标取反，然后整个图像向 x 轴正方向平移 w 个像素回到原位。</p><p>以矩阵形式表示水平镜像前后的像素关系为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_1+%5C%5C+y_1+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+-1+%26+0+%26+w+%5C%5C+0+%26+1+%26+0+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x_1 \\\\ y_1 \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} -1 &amp; 0 &amp; w \\\\ 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>(2) <b>垂直镜像</b> (相对于 x 轴翻转)：</p><p>图像的垂直镜像的变换公式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+x_1+%3D+x_0+%5C%5C+++y_1+%3D+-y_0+%2B+h+%5Cend%7Barray%7D+++%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**lr**} x_1 = x_0 \\\\   y_1 = -y_0 + h \\end{array}   \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>就是保持 x 坐标不变，y 坐标取反，然后整个图像向 y 轴正方向平移 h 个像素回到原位。</p><p>以矩阵形式表示垂直镜像前后的像素关系为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_1+%5C%5C+y_1+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+1+%26+0+%26+0+%5C%5C+0+%26+-1+%26+h+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x_1 \\\\ y_1 \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} 1 &amp; 0 &amp; 0 \\\\ 0 &amp; -1 &amp; h \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><p>下面这幅图表示了水平镜像和垂直镜像后没有平移的情况。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-93607501b1101820a752d84e26e9544e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb\" width=\"592\" data-original=\"https://pic3.zhimg.com/v2-93607501b1101820a752d84e26e9544e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;592&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"592\" data-original=\"https://pic3.zhimg.com/v2-93607501b1101820a752d84e26e9544e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-93607501b1101820a752d84e26e9544e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.3、图像旋转(Rotation)</h3><p>一般情况下图像的旋转是以图像的中心为原点，旋转一定的角度，即将图像上的所有像素都旋转一个相同的角度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-caebf7fbddd267e5b0059a5c8e806bbc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"292\" class=\"content_image\" width=\"328\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;328&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"292\" class=\"content_image lazy\" width=\"328\" data-actualsrc=\"https://pic1.zhimg.com/v2-caebf7fbddd267e5b0059a5c8e806bbc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>设原始图像的任意点 <img src=\"https://www.zhihu.com/equation?tex=A_0%28x_0%2C%5C+y_0%29\" alt=\"A_0(x_0,\\ y_0)\" eeimg=\"1\"/> ，经旋转角度 <img src=\"https://www.zhihu.com/equation?tex=%5Cbeta\" alt=\"\\beta\" eeimg=\"1\"/> 以后到新的位置 <img src=\"https://www.zhihu.com/equation?tex=A%28x%2C%5C+y%29\" alt=\"A(x,\\ y)\" eeimg=\"1\"/> ，为表示方便，采用极坐标形式来表示旋转，原始的角度为 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> ，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2a1f6032d24c3d6be49983d80a2e38e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"190\" class=\"content_image\" width=\"271\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;271&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"190\" class=\"content_image lazy\" width=\"271\" data-actualsrc=\"https://pic1.zhimg.com/v2-2a1f6032d24c3d6be49983d80a2e38e0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>原始图像点 <img src=\"https://www.zhihu.com/equation?tex=A_0%28x_0%2C%5C+y_0%29\" alt=\"A_0(x_0,\\ y_0)\" eeimg=\"1\"/> 的坐标为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+x_0+%3D+r+%5Ccos+%5Calpha+%5C%5C+++y_0+%3D+r+%5Csin+%5Calpha+%5Cend%7Barray%7D+++%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**lr**} x_0 = r \\cos \\alpha \\\\   y_0 = r \\sin \\alpha \\end{array}   \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>旋转到新位置以后点 <img src=\"https://www.zhihu.com/equation?tex=A%28x%2C%5C+y%29\" alt=\"A(x,\\ y)\" eeimg=\"1\"/> 的坐标如下为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Alr%2A%2A%7D+x+%3D+r+%5Ccos+%28%5Calpha+-+%5Cbeta%29+%3D+r+%5Ccos+%5Calpha+%5Ccos+%5Cbeta+%2B+r+%5Csin+%5Calpha+%5Csin+%5Cbeta+%5C%5C+++y+%3D+r+%5Csin+%28%5Calpha+-+%5Cbeta%29+%3D+r+%5Csin+%5Calpha+%5Ccos+%5Cbeta+-+r+%5Ccos+%5Calpha+%5Csin+%5Cbeta+%5Cend%7Barray%7D+%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**lr**} x = r \\cos (\\alpha - \\beta) = r \\cos \\alpha \\cos \\beta + r \\sin \\alpha \\sin \\beta \\\\   y = r \\sin (\\alpha - \\beta) = r \\sin \\alpha \\cos \\beta - r \\cos \\alpha \\sin \\beta \\end{array} \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>所以：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Al%2A%2A%7D+x+%3D+x_0+%5Ccos+%5Cbeta+%2B+y_0+%5Csin+%5Cbeta+%5C%5C+++y+%3D+-x_0+%5Csin+%5Cbeta+%2B+y_0+%5Ccos+%5Cbeta+%5Cend%7Barray%7D+%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**l**} x = x_0 \\cos \\beta + y_0 \\sin \\beta \\\\   y = -x_0 \\sin \\beta + y_0 \\cos \\beta \\end{array} \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>以矩阵形式表示图像旋转前后的像素关系为： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x+%5C%5C+y+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+%5Ccos+%5Cbeta+%26+%5Csin+%5Cbeta+%26+0+%5C%5C+-+%5Csin+%5Cbeta+%26+%5Ccos+%5Cbeta+%26+0+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x \\\\ y \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} \\cos \\beta &amp; \\sin \\beta &amp; 0 \\\\ - \\sin \\beta &amp; \\cos \\beta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><p>若图像旋转角  <img src=\"https://www.zhihu.com/equation?tex=%5Cbeta%3D45\" alt=\"\\beta=45\" eeimg=\"1\"/> 时，则变换关系如下： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Al%2A%2A%7D+x+%3D+0.707%5C+x_0+%2B+0.707%5C+y_0+%5C%5C+++y+%3D+-0.707%5C+x_0+%2B+0.707%5C+y_0+%5Cend%7Barray%7D+%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**l**} x = 0.707\\ x_0 + 0.707\\ y_0 \\\\   y = -0.707\\ x_0 + 0.707\\ y_0 \\end{array} \\right. \\end{equation}\" eeimg=\"1\"/> </p><p> 这样图像旋转之后，由于数字图像的坐标值必须是整数，因此可能引起图像部分像素点的局部改变，这时图像的大小也会发生一定的改变。</p><p>上述的旋转是绕坐标轴原点 (0,0) 进行的，如果是绕某一个指定点 (a,b) 旋转，则先要将坐标系平移到该点，再进行旋转，然后将旋转后的图像平移回原坐标系。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>利用公式进行图像旋转正变换时需要注意如下两点：</p><ol><li>为了避免图像信息的丢失，图像旋转后必须进行平移变换。</li><li>图像旋转之后，会出现许多空缺区域，如下图所示。我们需要对这些空缺区域进行填充处理，一般也称这种操作为插值处理，可采用行或列插值方法。最简单的插值方法是，图像旋转前某一点 (x, y) 的像素点颜色，除了填充在旋转后的坐标 (x&#39;, y&#39;) 上，还要填充点 (x&#39;+1, y&#39;) 和 (x&#39;, y&#39;+1) 上。</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-564dbb608de476e0fedba366e7cdefa8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"181\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;181&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"181\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic1.zhimg.com/v2-564dbb608de476e0fedba366e7cdefa8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>比如图像旋转  <img src=\"https://www.zhihu.com/equation?tex=%5Cbeta%3D45\" alt=\"\\beta=45\" eeimg=\"1\"/> 时，变换关系如下： </p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Al%2A%2A%7D+x+%3D+0.707%5C+x_0+%2B+0.707%5C+y_0+%5C%5C+++y+%3D+-0.707%5C+x_0+%2B+0.707%5C+y_0+%5Cend%7Barray%7D+%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**l**} x = 0.707\\ x_0 + 0.707\\ y_0 \\\\   y = -0.707\\ x_0 + 0.707\\ y_0 \\end{array} \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>以原始图像的点 (1,1) 为例，旋转以后，均为小数，经舍入后为 (1,0)，产生了位置误差。因此，图像旋转之后，可能会出现一些空白点，需要对这些空白点进行灰度级的插值处理，否则影响旋转后的图像质量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图像旋转之后也可以根据新点求解原始点的坐标，其矩阵表示形式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x+%5C%5C+y+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+%5Ccos+%5Cbeta+%26+-%5Csin+%5Cbeta+%26+0+%5C%5C+%5Csin+%5Cbeta+%26+%5Ccos+%5Cbeta+%26+0+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x \\\\ y \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} \\cos \\beta &amp; -\\sin \\beta &amp; 0 \\\\ \\sin \\beta &amp; \\cos \\beta &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.4、图像的缩放</h3><p>数字图像的比例缩放是指将给定的图像在 x 方向和 y 方向按相同的比例 a 进行缩放，从而获得一幅新的图像，又称为全比例缩放。如果 x 方向和 y 方向缩放的比例不同，则图像的比例缩放会改变原始图像像素间的相对位置，产生几何畸变。</p><p>设原始图像中的点 A0 (x0, y0) 比例缩放后,在新图中的对应点为 A1(x1, y1)，则 A0(x0, y0) 和 A1(x1, y1) 之间坐标关系可表示如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Bequation%7D+++%5Cleft%5C%7B+%5Cbegin%7Barray%7D%7B%2A%2Al%2A%2A%7D+x_1+%3D+a+x_0+%5C%5C+++y_1+%3D+a+y_0+%5Cend%7Barray%7D+%5Cright.+%5Cend%7Bequation%7D\" alt=\"\\begin{equation}   \\left\\{ \\begin{array}{**l**} x_1 = a x_0 \\\\   y_1 = a y_0 \\end{array} \\right. \\end{equation}\" eeimg=\"1\"/> </p><p>以矩阵形式表示缩放前后的像素关系为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_1+%5C%5C+y_1+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D+%3D++%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+a+%26+0+%26+0+%5C%5C+0+%26+a+%26+0+%5C%5C+0+%26+0+%26+1+%5Cend%7Barray%7D%5Cright%5D+%5Cleft%5B%5Cbegin%7Barray%7D%7Bccc%7D+x_0+%5C%5C+y_0+%5C%5C+1+%5Cend%7Barray%7D%5Cright%5D\" alt=\"\\left[\\begin{array}{ccc} x_1 \\\\ y_1 \\\\ 1 \\end{array}\\right] =  \\left[\\begin{array}{ccc} a &amp; 0 &amp; 0 \\\\ 0 &amp; a &amp; 0 \\\\ 0 &amp; 0 &amp; 1 \\end{array}\\right] \\left[\\begin{array}{ccc} x_0 \\\\ y_0 \\\\ 1 \\end{array}\\right]\" eeimg=\"1\"/> </p><p>若 a &gt;1，则图像被放大；若 a &lt;1，则图像被缩小。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>若比例缩放所产生的图像中的像素在原图像中没有相对应的像素点时，就需要进行灰度级的插值运算，一般有以下两种插值处理方法。</p><ol><li>直接赋值为和它最邻近的像素的灰度值，这种方法称为最近邻插值法，该方法简单、计算量小，但很可能会产生马赛克现象。</li><li>通过其他数学插值算法来计算相应像素点的灰度值（比如双线性插值法和 3次内插法），这类方法处理效果好，但运算量会有所增加。</li></ol><p></p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65736195", 
            "userName": "z.defying", 
            "userLink": "https://www.zhihu.com/people/2b93b7b2dd2c18ad2a6ac2e3c2962296", 
            "upvote": 2, 
            "title": "数字图像处理基础", 
            "content": "<p></p><p><b>目录：</b></p><p><b>1、图像的采样与量化</b></p><p><b>2、图像文件的类型</b></p><p><b>3、像素间的关系</b></p><p><b>4、距离度量</b></p><p><b>5、图像的质量</b><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>一幅图像可以被定义为一个二维函数 <code>f(x，y)</code>，其中 x 和 y 是空间(平面)坐标，f 在任何坐标处(x，y)处的振幅称为图像在该点的亮度。灰度表示黑白图像的亮度，而彩色图像是由三个二维图像组合形成的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如在 RGB 彩色系统中，一幅彩色图像是由三幅独立的分量图像(红、绿、蓝)组成的。因此，许多为黑白图像处理开发的技术适用于彩色图像处理，方法是分别处理三幅独立的分量图像即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>1、图像的采样与量化</h3><p><b>图像数字化</b>：将代表图像的连续(模拟)信号转换为离散(数字)信号的过程称为图像数字化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>包括采样和量化两个步骤：</p><ul><li><b>采样（sampling）</b>：数字化坐标，将空间上连续的图像变换成离散点的操作，用空间上部分点的灰度值代表图像，这些点称为采样点。对同一幅图像采样间隔越小，所得图像像素(Pixel)越多，图像的空间分辨率越高，图像细节越清晰，但文件尺寸大，处理时间长，对设备的要求高。</li><li><b>量化（quantitization）</b>：数字化振幅，对采样点亮度(灰度)值的离散化过程，确定了图像的灰(幅)度等级。一般说的都是均匀量化，即将样点灰度级值等间隔分档取整。随着灰度等级的减少，图像的细节信息在逐渐损失，伪轮廓信息在逐渐增加，图像的视觉效果越差。图中由于伪轮廓信息的积累，图像已显现出了木刻画的效果。</li></ul><p>注：分辨率就是单位长度上采样的像素个数 DPI (dot/inch)，也就是对模拟图像进行数字化采样时的网格大小。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当 f 的 x、y 分量和振幅都是有限且离散的量时，称该图像为数字图像。采样和量化的过程如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1e5365d8bf15d2474af0fb4764d103ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"577\" data-original=\"https://pic4.zhimg.com/v2-1e5365d8bf15d2474af0fb4764d103ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;577&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"577\" data-original=\"https://pic4.zhimg.com/v2-1e5365d8bf15d2474af0fb4764d103ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1e5365d8bf15d2474af0fb4764d103ff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图像空间分辨率变化所产生的效果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9ceeefa541e948a1b2a4eae5ae485873_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-9ceeefa541e948a1b2a4eae5ae485873_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-9ceeefa541e948a1b2a4eae5ae485873_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9ceeefa541e948a1b2a4eae5ae485873_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图像灰度分辨率变化所产生的效果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-444eec7fed3184e6bcda5411bbbbf043_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"870\" data-original=\"https://pic4.zhimg.com/v2-444eec7fed3184e6bcda5411bbbbf043_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;870&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"870\" data-original=\"https://pic4.zhimg.com/v2-444eec7fed3184e6bcda5411bbbbf043_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-444eec7fed3184e6bcda5411bbbbf043_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由上面两个图可以得知量化等级越多，所得图像层次越丰富，灰度分辨率高，图像质量好，但数据量大；量化等级越少，图像层次欠丰富，灰度分辨率低，会出现假轮廓现象，图像质量变差，但数据量小。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>采样和量化的级数，假定图像取M×N个采样点（列数为M，行数为N），对灰度值进行G级分档取整。M, N, G 一般取2的整数次幂。其中M，N和G分别为： <img src=\"https://www.zhihu.com/equation?tex=M%3D2%5Em%2C+N%3D2%5En%2C+G%3D2%5Ek\" alt=\"M=2^m, N=2^n, G=2^k\" eeimg=\"1\"/> ，则图像所需的位数为： <img src=\"https://www.zhihu.com/equation?tex=M+%5Ctimes+N+%5Ctimes+k\" alt=\"M \\times N \\times k\" eeimg=\"1\"/> 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图像数字化用到的技术：</p><ul><li>采样：成像技术（光信息-&gt;电信号）</li><li>量化：模数转换(A/D Converter)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h3>2、图像文件的类型</h3><p class=\"ztext-empty-paragraph\"><br/></p><p>位图是通过许多像素点表示一幅图像，每个像素具有颜色属性和位置属性。可以从传统的相片、幻灯片上制作出来或使用数字相机得到。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>位图分成如下四种：二值图像 (binary images)、亮度图像 (intensity images)、索引图像(indexed images)和RGB图像(RGB images)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>(1) 二值图像 一幅二值图像是一个像素取值只有 0 和 1 的逻辑数组，只有黑白两种颜色。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-017d5c74b790e0c9cc8d9850c35b41a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic1.zhimg.com/v2-017d5c74b790e0c9cc8d9850c35b41a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic1.zhimg.com/v2-017d5c74b790e0c9cc8d9850c35b41a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-017d5c74b790e0c9cc8d9850c35b41a4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>(2) 亮度图像 一幅灰度图像是一个数据矩阵，像素灰度级（gray level）为8，每个像素都是介于黑色(0)和白色(255)之间的256种灰度中的一种。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6f9b50b66b19a9862cf4a5af4e28559e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"453\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"453\" data-original=\"https://pic3.zhimg.com/v2-6f9b50b66b19a9862cf4a5af4e28559e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;453&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"453\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"453\" data-original=\"https://pic3.zhimg.com/v2-6f9b50b66b19a9862cf4a5af4e28559e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6f9b50b66b19a9862cf4a5af4e28559e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>(3) RGB 图像 一幅 RGB 图像就是彩色像素的一个 M×N×3 数组，其中每一个彩色像素点都是在特定空间位置的彩色图像相对应的红、绿、蓝三个分量。按照惯例，形成一幅 RGB 彩色图像的三个灰度图像常称为红、绿或蓝分量图像。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b118842df4344b2d5a712eab383817af_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"593\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb\" width=\"593\" data-original=\"https://pic4.zhimg.com/v2-b118842df4344b2d5a712eab383817af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;593&#39; height=&#39;565&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"593\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"593\" data-original=\"https://pic4.zhimg.com/v2-b118842df4344b2d5a712eab383817af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b118842df4344b2d5a712eab383817af_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3、像素间的关系</h3><p>做图像分割时通常会考虑像素间的关系，同类物体的像素具有一定的相似性。</p><p>图像由像素组成，像素在图像空间上按规律排列，相互之间有一定的联系。图像像素间的关系主要是讨论了邻接、连通及距离等概念。</p><ul><li>像素的邻域与连接</li><li>连通性</li><li>距离度量</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>邻域</b>：</p><ol><li>4-邻域 —— <img src=\"https://www.zhihu.com/equation?tex=N_4%28p%29\" alt=\"N_4(p)\" eeimg=\"1\"/> ：中心像素与其上下左右四个相邻像素之间的关系。p(x, y)：(x+1, y); (x-1, y); (x, y+1); (x, y-1)</li><li>对角邻域 —— <img src=\"https://www.zhihu.com/equation?tex=N_D%28p%29\" alt=\"N_D(p)\" eeimg=\"1\"/> ：中心像素与其四个斜对角像素之间的关系。p(x, y)：(x-1, y-1); (x+1, y-1); (x-1, y+1); (x+1, y+1)</li><li>8-邻域 —— <img src=\"https://www.zhihu.com/equation?tex=N_8%28p%29\" alt=\"N_8(p)\" eeimg=\"1\"/> ：4邻域和对角邻域的合并</li></ol><p>下面三个图分别表示4-邻域，对角邻域和8-邻域：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-51c986cb5943aa7470869a75350a21d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"477\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb\" width=\"477\" data-original=\"https://pic1.zhimg.com/v2-51c986cb5943aa7470869a75350a21d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;477&#39; height=&#39;161&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"477\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"477\" data-original=\"https://pic1.zhimg.com/v2-51c986cb5943aa7470869a75350a21d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-51c986cb5943aa7470869a75350a21d4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>连接</b>：</p><p>邻域仅考虑像素间的空间关系，连接则要求空间上是邻域且像素灰度值相似，所以判断两个像素是否连接：</p><ol><li>是否接触(邻域)</li><li>灰度值是否满足某个特定的相似准则（灰度值相等或同属于一个灰度值区间）</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>连接也分为三种（V 为灰度值集合，假设 V={1} ）：</p><p><b>4-连接</b></p><p>2个像素 p 和 r 的灰度值在 V 集合中，且 r 在 <img src=\"https://www.zhihu.com/equation?tex=N_4%28p%29\" alt=\"N_4(p)\" eeimg=\"1\"/> 中，那么称像素 p 和 q 是4-连接的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5cfe49c7466e752d5bfbeb4355a5dff6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"188\" data-rawheight=\"187\" class=\"content_image\" width=\"188\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;188&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"188\" data-rawheight=\"187\" class=\"content_image lazy\" width=\"188\" data-actualsrc=\"https://pic3.zhimg.com/v2-5cfe49c7466e752d5bfbeb4355a5dff6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>8-连接</b></p><p>2个像素 p 和 r 的灰度值在 V 集合中，且 r 在 <img src=\"https://www.zhihu.com/equation?tex=N_8%28p%29\" alt=\"N_8(p)\" eeimg=\"1\"/> 中，那么称像素 p 和 q 是8-连接的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-dace0a7ce8a4a7fc646453343d47699c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"186\" data-rawheight=\"187\" class=\"content_image\" width=\"186\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;186&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"186\" data-rawheight=\"187\" class=\"content_image lazy\" width=\"186\" data-actualsrc=\"https://pic1.zhimg.com/v2-dace0a7ce8a4a7fc646453343d47699c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>m-连接(混合连接)</b></p><p>2个像素 p 和 r 的灰度值在 V 集合中，且需要满足下列条件之一：</p><ul><li>r 在 <img src=\"https://www.zhihu.com/equation?tex=N_4%28p%29\" alt=\"N_4(p)\" eeimg=\"1\"/> 中，或者</li><li>r 在 <img src=\"https://www.zhihu.com/equation?tex=N_D%28p%29\" alt=\"N_D(p)\" eeimg=\"1\"/> 中，且集合 <img src=\"https://www.zhihu.com/equation?tex=N_4%28p%29+%5Ccap+N_4%28r%29\" alt=\"N_4(p) \\cap N_4(r)\" eeimg=\"1\"/> 是空集（交集内的像素的灰度值都不在 V 中）</li></ul><p>可以看做是4连通和D连通的混合连通。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>混合连接时，当像素间同时存在4-连接和8-连接时，优先采用4-连接，即屏蔽和同一像素间存在4-连接的两个像素之间的8-连接。</p><p>这句话有点拗口，可以看下面这个8-连接图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-be58c7fa68220b5df8f0a5620aa5a4e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"176\" data-rawheight=\"155\" class=\"content_image\" width=\"176\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;176&#39; height=&#39;155&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"176\" data-rawheight=\"155\" class=\"content_image lazy\" width=\"176\" data-actualsrc=\"https://pic4.zhimg.com/v2-be58c7fa68220b5df8f0a5620aa5a4e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第二个1和第三个1都与第一个1是4-连接关系，同时第二个1和第三个1还是8-连接关系，避免重复就可以剔除掉这两者的8-连接关系。</p><p>m-连接是8连接的改进版，为了消除8-连接的二义性。即8-连接在像素距离的选择时有多种路径，引发歧义，而m-连接则没有。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图就是m-连接图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-61944d33de89047a56a716318e479219_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"154\" class=\"content_image\" width=\"177\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;177&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"154\" class=\"content_image lazy\" width=\"177\" data-actualsrc=\"https://pic2.zhimg.com/v2-61944d33de89047a56a716318e479219_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>连通性</b></p><p>通路：像素 p(x, y) 到像素 q(s, t) 的一条通路由一系列具有坐标 <img src=\"https://www.zhihu.com/equation?tex=%28x_0%2C+y_0%29%2C+%28x_1%2C+y_1%29+%2C...%2C+%28x_i%2C+y_i%29+%2C...%2C+%28x_n%2C+y_n%29\" alt=\"(x_0, y_0), (x_1, y_1) ,..., (x_i, y_i) ,..., (x_n, y_n)\" eeimg=\"1\"/> 的独立像素组成。这里 <img src=\"https://www.zhihu.com/equation?tex=%28x_i%2C+y_i%29\" alt=\"(x_i, y_i)\" eeimg=\"1\"/> 与 <img src=\"https://www.zhihu.com/equation?tex=%28x_%7Bi-1%7D%2C+y_%7Bi-1%7D%29\" alt=\"(x_{i-1}, y_{i-1})\" eeimg=\"1\"/> 具有邻接关系。其中1≤i≤n，n为通路长度。通路分为4-通路和8-通路。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>连通性反映两个像素间的空间关系，通路上的所有像素灰度值均满足相似准则，即两个像素具有连接关系。所以连通和连接一样分为三类：4-连通、8-连通和m-连通。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如下图，从 s 像素到 t 像素不存在4-连通，有两条8-连通，一条m-连通。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f1d623d26b45aa97bbe354e8f7f5a07e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"255\" data-rawheight=\"171\" class=\"content_image\" width=\"255\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;255&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"255\" data-rawheight=\"171\" class=\"content_image lazy\" width=\"255\" data-actualsrc=\"https://pic3.zhimg.com/v2-f1d623d26b45aa97bbe354e8f7f5a07e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4、距离度量</h3><p class=\"ztext-empty-paragraph\"><br/></p><p>像素之间的联系常与像素在空间的接近程度有关。像素在空间的接近程度可以用像素之间的距离来度量。为测量距离需要定义距离度量函数。对于像素 p, q 和 z，分别具有坐标 (x, y), (s, t ), (u, v)，如果满足下面三个条件：</p><ol><li>D (p, q) ≥0，[D (p, q)= 0, 当且仅当 p=q ]</li><li>D (p, q) = D (q, p)</li><li>D (p, z) ≤ D (p , q) + D (q, z)</li></ol><p>则 D 是距离函数或度量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图像中常用的有三个距离函数，欧氏距离，城市距离(D4距离)和棋盘距离(D8距离)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4.1、<b>欧式距离</b></p><p>p 和 q 之间的欧式距离定义为： <img src=\"https://www.zhihu.com/equation?tex=D_e%28p%2C+q%29+%3D+%5Csqrt+%7B%28x-s%29%5E2+%2B+%28y-t%29%5E2%7D\" alt=\"D_e(p, q) = \\sqrt {(x-s)^2 + (y-t)^2}\" eeimg=\"1\"/> </p><p>根据这个距离度量，与点 (x , y) 的 De 距离小于或等于某一值 d 的所有像素组成一个以 (x, y ) 为中心，以 d 为半径的圆。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4.2、<b>城市距离</b></p><p>p 和 q 之间的 D4 距离(也称城市街区距离)定义为： <img src=\"https://www.zhihu.com/equation?tex=D_4%28p%2C+q%29+%3D+%7Cx-s%7C+%2B+%7Cy-t%7C\" alt=\"D_4(p, q) = |x-s| + |y-t|\" eeimg=\"1\"/> </p><p>根据这个距离度量，与点 (x, y) 的 D4 距离小于或等于某一值 d 的所有像素组成以 (x, y) 为中心的菱形。</p><p>与中心点的城市距离 <img src=\"https://www.zhihu.com/equation?tex=D4+%5Cleq+2\" alt=\"D4 \\leq 2\" eeimg=\"1\"/> 的所有像素所构成的菱形如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eee81a41220b35fd11fcc55198cb0b40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"280\" class=\"content_image\" width=\"281\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;281&#39; height=&#39;280&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"280\" class=\"content_image lazy\" width=\"281\" data-actualsrc=\"https://pic1.zhimg.com/v2-eee81a41220b35fd11fcc55198cb0b40_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4.3、<b>棋盘距离</b></p><p>p 和 q 之间的 D8 距离(也称棋盘距离)定义为： <img src=\"https://www.zhihu.com/equation?tex=D_8%28p%2C+q%29+%3D+max%28%7Cx-s%7C%2C+%7Cy-t%7C%29\" alt=\"D_8(p, q) = max(|x-s|, |y-t|)\" eeimg=\"1\"/> </p><p>根据这个距离度量，与点 (x, y) 的 D8 距离小于或等于某一值 d 的所有像素组成以 (x, y) 为中心的方形。</p><p>与中心点的棋盘距离 <img src=\"https://www.zhihu.com/equation?tex=D8+%5Cleq+2\" alt=\"D8 \\leq 2\" eeimg=\"1\"/> 的所有像素所构成的方形如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d2fae72a6118fc8d118269209142629a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"283\" class=\"content_image\" width=\"283\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;283&#39; height=&#39;283&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"283\" class=\"content_image lazy\" width=\"283\" data-actualsrc=\"https://pic3.zhimg.com/v2-d2fae72a6118fc8d118269209142629a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>5、图像的质量</h3><p>评价图像的好坏通常考虑这样几个方面：图像的层次、图像的对比度以及图像的清晰度。</p><ul><li>图像的层次以图像的灰度级来表示，它是像素明暗程度的整数量，例如：像素的取值范围为0~255，就称该图像为 256 个灰度级的图像，或该图像具有 256 个层次，图像的实际层次越多，视觉效果就越好。</li><li>图像的对比度是指一幅图像中灰度反差的大小，通常表示为：对比度=最大亮度/最小亮度。</li><li>图像的清晰度主要有：亮度、对比度、尺寸大小、细微层次以及颜色饱和度。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>注：本文的图均来自武汉理工大学的 <a href=\"https://link.zhihu.com/?target=https%3A//www.icourse163.org/course/WHUT-1003535158\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数字图像处理课程</a>。</p>", 
            "topic": [
                {
                    "tag": "数字图像处理（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20735727"
                }
            ], 
            "comments": [
                {
                    "userName": "吉光片羽", 
                    "userLink": "https://www.zhihu.com/people/e83dc59dc39fa1119986817d946ca7d7", 
                    "content": "<p>需要注意的是，p 和 q 之间的 D4 和 D8 距离与任何通路无关。然而对于 m-连通，两点之间的 Dm 距离(通路的长度)将依赖于沿通路的像素及它们近邻像素的值。请问您这句话该怎么理解呢？距离计算公式给定的情况下，对于任意两点p,q，他们之间的距离就已经确定了，应该和任何通路无关吧，为什么要单独提D4和D8距离而没有欧几里得距离？后面这句是想说，在m联通时，计算通路的总长度(一步一步统计)依赖具体路线？因为可能存在多条路线？为什么专门提m联通？8联通，4联通也可能有多条路线啊</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>嗯对，两点之间的D4，D8和欧式距离都和通路无关，因为欧式距离比较常用就偷了个懒。还有4连通，8连通和m连通因为路线的不同，通路长度也都会不同。原文句话不是很严谨，多谢指出，我把这句话在原文中删除了，免得误导大家。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "吉光片羽"
                        }, 
                        {
                            "userName": "吉光片羽", 
                            "userLink": "https://www.zhihu.com/people/e83dc59dc39fa1119986817d946ca7d7", 
                            "content": "嗯嗯，谢谢回复，我这些天在读您的数字图像专栏，请问还有什么学习资源推荐吗？我想先整体认识，再逐个了解具体算法实现。", 
                            "likes": 0, 
                            "replyToAuthor": "吉光片羽"
                        }
                    ]
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/digital-image-processing"
}
