{
    "title": "互联网时代", 
    "description": "你们有想了解的所有关互联网的所有知识我都会在我的专栏上发布。", 
    "followers": [
        "https://www.zhihu.com/people/zhong-tian-lin-8", 
        "https://www.zhihu.com/people/yu-wen-62-94-16", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/stefan-hu-44", 
        "https://www.zhihu.com/people/churman-55", 
        "https://www.zhihu.com/people/danny-liu-49-25", 
        "https://www.zhihu.com/people/huan-hao-ba-92-1", 
        "https://www.zhihu.com/people/mei-shi-jian-21-76", 
        "https://www.zhihu.com/people/tao-zi-bu-da-la", 
        "https://www.zhihu.com/people/ezio-84-12", 
        "https://www.zhihu.com/people/johnsonsteven2", 
        "https://www.zhihu.com/people/xiang-lu-mao", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/yan-jiu-sheng-wang-jun-kai", 
        "https://www.zhihu.com/people/xiao-chen-52-31", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/li-yun-hui-88-14", 
        "https://www.zhihu.com/people/jiu-wei-ling-hu-7", 
        "https://www.zhihu.com/people/li-li-wei-40-45", 
        "https://www.zhihu.com/people/nex-91", 
        "https://www.zhihu.com/people/zhao-di-60-11", 
        "https://www.zhihu.com/people/wugengchaoji", 
        "https://www.zhihu.com/people/dui-die-94-72", 
        "https://www.zhihu.com/people/sheho-91", 
        "https://www.zhihu.com/people/liu-yan-31-34", 
        "https://www.zhihu.com/people/petertanujs", 
        "https://www.zhihu.com/people/ha-ha-ha-9-64-57", 
        "https://www.zhihu.com/people/lonston", 
        "https://www.zhihu.com/people/wen-sir-11-97", 
        "https://www.zhihu.com/people/dgc000224", 
        "https://www.zhihu.com/people/thetomtang"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/87207428", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "互联网的三大巨头 百度 阿里巴巴 腾讯（BAT)", 
            "content": "<p> 大家也都清楚现在互联网中三大巨头：百度、阿里巴巴、腾讯这三大巨头时不时的收购小型或大型软件公司等，在不断的庞大自己，下面来谈谈一些对互联网的三大巨头的看法。</p><p>如今的互联网投资圈，更像一个娱乐圈。时不时爆出三大互联网公司(百度、阿里、腾讯，英文缩写为BAT)又正在与谁亲密接触的“绯闻”。这样的小道消息传播很快，触动着这个从业人员的敏感神经。<br/>3月22日，互联网圈内有消息称，阿里将全资收购友盟。即便阿里、友盟官方死活不承认，但阿里以7000多万美元收购友盟已经是板上钉钉的事实。在 2011年6月的A轮融资中，友盟估值为5000万美元。而今是移动互联网融资低潮，被阿里收购还有溢价，在不少创业者眼里，友盟已算寻着了一个好归宿。</p><p>日前，投资圈的消息称，百度与阿里巴巴分别有10亿元以上的投资入股或者控股收购。虽然还未正式披露，但百度豪掷3.5亿美元来收购PPS已成事实，其目的是借助PPS的巨多用户，来分流爱奇艺的视频广告。</p><p>坊间亦传言称，百度与阿里巴巴都正在与高德地图接触，洽谈投资一事。高德软件拥有地图底层测绘资质，并且有过亿的用户数，移动互联网上的一些创新也颇具吸引力。</p><p>更早的投资并购传闻也会随波而来。每隔一断时间，不知道哪阵风刮起，百度与UC“联姻”一事，就会被拿出来炒一下。这是一对大家眼中业务互补、珠联璧合的“佳人”，却始终无缘牵手。据说是双方基本年年谈收购，但年年谈不拢。</p><p>无论有多少真相与谎言，绯闻与佳话，故事的主角总是他们——腾讯、阿里、百度。</p><p>10年创业艰难路，而今出路各不同。</p><p>10年前，互联网创业者的梦想是独立上市，那时候，大家都是虾兵蟹将，谁也吞并不了谁。如今，这个梦想可能离创业者越来越遥远，最好的出路可能是卖给某个互联网大佬。</p><p>卖掉的项目</p><p>2012年11月，创业不到一年，“今晚看啥”，一个做电影内容个性化搜索，就被百度以200万-300万美元的价格收购，两位从美国留学归来的创始人也被招至百度麾下，距离他们拿到徐小平的天使投资仅1年多时间。</p><p>成立3年的友盟，在即将迎来自己B轮融资的时节，接受了阿里巴巴7000多万美元的收购要约。公开的信息显示，目前，友盟笼络了3万个APP开发者，有 10多万个APP正在使用友盟的统计分析服务，在APP统计分析领域占据领先地位。而阿里巴巴也希望搭建一个平台，将开发者拢聚在其中。而那些统计工具，用户也愿意形成。</p><p>这样的投资一直层出不穷。一位互联网投资界人士告诉记者，爱奇艺收购PPS，腾讯投资嘀嘀打车，都已经基本确定。</p><p>由于移动互联网投融资泡沫的破裂，一些移动互联网创业项目也遭遇了“今不如惜”的状况。VC们也开始为这些项目寻找下家，以求自己减少损失，收回成本。</p><p>这其中，有些“悲催”的典型例子是点心。在创业公司做手机操作系统风生水起时，2011年3月，点心以1500万美元的估值获得金沙江领衔的A轮投资。而当手机操作系统被实践证明不会成为移动互联网第一入口后，点心的估值大幅缩水。据一名互联网投资界人士透露，2012年11月，点心被百度全资收购时，估价已降至1000万美元。</p><p>这位互联网投资界人士透露，由于估值下降，被百度收购后，点心的创始团队并没有获得多少收益，而金沙江、创新工场等投资人也只是收回了成本。</p><p>在不少互联网人看来，收购点心，百度当了“冤大头”，花1000万美元收购了一个已被证明不再是移动互联网入口级的产品。</p><p>一位不愿意透露名字的互联网界人士透露，百度收购点心更多是看中其团队能力。除此之外，OS虽然被证明不再是移动互联网的入口，但也并非一无是处，其可以与百度易平台融合，接入易平台。</p><p>据创新工场创始人兼管理合伙人汪华介绍，点心的“优化大师”日活跃用户在同类应用中居领先地位。而从手机应用的层级来划分，“优化大师”对手机的重要性仅次于安全类的应用，如360安全卫士。这样，点心的用户粘性就很强。不仅如此，接下来，越来越多的普通用户开始使用智能手机，深度定制的手机操作系统还会有一些机会。</p><p>“那些不错的移动互联网创业公司基本上都收到了大互联网公司的投资收购要约。”汪华称道，移动互联网创业，经过两三年，市场已经洗过一轮，那些剩下来的标的，都很不错，三大互联网公司投资或收购的意愿强。</p><p>在移动投资领域，不少项目是“狼多肉少”。百度、阿里、腾讯的投资部门都有过“暗抢”某一个创业项目的经历。</p><p>移动公司被收购的大多分为几种类型：看中技术实力，如“今晚看啥”;要么将其作为一个有用的平台，如友盟、点心。更多的是业务层面的投资，比如丁丁网、嘀嘀打车等服务，未来可以直接接入平台层，起到丰富应用的作用。</p><p>这些互联网公司在投资或收购时，看重的点也不一而同。“有的收购是为了产品，有的是为了技术，有的干脆就是为了人。” 一位互联网早期投资人士告诉记者。</p><p>“现在，这些大公司成熟了，开始有收购的意识。这波投资收购潮与互联网大公司的这种意识会互相促进。但相比硅谷，中国互联网界的收购还是太少了。”汪华举例称，在硅谷，获得天使或者A轮投资活下来的公司，有70%最后都是被大公司收购。而国内的互联网投资收购远没有达到这样的活跃程度。</p><p>从外界来看，一个公司达几千万美元的投资，或者亿级美元的收购，这也是一笔很大的支出。因为在中国的互联网史上，还史无前例。汪华认为，这相对于以后在移动互联网上的机会来说，这样的投入还是值得的。</p><p>“现在这些互联网公司不投就没有任何机会，投了才可能有机会。”汪华说，移动互联网爆发很快，新的应用层出不穷，而现在谁也不知道哪一个细分领域会有机会，所以，四处下注是正确的。现在花千万，或者亿级的美元来投资或收购，如果不做这些事情，那么将来可能损失的是一个大市场。</p><p>稀缺资源下的抉择</p><p>“一个不错的应用，我们通过微博导流量及少量的流量购买，将用户从零做到几十万的规模，不难。拿到融资之后，自己多努力努力，将用户从几十万做到几百万，也是可以做到的。但是将用户做到千万规模，对一个没有资源的创业公司来说，是一件难度很大的事情。”一位被百度收购的公司的创始人告诉记者，当初，公司也收到VC发的Term sheet(投资意向书)，但仔细考虑之后，还是觉得要想将这件事情做大，需要更多的资源，于是他们最终选择投身巨头。</p><p>他道出了不少移动互联网创业者的心声——不仅需要钱，更需要资源，以便在同行者的竞争中取得优势。</p><p>用户数达百万与千万级别，是一个移动互联网创业公司要过的两道坎。顺利穿过这两道坎，需要消耗大量的心血，绝大多数的创业者都倒在了通往这两个目标的路上。</p><p>2012年刮起的移动互联网创业寒潮，让创业者感觉到这个冬天格外冷，基本上是“风萧萧兮易水寒，壮士一去兮不复返”。记者接触的不少手机游戏、APP 应用的开发者由于缺少资金，许多都开始接短、平、快的APP外包单，先把自己养活。也有不少的创业团队干脆集体跳槽，傍上BAT。</p><p>互联网资本遇冷的情况，也引起了那些在挣扎中活下来的公司的警觉。</p><p>从创业者的角度来看，移动互联网的项目基本都需要线下的推广服务。一旦涉及线下，则需要建立一支较大的地推团队。这对创业者来说，意味着公司不再是只需几个技术牛人、几台服务器的轻公司，而需要投入更多的人力，更大的资源。这对于一个创业公司来说，并不容易。它们一般只获得百万级人民币的天使投资，在A 轮也顶多拿到百万美元到千万美元的投资。如若成为一家重公司，那么粮弹的消耗会非常迅速。</p><p>点心CEO张磊曾对媒体感叹：手机OS这条路太难走，需要整理硬件、软件等各种关系。行业竞争也在加剧，而随着三星、HTC、华为、中兴等手机厂商开始使用自己开发的系统，他曾说，“大公司要大规模投入，你再给我几千万美金，我也干不过他们。”</p><p>对这些创业者来说，百度、阿里、腾讯的庞大资源令人垂涎。百度在搜索、阿里在电商、腾讯在即时通讯、社交都处于垄断地位，资源的丰厚令他们可望而不可及。</p><p>“现在，百度、阿里、腾讯出手都还算大方，给的投资，收购价格相对VC都有一些溢价。”一位互联网投资界人士告诉记者，这样从财务投资的角度来看，创业者也愿意接受BAT的投资或收购，一些VC也愿意将手上的项目转手给BAT。</p><p>而投资与收购是一件你情我愿的事情。汪华告诉记者，一个不错的创业团队是否选择被收购，资方、创始团队、公司发展状况等都可能是决定因素。从目前国内形成的互联网早期投资氛围来看，投资人一般比较尊重创始团队。</p><p>与中后期的项目越来越注重短期套现相比，早期的互联网投资，投资人并不会那么“功利”，往往更看中产品与团队，也希望自己投的项目能够闯出一家伟大的公司，这样无论从金钱收益，还是个人名望，都会是最大化的回报。</p><p>但这些投资人也明白，与互联网时代从无到有、所有人都是白手起家不同，移动互联网时代，已经存在的互联网巨头具有先头优势，而移动互联网更注重线上与线下的结合，独立创业的难度大增。一家公司从初创到最终上市，最快也需要花费5年以上的时间，这其中也会经历很多艰难险阻，并不容易。</p><p>“有的创始人团队并不一定适合一直独立创业，去一个大公司，或许还会有机会。”早在1999年就辞职投身互联网创业的汪华会依据创始人团队的性格特点，给出一些建议。他觉得，既要有远大的理想，也要有务实的操作手法。</p><p>占先机 卜入口</p><p>从目前这三大巨头所做的投资来看，各家的投资手法与逻辑各有千秋。</p><p>据记者的多方了解，目前，这三家互联网公司负责投资的人数在10人-30人之间的规模。百度的企业发展部，负责投资的大约有10名员工。而腾讯在北京、深圳都设有办公室，投资团队超过20人。阿里巴巴在北京、杭州两地设有投资部员工，人员数量接近30人。</p><p>百度现在只做战略投资，腾讯、阿里是财务投资与战略投资同时进行。百度大的收购策略是“优势实力提升型”，它更乐意收购那些能够加强搜索上的实力，以及地图业务的延展。例如，收购“今晚看啥”，就是想加强其在视频垂直搜索领域的个性化推荐。</p><p>自2012年才决心做移动互联网的百度在移动互联网比腾讯、阿里迟到不少，该公司着急追上移动互联网步伐，也愿意“出手”一些好的项目，用金钱换时间。 2012年年底，百度通过资本市场发债15亿美元，而百度CEO李彦宏曾公开表示，这笔钱将用于投资收购、基础的技术研发、百度研究院等项目，公司的4大战略方向包括搜索、云、LBS、国际化等。</p><p>阿里巴巴一方面补充自己在电商上的不足，如物流，构筑涵盖物流、数据服务、代运营、站长资源的电子商务生态链，更多的是寻找无线、社交类的项目，以便在未来的竞争中取得战略性的优势地位。</p><p>“阿里巴巴在无线、社交上投的几个项目都还不错，丁丁优惠券、陌陌、在杭州做得不错的‘快的打车’。” 一位接近阿里巴巴的投资界人士认为，阿里的投资偏向中后期，一般情况下，天使轮与A轮融资不介入。</p><p>相比百度、阿里巴巴，腾讯的投资玩法更激进，除了天使投资外，早期、中期、后期的投资与并购都涉及。</p><p>“腾讯投资的风格更像是一家VC机构，它的投资项目多处于移动互联网的各个细分领域。”一位互联网早期投资界人士评论说，“腾讯想通过投资来寻找未来的增长引擎。”</p><p>其中，游戏是腾讯投资最看中的领域。在国内，热酷、行云、智明星通、易乐网、顺网科技等都接受了腾迅的投资。在硅谷、韩国、东南亚、俄罗斯，腾讯更是大手笔，韩国的Kakao(类似于微信的应用)、Riot Games、Epic Games 、ZAM、Raptr等知名游戏公司都接受了腾讯的投资。“现在，腾讯扮演游戏平台的角色，它希望将这种实力延展到移动上，只要拥有了好的游戏研发公司，那么无论未来游戏的形式如何展现，腾讯还是可以拢聚好的游戏内容，这样其游戏带来的营收便不在话下。”这位互联网早期投资界人士分析。</p><p>目前，由于具体的执行层面人员不同，BAT之间的投资风格也不同。目前，这三家公司在投资与收购时，并没有出现大规模的“明抢”现象。但“好项目永远是稀缺资源”，未来，在一些项目上，可能会出现你争我压的现象。</p><p>“百度、阿里在无线上并没有找到一个杀手级的应用，它们投资的选择并不是那么明确，而只是希望补强自己在无线端的实力。腾讯在无线上的投资更加大胆。” 汪华认为，现在各家做投资都是摸着石头过河，并不知道未来哪一个细分领域会成为关键型的应用，于是都选择广撒网的布局方式。</p><p>百度、阿里、腾讯进行无线投资的背后，有一个移动互联网的入口逻辑。对此，汪华认为，所谓“入口”应具有3个特征：良好的产品与服务、受众范围广、用户使用频次高。符合这3个特征的应用很多，但移动互联网上并没有一个绝对的、统一的入口，而是从应用层、工具层、系统层等方面都是某一种入口。</p><p>“移动互联网的入口也不是一成不变的，而是随着新用户的进入，移动互联网的使用特点，习惯会不断发生变化。用户对移动互联网的看法，也会发生变化。这就从需求端带来了入口的变化。”汪华说，这样的变化，让大的互联网公司需要不停地广撒网，多投资，寻找未来的可能性。</p><a href=\"https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_b4cbba7e0101a8sz.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">互联网的三大巨头 百度_阿里巴巴_腾讯（BAT)</a><p></p>", 
            "topic": [
                {
                    "tag": "腾讯", 
                    "tagLink": "https://api.zhihu.com/topics/19550757"
                }, 
                {
                    "tag": "阿里巴巴集团", 
                    "tagLink": "https://api.zhihu.com/topics/19551577"
                }, 
                {
                    "tag": "百度", 
                    "tagLink": "https://api.zhihu.com/topics/19551460"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84684104", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "如何快速申请自媒体账号", 
            "content": "<p>想做<b>自媒体</b>的朋友们快速找到了自己喜爱的平台，并注册了账号，静静的等待着审核成功的消息，可是一天、两天甚至更久都没见到审核通过的动静，这是怎么回事呢？那你肯定是有些地方不注意，导致不能通过审核，想要快速通过账号的审核吗？那你一定要知道这些哦！</p><p>1、选择注册类型</p><p>自媒体平台根据现有的主体类型大概分为了个人、企业、媒体、政府机关和其他组织机构五大入驻类型，我们根据自己需求选择对应的类型进行申请。</p><p>2、填写申请信息</p><p>这类信息一般包括自媒体账号信息，像自媒体名称、自媒体头像、自媒体个性签名；还有运营着的身份信息，行运营者的身份证姓名、运营者的身份者号码、运营着的手持身份证照片及联系邮箱；最后就是除了个人类型以外的申请主体类型的辅助资料，像企业的话就还要企业名称、营业执照等信息补充。根据自己的申请类型准备好资料。</p><p>3、审核未通过的原因</p><p>在按照步骤填写信息之后却没有通过审核，原因可能有这些：</p><p>⑴自媒体账号不符合规定，比如名称中含有一些特殊字符或字母，或是含有推广信息的文字之类的等等，这些情况存在的话，审核成功的几率当然是低得可怜的；</p><p>⑵自媒体头像不符合规定，像使用一些纯色头像、第三方品牌的logo图像、模糊不清的头之类的也是不可以的，选头像的时候就可以往你选的领域靠近哦；</p><p>⑶自媒体个性签名，如果这部分里面含有推广信息、链接、低俗色情的内容，当然是不允许通过的啦；</p><p>⑷还有就是身份证照片信息，比如上传的照片不清晰、文字模糊不清、与填写的信息不符等，这些很容易被打回来的；</p><p>⑸涉嫌冒用他人信息、或信息与账号定位不符等。</p><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84682867", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "小程序入门指针。", 
            "content": "<p>说起【今日头条】【抖音】app，很多用户都知道，但这两个产品的研发商字节跳动公司缺不一定为大家所熟悉。其实字节跳动公司旗下有众多大流量的app产品：除了今日头条、抖音外，还有西瓜视频、火山小视频、皮皮虾等一系列产品。</p><p>2019年3月初，字节跳动公司宣布进入小游戏行业，逐步在以上众多app产品中接入小游戏，这对整个小游戏行业来说是个很大的事件，对小游戏开发商来说是个重大利好。本文将详细介绍接入字节游戏平台的流程和一些注意事项。</p><h3>接入流程：</h3><p><b>第一步：申请开发者权限。</b><br/>准备一个手机号和一个可以外网体验的游戏地址（或者微信小游戏可以访问的游戏）、游戏简介、游戏logo。<br/>申请地址：<a href=\"https://link.zhihu.com/?target=https%3A//developer.toutiao.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">developer.toutiao.com</span><span class=\"invisible\"></span></a><br/>用手机号注册一个账号，并填写游戏相关信息进行申请，（审核时长大概3-5个工作日）审核通过后，头条会发邮件通知。这样就可以登录后台创建游戏了。</p><p><b>第二步：创建游戏。</b><br/>创建游戏，填入游戏相关信息，另外还需要填入主体信息，可以选择企业开发者或个人开发者。开发者账号第一次创建游戏填写的主体信息需要等待审核（审核时长3-5个工作日 ），主体信息审核通过之后再创建游戏就可以选择复用主体信息了无需再审核。</p><p><b>第三步：设置游戏配置。</b><br/>在后台对游戏进行配置，具体包括分享信息、游戏美术风格、流量标签、流量主广告申请、生成AppSecret、服务器域名配置。其中分享信息和流量标签需要官方审核，其他内容无需审核直接生效。</p><p><b>第四步：发布字节小游戏项目。</b><br/>字节的sdk和api文件和微信小游戏几乎完全一致，包括类包wx也是支持的，各主流小游戏引擎（egret、Laya）并没有针对字节平台发布对应的引擎版本，因此直接复制微信小游戏文件夹进行修改作为字节小游戏项目即可。<br/>修改project.config.json、game.json文件</p><p><b>第五步：修改项目代码。</b><br/>这是本文的重点，具体描述平台功能、技术 和微信小游戏平台的不同和差异。</p><p>1、\t修改项目代码：<br/>6）\t支持匿名账号，微信小游戏是不存在匿名账号的，头条需要支持匿名账号登录，需要处理好这部分逻辑<br/>7）\t处理好用户信息、排行榜、分享、banner广告、视频广告<br/>8）\t游戏数据配置，比如某些游戏业务逻辑，针对不同渠道不同的配置<br/>9）\t游戏矩阵<br/>10）混服、世界排行榜的处理</p><p>字节头条小游戏接入和微信小游戏的异同：<br/>相同之处：绝大部分API都相同<br/>不同之处：<br/>1）没有好友关系链，游戏内的排行榜需要移除<br/>2）游客，就不显示获取授权、昵称头像按钮</p><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84509683", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 1, 
            "title": "对于程序员来说，你的人生规划是什么？", 
            "content": "<p>本人本科（三本）院校毕业，学的是电子信息工程专业，现从事JAVA后端开发的工作快两个月了，我本人总结了一些技术相关的经验和非技术相关的心得，加上我是一个非常无聊的人，周末有空，顺便写写知乎。特别好朋友算起来就五六个，感觉自己人生太失败了。不多扯屁话，下面就是我的一些我总结的一些心得。</p><p>一、工作</p><p>1、毕业刚开始，没有工作经验，工资能够满足基本生活就可以了，不要看短期的工资多或少，找一份可以提升自己的技能的工作。我在2019年6月的时候，我是没有毕业就开始找工作了，因为大四就没有课了，七月份在深圳找到了一份三千元月薪的工作，这个薪资是对普通院校毕业的学生而言的，如果是名牌大学毕业的就不一样，我听我以前的一个同事说过他的同学刚毕业就进了腾讯，薪资没透露多少，我也不好问，但是肯定是我比高3倍，他是华南理工毕业的。一个好的大学毕业证是多么重要，这个决定了同一批毕业生的起点。上那个大学是高考就已经决定了，无法改变，所以当起点不一样的时候，普通大学毕业的学生就要认真多一些了。可以去一个公司中小型公司，找一份JAVA开发相关的工作，一边完成上级安排的工作，另一边自我学习。学习的方式可以是加入相关的QQ群，上github、码云等技术网站，看别人的源码，在自己本地电脑实践。做JAVA开发的人，无可避免要学会前端开发，因为大部分业务系统都涉及后台管理系统的页面开发，一些小公司是不会投入人力在后台管理系统页面开发的，所以一般都是JAVA开发人员包了这块工作内容。记住一点，不要埋怨怎么又分这种任务给我。其实多做一些这种事情有利于提高技能熟练度。像一些前端的技术栈：JS、HTML5、CSS3、JQuery、esayUI、extJs这些，目前可能不会再使用了，但是之前很多系统是用这些做前端页面开发的，维护系统，所以要使用。学一下也没什么。目前流行的VUE、TS、angular、reflect、node js等前端语言也会慢慢被后面的技术栈替换，需要养成一个终生学习的态度，需要用到什么就去学习什么，都是为了完成工作。我以前就经常抱怨项目经理老是把那种前端页面开发的活丢给我，印象很深刻的是我还怼了以前公司的一个项目经理，我就说你能不能招聘一个前端开发来干这些，他说公司没资源，只能我来干，后面有资源了就不用你了。现在看来项目经理确实是对的，当时太年轻，不懂分寸，如果有机会，我还是要跟他道歉，不该当着同事的面怼他。顶撞上级，这个是大忌。</p><p>2、先要掌握各种技术栈的使用，例如spring家族图谱技术栈、mybatis、hibernate、dubbo、springboot、mysql、redis、rabbit mq、kafka、elk、mock、junit test、spring cloud、netty、web socket 、web service、阿里巴巴开源项目等，然后再了解其原理，再深入其源码。（我还是停留在知其原理，未探究其源码阶段，这里需要的时间太多了，我没这个心思，我是以工作为驱动，需要解决什么问题就去掌握什么技术栈）掌握了使用和原理，这样去找工作的时候能作为一个考核点，技能能适应岗位，也许可以被招聘，个人经验总结找工作第一点看学历，第二点看技能，学历不好，技能熟练，也是可以通过考核的，还有一个加分点就是看眼缘，面试官觉得你顺眼，给你机会试一试。我以往的求助经历都是这样的，面试官觉得我这个人技能还行，能独立解决问题，还有一点可能是真的看着我顺眼，就我了这种感觉。我求职不上的原因很多时候都是学历不符合一些企业的招聘要求和面试官觉得我不行。我并不会为此难过，我把这些看成了一种缘分不够的事情。只要不是做基础研发，做业务系统、应用的开发，并不需要很高的智商，勤奋一点的人都能做到。</p><p>3、学会使用各种工具，例如eclipse、idea、power designer、xshell5、sftp5、SQLyog、putty、filezilla、Axure RPro、post man等等</p><p>4、深入一个行业的业务，例如金融行业、电商行业、物流行业、物联网行业。这些行业有什么特点，业务系统、应用需要用到什么技术栈，这些技术栈可以解决什么系统、应用的问题。行业业务是怎么开展的，业务系统、应用需要做什么。最近我跟我以前的一个同事交流，他跟我说了一句我觉得很对的，他说小赖，你知道你为什么要不高工资吗？他说很重要的一点是你没用特别深入一个行业，没在一个特定的领域有深入研究，加上你学历不好，所以你求职的时候会遇到一个不上不下的尴尬，本来那个招聘的岗位是月薪1万的，但是你不符合这个岗位的要求，还有一些地方达不到，所以不会用你。确实是这样的，我在做电商、物联网的时候用到的技术栈和做金融行业的技术确实不一样，而且金融行业对业务的理解要求非常高，不懂业务，你没办法设计业务系统、应用，使用的技术栈和解决方案都不一样。我同事给我的建议是让我一直做金融行业的业务系统、应用开发，未来通货膨胀了几倍，到时候月薪1万不是梦。我觉得他说的很对。之前我做物联网应用的时候，一直使用netty、springboot集成IOT、涉及tcp通讯，kafka消息推送等，现在做金融行业的信贷系统，IOT就用不上了。但是那种分布式的微服务的概念、解决方案却是通用的。</p><p>5、了解一些概念性的、解决方案的、前景的事情。比如微服务架构、devOps、iot平台、ai、大数据平台、数据仓库、分库分表spark流计算等</p><p>6、做一些与运维相关的事情。例如系统运维、磁盘容量监控、网络策略、中间件集群搭建与维护、数据库搭建与维护、数据库监控、jenkins自动化部署、docker安装和维护等。可以花钱买一个阿里云实例，自己本地电脑远程连接到阿里云实例上，平时自己实践一下，例如搭建一个elk收集应用日志，安装一个mysql、redis、rabbit mq、kafka等。</p><p>7、做一些与项目管理相关的事情。例如gitLab管理代码版本分支、合并代码等，自己搭建一个gitLab。项目需求管理、项目进度管理、项目文档管理等</p><p>二、生活</p><p>1、个人建议刚毕业第一年以内，找一份稳定的工作，有一定的收入，存点钱。一边工作，一边报名考驾照。利用周末的时候去学车，把驾照考了。平时工作和学习都很累了，生活上可以培养一些兴趣爱好，学学唱歌跳舞，放松一下，别过得那么压抑。我之前是骑单车的，现在已经放弃骑车了。可以通过其他运动来锻炼身体，钱没赚到不要紧，保重身体，别年纪轻轻就一身病。尽量不要抽烟喝酒，这样会加速脱发。保护好头发、牙齿，颈椎、腰等财富，平时多注意一下个人卫生，别搞得那么邋遢，一身臭味，影响其他人。尽量自己一个人租房住，学会独立生活，面对孤独。很多时候很多事情都要独当一面了，别老是想依靠别人，尤其是父母。如果是普通人家的孩子，父母都是工人，没什么物质基础和背景的人，那么还是想想怎么提高自身，培养自己独立解决一切生活上的问题。比如租房、搬家、买家具家电、维修家电、打扫卫生等。</p><p>2、第二或三年换一份工作，主要还是要看工资，因为是真的穷，要存钱，将来做点什么事情也有点积蓄。还是要找一个女朋友，认认真真地谈恋爱，谈恋爱也是生活中的一部分。至于追女孩子的经验，我个人觉得是这样的，不要吹嘘自己，真诚一点，是怎样的就怎样，通过欺骗和吹嘘自己骗了一个女孩，最后她也是会发现你不是像你所说的那样，真正合得来的人，你就是很普通地请她吃一顿饭，诚实地对待，很简单地就成为男女朋友。如果你追一个女孩很累很费劲很不开心，那么我还是建议你不要追了。金庸的小说里的男女主角很多时候都是吃了一顿饭，自然而然地在一起。</p><p>3、男孩纸有钱了要先买车，不要把自己的下半生都按揭在一套房子上面。如果你是很有钱的人，那么就另当别论。有个车，出门比较方便。另外不要纠结养成成本的问题，这些钱是要花的。出门方便一些，朋友同事之间来往的次数也多一些，交流一下，多多少少可以了解到一些信息，对自己也是有帮助的。</p><p>4、至于结婚生子的问题，不要怕父母催。有些事情是急不来的，命中自有安排。还是要看自己是不是有能力、有条件、内心上是否做好了要筹建一个家庭的准备。毕竟谈恋爱只是2个人的事情，不开心不适合还可以随时分，不用承担过多的责任。结婚了就是2个家庭的事情，如果很富裕，那么应该也不会有什么矛盾。如果生活贫困，那么时间一长了就很多矛盾。弄不好像我大哥大嫂那样，隔一个一年半载就闹离婚，闹了几年都没离成，2个孩子都上小学了。</p><p>5、生活中要看到自己的缺点、不足的地方，不要自以为是，有错就改，做得不好不对就改。人都是主观性的，旁观者清，很多时候一些朋友对自己说的话都是中肯正确的，只是自己没听懂。我认识的一个朋友，我说我要买SUV，他却对我说，小赖你不适合开SUV，SUV车太大太高，你矮，不太搭，你适合开轿车。我这个朋友说的话，我居然不会生气，我还觉得他说的很对，确实是这样的，后来我就决定了买轿车。生活中真的有一些朋友是真正给你建议帮助你的，你要学会倾听那句话是有用的。</p>", 
            "topic": [], 
            "comments": [
                {
                    "userName": "陈先生", 
                    "userLink": "https://www.zhihu.com/people/6d780828f4a1a17d8d5956a47fba1239", 
                    "content": "过来人的经验。学习下", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84508884", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "在程序员眼里什么都可以用代码搞定。", 
            "content": "<p>前几日中午又被莫名其妙的刷屏的，像去年圣诞一样，大家@微信官方要圣诞帽，今年@微信官方要国旗，甚至广大圈友提出更加过分的要求，要女朋友的，要暴富的，要头发的....</p><p> SkrEric虽然不能满足你们这些要求，但是给头像加一面国旗还是小意思的啦，万能的Python就能通过10多行代码搞定</p><p>废话少说，代码奉上：</p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding: utf8 -*-import cv2# 读取头像和国旗图案img_head = cv2.imread(&#39;head.jpg&#39;)img_flag = cv2.imread(&#39;flag.png&#39;)# 获取头像和国旗图案宽度w_head, h_head = img_head.shape[:2]w_flag, h_flag = img_flag.shape[:2]# 计算图案缩放比例scale = w_head / w_flag / 4# 缩放图案img_flag = cv2.resize(img_flag, (0, 0), fx=scale, fy=scale)# 获取缩放后新宽度w_flag, h_flag = img_flag.shape[:2]# 按3个通道合并图片for c in range(0, 3):    img_head[w_head - w_flag:, h_head - h_flag:, c] = img_flag[:, :, c]# 保存最终结果cv2.imwrite(&#39;new_head.jpg&#39;, img_head)</code></pre></div><p>你需要做的是将上面的代码复制到你创建的py文件里，并在同一目录下放入你头像的图片和国旗的图片，并将头像图片命名为head.jpg，将国旗图片命名为flag.png(当然了，除了国旗，你也可以拼接任何图片)，最后运行就生成了new_head.jpg也就是加了国旗的图片了</p><p>效果如下：</p><p>实现基本思路：</p><p>1. 读取进头像和国旗的图片</p><p>2. 根据头像和国旗的长宽，我们计算下图案需要缩放多少比例</p><p>3. 通过像素替换，将缩放后的国旗图案添加到头像图片的右下角</p><p>对了，这个需要通过opencv-python库来处理图像，大家可以用pycharm导入，或者直接pip install opencv-python</p><p>最后希望祖国繁荣昌盛，国泰民安！</p><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84505702", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "阿里巴巴还是一如既往牛呀。", 
            "content": "<p>近日，一则阿里巴巴P8级别员工的征婚贴火了，微博大V@北京大土豆作为贴子发布者，也连带受到了不少应征者的“骚扰”，针对应征者的问题，@北京大土豆 9月26日晚间又发一贴，进一步阐明了原贴观点，并摆明了自己的中立立常</p><p>阿里P8员工征婚贴</p><p>原贴的主旨大意如下：1986年生人，阿里P8员工，年薪170万元，身高170cm，有房有车。想找个江浙地区的90后女孩结婚，要求独生女，漂亮懂事，学历211起步，月薪一万以上，身高162cm以上，买新房自己能出200万元，多退少了女方补，女方需要做家务，希望可以生二胎。</p><p>条件一摆，自然有不少姑娘应征，但同时也受到了质疑，其中包括：买房还要女方出钱；房产不是自己的；这么有钱女方还要做家务；说自己170cm，其实应该只有168cm；阿里P8年薪没这么高等等等等。</p><p>@北京大土豆看不下去了，在最新的微博中一一澄清，他首先表示自己只是中间人，但不是媒婆，能不能成自己不负责。他表示，170万元年薪不夸张，真的是这么多，自己亲眼看过工资单；买房没逼女方非要出多少钱，出的多就买大的，出的少就买小的；房产写两个人的名字，都是夫妻共同财产，不吃亏。</p><p>对此，网友从另一个角度发表了观点：“不是说他钱不够多。而是符合他条件的女生可能看不上他的钱。既然钱是他最大的优势，就直接找缺钱但是年轻貌美的妹子最合适了。</p><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82549095", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "Java 工程师核心基础修炼", 
            "content": "<h3>1 Java 的异常分类及处理</h3><h3>1.1 异常分类</h3><p><b>Throwable</b> 是 Java 语言中所有错误或异常的超类。下一层分为 <b>Error</b> 和 <b>Exception</b>。 <b>Error</b> 类是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p><p><b>Exception</b> 又有两个分支，一个是运行时异常 <b>RuntimeException</b> ，如：NullPointerException 、 ClassCastException；一个是检查<b>CheckedException</b>，如 I/O 错误导致的 IOException、SQLException。</p><p>RuntimeException 是那些可能在 Java 虚拟机正常运行期间抛出的异常的超类。 如果出现 RuntimeException，那么一定是程序员的错误。</p><p>CheckedException 一般是外部错误，这种异常都发生在编译阶段，Java 编译器会强制程序去捕获此类异常，即会出现要求你把这段可能出现异常的程序进行 try catch，该类异常一般包括几个方面：</p><ul><li>试图在文件尾部读取数据；</li><li>试图打开一个错误格式的 URL；</li><li>试图根据给定的字符串查找 class 对象，而这个字符串表示的类并不存在。</li></ul><h3>1.2 异常处理方式</h3><p>抛出异常有三种形式，一个是 throw，一个是 throws，还有一种系统自动抛异常。如：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void main(String[] args) { \n        String s = &#34;abc&#34;; \n        if(s.equals(&#34;abc&#34;)) { \n           throw new NumberFormatException(); \n       } else { \n            System.out.println(s); \n             } \n       }\n\n int div(int a,int b) throws Exception{\n     return a/b;\n }</code></pre></div><h3>2 Java 反射</h3><h3>2.1 动态语言</h3><p>动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。比如常见的 JavaScript 就是动态语言，除此之外 Ruby、Python 等也属于动态语言，而 C、C++ 则不属于动态语言。从反射角度说 Java 属于半动态语言。</p><h3>2.2 反射机制概念</h3><p>在 Java 中的反射机制是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。</p><h3>2.3 反射的应用场合</h3><p><b>编译时类型和运行时类型</b></p><p>在 Java 程序中许多对象在运行是都会出现两种类型：编译时类型和运行时类型。 编译时的类型由声明对象时实用的类型来决定，运行时的类型由实际赋值给对象的类型决定 。如：</p><div class=\"highlight\"><pre><code class=\"language-text\">Person p=new Student();</code></pre></div><p>其中编译时类型为 Person，运行时类型为 Student。</p><p><b>编译时类型无法获取具体方法</b></p><p>程序在运行时还可能接收到外部传入的对象，该对象的编译时类型为 Object，但是程序有需要调用该对象的运行时类型的方法。为了解决这些问题，程序需要在运行时发现对象和类的真实信息。然而，如果编译时根本无法预知该对象和类属于哪些类，程序只能依靠运行时信息来发现该对象和类的真实信息，此时就必须使用到反射了。</p><h3>2.4 Java 反射 API</h3><p><b>反射 API 用来生成 JVM 中的类、接口或对象的信息</b>。</p><ul><li><b>Class</b> 类：反射的核心类，可以获取类的属性，方法等信息。</li><li><b>Field</b> 类：Java.lang.reflec 包中的类，表示类的成员变量，可以用来获取和设置类之中的属性值。</li><li><b>Method</b> 类： Java.lang.reflec 包中的类，表示类的方法，它可以用来获取类中的方法信息或者执行方法。</li><li><b>Constructor</b> 类： Java.lang.reflec 包中的类，表示类的构造方法。</li></ul><h3>2.5 反射使用步骤</h3><p>（1）获取想要操作的类的 Class 对象，他是反射的核心，通过 Class 对象我们可以任意调用类的方法。 （2）调用 Class 类中的方法，既就是反射的使用阶段。 （3）使用反射 API 来操作这些信息。</p><p><b>获取 Class 对象的三种方法</b></p><p>调用某个对象的 getClass()方法</p><div class=\"highlight\"><pre><code class=\"language-text\">Person p=new Person();\nClass clazz=p.getClass();</code></pre></div><p>调用某个类的 class 属性来获取该类对应的 Class 对象</p><div class=\"highlight\"><pre><code class=\"language-text\">Class clazz=Person.class;</code></pre></div><p>使用 Class 类中的 forName()静态方法(最安全/性能最好)</p><div class=\"highlight\"><pre><code class=\"language-text\">Class clazz=Class.forName(&#34;类的全路径&#34;); (最常用)</code></pre></div><p>当我们获得了想要操作的类的 Class 对象后，可以通过 Class 类中的方法获取并查看该类中的方法和属性。</p><div class=\"highlight\"><pre><code class=\"language-text\">//获取 Person 类的 Class 对象\n    Class clazz=Class.forName(&#34;reflection.Person&#34;);\n    //获取 Person 类的所有方法信息 \n    Method[] method=clazz.getDeclaredMethods(); \n    for(Method m:method){ \n       System.out.println(m.toString());\n    } \n    //获取 Person 类的所有成员属性信息 \n    Field[] field=clazz.getDeclaredFields(); \n    for(Field f:field){ \n       System.out.println(f.toString()); \n    }\n    //获取 Person 类的所有构造方法信息 \n    Constructor[] constructor=clazz.getDeclaredConstructors(); \n    for(Constructor c:constructor){ \n       System.out.println(c.toString());\n    }</code></pre></div><p><b>创建对象的两种方法</b></p><p>（1）使用 Class 对象的 newInstance() 方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。</p><p>（2）先使用 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance()方法来创建 Class 对象对应类的实例,通过这种方法可以选定构造方法创建实例。</p><div class=\"highlight\"><pre><code class=\"language-text\">//获取 Person 类的 Class 对象\n    Class clazz=Class.forName(&#34;reflection.Person&#34;); \n    //使用.newInstane 方法创建对象 \n    Person p=(Person) clazz.newInstance(); \n    //获取构造方法并创建对象\n    Constructor    c=clazz.getDeclaredConstructor(String.class,String.class,int.class); \n    //创建对象并设置属性\n    Person p1=(Person) c.newInstance(&#34;张三&#34;,&#34;男&#34;,20);</code></pre></div><h3>3 Java 注解</h3><p><b>Annotation</b>（注解）是 Java 提供的一种对元程序中元素关联信息和元数据（metadata）的途径和方法。<b>Annatation</b>(注解)是一个接口，程序可以通过反射来获取指定程序中元素的 <b>Annotation</b>对象，然后通过该 <b>Annotation</b> 对象来获取注解中的元数据信息。</p><h3>3.1 四种标注元注解</h3><p>元注解的作用是负责注解其他注解。 Java5.0 定义了 4 个标准的 meta-annotation 类型，它们被用来提供对其它 annotation 类型作说明。</p><ul><li><b>@Target 修饰的对象范围</b></li></ul><p>@Target 说明了Annotation所修饰的对象范围， Annotation 可被用于 packages、types（类、接口、枚举、Annotation 类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch 参数）。在 Annotation 类型的声明中使用了 target 可更加明晰其修饰的目标。</p><ul><li><b>@Retention 定义被保留的时间长短</b></li></ul><p>@Retention 定义了该 Annotation 被保留的时间长短，表示需要在什么级别保存注解信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效），取值（RetentionPoicy）有：</p><p><b>SOURCE</b>：在源文件中有效（即源文件保留）</p><p><b>CLASS</b>：在 class 文件中有效（即 class 保留）</p><p><b>RUNTIME</b>：在运行时有效（即运行时保留）</p><ul><li><b>@Documented 描述 -javadoc</b></li></ul><p>@Documented 用于描述其它类型的 Annotation 应该作为被标注程序成员的公共 API，因此可以被例如 javadoc 此类的工具文档化。</p><ul><li><b>@Inherited 阐述了某个被标注的类型是被继承的</b></li></ul><p>@Inherited 元注解是一个标记注解，@Inherited 阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited 修饰的 Annotation 类型被用于一个 Class，则这个 Annotation 将被用于该 Class 的子类。</p><h3>3.2 注解处理器</h3><p>如果没有用来读取注解的方法和工作，那么注解也就不会比注释更有用处了。使用注解的过程中，很重要的一部分就是创建于使用注解处理器。Java SE5 扩展了反射机制的 API，以帮助程序员快速的构造自定义注解处理器。下面实现一个注解处理器。</p><div class=\"highlight\"><pre><code class=\"language-text\">//定义注解\n    @Target(ElementType.FIELD)\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface FruitProvider {\n    /**供应商编号*/ \n    public int id() default -1;\n    /**供应商名称*/\n    public String name() default &#34;&#34;；\n    /**供应商地址*/\n    public String address() default &#34;&#34;; \n    }\n    //注解使用\n    public class Apple {\n    @FruitProvider(id = 1, name = &#34;XX公司&#34;, address = &#34;XX  路&#34;) \n    private String appleProvider; \n    public void setAppleProvider(String appleProvider){\n        this.appleProvider = appleProvider;\n       } \n    public String getAppleProvider() { \n        return appleProvider;     \n       } \n    }\n    //注解处理器\n    public class FruitInfoUtil {\n    public static void getFruitInfo(Class clazz) { \n    Field[] fields = clazz.getDeclaredFields();\n       for (Field field : fields) { \n         if(field.isAnnotationPresent(FruitProvider.class))   { FruitProvider fruitProvider = (FruitProvider) field.getAnnotation(FruitProvider.class); \n     //注解信息的处理地方 \n    strFruitProvicer = &#34; 供应商编号：&#34; + fruitProvider.id() + &#34; 供应商名称：&#34;+ fruitProvider.name() + &#34; 供应商地址：&#34;+ fruitProvider.address();  System.out.println(strFruitProvicer); } } } }</code></pre></div><h3>4 Java 泛型</h3><p>泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。比如我们要写一个排序方法,能够对整型数组、字符串数组甚至其他任何类型的数组进行排序，我们就可以使用 Java 泛型。</p><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Box {\n       private T t; \n       public void add(T t) { \n       this.t = t; \n    } \n    public T get() {\n       return t; \n    }</code></pre></div><h3>5 Java 复制</h3><p>将一个对象的引用复制给另外一个对象，一共有三种方式。第一种方式是直接赋值，第二种方式是浅拷贝，第三种是深拷贝。所以大家知道了哈，这三种方式实际上都是为了拷贝对象。</p><h3>5.1 直接赋值复制</h3><p>在 Java 中，A a1 = a2，我们需要理解的是这实际上复制的是引用，也就是说 a1 和 a2 指向的是同一个对象。因此，当 a1 变化的时候，a2 里面的成员变量也会跟着变化。</p><h3>5.2 浅复制（复制引用但不复制引用的对象）</h3><p>创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。</p><div class=\"highlight\"><pre><code class=\"language-text\">Class Resume implements Cloneable{ \n        public Object clone() { \n          try { return (Resume)super.clone();\n          } catch (Exception e) { \n              e.printStackTrace(); \n              return null; \n           } \n        } \n     }</code></pre></div><h3>5.3 深复制（复制对象和其应用对象）</h3><p>深拷贝不仅复制对象本身，而且复制对象包含的引用指向的所有对象。</p><div class=\"highlight\"><pre><code class=\"language-text\">class Student implements Cloneable {\n        String name; \n        int age; \n        Professor p; \n        Student(String name, int age, Professor p) { \n            this.name = name; \n            this.age = age; \n            this.p = p; \n    } \n        public Object clone() { \n            Student o = null; \n            try { \n                o = (Student) super.clone(); \n            } catch (CloneNotSupportedException e) { \n                System.out.println(e.toString()); \n            } \n            o.p = (Professor) p.clone();\n            return o; \n        } \n    }</code></pre></div><h3>6 JVM</h3><p>JVM 是可运行 Java 代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p><h3>6.1 运行过程</h3><p>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码 。也就是如下：</p><p>① Java 源文件—-&gt;编译器—-&gt;字节码文件</p><p>② 字节码文件—-&gt;JVM—-&gt;机器码</p><p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p><h3>6.2 JVM 内存区域</h3><p>JVM 内存区域主要分为线程私有区域（程序计数器、虚拟机栈、本地方法区）、线程共享区域（JAVA 堆、方法区）、直接内存。</p><p>线程私有数据区域生命周期与线程相同，依赖用户线程的启动/结束 而 创建/销毁（在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应）。</p><p>线程共享区域随虚拟机的启动/关闭而创建/销毁。</p><p>直接内存并不是 JVM 运行时数据区的一部分, 但也会被频繁的使用: 在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用 DirectByteBuffer 对象作为这块内存的引用进行操作，这样就避免了在 Java堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。</p><h3>6.3 JVM 运行时内存</h3><p>Java 堆从 GC 的角度还可以细分为：新生代（Eden 区、From Survivor 区和 To Survivor 区）和老年代。</p><ul><li><b>新生代</b></li></ul><p>是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p><p><b>Eden 区</b>：Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。</p><p><b>ServivorFrom</b>：上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p><p><b>ServivorTo</b>：保留了一次 MinorGC 过程中的幸存者。</p><ul><li><b>老年代</b></li></ul><p>主要存放应用程序中生命周期长的内存对象。老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p><p>MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p><h3>6.4 垃圾回收与算法</h3><ul><li><b>如何确定垃圾</b></li></ul><p><b>引用计数法</b>：在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，很显然一个简单的办法是通过引用计数来判断一个对象是否可以回收。简单说，即一个对象如果没有任何与之关联的引用，即他们的引用计数都不为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象。</p><p><b>可达性分析</b>：为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。通过一系列“GC roots”对象作为起点搜索。如果在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的。要注意的是，不可达对象不等价于可回收对象，不可达对象变为可回收对象至少要经过两次标记过程。两次标记后仍然是可回收对象，则将面临回收。</p><ul><li><b>垃圾回收算法</b></li></ul><p><b>标记清除算法（Mark-Sweep）</b> 最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间。该算法最大的问题是内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题。</p><p><b>复制算法（copying）</b> 为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p><p><b>分代收集算法</b> 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p><ul><li><b>新生代与复制算法</b></li></ul><p>目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><ul><li><b>老年代与标记复制算法</b></li></ul><p>老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。</p><p>（1）Java虚拟机提到过的处于方法区的永生代（Permanet Generation），它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。</p><p>（2）对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space（Survivor 目前存放对象的那一块），少数情况会直接分配到老生代。</p><p>（3）当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。</p><p>（4）如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。</p><p>（5）在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。</p><p>（6）当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。</p><h3>7 Java 多线程并发</h3><h3>7.1 Java 线程实现/创建方式</h3><p><b>继承 Thread 类</b></p><p>Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class MyThread extends Thread { \n         public void run() { \n             System.out.println(&#34;MyThread.run()&#34;); \n         } \n    } \n        MyThread myThread1 = new MyThread(); \n        myThread1.start();</code></pre></div><p><b>实现 Runnable 接口</b></p><p>如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class MyThread extends OtherClass implements Runnable { \n        public void run() { \n             System.out.println(&#34;MyThread.run()&#34;); \n         } \n    } \n    //启动 MyThread\n    MyThread myThread = new MyThread(); \n    Thread thread = new Thread(myThread); \n    thread.start(); \n    target.run()\n    public void run() { \n     if (target != null) { \n     target.run(); \n     } \n    }</code></pre></div><p><b>ExecutorService、Callable、Future 有返回值线程</b></p><p>有返回值的任务必须实现 Callable 接口，类似的，无返回值的任务必须 Runnable 接口。执行Callable 任务后，可以获取一个 Future 的对象，在该对象上调用 get 就可以获取到 Callable 任务返回的 Object 了，再结合线程池接口 ExecutorService 就可以实现传说中有返回结果的多线程了。</p><div class=\"highlight\"><pre><code class=\"language-text\">//创建一个线程池\n    ExecutorService pool = Executors.newFixedThreadPool(taskSize);\n    // 创建多个有返回值的任务\n    List&lt;Future&gt; list = new ArrayList&lt;Future&gt;(); \n    for (int i = 0; i &lt; taskSize; i++) { \n    Callable c = new MyCallable(i + &#34; &#34;); \n    // 执行任务并获取 Future 对象\n    Future f = pool.submit(c); \n    list.add(f); \n    } \n    // 关闭线程池\n    pool.shutdown(); \n    // 获取所有并发任务的运行结果\n    for (Future f : list) { \n    // 从 Future 对象上获取任务的返回值，并输出到控制台\n    System.out.println(&#34;res：&#34; + f.get().toString()); \n    }</code></pre></div><p><b>基于线程池的方式</b></p><p>线程和数据库连接这些资源都是非常宝贵的资源。如果每次需要的时候创建，不需要的时候销毁，是非常浪费资源的。那么我们就可以使用缓存的策略，也就是使用线程池。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 创建线程池\n    ExecutorService threadPool = Executors.newFixedThreadPool(10);\n     while(true) {\n     threadPool.execute(new Runnable() { // 提交多个线程执行\n     @Override\n     public void run() {\n             System.out.println(Thread.currentThread().getName() + &#34; is running ..&#34;);\n     try {\n         Thread.sleep(3000);\n     } catch (InterruptedException e) {\n         e.printStackTrace();\n             }\n           }\n        });\n      }\n    }</code></pre></div><h3>7.2 同步锁与死锁</h3><p><b>同步锁</b> 当多个线程同时访问同一个数据时，很容易出现问题。为了避免这种情况出现，我们要保证线程同步互斥，就是指并发执行的多个线程，在同一时间内只允许一个线程访问共享数据。 Java 中可以使用 synchronized 关键字来取得一个对象的同步锁。</p><p><b>死锁</b> 何为死锁，就是多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。</p><h3>7.3 线程池原理</h3><p>线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。主要特点为：线程复用；控制最大并发数；管理线程。</p><p><b>线程复用</b> 一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run 方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写 Thread 类，在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。</p><p><b>线程池的组成</b> 一般的线程池主要分为以下 4 个组成部分：</p><p>（1）线程池管理器：用于创建并管理线程池。 （2）工作线程：线程池中的线程。 （3）任务接口：每个任务必须实现的接口，用于工作线程调度其运行。 （4）任务队列：用于存放待处理的任务，提供一种缓冲机制。</p><p>Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor ，Callable 和 Future、FutureTask 这几个类。</p><p>ThreadPoolExecutor 的构造方法如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize, long keepAliveTime,\n            TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) {\n            this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,Executors.defaultThreadFactory(), defaultHandler);\n    }</code></pre></div><p><b>corePoolSize</b>：指定了线程池中的线程数量。</p><p><b>maximumPoolSize</b>：指定了线程池中的最大线程数量。</p><p><b>keepAliveTime</b>：当前线程池数量超过 corePoolSize 时，多余的空闲线程的存活时间，即多次时间内会被销毁。</p><p><b>unit</b>：keepAliveTime 的单位。</p><p><b>workQueue</b>：任务队列，被提交但尚未被执行的任务。</p><p><b>threadFactory</b>：线程工厂，用于创建线程，一般用默认的即可。</p><p><b>handler</b>：拒绝策略，当任务太多来不及处理，如何拒绝任务。</p><p><b>拒绝策略</b> 线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK 内置的拒绝策略如下：</p><p><b>AbortPolicy</b> ： 直接抛出异常，阻止系统正常运行。</p><p><b>CallerRunsPolicy</b> ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。</p><p><b>DiscardOldestPolicy</b> ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。</p><p><b>DiscardPolicy</b> ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p><p>以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。</p><p><b>Java 线程池工作过程</b> （1）线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。</p><p>（2）当调用 execute() 方法添加一个任务时，线程池会做如下判断：</p><p>a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； c) 如果这时候队列满了，而且正在运行的线程数量小maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； d) 如果队列满了，而且正在运行的线程数量大于或等maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。</p><p>（3）当一个线程完成任务时，它会从队列中取下一个任务来执行。</p><p>（4）当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。</p><h3>8 Java 常用算法</h3><h3>8.1 快速排序算法</h3><p>快速排序的原理：选择一个关键值作为基准值。比基准值小的都在左边序列（一般是无序的），比基准值大的都在右边（一般是无序的）。一般选择序列的第一个元素。一次循环：从后往前比较，用基准值和最后一个值比较，如果比基准值小的交换位置，如果没有继续比较下一个，直到找到第一个比基准值小的值才交换。找到这个值之后，又从前往后开始比较，如果有比基准值大的，交换位置，如果没有继续比较下一个，直到找到第一个比基准值大的值才交换。直到从前往后的比较索引&gt;从后往前比较的索引，结束第一次循环，此时，对于基准值来说，左右两边就是有序的了。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void sort(int[] a,int low,int high){\n         int start = low;\n         int end = high;\n         int key = a[low]; \n         while(end&gt;start){\n         //从后往前比较\n         while(end&gt;start&amp;&amp;a[end]&gt;=key) \n        //如果没有比关键值小的，比较下一个，直到有比关键值小的交换位置，然后又从前往后比较\n         end--;\n         if(a[end]&lt;=key){\n             int temp = a[end];\n             a[end] = a[start];\n             a[start] = temp;\n         }\n         //从前往后比较\n         while(end&gt;start&amp;&amp;a[start]&lt;=key)\n        //如果没有比关键值大的，比较下一个，直到有比关键值大的交换位置\n         start++;\n         if(a[start]&gt;=key){\n             int temp = a[start];\n             a[start] = a[end];\n             a[end] = temp;\n         }\n         //此时第一次循环比较结束，关键值的位置已经确定了。左边的值都比关键值小，右边的值都比关键值大，但是两边的顺序还有可能是不一样的，进行下面的递归调用\n     }\n         //递归\n        if(start&gt;low) sort(a,low,start-1);//左边序列。第一个索引位置到关键值索引-1\n         if(end&lt;high) sort(a,end+1,high);//右边序列。从关键值索引+1 到最后一个\n         }\n }</code></pre></div><h3>8.2 冒泡排序算法</h3><p>（1）比较前后相邻的二个数据，如果前面数据大于后面的数据，就将这二个数据交换。</p><p>（2）这样对数组的第 0 个数据到 N-1 个数据进行一次遍历后，最大的一个数据就“沉”到数组第N-1 个位置。</p><p>（3）N=N-1，如果 N 不为 0 就重复前面二步，否则排序完成。</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void bubbleSort1(int [] a, int n){\n         int i, j;\n         for(i=0; i&lt;n; i++){//表示 n 次排序过程。\n             for(j=1; j&lt;n-i; j++){\n                 if(a[j-1] &gt; a[j]){//前面的数字大于后面的数字就交换\n                //交换 a[j-1]和 a[j]\n                int temp;\n                temp = a[j-1];\n                a[j-1] = a[j];\n                a[j]=temp;\n                }\n            }\n         }\n    }</code></pre></div><h3>8.3 二分查找</h3><p>又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><div class=\"highlight\"><pre><code class=\"language-text\">public static int biSearch(int []array,int a){\n         int lo=0;\n         int hi=array.length-1;\n         int mid;\n         while(lo&lt;=hi){\n             mid=(lo+hi)/2;//中间位置\n             if(array[mid]==a){\n             return mid+1;\n             }else if(array[mid]&lt;a){ //向右查找\n                 lo=mid+1;\n             }else{ //向左查找\n                 hi=mid-1;\n             }\n         }\n         return -1;\n    }</code></pre></div><h3>8.4 基数排序算法</h3><p>将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class radixSort {\n        inta[]={49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,101,56,17,18,23,34,15,35,2\n    5,53,51};\n    public radixSort(){\n        sort(a);\n        for(inti=0;i&lt;a.length;i++){\n            System.out.println(a[i]);\n        }\n    }\n    public void sort(int[] array){\n        //首先确定排序的趟数;\n        int max=array[0];\n        for(inti=1;i&lt;array.length;i++){\n            if(array[i]&gt;max){\n                max=array[i];\n        }\n    }\n        int time=0;\n        //判断位数;\n        while(max&gt;0){\n            max/=10;\n            time++;\n        }\n        //建立 10 个队列;\n        List&lt;ArrayList&gt; queue=newArrayList&lt;ArrayList&gt;();\n        for(int i=0;i&lt;10;i++){\n        ArrayList&lt;Integer&gt;queue1=new ArrayList&lt;Integer&gt;();\n        queue.add(queue1);\n        }\n        //进行 time 次分配和收集;\n        for(int i=0;i&lt;time;i++){\n        //分配数组元素;\n        for(intj=0;j&lt;array.length;j++){\n        //得到数字的第 time+1 位数;\n        int x=array[j]%(int)Math.pow(10,i+1)/(int)Math.pow(10, i);\n        ArrayList&lt;Integer&gt;queue2=queue.get(x);\n        queue2.add(array[j]);\n        queue.set(x, queue2);\n        }\n        int count=0;//元素计数器;\n        //收集队列元素;\n        for(int k=0;k&lt;10;k++){\n            while(queue.get(k).size()&gt;0){\n                ArrayList&lt;Integer&gt;queue3=queue.get(k);\n                array[count]=queue3.get(0);\n                queue3.remove(0);\n                count++;\n        }\n    }\n    }\n    }\n    }</code></pre></div><h3>8.5 插入排序算法</h3><p>通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将 它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是（n2）。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void sort(int arr[]){\n        for(int i =1; i&lt;arr.length;i++)\n     {\n     //插入的数\n     int insertVal = arr[i];\n     //被插入的位置(准备和前一个数比较)\n     int index = i-1;\n     //如果插入的数比被插入的数小\n     while(index&gt;=0&amp;&amp;insertVal&lt;arr[index])\n     {\n     //将把 arr[index] 向后移动\n     arr[index+1]=arr[index];\n     //让 index 向前移动\n     index--;\n     }\n     //把插入的数放入合适位置\n     arr[index+1]=insertVal;\n       }\n     }</code></pre></div><h3>9 数据结构</h3><ul><li><b>栈（stack）</b></li></ul><p>栈（stack）是限制插入和删除只能在一个位置上进行的表，该位置是表的末端，叫做栈顶（top）。它是后进先出（LIFO）的。对栈的基本操作只有 push（进栈）和 pop（出栈）两种，前者相当于插入，后者相当于删除最后的元素。</p><ul><li><b>队列（queue）</b></li></ul><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><ul><li><b>链表（Link）</b></li></ul><p>表是一种数据结构，和数组同级。比如，Java 中我们使用的 ArrayList，其实现原理是数组。而LinkedList 的实现原理就是链表了。链表在进行循环遍历时效率不高，但是插入和删除时优势明显。</p><ul><li><b>散列表（Hash Table）</b></li></ul><p>散列表（Hash table，也叫哈希表）是一种查找算法，与链表、树等算法不同的是，散列表算法在查找时不需要进行一系列和关键字（关键字是数据元素中某个数据项的值，用以标识一个数据元素）的比较操作。散列表算法希望能尽量做到不经过任何比较，通过一次存取就能得到所查找的数据元素，因而必须要在数据元素的存储位置和它的关键字（可用 key 表示）之间建立一个确定的对应关系，使每个关键字和散列表中一个唯一的存储位置相对应。因此在查找时，只要根据这个对应关系找到给定关键字在散列表中的位置即可。这种对应关系被称为散列函数（可用 h(key)表示）。</p><p>用的构造散列函数的方法有：</p><p>（1）直接定址法： 取关键字或关键字的某个线性函数值为散列地址，即：h(key) = key 或 h(key) = a * key + b，其中 a 和 b 为常数。 （2）数字分析法 （3）方取值法： 取关键字平方后的中间几位为散列地址。 （4）折叠法：将关键字分割成位数相同的几部分，然后取这几部分的叠加和作为散列地址。 （5）除留余数法：取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即：h(key) = key MOD p p ≤ m （6）随机数法：选择一个随机函数，取关键字的随机函数值为它的散列地址，即：h(key) = random(key)</p><h3>10 结束语</h3><p>本 Chat 涉及的知识点比较多，范围广，由于时间仓促，很多都未能展开详细的论述，出错难免，如发现错漏，敬请各位同学在读者圈提出。也希望本 Chat 能对各位同学学习 Java 的核心基础知识有所帮助，使大家在工作或面试中能融汇贯通，形成完整的知识体系。谢谢各位同学的支持！</p><p>PS：本文首发于 GitChat，如有侵权请及时联系我，我看到会第一时间删掉。未能第一时间联系到本文作者，请谅解。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82548855", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "Java面试的5个小技巧", 
            "content": "<p>1. 笔试</p><p>笔试这个环节是很容易，几张试卷，一共也就十几道题。一般由5至10个选择题+2至5个论述题+1至2个编程题组成。</p><p>平静心态--浏览所有题目--开答</p><p class=\"ztext-empty-paragraph\"><br/></p><p>答题的时候，要先把自己会的快速的答上来，选择题自然不多说了，论述题根据自己的理解大致说明一下，多少会给你自己加分的。编程题其实也不难，出现几率最大的是写一个关于某某设计模式的例子，而设计模式的编码例子，出现最多的是单例模式、工厂模式和代理模式。</p><p>有时候也会有一些算法的编码，一般是排序算法的编码实现。还有的笔试题，会有一些程序题，就是看程序，然后自己写出运行结果，这样的问题考察的是对java基础知识的掌握，所以，有坚固的基础是很重要滴！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2. 面试</p><p>开始会问些技术性的问题，总结出以下：</p><p>Struts1原理和Struts2原理以及区别和联系，在什么项目中用过，有什么体会。　　</p><p>spring的原理aop和ioc机制，如何使用，在哪个项目用到过？有什么体会。</p><p>简要说明一下StrutsMVC和SpringMVC。</p><p>servlet的原理，生命周期。</p><p>socket原理以及使用方式</p><p>Linux常用命令，shell编程介绍</p><p>java常用算法</p><p>多线程、线程池、线程锁等等</p><p>二叉树、java数据结构</p><p>数据库mysql、Oracle的优缺点以及使用方法和sql语句，问的多的是如果模拟分页查询和多表查询</p><p>Java垃圾回收机制</p><p>敏捷开发的简要说明，是否了解</p><p>OOA/OOD/OOP的含义</p><p>java加密与解密</p><p>java网络通信、http协议要素</p><p>是否熟悉设计模式？简要说一下自己所了解或者使用过的开发模式有哪些，在哪些场景中使用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3. 项目经验的问题</p><p>简要说一下你自己做过的自认为很不错的项目，你在项目中的职责，是否能够胜任之前的任务安排，在项目中遇到的问题，你是怎么解决的(一般这样的问题，可以说是自己解决，但是要讲明解决过程，一定要突出解决思路的灵活。也可以回答与同事讨论解决，这样可以让面试官觉察到自己善于利用团队资源，会给自己的团队意识加分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4. 个人对团队的看法及自己的职业规划</p><p>你怎么看待个人与团队，个人能力与团队协作的联系。</p><p>在团队合作中，最重要的是什么？</p><p>如果团队成员对于某个问题出现意见分歧，应该如何解决？</p><p>当对于上级有不满的时候，应该怎么解决？</p><p>团队的发展如何与个人的规划出现分歧，如何应对？</p><p>如何快速融入新的团队，结交新的同事？</p><p>个人的职业规划和职业目标，例如近两年的目标，近五年的规划。</p><p>如何看待企业文化，如何理解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>5. 临阵磨枪</p><p>面试前如果准备的不是很充分，还有很多没有来得及试验的，先放放，可以网上搜集一些经典的面试题，临时背背，或者再去面试的路上看两眼，说不定哪一眼就蒙上了，还可以起到缓解紧张的作用，当然想要拿到高薪是要付出努力的。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「qq_37566545」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_37566545/article/details/80263102\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_375665</span><span class=\"invisible\">45/article/details/80263102</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82548330", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 0, 
            "title": "Java 后端到底是在做什么？", 
            "content": "<p>新手程序员通常会走入一个误区，就是认为学习了一门语言，就可以称为是某某语言工程师了。但事实上真的是这样吗？其实并非如此。</p><p>今天我们就来聊一聊，Java 开发工程师到底开发的是什么东西。准确点来说，Java后端到底在做什么？</p><p>大家都知道 Java 是一门后端语言，后端指的就是服务端，服务端代码一般运行在服务器上，通常我们运行Java 程序的服务器都是 Linux 服务器。</p><p>这些服务器在互联网公司中一般放在一个叫做机房的地方里，于是像我们这类 Java 程序员的代码一般也运行在这些机房里的服务器中</p><p>标志，商店橱窗，商店橱窗，店面，模特，购物，衣服，服装店，透过窗户，帽子</p><p>Java 里有一个概念叫做虚拟机，你可以把它理解为一个安卓的模拟器，比如你在电脑上装了一个安卓模拟器，就可以通过它来运行安卓应用程序，比如装个 APP，手机游戏什么的。</p><p>所以当你在电脑上安装了一个叫做 JDK 的东西时，电脑里就有了 JRE 也就是 Java 运行环境，有了这个运行环境，你就可以运行 Java 应用程序了。</p><p>知道 Java 程序如何运行在计算机上之后，我们再来讲一讲平时学的一些 Java 基础知识，它们到底有什么用？</p><p>其实平时这一些 Java 基础语法都仅仅是你写代码的一些基础知识，就相当于英语中的 26 个字母，常见的有基本类型变量、for 循环、if else 等等基本语法，掌握了这些基础知识之后，你就可以上手写一些很简单的代码了。</p><p>除此之外，Java 还有一些比较特别的概念，比如面向对象的特性，其中有类、接口等概念。为什么 Java 要引入这些东西呢，其实就是想让使用者更好地进行设计、抽象和编程。</p><p>对于新手来说，你不需要理解得特别的深刻，因为这些东西只有你在你真正写代码之后才能逐步去理解。</p><p>说完基本知识之后，我想你也会好奇，Java里经常提到的一些集合类是干嘛的呢，因为在现实生活中有很多场景，需要用到集合类，比如说一个用户名列表，你要怎么存呢？</p><p>你会用一个 List 来做对不对，所以集合类的作用就是让你在编程中更好的存储数据。</p><p>事实上，集合类的概念最早是来源于数据结构的，因为计算机里有很多特殊的数据存储结构，比如文件树，比如链表和数组等结构，因此计算机理论把这些存储数据的模型抽象成一些常见的结构，统称为数据结构。</p><p>那么，Java 中的并发编程又是做什么的呢，Java 中的多线程是为了更好地利用电脑中的CPU核心，通过并发编程，就可以提高程序并发的效率。</p><p>但是并发编程的背后需要操作系统的支持，以及计算机硬件的支持，所以，如果你要完全地理解多线程，绝不仅仅是理解 Java 里的 Thread 或者是线程池就足够了，你还需要去理解操作系统，以及计算机组成原理。</p><p>辣椒，红辣椒，黄辣椒，蔬菜，杂货，戒指，农产品，红色，黄色，颜色，食物，手臂，手腕，手，烹饪，购物，健康，新鲜，饮食，食谱</p><p>和并发编程类似，Java 里也有网络编程的概念，Java 里的网络编程和其他语言大同小异，其实也是基于 TCP/IP 协议实现的一套 API，通过网络编程，你就可以在程序中把你想传输的数据传输到网络的另一端，有了网络编程和并发编程之后，Java 程序员的能量已经很大了</p><p>讲完这几点之后接下来再谈谈，我们通常说的 Java 后端技术到底是什么，就拿支付宝来举例吧，曾经的支付宝用户数并不多，一台服务器，一个数据库就可以支持所有的业务了。</p><p>当支付宝的用户越来越多的时候，一台服务器无法同时满足海量用户的需求，于是开始出现了多台服务器，多台服务器组成了一个集群，用户可以通过负载均衡的方式访问这些服务器，每个用户可能会访问到不同的机器上，这样子就达到了分流的效果，服务器的压力就会减小。</p><p>由于数据库需要保证数据的可靠性，万一某一台数据库挂了，并且没有备份的话，那么这个数据就无法访问了，这在大型系统中是不允许出现的，于是乎，就有了数据库的主从部署。</p><p>但事实上，随着业务发展，数据库的压力也越来越大，主备部署并不能解决数据库访问性能的问题，于是乎我们需要进行分库分表，在数据库主备的基础上，我们会把一个数据量很大的表拆成多个表，并且把数据库请求分流到不同的数据上，比如说100个分库，100个分表，就相当于把一个数据表划分成10000个数据表。</p><p>此时又出现一个问题，如果一个数据库有多个备库，并且当主库挂掉的时候需要进行主从切换时，主备数据库之间的数据就可能发生不一致，而这也是分布式理论研究的问题之一，因为比较复杂，我们这里就略过不讲。</p><p>肖像、女人、微笑、购物、口香糖、糖果、糖果、快乐、欢乐、笑声、微笑、高加索人、眼镜、手、携带、乐趣</p><p>刚才说到了分布式技术，其实负载均衡、分库分表都是分布式技术的一种实现，如果你不想做分库分表，那还有什么办法能够减轻数据库访问的压力呢？于是缓存就出现了，缓存可以让服务器先把请求打到缓存上，由于缓存的数据一般在内存中，所以访问速度会非常快，这些请求无需经过数据库。</p><p>随着业务发展，缓存的单点压力也会比较大，于是乎分布式缓存就出现了，通常来说，缓存难以保证数据的可靠性，因为它们的数据可能会丢失，同时缓存只能存储一部分的数据，并不能解决所有问题。</p><p>所以当某些业务的请求量非常大的时候，光靠缓存也解决不了问题，此时我们还可以通过消息队列来帮我们解决大流量并发请求的问题。</p><p>我们可以通过消息队列来存储一部分的请求消息，然后根据我们服务器处理请求的能力，把消息再逐步取出来，接着去把这些消息逐渐地进行处理，这样就可以很好的解决高并发的问题。当然，前提是消息队列要保证消息存储的可靠性，这也是大部分消息队列都会保证的能力。</p><p>杂志，书堆，商店，商店，摊位，货架，纸张，杂志商店，杂志商店</p><p>一口气讲了这么多，算是把 Java 后端的大概面貌介绍清楚了，除此之外还有很多东西没讲到，真要讲完的话一晚上也说不完。</p><p>总体来说，Java 后端技术，说难不难说简单也不简单，我尽量把这些内容都讲的比较通俗易懂，事实上每项技术的背后都有特别多复杂的实现原理，当然，在你理解了 Java 后端技术的整体概念以后，相信对于你之后的学习会更有帮助。</p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzIwMTY0NDU3Nw%3D%3D%26mid%3D2651940039%26idx%3D1%26sn%3D7f4fc4efdfc2d928048d458e5af709a2%26chksm%3D8d0f0b89ba78829f7ba4aaed8fae72b6648b65de5e9b5b9e626a94226efd05623e6ed8398815%26mpshare%3D1%26scene%3D1%26srcid%3D%26sharer_sharetime%3D1567479687548%26sharer_sh\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-def03a073a6ba4fde49f3a3b4034c25e_180x120.jpg\" data-image-width=\"1280\" data-image-height=\"543\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用大白话告诉你 ：Java 后端到底是在做什么？</a><p></p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81834345", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 1, 
            "title": "Spring 中的 AOP 详解", 
            "content": "<p>1 什么是 AOP ?</p><p>AOP ，即面向切面编程。其作用为对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>2 AOP 的作用</p><p>将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，将它们独立到非业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。</p><p>3 部分 AOP 常用术语</p><p>切面(Aspect)</p><p>Aspect 声明类似于 Java 中的类声明，在 Aspect 中会包含着一些 Pointcut 以及相应的 Advice。</p><p>连接点（Joint point）</p><p>表示在程序中明确定义的点，典型的包括方法调用，对类成员的访问以及异常处理程序块的执行等等，它自身还可以嵌套其它 joint point。Joint point 是所有可能被织入 Advice 的候选的点, 在 Spring AOP中, 则可以认为所有方法执行点都是 Joint point，通俗的讲，连接点即表示类里面可以被增强的方法。</p><p>通知(Advice)：定义了切面何时调用</p><p>Before：在方法被调用之前调用通知</p><p>After：在方法完成之后调用通知，无论方法执行是否成功</p><p>After-returning：在方法成功执行之后调用通知</p><p>After-throwing：在方法抛出异常后调用通知</p><p>Around：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</p><p>切点(PointCut)</p><p>切点定义了何处，切点的定义会匹配通知所要织入的一个或多个连接点，我们通常使用明确的类的方法名称来指定这些切点，或是利用正则表达式定义匹配的类和方法名称来指定这些切点。PointCut 的作用就是提供一组规则来匹配 joinpoint, 给满足规则的 joinpoint 添加 Advice。</p><p>目标对象（Target）</p><p>织入 Advice 的目标对象.。</p><p>织入（Weaving）</p><p>将 Aspect 和其他对象连接起来, 并创建 Adviced object 的过程</p><p>4 Spring AOP 代理对象的生成</p><p>AOP 技术应该如何实现？这就不得不说我们以前学习过的一种设计模式了 – 代理模式。实际上实现 AOP 的方法有两种，一是静态织入，使编译器在编译期间织入有关方面的代码；二是动态代理，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行。</p><p>Spring AOP 采用的是动态代理方式，提供了JDKProxy 和 Cglib 两种方式来生成代理对象。</p><p>JDKProxy 和 Cglib 的异同</p><p>JDK动态代理一般针对实现了接口的类生成代理，若目标没有实现接口，则默认会采用CGLIB代理。若目标实现了接口，使用JDK实现代理。</p><p>两种动态代理本质上都是字节码组装。</p><p>CGLib的效率没有使用JDK代理机制高，速度平均要慢8倍左右。</p><p>5 实战</p><p>AOP 在 Spring 中有两种配置方式，一是 xml 配置的方式，二是自动注解的模式。我们平时一般不会使用 xml 配置的方式，故我们今天只讲解自动注解的模式。</p><p>导入依赖如下：</p><p>&lt;project xmlns=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/POM/4.0.0\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/POM/4.</span><span class=\"invisible\">0.0</span><span class=\"ellipsis\"></span></a>&#34; xmlns:xsi=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34;</p><p>  xsi:schemaLocation=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/POM/4.0.0\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/POM/4.</span><span class=\"invisible\">0.0</span><span class=\"ellipsis\"></span></a> <a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/xsd/maven-4.0.0.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/xsd/ma</span><span class=\"invisible\">ven-4.0.0.xsd</span><span class=\"ellipsis\"></span></a>&#34;&gt;</p><p>  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  &lt;groupId&gt;edu.szu&lt;/groupId&gt;</p><p>  &lt;artifactId&gt;AOPTest&lt;/artifactId&gt;</p><p>  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</p><p>  &lt;packaging&gt;jar&lt;/packaging&gt;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  &lt;name&gt;AOPTest&lt;/name&gt;</p><p>  &lt;url&gt;<a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Welcome to Apache Maven</a>&lt;/url&gt;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  &lt;properties&gt;</p><p>  \t&lt;spring.version&gt;5.1.5.RELEASE&lt;/spring.version&gt;</p><p>  \t&lt;aspectj.version&gt;1.9.0&lt;/aspectj.version&gt;</p><p>  \t&lt;cglib.version&gt;2.2&lt;/cglib.version&gt;</p><p>    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</p><p>  &lt;/properties&gt;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  &lt;dependencies&gt;</p><p>    &lt;dependency&gt;</p><p>      &lt;groupId&gt;junit&lt;/groupId&gt;</p><p>      &lt;artifactId&gt;junit&lt;/artifactId&gt;</p><p>      &lt;version&gt;3.8.1&lt;/version&gt;</p><p>      &lt;scope&gt;test&lt;/scope&gt;</p><p>    &lt;/dependency&gt;</p><p>    &lt;dependency&gt;</p><p>\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</p><p>\t\t\t&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;</p><p>\t\t\t&lt;version&gt;${spring.version}&lt;/version&gt;</p><p>\t&lt;/dependency&gt;</p><p>\t&lt;dependency&gt;</p><p>\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</p><p>\t\t\t&lt;artifactId&gt;spring-context&lt;/artifactId&gt;</p><p>\t\t\t&lt;version&gt;${spring.version}&lt;/version&gt;</p><p>\t&lt;/dependency&gt;</p><p>\t&lt;dependency&gt;</p><p>\t\t\t&lt;groupId&gt;org.springframework&lt;/groupId&gt;</p><p>\t\t\t&lt;artifactId&gt;spring-core&lt;/artifactId&gt;</p><p>\t\t\t&lt;version&gt;${spring.version}&lt;/version&gt;</p><p>\t&lt;/dependency&gt;</p><p>    &lt;!-- AspectJ --&gt;</p><p>    &lt;dependency&gt;</p><p>            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</p><p>            &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt;</p><p>            &lt;version&gt;${aspectj.version}&lt;/version&gt;</p><p>    &lt;/dependency&gt;</p><p>    &lt;dependency&gt;</p><p>            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</p><p>            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</p><p>            &lt;version&gt;${aspectj.version}&lt;/version&gt;</p><p>    &lt;/dependency&gt;</p><p>    &lt;dependency&gt;</p><p>\t\t\t&lt;groupId&gt;cglib&lt;/groupId&gt;</p><p>\t\t\t&lt;artifactId&gt;cglib&lt;/artifactId&gt;</p><p>\t\t\t&lt;version&gt;${cglib.version}&lt;/version&gt;</p><p>\t&lt;/dependency&gt;</p><p>  &lt;/dependencies&gt;</p><p>&lt;/project&gt;</p><p>然后我们新建一个配置文件 applicationContext.xml</p><p>&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</p><p>&lt;beans xmlns=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/beans</a>&#34;  </p><p>         xmlns:xsi=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34;  </p><p>         xmlns:aop=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/aop\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/aop</a>&#34;  </p><p>         xmlns:context=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/context</a>&#34;  </p><p>         xsi:schemaLocation=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/beans</a> </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans/spring-beans.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans/spring-beans.xsd</span><span class=\"ellipsis\"></span></a>  </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/aop\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/aop</a> </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/aop/spring-aop.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/aop/spring-aop.xsd</span><span class=\"ellipsis\"></span></a>  </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Index of /schema/context</a> </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/context/spring-context.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/context/spring-context.xsd</span><span class=\"ellipsis\"></span></a>&#34;&gt;  </p><p>  \t&lt;context:component-scan base-package=&#34;edu.szu.AOPTest&#34;/&gt;</p><p>   \t&lt;!-- 激活自动代理功能 --&gt;</p><p>\t&lt;aop:aspectj-autoproxy /&gt;\t</p><p class=\"ztext-empty-paragraph\"><br/></p><p>&lt;/beans&gt;</p><p>然后创建一个类</p><p>@Component</p><p>public class BookManager {</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic void addBook() {</p><p>\t\tSystem.out.println(&#34;增加书本&#34;);</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic void deleteBook() {</p><p>\t\tSystem.out.println(&#34;删除书本&#34;);</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic void updateBook() {</p><p>\t\tSystem.out.println(&#34;修改书本&#34;);</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic void selectBook() {</p><p>\t\tSystem.out.println(&#34;查询书本&#34;);</p><p>\t}</p><p>}</p><p>新建一个切面，@Aspect 注解表示这是一个切面类</p><p>@Aspect</p><p>@Component</p><p>public class AspectJAdvice {</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\t// 配置切点</p><p>\t@Pointcut(&#34;execution(* edu.szu.AOPTest.BookManager.addBook(..))&#34;)</p><p>\tprivate void aspectJMethod(){};</p><p>\t// 配置连接点 方法开始执行时通知</p><p>\t@Before(&#34;aspectJMethod()&#34;)</p><p>\tpublic void doBefore(JoinPoint joinPoint){</p><p>\t\tSystem.out.println(&#34;doBefore()&#34;);</p><p>\t}</p><p>\t// 环绕通知</p><p>\t@Around(&#34;aspectJMethod()&#34;)</p><p>\tpublic Object doAround(ProceedingJoinPoint pjp) throws Throwable{</p><p>\t\tSystem.out.println(&#34;doAround()开始&#34;);</p><p>\t\t//核心逻辑</p><p>\t\tObject retval = pjp.proceed();</p><p>\t\tSystem.out.println(&#34;doAround()结束&#34;);</p><p>\t\treturn retval;</p><p>\t}</p><p>\t// 方法执行完后通知</p><p>\t@After(value=&#34;aspectJMethod()&#34;)</p><p>\tpublic void doAfter(JoinPoint joinPoint){</p><p>\t\tSystem.out.println(&#34;doAfter()&#34;);</p><p>\t}</p><p>\t// 执行成功后通知</p><p>\t@AfterReturning(value=&#34;aspectJMethod()&#34;)</p><p>\tpublic void doReturn(JoinPoint joinPoint){</p><p>\t\tSystem.out.println(&#34;doReturn()&#34;);</p><p>\t}</p><p>\t// 抛出异常后通知</p><p>\t@AfterThrowing(value=&#34;aspectJMethod()&#34;, throwing=&#34;e&#34;)</p><p>\tpublic void doThrowing(JoinPoint joinPoint,Exception e){</p><p>        System.out.println(&#34;doThrowing() &#34; + e);  </p><p>\t}</p><p>}</p><p>测试一下</p><p>public class Test {</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic static void main(String[] args) {</p><p>\t\tSystem.out.println(&#34;开始测试！&#34;);</p><p>\t\tBeanFactory factory=new ClassPathXmlApplicationContext(&#34;applicationContext.xml&#34;);</p><p>\t\tBookManager bookManager=(BookManager) factory.getBean(BookManager.class);</p><p>\t\tbookManager.addBook();</p><p>\t}</p><p>}</p><p>结果如图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-31c3585b1b4806a626da758ecf6dc408_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"729\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb\" width=\"729\" data-original=\"https://pic1.zhimg.com/v2-31c3585b1b4806a626da758ecf6dc408_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;729&#39; height=&#39;213&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"729\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"729\" data-original=\"https://pic1.zhimg.com/v2-31c3585b1b4806a626da758ecf6dc408_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-31c3585b1b4806a626da758ecf6dc408_b.jpg\"/></figure><p>可以看到，如果增强的方法中不抛出异常的话，@AfterThrowing 标注的方法不会执行，其他四种执行的顺序如图所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-86b2936fba0701f1b80aad8033ff8c37_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"608\" data-original=\"https://pic4.zhimg.com/v2-86b2936fba0701f1b80aad8033ff8c37_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;608&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"608\" data-original=\"https://pic4.zhimg.com/v2-86b2936fba0701f1b80aad8033ff8c37_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-86b2936fba0701f1b80aad8033ff8c37_b.jpg\"/></figure><p>现在我们修改一下 addBook（）方法，增加一个异常，看看执行的结果如何。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c92c90950a187b51f2e75c58804f56ea_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"121\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic3.zhimg.com/v2-c92c90950a187b51f2e75c58804f56ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;121&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"121\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic3.zhimg.com/v2-c92c90950a187b51f2e75c58804f56ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c92c90950a187b51f2e75c58804f56ea_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-caec411e485e70df08764ff8ae7bc409_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic2.zhimg.com/v2-caec411e485e70df08764ff8ae7bc409_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic2.zhimg.com/v2-caec411e485e70df08764ff8ae7bc409_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-caec411e485e70df08764ff8ae7bc409_b.jpg\"/></figure><p>我们可以清晰的看到，当增强的方法抛出异常时，环绕通知后面那一半跟执行成功通知不再执行，并执行抛出异常后通知。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1a7a78bcac9ef3d88df9d84141c498da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"847\" data-rawheight=\"445\" class=\"origin_image zh-lightbox-thumb\" width=\"847\" data-original=\"https://pic3.zhimg.com/v2-1a7a78bcac9ef3d88df9d84141c498da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;847&#39; height=&#39;445&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"847\" data-rawheight=\"445\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"847\" data-original=\"https://pic3.zhimg.com/v2-1a7a78bcac9ef3d88df9d84141c498da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1a7a78bcac9ef3d88df9d84141c498da_b.jpg\"/></figure><p><i>版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Geffin/article/details/98394471\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/Geffin/ar</span><span class=\"invisible\">ticle/details/98394471</span><span class=\"ellipsis\"></span></a></i></p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81832377", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 2, 
            "title": "Java设计模式——命令模式", 
            "content": "<h2>命令模式</h2><p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4bf03e144656bc29d514c3ae7935ae70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"234\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-4bf03e144656bc29d514c3ae7935ae70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;234&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"234\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-4bf03e144656bc29d514c3ae7935ae70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4bf03e144656bc29d514c3ae7935ae70_b.jpg\"/></figure><p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：</p><p>public interface Command {  </p><p>    public void exe();  </p><p>}  </p><p>public class MyCommand implements Command {  </p><p>    private Receiver receiver;  </p><p>    public MyCommand(Receiver receiver) {  </p><p>        this.receiver = receiver;  </p><p>    }  </p><p>    @Override  </p><p>    public void exe() {  </p><p>        receiver.action();  </p><p> }  </p><p>}  </p><p>public class Receiver {  </p><p>    public void action(){  </p><p>        System.out.println(&#34;command received!&#34;);  </p><p>    }  </p><p>}  </p><p>public class Invoker {      </p><p>    private Command command;  </p><p>    public Invoker(Command command) {  </p><p>        this.command = command;  </p><p>    }  </p><p>   public void action(){  </p><p>        command.exe();  </p><p>    }  </p><p>}  </p><p>public class Test {  </p><p>    public static void main(String[] args) {  </p><p>        Receiver receiver = new Receiver();  </p><p>        Command cmd = new MyCommand(receiver);  </p><p>        Invoker invoker = new Invoker(cmd);  </p><p>        invoker.action();  </p><p>    }  </p><p>}  </p><p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><p>介绍</p><p>意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p><p>主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。</p><p>何时使用：在某些场合，比如要对行为进行&#34;记录、撤销/重做、事务&#34;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将&#34;行为请求者&#34;与&#34;行为实现者&#34;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。</p><p>如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。</p><p>关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口</p><p>应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。</p><p>优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。</p><p>缺点：使用命令模式可能会导致某些系统有过多的具体命令类。</p><p>使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。</p><p>注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。</p><p>————————————————</p><p><i>版权声明：本文为CSDN博主「No_Game_No_Life_」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</i></p><p><i>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/No_Game_No_Life_/article/details/85989272\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/No_Game_N</span><span class=\"invisible\">o_Life_/article/details/85989272</span><span class=\"ellipsis\"></span></a></i></p>", 
            "topic": [
                {
                    "tag": "Java 设计模式深入研究（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20833303"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81777642", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 1, 
            "title": "面向对象", 
            "content": "<p>什么是面向对象</p><p>面向对象和面向过程对比</p><p>面向对象:</p><p>面向对象是宏观的上为用户解决功能需求，用户只需要知道怎么用对象实现功能就好了，具体底层如何实现不用操心，不过面向对象的最底层还是以面向过程的方式实现，但面向对象对比面向过程，减少了学习成本。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>面向过程:</p><p>面向对象是微观下对要实现的功能进行详细设计。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类和对象的关系</p><p>类：</p><p>类是对象的抽象，是将对象的相同部分提取出来</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对象：</p><p>对象是对类的具象化的体系</p><p class=\"ztext-empty-paragraph\"><br/></p><p>先有类还是先有对象:</p><p>在编写过程中，是先有类，再有对象。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类加载</p><p>1:调用当前类中的静态方法时</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2:创建当前类的实例对象时</p><p class=\"ztext-empty-paragraph\"><br/></p><p>构造器</p><p>构造器</p><p>在类中用来创建对象那个的方法称之为构造器</p><p class=\"ztext-empty-paragraph\"><br/></p><p>方法名与类名相同</p><p>没有返回值</p><p>允许方法重载</p><p>在默认情况下会自动生成无参构造器，但如果你写了构造器在不会生成。</p><p>构造器的调用：</p><p>通过new对象，自动调用构造器</p><p>通过 this() 或 super() 分别调用当前类的构造方法和其父类的的构造方法。</p><p>this的方法</p><p>this.</p><p>​\t当前对象的属性或方法</p><p>​\t可省略：使用的范围内，没有同名变量时（无异议时）</p><p>​\t不可省略：区分同名变量，局部变量和成员变量（有异议时）</p><p>this()</p><p>​\t构造器之间的互相调用</p><p>​\tthis()一定要在构造器的首行</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d9c1d50821b352119180cbbdf9157f1d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"898\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"898\" data-original=\"https://pic2.zhimg.com/v2-d9c1d50821b352119180cbbdf9157f1d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;898&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"898\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"898\" data-original=\"https://pic2.zhimg.com/v2-d9c1d50821b352119180cbbdf9157f1d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d9c1d50821b352119180cbbdf9157f1d_b.jpg\"/></figure><p>继承</p><p>继承的优势：</p><p>在一定程度上提高了代码的复用性</p><p>继承编写：</p><p>子类 extends 父类 子类拥有父类中的所有的属性以及方法 (根据修饰确定是否能够全部继承)</p><p>什么是继承：</p><p>将多个类中的共性再一次抽取，抽取为一个父类。父类的作用就是用来将一些重复的内容不再多次编写(提高代码复用性)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意事项：</p><p>java中只支持单继承 一个子类有且只能有一个父类 复用性的提高是有限的</p><p>多继承好还是单继承好</p><p>多继承 ：极大提高代码复用性 但是代码调用的复杂度也提升了</p><p>单继承：代码调用的复杂度比较低，但是复用性比较有限</p><p>假设在应用场景中：</p><p>A-&gt;B 后期随着业务不断扩展，导致A需要继承C时一般的解决办法：A-&gt;B-&gt;C</p><p>但是该种解决办法随着后期业务的不断升级，导致整个继承连会变得极其复杂，既不利于后期维护以及拓展。</p><p>能不能用继承就别用继承。</p><p>super的用法</p><p>​\t当创建子类对象时 会先执行父类的构造器</p><p>​\tsuper: 和this的用法一模一样</p><p class=\"ztext-empty-paragraph\"><br/></p><p>super.</p><p>当前对象的父类对象的</p><p>super. 可省略的：</p><p>super和this的用法是重复的 都可以省略（就是没有同名时）</p><p>super. 不可省略</p><p>如果子类和父类中出现了同名变量或者是同名方法</p><p>super()</p><p>调用父类的构造器，默认情况下调用的父类的无参构造器(默认情况下每个类中都存再一个无参构造器 哪怕不写也存在)</p><p>当父类中存在其他构造器时，无参构造器不存在，此时如果再子类中没有通过super()显示的指定调用的构造器会导致程序报错。</p><p>在构造器中this()和super()不能同时出现，如果两个都不存在，则默认存在super()。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-06311d70cb04689aeb6ccbf273f7faa9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-06311d70cb04689aeb6ccbf273f7faa9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-06311d70cb04689aeb6ccbf273f7faa9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-06311d70cb04689aeb6ccbf273f7faa9_b.jpg\"/></figure><p>方法重写</p><p>在子类中定义了和父类中同名的方法 我们将该方法称之为重写方法(覆盖)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么需要重写？</p><p>父类的功能不能满足子类的需求。子类在父类的基础上进行了扩展。</p><p>如何确定一个方法是重写方法？</p><p>在子类的方法上加入@Overried 注解 如果不报错 证明是重写</p><p>重写的前提：</p><p>一定要发生继承关系。并且子类的方法名和父类的方法名同名</p><p>参数列表要一样</p><p>返回类型要一样</p><p>Object</p><p>Object: 是所有类的根基类 超类 父类</p><p>当一个类没有显式的继承关系的时候，默认情况下他的父类都是Object</p><p>Object:</p><p>toString ： 输出对象 全限定名(包名.类名)@16进制hash值</p><p>输出一个对象的时候默认情况下会调用当前对象的toString</p><p>getClass：获取当前类的Class对象 反射</p><p>== 比较基本数据类型比较的是值 比较引用类型比较的是地址</p><p>equals:如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；诸如String、Date等类对equals方法进行了重写的话，比较的是所是否是同一类型的对象(不一定是同一对象)，内容是否相等。</p><p>Object中的比较是通过==比较的</p><p>封装</p><p>权限修饰符</p><p>权限修饰符\t本类\t同包下子类\t同包下无关类\t异包子类\t异包下无关类</p><p>public\t√\t√\t√\t√\t√</p><p>protected\t√\t√\t√\t√\t×</p><p>默认的\t√\t√\t√\t×\t×</p><p>private\t√\t×\t×\t×\t×</p><p>注意：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于class的权限修饰只可以用public和default(默认的)。</p><p>状态修饰符</p><p>static(静态的)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以修饰成员变量,成员方法,不能修饰类（除了内部类）,不能修饰构造方法。</p><p>被修饰的变量，方法可以通过类名进行调用。</p><p>可以修饰静态代码块 静态方法 静态变量 静态常量</p><p>静态方法不可以直接调用调用非静态方法 可以创建对象调用</p><p>非静态方法可以调用静态方法</p><p>静态内容共享的 被所有类和对象共享 修改之后都可见</p><p>静态内容可以通过类名. 或者是对象.</p><p>类加载就会被加载 只被加载一次</p><p>不可以使用this.和super.</p><p>静态内容调用时会导致类被加载</p><p>final（最终的）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以修饰类,成员变量,成员方法,不能修饰构造方法。</p><p>修饰的类不能被继承，被修饰的变量是常量，被修饰的方法不能被继承。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>抽象修饰符</p><p>abstract(抽象的)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不能修饰构造方法,不能修饰成员变量,可以修饰类（接口）,成员方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>被修饰的类（接口）不能被实例化，只能被继承，被修饰的成员方法在子类中必须被重写</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结</p><p>修饰符\t类\t成员变量\t成员方法\t接口\t构造方法</p><p>public\t√\t√\t√\t√\t√</p><p>protected\tx(外部类)\t√\t√\t×\t√</p><p>default(默认的)\t√\t√\t√\t√\t√</p><p>private\tx(外部类)\t√\t√\t×\t√</p><p>static(静态的)\t√（内部类）\t√\t√\t×\t×</p><p>final（最终的）\t√\t√\t√\t×\t×</p><p>abstract(抽象的)\t√\t×\t√\t√\t×</p><p>单例模式</p><p>单例模式</p><p>一个类只能产生一个实例对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何编写</p><p>1:构造器私有</p><p>2：对外提供过去对象的方法</p><p>3：声明一个static的成员变量 类加载的时候创建当前单例对象</p><p>4：在获取对象方法中返回成员变量的值</p><p>饿汉式</p><p>优缺点分析</p><p>优点： 天然线程安全</p><p>缺点： 不能做到延迟加载</p><p>public class Single {</p><p>    // 声明一个Single对象</p><p>    public static Single single = new Single();</p><p>    //1：将构造器私有</p><p>    private Single() {</p><p>    }</p><p>    /**</p><p>    * public : 外界一定是通过该方法获取当前类的实例对象 所以对外一定要可见</p><p>    * static : 构造器都私有了 外部肯定无法获取到当前类的实例对象 所以只能用static修饰 属于类的 \t可以通</p><p>    过类名调用</p><p>    * 不加static要通过对象调用 对象没有</p><p>    * 返回值 : 当前类的实例</p><p>    *</p><p>    */</p><p>    public static Single getInstance() {</p><p>    \treturn single;</p><p>    }</p><p>    public static void add() {</p><p>    }</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>懒汉式</p><p>优缺点分析</p><p>优点： 能够做到延迟加载</p><p>缺点： 但是线程不安全</p><p>public class Lazy {</p><p>    private static Lazy lazy = null;</p><p>    private Lazy() {</p><p>    }</p><p>    public static Lazy getInstance() {</p><p>    \tif(lazy==null) {</p><p>    \t\tlazy = new Lazy();</p><p>    \t}</p><p>    \treturn lazy;</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>多态</p><p>多种形态</p><p class=\"ztext-empty-paragraph\"><br/></p><p>多态前提</p><p>继承关系</p><p>父类变量指向了子类对象</p><p>一定要有方法的重写</p><p>类的加载顺序</p><p>{} 代码块：</p><p>局部代码块：</p><p>声明在方法中的代码块</p><p>缩减局部变量的生命周期 提高内存是使用率</p><p>成员代码块：</p><p>声明在方法外 类中的代码块 初始化块</p><p class=\"ztext-empty-paragraph\"><br/></p><p>初始化块在类加载的时候是不会执行的</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在创建对象之前会被调用(对于对象中的一些初始进行初始化操作)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>静态代码块:</p><p>声明在类中 方法外 且使用static修饰</p><p>类加载的时候就会被加载 并且只加载1次 静态内容</p><p>类中的执行顺序：</p><p>1：首先执行静态内容(加载) 静态代码块</p><p>2：初始化块</p><p>3：构造器</p><p>类型转换</p><p>引用类型也有类型转换：</p><p>自动转换</p><p>父类型 变量名 = 子类对象;（new 子类对象 或 子类对象的变量）</p><p>强制转换</p><p>子类型 变量名 = (子类型)父类变量;</p><p>事先确定了父类变量中实际存储的对象是什么类型，相同类型才能转 ，不然报 ClassCastException 类型转换异常错误</p><p>final</p><p>final修饰的变量称之为最终常量 在程序运行期间其值不可发生改变</p><p>final修饰的类不可以被继承：太监类</p><p>final修饰的方法不可以被重写</p><p>final修饰静态常量经过方法</p><p>final 修饰的基本数据类型变量 无法进行修改其值。</p><p>final 修饰的引用类型的变量 只保证地址不变 对象中的内容可以发生改变</p><p>final修饰的静态常量不会导致类加载</p><p>静态成员常量不会导致类加载</p><p>静态成员常量的值在加载前无法确定 那么会导致类加载（如下代码）</p><p>public class Test02 {</p><p>    final static int num  = (int)(Math.random()*33);//10;</p><p>    static {</p><p>    \tSystem.out.println(&#34;我是静态代码块&#34;);</p><p>    }</p><p>    public static void main(String[] args) {</p><p>   \t\tSystem.out.println(Test02.num);</p><p>    }</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public class Test03 {</p><p>    public static void main(String[] args) {</p><p>    \tSystem.out.println(Test02.num);</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类的加载顺序</p><p>分析：</p><p>先加载静态内容 -&gt; 静态代码块</p><p>由于父子关系 所以子类加载之前需要先加载父类</p><p>执行的父类的初始化块和构造器（因为子类构造器中有一个super）</p><p>然后执行子类的初始化块和构造器</p><p>加载顺序：</p><p>父类的静态代码块</p><p>子类的静态代码块</p><p>父类的初始化块</p><p>父类的构造器</p><p>子类的初始化块</p><p>子类的构造器</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>abstract 抽象类</p><p>抽象类基础概念</p><p>​\t1: 父类中定义的方法不需要具体的实现步骤 子类都不按照父类的做</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t2： 父类中定义这个方法的目的是告诉子类 一定要保证存在该方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于类的要求：</p><p>​\t1：父类中不需要定义方法的实现步骤</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t2：子类必须要重写</p><p class=\"ztext-empty-paragraph\"><br/></p><p>抽象类：</p><p>​\t包含了抽象方法的的类称之为抽象类。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t被abstract修饰的类称之为抽象了</p><p class=\"ztext-empty-paragraph\"><br/></p><p>抽象方法：</p><p>​\t只要方法的声明，没有方法体。 通过abstract修饰的方法称之为抽象方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么需要抽象类？</p><p>​\t避免子类的随意设计 提高了代码可读性 提高了子类的健壮性</p><p class=\"ztext-empty-paragraph\"><br/></p><p>深入理解抽象类</p><p>1:抽象类中只能包含抽象方法吗?</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t既可以定义抽象方法也可以定义普通方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2:是否可以定义构造器</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t抽象类可以存在构造器但是无法实例化</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t抽象类中的构造器是给子类准备的</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t抽象类就是用来被继承的 抽象方法就是被重写的</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3:子类继承了抽象了之后一定要重写所有的抽象方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口</p><p>接口是一个规范 是一套标准 比抽象类还抽象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口的简单定义</p><p>修饰符 interface 接口名{}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口中的变量都是公开的 静态的最终常量值 默认情况下变量都是public static final修饰</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口中可以定义静态方法(不建议1.8)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口中定义的对象方法都是抽象方法 接口中的方法默认就是通过abstract修饰的</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口中的默认方法从1.8之后才开始被使用 允许在接口中定义default方法 而且存在方法体</p><p class=\"ztext-empty-paragraph\"><br/></p><p>深入理解接口</p><p>接口深入：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类和接口直接通过implements 发生关系 类实现接口</p><p>类必须要实现接口中的所有抽象方法</p><p>一个类可以实现多个接口 类名 implements 接口1，接口2。。。。。</p><p>一个类实现了接口之后 要将当前接口以及接口的父接口中的所有抽象方法全部重写</p><p>接口可以多继承</p><p>接口无法实例化</p><p>接口没有构造器</p><p>接口中也可以使用多态</p><p>Tips:</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接口就是一套规则，用来定义具体要做哪些事情，但是所有事情的具体实现都会延迟到实现类中完成。接口只需要定义has-a的关系，如果你是什么，则你具备了什么能力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>equals方法</p><p>equals方法就是用来比较两个对象是否相等的，默认Object的equals方法比较是两个对象的地址。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.lang.NullPointerException 空指针异常 对象为null</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ClassCastException 类型转换异常</p><p class=\"ztext-empty-paragraph\"><br/></p><p>null可以强转为任意类型</p><p class=\"ztext-empty-paragraph\"><br/></p><p>null用instanceof 跟任何类型比较时都是false</p><p class=\"ztext-empty-paragraph\"><br/></p><p>内部类</p><p>普通内部类</p><p>外部类中如何使用内部类的属性以及方法</p><p>在外部类中创建内部类对象，就可以调用内部类功能、属性</p><p class=\"ztext-empty-paragraph\"><br/></p><p>内部类中使用外部类的属性以及方法</p><p>可以直接使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其它类中调用内部类中的属性和方法：</p><p>第一种：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\ta：导包 包名.外部类.内部类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tb：内部类类型 变量名= new 外部类对象().new 内部类对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tInner01 in = new Outer01().new Inner01();</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第二种：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t外部类.内部类 变量名= new 外部类对象().new 内部类对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tOuter01.Inner01 in = new Outer01().new Inner01();</p><p class=\"ztext-empty-paragraph\"><br/></p><p>静态内部类</p><p>静态内部类：</p><p>通过static修饰的内部类称之为静态内部类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\ta：外部类中如何使用静态内部类的属性以及方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t创建对象，调用对象的属性以及方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tb:静态内部类中使用外部类的属性以及方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t创建外部类的对象 调用对象的属性以及方法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tc:其它类中调用内部类中的属性和方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t第一种：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\ta：导包 包名.外部类.内部类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tb：内部类类型 变量名= new 外部类. 内部类对象()</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tInner01 in = new Outer02.Inner01();</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t第二种：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t外部类.内部类 变量名= new 外部类. 内部类对象()</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tOuter01.Inner01 in =new Outer02.Inner01();</p><p class=\"ztext-empty-paragraph\"><br/></p><p>编写静态内部类完成单例模式创建</p><p>线程安全问题： 天然线程安全</p><p class=\"ztext-empty-paragraph\"><br/></p><p>延迟加载： 能做到延迟加载</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类何时被加载： 调用静态内容 创建对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类加载的时候 首先将静态内容加载大内存中</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public class Single {  </p><p>    static class SingleHolder{  </p><p>        private static Single single = new Single();  </p><p>    }   </p><p>    private Single() {  </p><p>    }    </p><p>    public static Single getInstance() {  </p><p>        return SingleHolder.single;  </p><p>    }  </p><p>    public static void add() {  </p><p>    }  </p><p>    public static void main(String[] args) {  </p><p>        Single.add();  </p><p>        Single s1 = getInstance();  </p><p>    }  </p><p>}  </p><p>局部内部类</p><p>局部内部类，这种内部类是局部的，实际上和局部变量有点类似，是定义在方法中的，不过在实际开发中，对于局部内部类的使用是很少的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>匿名内部类</p><p>通过匿名内部类可以产生一个接口/抽象了的 实现类对象/子类对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数组</p><p>什么是数组：</p><p>一组数 （数据） 的集合</p><p class=\"ztext-empty-paragraph\"><br/></p><p>官方定义：</p><p>​\t在内存中 通过连续的存储单元 存储相同数据类型的 有序集合</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何定义数组：</p><p>​\t数据类型[] 变量名;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何初始化数组：</p><p>​\t变量名 = new 数据类型[数组的长度];</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tarrs = new int[10]</p><p class=\"ztext-empty-paragraph\"><br/></p><p>获取数组中的元素</p><p>​\t数组变量[索引] （索引从0开始 到 长度-1 结束）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>获取数组中的长度：</p><p>​\t数组变量.length</p><p class=\"ztext-empty-paragraph\"><br/></p><p>编写ArrayList类</p><p>package com.mage.arrays;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public class ArrayList {</p><p>\tprivate Object[] arrs;</p><p>\tprivate int size; //数组实际存储元素个数</p><p>\tprivate int capacity;//底层arrs数组的长度,也就是开的内存空间大小</p><p>\tprivate static final int DEFAULT_CAPACITY = 10;</p><p>\tpublic ArrayList() {</p><p>\t\tthis(DEFAULT_CAPACITY);</p><p>\t}</p><p>\tpublic ArrayList(int capacity) {</p><p>\t\tarrs = new Object[capacity];</p><p>\t\tthis.capacity = capacity;</p><p>\t}</p><p>\t/**</p><p>\t * @return 返回数组实际存储的元素个数</p><p>\t */</p><p>\tpublic int size(){</p><p>\t\treturn this.size;</p><p>\t}</p><p>\t/**</p><p>\t * @return 返回当前ArrayList底层数组的容量</p><p>\t */</p><p>\tpublic int opacity() {</p><p>\t\treturn arrs.length;</p><p>\t}</p><p>\t/**</p><p>\t * @return 返回当前数组是否为null</p><p>\t */</p><p>\tpublic boolean isEmpty() {</p><p>\t\treturn this.size==0;</p><p>\t}</p><p>\t/**</p><p>\t * \t 添加元素到指定的位置上</p><p>\t * @param value 添加的元素</p><p>\t * @param index 添加的位置</p><p>\t */</p><p>\tpublic void add(Object value,int index) {</p><p>\t\tif(index&lt;0||index&gt;size) {</p><p>\t\t\tSystem.out.println(&#34;错误参数：index&#34;);</p><p>\t\t\treturn;</p><p>\t\t}</p><p>\t\t//存满了</p><p>\t\tif(size==arrs.length) {</p><p>\t\t\tresize(size*2);</p><p>\t\t}</p><p>\t\tfor(int i=size-1;i&gt;=index;i--) {</p><p>\t\t\tarrs[i+1]=arrs[i];</p><p>\t\t}</p><p>\t\tarrs[index]=value;</p><p>\t\tsize++;</p><p>\t}</p><p>\t/**</p><p>\t *  \t添加首元素</p><p>\t * @param value 添加的元素值</p><p>\t */</p><p>\tpublic void addFirst(Object value) {</p><p>\t\tadd(value,0);</p><p>\t}</p><p>\t/**</p><p>\t *  \t添加尾元素</p><p>\t * @param value</p><p>\t */</p><p>\tpublic void addLast(Object value) {</p><p>\t\tadd(value,size);</p><p>\t}</p><p>\t/**</p><p>\t *  \t查询指定元素在当前数组中的索引位置(只找一个)  </p><p>\t * @param value</p><p>\t * @return 查找的元素的索引 如果不存在返回-1</p><p>\t */</p><p>\tpublic int getIndexByValue(Object value) {</p><p>\t\tfor(int i=0;i&lt;size;i++) {</p><p>\t\t\tif(arrs[i]==value) {</p><p>\t\t\t\treturn i;</p><p>\t\t\t}</p><p>\t\t}</p><p>\t\treturn -1;</p><p>\t}</p><p>\t/**</p><p>\t *      返回指定索引位置上的元素</p><p>\t * @param index 索引</p><p>\t * @return 元素    如果返回null代表当前数组的入参有误</p><p>\t */</p><p>\tpublic Object get(int index) {</p><p>\t\tif(index&lt;0||index&gt;=size) {</p><p>\t\t\tSystem.out.println(&#34;参数有误：index&#34;);</p><p>\t\t\treturn null;</p><p>\t\t}</p><p>\t\treturn this.arrs[index];</p><p>\t}</p><p>\t/**</p><p>\t *       \t修改数组中指定位置上的元素</p><p>\t * @param index  指定的索引</p><p>\t * @param value  修改之后的值</p><p>\t * @return  修改之前的值 如果索引有问题 返回null</p><p>\t */</p><p>\tpublic Object set(int index,Object value) {</p><p>\t\tif(get(index)==null) {</p><p>\t\t\treturn null;</p><p>\t\t}</p><p>\t\tObject oldValue=arrs[index];</p><p>\t\tarrs[index]=value;</p><p>\t\treturn oldValue;</p><p>\t}</p><p>\t/**</p><p>\t * \t根据索引删除元素</p><p>\t * @param index 索引</p><p>\t * @return 删除的元素   如果索引有误 返回null</p><p>\t */</p><p>\tpublic Object remove(int index) {</p><p>\t\tif(get(index)==null) {</p><p>\t\t\treturn null;</p><p>\t\t}</p><p>\t\tObject oldValue = arrs[index];</p><p>\t\tfor(int i=index;i&lt;size-1;i++) {</p><p>\t\t\tarrs[i]=arrs[i+1];</p><p>\t\t}</p><p>\t\tsize--;</p><p>\t\tarrs[size]=null;</p><p>\t\tif(size==arrs.length/4&amp;&amp;arrs.length/2&gt;0) {</p><p>\t\t\tresize(arrs.length/2);</p><p>\t\t}</p><p>\t\treturn oldValue;</p><p>\t}</p><p>\t/**</p><p>\t *  \t删除第一个元素</p><p>\t * @return</p><p>\t */</p><p>\tpublic Object removeFirst() {</p><p>\t\treturn remove(0);</p><p>\t}</p><p>\t/**</p><p>\t *  \t删除最后元素</p><p>\t * @return</p><p>\t */</p><p>\tpublic Object removeLast() {</p><p>\t\treturn remove(size-1);</p><p>\t}</p><p>\t/**</p><p>\t * 数组扩容操作</p><p>\t * @param capacity 新数组的容量</p><p>\t */</p><p>\tprivate void resize(int capacity) {</p><p>\t\tObject[] newArrs = new Object[capacity];</p><p>\t\tcopyOf(arrs,newArrs);</p><p>\t\tarrs = newArrs;</p><p>\t}</p><p>\t/**</p><p>\t *  \t数组复制</p><p>\t * @param src 源数组</p><p>\t * @param dest 目标数组</p><p>\t */</p><p>\tprivate void copyOf(Object[] src,Object[] dest) {</p><p>\t\tfor(int i=0;i&lt;this.size;i++) {</p><p>\t\t\tdest[i]=src[i];</p><p>\t\t}</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\t/**</p><p>\t * 获取当前ArrayList的内容</p><p>\t */</p><p>\tpublic String toString() {</p><p>\t\tStringBuffer sb = new StringBuffer();</p><p>\t\tsb.append(&#34;size:&#34;+this.size+&#34;\\topacity:&#34;+this.arrs.length+&#34;\\t&#34;);</p><p>\t\tsb.append(&#34;[&#34;);</p><p>\t\tfor(int i = 0;i&lt;size;i++) {</p><p>\t\t\tsb.append(arrs[i]);</p><p>\t\t\tif(i!=size-1) {</p><p>\t\t\t\tsb.append(&#34;,&#34;);</p><p>\t\t\t}</p><p>\t\t}</p><p>\t\tsb.append(&#34;]&#34;);</p><p>\t\treturn sb.toString();</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试类</p><p>package com.mage.arrays;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public class TestArrayList {</p><p>\tpublic static void main(String[] args) {</p><p>\t\t// ArrayList存储数据的对象</p><p>\t\tArrayList arrayList = new ArrayList();// size = 0 capacity 10   </p><p>\t\t//测试增加不同类型值</p><p>\t\tarrayList.addFirst(&#39;a&#39;);</p><p>\t\tarrayList.addFirst(&#34;哈哈&#34;);</p><p>\t\tarrayList.addFirst(44);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t\t//测试在最后位置加值</p><p>\t\tarrayList.addLast(33);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t\t//测试元素加满了，内存扩容。</p><p>\t\tarrayList.addLast(33);</p><p>\t\tarrayList.addLast(33);</p><p>\t\tarrayList.addLast(33);</p><p>\t\tarrayList.addLast(33);</p><p>\t\tarrayList.addLast(33);</p><p>\t\tarrayList.addLast(44);</p><p>\t\tarrayList.addLast(55);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t\t//测试移除增加元素会撤回扩容嘛</p><p>\t\tarrayList.remove(0);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t\t//测试元素个数为原来的四分之一会压缩一半内存嘛</p><p>\t\tarrayList.remove(0);</p><p>\t\tarrayList.remove(0);</p><p>\t\tarrayList.remove(0);</p><p>\t\tarrayList.remove(0);</p><p>\t\tarrayList.remove(0);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t\t//测试修改</p><p>\t\tarrayList.set(1, &#34;被修改了&#34;);</p><p>\t\tSystem.out.println(arrayList.toString());</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>排序</p><p>冒泡排序</p><p>第一种</p><p>\tpublic static void bubbleSort01(int[] arrs) {</p><p>\t\tSystem.out.println(&#34;原数组：&#34;+toString(arrs));</p><p>\t\tfor(int i=0;i&lt;arrs.length-1;i++) {//控制趟数</p><p>\t\t\tSystem.out.println(&#34;第&#34;+(i+1)+&#34;趟&#34;);</p><p>\t\t\tfor(int j=0;j&lt;arrs.length-1;j++) {//次数</p><p>\t\t\t\tif(arrs[j]&gt;arrs[j+1]) {</p><p>\t\t\t\t\tint temp = arrs[j];</p><p>\t\t\t\t\tarrs[j] = arrs[j+1];</p><p>\t\t\t\t\tarrs[j+1] = temp;</p><p>\t\t\t\t}</p><p>\t\t\t\tSystem.out.println(&#34;第&#34;+(j+1)+&#34;次:&#34;+toString(arrs));</p><p>\t\t\t}</p><p>\t\t}</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第二种</p><p>public static void bubbleSort02(int[] arrs) {</p><p>\t\tSystem.out.println(&#34;原数组：&#34;+toString(arrs));</p><p>\t\tfor(int i=0;i&lt;arrs.length-1;i++) {//控制趟数</p><p>\t\t\tSystem.out.println(&#34;第&#34;+(i+1)+&#34;趟&#34;);</p><p>\t\t\tfor(int j=0;j&lt;arrs.length-1-i;j++) {//次数</p><p>\t\t\t\tif(arrs[j]&gt;arrs[j+1]) {</p><p>\t\t\t\t\tint temp = arrs[j];</p><p>\t\t\t\t\tarrs[j] = arrs[j+1];</p><p>\t\t\t\t\tarrs[j+1] = temp;</p><p>\t\t\t\t}</p><p>\t\t\t\tSystem.out.println(&#34;第&#34;+(j+1)+&#34;次:&#34;+toString(arrs));</p><p>\t\t\t}</p><p>\t\t}</p><p>\t}</p><p>第三种</p><p>public static void bubbleSort03(int[] arrs) {</p><p>\t\tSystem.out.println(&#34;原数组：&#34;+toString(arrs));</p><p>\t\tfor(int i=0;i&lt;arrs.length-1;i++) {//控制趟数</p><p>\t\t\t//声明一个是否排好序</p><p>\t\t\tboolean isSorted = true;</p><p>\t\t\tSystem.out.println(&#34;第&#34;+(i+1)+&#34;趟&#34;);</p><p>\t\t\tfor(int j=0;j&lt;arrs.length-1-i;j++) {//次数</p><p>\t\t\t\tif(arrs[j]&gt;arrs[j+1]) {</p><p>\t\t\t\t\tisSorted = false;</p><p>\t\t\t\t\tint temp = arrs[j];</p><p>\t\t\t\t\tarrs[j] = arrs[j+1];</p><p>\t\t\t\t\tarrs[j+1] = temp;</p><p>\t\t\t\t}</p><p>\t\t\t\tSystem.out.println(&#34;第&#34;+(j+1)+&#34;次:&#34;+toString(arrs));</p><p>\t\t\t}</p><p>\t\t\t//判定</p><p>\t\t\tif(isSorted) {</p><p>\t\t\t\tbreak;</p><p>\t\t\t}</p><p>\t\t}</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第四种</p><p>public static void bubbleSort04(int[] arrs) {</p><p>\t\tSystem.out.println(&#34;原数组：&#34;+toString(arrs));</p><p>\t\t//基准点</p><p>\t\tint index = arrs.length-1;</p><p>\t\tfor(int i=0;i&lt;arrs.length-1;i++) {//控制趟数</p><p>\t\t\t//声明一个是否排好序</p><p>\t\t\tboolean isSorted = true;</p><p>\t\t\tint tmp = 0; </p><p>\t\t\tSystem.out.println(&#34;第&#34;+(i+1)+&#34;趟&#34;);</p><p>\t\t\tfor(int j=0;j&lt;index;j++) {//次数</p><p>\t\t\t\tif(arrs[j]&gt;arrs[j+1]) {</p><p>\t\t\t\t\tisSorted = false;</p><p>\t\t\t\t\tint temp = arrs[j];</p><p>\t\t\t\t\tarrs[j] = arrs[j+1];</p><p>\t\t\t\t\tarrs[j+1] = temp;</p><p>\t\t\t\t\ttmp = j;</p><p>\t\t\t\t}</p><p>\t\t\t\tSystem.out.println(&#34;第&#34;+(j+1)+&#34;次:&#34;+toString(arrs));</p><p>\t\t\t}</p><p>\t\t\tindex = tmp;</p><p>\t\t\t//判定</p><p>\t\t\tif(isSorted) {</p><p>\t\t\t\tbreak;</p><p>\t\t\t}</p><p>\t\t}</p><p>\t}</p><p>快速查找</p><p>\tpublic static void SelsctSort(int[] arrs) {</p><p>\t\tfor(int i=0;i&lt;arrs.length-1;i++) {</p><p>\t\t\tint min = i;</p><p>\t\t\tfor(int j=i+1;j&lt;arrs.length;j++) {</p><p>\t\t\t\tif(arrs[min]&gt;arrs[j]) {</p><p>\t\t\t\t\tmin=j;</p><p>\t\t\t\t}</p><p>\t\t\t}</p><p>\t\t\tif(arrs[i]!=arrs[min]) {</p><p>\t\t\t\tint tmp = arrs[min];</p><p>\t\t\t\tarrs[min] = arrs[i];</p><p>\t\t\t\tarrs[i]=tmp;</p><p>\t\t\t}</p><p>\t\t}</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二分查找</p><p>\tpublic static int bSearch(int[] arrs,int value) {</p><p>\t\t//声明索引</p><p>\t\tint max = arrs.length-1;</p><p>\t\tint min = 0;</p><p>\t\tint mid = 0;</p><p>\t\t//循环判定</p><p>\t\twhile(min&lt;=max) {</p><p>\t\t\tmid = (max+min)/2;</p><p>\t\t\tif(arrs[mid]&gt;value) {</p><p>\t\t\t\tmax = mid-1;</p><p>\t\t\t}else if(arrs[mid]&lt;value) {</p><p>\t\t\t\tmin = mid+1;</p><p>\t\t\t}else {</p><p>\t\t\t\treturn mid;</p><p>\t\t\t}</p><p>\t\t}</p><p>\t\treturn -1;</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>异常</p><p>try-catch</p><p>语法结构：</p><p>​\ttry{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//有可能出现异常的代码块</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}catch(声明异常){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t异常解决办法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}</p><p>执行顺序：</p><p>1：执行try块中的内容</p><p>2:如果try块中内容出现异常，执行catch块</p><p>3：匹配catch中声明的异常信息 ，如果匹配上，则执行catch中的代</p><p>4：继续执行后续代码</p><p>5:如果catch中的异常信息没有匹配到 那么此时交由jvm处理该异常</p><p>注意：</p><p>catch:中的类型一定要能够捕获到try快中实际出现的异常信息 如果忘记了具体的异常信息可以通过使用Exception去捕获异常信息，不要再catch块中做业务逻辑判定</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\ttry {</p><p>        System.out.println(1/0);</p><p>    }catch(ArithmeticException e) {</p><p>        System.out.println(&#34;输入的数据有误。。。。。&#34;);</p><p>    }</p><p>\tSystem.out.println(&#34;我是try-catch外的代码&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p>try多层catch</p><p>语法结构：</p><p>​\ttry{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//可能出现异常的代码段</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}catch(异常1){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//异常 的解决办法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}catch(异常2){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//异常 的解决办法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}…{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>try多层catch执行顺序：</p><p>1:执行try块 如果出现异常 new出当前异常对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2:逐一匹配catch中的异常内容</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3：如果匹配上 执行对应的catch中的代码 整个try-catch执行结束</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4：如果匹配上 jvm去解决当前异常信息</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意事项：</p><p>1：在多重catch中一般情况下会在最后一个catch语句中编写exception 用来捕获可能未被识别的异常信息</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2：不要再第一个catch中编写父类异常 屏蔽所有子类异常</p><p class=\"ztext-empty-paragraph\"><br/></p><p>异常对象的常见方法：</p><p>toString： 当前异常类型以及原因描述</p><p class=\"ztext-empty-paragraph\"><br/></p><p>printStackTrace：打印堆栈信息 异常类型以及原因描述 异常位置</p><p class=\"ztext-empty-paragraph\"><br/></p><p>getMessage：异常原因</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tScanner input = new Scanner(<a href=\"https://link.zhihu.com/?target=http%3A//System.in\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">system.in - 这个网站可出售。 - 最佳的System 来源和相关信息。</a>);</p><p>    try {</p><p>        System.out.println(&#34;请输入第一个数:&#34;);</p><p>        int num1 = input.nextInt();</p><p>        System.out.println(&#34;请输入第二个数:&#34;);</p><p>        int num2 = input.nextInt();</p><p class=\"ztext-empty-paragraph\"><br/></p><p>        int result = num1/num2;</p><p>        System.out.println(num1+&#34;/&#34;+num2+&#34;=&#34;+result);</p><p>    }catch(ArithmeticException e) {</p><p>        System.out.println(&#34;除数不能为0&#34;);</p><p><a href=\"https://link.zhihu.com/?target=//System.out.println\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">//</span><span class=\"visible\">System.out.println</span><span class=\"invisible\"></span></a>(e.toString());</p><p><a href=\"https://link.zhihu.com/?target=//e.printStackTrace\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">//</span><span class=\"visible\">e.printStackTrace</span><span class=\"invisible\"></span></a>();</p><p><a href=\"https://link.zhihu.com/?target=//System.out.println\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">//</span><span class=\"visible\">System.out.println</span><span class=\"invisible\"></span></a>(e.getMessage());</p><p>    }catch(InputMismatchException e) {</p><p>        System.out.println(&#34;用户输入有误&#34;);</p><p>    }catch(Exception e) {</p><p>        System.out.println(&#34;网络加载问题!!!&#34;);</p><p>    }</p><p class=\"ztext-empty-paragraph\"><br/></p><p>    System.out.println(&#34;后续代码。。。&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p>try-catch-finally</p><p>语法结构：</p><p>​\ttry{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//可能出现异常的代码</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}catch(异常1){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//处理办法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}…{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}finally{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//代码块</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//关闭资源的代码</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试如何让finally不执行</p><p>retrun 语句不会让finally不执行</p><p class=\"ztext-empty-paragraph\"><br/></p><p>finally先于return语句执行</p><p class=\"ztext-empty-paragraph\"><br/></p><p>代码中存在System.exit() 可以让finally不执行 但是一般不这么干</p><p class=\"ztext-empty-paragraph\"><br/></p><p>执行顺序：</p><p>1:执行try块 如果出现异常 new出当前异常对象</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2:逐一匹配catch中的异常内容</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3：如果匹配上 执行对应的catch中的代码</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4：如果未匹配上 jvm去解决当前异常信息</p><p class=\"ztext-empty-paragraph\"><br/></p><p>5：不论是否匹配成功 都会执行finally中内容</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：</p><p>finally中一般情况下编写关闭资源的操作</p><p class=\"ztext-empty-paragraph\"><br/></p><p>jdk1.7之后对于try-catch-finally的改变</p><p>可以通过对于流、网络连接对象的创建声明在try的()中，后续无序通过使用finally显式的关闭资源</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\ttry(资源1;资源2.。。。){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//可能出现的异常信息</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}catch(异常1){</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t//解决办法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}。。。。。{</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tScanner input = new Scanner(<a href=\"https://link.zhihu.com/?target=http%3A//System.in\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">system.in - 这个网站可出售。 - 最佳的System 来源和相关信息。</a>);</p><p>    try {</p><p>        System.out.println(&#34;请输入第一个数:&#34;);</p><p>        int num1 = input.nextInt();</p><p>        System.out.println(&#34;请输入第二个数:&#34;);</p><p>        int num2 = input.nextInt();</p><p>        int result = num1/num2;</p><p>        System.out.println(num1+&#34;/&#34;+num2+&#34;=&#34;+result);</p><p>        input.close();</p><p>    }catch(InputMismatchException e) {</p><p>        System.out.println(&#34;输入有误&#34;);</p><p>    }catch(ArithmeticException e) {</p><p>        System.out.println(&#34;除数不能为0&#34;);</p><p>    }catch(Exception e) {</p><p>        System.out.println(&#34;网络加载有误。。&#34;);</p><p>    }finally {</p><p>        // 一定会被执行</p><p>        System.out.println(&#34;我是finally块中的代码&#34;);</p><p>        input.close();</p><p>    }</p><p>    System.out.println(&#34;后续代码。。。。&#34;);</p><p>throw-throws</p><p>throw</p><p>1：throw 声明当前代码块中可能存在的异常信息 并且将当前异常信息抛出给调用者。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于调用者而言 通过try-catch捕获异常</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果调用者也不管当前异常交由jvm解决</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2：throw会导致当前程序中断掉 后续代码不执行</p><p class=\"ztext-empty-paragraph\"><br/></p><p>throws</p><p>在方法外对外抛出某个异常，调用者解决当前异常。main方法中对外抛出的异常全部都交由jvm做。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>throws抛出异常 是异常解决的一种办法定义在方法的外部 形式参数后 可以抛出多个异常通过&#34;,&#34;分割</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一般会将throws和throw在一起使用，throw 声明的异常是检查时异常需要和throws一起使用，但是throws可以单独使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public class Test09 {</p><p>\tpublic static void main(String[] args) {</p><p>        //创建student对象</p><p>\t\tStudent stu1 = new Student();</p><p>\t\tstu1.setName(&#34;李四&#34;);</p><p>\t\ttry {</p><p>\t\t\tstu1.setAge(-1);</p><p>\t\t} catch (RuntimeException e) {</p><p>\t\t\tSystem.out.println(&#34;参数有误&#34;);</p><p>\t\t}</p><p>\t\tSystem.out.println(stu1);</p><p>\t\ttry {</p><p>\t\t\tinfo();</p><p>\t\t}catch(FileNotFoundException e){</p><p>\t\t\tSystem.out.println(&#34;找不到文件！&#34;);</p><p>\t\t}</p><p>\t}</p><p>\tpublic static void info() throws FileNotFoundException{</p><p>\t\t//try {</p><p>\t\t\tnew FileInputStream(new File(&#34;&#34;));</p><p>\t\t/*}catch(FileNotFoundException e) {</p><p>\t\t\tSystem.out.println(e);</p><p>\t\t}*/</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>class Student{</p><p>\tprivate String name;</p><p>\tprivate int age;</p><p>\tpublic Student() {</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic String getName() {</p><p>\t\treturn name;</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic void setName(String name) {</p><p><a href=\"https://link.zhihu.com/?target=http%3A//this.name\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">this.name</a> = name;</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\tpublic int getAge() {</p><p>\t\treturn age;</p><p>\t}</p><p>\t/**</p><p>\t * </p><p>\t * @param age</p><p>\t * @throws RuntimeException 当前方法对外会抛出异常 如果参数有误</p><p>\t */</p><p>\tpublic void setAge(int age)/* throws FileNotFoundException */{</p><p>\t\tif(age&lt;0||age&gt;150) {</p><p>\t\t\tthrow new RuntimeException();//throw new FileNotFoundException</p><p>\t\t}</p><p>\t\tthis.age = age;</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>\t@Override</p><p>\tpublic String toString() {</p><p>\t\treturn &#34;Student [name=&#34; + name + &#34;, age=&#34; + age + &#34;]&#34;;</p><p>\t}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>自定义异常</p><p>1：jdk中提供的异常信息不满足目前的使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2：如何自定义异常：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\ta:声明一个自定义异常类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tb：继承Exception</p><p class=\"ztext-empty-paragraph\"><br/></p><p>​\tc:编写两个构造器 一个空 一个带字符串的构造器</p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用自定义异常</p><p>class User{</p><p>\tprivate int age;</p><p>\tpublic User() {</p><p>\t}</p><p>\tpublic int getAge() {</p><p>\t\treturn age;</p><p>\t}</p><p>\tpublic void setAge(int age) throws AgeException{</p><p>\t\tif(age&lt;0||age&gt;150) {</p><p>\t\t\tthrow new AgeException(&#34;年龄输入有误&#34;);</p><p>\t\t}</p><p>\t\tthis.age = age;</p><p>\t}</p><p>\t@Override</p><p>\tpublic String toString() {</p><p>\t\treturn &#34;User [age=&#34; + age + &#34;]&#34;;</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>自定义异常类</p><p>public class AgeException extends Exception{</p><p>\tpublic AgeException() {</p><p>\t}</p><p>\tpublic AgeException(String msg) {</p><p>\t\tsuper(msg);</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试类</p><p>public class Test10 {</p><p>\tpublic static void main(String[] args){</p><p>\t\tUser u = new User();</p><p>\t\ttry {</p><p>\t\t\tu.setAge(-1);</p><p>\t\t}catch(AgeException e) {</p><p>\t\t\tSystem.out.println(e.getMessage());</p><p>\t\t}</p><p>\t\tSystem.out.println(u);</p><p>\t}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>————————————————</p><p>版权声明：本文为CSDN博主「sun_wz」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/L6_6LXXX/article/details/96445205\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/L6_6LXXX/</span><span class=\"invisible\">article/details/96445205</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Java 面向对象程序设计（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20834909"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81177480", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 1, 
            "title": "HTTP和HTTPS详解", 
            "content": "<p>一，HTTP和HTTPS基本概念</p><p>　　深入学习某个东西时，我们先来从维基百科上看看它俩的概念。</p><p>　　HTTP:超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议[1]。HTTP是万维网的数据通信的基础。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。通过HTTP或者HTTPS协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。</p><p>　　HTTPS：超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。历史上，HTTPS连接经常用于万维网上的交易支付和企业信息系统中敏感信息的传输。在2000年代晚期和2010年代早期，HTTPS开始广泛使用于保护所有类型网站上的网页真实性，保护账户和保持用户通信，身份和网络浏览的私密性。</p><p>###二，HTTP和HTTPS的差异</p><p>　　1，从上面概念也可以看出来HTTP是不安全的，且攻击者通过监听和中间人攻击等手段，可以获取网站帐户和敏感信息等。HTTPS被设计为可防止前述攻击，并在正确配置时被认为是安全的。</p><p>　　2，HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</p><p>　　3，HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。</p><p>　　1）对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</p><p>　　2）非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a2fe74f926bd044ccd6b4d820c39f4f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"470\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"470\" data-original=\"https://pic4.zhimg.com/v2-a2fe74f926bd044ccd6b4d820c39f4f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;470&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"470\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"470\" data-original=\"https://pic4.zhimg.com/v2-a2fe74f926bd044ccd6b4d820c39f4f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a2fe74f926bd044ccd6b4d820c39f4f3_b.jpg\"/></figure><p>三，HTTPS工作原理</p><p>   下面看一下网站访问过程：</p><p>　　大家很明显发现目前大部分网站使用的还是http协议，下面我们通过一个图片很容易的了解一下网站访问的一个过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a8d3c11bec17e98820db9ea1dd88ef1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1155\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb\" width=\"1155\" data-original=\"https://pic2.zhimg.com/v2-1a8d3c11bec17e98820db9ea1dd88ef1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1155&#39; height=&#39;650&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1155\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1155\" data-original=\"https://pic2.zhimg.com/v2-1a8d3c11bec17e98820db9ea1dd88ef1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a8d3c11bec17e98820db9ea1dd88ef1_b.jpg\"/></figure><p>了解完网站访问后我们来看一下使用HTTPS的工作原理</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-558d48bb41691efbf19a2997369e219e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"365\" data-rawheight=\"411\" class=\"content_image\" width=\"365\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;365&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"365\" data-rawheight=\"411\" class=\"content_image lazy\" width=\"365\" data-actualsrc=\"https://pic3.zhimg.com/v2-558d48bb41691efbf19a2997369e219e_b.jpg\"/></figure><p>（1）客户使用HTTPS的URL访问Web服务器，要求与Web服务器建立SSL连接。</p><p>　　（2）Web服务器收到客户端请求后，会将网站的证书信息（证书中包含公钥）传送一份给客户端。</p><p>　　（3）客户端的浏览器与Web服务器开始协商SSL/TLS连接的安全等级，也就是信息加密的等级。</p><p>　　（4）客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。</p><p>　　（5）Web服务器利用自己的私钥解密出会话密钥。</p><p>　　（6）Web服务器利用会话密钥加密与客户端之间的通信。</p><p>####从上面可以总结出HTTPS的优点：</p><p>　　（1）客户端产生的密钥只有客户端和服务器端能得到；</p><p>　　（2）加密的数据只有客户端和服务器端才能得到明文；</p><p>　　（3）客户端到服务端的通信是安全的。</p><p>　　另外谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</p><p>四，HTTPS的局限/缺点</p><p>　　我们说了这么多HTTPS的优点，难道它就没有缺点或者说是局限吗？当然有，毕竟万物不可完美！</p><p>　　1,HTTPS比HTTP耗费更多服务器资源（https其实就是建构在SSL/TLS之上的 http协议，所以要比较https比http多用多少服务器资源，主要看SSL/TLS本身消耗多少服务器资源。）</p><p>2，耗费的资源多，过程也复杂，想当然访问不如HTTP高效。大流量网站非必要也不会采用，流量成本太高。</p><p>　　3，HTTPS并不能防止站点被网络蜘蛛抓取。在某些情形中，被加密资源的URL可仅通过截获请求和响应的大小推得，这就可使攻击者同时知道明文（公开的静态内容）和密文（被加密过的明文），从而使选择密文攻击成为可能。</p><p>　　４，SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用。</p><p>　　５，SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗。</p><p>你们想还有什么想知道，可以在评论出留言。</p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "HTTPS", 
                    "tagLink": "https://api.zhihu.com/topics/19568367"
                }
            ], 
            "comments": [
                {
                    "userName": "沐阳小北", 
                    "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
                    "content": "欢迎大家留言评论，有想了解其他可以在下方留言哦，可能不会一一做答复，但是你们的留言我都会看的。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80710641", 
            "userName": "沐阳小北", 
            "userLink": "https://www.zhihu.com/people/cb746ab0955a0efd519692644a8eeefb", 
            "upvote": 1, 
            "title": "iPhone XR再次登榜，可以算是说起死回生", 
            "content": "<p>自从去年的三款iPhone发布之后，iPhone在全球的销量都出现了一定的下滑趋势。为了能够重振销量，苹果在全球也是用尽浑身解数，似乎都没有太好的办法。最后也是不得不祭出降价大法，才让iPhone的销量有所回暖。今年的iPhone 11系列依旧和去年一样被普遍看衰，我们并不清楚iPhone 11系列销量如何，但是去年发布的iPhone XR依旧保持着“真香”的趋势。</p><p>我们一直都在说支持国产机，苹果没创新不行了。但是每到国内的大型电商购物节，苹果都会脱颖而出。在6.18期间，iPhone XR凭借着大幅的降价，不仅在销量还是销售额方面，都始终保持在前三的地位。这个结果却是让人有点意外，不过也证明了一个情况，只要iPhone价格够低，即便是再丑，也会得到大批果粉的青睐。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e2d28cc1717362ff6805d2dd2716d3b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-e2d28cc1717362ff6805d2dd2716d3b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-e2d28cc1717362ff6805d2dd2716d3b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e2d28cc1717362ff6805d2dd2716d3b6_b.jpg\"/></figure><p>就在半个月前，苏宁又开启了自己的8.18大促活动，结果还是惊人的相似。因为在翻看了苏宁的“无孔榜”之后，发现苹果和iPhone XR基本上霸占了所有榜单的第一名。从价格来看，818大促的价格似乎并没有6.18降的那么厉害，不过iPhone XR的价格依旧很有性价比。这也再次说明，只要价格降的低，iPhone永远都是真香机。</p><p>近几年来，以华为为首的国产机不断冲击高端市场，而且也有着不错的成功。在五千元的价格段上也会抢夺一些苹果的用户，但为什么配置低，价格也并不算很低的iPhone降价之后依旧备受欢迎，最主要的原因还是苹果系统的功劳。只要苹果保持着系统一直保持着这种优势，相同价格情况下，估计还是更多人愿意选择iPhone。 今天给大家推荐一款非常具有性价比的蓝牙耳机：阿里云C智能声控耳机 1、这个耳机是阿里的技术平台，这是最大特色，秒杀90%以上智能声控耳机。 2、人工智能很强悍：可以实现人机对话，而且具有智能家居功能。用耳机可以声控家中所有智能电器。</p><p>3、智能运动强悍：根据运动提供音乐，不懂的运动项目可以咨询。秒速解答。</p><p>4、HIFI保真音质：6D立体音质，HIFI保真音质。金属音腔，高中低音，佩戴舒适。 可以查看天猫店评论，99%都是好评。</p><p>下面给出一些核心参数：</p><p> 主屏尺寸     6.1英寸</p><p>主屏分辨率     1792x828像素</p><p>后置摄像头      1200万像素</p><p>手机类型  4G手机，3G手机，智能手机，平板手机，拍照手机，快充手机</p><p>屏幕类型      全面屏（刘海屏）</p><p>出厂系统内核        iOS 12</p><p>官方售价：4899-6888元</p><p></p>", 
            "topic": [
                {
                    "tag": "iphoneXR", 
                    "tagLink": "https://api.zhihu.com/topics/20744679"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1132591122811269120"
}
