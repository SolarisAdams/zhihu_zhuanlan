{
    "title": "golang runtime 阅读", 
    "description": "go的内存分配、内存回收(GC)、协程设计、go编译器(和go汇编)相关的笔记。", 
    "followers": [
        "https://www.zhihu.com/people/xiaobaisu", 
        "https://www.zhihu.com/people/kksk-18", 
        "https://www.zhihu.com/people/hasaji", 
        "https://www.zhihu.com/people/simon-3-41", 
        "https://www.zhihu.com/people/restartlife-70", 
        "https://www.zhihu.com/people/meskal", 
        "https://www.zhihu.com/people/da-shu-bu-da", 
        "https://www.zhihu.com/people/wsjhk", 
        "https://www.zhihu.com/people/mei-wen-67-3", 
        "https://www.zhihu.com/people/mark-9-34-37", 
        "https://www.zhihu.com/people/waha-91-71", 
        "https://www.zhihu.com/people/pao-mian-27", 
        "https://www.zhihu.com/people/st-tan", 
        "https://www.zhihu.com/people/dean-94-22", 
        "https://www.zhihu.com/people/lindh", 
        "https://www.zhihu.com/people/frankzhang-55", 
        "https://www.zhihu.com/people/glowdan", 
        "https://www.zhihu.com/people/qian-zhua-zi", 
        "https://www.zhihu.com/people/xie-jiang-hui-54", 
        "https://www.zhihu.com/people/firetaker", 
        "https://www.zhihu.com/people/cheng-yong-qiao", 
        "https://www.zhihu.com/people/chen-xu-91-33", 
        "https://www.zhihu.com/people/mediary", 
        "https://www.zhihu.com/people/lu-ming-ming-17", 
        "https://www.zhihu.com/people/zhanghui-23", 
        "https://www.zhihu.com/people/mercedes-53-9", 
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/xi-de-xiao-zi", 
        "https://www.zhihu.com/people/kong-cheng-09-03", 
        "https://www.zhihu.com/people/yue-guo-shuai-68", 
        "https://www.zhihu.com/people/bu-lu-gu", 
        "https://www.zhihu.com/people/duan-fang-liang", 
        "https://www.zhihu.com/people/wang-wei-wen-82-44", 
        "https://www.zhihu.com/people/ma-ming-hui-80", 
        "https://www.zhihu.com/people/huang-han-tao-54", 
        "https://www.zhihu.com/people/han-lin-82-60", 
        "https://www.zhihu.com/people/ztime-11", 
        "https://www.zhihu.com/people/ha-ha-17-96-16", 
        "https://www.zhihu.com/people/wang-hg", 
        "https://www.zhihu.com/people/meission", 
        "https://www.zhihu.com/people/liu-xiao-yao-12", 
        "https://www.zhihu.com/people/lin-yi-fan-8", 
        "https://www.zhihu.com/people/mengdao2046", 
        "https://www.zhihu.com/people/wen-zhi-hong", 
        "https://www.zhihu.com/people/wang-pei-81", 
        "https://www.zhihu.com/people/lovelemon1983", 
        "https://www.zhihu.com/people/fei-ye-10", 
        "https://www.zhihu.com/people/ahnuxc", 
        "https://www.zhihu.com/people/tan-zhe-40", 
        "https://www.zhihu.com/people/hui-lang-31", 
        "https://www.zhihu.com/people/tong-wang-te-lei-bi-xi-ya-de-qiao", 
        "https://www.zhihu.com/people/xuanxuan-zhu", 
        "https://www.zhihu.com/people/qinfeng_", 
        "https://www.zhihu.com/people/pan-jia-wei-31", 
        "https://www.zhihu.com/people/K-L-e-e", 
        "https://www.zhihu.com/people/cheng-bao-jue-shi", 
        "https://www.zhihu.com/people/wook9615", 
        "https://www.zhihu.com/people/li-cheng-seven", 
        "https://www.zhihu.com/people/karminski", 
        "https://www.zhihu.com/people/ai-fei-fei-64", 
        "https://www.zhihu.com/people/chen-qing-he-50-10", 
        "https://www.zhihu.com/people/lan-yong-33", 
        "https://www.zhihu.com/people/Liiu00", 
        "https://www.zhihu.com/people/qiouziyu", 
        "https://www.zhihu.com/people/ice-water", 
        "https://www.zhihu.com/people/ni-yu-jue-yi", 
        "https://www.zhihu.com/people/wudalu", 
        "https://www.zhihu.com/people/chen-xu-cheng", 
        "https://www.zhihu.com/people/dg-neige", 
        "https://www.zhihu.com/people/ding-yi-kang-54", 
        "https://www.zhihu.com/people/LanceMa", 
        "https://www.zhihu.com/people/zhang-xing-71", 
        "https://www.zhihu.com/people/bailaobo", 
        "https://www.zhihu.com/people/sun-sun-95-97", 
        "https://www.zhihu.com/people/fanngyuan", 
        "https://www.zhihu.com/people/NNGDDW", 
        "https://www.zhihu.com/people/ickelin-45", 
        "https://www.zhihu.com/people/infoflow", 
        "https://www.zhihu.com/people/wu-su-49-18", 
        "https://www.zhihu.com/people/wu-xin-ren-91", 
        "https://www.zhihu.com/people/feng-huang-yuan-xiong-zhen-83", 
        "https://www.zhihu.com/people/yifen-hao-22", 
        "https://www.zhihu.com/people/wangchunye", 
        "https://www.zhihu.com/people/chunyi-gao", 
        "https://www.zhihu.com/people/li-wei-long-92", 
        "https://www.zhihu.com/people/zhaohuc", 
        "https://www.zhihu.com/people/teckersherlock", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/zhu-zhi-wei-14-45", 
        "https://www.zhihu.com/people/wang-wei-wei-61-96", 
        "https://www.zhihu.com/people/zsybupt", 
        "https://www.zhihu.com/people/wu-rui-79-59", 
        "https://www.zhihu.com/people/yuan-bao-87", 
        "https://www.zhihu.com/people/zhou-mo-la", 
        "https://www.zhihu.com/people/itachi-yao", 
        "https://www.zhihu.com/people/dao-suan", 
        "https://www.zhihu.com/people/jamaz-71", 
        "https://www.zhihu.com/people/huoshijie", 
        "https://www.zhihu.com/people/walterzhao", 
        "https://www.zhihu.com/people/hui-xiong-65", 
        "https://www.zhihu.com/people/wang-pan-72-30", 
        "https://www.zhihu.com/people/xu-zhe-10", 
        "https://www.zhihu.com/people/best-my", 
        "https://www.zhihu.com/people/eddychou", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/carch", 
        "https://www.zhihu.com/people/ErenNo1", 
        "https://www.zhihu.com/people/ygxc", 
        "https://www.zhihu.com/people/daetalus", 
        "https://www.zhihu.com/people/darkmatter", 
        "https://www.zhihu.com/people/leo-leo-41", 
        "https://www.zhihu.com/people/zhao-dong-zhi", 
        "https://www.zhihu.com/people/yang-li-1", 
        "https://www.zhihu.com/people/mo-ming-chen-yuan", 
        "https://www.zhihu.com/people/liaoer", 
        "https://www.zhihu.com/people/lit10050528", 
        "https://www.zhihu.com/people/zheng_1", 
        "https://www.zhihu.com/people/song-xiao-cd", 
        "https://www.zhihu.com/people/qing-xin-qin-xin", 
        "https://www.zhihu.com/people/ben1009", 
        "https://www.zhihu.com/people/zhu-yicong", 
        "https://www.zhihu.com/people/zhang-zhi-yuan-79-95", 
        "https://www.zhihu.com/people/cui-zheng-83", 
        "https://www.zhihu.com/people/cliff-yuan", 
        "https://www.zhihu.com/people/haotianhaq", 
        "https://www.zhihu.com/people/ggff-ss", 
        "https://www.zhihu.com/people/ju-shang-38", 
        "https://www.zhihu.com/people/GammaGo", 
        "https://www.zhihu.com/people/qichao-tang", 
        "https://www.zhihu.com/people/sunicdavy", 
        "https://www.zhihu.com/people/noodles-he", 
        "https://www.zhihu.com/people/boring-29-75", 
        "https://www.zhihu.com/people/mu-mu-31-13-6", 
        "https://www.zhihu.com/people/wherewindblow", 
        "https://www.zhihu.com/people/nan-ge-56", 
        "https://www.zhihu.com/people/mai-yue", 
        "https://www.zhihu.com/people/jackyu", 
        "https://www.zhihu.com/people/wang-er-41-6", 
        "https://www.zhihu.com/people/qingganwan", 
        "https://www.zhihu.com/people/kano-acker", 
        "https://www.zhihu.com/people/zhou-meng-86-3", 
        "https://www.zhihu.com/people/lin-xiao-jia-98-89", 
        "https://www.zhihu.com/people/YukiSou", 
        "https://www.zhihu.com/people/xiangdao653", 
        "https://www.zhihu.com/people/michaelchen13", 
        "https://www.zhihu.com/people/_andy2046", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/hehao-40", 
        "https://www.zhihu.com/people/hiking-24", 
        "https://www.zhihu.com/people/foo_hack", 
        "https://www.zhihu.com/people/zhang-bo-34", 
        "https://www.zhihu.com/people/xun-gong-9", 
        "https://www.zhihu.com/people/wang-chao-84-29", 
        "https://www.zhihu.com/people/sheldon-18-75", 
        "https://www.zhihu.com/people/ych1987", 
        "https://www.zhihu.com/people/future-2", 
        "https://www.zhihu.com/people/zhu-xin-gan-29", 
        "https://www.zhihu.com/people/leonhardli", 
        "https://www.zhihu.com/people/bb7133", 
        "https://www.zhihu.com/people/jonahgao", 
        "https://www.zhihu.com/people/xiao-wen-jie-41-22", 
        "https://www.zhihu.com/people/invalid_user", 
        "https://www.zhihu.com/people/kinglong-29", 
        "https://www.zhihu.com/people/rayray-222223", 
        "https://www.zhihu.com/people/bai-gui-hong", 
        "https://www.zhihu.com/people/nichosinsang", 
        "https://www.zhihu.com/people/arnkore", 
        "https://www.zhihu.com/people/wang-cheng-87-67", 
        "https://www.zhihu.com/people/sui-feng-rock", 
        "https://www.zhihu.com/people/cui-xiao-chen-82", 
        "https://www.zhihu.com/people/jarvys", 
        "https://www.zhihu.com/people/asmlover", 
        "https://www.zhihu.com/people/zhang-da-ya-5", 
        "https://www.zhihu.com/people/dong-dong-xian-sheng", 
        "https://www.zhihu.com/people/angwer-zhang", 
        "https://www.zhihu.com/people/yang-hong-zhi-38", 
        "https://www.zhihu.com/people/cao-xin-58-59", 
        "https://www.zhihu.com/people/ss33-6", 
        "https://www.zhihu.com/people/adam_wen", 
        "https://www.zhihu.com/people/linyu-wang", 
        "https://www.zhihu.com/people/gang-liao-12", 
        "https://www.zhihu.com/people/Oshinobu", 
        "https://www.zhihu.com/people/ren-hong-di", 
        "https://www.zhihu.com/people/ethercflow", 
        "https://www.zhihu.com/people/uucloud", 
        "https://www.zhihu.com/people/xiang-ji-81", 
        "https://www.zhihu.com/people/longxboy", 
        "https://www.zhihu.com/people/halfer53", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/MikeMao", 
        "https://www.zhihu.com/people/foxmailed", 
        "https://www.zhihu.com/people/liublued", 
        "https://www.zhihu.com/people/xing-long-67", 
        "https://www.zhihu.com/people/fleurer", 
        "https://www.zhihu.com/people/conndots", 
        "https://www.zhihu.com/people/tao-tao-tao-tao-wen", 
        "https://www.zhihu.com/people/canceled-names", 
        "https://www.zhihu.com/people/zoubapi", 
        "https://www.zhihu.com/people/rong-jian-1-92", 
        "https://www.zhihu.com/people/feng-ling-18-9", 
        "https://www.zhihu.com/people/bu-gei-xing-ming", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/liaohongyu", 
        "https://www.zhihu.com/people/yu-hun-shi-99", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/zhou-xin-36-85"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/63582135", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 6, 
            "title": "Timer和Ticker", 
            "content": "<h2>Timer和Ticker</h2><p>编程中经常会通过timer和ticker。其基本用法不在多说，本文结合源码分析其语义内涵。</p><h2>timer</h2><p>timer创建有两种方式，<code>time.NewTimer(Duration)</code> 和<code>time.After(Duration)</code>。 后者只是对前者的一个包装。这里只分析前者。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Timer</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">C</span> <span class=\"o\">&lt;-</span><span class=\"kd\">chan</span> <span class=\"nx\">Time</span>\n    <span class=\"nx\">r</span> <span class=\"nx\">runtimeTimer</span> <span class=\"c1\">// 触发时间的结构\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"kd\">func</span> <span class=\"nf\">NewTimer</span><span class=\"p\">(</span><span class=\"nx\">d</span> <span class=\"nx\">Duration</span><span class=\"p\">)</span> <span class=\"o\">*</span><span class=\"nx\">Timer</span> <span class=\"p\">{</span>\n    <span class=\"nx\">c</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">(</span><span class=\"kd\">chan</span> <span class=\"nx\">Time</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"nx\">t</span> <span class=\"o\">:=</span> <span class=\"o\">&amp;</span><span class=\"nx\">Timer</span><span class=\"p\">{</span>\n        <span class=\"nx\">C</span><span class=\"p\">:</span> <span class=\"nx\">c</span><span class=\"p\">,</span>\n        <span class=\"nx\">r</span><span class=\"p\">:</span> <span class=\"nx\">runtimeTimer</span><span class=\"p\">{</span>\n            <span class=\"nx\">when</span><span class=\"p\">:</span> <span class=\"nf\">when</span><span class=\"p\">(</span><span class=\"nx\">d</span><span class=\"p\">),</span>\n            <span class=\"nx\">f</span><span class=\"p\">:</span>    <span class=\"nx\">sendTime</span><span class=\"p\">,</span>\n            <span class=\"nx\">arg</span><span class=\"p\">:</span>  <span class=\"nx\">c</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">}</span>\n    <span class=\"nf\">startTimer</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">r</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nx\">t</span>\n<span class=\"p\">}</span></code></pre></div><p>可以看出timer只是对runtimeTimer的包装。runtimeTimer在<code>runtime/time</code>中实现，具体结构稍后分析。</p><h2>Ticker</h2><p>和timer类似，ticker也有两个创建方式，下面看一下创建的代码。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">Ticker</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">C</span> <span class=\"o\">&lt;-</span><span class=\"kd\">chan</span> <span class=\"nx\">Time</span> <span class=\"c1\">// The channel on which the ticks are delivered.\n</span><span class=\"c1\"></span>    <span class=\"nx\">r</span> <span class=\"nx\">runtimeTimer</span>\n<span class=\"p\">}</span>       <span class=\"c1\">// 可以看出 timer和ticker的结构体都一样\n</span><span class=\"c1\"></span>\n<span class=\"kd\">func</span> <span class=\"nf\">NewTicker</span><span class=\"p\">(</span><span class=\"nx\">d</span> <span class=\"nx\">Duration</span><span class=\"p\">)</span> <span class=\"o\">*</span><span class=\"nx\">Ticker</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"nx\">d</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n        <span class=\"nb\">panic</span><span class=\"p\">(</span><span class=\"nx\">errors</span><span class=\"p\">.</span><span class=\"nf\">New</span><span class=\"p\">(</span><span class=\"s\">&#34;non-positive interval for NewTicker&#34;</span><span class=\"p\">))</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">c</span> <span class=\"o\">:=</span> <span class=\"nb\">make</span><span class=\"p\">(</span><span class=\"kd\">chan</span> <span class=\"nx\">Time</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"nx\">t</span> <span class=\"o\">:=</span> <span class=\"o\">&amp;</span><span class=\"nx\">Ticker</span><span class=\"p\">{</span>\n        <span class=\"nx\">C</span><span class=\"p\">:</span> <span class=\"nx\">c</span><span class=\"p\">,</span>\n        <span class=\"nx\">r</span><span class=\"p\">:</span> <span class=\"nx\">runtimeTimer</span><span class=\"p\">{</span>\n            <span class=\"nx\">when</span><span class=\"p\">:</span>   <span class=\"nf\">when</span><span class=\"p\">(</span><span class=\"nx\">d</span><span class=\"p\">),</span>\n            <span class=\"nx\">period</span><span class=\"p\">:</span> <span class=\"nb\">int64</span><span class=\"p\">(</span><span class=\"nx\">d</span><span class=\"p\">),</span>\n            <span class=\"nx\">f</span><span class=\"p\">:</span>      <span class=\"nx\">sendTime</span><span class=\"p\">,</span>\n            <span class=\"nx\">arg</span><span class=\"p\">:</span>    <span class=\"nx\">c</span><span class=\"p\">,</span>\n        <span class=\"p\">},</span>\n    <span class=\"p\">}</span>\n    <span class=\"nf\">startTimer</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">r</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nx\">t</span>\n<span class=\"p\">}</span></code></pre></div><p>可以发现，timer和ticker几乎一样，只是runtimeTimer的参数不同，ticker多了一个period，下面具体分析<code>runtime/time.go</code>中的机制。</p><h2>runtime/time</h2><p>这里是真正干活的地方，首先猜一下大概的工作原理。   定时器的实现方式一般有下面几种: 1. 最小堆，最小堆是比较高效的。 2. 红黑树，nginx用的这个，某些情况也比较高效。 3. 链表，redis用的这个，某些情况也比较高效。 4. 时间轮等其变种，linux采用的这种。</p><p>最小堆其实是用的比较多的，go也用的是最小堆。关于这几种之间的差异，可以参考论文[1]。 另外定时器一般需要支持单次和重复两种，分别对应tick和timer。</p><p>看一下<code>runtime.timer</code>的结构。<code>runtimeTimer</code>和<code>runtime.timer</code>是一样的，他们的layout是一样的。这么做应该是为了解决循环引用。</p><div class=\"highlight\"><pre><code class=\"language-text\">type timer struct {\n    tb *timersBucket  // 指向P的时间堆\n    i  int      // 堆中的位置\n    when   int64 // 第一次触发在when的时候\n    period int64 // 周期,如果大于0，第2次在when+period....\n    f      func(interface{}, uintptr) // NOTE: must not be closure \n    arg    interface{} // 参数\n    seq    uintptr // TODO:\n}</code></pre></div><p>可以看出最后的活是交给timesBuket干的，timer只是存了一些参数。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">timersBucket</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">lock</span>         <span class=\"nx\">mutex</span>  \n    <span class=\"nx\">gp</span>           <span class=\"o\">*</span><span class=\"nx\">g</span>\n    <span class=\"nx\">created</span>      <span class=\"kt\">bool</span>\n    <span class=\"nx\">sleeping</span>     <span class=\"kt\">bool</span>\n    <span class=\"nx\">rescheduling</span> <span class=\"kt\">bool</span>\n    <span class=\"nx\">sleepUntil</span>   <span class=\"kt\">int64</span>\n    <span class=\"nx\">waitnote</span>     <span class=\"nx\">note</span>\n    <span class=\"nx\">t</span>            <span class=\"p\">[]</span><span class=\"o\">*</span><span class=\"nx\">timer</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 所有P的时间堆都在timers中。\n</span><span class=\"c1\"></span><span class=\"kd\">var</span> <span class=\"nx\">timers</span> <span class=\"p\">[</span><span class=\"nx\">timersLen</span><span class=\"p\">]</span><span class=\"kd\">struct</span> <span class=\"p\">{</span> <span class=\"c1\">//长度64的数组\n</span><span class=\"c1\"></span>    <span class=\"nx\">timersBucket</span> \n    <span class=\"nx\">pad</span> <span class=\"p\">[</span><span class=\"nx\">sys</span><span class=\"p\">.</span><span class=\"nx\">CacheLineSize</span> <span class=\"o\">-</span> <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nf\">Sizeof</span><span class=\"p\">(</span><span class=\"nx\">timersBucket</span><span class=\"p\">{})</span><span class=\"o\">%</span><span class=\"nx\">sys</span><span class=\"p\">.</span><span class=\"nx\">CacheLineSize</span><span class=\"p\">]</span><span class=\"kt\">byte</span> <span class=\"c1\">// 伪共享\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"c1\">// 做了取模，p的id是连续的，P小于64时互不干扰。\n</span><span class=\"c1\">// 大于64时不知道会不会出问题。TODO:\n</span><span class=\"c1\"></span><span class=\"kd\">func</span> <span class=\"p\">(</span><span class=\"nx\">t</span> <span class=\"o\">*</span><span class=\"nx\">timer</span><span class=\"p\">)</span> <span class=\"nf\">assignBucket</span><span class=\"p\">()</span> <span class=\"o\">*</span><span class=\"nx\">timersBucket</span> <span class=\"p\">{</span>\n    <span class=\"nx\">id</span> <span class=\"o\">:=</span> <span class=\"nb\">uint8</span><span class=\"p\">(</span><span class=\"nf\">getg</span><span class=\"p\">().</span><span class=\"nx\">m</span><span class=\"p\">.</span><span class=\"nx\">p</span><span class=\"p\">.</span><span class=\"nf\">ptr</span><span class=\"p\">().</span><span class=\"nx\">id</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"nx\">timersLen</span>\n    <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">tb</span> <span class=\"p\">=</span> <span class=\"o\">&amp;</span><span class=\"nx\">timers</span><span class=\"p\">[</span><span class=\"nx\">id</span><span class=\"p\">].</span><span class=\"nx\">timersBucket</span>\n    <span class=\"k\">return</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">tb</span>\n<span class=\"p\">}</span></code></pre></div><p>go的实现中每个P都一个时间堆，每个timersBucket都会起一个协程，用来处理时间事件。 (一般情况下，P小于64个)全局一个timers，64个timersBucket， 每个P对应一个timersBucket,每个timersBucket初始化时会新起一个协程 处理时间循环。新建一个定时器即在堆中添加新的一个节点， 停止定时器即移除该节点。 堆处理的相关代码不在赘述，下面分析一下<code>timerproc</code>。 这个函数包含了事件循环的主要工作。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"nf\">timerproc</span><span class=\"p\">(</span><span class=\"nx\">tb</span> <span class=\"o\">*</span><span class=\"nx\">timersBucket</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">gp</span> <span class=\"p\">=</span> <span class=\"nf\">getg</span><span class=\"p\">()</span> <span class=\"c1\">// 获得当前的g。每个tb一个。\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">{</span>\n        <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>  \n        <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">sleeping</span> <span class=\"p\">=</span> <span class=\"kc\">false</span> <span class=\"c1\">// 不用休息\n</span><span class=\"c1\"></span>        <span class=\"nx\">now</span> <span class=\"o\">:=</span> <span class=\"nf\">nanotime</span><span class=\"p\">()</span>\n        <span class=\"nx\">delta</span> <span class=\"o\">:=</span> <span class=\"nb\">int64</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">{</span> <span class=\"c1\">// 空的，直接sleep就行了。\n</span><span class=\"c1\"></span>                <span class=\"nx\">delta</span> <span class=\"p\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n                <span class=\"k\">break</span>\n            <span class=\"p\">}</span>\n            <span class=\"nx\">t</span> <span class=\"o\">:=</span> <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\">// 最小堆，第一个是最近要发生的\n</span><span class=\"c1\"></span>            <span class=\"nx\">delta</span> <span class=\"p\">=</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">when</span> <span class=\"o\">-</span> <span class=\"nx\">now</span> \n            <span class=\"k\">if</span> <span class=\"nx\">delta</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n                <span class=\"k\">break</span> <span class=\"c1\">// 第一个未就绪，sleep\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n            <span class=\"c1\">// 此时第一个已经就绪了\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">period</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span> <span class=\"c1\">// 如果t是周期的,不要删除这个节点\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 重制when，并将它放到合适的位置\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 这里补偿了delta的延迟。\n</span><span class=\"c1\"></span>                <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">when</span> <span class=\"o\">+=</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">period</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"o\">-</span><span class=\"nx\">delta</span><span class=\"o\">/</span><span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">period</span><span class=\"p\">)</span>\n                <span class=\"nf\">siftdownTimer</span><span class=\"p\">(</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span> <span class=\"c1\">// 一次性的，直接移走\n</span><span class=\"c1\"></span>                <span class=\"nx\">last</span> <span class=\"o\">:=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>\n                <span class=\"k\">if</span> <span class=\"nx\">last</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n                    <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"p\">=</span> <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[</span><span class=\"nx\">last</span><span class=\"p\">]</span>\n                    <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"nx\">i</span> <span class=\"p\">=</span> <span class=\"mi\">0</span>\n                <span class=\"p\">}</span>\n                <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[</span><span class=\"nx\">last</span><span class=\"p\">]</span> <span class=\"p\">=</span> <span class=\"kc\">nil</span>\n                <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span> <span class=\"p\">=</span> <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">[:</span><span class=\"nx\">last</span><span class=\"p\">]</span>\n                <span class=\"k\">if</span> <span class=\"nx\">last</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span>\n                    <span class=\"nf\">siftdownTimer</span><span class=\"p\">(</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">t</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n                <span class=\"p\">}</span>\n                <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">i</span> <span class=\"p\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"c1\">// mark as removed\n</span><span class=\"c1\"></span>            <span class=\"p\">}</span>\n            <span class=\"nx\">f</span> <span class=\"o\">:=</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">f</span> <span class=\"c1\">// 即sendtime，下面分析。\n</span><span class=\"c1\"></span>            <span class=\"nx\">arg</span> <span class=\"o\">:=</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">arg</span>\n            <span class=\"nx\">seq</span> <span class=\"o\">:=</span> <span class=\"nx\">t</span><span class=\"p\">.</span><span class=\"nx\">seq</span>\n            <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"nx\">raceenabled</span> <span class=\"p\">{</span>\n                <span class=\"nf\">raceacquire</span><span class=\"p\">(</span><span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nf\">Pointer</span><span class=\"p\">(</span><span class=\"nx\">t</span><span class=\"p\">))</span>\n            <span class=\"p\">}</span>\n            <span class=\"nf\">f</span><span class=\"p\">(</span><span class=\"nx\">arg</span><span class=\"p\">,</span> <span class=\"nx\">seq</span><span class=\"p\">)</span> <span class=\"c1\">// 同步调用，不能阻塞\n</span><span class=\"c1\"></span>            <span class=\"nf\">lock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"nx\">delta</span> <span class=\"p\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"nx\">faketime</span> <span class=\"p\">&gt;</span> <span class=\"mi\">0</span> <span class=\"p\">{</span><span class=\"c1\">// faketime用于伪造时间\n</span><span class=\"c1\"></span>            <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">rescheduling</span> <span class=\"p\">=</span> <span class=\"kc\">true</span>\n            <span class=\"nf\">goparkunlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">,</span> <span class=\"s\">&#34;timer goroutine (idle)&#34;</span><span class=\"p\">,</span> <span class=\"nx\">traceEvGoBlock</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"k\">continue</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 都未就绪\n</span><span class=\"c1\"></span>        <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">sleeping</span> <span class=\"p\">=</span> <span class=\"kc\">true</span>\n        <span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">sleepUntil</span> <span class=\"p\">=</span> <span class=\"nx\">now</span> <span class=\"o\">+</span> <span class=\"nx\">delta</span> <span class=\"c1\">//休息到第一个就绪\n</span><span class=\"c1\"></span>        <span class=\"nf\">noteclear</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">waitnote</span><span class=\"p\">)</span>\n        <span class=\"nf\">unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"p\">)</span>\n        <span class=\"nf\">notetsleepg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"nx\">tb</span><span class=\"p\">.</span><span class=\"nx\">waitnote</span><span class=\"p\">,</span> <span class=\"nx\">delta</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><p>下面看一下<code>sendtime</code>，这里是具体的处理函数。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">func</span> <span class=\"nf\">sendTime</span><span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"kd\">interface</span><span class=\"p\">{},</span> <span class=\"nx\">seq</span> <span class=\"kt\">uintptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 很经典的非阻塞操作chan。\n</span><span class=\"c1\"></span>    <span class=\"k\">select</span> <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"nx\">c</span><span class=\"p\">.(</span><span class=\"kd\">chan</span> <span class=\"nx\">Time</span><span class=\"p\">)</span> <span class=\"o\">&lt;-</span> <span class=\"nf\">Now</span><span class=\"p\">():</span>\n    <span class=\"k\">default</span><span class=\"p\">:</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><h2>reference:</h2><ol><li>[<a href=\"https://link.zhihu.com/?target=http%3A//59.80.44.99/http%3A//www.cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">59.80.44.99/http://www.</span><span class=\"invisible\">cs.columbia.edu/~nahum/w6998/papers/sosp87-timing-wheels.pdf</span><span class=\"ellipsis\"></span></a>]</li><li>[<a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/linux/l-cn-timers/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">ibm.com/developerworks/</span><span class=\"invisible\">cn/linux/l-cn-timers/</span><span class=\"ellipsis\"></span></a>]</li><li>[<a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/linux/1308_liuming_linuxtime3/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">ibm.com/developerworks/</span><span class=\"invisible\">cn/linux/1308_liuming_linuxtime3/</span><span class=\"ellipsis\"></span></a>]</li></ol>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53581298", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 7, 
            "title": "内存分配", 
            "content": "<h2><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jingyugao/golang_runtime_reading/blob/gjy/sample/go-memory.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jingyugao/golang_runtime_reading</a></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><code>glibc</code>用的malloc为ptmalloc2。往往不能满足我们的需要，造轮子实现一个内存池或者内存分配器几乎是家常便饭。对于ptmalloc2，至少有以下缺点。</p><p> 1. 内存碎片多。 </p><p>2. 内存释放方式不太好。ptmalloc 收缩内存是从 top chunk 开始,如果与 top chunk 相邻的 chunk 不能释放, top chunk 以下的 chunk 都无法释放。</p><p> 3. 锁的开销，并发性能低。</p><p> 4. 内存释放不可控(free后不会立刻把内存还给os,而且采用)。</p><p> 5. 线程不均衡。(线程A分配的内存用完之后free掉，这块内存一般不会立刻归还os，线程B malloc的时候不能用这块内存) </p><p>6. 元数据较大。 </p><p>7. 小对象分配速度低。</p><h2>glibc和tmalloc对比</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7a5d80588558b8ae7f19c7207ca7a027_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1310\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"1310\" data-original=\"https://pic4.zhimg.com/v2-7a5d80588558b8ae7f19c7207ca7a027_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1310&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1310\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1310\" data-original=\"https://pic4.zhimg.com/v2-7a5d80588558b8ae7f19c7207ca7a027_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7a5d80588558b8ae7f19c7207ca7a027_b.jpg\"/></figure><h2>go的内存分配器</h2><p>tmalloc是通用的内存分配器，通用性往往会降低性能，因此go借鉴tmalloc的思想实现了一套内存分配器。此外go还有垃圾回收机制，这也增加了分配器的复杂度。 首先，os的内存是以页为单位的，go自己搞了一个页的概念，一页为8k，span是多个页。 分为多级姑且称为(0-3) </p><p>0级:封装了mmap和ummap，向os申请内存，每次都申请一大块。</p><p>1级:heap，里面管理了所有的内存，全局唯一。负责把内存切割成span。并且有内存信息统计功能。 </p><p>2级:mcentral，全局唯124个。把内存切割为相同大小的&#34;对象&#34;,一个&#34;对象&#34;就是最小的分配单位。(有一点点浪费，但是整齐，方便管理) </p><p>3级:mcache，每个P一个。相当于TLS变量，不需要加锁，很快。</p><h2>span</h2><p>go的内存是以span组织的，一个span是多个页。span主要是给内存做一个bitmap，标记是否使用，有O(1)的分配效率。 span这个bitmap很巧妙，主要有两个函数。<code>nextFreeIndex</code>和<code>nextFreeFast</code> 首先看nextFreeFast:</p><div class=\"highlight\"><pre><code class=\"language-text\">func nextFreeFast(s *mspan) gclinkptr {\n    // 第几位开始不是0,从0位开始,从右边开始数。\n    theBit := sys.Ctz64(s.allocCache) // Is there a free object in the allocCache?\n    // 超过了说明没可用的了\n    if theBit &lt; 64 {\n        result := s.freeindex + uintptr(theBit)\n        // 超过了表明无可用的\n        if result &lt; s.nelems {\n            // 可能有可用的\n            freeidx := result + 1\n            if freeidx%64 == 0 &amp;&amp; freeidx != s.nelems {\n                // 不是最后一个，且整除64，返回0\n                return 0\n            }\n            // 真的有可用的\n            // 更新一下\n            s.allocCache &gt;&gt;= uint(theBit + 1)\n            s.freeindex = freeidx\n            s.allocCount++\n            return gclinkptr(result*s.elemsize + s.base())\n        }\n    }\n    return 0\n}</code></pre></div><p>看到这难免有些疑问 <i> allocCache是什么? </i> Ctz64又是什么? * 这段代码又是如何工作的?</p><p>首先来看go的注释:</p><blockquote> allocCache 是 allocBit的一段(所以叫cache)，从freeindex开始的64位（可能会溢出，自行考虑） freeindex 在0-nelems之间，代表了查找空闲对象的起点。 每次分配都会从freeindex开始扫描allocBits直到它为0(allocBits的第x位)，意味着这里是(x)空闲对象 freeindex 调节以使以后的扫描从新发现的freeobject开始。 如果freeindex==nelem 说明没有空闲对象了 allocBits是对象的bitmap，allocBit中1表示使用，allocCache中1表示未使用 如果n&gt;=freeindex而且allocBits[n/8]&amp;(1&lt;&lt;(n%8))为0，(即allocBits的第n位为0),说明这是free的。 否则，n是已经分配的。nelem后的Bits未定义的，不应该被引用 object n 的起使内存是 n*elemsize+(start&lt;&lt;\\pageShift)  (span起使内存+对象偏移)<br/> </blockquote><p>这里比较乱，大概意思是，allocBits是一个bitmap，标记是否使用，通过allocBits已经可以达到O(1)的分配速度，但是go为了极限性能，对其做了一个缓存，allocCache，从freeindex开始，长度是64。</p><p>初始状态，freeindex是0,allocCache全是1，allocBit是0。 </p><p> 第一次分配，theBit是0，freeindex为1，allocCache为01111...。 </p><p>第二次分配，theBit还是0，freeinde是2，allocCache为001111...。 </p><p>...</p><p>在一个span清扫之后，情况会又些复杂。 freeindex会为0，不妨假设allocBit为1010....1010。全是1和0交替。 </p><p>第一次分配，theBit是1，freeindex是2,allocCache是001010...10。 </p><p>第二次分配，theBit是1，freeindex是4,allocCache是00001010..10。 ...</p><p>最终freeindex变为了64返回0，这是会调用<code>func (s *mspan) nextFreeIndex() uintptr</code></p><div class=\"highlight\"><pre><code class=\"language-text\">func (s *mspan) nextFreeIndex() uintptr {//这个函数有硬件优化，性能极高。\n    sfreeindex := s.freeindex\n    snelems := s.nelems\n    if sfreeindex == snelems { // 没有空闲的对象了\n        return sfreeindex\n    }\n    aCache := s.allocCache\n    bitIndex := sys.Ctz64(aCache)\n    for bitIndex == 64 { //allocCache为0，没有一个空闲对象，说么要更新一下allocCache了\n        // 找到下一个缓存的地址。这个是吧sfreeindex取向上64的倍数\n        sfreeindex = (sfreeindex + 64) &amp;^ (64 - 1)\n        if sfreeindex &gt;= snelems {\n            // 说明真的没了\n            s.freeindex = snelems\n            return snelems\n        }\n        // 只是缓存的值不行了，更新一下allocCache就好\n        whichByte := sfreeindex / 8 // sfreeindex是64的倍数,不需要担心整除的问题\n        s.refillAllocCache(whichByte)\n        aCache = s.allocCache\n        bitIndex = sys.Ctz64(aCache)\n    }\n    result := sfreeindex + uintptr(bitIndex)\n    if result &gt;= snelems {\n        s.freeindex = snelems\n        return snelems\n    }\n    s.allocCache &gt;&gt;= uint(bitIndex + 1)\n    sfreeindex = result + 1\n    if sfreeindex%64 == 0 &amp;&amp; sfreeindex != snelems {\n        whichByte := sfreeindex / 8\n        s.refillAllocCache(whichByte)\n    }\n    s.freeindex = sfreeindex\n    return result\n}</code></pre></div><p>这个函数会试着移动一下缓存，如果不行就申请新的span。通过这个操作，极大的提高了内存的复用和速度。 回收的时候也只需要标记一下bitmap就可以了。不会出现间隙对象不能复用的情况。</p><h2>mcache</h2><p>对于小块内存(&lt;32k)是从mcache开始分配，若不足则从上一级分配内存。多级分配。mcache每个P一个，分配时不需要加锁，这一层用来解决并发问题。 另外由于go是有gc的，go的gc是标记清楚法，这个算法会从<i>根对象</i>开始遍历所有储存指针的地方并递归标记。 这种方法往往需要知道一个地方储存的是指针还是整数，go通过bitmap储存了这个信息。 但是go对此做了一个优化，把内存分为noscan和scan的，对于前者，nosca意味着不含指针，在gc扫描过程中可以被忽略。 我们程序中经常使用的都是一些不含指针的结构体，他们不会被扫描，这样可以提高gc的性能。 对于noscan且非常小的对象(&lt;16byte),为了避免浪费，go做了一个小对象分配器来分配，减小的内存分配效率。</p><h2>mcentral</h2><p>mcentral是固定大小的分配器，有124个。这一级出现了对象的概念，比如class=3的mcentral是对象大小为32byte的分配器。 其中的span以双向链表的方式组织，分为两个。 noempty表示表示确定该span最少有一个未分配的元素，empty表示不确定该span最少有一个未分配的元素。 在查找的时候还会辅助做一些内存回收。如果没有内存可以会继续向上一级分配内存。 mcentral.go文件比较小，有意思的函数是<code>func (c *mcentral) cacheSpan() *mspan</code>，这个函数有100多行，占了文件的一半。下面分析一下简要流程。 这个函数是用来给mcache发放span的，分配之前会做一些回收工作，具体做多少根据mcentral的类型决定。 比如class=3的mcentral要做一个pageSize(8k)的gc工作量。(这个8k还需要乘以一个系数，之后得到的是要清扫的页数，这个页数就是工作量)</p><div class=\"highlight\"><pre><code class=\"language-text\">retry:\n    for s = c.nonempty.first; s != nil; s = s.next {\n        if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) {\n            //至少有一个可以使用的对象。\n            //待会分配完就不保证还有了，所以放入empty中。\n            c.nonempty.remove(s)\n            c.empty.insertBack(s)\n            unlock(&amp;c.lock)\n            s.sweep(true)\n            goto havespan\n        }\n        if s.sweepgen == sg-1 {\n            // 正在清扫，下一个\n            // the span is being swept by background sweeper, skip\n            continue\n        }\n        // 请扫过了 可以直接用\n        // we have a nonempty span that does not require sweeping, allocate from it\n        c.nonempty.remove(s)\n        c.empty.insertBack(s)\n        unlock(&amp;c.lock)\n        goto havespan\n    }</code></pre></div><p>这里需要解释一下nonempty 和empty的语意。 nonempty意味着至少有一个对象。 比如class=3，这个span有8k，总共可以有256个对象，nonempty意味着现在最多有255个，也就是说，还有一个空余，也可能更多。 empty意味着不确定只少有一个可用的对象。可能有，也可能没有。只要可能没有，就放进去。 如果没有的话会去empty中碰碰运气，</p><div class=\"highlight\"><pre><code class=\"language-text\">for s = c.empty.first; s != nil; s = s.next {\n        // 需要清扫\n        if s.sweepgen == sg-2 &amp;&amp; atomic.Cas(&amp;s.sweepgen, sg-2, sg-1) {\n            //这个链表遍历操作很秀，下面的remove和inertBack\n            c.empty.remove(s)\n            c.empty.insertBack(s) //现在s是链表末尾且s.next=nil\n            unlock(&amp;c.lock)\n            s.sweep(true)\n            freeIndex := s.nextFreeIndex()\n            if freeIndex != s.nelems {\n                s.freeindex = freeIndex\n                //找到空闲的就返回了。\n                goto havespan\n            }\n            lock(&amp;c.lock)\n            //这里会回到函数开头。\n            goto retry\n        }\n        if s.sweepgen == sg-1 {\n            // the span is being swept by background sweeper, skip\n            continue\n        }\n        // already swept empty span,\n        // all subsequent ones must also be either swept or in process of sweeping\n        break\n    }</code></pre></div><h2>mheap</h2><p>堆是负责最终的内存分配，准确的说是span的分配，堆中负责把内存切割为span(以及span再切割，span合并)， 还会统计各种内存信息，gc信息，bitmap信息，还包括了几个特殊的分配器(go内部使用) 首先heap把span分为四类: </p><p>free [MaxMHeapList]mSpanList:小于128页的span，且未使用。是一个数组链表。下标代表span的页数。 </p><p>freelarge mTreap:大于128页的span，且未使用。是一个树堆。 </p><p>busy [MaxMHeapList]mSpanList:小于128页的span，且已使用。 </p><p>busylarge mSpanList:大于128页的span，且已使用。是一个链表。</p><p>我们知道，mcentral都是有固定型号的(对象大小，span页数),比如class=34的mcentral需要的span是16k，两页。mheap则负责去查找2页的span。这里是first-fit。</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"k\">for</span> <span class=\"nx\">i</span> <span class=\"o\">:=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"nx\">npage</span><span class=\"p\">);</span> <span class=\"nx\">i</span> <span class=\"p\">&lt;</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"nx\">h</span><span class=\"p\">.</span><span class=\"nx\">free</span><span class=\"p\">);</span> <span class=\"nx\">i</span><span class=\"o\">++</span> <span class=\"p\">{</span>\n        <span class=\"nx\">list</span> <span class=\"p\">=</span> <span class=\"o\">&amp;</span><span class=\"nx\">h</span><span class=\"p\">.</span><span class=\"nx\">free</span><span class=\"p\">[</span><span class=\"nx\">i</span><span class=\"p\">]</span>\n        <span class=\"k\">if</span> <span class=\"p\">!</span><span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nf\">isEmpty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n            <span class=\"nx\">s</span> <span class=\"p\">=</span> <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nx\">first</span>\n            <span class=\"nx\">list</span><span class=\"p\">.</span><span class=\"nf\">remove</span><span class=\"p\">(</span><span class=\"nx\">s</span><span class=\"p\">)</span>\n            <span class=\"k\">goto</span> <span class=\"nx\">HaveSpan</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span></code></pre></div><p>如果查找不到则会从freeLarge中查找一个。best-fit。</p><div class=\"highlight\"><pre><code class=\"language-text\">for t != nil {\n        if t.spanKey == nil {\n            throw(&#34;treap node with nil spanKey found&#34;)\n        }\n        if t.npagesKey &lt; npages {\n            t = t.right\n        } else if t.left != nil &amp;&amp; t.left.npagesKey &gt;= npages {\n            t = t.left\n        } else {\n            result := t.spanKey\n            root.removeNode(t)\n            return result\n        }\n    }</code></pre></div><p>如果span较大会对其进行切割，将剩余的边角料放入free或者freeLarge中去。 此外，分配之前还会进行回收工作，如果busy中的span有不用了的，会将其放入free中。</p><p>参考资料：</p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zkweb/p/7880099.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-9d728b7e8e69179ba70c6b47c93d6723_180x120.jpg\" data-image-width=\"778\" data-image-height=\"125\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Golang源码探索(三) GC的实现原理</a><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53030052", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 3, 
            "title": "连接器和目标文件", 
            "content": "<h2>链接器和目标文件</h2><p>今天，我们谈一谈go的linker，目标文件和relocations(重定位，变量地址的分配是在链接时分配的) 为什么要关注这些东西？如果你学习任何语言的内部原理，第一件要做的事就是模块划分。第二就是理解模块暴露出来的接口。对于go，高层的模块是编译器，链接器和runtime。编译器给链接器提供的接口就是目标文件，也是我们今天要说的。</p><h2>生成go目标文件。</h2><p>做一个简单的小实验，写一段小程序并编译，然后看看目标文件是什么样的。</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nfunc main() {\n    print(1)\n}</code></pre></div><p>用下面的命令编译。</p><div class=\"highlight\"><pre><code class=\"language-text\">go tool compile test.go</code></pre></div><p>为了查看内部结构，我们需要用 <i>goobj</i> 库。这是go内部使用的，用来检验生成的目标文件是否正确。我已经写了一个小程序。地址在github上。使用go get安装。</p><div class=\"highlight\"><pre><code class=\"language-text\">go get github.com/s-maktyukevich/goobj_explorer\ngoobj_explorer -o test.6</code></pre></div><p>接着你会看到<code>gob.Package</code>的具体结构。(现在这个工具可能会编译不过,需要到~/src/github.com/golang/go下面，检出go1.4分支，接着吧src/cmd/internal文件复制一份，名为src/cmd/inter2,最后把github.com/s-matyukevich/goobj_explorer/main.go里面的import路径改为inter2,当然了，go的版本最好也是1.4的，推荐用docker)</p><h2>分析目标文件</h2><p>目标文件最有趣的部分是 <i>Syms array</i>。这其实是符号表。程序中所有你定义的函数，全局变量，类型，常量等都在其中。接下来看一下<i>main</i>函数的入口。(已经略去部分代码)</p><div class=\"highlight\"><pre><code class=\"language-text\">&amp;goobj.Sym{\n            SymID: goobj.SymID{Name:&#34;main.main&#34;, Version:0},\n            Kind:  1,\n            DupOK: false,\n            Size:  48,\n            Type:  goobj.SymID{},\n            Data:  goobj.Data{Offset:137, Size:44},\n            Reloc: ...,\n            Func:  ...,\n}</code></pre></div><p>goobj.Sum结构的字段如下:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bbbf7a925467e13d7cbf7e9433938091_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1540\" data-rawheight=\"668\" class=\"origin_image zh-lightbox-thumb\" width=\"1540\" data-original=\"https://pic2.zhimg.com/v2-bbbf7a925467e13d7cbf7e9433938091_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1540&#39; height=&#39;668&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1540\" data-rawheight=\"668\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1540\" data-original=\"https://pic2.zhimg.com/v2-bbbf7a925467e13d7cbf7e9433938091_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bbbf7a925467e13d7cbf7e9433938091_b.jpg\"/></figure><p>现在看一下符合的种类。符号种类定义在 <i>goobj</i> 包中。</p><div class=\"highlight\"><pre><code class=\"language-text\">const (\n    _ SymKind = iota\n\n    // readonly, executable\n    STEXT\n    SELFRXSECT\n\n    // readonly, non-executable\n    STYPE\n    SSTRING\n    SGOSTRING\n    SGOFUNC\n    SRODATA\n    SFUNCTAB\n    STYPELINK\n    SSYMTAB // TODO: move to unmapped section\n    SPCLNTAB\n    SELFROSECT\n    ...</code></pre></div><p>可以看出<i>main.main</i>是<i>STEXT</i>类型的符号。<i>STEXT</i>是包含机器码的符号。现在，我们看一下Reloc数组。包含以下结构。</p><div class=\"highlight\"><pre><code class=\"language-text\">type Reloc struct {\n    Offset int\n    Size   int\n    Sym    SymID\n    Add    int\n    Type int\n}</code></pre></div><p>每次relocation都意味着位于[offset,offset+size]间的字节需要被一个新的地址代替。这个地址通过Sym符号的地址和字节数相加得到。(直接替换地址，简单粗暴。地址计算还是类似于基地址+偏移量的到的。)</p><h2>理解relocations</h2><p>现在用一个例子理解relocation如何工作的。</p><div class=\"highlight\"><pre><code class=\"language-text\">go tool compile -S test.go</code></pre></div><p>查看main函数的汇编码。(和c的汇编差不多，汇编应该都这种样子)</p><div class=\"highlight\"><pre><code class=\"language-text\">&#34;&#34;.main t=1 size=48 value=0 args=0x0 locals=0x8\n    0x0000 00000 (test.go:3)    TEXT    &#34;&#34;.main+0(SB),$8-0\n    0x0000 00000 (test.go:3)    MOVQ    (TLS),CX  //拿到g的指针\n    0x0009 00009 (test.go:3)    CMPQ    SP,16(CX) //16(CX)是g里面的preempt字段。\n    0x000d 00013 (test.go:3)    JHI ,22 //做其他事，被抢占或者进行栈扩张。\n    0x000f 00015 (test.go:3)    CALL    ,runtime.morestack_noctxt(SB)\n    0x0014 00020 (test.go:3)    JMP ,0\n    0x0016 00022 (test.go:3)    SUBQ    $8,SP\n    0x001a 00026 (test.go:3)    FUNCDATA    $0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)\n    0x001a 00026 (test.go:3)    FUNCDATA    $1,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)\n    0x001a 00026 (test.go:4)    MOVQ    $1,(SP)\n    0x0022 00034 (test.go:4)    PCDATA  $0,$0\n    0x0022 00034 (test.go:4)    CALL    ,runtime.printint(SB)\n    0x0027 00039 (test.go:5)    ADDQ    $8,SP\n    0x002b 00043 (test.go:5)    RET ,</code></pre></div><p>这里我们关心这一行:</p><div class=\"highlight\"><pre><code class=\"language-text\">0x0022 00034 (test.go:4)    CALL    ,runtime.printint(SB)</code></pre></div><p>这个语句的偏移量是<code>0x0022</code>。这个偏移量是相对于函数数据的。这一行实际上是调用了<code>runtime.printint</code>函数。而函数并不知道<code>runtime.printint</code>函数的真实地址。这个函数在不同的目标文件中。因此要通过relocation。下面展示了具体的内容。</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n                    Offset: 35,// 0x0022的十进制是34\n                    Size:   4,\n                    Sym:    goobj.SymID{Name:&#34;runtime.printint&#34;, Version:0},\n                    Add:    0,\n                    Type:   3,\n                },</code></pre></div><p>这个relocation告诉连接器，从偏移量35开始，需要吧4个字节的数据用<code>runtime.printint</code>符号的地址代替。(为什么不是35，因为有一个字节是操作符call,后面的是地址)</p><h2>理解TLS</h2><p>细心的读者注意到main函数的relocation。这和其他的都不同，他有一个空的symbol:</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n                    Offset: 5,\n                    Size:   4,\n                    Sym:    goobj.SymID{},\n                    Add:    0,\n                    Type:   9,\n                },</code></pre></div><p>这是什么意思。偏移量为5，size为4是这条语句。(获取当前g的指针)</p><div class=\"highlight\"><pre><code class=\"language-text\">0x0000 00000 (test.go:3)    MOVQ    (TLS),CX</code></pre></div><p>从0开始有9个byte(TEXT和MOVQ两行,CMPQ开始的是9),可以猜到这个重定向是跟tls有关的。但是TLS是什么，又将如何定位呢？(似乎go对TLS也有修改) TLS是线程局部变量。这个东西在很多语言中都有。简而言之，他可以让一个变量在不同的线程中代表不同的数据。(例如c语言中的errorn.) 在go中，TLS用来储存指向g的指针。因而不同goroutine运行时，其可以指向不同的g(总是指向正在运行的g，不过切换过程中还是会有一些中间态)。链接器知道这个变量的地址并把它移到<code>CX</code>寄存器中。TLS在不同的机器上有不同的实现。对于AMD64，TLS是通过FS寄存器，因此这条命令最终会被翻译为<code>MOVQ FS,CX</code> (连接器会把这些虚拟寄存器转换成真实的寄存器，这是在relocation的时候进行的)</p><h2>函数</h2><p>下面谈论一下go的函数结构和垃圾回收的一些细节。</p><h2>元数据</h2><p>下面看一下<code>main</code>函数的结构。(go是支持反射的，func和struct会有一些元信息来支持反射)</p><div class=\"highlight\"><pre><code class=\"language-text\">Func: &amp;goobj.Func{\n    Args:    0, //函数参数数目\n    Frame:   8, //参数和返回值的byte数，go的参数和返回值都是在栈上，参考go如何返回多个值。\n    Leaf:    false,//ARM架构下的，\n    NoSplit: false,//参考//go:nosplit，不要进行stack check，自然也不会发生栈扩张。\n    Var:     {\n    },//局部变量的信息。\n    //文件的信息，行数之类的，参考debug.Stack()\n    PCSP:   goobj.Data{Offset:255, Size:7},\n    PCFile: goobj.Data{Offset:263, Size:3},\n    PCLine: goobj.Data{Offset:267, Size:7},\n    PCData: {\n        {Offset:276, Size:5},\n    },\n    FuncData: {\n        {\n            Sym:    goobj.SymID{Name:&#34;gclocals·3280bececceccd33cb74587feedb1f9f&#34;, Version:0},\n         Offset: 0,\n     },\n     {\n         Sym:    goobj.SymID{Name:&#34;gclocals·3280bececceccd33cb74587feedb1f9f&#34;, Version:0},\n               Offset: 0,\n           },\n       },\n       File: {&#34;/home/adminone/temp/test.go&#34;},\n   },</code></pre></div><p>可以发现函数信息在编译的时候加入了目标文件并且被runtime使用。接下来讲述go是如何利用这些元信息的。 在<code>runtime</code>包中，元信息的结构体如下。</p><div class=\"highlight\"><pre><code class=\"language-text\">type _func struct {\n    entry   uintptr // start pc 这个是函数的地址\n    nameoff int32   // function name 函数名\n\n    args  int32 // in/out args size 参数大小\n    frame int32 // legacy frame size; use pcsp if possible \n\n    pcsp      int32\n    pcfile    int32\n    pcln      int32\n    npcdata   int32\n    nfuncdata int32\n}</code></pre></div><p>可以看出并非目标文件中的所有信息都被映射了。一些字段只是用于连接器。而且，最有趣的是<code>pscp,pcfile,pcln</code>三个字段，用于程序计数器，被翻译为栈指针，文件名，和行号。(程序计数器,program counter,参考wiki,这里的意思应该是记录了代码的信息) 这是很有用的，比如panic的时候。准确的说，runtime只知道触发panic的汇编码。然后runtime根据程序计数器找到当前的文件名，行号和调用栈。文件名和行号是<code>pcfile</code>和<code>pcln</code>。调用栈需要递归的查询<code>pcsp</code> 既然有了程序计数器，那么如何获取对应的行号呢？查看汇编码中的行号。</p><div class=\"highlight\"><pre><code class=\"language-text\">0x001a 00026 (test.go:4)    MOVQ    $1,(SP)\n    0x0022 00034 (test.go:4)    PCDATA  $0,$0\n    0x0022 00034 (test.go:4)    CALL    ,runtime.printint(SB)\n    0x0027 00039 (test.go:5)    ADDQ    $8,SP\n    0x002b 00043 (test.go:5)    RET ,</code></pre></div><p>可以看出程序计数器从26到38包含了行号4，从39到下一个程序计数器记录了行号5。为了节省空间，可以这样储存。</p><div class=\"highlight\"><pre><code class=\"language-text\">26 - 4\n39 - 5\n...</code></pre></div><p>编译器知道这些信息。<code>pcln</code>字段指向当前函数在程序计数器的起点。然后二分法搜索可以找到对应的行号。 在g\\o中美这是很普遍的，不只是行号或栈指针映射在程序计数器中，任何整数都映射其中。通过<code>PCDATA</code>命令。(这个东西是用来辅助GC的，在go源码中搜索<code>pcdatavalue</code>可以看出具体是如何使用的。参考scanframeworker)</p><div class=\"highlight\"><pre><code class=\"language-text\">0x0022 00034 (test.go:4)    PCDATA  $0,$0</code></pre></div><p>第一个参数意为，这是一个函数或者是一个变量。第二个是一个包含了gc mask的变量的引用。</p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": [
                {
                    "userName": "大道至简", 
                    "userLink": "https://www.zhihu.com/people/32b2ba3d036721ba94f91c4abb43200e", 
                    "content": "<p>好文!!! 请教一下, 如果不用go低版本和6g处理, go新版本应该怎么生产goobj的Sym. 两种版本编译出来的结果会不一样吗,go更改了TSL的处理吗?</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52614346", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 9, 
            "title": "go编译器", 
            "content": "<p>翻译自</p><a href=\"https://link.zhihu.com/?target=https%3A//blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-3add38610b1463497aec33b1d3545f3c_180x120.jpg\" data-image-width=\"300\" data-image-height=\"195\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Golang Internals, Part 3: The Linker, Object Files, and Relocations | Altoros</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jingyugao/golang_runtime_reading/blob/27c93967762570ddec54fb46747fcffebdc7964f/sample/tmp.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-20cbb0a67f8f400a3301141c82b3f749_ipico.jpg\" data-image-width=\"150\" data-image-height=\"150\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jingyugao/golang_runtime_reading</a><p>这个系列的博文面向那些已经熟悉go的基本语法并想要深入了解内部原理的读者。今天的博文主要介绍go源码结构和一些go编译器细节。读完这篇文章，你应该可以回答以下问题:</p><p> 1. go源码的结构是什么样的？</p><p> 2. go编译器是如何工作的？</p><p> 3. go的node tree的基本结构是什么样的？</p><h2>开始准备</h2><div class=\"highlight\"><pre><code class=\"language-text\">当你开始学习一门新的语言时，你通常可以找到许多&#34;helloworld&#34;的教程、入门指导、或者关于语言概念、语法、甚至标准库的书。然而，从这些资料上无法获取到语言runtime分配的内存布局或者当你调用内部函数时生成的汇编代码。显然的，这些答案隐藏来源码之中，但是，按照我的经验，你可能花费了几个小时思考，但是却没有取得什么进展。</code></pre></div><p>在这个主题，我即不会装作是一个专家，也不会尝试解释每个概念。相反，本文的目标是使你独立的识别go的源码。 开始之前，我们需要一份源码的拷贝。简单执行下面的命令。</p><div class=\"highlight\"><pre><code class=\"language-text\">git clone https://github.com/golang/go</code></pre></div><p>注意master分支的代码已经更新了许多，因此我们使用 <i>release-branch.go1.4</i> 分支。</p><h2>项目结构</h2><p>如果你看<code>/src</code>目录，你可以看到许多子目录。大多数都包含标准库的代码。这里的命名很标准，因此每个package都在一个相同名字的目录下。除了标准库，还有一些其他东西。在我看来，主要的目录如下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f85d08f15d635939aa3f95670479d43e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"798\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb\" width=\"798\" data-original=\"https://pic3.zhimg.com/v2-f85d08f15d635939aa3f95670479d43e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;798&#39; height=&#39;730&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"798\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"798\" data-original=\"https://pic3.zhimg.com/v2-f85d08f15d635939aa3f95670479d43e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f85d08f15d635939aa3f95670479d43e_b.jpg\"/></figure><h2>编译器</h2><p>正如上面所说，编译器平台无关的代码在<code>/src/cmd/gc</code>目录。入口点在<code>lex.c</code>文件。除了公共的部分，例如解析命令行参数，编译器做了以下事情： 1. 初始化一些公共的数据结构。 2. 遍历所有提供的go文件，对每个文件调用<i>yyoarse</i>方法。这是实际的parser。编译器用<i>Bison</i>作为语法解析器。语言的语法全部位于<code>go.y</code>文件。这一步产生一个完整的语法数，每个节点都代表被编译程序的一个元素。 3. 多次递归访问生成的语法树，并做一些修改。例如，定义implicit type的类型信息，重写一些语句--例如类型转换--调用runtime包的函数或做一些其他工作。 4. 语法树完成之后开始真正的编译。节点被编译为机器语言。 5. 创建目标文件，包含生成机器码和其他数据，比如符号表。这个会被写入磁盘。</p><h2>深入GO语法</h2><div class=\"highlight\"><pre><code class=\"language-text\">现在让我们看一下第二步。理解go编译器和语法，包含了语法的`go.y`文件是一个很好的切入点。文件的主要部分包括声明，如下：\nxfndcl:\n     LFUNC fndcl fnbody\n\nfndcl:\n     sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres\n| &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres</code></pre></div><p>这个声明中，定义了<code>xfndcl</code>和<code>fundcl</code>。<code>fundck</code>节点有两种形式， <code>somefunction(x int, y int) int</code>或者 <code>(t *SomeType) somefunction(x int, y int) int</code>. <code>xfndcl</code>节点包含<code>func</code>的关键字，储存在<code>LFUNC</code>常量中，跟在<code>fndcl</code>和<code>fnbodynodes</code>后。 Bison的一个重要特性是他允许在每个定义之后放置c代码。每当匹配到这个定义时，代码就会执行一次。这里你可以引用变量<code>$$,$1,$2</code>等。<code>$$</code>为返回值，其余为参数。 可以通过下面的例子来理解。以下是一段实际的代码。</p><div class=\"highlight\"><pre><code class=\"language-text\">fndcl:\n      sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres\n        {\n          t = nod(OTFUNC, N, N);\n          t-&gt;list = $3;\n          t-&gt;rlist = $5;\n\n          $$ = nod(ODCLFUNC, N, N);\n          $$-&gt;nname = newname($1);\n          $$-&gt;nname-&gt;ntype = t;\n          declare($$-&gt;nname, PFUNC);\n      }\n| &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; sym &#39;(&#39; oarg_type_list_ocomma &#39;)&#39; fnres</code></pre></div><p>首先，创建了一个新的<i>node</i>，这个节点包含了函数的类型信息。<code>$3</code>和<code>$5</code>代表<code>oarg_type_list_ocomma</code>和<code>fnres</code>。最后创建了<code>$$</code>节点，储存了函数名和类型信息。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-277a973816d8a52ea203cb786fa0d976_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"866\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"866\" data-original=\"https://pic3.zhimg.com/v2-277a973816d8a52ea203cb786fa0d976_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;866&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"866\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"866\" data-original=\"https://pic3.zhimg.com/v2-277a973816d8a52ea203cb786fa0d976_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-277a973816d8a52ea203cb786fa0d976_b.jpg\"/></figure><p>现在你理解了语法树等基本结构。你可以实践一下。在下面的内容，我们会使用一个简单的go程序分析汇编码的生成。</p><h2>深入编译器</h2><p>你了解当你通过<code>interface</code>引用一个变量时，发生了什么么？这不是个无聊的问题，因为go语言中一个类型实现了一个不包含任何自身信息的接口。我们可以试着回答一下，通过编译器的知识。 现在，让我们深入编译器，创建一个go程序看一下类型转换的内部原理。看一下语法树如何生成和使用的。 开始之前 为了完成实验，我们需要直接使用编译器(不是go tool)</p><div class=\"highlight\"><pre><code class=\"language-text\">go tool 6g test.go</code></pre></div><p>这会编译test.go并生成目标文件。这里6g时amd64下的编译器名字。不同的平台应该用不同的名字。有时候，我们也需要一些其他的命令行参数。例如，我们用 -W标志打印语法树的结构。 创建一个简单的go程序。 首先，创建一个简单的程序。</p><div class=\"highlight\"><pre><code class=\"language-text\">1  package main\n  2 \n  3  type I interface {\n  4          DoSomeWork()\n  5  }\n  6 \n  7  type T struct {\n  8          a int\n  9  }\n 10 \n 11  func (t *T) DoSomeWork() {\n 12  }\n 13 \n 14  func main() {\n 15          t := &amp;T{}\n 16          i := I(t)\n 17          print(i)\n 18  }</code></pre></div><p>接着编译它</p><div class=\"highlight\"><pre><code class=\"language-text\">go tool 6g -W test.go</code></pre></div><p>之后，你会看到输出中的语法树，每个方法都在其中。这里是<code>main</code>和<code>init</code>方法。<code>init</code>方法是程序隐式定义的，我们现在并不关心。 对于每个方法，编译器有两个打印版本。第一格式解析源文件的到的原始语法树，第二个是类型检查和一些更改之后的到的。</p><p>语法树的main函数</p><div class=\"highlight\"><pre><code class=\"language-text\">DCL l(15)\n.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n\nAS l(15) colas(1) tc(1)\n.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n.   PTRLIT l(15) esc(no) ld(1) tc(1) PTR64-*main.T\n.   .   STRUCTLIT l(15) tc(1) main.T\n.   .   .   TYPE &lt;S&gt; l(15) tc(1) implicit(1) type=PTR64-*main.T PTR64-*main.T\n\nDCL l(16)\n.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I\n\nAS l(16) tc(1)\n.   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n.   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n\nAS l(16) colas(1) tc(1)\n.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I\n.   CONVIFACE l(16) tc(1) main.I\n.   .   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n\nVARKILL l(16) tc(1)\n.   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n\nPRINT l(17) tc(1)\nPRINT-list\n.   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I</code></pre></div><p>为了简要，采取了删减版的代码。 第一个节点很简单:</p><div class=\"highlight\"><pre><code class=\"language-text\">DCL l(15)\n.   NAME-main.t l(15) PTR64-*main.T</code></pre></div><p>第一个节点是声明节点。I(15)说么这个节点在15行定义。节点引用了代表matin.t变量的节点。这个变量在main包中定义，是一个main.T类型的指针。通过15行可以看出这一点。 下一个有些复杂。</p><div class=\"highlight\"><pre><code class=\"language-text\">AS l(15) \n.   NAME-main.t l(15) PTR64-*main.T\n.   PTRLIT l(15) PTR64-*main.T\n.   .   STRUCTLIT l(15) main.T\n.   .   .   TYPE l(15) type=PTR64-*main.T PTR64-*main.T</code></pre></div><p>根节点是赋值节点。第一个孩子是代表<code>main.t</code>变量的节点。第二个是要赋给<code>main.t</code>的，一个字面值指针。他有一个结构体字面值，其实就是一个指向<code>main.T</code>的指针。 第二个节点是另一个声明。这次，他声明了<code>main.I</code>类型的<code>main.i</code>变量。</p><div class=\"highlight\"><pre><code class=\"language-text\">DCL l(16)\n.   NAME-main.i l(16) main.I</code></pre></div><p>接下来，编译器创建了另一个变量，<code>autotmp_0000</code>，并赋<code>main.t</code>值给他。</p><div class=\"highlight\"><pre><code class=\"language-text\">AS l(16) tc(1)\n.   NAME-main.autotmp_0000 l(16) PTR64-*main.T\n.   NAME-main.t l(15) PTR64-*main.T</code></pre></div><p>最后，这是关键的节点。</p><div class=\"highlight\"><pre><code class=\"language-text\">AS l(16) \n.   NAME-main.i l(16)main.I\n.   CONVIFACE l(16) main.I\n.   .   NAME-main.autotmp_0000 PTR64-*main.T</code></pre></div><p>这里，有一个特殊的节点，叫做<i>CONVIFACE</i>，编译器把它赋值给<code>main.i</code>。但是这没有给我们更多的信息，到底发生了什么。我们需要查看一下经过语法树重写后最终的语法树 编译器如何转换赋值节点 下么你可以看到编译器如何转换赋值节点的。</p><div class=\"highlight\"><pre><code class=\"language-text\">AS-init\n.   AS l(16) \n.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n.   .   NAME-go.itab.*&#34;&#34;.T.&#34;&#34;.I l(16) PTR64-*uint8\n\n.   IF l(16) \n.   IF-test\n.   .   EQ l(16) bool\n.   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n.   .   .   LITERAL-nil I(16) PTR64-*uint8\n.   IF-body\n.   .   AS l(16)\n.   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n.   .   .   CALLFUNC l(16) PTR64-*byte\n.   .   .   .   NAME-runtime.typ2Itab l(2) FUNC-funcSTRUCT-(FIELD-\n.   .   .   .   .   NAME-runtime.typ·2 l(2) PTR64-*byte, FIELD-\n.   .   .   .   .   NAME-runtime.typ2·3 l(2) PTR64-*byte PTR64-*byte, FIELD-\n.   .   .   .   .   NAME-runtime.cache·4 l(2) PTR64-*PTR64-*byte PTR64-*PTR64-*byte) PTR64-*byte\n.   .   .   CALLFUNC-list\n.   .   .   .   AS l(16) \n.   .   .   .   .   INDREG-SP l(16) runtime.typ·2 G0 PTR64-*byte\n.   .   .   .   .   ADDR l(16) PTR64-*uint8\n.   .   .   .   .   .   NAME-type.*&#34;&#34;.T l(11) uint8\n\n.   .   .   .   AS l(16)\n.   .   .   .   .   INDREG-SP l(16) runtime.typ2·3 G0 PTR64-*byte\n.   .   .   .   .   ADDR l(16) PTR64-*uint8\n.   .   .   .   .   .   NAME-type.&#34;&#34;.I l(16) uint8\n\n.   .   .   .   AS l(16) \n.   .   .   .   .   INDREG-SP l(16) runtime.cache·4 G0 PTR64-*PTR64-*byte\n.   .   .   .   .   ADDR l(16) PTR64-*PTR64-*uint8\n.   .   .   .   .   .   NAME-go.itab.*&#34;&#34;.T.&#34;&#34;.I l(16) PTR64-*uint8\nAS l(16) \n.   NAME-main.i l(16) main.I\n.   EFACE l(16) main.I\n.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n.   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T</code></pre></div><p>从输出中看到，编译器首先添加了初始化节点列表。在<code>AS-init</code>节点中，创建了一个新的变量，<code>main.autotmp_0003</code>,并把<code>go.itab.*””.T.””.I</code>变量的值赋给他。之后，检查这个变量是否为nil，。如果是nil，编译器调用<code>runtime.typ2Itab</code>函数并传递以下参数。 <i> 一个<code>main.T</code>类型的指针 </i> 一个<code>main.I</code>类型的指针 * 一个<code>go.itab.*””.T.””.I</code> 的变量 可以看出，这个变量是类型转换的关键。</p><h2>getitab函数</h2><p>接下来要分析<code>runtime.typ2Itab</code>。下面是这个函数。</p><div class=\"highlight\"><pre><code class=\"language-text\">func typ2Itab(t *_type, inter *interfacetype, cache **itab) *itab {\n    tab := getitab(inter, t, false)\n    atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab))\n    return tab\n}</code></pre></div><p>显然真正的工作是在getitab中，第二句只是一个简单的赋值。接下来分析getitab，这个函数很大，所以只截取部分。</p><div class=\"highlight\"><pre><code class=\"language-text\">m = \n    (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0,\n    &amp;memstats.other_sys))\n    m.inter = interm._type = typ\n\nni := len(inter.mhdr)\nnt := len(x.mhdr)\nj := 0\nfor k := 0; k &lt; ni; k++ {\n    i := &amp;inter.mhdr[k]\n    iname := i.name\n    ipkgpath := i.pkgpath\n    itype := i._type\n    for ; j &lt; nt; j++ {\n        t := &amp;x.mhdr[j]\n        if t.mtyp == itype &amp;&amp; t.name == iname &amp;&amp; t.pkgpath == ipkgpath {\n            if m != nil {\n                *(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn\n            }\n        }\n    }\n}</code></pre></div><p>首先分配内存，<i>persistentalloc</i>是go的一个内存分配器。注意，它分配的内存无法释放，会一直存在。 为什么要用它分配呢？我们看一下itab结构体。</p><div class=\"highlight\"><pre><code class=\"language-text\">type itab struct {\n    inter  *interfacetype\n    _type  *_type\n    link   *itab\n    bad    int32\n    unused int32\n    fun    [1]uintptr // variable sized\n}</code></pre></div><p>最后一个字段，是定义为了一个只有一个元素的数组,但其实是可变大小的。(参考gcc变长数组)。接着来看这个数组指针。这些方法和interface里的方法一样。go的作者动态分配这个内存。(当你用unsafe时分配的都是这种内存).内存的大小时结构体自身大小加上interface里的函数数量乘以指针大小</p><div class=\"highlight\"><pre><code class=\"language-text\">unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize</code></pre></div><p>接下来，是两个内嵌循环。首先，我们遍历所有的interface方法。对每个方法都试着找出相关的类型(在mhdr表中储存的)。这是为了检查两个方法是否匹配。 如果我们找到一个匹配的，我们吧指针储存在fun字段中。</p><div class=\"highlight\"><pre><code class=\"language-text\">*(*unsafe.Pointer)(add(unsafe.Pointer(&amp;m.fun[0]), uintptr(k)*ptrSize)) = t.ifn</code></pre></div><p>一个小知识：由于方法都是按照字典序排序的，这个循环可以是O(m+n)而不是O(n*m) 最后是真正的赋值。</p><div class=\"highlight\"><pre><code class=\"language-text\">AS l(16) \n.   NAME-main.i l(16) main.I\n.   EFACE l(16) main.I\n.   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n.   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T</code></pre></div><p>这里，我们把<i>EFACE</i>节点赋给<code>main.i</code>变量。这个<i>EFACE</i>节点包含<code>main.autotmp_0003</code>变量的引用，<code>main.autotmp_0003</code>变量是<code>runtime.typ2Itab</code>方法的返回值，一个itab类型的指针。 最后，这个<code>main.i</code>变量包含一个iface类型的对象，</p><div class=\"highlight\"><pre><code class=\"language-text\">type iface struct {\n    tab  *itab\n    data unsafe.Pointer\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": [
                {
                    "userName": "LucienXian", 
                    "userLink": "https://www.zhihu.com/people/89c8657690e2fa0132984e350c173fbf", 
                    "content": "yyoarse?yyparse吧", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48704118", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 0, 
            "title": "map和channel的创建", 
            "content": "<h2>map和channel</h2><h2>map的创建</h2><p>map的语意为一个指向hmap的指针。 (string的语意是stringStruct。字符串为&#34;&#34; 和 长度为0的语意相同， 即<code>len(str) == 0</code> 和 <code>str == &#34;&#34;</code> 会被编译为相同的汇编代码，只判断长度。 slice的语意为slice。<code>sli == nil</code> 意味着{nil,?,?}的slice， <code>len(sli) == 0</code> 意味着{?,0,?}的slice，cgo中需要注意这点。 因为stringStruct和slice大小比较小，不用指针可以提高缓存命中。 hmap比较大，拷贝开销较大。 )</p><p>map的创建方式有三种: 1. m:=map[int]int{} 2. m:=make(map[int]int) 3. var m map[int]int</p><p>对于情况12，调用的都是 <code>func makemap_small() *hmap</code> ，对于情况3不会调用构造函数， 即一个未初始化的map为nil指针，(string为{nil,0},slice为slice{nil,0,0})</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"c1\">// map的结构，采用了均摊扩容的机制(参考redis，\n</span><span class=\"c1\">// 扩容时写新，双读，每次读都会把这个元素cp到新的里面，\n</span><span class=\"c1\">// 扩容完成后删除旧的，得到均摊O(1)的复杂度。)\n</span><span class=\"c1\">// A header for a Go map.\n</span><span class=\"c1\"></span><span class=\"kd\">type</span> <span class=\"nx\">hmap</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ../reflect/type.go. Don&#39;t change this structure without also changing that code!\n</span><span class=\"c1\"></span>    <span class=\"nx\">count</span>     <span class=\"kt\">int</span> <span class=\"c1\">// # live cells == size of map.  Must be first (used by len() builtin)\n</span><span class=\"c1\"></span>    <span class=\"nx\">flags</span>     <span class=\"kt\">uint8</span>\n    <span class=\"nx\">B</span>         <span class=\"kt\">uint8</span>  <span class=\"c1\">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n</span><span class=\"c1\"></span>    <span class=\"nx\">noverflow</span> <span class=\"kt\">uint16</span> <span class=\"c1\">// approximate number of overflow buckets; see incrnoverflow for details\n</span><span class=\"c1\"></span>    <span class=\"nx\">hash0</span>     <span class=\"kt\">uint32</span> <span class=\"c1\">// hash seed\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 选2的倍数，扩容简单。\n</span><span class=\"c1\"></span>    <span class=\"nx\">buckets</span>    <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nx\">Pointer</span> <span class=\"c1\">// array of 2^B Buckets. may be nil if count==0.\n</span><span class=\"c1\"></span>    <span class=\"nx\">oldbuckets</span> <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nx\">Pointer</span> <span class=\"c1\">// previous bucket array of half the size, non-nil only when growing\n</span><span class=\"c1\"></span>    <span class=\"nx\">nevacuate</span>  <span class=\"kt\">uintptr</span>        <span class=\"c1\">// progress counter for evacuation (buckets less than this have been evacuated)\n</span><span class=\"c1\"></span>\n    <span class=\"nx\">extra</span> <span class=\"o\">*</span><span class=\"nx\">mapextra</span> <span class=\"c1\">// optional fields\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><h2>channel</h2><p>channel的语意为指向hchan的指针。 创建方式只有两种: 1. var c chan int 2. c:=make(chan int,0)</p><p>查看汇编代码，1中直接返回一个nil指针， 对于2会调用 <code>func makechan(t *chantype, size int) *hchan</code> 。</p><div class=\"highlight\"><pre><code class=\"language-text\">0x0026 00038 (mem_chan.go:9)    LEAQ    type.chan int(SB), AX\n    0x002d 00045 (mem_chan.go:9)    PCDATA  $2, $0\n    0x002d 00045 (mem_chan.go:9)    MOVQ    AX, (SP)\n    // 0为buf大小\n    0x0031 00049 (mem_chan.go:9)    MOVQ    $0, 8(SP)\n    0x003a 00058 (mem_chan.go:9)    CALL    runtime.makechan(SB)</code></pre></div><p>其次可以发现，只读chan只是编译断言，由编译器语法分析时保证， 通过unsafe方法把一个只读chan转化为双向chan并进行写入也是可以的。 hchan结构如下:</p><div class=\"highlight\"><pre><code class=\"language-go\"><span class=\"kd\">type</span> <span class=\"nx\">hchan</span> <span class=\"kd\">struct</span> <span class=\"p\">{</span>\n    <span class=\"nx\">qcount</span>   <span class=\"kt\">uint</span>           <span class=\"c1\">// total data in the queue\n</span><span class=\"c1\"></span>    <span class=\"nx\">dataqsiz</span> <span class=\"kt\">uint</span>           <span class=\"c1\">// size of the circular queue\n</span><span class=\"c1\"></span>    <span class=\"nx\">buf</span>      <span class=\"nx\">unsafe</span><span class=\"p\">.</span><span class=\"nx\">Pointer</span> <span class=\"c1\">// points to an array of dataqsiz elements\n</span><span class=\"c1\"></span>    <span class=\"nx\">elemsize</span> <span class=\"kt\">uint16</span>\n    <span class=\"nx\">closed</span>   <span class=\"kt\">uint32</span>\n    <span class=\"nx\">elemtype</span> <span class=\"o\">*</span><span class=\"nx\">_type</span> <span class=\"c1\">// element type\n</span><span class=\"c1\"></span>    <span class=\"nx\">sendx</span>    <span class=\"kt\">uint</span>   <span class=\"c1\">// send index\n</span><span class=\"c1\"></span>    <span class=\"nx\">recvx</span>    <span class=\"kt\">uint</span>   <span class=\"c1\">// receive index\n</span><span class=\"c1\"></span>    <span class=\"nx\">recvq</span>    <span class=\"nx\">waitq</span>  <span class=\"c1\">// list of recv waiters\n</span><span class=\"c1\"></span>    <span class=\"nx\">sendq</span>    <span class=\"nx\">waitq</span>  <span class=\"c1\">// list of send waiters\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// lock protects all fields in hchan, as well as several\n</span><span class=\"c1\"></span>    <span class=\"c1\">// fields in sudogs blocked on this channel.\n</span><span class=\"c1\"></span>    <span class=\"c1\">//\n</span><span class=\"c1\"></span>    <span class=\"c1\">// Do not change another G&#39;s status while holding this lock\n</span><span class=\"c1\"></span>    <span class=\"c1\">// (in particular, do not ready a G), as this can deadlock\n</span><span class=\"c1\"></span>    <span class=\"c1\">// with stack shrinking.\n</span><span class=\"c1\"></span>    <span class=\"nx\">lock</span> <span class=\"nx\">mutex</span>  <span class=\"c1\">// chan是协程安全的\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><p>chan的设计思路类似于linux的select机制， select机制中，如果没有fd可读写(异常)， 挂起线程，并把它加在设备的等待队列上， 设备就绪时，OS唤醒等待队列(把线程投入调度队列中) go也是类似，只不过是协程和go调度器实现。</p><p>select只会通知你有fd就绪，还需要自己循环 查找就绪的fd。 而go自动帮你随机选了一个。</p><h2>声明和初始化语意</h2><ol><li>对于slice: <code>s := []int{}</code> 和 <code>var s []int</code> 对于前者，结果为一个 <code>slice{ ptr=data, len=0, cap=0 }</code> 对于后者，结果为一个 <code>slice{ ptr=nil, len=0 ,cap=0 }</code></li><li>对于string，<code>s := &#34;&#34;</code> 和 <code>var s string</code> 两者相同，都是stringStruct{nil,0}</li><li>对于map，chan这种指针语意的结构， <code>m := map[int]int{}</code> 意味着指向空map的指针， <code>var m map[int]int</code> 意味着空指针。</li></ol><h2>nil的语意</h2><p>在go里面，常常用 nil 来判断一个变量是否初始化，但是对于不同的变量，nil的语意是不同的。 对于指针类型，nil即表示指针的值为0 。未初始化的指针即为 nil (chan 和 map都是指针语意)</p><p>对于非指针类型，即slice和string，情况有些特殊， 首先string不能和nil比较，string要和&#34;&#34;比较，比较的语意为stringStruct.len==0 而slice可以和nil比较，<code>sli == nil</code> 意味着<code>slice.ptr == nil</code>，</p><h2>len(var) == 0 和 var == nil</h2><ul><li>slice:<code>len(sli) == 0</code> 意味着 <code>slice.len == 0</code>,  <code>sli == nil</code> 意味着 <code>slice.ptr == nil</code> 。</li><li>string:两者意思相同(string 的nil对应 &#34;&#34;)，即 <code>string.len == 0</code> 。</li><li>map: <code>len(m) == 0</code> 会先判断 <code>m == nil</code> ，非nil则继续判断 <code>map.size == 0</code>,  <code>m == nil</code> 只会判断是否为空指针。 chan同理。</li></ul>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "Go 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052037"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48610965", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 0, 
            "title": "string和slice内部实现", 
            "content": "<h2>github的排版好一些</h2><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jingyugao/golang_runtime_reading/blob/gjy/sample/memory/mem.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jingyugao/golang_runtime_reading</a><h2>内存分配的上层接口</h2><h2>string 内部结构如下</h2><div class=\"highlight\"><pre><code class=\"language-text\">type stringStruct struct {\n\tstr unsafe.Pointer\n\tlen int\n}\n</code></pre></div><p>生成string的方法有三种:</p><ol><li>从一个literal string生成。</li><li>从一个[]byte转换。</li><li>从一个string用append转换</li><li>自己构造<code>strinStruct</code>，即cgo的做法（略）。</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">func f1() string {\n\tret := &#34;literial string&#34;\n\treturn ret\n}\nfunc f2() string {\n\tbs := []byte{&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39; &#39;, &#39;b&#39;, &#39;y&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;}\n\tret := string(bs)\n\treturn ret\n}\nfunc f3() string {\n\tvar ret string\n\tret = ret + &#34;from append&#34;\n\treturn ret\n}\n</code></pre></div><p>用命令行工具将其编译为汇编文件，查看内部具体转换。</p><div class=\"highlight\"><pre><code class=\"language-text\">go build -gcflags &#34;-S -l -N&#34; mem_slice.go 2&gt;mem_slice.S\n</code></pre></div><p>关键代码如下:</p><div class=\"highlight\"><pre><code class=\"language-text\">func f1() string {\n        ret := &#34;literial string&#34;\n        return ret\n    }\n\n    // 这里是data区域的字符串。\ngo.string.literial string&#34; SRODATA dupok size=15\n\t0x0000 6c 69 74 65 72 69 61 6c 20 73 74 72 69 6e 67     literial string\n\n    0x0016 00022 (mem_str.go:6)\tPCDATA\t$2, $1\n\t// 取字面值的地址,(字面值的数据在.data区域分配)\n\t0x0016 00022 (mem_str.go:6)\tLEAQ\tgo.string.&#34;literial string&#34;(SB), AX\n\t// 构造stringStruct\n\t// {\n\t//   \tstr=AX\n\t//\t\tlen=$15\n\t// }\n\t0x001d 00029 (mem_str.go:6)\tMOVQ\tAX, &#34;&#34;.ret(SP)\n\t0x0021 00033 (mem_str.go:6)\tMOVQ\t$15, &#34;&#34;.ret+8(SP)\n\t0x002a 00042 (mem_str.go:7)\tPCDATA\t$2, $0\n\t0x002a 00042 (mem_str.go:7)\tPCDATA\t$0, $1\n\t0x002a 00042 (mem_str.go:7)\tMOVQ\tAX, &#34;&#34;.~r0+32(SP)\n\t0x002f 00047 (mem_str.go:7)\tMOVQ\t$15, &#34;&#34;.~r0+40(SP)\n\t0x0038 00056 (mem_str.go:7)\tMOVQ\t16(SP), BP\n\t0x003d 00061 (mem_str.go:7)\tADDQ\t$24, SP\n\t0x0041 00065 (mem_str.go:7)\tRET\n\nfunc f2() string {\n\tbs := []byte{&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39; &#39;, &#39;b&#39;, &#39;y&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;}\n\tret := string(bs)\n\treturn ret\n}\n// 相关函数签名\nfunc slicebytetostring(buf *tmpBuf, b []byte) (str string) \n\n// 这里的几个字符也被编码为了字符串。位于data区域\n&#34;&#34;.statictmp_0 SRODATA size=10\n\t0x0000 73 6f 6d 65 20 62 79 74 65 73                    some bytes\n\n\t// tempbuf为nil。因为这个string要escape(传出函数),因此会在堆上分配一块内存\n\t// 如果不逃逸，则编译器会在栈上分配一段tempbuf。\n\t// 这里是go的小细节。\n\t// 同时也提示我们，[]byte转string时内存不共享。\n\t0x0070 00112 (mem_str.go:11)\tMOVQ\t$0, (SP)\n\t0x0078 00120 (mem_str.go:11)\tPCDATA\t$2, $1\n\t0x0078 00120 (mem_str.go:11)\tPCDATA\t$0, $0\n\t// 字面值的地址，这里只拷贝了一个地址。\n    // len和cap是编译常量，因此没有拷贝。\n\t0x0078 00120 (mem_str.go:11)\tMOVQ\t&#34;&#34;.bs+88(SP), AX\n\t0x007d 00125 (mem_str.go:11)\tPCDATA\t$2, $0\n\t// []byte如栈，AX为data*,10和10分别为len和cap,\n    // 小细节，这里的10编译时知道，因此直接写死了\n    // 一般情况下需要把sliceStruct的结构拷过来\n\t0x007d 00125 (mem_str.go:11)\tMOVQ\tAX, 8(SP)\n\t0x0082 00130 (mem_str.go:11)\tMOVQ\t$10, 16(SP)\n\t0x008b 00139 (mem_str.go:11)\tMOVQ\t$10, 24(SP)\n\t0x0094 00148 (mem_str.go:11)\tCALL\truntime.slicebytetostring(SB)\n\nfunc f3() string {\n\tvar ret string\n\tret = ret + &#34;from append&#34;\n\treturn ret\n}\n// 函数签名，buf如果不escape就是nil\n// 2的意思是两个字符串相加\n// 如果是str1+str2+str3的话会调用concatstring3\nfunc concatstring2(buf *tmpBuf, a [2]string) string {\n\treturn concatstrings(buf, a[:])\n}\n\n\n\t// 传参数，buf=nil,这里要escape。\n\t0x002d 00045 (mem_str.go:17)\tMOVQ\t$0, (SP)\n\t0x0035 00053 (mem_str.go:17)\tXORPS\tX0, X0\n\t// stringStruct{str=nil,len=0}\n\t0x0038 00056 (mem_str.go:17)\tMOVUPS\tX0, 8(SP)\n\t0x003d 00061 (mem_str.go:17)\tPCDATA\t$2, $1\n\t// stringStruct{str=AX,len=11}\n\t0x003d 00061 (mem_str.go:17)\tLEAQ\tgo.string.&#34;from append&#34;(SB), AX\n\t0x0044 00068 (mem_str.go:17)\tPCDATA\t$2, $0\n\t0x0044 00068 (mem_str.go:17)\tMOVQ\tAX, 24(SP)\n\t0x0049 00073 (mem_str.go:17)\tMOVQ\t$11, 32(SP)\n\t0x0052 00082 (mem_str.go:17)\tCALL\truntime.concatstring2(SB)\n</code></pre></div><h2>slice的分配细节</h2><p>slice结构如下</p><div class=\"highlight\"><pre><code class=\"language-text\">type slice struct {\n\tarray unsafe.Pointer\n\tlen   int\n\tcap   int\n}\n</code></pre></div><p>分配方式较多但总体来讲只有三种:</p><ol><li>编译器直接构造slice结构体</li><li>编译器调用growslice</li><li>编译器调用stringtoslice</li><li>调用makeslice</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">func f4() []byte {\n\tret := []byte{&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39; &#39;, &#39;b&#39;, &#39;y&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;}\n\treturn ret\n}\n\n\n\t// AX即指向 _type的指针，这里_type为[10]uint8\n    0x0032 00050 (mem_slice.go:4)\tLEAQ\ttype.[10]uint8(SB), AX\n\t0x0039 00057 (mem_slice.go:4)\tPCDATA\t$2, $0\n\t0x0039 00057 (mem_slice.go:4)\tMOVQ\tAX, (SP)\n\t// 构造数组[10]byte\n\t0x003d 00061 (mem_slice.go:4)\tCALL\truntime.newobject(SB)\n    // ...略去无关代码\n    // 构造slice { data *byte, len int, cap int}\n\t0x006a 00106 (mem_slice.go:4)\tMOVQ\tAX, &#34;&#34;.ret+24(SP)\n\t0x006f 00111 (mem_slice.go:4)\tMOVQ\t$10, &#34;&#34;.ret+32(SP)\n\t0x0078 00120 (mem_slice.go:4)\tMOVQ\t$10, &#34;&#34;.ret+40(SP)\n\nfunc f5() []byte {\n\ttmp := []byte{&#39;s&#39;, &#39;o&#39;, &#39;m&#39;, &#39;e&#39;, &#39; &#39;, &#39;b&#39;, &#39;y&#39;, &#39;t&#39;, &#39;e&#39;, &#39;s&#39;}\n\tret := tmp[1:9]\n\treturn ret\n}\n\n\t// 构造[10]数组,同上\n\t0x0032 00050 (mem_slice.go:9)\tLEAQ\ttype.[10]uint8(SB), AX\n\t0x0039 00057 (mem_slice.go:9)\tPCDATA\t$2, $0\n\t0x0039 00057 (mem_slice.go:9)\tMOVQ\tAX, (SP)\n\t0x003d 00061 (mem_slice.go:9)\tCALL\truntime.newobject(SB)\n    // ... 中间是给数组赋值的操作略去。\n    // 指针+1，即[1:9]的1\n\t0x0085 00133 (mem_slice.go:10)\tINCQ\tAX\n\t// 构造slice，这里len为8，cap为9，len即为[1:9]的9-1=8\n\t0x0088 00136 (mem_slice.go:10)\tMOVQ\tAX, &#34;&#34;.ret+48(SP)\n\t0x008d 00141 (mem_slice.go:10)\tMOVQ\t$8, &#34;&#34;.ret+56(SP)\n\t0x0096 00150 (mem_slice.go:10)\tMOVQ\t$9, &#34;&#34;.ret+64(SP)\n\nfunc f6() []byte {\n\tvar ret []byte\n\tret = append(ret, &#39;x&#39;)\n\treturn ret\n}\nfunc growslice(et *_type, old slice, cap int) slice \n\n\t// 构造空的slice，xorps使x0置为0，这里len=0，cap=0\n\t// movups 可以移动128位即两个int64,都是0\n\t0x0032 00050 (mem_slice.go:15)\tMOVQ\t$0, &#34;&#34;.ret+64(SP)\n\t0x003b 00059 (mem_slice.go:15)\tXORPS\tX0, X0\n\t0x003e 00062 (mem_slice.go:15)\tMOVUPS\tX0, &#34;&#34;.ret+72(SP)\n    // ... 略去无关代码 \n\t// AX为*_type,这个_type是byte类型信息\n\t0x0045 00069 (mem_slice.go:16)\tLEAQ\ttype.uint8(SB), AX\n\t0x004c 00076 (mem_slice.go:16)\tPCDATA\t$2, $0\n\t0x004c 00076 (mem_slice.go:16)\tMOVQ\tAX, (SP)\n\t// 传入空slice\n\t0x0050 00080 (mem_slice.go:16)\tXORPS\tX0, X0\n\t0x0053 00083 (mem_slice.go:16)\tMOVUPS\tX0, 8(SP)\n\t0x0058 00088 (mem_slice.go:16)\tMOVQ\t$0, 24(SP)\n\t// 传入cap，结果的长度是1，因此是1。\n\t0x0061 00097 (mem_slice.go:16)\tMOVQ\t$1, 32(SP)\n\nfunc f7() []byte {\n\tret := make([]byte, 10)\n\treturn ret\n\nfunc makeslice(et *_type, len, cap int) slice \n\n\t0x002e 00046 (mem_slice.go:21)\tLEAQ\ttype.uint8(SB), AX\n\t0x0035 00053 (mem_slice.go:21)\tPCDATA\t$2, $0\n\t// 传入*_type,len,cap 调用makeslice\n\t0x0035 00053 (mem_slice.go:21)\tMOVQ\tAX, (SP)\n\t0x0039 00057 (mem_slice.go:21)\tMOVQ\t$10, 8(SP)\n\t0x0042 00066 (mem_slice.go:21)\tMOVQ\t$10, 16(SP)\n\t0x004b 00075 (mem_slice.go:21)\tCALL\truntime.makeslice(SB)\n\nfunc f8() []byte {\n\tret := []byte(&#34;literal string&#34;)\n\treturn ret\n}\nfunc stringtoslicbyte(buf *tmpBuf, s string) []byte \n\n\t// tmpbuf=nil\n\t0x002e 00046 (mem_slice.go:26)\tMOVQ\t$0, (SP)\n\t0x0036 00054 (mem_slice.go:26)\tPCDATA\t$2, $1\n\t// 字面值字符串的地址\n\t0x0036 00054 (mem_slice.go:26)\tLEAQ\tgo.string.&#34;literal string&#34;(SB), AX\n\t0x003d 00061 (mem_slice.go:26)\tPCDATA\t$2, $0\n\t// 传入string{data *byte,len int}\n\t0x003d 00061 (mem_slice.go:26)\tMOVQ\tAX, 8(SP)\n\t0x0042 00066 (mem_slice.go:26)\tMOVQ\t$14, 16(SP)\n\t// 调用stringtoslicebyte\n\t0x004b 00075 (mem_slice.go:26)\tCALL\truntime.stringtoslicebyte(SB)\n\nfunc f9() []byte {\n\tarray := [10]byte{&#39;a&#39;, &#39;r&#39;, &#39;r&#39;, &#39;a&#39;, &#39;y&#39;}\n\treturn array[1:5]\n}\n\n    // 这个跟f4一样，看来go会把这两个都当作数组处理了。  \n    // 即[]byte声明的时候是数组\n    // 可以隐式转换为slice  \n\t0x0032 00050 (mem_slice.go:31)\tLEAQ\ttype.[10]uint8(SB), AX\n\t0x0039 00057 (mem_slice.go:31)\tPCDATA\t$2, $0\n\t0x0039 00057 (mem_slice.go:31)\tMOVQ\tAX, (SP)\n\t// 构造一个array\n\t0x003d 00061 (mem_slice.go:31)\tCALL\truntime.newobject(SB)\n    // ... 无关代码略去\n    // AX+1 即 [1:5]的1\n\t0x006c 00108 (mem_slice.go:32)\tINCQ\tAX\n\t0x006f 00111 (mem_slice.go:32)\tMOVQ\tAX, &#34;&#34;..autotmp_3+24(SP)\n\t// 4即5-1，9为10-1\n\t0x0074 00116 (mem_slice.go:32)\tMOVQ\t$4, &#34;&#34;..autotmp_3+32(SP)\n\t0x007d 00125 (mem_slice.go:32)\tMOVQ\t$9, &#34;&#34;..autotmp_3+40(SP) </code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "Go 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052037"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48528980", 
            "userName": "月明星稀", 
            "userLink": "https://www.zhihu.com/people/c040b7238a9c452a1d879070229db8ca", 
            "upvote": 12, 
            "title": "golang runtime HACKING.md翻译", 
            "content": "<p></p><hr/><p>最近阅读了一下golang的runtime，其中一个文档干货很多，于是简要翻译了一下。</p><p>github的排版比较好看一些。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jingyugao/golang_runtime_reading/blob/gjy/src/runtime/HACKING_zh.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jingyugao/golang_runtime_reading</a></p><p>以下是翻译</p><p>-------------------------------------------------</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这是一个简要的文档，以后可能会过时。 它意在说清楚go runtime和普通代码编写的不同。 它注重普适的概念而不是某个接口的细节</p><h2>调度结构</h2><p>调度器管理着遍布runtime的三种类型的资源:Gs,Ms 和Ps。 即使你不是从事调度器开发也应该理解这些结构。</p><h2>Gs, Ms, Ps</h2><p>一个G就是简单的goroutine。它由类型 <code>g</code> 代表。 当一个goroutine存在时，他的 <code>g</code> 归还到空闲 <code>g</code> 池中 并且可以在稍后被其他goroutine复用 (这里应该是写错了吧。应该是g消亡以后，可以被复用，即 <code>g</code> 池</p><p>一个 &#34;M&#34; 是可以执行用户代码，runtime代码的系统线程 它由类型 <code>m</code> 表示 由于可能存在任意数量的线程陷于系统调用， 因此同一时刻可能会存在任意数量的Ms</p><p>最后，一个 &#34;P&#34; 代表了用于执行用户代码的资源，如调度器和内存分配的状态。 它由类型 <code>p</code> 表示。P的数量是 <code>GOMAXPROCS</code> ，这个数字是确定不变的。 一个P可以被认为像os调度器的cpu，p的状态类似于每个cpu的状态。 这是一个存放共享状态的好地方。（那些非per-thread和per-gouroutine的状态）</p><p>调度器的工作是使G(要执行的代码)，M(在哪里执行),和P(执行的权利和资源)相协调。 当一个M在执行用户代码的时候停止了，比如进入系统调用， 他返回持有的P给闲置的P池 为了重新开始执行晕乎代码，例如从系统调用返回， 它(M)必须从空闲的P池中获取一个P</p><p>所有的 <code>g</code>, <code>m</code>, 和 <code>p</code> 对象都是在堆中分配的，但是永远不会被释放， 印次他们的内存保持稳定。 因此，runtime可以避免在在调度中的写屏障</p><h2>用户栈和系统栈</h2><p>每个非死亡的G有一个相连的 <i>用户栈</i> ，即用户代码在何处执行。 用户栈刚开始很小(比如,2k) 可以动态增长或下降。</p><p>每个M有一个相关的 <i>系统栈</i> (即M的g0的栈)，以及一个 <i>信号栈</i> (即gsingal). 系统栈和信号栈不能增长，但是足够执行runtime的代码以及cgo代码 (在纯go二进制文件中是8k,在cgo中是系统分配)</p><p>Runtime代码通过 <code>systemstack</code>, <code>mcall</code>, 或者 <code>asmcgocall</code> 切换到系统栈 来执行不能被抢占的任务，不能扩张用户栈的代码，或者要切换用户goroutine的代码 运行在系统栈上的代码暗含了非抢占的意思且gc不会扫描系统栈。 当在系统栈运行时，当前的用户栈不能用于执行(代码)。</p><h2><code>getg()</code> 和 <code>getg().m.curg</code></h2><p>为了得到当前的用户 <code>g</code> ，使用 <code>getg().m.curg</code> 。</p><p><code>getg()</code> 返回当前的 <code>g</code> ，但是在系统栈或信号栈上运行时， 会返回当前M的g0(或gsignal)的栈。这可能不是你想要的。</p><p>位了判断你是在用户栈还是在系统栈上 使用 <code>getg() == getg().m.curg</code> .</p><h2>错误处理和报告</h2><p>同常用户代码中的可以合理revover的错误应该使用 <code>panic</code> 。 然而，有些情况 <code>panic</code> 会立即导致致命错误，例如在系统栈上调用， 或者在 <code>mallocgc</code> 的期间调用</p><p>runtime的大多数错误都是不能recover的。对于这些，使用 <code>throw</code> ， 它会储存调用栈回溯并立即结束进程。 通常，<code>thorw</code>应该传入一个字符串常量防止在危险的情况下下进行内存分配。 按照惯例，格外的细节应该在 <code>throw</code> 前用 <code>print</code> 或 <code>println</code> 打印 这些信息会被加上&#34;runtime&#34; 前缀</p><p>对于runtime错误调试，可以添加 <code>GOTRACEBACK=system</code> 或 <code>GOTRACEBACK=crash</code>。</p><h2>同步</h2><p>runtime有多个同步机制。他们有不同的语意， 尤其是，他们与goroutine调度器和系统调度器相互影响。</p><p>最简单的是 <code>mutex</code>，通过 <code>lock</code> 和 <code>unlock</code> 操作。 它可以在短时间内保护共享结构。 在 <code>mutex</code> 上阻塞会直接阻塞对应的M， 而不和调度器相互作用。(不需要调度器参与) 这意味着它可以用于runtime的底层代码， 但是也阻止了相关的G和P被重新调度 <code>rwmutex</code> 也是类似</p><p>对于单次通知，使用 <code>note</code> ，它提供了 <code>notesleep</code> 和 <code>notewakeup</code> 。 不像传统的unix <code>sleep</code>/<code>wakeup</code>, <code>note</code> 是race-free的， 因此如果<code>notewakeup</code> 已经发生了， <code>notesleep</code> 会立刻返回。 一个 <code>note</code> 可以使用 <code>noteclear</code> 重制， 但是绝对不能和sleep或wakeup存在竞争。 当一个 <code>note</code> 阻塞了M，表现的和 <code>mutex</code> 类似。 然而，有多种方式可以在 <code>note</code> 上sleep: <code>notesleep</code> 也可以阻止相关的G和P重新调度， 而 <code>notesleepg</code> 表现的像一个阻塞系统调用，允许P被复用来跑其他的G。 这不如直接阻塞G效率高因为这消费了一个M</p><p>为了直接与调度器交互，使用 <code>gopark</code> 和 <code>goready</code> 。 <code>gopark</code> 把当前的goroutine置为 &#34;waiting&#34; 状态 并把它从调度器的运行队列中移除， 并调度另一个在当前M/P上的G。</p><p><code>goready</code> 把一个被寄存的goroutine置为&#34;runnable&#34;状态 并把其放入运行队列中去。</p><p>简要概括</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7a82497cc8a96cc29cd09be4b6037727_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic4.zhimg.com/v2-7a82497cc8a96cc29cd09be4b6037727_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;374&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic4.zhimg.com/v2-7a82497cc8a96cc29cd09be4b6037727_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7a82497cc8a96cc29cd09be4b6037727_b.jpg\"/></figure><h2>非托管内存</h2><p>一般来说，runtime尝试使用普通的堆分配的内存。 然而，有些时候runtime必须使用不在gc堆上的内存，(即 <i>unmanaged memeory</i>) 如果对象是内存管理系统本身的一部分或者在某些调用者不含P的情况下分配的。 (即这部分内存不受gc控制，是更底层的接口，直接用mmap分配的)</p><p>分配非托管内存有三种方式</p><ul><li>sysAlloc 直接从OS获取内存。可以获取任何系统页大小(4k)整数倍的内存， 也可以被sysFree释放</li><li>persistentalloc 吧多个小内存组合为单次sysAlloc防止内存碎片。 然而，没有办法释放其分配的内存。</li><li>fixalloc 是slab风格的分配器，用于分配固定大小的对象。 fixalloc分配的对象可以被释放，但是这个内存可能会被fixalloc pool复用， 因此它只能给相同类型的对象复用。</li></ul><p>一般来说，任何通过上面这些分配的类型都应该标记为<code>//go:notinheap</code></p><p>非托管内存分配的对象 <i>禁止</i> 含有堆指针，除非一下满足以下条件:</p><ol><li>非托管内存的人和指针都必须明确地加入到gc的根对象(<code>runtime.markroot</code>)。</li><li>如果内存复用，堆指针必须在被gc根可见之前0初始化。 否则，gc会看到陈旧的堆指针。 参考 &#34;Zero-initialization versus zeroing&#34;</li></ol><h2>Zero-initialization versus zeroing</h2><p>runtime中有两种置零方式，取决于内存是否已经初始化为类型安全的状态</p><p>如果内存不是类型安全的状态，意味着它可能含有垃圾， 因为它是刚刚分配的且初始化以供首次使用， 这样它必须使用 <code>memclrNoHeapPointers</code> 或非指针的写来零初始化 这不需要写屏障。 (什么是非指针写 &#34;non-pointer write&#34; ??? 类型安全是什么意思，&#34;type-safe&#34; ???</p><p>如果内存已经处于类型安全状态且简单的设置为0，这必须使用&#34;regular write&#34; 即 <code>typedmemclr</code> ,或 <code>memclrHasPointers</code>。这需要写屏障。</p><h2>runtime-only 编译准则</h2><p>除了&#34;go doc compile&#34; 中的&#34;//go:&#34;准则之外， 还有一些只能用于runtime的编译准则。</p><h2>go:systemstack</h2><p><code>go:systemstack</code> 暗示一个函数必须在系统栈运行。 它会由一个特殊函数序言动态检查。 (函数序言即在汇编中，函数开始的那几行代码， 用来调节栈，寄存器之类的。参考wiki)</p><h2>go:nowritebarrier</h2><p><code>go:nowritebarrier</code> 指示编译器如果发现在下面的函数中包含写屏障， 产生一个错误。 (这不能阻止写屏障的产生，这只是个断言)</p><p>通常你需要 <code>go:nowritebarruerrec</code>。 <code>go:nowritebarrier</code>主要用于最好不要有写屏障的情形， 但是不需要严格保证。 (类似于warning，还是可以运行的)</p><h2>go:nowritebarrierrec and go:yeswritebarrierrec</h2><p><code>go:nowritebarrierrec</code> 指示编译器遇到写屏障时产生一个错误， 只不过是递归的，即这个函数调用的其他函数如果有写屏障也会报错。 <code>go:yeswritebarrierrec</code> 意思差不多，包含一个写屏障。</p><p>逻辑上说，编译器从每个 <code>go:nowritebarrierrec</code> 标记的函数开始搜索调用图 如果遇到一个函数包含写屏障就会产生一个错误。 遇到 <code>go:yeswritebarrierrec</code> 标记的函数时也会停止。</p><p><code>go:nowritebarrierrec</code> 用于写屏障的实现防止死循环。</p><p>这两个都则都用于调度器。开启写屏障需要一个活跃的P(<code>getg().m.p !=nil</code> ) 且调度器代码运行的时候经常没有活跃的P。 这种情况下，<code>go:nowritebarrierrec</code> 经常用于刚释放了P或者没有P的函数。 <code>go:yeswritebarrierrec</code> 用于代码重新获取了一个活跃的P。</p><p>因为他们是函数级别的注视，释放或获取P的代码可能需要分割为两个。</p><h2>go:notinheap</h2><p><code>go:notinheap</code> 用于类型声明。它暗示了一个类型不能从gc的堆上分配。 特别地，指向这个类型的指针在 <code>runtime.inheap</code> 检查时必须失败。 类型必须用于全局变量，栈变量或者非托管内存。 特别地:</p><ol><li><code>new(T)</code>, <code>make([]Y)</code>, <code>append([]T, ...)</code> 和隐式的堆分配是不允许的。 (虽然隐式分配无论如何在runtime中是不允许的)</li><li>指向普通类型的指针(不是 <code>unsafe.Pointer</code>) 不能被转化为一个指向 <code>go:notinheap</code> 标记的类型，即使他们有相同的基类。</li><li>任何包含 <code>go:notinheap</code> 的类型都是 <code>go:notinheap</code> 的。 结构体和数组是这样。<code>go:notinheap</code> 的map和channel不允许的。 为了明确起见，任何实现了 <code>go:notinheap</code> 的类型必须标记为 <code>go:notinheap</code></li><li>对于一个指向 <code>go:notinheap</code> 的类型的指针，写屏障可以忽略。</li></ol><p>最后一点是 <code>go:notinheap</code> 的好处。 runtime用它做低层次的内部结构，避免调度器和内存分配中的内存屏障， (内存屏障会引起性能问题甚至是非法的) 这个机制是相当的安全而且不会降低runtime的可读性。</p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "Go 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052037"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1042778687384576000"
}
