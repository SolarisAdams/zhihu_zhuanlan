{
    "title": "区块链基础教程", 
    "description": "不管改变世界还是改变师姐了", 
    "followers": [
        "https://www.zhihu.com/people/tian-qi-46-58", 
        "https://www.zhihu.com/people/mo-ran-hui-tou-29", 
        "https://www.zhihu.com/people/learning-boy", 
        "https://www.zhihu.com/people/wang-jin-14", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/leng-yan-guan-chao-38-44", 
        "https://www.zhihu.com/people/victor-52-15-23", 
        "https://www.zhihu.com/people/he-xu-89-18", 
        "https://www.zhihu.com/people/fang-li-25", 
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/nuotu-yu", 
        "https://www.zhihu.com/people/rengongzz", 
        "https://www.zhihu.com/people/tony.tsui", 
        "https://www.zhihu.com/people/hyde58", 
        "https://www.zhihu.com/people/shanpengfei7", 
        "https://www.zhihu.com/people/wang-qi-75", 
        "https://www.zhihu.com/people/jun-lei-15", 
        "https://www.zhihu.com/people/geng-dong-96", 
        "https://www.zhihu.com/people/yu-shan-lun-jin-27", 
        "https://www.zhihu.com/people/amazing_cat", 
        "https://www.zhihu.com/people/ltye", 
        "https://www.zhihu.com/people/long-long-pi-long-long", 
        "https://www.zhihu.com/people/wang-cheng-68-3", 
        "https://www.zhihu.com/people/luo-yifan-24-48", 
        "https://www.zhihu.com/people/programmer_song", 
        "https://www.zhihu.com/people/fang-ya-qi", 
        "https://www.zhihu.com/people/yu-di-di-51", 
        "https://www.zhihu.com/people/james-7-63", 
        "https://www.zhihu.com/people/lemonsen", 
        "https://www.zhihu.com/people/lao-wang-37", 
        "https://www.zhihu.com/people/xuwl", 
        "https://www.zhihu.com/people/1221-55", 
        "https://www.zhihu.com/people/qi-ya-tou-47", 
        "https://www.zhihu.com/people/chan-chan-36-35", 
        "https://www.zhihu.com/people/liang-yan-42-54", 
        "https://www.zhihu.com/people/chen-yong-73", 
        "https://www.zhihu.com/people/wgfxcu-88", 
        "https://www.zhihu.com/people/robin-97-3-11", 
        "https://www.zhihu.com/people/aaron_lu", 
        "https://www.zhihu.com/people/vtan-89", 
        "https://www.zhihu.com/people/zheng-zhong-wei", 
        "https://www.zhihu.com/people/onlinemanual", 
        "https://www.zhihu.com/people/zhang-wen-yuan-68-19", 
        "https://www.zhihu.com/people/kingsley-50-39", 
        "https://www.zhihu.com/people/duan-fang-liang", 
        "https://www.zhihu.com/people/jia-jie-37", 
        "https://www.zhihu.com/people/freedom_life", 
        "https://www.zhihu.com/people/lidinglin3452", 
        "https://www.zhihu.com/people/wei-peng-1-59", 
        "https://www.zhihu.com/people/ba-si-dong-gua-51", 
        "https://www.zhihu.com/people/nan-gong-deng", 
        "https://www.zhihu.com/people/xie-jia-yu-64-21", 
        "https://www.zhihu.com/people/li-he-he-32-61", 
        "https://www.zhihu.com/people/czyt", 
        "https://www.zhihu.com/people/e-e-11-35", 
        "https://www.zhihu.com/people/jieyouzahuodian", 
        "https://www.zhihu.com/people/hui-lang-31", 
        "https://www.zhihu.com/people/scrat000", 
        "https://www.zhihu.com/people/kang-kang-82-78-48", 
        "https://www.zhihu.com/people/yishang-tan-huan-46", 
        "https://www.zhihu.com/people/tong-jian-lin", 
        "https://www.zhihu.com/people/andyyin-50", 
        "https://www.zhihu.com/people/johnnyeven", 
        "https://www.zhihu.com/people/lifeng-54-51", 
        "https://www.zhihu.com/people/zi-jingong-guan", 
        "https://www.zhihu.com/people/chen-xin-36-2-33", 
        "https://www.zhihu.com/people/chl-jia", 
        "https://www.zhihu.com/people/zhang-xian-sheng-76-6", 
        "https://www.zhihu.com/people/nike-56-77", 
        "https://www.zhihu.com/people/coffeebean-64", 
        "https://www.zhihu.com/people/guo-dan-75-39", 
        "https://www.zhihu.com/people/frankCloudLi", 
        "https://www.zhihu.com/people/hiking-24"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/57911920", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 0, 
            "title": "grin（Mimblewimble）转账交易流程深入分析", 
            "content": "<p><a href=\"https://link.zhihu.com/?target=https%3A//grin-tech.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Grin</a> is an exciting new cryptocurrency leveraging the MimbleWimble protocol. But tutorials on Grin are notoriously nondescript.</p><p>这篇文章旨在确切的分享<code>grin</code>的交易过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0344bd5c208773ee7be374d2a60622a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"1221\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-0344bd5c208773ee7be374d2a60622a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;1221&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"1221\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-0344bd5c208773ee7be374d2a60622a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0344bd5c208773ee7be374d2a60622a9_b.jpg\"/></figure><p>在<code>grin</code>中，一个输出就是一个<code>Pedersen Commitment</code>,任何输出都呈现下面的形式：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-deb2d8673322263cb8a80046dc22c5f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-deb2d8673322263cb8a80046dc22c5f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-deb2d8673322263cb8a80046dc22c5f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-deb2d8673322263cb8a80046dc22c5f9_b.jpg\"/></figure><p><br/>A Grin output, which is a Pedersen Commitment.</p><p class=\"ztext-empty-paragraph\"><br/></p><p><code>Pedersen Commitment(Pedersen 承诺)</code>用一种和聪明的方式隐藏了信息。如果你是刚听说<code>commitments（承诺）</code>， 那看到它把它理解成<code>shielded value(屏蔽值)</code>就可以了。</p><p>下面的内容来<a href=\"https://link.zhihu.com/?target=https%3A//github.com/mimblewimble/grin/blob/master/doc/intro.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Grin wiki</a>，对理解这篇文章来说是很好的入门。</p><blockquote>• 如果选择一个很大的数<code>k</code>作为私钥，<code>k*H</code>就是对应的公钥。即使一个人知道公钥<code>k*H</code>值，想推导出<code>k</code>几乎不可能<br/>• <code>r</code>是被用作致盲因子的私钥，<code>G</code>是椭圆曲线上的固定点，它们的乘积<code>r*G</code>是<code>r</code>在曲线上的公钥。<br/>• <code>v</code> 是输入或输出的金额，<code>H</code>是椭圆曲线上的另一个固定点。<br/><code>(k+j)*H = k*H + j*H</code>，<code>k</code>和<code>j</code>都是私钥。等式表明从两个私钥的和获取公钥<code>（k + j）* H</code>，等价于每个私钥的对应公钥的和 <code>（k * H + j * H）</code></blockquote><p>更深入的密码学研究可以在这里<a href=\"https://link.zhihu.com/?target=https%3A//andrea.corbellini.name/2015/05/17/elliptic-curve-cryptography-a-gentle-introduction/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ECC primer</a>找到。但简而言之，要花费Grin的输出，你必须知道致盲因子（r）和Grin（v）的数量。要解构承诺来推断这些值是不可能的。你必须提前知道它们。</p><p>致盲因素的存在是因为有人支付给你这些grin，他也会知道<code>v</code>的值（他给你发送了多少grin）。但只有你（甚至都不是Grin的发送者）将会知道这个输出的致盲因子，因此只有你能够花掉这个输出。</p><p>假设此输出使用致盲因子20，此输出包含40 Grin。（注意： Grin的数量实际上是以原子单位<code>1 NanoGrin</code>的倍数发送的。在这里直接使用<code>grin</code>简化了）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c45fd6084383a700e8e36561d75dd2ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"794\" data-original=\"https://pic3.zhimg.com/v2-c45fd6084383a700e8e36561d75dd2ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;794&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"794\" data-original=\"https://pic3.zhimg.com/v2-c45fd6084383a700e8e36561d75dd2ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c45fd6084383a700e8e36561d75dd2ee_b.jpg\"/></figure><p><br/>In this output, the blinding factor is 20, and the amount of Grin is 40.</p><p>如果我们看<a href=\"https://link.zhihu.com/?target=https%3A//grinexplorer.net/block/00000317907f10bc6dd3101574d2d4412839602381ed4c5365aafe3f2771fd94\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Grin 区块链浏览器</a>，输出不会像上面那样优雅的分解。就像我们所说的，这才是Grin真正输出的样子，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b60900e2ddd48cbb61f07d293df0b24f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"107\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-b60900e2ddd48cbb61f07d293df0b24f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;107&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"107\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-b60900e2ddd48cbb61f07d293df0b24f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b60900e2ddd48cbb61f07d293df0b24f_b.jpg\"/></figure><p><br/>What a Grin output looks like (under the Commit column).</p><p>再重复一次，从这个输出中推导出<code>20(致盲因子)</code>或者<code>40(grin 数量)</code>是不可能的。</p><h2>花费输出</h2><p>假设刚才展示的输出属于Alice。现在，Alice希望将40个Grin中的25个发送给Bob。为简单起见，我们会忽略挖矿费。</p><p>假如您有5美元，购买3美元的东西，您将获得2美元的找零。比特币交易是这样的，Grin也不例外。如果Alice想要从她40个未花费的Grin输出中向Bob发送25个Grin，她也会在同一笔交易中创建一个输出，把剩余的15个 Grin（她的零钱）返还自己。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f37c41b2225701c414534685697c3ed7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"751\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-f37c41b2225701c414534685697c3ed7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;751&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"751\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-f37c41b2225701c414534685697c3ed7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f37c41b2225701c414534685697c3ed7_b.jpg\"/></figure><p><br/>Alice identifies how much Grin she wants to send to Bob, and also her change.</p><p>这15个Grin将会返还Alice，这意味着只有她能够控制它并再次花费它。换句话说，Bob不应该花费Alice的找零。为此，Alice必须为她的找零输出创建一个新的致盲因子。假设Alice选择34。</p><p>Alice知道<code>r</code>（为她找零输出的致盲因子）和 <code>v</code>（她找零的grin的数量），她拥有创建找零输出（<code>co</code>）所需的一切。这将作为一个输出记录在区块链上，就像Alice创建的将25个Grin发送给Bob的输出一样。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bfa460919c74e785bbf04102fe00b65f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-bfa460919c74e785bbf04102fe00b65f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;168&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"168\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-bfa460919c74e785bbf04102fe00b65f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bfa460919c74e785bbf04102fe00b65f_b.jpg\"/></figure><p><br/>Alice’s change output.</p><p>正如我之前提到的，要花费任何输出，您必须知道该输出中使用的致盲因子。Alice知道她想要花费的输出中所使用的致盲因素（20），但她需要一种方法向所有人证明她知道。</p><p>这就是为什么她需要创建一个完全独立的计算，就是<i>致盲因子的和</i>。这涉及到Alice刚才为她的找零输出采用的致盲因子（34），并从中减去她想要花费的输出的致盲因子（20）。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-63c17b8cc2c790c6b54f49c642391007_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"773\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-63c17b8cc2c790c6b54f49c642391007_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;773&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"773\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-63c17b8cc2c790c6b54f49c642391007_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-63c17b8cc2c790c6b54f49c642391007_b.jpg\"/></figure><p><br/>Alice’s sum of her blinding factors.</p><p class=\"ztext-empty-paragraph\"><br/></p><p><code>rs</code>（s表示发送者，现在是Alice）是Alice所有致盲因子的总和，现在的情况下它是14。（Note: I am intentionally leaving out kernel offsets）。</p><p>Alice做的就是创建一个随机的nonce <code>ks</code>（再次说明，s表示发送者）。她将使用这个随机的nonce来帮助她对这笔交易签名，我们稍后将会展示。Alice不会将实际的nonce发送给Bob。相反，她发送<code>ks•G</code>，这是对该nonce 的承诺。如前所述，通过将nonce乘以生成点<code>G</code>，Alice屏蔽了她实际的nonce值。</p><p>Alice将以下信息发送给Bob。实际上，Grin数据不会区分“Metadata”和“Data”字段，这里只是为了清楚的显示。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-56a11b4af95509a96b83607b2f657f61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-56a11b4af95509a96b83607b2f657f61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-56a11b4af95509a96b83607b2f657f61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-56a11b4af95509a96b83607b2f657f61_b.jpg\"/></figure><p><br/>Everything Alice sends Bob in the first step of this Grin transaction.</p><p><b>Metadata</b>中的数据：</p><ul><li><b>Amount to send:</b> Alice想要发送给Bob的grin数量（现在是25）。</li><li><b>TX UUID:</b> Alice和Bob用于在来回发送数据时，标识此交易的唯一标识符。</li><li><b>TX fee:</b> 交易费（这篇文章先不讨论）。</li><li><b>lock_height:</b> 区块数，在此之后交易将有效。</li></ul><p><b>Data</b>中的数据</p><ul><li><b>TX Inputs</b>: Alice为她给Bob的交易的使用的未花费输入。</li><li><b>co</b>: Alice的找零输出</li><li><b>ks • G</b>: Alice的nonce变成对应的承诺通过乘以生成点<code>G</code>.</li><li><b>rs • G</b>*: Alice致盲因子的和对应的承诺通过乘以生成点<code>G</code>.</li></ul><p>Alice将所有这些发送给Bob，Bob继续下一步。</p><h2>Bob的回合</h2><p>一旦从Alice接收到该数据后，Bob将<b>TX fee</b>和<b>lock_height</b>连接起来以创建<b>M</b>，称为交易的“Message”。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f2cf6aa8912ce885949074e046ab4190_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"512\" data-rawheight=\"116\" class=\"origin_image zh-lightbox-thumb\" width=\"512\" data-original=\"https://pic1.zhimg.com/v2-f2cf6aa8912ce885949074e046ab4190_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;512&#39; height=&#39;116&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"512\" data-rawheight=\"116\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"512\" data-original=\"https://pic1.zhimg.com/v2-f2cf6aa8912ce885949074e046ab4190_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f2cf6aa8912ce885949074e046ab4190_b.jpg\"/></figure><p><br/>The “message” of the transaction.</p><p>Bob为他希望从Alice哪里收到的25个grin选择一个致盲因子<b>rr</b>（r表示接受者，在这里是Bob）。假设他选择 <b>11</b>。他还选择了他自己的随机的nonce <b>kr</b>（r表示接受者）。</p><p>就像Alice一样，Bob通过将每个值乘以生成点<b>G</b>来创建对这两个值的<i>承诺</i>。使用这些值，Bob 为此交易生成 <b>Schnorr challenge</b>，由变量<b><code>e</code></b>表示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-145b175af2eb16679cd1609cf03bed24_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-145b175af2eb16679cd1609cf03bed24_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-145b175af2eb16679cd1609cf03bed24_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-145b175af2eb16679cd1609cf03bed24_b.jpg\"/></figure><p><br/>The Schnorr challenge for the transaction.</p><p><b>Schnorr challenge</b>由以下值的 <b>SHA256 hash</b>组成：</p><ul><li>交易的message。</li><li>Alice和Bob使用的nonce对应承诺的和。</li><li>Bob的致盲因子（为他25个grin的输出）对应的承诺 + Alice致盲因子和对应的承诺。</li></ul><p>Bob使用<b>e</b>为此交易生成他的<b>Schnorr signature</b> ，简称<b>sr</b>（r为收件人）。虽然它是Bob签名的全部，但我们称之为<b>Bob方签名</b>，因为它最终将被添加到<b>Alice方签名</b>中来创建整个交易的签名。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_b.jpg\"/></figure><p><br/>The Schnorr challenge for the transaction.</p><p>当Alice最终收到<b>sr</b>时，她将无法从中推断出<b>kr</b>或<b>rr</b>的值。</p><h2>Bob将以下内容发送回Alice</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0c803546b2f58306b8ff7f58242f2a11_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"754\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"754\" data-original=\"https://pic2.zhimg.com/v2-0c803546b2f58306b8ff7f58242f2a11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;754&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"754\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"754\" data-original=\"https://pic2.zhimg.com/v2-0c803546b2f58306b8ff7f58242f2a11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0c803546b2f58306b8ff7f58242f2a11_b.jpg\"/></figure><p><br/>Bob sends his partial signature, commitment to his nonce, and commitment to his blinding factor for his output back to Alice.</p><p>包括：</p><ul><li><b>sr:</b> Bob方的签名</li><li><b>kr • G：</b> Bob的nonce对应的承诺</li><li><b>rr • G：</b> Bob为他期望收到的25个grin选择的致盲因子对应的承诺。</li></ul><h2>最后一步：返回给Alice</h2><p>Alice现在有所需的一切，她也需要计算<b>e</b>（这笔交易的Schnorr challenge）。在本地计算e之后，Alice就可以<b>验证Bob方的签名</b>。<br/>回顾一下Bob方的签名<b>sr</b>,由一下组成：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-05b5d5412ce312009b71d94857ce7723_b.jpg\"/></figure><p><br/>Bob’s partial signature for this transaction.</p><p>基于我们前面描述的椭圆曲线的性质，Alice可以将生成点<b>G</b> 引入等式的两边，等式任然成立。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-448944d316cbbcbd273a6c30b28bfc41_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-448944d316cbbcbd273a6c30b28bfc41_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-448944d316cbbcbd273a6c30b28bfc41_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-448944d316cbbcbd273a6c30b28bfc41_b.jpg\"/></figure><p><br/>Alice multiples each side of the equation by generator point G.</p><p>由于Alice收到了Bob的<b>kr • G</b>（Bob的nonce对应的承诺）和<b>rr•G</b>（Bob为他期望收到的25个Grin选择的致盲因子对应的承诺），并且因为她已经在本地计算了<b>e</b>，所以Alice验证Bob方签名<b>sr</b>，通过简单地将它乘以生成器<b>G</b>并确保等式的右边等于该值。<br/>通过这样做，Alice证明：</p><ol><li>Bob知道他将收到多少grin</li><li>Bob知道他的nonce</li><li>Bob知道他期望收到的25grin的致盲因子</li></ol><p>Alice并不知道Bob的nonce和他选择的致盲因子。</p><p>然后Alice生成自己方的签名：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-602a6432c1fae51dda87489ac2d72c40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"84\" class=\"content_image\" width=\"398\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;398&#39; height=&#39;84&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"84\" class=\"content_image lazy\" width=\"398\" data-actualsrc=\"https://pic1.zhimg.com/v2-602a6432c1fae51dda87489ac2d72c40_b.jpg\"/></figure><p><br/>Alice generates her partial signature for the transaction.</p><p>Alice现在可以生成整个交易的签名，该签名包括她和Bob的签名：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0fb265d06c37819996d56947ed86429f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-0fb265d06c37819996d56947ed86429f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;88&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"88\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-0fb265d06c37819996d56947ed86429f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0fb265d06c37819996d56947ed86429f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>签名</b>包括</p><ul><li>Alice和Bob方签名的和</li><li>Alice和Bob的nonces对应的承诺（他们都不知道对方真正的nonce）</li></ul><p>再简明一点，它可以是这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6aec96e50e3d087f5a74b5eab24002b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"78\" class=\"content_image\" width=\"332\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;332&#39; height=&#39;78&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"78\" class=\"content_image lazy\" width=\"332\" data-actualsrc=\"https://pic2.zhimg.com/v2-6aec96e50e3d087f5a74b5eab24002b1_b.jpg\"/></figure><p><br/>The signature for the transaction.</p><p>其中 <code>s = ss + sr</code> ，<code>k = ks + kr</code>.</p><p>记住这个签名，它马上会很有意义。</p><h2>完成交易</h2><p>数字货币需要一个&#34;memory&#34; , 也就是说，当你向一个人转账后，你不能将同样的钱再发给别人。在Grin中，我们隐藏了发送的Grin数和接受者。那么我们怎么能证明没有钱被双花或者凭空产生呢？</p><p>在Grin交易中，当您从输入中减去所有输出时，剩余的Grin数应该等于0。回到刚才的5美元的比喻，有下面的公式：</p><blockquote>3 dollars to cashier (output) + 2 dollars in change back to me (output) - 5 dollar bill (input) = 0</blockquote><p>在Grin中，当交易合法时，相同的求和使<b>v</b>值总和为零。但是，我们如何在不知道<b>value</b>的情况下证明这一点？让我们看一下从Alice到Bob的交易中使用的输入和输出：</p><blockquote>（34•G）+（15•H）+（11•G）+（25•H） - （20•G） - （40•H）=（25•G）+（0•H）</blockquote><p>这里比较巧妙的属性是，当Grin金额抵消时（因为没有钱是凭空创造的），从输入中减去输出所剩下的全部是“<b>the excess blinding factor</b>” 的承诺，或者“<b>kernel excess</b>”。这个“<b>the excess blinding factor</b>”的承诺，现在是<b>25•G</b>，就是椭圆曲线上的公钥。</p><p>如果Grin交易的输出总和减去输入的总和会在曲线上产生有效的公钥，你便知道<b>v</b>值肯定已经抵消了。如果等式的右边不是<b>n•G + 0•H</b>的形式 【for some known value of <i>n</i>】 ，你便知道该交易无效。这意味着花费的金额大于输入金额（例如，您提供5美元的账单，向收银员支付3美元，并在找零中获得10美元），或者输入大于输出（例如，您提供5美元的账单，向收银员支付3美元，并且没有找零）。</p><p>记得之前的签名吗？</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-50b6860689b8b124bfc09983c8d89830_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"228\" data-rawheight=\"77\" class=\"content_image\" width=\"228\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;228&#39; height=&#39;77&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"228\" data-rawheight=\"77\" class=\"content_image lazy\" width=\"228\" data-actualsrc=\"https://pic1.zhimg.com/v2-50b6860689b8b124bfc09983c8d89830_b.jpg\"/></figure><p><br/>The signature from the transaction.</p><p>这个签名实际上已经签署了我刚刚提到的<b>excess blinding factor</b>对应的承诺。这是如何做的？</p><p>如果你还记得，当你用生成器<b>G</b>乘以等式的两边时，这就是Bob方签名。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"614\" data-original=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;614&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"614\" data-original=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_b.jpg\"/></figure><p><br/>Bob’s partial signature when you multiply both sides by generator G.</p><p>类似地，当你用生成器<b>G</b>乘以等式两边时，Alice方签名就是这样：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"614\" data-original=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;614&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"614\" data-original=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-433d5a2ff5a86d8230ce25abd5fe8900_b.jpg\"/></figure><p><br/>Bob’s partial signature when you multiply both sides by generator G.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果将两个方程式加在一起会发生什么？你会得到：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>sr•G + ss•G =（kr•G）+（ks•G）+（e•（rr•G + rs•G））</blockquote><p>请记住，<b>rr</b>是Bob的致盲因子，<b>rs</b>是Alice的盲目因子之和。还需要记住<code>rr•G + rs•G</code> 和 <code>(rr + rs)•G</code>是等价的。</p><p>Bob的致盲因子对应的承诺是<b>11•G</b>。Alice所有致盲因子的和对应的承诺是<code>14•G</code>。将它们加在一起得到<b>25•G</b>，这是交易的** excess blinding factor<b>对应的承诺。因此，添加</b>sr<b>和</b>ss<b>（ Bob和Alice各自的部分签名）证明了整个交易的有效性，因为它们加起来是</b>excess blinding factor**对应的承诺。<br/>Further simplifying that equation, we get:<br/>进一步简化该等式，我们得到：</p><blockquote>sr•G + ss•G = (k•G) + (e • (r•G))</blockquote><p>或者</p><blockquote>sr•G + ss•G = (k•G) + (e • (25•G))</blockquote><p>剩下要做的就是检查等式左侧等于右侧。</p><p>请记住，这个等式中的所有内容（双方签名的和，<b>e</b>中的所有内容，** excess blinding factor**对应的承诺，nonce和对应的承诺）都是公开可见的，因此任何人都可以进行此验证。我们不需要Alice和Bob的致盲因子来验证交易。By adding their partial signatures and verifying that they summed to the commitment to the excess blinding factor，我们证明：</p><ol><li>再花费Alice之前的输入时，没有钱凭空产生。</li><li>Alice and Bob both knew the blinding factors for their outputs when they created this transaction. This means the new outputs are spendable by them, and not lost to the abyss.Alice和Bob都知道他们的输出对应的致盲因子。这意味着他们可以花费新的输出，而不是丢失【这里翻译不好】</li></ol><p>我们用来验证交易的信息放在所谓的<b>transaction kernel</b>中了。</p><h2>交易核</h2><p>除了输出之外，<b>transaction kernel（交易核）</b>是从Grin交易中产生的另一块信息。每个交易都会产生一个<b>transaction kernel（交易核）</b>，但是没有办法通过Grin区块链将输出和交易核关联起来。每个Grin交易都存在一个，它包含没有钱凭空产生的证明。</p><p>下面的信息存储来交易核中：</p><ul><li>交易的签名(s, k • G)</li><li>和“<b>excess blinding factor</b>” 相关联的公钥（这里指<b>25•G</b>），如上所述，它可以用来验证<b>s</b>。</li><li>交易的<b>交易费</b>和<b>锁定高度</b>(注意:如果这是Coinbase交易，那么这些交易都不存在).</li></ul><h2>总结</h2><p>After all this is said and done, the only things broadcast to the network from the transaction are:<br/>完成所有这些之后，只把交易的以下内容向网络广播：</p><ul><li>所用的输入</li><li>新的输出</li><li>交易核</li><li>核偏移 (这篇文章没有讲到).</li></ul><p>None of the transaction metadata from earlier are relayed. Even better, some of this information may get discarded, too — but we will save that for another post.</p><p>希望这篇文章能够说明Grin交易是如何运作的。我遗漏了范围证明，内核偏移和交易费用。请留意更多关于Grin如何实现切入工作的帖子，多参与者交易的外观以及一些实验性功能。Look out for more posts on how cut-through works in Grin, what multi-participant transactions look like, and some experimental features.</p><p><b>原文链接:</b> <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40brandonarvanaghi/grin-transactions-explained-step-by-step-fdceb905a853\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">medium.com/@brandonarva</span><span class=\"invisible\">naghi/grin-transactions-explained-step-by-step-fdceb905a853</span><span class=\"ellipsis\"></span></a><br/><b>作者:</b> <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40brandonarvanaghi\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Brandon Arvanaghi</a></p><p><b>翻译&amp;校对:</b> 徐晓峰</p>", 
            "topic": [
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>http交易方式,grin接收者,会知道发送者的ip地址吗?</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "kingsun zhang", 
                    "userLink": "https://www.zhihu.com/people/664920f5ac45c4d59968b7b13fa29fbe", 
                    "content": "<p>我想知道的是ALICE怎么找到BOB，并把交易发给BOB的，哈哈，而不是具体咋操作的。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39272735", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 0, 
            "title": "区块链技术架构分析（6）-数字签名", 
            "content": "<p>数字签名又称之为公钥数字签名，是一种类似于写在纸上的物理签名。数字签名主要用于数据更改的签名者身份识别以及抗抵赖。数字签名包含三个重要特性：<br/>l 只有自己可以签署自己的数字签名，但是他人可以验证签名是否是你签发；<br/>l 数字签名需要和具体的数字文档绑定，就好比现实中你的签名应该和纸质媒介绑定；<br/>l 数字签名不可伪造；<br/>通过非对称加密机制可以较容易实现上述三种特性。<br/>首先，需要生成个人的公私钥对：(sk, pk) := <br/>generateKeys(keysize)，sk私钥用户自己保留，pk公钥可以分发给其他人其次，可以通过sk对一个具体的message进行签名：sig<br/> := sign(sk, message) 这样就得到了具体的签名sig最后，拥有该签名公钥的一方能够进行签名的验证：isValid := <br/>verify(pk, message, <br/>sig)在区块链体系中每一条数据交易都需要签名，在比特币的设计过程中直接将用户的公钥来表征用户的比特币地址。这样在用户发起转账等比特币交易时可以方便的进行用户交易的合法性验证。<br/>数字签名就是在信息后面加上另一段内容，作为发送者的证明并且证明信息没有被篡改。一般是发送者将信息用哈希算法处理得出一个哈希值，然后用私钥对该哈希值进行加密，得出一个签名。然后发送者再将信息和签名一起发送给接收者。接收者使用发送者的公钥对签名进行解密，还原出哈希值，再通过哈希算法来验证信息的哈希值和解密签名还原出来的哈希值是否一致，从而可以鉴定信息是否来自发送者或验证信息是否被篡，如下图所示。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dbe98a333ca6107ee6581b22ccb16c11_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-dbe98a333ca6107ee6581b22ccb16c11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-dbe98a333ca6107ee6581b22ccb16c11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dbe98a333ca6107ee6581b22ccb16c11_b.jpg\"/></figure><p><br/>相关知识：数字证书和认证中心<br/>数字证书（Digital <br/>Certificate）又称“数字身份证”、“网络身份证”是经认证中心授权颁发并经认证中心数字签名的包含公开秘钥拥有者及公开秘钥相关信息的电子文件，可以用来判别数字证书拥有者身份。数字证书包含：公钥、证书名称信息、签发机构对证书的数字签名以及匹配的私钥证书可以存储在网络中的数据库中。用户可以利用网络彼此交换证书。当证书撤销后，签发此证书的CA仍保留此证书的副本，以备日后解<br/> 决可能引起的纠纷。<br/>认证中心（Certificate Authority） 一般简称CA, <br/>CA一般是一个公认可信的第三方机构，其作用主要是为每个用户颁发一个独一无二的包含名称和公钥的数字证书。CA解决了电子商务中公钥的可信度问题：负责证明“我确实始我”，CA是受信仟的第三方，公钥的合法性检验，CA证书内容包括：证书持有人的公钥、证书授权中心名称、证书有效期、证书授权中心的数字签名。<br/>CA证书用例-Https访问网站：<br/>*客户端通过https向服务器发安全链接请求<br/>*服务器用私钥加密网页内容，同CA证书一并发给客户端<br/>*客户端会根据CA证书验证是否合法：<br/>*如果验证失败，客户端弹出警告信息<br/>*如果验证通过，客户端使用CA证书中的公钥向服务器发送加密信息<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4a22f520424466f3a61139d7806c900d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"469\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-4a22f520424466f3a61139d7806c900d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;469&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"469\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-4a22f520424466f3a61139d7806c900d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4a22f520424466f3a61139d7806c900d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "游戏从业者", 
                    "tagLink": "https://api.zhihu.com/topics/19920507"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39272635", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 0, 
            "title": "区块链技术架构分析（5）-加密算法", 
            "content": "<p>加密就是通过一种算法将原始信息进行转换，接收者能够通过密钥对密文进行解密还原成原文的过程。加密算法的典型组件有加解密算法、加密密钥和解密密钥。其中加解密算法是固定不变和公开可见的；密钥则不固定而且需要保护起来，一般来说，对同一种算法，密钥长度越长，则加密强度越大。<br/>加密过程即通过加密算法和加密密钥，对明文进行加密，获得密文。<br/>解密过程即通过解密算法和解密密钥，对密文进行解密，获得明文。<br/>根据加解密的密钥是否相同，算法可以分为对称加密（symmetric cryptography，又称公共密钥加密，common-key <br/>cryptography）和非对称加密（asymmetric cryptography，又称公钥加密，public-key <br/>cryptography）。两种模式适用于不同的需求，恰好形成互补，很多时候也可以组合使用，形成混合加密机制。<br/>并非所有加密算法的强度都可以从数学上进行证明。公认的高强度加密算法是在经过长时间各方面实践论证后，被大家所认可，不代表其不存在漏洞。但任何时候，自行发明加密算法都是一种不太明智的行为。<br/><b>A、对称加密</b><br/>用相同的密钥来加密和解密，对称加密的优点是加解密效率高（速度快，空间占用小），加密强度高。缺点是参与多方都需要持有密钥，一旦有人泄露则安全性被破坏，如何在不安全通道下分发密钥是关键问题。<br/>加密过程：原文+密钥=》密文；解密过程：密文-密钥=》原文。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-31e51005f6bee6f192d2c189305ee064_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-31e51005f6bee6f192d2c189305ee064_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-31e51005f6bee6f192d2c189305ee064_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-31e51005f6bee6f192d2c189305ee064_b.jpg\"/></figure><p><br/>对称密码从实现原理上可以分为两种：分组密码和序列密码。前者将明文切分为定长数据块作为加密单位，应用最为广泛。后者则只对一个字节进行加密，且密码不断变化，只用在一些特定领域，如数字媒介的加密等。<br/>代表算法包括：<br/>l DES（Data Encryption Standard）：经典的分组加密算法，1977年由美国联邦信息处理标准（FIPS）所采用FIPS-46-3，将64位明文加密为64位的密文，其密钥长度为56位+8位校验。现在已经很容易被暴力破解。<br/>l 3DES：三重DES操作：加密解密加密，处理过程和加密强度优于DES，但现在也被认为不够安全。<br/>l AES（Advanced Encryption <br/>Standard）：美国国家标准研究所（NIST）采用取代DES成为对称加密实现的标准，1997~2000年NIST从15个候选算法中评选Rijndael算法（由比利时密码学家Joan<br/> Daemon和Vicent <br/>Rijmen发明）作为AES，标准为FIPS-197。AES也是分组算法，分组长度为128、192、256位三种。AES的优势在于处理速度快，整个过程可以数学化描述，目前尚未有有效的破解手段。<br/>适用于大量数据的加解密；不能用于签名场景；需要提前分发密钥。其中分组加密每次只能处理固定长度的明文，因此过长的内容需要采用一定模式进行加密，《使用密码学》中推荐使用密文分组链接（Cipher<br/> Block Chain,CBC）、计数器（Counter,CTR）模式。<br/><b>B、非对称加密</b><br/>非对称加密是现代密码学历史上最为伟大的发明，可以很好的解决对称加密需要的提前分发密钥问题。加密密钥和解密密钥是不同的，分别称为公钥和私钥。公钥一般是公开的，人人可获取的，私钥一般是个人自己持有，不能被他人获取。公钥用于加密，私钥用于解密。公钥由私钥生成，私钥可以推导出公钥，从公钥无法推导出私钥。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6b2bc454df2ec0214d85eee9b89f980b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"157\" class=\"origin_image zh-lightbox-thumb\" width=\"428\" data-original=\"https://pic4.zhimg.com/v2-6b2bc454df2ec0214d85eee9b89f980b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;428&#39; height=&#39;157&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"157\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"428\" data-original=\"https://pic4.zhimg.com/v2-6b2bc454df2ec0214d85eee9b89f980b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6b2bc454df2ec0214d85eee9b89f980b_b.jpg\"/></figure><p><br/>它的优点是公私钥分开，不安全通道也可以使用。缺点是加解密速度慢，一般比对称加解密算法慢2到3个数量级；同时加密强度相比对称加密要差。<br/>加密过程：原文+接收方公钥=》密文；解密过程：密文+接收方私钥=》原文<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e9d059f54b7e15b8273035ef002e083f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-e9d059f54b7e15b8273035ef002e083f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-e9d059f54b7e15b8273035ef002e083f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e9d059f54b7e15b8273035ef002e083f_b.jpg\"/></figure><p><br/>非对称加密算法的安全性往往需要基于数学问题来保障，目前主要有基于大数质因子分解、离散对数、椭圆曲线等几种思路。<br/>代表算法包括：<br/>l RSA：经典的公钥算法，1978年提出。算法利用了对大数进行质因子分解困难的特性，但目前还没有数学证明两者难度等价，或许存在未知算法在不进行大数分解的前提下解密。<br/>l Diffie-Hellman密钥交换：基于离散对数无法快速求解，可以在不安全的通道上，双方协商一个公共密钥。<br/>l ElGamal：利用了模运算下求离散对数困难的特性。被应用在PGP等安全工具中。<br/>l 椭圆曲线算法（Elliptic curve <br/>cryptography,ECC）：现代备受关注的算法系列，基于对椭圆曲线上特定点进行特殊乘法逆运算难以计算的特性。最早在1985年提出。ECC系列算法一般被认为具备较高的安全性，但加解密计算过程往往比较费时。<br/>一般适用于签名场景或密钥协商，不适于大量数据的加解密。 其中RSA算法等已被认为不够安全，一般推荐采用椭圆曲线系列算法。<br/><b>C、混合加密机制</b><br/>这种方式将加密过程分为两个阶段，阶段一使用非对称加密进行秘钥的分发使得对方安全地得到对称加密的秘钥，阶段二使用对称加密对原文进行加解密，如下图所示。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9787e51d19440abdee729f28774ea66c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-9787e51d19440abdee729f28774ea66c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-9787e51d19440abdee729f28774ea66c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9787e51d19440abdee729f28774ea66c_b.jpg\"/></figure><p><br/>典型的场景是现在大家常用的HTTPS机制。<br/>建立安全连接具体步骤如下：<br/>l 客户端浏览器发送信息到服务器，包括随机数R1，支持的加密算法类型、协议版本、压缩算法等。注意该过程为明文。<br/>l 服务端返回信息，包括随机数R2、选定加密算法类型、协议版本，以及服务器证书。注意该过程为明文。<br/>l 浏览器检查带有该网站公钥的证书。该证书需要由第三方CA来签发，浏览器和操作系统会预置权威CA的根证书。如果证书被篡改作假（中间人攻击），很容易通过CA的证书验证出来。<br/>l 如果证书没问题，则用证书中公钥加密随机数R3，发送给服务器。此时，只有客户端和服务器都拥有R1、R2和R3信息，基于R1、R2和R3，生成对称的会话密钥（如AES算法）。后续通信都通过对称加密进行保护。<br/><b>D、常见加密算法的对比</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ad2948885969036085d4793a28a1b6d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-ad2948885969036085d4793a28a1b6d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;133&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-ad2948885969036085d4793a28a1b6d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ad2948885969036085d4793a28a1b6d8_b.jpg\"/></figure><p><br/><b>E、比特币中加密算法的使用</b><br/>比特币系统中使用的就是一种非常典型的非对称加密算法——椭圆曲线加密算法（ECC）。比特币系统一般从操作系统底层的一个密码学安全的随机源中取出一个256位随机数作为私钥，私钥总数为2256<br/> <br/>个，所以很难通过遍历所有可能的私钥得出与公钥的对应的私钥。用户使用的私钥还会通过SHA256和Base58转换成易书写和识别的50位长度的私钥，公钥则首先由私钥和Secp256k1椭圆曲线算法生成65字节长度的随机数。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d5920b7dea47aca4d89381b4e965f1d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-4d5920b7dea47aca4d89381b4e965f1d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;662&#39; height=&#39;185&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-4d5920b7dea47aca4d89381b4e965f1d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d5920b7dea47aca4d89381b4e965f1d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "加密算法", 
                    "tagLink": "https://api.zhihu.com/topics/19746975"
                }, 
                {
                    "tag": "加密", 
                    "tagLink": "https://api.zhihu.com/topics/19569234"
                }, 
                {
                    "tag": "数据加密", 
                    "tagLink": "https://api.zhihu.com/topics/19567918"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39272368", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 1, 
            "title": "区块链技术架构分析（4）-hash算法", 
            "content": "<p>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。这种转换是一种压缩映射，也就是，散列值的空间通常远小于输入的空间，不同的输入可能会散列成相同的输出，所以不可能从散列值来确定唯一的输入值。简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。<br/>哈希能够实现数据从一个维度向另一个维度的映射，通常使用哈希函数实现这种映射。通常业界使用y = hash(x)的方式进行表示，该哈希函数实现对x进行运算计算出一个哈希值y。<br/><b>A、哈希算法的特点</b><br/>l 哈希算法接受一段明文后，以一种不可逆的方式，将其转化为一段长度较短、位数固定的散列数据，计算高效。<br/>l collision-free 即冲突概率小，如果两个哈希值是不相同的（根据同一函数），那么这两个哈希值的原始输入也是不相同的；如果两个哈希值相同，两个输入值很可能是相同的，但不绝对肯定二者一定相等（可能出现哈希碰撞）。<br/>l 能够隐藏原始信息：例如区块链中各个节点之间对交易的验证只需要验证交易的信息熵，而不需要对原始信息进行比对，节点间不需要传输交易的原始数据只传输交易的哈希即可，常见算法有SHA系列和MD5等算法。<br/>l 加密过程不可逆，即无法通过输出的散列数据倒推原本的明文是什么。<br/>l 输入的明文与输出的散列数据一一对应，任何一个输入信息的变化，都必将导致最终输出的散列数据的变化，冲突的概率非常小。<br/><b>B、哈希的用法</b><br/>哈希在区块链中用处广泛，其一我们称之为哈希指针（Hash Pointer），哈希指针是指该变量的值是通过实际数据计算出来的且指向实际的数据所在位置，即其既可以表示实际数据内容又可以表示实际数据的存储位置。如下图所示：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c25581bb918afe3d3204b0d66acd8f6f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-c25581bb918afe3d3204b0d66acd8f6f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-c25581bb918afe3d3204b0d66acd8f6f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c25581bb918afe3d3204b0d66acd8f6f_b.jpg\"/></figure><p><br/>image<br/>HashPointer在区块链中主要有两处使用，第一个就是构建区块链数据结构，从上面的区块数据结构中就可以知道，每个区块都包含了上一个区块的hash值（即hash<br/> <br/>pointer），这样的好处在于后面区块可以查找前面所有区块中的信息，而且区块的HashPointer的计算包含了前面区块的信息从而一定程度上保证了区块链的不易篡改的特性。第二个就是用于构建Merkle<br/> Tree.，Merkle Tree的各个节点使用HashPointer进行构建。<br/>哈希还在其他技术中有所应用例如:交易验证以及数字签名等等。</p>", 
            "topic": [
                {
                    "tag": "哈希函数", 
                    "tagLink": "https://api.zhihu.com/topics/19631819"
                }, 
                {
                    "tag": "密码学", 
                    "tagLink": "https://api.zhihu.com/topics/19621679"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39271872", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 2, 
            "title": "区块链技术架构分析（3）-默克尔树（merkle tree）", 
            "content": "<p>默克尔树（Merkle<br/> tree，MT）是一种哈希二叉树，1979年由Ralph <br/>Merkle发明。在计算机科学中，二叉树是每个节点最多有两个子树的树结构，每个节点代表一条结构化数据。通常子树被称作“左子树”（left <br/>subtree）和“右子树”（right subtree）。二叉树常被用于实现数据快速查询。二叉树如下图所示。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7b414984d3b0a52182df3e6ef7ee1107_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"389\" data-rawheight=\"358\" class=\"content_image\" width=\"389\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;389&#39; height=&#39;358&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"389\" data-rawheight=\"358\" class=\"content_image lazy\" width=\"389\" data-actualsrc=\"https://pic4.zhimg.com/v2-7b414984d3b0a52182df3e6ef7ee1107_b.jpg\"/></figure><p><br/><b>A、Merkle树结构</b><br/>由一个根节点（root）、一组中间节点和一组叶节点（leaf）组成。叶节点（leaf）包含存储数据或其哈希值，中间节点是它的两个孩子节点内容的哈希值，根节点也是由它的两个子节点内容的哈希值组成。所以Merkle树也称哈希树。<br/><b>B、哈希树的特点</b><br/>叶节点存储的是数据文件，而非叶节点存储的是其子节点的哈希值（Hash，通过SHA1、SHA256等哈希算法计算而来），这些非叶子节点的Hash被称作路径哈希值（可以据其确定某个叶节点到根节点的路径）,<br/> 叶节点的Hash值是真实数据的Hash值。因为使用了树形结构, 其查询的时间复杂度为 O(logn)，n是节点数量。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-49d924ba2348962aa7ede636c622d2ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic2.zhimg.com/v2-49d924ba2348962aa7ede636c622d2ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic2.zhimg.com/v2-49d924ba2348962aa7ede636c622d2ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-49d924ba2348962aa7ede636c622d2ed_b.jpg\"/></figure><p><br/>默克尔树的另一个特点是，底层数据的任何变动，都会传递到其父节点，一直到树根。<br/><b>C、应用模式</b><br/>默克尔树的典型应用场景包括：<br/>l 快速比较大量数据：当两个默克尔树根相同时，则意味着所代表的数据必然相同（哈希算法决定的）。<br/>l 快速定位修改：例如上例中，如果 D1 中数据被修改，会影响到Hash0-0，Hash0 和 Root。因此，沿着 Root --&gt; 0 --&gt; 0-0，可以快速定位到发生改变的 D1；<br/><b>l 零知识证明：例如如何证明某个数据（D0……D3）中包括给定内容 D0，很简单，构造一个默克尔树，公布 N0，N1，N4，Root，D0拥有者可以很容易检测 D0 存在，但不知道其它内容。</b><br/>相对于 Hash List，MT的明显的一个好处是可以单独拿出一个分支来（作为一个小树）对部分数据进行校验，这个很多使用场合就带来了哈希列表所不能比拟的方便和高效。正是源于这些优点，MT常用于分布式系统或分布式存储中<br/><b>D、在分布式存储系统中的应用原理</b><br/>为了保持数据一致，分布系统间数据需要同步，如果对机器上所有数据都进行比对的话，数据传输量就会很大，从而造成“网络拥挤”。为了解决这个问题，可以在每台机器上构造一棵Merkle<br/> Tree，这样，在两台机器间进行数据比对时，从Merkle <br/>Tree的根节点开始进行比对，如果根节点一样，则表示两个副本目前是一致的，不再需要任何处理；如果不一样，则沿着hash值不同的节点路径查询，很快就能定位到数据不一致的叶节点，只用把不一致的数据同步即可，这样大大节省了比对时间以及数据的传输量。<br/><b>E、比特币中的Merkle Tree</b><br/>比特币区块链系统中的采用的是Merkle二叉树，它的作用主要是快速归纳和校验区块数据的完整性，它会将区块链中的数据分组进行哈希运算，向上不断递归运算产生新的哈希节点，最终只剩下一个Merkle根存入区块头中，每个哈希节点总是包含两个相邻的数据块或其哈希值。<br/>在比特币系统中使用Merkle树有诸多优点：首先是极大地提高了区块链的运行效率和可扩展性，使得区块头只需包含根哈希值而不必封装所有底层数据，这使得哈希运算可以高效地运行在智能手机甚至物联网设备上；其次是Merkle树可支持“简化支付验证协议”（SPV），即在不运行完整区块链网络节点的情况下，也能够对交易数据进行检验。所以，在区块链中使用Merkle树这种数据结构是非常具有意义的。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1f17128b389480f680a758e3253b0e01_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-1f17128b389480f680a758e3253b0e01_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-1f17128b389480f680a758e3253b0e01_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1f17128b389480f680a758e3253b0e01_b.jpg\"/></figure><p><br/>Merkle树的计算可参考：<br/><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/fengzhiwu/p/5524324.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/fengzhiwu/p</span><span class=\"invisible\">/5524324.html</span><span class=\"ellipsis\"></span></a><br/><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_33935254/article/details/55505472\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_339352</span><span class=\"invisible\">54/article/details/55505472</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "哈希函数", 
                    "tagLink": "https://api.zhihu.com/topics/19631819"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "技术架构", 
                    "tagLink": "https://api.zhihu.com/topics/19612641"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39271758", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 0, 
            "title": "区块链技术架构分析（2）-区块数据和链式结构", 
            "content": "<p>区块数据主要是保存交易数据，不同的系统采用的结构不同，下面以比特币的区块结构为例做介绍。<br/>比特币的交易记录会保存在数据区块之中，比特币系统中大约每10分钟会产生一个区块，每个数据区块一般包含区块头（Header）和区块体（Body）两部分，如图所示。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cabc6f4ea0af64c382a75bce6833c5e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-cabc6f4ea0af64c382a75bce6833c5e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-cabc6f4ea0af64c382a75bce6833c5e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cabc6f4ea0af64c382a75bce6833c5e3_b.jpg\"/></figure><p><b><br/>区块结构：</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c52eec2f8fe0ccf460fad094957c6d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-4c52eec2f8fe0ccf460fad094957c6d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-4c52eec2f8fe0ccf460fad094957c6d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c52eec2f8fe0ccf460fad094957c6d2_b.jpg\"/></figure><p><b><br/>区块头的结构说明：</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-685c44be9002f01f94acd58747a31243_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb\" width=\"657\" data-original=\"https://pic4.zhimg.com/v2-685c44be9002f01f94acd58747a31243_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;657&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"657\" data-original=\"https://pic4.zhimg.com/v2-685c44be9002f01f94acd58747a31243_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-685c44be9002f01f94acd58747a31243_b.jpg\"/></figure><p><br/>比特币区块链格式可参考：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/mengzaishenqiu/article/details/80340877\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/mengzaish</span><span class=\"invisible\">enqiu/article/details/80340877</span><span class=\"ellipsis\"></span></a></p><p><br/>区块链的数据结构成员分散存储在底层数据库，最终存储形式是[k,v]键值对，使用的[k,v]型底层数据库是LevelDB；与交易操作相关的数据，其呈现的集合形式是Block；如果以Block为单位链接起来，则构成更大粒度的BlockChain。</p><p><b>从上面的区块结构中可以看到，每一个区块都保存了上一个区块的hash值，这样就将这些区块连接起来。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-07bbb13b299c0db202bdebe175c0bdd4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-07bbb13b299c0db202bdebe175c0bdd4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-07bbb13b299c0db202bdebe175c0bdd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-07bbb13b299c0db202bdebe175c0bdd4_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "比特币 (Bitcoin)", 
                    "tagLink": "https://api.zhihu.com/topics/19600228"
                }, 
                {
                    "tag": "以太坊", 
                    "tagLink": "https://api.zhihu.com/topics/20042675"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39271576", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 0, 
            "title": "区块链技术架构分析（1）-存储系统", 
            "content": "<p>数据层是最底层的技术，主要实现了两个功能：数据存储、账户和交易的实现与安全。数据存储主要基于Merkle树，通过区块的方式和链式结构实现，大多以KV数据库的方式实现持久化，比如比特币和以太坊采用的leveldb。账户和交易的实现与安全这个功能基于数字签名、哈希函数和非对称加密技术等多种密码学算法和技术，保证了交易在去中心化的情况下能够安全的进行。<br/>数据层的系统模型有很多，比如比特币的UTXO 模型、迅雷链的账户模型等。<br/><b>数据存储系统--数据库</b><br/>数据层的一大功能是存储，存储系统的选择原则是性能和易用性。一个网络系统的整体性能，主要取决于网络或本地数据存储系统的I/O性能，比如比特币用的是谷歌的LevelDB，据说这个数据库读写性能很好，但是很多功能需要开发者自己实现。<br/>数据库的历史：在IT界，其实一个特别古老的研究领域。从最初的文件系统，到后来的ER实体关系模型。实体关系模型的提出催生了一系列伟大的数据库公司和软件，例如IBM的DB2，<br/> <br/>Sybase，Oracle，微软的SQLServer，MySQL等等。以及，由此引发了传统数据库的三大成就，关系模型、事务处理、查询优化。再到后来随着互联网的盛行，MangoDB为典型代表的NOSQL数据库崛起。数据库技术本身在不停的演进，且一直是热门的方向，也包括XML为代表的半结构化，基于文本、语音和图像的非结构化数据处理等。<br/>伴随着现实的需求不断升级，数据库也在不断发展的，我们通过ER实体关系模型、通过NOSQL，能很好的解决数据存储和数据访问的Scalability问题。我们通过NOSQL数据库、云存储等技术解决了互联网海量数据的处理问题后，下一个问题接踵而至。那就是如何以一种规模化的方式解决数据真实性和有效性的问题。<br/>区块链的数据库和传统分布式数据库的比较。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f3d4b7420143802315ad948417c55bf8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-f3d4b7420143802315ad948417c55bf8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;456&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-f3d4b7420143802315ad948417c55bf8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f3d4b7420143802315ad948417c55bf8_b.jpg\"/></figure><p><br/>img<br/>从图中可以看出，区块链的数据库使用技术还是数据库，知识在管理权限、数据节点分布、去中心化等部分有差异。区块链的不可篡改数据，必然伴随着数据存储的膨胀，这个会不会是一个问题呢？</p>", 
            "topic": [
                {
                    "tag": "技术架构", 
                    "tagLink": "https://api.zhihu.com/topics/19612641"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38300602", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 47, 
            "title": "golang实现p2p之UDP打洞", 
            "content": "<p>当今互联网到处存在着一些中间件(MIddleBoxes)，如NAT和防火墙，导致两个(不在同一内网)中的客户端无法直接通信。 这些问题即便是到了IPV6时代也会存在，因为即使不需要NAT，但还有其他中间件如防火墙阻挡了链接的建立。 目前部署的中间件多都是在C/S架构上设计的，其中相对隐匿的客户机主动向周知的服务端(拥有静态IP地址和DNS名称)发起链接请求。 大多数中间件实现了一种非对称的通讯模型，即内网中的主机可以初始化对外的链接，而外网的主机却不能初始化对内网的链接， 除非经过中间件管理员特殊配置。</p><p>在中间件为常见的NAPT的情况下（也是本文主要讨论的），内网中的客户端没有单独的公网IP地址， 而是通过NAPT转换，和其他同一内网用户共享一个公网IP。这种内网主机隐藏在中间件后的不可访问性对于一些客户端软件如浏览器来说 并不是一个问题，因为其只需要初始化对外的链接，从某方面来看反而还对隐私保护有好处。然而在P2P应用中， 内网主机（客户端）需要对另外的终端（Peer）直接建立链接，但是发起者和响应者可能在不同的中间件后面， 两者都没有公网IP地址。而外部对NAT公网IP和端口主动的链接或数据都会因内网未请求被丢弃掉。本文讨论的就是如何跨越NAT实现内网主机直接通讯的问题。</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23section\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">网络模型</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23section-1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">打洞流程</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23section-2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">先决条件</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23section-3\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">源码示例</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23udptcp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">udp打洞转tcp通信</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//qjpcpu.github.io/blog/2018/01/26/p2pzhi-udpda-dong/%23section-4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">参考文献</a></li></ul><h2><b>网络模型</b></h2><p>假设客户端A和客户端B的地址都是内网地址，且在不同的NAT后面。A、B上运行的P2P应用程序和服务器S都使用了UDP端口9982，A和B分别初始化了 与Server的UDP通信，地址映射如图所示:</p><div class=\"highlight\"><pre><code class=\"language-text\">                        Server S\n                    207.148.70.129:9981\n                           |\n                           |\n    +----------------------|----------------------+\n    |                                             |\n  NAT A                                         NAT B\n120.27.209.161:6000                            120.26.10.118:3000\n    |                                             |\n    |                                             |\n Client A                                      Client B\n  10.0.0.1:9982                                 192.168.0.1:9982</code></pre></div><p>现在假设客户端A打算与客户端B直接建立一个UDP通信会话。如果A直接给B的公网地址120.26.10.118:3000发送UDP数据，NAT B将很可能会无视进入的 数据（除非是Full Cone NAT），因为源地址和端口与S不匹配，而最初只与S建立过会话。B往A直接发信息也类似。</p><p>假设A开始给B的公网地址发送UDP数据的同时，给服务器S发送一个中继请求，要求B开始给A的公网地址发送UDP信息。A往B的输出信息会导致NAT A打开 一个A的内网地址与与B的外网地址之间的新通讯会话，B往A亦然。一旦新的UDP会话在两个方向都打开之后，客户端A和客户端B就能直接通讯， 而无须再通过引导服务器S了。</p><p>UDP打洞技术有许多有用的性质。一旦一个的P2P链接建立，链接的双方都能反过来作为“引导服务器”来帮助其他中间件后的客户端进行打洞， 极大减少了服务器的负载。应用程序不需要知道中间件具体是什么（如果有的话），因为以上的过程在没有中间件或者有多个中间件的情况下 也一样能建立通信链路。</p><h2><b>打洞流程</b></h2><p>假设A现在希望建立一条到B的udp会话，那么这个建立基本流程是:</p><ol><li>A,B分别建立到Server S的udp会话,那么Server S此时是知道A,B各自的外网ip+端口</li><li>Server S在和B的udp会话里告诉A的地址(外网ip+端口: 120.27.209.161:6000),同理把B的地址(120.26.10.118:3000)告诉A</li><li>B向A地址(120.27.209.161:6000)发送一个&#34;握手&#34;udp包,打通A-&gt;B的udp链路</li><li>此时A可以向B(120.26.10.118:3000)发送udp包,A-&gt;B的会话建立成功</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>先决条件</b></h2><p>能够完成打洞有几个先决条件:</p><ol><li>A,B所在的nat网络类型(Full cone, Restricted cone, Port-restricted cone, Symmetric NAT)</li><li>在一次udp会话期间,nat设备(路由器)会保持内网进程 inner_ip:inner_port &lt;-&gt; share_public_ip:share_port的映射关系,一般根据具体路由器实现,这个映射关系可以维持几分钟到几个小时不等</li><li>流程中第3步,nat A收到这个握手包后并不会转发给A,因为它发现自己的没有保存过B的地址,认为这是一个来历不明的包而直接丢弃,然而这个包的作用在于在nat B留下了A的记录,使得nat B认为A是可达或者说可通过了,这样当A-&gt;B再发送udp包时就可以真正到达B了。所以这个&#34;握手&#34;包的作用是可以打通A-&gt;B的通路,是必要的</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>源码示例</b></h2><p>使用三台设备模拟,外网设备207.148.70.129模拟Server S,执行server.go代码:</p><blockquote>server.go</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">package main\n​\nimport (\n    &#34;fmt&#34;\n    &#34;log&#34;\n    &#34;net&#34;\n    &#34;time&#34;\n)\n​\nfunc main() {\n    listener, err := net.ListenUDP(&#34;udp&#34;, &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9981})\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    log.Printf(&#34;本地地址: &lt;%s&gt; \\n&#34;, listener.LocalAddr().String())\n    peers := make([]net.UDPAddr, 0, 2)\n    data := make([]byte, 1024)\n    for {\n        n, remoteAddr, err := listener.ReadFromUDP(data)\n        if err != nil {\n            fmt.Printf(&#34;error during read: %s&#34;, err)\n        }\n        log.Printf(&#34;&lt;%s&gt; %s\\n&#34;, remoteAddr.String(), data[:n])\n        peers = append(peers, *remoteAddr)\n        if len(peers) == 2 {\n​\n            log.Printf(&#34;进行UDP打洞,建立 %s &lt;--&gt; %s 的连接\\n&#34;, peers[0].String(), peers[1].String())\n            listener.WriteToUDP([]byte(peers[1].String()), &amp;peers[0])\n            listener.WriteToUDP([]byte(peers[0].String()), &amp;peers[1])\n            time.Sleep(time.Second * 8)\n            log.Println(&#34;中转服务器退出,仍不影响peers间通信&#34;)\n            return\n        }\n    }\n}</code></pre></div><blockquote>另外两台分别位于不同内网后的设备,均运行相同代码peer.go:</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">package main\n​\nimport (\n    &#34;fmt&#34;\n    &#34;log&#34;\n    &#34;net&#34;\n    &#34;os&#34;\n    &#34;strconv&#34;\n    &#34;strings&#34;\n    &#34;time&#34;\n)\n​\nvar tag string\n​\nconst HAND_SHAKE_MSG = &#34;我是打洞消息&#34;\n​\nfunc main() {\n    // 当前进程标记字符串,便于显示\n    tag = os.Args[1]\n    srcAddr := &amp;net.UDPAddr{IP: net.IPv4zero, Port: 9982} // 注意端口必须固定\n    dstAddr := &amp;net.UDPAddr{IP: net.ParseIP(&#34;207.148.70.129&#34;), Port: 9981}\n    conn, err := net.DialUDP(&#34;udp&#34;, srcAddr, dstAddr)\n    if err != nil {\n        fmt.Println(err)\n    }\n    if _, err = conn.Write([]byte(&#34;hello, I&#39;m new peer:&#34; + tag)); err != nil {\n        log.Panic(err)\n    }\n    data := make([]byte, 1024)\n    n, remoteAddr, err := conn.ReadFromUDP(data)\n    if err != nil {\n        fmt.Printf(&#34;error during read: %s&#34;, err)\n    }\n    conn.Close()\n    anotherPeer := parseAddr(string(data[:n]))\n    fmt.Printf(&#34;local:%s server:%s another:%s\\n&#34;, srcAddr, remoteAddr, anotherPeer.String())\n​\n    // 开始打洞\n    bidirectionHole(srcAddr, &amp;anotherPeer)\n​\n}\n​\nfunc parseAddr(addr string) net.UDPAddr {\n    t := strings.Split(addr, &#34;:&#34;)\n    port, _ := strconv.Atoi(t[1])\n    return net.UDPAddr{\n        IP:   net.ParseIP(t[0]),\n        Port: port,\n    }\n}\n​\nfunc bidirectionHole(srcAddr *net.UDPAddr, anotherAddr *net.UDPAddr) {\n    conn, err := net.DialUDP(&#34;udp&#34;, srcAddr, anotherAddr)\n    if err != nil {\n        fmt.Println(err)\n    }\n    defer conn.Close()\n    // 向另一个peer发送一条udp消息(对方peer的nat设备会丢弃该消息,非法来源),用意是在自身的nat设备打开一条可进入的通道,这样对方peer就可以发过来udp消息\n    if _, err = conn.Write([]byte(HAND_SHAKE_MSG)); err != nil {\n        log.Println(&#34;send handshake:&#34;, err)\n    }\n    go func() {\n        for {\n            time.Sleep(10 * time.Second)\n            if _, err = conn.Write([]byte(&#34;from [&#34; + tag + &#34;]&#34;)); err != nil {\n                log.Println(&#34;send msg fail&#34;, err)\n            }\n        }\n    }()\n    for {\n        data := make([]byte, 1024)\n        n, _, err := conn.ReadFromUDP(data)\n        if err != nil {\n            log.Printf(&#34;error during read: %s\\n&#34;, err)\n        } else {\n            log.Printf(&#34;收到数据:%s\\n&#34;, data[:n])\n        }\n    }\n}</code></pre></div><p>注意代码仅模拟打洞基础流程,如果读者测试网络情况较差发生udp丢包,可能看不到预期结果,此时简单重启server,peer即可.</p><p>完整代码参考<a href=\"https://link.zhihu.com/?target=https%3A//github.com/qjpcpu/p2pbyudp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">github</a></p><h2><b>udp打洞转tcp通信</b></h2><p>通常,由于udp打洞实现简单,p2p的实现采用udp打洞较多,然而当通路建立起来后使用tcp进行节点间通信可以获取更好的通信效果。因为udp打洞完成后形成的nat映射是和tcp/udp无关的,所以此时可以转为使用tcp建立连接,达到最终的p2p的tcp通信.由于代码较简单,这里就不给出示例了。</p><h2><b>参考文献</b></h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//yq.aliyun.com/articles/227421\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">UDP用打洞技术穿透NAT的原理与实现</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/26796476\" class=\"internal\">P2P通信原理与实现</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jtriley/pystun\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NAT类型检测工具</a></li></ul>", 
            "topic": [
                {
                    "tag": "对等网络（P2P）", 
                    "tagLink": "https://api.zhihu.com/topics/19665362"
                }, 
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "Golang 最佳实践", 
                    "tagLink": "https://api.zhihu.com/topics/20063071"
                }
            ], 
            "comments": [
                {
                    "userName": "孤独的居士", 
                    "userLink": "https://www.zhihu.com/people/5158cb43f160c14d7c24b26c55504887", 
                    "content": "不错，通俗易懂，最好再提到实际开发中遇到的坑就好了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38300906", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 3, 
            "title": "用go实现基于pos共识算法的区块链", 
            "content": "<h2><b>005使用 go 实现 Proof of Stake 共识机制</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>什么是 Proof of Stake</b></h2><p>在PoW中，节点之间通过hash的计算力来竞赛以获取下一个区块的记账权，而在PoS中，块是已经铸造好的，铸造的过程是基于每个节点(Node)愿意作为抵押的令牌(Token)数量。如果验证者愿意提供更多的令牌作为抵押品，他们就有更大的机会记账下一个区块并获得奖励。</p><h2><b>实现 Proof of Stake 主要功能点</b></h2><ul><li>我们将有一个中心化的TCP服务节点，其他节点可以连接该服务器</li><li>最新的区块链状态将定期广播到每个节点</li><li>每个节点都能提议建立新的区块</li><li>基于每个节点的令牌数量，其中一个节点将随机地(以令牌数作为加权值)作为获胜者，并且将该区块添加到区块链中</li></ul><h2><b>实现 Proof of Stake</b></h2><h2><b>设置 TCP 服务器的端口</b></h2><p>新建 <code>.env</code>，添加如下内容 <code>PORT=9000</code></p><h2><b>安装依赖软件</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ go get github.com/davecgh/go-spew/spew\n​\n$ go get github.com/joho/godotenv</code></pre></div><ul><li><code>spew</code> 在控制台中格式化输出相应的结果。</li><li><code>godotenv</code> 可以从我们项目的根目录的 <code>.env</code> 文件中读取数据。</li></ul><h2><b>引入相应的包</b></h2><p>新建 <code>main.go</code>，引入相应的包</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n​\nimport (\n    &#34;bufio&#34;\n    &#34;crypto/sha256&#34;\n    &#34;encoding/hex&#34;\n    &#34;encoding/json&#34;\n    &#34;fmt&#34;\n    &#34;io&#34;\n    &#34;log&#34;\n    &#34;math/rand&#34;\n    &#34;net&#34;\n    &#34;os&#34;\n    &#34;strconv&#34;\n    &#34;sync&#34;\n    &#34;time&#34;\n​\n    &#34;github.com/davecgh/go-spew/spew&#34;\n    &#34;github.com/joho/godotenv&#34;\n)</code></pre></div><h2><b>全局变量</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">// Block represents each &#39;item&#39; in the blockchain\ntype Block struct {\n    Index     int\n    Timestamp string\n    BPM       int\n    Hash      string\n    PrevHash  string\n    Validator string\n}\n​\n// Blockchain is a series of validated Blocks\nvar Blockchain []Block\nvar tempBlocks []Block\n​\n// candidateBlocks handles incoming blocks for validation\nvar candidateBlocks = make(chan Block)\n​\n// announcements broadcasts winning validator to all nodes\nvar announcements = make(chan string)\n​\nvar mutex = &amp;sync.Mutex{}\n​\n// validators keeps track of open validators and balances\nvar validators = make(map[string]int)</code></pre></div><ul><li><code>Block</code> 是每个区块的内容</li><li><code>Blockchain</code> 是我们的官方区块链，它只是一串经过验证的区块集合。每个区块中的 <code>PrevHash</code> 与前面块的 <code>Hash</code> 相比较，以确保我们的链是正确的。 <code>tempBlocks</code> 是临时存储单元，在区块被选出来并添加到 <code>BlockChain</code> 之前，临时存储在这里</li><li><code>candidateBlocks</code> 是 <code>Block</code> 的通道，任何一个节点在提出一个新块时都将它发送到这个通道</li><li><code>announcements</code> 也是一个通道，我们的主Go TCP服务器将向所有节点广播最新的区块链</li><li><code>mutex</code>是一个标准变量，允许我们控制读/写和防止数据竞争</li><li><code>validators</code> 是节点的存储map，同时也会保存每个节点持有的令牌数</li></ul><h2><b>生成区块</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">func generateBlock(oldBlock Block, BPM int, address string) (Block, error) {\n​\n    var newBlock Block\n​\n    t := time.Now()\n​\n    newBlock.Index = oldBlock.Index + 1\n    newBlock.Timestamp = t.String()\n    newBlock.BPM = BPM\n    newBlock.PrevHash = oldBlock.Hash\n    newBlock.Hash = calculateBlockHash(newBlock)\n    newBlock.Validator = address\n​\n    return newBlock, nil\n}</code></pre></div><p><code>generateBlock</code> 是用来创建新块的。<code>newBlock.PrevHash</code> 存储的是上一个区块的 <code>HashnewBlock.Hash</code> 是通过 <code>calculateBlockHash(newBlock)</code> 生成的 Hash 。<code>newBlock.Validator</code> 存储的是获取记账权的节点地址</p><div class=\"highlight\"><pre><code class=\"language-text\">// SHA256 hasing\n// calculateHash is a simple SHA256 hashing function\nfunc calculateHash(s string) string {\n    h := sha256.New()\n    h.Write([]byte(s))\n    hashed := h.Sum(nil)\n    return hex.EncodeToString(hashed)\n}\n​\n//calculateBlockHash returns the hash of all block information\nfunc calculateBlockHash(block Block) string {\n    record := string(block.Index) + block.Timestamp + string(block.BPM) + block.PrevHash\n    return calculateHash(record)\n}</code></pre></div><p><code>calculateHash</code> 函数会接受一个 <code>string</code> ，并且返回一个<code>SHA256 hash</code> 。</p><p><code>calculateBlockHash</code> 是对一个 <code>block</code> 进行 <code>hash</code>，将一个 <code>block</code> 的所有字段连接到一起后，再调用 <code>calculateHash</code> 将字符串转为 <code>SHA256 hash</code> 。</p><h2><b>验证区块</b></h2><p>我们通过检查 <code>Index</code> 来确保它们按预期递增。我们也检查以确保我们 <code>PrevHash</code> 的确与 <code>Hash</code> 前一个区块相同。最后，我们希望通过在当前块上 <code>calculateBlockHash</code> 再次运行该函数来检查当前块的散列。</p><div class=\"highlight\"><pre><code class=\"language-text\">// isBlockValid makes sure block is valid by checking index\n// and comparing the hash of the previous block\nfunc isBlockValid(newBlock, oldBlock Block) bool {\n    if oldBlock.Index+1 != newBlock.Index {\n        return false\n    }\n​\n    if oldBlock.Hash != newBlock.PrevHash {\n        return false\n    }\n​\n    if calculateBlockHash(newBlock) != newBlock.Hash {\n        return false\n    }\n​\n    return true\n}</code></pre></div><h2><b>验证者</b></h2><p>当一个验证者连接到我们的TCP服务，我们需要提供一些函数达到以下目标：</p><ul><li>输入令牌的余额（之前提到过，我们不做钱包等逻辑)</li><li>接收区块链的最新广播</li><li>接收验证者赢得区块的广播信息</li><li>将自身节点添加到全局的验证者列表中（validators)</li><li>输入Block的BPM数据- BPM是每个验证者的人体脉搏值</li><li>提议创建一个新的区块</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">func handleConn(conn net.Conn) {\n    defer conn.Close()\n​\n    go func() {\n        for {\n            msg := &lt;-announcements\n            io.WriteString(conn, msg)\n        }\n    }()\n    // 验证者地址\n    var address string\n​\n    // 验证者输入他所拥有的 tokens，tokens 的值越大，越容易获得新区块的记账权\n    io.WriteString(conn, &#34;Enter token balance:&#34;)\n    scanBalance := bufio.NewScanner(conn)\n    for scanBalance.Scan() {\n        // 获取输入的数据，并将输入的值转为 int\n        balance, err := strconv.Atoi(scanBalance.Text())\n        if err != nil {\n            log.Printf(&#34;%v not a number: %v&#34;, scanBalance.Text(), err)\n            return\n        }\n        t := time.Now()\n        // 生成验证者的地址\n        address = calculateHash(t.String())\n        // 将验证者的地址和token 存储到 validators\n        validators[address] = balance\n        fmt.Println(validators)\n        break\n    }\n​\n    io.WriteString(conn, &#34;\\nEnter a new BPM:&#34;)\n​\n    scanBPM := bufio.NewScanner(conn)\n​\n    go func() {\n        for {\n            // take in BPM from stdin and add it to blockchain after conducting necessary validation\n            for scanBPM.Scan() {\n                bpm, err := strconv.Atoi(scanBPM.Text())\n                // 如果验证者试图提议一个被污染（例如伪造）的block，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表validators中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。\n                if err != nil {\n                    log.Printf(&#34;%v not a number: %v&#34;, scanBPM.Text(), err)\n                    delete(validators, address)\n                    conn.Close()\n                }\n​\n                mutex.Lock()\n                oldLastIndex := Blockchain[len(Blockchain)-1]\n                mutex.Unlock()\n​\n                // 创建新的区块，然后将其发送到 candidateBlocks 通道\n                newBlock, err := generateBlock(oldLastIndex, bpm, address)\n                if err != nil {\n                    log.Println(err)\n                    continue\n                }\n                if isBlockValid(newBlock, oldLastIndex) {\n                    candidateBlocks &lt;- newBlock\n                }\n                io.WriteString(conn, &#34;\\nEnter a new BPM:&#34;)\n            }\n        }\n    }()\n​\n    // 循环会周期性的打印出最新的区块链信息\n    for {\n        time.Sleep(time.Minute)\n        mutex.Lock()\n        output, err := json.Marshal(Blockchain)\n        mutex.Unlock()\n        if err != nil {\n            log.Fatal(err)\n        }\n        io.WriteString(conn, string(output)+&#34;\\n&#34;)\n    }\n​\n}\n​</code></pre></div><ul><li><code>io.WriteString(conn, &#34;Enter token balance:&#34;)</code>允许验证者输入他持有的令牌数量，然后，该验证者被分配一个 <code>SHA256</code>地址，随后该验证者地址和验证者的令牌数被添加到验证者列表<code>validators</code> 中。</li><li>接着我们输入BPM，验证者的脉搏值，并创建一个单独的Go协程来处理这块儿逻辑</li><li><code>delete(validators, address)</code> 如果验证者试图提议一个被污染（例如伪造）的 <code>block</code>，例如包含一个不是整数的BPM，那么程序会抛出一个错误，我们会立即从我们的验证器列表 <code>validators</code> 中删除该验证者，他们将不再有资格参与到新块的铸造过程同时丢失相应的抵押令牌。</li><li>正是因为这种抵押令牌的机制，使得PoS协议是一种更加可靠的机制。如果一个人试图伪造和破坏，那么他将被抓住，并且失去所有抵押和未来的权益，因此对于恶意者来说，是非常大的威慑。</li><li>接着，我们用 <code>generateBlock</code> 函数创建一个新的 <code>block</code>，然后将其发送到 <code>candidateBlocks</code> 通道进行进一步处理。将<code>Block</code> 发送到通道使用的语法: <code>candidateBlocks &lt;- newBlock</code></li><li>最后会循环打印出最新的区块链，这样每个验证者都能获知最新的状态。</li></ul><h2><b>选择获取记账权的节点</b></h2><p>下面是PoS的主要逻辑。我们需要编写代码以实现获胜验证者的选择;他们所持有的令牌数量越高，他们就越有可能被选为胜利者。</p><div class=\"highlight\"><pre><code class=\"language-text\">// pickWinner creates a lottery pool of validators and chooses the validator who gets to forge a block to the blockchain\n// by random selecting from the pool, weighted by amount of tokens staked\nfunc pickWinner() {\n    time.Sleep(30 * time.Second)\n    mutex.Lock()\n    temp := tempBlocks\n    mutex.Unlock()\n​\n    lotteryPool := []string{}\n    if len(temp) &gt; 0 {\n​\n        // slightly modified traditional proof of stake algorithm\n        // from all validators who submitted a block, weight them by the number of staked tokens\n        // in traditional proof of stake, validators can participate without submitting a block to be forged\n    OUTER:\n        for _, block := range temp {\n            // if already in lottery pool, skip\n            for _, node := range lotteryPool {\n                if block.Validator == node {\n                    continue OUTER\n                }\n            }\n​\n            // lock list of validators to prevent data race\n            mutex.Lock()\n            setValidators := validators\n            mutex.Unlock()\n​\n            // 获取验证者的tokens\n            k, ok := setValidators[block.Validator]\n            if ok {\n                // 向 lotteryPool 追加 k 条数据，k 代表的是当前验证者的tokens\n                for i := 0; i &lt; k; i++ {\n                    lotteryPool = append(lotteryPool, block.Validator)\n                }\n            }\n        }\n​\n        // 通过随机获得获胜节点的地址\n        s := rand.NewSource(time.Now().Unix())\n        r := rand.New(s)\n        lotteryWinner := lotteryPool[r.Intn(len(lotteryPool))]\n​\n        // 把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息\n        for _, block := range temp {\n            if block.Validator == lotteryWinner {\n                mutex.Lock()\n                Blockchain = append(Blockchain, block)\n                mutex.Unlock()\n                for _ = range validators {\n                    announcements &lt;- &#34;\\nwinning validator: &#34; + lotteryWinner + &#34;\\n&#34;\n                }\n                break\n            }\n        }\n    }\n​\n    mutex.Lock()\n    tempBlocks = []Block{}\n    mutex.Unlock()\n}</code></pre></div><ul><li>每隔30秒，我们选出一个胜利者，这样对于每个验证者来说，都有时间提议新的区块，参与到竞争中来。接着创建一个<code>lotteryPool</code>，它会持有所有验证者的地址，这些验证者都有机会成为一个胜利者。然后，对于提议块的暂存区域，我们会通过<code>if len(temp) &gt; 0</code>来判断是否已经有了被提议的区块。</li><li>在<code>OUTER FOR</code>循环中，要检查暂存区域是否和 <code>lotteryPool</code> 中存在同样的验证者，如果存在，则跳过。</li><li>在以 <code>k, ok := setValidators[block.Validator]</code>开始的代码块中，我们确保了从<code>temp</code>中取出来的验证者都是合法的，即这些验证者在验证者列表<code>validators</code>已存在。若合法，则把该验证者加入到<code>lotteryPool</code>中。</li><li>那么我们怎么根据这些验证者持有的令牌数来给予他们合适的随机权重呢？<br/></li><ul><li>首先，用验证者的令牌填充<code>lotteryPool</code>数组，例如一个验证者有100个令牌，那么在<code>lotteryPool</code>中就将有100个元素填充；如果有1个令牌，那么将仅填充1个元素。</li><li>然后，从<code>lotteryPool</code>中随机选择一个元素，元素所属的验证者即是胜利者，把胜利验证者的地址赋值给lotteryWinner。这里能够看出来，如果验证者持有的令牌越多，那么他在数组中的元素也越多，他获胜的概率就越大；同时，持有令牌很少的验证者，也是有概率获胜的。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>接着我们把获胜者的区块添加到整条区块链上，然后通知所有节点关于胜利者的消息：<code>announcements &lt;- &#34;\\nwinning validator: &#34; + lotteryWinner + &#34;\\n&#34;</code>。</li><li>最后，清空tempBlocks，以便下次提议的进行。</li></ul><h2><b>主函数</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">func main() {\n    err := godotenv.Load()\n    if err != nil {\n        log.Fatal(err)\n    }\n​\n    // 创建初始区块\n    t := time.Now()\n    genesisBlock := Block{}\n    genesisBlock = Block{0, t.String(), 0, calculateBlockHash(genesisBlock), &#34;&#34;, &#34;&#34;}\n    spew.Dump(genesisBlock)  //控制台格式化输出\n    Blockchain = append(Blockchain, genesisBlock)\n​\n    httpPort := os.Getenv(&#34;PORT&#34;)\n​\n    // 启动 TCP 服务\n    server, err := net.Listen(&#34;tcp&#34;, &#34;:&#34;+httpPort)\n    if err != nil {\n        log.Fatal(err)\n    }\n    log.Println(&#34;HTTP Server Listening on port :&#34;, httpPort)\n    defer server.Close()\n​\n    // 启动了一个Go routine 从 candidateBlocks 通道中获取提议的区块，然后填充到临时缓冲区 tempBlocks 中\n    go func() {\n        for candidate := range candidateBlocks {\n            mutex.Lock()\n            tempBlocks = append(tempBlocks, candidate)\n            mutex.Unlock()\n        }\n    }()\n​\n    // 启动了一个Go routine 完成 pickWinner 函数\n    go func() {\n        for {\n            pickWinner()\n        }\n    }()\n​\n    // 接收验证者节点的连接\n    for {\n        conn, err := server.Accept()\n        if err != nil {\n            log.Fatal(err)\n        }\n        go handleConn(conn)\n    }\n}</code></pre></div><ul><li><code>godotenv.Load()</code> 会解析 <code>.env</code> 文件并将相应的Key/Value对都放到环境变量中，通过 <code>os.Getenv</code> 获取</li><li>然后创建一个创世区块genesisBlock，形成了区块链。</li><li>接着启动了Tcp服务，等待所有验证者的连接。</li><li>启动了一个Go协程从 <code>candidateBlocks</code> 通道中获取提议的区块，然后填充到临时缓冲区 <code>tempBlocks</code> 中，最后启动了另外一个Go协程来完成 <code>pickWinner</code> 函数。</li><li>最后的for循环，用来接收验证者节点的连接。</li></ul><h2><b>运行</b></h2><p><code>go run main.go</code> 启动您的Go程序和TCP服务器，并会打印出初始区块的信息。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ go run main.go\n(main.Block) {\n Index: (int) 0,\n Timestamp: (string) (len=50) &#34;2018-05-08 16:45:27.14287 +0800 CST m=+0.000956793&#34;,\n BPM: (int) 0,\n Hash: (string) (len=64) &#34;96a296d224f285c67bee93c30f8a309157f0daa35dc5b87e410b78630a09cfc7&#34;,\n PrevHash: (string) &#34;&#34;,\n Validator: (string) &#34;&#34;\n}\n2018/05/08 16:45:27 HTTP Server Listening on port : 9000</code></pre></div><p>打开新的终端，运行 <code>nc localhost 9000</code>，输入 <code>tokens</code> , 然后输入 <code>BPM</code></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5be01f7a01104ade6f68d15d23500637_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1134\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"1134\" data-original=\"https://pic4.zhimg.com/v2-5be01f7a01104ade6f68d15d23500637_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1134&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1134\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1134\" data-original=\"https://pic4.zhimg.com/v2-5be01f7a01104ade6f68d15d23500637_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5be01f7a01104ade6f68d15d23500637_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以打开多个终端，输入不同的 <code>tokens</code> ,来检验 PoS 算法</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7a71d12b106ed3e54e0ed9a2b140214e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb\" width=\"1060\" data-original=\"https://pic3.zhimg.com/v2-7a71d12b106ed3e54e0ed9a2b140214e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1060&#39; height=&#39;562&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"562\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1060\" data-original=\"https://pic3.zhimg.com/v2-7a71d12b106ed3e54e0ed9a2b140214e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7a71d12b106ed3e54e0ed9a2b140214e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里有自己学习写的代码,已经添加注释,希望能有帮助<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/9dd3727c8093\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/9dd3727c8</span><span class=\"invisible\">093</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }
            ], 
            "comments": [
                {
                    "userName": "Liu Richard", 
                    "userLink": "https://www.zhihu.com/people/aaacdc8975d4f57d5b1e9a2a7eb3214f", 
                    "content": "<p>抄别人的东西，也 应该写个引用吧？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38300827", 
            "userName": "hello world", 
            "userLink": "https://www.zhihu.com/people/e1a2aafd35ba43051b33ea1e4a8faf9f", 
            "upvote": 3, 
            "title": "etcd分布式数据一致性框架使用入门教程", 
            "content": "<h2><b>etcd - 一个分布式一致性键值存储系统</b></h2><p>etcd是一个分布式一致性键值存储系统，用于共享配置和服务发现，专注于：</p><ul><li>简单:良好定义的，面向用户的API (gRPC)</li><li>安全： 带有可选客户端证书认证的自动TLS</li><li>快速:测试验证，每秒10000写入</li><li>可靠:使用Raft适当分布</li></ul><p>etcd是Go编写，并使用Raft一致性算法来管理高可用复制日志，架构如下图所示：</p><h2><b>下载安装</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ mkdir -p $GOPATH/src/github.com/coreos\n$ cd !$\n$ git clone https://github.com/coreos/etcd.git\n$ cd etcd\n$ ./build\n$ ./bin/etcd</code></pre></div><p>另外一种下载安装的方法：</p><p>直接下载etcd二进制 （包含etcd、etcdctl）<a href=\"https://link.zhihu.com/?target=https%3A//github.com/coreos/etcd/releases\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/coreos/etcd/</span><span class=\"invisible\">releases</span><span class=\"ellipsis\"></span></a></p><h2><b>测试</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ cd $GOPATH\n$ ./bin/etcd\n​\n$ cd $GOPATH\n$ ETCDCTL_API=3 ./bin/etcdctl put foo bar\n​\n# 输出结果显示OK，表示安装成功\nOK</code></pre></div><h2><b>搭建本地集群</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ go get github.com/mattn/goreman\n​\n$ cd $GOPATH/src/github.com/coreos/etcd\n$ goreman -f Procfile start</code></pre></div><p>查看本地集群的服务器列表</p><div class=\"highlight\"><pre><code class=\"language-text\">$ cd $GOPATH/src/github.com/coreos/etcd\n​\n$ ./bin/etcdctl member list\n​\n# 显示结果\n​\n8211f1d0f64f3269: name=infra1 peerURLs=http://127.0.0.1:12380 clientURLs=http://127.0.0.1:2379 isLeader=false\n91bc3c398fb3c146: name=infra2 peerURLs=http://127.0.0.1:22380 clientURLs=http://127.0.0.1:22379 isLeader=true\nfd422379fda50e48: name=infra3 peerURLs=http://127.0.0.1:32380 clientURLs=http://127.0.0.1:32379 isLeader=false\n​</code></pre></div><h2><b>存储数据</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">export ETCDCTL_API=3     //就在在当前终端的情况下，默认就是这个版本\n​\n$ ./bin/etcdctl put foo &#34;Hello World!&#34;\n​\nOK\n​\n$ ./bin/etcdctl get foo\n​\nfoo\nHello World!\n​\n​\n$ ./bin/etcdctl  --write-out=&#34;json&#34; get foo   //设置数个格式是json\n​\n{&#34;header&#34;:{&#34;cluster_id&#34;:17237436991929493444,&#34;member_id&#34;:9372538179322589801,&#34;revision&#34;:2,&#34;raft_term&#34;:2},&#34;kvs&#34;:[{&#34;key&#34;:&#34;Zm9v&#34;,&#34;create_revision&#34;:2,&#34;mod_revision&#34;:2,&#34;version&#34;:1,&#34;value&#34;:&#34;SGVsbG8gV29ybGQh&#34;}],&#34;count&#34;:1}</code></pre></div><h2><b>根据前缀查询</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">​\n$ ./bin/etcdctl put web1 value1\n$ ./bin/etcdctl put web2 value2\n$ ./bin/etcdctl put web3 value3\n​\n$ ./bin/etcdctl get web --prefix\n​\nweb1\nvalue1\nweb2\nvalue2\nweb3\nvalue3</code></pre></div><h2><b>删除数据</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ ./bin/etcdctl put key myvalue\n$ ./bin/etcdctl del key\n1   //1代表删除的数据是一行\n$ ./bin/etcdctl get key\n// 查询结果为空\n​\n$ ./bin/etcdctl put k1 value1\n$ ./bin/etcdctl put k2 value2\n$ ./bin/etcdctl del k --prefix\n2  //影响结果是2行\n$ ./bin/etcdctl get k --prefix\n// 查询结果为空</code></pre></div><h2><b>事务写入</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ ./bin/etcdctl put user1 bad\nOK\n$ ./bin/etcdctl txn --interactive  //\n​\ncompares:\n// 输入以下内容，输入结束按 两次回车\nvalue(&#34;user1&#34;) = &#34;bad&#34;      \n​\n//如果 user1 = bad，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n​\n//如果 user1 != bad，则执行 put user1 good\nfailure requests (get, put, del):\nput user1 good\n​\n// 运行结果，执行 success\nSUCCESS\n​\nuser1\nbad\n​\n​\n​\n$ ./bin/etcdctl txn --interactive\ncompares:\nvalue(&#34;user1&#34;) = &#34;111&#34;  \n​\n// 如果 user1 = 111，则执行 get user1 \nsuccess requests (get, put, del):\nget user1\n​\n//如果 user1 != 111，则执行 put user1 2222\nfailure requests (get, put, del):\nput user1 2222\n​\n// 运行结果，执行 failure\nFAILURE\n​\nOK\n​\n$ ./bin/etcdctl get user1\nuser1\n2222</code></pre></div><h2><b>watch</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">// 当 stock1 的数值改变（ put 方法）的时候，watch 会收到通知\n$ ./bin/etcdctl watch stock1\n​\n// 新打开终端etcd 多台服务器集群\n$ export ETCDCTL_API=3\n$ ./bin/etcdctl put stock1 1000\n​\n//在watch 终端显示\nPUT\nstock1\n1000\n​\n​\n$ ./bin/etcdctl watch stock --prefix\n$ ./bin/etcdctl put stock1 10\n$ ./bin/etcdctl put stock2 20</code></pre></div><h2><b>lease  设置访问的限制时间</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ ./bin/etcdctl lease grant 300\n# lease 326963a02758b527 granted with TTL(300s)\n​\n$ ./bin/etcdctl put sample value -- lease=326963a02758b527\nOK\n​\n$ ./bin/etcdctl get sample\n​\n$ ./bin/etcdctl lease keep-alive 326963a02758b520\n$ ./bin/etcdctl lease revoke 326963a02758b527\nlease 326963a02758b527 revoked\n​\n# or after 300 seconds\n$ ./bin/etcdctl get sample</code></pre></div><h2><b>Distributed locks</b></h2><blockquote>分布式锁，一个人操作的时候，另外一个人只能看，不能操作</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">//第一终端\n$ ./bin/etcdctl lock mutex1\nmutex1/326963a02758b52d\n​\n# 第二终端\n$ ./bin/etcdctl lock mutex1\n​\n// 当第一个终端结束了，第二个终端会显示\nmutex1/326963a02758b531\n​</code></pre></div><h2><b>Elections</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">$ ./bin/etcdctl elect one p1\n​\none/326963a02758b539\np1\n​\n​\n# another client with the same name blocks\n$ ./bin/etcdctl elect one p2\n​\n//结束第一终端，第二终端显示\none/326963a02758b53e\np2</code></pre></div><h2><b>Cluster status</b></h2><p>集群状态</p><div class=\"highlight\"><pre><code class=\"language-text\">$ ./bin/etcdctl --write-out=table endpoint status\n​\n$ ./bin/etcdctl endpoint health</code></pre></div><h2><b>Snapshot</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">./bin/etcdctl snapshot save my.db\n​\nSnapshot saved at my.db\n​\n./bin/etcdctl --write-out=table snapshot status my.db</code></pre></div><h2><b>Member</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">./bin/etcdctl member list -w table</code></pre></div><p></p><p></p>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "分布式计算", 
                    "tagLink": "https://api.zhihu.com/topics/19552071"
                }, 
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_205291110"
}
