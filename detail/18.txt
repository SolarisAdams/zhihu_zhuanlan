{
    "title": "后端面试进阶指南", 
    "description": "主要面向 Java、C++、Python 等后端研发岗位，以及 大数据、移动开发、测开 等和后端研发类似岗位的同学。同步于 https://github.com/CyC2018/CS-Notes", 
    "followers": [
        "https://www.zhihu.com/people/ke-yi-94-89-63", 
        "https://www.zhihu.com/people/chen-gao-shuang", 
        "https://www.zhihu.com/people/john-80-55", 
        "https://www.zhihu.com/people/amoresj", 
        "https://www.zhihu.com/people/zhang-yu-71-29-7", 
        "https://www.zhihu.com/people/yang-long-herman", 
        "https://www.zhihu.com/people/tou-wong-64", 
        "https://www.zhihu.com/people/yang-xi-wen-10", 
        "https://www.zhihu.com/people/yishi-qing-yuan-71", 
        "https://www.zhihu.com/people/tang-mao-lin-50", 
        "https://www.zhihu.com/people/a-ha-er", 
        "https://www.zhihu.com/people/aeternity", 
        "https://www.zhihu.com/people/DiXinkai", 
        "https://www.zhihu.com/people/juneherren", 
        "https://www.zhihu.com/people/wang-xuan-ju", 
        "https://www.zhihu.com/people/yuan-fang-91-30", 
        "https://www.zhihu.com/people/uuu-59-37", 
        "https://www.zhihu.com/people/ChangingFond", 
        "https://www.zhihu.com/people/zhe-yang-de-wo-8", 
        "https://www.zhihu.com/people/tian-tian-tian-lan-72-5", 
        "https://www.zhihu.com/people/liu-xiao-sheng-27", 
        "https://www.zhihu.com/people/ze-xchong", 
        "https://www.zhihu.com/people/gavin_alison", 
        "https://www.zhihu.com/people/liang-de-tai-yang", 
        "https://www.zhihu.com/people/li-xin-84-96-66", 
        "https://www.zhihu.com/people/chou-miao-miao-10", 
        "https://www.zhihu.com/people/roy-76-41-65", 
        "https://www.zhihu.com/people/dellt3500", 
        "https://www.zhihu.com/people/shao-lin-xiao-zi-24", 
        "https://www.zhihu.com/people/ai-zhi-wen-99", 
        "https://www.zhihu.com/people/shao-guo-liang", 
        "https://www.zhihu.com/people/fang-he-yi", 
        "https://www.zhihu.com/people/wolfwar", 
        "https://www.zhihu.com/people/linphy", 
        "https://www.zhihu.com/people/yanni-87", 
        "https://www.zhihu.com/people/guo-ming-zhou-89", 
        "https://www.zhihu.com/people/ichenxing-88", 
        "https://www.zhihu.com/people/zhu-christmas-81", 
        "https://www.zhihu.com/people/CodeInception", 
        "https://www.zhihu.com/people/jian-dan-jiu-hao-25-84", 
        "https://www.zhihu.com/people/da-xia-86-95", 
        "https://www.zhihu.com/people/mu-rong-chuan-38", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/god-thanra", 
        "https://www.zhihu.com/people/Ashitaka_L", 
        "https://www.zhihu.com/people/kan-chang-fa-77", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/mo-shang-hua-kai-78-20-72", 
        "https://www.zhihu.com/people/zwl-41", 
        "https://www.zhihu.com/people/sheng-zhu-77", 
        "https://www.zhihu.com/people/tao-wu-sheng", 
        "https://www.zhihu.com/people/huitoushian", 
        "https://www.zhihu.com/people/bu-ding-long", 
        "https://www.zhihu.com/people/xiao-hua-69-57-6", 
        "https://www.zhihu.com/people/whiteyork", 
        "https://www.zhihu.com/people/bu-xiang-qiao-dai-ma-de-cheng-xu-yuan-76", 
        "https://www.zhihu.com/people/xiao-qian-52-32", 
        "https://www.zhihu.com/people/wu-jing-yi-65-96", 
        "https://www.zhihu.com/people/zhou-zhi-gang-28", 
        "https://www.zhihu.com/people/ai-ke-78", 
        "https://www.zhihu.com/people/wang-ming-hao-7", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/lazy-c", 
        "https://www.zhihu.com/people/di-jing-85", 
        "https://www.zhihu.com/people/lin-dong-jiang-zhi-5-81", 
        "https://www.zhihu.com/people/dong-bin-75", 
        "https://www.zhihu.com/people/hewenning", 
        "https://www.zhihu.com/people/xiao-bing-ling-54", 
        "https://www.zhihu.com/people/lu-zai-jiao-xia-36", 
        "https://www.zhihu.com/people/hu-wei-16-4", 
        "https://www.zhihu.com/people/root-22-59", 
        "https://www.zhihu.com/people/willvi-79", 
        "https://www.zhihu.com/people/zi-lu-2-53", 
        "https://www.zhihu.com/people/ienterprise", 
        "https://www.zhihu.com/people/beauty-58-30", 
        "https://www.zhihu.com/people/jeson-47", 
        "https://www.zhihu.com/people/gle-goo-42"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/69358772", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "后端面试进阶指南 目录 📚", 
            "content": "<p>本专栏同步于个人博客：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CyC2018/CS-Notes</a>，该博客已有 66k Star，在 Github 上排二十名左右：<a href=\"https://link.zhihu.com/?target=https%3A//gitstar-ranking.com/repositories\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gitstar-ranking</a>。</p><h2>💯 面试相关</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/56655579\" class=\"internal\">从春招惨败到秋招收获 BAT OFFER</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56655484\" class=\"internal\">一文帮你理清面试知识点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56655602\" class=\"internal\">写好技术简历</a></li></ul><h2>✏️ 算法</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/69346234\" class=\"internal\">剑指 Offer 题解</a></li></ul><h2>💻 操作系统</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E6%2593%258D%25E4%25BD%259C%25E7%25B3%25BB%25E7%25BB%259F%2520-%2520%25E7%259B%25AE%25E5%25BD%2595.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">计算机操作系统</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/Linux.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Linux</a></li></ul><h2>☁️ 网络</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764284\" class=\"internal\">计算机网络</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764595\" class=\"internal\">HTTP</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68529777\" class=\"internal\">Socket</a></li></ul><h2>🎨 面向对象</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/%25E9%259D%25A2%25E5%2590%2591%25E5%25AF%25B9%25E8%25B1%25A1%25E6%2580%259D%25E6%2583%25B3.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">面向对象思想</a></li></ul><h2>💾 数据库</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/68500259\" class=\"internal\">数据库系统原理</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68500444\" class=\"internal\">SQL</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68500647\" class=\"internal\">Leetcode-Database 题解</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68500693\" class=\"internal\">MySQL</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/Redis.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Redis</a></li></ul><h2>☕️ Java</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/68499453\" class=\"internal\">Java 基础</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/59850978\" class=\"internal\">Java 容器</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/59850678\" class=\"internal\">Java 并发</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68499946\" class=\"internal\">Java 虚拟机</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68500017\" class=\"internal\">Java I/O</a></li></ul><h2>💡 系统设计</h2><ul><li><a href=\"https://zhuanlan.zhihu.com/p/68500774\" class=\"internal\">系统设计基础</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68500828\" class=\"internal\">分布式</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68528961\" class=\"internal\">集群</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68529177\" class=\"internal\">攻击技术</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68529269\" class=\"internal\">缓存</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68529374\" class=\"internal\">消息队列</a></li></ul><h2>🔧 工具</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/Git.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Git</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/Docker.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/%25E6%259E%2584%25E5%25BB%25BA%25E5%25B7%25A5%25E5%2585%25B7.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">构建工具</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/CS-Notes/blob/master/notes/%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">正则表达式</a></li></ul>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69346234", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解", 
            "content": "<p></p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764745\" class=\"internal\">3-9</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845\" class=\"internal\">10-19</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926\" class=\"internal\">20-29</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988\" class=\"internal\">30-39</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978\" class=\"internal\">40-49</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998\" class=\"internal\">50-59</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022\" class=\"internal\">60-68</a></li></ul><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69346022", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解 60-68", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#60-n-%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0\" class=\"internal\">60. n 个骰子的点数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#61-%E6%89%91%E5%85%8B%E7%89%8C%E9%A1%BA%E5%AD%90\" class=\"internal\">61. 扑克牌顺子</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0\" class=\"internal\">62. 圆圈中最后剩下的数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6\" class=\"internal\">63. 股票的最大利润</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#64-%E6%B1%82-123n\" class=\"internal\">64. 求 1+2+3+...+n</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95\" class=\"internal\">65. 不用加减乘除做加法</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84\" class=\"internal\">66. 构建乘积数组</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0\" class=\"internal\">67. 把字符串转换成整数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69346022/edit#68-%E6%A0%91%E4%B8%AD%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E4%BD%8E%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88\" class=\"internal\">68. 树中两个节点的最低公共祖先</a> </li></ul><h2>60. n 个骰子的点数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.lintcode.com/en/problem/dices-sum/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lintcode</a></p><h2>题目描述</h2><p>把 n 个骰子仍在地上，求点数和为 s 的概率。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-48b04f57e153733b4f1430bafc7d86e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"132\" class=\"origin_image zh-lightbox-thumb\" width=\"491\" data-original=\"https://pic1.zhimg.com/v2-48b04f57e153733b4f1430bafc7d86e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;491&#39; height=&#39;132&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"132\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"491\" data-original=\"https://pic1.zhimg.com/v2-48b04f57e153733b4f1430bafc7d86e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-48b04f57e153733b4f1430bafc7d86e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><h3>动态规划</h3><p>使用一个二维数组 dp 存储点数出现的次数，其中 dp[i][j] 表示前 i 个骰子产生点数 j 的次数。</p><p>空间复杂度：O(N2)</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Double</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">dicesSum</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">face</span> <span class=\"o\">=</span> <span class=\"n\">6</span><span class=\"o\">;</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">pointNum</span> <span class=\"o\">=</span> <span class=\"n\">face</span> <span class=\"o\">*</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">long</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">long</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">pointNum</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">face</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">pointNum</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>     <span class=\"cm\">/* 使用 i 个骰子最小点数为 i */</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">face</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n                <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">k</span><span class=\"o\">];</span>\n\n    <span class=\"kd\">final</span> <span class=\"kt\">double</span> <span class=\"n\">totalNum</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">6</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">);</span>\n    <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Double</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">pointNum</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">AbstractMap</span><span class=\"o\">.</span><span class=\"na\">SimpleEntry</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">/</span> <span class=\"n\">totalNum</span><span class=\"o\">));</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>动态规划 + 旋转数组</h3><p>空间复杂度：O(N)</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Double</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">dicesSum</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">face</span> <span class=\"o\">=</span> <span class=\"n\">6</span><span class=\"o\">;</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">pointNum</span> <span class=\"o\">=</span> <span class=\"n\">face</span> <span class=\"o\">*</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">long</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">long</span><span class=\"o\">[</span><span class=\"n\">2</span><span class=\"o\">][</span><span class=\"n\">pointNum</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">face</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>                                     <span class=\"cm\">/* 旋转标记 */</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++,</span> <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">-</span> <span class=\"n\">flag</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">pointNum</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">flag</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>                          <span class=\"cm\">/* 旋转数组清零 */</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">pointNum</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">face</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">j</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n                <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">flag</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">1</span> <span class=\"o\">-</span> <span class=\"n\">flag</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">k</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">final</span> <span class=\"kt\">double</span> <span class=\"n\">totalNum</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">6</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">);</span>\n    <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Double</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">pointNum</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">AbstractMap</span><span class=\"o\">.</span><span class=\"na\">SimpleEntry</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">1</span> <span class=\"o\">-</span> <span class=\"n\">flag</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">/</span> <span class=\"n\">totalNum</span><span class=\"o\">));</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>61. 扑克牌顺子</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/762836f4d43d43ca9deb273b3de8e1f4%3FtpId%3D13%26tqId%3D11198%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>五张牌，其中大小鬼为癞子，牌面为 0。判断这五张牌是否能组成顺子。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-daa3590e7a189dfc557eef8d2c30441e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"439\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb\" width=\"439\" data-original=\"https://pic3.zhimg.com/v2-daa3590e7a189dfc557eef8d2c30441e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;439&#39; height=&#39;208&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"439\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"439\" data-original=\"https://pic3.zhimg.com/v2-daa3590e7a189dfc557eef8d2c30441e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-daa3590e7a189dfc557eef8d2c30441e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isContinuous</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&lt;</span> <span class=\"n\">5</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">// 统计癞子数量\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">num</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n\n    <span class=\"c1\">// 使用癞子去补全不连续的顺子\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">cnt</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"n\">cnt</span> <span class=\"o\">-=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">cnt</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>62. 圆圈中最后剩下的数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/f78a359491e64a50bce2d89cff857eb6%3FtpId%3D13%26tqId%3D11199%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>让小朋友们围成一个大圈。然后，随机指定一个数 m，让编号为 0 的小朋友开始报数。每次喊到 m-1 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始，继续 0...m-1 报数 .... 这样下去 .... 直到剩下最后一个小朋友，可以不用表演。</p><h2>解题思路</h2><p>约瑟夫环，圆圈长度为 n 的解可以看成长度为 n-1 的解再加上报数的长度 m。因为是圆圈，所以最后需要对 n 取余。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">LastRemaining_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>     <span class=\"cm\">/* 特殊输入的处理 */</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>     <span class=\"cm\">/* 递归返回条件 */</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">LastRemaining_Solution</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>63. 股票的最大利润</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/best-time-to-buy-and-sell-stock/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode</a></p><h2>题目描述</h2><p>可以有一次买入和一次卖出，买入必须在前。求最大收益。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b2970e333ceb91a6098267200351e3c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"259\" class=\"content_image\" width=\"314\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;314&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"259\" class=\"content_image lazy\" width=\"314\" data-actualsrc=\"https://pic3.zhimg.com/v2-b2970e333ceb91a6098267200351e3c6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>使用贪心策略，假设第 i 轮进行卖出操作，买入操作价格应该在 i 之前并且价格最低。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">prices</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prices</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">prices</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">soFarMin</span> <span class=\"o\">=</span> <span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">maxProfit</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">soFarMin</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">soFarMin</span><span class=\"o\">,</span> <span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"n\">maxProfit</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">maxProfit</span><span class=\"o\">,</span> <span class=\"n\">prices</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">-</span> <span class=\"n\">soFarMin</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">maxProfit</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>64. 求 1+2+3+...+n</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1%3FtpId%3D13%26tqId%3D11200%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句 A ? B : C。</p><h2>解题思路</h2><p>使用递归解法最重要的是指定返回条件，但是本题无法直接使用 if 语句来指定返回条件。</p><p>条件与 &amp;&amp; 具有短路原则，即在第一个条件语句为 false 的情况下不会去执行第二个条件语句。利用这一特性，将递归的返回条件取非然后作为 &amp;&amp; 的第一个条件语句，递归的主体转换为第二个条件语句，那么当递归的返回条件为 true 的情况下就不会执行递归的主体部分，递归返回。</p><p>本题的递归返回条件为 n &lt;= 0，取非后就是 n &gt; 0；递归的主体部分为 sum += Sum_Solution(n - 1)，转换为条件语句后就是 (sum += Sum_Solution(n - 1)) &gt; 0。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Sum_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">((</span><span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">Sum_Solution</span><span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">))</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>65. 不用加减乘除做加法</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/59ac416b4b944300b617d4f7f111b215%3FtpId%3D13%26tqId%3D11201%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>写一个函数，求两个整数之和，要求不得使用 +、-、*、/ 四则运算符号。</p><h2>解题思路</h2><p>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</p><p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Add</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">b</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">?</span> <span class=\"n\">a</span> <span class=\"o\">:</span> <span class=\"n\">Add</span><span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">^</span> <span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">&amp;</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>66. 构建乘积数组</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/94a4d381a68b47b7a8bed86f2975db46%3FtpId%3D13%26tqId%3D11204%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>给定一个数组 A[0, 1,..., n-1]，请构建一个数组 B[0, 1,..., n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。要求不能使用除法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-058cd373a0cc9fa92bfb46a73d5a1120_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"323\" data-rawheight=\"281\" class=\"content_image\" width=\"323\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;323&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"323\" data-rawheight=\"281\" class=\"content_image lazy\" width=\"323\" data-actualsrc=\"https://pic1.zhimg.com/v2-058cd373a0cc9fa92bfb46a73d5a1120_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">multiply</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">product</span> <span class=\"o\">*=</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">i</span><span class=\"o\">++)</span>       <span class=\"cm\">/* 从左往右累乘 */</span>\n        <span class=\"n\">B</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">product</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">product</span> <span class=\"o\">*=</span> <span class=\"n\">A</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">i</span><span class=\"o\">--)</span>  <span class=\"cm\">/* 从右往左累乘 */</span>\n        <span class=\"n\">B</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">*=</span> <span class=\"n\">product</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">B</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>67. 把字符串转换成整数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e%3FtpId%3D13%26tqId%3D11202%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>将一个字符串转换成一个整数，字符串不是一个合法的数值则返回 0，要求不能使用字符串转换整数的库函数。</p><div class=\"highlight\"><pre><code class=\"language-html\">Iuput:\n+2147483647\n1a33\n\nOutput:\n2147483647\n0</code></pre></div><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">StrToInt</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">str</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span> <span class=\"n\">isNegative</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;-&#39;</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;+&#39;</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;-&#39;</span><span class=\"o\">))</span>  <span class=\"cm\">/* 符号判定 */</span>\n            <span class=\"k\">continue</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"sc\">&#39;0&#39;</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">&gt;</span> <span class=\"sc\">&#39;9&#39;</span><span class=\"o\">)</span>                <span class=\"cm\">/* 非法输入 */</span>\n            <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">ret</span> <span class=\"o\">*</span> <span class=\"n\">10</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">-</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">isNegative</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"n\">ret</span> <span class=\"o\">:</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>68. 树中两个节点的最低公共祖先</h2><h2>解题思路</h2><h3>二叉查找树</h3><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode : 235. Lowest Common Ancestor of a Binary Search Tree</a></p><p>二叉查找树中，两个节点 p, q 的公共祖先 root 满足 root.val &gt;= p.val &amp;&amp; root.val &lt;= q.val。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bd6a013613ac0e745043785b2132f18c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"424\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"424\" data-original=\"https://pic1.zhimg.com/v2-bd6a013613ac0e745043785b2132f18c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;424&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"424\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"424\" data-original=\"https://pic1.zhimg.com/v2-bd6a013613ac0e745043785b2132f18c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-bd6a013613ac0e745043785b2132f18c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&gt;</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>普通二叉树</h3><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode : 236. Lowest Common Ancestor of a Binary Tree</a></p><p>在左右子树中查找是否存在 p 或者 q，如果 p 和 q 分别在两个子树中，那么就说明根节点就是最低公共祖先。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6c6c21a976f21b293af2f6eb3da218bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"486\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"486\" data-original=\"https://pic2.zhimg.com/v2-6c6c21a976f21b293af2f6eb3da218bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;486&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"486\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"486\" data-original=\"https://pic2.zhimg.com/v2-6c6c21a976f21b293af2f6eb3da218bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6c6c21a976f21b293af2f6eb3da218bd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">q</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"n\">p</span> <span class=\"o\">||</span> <span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"n\">q</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">lowestCommonAncestor</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">p</span><span class=\"o\">,</span> <span class=\"n\">q</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">left</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">right</span> <span class=\"o\">:</span> <span class=\"n\">right</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">left</span> <span class=\"o\">:</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69345998", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "剑指 Offer 题解 50-59", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6%E4%BD%8D%E7%BD%AE\" class=\"internal\">50. 第一个只出现一次的字符位置</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9\" class=\"internal\">51. 数组中的逆序对</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E7%BB%93%E7%82%B9\" class=\"internal\">52. 两个链表的第一个公共结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#53-%E6%95%B0%E5%AD%97%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0\" class=\"internal\">53. 数字在排序数组中出现的次数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#54-%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E7%9A%84%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9\" class=\"internal\">54. 二叉查找树的第 K 个结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#551-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6\" class=\"internal\">55.1 二叉树的深度</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#552-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">55.2 平衡二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#56-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97\" class=\"internal\">56. 数组中只出现一次的数字</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#571-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97\" class=\"internal\">57.1 和为 S 的两个数字</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#572-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97\" class=\"internal\">57.2 和为 S 的连续正数序列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#581-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F%E5%88%97\" class=\"internal\">58.1 翻转单词顺序列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#582-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2\" class=\"internal\">58.2 左旋转字符串</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345998/edit#59-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC\" class=\"internal\">59. 滑动窗口的最大值</a> </li></ul><h2>50. 第一个只出现一次的字符位置</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c%3FtpId%3D13%26tqId%3D11187%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>在一个字符串中找到第一个只出现一次的字符，并返回它的位置。</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: abacc\nOutput: b</code></pre></div><h2>解题思路</h2><p>最直观的解法是使用 HashMap 对出现次数进行统计，但是考虑到要统计的字符范围有限，因此可以使用整型数组代替 HashMap，从而将空间复杂度由 O(N) 降低为 O(1)。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">FirstNotRepeatingChar</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">cnts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">256</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">cnts</span><span class=\"o\">[</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)]++;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cnts</span><span class=\"o\">[</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)]</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>以上实现的空间复杂度还不是最优的。考虑到只需要找到只出现一次的字符，那么需要统计的次数信息只有 0,1,更大，使用两个比特位就能存储这些信息。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">FirstNotRepeatingChar2</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">BitSet</span> <span class=\"n\">bs1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BitSet</span><span class=\"o\">(</span><span class=\"n\">256</span><span class=\"o\">);</span>\n    <span class=\"n\">BitSet</span> <span class=\"n\">bs2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BitSet</span><span class=\"o\">(</span><span class=\"n\">256</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">:</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">bs1</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">bs2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">))</span>\n            <span class=\"n\">bs1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>     <span class=\"c1\">// 0 0 -&gt; 0 1\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bs1</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">bs2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">))</span>\n            <span class=\"n\">bs2</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>     <span class=\"c1\">// 0 1 -&gt; 1 1\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">bs1</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">bs2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">))</span>  <span class=\"c1\">// 0 1\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>51. 数组中的逆序对</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5%3FtpId%3D13%26tqId%3D11188%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">tmp</span><span class=\"o\">;</span>  <span class=\"c1\">// 在这里声明辅助数组，而不是在 merge() 递归函数中声明\n</span><span class=\"c1\"></span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">InversePairs</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n    <span class=\"n\">mergeSort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">cnt</span> <span class=\"o\">%</span> <span class=\"n\">1000000007</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">mergeSort</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"n\">mergeSort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">);</span>\n    <span class=\"n\">mergeSort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n    <span class=\"n\">merge</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">m</span> <span class=\"o\">||</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n            <span class=\"n\">tmp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">++];</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n            <span class=\"n\">tmp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">++];</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span>\n            <span class=\"n\">tmp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">++];</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">tmp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">++];</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cnt</span> <span class=\"o\">+=</span> <span class=\"n\">m</span> <span class=\"o\">-</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>  <span class=\"c1\">// nums[i] &gt; nums[j]，说明 nums[i...mid] 都大于 nums[j]\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n        <span class=\"n\">k</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">h</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>52. 两个链表的第一个公共结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6ab1d9a29e88450685099d45c9e31e46%3FtpId%3D13%26tqId%3D11189%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e9a1e3287939b45c46d3db9a7a0933c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"229\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic3.zhimg.com/v2-e9a1e3287939b45c46d3db9a7a0933c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"229\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic3.zhimg.com/v2-e9a1e3287939b45c46d3db9a7a0933c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e9a1e3287939b45c46d3db9a7a0933c6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p><p>当访问链表 A 的指针访问到链表尾部时，令它从链表 B 的头部重新开始访问链表 B；同样地，当访问链表 B 的指针访问到链表尾部时，令它从链表 A 的头部重新开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">FindFirstCommonNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">pHead1</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"n\">pHead2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">l1</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">,</span> <span class=\"n\">l2</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l1</span> <span class=\"o\">!=</span> <span class=\"n\">l2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">l1</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">l1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">pHead2</span> <span class=\"o\">:</span> <span class=\"n\">l1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">l2</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">l2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">pHead1</span> <span class=\"o\">:</span> <span class=\"n\">l2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">l1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>53. 数字在排序数组中出现的次数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/70610bf967994b22bb1c26f9ae901fa2%3FtpId%3D13%26tqId%3D11190%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><div class=\"highlight\"><pre><code class=\"language-html\">Input:\nnums = 1, 2, 3, 3, 3, 3, 4, 6\nK = 3\n\nOutput:\n4</code></pre></div><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">GetNumberOfK</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">K</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">||</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">first</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"n\">last</span> <span class=\"o\">-</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">binarySearch</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">K</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">K</span><span class=\"o\">)</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">l</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>54. 二叉查找树的第 K 个结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/ef068f602dde4d28aab2b210e859150a%3FtpId%3D13%26tqId%3D11215%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><p>利用二叉查找树中序遍历有序的特点。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">TreeNode</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">KthNode</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">pRoot</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">pRoot</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">inOrder</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">cnt</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n    <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cnt</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>55.1 二叉树的深度</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/435fb86331474282a3499955f0a41e8b%3FtpId%3D13%26tqId%3D11191%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6281f25c576cdbe08c5dca6770ab02e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"589\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb\" width=\"589\" data-original=\"https://pic3.zhimg.com/v2-6281f25c576cdbe08c5dca6770ab02e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;589&#39; height=&#39;375&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"589\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"589\" data-original=\"https://pic3.zhimg.com/v2-6281f25c576cdbe08c5dca6770ab02e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6281f25c576cdbe08c5dca6770ab02e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">TreeDepth</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"n\">1</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">TreeDepth</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">),</span> <span class=\"n\">TreeDepth</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">));</span>\n<span class=\"o\">}</span></code></pre></div><h2>55.2 平衡二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8b3b95850edb4115918ecebdf1b4d222%3FtpId%3D13%26tqId%3D11192%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>平衡二叉树左右子树高度差不超过 1。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-aa36f34b9ae8c619aecd0c8b2bd02ca3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"413\" class=\"content_image\" width=\"409\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;409&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"413\" class=\"content_image lazy\" width=\"409\" data-actualsrc=\"https://pic4.zhimg.com/v2-aa36f34b9ae8c619aecd0c8b2bd02ca3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"n\">isBalanced</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">IsBalanced_Solution</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">height</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">isBalanced</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">height</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">isBalanced</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">abs</span><span class=\"o\">(</span><span class=\"n\">left</span> <span class=\"o\">-</span> <span class=\"n\">right</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"n\">isBalanced</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">1</span> <span class=\"o\">+</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>56. 数组中只出现一次的数字</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/e02fdb54d7524710a7d664d082bb7811%3FtpId%3D13%26tqId%3D11193%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次，找出这两个数。</p><h2>解题思路</h2><p>两个不相等的元素在位级表示上必定会有一位存在不同，将数组的所有元素异或得到的结果为不存在重复的两个元素异或的结果。</p><p>diff &amp;= -diff 得到出 diff 最右侧不为 0 的位，也就是不存在重复的两个元素在位级表示上最右侧不同的那一位，利用这一位就可以将两个元素区分开来。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">FindNumsAppearOnce</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">num1</span><span class=\"o\">[],</span> <span class=\"kt\">int</span> <span class=\"n\">num2</span><span class=\"o\">[])</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">diff</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span>\n        <span class=\"n\">diff</span> <span class=\"o\">^=</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"n\">diff</span> <span class=\"o\">&amp;=</span> <span class=\"o\">-</span><span class=\"n\">diff</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">num</span> <span class=\"o\">&amp;</span> <span class=\"n\">diff</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">num1</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">^=</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">num2</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">^=</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>57.1 和为 S 的两个数字</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/390da4f7a00f44bea7c2f3d19491311b%3FtpId%3D13%26tqId%3D11195%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个递增排序的数组和一个数字 S，在数组中查找两个数，使得他们的和正好是 S。如果有多对数字的和等于 S，输出两个数的乘积最小的。</p><h2>解题思路</h2><p>使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。</p><ul><li>如果两个指针指向元素的和 sum == target，那么得到要求的结果；</li><li>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；</li><li>如果 sum &lt; target，移动较小的元素，使 sum 变大一些。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">FindNumbersWithSum</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">array</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cur</span> <span class=\"o\">==</span> <span class=\"n\">sum</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]));</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cur</span> <span class=\"o\">&lt;</span> <span class=\"n\">sum</span><span class=\"o\">)</span>\n            <span class=\"n\">i</span><span class=\"o\">++;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">j</span><span class=\"o\">--;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"o\">}</span></code></pre></div><h2>57.2 和为 S 的连续正数序列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/c451a3fd84b64cb19485dad758a55ebe%3FtpId%3D13%26tqId%3D11194%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输出所有和为 S 的连续正数序列。</p><p>例如和为 100 的连续序列有：</p><div class=\"highlight\"><pre><code class=\"language-text\">[9, 10, 11, 12, 13, 14, 15, 16]\n[18, 19, 20, 21, 22]。</code></pre></div><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">FindContinuousSequence</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">curSum</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">end</span> <span class=\"o\">&lt;</span> <span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">curSum</span> <span class=\"o\">&gt;</span> <span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">curSum</span> <span class=\"o\">-=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n            <span class=\"n\">start</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">curSum</span> <span class=\"o\">&lt;</span> <span class=\"n\">sum</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">end</span><span class=\"o\">++;</span>\n            <span class=\"n\">curSum</span> <span class=\"o\">+=</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">end</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n                <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span>\n            <span class=\"n\">curSum</span> <span class=\"o\">-=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n            <span class=\"n\">start</span><span class=\"o\">++;</span>\n            <span class=\"n\">end</span><span class=\"o\">++;</span>\n            <span class=\"n\">curSum</span> <span class=\"o\">+=</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>58.1 翻转单词顺序列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3%3FtpId%3D13%26tqId%3D11197%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><div class=\"highlight\"><pre><code class=\"language-html\">Input:\n&#34;I am a student.&#34;\n\nOutput:\n&#34;student. a am I&#34;</code></pre></div><h2>解题思路</h2><p>题目应该有一个隐含条件，就是不能用额外的空间。虽然 Java 的题目输入参数为 String 类型，需要先创建一个字符数组使得空间复杂度为 O(N)，但是正确的参数类型应该和原书一样，为字符数组，并且只能使用该字符数组的空间。任何使用了额外空间的解法在面试时都会大打折扣，包括递归解法。</p><p>正确的解法应该是和书上一样，先旋转每个单词，再旋转整个字符串。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">ReverseSentence</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">==</span> <span class=\"n\">n</span> <span class=\"o\">||</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39; &#39;</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">j</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">reverse</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n        <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">++,</span> <span class=\"n\">j</span><span class=\"o\">--);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">c</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>58.2 左旋转字符串</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec%3FtpId%3D13%26tqId%3D11196%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><div class=\"highlight\"><pre><code class=\"language-html\">Input:\nS=&#34;abcXYZdef&#34;\nK=3\n\nOutput:\n&#34;XYZdefabc&#34;</code></pre></div><h2>解题思路</h2><p>先将 &#34;abc&#34; 和 &#34;XYZdef&#34; 分别翻转，得到 &#34;cbafedZYX&#34;，然后再把整个字符串翻转得到 &#34;XYZdefabc&#34;。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">LeftRotateString</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">())</span>\n        <span class=\"k\">return</span> <span class=\"n\">str</span><span class=\"o\">;</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n    <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"n\">reverse</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">reverse</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n        <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">++,</span> <span class=\"n\">j</span><span class=\"o\">--);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">char</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>59. 滑动窗口的最大值</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/1624bc35a45c42c0bc17d17fa0cba788%3FtpId%3D13%26tqId%3D11217%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p><p>例如，如果输入数组 {2, 3, 4, 2, 6, 2, 5, 1} 及滑动窗口的大小 3，那么一共存在 6 个滑动窗口，他们的最大值分别为 {4, 4, 6, 6, 6, 5}。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">maxInWindows</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">num</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"n\">num</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">||</span> <span class=\"n\">size</span> <span class=\"o\">&lt;</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n    <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">heap</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;&gt;((</span><span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">o2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">o2</span> <span class=\"o\">-</span> <span class=\"n\">o1</span><span class=\"o\">);</span>  <span class=\"cm\">/* 大顶堆 */</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">num</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n    <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">());</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">num</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++,</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>            <span class=\"cm\">/* 维护一个大小为 size 的大顶堆 */</span>\n        <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">num</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">num</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]);</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">heap</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69345978", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解 40-49", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#40-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0\" class=\"internal\">40. 最小的 K 个数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#411-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0\" class=\"internal\">41.1 数据流中的中位数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#412-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%97%E7%AC%A6\" class=\"internal\">41.2 字符流中第一个不重复的字符</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C\" class=\"internal\">42. 连续子数组的最大和</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#43-%E4%BB%8E-1-%E5%88%B0-n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0\" class=\"internal\">43. 从 1 到 n 整数中 1 出现的次数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E6%9F%90%E4%B8%80%E4%BD%8D%E6%95%B0%E5%AD%97\" class=\"internal\">44. 数字序列中的某一位数字</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0\" class=\"internal\">45. 把数组排成最小的数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2\" class=\"internal\">46. 把数字翻译成字符串</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC\" class=\"internal\">47. 礼物的最大价值</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2\" class=\"internal\">48. 最长不含重复字符的子字符串</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/69345978/edit#49-%E4%B8%91%E6%95%B0\" class=\"internal\">49. 丑数</a> </li></ul><h2>40. 最小的 K 个数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6a296eb82cf844ca8539b57c23e6e9bf%3FtpId%3D13%26tqId%3D11182%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><h3>快速选择</h3><ul><li>复杂度：O(N) + O(1)</li><li>只有当允许修改数组元素时才可以使用</li></ul><p>快速排序的 partition() 方法，会返回一个整数 j 使得 a[l..j-1] 小于等于 a[j]，且 a[j+1..h] 大于等于 a[j]，此时 a[j] 就是数组的第 j 大元素。可以利用这个特性找出数组的第 K 个元素，这种找第 K 个元素的算法称为快速选择算法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">GetLeastNumbers_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">||</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n    <span class=\"n\">findKthSmallest</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">k</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"cm\">/* findKthSmallest 会改变数组，使得前 k 个数都是最小的 k 个数 */</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">findKthSmallest</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">partition</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n            <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">partition</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>     <span class=\"cm\">/* 切分元素 */</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">h</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">!=</span> <span class=\"n\">h</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"o\">[++</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">!=</span> <span class=\"n\">l</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"o\">[--</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">j</span><span class=\"o\">)</span>\n            <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">j</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>大小为 K 的最小堆</h3><ul><li>复杂度：O(NlogK) + O(K)</li><li>特别适合处理海量数据</li></ul><p>应该使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p><p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">GetLeastNumbers_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">||</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">maxHeap</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;&gt;((</span><span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">o2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">o2</span> <span class=\"o\">-</span> <span class=\"n\">o1</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">maxHeap</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">num</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">maxHeap</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span>\n            <span class=\"n\">maxHeap</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">maxHeap</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>41.1 数据流中的中位数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1%3FtpId%3D13%26tqId%3D11216%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/* 大顶堆，存储左半边元素 */</span>\n<span class=\"kd\">private</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;&gt;((</span><span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">o2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">o2</span> <span class=\"o\">-</span> <span class=\"n\">o1</span><span class=\"o\">);</span>\n<span class=\"cm\">/* 小顶堆，存储右半边元素，并且右半边元素都大于左半边 */</span>\n<span class=\"kd\">private</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"cm\">/* 当前数据流读入的元素个数 */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Insert</span><span class=\"o\">(</span><span class=\"n\">Integer</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/* 插入要保证两个堆存于平衡状态 */</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"cm\">/* N 为偶数的情况下插入到右半边。\n</span><span class=\"cm\">         * 因为右半边元素都要大于左半边，但是新插入的元素不一定比左半边元素来的大，\n</span><span class=\"cm\">         * 因此需要先将元素插入左半边，然后利用左半边为大顶堆的特点，取出堆顶元素即为最大元素，此时插入右半边 */</span>\n        <span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">N</span><span class=\"o\">++;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">Double</span> <span class=\"nf\">GetMedian</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">())</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">.</span><span class=\"na\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">double</span><span class=\"o\">)</span> <span class=\"n\">right</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>41.2 字符流中第一个不重复的字符</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/00de97733b8e4f97a3fb5c680ee10720%3FtpId%3D13%26tqId%3D11207%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符 &#34;go&#34; 时，第一个只出现一次的字符是 &#34;g&#34;。当从该字符流中读出前六个字符“google&#34; 时，第一个只出现一次的字符是 &#34;l&#34;。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">cnts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">256</span><span class=\"o\">];</span>\n<span class=\"kd\">private</span> <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Character</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Insert</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">ch</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">cnts</span><span class=\"o\">[</span><span class=\"n\">ch</span><span class=\"o\">]++;</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">ch</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">cnts</span><span class=\"o\">[</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()]</span> <span class=\"o\">&gt;</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">char</span> <span class=\"nf\">FirstAppearingOnce</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">?</span> <span class=\"sc\">&#39;#&#39;</span> <span class=\"o\">:</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>42. 连续子数组的最大和</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/459bd355da1549fa8a49e350bf3df484%3FtpId%3D13%26tqId%3D11183%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>{6, -3, -2, 7, -15, 1, 2, 2}，连续子数组的最大和为 8（从第 0 个开始，到第 3 个为止）。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">FindGreatestSumOfSubArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">greatestSum</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MIN_VALUE</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">sum</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span> <span class=\"o\">?</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">sum</span> <span class=\"o\">+</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n        <span class=\"n\">greatestSum</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">greatestSum</span><span class=\"o\">,</span> <span class=\"n\">sum</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">greatestSum</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>43. 从 1 到 n 整数中 1 出现的次数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/bd7f978302044eee894445e244c7eee6%3FtpId%3D13%26tqId%3D11184%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">NumberOf1Between1AndN_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">m</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">m</span> <span class=\"o\">*=</span> <span class=\"n\">10</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">/</span> <span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">%</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n        <span class=\"n\">cnt</span> <span class=\"o\">+=</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">8</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">10</span> <span class=\"o\">*</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">%</span> <span class=\"n\">10</span> <span class=\"o\">==</span> <span class=\"n\">1</span> <span class=\"o\">?</span> <span class=\"n\">b</span> <span class=\"o\">+</span> <span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><blockquote><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/number-of-digit-one/discuss/64381/4%2B-lines-O%28log-n%29-C%2B%2BJavaPython\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode : 233. Number of Digit One</a><br/> </blockquote><h2>44. 数字序列中的某一位数字</h2><h2>题目描述</h2><p>数字以 0123456789101112131415... 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getDigitAtIndex</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">place</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>  <span class=\"c1\">// 1 表示个位，2 表示 十位...\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">amount</span> <span class=\"o\">=</span> <span class=\"n\">getAmountOfPlace</span><span class=\"o\">(</span><span class=\"n\">place</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">totalAmount</span> <span class=\"o\">=</span> <span class=\"n\">amount</span> <span class=\"o\">*</span> <span class=\"n\">place</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">totalAmount</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"n\">getDigitAtIndex</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">place</span><span class=\"o\">);</span>\n        <span class=\"n\">index</span> <span class=\"o\">-=</span> <span class=\"n\">totalAmount</span><span class=\"o\">;</span>\n        <span class=\"n\">place</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * place 位数的数字组成的字符串长度\n</span><span class=\"cm\"> * 10, 90, 900, ...\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">getAmountOfPlace</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">place</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">,</span> <span class=\"n\">place</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">*</span> <span class=\"n\">9</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * place 位数的起始数字\n</span><span class=\"cm\"> * 0, 10, 100, ...\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">getBeginNumberOfPlace</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">place</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">,</span> <span class=\"n\">place</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 在 place 位数组成的字符串中，第 index 个数\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">getDigitAtIndex</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">place</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">beginNumber</span> <span class=\"o\">=</span> <span class=\"n\">getBeginNumberOfPlace</span><span class=\"o\">(</span><span class=\"n\">place</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">shiftNumber</span> <span class=\"o\">=</span> <span class=\"n\">index</span> <span class=\"o\">/</span> <span class=\"n\">place</span><span class=\"o\">;</span>\n    <span class=\"n\">String</span> <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">beginNumber</span> <span class=\"o\">+</span> <span class=\"n\">shiftNumber</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">index</span> <span class=\"o\">%</span> <span class=\"n\">place</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">number</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>45. 把数组排成最小的数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8fecd3f8ba334add803bf2a06af1b993%3FtpId%3D13%26tqId%3D11185%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p><h2>解题思路</h2><p>可以看成是一个排序问题，在比较两个字符串 S1 和 S2 的大小时，应该比较的是 S1+S2 和 S2+S1 的大小，如果 S1+S2 &lt; S2+S1，那么应该把 S1 排在前面，否则应该把 S2 排在前面。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">PrintMinNumber</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">numbers</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">numbers</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">numbers</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">numbers</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">nums</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">numbers</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">s2</span><span class=\"o\">)</span> <span class=\"o\">-&gt;</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">s2</span><span class=\"o\">).</span><span class=\"na\">compareTo</span><span class=\"o\">(</span><span class=\"n\">s2</span> <span class=\"o\">+</span> <span class=\"n\">s1</span><span class=\"o\">));</span>\n    <span class=\"n\">String</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span>\n        <span class=\"n\">ret</span> <span class=\"o\">+=</span> <span class=\"n\">str</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>46. 把数字翻译成字符串</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/decode-ways/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode</a></p><h2>题目描述</h2><p>给定一个数字，按照如下规则翻译成字符串：1 翻译成“a”，2 翻译成“b”... 26 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 abbeh，lbeh，aveh，abyh，lyh。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">numDecodings</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;0&#39;</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">one</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">));</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">one</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">)</span>\n            <span class=\"k\">continue</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">two</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">));</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">two</span> <span class=\"o\">&lt;=</span> <span class=\"n\">26</span><span class=\"o\">)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>47. 礼物的最大价值</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/questionTerminal/72a99e28381a407991f2c96d8cb238ab\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>在一个 m*n 的棋盘的每一个格都放有一个礼物，每个礼物都有一定价值（大于 0）。从左上角开始拿礼物，每次向右或向下移动一格，直到右下角结束。给定一个棋盘，求拿到礼物的最大价值。例如，对于如下棋盘</p><div class=\"highlight\"><pre><code class=\"language-text\">1    10   3    8\n12   2    9    6\n5    7    4    11\n3    7    16   5</code></pre></div><p>礼物的最大价值为 1+12+5+7+7+16+5=53。</p><h2>解题思路</h2><p>应该用动态规划求解，而不是深度优先搜索，深度优先搜索过于复杂，不是最优解。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getMost</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">values</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">values</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">values</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">values</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">value</span> <span class=\"o\">:</span> <span class=\"n\">values</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">value</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">])</span> <span class=\"o\">+</span> <span class=\"n\">value</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>48. 最长不含重复字符的子字符串</h2><h2>题目描述</h2><p>输入一个字符串（只包含 a\\~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">longestSubStringWithoutDuplication</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">curLen</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">maxLen</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">preIndexs</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">26</span><span class=\"o\">];</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">preIndexs</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">curI</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">curI</span> <span class=\"o\">&lt;</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">curI</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">curI</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">preI</span> <span class=\"o\">=</span> <span class=\"n\">preIndexs</span><span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">preI</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">||</span> <span class=\"n\">curI</span> <span class=\"o\">-</span> <span class=\"n\">preI</span> <span class=\"o\">&gt;</span> <span class=\"n\">curLen</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">curLen</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">maxLen</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">maxLen</span><span class=\"o\">,</span> <span class=\"n\">curLen</span><span class=\"o\">);</span>\n            <span class=\"n\">curLen</span> <span class=\"o\">=</span> <span class=\"n\">curI</span> <span class=\"o\">-</span> <span class=\"n\">preI</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">preIndexs</span><span class=\"o\">[</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">curI</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">maxLen</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">maxLen</span><span class=\"o\">,</span> <span class=\"n\">curLen</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">maxLen</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>49. 丑数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6aa9e04fc3794f68acf8778237ba065b%3FtpId%3D13%26tqId%3D11186%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>把只包含因子 2、3 和 5 的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。习惯上我们把 1 当做是第一个丑数。求按从小到大的顺序的第 N 个丑数。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">GetUglyNumber_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">N</span> <span class=\"o\">&lt;=</span> <span class=\"n\">6</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">N</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i2</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">i3</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">i5</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">N</span><span class=\"o\">];</span>\n    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">next2</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i2</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">next3</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i3</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">next5</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i5</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"n\">5</span><span class=\"o\">;</span>\n        <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">next2</span><span class=\"o\">,</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">next3</span><span class=\"o\">,</span> <span class=\"n\">next5</span><span class=\"o\">));</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">next2</span><span class=\"o\">)</span>\n            <span class=\"n\">i2</span><span class=\"o\">++;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">next3</span><span class=\"o\">)</span>\n            <span class=\"n\">i3</span><span class=\"o\">++;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">next5</span><span class=\"o\">)</span>\n            <span class=\"n\">i5</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">N</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764988", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解 30-39", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#30-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88\" class=\"internal\">30. 包含 min 函数的栈</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97\" class=\"internal\">31. 栈的压入、弹出序列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#321-%E4%BB%8E%E4%B8%8A%E5%BE%80%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">32.1 从上往下打印二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#322-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C\" class=\"internal\">32.2 把二叉树打印成多行</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#323-%E6%8C%89%E4%B9%8B%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">32.3 按之字形顺序打印二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97\" class=\"internal\">33. 二叉搜索树的后序遍历序列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84\" class=\"internal\">34. 二叉树中和为某一值的路径</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6\" class=\"internal\">35. 复杂链表的复制</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\" class=\"internal\">36. 二叉搜索树与双向链表</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">37. 序列化二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97\" class=\"internal\">38. 字符串的排列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764988/edit#39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97\" class=\"internal\">39. 数组中出现次数超过一半的数字</a> </li></ul><h2>30. 包含 min 函数的栈</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49%3FtpId%3D13%26tqId%3D11173%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">dataStack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"kd\">private</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">minStack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">dataStack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n    <span class=\"n\">minStack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">minStack</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">?</span> <span class=\"n\">node</span> <span class=\"o\">:</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">minStack</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">(),</span> <span class=\"n\">node</span><span class=\"o\">));</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">dataStack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n    <span class=\"n\">minStack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">top</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">dataStack</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">min</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">minStack</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>31. 栈的压入、弹出序列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106%3FtpId%3D13%26tqId%3D11174%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。</p><p>例如序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序列的弹出序列。</p><h2>解题思路</h2><p>使用一个栈来模拟压入弹出操作。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">IsPopOrder</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pushSequence</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">popSequence</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">pushSequence</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">pushIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">popIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">pushIndex</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">pushIndex</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">pushSequence</span><span class=\"o\">[</span><span class=\"n\">pushIndex</span><span class=\"o\">]);</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">popIndex</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> \n                <span class=\"o\">&amp;&amp;</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">popSequence</span><span class=\"o\">[</span><span class=\"n\">popIndex</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n            <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n            <span class=\"n\">popIndex</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>32.1 从上往下打印二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/7fe2212963db4790b57431d9ed259701%3FtpId%3D13%26tqId%3D11175%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><p>例如，以下二叉树层次遍历的结果为：1,2,3,4,5,6,7</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-383f3b31bd1818a11345669da1e515b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"436\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"436\" data-original=\"https://pic1.zhimg.com/v2-383f3b31bd1818a11345669da1e515b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;436&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"436\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"436\" data-original=\"https://pic1.zhimg.com/v2-383f3b31bd1818a11345669da1e515b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-383f3b31bd1818a11345669da1e515b0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>使用队列来进行层次遍历。</p><p>不需要使用两个队列分别存储当前层的节点和下一层的节点，因为在开始遍历一层的节点时，当前队列中的节点数就是当前层的节点数，只要控制遍历这么多节点数，就能保证这次遍历的都是当前层的节点。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">PrintFromTopToBottom</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">TreeNode</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">--</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">TreeNode</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"k\">continue</span><span class=\"o\">;</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>32.2 把二叉树打印成多行</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/445c44d982d04483b04a54f298796288%3FtpId%3D13%26tqId%3D11213%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>和上题几乎一样。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">Print</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">pRoot</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">TreeNode</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">pRoot</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">--</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">TreeNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"k\">continue</span><span class=\"o\">;</span>\n            <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>32.3 按之字形顺序打印二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0%3FtpId%3D13%26tqId%3D11212%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">Print</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">pRoot</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">TreeNode</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">pRoot</span><span class=\"o\">);</span>\n    <span class=\"kt\">boolean</span> <span class=\"n\">reverse</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">--</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">TreeNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"k\">continue</span><span class=\"o\">;</span>\n            <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n            <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">reverse</span><span class=\"o\">)</span>\n            <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">reverse</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span>\n        <span class=\"n\">reverse</span> <span class=\"o\">=</span> <span class=\"o\">!</span><span class=\"n\">reverse</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>33. 二叉搜索树的后序遍历序列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/a861533d45854474ac791d90e447bafd%3FtpId%3D13%26tqId%3D11176%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。假设输入的数组的任意两个数字都互不相同。</p><p>例如，下图是后序遍历序列 1,3,2 所对应的二叉搜索树。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8266fb847353371e5a8bcfeae46ad87f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"251\" data-rawheight=\"249\" class=\"content_image\" width=\"251\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;251&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"251\" data-rawheight=\"249\" class=\"content_image lazy\" width=\"251\" data-actualsrc=\"https://pic4.zhimg.com/v2-8266fb847353371e5a8bcfeae46ad87f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">VerifySquenceOfBST</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">sequence</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequence</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">sequence</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">verify</span><span class=\"o\">(</span><span class=\"n\">sequence</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">sequence</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">verify</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">sequence</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">first</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">last</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">-</span> <span class=\"n\">first</span> <span class=\"o\">&lt;=</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">rootVal</span> <span class=\"o\">=</span> <span class=\"n\">sequence</span><span class=\"o\">[</span><span class=\"n\">last</span><span class=\"o\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">cutIndex</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cutIndex</span> <span class=\"o\">&lt;</span> <span class=\"n\">last</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">sequence</span><span class=\"o\">[</span><span class=\"n\">cutIndex</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">rootVal</span><span class=\"o\">)</span>\n        <span class=\"n\">cutIndex</span><span class=\"o\">++;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">cutIndex</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">last</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sequence</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">rootVal</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">verify</span><span class=\"o\">(</span><span class=\"n\">sequence</span><span class=\"o\">,</span> <span class=\"n\">first</span><span class=\"o\">,</span> <span class=\"n\">cutIndex</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">verify</span><span class=\"o\">(</span><span class=\"n\">sequence</span><span class=\"o\">,</span> <span class=\"n\">cutIndex</span><span class=\"o\">,</span> <span class=\"n\">last</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>34. 二叉树中和为某一值的路径</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/b736e784e3e34731af99065031301bca%3FtpId%3D13%26tqId%3D11177%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p><p>下图的二叉树有两条和为 22 的路径：10, 5, 7 和 10, 12</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f0a6da5382120c68a9c0ce3a419cb167_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"371\" class=\"content_image\" width=\"350\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;350&#39; height=&#39;371&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"371\" class=\"content_image lazy\" width=\"350\" data-actualsrc=\"https://pic4.zhimg.com/v2-f0a6da5382120c68a9c0ce3a419cb167_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">FindPath</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;());</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">backtracking</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">node</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">path</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n    <span class=\"n\">target</span> <span class=\"o\">-=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">path</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">path</span><span class=\"o\">);</span>\n        <span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">path</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">path</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>35. 复杂链表的复制</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/f836b2c43afc4b35ad6adc41ec941dba%3FtpId%3D13%26tqId%3D11178%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的 head。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">RandomListNode</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">label</span><span class=\"o\">;</span>\n    <span class=\"n\">RandomListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">RandomListNode</span> <span class=\"n\">random</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n    <span class=\"n\">RandomListNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">label</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">label</span> <span class=\"o\">=</span> <span class=\"n\">label</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-29e7660af125d2231eb34293b1e78593_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"543\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb\" width=\"543\" data-original=\"https://pic4.zhimg.com/v2-29e7660af125d2231eb34293b1e78593_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;543&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"543\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"543\" data-original=\"https://pic4.zhimg.com/v2-29e7660af125d2231eb34293b1e78593_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-29e7660af125d2231eb34293b1e78593_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>第一步，在每个节点的后面插入复制的节点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-21ee57da0a87b0ac49f64b7bcf3435a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1076\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"1076\" data-original=\"https://pic4.zhimg.com/v2-21ee57da0a87b0ac49f64b7bcf3435a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1076&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1076\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1076\" data-original=\"https://pic4.zhimg.com/v2-21ee57da0a87b0ac49f64b7bcf3435a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-21ee57da0a87b0ac49f64b7bcf3435a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第二步，对复制节点的 random 链接进行赋值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f34494f6d9ebe2437da721da937ad22_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"256\" class=\"origin_image zh-lightbox-thumb\" width=\"1062\" data-original=\"https://pic3.zhimg.com/v2-9f34494f6d9ebe2437da721da937ad22_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1062&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"256\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1062\" data-original=\"https://pic3.zhimg.com/v2-9f34494f6d9ebe2437da721da937ad22_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f34494f6d9ebe2437da721da937ad22_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第三步，拆分。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f665362398a87296e903b5048ebb0829_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1193\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"1193\" data-original=\"https://pic2.zhimg.com/v2-f665362398a87296e903b5048ebb0829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1193&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1193\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1193\" data-original=\"https://pic2.zhimg.com/v2-f665362398a87296e903b5048ebb0829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f665362398a87296e903b5048ebb0829_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">RandomListNode</span> <span class=\"nf\">Clone</span><span class=\"o\">(</span><span class=\"n\">RandomListNode</span> <span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"c1\">// 插入新节点\n</span><span class=\"c1\"></span>    <span class=\"n\">RandomListNode</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cur</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">RandomListNode</span> <span class=\"n\">clone</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">RandomListNode</span><span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">label</span><span class=\"o\">);</span>\n        <span class=\"n\">clone</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">clone</span><span class=\"o\">;</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">clone</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 建立 random 链接\n</span><span class=\"c1\"></span>    <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cur</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">RandomListNode</span> <span class=\"n\">clone</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">random</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">clone</span><span class=\"o\">.</span><span class=\"na\">random</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">random</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">clone</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 拆分\n</span><span class=\"c1\"></span>    <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"n\">RandomListNode</span> <span class=\"n\">pCloneHead</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">RandomListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">pCloneHead</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>36. 二叉搜索树与双向链表</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5%3FtpId%3D13%26tqId%3D11179%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eaf36964f9981bf1193eac8bbbae2a10_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"710\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb\" width=\"710\" data-original=\"https://pic1.zhimg.com/v2-eaf36964f9981bf1193eac8bbbae2a10_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;710&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"710\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"710\" data-original=\"https://pic1.zhimg.com/v2-eaf36964f9981bf1193eac8bbbae2a10_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-eaf36964f9981bf1193eac8bbbae2a10_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">TreeNode</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"n\">TreeNode</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">Convert</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">inOrder</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n    <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pre</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">pre</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>37. 序列化二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84%3FtpId%3D13%26tqId%3D11214%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">deserializeStr</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">Serialize</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;#&#34;</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span> <span class=\"o\">+</span> <span class=\"n\">Serialize</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span> <span class=\"o\">+</span> <span class=\"n\">Serialize</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">Deserialize</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">deserializeStr</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">Deserialize</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">Deserialize</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">deserializeStr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">deserializeStr</span><span class=\"o\">.</span><span class=\"na\">indexOf</span><span class=\"o\">(</span><span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">String</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">index</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">?</span> <span class=\"n\">deserializeStr</span> <span class=\"o\">:</span> <span class=\"n\">deserializeStr</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">);</span>\n    <span class=\"n\">deserializeStr</span> <span class=\"o\">=</span> <span class=\"n\">index</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">?</span> <span class=\"s\">&#34;&#34;</span> <span class=\"o\">:</span> <span class=\"n\">deserializeStr</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"s\">&#34;#&#34;</span><span class=\"o\">))</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TreeNode</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">);</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">Deserialize</span><span class=\"o\">();</span>\n    <span class=\"n\">t</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">Deserialize</span><span class=\"o\">();</span>\n    <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>38. 字符串的排列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7%3FtpId%3D13%26tqId%3D11180%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a, b, c 所能排列出来的所有字符串 abc, acb, bac, bca, cab 和 cba。</p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"nf\">Permutation</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">toCharArray</span><span class=\"o\">();</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">);</span>\n    <span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">],</span> <span class=\"k\">new</span> <span class=\"n\">StringBuilder</span><span class=\"o\">());</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">backtracking</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">hasUsed</span><span class=\"o\">,</span> <span class=\"n\">StringBuilder</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">());</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">chars</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">hasUsed</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span>\n            <span class=\"k\">continue</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">!=</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">hasUsed</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">])</span> <span class=\"cm\">/* 保证不重复 */</span>\n            <span class=\"k\">continue</span><span class=\"o\">;</span>\n        <span class=\"n\">hasUsed</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">,</span> <span class=\"n\">hasUsed</span><span class=\"o\">,</span> <span class=\"n\">s</span><span class=\"o\">);</span>\n        <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">deleteCharAt</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">hasUsed</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>39. 数组中出现次数超过一半的数字</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163%3FtpId%3D13%26tqId%3D11181%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><p>多数投票问题，可以利用 Boyer-Moore Majority Vote Algorithm 来解决这个问题，使得时间复杂度为 O(N)。</p><p>使用 cnt 来统计一个元素出现的次数，当遍历到的元素和统计元素相等时，令 cnt++，否则令 cnt--。如果前面查找了 i 个元素，且 cnt == 0，说明前 i 个元素没有 majority，或者有 majority，但是出现的次数少于 i / 2 ，因为如果多于 i / 2 的话 cnt 就一定不会为 0 。此时剩下的 n - i 个元素中，majority 的数目依然多于 (n - i) / 2，因此继续查找就能找出 majority。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">MoreThanHalfNum_Solution</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">majority</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">majority</span> <span class=\"o\">?</span> <span class=\"n\">cnt</span> <span class=\"o\">+</span> <span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"n\">cnt</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cnt</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">majority</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n            <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">==</span> <span class=\"n\">majority</span><span class=\"o\">)</span>\n            <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n    <span class=\"k\">return</span> <span class=\"n\">cnt</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">/</span> <span class=\"n\">2</span> <span class=\"o\">?</span> <span class=\"n\">majority</span> <span class=\"o\">:</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764926", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解 20-29", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2\" class=\"internal\">20. 表示数值的字符串</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2\" class=\"internal\">21. 调整数组顺序使奇数位于偶数前面</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9\" class=\"internal\">22. 链表中倒数第 K 个结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#23-%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E7%BB%93%E7%82%B9\" class=\"internal\">23. 链表中环的入口结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8\" class=\"internal\">24. 反转链表</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8\" class=\"internal\">25. 合并两个排序的链表</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84\" class=\"internal\">26. 树的子结构</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F\" class=\"internal\">27. 二叉树的镜像</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">28 对称的二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764926/edit#29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5\" class=\"internal\">29. 顺时针打印矩阵</a> </li></ul><h2>20. 表示数值的字符串</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6f8c901d091949a5837e24bb82a731f2%3FtpId%3D13%26tqId%3D11206%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><div class=\"highlight\"><pre><code class=\"language-text\">true\n\n&#34;+100&#34;\n&#34;5e2&#34;\n&#34;-123&#34;\n&#34;3.1416&#34;\n&#34;-1E-16&#34;\nfalse\n\n&#34;12e&#34;\n&#34;1a3.14&#34;\n&#34;1.2.3&#34;\n&#34;+-5&#34;\n&#34;12e+4.3&#34;</code></pre></div><h2>解题思路</h2><p>使用正则表达式进行匹配。</p><div class=\"highlight\"><pre><code class=\"language-html\">[]  ： 字符集合\n()  ： 分组\n?   ： 重复 0 ~ 1 次\n+   ： 重复 1 ~ n 次\n*   ： 重复 0 ~ n 次\n.   ： 任意字符\n\\\\. ： 转义后的 .\n\\\\d ： 数字\npublic boolean isNumeric(char[] str) {\n    if (str == null || str.length == 0)\n        return false;\n    return new String(str).matches(&#34;[+-]?\\\\d*(\\\\.\\\\d+)?([eE][+-]?\\\\d+)?&#34;);\n}</code></pre></div><h2>21. 调整数组顺序使奇数位于偶数前面</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/beb5aa231adc45b2a5dcc5b62c93f593%3FtpId%3D13%26tqId%3D11166%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>需要保证奇数和奇数，偶数和偶数之间的相对位置不变，这和书本不太一样。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d2365af564dd8f9d72b0ffb4de99b27f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"269\" data-rawheight=\"277\" class=\"content_image\" width=\"269\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;269&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"269\" data-rawheight=\"277\" class=\"content_image lazy\" width=\"269\" data-actualsrc=\"https://pic4.zhimg.com/v2-d2365af564dd8f9d72b0ffb4de99b27f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>方法一：创建一个新数组，时间复杂度 O(N)，空间复杂度 O(N)。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">reOrderArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 奇数个数\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">oddCnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">isEven</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">))</span>\n            <span class=\"n\">oddCnt</span><span class=\"o\">++;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">copy</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">oddCnt</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">:</span> <span class=\"n\">copy</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">num</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n            <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEven</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>方法二：使用冒泡思想，每次都当前偶数上浮到当前最右边。时间复杂度 O(N2)，空间复杂度 O(1)，时间换空间。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">reOrderArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">N</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isEven</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">isEven</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">]))</span> <span class=\"o\">{</span>\n                <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEven</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>22. 链表中倒数第 K 个结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a%3FtpId%3D13%26tqId%3D11167%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><p>设链表的长度为 N。设置两个指针 P1 和 P2，先让 P1 移动 K 个节点，则还有 N - K 个节点可以移动。此时让 P1 和 P2 同时移动，可以知道当 P1 移动到链表结尾时，P2 移动到第 N - K 个节点处，该位置就是倒数第 K 个节点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e0b5753ba289e93b8b10d285d0666f53_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"737\" data-original=\"https://pic4.zhimg.com/v2-e0b5753ba289e93b8b10d285d0666f53_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;737&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"737\" data-original=\"https://pic4.zhimg.com/v2-e0b5753ba289e93b8b10d285d0666f53_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e0b5753ba289e93b8b10d285d0666f53_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">FindKthToTail</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">P1</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">P1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">k</span><span class=\"o\">--</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">P1</span> <span class=\"o\">=</span> <span class=\"n\">P1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">P2</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">P1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">P1</span> <span class=\"o\">=</span> <span class=\"n\">P1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">P2</span> <span class=\"o\">=</span> <span class=\"n\">P2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">P2</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>23. 链表中环的入口结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4%3FtpId%3D13%26tqId%3D11208%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>一个链表中包含环，请找出该链表的环的入口结点。要求不能使用额外的空间。</p><h2>解题思路</h2><p>使用双指针，一个指针 fast 每次移动两个节点，一个指针 slow 每次移动一个节点。因为存在环，所以两个指针必定相遇在环中的某个节点上。假设相遇点在下图的 z1 位置，此时 fast 移动的节点数为 x+2y+z，slow 为 x+y，由于 fast 速度比 slow 快一倍，因此 x+2y+z=2(x+y)，得到 x=z。</p><p>在相遇点，slow 要到环的入口点还需要移动 z 个节点，如果让 fast 重新从头开始移动，并且速度变为每次移动一个节点，那么它到环入口点还需要移动 x 个节点。在上面已经推导出 x=z，因此 fast 和 slow 将在环入口点相遇。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-651a721a04171c99d9559c20f7628a0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"721\" data-original=\"https://pic1.zhimg.com/v2-651a721a04171c99d9559c20f7628a0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;721&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"721\" data-original=\"https://pic1.zhimg.com/v2-651a721a04171c99d9559c20f7628a0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-651a721a04171c99d9559c20f7628a0c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">EntryNodeOfLoop</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">,</span> <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">do</span> <span class=\"o\">{</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">slow</span> <span class=\"o\">!=</span> <span class=\"n\">fast</span><span class=\"o\">);</span>\n    <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">slow</span> <span class=\"o\">!=</span> <span class=\"n\">fast</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">slow</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>24. 反转链表</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/75e878df47f24fdc9dc3e400ec6058ca%3FtpId%3D13%26tqId%3D11168%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>解题思路</h2><h3>递归</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">ReverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">newHead</span> <span class=\"o\">=</span> <span class=\"n\">ReverseList</span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">);</span>\n    <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">newHead</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>迭代</h3><p>使用头插法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">ReverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">newList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ListNode</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">newList</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">newList</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">newList</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>25. 合并两个排序的链表</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/d8b6b4358f774294a89de2a6ac4d9337%3FtpId%3D13%26tqId%3D11169%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9e0f5a4efd2efb72f270a689492735f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"647\" data-rawheight=\"237\" class=\"origin_image zh-lightbox-thumb\" width=\"647\" data-original=\"https://pic1.zhimg.com/v2-9e0f5a4efd2efb72f270a689492735f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;647&#39; height=&#39;237&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"647\" data-rawheight=\"237\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"647\" data-original=\"https://pic1.zhimg.com/v2-9e0f5a4efd2efb72f270a689492735f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9e0f5a4efd2efb72f270a689492735f4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><h3>递归</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">Merge</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">list1</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"n\">list2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;=</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">Merge</span><span class=\"o\">(</span><span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">,</span> <span class=\"n\">list2</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">Merge</span><span class=\"o\">(</span><span class=\"n\">list1</span><span class=\"o\">,</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>迭代</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">Merge</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">list1</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"n\">list2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ListNode</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">list2</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;=</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n            <span class=\"n\">list1</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n            <span class=\"n\">list2</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list2</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>26. 树的子结构</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6e196c44c7004d15b1610b9afca8bd88%3FtpId%3D13%26tqId%3D11170%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0b02e856024a56c3051c784cce51d0b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-0b02e856024a56c3051c784cce51d0b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;307&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-0b02e856024a56c3051c784cce51d0b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0b02e856024a56c3051c784cce51d0b4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">HasSubtree</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root1</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">root2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">root2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">isSubtreeWithRoot</span><span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">,</span> <span class=\"n\">root2</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"n\">HasSubtree</span><span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">root2</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"n\">HasSubtree</span><span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">root2</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isSubtreeWithRoot</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root1</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">root2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">!=</span> <span class=\"n\">root2</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">isSubtreeWithRoot</span><span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">root2</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">isSubtreeWithRoot</span><span class=\"o\">(</span><span class=\"n\">root1</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">root2</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>27. 二叉树的镜像</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/564f4c26aa584921bc75623e48ca3011%3FtpId%3D13%26tqId%3D11171%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Mirror</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"n\">Mirror</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n    <span class=\"n\">Mirror</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">;</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">;</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>28 对称的二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/ff05d44dfdb04e1d83bdbdab320efbcb%3FtpId%3D13%26tqId%3D11211%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;224&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"224\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1074bc4b63b5a735eb4ef58f057c6853_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">boolean</span> <span class=\"nf\">isSymmetrical</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">pRoot</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pRoot</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">isSymmetrical</span><span class=\"o\">(</span><span class=\"n\">pRoot</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">pRoot</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kt\">boolean</span> <span class=\"nf\">isSymmetrical</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">t1</span><span class=\"o\">,</span> <span class=\"n\">TreeNode</span> <span class=\"n\">t2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">t2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">t2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">!=</span> <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">isSymmetrical</span><span class=\"o\">(</span><span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">isSymmetrical</span><span class=\"o\">(</span><span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>29. 顺时针打印矩阵</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a%3FtpId%3D13%26tqId%3D11172%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>下图的矩阵顺时针打印结果为：1, 2, 3, 4, 8, 12, 16, 15, 14, 13, 9, 5, 6, 7, 11, 10</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-661d99e666148103d1bc36ebd4cd0f45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"294\" data-rawheight=\"335\" class=\"content_image\" width=\"294\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;294&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"294\" data-rawheight=\"335\" class=\"content_image lazy\" width=\"294\" data-actualsrc=\"https://pic2.zhimg.com/v2-661d99e666148103d1bc36ebd4cd0f45_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">printMatrix</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">r1</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">r2</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">c1</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">c2</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c1</span> <span class=\"o\">&lt;=</span> <span class=\"n\">c2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">c1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">c2</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r1</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">r1</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r2</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">c2</span><span class=\"o\">]);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r1</span> <span class=\"o\">!=</span> <span class=\"n\">r2</span><span class=\"o\">)</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">c2</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">c1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span>\n                <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r2</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c1</span> <span class=\"o\">!=</span> <span class=\"n\">c2</span><span class=\"o\">)</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">r2</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">r1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">--)</span>\n                <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">c1</span><span class=\"o\">]);</span>\n        <span class=\"n\">r1</span><span class=\"o\">++;</span> <span class=\"n\">r2</span><span class=\"o\">--;</span> <span class=\"n\">c1</span><span class=\"o\">++;</span> <span class=\"n\">c2</span><span class=\"o\">--;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764845", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "剑指 Offer 题解 10-19", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#101-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\" class=\"internal\">10.1 斐波那契数列</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#102-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96\" class=\"internal\">10.2 矩形覆盖</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#103-%E8%B7%B3%E5%8F%B0%E9%98%B6\" class=\"internal\">10.3 跳台阶</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#104-%E5%8F%98%E6%80%81%E8%B7%B3%E5%8F%B0%E9%98%B6\" class=\"internal\">10.4 变态跳台阶</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97\" class=\"internal\">11. 旋转数组的最小数字</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84\" class=\"internal\">12. 矩阵中的路径</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4\" class=\"internal\">13. 机器人的运动范围</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#14-%E5%89%AA%E7%BB%B3%E5%AD%90\" class=\"internal\">14. 剪绳子</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD-1-%E7%9A%84%E4%B8%AA%E6%95%B0\" class=\"internal\">15. 二进制中 1 的个数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9\" class=\"internal\">16. 数值的整数次方</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#17-%E6%89%93%E5%8D%B0%E4%BB%8E-1-%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84-n-%E4%BD%8D%E6%95%B0\" class=\"internal\">17. 打印从 1 到最大的 n 位数</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#181-%E5%9C%A8-o1-%E6%97%B6%E9%97%B4%E5%86%85%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9\" class=\"internal\">18.1 在 O(1) 时间内删除链表节点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#182-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E7%BB%93%E7%82%B9\" class=\"internal\">18.2 删除链表中重复的结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764845/edit#19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D\" class=\"internal\">19. 正则表达式匹配</a> </li></ul><h2>10.1 斐波那契数列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3%3FtpId%3D13%26tqId%3D11160%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>求斐波那契数列的第 n 项，n &lt;= 39。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ee9a13c64aa14d66e245ad2259b20430_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-ee9a13c64aa14d66e245ad2259b20430_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-ee9a13c64aa14d66e245ad2259b20430_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ee9a13c64aa14d66e245ad2259b20430_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>如果使用递归求解，会重复计算一些子问题。例如，计算 f(4) 需要计算 f(3) 和 f(2)，计算 f(3) 需要计算 f(2) 和 f(1)，可以看到 f(2) 被重复计算了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d1466ad75bfc9547e6352ecee7301ac3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-d1466ad75bfc9547e6352ecee7301ac3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;610&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-d1466ad75bfc9547e6352ecee7301ac3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d1466ad75bfc9547e6352ecee7301ac3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>递归是将一个问题划分成多个子问题求解，动态规划也是如此，但是动态规划会把子问题的解缓存起来，从而避免重复求解子问题。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Fibonacci</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">fib</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span>\n    <span class=\"k\">return</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><p>考虑到第 i 项只与第 i-1 和第 i-2 项有关，因此只需要存储前两项的值就能求解第 i 项，从而将空间复杂度由 O(N) 降低为 O(1)。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Fibonacci</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">fib</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">fib</span> <span class=\"o\">=</span> <span class=\"n\">pre2</span> <span class=\"o\">+</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">fib</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>由于待求解的 n 小于 40，因此可以将前 40 项的结果先进行计算，之后就能以 O(1) 时间复杂度得到第 n 项的值。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">fib</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">40</span><span class=\"o\">];</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Solution</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">fib</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Fibonacci</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">fib</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>10.2 矩形覆盖</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/72a5a919508a4251859fb2cfb987a0e6%3FtpId%3D13%26tqId%3D11163%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>我们可以用 2*1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2*1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7a662579a815828a7e175142e178d328_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"453\" data-thumbnail=\"https://pic1.zhimg.com/v2-7a662579a815828a7e175142e178d328_b.jpg\" class=\"content_image\" width=\"177\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;177&#39; height=&#39;453&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"177\" data-rawheight=\"453\" data-thumbnail=\"https://pic1.zhimg.com/v2-7a662579a815828a7e175142e178d328_b.jpg\" class=\"content_image lazy\" width=\"177\" data-actualsrc=\"https://pic1.zhimg.com/v2-7a662579a815828a7e175142e178d328_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>当 n 为 1 时，只有一种覆盖方法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d2b2b221e3d702541f5036bcd57741e3_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"159\" data-rawheight=\"244\" class=\"content_image\" width=\"159\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;159&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"159\" data-rawheight=\"244\" class=\"content_image lazy\" width=\"159\" data-actualsrc=\"https://pic4.zhimg.com/v2-d2b2b221e3d702541f5036bcd57741e3_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当 n 为 2 时，有两种覆盖方法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0e537ff338acae6c238ac72d8cb39c1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"260\" class=\"content_image\" width=\"314\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;314&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"314\" data-rawheight=\"260\" class=\"content_image lazy\" width=\"314\" data-actualsrc=\"https://pic3.zhimg.com/v2-0e537ff338acae6c238ac72d8cb39c1e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>要覆盖 2*n 的大矩形，可以先覆盖 2*1 的矩形，再覆盖 2*(n-1) 的矩形；或者先覆盖 2*2 的矩形，再覆盖 2*(n-2) 的矩形。而覆盖 2*(n-1) 和 2*(n-2) 的矩形可以看成子问题。该问题的递推公式如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;651&#39; height=&#39;145&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">RectCover</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">2</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">pre2</span> <span class=\"o\">+</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>10.3 跳台阶</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4%3FtpId%3D13%26tqId%3D11161%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f3989297ae8963dc82bfbc7454972c4f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"596\" data-original=\"https://pic4.zhimg.com/v2-f3989297ae8963dc82bfbc7454972c4f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;596&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"596\" data-original=\"https://pic4.zhimg.com/v2-f3989297ae8963dc82bfbc7454972c4f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f3989297ae8963dc82bfbc7454972c4f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>当 n = 1 时，只有一种跳法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a33d59988474a7ba603621d60fd61f21_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"271\" class=\"content_image\" width=\"370\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;370&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"271\" class=\"content_image lazy\" width=\"370\" data-actualsrc=\"https://pic2.zhimg.com/v2-a33d59988474a7ba603621d60fd61f21_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当 n = 2 时，有两种跳法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-140e7005187a714779e84db26d4008a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-140e7005187a714779e84db26d4008a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-140e7005187a714779e84db26d4008a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-140e7005187a714779e84db26d4008a4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>跳 n 阶台阶，可以先跳 1 阶台阶，再跳 n-1 阶台阶；或者先跳 2 阶台阶，再跳 n-2 阶台阶。而 n-1 和 n-2 阶台阶的跳法可以看成子问题，该问题的递推公式为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;651&#39; height=&#39;145&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"651\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"651\" data-original=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-12de2e2de1129184b762177de051bf48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">JumpFloor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">2</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">pre2</span> <span class=\"o\">+</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre2</span> <span class=\"o\">=</span> <span class=\"n\">pre1</span><span class=\"o\">;</span>\n        <span class=\"n\">pre1</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>10.4 变态跳台阶</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387%3FtpId%3D13%26tqId%3D11162%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级... 它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-76eae365cbe3a7326bdbc90d58e01875_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"586\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb\" width=\"586\" data-original=\"https://pic2.zhimg.com/v2-76eae365cbe3a7326bdbc90d58e01875_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;586&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"586\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"586\" data-original=\"https://pic2.zhimg.com/v2-76eae365cbe3a7326bdbc90d58e01875_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-76eae365cbe3a7326bdbc90d58e01875_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><h3>动态规划</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">JumpFloorII</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">target</span><span class=\"o\">];</span>\n    <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">target</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h3>数学推导</h3><p>跳上 n-1 级台阶，可以从 n-2 级跳 1 级上去，也可以从 n-3 级跳 2 级上去...，那么</p><div class=\"highlight\"><pre><code class=\"language-text\">f(n-1) = f(n-2) + f(n-3) + ... + f(0)</code></pre></div><p>同样，跳上 n 级台阶，可以从 n-1 级跳 1 级上去，也可以从 n-2 级跳 2 级上去... ，那么</p><div class=\"highlight\"><pre><code class=\"language-text\">f(n) = f(n-1) + f(n-2) + ... + f(0)</code></pre></div><p>综上可得</p><div class=\"highlight\"><pre><code class=\"language-text\">f(n) - f(n-1) = f(n-1)</code></pre></div><p>即</p><div class=\"highlight\"><pre><code class=\"language-text\">f(n) = 2*f(n-1)</code></pre></div><p>所以 f(n) 是一个等比数列</p><div class=\"highlight\"><pre><code class=\"language-text\">public int JumpFloorII(int target) {\n    return (int) Math.pow(2, target - 1);\n}</code></pre></div><h2>11. 旋转数组的最小数字</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba%3FtpId%3D13%26tqId%3D11159%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0c0e322c9072f64418c601c1b39381c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"336\" data-rawheight=\"357\" class=\"content_image\" width=\"336\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;336&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"336\" data-rawheight=\"357\" class=\"content_image lazy\" width=\"336\" data-actualsrc=\"https://pic3.zhimg.com/v2-0c0e322c9072f64418c601c1b39381c2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>将旋转数组对半分可以得到一个包含最小元素的新旋转数组，以及一个非递减排序的数组。新的旋转数组的数组元素是原数组的一半，从而将问题规模减少了一半，这种折半性质的算法的时间复杂度为 O(logN)（为了方便，这里将 log2N 写为 logN）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-90681c8ff4b123903f547ab8b553596a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"510\" data-original=\"https://pic3.zhimg.com/v2-90681c8ff4b123903f547ab8b553596a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;510&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"510\" data-original=\"https://pic3.zhimg.com/v2-90681c8ff4b123903f547ab8b553596a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-90681c8ff4b123903f547ab8b553596a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此时问题的关键在于确定对半分得到的两个数组哪一个是旋转数组，哪一个是非递减数组。我们很容易知道非递减数组的第一个元素一定小于等于最后一个元素。</p><p>通过修改二分查找算法进行求解（l 代表 low，m 代表 mid，h 代表 high）：</p><ul><li>当 nums[m] &lt;= nums[h] 时，表示 [m, h] 区间内的数组是非递减数组，[l, m] 区间内的数组是旋转数组，此时令 h = m；</li><li>否则 [m + 1, h] 区间内的数组是旋转数组，令 l = m + 1。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">minNumberInRotateArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><p>如果数组元素允许重复，会出现一个特殊的情况：nums[l] == nums[m] == nums[h]，此时无法确定解在哪个区间，需要切换到顺序查找。例如对于数组 {1,1,1,0,1}，l、m 和 h 指向的数都为 1，此时无法知道最小数字 0 在哪个区间。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">minNumberInRotateArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n            <span class=\"k\">return</span> <span class=\"n\">minNumber</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">h</span><span class=\"o\">])</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">minNumber</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">])</span>\n            <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>12. 矩阵中的路径</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc%3FtpId%3D13%26tqId%3D11218%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向上下左右移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p><p>例如下面的矩阵包含了一条 bfce 路径。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8d827a9bd0357a78d1cfde1398c19f5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"278\" data-rawheight=\"251\" class=\"content_image\" width=\"278\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;278&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"278\" data-rawheight=\"251\" class=\"content_image lazy\" width=\"278\" data-actualsrc=\"https://pic4.zhimg.com/v2-8d827a9bd0357a78d1cfde1398c19f5b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>使用回溯法（backtracking）进行求解，它是一种暴力搜索方法，通过搜索所有可能的结果来求解问题。回溯法在一次搜索结束时需要进行回溯（回退），将这一次搜索过程中设置的状态进行清除，从而开始一次新的搜索过程。例如下图示例中，从 f 开始，下一步有 4 种搜索可能，如果先搜索 b，需要将 b 标记为已经使用，防止重复使用。在这一次搜索结束之后，需要将 b 的已经使用状态清除，并搜索 c。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-67496327c4f0c3dcb353f42879503e59_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"337\" class=\"content_image\" width=\"377\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;377&#39; height=&#39;337&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"337\" class=\"content_image lazy\" width=\"377\" data-actualsrc=\"https://pic2.zhimg.com/v2-67496327c4f0c3dcb353f42879503e59_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>本题的输入是数组而不是矩阵（二维数组），因此需要先将数组转换成矩阵。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"o\">{{</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">},</span> <span class=\"o\">{-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">}};</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">rows</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cols</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">hasPath</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">array</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">rows</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">cols</span><span class=\"o\">,</span> <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rows</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">cols</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">rows</span> <span class=\"o\">=</span> <span class=\"n\">rows</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cols</span> <span class=\"o\">=</span> <span class=\"n\">cols</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">marked</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">rows</span><span class=\"o\">][</span><span class=\"n\">cols</span><span class=\"o\">];</span>\n    <span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span> <span class=\"o\">=</span> <span class=\"n\">buildMatrix</span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">rows</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">cols</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">,</span> <span class=\"n\">str</span><span class=\"o\">,</span> <span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">))</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">backtracking</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">,</span> <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">str</span><span class=\"o\">,</span>\n                             <span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">pathLen</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pathLen</span> <span class=\"o\">==</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">rows</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">&gt;=</span> <span class=\"n\">cols</span>\n            <span class=\"o\">||</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">str</span><span class=\"o\">[</span><span class=\"n\">pathLen</span><span class=\"o\">]</span> <span class=\"o\">||</span> <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">next</span><span class=\"o\">)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">backtracking</span><span class=\"o\">(</span><span class=\"n\">matrix</span><span class=\"o\">,</span> <span class=\"n\">str</span><span class=\"o\">,</span> <span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"n\">pathLen</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">],</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]))</span>\n            <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"nf\">buildMatrix</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">array</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">char</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"o\">[</span><span class=\"n\">rows</span><span class=\"o\">][</span><span class=\"n\">cols</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">idx</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">rows</span><span class=\"o\">;</span> <span class=\"n\">r</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">cols</span><span class=\"o\">;</span> <span class=\"n\">c</span><span class=\"o\">++)</span>\n            <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">idx</span><span class=\"o\">++];</span>\n    <span class=\"k\">return</span> <span class=\"n\">matrix</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>13. 机器人的运动范围</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/6e5207314b5241fb83f2329e89fdecc8%3FtpId%3D13%26tqId%3D11219%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>地上有一个 m 行和 n 列的方格。一个机器人从坐标 (0, 0) 的格子开始移动，每一次只能向左右上下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 k 的格子。</p><p>例如，当 k 为 18 时，机器人能够进入方格 (35,37)，因为 3+5+3+7=18。但是，它不能进入方格 (35,38)，因为 3+5+3+8=19。请问该机器人能够达到多少个格子？</p><h2>解题思路</h2><p>使用深度优先搜索（Depth First Search，DFS）方法进行求解。回溯是深度优先搜索的一种特例，它在一次搜索过程中需要设置一些本次搜索过程的局部状态，并在本次搜索结束之后清除状态。而普通的深度优先搜索并不需要使用这些局部状态，虽然还是有可能设置一些全局状态。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"o\">{{</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">},</span> <span class=\"o\">{-</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">},</span> <span class=\"o\">{</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">}};</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">rows</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cols</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">digitSum</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">movingCount</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">threshold</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">rows</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">cols</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">rows</span> <span class=\"o\">=</span> <span class=\"n\">rows</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cols</span> <span class=\"o\">=</span> <span class=\"n\">cols</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n    <span class=\"n\">initDigitSum</span><span class=\"o\">();</span>\n    <span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">marked</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">rows</span><span class=\"o\">][</span><span class=\"n\">cols</span><span class=\"o\">];</span>\n    <span class=\"n\">dfs</span><span class=\"o\">(</span><span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">dfs</span><span class=\"o\">(</span><span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">rows</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">c</span> <span class=\"o\">&gt;=</span> <span class=\"n\">cols</span> <span class=\"o\">||</span> <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">])</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">digitSum</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">threshold</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">n</span> <span class=\"o\">:</span> <span class=\"n\">next</span><span class=\"o\">)</span>\n        <span class=\"n\">dfs</span><span class=\"o\">(</span><span class=\"n\">marked</span><span class=\"o\">,</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">],</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">n</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">initDigitSum</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">digitSumOne</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">rows</span><span class=\"o\">,</span> <span class=\"n\">cols</span><span class=\"o\">)];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">digitSumOne</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">digitSumOne</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+=</span> <span class=\"n\">n</span> <span class=\"o\">%</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n            <span class=\"n\">n</span> <span class=\"o\">/=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">digitSum</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">rows</span><span class=\"o\">][</span><span class=\"n\">cols</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">rows</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cols</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">digitSum</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">digitSumOne</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"n\">digitSumOne</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>14. 剪绳子</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/integer-break/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode</a></p><h2>题目描述</h2><p>把一根绳子剪成多段，并且使得每段的长度乘积最大。</p><div class=\"highlight\"><pre><code class=\"language-html\">n = 2\nreturn 1 (2 = 1 + 1)\n\nn = 10\nreturn 36 (10 = 3 + 3 + 4)</code></pre></div><h2>解题思路</h2><h3>贪心</h3><p>尽可能多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。</p><p>证明：当 n &gt;= 5 时，3(n - 3) - n = 2n - 9 &gt; 0，且 2(n - 2) - n = n - 4 &gt; 0。因此在 n &gt;= 5 的情况下，将绳子剪成一段为 2 或者 3，得到的乘积会更大。又因为 3(n - 3) - 2(n - 2) = n - 5 &gt;= 0，所以剪成一段长度为 3 比长度为 2 得到的乘积更大。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">integerBreak</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">2</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"n\">2</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"n\">3</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">timesOf3</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">/</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">timesOf3</span> <span class=\"o\">*</span> <span class=\"n\">3</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"n\">timesOf3</span><span class=\"o\">--;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">timesOf2</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">timesOf3</span> <span class=\"o\">*</span> <span class=\"n\">3</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">timesOf3</span><span class=\"o\">))</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">pow</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">timesOf2</span><span class=\"o\">));</span>\n<span class=\"o\">}</span></code></pre></div><h3>动态规划</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">integerBreak</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">j</span><span class=\"o\">),</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">j</span><span class=\"o\">)));</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>15. 二进制中 1 的个数</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8%3FtpId%3D13%26tqId%3D11164%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>输入一个整数，输出该数二进制表示中 1 的个数。</p><h3>n&amp;(n-1)</h3><p>该位运算去除 n 的位级表示中最低的那一位。</p><div class=\"highlight\"><pre><code class=\"language-text\">n       : 10110100\nn-1     : 10110011\nn&amp;(n-1) : 10110000</code></pre></div><p>时间复杂度：O(M)，其中 M 表示 1 的个数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">NumberOf1</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n        <span class=\"n\">n</span> <span class=\"o\">&amp;=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>Integer.bitCount()</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">NumberOf1</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">bitCount</span><span class=\"o\">(</span><span class=\"n\">n</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>16. 数值的整数次方</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/1a834e5e3e1a4b7ba251417554e07c00%3FtpId%3D13%26tqId%3D11165%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent，求 base 的 exponent 次方。</p><h2>解题思路</h2><p>下面的讨论中 x 代表 base，n 代表 exponent。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-223e447dd1e31ed7c1c35d4db84c39cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"93\" class=\"content_image\" width=\"418\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;418&#39; height=&#39;93&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"93\" class=\"content_image lazy\" width=\"418\" data-actualsrc=\"https://pic4.zhimg.com/v2-223e447dd1e31ed7c1c35d4db84c39cb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>因为 (x*x)n/2 可以通过递归求解，并且每次递归 n 都减小一半，因此整个算法的时间复杂度为 O(logN)。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">double</span> <span class=\"nf\">Power</span><span class=\"o\">(</span><span class=\"kt\">double</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">exponent</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">exponent</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">exponent</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">base</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span> <span class=\"n\">isNegative</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">exponent</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">exponent</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">exponent</span><span class=\"o\">;</span>\n        <span class=\"n\">isNegative</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">double</span> <span class=\"n\">pow</span> <span class=\"o\">=</span> <span class=\"n\">Power</span><span class=\"o\">(</span><span class=\"n\">base</span> <span class=\"o\">*</span> <span class=\"n\">base</span><span class=\"o\">,</span> <span class=\"n\">exponent</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">exponent</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">pow</span> <span class=\"o\">=</span> <span class=\"n\">pow</span> <span class=\"o\">*</span> <span class=\"n\">base</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">isNegative</span> <span class=\"o\">?</span> <span class=\"n\">1</span> <span class=\"o\">/</span> <span class=\"n\">pow</span> <span class=\"o\">:</span> <span class=\"n\">pow</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>17. 打印从 1 到最大的 n 位数</h2><h2>题目描述</h2><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数即 999。</p><h2>解题思路</h2><p>由于 n 可能会非常大，因此不能直接用 int 表示数字，而是用 char 数组进行存储。</p><p>使用回溯法得到所有的数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">print1ToMaxOfNDigits</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">number</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"n\">print1ToMaxOfNDigits</span><span class=\"o\">(</span><span class=\"n\">number</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">print1ToMaxOfNDigits</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">number</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">digit</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">digit</span> <span class=\"o\">==</span> <span class=\"n\">number</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">printNumber</span><span class=\"o\">(</span><span class=\"n\">number</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">number</span><span class=\"o\">[</span><span class=\"n\">digit</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">print1ToMaxOfNDigits</span><span class=\"o\">(</span><span class=\"n\">number</span><span class=\"o\">,</span> <span class=\"n\">digit</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">printNumber</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">number</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">number</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">number</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">)</span>\n        <span class=\"n\">index</span><span class=\"o\">++;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">number</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">number</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">++]);</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>18.1 在 O(1) 时间内删除链表节点</h2><h2>解题思路</h2><p>① 如果该节点不是尾节点，那么可以直接将下一个节点的值赋给该节点，然后令该节点指向下下个节点，再删除下一个节点，时间复杂度为 O(1)。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-02148f36dc1d29c2cf80551ed6fe3785_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"141\" class=\"origin_image zh-lightbox-thumb\" width=\"824\" data-original=\"https://pic2.zhimg.com/v2-02148f36dc1d29c2cf80551ed6fe3785_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;824&#39; height=&#39;141&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"824\" data-rawheight=\"141\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"824\" data-original=\"https://pic2.zhimg.com/v2-02148f36dc1d29c2cf80551ed6fe3785_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-02148f36dc1d29c2cf80551ed6fe3785_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>② 否则，就需要先遍历链表，找到节点的前一个节点，然后让前一个节点指向 null，时间复杂度为 O(N)。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fb8a5e57dc79de35fb2858548a1aa77c_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-fb8a5e57dc79de35fb2858548a1aa77c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;815&#39; height=&#39;134&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"815\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"815\" data-original=\"https://pic1.zhimg.com/v2-fb8a5e57dc79de35fb2858548a1aa77c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fb8a5e57dc79de35fb2858548a1aa77c_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>综上，如果进行 N 次操作，那么大约需要操作节点的次数为 N-1+N=2N-1，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。(2N-1)/N \\~ 2，因此该算法的平均时间复杂度为 O(1)。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">deleteNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"n\">tobeDelete</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">tobeDelete</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">tobeDelete</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 要删除的节点不是尾节点\n</span><span class=\"c1\"></span>        <span class=\"n\">ListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">tobeDelete</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">tobeDelete</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n        <span class=\"n\">tobeDelete</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"n\">tobeDelete</span><span class=\"o\">)</span>\n             <span class=\"c1\">// 只有一个节点\n</span><span class=\"c1\"></span>            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">ListNode</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"n\">tobeDelete</span><span class=\"o\">)</span>\n                <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>18.2 删除链表中重复的结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef%3FtpId%3D13%26tqId%3D11209%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7767980ebc26313432c83b7320f7638f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-7767980ebc26313432c83b7320f7638f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;206&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-7767980ebc26313432c83b7320f7638f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7767980ebc26313432c83b7320f7638f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题描述</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">deleteDuplication</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">==</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">==</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span>\n            <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">deleteDuplication</span><span class=\"o\">(</span><span class=\"n\">next</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">deleteDuplication</span><span class=\"o\">(</span><span class=\"n\">pHead</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>19. 正则表达式匹配</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/45327ae22b7b413ea21df13ee7d6429c%3FtpId%3D13%26tqId%3D11205%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>请实现一个函数用来匹配包括 &#39;.&#39; 和 &#39;*&#39; 的正则表达式。模式中的字符 &#39;.&#39; 表示任意一个字符，而 &#39;*&#39; 表示它前面的字符可以出现任意次（包含 0 次）。</p><p>在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 &#34;aaa&#34; 与模式 &#34;a.a&#34; 和 &#34;ab*ac*a&#34; 匹配，但是与 &#34;aa.a&#34; 和 &#34;ab*a&#34; 均不匹配。</p><h2>解题思路</h2><p>应该注意到，&#39;.&#39; 是用来当做一个任意字符，而 &#39;*&#39; 是用来重复前面的字符。这两个的作用不同，不能把 &#39;.&#39; 的作用和 &#39;*&#39; 进行类比，从而把它当成重复前面字符一次。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">match</span><span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">str</span><span class=\"o\">,</span> <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">pattern</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">pattern</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span><span class=\"o\">[][]</span> <span class=\"n\">dp</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">m</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n\n    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">][</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;*&#39;</span><span class=\"o\">)</span>\n            <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">][</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">][</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span>\n\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">m</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">||</span> <span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;.&#39;</span><span class=\"o\">)</span>\n                <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;*&#39;</span><span class=\"o\">)</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">str</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">||</span> <span class=\"n\">pattern</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;.&#39;</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">|=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">];</span> <span class=\"c1\">// a* counts as single a\n</span><span class=\"c1\"></span>                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">|=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">];</span> <span class=\"c1\">// a* counts as multiple a\n</span><span class=\"c1\"></span>                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">|=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span> <span class=\"c1\">// a* counts as empty\n</span><span class=\"c1\"></span>                <span class=\"o\">}</span> <span class=\"k\">else</span>\n                    <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">];</span>   <span class=\"c1\">// a* only counts as empty\n</span><span class=\"c1\"></span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">][</span><span class=\"n\">n</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764745", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 2, 
            "title": "剑指 Offer 题解 3-9", 
            "content": "<ul><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97\" class=\"internal\">3. 数组中重复的数字</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE\" class=\"internal\">4. 二维数组中的查找</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC\" class=\"internal\">5. 替换空格</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8\" class=\"internal\">6. 从尾到头打印链表</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91\" class=\"internal\">7. 重建二叉树</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#8-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9\" class=\"internal\">8. 二叉树的下一个结点</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/68764745/edit#9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97\" class=\"internal\">9. 用两个栈实现队列</a> </li></ul><h2>3. 数组中重复的数字</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/623a5ac0ea5b4e5f95552655361ae0a8%3FtpId%3D13%26tqId%3D11203%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的，也不知道每个数字重复几次。请找出数组中任意一个重复的数字。</p><div class=\"highlight\"><pre><code class=\"language-html\">Input:\n{2, 3, 1, 0, 2, 5}\n\nOutput:\n2</code></pre></div><h2>解题思路</h2><p>要求时间复杂度 O(N)，空间复杂度 O(1)。因此不能使用排序的方法，也不能使用额外的标记数组。</p><p>对于这种数组元素在 [0, n-1] 范围内的问题，可以将值为 i 的元素调整到第 i 个位置上进行求解。</p><p>以 (2, 3, 1, 0, 2, 5) 为例，遍历到位置 4 时，该位置上的数为 2，但是第 2 个位置上已经有一个 2 的值了，因此可以知道 2 重复：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-90c8c1c7d3aed5e0874bc09d4cce3453_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"284\" data-thumbnail=\"https://pic4.zhimg.com/v2-90c8c1c7d3aed5e0874bc09d4cce3453_b.jpg\" class=\"content_image\" width=\"407\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;407&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"284\" data-thumbnail=\"https://pic4.zhimg.com/v2-90c8c1c7d3aed5e0874bc09d4cce3453_b.jpg\" class=\"content_image lazy\" width=\"407\" data-actualsrc=\"https://pic4.zhimg.com/v2-90c8c1c7d3aed5e0874bc09d4cce3453_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">duplicate</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">duplication</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">length</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]])</span> <span class=\"o\">{</span>\n                <span class=\"n\">duplication</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>4. 二维数组中的查找</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e%3FtpId%3D13%26tqId%3D11154%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>给定一个二维数组，其每一行从左到右递增排序，从上到下也是递增排序。给定一个数，判断这个数是否在该二维数组中。</p><div class=\"highlight\"><pre><code class=\"language-html\">Consider the following matrix:\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\nGiven target = 5, return true.\nGiven target = 20, return false.</code></pre></div><h2>解题思路</h2><p>要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为 列数。</p><p>该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b16b0904f6dc2fbf3aa84ee43a3deaf0_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"324\" data-rawheight=\"446\" data-thumbnail=\"https://pic1.zhimg.com/v2-b16b0904f6dc2fbf3aa84ee43a3deaf0_b.jpg\" class=\"content_image\" width=\"324\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;324&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"324\" data-rawheight=\"446\" data-thumbnail=\"https://pic1.zhimg.com/v2-b16b0904f6dc2fbf3aa84ee43a3deaf0_b.jpg\" class=\"content_image lazy\" width=\"324\" data-actualsrc=\"https://pic1.zhimg.com/v2-b16b0904f6dc2fbf3aa84ee43a3deaf0_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">Find</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">matrix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">matrix</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">length</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">rows</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">,</span> <span class=\"n\">cols</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">cols</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// 从右上角开始\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;=</span> <span class=\"n\">rows</span> <span class=\"o\">-</span> <span class=\"n\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">==</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">])</span>\n            <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">&gt;</span> <span class=\"n\">matrix</span><span class=\"o\">[</span><span class=\"n\">r</span><span class=\"o\">][</span><span class=\"n\">c</span><span class=\"o\">])</span>\n            <span class=\"n\">r</span><span class=\"o\">++;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">c</span><span class=\"o\">--;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>5. 替换空格</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423%3FtpId%3D13%26tqId%3D11155%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>将一个字符串中的空格替换成 &#34;%20&#34;。</p><div class=\"highlight\"><pre><code class=\"language-text\">Input:\n&#34;A B&#34;\n\nOutput:\n&#34;A%20B&#34;</code></pre></div><h2>解题思路</h2><p>在字符串尾部填充任意字符，使得字符串的长度等于替换之后的长度。因为一个空格要替换成三个字符（%20），因此当遍历到一个空格时，需要在尾部填充两个任意字符。</p><p>令 P1 指向字符串原来的末尾位置，P2 指向字符串现在的末尾位置。P1 和 P2 从后向前遍历，当 P1 遍历到一个空格时，就需要令 P2 指向的位置依次填充 02%（注意是逆序的），否则就填充上 P1 指向字符的值。</p><p>从后向前遍是为了在改变 P2 所指向的内容时，不会影响到 P1 遍历原来字符串的内容。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3a357aa51f518a79f740282e310a623d_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"345\" data-rawheight=\"256\" data-thumbnail=\"https://pic2.zhimg.com/v2-3a357aa51f518a79f740282e310a623d_b.jpg\" class=\"content_image\" width=\"345\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;345&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"345\" data-rawheight=\"256\" data-thumbnail=\"https://pic2.zhimg.com/v2-3a357aa51f518a79f740282e310a623d_b.jpg\" class=\"content_image lazy\" width=\"345\" data-actualsrc=\"https://pic2.zhimg.com/v2-3a357aa51f518a79f740282e310a623d_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">replaceSpace</span><span class=\"o\">(</span><span class=\"n\">StringBuffer</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">P1</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">P1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"sc\">&#39; &#39;</span><span class=\"o\">)</span>\n            <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"s\">&#34;  &#34;</span><span class=\"o\">);</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">P2</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">P1</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">P2</span> <span class=\"o\">&gt;</span> <span class=\"n\">P1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">char</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">P1</span><span class=\"o\">--);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"sc\">&#39; &#39;</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">setCharAt</span><span class=\"o\">(</span><span class=\"n\">P2</span><span class=\"o\">--,</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">);</span>\n            <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">setCharAt</span><span class=\"o\">(</span><span class=\"n\">P2</span><span class=\"o\">--,</span> <span class=\"sc\">&#39;2&#39;</span><span class=\"o\">);</span>\n            <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">setCharAt</span><span class=\"o\">(</span><span class=\"n\">P2</span><span class=\"o\">--,</span> <span class=\"sc\">&#39;%&#39;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">setCharAt</span><span class=\"o\">(</span><span class=\"n\">P2</span><span class=\"o\">--,</span> <span class=\"n\">c</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>6. 从尾到头打印链表</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035%3FtpId%3D13%26tqId%3D11156%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>从尾到头反过来打印出每个结点的值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bf654bd371af9d72f569c3fece1f1ec5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"444\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"444\" data-original=\"https://pic2.zhimg.com/v2-bf654bd371af9d72f569c3fece1f1ec5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;444&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"444\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"444\" data-original=\"https://pic2.zhimg.com/v2-bf654bd371af9d72f569c3fece1f1ec5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bf654bd371af9d72f569c3fece1f1ec5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><h3>使用递归</h3><p>要逆序打印链表 1-&gt;2-&gt;3（3,2,1)，可以先逆序打印链表 2-&gt;3(3,2)，最后再打印第一个节点 1。而链表 2-&gt;3 可以看成一个新的链表，要逆序打印该链表可以继续使用求解函数，也就是在求解函数中调用自己，这就是递归函数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">printListFromTailToHead</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">listNode</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">listNode</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">addAll</span><span class=\"o\">(</span><span class=\"n\">printListFromTailToHead</span><span class=\"o\">(</span><span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">));</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>使用头插法</h3><p>使用头插法可以得到一个逆序的链表。</p><p>头结点和第一个节点的区别：</p><ul><li>头结点是在头插法中使用的一个额外节点，这个节点不存储值；</li><li>第一个节点就是链表的第一个真正存储值的节点。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"347\" data-thumbnail=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;347&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"347\" data-thumbnail=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-800c015fdcbe7d0e5a1d2b7f06d3783d_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">printListFromTailToHead</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">listNode</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 头插法构建逆序链表\n</span><span class=\"c1\"></span>    <span class=\"n\">ListNode</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ListNode</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">listNode</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">memo</span> <span class=\"o\">=</span> <span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">listNode</span><span class=\"o\">;</span>\n        <span class=\"n\">listNode</span> <span class=\"o\">=</span> <span class=\"n\">memo</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 构建 ArrayList\n</span><span class=\"c1\"></span>    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>使用栈</h3><p>栈具有后进先出的特点，在遍历链表时将值按顺序放入栈中，最后出栈的顺序即为逆序。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"672\" data-thumbnail=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"566\" data-original=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;566&#39; height=&#39;672&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"672\" data-thumbnail=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"566\" data-original=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6d9db2f8df9c41e3c24d77d2ce8f0789_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">printListFromTailToHead</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">listNode</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">stack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">listNode</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n        <span class=\"n\">listNode</span> <span class=\"o\">=</span> <span class=\"n\">listNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n        <span class=\"n\">ret</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">stack</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n    <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>7. 重建二叉树</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6%3FtpId%3D13%26tqId%3D11157%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>根据二叉树的前序遍历和中序遍历的结果，重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-27f8a8310213226379d6a24dd19ee8e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"593\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-27f8a8310213226379d6a24dd19ee8e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;593&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"593\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-27f8a8310213226379d6a24dd19ee8e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-27f8a8310213226379d6a24dd19ee8e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>解题思路</h2><p>前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"601\" data-thumbnail=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"587\" data-original=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;601&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"601\" data-thumbnail=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"587\" data-original=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-81d0ed342a1fe627e279efa8693bba94_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 缓存中序遍历数组每个值对应的索引\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">indexForInOrders</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">reConstructBinaryTree</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">in</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">indexForInOrders</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">in</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">reConstructBinaryTree</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">pre</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"n\">TreeNode</span> <span class=\"nf\">reConstructBinaryTree</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">preL</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">preR</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">inL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">preL</span> <span class=\"o\">&gt;</span> <span class=\"n\">preR</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">TreeNode</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">TreeNode</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">preL</span><span class=\"o\">]);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">inIndex</span> <span class=\"o\">=</span> <span class=\"n\">indexForInOrders</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">leftTreeSize</span> <span class=\"o\">=</span> <span class=\"n\">inIndex</span> <span class=\"o\">-</span> <span class=\"n\">inL</span><span class=\"o\">;</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">reConstructBinaryTree</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">preL</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">preL</span> <span class=\"o\">+</span> <span class=\"n\">leftTreeSize</span><span class=\"o\">,</span> <span class=\"n\">inL</span><span class=\"o\">);</span>\n    <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">reConstructBinaryTree</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">preL</span> <span class=\"o\">+</span> <span class=\"n\">leftTreeSize</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">preR</span><span class=\"o\">,</span> <span class=\"n\">inL</span> <span class=\"o\">+</span> <span class=\"n\">leftTreeSize</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>8. 二叉树的下一个结点</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/9023a0c988684a53960365b889ceaf5e%3FtpId%3D13%26tqId%3D11210%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">TreeLinkNode</span> <span class=\"o\">{</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"n\">TreeLinkNode</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">TreeLinkNode</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">TreeLinkNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n    <span class=\"n\">TreeLinkNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>解题思路</h2><p>① 如果一个节点的右子树不为空，那么该节点的下一个节点是右子树的最左节点；</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fcec11861486522e3dad8d8dc9d3f136_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"467\" data-thumbnail=\"https://pic3.zhimg.com/v2-fcec11861486522e3dad8d8dc9d3f136_b.jpg\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;467&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"467\" data-thumbnail=\"https://pic3.zhimg.com/v2-fcec11861486522e3dad8d8dc9d3f136_b.jpg\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic3.zhimg.com/v2-fcec11861486522e3dad8d8dc9d3f136_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>② 否则，向上找第一个左链接指向的树包含该节点的祖先节点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7c2c842a66aa96edb8121dc0df53cea7_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"474\" data-thumbnail=\"https://pic4.zhimg.com/v2-7c2c842a66aa96edb8121dc0df53cea7_b.jpg\" class=\"content_image\" width=\"329\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;329&#39; height=&#39;474&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"474\" data-thumbnail=\"https://pic4.zhimg.com/v2-7c2c842a66aa96edb8121dc0df53cea7_b.jpg\" class=\"content_image lazy\" width=\"329\" data-actualsrc=\"https://pic4.zhimg.com/v2-7c2c842a66aa96edb8121dc0df53cea7_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">TreeLinkNode</span> <span class=\"nf\">GetNext</span><span class=\"o\">(</span><span class=\"n\">TreeLinkNode</span> <span class=\"n\">pNode</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pNode</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">TreeLinkNode</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">pNode</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pNode</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">TreeLinkNode</span> <span class=\"n\">parent</span> <span class=\"o\">=</span> <span class=\"n\">pNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">parent</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">==</span> <span class=\"n\">pNode</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">parent</span><span class=\"o\">;</span>\n            <span class=\"n\">pNode</span> <span class=\"o\">=</span> <span class=\"n\">pNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>9. 用两个栈实现队列</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6%3FtpId%3D13%26tqId%3D11158%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NowCoder</a></p><h2>题目描述</h2><p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</p><h2>解题思路</h2><p>in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"524\" data-thumbnail=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;524&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"524\" data-thumbnail=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-aaa9b59f2d5f8f9c638bfcf96d5f3654_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n<span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Stack</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n            <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">Exception</span><span class=\"o\">(</span><span class=\"s\">&#34;queue is empty&#34;</span><span class=\"o\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>微信公众号</h2><p>你可以在我的微信公众号后台与我交流。另外，公众号也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。公众号也提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764663", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "Socket", 
            "content": "<p></p><h2>一、I/O 模型</h2><p>一个输入操作通常包括两个阶段：</p><ul><li>等待数据准备好</li><li>从内核向进程复制数据</li></ul><p>对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。</p><p>Unix 有五种 I/O 模型：</p><ul><li>阻塞式 I/O</li><li>非阻塞式 I/O</li><li>I/O 复用（select 和 poll）</li><li>信号驱动式 I/O（SIGIO）</li><li>异步 I/O（AIO）</li></ul><h2>阻塞式 I/O</h2><p>应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。</p><p>应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p><p>下图中，recvfrom() 用于接收 Socket 传来的数据，并复制到应用进程的缓冲区 buf 中。这里把 recvfrom() 当成系统调用。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">ssize_t</span> <span class=\"nf\">recvfrom</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">len</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">flags</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">sockaddr</span> <span class=\"o\">*</span><span class=\"n\">src_addr</span><span class=\"p\">,</span> <span class=\"n\">socklen_t</span> <span class=\"o\">*</span><span class=\"n\">addrlen</span><span class=\"p\">);</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8a8ad2c956a36324319c868c9d9f775b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-8a8ad2c956a36324319c868c9d9f775b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;399&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-8a8ad2c956a36324319c868c9d9f775b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8a8ad2c956a36324319c868c9d9f775b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>非阻塞式 I/O</h2><p>应用进程执行系统调用之后，内核返回一个错误码。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。</p><p>由于 CPU 要处理更多的系统调用，因此这种模型的 CPU 利用率比较低。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-377a6ff0ab5e0114673e8728e1051ee0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"707\" data-original=\"https://pic1.zhimg.com/v2-377a6ff0ab5e0114673e8728e1051ee0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;707&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"707\" data-original=\"https://pic1.zhimg.com/v2-377a6ff0ab5e0114673e8728e1051ee0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-377a6ff0ab5e0114673e8728e1051ee0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>I/O 复用</h2><p>使用 select 或者 poll 等待数据，并且可以等待多个套接字中的任何一个变为可读。这一过程会被阻塞，当某一个套接字可读时返回，之后再使用 recvfrom 把数据从内核复制到进程中。</p><p>它可以让单个进程具有处理多个 I/O 事件的能力。又被称为 Event Driven I/O，即事件驱动 I/O。</p><p>如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-362dc640c7ed4877e7c88ed24dee6d22_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb\" width=\"748\" data-original=\"https://pic3.zhimg.com/v2-362dc640c7ed4877e7c88ed24dee6d22_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;748&#39; height=&#39;406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"748\" data-original=\"https://pic3.zhimg.com/v2-362dc640c7ed4877e7c88ed24dee6d22_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-362dc640c7ed4877e7c88ed24dee6d22_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>信号驱动 I/O</h2><p>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送 SIGIO 信号，应用进程收到之后在信号处理程序中调用 recvfrom 将数据从内核复制到应用进程中。</p><p>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7f980441d18fda96ccac967aae7b66f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-7f980441d18fda96ccac967aae7b66f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-7f980441d18fda96ccac967aae7b66f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7f980441d18fda96ccac967aae7b66f3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>异步 I/O</h2><p>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作完成之后向应用进程发送信号。</p><p>异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程 I/O 完成，而信号驱动 I/O 的信号是通知应用进程可以开始 I/O。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2afb6123779c407bef0509bf28080b2f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"407\" class=\"origin_image zh-lightbox-thumb\" width=\"718\" data-original=\"https://pic4.zhimg.com/v2-2afb6123779c407bef0509bf28080b2f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;718&#39; height=&#39;407&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"407\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"718\" data-original=\"https://pic4.zhimg.com/v2-2afb6123779c407bef0509bf28080b2f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2afb6123779c407bef0509bf28080b2f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>五大 I/O 模型比较</h2><ul><li>同步 I/O：将数据从内核缓冲区复制到应用进程缓冲区的阶段，应用进程会阻塞。</li><li>异步 I/O：不会阻塞。</li></ul><p>阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O，它们的主要区别在第一个阶段。</p><p>非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07c3f47dbf077f922a5cf6461fd8ba1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-07c3f47dbf077f922a5cf6461fd8ba1e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;761&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"761\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"761\" data-original=\"https://pic3.zhimg.com/v2-07c3f47dbf077f922a5cf6461fd8ba1e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-07c3f47dbf077f922a5cf6461fd8ba1e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、I/O 复用</h2><p>select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。</p><h2>select</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">select</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">fd_set</span> <span class=\"o\">*</span><span class=\"n\">readfds</span><span class=\"p\">,</span> <span class=\"n\">fd_set</span> <span class=\"o\">*</span><span class=\"n\">writefds</span><span class=\"p\">,</span> <span class=\"n\">fd_set</span> <span class=\"o\">*</span><span class=\"n\">exceptfds</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">timeval</span> <span class=\"o\">*</span><span class=\"n\">timeout</span><span class=\"p\">);</span></code></pre></div><p>有三种类型的描述符类型：readset、writeset、exceptset，分别对应读、写、异常条件的描述符集合。fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义。</p><p>timeout 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。</p><p>成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">fd_set</span> <span class=\"n\">fd_in</span><span class=\"p\">,</span> <span class=\"n\">fd_out</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">timeval</span> <span class=\"n\">tv</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Reset the sets\n</span><span class=\"c1\"></span><span class=\"n\">FD_ZERO</span><span class=\"p\">(</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_in</span> <span class=\"p\">);</span>\n<span class=\"n\">FD_ZERO</span><span class=\"p\">(</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_out</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// Monitor sock1 for input events\n</span><span class=\"c1\"></span><span class=\"n\">FD_SET</span><span class=\"p\">(</span> <span class=\"n\">sock1</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_in</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// Monitor sock2 for output events\n</span><span class=\"c1\"></span><span class=\"n\">FD_SET</span><span class=\"p\">(</span> <span class=\"n\">sock2</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_out</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// Find out which socket has the largest numeric value as select requires it\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">largest_sock</span> <span class=\"o\">=</span> <span class=\"n\">sock1</span> <span class=\"o\">&gt;</span> <span class=\"n\">sock2</span> <span class=\"o\">?</span> <span class=\"nl\">sock1</span> <span class=\"p\">:</span> <span class=\"n\">sock2</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Wait up to 10 seconds\n</span><span class=\"c1\"></span><span class=\"n\">tv</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n<span class=\"n\">tv</span><span class=\"p\">.</span><span class=\"n\">tv_usec</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Call the select\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">select</span><span class=\"p\">(</span> <span class=\"n\">largest_sock</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_in</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_out</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">tv</span> <span class=\"p\">);</span>\n\n<span class=\"c1\">// Check if select actually succeed\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// report error and abort\n</span><span class=\"c1\"></span><span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// timeout; no event detected\n</span><span class=\"c1\"></span><span class=\"k\">else</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">FD_ISSET</span><span class=\"p\">(</span> <span class=\"n\">sock1</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_in</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n        <span class=\"c1\">// input event on sock1\n</span><span class=\"c1\"></span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">FD_ISSET</span><span class=\"p\">(</span> <span class=\"n\">sock2</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">fd_out</span> <span class=\"p\">)</span> <span class=\"p\">)</span>\n        <span class=\"c1\">// output event on sock2\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><h2>poll</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">poll</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">pollfd</span> <span class=\"o\">*</span><span class=\"n\">fds</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">nfds</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">timeout</span><span class=\"p\">);</span></code></pre></div><p>pollfd 使用链表实现。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">// The structure for two events\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"n\">pollfd</span> <span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n\n<span class=\"c1\">// Monitor sock1 for input\n</span><span class=\"c1\"></span><span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">sock1</span><span class=\"p\">;</span>\n<span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">POLLIN</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Monitor sock2 for output\n</span><span class=\"c1\"></span><span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">sock2</span><span class=\"p\">;</span>\n<span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">POLLOUT</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Wait 10 seconds\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">poll</span><span class=\"p\">(</span> <span class=\"o\">&amp;</span><span class=\"n\">fds</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">10000</span> <span class=\"p\">);</span>\n<span class=\"c1\">// Check if poll actually succeed\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// report error and abort\n</span><span class=\"c1\"></span><span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// timeout; no event detected\n</span><span class=\"c1\"></span><span class=\"k\">else</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// If we detect the event, zero it out so we can reuse the structure\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">revents</span> <span class=\"o\">&amp;</span> <span class=\"n\">POLLIN</span> <span class=\"p\">)</span>\n        <span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">revents</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"c1\">// input event on sock1\n</span><span class=\"c1\"></span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">revents</span> <span class=\"o\">&amp;</span> <span class=\"n\">POLLOUT</span> <span class=\"p\">)</span>\n        <span class=\"n\">fds</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">revents</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"c1\">// output event on sock2\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><h2>比较</h2><h3>1. 功能</h3><p>select 和 poll 的功能基本相同，不过在一些实现细节上有所不同。</p><ul><li>select 会修改描述符，而 poll 不会；</li><li>select 的描述符类型使用数组实现，FD_SETSIZE 大小默认为 1024，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后重新编译；而 poll 的描述符类型使用链表实现，没有描述符数量的限制；</li><li>poll 提供了更多的事件类型，并且对描述符的重复利用上比 select 高。</li><li>如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。</li></ul><h3>2. 速度</h3><p>select 和 poll 速度都比较慢。</p><ul><li>select 和 poll 每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。</li><li>select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。</li></ul><h3>3. 可移植性</h3><p>几乎所有的系统都支持 select，但是只有比较新的系统支持 poll。</p><h2>epoll</h2><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">epoll_create</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"p\">);</span>\n<span class=\"kt\">int</span> <span class=\"nf\">epoll_ctl</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span><span class=\"n\">event</span><span class=\"p\">)</span><span class=\"err\">；</span>\n<span class=\"kt\">int</span> <span class=\"n\">epoll_wait</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span> <span class=\"n\">events</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">maxevents</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">timeout</span><span class=\"p\">);</span></code></pre></div><p>epoll_ctl() 用于向内核注册新的描述符或者是改变某个文件描述符的状态。已注册的描述符在内核中会被维护在一棵红黑树上，通过回调函数内核会将 I/O 准备好的描述符加入到一个链表中管理，进程调用 epoll_wait() 便可以得到事件完成的描述符。</p><p>从上面的描述可以看出，epoll 只需要将描述符从进程缓冲区向内核缓冲区拷贝一次，并且进程不需要通过轮询来获得事件完成的描述符。</p><p>epoll 仅适用于 Linux OS。</p><p>epoll 比 select 和 poll 更加灵活而且没有描述符数量限制。</p><p>epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">// Create the epoll descriptor. Only one is needed per app, and is used to monitor all sockets.\n</span><span class=\"c1\">// The function argument is ignored (it was not before, but now it is), so put your favorite number here\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">pollingfd</span> <span class=\"o\">=</span> <span class=\"n\">epoll_create</span><span class=\"p\">(</span> <span class=\"mh\">0xCAFE</span> <span class=\"p\">);</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">pollingfd</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n <span class=\"c1\">// report error\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// Initialize the epoll structure in case more members are added in future\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"n\">ev</span> <span class=\"o\">=</span> <span class=\"p\">{</span> <span class=\"mi\">0</span> <span class=\"p\">};</span>\n\n<span class=\"c1\">// Associate the connection class instance with the event. You can associate anything\n</span><span class=\"c1\">// you want, epoll does not use this information. We store a connection class pointer, pConnection1\n</span><span class=\"c1\"></span><span class=\"n\">ev</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">pConnection1</span><span class=\"p\">;</span>\n\n<span class=\"c1\">// Monitor for input, and do not automatically rearm the descriptor after the event\n</span><span class=\"c1\"></span><span class=\"n\">ev</span><span class=\"p\">.</span><span class=\"n\">events</span> <span class=\"o\">=</span> <span class=\"n\">EPOLLIN</span> <span class=\"o\">|</span> <span class=\"n\">EPOLLONESHOT</span><span class=\"p\">;</span>\n<span class=\"c1\">// Add the descriptor into the monitoring list. We can do it even if another thread is\n</span><span class=\"c1\">// waiting in epoll_wait - the descriptor will be properly added\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">epoll_ctl</span><span class=\"p\">(</span> <span class=\"n\">epollfd</span><span class=\"p\">,</span> <span class=\"n\">EPOLL_CTL_ADD</span><span class=\"p\">,</span> <span class=\"n\">pConnection1</span><span class=\"o\">-&gt;</span><span class=\"n\">getSocket</span><span class=\"p\">(),</span> <span class=\"o\">&amp;</span><span class=\"n\">ev</span> <span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// report error\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// Wait for up to 20 events (assuming we have added maybe 200 sockets before that it may happen)\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"n\">pevents</span><span class=\"p\">[</span> <span class=\"mi\">20</span> <span class=\"p\">];</span>\n\n<span class=\"c1\">// Wait for 10 seconds, and retrieve less than 20 epoll_event and store them into epoll_event array\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">ready</span> <span class=\"o\">=</span> <span class=\"n\">epoll_wait</span><span class=\"p\">(</span> <span class=\"n\">pollingfd</span><span class=\"p\">,</span> <span class=\"n\">pevents</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"mi\">10000</span> <span class=\"p\">);</span>\n<span class=\"c1\">// Check if epoll actually succeed\n</span><span class=\"c1\"></span><span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// report error and abort\n</span><span class=\"c1\"></span><span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">ret</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n    <span class=\"c1\">// timeout; no event detected\n</span><span class=\"c1\"></span><span class=\"k\">else</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// Check if any events detected\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">ret</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span> <span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">pevents</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">events</span> <span class=\"o\">&amp;</span> <span class=\"n\">EPOLLIN</span> <span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"c1\">// Get back our connection pointer\n</span><span class=\"c1\"></span>            <span class=\"n\">Connection</span> <span class=\"o\">*</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Connection</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"n\">pevents</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n            <span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">handleReadEvent</span><span class=\"p\">();</span>\n         <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><h2>工作模式</h2><p>epoll 的描述符事件有两种触发模式：LT（level trigger）和 ET（edge trigger）。</p><h3>1. LT 模式</h3><p>当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。</p><h3>2. ET 模式</h3><p>和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。</p><p>很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h2>应用场景</h2><p>很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。</p><h3>1. select 应用场景</h3><p>select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此 select 更加适用于实时性要求比较高的场景，比如核反应堆的控制。</p><p>select 可移植性更好，几乎被所有主流平台所支持。</p><h3>2. poll 应用场景</h3><p>poll 没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用 poll 而不是 select。</p><h3>3. epoll 应用场景</h3><p>只需要运行在 Linux 平台上，有大量的描述符需要同时轮询，并且这些连接最好是长连接。</p><p>需要同时监控小于 1000 个描述符，就没有必要使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。</p><p>需要监控的描述符状态变化多，而且都是非常短暂的，也没有必要使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。</p><h2>参考资料</h2><ul><li>Stevens W R, Fenner B, Rudoff A M. UNIX network programming[M]. Addison-Wesley Professional, 2004.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/linux/library/l-async/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Boost application performance using asynchronous I/O</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//msdn.microsoft.com/en-us/library/windows/desktop/aa365683%28v%3Dvs.85%29.aspx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Synchronous and Asynchronous I/O</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000003063859\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Linux IO 模式及 select、poll、epoll 详解</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//daniel.haxx.se/docs/poll-vs-select.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">poll vs select vs event-based</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.ulduzsoft.com/2014/01/select-poll-epoll-practical-difference-for-system-architects/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">select / poll / epoll: practical difference for system architects</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//code.woboq.org/userspace/glibc/sysdeps/unix/sysv/linux/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Browse the source code of userspace/glibc/sysdeps/unix/sysv/linux/ online</a></li></ul><h2>微信公众号</h2><p>微信公众号 CyC2018 提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Socket", 
                    "tagLink": "https://api.zhihu.com/topics/19604051"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68764595", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "HTTP", 
            "content": "<p></p><h2>一 、基础概念</h2><h2>URI</h2><p>URI 包含 URL 和 URN。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-376bd7732a90331b7ff7f7d943ce7c17_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"762\" data-original=\"https://pic4.zhimg.com/v2-376bd7732a90331b7ff7f7d943ce7c17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;762&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"762\" data-original=\"https://pic4.zhimg.com/v2-376bd7732a90331b7ff7f7d943ce7c17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-376bd7732a90331b7ff7f7d943ce7c17_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>请求和响应报文</h2><h3>1. 请求报文</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cd86f8fbd1c2d3a0580e8917a607c343_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-cd86f8fbd1c2d3a0580e8917a607c343_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;221&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-cd86f8fbd1c2d3a0580e8917a607c343_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cd86f8fbd1c2d3a0580e8917a607c343_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 响应报文</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-71c4b0d5df52bf4a27b525d9bd8c2c8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-71c4b0d5df52bf4a27b525d9bd8c2c8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-71c4b0d5df52bf4a27b525d9bd8c2c8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-71c4b0d5df52bf4a27b525d9bd8c2c8f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、HTTP 方法</h2><p>客户端发送的  <b>请求报文</b>  第一行为请求行，包含了方法字段。</p><h2>GET</h2><blockquote> 获取资源<br/> </blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h2>HEAD</h2><blockquote> 获取报文首部<br/> </blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。</p><p>主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h2>POST</h2><blockquote> 传输实体主体<br/> </blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。</p><p>更多 POST 与 GET 的比较请见第九章。</p><h2>PUT</h2><blockquote> 上传文件<br/> </blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><div class=\"highlight\"><pre><code class=\"language-html\">PUT /new.html HTTP/1.1\nHost: example.com\nContent-type: text/html\nContent-length: 16\n\n<span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>New File<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span></code></pre></div><h2>PATCH</h2><blockquote> 对资源进行部分修改<br/> </blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><div class=\"highlight\"><pre><code class=\"language-html\">PATCH /file.txt HTTP/1.1\nHost: www.example.com\nContent-Type: application/example\nIf-Match: &#34;e0023aa4e&#34;\nContent-Length: 100\n\n[description of changes]</code></pre></div><h2>DELETE</h2><blockquote> 删除文件<br/> </blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><div class=\"highlight\"><pre><code class=\"language-html\">DELETE /file.html HTTP/1.1</code></pre></div><h2>OPTIONS</h2><blockquote> 查询支持的方法<br/> </blockquote><p>查询指定的 URL 能够支持的方法。</p><p>会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h2>CONNECT</h2><blockquote> 要求在与代理服务器通信时建立隧道<br/> </blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><div class=\"highlight\"><pre><code class=\"language-html\">CONNECT www.example.com:443 HTTP/1.1</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e3b4504f8bea5afeaac089c28743c3da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-e3b4504f8bea5afeaac089c28743c3da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;185&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-e3b4504f8bea5afeaac089c28743c3da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e3b4504f8bea5afeaac089c28743c3da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>TRACE</h2><blockquote> 追踪路径<br/> </blockquote><p>服务器会将通信路径返回给客户端。</p><p>发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。</p><p>通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h2>三、HTTP 状态码</h2><p>服务器返回的  <b>响应报文</b>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><p>| 状态码 | 类别 | 含义 | | :---: | :---: | :---: | | 1XX | Informational（信息性状态码） | 接收的请求正在处理 | | 2XX | Success（成功状态码） | 请求正常处理完毕 | | 3XX | Redirection（重定向状态码） | 需要进行附加操作以完成请求 | | 4XX | Client Error（客户端错误状态码） | 服务器无法处理请求 | | 5XX | Server Error（服务器错误状态码） | 服务器处理请求出错 |</p><h2>1XX 信息</h2><ul><li><b>100 Continue</b> ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h2>2XX 成功</h2><ul><li><b>200 OK</b> <br/> </li><li><b>204 No Content</b> ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。<br/> </li><li><b>206 Partial Content</b> ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。<br/> </li></ul><h2>3XX 重定向</h2><ul><li><b>301 Moved Permanently</b> ：永久性重定向<br/> </li><li><b>302 Found</b> ：临时性重定向<br/> </li><li><b>303 See Other</b> ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。<br/> </li><li> 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。<br/> </li><li><b>304 Not Modified</b> ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。<br/> </li><li><b>307 Temporary Redirect</b> ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。<br/> </li></ul><h2>4XX 客户端错误</h2><ul><li><b>400 Bad Request</b> ：请求报文中存在语法错误。<br/> </li><li><b>401 Unauthorized</b> ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。<br/> </li><li><b>403 Forbidden</b> ：请求被拒绝。<br/> </li><li><b>404 Not Found</b> <br/> </li></ul><h2>5XX 服务器错误</h2><ul><li><b>500 Internal Server Error</b> ：服务器正在执行请求时发生错误。<br/> </li><li><b>503 Service Unavailable</b> ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。<br/> </li></ul><h2>四、HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h2>通用首部字段</h2><p>| 首部字段名 | 说明 | | :--: | :--: | | Cache-Control | 控制缓存的行为 | | Connection | 控制不再转发给代理的首部字段、管理持久连接| | Date | 创建报文的日期时间 | | Pragma | 报文指令 | | Trailer | 报文末端的首部一览 | | Transfer-Encoding | 指定报文主体的传输编码方式 | | Upgrade | 升级为其他协议 | | Via | 代理服务器的相关信息 | | Warning | 错误通知 |</p><h2>请求首部字段</h2><p>| 首部字段名 | 说明 | | :--: | :--: | | Accept | 用户代理可处理的媒体类型 | | Accept-Charset | 优先的字符集 | | Accept-Encoding | 优先的内容编码 | | Accept-Language | 优先的语言（自然语言） | | Authorization | Web 认证信息 | | Expect | 期待服务器的特定行为 | | From | 用户的电子邮箱地址 | | Host | 请求资源所在服务器 | | If-Match | 比较实体标记（ETag） | | If-Modified-Since | 比较资源的更新时间 | | If-None-Match | 比较实体标记（与 If-Match 相反） | | If-Range | 资源未更新时发送实体 Byte 的范围请求 | | If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） | | Max-Forwards | 最大传输逐跳数 | | Proxy-Authorization | 代理服务器要求客户端的认证信息 | | Range | 实体的字节范围请求 | | Referer | 对请求中 URI 的原始获取方 | | TE | 传输编码的优先级 | | User-Agent | HTTP 客户端程序的信息 |</p><h2>响应首部字段</h2><p>| 首部字段名 | 说明 | | :--: | :--: | | Accept-Ranges | 是否接受字节范围请求 | | Age | 推算资源创建经过时间 | | ETag | 资源的匹配信息 | | Location | 令客户端重定向至指定 URI | | Proxy-Authenticate | 代理服务器对客户端的认证信息 | | Retry-After | 对再次发起请求的时机要求 | | Server | HTTP 服务器的安装信息 | | Vary | 代理服务器缓存的管理信息 | | WWW-Authenticate | 服务器对客户端的认证信息 |</p><h2>实体首部字段</h2><p>| 首部字段名 | 说明 | | :--: | :--: | | Allow | 资源可支持的 HTTP 方法 | | Content-Encoding | 实体主体适用的编码方式 | | Content-Language | 实体主体的自然语言 | | Content-Length | 实体主体的大小 | | Content-Location | 替代对应资源的 URI | | Content-MD5 | 实体主体的报文摘要 | | Content-Range | 实体主体的位置范围 | | Content-Type | 实体主体的媒体类型 | | Expires | 实体主体过期的日期时间 | | Last-Modified | 资源的最后修改日期时间 |</p><h2>五、具体应用</h2><h2>连接管理</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5a756ef02ebd371dced94884db6fe840_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"670\" class=\"origin_image zh-lightbox-thumb\" width=\"1012\" data-original=\"https://pic1.zhimg.com/v2-5a756ef02ebd371dced94884db6fe840_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1012&#39; height=&#39;670&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"670\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1012\" data-original=\"https://pic1.zhimg.com/v2-5a756ef02ebd371dced94884db6fe840_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5a756ef02ebd371dced94884db6fe840_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1. 短连接与长连接</h3><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h3>2. 流水线</h3><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h2>Cookie</h2><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h3>1. 用途</h3><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3>2. 创建过程</h3><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><div class=\"highlight\"><pre><code class=\"language-html\">HTTP/1.0 200 OK\nContent-type: text/html\nSet-Cookie: yummy_cookie=choco\nSet-Cookie: tasty_cookie=strawberry\n\n[page content]</code></pre></div><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><div class=\"highlight\"><pre><code class=\"language-html\">GET /sample_page.html HTTP/1.1\nHost: www.example.org\nCookie: yummy_cookie=choco; tasty_cookie=strawberry</code></pre></div><h3>3. 分类</h3><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><div class=\"highlight\"><pre><code class=\"language-html\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</code></pre></div><h3>4. 作用域</h3><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=<a href=\"https://link.zhihu.com/?target=http%3A//mozilla.org\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">mozilla.org</span><span class=\"invisible\"></span></a>，则 Cookie 也包含在子域名中（如 <a href=\"https://link.zhihu.com/?target=http%3A//developer.mozilla.org\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">developer.mozilla.org</span><span class=\"invisible\"></span></a>）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (&#34;/&#34;) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h3>5. JavaScript</h3><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><div class=\"highlight\"><pre><code class=\"language-html\">document.cookie = &#34;yummy_cookie=choco&#34;;\ndocument.cookie = &#34;tasty_cookie=strawberry&#34;;\nconsole.log(document.cookie);</code></pre></div><h3>6. HttpOnly</h3><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><div class=\"highlight\"><pre><code class=\"language-html\">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</code></pre></div><h3>7. Secure</h3><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h3>8. Session</h3><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h3>9. 浏览器禁用 Cookie</h3><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h3>10. Cookie 与 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h2>缓存</h2><h3>1. 优点</h3><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h3>2. 实现方法</h3><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h3>3. Cache-Control</h3><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><b>3.1 禁止进行缓存</b> </p><p>no-store 指令规定不能对请求或响应的任何一部分进行缓存。</p><div class=\"highlight\"><pre><code class=\"language-html\">Cache-Control: no-store</code></pre></div><p><b>3.2 强制确认缓存</b> </p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><div class=\"highlight\"><pre><code class=\"language-html\">Cache-Control: no-cache</code></pre></div><p><b>3.3 私有缓存和公共缓存</b> </p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><div class=\"highlight\"><pre><code class=\"language-html\">Cache-Control: private</code></pre></div><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><div class=\"highlight\"><pre><code class=\"language-html\">Cache-Control: public</code></pre></div><p><b>3.4 缓存过期机制</b> </p><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><div class=\"highlight\"><pre><code class=\"language-html\">Cache-Control: max-age=31536000</code></pre></div><p>Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><div class=\"highlight\"><pre><code class=\"language-html\">Expires: Wed, 04 Jul 2012 08:26:05 GMT</code></pre></div><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h3>4. 缓存验证</h3><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><div class=\"highlight\"><pre><code class=\"language-html\">ETag: &#34;82e22293907ce725faf67773957acd12&#34;</code></pre></div><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><div class=\"highlight\"><pre><code class=\"language-html\">If-None-Match: &#34;82e22293907ce725faf67773957acd12&#34;</code></pre></div><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><div class=\"highlight\"><pre><code class=\"language-html\">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT\nIf-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</code></pre></div><h2>内容协商</h2><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h3>1. 类型</h3><p><b>1.1 服务端驱动型</b> </p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><b>1.2 代理驱动型</b> </p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h3>2. Vary</h3><div class=\"highlight\"><pre><code class=\"language-html\">Vary: Accept-Language</code></pre></div><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h2>内容编码</h2><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p><p>常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p><h2>范围请求</h2><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h3>1. Range</h3><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><div class=\"highlight\"><pre><code class=\"language-html\">GET /z4d4kWk.jpg HTTP/1.1\nHost: i.imgur.com\nRange: bytes=0-1023</code></pre></div><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><div class=\"highlight\"><pre><code class=\"language-html\">HTTP/1.1 206 Partial Content\nContent-Range: bytes 0-1023/146515\nContent-Length: 1024\n...\n(binary content)</code></pre></div><h3>2. Accept-Ranges</h3><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><div class=\"highlight\"><pre><code class=\"language-html\">Accept-Ranges: bytes</code></pre></div><h3>3. 响应状态码</h3><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h2>分块传输编码</h2><p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h2>多部分对象集合</h2><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><div class=\"highlight\"><pre><code class=\"language-html\">Content-Type: multipart/form-data; boundary=AaB03x\n\n--AaB03x\nContent-Disposition: form-data; name=&#34;submit-name&#34;\n\nLarry\n--AaB03x\nContent-Disposition: form-data; name=&#34;files&#34;; filename=&#34;file1.txt&#34;\nContent-Type: text/plain\n\n... contents of file1.txt ...\n--AaB03x--</code></pre></div><h2>虚拟主机</h2><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h2>通信数据转发</h2><h3>1. 代理</h3><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><ul><li>用户察觉得到正向代理的存在。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d4d4ebeef1c6f6c73415fff7d5405659_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-d4d4ebeef1c6f6c73415fff7d5405659_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-d4d4ebeef1c6f6c73415fff7d5405659_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d4d4ebeef1c6f6c73415fff7d5405659_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>而反向代理一般位于内部网络中，用户察觉不到。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-90662d6d8c4f9ae2360d66cf96cccbfc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb\" width=\"467\" data-original=\"https://pic1.zhimg.com/v2-90662d6d8c4f9ae2360d66cf96cccbfc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;467&#39; height=&#39;175&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"467\" data-original=\"https://pic1.zhimg.com/v2-90662d6d8c4f9ae2360d66cf96cccbfc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-90662d6d8c4f9ae2360d66cf96cccbfc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 网关</h3><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h3>3. 隧道</h3><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2>六、HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cb7f3d4ba96c5ce37f339bbfe42db675_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1103\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"1103\" data-original=\"https://pic2.zhimg.com/v2-cb7f3d4ba96c5ce37f339bbfe42db675_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1103&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1103\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1103\" data-original=\"https://pic2.zhimg.com/v2-cb7f3d4ba96c5ce37f339bbfe42db675_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cb7f3d4ba96c5ce37f339bbfe42db675_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>加密</h2><h3>1. 对称密钥加密</h3><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c29f1767fb947606162362a3cf36241b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"772\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"772\" data-original=\"https://pic4.zhimg.com/v2-c29f1767fb947606162362a3cf36241b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;772&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"772\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"772\" data-original=\"https://pic4.zhimg.com/v2-c29f1767fb947606162362a3cf36241b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c29f1767fb947606162362a3cf36241b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.非对称密钥加密</h3><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a92eb07c039513da4b419d00e03ffca2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"779\" data-original=\"https://pic3.zhimg.com/v2-a92eb07c039513da4b419d00e03ffca2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;779&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"779\" data-original=\"https://pic3.zhimg.com/v2-a92eb07c039513da4b419d00e03ffca2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a92eb07c039513da4b419d00e03ffca2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. HTTPS 采用的加密方式</h3><p>HTTPS 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fd1ff7363bf25f435f74d666472ebb50_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1572\" data-rawheight=\"4096\" class=\"origin_image zh-lightbox-thumb\" width=\"1572\" data-original=\"https://pic1.zhimg.com/v2-fd1ff7363bf25f435f74d666472ebb50_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1572&#39; height=&#39;4096&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1572\" data-rawheight=\"4096\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1572\" data-original=\"https://pic1.zhimg.com/v2-fd1ff7363bf25f435f74d666472ebb50_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fd1ff7363bf25f435f74d666472ebb50_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>认证</h2><p>通过使用  <b>证书</b>  来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f124262d5d7ac2d6e2b643eba64b2290_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-f124262d5d7ac2d6e2b643eba64b2290_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;595&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-f124262d5d7ac2d6e2b643eba64b2290_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f124262d5d7ac2d6e2b643eba64b2290_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>完整性保护</h2><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h2>HTTPS 的缺点</h2><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2>七、HTTP/2.0</h2><h2>HTTP/1.x 缺陷</h2><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h2>二进制分帧层</h2><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a27bcbc580278f388ace0fb3d245d2d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-a27bcbc580278f388ace0fb3d245d2d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-a27bcbc580278f388ace0fb3d245d2d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a27bcbc580278f388ace0fb3d245d2d5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b6d41f91cd72ccd8ef2a6683226ff9b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"936\" data-original=\"https://pic2.zhimg.com/v2-b6d41f91cd72ccd8ef2a6683226ff9b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;936&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"936\" data-original=\"https://pic2.zhimg.com/v2-b6d41f91cd72ccd8ef2a6683226ff9b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b6d41f91cd72ccd8ef2a6683226ff9b9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>服务端推送</h2><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0eb94ec6fce5d89a32d3e8940ebdeb2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"853\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"853\" data-original=\"https://pic4.zhimg.com/v2-0eb94ec6fce5d89a32d3e8940ebdeb2b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;853&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"853\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"853\" data-original=\"https://pic4.zhimg.com/v2-0eb94ec6fce5d89a32d3e8940ebdeb2b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0eb94ec6fce5d89a32d3e8940ebdeb2b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>首部压缩</h2><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e72489d133e7997c94d60f1bdde1890_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-6e72489d133e7997c94d60f1bdde1890_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;873&#39; height=&#39;722&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-6e72489d133e7997c94d60f1bdde1890_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e72489d133e7997c94d60f1bdde1890_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>八、HTTP/1.1 新特性</h2><p>详细内容请见上文</p><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h2>九、GET 和 POST 比较</h2><h2>作用</h2><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h2>参数</h2><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><div class=\"highlight\"><pre><code class=\"language-text\">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1\nPOST /test/demo_form.asp HTTP/1.1\nHost: w3schools.com\nname1=value1&amp;name2=value2</code></pre></div><h2>安全</h2><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h2>幂等性</h2><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">GET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1\nGET /pageX HTTP/1.1</code></pre></div><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><div class=\"highlight\"><pre><code class=\"language-text\">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row\nPOST /add_row HTTP/1.1   -&gt; Adds a 2nd row\nPOST /add_row HTTP/1.1   -&gt; Adds a 3rd row</code></pre></div><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><div class=\"highlight\"><pre><code class=\"language-text\">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists\nDELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted\nDELETE /idX/delete HTTP/1.1   -&gt; Returns 404</code></pre></div><h2>可缓存</h2><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h2>XMLHttpRequest</h2><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote> XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。<br/> </blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><h2>参考资料</h2><ul><li>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTTP\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MDN : HTTP</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/http2/%3Fhl%3Dzh-cn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTP/2 简介</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//php.net/manual/zh/function.htmlspecialchars.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">htmlspecialchars</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//java2db.com/java-io/how-to-get-and-the-difference-between-file-uri-and-url-in-java\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Difference between file URI and URL in java</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//software-security.sans.org/developer-how-to/fix-sql-injection-in-java-using-prepared-callable-statement\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">浅谈 HTTP 中 Get 与 Post 的区别</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.webdancers.com/are-http-and-www-necesary/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Are http:// and www really necessary?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ntu.edu.sg/home/ehchua/programming/webprogramming/HTTP_Basics.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTP (HyperText Transfer Protocol)</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.igvita.com/2011/12/01/web-vpn-secure-proxies-with-spdy-chrome/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Web-VPN: Secure Proxies with SPDY &amp; Chrome</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/File%3AHTTP_persistent_connection.svg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">File:HTTP persistent connection.svg</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Proxy_server\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Proxy server</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.x-cart.com/blog/what-is-https-and-ssl.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What Is This HTTPS/SSL Thing And Why Should You Care?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//securebox.comodo.com/ssl-sniffing/ssl-offloading/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is SSL Offloading?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/cd/E19424-01/820-4811/6ng8i26bn/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.codeproject.com/Articles/326574/An-Introduction-to-Mutual-SSL-Authentication\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">An Introduction to Mutual SSL Authentication</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//danielmiessler.com/study/url-uri/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Difference Between URLs and URIs</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/entry/5766c29d6be3ff006a31b84e%23comment\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cookie 与 Session 的区别</a></li><li><a href=\"https://www.zhihu.com/question/19786827\" class=\"internal\">COOKIE 和 SESSION 有什么区别</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//harttle.land/2015/08/10/cookie-session.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Cookie/Session 的机制与安全</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//shijianan.com/2017/06/11/https/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTPS 证书原理</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is the difference between a URI, a URL and a URN?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XMLHttpRequest</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.josephscott.org/2009/08/27/xmlhttprequest-xhr-uses-multiple-packets-for-http-post/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ssl2buy.com/wiki/symmetric-vs-asymmetric-encryption-what-are-differences\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Symmetric vs. Asymmetric Encryption – What are differences?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/digest/web-performance-http2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Web 性能优化与 HTTP/2</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.com/web/fundamentals/performance/http2/%3Fhl%3Dzh-cn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTP/2 简介</a></li></ul><h2>微信公众号</h2><p>微信公众号 CyC2018 提供了该项目的离线阅读版本，后台回复 &#34;下载&#34; 即可领取。也提供了一份技术面试复习大纲，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点，后台回复 &#34;大纲&#34; 即可领取。我基本是按照这个大纲来进行复习的，对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68529668", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "面向对象思想", 
            "content": "<p></p><h2>一、三大特性</h2><h2>封装</h2><p>利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。</p><p>优点：</p><ul><li>减少耦合：可以独立地开发、测试、优化、使用、理解和修改</li><li>减轻维护的负担：可以更容易被程序员理解，并且在调试的时候可以不影响其他模块</li><li>有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能</li><li>提高软件的可重用性</li><li>降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的</li></ul><p>以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。</p><p>注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Person</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">gender</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getName</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getGender</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">gender</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">?</span> <span class=\"s\">&#34;man&#34;</span> <span class=\"o\">:</span> <span class=\"s\">&#34;woman&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">work</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">18</span> <span class=\"o\">&lt;=</span> <span class=\"n\">age</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">age</span> <span class=\"o\">&lt;=</span> <span class=\"n\">50</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">+</span> <span class=\"s\">&#34; is working very hard!&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">+</span> <span class=\"s\">&#34; can&#39;t work any more!&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>继承</h2><p>继承实现了  <b>IS-A</b>  关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。</p><p>Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为  <b>向上转型</b> 。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Animal</span> <span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"o\">();</span></code></pre></div><h2>多态</h2><p>多态分为编译时多态和运行时多态：</p><ul><li>编译时多态主要指方法的重载</li><li>运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定</li></ul><p>运行时多态有三个条件：</p><ul><li>继承</li><li>覆盖（重写）</li><li>向上转型</li></ul><p>下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Instrument</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">play</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Instument is playing...&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Wind</span> <span class=\"kd\">extends</span> <span class=\"n\">Instrument</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">play</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Wind is playing...&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Percussion</span> <span class=\"kd\">extends</span> <span class=\"n\">Instrument</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">play</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Percussion is playing...&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Music</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Instrument</span><span class=\"o\">&gt;</span> <span class=\"n\">instruments</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"n\">instruments</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Wind</span><span class=\"o\">());</span>\n        <span class=\"n\">instruments</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Percussion</span><span class=\"o\">());</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"n\">Instrument</span> <span class=\"n\">instrument</span> <span class=\"o\">:</span> <span class=\"n\">instruments</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">instrument</span><span class=\"o\">.</span><span class=\"na\">play</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Wind</span> <span class=\"n\">is</span> <span class=\"n\">playing</span><span class=\"o\">...</span>\n<span class=\"n\">Percussion</span> <span class=\"n\">is</span> <span class=\"n\">playing</span><span class=\"o\">...</span></code></pre></div><h2>二、类图</h2><p>以下类图使用 <a href=\"https://link.zhihu.com/?target=https%3A//www.planttext.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PlantUML</a> 绘制，更多语法及使用请参考：<a href=\"https://link.zhihu.com/?target=http%3A//plantuml.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">plantuml.com/</span><span class=\"invisible\"></span></a> 。</p><h2>泛化关系 (Generalization)</h2><p>用来描述继承关系，在 Java 中使用 extends 关键字。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-90a615e2f896a6a0fa599e64bfced1b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"302\" data-rawheight=\"352\" class=\"content_image\" width=\"302\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;302&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"302\" data-rawheight=\"352\" class=\"content_image lazy\" width=\"302\" data-actualsrc=\"https://pic4.zhimg.com/v2-90a615e2f896a6a0fa599e64bfced1b3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Generalization\n\nclass Vihical\nclass Car\nclass Trunck\n\nVihical &lt;|-- Car\nVihical &lt;|-- Trunck\n\n@enduml</code></pre></div><h2>实现关系 (Realization)</h2><p>用来实现一个接口，在 Java 中使用 implements 关键字。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5116aff9fd51c77bc91e8b93bb0f03c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"360\" class=\"content_image\" width=\"271\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;271&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"360\" class=\"content_image lazy\" width=\"271\" data-actualsrc=\"https://pic1.zhimg.com/v2-5116aff9fd51c77bc91e8b93bb0f03c0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Realization\n\ninterface MoveBehavior\nclass Fly\nclass Run\n\nMoveBehavior &lt;|.. Fly\nMoveBehavior &lt;|.. Run\n\n@enduml</code></pre></div><h2>聚合关系 (Aggregation)</h2><p>表示整体由部分组成，但是整体和部分不是强依赖的，整体不存在了部分还是会存在。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fe80d0bfc5318d6de8b7d0023e38e041_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic2.zhimg.com/v2-fe80d0bfc5318d6de8b7d0023e38e041_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic2.zhimg.com/v2-fe80d0bfc5318d6de8b7d0023e38e041_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fe80d0bfc5318d6de8b7d0023e38e041_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Aggregation\n\nclass Computer\nclass Keyboard\nclass Mouse\nclass Screen\n\nComputer o-- Keyboard\nComputer o-- Mouse\nComputer o-- Screen\n\n@enduml</code></pre></div><h2>组合关系 (Composition)</h2><p>和聚合不同，组合中整体和部分是强依赖的，整体不存在了部分也不存在了。比如公司和部门，公司没了部门就不存在了。但是公司和员工就属于聚合关系了，因为公司没了员工还在。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3b29f30dad1e53d8311e167615f128b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb\" width=\"467\" data-original=\"https://pic4.zhimg.com/v2-3b29f30dad1e53d8311e167615f128b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;467&#39; height=&#39;356&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"467\" data-original=\"https://pic4.zhimg.com/v2-3b29f30dad1e53d8311e167615f128b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3b29f30dad1e53d8311e167615f128b3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Composition\n\nclass Company\nclass DepartmentA\nclass DepartmentB\n\nCompany *-- DepartmentA\nCompany *-- DepartmentB\n\n@enduml</code></pre></div><h2>关联关系 (Association)</h2><p>表示不同类对象之间有关联，这是一种静态关系，与运行过程的状态无关，在最开始就可以确定。因此也可以用 1 对 1、多对 1、多对多这种关联关系来表示。比如学生和学校就是一种关联关系，一个学校可以有很多学生，但是一个学生只属于一个学校，因此这是一种多对一的关系，在运行开始之前就可以确定。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9f4f39c11d8b98a7b11052b6be7143ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"174\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;174&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"174\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic4.zhimg.com/v2-9f4f39c11d8b98a7b11052b6be7143ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Association\n\nclass School\nclass Student\n\nSchool &#34;1&#34; - &#34;n&#34; Student\n\n@enduml</code></pre></div><h2>依赖关系 (Dependency)</h2><p>和关联关系不同的是，依赖关系是在运行过程中起作用的。A 类和 B 类是依赖关系主要有三种形式：</p><ul><li>A 类是 B 类方法的局部变量；</li><li>A 类是 B 类方法当中的一个参数；</li><li>A 类向 B 类发送消息，从而影响 B 类发生变化。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-91da90365d7b191cfdcfc93b4015fc48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"537\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"537\" data-original=\"https://pic1.zhimg.com/v2-91da90365d7b191cfdcfc93b4015fc48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;537&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"537\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"537\" data-original=\"https://pic1.zhimg.com/v2-91da90365d7b191cfdcfc93b4015fc48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-91da90365d7b191cfdcfc93b4015fc48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@startuml\n\ntitle Dependency\n\nclass Vihicle {\n    move(MoveBehavior)\n}\n\ninterface MoveBehavior {\n    move()\n}\n\nnote &#34;MoveBehavior.move()&#34; as N\n\nVihicle ..&gt; MoveBehavior\n\nVihicle .. N\n\n@enduml</code></pre></div><h2>三、设计原则</h2><h2>S.O.L.I.D</h2><p>| 简写 | 全拼 | 中文翻译 | | :--: | :--: | :--: | | SRP | The Single Responsibility Principle    | 单一责任原则 | | OCP | The Open Closed Principle              | 开放封闭原则 | | LSP | The Liskov Substitution Principle      | 里氏替换原则 | | ISP | The Interface Segregation Principle    | 接口分离原则 | | DIP | The Dependency Inversion Principle     | 依赖倒置原则 |</p><h3>1. 单一责任原则</h3><blockquote> 修改一个类的原因应该只有一个。<br/> </blockquote><p>换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。</p><p>如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。</p><h3>2. 开放封闭原则</h3><blockquote> 类应该对扩展开放，对修改关闭。<br/> </blockquote><p>扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。</p><p>符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。</p><h3>3. 里氏替换原则</h3><blockquote> 子类对象必须能够替换掉所有父类对象。<br/> </blockquote><p>继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。</p><p>如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。</p><h3>4. 接口分离原则</h3><blockquote> 不应该强迫客户依赖于它们不用的方法。<br/> </blockquote><p>因此使用多个专门的接口比使用单一的总接口要好。</p><h3>5. 依赖倒置原则</h3><blockquote> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；<br/>抽象不应该依赖于细节，细节应该依赖于抽象。<br/> </blockquote><p>高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。</p><p>依赖于抽象意味着：</p><ul><li>任何变量都不应该持有一个指向具体类的指针或者引用；</li><li>任何类都不应该从具体类派生；</li><li>任何方法都不应该覆写它的任何基类中的已经实现的方法。</li></ul><h2>其他常见原则</h2><p>除了上述的经典原则，在实际开发中还有下面这些常见的设计原则。</p><p>| 简写    | 全拼    | 中文翻译 | | :--: | :--: | :--: | |LOD|    The Law of Demeter                   | 迪米特法则   | |CRP|    The Composite Reuse Principle        | 合成复用原则 | |CCP|    The Common Closure Principle         | 共同封闭原则 | |SAP|    The Stable Abstractions Principle    | 稳定抽象原则 | |SDP|    The Stable Dependencies Principle    | 稳定依赖原则 |</p><h3>1. 迪米特法则</h3><p>迪米特法则又叫作最少知识原则（Least Knowledge Principle，简写 LKP），就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。</p><h3>2. 合成复用原则</h3><p>尽量使用对象组合，而不是通过继承来达到复用的目的。</p><h3>3. 共同封闭原则</h3><p>一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。</p><h3>4. 稳定抽象原则</h3><p>最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟它的稳定性成正比。</p><h3>5. 稳定依赖原则</h3><p>包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性。</p><h2>参考资料</h2><ul><li>Java 编程思想</li><li>敏捷软件开发：原则、模式与实践</li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/shanyou/archive/2009/09/21/1570716.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">面向对象设计的 SOLID 原则</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//design-patterns.readthedocs.io/zh_CN/latest/read_uml.html%23generalization\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">看懂 UML 类图和时序图</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/wolf-sun/p/UML-Sequence-diagram.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">UML 系列——时序图（顺序图）sequence diagram</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/jianyuerensheng/article/details/51602015\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">面向对象编程三大特性 ------ 封装、继承、多态</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68529374", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "消息队列", 
            "content": "<p></p><h2>一、消息模型</h2><h2>点对点</h2><p>消息生产者向消息队列中发送了一个消息之后，只能被一个消费者消费一次。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5ea1e6953df65d1714f560c5c3f7ae38_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"283\" class=\"origin_image zh-lightbox-thumb\" width=\"717\" data-original=\"https://pic1.zhimg.com/v2-5ea1e6953df65d1714f560c5c3f7ae38_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;717&#39; height=&#39;283&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"283\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"717\" data-original=\"https://pic1.zhimg.com/v2-5ea1e6953df65d1714f560c5c3f7ae38_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5ea1e6953df65d1714f560c5c3f7ae38_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>发布/订阅</h2><p>消息生产者向频道发送一个消息之后，多个消费者可以从该频道订阅到这条消息并消费。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d7bf5b9fc78595a22998b3eaddfe78ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-d7bf5b9fc78595a22998b3eaddfe78ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;266&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-d7bf5b9fc78595a22998b3eaddfe78ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d7bf5b9fc78595a22998b3eaddfe78ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>发布与订阅模式和观察者模式有以下不同：</p><ul><li>观察者模式中，观察者和主题都知道对方的存在；而在发布与订阅模式中，生产者与消费者不知道对方的存在，它们之间通过频道进行通信。</li><li>观察者模式是同步的，当事件触发时，主题会调用观察者的方法，然后等待方法返回；而发布与订阅模式是异步的，生产者向频道发送一个消息之后，就不需要关心消费者何时去订阅这个消息，可以立即返回。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-217cd72a6c43eacaed822390b865920b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic4.zhimg.com/v2-217cd72a6c43eacaed822390b865920b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;465&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic4.zhimg.com/v2-217cd72a6c43eacaed822390b865920b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-217cd72a6c43eacaed822390b865920b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、使用场景</h2><h2>异步处理</h2><p>发送者将消息发送给消息队列之后，不需要同步等待消息接收者处理完毕，而是立即返回进行其它操作。消息接收者从消息队列中订阅消息之后异步处理。</p><p>例如在注册流程中通常需要发送验证邮件来确保注册用户身份的合法性，可以使用消息队列使发送验证邮件的操作异步处理，用户在填写完注册信息之后就可以完成注册，而将发送验证邮件这一消息发送到消息队列中。</p><p>只有在业务流程允许异步处理的情况下才能这么做，例如上面的注册流程中，如果要求用户对验证邮件进行点击之后才能完成注册的话，就不能再使用消息队列。</p><h2>流量削锋</h2><p>在高并发的场景下，如果短时间有大量的请求到达会压垮服务器。</p><p>可以将请求发送到消息队列中，服务器按照其处理能力从消息队列中订阅消息进行处理。</p><h2>应用解耦</h2><p>如果模块之间不直接进行调用，模块之间耦合度就会很低，那么修改一个模块或者新增一个模块对其它模块的影响会很小，从而实现可扩展性。</p><p>通过使用消息队列，一个模块只需要向消息队列中发送消息，其它模块可以选择性地从消息队列中订阅消息从而完成调用。</p><h2>三、可靠性</h2><h2>发送端的可靠性</h2><p>发送端完成操作后一定能将消息成功发送到消息队列中。</p><p>实现方法：在本地数据库建一张消息表，将消息数据与业务数据保存在同一数据库实例里，这样就可以利用本地数据库的事务机制。事务提交成功后，将消息表中的消息转移到消息队列中，若转移消息成功则删除消息表中的数据，否则继续重传。</p><h2>接收端的可靠性</h2><p>接收端能够从消息队列成功消费一次消息。</p><p>两种实现方法：</p><ul><li>保证接收端处理消息的业务逻辑具有幂等性：只要具有幂等性，那么消费多少次消息，最后处理的结果都是一样的。</li><li>保证消息具有唯一编号，并使用一张日志表来记录已经消费的消息编号。</li></ul><h2>参考资料</h2><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//developers-club.com/posts/270339/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Observer vs Pub-Sub</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/lizhitao/article/details/47723105\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">消息队列中点对点与发布订阅区别</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "消息队列", 
                    "tagLink": "https://api.zhihu.com/topics/19708788"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68529269", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "缓存", 
            "content": "<p></p><h2>命中率</h2><p>当某个请求能够通过访问缓存而得到响应时，称为缓存命中。</p><p>缓存命中率越高，缓存的利用率也就越高。</p><h2>最大空间</h2><p>缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。</p><p>当缓存存放的数据量超过最大空间时，就需要淘汰部分数据来存放新到达的数据。</p><h2>淘汰策略</h2><ul><li> FIFO（First In First Out）：先进先出策略，在实时性的场景下，需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最晚的数据）被淘汰。<br/> </li><li> LRU（Least Recently Used）：最近最久未使用策略，优先淘汰最久未使用的数据，也就是上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。<br/> </li><li> LFU（Least Frequently Used）：最不经常使用策略，优先淘汰一段时间内使用次数最少的数据。<br/> </li></ul><h2>二、LRU</h2><p>以下是基于 双向链表 + HashMap 的 LRU 算法实现，对算法的解释如下：</p><ul><li>访问某个节点时，将其从原来的位置删除，并重新插入到链表头部。这样就能保证链表尾部存储的就是最近最久未使用的节点，当节点数量大于缓存最大空间时就淘汰链表尾部的节点。</li><li>为了使删除操作时间复杂度为 O(1)，就不能采用遍历的方式找到某个节点。HashMap 存储着 Key 到节点的映射，通过 Key 就能以 O(1) 的时间得到节点，然后再以 O(1) 的时间将其从双向队列中删除。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LRU</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">Iterable</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">Node</span><span class=\"o\">&gt;</span> <span class=\"n\">map</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n        <span class=\"n\">Node</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n        <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n\n        <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">k</span> <span class=\"o\">=</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">v</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">public</span> <span class=\"nf\">LRU</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">maxSize</span> <span class=\"o\">=</span> <span class=\"n\">maxSize</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">maxSize</span> <span class=\"o\">*</span> <span class=\"n\">4</span> <span class=\"o\">/</span> <span class=\"n\">3</span><span class=\"o\">);</span>\n\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n        <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"n\">unlink</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n        <span class=\"n\">appendHead</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">v</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n            <span class=\"n\">unlink</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n        <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">);</span>\n        <span class=\"n\">appendHead</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Node</span> <span class=\"n\">toRemove</span> <span class=\"o\">=</span> <span class=\"n\">removeTail</span><span class=\"o\">();</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">toRemove</span><span class=\"o\">.</span><span class=\"na\">k</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">unlink</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">pre</span><span class=\"o\">;</span>\n        <span class=\"n\">Node</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n\n        <span class=\"n\">pre</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">appendHead</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">next</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"nf\">removeTail</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">pre</span><span class=\"o\">;</span>\n\n        <span class=\"n\">Node</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">pre</span><span class=\"o\">;</span>\n        <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n        <span class=\"n\">pre</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">pre</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">&gt;</span> <span class=\"nf\">iterator</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">&gt;()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n\n            <span class=\"nd\">@Override</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">hasNext</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">cur</span> <span class=\"o\">!=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"nd\">@Override</span>\n            <span class=\"kd\">public</span> <span class=\"n\">K</span> <span class=\"nf\">next</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">;</span>\n                <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n                <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">k</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>三、缓存位置</h2><h2>浏览器</h2><p>当 HTTP 响应允许进行缓存时，浏览器会将 HTML、CSS、JavaScript、图片等静态资源进行缓存。</p><h2>ISP</h2><p>网络服务提供商（ISP）是网络访问的第一跳，通过将数据缓存在 ISP 中能够大大提高用户的访问速度。</p><h2>反向代理</h2><p>反向代理位于服务器之前，请求与响应都需要经过反向代理。通过将数据缓存在反向代理，在用户请求反向代理时就可以直接使用缓存进行响应。</p><h2>本地缓存</h2><p>使用 Guava Cache 将数据缓存在服务器本地内存中，服务器代码可以直接读取本地内存中的缓存，速度非常快。</p><h2>分布式缓存</h2><p>使用 Redis、Memcache 等分布式缓存将数据缓存在分布式缓存系统中。</p><p>相对于本地缓存来说，分布式缓存单独部署，可以根据需求分配硬件资源。不仅如此，服务器集群都可以访问分布式缓存，而本地缓存需要在服务器集群之间进行同步，实现难度和性能开销上都非常大。</p><h2>数据库缓存</h2><p>MySQL 等数据库管理系统具有自己的查询缓存机制来提高查询效率。</p><h2>Java 内部的缓存</h2><p>Java 为了优化空间，提高字符串、基本数据类型包装类的创建效率，设计了字符串常量池及 Byte、Short、Character、Integer、Long、Boolean 这六种包装类缓冲池。</p><h2>CPU 多级缓存</h2><p>CPU 为了解决运算速度与主存 IO 速度不匹配的问题，引入了多级缓存结构，同时使用 MESI 等缓存一致性协议来解决多核 CPU 缓存数据一致性的问题。</p><h2>四、CDN</h2><p>内容分发网络（Content distribution network，CDN）是一种互连的网络系统，它利用更靠近用户的服务器从而更快更可靠地将 HTML、CSS、JavaScript、音乐、图片、视频等静态资源分发给用户。</p><p>CDN 主要有以下优点：</p><ul><li>更快地将数据分发给用户；</li><li>通过部署多台服务器，从而提高系统整体的带宽性能；</li><li>多台服务器可以看成是一种冗余机制，从而具有高可用性。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f2d9346f08500a6cc18339c8b4ae7dd9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb\" width=\"722\" data-original=\"https://pic2.zhimg.com/v2-f2d9346f08500a6cc18339c8b4ae7dd9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;722&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"722\" data-original=\"https://pic2.zhimg.com/v2-f2d9346f08500a6cc18339c8b4ae7dd9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f2d9346f08500a6cc18339c8b4ae7dd9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>五、缓存问题</h2><h2>缓存穿透</h2><p>指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。</p><p>解决方案：</p><ul><li>对这些不存在的数据缓存一个空数据；</li><li>对这类请求进行过滤。</li></ul><h2>缓存雪崩</h2><p>指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。</p><p>在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。</p><p>解决方案：</p><ul><li>为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；</li><li>为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。</li><li>也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li></ul><h2>缓存一致性</h2><p>缓存一致性要求数据更新的同时缓存数据也能够实时更新。</p><p>解决方案：</p><ul><li>在数据更新的同时立即去更新缓存；</li><li>在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新。</li></ul><p>要保证缓存一致性需要付出很大的代价，缓存数据最好是那些对一致性要求不高的数据，允许缓存数据存在一些脏数据。</p><h2>缓存 “无底洞” 现象</h2><p>指的是为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降了的现象。</p><p>产生原因：缓存系统通常采用 hash 函数将 key 映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及多次网络操作，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外，网络连接数变多，对节点的性能也有一定影响。</p><p>解决方案：</p><ul><li>优化批量数据操作命令；</li><li>减少网络通信次数；</li><li>降低接入成本，使用长连接 / 连接池，NIO 等。</li></ul><h2>六、数据分布</h2><h2>哈希分布</h2><p>哈希分布就是将数据计算哈希值之后，按照哈希值分配到不同的节点上。例如有 N 个节点，数据的主键为 key，则将该数据分配的节点序号为：hash(key)%N。</p><p>传统的哈希分布算法存在一个问题：当节点数量变化时，也就是 N 值变化，那么几乎所有的数据都需要重新分布，将导致大量的数据迁移。</p><h2>顺序分布</h2><p>将数据划分为多个连续的部分，按数据的 ID 或者时间分布到不同节点上。例如 User 表的 ID 范围为 1 \\~ 7000，使用顺序分布可以将其划分成多个子表，对应的主键范围为 1 \\~ 1000，1001 \\~ 2000，...，6001 \\~ 7000。</p><p>顺序分布相比于哈希分布的主要优点如下：</p><ul><li>能保持数据原有的顺序；</li><li>并且能够准确控制每台服务器存储的数据量，从而使得存储空间的利用率最大。</li></ul><h2>七、一致性哈希</h2><p>Distributed Hash Table（DHT） 是一种哈希分布方式，其目的是为了克服传统哈希分布在服务器节点数量变化时大量数据迁移的问题。</p><h2>基本原理</h2><p>将哈希空间 [0, 2n-1] 看成一个哈希环，每个服务器节点都配置到哈希环上。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4cfc481ef77a1f9b4a9e44518a6210d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-4cfc481ef77a1f9b4a9e44518a6210d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-4cfc481ef77a1f9b4a9e44518a6210d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4cfc481ef77a1f9b4a9e44518a6210d8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点，例如下图中新增节点 X，只需要将它前一个节点 C 上的数据重新进行分布即可，对于节点 A、B、D 都没有影响。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4c7c93dbef7596647e271ee04422caf7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"546\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb\" width=\"546\" data-original=\"https://pic4.zhimg.com/v2-4c7c93dbef7596647e271ee04422caf7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;546&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"546\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"546\" data-original=\"https://pic4.zhimg.com/v2-4c7c93dbef7596647e271ee04422caf7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4c7c93dbef7596647e271ee04422caf7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>虚拟节点</h2><p>上面描述的一致性哈希存在数据分布不均匀的问题，节点存储的数据量有可能会存在很大的不同。</p><p>数据不均匀主要是因为节点在哈希环上分布的不均匀，这种情况在节点数量很少的情况下尤其明显。</p><p>解决方式是通过增加虚拟节点，然后将虚拟节点映射到真实节点上。虚拟节点的数量比真实节点来得多，那么虚拟节点在哈希环上分布的均匀性就会比原来的真实节点好，从而使得数据分布也更加均匀。</p><h2>参考资料</h2><ul><li>大规模分布式存储系统</li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/cache_about.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">缓存那些事</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//my.oschina.net/jayhu/blog/732849\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一致性哈希算法</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2585%25A7%25E5%25AE%25B9%25E5%2582%25B3%25E9%2581%259E%25E7%25B6%25B2%25E8%25B7%25AF\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">内容分发网络</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.aspirationhosting.com/aspiration-cdn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How Aspiration CDN helps to improve your website loading speed?</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68529177", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "攻击技术", 
            "content": "<p></p><h2>一、跨站脚本攻击</h2><h2>概念</h2><p>跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。</p><h2>攻击原理</h2><p>例如有一个论坛网站，攻击者可以在上面发布以下内容：</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span><span class=\"nx\">location</span><span class=\"p\">.</span><span class=\"nx\">href</span><span class=\"o\">=</span><span class=\"s2\">&#34;//domain.com/?c=&#34;</span> <span class=\"o\">+</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">cookie</span><span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span></code></pre></div><p>之后该内容可能会被渲染成以下形式：</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;&lt;</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span><span class=\"nx\">location</span><span class=\"p\">.</span><span class=\"nx\">href</span><span class=\"o\">=</span><span class=\"s2\">&#34;//domain.com/?c=&#34;</span> <span class=\"o\">+</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">cookie</span><span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span></code></pre></div><p>另一个用户浏览了含有这个内容的页面将会跳转到 <a href=\"https://link.zhihu.com/?target=http%3A//domain.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">domain.com</span><span class=\"invisible\"></span></a> 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。</p><h2>危害</h2><ul><li>窃取用户的 Cookie</li><li>伪造虚假的输入表单骗取个人信息</li><li>显示伪造的文章或者图片</li></ul><h2>防范手段</h2><h3>1. 设置 Cookie 为 HttpOnly</h3><p>设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。</p><h3>2. 过滤特殊字符</h3><p>例如将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，从而避免 HTML 和 Jascript 代码的运行。</p><p>富文本编辑器允许用户输入 HTML 代码，就不能简单地将 <code>&lt;</code> 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。</p><p>富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。</p><p>以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">h1</span> <span class=\"na\">id</span><span class=\"o\">=</span><span class=\"s\">&#34;title&#34;</span><span class=\"p\">&gt;</span>XSS Demo<span class=\"p\">&lt;/</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>123<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">form</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">input</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">&#34;text&#34;</span> <span class=\"na\">name</span><span class=\"o\">=</span><span class=\"s\">&#34;q&#34;</span> <span class=\"na\">value</span><span class=\"o\">=</span><span class=\"s\">&#34;test&#34;</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">form</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>hello<span class=\"p\">&lt;/</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">script</span> <span class=\"na\">type</span><span class=\"o\">=</span><span class=\"s\">&#34;text/javascript&#34;</span><span class=\"p\">&gt;</span>\n<span class=\"nx\">alert</span><span class=\"p\">(</span><span class=\"sr\">/xss/</span><span class=\"p\">);</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">script</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>XSS Demo<span class=\"p\">&lt;/</span><span class=\"nt\">h1</span><span class=\"p\">&gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>123<span class=\"p\">&lt;/</span><span class=\"nt\">p</span><span class=\"p\">&gt;</span>\n\n<span class=\"ni\">&amp;lt;</span>form<span class=\"ni\">&amp;gt;</span>\n  <span class=\"ni\">&amp;lt;</span>input type=&#34;text&#34; name=&#34;q&#34; value=&#34;test&#34;<span class=\"ni\">&amp;gt;</span>\n<span class=\"ni\">&amp;lt;</span>/form<span class=\"ni\">&amp;gt;</span>\n\n<span class=\"p\">&lt;</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>hello<span class=\"p\">&lt;/</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>\n\n<span class=\"ni\">&amp;lt;</span>script type=&#34;text/javascript&#34;<span class=\"ni\">&amp;gt;</span>\nalert(/xss/);\n<span class=\"ni\">&amp;lt;</span>/script<span class=\"ni\">&amp;gt;</span></code></pre></div><blockquote><a href=\"https://link.zhihu.com/?target=http%3A//jsxss.com/zh/try.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XSS 过滤在线测试</a><br/> </blockquote><h2>二、跨站请求伪造</h2><h2>概念</h2><p>跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。</p><p>XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。</p><h2>攻击原理</h2><p>假如一家银行用以执行转账操作的 URL 地址如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName。</code></pre></div><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;img src=&#34;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&#34;&gt;。</code></pre></div><p>如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。</p><p>通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。</p><h2>防范手段</h2><h3>1. 检查 Referer 首部字段</h3><p>Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。</p><h3>2. 添加校验 Token</h3><p>在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。</p><h3>3. 输入验证码</h3><p>因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。</p><h2>三、SQL 注入攻击</h2><h2>概念</h2><p>服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。</p><h2>攻击原理</h2><p>例如一个网站登录验证的 SQL 查询代码为：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">strSQL</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;SELECT * FROM users WHERE (name = &#39;&#34;</span> <span class=\"o\">+</span> <span class=\"n\">userName</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;&#39;) and (pw = &#39;&#34;</span><span class=\"o\">+</span> <span class=\"n\">passWord</span> <span class=\"o\">+</span><span class=\"s2\">&#34;&#39;);&#34;</span></code></pre></div><p>如果填入以下内容：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">userName</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;1&#39; OR &#39;1&#39;=&#39;1&#34;</span><span class=\"p\">;</span>\n<span class=\"n\">passWord</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;1&#39; OR &#39;1&#39;=&#39;1&#34;</span><span class=\"p\">;</span></code></pre></div><p>那么 SQL 查询字符串为：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">strSQL</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;SELECT * FROM users WHERE (name = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;) and (pw = &#39;1&#39; OR &#39;1&#39;=&#39;1&#39;);&#34;</span></code></pre></div><p>此时无需验证通过就能执行以下查询：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">strSQL</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;SELECT * FROM users;&#34;</span></code></pre></div><h2>防范手段</h2><h3>1. 使用参数化查询</h3><p>Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">PreparedStatement</span> <span class=\"n\">stmt</span> <span class=\"o\">=</span> <span class=\"n\">connection</span><span class=\"o\">.</span><span class=\"na\">prepareStatement</span><span class=\"o\">(</span><span class=\"s\">&#34;SELECT * FROM users WHERE userid=? AND password=?&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">stmt</span><span class=\"o\">.</span><span class=\"na\">setString</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">userid</span><span class=\"o\">);</span>\n<span class=\"n\">stmt</span><span class=\"o\">.</span><span class=\"na\">setString</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">password</span><span class=\"o\">);</span>\n<span class=\"n\">ResultSet</span> <span class=\"n\">rs</span> <span class=\"o\">=</span> <span class=\"n\">stmt</span><span class=\"o\">.</span><span class=\"na\">executeQuery</span><span class=\"o\">();</span></code></pre></div><h3>2. 单引号转换</h3><p>将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。</p><h2>四、拒绝服务攻击</h2><p>拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p><p>分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。</p><h2>参考资料</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25B7%25A8%25E7%25B6%25B2%25E7%25AB%2599%25E6%258C%2587%25E4%25BB%25A4%25E7%25A2%25BC\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科：跨站脚本</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/SQL%25E8%25B3%2587%25E6%2596%2599%25E9%259A%25B1%25E7%25A2%25BC%25E6%2594%25BB%25E6%2593%258A\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科：SQL 注入攻击</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25B7%25A8%25E7%25AB%2599%25E8%25AF%25B7%25E6%25B1%2582%25E4%25BC%25AA%25E9%2580%25A0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科：跨站点请求伪造</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2598%25BB%25E6%2596%25B7%25E6%259C%258D%25E5%258B%2599%25E6%2594%25BB%25E6%2593%258A\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科：拒绝服务攻击</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "网络攻击", 
                    "tagLink": "https://api.zhihu.com/topics/19568943"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68528961", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "集群", 
            "content": "<p></p><h2>一、负载均衡</h2><p>集群中的应用服务器（节点）通常被设计成无状态，用户可以请求任何一个节点。</p><p>负载均衡器会根据集群中每个节点的负载情况，将用户请求转发到合适的节点上。</p><p>负载均衡器可以用来实现高可用以及伸缩性：</p><ul><li>高可用：当某个节点故障时，负载均衡器会将用户请求转发到另外的节点上，从而保证所有服务持续可用；</li><li>伸缩性：根据系统整体负载情况，可以很容易地添加或移除节点。</li></ul><p>负载均衡器运行过程包含两个部分：</p><ol><li>根据负载均衡算法得到转发的节点；</li><li>进行转发。</li></ol><h2>负载均衡算法</h2><h3>1. 轮询（Round Robin）</h3><p>轮询算法把每个请求轮流发送到每个服务器上。</p><p>下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3b945cbeba438d1d8bc26029b81840a7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-3b945cbeba438d1d8bc26029b81840a7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;768&#39; height=&#39;594&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"768\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"768\" data-original=\"https://pic4.zhimg.com/v2-3b945cbeba438d1d8bc26029b81840a7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3b945cbeba438d1d8bc26029b81840a7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>该算法比较适合每个服务器的性能差不多的场景，如果有性能存在差异的情况下，那么性能较差的服务器可能无法承担过大的负载（下图的 Server 2）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0aece687ab2b9cea0c17e53007bbfd59_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic2.zhimg.com/v2-0aece687ab2b9cea0c17e53007bbfd59_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;570&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic2.zhimg.com/v2-0aece687ab2b9cea0c17e53007bbfd59_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0aece687ab2b9cea0c17e53007bbfd59_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 加权轮询（Weighted Round Robbin）</h3><p>加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。</p><p>例如下图中，服务器 1 被赋予的权值为 5，服务器 2 被赋予的权值为 1，那么 (1, 2, 3, 4, 5) 请求会被发送到服务器 1，(6) 请求会被发送到服务器 2。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ebce95b98391a5a97519066b79889d7c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb\" width=\"733\" data-original=\"https://pic1.zhimg.com/v2-ebce95b98391a5a97519066b79889d7c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;733&#39; height=&#39;561&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"733\" data-original=\"https://pic1.zhimg.com/v2-ebce95b98391a5a97519066b79889d7c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ebce95b98391a5a97519066b79889d7c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. 最少连接（least Connections）</h3><p>由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。</p><p>例如下图中，(1, 3, 5) 请求会被发送到服务器 1，但是 (1, 3) 很快就断开连接，此时只有 (5) 请求连接服务器 1；(2, 4, 6) 请求被发送到服务器 2，只有 (2) 的连接断开，此时 (6, 4) 请求连接服务器 2。该系统继续运行时，服务器 2 会承担过大的负载。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bcb11da0591632e4b3ba5634a70aa75d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb\" width=\"718\" data-original=\"https://pic2.zhimg.com/v2-bcb11da0591632e4b3ba5634a70aa75d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;718&#39; height=&#39;591&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"718\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"718\" data-original=\"https://pic2.zhimg.com/v2-bcb11da0591632e4b3ba5634a70aa75d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bcb11da0591632e4b3ba5634a70aa75d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最少连接算法就是将请求发送给当前最少连接数的服务器上。</p><p>例如下图中，服务器 1 当前连接数最小，那么新到来的请求 6 就会被发送到服务器 1 上。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6b426f75006a7cc2075aade42237adf7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb\" width=\"721\" data-original=\"https://pic4.zhimg.com/v2-6b426f75006a7cc2075aade42237adf7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;721&#39; height=&#39;560&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"560\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"721\" data-original=\"https://pic4.zhimg.com/v2-6b426f75006a7cc2075aade42237adf7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6b426f75006a7cc2075aade42237adf7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4. 加权最少连接（Weighted Least Connection）</h3><p>在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数。</p><h3>5. 随机算法（Random）</h3><p>把请求随机发送到服务器上。</p><p>和轮询算法类似，该算法比较适合服务器性能差不多的场景。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-97daa42a790f2a0e42fa6b3f7ff4c0ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-97daa42a790f2a0e42fa6b3f7ff4c0ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;566&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"566\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-97daa42a790f2a0e42fa6b3f7ff4c0ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-97daa42a790f2a0e42fa6b3f7ff4c0ea_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>6. 源地址哈希法 (IP Hash)</h3><p>源地址哈希通过对客户端 IP 计算哈希值之后，再对服务器数量取模得到目标服务器的序号。</p><p>可以保证同一 IP 的客户端的请求会转发到同一台服务器上，用来实现会话粘滞（Sticky Session）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1b2787e22b69aed6521c64c9a38d9b3f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"777\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb\" width=\"777\" data-original=\"https://pic4.zhimg.com/v2-1b2787e22b69aed6521c64c9a38d9b3f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;777&#39; height=&#39;595&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"777\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"777\" data-original=\"https://pic4.zhimg.com/v2-1b2787e22b69aed6521c64c9a38d9b3f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1b2787e22b69aed6521c64c9a38d9b3f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>转发实现</h2><h3>1. HTTP 重定向</h3><p>HTTP 重定向负载均衡服务器使用某种负载均衡算法计算得到服务器的 IP 地址之后，将该地址写入 HTTP 重定向报文中，状态码为 302。客户端收到重定向报文之后，需要重新向服务器发起请求。</p><p>缺点：</p><ul><li>需要两次请求，因此访问延迟比较高；</li><li>HTTP 负载均衡器处理能力有限，会限制集群的规模。</li></ul><p>该负载均衡转发的缺点比较明显，实际场景中很少使用它。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8cec4803cd277056378d71b4d1dd3eae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb\" width=\"821\" data-original=\"https://pic3.zhimg.com/v2-8cec4803cd277056378d71b4d1dd3eae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;821&#39; height=&#39;399&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"399\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"821\" data-original=\"https://pic3.zhimg.com/v2-8cec4803cd277056378d71b4d1dd3eae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8cec4803cd277056378d71b4d1dd3eae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. DNS 域名解析</h3><p>在 DNS 解析域名的同时使用负载均衡算法计算服务器 IP 地址。</p><p>优点：</p><ul><li>DNS 能够根据地理位置进行域名解析，返回离用户最近的服务器 IP 地址。</li></ul><p>缺点：</p><ul><li>由于 DNS 具有多级结构，每一级的域名记录都可能被缓存，当下线一台服务器需要修改 DNS 记录时，需要过很长一段时间才能生效。</li></ul><p>大型网站基本使用了 DNS 做为第一级负载均衡手段，然后在内部使用其它方式做第二级负载均衡。也就是说，域名解析的结果为内部的负载均衡服务器 IP 地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-af25505fa3b5bfe22edccd0b0c20f6d6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic3.zhimg.com/v2-af25505fa3b5bfe22edccd0b0c20f6d6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;416&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic3.zhimg.com/v2-af25505fa3b5bfe22edccd0b0c20f6d6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-af25505fa3b5bfe22edccd0b0c20f6d6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. 反向代理服务器</h3><p>反向代理服务器位于源服务器前面，用户的请求需要先经过反向代理服务器才能到达源服务器。反向代理可以用来进行缓存、日志记录等，同时也可以用来做为负载均衡服务器。</p><p>在这种负载均衡转发方式下，客户端不直接请求源服务器，因此源服务器不需要外部 IP 地址，而反向代理需要配置内部和外部两套 IP 地址。</p><p>优点：</p><ul><li>与其它功能集成在一起，部署简单。</li></ul><p>缺点：</p><ul><li>所有请求和响应都需要经过反向代理服务器，它可能会成为性能瓶颈。</li></ul><h3>4. 网络层</h3><p>在操作系统内核进程获取网络数据包，根据负载均衡算法计算源服务器的 IP 地址，并修改请求数据包的目的 IP 地址，最后进行转发。</p><p>源服务器返回的响应也需要经过负载均衡服务器，通常是让负载均衡服务器同时作为集群的网关服务器来实现。</p><p>优点：</p><ul><li>在内核进程中进行处理，性能比较高。</li></ul><p>缺点：</p><ul><li>和反向代理一样，所有的请求和响应都经过负载均衡服务器，会成为性能瓶颈。</li></ul><h3>5. 链路层</h3><p>在链路层根据负载均衡算法计算源服务器的 MAC 地址，并修改请求数据包的目的 MAC 地址，并进行转发。</p><p>通过配置源服务器的虚拟 IP 地址和负载均衡服务器的 IP 地址一致，从而不需要修改 IP 地址就可以进行转发。也正因为 IP 地址一样，所以源服务器的响应不需要转发回负载均衡服务器，可以直接转发给客户端，避免了负载均衡服务器的成为瓶颈。</p><p>这是一种三角传输模式，被称为直接路由。对于提供下载和视频服务的网站来说，直接路由避免了大量的网络传输数据经过负载均衡服务器。</p><p>这是目前大型网站使用最广负载均衡转发方式，在 Linux 平台可以使用的负载均衡服务器为 LVS（Linux Virtual Server）。</p><p>参考：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.jscape.com/blog/load-balancing-algorithms\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Comparing Load Balancing Algorithms</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//slideplayer.com/slide/6599069/%23\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Redirection and Load Balancing</a></li></ul><h2>二、集群下的 Session 管理</h2><p>一个用户的 Session 信息如果存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器，由于服务器没有用户的 Session 信息，那么该用户就需要重新进行登录等操作。</p><h2>Sticky Session</h2><p>需要配置负载均衡器，使得一个用户的所有请求都路由到同一个服务器，这样就可以把用户的 Session 存放在该服务器中。</p><p>缺点：</p><ul><li>当服务器宕机时，将丢失该服务器上的所有 Session。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b6783034eb0e2b5bcac8ef8f4a54d47b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb\" width=\"716\" data-original=\"https://pic4.zhimg.com/v2-b6783034eb0e2b5bcac8ef8f4a54d47b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;716&#39; height=&#39;520&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"716\" data-original=\"https://pic4.zhimg.com/v2-b6783034eb0e2b5bcac8ef8f4a54d47b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b6783034eb0e2b5bcac8ef8f4a54d47b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Session Replication</h2><p>在服务器之间进行 Session 同步操作，每个服务器都有所有用户的 Session 信息，因此用户可以向任何一个服务器进行请求。</p><p>缺点：</p><ul><li>占用过多内存；</li><li>同步过程占用网络带宽以及服务器处理器时间。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-83a40112583526f55e3a9f87f9400d41_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"683\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-83a40112583526f55e3a9f87f9400d41_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;701&#39; height=&#39;683&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"683\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-83a40112583526f55e3a9f87f9400d41_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-83a40112583526f55e3a9f87f9400d41_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Session Server</h2><p>使用一个单独的服务器存储 Session 数据，可以使用传统的 MySQL，也使用 Redis 或者 Memcached 这种内存型数据库。</p><p>优点：</p><ul><li>为了使得大型网站具有伸缩性，集群中的应用服务器通常需要保持无状态，那么应用服务器不能存储用户的会话信息。Session Server 将用户的会话信息单独进行存储，从而保证了应用服务器的无状态。</li></ul><p>缺点：</p><ul><li>需要去实现存取 Session 的代码。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7ad85df981c5f5ad0b6ea20f73f766ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"547\" class=\"origin_image zh-lightbox-thumb\" width=\"1046\" data-original=\"https://pic3.zhimg.com/v2-7ad85df981c5f5ad0b6ea20f73f766ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1046&#39; height=&#39;547&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"547\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1046\" data-original=\"https://pic3.zhimg.com/v2-7ad85df981c5f5ad0b6ea20f73f766ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7ad85df981c5f5ad0b6ea20f73f766ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>参考：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//sivalabs.in/2018/02/session-management-using-spring-session-jdbc-datastore/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Session Management using Spring Session with JDBC DataStore</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;937&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"937\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"937\" data-original=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a4a3f26355998cfe8c467463a32a80d_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "集群", 
                    "tagLink": "https://api.zhihu.com/topics/19596215"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500828", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 2, 
            "title": "分布式", 
            "content": "<p></p><h2>一、分布式锁</h2><p>在单机场景下，可以使用语言的内置锁来实现进程同步。但是在分布式场景下，需要同步的进程可能位于不同的节点上，那么就需要使用分布式锁。</p><p>阻塞锁通常使用互斥量来实现：</p><ul><li>互斥量为 0 表示有其它进程在使用锁，此时处于锁定状态；</li><li>互斥量为 1 表示未锁定状态。</li></ul><p>1 和 0 可以用一个整型值表示，也可以用某个数据是否存在表示。</p><h2>数据库的唯一索引</h2><p>获得锁时向表中插入一条记录，释放锁时删除这条记录。唯一索引可以保证该记录只被插入一次，那么就可以用这个记录是否存在来判断是否存于锁定状态。</p><p>存在以下几个问题：</p><ul><li>锁没有失效时间，解锁失败的话其它进程无法再获得该锁。</li><li>只能是非阻塞锁，插入失败直接就报错了，无法重试。</li><li>不可重入，已经获得锁的进程也必须重新获取锁。</li></ul><h2>Redis 的 SETNX 指令</h2><p>使用 SETNX（set if not exist）指令插入一个键值对，如果 Key 已经存在，那么会返回 False，否则插入成功并返回 True。</p><p>SETNX 指令和数据库的唯一索引类似，保证了只存在一个 Key 的键值对，那么可以用一个 Key 的键值对是否存在来判断是否存于锁定状态。</p><p>EXPIRE 指令可以为一个键值对设置一个过期时间，从而避免了数据库唯一索引实现方式中释放锁失败的问题。</p><h2>Redis 的 RedLock 算法</h2><p>使用了多个 Redis 实例来实现分布式锁，这是为了保证在发生单点故障时仍然可用。</p><ul><li>尝试从 N 个互相独立 Redis 实例获取锁；</li><li>计算获取锁消耗的时间，只有当这个时间小于锁的过期时间，并且从大多数（N / 2 + 1）实例上获取了锁，那么就认为锁获取成功了；</li><li>如果锁获取失败，就到每个实例上释放锁。</li></ul><h2>Zookeeper 的有序节点</h2><h3>1. Zookeeper 抽象模型</h3><p>Zookeeper 提供了一种树形结构的命名空间，/app1/p_1 节点的父节点为 /app1。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46b1745f183af70652fb8355481cda0b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"566\" data-original=\"https://pic4.zhimg.com/v2-46b1745f183af70652fb8355481cda0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;566&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"566\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"566\" data-original=\"https://pic4.zhimg.com/v2-46b1745f183af70652fb8355481cda0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46b1745f183af70652fb8355481cda0b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 节点类型</h3><ul><li>永久节点：不会因为会话结束或者超时而消失；</li><li>临时节点：如果会话结束或者超时就会消失；</li><li>有序节点：会在节点名的后面加一个数字后缀，并且是有序的，例如生成的有序节点为 /lock/node-0000000000，它的下一个有序节点则为 /lock/node-0000000001，以此类推。</li></ul><h3>3. 监听器</h3><p>为一个节点注册监听器，在节点状态发生改变时，会给客户端发送消息。</p><h3>4. 分布式锁实现</h3><ul><li>创建一个锁目录 /lock；</li><li>当一个客户端需要获取锁时，在 /lock 下创建临时的且有序的子节点；</li><li>客户端获取 /lock 下的子节点列表，判断自己创建的子节点是否为当前子节点列表中序号最小的子节点，如果是则认为获得锁；否则监听自己的前一个子节点，获得子节点的变更通知后重复此步骤直至获得锁；</li><li>执行业务代码，完成后，删除对应的子节点。</li></ul><h3>5. 会话超时</h3><p>如果一个已经获得锁的会话超时了，因为创建的是临时节点，所以该会话对应的临时节点会被删除，其它会话就可以获得锁了。可以看到，Zookeeper 分布式锁不会出现数据库的唯一索引实现的分布式锁释放锁失败问题。</p><h3>6. 羊群效应</h3><p>一个节点未获得锁，只需要监听自己的前一个子节点，这是因为如果监听所有的子节点，那么任意一个子节点状态改变，其它所有子节点都会收到通知（羊群效应），而我们只希望它的后一个子节点收到通知。</p><h2>二、分布式事务</h2><p>指事务的操作位于不同的节点上，需要保证事务的 ACID 特性。</p><p>例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。</p><h2>2PC</h2><p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p><h3>1. 运行过程</h3><h3>1.1 准备阶段</h3><p>协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cb9e81a4c9f8f95514ac62171605475a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1006\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb\" width=\"1006\" data-original=\"https://pic3.zhimg.com/v2-cb9e81a4c9f8f95514ac62171605475a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1006&#39; height=&#39;366&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1006\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1006\" data-original=\"https://pic3.zhimg.com/v2-cb9e81a4c9f8f95514ac62171605475a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cb9e81a4c9f8f95514ac62171605475a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1.2 提交阶段</h3><p>如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。</p><p>需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c2b0eba5c21dd924b536ee28c75b20fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"996\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"996\" data-original=\"https://pic3.zhimg.com/v2-c2b0eba5c21dd924b536ee28c75b20fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;996&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"996\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"996\" data-original=\"https://pic3.zhimg.com/v2-c2b0eba5c21dd924b536ee28c75b20fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c2b0eba5c21dd924b536ee28c75b20fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 存在的问题</h3><h3>2.1 同步阻塞</h3><p>所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</p><h3>2.2 单点问题</h3><p>协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待，无法完成其它操作。</p><h3>2.3 数据不一致</h3><p>在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</p><h3>2.4 太过保守</h3><p>任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</p><h2>本地消息表</h2><p>本地消息表与业务数据表处于同一个数据库中，这样就能利用本地事务来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。</p><ol><li>在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。</li><li>之后将本地消息表中的消息转发到消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。</li><li>在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8836bd7f0a76edbee12cfbbc87728db7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1258\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb\" width=\"1258\" data-original=\"https://pic4.zhimg.com/v2-8836bd7f0a76edbee12cfbbc87728db7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1258&#39; height=&#39;459&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1258\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1258\" data-original=\"https://pic4.zhimg.com/v2-8836bd7f0a76edbee12cfbbc87728db7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8836bd7f0a76edbee12cfbbc87728db7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、CAP</h2><p>分布式系统不可能同时满足一致性（C：Consistency）、可用性（A：Availability）和分区容忍性（P：Partition Tolerance），最多只能同时满足其中两项。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5a8d572e401dd09dceaa9bb2d7b05a7c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"734\" class=\"origin_image zh-lightbox-thumb\" width=\"683\" data-original=\"https://pic1.zhimg.com/v2-5a8d572e401dd09dceaa9bb2d7b05a7c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;683&#39; height=&#39;734&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"734\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"683\" data-original=\"https://pic1.zhimg.com/v2-5a8d572e401dd09dceaa9bb2d7b05a7c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5a8d572e401dd09dceaa9bb2d7b05a7c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>一致性</h2><p>一致性指的是多个数据副本是否能保持一致的特性，在一致性的条件下，系统在执行数据更新操作之后能够从一致性状态转移到另一个一致性状态。</p><p>对系统的一个数据更新成功之后，如果所有用户都能够读取到最新的值，该系统就被认为具有强一致性。</p><h2>可用性</h2><p>可用性指分布式系统在面对各种异常时可以提供正常服务的能力，可以用系统可用时间占总时间的比值来衡量，4 个 9 的可用性表示系统 99.99% 的时间是可用的。</p><p>在可用性条件下，要求系统提供的服务一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。</p><h2>分区容忍性</h2><p>网络分区指分布式系统中的节点被划分为多个区域，每个区域内部可以通信，但是区域之间无法通信。</p><p>在分区容忍性条件下，分布式系统在遇到任何网络分区故障的时候，仍然需要能对外提供一致性和可用性的服务，除非是整个网络环境都发生了故障。</p><h2>权衡</h2><p>在分布式系统中，分区容忍性必不可少，因为需要总是假设网络是不可靠的。因此，CAP 理论实际上是要在可用性和一致性之间做权衡。</p><p>可用性和一致性往往是冲突的，很难使它们同时满足。在多个节点之间进行数据同步时，</p><ul><li>为了保证一致性（CP），不能访问未同步完成的节点，也就失去了部分可用性；</li><li>为了保证可用性（AP），允许读取所有节点的数据，但是数据可能不一致。</li></ul><h2>四、BASE</h2><p>BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><h2>基本可用</h2><p>指分布式系统在出现故障的时候，保证核心可用，允许损失部分可用性。</p><p>例如，电商在做促销时，为了保证购物系统的稳定性，部分消费者可能会被引导到一个降级的页面。</p><h2>软状态</h2><p>指允许系统中的数据存在中间状态，并认为该中间状态不会影响系统整体可用性，即允许系统不同节点的数据副本之间进行同步的过程存在时延。</p><h2>最终一致性</h2><p>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能达到一致的状态。</p><p>ACID 要求强一致性，通常运用在传统的数据库系统上。而 BASE 要求最终一致性，通过牺牲强一致性来达到可用性，通常运用在大型分布式系统中。</p><p>在实际的分布式场景中，不同业务单元和组件对一致性的要求是不同的，因此 ACID 和 BASE 往往会结合在一起使用。</p><h2>五、Paxos</h2><p>用于达成共识性问题，即对多个节点产生的值，该算法能保证只选出唯一一个值。</p><p>主要有三类节点：</p><ul><li>提议者（Proposer）：提议一个值；</li><li>接受者（Acceptor）：对每个提议进行投票；</li><li>告知者（Learner）：被告知投票的结果，不参与投票过程。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2e28af608c6c3a970a27becbbdaf7830_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-2e28af608c6c3a970a27becbbdaf7830_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;635&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-2e28af608c6c3a970a27becbbdaf7830_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2e28af608c6c3a970a27becbbdaf7830_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>执行过程</h2><p>规定一个提议包含两个字段：[n, v]，其中 n 为序号（具有唯一性），v 为提议值。</p><h3>1. Prepare 阶段</h3><p>下图演示了两个 Proposer 和三个 Acceptor 的系统中运行该算法的初始过程，每个 Proposer 都会向所有 Acceptor 发送 Prepare 请求。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b89ed9e47cef15c83e61dc97bf1e0fdc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-b89ed9e47cef15c83e61dc97bf1e0fdc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;475&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-b89ed9e47cef15c83e61dc97bf1e0fdc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b89ed9e47cef15c83e61dc97bf1e0fdc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n1, v1]，并且之前还未接收过 Prepare 请求，那么发送一个 Prepare 响应，设置当前接收到的提议为 [n1, v1]，并且保证以后不会再接受序号小于 n1 的提议。</p><p>如下图，Acceptor X 在收到 [n=2, v=8] 的 Prepare 请求时，由于之前没有接收过提议，因此就发送一个 [no previous] 的 Prepare 响应，设置当前接收到的提议为 [n=2, v=8]，并且保证以后不会再接受序号小于 2 的提议。其它的 Acceptor 类似。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9f2998a5cf9e637bd89f01d25fa208d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"744\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb\" width=\"744\" data-original=\"https://pic2.zhimg.com/v2-9f2998a5cf9e637bd89f01d25fa208d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;744&#39; height=&#39;470&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"744\" data-rawheight=\"470\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"744\" data-original=\"https://pic2.zhimg.com/v2-9f2998a5cf9e637bd89f01d25fa208d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9f2998a5cf9e637bd89f01d25fa208d9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果 Acceptor 接收到一个 Prepare 请求，包含的提议为 [n2, v2]，并且之前已经接收过提议 [n1, v1]。如果 n1 &gt; n2，那么就丢弃该提议请求；否则，发送 Prepare 响应，该 Prepare 响应包含之前已经接收过的提议 [n1, v1]，设置当前接收到的提议为 [n2, v2]，并且保证以后不会再接受序号小于 n2 的提议。</p><p>如下图，Acceptor Z 收到 Proposer A 发来的 [n=2, v=8] 的 Prepare 请求，由于之前已经接收过 [n=4, v=5] 的提议，并且 n &gt; 2，因此就抛弃该提议请求；Acceptor X 收到 Proposer B 发来的 [n=4, v=5] 的 Prepare 请求，因为之前接收到的提议为 [n=2, v=8]，并且 2 &lt;= 4，因此就发送 [n=2, v=8] 的 Prepare 响应，设置当前接收到的提议为 [n=4, v=5]，并且保证以后不会再接受序号小于 4 的提议。Acceptor Y 类似。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e9871a19edc2ce86be42f40370afce65_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"463\" class=\"origin_image zh-lightbox-thumb\" width=\"712\" data-original=\"https://pic2.zhimg.com/v2-e9871a19edc2ce86be42f40370afce65_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;712&#39; height=&#39;463&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"463\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"712\" data-original=\"https://pic2.zhimg.com/v2-e9871a19edc2ce86be42f40370afce65_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e9871a19edc2ce86be42f40370afce65_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. Accept 阶段</h3><p>当一个 Proposer 接收到超过一半 Acceptor 的 Prepare 响应时，就可以发送 Accept 请求。</p><p>Proposer A 接收到两个 Prepare 响应之后，就发送 [n=2, v=8] Accept 请求。该 Accept 请求会被所有 Acceptor 丢弃，因为此时所有 Acceptor 都保证不接受序号小于 4 的提议。</p><p>Proposer B 过后也收到了两个 Prepare 响应，因此也开始发送 Accept 请求。需要注意的是，Accept 请求的 v 需要取它收到的最大提议编号对应的 v 值，也就是 8。因此它发送 [n=4, v=8] 的 Accept 请求。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d29e4a5e9bc89c187674ebd884a7f571_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb\" width=\"481\" data-original=\"https://pic2.zhimg.com/v2-d29e4a5e9bc89c187674ebd884a7f571_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;481&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"481\" data-original=\"https://pic2.zhimg.com/v2-d29e4a5e9bc89c187674ebd884a7f571_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d29e4a5e9bc89c187674ebd884a7f571_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. Learn 阶段</h3><p>Acceptor 接收到 Accept 请求时，如果序号大于等于该 Acceptor 承诺的最小序号，那么就发送 Learn 提议给所有的 Learner。当 Learner 发现有大多数的 Acceptor 接收了某个提议，那么该提议的提议值就被 Paxos 选择出来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b9a37e5de8950c24bd5275f5253404ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic4.zhimg.com/v2-b9a37e5de8950c24bd5275f5253404ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;353&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic4.zhimg.com/v2-b9a37e5de8950c24bd5275f5253404ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b9a37e5de8950c24bd5275f5253404ef_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>约束条件</h2><h3>1. 正确性</h3><p>指只有一个提议值会生效。</p><p>因为 Paxos 协议要求每个生效的提议被多数 Acceptor 接收，并且 Acceptor 不会接受两个不同的提议，因此可以保证正确性。</p><h3>2. 可终止性</h3><p>指最后总会有一个提议生效。</p><p>Paxos 协议能够让 Proposer 发送的提议朝着能被大多数 Acceptor 接受的那个提议靠拢，因此能够保证可终止性。</p><h2>六、Raft</h2><p>Raft 也是分布式一致性协议，主要是用来竞选主节点。</p><h2>单个 Candidate 的竞选</h2><p>有三种节点：Follower、Candidate 和 Leader。Leader 会周期性的发送心跳包给 Follower。每个 Follower 都设置了一个随机的竞选超时时间，一般为 150ms\\~300ms，如果在这个时间内没有收到 Leader 的心跳包，就会变成 Candidate，进入竞选阶段。</p><ul><li>下图展示一个分布式系统的最初阶段，此时只有 Follower 没有 Leader。Node A 等待一个随机的竞选超时时间之后，没收到 Leader 发来的心跳包，因此进入竞选阶段。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-83662c9b61e6591c371f27a838c00e1d_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>此时 Node A 发送投票请求给其它所有节点。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-508122a2f5cf603358d0e13e519c3727_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>其它节点会对请求进行回复，如果超过一半的节点回复了，那么该 Candidate 就会变成 Leader。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b379b76cd0a2e12c44e45d66f9f640cd_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>之后 Leader 会周期性地发送心跳包给 Follower，Follower 接收到心跳包，会重新开始计时。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c149bfd1560369635d47650d3dfabb09_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>多个 Candidate 竞选</h2><ul><li>如果有多个 Follower 成为 Candidate，并且所获得票数相同，那么就需要重新开始投票。例如下图中 Node B 和 Node D 都获得两票，需要重新开始投票。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2817dccb8da5a59439f58e211ae7c17b_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>由于每个节点设置的随机竞选超时时间不同，因此下一次再次出现多个 Candidate 并获得同样票数的概率很低。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"435\" data-thumbnail=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4306b9b7a8de676392ea00b780f819d8_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>数据同步</h2><ul><li>来自客户端的修改都会被传入 Leader。注意该修改还未被提交，只是写入日志中。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c571677785e2d616c058eff45bb3eccb_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>Leader 会把修改复制到所有 Follower。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e60d9756f05d881d5d33906655fc0ed5_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>Leader 会等待大多数的 Follower 也进行了修改，然后才将修改提交。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a9116fc2718b3e760e04b0153dc58961_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>此时 Leader 会通知的所有 Follower 让它们也提交修改，此时所有节点的值达成一致。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;825&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"825\" data-rawheight=\"447\" data-thumbnail=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"825\" data-original=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e97604005bbe893e3e3367c8feab047f_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考</h2><ul><li>倪超. 从 Paxos 到 ZooKeeper : 分布式一致性原理与实践 [M]. 电子工业出版社, 2015.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//redis.io/topics/distlock\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Distributed locks with Redis</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.linkedkeeper.com/detail/blog.action%3Fbid%3D1023\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">浅谈分布式锁</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.dengshenyu.com/java/%25E5%2588%2586%25E5%25B8%2583%25E5%25BC%258F%25E7%25B3%25BB%25E7%25BB%259F/2017/10/23/zookeeper-distributed-lock.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">基于 Zookeeper 的分布式锁</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//thesecretlivesofdata.com/raft\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Raft: Understandable Distributed Consensus</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">聊聊分布式事务，再说说解决方案</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//coolshell.cn/articles/10910.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">分布式系统的事务处理</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/entry/577c6f220a2b5800573492be\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解分布式事务</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.colooshiki.com/index.php/2017/04/20/what-is-cap-theorem-in-distributed-database-system/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is CAP theorem in distributed database system?</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//harry.me/blog/2014/12/27/neat-algorithms-paxos/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NEAT ALGORITHMS - PAXOS</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//angus.nyc/2012/paxos-by-example/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Paxos By Example</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "系统设计", 
                    "tagLink": "https://api.zhihu.com/topics/19572259"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500774", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "系统设计基础", 
            "content": "<p></p><h2>一、性能</h2><h2>性能指标</h2><h3>1. 响应时间</h3><p>指某个请求从发出到接收到响应消耗的时间。</p><p>在对响应时间进行测试时，通常采用重复请求的方式，然后计算平均响应时间。</p><h3>2. 吞吐量</h3><p>指系统在单位时间内可以处理的请求数量，通常使用每秒的请求数来衡量。</p><h3>3. 并发用户数</h3><p>指系统能同时处理的并发用户请求数量。</p><p>在没有并发存在的系统中，请求被顺序执行，此时响应时间为吞吐量的倒数。例如系统支持的吞吐量为 100 req/s，那么平均响应时间应该为 0.01s。</p><p>目前的大型系统都支持多线程来处理并发请求，多线程能够提高吞吐量以及缩短响应时间，主要有两个原因：</p><ul><li>多 CPU</li><li>IO 等待时间</li></ul><p>使用 IO 多路复用等方式，系统在等待一个 IO 操作完成的这段时间内不需要被阻塞，可以去处理其它请求。通过将这个等待时间利用起来，使得 CPU 利用率大大提高。</p><p>并发用户数不是越高越好，因为如果并发用户数太高，系统来不及处理这么多的请求，会使得过多的请求需要等待，那么响应时间就会大大提高。</p><h2>性能优化</h2><h3>1. 集群</h3><p>将多台服务器组成集群，使用负载均衡将请求转发到集群中，避免单一服务器的负载压力过大导致性能降低。</p><h3>2. 缓存</h3><p>缓存能够提高性能的原因如下：</p><ul><li>缓存数据通常位于内存等介质中，这种介质对于读操作特别快；</li><li>缓存数据可以位于靠近用户的地理位置上；</li><li>可以将计算结果进行缓存，从而避免重复计算。</li></ul><h3>3. 异步</h3><p>某些流程可以将操作转换为消息，将消息发送到消息队列之后立即返回，之后这个操作会被异步处理。</p><h2>二、伸缩性</h2><p>指不断向集群中添加服务器来缓解不断上升的用户并发访问压力和不断增长的数据存储需求。</p><h2>伸缩性与性能</h2><p>如果系统存在性能问题，那么单个用户的请求总是很慢的；</p><p>如果系统存在伸缩性问题，那么单个用户的请求可能会很快，但是在并发数很高的情况下系统会很慢。</p><h2>实现伸缩性</h2><p>应用服务器只要不具有状态，那么就可以很容易地通过负载均衡器向集群中添加新的服务器。</p><p>关系型数据库的伸缩性通过 Sharding 来实现，将数据按一定的规则分布到不同的节点上，从而解决单台存储服务器的存储空间限制。</p><p>对于非关系型数据库，它们天生就是为海量数据而诞生，对伸缩性的支持特别好。</p><h2>三、扩展性</h2><p>指的是添加新功能时对现有系统的其它应用无影响，这就要求不同应用具备低耦合的特点。</p><p>实现可扩展主要有两种方式：</p><ul><li>使用消息队列进行解耦，应用之间通过消息传递进行通信；</li><li>使用分布式服务将业务和可复用的服务分离开来，业务使用分布式服务框架调用可复用的服务。新增的产品可以通过调用可复用的服务来实现业务逻辑，对其它产品没有影响。</li></ul><h2>四、可用性</h2><h2>冗余</h2><p>保证高可用的主要手段是使用冗余，当某个服务器故障时就请求其它服务器。</p><p>应用服务器的冗余比较容易实现，只要保证应用服务器不具有状态，那么某个应用服务器故障时，负载均衡器将该应用服务器原先的用户请求转发到另一个应用服务器上，不会对用户有任何影响。</p><p>存储服务器的冗余需要使用主从复制来实现，当主服务器故障时，需要提升从服务器为主服务器，这个过程称为切换。</p><h2>监控</h2><p>对 CPU、内存、磁盘、网络等系统负载信息进行监控，当某个信息达到一定阈值时通知运维人员，从而在系统发生故障之前及时发现问题。</p><h2>服务降级</h2><p>服务降级是系统为了应对大量的请求，主动关闭部分功能，从而保证核心功能可用。</p><h2>五、安全性</h2><p>要求系统在应对各种攻击手段时能够有可靠的应对措施。</p><h2>参考资料</h2><ul><li>大型网站技术架构：核心原理与案例分析</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "系统设计", 
                    "tagLink": "https://api.zhihu.com/topics/19572259"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500713", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "Redis", 
            "content": "<p></p><h2>一、概述</h2><p>Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p><p>键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。</p><p>Redis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。</p><h2>二、数据类型</h2><p>| 数据类型 | 可以存储的值 | 操作 | | :--: | :--: | :--: | | STRING | 字符串、整数或者浮点数 | 对整个字符串或者字符串的其中一部分执行操作<br/> 对整数和浮点数执行自增或者自减操作 | | LIST | 列表 | 从两端压入或者弹出元素 <br/> 对单个或者多个元素进行修剪，<br/> 只保留一个范围内的元素 | | SET | 无序集合 | 添加、获取、移除单个元素<br/> 检查一个元素是否存在于集合中<br/> 计算交集、并集、差集<br/> 从集合里面随机获取元素 | | HASH | 包含键值对的无序散列表 | 添加、获取、移除单个键值对<br/> 获取所有键值对<br/> 检查某个键是否存在| | ZSET | 有序集合 | 添加、获取、删除元素<br/> 根据分值范围或者成员来获取元素<br/> 计算一个键的排名 |</p><blockquote><a href=\"https://link.zhihu.com/?target=https%3A//redislabs.com/ebook/part-1-getting-started/chapter-1-getting-to-know-redis/1-2-what-redis-data-structures-look-like/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What Redis data structures look like</a><br/> </blockquote><h2>STRING</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a52d2c2abb30c2758c4a10d148f99ba8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"773\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb\" width=\"773\" data-original=\"https://pic1.zhimg.com/v2-a52d2c2abb30c2758c4a10d148f99ba8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;773&#39; height=&#39;504&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"773\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"773\" data-original=\"https://pic1.zhimg.com/v2-a52d2c2abb30c2758c4a10d148f99ba8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a52d2c2abb30c2758c4a10d148f99ba8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\">&gt; set hello world\nOK\n&gt; get hello\n&#34;world&#34;\n&gt; del hello\n(integer) 1\n&gt; get hello\n(nil)</code></pre></div><h2>LIST</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0d52589360afc3f91ff8e301642b371d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"752\" data-original=\"https://pic2.zhimg.com/v2-0d52589360afc3f91ff8e301642b371d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;752&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"752\" data-original=\"https://pic2.zhimg.com/v2-0d52589360afc3f91ff8e301642b371d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0d52589360afc3f91ff8e301642b371d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\">&gt; rpush list-key item\n(integer) 1\n&gt; rpush list-key item2\n(integer) 2\n&gt; rpush list-key item\n(integer) 3\n\n&gt; lrange list-key 0 -1\n1) &#34;item&#34;\n2) &#34;item2&#34;\n3) &#34;item&#34;\n\n&gt; lindex list-key 1\n&#34;item2&#34;\n\n&gt; lpop list-key\n&#34;item&#34;\n\n&gt; lrange list-key 0 -1\n1) &#34;item2&#34;\n2) &#34;item&#34;</code></pre></div><h2>SET</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5b0d9c30927111280bcbef0e64b163b7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"529\" class=\"origin_image zh-lightbox-thumb\" width=\"759\" data-original=\"https://pic4.zhimg.com/v2-5b0d9c30927111280bcbef0e64b163b7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;759&#39; height=&#39;529&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"529\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"759\" data-original=\"https://pic4.zhimg.com/v2-5b0d9c30927111280bcbef0e64b163b7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5b0d9c30927111280bcbef0e64b163b7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\">&gt; sadd set-key item\n(integer) 1\n&gt; sadd set-key item2\n(integer) 1\n&gt; sadd set-key item3\n(integer) 1\n&gt; sadd set-key item\n(integer) 0\n\n&gt; smembers set-key\n1) &#34;item&#34;\n2) &#34;item2&#34;\n3) &#34;item3&#34;\n\n&gt; sismember set-key item4\n(integer) 0\n&gt; sismember set-key item\n(integer) 1\n\n&gt; srem set-key item2\n(integer) 1\n&gt; srem set-key item2\n(integer) 0\n\n&gt; smembers set-key\n1) &#34;item&#34;\n2) &#34;item3&#34;</code></pre></div><h2>HASH</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a507f684977f04f7cc1612baace7334f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"750\" data-original=\"https://pic4.zhimg.com/v2-a507f684977f04f7cc1612baace7334f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;750&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"750\" data-original=\"https://pic4.zhimg.com/v2-a507f684977f04f7cc1612baace7334f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a507f684977f04f7cc1612baace7334f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\">&gt; hset hash-key sub-key1 value1\n(integer) 1\n&gt; hset hash-key sub-key2 value2\n(integer) 1\n&gt; hset hash-key sub-key1 value1\n(integer) 0\n\n&gt; hgetall hash-key\n1) &#34;sub-key1&#34;\n2) &#34;value1&#34;\n3) &#34;sub-key2&#34;\n4) &#34;value2&#34;\n\n&gt; hdel hash-key sub-key2\n(integer) 1\n&gt; hdel hash-key sub-key2\n(integer) 0\n\n&gt; hget hash-key sub-key1\n&#34;value1&#34;\n\n&gt; hgetall hash-key\n1) &#34;sub-key1&#34;\n2) &#34;value1&#34;</code></pre></div><h2>ZSET</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b5fa7c360f336ab84ee50a107798aa84_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"619\" class=\"origin_image zh-lightbox-thumb\" width=\"770\" data-original=\"https://pic1.zhimg.com/v2-b5fa7c360f336ab84ee50a107798aa84_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;770&#39; height=&#39;619&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"619\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"770\" data-original=\"https://pic1.zhimg.com/v2-b5fa7c360f336ab84ee50a107798aa84_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b5fa7c360f336ab84ee50a107798aa84_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-html\">&gt; zadd zset-key 728 member1\n(integer) 1\n&gt; zadd zset-key 982 member0\n(integer) 1\n&gt; zadd zset-key 982 member0\n(integer) 0\n\n&gt; zrange zset-key 0 -1 withscores\n1) &#34;member1&#34;\n2) &#34;728&#34;\n3) &#34;member0&#34;\n4) &#34;982&#34;\n\n&gt; zrangebyscore zset-key 0 800 withscores\n1) &#34;member1&#34;\n2) &#34;728&#34;\n\n&gt; zrem zset-key member1\n(integer) 1\n&gt; zrem zset-key member1\n(integer) 0\n\n&gt; zrange zset-key 0 -1 withscores\n1) &#34;member0&#34;\n2) &#34;982&#34;</code></pre></div><h2>三、数据结构</h2><h2>字典</h2><p>dictht 是一个散列表结构，使用拉链法解决哈希冲突。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cm\">/* This is our hash table structure. Every dictionary has two of this as we\n</span><span class=\"cm\"> * implement incremental rehashing, for the old to the new table. */</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">dictht</span> <span class=\"p\">{</span>\n    <span class=\"n\">dictEntry</span> <span class=\"o\">**</span><span class=\"n\">table</span><span class=\"p\">;</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">size</span><span class=\"p\">;</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">sizemask</span><span class=\"p\">;</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">used</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"n\">dictht</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">dictEntry</span> <span class=\"p\">{</span>\n    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">key</span><span class=\"p\">;</span>\n    <span class=\"k\">union</span> <span class=\"p\">{</span>\n        <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">val</span><span class=\"p\">;</span>\n        <span class=\"n\">uint64_t</span> <span class=\"n\">u64</span><span class=\"p\">;</span>\n        <span class=\"n\">int64_t</span> <span class=\"n\">s64</span><span class=\"p\">;</span>\n        <span class=\"kt\">double</span> <span class=\"n\">d</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"n\">v</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">dictEntry</span> <span class=\"o\">*</span><span class=\"n\">next</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"n\">dictEntry</span><span class=\"p\">;</span></code></pre></div><p>Redis 的字典 dict 中包含两个哈希表 dictht，这是为了方便进行 rehash 操作。在扩容时，将其中一个 dictht 上的键值对 rehash 到另一个 dictht 上面，完成之后释放空间并交换两个 dictht 的角色。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">dict</span> <span class=\"p\">{</span>\n    <span class=\"n\">dictType</span> <span class=\"o\">*</span><span class=\"n\">type</span><span class=\"p\">;</span>\n    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">privdata</span><span class=\"p\">;</span>\n    <span class=\"n\">dictht</span> <span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n    <span class=\"kt\">long</span> <span class=\"n\">rehashidx</span><span class=\"p\">;</span> <span class=\"cm\">/* rehashing not in progress if rehashidx == -1 */</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">iterators</span><span class=\"p\">;</span> <span class=\"cm\">/* number of iterators currently running */</span>\n<span class=\"p\">}</span> <span class=\"n\">dict</span><span class=\"p\">;</span></code></pre></div><p>rehash 操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的 rehash 操作给服务器带来过大的负担。</p><p>渐进式 rehash 通过记录 dict 的 rehashidx 完成，它从 0 开始，然后每执行一次 rehash 都会递增。例如在一次 rehash 中，要把 dict[0] rehash 到 dict[1]，这一次会把 dict[0] 上 table[rehashidx] 的键值对 rehash 到 dict[1] 上，dict[0] 的 table[rehashidx] 指向 null，并令 rehashidx++。</p><p>在 rehash 期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式 rehash。</p><p>采用渐进式 rehash 会导致字典中的数据分散在两个 dictht 上，因此对字典的查找操作也需要到对应的 dictht 去执行。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cm\">/* Performs N steps of incremental rehashing. Returns 1 if there are still\n</span><span class=\"cm\"> * keys to move from the old to the new hash table, otherwise 0 is returned.\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * Note that a rehashing step consists in moving a bucket (that may have more\n</span><span class=\"cm\"> * than one key as we use chaining) from the old to the new hash table, however\n</span><span class=\"cm\"> * since part of the hash table may be composed of empty spaces, it is not\n</span><span class=\"cm\"> * guaranteed that this function will rehash even a single bucket, since it\n</span><span class=\"cm\"> * will visit at max N*10 empty buckets in total, otherwise the amount of\n</span><span class=\"cm\"> * work it does would be unbound and the function may block for a long time. */</span>\n<span class=\"kt\">int</span> <span class=\"nf\">dictRehash</span><span class=\"p\">(</span><span class=\"n\">dict</span> <span class=\"o\">*</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">empty_visits</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">*</span> <span class=\"mi\">10</span><span class=\"p\">;</span> <span class=\"cm\">/* Max number of empty buckets to visit. */</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">dictIsRehashing</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">))</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">n</span><span class=\"o\">--</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">used</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">dictEntry</span> <span class=\"o\">*</span><span class=\"n\">de</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">nextde</span><span class=\"p\">;</span>\n\n        <span class=\"cm\">/* Note that rehashidx can&#39;t overflow as we are sure there are more\n</span><span class=\"cm\">         * elements because ht[0].used != 0 */</span>\n        <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"p\">(</span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span><span class=\"p\">)</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"p\">);</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">--</span><span class=\"n\">empty_visits</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">de</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"p\">];</span>\n        <span class=\"cm\">/* Move all the keys in this bucket from the old to the new hash HT */</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">de</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">uint64_t</span> <span class=\"n\">h</span><span class=\"p\">;</span>\n\n            <span class=\"n\">nextde</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n            <span class=\"cm\">/* Get the index in the new hash table */</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">dictHashKey</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">,</span> <span class=\"n\">de</span><span class=\"o\">-&gt;</span><span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">sizemask</span><span class=\"p\">;</span>\n            <span class=\"n\">de</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">h</span><span class=\"p\">];</span>\n            <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">h</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">de</span><span class=\"p\">;</span>\n            <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">used</span><span class=\"o\">--</span><span class=\"p\">;</span>\n            <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">used</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"n\">de</span> <span class=\"o\">=</span> <span class=\"n\">nextde</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">[</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"cm\">/* Check if we already rehashed the whole table... */</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">used</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">zfree</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">table</span><span class=\"p\">);</span>\n        <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n        <span class=\"n\">_dictReset</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">ht</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n        <span class=\"n\">d</span><span class=\"o\">-&gt;</span><span class=\"n\">rehashidx</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"cm\">/* More to rehash... */</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><h2>跳跃表</h2><p>是有序集合的底层实现之一。</p><p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ab1791a0287d321a182005805f4b878e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb\" width=\"907\" data-original=\"https://pic3.zhimg.com/v2-ab1791a0287d321a182005805f4b878e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;907&#39; height=&#39;206&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"907\" data-original=\"https://pic3.zhimg.com/v2-ab1791a0287d321a182005805f4b878e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ab1791a0287d321a182005805f4b878e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。下图演示了查找 22 的过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad77c15310803763750e469d676a04ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb\" width=\"897\" data-original=\"https://pic2.zhimg.com/v2-ad77c15310803763750e469d676a04ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;897&#39; height=&#39;210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"897\" data-original=\"https://pic2.zhimg.com/v2-ad77c15310803763750e469d676a04ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad77c15310803763750e469d676a04ad_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现；</li><li>支持无锁操作。</li></ul><h2>四、使用场景</h2><h2>计数器</h2><p>可以对 String 进行自增自减运算，从而实现计数器功能。</p><p>Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p><h2>缓存</h2><p>将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</p><h2>查找表</h2><p>例如 DNS 记录就很适合使用 Redis 进行存储。</p><p>查找表和缓存类似，也是利用了 Redis 快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。</p><h2>消息队列</h2><p>List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息</p><p>不过最好使用 Kafka、RabbitMQ 等消息中间件。</p><h2>会话缓存</h2><p>可以使用 Redis 来统一存储多台应用服务器的会话信息。</p><p>当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</p><h2>分布式锁实现</h2><p>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p><p>可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。</p><h2>其它</h2><p>Set 可以实现交集、并集等操作，从而实现共同好友等功能。</p><p>ZSet 可以实现有序性操作，从而实现排行榜等功能。</p><h2>五、Redis 与 Memcached</h2><p>两者都是非关系型内存键值数据库，主要有以下不同：</p><h2>数据类型</h2><p>Memcached 仅支持字符串类型，而 Redis 支持五种不同的数据类型，可以更灵活地解决问题。</p><h2>数据持久化</h2><p>Redis 支持两种持久化策略：RDB 快照和 AOF 日志，而 Memcached 不支持持久化。</p><h2>分布式</h2><p>Memcached 不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p><p>Redis Cluster 实现了分布式的支持。</p><h2>内存管理机制</h2><ul><li> 在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘，而 Memcached 的数据则会一直在内存中。<br/> </li><li> Memcached 将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。但是这种方式会使得内存的利用率不高，例如块的大小为 128 bytes，只存储 100 bytes 的数据，那么剩下的 28 bytes 就浪费掉了。<br/> </li></ul><h2>六、键的过期时间</h2><p>Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h2>七、数据淘汰策略</h2><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis 具体有 6 种淘汰策略：</p><p>| 策略 | 描述 | | :--: | :--: | | volatile-lru | 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰 | | volatile-ttl | 从已设置过期时间的数据集中挑选将要过期的数据淘汰 | |volatile-random | 从已设置过期时间的数据集中任意选择数据淘汰 | | allkeys-lru | 从所有数据集中挑选最近最少使用的数据淘汰 | | allkeys-random | 从所有数据集中任意选择数据进行淘汰 | | noeviction | 禁止驱逐数据 |</p><p>作为内存数据库，出于对性能和内存消耗的考虑，Redis 的淘汰算法实际实现上并非针对所有 key，而是抽样一小部分并且从中选出被淘汰的 key。</p><p>使用 Redis 缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。可以将内存最大使用量设置为热点数据占用的内存量，然后启用 allkeys-lru 淘汰策略，将最近最少使用的数据淘汰。</p><p>Redis 4.0 引入了 volatile-lfu 和 allkeys-lfu 淘汰策略，LFU 策略通过统计访问频率，将访问频率最少的键值对淘汰。</p><h2>八、持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h2>RDB 持久化</h2><p>将某个时间点的所有数据都存放到硬盘上。</p><p>可以将快照复制到其它服务器从而创建具有相同数据的服务器副本。</p><p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p><p>如果数据量很大，保存快照的时间会很长。</p><h2>AOF 持久化</h2><p>将写命令添加到 AOF 文件（Append Only File）的末尾。</p><p>使用 AOF 持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。有以下同步选项：</p><p>| 选项 | 同步频率 | | :--: | :--: | | always | 每个写命令都同步 | | everysec | 每秒同步一次 | | no | 让操作系统来决定何时同步 |</p><ul><li>always 选项会严重减低服务器的性能；</li><li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器性能几乎没有任何影响；</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p><h2>九、事务</h2><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能。</p><p>Redis 最简单的事务实现方式是使用 MULTI 和 EXEC 命令将事务操作包围起来。</p><h2>十、事件</h2><p>Redis 服务器是一个事件驱动程序。</p><h2>文件事件</h2><p>服务器通过套接字与客户端或者其它服务器进行通信，文件事件就是对套接字操作的抽象。</p><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器，使用 I/O 多路复用程序来同时监听多个套接字，并将到达的事件传送给文件事件分派器，分派器会根据套接字产生的事件类型调用相应的事件处理器。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-72d61b5d9362b644f8778aab0edcd523_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic4.zhimg.com/v2-72d61b5d9362b644f8778aab0edcd523_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic4.zhimg.com/v2-72d61b5d9362b644f8778aab0edcd523_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-72d61b5d9362b644f8778aab0edcd523_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>时间事件</h2><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。</p><p>时间事件又分为：</p><ul><li>定时事件：是让一段程序在指定的时间之内执行一次；</li><li>周期性事件：是让一段程序每隔指定时间就执行一次。</li></ul><p>Redis 将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，并调用相应的事件处理器。</p><h2>事件的调度与执行</h2><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但是不能一直监听，否则时间事件无法在规定的时间内执行，因此监听时间应该根据距离现在最近的时间事件来决定。</p><p>事件调度与执行由 aeProcessEvents 函数负责，伪代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">def</span> <span class=\"nf\">aeProcessEvents</span><span class=\"p\">():</span>\n    <span class=\"c1\"># 获取到达时间离当前时间最接近的时间事件</span>\n    <span class=\"n\">time_event</span> <span class=\"o\">=</span> <span class=\"n\">aeSearchNearestTimer</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 计算最接近的时间事件距离到达还有多少毫秒</span>\n    <span class=\"n\">remaind_ms</span> <span class=\"o\">=</span> <span class=\"n\">time_event</span><span class=\"o\">.</span><span class=\"n\">when</span> <span class=\"o\">-</span> <span class=\"n\">unix_ts_now</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 如果事件已到达，那么 remaind_ms 的值可能为负数，将它设为 0</span>\n    <span class=\"k\">if</span> <span class=\"n\">remaind_ms</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">remaind_ms</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"c1\"># 根据 remaind_ms 的值，创建 timeval</span>\n    <span class=\"n\">timeval</span> <span class=\"o\">=</span> <span class=\"n\">create_timeval_with_ms</span><span class=\"p\">(</span><span class=\"n\">remaind_ms</span><span class=\"p\">)</span>\n    <span class=\"c1\"># 阻塞并等待文件事件产生，最大阻塞时间由传入的 timeval 决定</span>\n    <span class=\"n\">aeApiPoll</span><span class=\"p\">(</span><span class=\"n\">timeval</span><span class=\"p\">)</span>\n    <span class=\"c1\"># 处理所有已产生的文件事件</span>\n    <span class=\"n\">procesFileEvents</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 处理所有已到达的时间事件</span>\n    <span class=\"n\">processTimeEvents</span><span class=\"p\">()</span></code></pre></div><p>将 aeProcessEvents 函数置于一个循环里面，加上初始化和清理函数，就构成了 Redis 服务器的主函数，伪代码如下：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"c1\"># 初始化服务器</span>\n    <span class=\"n\">init_server</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 一直处理事件，直到服务器关闭为止</span>\n    <span class=\"k\">while</span> <span class=\"n\">server_is_not_shutdown</span><span class=\"p\">():</span>\n        <span class=\"n\">aeProcessEvents</span><span class=\"p\">()</span>\n    <span class=\"c1\"># 服务器关闭，执行清理操作</span>\n    <span class=\"n\">clean_server</span><span class=\"p\">()</span></code></pre></div><p>从事件处理的角度来看，服务器运行流程如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1326faa27a0e21aaee5e303c67689396_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"630\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-1326faa27a0e21aaee5e303c67689396_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;630&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"630\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-1326faa27a0e21aaee5e303c67689396_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1326faa27a0e21aaee5e303c67689396_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>十一、复制</h2><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p><p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p><h2>连接过程</h2><ol><li> 主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。快照文件发送完毕之后，开始向从服务器发送存储在缓冲区中的写命令；<br/> </li><li> 从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；<br/> </li><li> 主服务器每执行一次写命令，就向从服务器发送相同的写命令。<br/> </li></ol><h2>主从链</h2><p>随着负载不断上升，主服务器可能无法很快地更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4c18bbb90a0371ffce544d91ff8da011_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-4c18bbb90a0371ffce544d91ff8da011_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-4c18bbb90a0371ffce544d91ff8da011_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4c18bbb90a0371ffce544d91ff8da011_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>十二、Sentinel</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p><h2>十三、分片</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p><p>假设有 4 个 Redis 实例 R0，R1，R2，R3，还有很多表示用户的键 user:1，user:2，... ，有不同的方式来选择一个指定的键存储在哪个实例中。</p><ul><li>最简单的方式是范围分片，例如用户 id 从 0\\~1000 的存储到实例 R0 中，用户 id 从 1001\\~2000 的存储到实例 R1 中，等等。但是这样需要维护一张映射范围表，维护操作代价很高。</li><li>还有一种方式是哈希分片，使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道应该存储的实例。</li></ul><p>根据执行分片的位置，可以分为三种分片方式：</p><ul><li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点。</li><li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上。</li><li>服务器分片：Redis Cluster。</li></ul><h2>十四、一个简单的论坛系统分析</h2><p>该论坛系统功能如下：</p><ul><li>可以发布文章；</li><li>可以对文章进行点赞；</li><li>在首页可以按文章的发布时间或者文章的点赞数进行排序显示。</li></ul><h2>文章信息</h2><p>文章包括标题、作者、赞数等信息，在关系型数据库中很容易构建一张表来存储这些信息，在 Redis 中可以使用 HASH 来存储每种信息以及其对应的值的映射。</p><p>Redis 没有关系型数据库中的表这一概念来将同种类型的数据存放在一起，而是使用命名空间的方式来实现这一功能。键名的前面部分存储命名空间，后面部分的内容存储 ID，通常使用 : 来进行分隔。例如下面的 HASH 的键名为 article:92617，其中 article 为命名空间，ID 为 92617。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-44f945faa4ac08fe38a6aad55d1fdb47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"766\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb\" width=\"766\" data-original=\"https://pic4.zhimg.com/v2-44f945faa4ac08fe38a6aad55d1fdb47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;766&#39; height=&#39;590&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"766\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"766\" data-original=\"https://pic4.zhimg.com/v2-44f945faa4ac08fe38a6aad55d1fdb47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-44f945faa4ac08fe38a6aad55d1fdb47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>点赞功能</h2><p>当有用户为一篇文章点赞时，除了要对该文章的 votes 字段进行加 1 操作，还必须记录该用户已经对该文章进行了点赞，防止用户点赞次数超过 1。可以建立文章的已投票用户集合来进行记录。</p><p>为了节约内存，规定一篇文章发布满一周之后，就不能再对它进行投票，而文章的已投票集合也会被删除，可以为文章的已投票集合设置一个一周的过期时间就能实现这个规定。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b02800d838d4e9d49f383b20d580bb73_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb\" width=\"781\" data-original=\"https://pic4.zhimg.com/v2-b02800d838d4e9d49f383b20d580bb73_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;781&#39; height=&#39;521&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"781\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"781\" data-original=\"https://pic4.zhimg.com/v2-b02800d838d4e9d49f383b20d580bb73_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b02800d838d4e9d49f383b20d580bb73_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>对文章进行排序</h2><p>为了按发布时间和点赞数进行排序，可以建立一个文章发布时间的有序集合和一个文章点赞数的有序集合。（下图中的 score 就是这里所说的点赞数；下面所示的有序集合分值并不直接是时间和点赞数，而是根据时间和点赞数间接计算出来的）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-524a1c8ee8ff10e61c47269fab6034f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb\" width=\"776\" data-original=\"https://pic1.zhimg.com/v2-524a1c8ee8ff10e61c47269fab6034f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;776&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"776\" data-original=\"https://pic1.zhimg.com/v2-524a1c8ee8ff10e61c47269fab6034f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-524a1c8ee8ff10e61c47269fab6034f0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考资料</h2><ul><li>Carlson J L. Redis in Action[J]. Media.johnwiley.com.au, 2013.</li><li><a href=\"https://link.zhihu.com/?target=http%3A//redisbook.com/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">黄健宏. Redis 设计与实现 [M]. 机械工业出版社, 2014.</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//redislabs.com/ebook/foreword/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">REDIS IN ACTION</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//ticki.github.io/blog/skip-lists-done-right/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Skip Lists: Done Right</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/loveincode/p/7411911.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">论述 Redis 和 Memcached 的差异</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//wiki.jikexueyuan.com/project/redis-guide\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Redis 3.0 中文版- 分片</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.scienjus.com/redis-use-case/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Redis 应用场景</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//redis.io/topics/lru-cache\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Using Redis as an LRU cache</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500693", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 2, 
            "title": "MySQL", 
            "content": "<p></p><h2>一、索引</h2><h2>B+ Tree 原理</h2><h3>1. 数据结构</h3><p>B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。</p><p>B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-944b25c93942b6166777920fd0c431b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-944b25c93942b6166777920fd0c431b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;571&#39; height=&#39;289&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-944b25c93942b6166777920fd0c431b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-944b25c93942b6166777920fd0c431b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 操作</h3><p>进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。</p><p>插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。</p><h3>3. 与红黑树的比较</h3><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：</p><p>（一）更少的查找次数</p><p>平衡树查找操作的时间复杂度和树高 h 相关，O(h)=O(logdN)，其中 d 为每个节点的出度。</p><p>红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。</p><p>（二）利用磁盘预读特性</p><p>为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。</p><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2>MySQL 索引</h2><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。</p><h3>1. B+Tree 索引</h3><p>是大多数 MySQL 存储引擎的默认索引类型。</p><p>因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。</p><p>因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。</p><p>可以指定多个列作为索引列，多个索引列共同组成键。</p><p>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</p><p>InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ab0c51a5759a7afcb54c78e922baa744_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"621\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"621\" data-original=\"https://pic1.zhimg.com/v2-ab0c51a5759a7afcb54c78e922baa744_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;621&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"621\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"621\" data-original=\"https://pic1.zhimg.com/v2-ab0c51a5759a7afcb54c78e922baa744_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ab0c51a5759a7afcb54c78e922baa744_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-946a02e2a1ecb5df71ac6f776bc1c8bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"584\" data-rawheight=\"288\" class=\"origin_image zh-lightbox-thumb\" width=\"584\" data-original=\"https://pic4.zhimg.com/v2-946a02e2a1ecb5df71ac6f776bc1c8bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;584&#39; height=&#39;288&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"584\" data-rawheight=\"288\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"584\" data-original=\"https://pic4.zhimg.com/v2-946a02e2a1ecb5df71ac6f776bc1c8bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-946a02e2a1ecb5df71ac6f776bc1c8bb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 哈希索引</h3><p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组；</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h3>3. 全文索引</h3><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p><p>查找条件使用 MATCH AGAINST，而不是普通的 WHERE。</p><p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p><p>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h3>4. 空间数据索引</h3><p>MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。</p><p>必须使用 GIS 相关的函数来维护数据。</p><h2>索引优化</h2><h3>1. 独立的列</h3><p>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</p><p>例如下面的查询不能使用 actor_id 列的索引：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">actor_id</span> <span class=\"k\">FROM</span> <span class=\"n\">sakila</span><span class=\"p\">.</span><span class=\"n\">actor</span> <span class=\"k\">WHERE</span> <span class=\"n\">actor_id</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span></code></pre></div><h3>2. 多列索引</h3><p>在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">film_id</span><span class=\"p\">,</span> <span class=\"n\">actor_</span> <span class=\"n\">id</span> <span class=\"k\">FROM</span> <span class=\"n\">sakila</span><span class=\"p\">.</span><span class=\"n\">film_actor</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">actor_id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"k\">AND</span> <span class=\"n\">film_id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><h3>3. 索引列的顺序</h3><p>让选择性最强的索引列放在前面。</p><p>索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。</p><p>例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"k\">DISTINCT</span> <span class=\"n\">staff_id</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">staff_id_selectivity</span><span class=\"p\">,</span>\n<span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"k\">DISTINCT</span> <span class=\"n\">customer_id</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">customer_id_selectivity</span><span class=\"p\">,</span>\n<span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span>\n<span class=\"k\">FROM</span> <span class=\"n\">payment</span><span class=\"p\">;</span>\n<span class=\"n\">staff_id_selectivity</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">.</span><span class=\"mi\">0001</span>\n<span class=\"n\">customer_id_selectivity</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">.</span><span class=\"mi\">0373</span>\n               <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">):</span> <span class=\"mi\">16049</span></code></pre></div><h3>4. 前缀索引</h3><p>对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。</p><p>前缀长度的选取需要根据索引选择性来确定。</p><h3>5. 覆盖索引</h3><p>索引包含所有需要查询的字段的值。</p><p>具有以下优点：</p><ul><li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。</li><li>一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。</li><li>对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。</li></ul><h2>索引的优点</h2><ul><li> 大大减少了服务器需要扫描的数据行数。<br/> </li><li> 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。<br/> </li><li> 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。<br/> </li></ul><h2>索引的使用条件</h2><ul><li> 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；<br/> </li><li> 对于中到大型的表，索引就非常有效；<br/> </li><li> 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。<br/> </li></ul><h2>二、查询性能优化</h2><h2>使用 Explain 进行分析</h2><p>Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。</p><p>比较重要的字段有：</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><h2>优化数据访问</h2><h3>1. 减少请求的数据量</h3><ul><li>只返回必要的列：最好不要使用 SELECT * 语句。</li><li>只返回必要的行：使用 LIMIT 语句来限制返回的数据。</li><li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。</li></ul><h3>2. 减少服务器端扫描的行数</h3><p>最有效的方式是使用索引来覆盖查询。</p><h2>重构查询方式</h2><h3>1. 切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">DELETE</span> <span class=\"k\">FROM</span> <span class=\"n\">messages</span> <span class=\"k\">WHERE</span> <span class=\"k\">create</span> <span class=\"o\">&lt;</span> <span class=\"n\">DATE_SUB</span><span class=\"p\">(</span><span class=\"n\">NOW</span><span class=\"p\">(),</span> <span class=\"nb\">INTERVAL</span> <span class=\"mi\">3</span> <span class=\"k\">MONTH</span><span class=\"p\">);</span>\n<span class=\"n\">rows_affected</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"k\">do</span> <span class=\"err\">{</span>\n    <span class=\"n\">rows_affected</span> <span class=\"o\">=</span> <span class=\"n\">do_query</span><span class=\"p\">(</span>\n    <span class=\"s2\">&#34;DELETE FROM messages WHERE create  &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&#34;</span><span class=\"p\">)</span>\n<span class=\"err\">}</span> <span class=\"n\">while</span> <span class=\"n\">rows_affected</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span></code></pre></div><h3>2. 分解大连接查询</h3><p>将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有：</p><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">tab</span>\n<span class=\"k\">JOIN</span> <span class=\"n\">tag_post</span> <span class=\"k\">ON</span> <span class=\"n\">tag_post</span><span class=\"p\">.</span><span class=\"n\">tag_id</span><span class=\"o\">=</span><span class=\"n\">tag</span><span class=\"p\">.</span><span class=\"n\">id</span>\n<span class=\"k\">JOIN</span> <span class=\"n\">post</span> <span class=\"k\">ON</span> <span class=\"n\">tag_post</span><span class=\"p\">.</span><span class=\"n\">post_id</span><span class=\"o\">=</span><span class=\"n\">post</span><span class=\"p\">.</span><span class=\"n\">id</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">tag</span><span class=\"p\">.</span><span class=\"n\">tag</span><span class=\"o\">=</span><span class=\"s1\">&#39;mysql&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">tag</span> <span class=\"k\">WHERE</span> <span class=\"n\">tag</span><span class=\"o\">=</span><span class=\"s1\">&#39;mysql&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">tag_post</span> <span class=\"k\">WHERE</span> <span class=\"n\">tag_id</span><span class=\"o\">=</span><span class=\"mi\">1234</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">post</span> <span class=\"k\">WHERE</span> <span class=\"n\">post</span><span class=\"p\">.</span><span class=\"n\">id</span> <span class=\"k\">IN</span> <span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">,</span><span class=\"mi\">456</span><span class=\"p\">,</span><span class=\"mi\">567</span><span class=\"p\">,</span><span class=\"mi\">9098</span><span class=\"p\">,</span><span class=\"mi\">8904</span><span class=\"p\">);</span></code></pre></div><h2>三、存储引擎</h2><h2>InnoDB</h2><p>是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。</p><h2>MyISAM</h2><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p><p>提供了大量的特性，包括压缩表、空间数据索引等。</p><p>不支持事务。</p><p>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。</p><p>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。</p><p>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</p><h2>比较</h2><ul><li> 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。<br/> </li><li> 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。<br/> </li><li> 外键：InnoDB 支持外键。<br/> </li><li> 备份：InnoDB 支持在线热备份。<br/> </li><li> 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。<br/> </li><li> 其它特性：MyISAM 支持压缩表和空间数据索引。<br/> </li></ul><h2>四、数据类型</h2><h2>整型</h2><p>TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。</p><p>INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p><h2>浮点数</h2><p>FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。</p><p>FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。</p><h2>字符串</h2><p>主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。</p><p>VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。</p><p>在进行存储和检索时，会保留 VARCHAR 末尾的空格，而会删除 CHAR 末尾的空格。</p><h2>时间和日期</h2><p>MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。</p><h3>1. DATETIME</h3><p>能够保存从 1000 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。</p><p>它与时区无关。</p><p>默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。</p><h3>2. TIMESTAMP</h3><p>和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。</p><p>它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。</p><p>MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。</p><p>默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。</p><p>应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。</p><h2>五、切分</h2><h2>水平切分</h2><p>水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。</p><p>当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-53b5e5bf4d85806abd3abda2f5110591_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb\" width=\"562\" data-original=\"https://pic2.zhimg.com/v2-53b5e5bf4d85806abd3abda2f5110591_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;562&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"562\" data-original=\"https://pic2.zhimg.com/v2-53b5e5bf4d85806abd3abda2f5110591_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-53b5e5bf4d85806abd3abda2f5110591_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>垂直切分</h2><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fb1b0a0f37e6afec2f60e555e54ccbaf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"466\" data-original=\"https://pic4.zhimg.com/v2-fb1b0a0f37e6afec2f60e555e54ccbaf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;466&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"466\" data-original=\"https://pic4.zhimg.com/v2-fb1b0a0f37e6afec2f60e555e54ccbaf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fb1b0a0f37e6afec2f60e555e54ccbaf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Sharding 策略</h2><ul><li>哈希取模：hash(key) % N；</li><li>范围：可以是 ID 范围也可以是时间范围；</li><li>映射表：使用单独的一个数据库来存储映射关系。</li></ul><h2>Sharding 存在的问题</h2><h3>1. 事务问题</h3><p>使用分布式事务来解决，比如 XA 接口。</p><h3>2. 连接</h3><p>可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</p><h3>3. ID 唯一性</h3><ul><li>使用全局唯一 ID（GUID）</li><li>为每个分片指定一个 ID 范围</li><li>分布式 ID 生成器 (如 Twitter 的 Snowflake 算法)</li></ul><h2>六、复制</h2><h2>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li><b>binlog 线程</b> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><b>I/O 线程</b> ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li><b>SQL 线程</b> ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c5e66808c1b34395e8a06b25f5ded53c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic1.zhimg.com/v2-c5e66808c1b34395e8a06b25f5ded53c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic1.zhimg.com/v2-c5e66808c1b34395e8a06b25f5ded53c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c5e66808c1b34395e8a06b25f5ded53c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于：</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-077ac71910b1c1e212ab8b92df465c6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-077ac71910b1c1e212ab8b92df465c6e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;390&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"390\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-077ac71910b1c1e212ab8b92df465c6e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-077ac71910b1c1e212ab8b92df465c6e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考资料</h2><ul><li>BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013.</li><li>姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.jfox.info/20-tiao-mysql-xing-nen-you-hua-de-zui-jia-jing-yan.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">20+ 条 MySQL 性能优化的最佳经验</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.720ui.com/2017/mysql_core_09_multi_db_table2/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/788829/how-to-create-unique-row-id-in-sharded-databases\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to create unique row ID in sharded databases?</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//geekswithblogs.net/shaunxu/archive/2012/01/07/sql-azure-federation-ndash-introduction.aspx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SQL Azure Federation – Introduction</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.codinglabs.org/articles/theory-of-mysql-index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MySQL 索引背后的数据结构及算法原理</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000008131735\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MySQL 性能优化神器 Explain 使用分析</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40jeeyoungk/how-sharding-works-b4dec46b3f6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How Sharding Works</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/dianping_order_db_sharding.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">大众点评订单系统分库分表实践</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/B%252B%25E6%25A0%2591\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">B + 树</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500444", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "SQL", 
            "content": "<p></p><h2>一、基础</h2><p>模式定义了数据如何存储、存储什么样的数据以及数据如何分解等信息，数据库和表都有模式。</p><p>主键的值不允许修改，也不允许复用（不能将已经删除的主键值赋给新数据行的主键）。</p><p>SQL（Structured Query Language)，标准 SQL 由 ANSI 标准委员会管理，从而称为 ANSI SQL。各个 DBMS 都有自己的实现，如 PL/SQL、Transact-SQL 等。</p><p>SQL 语句不区分大小写，但是数据库表名、列名和值是否区分依赖于具体的 DBMS 以及配置。</p><p>SQL 支持以下三种注释：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"o\">#</span> <span class=\"err\">注释</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span> <span class=\"c1\">-- 注释\n</span><span class=\"c1\"></span><span class=\"cm\">/* 注释1\n</span><span class=\"cm\">   注释2 */</span></code></pre></div><p>数据库创建与使用：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">DATABASE</span> <span class=\"n\">test</span><span class=\"p\">;</span>\n<span class=\"n\">USE</span> <span class=\"n\">test</span><span class=\"p\">;</span></code></pre></div><h2>二、创建表</h2><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span> <span class=\"p\">(</span>\n  <span class=\"o\">#</span> <span class=\"nb\">int</span> <span class=\"err\">类型，不为空，自增</span>\n  <span class=\"n\">id</span> <span class=\"nb\">INT</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"n\">AUTO_INCREMENT</span><span class=\"p\">,</span>\n  <span class=\"o\">#</span> <span class=\"nb\">int</span> <span class=\"err\">类型，不可为空，默认值为</span> <span class=\"mi\">1</span><span class=\"err\">，不为空</span>\n  <span class=\"n\">col1</span> <span class=\"nb\">INT</span> <span class=\"k\">NOT</span> <span class=\"k\">NULL</span> <span class=\"k\">DEFAULT</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"o\">#</span> <span class=\"err\">变长字符串类型，最长为</span> <span class=\"mi\">45</span> <span class=\"err\">个字符，可以为空</span>\n  <span class=\"n\">col2</span> <span class=\"nb\">VARCHAR</span><span class=\"p\">(</span><span class=\"mi\">45</span><span class=\"p\">)</span> <span class=\"k\">NULL</span><span class=\"p\">,</span>\n  <span class=\"o\">#</span> <span class=\"err\">日期类型，可为空</span>\n  <span class=\"n\">col3</span> <span class=\"nb\">DATE</span> <span class=\"k\">NULL</span><span class=\"p\">,</span>\n  <span class=\"o\">#</span> <span class=\"err\">设置主键为</span> <span class=\"n\">id</span>\n  <span class=\"k\">PRIMARY</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"o\">`</span><span class=\"n\">id</span><span class=\"o\">`</span><span class=\"p\">));</span></code></pre></div><h2>三、修改表</h2><p>添加列</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">ALTER</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span>\n<span class=\"k\">ADD</span> <span class=\"n\">col</span> <span class=\"nb\">CHAR</span><span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">);</span></code></pre></div><p>删除列</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">ALTER</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span>\n<span class=\"k\">DROP</span> <span class=\"k\">COLUMN</span> <span class=\"n\">col</span><span class=\"p\">;</span></code></pre></div><p>删除表</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">DROP</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><h2>四、插入</h2><p>普通插入</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">INSERT</span> <span class=\"k\">INTO</span> <span class=\"n\">mytable</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">,</span> <span class=\"n\">col2</span><span class=\"p\">)</span>\n<span class=\"k\">VALUES</span><span class=\"p\">(</span><span class=\"n\">val1</span><span class=\"p\">,</span> <span class=\"n\">val2</span><span class=\"p\">);</span></code></pre></div><p>插入检索出来的数据</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">INSERT</span> <span class=\"k\">INTO</span> <span class=\"n\">mytable1</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">,</span> <span class=\"n\">col2</span><span class=\"p\">)</span>\n<span class=\"k\">SELECT</span> <span class=\"n\">col1</span><span class=\"p\">,</span> <span class=\"n\">col2</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable2</span><span class=\"p\">;</span></code></pre></div><p>将一个表的内容插入到一个新表</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">TABLE</span> <span class=\"n\">newtable</span> <span class=\"k\">AS</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><h2>五、更新</h2><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">UPDATE</span> <span class=\"n\">mytable</span>\n<span class=\"k\">SET</span> <span class=\"n\">col</span> <span class=\"o\">=</span> <span class=\"n\">val</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><h2>六、删除</h2><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">DELETE</span> <span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span></code></pre></div><p><b>TRUNCATE TABLE</b>  可以清空表，也就是删除所有行。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">TRUNCATE</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><p>使用更新和删除操作时一定要用 WHERE 子句，不然会把整张表的数据都破坏。可以先用 SELECT 语句进行测试，防止错误删除。</p><h2>七、查询</h2><h2>DISTINCT</h2><p>相同值只会出现一次。它作用于所有列，也就是说所有列的值都相同才算相同。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"k\">DISTINCT</span> <span class=\"n\">col1</span><span class=\"p\">,</span> <span class=\"n\">col2</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><h2>LIMIT</h2><p>限制返回的行数。可以有两个参数，第一个参数为起始行，从 0 开始；第二个参数为返回的总行数。</p><p>返回前 5 行：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">LIMIT</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">LIMIT</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">;</span></code></pre></div><p>返回第 3 \\~ 5 行：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">LIMIT</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">;</span></code></pre></div><h2>八、排序</h2><ul><li><b>ASC</b> ：升序（默认）</li><li><b>DESC</b> ：降序</li></ul><p>可以按多个列进行排序，并且为每个列指定不同的排序方式：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">col1</span> <span class=\"k\">DESC</span><span class=\"p\">,</span> <span class=\"n\">col2</span> <span class=\"k\">ASC</span><span class=\"p\">;</span></code></pre></div><h2>九、过滤</h2><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col</span> <span class=\"k\">IS</span> <span class=\"k\">NULL</span><span class=\"p\">;</span></code></pre></div><p>下表显示了 WHERE 子句可用的操作符</p><p>|  操作符 | 说明  | | :---: | :---: | | = | 等于 | | &lt; | 小于 | | &gt; | 大于 | | &lt;&gt; != | 不等于 | | &lt;= !&gt; | 小于等于 | | &gt;= !&lt; | 大于等于 | | BETWEEN | 在两个值之间 | | IS NULL | 为 NULL 值 |</p><p>应该注意到，NULL 与 0、空字符串都不同。</p><p><b>AND 和 OR</b>  用于连接多个过滤条件。优先处理 AND，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><b>IN</b>  操作符用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><p><b>NOT</b>  操作符用于否定一个条件。</p><h2>十、通配符</h2><p>通配符也是用在过滤语句中，但它只能用于文本字段。</p><ul><li><b>%</b>  匹配 &gt;=0 个任意字符；<br/> </li><li><b>_</b>  匹配 ==1 个任意字符；<br/> </li><li><b>[ ]</b>  可以匹配集合内的字符，例如 [ab] 将匹配字符 a 或者 b。用脱字符 ^ 可以对其进行否定，也就是不匹配集合内的字符。<br/> </li></ul><p>使用 Like 来进行通配符匹配。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col</span> <span class=\"k\">LIKE</span> <span class=\"s1\">&#39;[^AB]%&#39;</span><span class=\"p\">;</span> <span class=\"c1\">-- 不以 A 和 B 开头的任意文本</span></code></pre></div><p>不要滥用通配符，通配符位于开头处匹配会非常慢。</p><h2>十一、计算字段</h2><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用  <b>AS</b>  来取别名，否则输出的时候字段名为计算表达式。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">col1</span> <span class=\"o\">*</span> <span class=\"n\">col2</span> <span class=\"k\">AS</span> <span class=\"k\">alias</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><p><b>CONCAT()</b>  用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <b>TRIM()</b> 可以去除首尾空格。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">CONCAT</span><span class=\"p\">(</span><span class=\"k\">TRIM</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">),</span> <span class=\"s1\">&#39;(&#39;</span><span class=\"p\">,</span> <span class=\"k\">TRIM</span><span class=\"p\">(</span><span class=\"n\">col2</span><span class=\"p\">),</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">concat_col</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><h2>十二、函数</h2><p>各个 DBMS 的函数都是不相同的，因此不可移植，以下主要是 MySQL 的函数。</p><h2>汇总</h2><p>|函 数 |说 明| | :---: | :---: | | AVG() | 返回某列的平均值 | | COUNT() | 返回某列的行数 | | MAX() | 返回某列的最大值 | | MIN() | 返回某列的最小值 | | SUM() |返回某列值之和 |</p><p>AVG() 会忽略 NULL 行。</p><p>使用 DISTINCT 可以汇总不同的值。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"k\">AVG</span><span class=\"p\">(</span><span class=\"k\">DISTINCT</span> <span class=\"n\">col1</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">avg_col</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span><span class=\"p\">;</span></code></pre></div><h2>文本处理</h2><p>| 函数  | 说明  | | :---: | :---: | |  LEFT() |  左边的字符 | | RIGHT() | 右边的字符 | | LOWER() | 转换为小写字符 | | UPPER() | 转换为大写字符 | | LTRIM() | 去除左边的空格 | | RTRIM() | 去除右边的空格 | | LENGTH() | 长度 | | SOUNDEX() | 转换为语音值 |</p><p>其中， <b>SOUNDEX()</b>  可以将一个字符串转换为描述其语音表示的字母数字模式。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">SOUNDEX</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">SOUNDEX</span><span class=\"p\">(</span><span class=\"s1\">&#39;apple&#39;</span><span class=\"p\">)</span></code></pre></div><h2>日期和时间处理</h2><ul><li>日期格式：YYYY-MM-DD</li><li>时间格式：HH:MM:SS</li></ul><p>|函 数 | 说 明| | :---: | :---: | | ADDDATE() | 增加一个日期（天、周等）| | ADDTIME() | 增加一个时间（时、分等）| | CURDATE() | 返回当前日期 | | CURTIME() | 返回当前时间 | | DATE() |返回日期时间的日期部分| | DATEDIFF() |计算两个日期之差| | DATE_ADD() |高度灵活的日期运算函数| | DATE_FORMAT() |返回一个格式化的日期或时间串| | DAY()| 返回一个日期的天数部分| | DAYOFWEEK() |对于一个日期，返回对应的星期几| | HOUR() |返回一个时间的小时部分| | MINUTE() |返回一个时间的分钟部分| | MONTH() |返回一个日期的月份部分| | NOW() |返回当前日期和时间| | SECOND() |返回一个时间的秒部分| | TIME() |返回一个日期时间的时间部分| | YEAR() |返回一个日期的年份部分|</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">mysql</span><span class=\"o\">&gt;</span> <span class=\"k\">SELECT</span> <span class=\"n\">NOW</span><span class=\"p\">();</span>\n<span class=\"mi\">2018</span><span class=\"o\">-</span><span class=\"mi\">4</span><span class=\"o\">-</span><span class=\"mi\">14</span> <span class=\"mi\">20</span><span class=\"p\">:</span><span class=\"mi\">25</span><span class=\"p\">:</span><span class=\"mi\">11</span></code></pre></div><h2>数值处理</h2><p>| 函数 | 说明 | | :---: | :---: | | SIN() | 正弦 | | COS() | 余弦 | | TAN() | 正切 | | ABS() | 绝对值 | | SQRT() | 平方根 | | MOD() | 余数 | | EXP() | 指数 | | PI() | 圆周率 | | RAND() | 随机数 |</p><h2>十三、分组</h2><p>把具有相同的数据值的行放在同一组中。</p><p>可以对同一分组数据使用汇总函数进行处理，例如求分组数据的平均值等。</p><p>指定的分组字段除了能按该字段进行分组，也会自动按该字段进行排序。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">col</span><span class=\"p\">,</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">num</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">col</span><span class=\"p\">;</span></code></pre></div><p>GROUP BY 自动按分组字段进行排序，ORDER BY 也可以按汇总字段来进行排序。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">col</span><span class=\"p\">,</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">num</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">col</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">num</span><span class=\"p\">;</span></code></pre></div><p>WHERE 过滤行，HAVING 过滤分组，行过滤应当先于分组过滤。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">col</span><span class=\"p\">,</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">num</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col</span> <span class=\"o\">&gt;</span> <span class=\"mi\">2</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">col</span>\n<span class=\"k\">HAVING</span> <span class=\"n\">num</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">2</span><span class=\"p\">;</span></code></pre></div><p>分组规定：</p><ul><li>GROUP BY 子句出现在 WHERE 子句之后，ORDER BY 子句之前；</li><li>除了汇总字段外，SELECT 语句中的每一字段都必须在 GROUP BY 子句中给出；</li><li>NULL 的行会单独分为一组；</li><li>大多数 SQL 实现不支持 GROUP BY 列具有可变长度的数据类型。</li></ul><h2>十四、子查询</h2><p>子查询中只能返回一个字段的数据。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable1</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col1</span> <span class=\"k\">IN</span> <span class=\"p\">(</span><span class=\"k\">SELECT</span> <span class=\"n\">col2</span>\n               <span class=\"k\">FROM</span> <span class=\"n\">mytable2</span><span class=\"p\">);</span></code></pre></div><p>下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">cust_name</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"k\">SELECT</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span>\n                   <span class=\"k\">FROM</span> <span class=\"n\">Orders</span>\n                   <span class=\"k\">WHERE</span> <span class=\"n\">Orders</span><span class=\"p\">.</span><span class=\"n\">cust_id</span> <span class=\"o\">=</span> <span class=\"n\">Customers</span><span class=\"p\">.</span><span class=\"n\">cust_id</span><span class=\"p\">)</span>\n                   <span class=\"k\">AS</span> <span class=\"n\">orders_num</span>\n<span class=\"k\">FROM</span> <span class=\"n\">Customers</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">cust_name</span><span class=\"p\">;</span></code></pre></div><h2>十五、连接</h2><p>连接用于连接多个表，使用 JOIN 关键字，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名，给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2>内连接</h2><p>内连接又称等值连接，使用 INNER JOIN 关键字。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">A</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">value</span>\n<span class=\"k\">FROM</span> <span class=\"n\">tablea</span> <span class=\"k\">AS</span> <span class=\"n\">A</span> <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"n\">tableb</span> <span class=\"k\">AS</span> <span class=\"n\">B</span>\n<span class=\"k\">ON</span> <span class=\"n\">A</span><span class=\"p\">.</span><span class=\"k\">key</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"k\">key</span><span class=\"p\">;</span></code></pre></div><p>可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">A</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">value</span>\n<span class=\"k\">FROM</span> <span class=\"n\">tablea</span> <span class=\"k\">AS</span> <span class=\"n\">A</span><span class=\"p\">,</span> <span class=\"n\">tableb</span> <span class=\"k\">AS</span> <span class=\"n\">B</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">A</span><span class=\"p\">.</span><span class=\"k\">key</span> <span class=\"o\">=</span> <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"k\">key</span><span class=\"p\">;</span></code></pre></div><h2>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">name</span>\n<span class=\"k\">FROM</span> <span class=\"n\">employee</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">department</span> <span class=\"o\">=</span> <span class=\"p\">(</span>\n      <span class=\"k\">SELECT</span> <span class=\"n\">department</span>\n      <span class=\"k\">FROM</span> <span class=\"n\">employee</span>\n      <span class=\"k\">WHERE</span> <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;Jim&#34;</span><span class=\"p\">);</span></code></pre></div><p>自连接版本</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">e1</span><span class=\"p\">.</span><span class=\"n\">name</span>\n<span class=\"k\">FROM</span> <span class=\"n\">employee</span> <span class=\"k\">AS</span> <span class=\"n\">e1</span> <span class=\"k\">INNER</span> <span class=\"k\">JOIN</span> <span class=\"n\">employee</span> <span class=\"k\">AS</span> <span class=\"n\">e2</span>\n<span class=\"k\">ON</span> <span class=\"n\">e1</span><span class=\"p\">.</span><span class=\"n\">department</span> <span class=\"o\">=</span> <span class=\"n\">e2</span><span class=\"p\">.</span><span class=\"n\">department</span>\n      <span class=\"k\">AND</span> <span class=\"n\">e2</span><span class=\"p\">.</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;Jim&#34;</span><span class=\"p\">;</span></code></pre></div><h2>自然连接</h2><p>自然连接是把同名列通过等值测试连接起来的，同名列可以有多个。</p><p>内连接和自然连接的区别：内连接提供连接的列，而自然连接自动连接所有同名列。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">A</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">B</span><span class=\"p\">.</span><span class=\"n\">value</span>\n<span class=\"k\">FROM</span> <span class=\"n\">tablea</span> <span class=\"k\">AS</span> <span class=\"n\">A</span> <span class=\"k\">NATURAL</span> <span class=\"k\">JOIN</span> <span class=\"n\">tableb</span> <span class=\"k\">AS</span> <span class=\"n\">B</span><span class=\"p\">;</span></code></pre></div><h2>外连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接，左外连接就是保留左表没有关联的行。</p><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">Customers</span><span class=\"p\">.</span><span class=\"n\">cust_id</span><span class=\"p\">,</span> <span class=\"n\">Orders</span><span class=\"p\">.</span><span class=\"n\">order_num</span>\n<span class=\"k\">FROM</span> <span class=\"n\">Customers</span> <span class=\"k\">LEFT</span> <span class=\"k\">OUTER</span> <span class=\"k\">JOIN</span> <span class=\"n\">Orders</span>\n<span class=\"k\">ON</span> <span class=\"n\">Customers</span><span class=\"p\">.</span><span class=\"n\">cust_id</span> <span class=\"o\">=</span> <span class=\"n\">Orders</span><span class=\"p\">.</span><span class=\"n\">cust_id</span><span class=\"p\">;</span></code></pre></div><p>customers 表：</p><p>| cust_id | cust_name | | :---: | :---: | | 1 | a | | 2 | b | | 3 | c |</p><p>orders 表：</p><p>| order_id | cust_id | | :---: | :---: | |1    | 1 | |2    | 1 | |3    | 3 | |4    | 3 |</p><p>结果：</p><p>| cust_id | cust_name | order_id | | :---: | :---: | :---: | | 1 | a | 1 | | 1 | a | 2 | | 3 | c | 3 | | 3 | c | 4 | | 2 | b | Null |</p><h2>十六、组合查询</h2><p>使用  <b>UNION</b>  来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p>每个查询必须包含相同的列、表达式和聚集函数。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"n\">col</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n<span class=\"k\">UNION</span>\n<span class=\"k\">SELECT</span> <span class=\"n\">col</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col</span> <span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">;</span></code></pre></div><h2>十七、视图</h2><p>视图是虚拟的表，本身不包含数据，也就不能对其进行索引操作。</p><p>对视图的操作和对普通表的操作一样。</p><p>视图具有如下好处：</p><ul><li>简化复杂的 SQL 操作，比如复杂的连接；</li><li>只使用实际表的一部分数据；</li><li>通过只给用户访问视图的权限，保证数据的安全性；</li><li>更改数据格式和表示。</li></ul><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">VIEW</span> <span class=\"n\">myview</span> <span class=\"k\">AS</span>\n<span class=\"k\">SELECT</span> <span class=\"n\">Concat</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">,</span> <span class=\"n\">col2</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">concat_col</span><span class=\"p\">,</span> <span class=\"n\">col3</span><span class=\"o\">*</span><span class=\"n\">col4</span> <span class=\"k\">AS</span> <span class=\"n\">compute_col</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">col5</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"p\">;</span></code></pre></div><h2>十八、存储过程</h2><p>存储过程可以看成是对一系列 SQL 操作的批处理。</p><p>使用存储过程的好处：</p><ul><li>代码封装，保证了一定的安全性；</li><li>代码复用；</li><li>由于是预先编译，因此具有很高的性能。</li></ul><p>命令行中创建存储过程需要自定义分隔符，因为命令行是以 ; 为结束符，而存储过程中也包含了分号，因此会错误把这部分分号当成是结束符，造成语法错误。</p><p>包含 in、out 和 inout 三种参数。</p><p>给变量赋值都需要用 select into 语句。</p><p>每次只能给一个变量赋值，不支持集合的操作。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">delimiter</span> <span class=\"o\">//</span>\n\n<span class=\"k\">create</span> <span class=\"k\">procedure</span> <span class=\"n\">myprocedure</span><span class=\"p\">(</span> <span class=\"k\">out</span> <span class=\"n\">ret</span> <span class=\"nb\">int</span> <span class=\"p\">)</span>\n    <span class=\"k\">begin</span>\n        <span class=\"k\">declare</span> <span class=\"n\">y</span> <span class=\"nb\">int</span><span class=\"p\">;</span>\n        <span class=\"k\">select</span> <span class=\"k\">sum</span><span class=\"p\">(</span><span class=\"n\">col1</span><span class=\"p\">)</span>\n        <span class=\"k\">from</span> <span class=\"n\">mytable</span>\n        <span class=\"k\">into</span> <span class=\"n\">y</span><span class=\"p\">;</span>\n        <span class=\"k\">select</span> <span class=\"n\">y</span><span class=\"o\">*</span><span class=\"n\">y</span> <span class=\"k\">into</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n    <span class=\"k\">end</span> <span class=\"o\">//</span>\n\n<span class=\"k\">delimiter</span> <span class=\"p\">;</span>\n<span class=\"k\">call</span> <span class=\"n\">myprocedure</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">ret</span><span class=\"p\">);</span>\n<span class=\"k\">select</span> <span class=\"o\">@</span><span class=\"n\">ret</span><span class=\"p\">;</span></code></pre></div><h2>十九、游标</h2><p>在存储过程中使用游标可以对一个结果集进行移动遍历。</p><p>游标主要用于交互式应用，其中用户需要对数据集中的任意行进行浏览和修改。</p><p>使用游标的四个步骤：</p><ol><li>声明游标，这个过程没有实际检索出数据；</li><li>打开游标；</li><li>取出数据；</li><li>关闭游标；</li></ol><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">delimiter</span> <span class=\"o\">//</span>\n<span class=\"k\">create</span> <span class=\"k\">procedure</span> <span class=\"n\">myprocedure</span><span class=\"p\">(</span><span class=\"k\">out</span> <span class=\"n\">ret</span> <span class=\"nb\">int</span><span class=\"p\">)</span>\n    <span class=\"k\">begin</span>\n        <span class=\"k\">declare</span> <span class=\"n\">done</span> <span class=\"nb\">boolean</span> <span class=\"k\">default</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n        <span class=\"k\">declare</span> <span class=\"n\">mycursor</span> <span class=\"k\">cursor</span> <span class=\"k\">for</span>\n        <span class=\"k\">select</span> <span class=\"n\">col1</span> <span class=\"k\">from</span> <span class=\"n\">mytable</span><span class=\"p\">;</span>\n        <span class=\"o\">#</span> <span class=\"err\">定义了一个</span> <span class=\"k\">continue</span> <span class=\"k\">handler</span><span class=\"err\">，当</span> <span class=\"k\">sqlstate</span> <span class=\"s1\">&#39;02000&#39;</span> <span class=\"err\">这个条件出现时，会执行</span> <span class=\"k\">set</span> <span class=\"n\">done</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n        <span class=\"k\">declare</span> <span class=\"k\">continue</span> <span class=\"k\">handler</span> <span class=\"k\">for</span> <span class=\"k\">sqlstate</span> <span class=\"s1\">&#39;02000&#39;</span> <span class=\"k\">set</span> <span class=\"n\">done</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n        <span class=\"k\">open</span> <span class=\"n\">mycursor</span><span class=\"p\">;</span>\n\n        <span class=\"n\">repeat</span>\n            <span class=\"k\">fetch</span> <span class=\"n\">mycursor</span> <span class=\"k\">into</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n            <span class=\"k\">select</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n        <span class=\"k\">until</span> <span class=\"n\">done</span> <span class=\"k\">end</span> <span class=\"n\">repeat</span><span class=\"p\">;</span>\n\n        <span class=\"k\">close</span> <span class=\"n\">mycursor</span><span class=\"p\">;</span>\n    <span class=\"k\">end</span> <span class=\"o\">//</span>\n <span class=\"k\">delimiter</span> <span class=\"p\">;</span></code></pre></div><h2>二十、触发器</h2><p>触发器会在某个表执行以下语句时而自动执行：DELETE、INSERT、UPDATE。</p><p>触发器必须指定在语句执行之前还是之后自动执行，之前执行使用 BEFORE 关键字，之后执行使用 AFTER 关键字。BEFORE 用于数据验证和净化，AFTER 用于审计跟踪，将修改记录到另外一张表中。</p><p>INSERT 触发器包含一个名为 NEW 的虚拟表。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">TRIGGER</span> <span class=\"n\">mytrigger</span> <span class=\"k\">AFTER</span> <span class=\"k\">INSERT</span> <span class=\"k\">ON</span> <span class=\"n\">mytable</span>\n<span class=\"k\">FOR</span> <span class=\"k\">EACH</span> <span class=\"k\">ROW</span> <span class=\"k\">SELECT</span> <span class=\"k\">NEW</span><span class=\"p\">.</span><span class=\"n\">col</span> <span class=\"k\">into</span> <span class=\"o\">@</span><span class=\"k\">result</span><span class=\"p\">;</span>\n\n<span class=\"k\">SELECT</span> <span class=\"o\">@</span><span class=\"k\">result</span><span class=\"p\">;</span> <span class=\"c1\">-- 获取结果</span></code></pre></div><p>DELETE 触发器包含一个名为 OLD 的虚拟表，并且是只读的。</p><p>UPDATE 触发器包含一个名为 NEW 和一个名为 OLD 的虚拟表，其中 NEW 是可以被修改的，而 OLD 是只读的。</p><p>MySQL 不允许在触发器中使用 CALL 语句，也就是不能调用存储过程。</p><h2>二十一、事务管理</h2><p>基本术语：</p><ul><li>事务（transaction）指一组 SQL 语句；</li><li>回退（rollback）指撤销指定 SQL 语句的过程；</li><li>提交（commit）指将未存储的 SQL 语句结果写入数据库表；</li><li>保留点（savepoint）指事务处理中设置的临时占位符（placeholder），你可以对它发布回退（与回退整个事务处理不同）。</li></ul><p>不能回退 SELECT 语句，回退 SELECT 语句也没意义；也不能回退 CREATE 和 DROP 语句。</p><p>MySQL 的事务提交默认是隐式提交，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 START TRANSACTION 语句时，会关闭隐式提交；当 COMMIT 或 ROLLBACK 语句执行后，事务会自动关闭，重新恢复隐式提交。</p><p>设置 autocommit 为 0 可以取消自动提交；autocommit 标记是针对每个连接而不是针对服务器的。</p><p>如果没有设置保留点，ROLLBACK 会回退到 START TRANSACTION 语句处；如果设置了保留点，并且在 ROLLBACK 中指定该保留点，则会回退到该保留点。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">START</span> <span class=\"n\">TRANSACTION</span>\n<span class=\"o\">//</span> <span class=\"p\">...</span>\n<span class=\"n\">SAVEPOINT</span> <span class=\"n\">delete1</span>\n<span class=\"o\">//</span> <span class=\"p\">...</span>\n<span class=\"k\">ROLLBACK</span> <span class=\"k\">TO</span> <span class=\"n\">delete1</span>\n<span class=\"o\">//</span> <span class=\"p\">...</span>\n<span class=\"k\">COMMIT</span></code></pre></div><h2>二十二、字符集</h2><p>基本术语：</p><ul><li>字符集为字母和符号的集合；</li><li>编码为某个字符集成员的内部表示；</li><li>校对字符指定如何比较，主要用于排序和分组。</li></ul><p>除了给表指定字符集和校对外，也可以给列指定：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">TABLE</span> <span class=\"n\">mytable</span>\n<span class=\"p\">(</span><span class=\"n\">col</span> <span class=\"nb\">VARCHAR</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span> <span class=\"nb\">CHARACTER</span> <span class=\"k\">SET</span> <span class=\"n\">latin</span> <span class=\"k\">COLLATE</span> <span class=\"n\">latin1_general_ci</span> <span class=\"p\">)</span>\n<span class=\"k\">DEFAULT</span> <span class=\"nb\">CHARACTER</span> <span class=\"k\">SET</span> <span class=\"n\">hebrew</span> <span class=\"k\">COLLATE</span> <span class=\"n\">hebrew_general_ci</span><span class=\"p\">;</span></code></pre></div><p>可以在排序、分组时指定校对：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"o\">*</span>\n<span class=\"k\">FROM</span> <span class=\"n\">mytable</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span> <span class=\"n\">col</span> <span class=\"k\">COLLATE</span> <span class=\"n\">latin1_general_ci</span><span class=\"p\">;</span></code></pre></div><h2>二十三、权限管理</h2><p>MySQL 的账户信息保存在 mysql 这个数据库中。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"n\">USE</span> <span class=\"n\">mysql</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"k\">user</span> <span class=\"k\">FROM</span> <span class=\"k\">user</span><span class=\"p\">;</span></code></pre></div><p><b>创建账户</b> </p><p>新创建的账户没有任何权限。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CREATE</span> <span class=\"k\">USER</span> <span class=\"n\">myuser</span> <span class=\"n\">IDENTIFIED</span> <span class=\"k\">BY</span> <span class=\"s1\">&#39;mypassword&#39;</span><span class=\"p\">;</span></code></pre></div><p><b>修改账户名</b> </p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">RENAME</span> <span class=\"n\">myuser</span> <span class=\"k\">TO</span> <span class=\"n\">newuser</span><span class=\"p\">;</span></code></pre></div><p><b>删除账户</b> </p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">DROP</span> <span class=\"k\">USER</span> <span class=\"n\">myuser</span><span class=\"p\">;</span></code></pre></div><p><b>查看权限</b> </p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SHOW</span> <span class=\"n\">GRANTS</span> <span class=\"k\">FOR</span> <span class=\"n\">myuser</span><span class=\"p\">;</span></code></pre></div><p><b>授予权限</b> </p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">GRANT</span> <span class=\"k\">SELECT</span><span class=\"p\">,</span> <span class=\"k\">INSERT</span> <span class=\"k\">ON</span> <span class=\"n\">mydatabase</span><span class=\"p\">.</span><span class=\"o\">*</span> <span class=\"k\">TO</span> <span class=\"n\">myuser</span><span class=\"p\">;</span></code></pre></div><p><b>删除权限</b> </p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">REVOKE</span> <span class=\"k\">SELECT</span><span class=\"p\">,</span> <span class=\"k\">INSERT</span> <span class=\"k\">ON</span> <span class=\"n\">mydatabase</span><span class=\"p\">.</span><span class=\"o\">*</span> <span class=\"k\">FROM</span> <span class=\"n\">myuser</span><span class=\"p\">;</span></code></pre></div><p><b>更改密码</b> </p><p>必须使用 Password() 函数进行加密。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SET</span> <span class=\"n\">PASSWROD</span> <span class=\"k\">FOR</span> <span class=\"n\">myuser</span> <span class=\"o\">=</span> <span class=\"n\">Password</span><span class=\"p\">(</span><span class=\"s1\">&#39;new_password&#39;</span><span class=\"p\">);</span></code></pre></div><h2>参考资料</h2><ul><li>BenForta. SQL 必知必会 [M]. 人民邮电出版社, 2013.</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500259", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 4, 
            "title": "数据库系统原理", 
            "content": "<p></p><h2>一、事务</h2><h2>概念</h2><p>事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10c951143070196e10fdbb91ab80ffe9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"597\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"597\" data-original=\"https://pic2.zhimg.com/v2-10c951143070196e10fdbb91ab80ffe9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;597&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"597\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"597\" data-original=\"https://pic2.zhimg.com/v2-10c951143070196e10fdbb91ab80ffe9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-10c951143070196e10fdbb91ab80ffe9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>ACID</h2><h3>1. 原子性（Atomicity）</h3><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h3>2. 一致性（Consistency）</h3><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h3>3. 隔离性（Isolation）</h3><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h3>4. 持久性（Durability）</h3><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>使用重做日志来保证持久性。</p><hr/><p>事务的 ACID 特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系：</p><ul><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要能满足原子性，就一定能满足一致性。</li><li>在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。</li><li>事务满足持久化是为了能应对数据库崩溃的情况。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e6cce247ea6b8487ef7594dfd119e7a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"799\" data-original=\"https://pic2.zhimg.com/v2-e6cce247ea6b8487ef7594dfd119e7a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;799&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"799\" data-original=\"https://pic2.zhimg.com/v2-e6cce247ea6b8487ef7594dfd119e7a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e6cce247ea6b8487ef7594dfd119e7a5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>AUTOCOMMIT</h2><p>MySQL 默认采用自动提交模式。也就是说，如果不显式使用<code>START TRANSACTION</code>语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。</p><h2>二、并发一致性问题</h2><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h2>丢失修改</h2><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cdcf36f827b7f9a94c50a1dbb39c5e56_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"507\" data-rawheight=\"726\" class=\"origin_image zh-lightbox-thumb\" width=\"507\" data-original=\"https://pic3.zhimg.com/v2-cdcf36f827b7f9a94c50a1dbb39c5e56_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;507&#39; height=&#39;726&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"507\" data-rawheight=\"726\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"507\" data-original=\"https://pic3.zhimg.com/v2-cdcf36f827b7f9a94c50a1dbb39c5e56_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cdcf36f827b7f9a94c50a1dbb39c5e56_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>读脏数据</h2><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-11f15a6701c3a24ebda1f7dcdc259303_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"595\" data-rawheight=\"723\" class=\"origin_image zh-lightbox-thumb\" width=\"595\" data-original=\"https://pic4.zhimg.com/v2-11f15a6701c3a24ebda1f7dcdc259303_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;595&#39; height=&#39;723&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"595\" data-rawheight=\"723\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"595\" data-original=\"https://pic4.zhimg.com/v2-11f15a6701c3a24ebda1f7dcdc259303_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-11f15a6701c3a24ebda1f7dcdc259303_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>不可重复读</h2><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-08fd5a86e988d0bbafc42b53f52f9800_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"732\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic1.zhimg.com/v2-08fd5a86e988d0bbafc42b53f52f9800_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;732&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"732\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic1.zhimg.com/v2-08fd5a86e988d0bbafc42b53f52f9800_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-08fd5a86e988d0bbafc42b53f52f9800_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>幻影读</h2><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d4d9ebd6c9177b6435f9250e42a7be9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-1d4d9ebd6c9177b6435f9250e42a7be9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;722&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-1d4d9ebd6c9177b6435f9250e42a7be9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d4d9ebd6c9177b6435f9250e42a7be9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>产生并发不一致性问题主要原因是破坏了事务的隔离性，解决方法是通过并发控制来保证隔离性。并发控制可以通过封锁来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p><h2>三、封锁</h2><h2>封锁粒度</h2><p>MySQL 中提供了两种封锁粒度：行级锁以及表级锁。</p><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><h2>封锁类型</h2><h3>1. 读写锁</h3><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。</li></ul><p>有以下两个规定：</p><ul><li>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。</li></ul><p>锁的兼容关系如下：</p><p>| - | X | S | | :--: | :--: | :--: | | <b>X</b> |×|×| | <b>S</b> |×|√|</p><h3>2. 意向锁</h3><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><p>| - | X | IX | S | IS | | :--: | :--: | :--: | :--: | :--: | |  <b>X</b>      |×    |×    |×   | ×| |  <b>IX</b>     |×    |√   |×   | √| |  <b>S</b>      |×    |×    |√  | √| |  <b>IS</b>     |×    |√  |√  | √|</p><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只是表示想要对表加锁，而不是真正加锁；</li><li>S 锁只与 S 锁和 IS 锁兼容，也就是说事务 T 想要对数据行加 S 锁，其它事务可以已经获得对表或者表中的行的 S 锁。</li></ul><h2>封锁协议</h2><h3>1. 三级封锁协议</h3><p><b>一级封锁协议</b> </p><p>事务 T 要修改数据 A 时必须加 X 锁，直到 T 结束才释放锁。</p><p>可以解决丢失修改问题，因为不能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p><p>| T1 | T2 | | :--: | :--: | | lock-x(A) | | | read A=20 | | | | lock-x(A) | |  | wait | | write A=19 |. | | commit |. | | unlock-x(A) |. | | | obtain | | | read A=19 | | | write A=21 | | | commit | | | unlock-x(A)|</p><p><b>二级封锁协议</b> </p><p>在一级的基础上，要求读取数据 A 时必须加 S 锁，读取完马上释放 S 锁。</p><p>可以解决读脏数据问题，因为如果一个事务在对数据 A 进行修改，根据 1 级封锁协议，会加 X 锁，那么就不能再加 S 锁了，也就是不会读入数据。</p><p>| T1 | T2 | | :--: | :--: | | lock-x(A) | | | read A=20 | | | write A=19 | | | | lock-s(A) | |  | wait | | rollback | .| | A=20 |. | | unlock-x(A) |. | | | obtain | | | read A=20 | | | unlock-s(A)| | | commit |</p><p><b>三级封锁协议</b> </p><p>在二级的基础上，要求读取数据 A 时必须加 S 锁，直到事务结束了才能释放 S 锁。</p><p>可以解决不可重复读的问题，因为读 A 时，其它事务不能对 A 加 X 锁，从而避免了在读的期间数据发生改变。</p><p>| T1 | T2 | | :--: | :--: | | lock-s(A) | | | read A=20 | | |  |lock-x(A) | | | wait | |  read A=20| . | | commit | .| | unlock-s(A) |. | | | obtain | | | read A=20 | | | write A=19| | | commit | | | unlock-X(A)|</p><h3>2. 两段锁协议</h3><p>加锁和解锁分为两个阶段进行。</p><p>可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p><p>事务遵循两段锁协议是保证可串行化调度的充分条件。例如以下操作满足两段锁协议，它是可串行化调度。</p><div class=\"highlight\"><pre><code class=\"language-html\">lock-x(A)...lock-s(B)...lock-s(C)...unlock(A)...unlock(C)...unlock(B)</code></pre></div><p>但不是必要条件，例如以下操作不满足两段锁协议，但是它还是可串行化调度。</p><div class=\"highlight\"><pre><code class=\"language-html\">lock-x(A)...unlock(A)...lock-s(B)...unlock(B)...lock-s(C)...unlock(C)</code></pre></div><h2>MySQL 隐式与显示锁定</h2><p>MySQL 的 InnoDB 存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。</p><p>InnoDB 也可以使用特定的语句进行显示锁定：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"p\">...</span> <span class=\"k\">LOCK</span> <span class=\"k\">In</span> <span class=\"k\">SHARE</span> <span class=\"k\">MODE</span><span class=\"p\">;</span>\n<span class=\"k\">SELECT</span> <span class=\"p\">...</span> <span class=\"k\">FOR</span> <span class=\"k\">UPDATE</span><span class=\"p\">;</span></code></pre></div><h2>四、隔离级别</h2><h2>未提交读（READ UNCOMMITTED）</h2><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h2>提交读（READ COMMITTED）</h2><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h2>可重复读（REPEATABLE READ）</h2><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h2>可串行化（SERIALIZABLE）</h2><p>强制事务串行执行。</p><p>需要加锁实现，而其它隔离级别通常不需要。</p><hr/><p>| 隔离级别 | 脏读 | 不可重复读 | 幻影读 | | :---: | :---: | :---:| :---: | | 未提交读 | √ | √ | √ | | 提交读 | × | √ | √ | | 可重复读 | × | × | √ | | 可串行化 | × | × | × |</p><h2>五、多版本并发控制</h2><p>多版本并发控制（Multi-Version Concurrency Control, MVCC）是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h2>版本号</h2><ul><li>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。</li><li>事务版本号：事务开始时的系统版本号。</li></ul><h2>隐藏的列</h2><p>MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p><ul><li>创建版本号：指示创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。</li></ul><h2>Undo 日志</h2><p>MVCC 使用到的快照存储在 Undo 日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e4fb40fe4b5144998bf1b1179d8da315_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"536\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb\" width=\"536\" data-original=\"https://pic2.zhimg.com/v2-e4fb40fe4b5144998bf1b1179d8da315_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;536&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"536\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"536\" data-original=\"https://pic2.zhimg.com/v2-e4fb40fe4b5144998bf1b1179d8da315_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e4fb40fe4b5144998bf1b1179d8da315_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>实现过程</h2><p>以下实现过程针对可重复读隔离级别。</p><p>当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号，理解这一点很关键。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p><h3>1. SELECT</h3><p>多个事务必须读取到同一个数据行的快照，并且这个快照是距离现在最近的一个有效快照。但是也有例外，如果有一个事务正在修改该数据行，那么它可以读取事务本身所做的修改，而不用和其它事务的读取结果一致。</p><p>把没有对一个数据行做修改的事务称为 T，T 所要读取的数据行快照的创建版本号必须小于 T 的版本号，因为如果大于或者等于 T 的版本号，那么表示该数据行快照是其它事务的最新修改，因此不能去读取它。除此之外，T 所要读取的数据行快照的删除版本号必须大于 T 的版本号，因为如果小于等于 T 的版本号，那么表示该数据行快照是已经被删除的，不应该去读取它。</p><h3>2. INSERT</h3><p>将当前系统版本号作为数据行快照的创建版本号。</p><h3>3. DELETE</h3><p>将当前系统版本号作为数据行快照的删除版本号。</p><h3>4. UPDATE</h3><p>将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。</p><h2>快照读与当前读</h2><h3>1. 快照读</h3><p>使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">select</span> <span class=\"o\">*</span> <span class=\"k\">from</span> <span class=\"k\">table</span> <span class=\"p\">...;</span></code></pre></div><h3>2. 当前读</h3><p>读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">select</span> <span class=\"o\">*</span> <span class=\"k\">from</span> <span class=\"k\">table</span> <span class=\"k\">where</span> <span class=\"o\">?</span> <span class=\"k\">lock</span> <span class=\"k\">in</span> <span class=\"k\">share</span> <span class=\"k\">mode</span><span class=\"p\">;</span>\n<span class=\"k\">select</span> <span class=\"o\">*</span> <span class=\"k\">from</span> <span class=\"k\">table</span> <span class=\"k\">where</span> <span class=\"o\">?</span> <span class=\"k\">for</span> <span class=\"k\">update</span><span class=\"p\">;</span>\n<span class=\"k\">insert</span><span class=\"p\">;</span>\n<span class=\"k\">update</span><span class=\"p\">;</span>\n<span class=\"k\">delete</span><span class=\"p\">;</span></code></pre></div><h2>六、Next-Key Locks</h2><p>Next-Key Locks 是 MySQL 的 InnoDB 存储引擎的一种锁实现。</p><p>MVCC 不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。</p><h2>Record Locks</h2><p>锁定一个记录上的索引，而不是记录本身。</p><p>如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。</p><h2>Gap Locks</h2><p>锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"k\">c</span> <span class=\"k\">FROM</span> <span class=\"n\">t</span> <span class=\"k\">WHERE</span> <span class=\"k\">c</span> <span class=\"k\">BETWEEN</span> <span class=\"mi\">10</span> <span class=\"k\">and</span> <span class=\"mi\">20</span> <span class=\"k\">FOR</span> <span class=\"k\">UPDATE</span><span class=\"p\">;</span></code></pre></div><h2>Next-Key Locks</h2><p>它是 Record Locks 和 Gap Locks 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"err\">∞</span><span class=\"p\">,</span> <span class=\"mi\">10</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"mi\">11</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"mi\">11</span><span class=\"p\">,</span> <span class=\"mi\">13</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"mi\">13</span><span class=\"p\">,</span> <span class=\"mi\">20</span><span class=\"p\">]</span>\n<span class=\"p\">(</span><span class=\"mi\">20</span><span class=\"p\">,</span> <span class=\"o\">+</span><span class=\"err\">∞</span><span class=\"p\">)</span></code></pre></div><h2>七、关系数据库设计理论</h2><h2>函数依赖</h2><p>记 A-&gt;B 表示 A 函数决定 B，也可以说 B 函数依赖于 A。</p><p>如果 {A1，A2，... ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p><p>对于 A-&gt;B，如果能找到 A 的真子集 A&#39;，使得 A&#39;-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p><p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p><h2>异常</h2><p>以下的学生课程关系的函数依赖为 {Sno, Cname} -&gt; {Sname, Sdept, Mname, Grade}，键码为 {Sno, Cname}。也就是说，确定学生和课程之后，就能确定其它信息。</p><p>| Sno | Sname | Sdept | Mname | Cname | Grade | | :---: | :---: | :---: | :---: | :---: |:---:| | 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 | | 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 | | 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 | | 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |</p><p>不符合范式的关系，会产生很多异常，主要有以下四种异常：</p><ul><li>冗余数据：例如 <code>学生-2</code> 出现了两次。</li><li>修改异常：修改了一个记录中的信息，但是另一个记录中相同的信息却没有被修改。</li><li>删除异常：删除一个信息，那么也会丢失其它信息。例如删除了 <code>课程-1</code> 需要删除第一行和第三行，那么 <code>学生-1</code> 的信息就会丢失。</li><li>插入异常：例如想要插入一个学生的信息，如果这个学生还没选课，那么就无法插入。</li></ul><h2>范式</h2><p>范式理论是为了解决以上提到四种异常。</p><p>高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。</p><h3>1. 第一范式 (1NF)</h3><p>属性不可分。</p><h3>2. 第二范式 (2NF)</h3><p>每个非主属性完全函数依赖于键码。</p><p>可以通过分解来满足。</p><p><b>分解前</b> <br/></p><p>| Sno | Sname | Sdept | Mname | Cname | Grade | | :---: | :---: | :---: | :---: | :---: |:---:| | 1 | 学生-1 | 学院-1 | 院长-1 | 课程-1 | 90 | | 2 | 学生-2 | 学院-2 | 院长-2 | 课程-2 | 80 | | 2 | 学生-2 | 学院-2 | 院长-2 | 课程-1 | 100 | | 3 | 学生-3 | 学院-2 | 院长-2 | 课程-2 | 95 |</p><p>以上学生课程关系中，{Sno, Cname} 为键码，有如下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li><li>Sno, Cname-&gt; Grade</li></ul><p>Grade 完全函数依赖于键码，它没有任何冗余数据，每个学生的每门课都有特定的成绩。</p><p>Sname, Sdept 和 Mname 都部分依赖于键码，当一个学生选修了多门课时，这些数据就会出现多次，造成大量冗余数据。</p><p><b>分解后</b> <br/></p><p>关系-1</p><p>| Sno | Sname | Sdept | Mname | | :---: | :---: | :---: | :---: | | 1 | 学生-1 | 学院-1 | 院长-1 | | 2 | 学生-2 | 学院-2 | 院长-2 | | 3 | 学生-3 | 学院-2 | 院长-2 |</p><p>有以下函数依赖：</p><ul><li>Sno -&gt; Sname, Sdept</li><li>Sdept -&gt; Mname</li></ul><p>关系-2</p><p>| Sno | Cname | Grade | | :---: | :---: |:---:| | 1 | 课程-1 | 90 | | 2 | 课程-2 | 80 | | 2 | 课程-1 | 100 | | 3 | 课程-2 | 95 |</p><p>有以下函数依赖：</p><ul><li>Sno, Cname -&gt;  Grade</li></ul><h3>3. 第三范式 (3NF)</h3><p>非主属性不传递函数依赖于键码。</p><p>上面的 关系-1 中存在以下传递函数依赖：</p><ul><li>Sno -&gt; Sdept -&gt; Mname</li></ul><p>可以进行以下分解：</p><p>关系-11</p><p>| Sno | Sname | Sdept | | :---: | :---: | :---: | | 1 | 学生-1 | 学院-1 | | 2 | 学生-2 | 学院-2 | | 3 | 学生-3 | 学院-2 |</p><p>关系-12</p><p>| Sdept | Mname | | :---: | :---: | | 学院-1 | 院长-1 | | 学院-2 | 院长-2 |</p><h2>八、ER 图</h2><p>Entity-Relationship，有三个组成部分：实体、属性、联系。</p><p>用来进行关系型数据库系统的概念设计。</p><h2>实体的三种联系</h2><p>包含一对一，一对多，多对多三种。</p><ul><li>如果 A 到 B 是一对多关系，那么画个带箭头的线段指向 B；</li><li>如果是一对一，画两个带箭头的线段；</li><li>如果是多对多，画两个不带箭头的线段。</li></ul><p>下图的 Course 和 Student 是一对多的关系。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-17291ae21435bc8bc45723edea9292b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-17291ae21435bc8bc45723edea9292b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;142&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-17291ae21435bc8bc45723edea9292b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-17291ae21435bc8bc45723edea9292b9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>表示出现多次的关系</h2><p>一个实体在联系出现几次，就要用几条线连接。</p><p>下图表示一个课程的先修关系，先修关系出现两个 Course 实体，第一个是先修课程，后一个是后修课程，因此需要用两条线来表示这种关系。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5aa339bb58d721f86158ba71b56caf20_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"261\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;261&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"261\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic1.zhimg.com/v2-5aa339bb58d721f86158ba71b56caf20_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>联系的多向性</h2><p>虽然老师可以开设多门课，并且可以教授多名学生，但是对于特定的学生和课程，只有一个老师教授，这就构成了一个三元联系。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b7a64e4a7db2e5c85015ba98a40591ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic4.zhimg.com/v2-b7a64e4a7db2e5c85015ba98a40591ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic4.zhimg.com/v2-b7a64e4a7db2e5c85015ba98a40591ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b7a64e4a7db2e5c85015ba98a40591ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>表示子类</h2><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，而与父类和子类都有关的连到父类上。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c462ace14933ed85ff3b940fc086bd0d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb\" width=\"764\" data-original=\"https://pic2.zhimg.com/v2-c462ace14933ed85ff3b940fc086bd0d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;764&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"764\" data-original=\"https://pic2.zhimg.com/v2-c462ace14933ed85ff3b940fc086bd0d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c462ace14933ed85ff3b940fc086bd0d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考资料</h2><ul><li>AbrahamSilberschatz, HenryF.Korth, S.Sudarshan, 等. 数据库系统概念 [M]. 机械工业出版社, 2006.</li><li>施瓦茨. 高性能 MYSQL(第3版)[M]. 电子工业出版社, 2013.</li><li>史嘉权. 数据库系统概论[M]. 清华大学出版社有限公司, 2006.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The InnoDB Storage Engine</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.slideshare.net/ErnestoHernandezRodriguez/transaction-isolation-levels\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Transaction isolation levels</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//scanftree.com/dbms/2-phase-locking-protocol\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Concurrency Control</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.slideshare.net/brshristov/the-nightmare-of-locking-blocking-and-isolation-levels-46391666\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Nightmare of Locking, Blocking and Isolation Levels!</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//aksakalli.github.io/2012/03/12/database-normalization-and-normal-forms-with-an-example.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Database Normalization and Normal Forms with an Example</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.jcole.us/2014/04/16/the-basics-of-the-innodb-undo-logging-and-history-system/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The basics of the InnoDB undo logging and history system</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.brightbox.com/blog/2013/10/31/on-mysql-locks/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MySQL locking for the busy web developer</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//draveness.me/mysql-innodb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">浅入浅出 MySQL 和 InnoDB</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/2014/08/20/innodb-lock.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Innodb 中的事务隔离级别和锁的关系</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68500017", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "Java I/O", 
            "content": "<p></p><h2>一、概览</h2><p>Java 的 I/O 大概可以分成以下几类：</p><ul><li>磁盘操作：File</li><li>字节操作：InputStream 和 OutputStream</li><li>字符操作：Reader 和 Writer</li><li>对象操作：Serializable</li><li>网络操作：Socket</li><li>新的输入/输出：NIO</li></ul><h2>二、磁盘操作</h2><p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p><p>递归地列出一个目录下所有文件：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">listAllFiles</span><span class=\"o\">(</span><span class=\"n\">File</span> <span class=\"n\">dir</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dir</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">!</span><span class=\"n\">dir</span><span class=\"o\">.</span><span class=\"na\">exists</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">dir</span><span class=\"o\">.</span><span class=\"na\">isFile</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dir</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">File</span> <span class=\"n\">file</span> <span class=\"o\">:</span> <span class=\"n\">dir</span><span class=\"o\">.</span><span class=\"na\">listFiles</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">listAllFiles</span><span class=\"o\">(</span><span class=\"n\">file</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p><h2>三、字节操作</h2><h2>实现文件复制</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">copyFile</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">src</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">dist</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n    <span class=\"n\">FileInputStream</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"o\">);</span>\n    <span class=\"n\">FileOutputStream</span> <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"n\">dist</span><span class=\"o\">);</span>\n\n    <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">byte</span><span class=\"o\">[</span><span class=\"n\">20</span> <span class=\"o\">*</span> <span class=\"n\">1024</span><span class=\"o\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// read() 最多读取 buffer.length 个字节\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 返回的是实际读取的个数\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 返回 -1 的时候表示读到 eof，即文件尾\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">))</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">cnt</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n    <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>装饰者模式</h2><p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p><ul><li>InputStream 是抽象组件；</li><li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li><li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-74321940629b4766a661bbf48bdd4131_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb\" width=\"1225\" data-original=\"https://pic2.zhimg.com/v2-74321940629b4766a661bbf48bdd4131_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1225&#39; height=&#39;499&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1225\" data-original=\"https://pic2.zhimg.com/v2-74321940629b4766a661bbf48bdd4131_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-74321940629b4766a661bbf48bdd4131_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">FileInputStream</span> <span class=\"n\">fileInputStream</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">filePath</span><span class=\"o\">);</span>\n<span class=\"n\">BufferedInputStream</span> <span class=\"n\">bufferedInputStream</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BufferedInputStream</span><span class=\"o\">(</span><span class=\"n\">fileInputStream</span><span class=\"o\">);</span></code></pre></div><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p><h2>四、字符操作</h2><h2>编码与解码</h2><p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p><p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p><ul><li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li><li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li><li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li></ul><p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p><p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p><h2>String 的编码方式</h2><p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">str1</span> <span class=\"o\">=</span> <span class=\"s\">&#34;中文&#34;</span><span class=\"o\">;</span>\n<span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">bytes</span> <span class=\"o\">=</span> <span class=\"n\">str1</span><span class=\"o\">.</span><span class=\"na\">getBytes</span><span class=\"o\">(</span><span class=\"s\">&#34;UTF-8&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">String</span> <span class=\"n\">str2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"n\">bytes</span><span class=\"o\">,</span> <span class=\"s\">&#34;UTF-8&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">str2</span><span class=\"o\">);</span></code></pre></div><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">bytes</span> <span class=\"o\">=</span> <span class=\"n\">str1</span><span class=\"o\">.</span><span class=\"na\">getBytes</span><span class=\"o\">();</span></code></pre></div><h2>Reader 与 Writer</h2><p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p><ul><li>InputStreamReader 实现从字节流解码成字符流；</li><li>OutputStreamWriter 实现字符流编码成为字节流。</li></ul><h2>实现逐行输出文本文件的内容</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">readFileContent</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">filePath</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">FileReader</span> <span class=\"n\">fileReader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileReader</span><span class=\"o\">(</span><span class=\"n\">filePath</span><span class=\"o\">);</span>\n    <span class=\"n\">BufferedReader</span> <span class=\"n\">bufferedReader</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BufferedReader</span><span class=\"o\">(</span><span class=\"n\">fileReader</span><span class=\"o\">);</span>\n\n    <span class=\"n\">String</span> <span class=\"n\">line</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">line</span> <span class=\"o\">=</span> <span class=\"n\">bufferedReader</span><span class=\"o\">.</span><span class=\"na\">readLine</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">line</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 因此只要一个 close() 调用即可\n</span><span class=\"c1\"></span>    <span class=\"n\">bufferedReader</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>五、对象操作</h2><h2>序列化</h2><p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p><ul><li>序列化：ObjectOutputStream.writeObject()</li><li>反序列化：ObjectInputStream.readObject()</li></ul><p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p><h2>Serializable</h2><p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span><span class=\"o\">,</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">A</span> <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">,</span> <span class=\"s\">&#34;abc&#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">String</span> <span class=\"n\">objectFile</span> <span class=\"o\">=</span> <span class=\"s\">&#34;file/a1&#34;</span><span class=\"o\">;</span>\n\n    <span class=\"n\">ObjectOutputStream</span> <span class=\"n\">objectOutputStream</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjectOutputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"n\">objectFile</span><span class=\"o\">));</span>\n    <span class=\"n\">objectOutputStream</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">);</span>\n    <span class=\"n\">objectOutputStream</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n\n    <span class=\"n\">ObjectInputStream</span> <span class=\"n\">objectInputStream</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjectInputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">objectFile</span><span class=\"o\">));</span>\n    <span class=\"n\">A</span> <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">A</span><span class=\"o\">)</span> <span class=\"n\">objectInputStream</span><span class=\"o\">.</span><span class=\"na\">readObject</span><span class=\"o\">();</span>\n    <span class=\"n\">objectInputStream</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"kd\">implements</span> <span class=\"n\">Serializable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"n\">A</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;x = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"s\">&#34;  &#34;</span> <span class=\"o\">+</span> <span class=\"s\">&#34;y = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>transient</h2><p>transient 关键字可以使一些属性不会被序列化。</p><p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">transient</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">elementData</span><span class=\"o\">;</span></code></pre></div><h2>六、网络操作</h2><p>Java 中的网络支持：</p><ul><li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li><li>URL：统一资源定位符；</li><li>Sockets：使用 TCP 协议实现网络通信；</li><li>Datagram：使用 UDP 协议实现网络通信。</li></ul><h2>InetAddress</h2><p>没有公有的构造函数，只能通过静态方法来创建实例。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">InetAddress</span><span class=\"o\">.</span><span class=\"na\">getByName</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">host</span><span class=\"o\">);</span>\n<span class=\"n\">InetAddress</span><span class=\"o\">.</span><span class=\"na\">getByAddress</span><span class=\"o\">(</span><span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">address</span><span class=\"o\">);</span></code></pre></div><h2>URL</h2><p>可以直接从 URL 中读取字节流数据。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">URL</span> <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">URL</span><span class=\"o\">(</span><span class=\"s\">&#34;http://www.baidu.com&#34;</span><span class=\"o\">);</span>\n\n    <span class=\"cm\">/* 字节流 */</span>\n    <span class=\"n\">InputStream</span> <span class=\"n\">is</span> <span class=\"o\">=</span> <span class=\"n\">url</span><span class=\"o\">.</span><span class=\"na\">openStream</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/* 字符流 */</span>\n    <span class=\"n\">InputStreamReader</span> <span class=\"n\">isr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InputStreamReader</span><span class=\"o\">(</span><span class=\"n\">is</span><span class=\"o\">,</span> <span class=\"s\">&#34;utf-8&#34;</span><span class=\"o\">);</span>\n\n    <span class=\"cm\">/* 提供缓存功能 */</span>\n    <span class=\"n\">BufferedReader</span> <span class=\"n\">br</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BufferedReader</span><span class=\"o\">(</span><span class=\"n\">isr</span><span class=\"o\">);</span>\n\n    <span class=\"n\">String</span> <span class=\"n\">line</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">line</span> <span class=\"o\">=</span> <span class=\"n\">br</span><span class=\"o\">.</span><span class=\"na\">readLine</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">line</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">br</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>Sockets</h2><ul><li>ServerSocket：服务器端类</li><li>Socket：客户端类</li><li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8f9b6ac1fdc8a33da6a35b1b163f806c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb\" width=\"897\" data-original=\"https://pic1.zhimg.com/v2-8f9b6ac1fdc8a33da6a35b1b163f806c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;897&#39; height=&#39;561&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"897\" data-original=\"https://pic1.zhimg.com/v2-8f9b6ac1fdc8a33da6a35b1b163f806c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8f9b6ac1fdc8a33da6a35b1b163f806c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Datagram</h2><ul><li>DatagramSocket：通信类</li><li>DatagramPacket：数据包类</li></ul><h2>七、NIO</h2><p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p><h2>流与块</h2><p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p><p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p><p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p><p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p><h2>通道与缓冲区</h2><h3>1. 通道</h3><p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p><p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p><p>通道包括以下类型：</p><ul><li>FileChannel：从文件中读写数据；</li><li>DatagramChannel：通过 UDP 读写网络中数据；</li><li>SocketChannel：通过 TCP 读写网络中数据；</li><li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li></ul><h3>2. 缓冲区</h3><p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p><p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p><p>缓冲区包括以下类型：</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li></ul><h2>缓冲区状态变量</h2><ul><li>capacity：最大容量；</li><li>position：当前已经读写的字节数；</li><li>limit：还可以读写的字节数。</li></ul><p>状态变量的改变过程举例：</p><p>① 新建一个大小为 8 个字节的缓冲区，此时 position 为 0，而 limit = capacity = 8。capacity 变量不会改变，下面的讨论会忽略它。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;186&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8b6864d61dc274d8345ec835ab7661d2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>② 从输入通道中读取 5 个字节数据写入缓冲区中，此时 position 为 5，limit 保持不变。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"496\" data-original=\"https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;496&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"496\" data-original=\"https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fc890e5883e578a1eceacd564f4fc5ba_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>③ 在将缓冲区的数据写到输出通道之前，需要先调用 flip() 方法，这个方法将 limit 设置为当前 position，并将 position 设置为 0。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"549\" data-rawheight=\"146\" class=\"origin_image zh-lightbox-thumb\" width=\"549\" data-original=\"https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;549&#39; height=&#39;146&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"549\" data-rawheight=\"146\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"549\" data-original=\"https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fbde9a084339448fa0a8c690a0621420_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>④ 从缓冲区中取 4 个字节到输出缓冲中，此时 position 设为 4。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7d0bc96ce589d38a640241e707e6386e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>⑤ 最后需要调用 clear() 方法来清空缓冲区，此时 position 和 limit 都被设置为最初位置。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;462&#39; height=&#39;151&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0c9bcea8c53459f420055a485797d6ee_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>文件 NIO 实例</h2><p>以下展示了使用 NIO 快速复制文件的实例：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">fastCopy</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">src</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">dist</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/* 获得源文件的输入字节流 */</span>\n    <span class=\"n\">FileInputStream</span> <span class=\"n\">fin</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">src</span><span class=\"o\">);</span>\n\n    <span class=\"cm\">/* 获取输入字节流的文件通道 */</span>\n    <span class=\"n\">FileChannel</span> <span class=\"n\">fcin</span> <span class=\"o\">=</span> <span class=\"n\">fin</span><span class=\"o\">.</span><span class=\"na\">getChannel</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/* 获取目标文件的输出字节流 */</span>\n    <span class=\"n\">FileOutputStream</span> <span class=\"n\">fout</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"n\">dist</span><span class=\"o\">);</span>\n\n    <span class=\"cm\">/* 获取输出字节流的文件通道 */</span>\n    <span class=\"n\">FileChannel</span> <span class=\"n\">fcout</span> <span class=\"o\">=</span> <span class=\"n\">fout</span><span class=\"o\">.</span><span class=\"na\">getChannel</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/* 为缓冲区分配 1024 个字节 */</span>\n    <span class=\"n\">ByteBuffer</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">ByteBuffer</span><span class=\"o\">.</span><span class=\"na\">allocateDirect</span><span class=\"o\">(</span><span class=\"n\">1024</span><span class=\"o\">);</span>\n\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"cm\">/* 从输入通道中读取数据到缓冲区中 */</span>\n        <span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">fcin</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">);</span>\n\n        <span class=\"cm\">/* read() 返回 -1 表示 EOF */</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"cm\">/* 切换读写 */</span>\n        <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">flip</span><span class=\"o\">();</span>\n\n        <span class=\"cm\">/* 把缓冲区的内容写入输出文件中 */</span>\n        <span class=\"n\">fcout</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">);</span>\n\n        <span class=\"cm\">/* 清空缓冲区 */</span>\n        <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">clear</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>选择器</h2><p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p><p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p><p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p><p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p><p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a36df1391f2ad8c834356eeb17d9a37f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"620\" data-original=\"https://pic4.zhimg.com/v2-a36df1391f2ad8c834356eeb17d9a37f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;620&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"620\" data-original=\"https://pic4.zhimg.com/v2-a36df1391f2ad8c834356eeb17d9a37f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a36df1391f2ad8c834356eeb17d9a37f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1. 创建选择器</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Selector</span> <span class=\"n\">selector</span> <span class=\"o\">=</span> <span class=\"n\">Selector</span><span class=\"o\">.</span><span class=\"na\">open</span><span class=\"o\">();</span></code></pre></div><h3>2. 将通道注册到选择器上</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">ServerSocketChannel</span> <span class=\"n\">ssChannel</span> <span class=\"o\">=</span> <span class=\"n\">ServerSocketChannel</span><span class=\"o\">.</span><span class=\"na\">open</span><span class=\"o\">();</span>\n<span class=\"n\">ssChannel</span><span class=\"o\">.</span><span class=\"na\">configureBlocking</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">);</span>\n<span class=\"n\">ssChannel</span><span class=\"o\">.</span><span class=\"na\">register</span><span class=\"o\">(</span><span class=\"n\">selector</span><span class=\"o\">,</span> <span class=\"n\">SelectionKey</span><span class=\"o\">.</span><span class=\"na\">OP_ACCEPT</span><span class=\"o\">);</span></code></pre></div><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p><p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p><ul><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ul><p>它们在 SelectionKey 的定义如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">OP_READ</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">OP_WRITE</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">OP_CONNECT</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">OP_ACCEPT</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">4</span><span class=\"o\">;</span></code></pre></div><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">interestSet</span> <span class=\"o\">=</span> <span class=\"n\">SelectionKey</span><span class=\"o\">.</span><span class=\"na\">OP_READ</span> <span class=\"o\">|</span> <span class=\"n\">SelectionKey</span><span class=\"o\">.</span><span class=\"na\">OP_WRITE</span><span class=\"o\">;</span></code></pre></div><h3>3. 监听事件</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">select</span><span class=\"o\">();</span></code></pre></div><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p><h3>4. 获取到达的事件</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">selectedKeys</span><span class=\"o\">();</span>\n<span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keyIterator</span> <span class=\"o\">=</span> <span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"na\">iterator</span><span class=\"o\">();</span>\n<span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">hasNext</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n    <span class=\"n\">SelectionKey</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isAcceptable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isReadable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h3>5. 事件循环</h3><p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">select</span><span class=\"o\">();</span>\n    <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">selectedKeys</span><span class=\"o\">();</span>\n    <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keyIterator</span> <span class=\"o\">=</span> <span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"na\">iterator</span><span class=\"o\">();</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">hasNext</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n        <span class=\"n\">SelectionKey</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isAcceptable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isReadable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n        <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>套接字 NIO 实例</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">NIOServer</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n\n        <span class=\"n\">Selector</span> <span class=\"n\">selector</span> <span class=\"o\">=</span> <span class=\"n\">Selector</span><span class=\"o\">.</span><span class=\"na\">open</span><span class=\"o\">();</span>\n\n        <span class=\"n\">ServerSocketChannel</span> <span class=\"n\">ssChannel</span> <span class=\"o\">=</span> <span class=\"n\">ServerSocketChannel</span><span class=\"o\">.</span><span class=\"na\">open</span><span class=\"o\">();</span>\n        <span class=\"n\">ssChannel</span><span class=\"o\">.</span><span class=\"na\">configureBlocking</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">);</span>\n        <span class=\"n\">ssChannel</span><span class=\"o\">.</span><span class=\"na\">register</span><span class=\"o\">(</span><span class=\"n\">selector</span><span class=\"o\">,</span> <span class=\"n\">SelectionKey</span><span class=\"o\">.</span><span class=\"na\">OP_ACCEPT</span><span class=\"o\">);</span>\n\n        <span class=\"n\">ServerSocket</span> <span class=\"n\">serverSocket</span> <span class=\"o\">=</span> <span class=\"n\">ssChannel</span><span class=\"o\">.</span><span class=\"na\">socket</span><span class=\"o\">();</span>\n        <span class=\"n\">InetSocketAddress</span> <span class=\"n\">address</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InetSocketAddress</span><span class=\"o\">(</span><span class=\"s\">&#34;127.0.0.1&#34;</span><span class=\"o\">,</span> <span class=\"n\">8888</span><span class=\"o\">);</span>\n        <span class=\"n\">serverSocket</span><span class=\"o\">.</span><span class=\"na\">bind</span><span class=\"o\">(</span><span class=\"n\">address</span><span class=\"o\">);</span>\n\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n            <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">select</span><span class=\"o\">();</span>\n            <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"n\">selector</span><span class=\"o\">.</span><span class=\"na\">selectedKeys</span><span class=\"o\">();</span>\n            <span class=\"n\">Iterator</span><span class=\"o\">&lt;</span><span class=\"n\">SelectionKey</span><span class=\"o\">&gt;</span> <span class=\"n\">keyIterator</span> <span class=\"o\">=</span> <span class=\"n\">keys</span><span class=\"o\">.</span><span class=\"na\">iterator</span><span class=\"o\">();</span>\n\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">hasNext</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n\n                <span class=\"n\">SelectionKey</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isAcceptable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n\n                    <span class=\"n\">ServerSocketChannel</span> <span class=\"n\">ssChannel1</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">ServerSocketChannel</span><span class=\"o\">)</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">channel</span><span class=\"o\">();</span>\n\n                    <span class=\"c1\">// 服务器会为每个新连接创建一个 SocketChannel\n</span><span class=\"c1\"></span>                    <span class=\"n\">SocketChannel</span> <span class=\"n\">sChannel</span> <span class=\"o\">=</span> <span class=\"n\">ssChannel1</span><span class=\"o\">.</span><span class=\"na\">accept</span><span class=\"o\">();</span>\n                    <span class=\"n\">sChannel</span><span class=\"o\">.</span><span class=\"na\">configureBlocking</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">);</span>\n\n                    <span class=\"c1\">// 这个新连接主要用于从客户端读取数据\n</span><span class=\"c1\"></span>                    <span class=\"n\">sChannel</span><span class=\"o\">.</span><span class=\"na\">register</span><span class=\"o\">(</span><span class=\"n\">selector</span><span class=\"o\">,</span> <span class=\"n\">SelectionKey</span><span class=\"o\">.</span><span class=\"na\">OP_READ</span><span class=\"o\">);</span>\n\n                <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">isReadable</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n\n                    <span class=\"n\">SocketChannel</span> <span class=\"n\">sChannel</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">SocketChannel</span><span class=\"o\">)</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">channel</span><span class=\"o\">();</span>\n                    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">readDataFromSocketChannel</span><span class=\"o\">(</span><span class=\"n\">sChannel</span><span class=\"o\">));</span>\n                    <span class=\"n\">sChannel</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n\n                <span class=\"n\">keyIterator</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"nf\">readDataFromSocketChannel</span><span class=\"o\">(</span><span class=\"n\">SocketChannel</span> <span class=\"n\">sChannel</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n\n        <span class=\"n\">ByteBuffer</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"n\">ByteBuffer</span><span class=\"o\">.</span><span class=\"na\">allocate</span><span class=\"o\">(</span><span class=\"n\">1024</span><span class=\"o\">);</span>\n        <span class=\"n\">StringBuilder</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StringBuilder</span><span class=\"o\">();</span>\n\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n            <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">clear</span><span class=\"o\">();</span>\n            <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">sChannel</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">flip</span><span class=\"o\">();</span>\n            <span class=\"kt\">int</span> <span class=\"n\">limit</span> <span class=\"o\">=</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">limit</span><span class=\"o\">();</span>\n            <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">dst</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"o\">[</span><span class=\"n\">limit</span><span class=\"o\">];</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">limit</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">dst</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">char</span><span class=\"o\">)</span> <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">dst</span><span class=\"o\">);</span>\n            <span class=\"n\">buffer</span><span class=\"o\">.</span><span class=\"na\">clear</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">NIOClient</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n        <span class=\"n\">Socket</span> <span class=\"n\">socket</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Socket</span><span class=\"o\">(</span><span class=\"s\">&#34;127.0.0.1&#34;</span><span class=\"o\">,</span> <span class=\"n\">8888</span><span class=\"o\">);</span>\n        <span class=\"n\">OutputStream</span> <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">socket</span><span class=\"o\">.</span><span class=\"na\">getOutputStream</span><span class=\"o\">();</span>\n        <span class=\"n\">String</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s\">&#34;hello world&#34;</span><span class=\"o\">;</span>\n        <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">getBytes</span><span class=\"o\">());</span>\n        <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>内存映射文件</h2><p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p><p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p><p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">MappedByteBuffer</span> <span class=\"n\">mbb</span> <span class=\"o\">=</span> <span class=\"n\">fc</span><span class=\"o\">.</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"n\">FileChannel</span><span class=\"o\">.</span><span class=\"na\">MapMode</span><span class=\"o\">.</span><span class=\"na\">READ_WRITE</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">1024</span><span class=\"o\">);</span></code></pre></div><h2>对比</h2><p>NIO 与普通 I/O 的区别主要有以下两点：</p><ul><li>NIO 是非阻塞的；</li><li>NIO 面向块，I/O 面向流。</li></ul><h2>八、参考资料</h2><ul><li>Eckel B, 埃克尔, 昊鹏, 等. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IBM: NIO 入门</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//tutorials.jenkov.com/java-nio/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java NIO Tutorial</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/nio.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java NIO 浅析</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IBM: 深入分析 Java I/O 的工作机制</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-chinesecoding/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IBM: 深入分析 Java 中的中文编码问题</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-serial/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IBM: Java 序列化的高级认识</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/shimiso/article/details/24990499\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NIO 与传统 IO 的区别</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//stg-tud.github.io/sedc/Lecture/ws13-14/5.3-Decorator.html%23mode%3Ddocument\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Decorator Design Pattern</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//labojava.blogspot.com/2012/12/socket-multicast.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Socket Multicast</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68499946", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "Java 虚拟机", 
            "content": "<p></p><p>本文大部分内容参考  <b>周志明《深入理解 Java 虚拟机》</b> ，想要深入学习的话请看原书。</p><h2>一、运行时数据区域</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0268349386d5c1e492b454460ff03e2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"1029\" class=\"origin_image zh-lightbox-thumb\" width=\"733\" data-original=\"https://pic2.zhimg.com/v2-0268349386d5c1e492b454460ff03e2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;733&#39; height=&#39;1029&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"1029\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"733\" data-original=\"https://pic2.zhimg.com/v2-0268349386d5c1e492b454460ff03e2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0268349386d5c1e492b454460ff03e2d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>程序计数器</h2><p>记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。</p><h2>Java 虚拟机栈</h2><p>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a81e9e5f899ad7efe6fdcd175b6f72f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"786\" data-original=\"https://pic2.zhimg.com/v2-a81e9e5f899ad7efe6fdcd175b6f72f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;786&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"786\" data-original=\"https://pic2.zhimg.com/v2-a81e9e5f899ad7efe6fdcd175b6f72f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a81e9e5f899ad7efe6fdcd175b6f72f9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以通过 -Xss 这个虚拟机参数来指定每个线程的 Java 虚拟机栈内存大小，在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">java</span> <span class=\"o\">-</span><span class=\"n\">Xss2M</span> <span class=\"n\">HackTheJava</span></code></pre></div><p>该区域可能抛出以下异常：</p><ul><li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；</li><li>栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。</li></ul><h2>本地方法栈</h2><p>本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地方法服务。</p><p>本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-11de47081dc95bfea1433985b1fa3874_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-11de47081dc95bfea1433985b1fa3874_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-11de47081dc95bfea1433985b1fa3874_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-11de47081dc95bfea1433985b1fa3874_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>堆</h2><p>所有对象都在这里分配内存，是垃圾收集的主要区域（&#34;GC 堆&#34;）。</p><p>现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：</p><ul><li>新生代（Young Generation）</li><li>老年代（Old Generation）</li></ul><p>堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。</p><p>可以通过 -Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">java</span> <span class=\"o\">-</span><span class=\"n\">Xms1M</span> <span class=\"o\">-</span><span class=\"n\">Xmx2M</span> <span class=\"n\">HackTheJava</span></code></pre></div><h2>方法区</h2><p>用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><p>和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。</p><p>对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。</p><p>HotSpot 虚拟机把它当成永久代来进行垃圾回收。但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。</p><p>方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。</p><h2>运行时常量池</h2><p>运行时常量池是方法区的一部分。</p><p>Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。</p><p>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。</p><h2>直接内存</h2><p>在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。</p><h2>二、垃圾收集</h2><p>垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。</p><h2>判断一个对象是否可被回收</h2><h3>1. 引用计数算法</h3><p>为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。</p><p>在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Test</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Test</span><span class=\"o\">();</span>\n        <span class=\"n\">Test</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Test</span><span class=\"o\">();</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">instance</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n        <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">instance</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">doSomething</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>在上述代码中，a 与 b 引用的对象实例互相持有了对象的引用，因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，导致两个 Test 对象无法被回收。</p><h3>2. 可达性分析算法</h3><p>以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。</p><p>Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：</p><ul><li>虚拟机栈中局部变量表中引用的对象</li><li>本地方法栈中 JNI 中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中的常量引用的对象</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-185d5df4e82924c1f04d7ba12337ceb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-185d5df4e82924c1f04d7ba12337ceb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;342&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-185d5df4e82924c1f04d7ba12337ceb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-185d5df4e82924c1f04d7ba12337ceb5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. 方法区的回收</h3><p>因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。</p><p>主要是对常量池的回收和对类的卸载。</p><p>为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。</p><p>类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：</p><ul><li>该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。</li></ul><h3>4. finalize()</h3><p>类似 C++ 的析构函数，用于关闭外部资源。但是 try-finally 等方式可以做得更好，并且该方法运行代价很高，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。</p><p>当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会再调用该方法。</p><h2>引用类型</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。</p><p>Java 提供了四种强度不同的引用类型。</p><h3>1. 强引用</h3><p>被强引用关联的对象不会被回收。</p><p>使用 new 一个新对象的方式来创建强引用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Object</span> <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">();</span></code></pre></div><h3>2. 软引用</h3><p>被软引用关联的对象只有在内存不够的情况下才会被回收。</p><p>使用 SoftReference 类来创建软引用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Object</span> <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">();</span>\n<span class=\"n\">SoftReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">sf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SoftReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;(</span><span class=\"n\">obj</span><span class=\"o\">);</span>\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>  <span class=\"o\">//</span> <span class=\"n\">使对象只被软引用关联</span></code></pre></div><h3>3. 弱引用</h3><p>被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。</p><p>使用 WeakReference 类来创建弱引用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Object</span> <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">();</span>\n<span class=\"n\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">wf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;(</span><span class=\"n\">obj</span><span class=\"o\">);</span>\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span></code></pre></div><h3>4. 虚引用</h3><p>又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。</p><p>为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。</p><p>使用 PhantomReference 来创建虚引用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Object</span> <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">();</span>\n<span class=\"n\">PhantomReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"n\">pf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PhantomReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;(</span><span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n<span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span></code></pre></div><h2>垃圾收集算法</h2><h3>1. 标记 - 清除</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-722cb484c4fb1761a3c5920480d62458_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"658\" data-original=\"https://pic1.zhimg.com/v2-722cb484c4fb1761a3c5920480d62458_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;658&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"658\" data-original=\"https://pic1.zhimg.com/v2-722cb484c4fb1761a3c5920480d62458_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-722cb484c4fb1761a3c5920480d62458_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。</p><p>在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。</p><p>在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block。如果它找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 (block - size) 的两部分，返回大小为 size 的分块，并把大小为 (block - size) 的块返回给空闲链表。</p><p>不足：</p><ul><li>标记和清除过程效率都不高；</li><li>会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul><h3>2. 标记 - 整理</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cc95191c9f5a2028d291ccdfc0509f5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"658\" data-original=\"https://pic4.zhimg.com/v2-cc95191c9f5a2028d291ccdfc0509f5b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;658&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"658\" data-original=\"https://pic4.zhimg.com/v2-cc95191c9f5a2028d291ccdfc0509f5b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cc95191c9f5a2028d291ccdfc0509f5b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>优点:</p><ul><li>不会产生内存碎片</li></ul><p>不足:</p><ul><li>需要移动大量对象，处理效率比较低。</li></ul><h3>3. 复制</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8fa24f2ef95d40e1357f4c2fe897eb9a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-8fa24f2ef95d40e1357f4c2fe897eb9a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-8fa24f2ef95d40e1357f4c2fe897eb9a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8fa24f2ef95d40e1357f4c2fe897eb9a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。</p><p>主要不足是只使用了内存的一半。</p><p>现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。</p><p>HotSpot 虚拟机的 Eden 和 Survivor 大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 就不够用了，此时需要依赖于老年代进行空间分配担保，也就是借用老年代的空间存储放不下的对象。</p><h3>4. 分代收集</h3><p>现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。</p><p>一般将堆分为新生代和老年代。</p><ul><li>新生代使用：复制算法</li><li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li></ul><h2>垃圾收集器</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d43a7060a00c6beb905f3c24fd386ef8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"646\" data-original=\"https://pic1.zhimg.com/v2-d43a7060a00c6beb905f3c24fd386ef8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;646&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"646\" data-original=\"https://pic1.zhimg.com/v2-d43a7060a00c6beb905f3c24fd386ef8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d43a7060a00c6beb905f3c24fd386ef8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以上是 HotSpot 虚拟机中的 7 个垃圾收集器，连线表示垃圾收集器可以配合使用。</p><ul><li>单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程；</li><li>串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行。</li></ul><h3>1. Serial 收集器</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-08897b0e82d7a2b16424d30cca15284a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"722\" data-original=\"https://pic3.zhimg.com/v2-08897b0e82d7a2b16424d30cca15284a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;722&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"722\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"722\" data-original=\"https://pic3.zhimg.com/v2-08897b0e82d7a2b16424d30cca15284a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-08897b0e82d7a2b16424d30cca15284a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Serial 翻译为串行，也就是说它以串行的方式执行。</p><p>它是单线程的收集器，只会使用一个线程进行垃圾收集工作。</p><p>它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。</p><p>它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。</p><h3>2. ParNew 收集器</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1b3ebac8fd28f9a3112670e8d6de3a2a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1b3ebac8fd28f9a3112670e8d6de3a2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;716&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1b3ebac8fd28f9a3112670e8d6de3a2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1b3ebac8fd28f9a3112670e8d6de3a2a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>它是 Serial 收集器的多线程版本。</p><p>它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。</p><h3>3. Parallel Scavenge 收集器</h3><p>与 ParNew 一样是多线程收集器。</p><p>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户程序的时间占总时间的比值。</p><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。</p><p>缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。</p><p>可以通过一个开关参数打开 GC 自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小（-Xmn）、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p><h3>4. Serial Old 收集器</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1c4c6fec6a11ffadcf3e0a2afcfd1de7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"734\" data-original=\"https://pic4.zhimg.com/v2-1c4c6fec6a11ffadcf3e0a2afcfd1de7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;734&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"734\" data-original=\"https://pic4.zhimg.com/v2-1c4c6fec6a11ffadcf3e0a2afcfd1de7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1c4c6fec6a11ffadcf3e0a2afcfd1de7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>是 Serial 收集器的老年代版本，也是给 Client 场景下的虚拟机使用。如果用在 Server 场景下，它有两大用途：</p><ul><li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。</li><li>作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。</li></ul><h3>5. Parallel Old 收集器</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3d67b5197f7c8776f22ce6cbc7d5e831_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb\" width=\"740\" data-original=\"https://pic2.zhimg.com/v2-3d67b5197f7c8776f22ce6cbc7d5e831_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;740&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"270\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"740\" data-original=\"https://pic2.zhimg.com/v2-3d67b5197f7c8776f22ce6cbc7d5e831_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3d67b5197f7c8776f22ce6cbc7d5e831_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>是 Parallel Scavenge 收集器的老年代版本。</p><p>在注重吞吐量以及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。</p><h3>6. CMS 收集器</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-635203d88706af1419aee561bfb39276_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb\" width=\"733\" data-original=\"https://pic3.zhimg.com/v2-635203d88706af1419aee561bfb39276_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;733&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"733\" data-original=\"https://pic3.zhimg.com/v2-635203d88706af1419aee561bfb39276_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-635203d88706af1419aee561bfb39276_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。</p><p>分为以下四个流程：</p><ul><li>初始标记：仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。</li><li>并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。</li><li>重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。</li><li>并发清除：不需要停顿。</li></ul><p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。</p><p>具有以下缺点：</p><ul><li>吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。</li><li>无法处理浮动垃圾，可能出现 Concurrent Mode Failure。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</li><li>标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。</li></ul><h3>7. G1 收集器</h3><p>G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。</p><p>堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7c9d46c971f780d42eb9f93ba90c16df_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"735\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb\" width=\"735\" data-original=\"https://pic4.zhimg.com/v2-7c9d46c971f780d42eb9f93ba90c16df_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;735&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"735\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"735\" data-original=\"https://pic4.zhimg.com/v2-7c9d46c971f780d42eb9f93ba90c16df_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7c9d46c971f780d42eb9f93ba90c16df_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8a3a8980055629dcf65e45639fc43dcd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"713\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb\" width=\"713\" data-original=\"https://pic2.zhimg.com/v2-8a3a8980055629dcf65e45639fc43dcd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;713&#39; height=&#39;511&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"713\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"713\" data-original=\"https://pic2.zhimg.com/v2-8a3a8980055629dcf65e45639fc43dcd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8a3a8980055629dcf65e45639fc43dcd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。</p><p>每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-963fa8518101ed719913c6dd743aac34_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"763\" data-original=\"https://pic1.zhimg.com/v2-963fa8518101ed719913c6dd743aac34_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;763&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"763\" data-original=\"https://pic1.zhimg.com/v2-963fa8518101ed719913c6dd743aac34_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-963fa8518101ed719913c6dd743aac34_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记</li><li>并发标记</li><li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。</li><li>筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p>具备如下特点：</p><ul><li>空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。</li><li>可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。</li></ul><h2>三、内存分配与回收策略</h2><h2>Minor GC 和 Full GC</h2><ul><li> Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。<br/> </li><li> Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。<br/> </li></ul><h2>内存分配策略</h2><h3>1. 对象优先在 Eden 分配</h3><p>大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。</p><h3>2. 大对象直接进入老年代</h3><p>大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。</p><p>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</p><p>-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</p><h3>3. 长期存活的对象进入老年代</h3><p>为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。</p><p>-XX:MaxTenuringThreshold 用来定义年龄的阈值。</p><h3>4. 动态对象年龄判定</h3><p>虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</p><h3>5. 空间分配担保</h3><p>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。</p><p>如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</p><h2>Full GC 的触发条件</h2><p>对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：</p><h3>1. 调用 System.gc()</h3><p>只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。</p><h3>2. 老年代空间不足</h3><p>老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。</p><p>为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。</p><h3>3. 空间分配担保失败</h3><p>使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。</p><h3>4. JDK 1.7 及以前的永久代空间不足</h3><p>在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。</p><p>当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。</p><p>为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。</p><h3>5. Concurrent Mode Failure</h3><p>执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。</p><h2>四、类加载机制</h2><p>类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。</p><h2>类的生命周期</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ec3637dda2f4cfe987b4e2f1a9a81a27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1085\" data-rawheight=\"257\" class=\"origin_image zh-lightbox-thumb\" width=\"1085\" data-original=\"https://pic4.zhimg.com/v2-ec3637dda2f4cfe987b4e2f1a9a81a27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1085&#39; height=&#39;257&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1085\" data-rawheight=\"257\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1085\" data-original=\"https://pic4.zhimg.com/v2-ec3637dda2f4cfe987b4e2f1a9a81a27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ec3637dda2f4cfe987b4e2f1a9a81a27_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>包括以下 7 个阶段：</p><ul><li><b>加载（Loading）</b> </li><li><b>验证（Verification）</b> </li><li><b>准备（Preparation）</b> </li><li><b>解析（Resolution）</b> </li><li><b>初始化（Initialization）</b> </li><li>使用（Using）</li><li>卸载（Unloading）</li></ul><h2>类加载过程</h2><p>包含了加载、验证、准备、解析和初始化这 5 个阶段。</p><h3>1. 加载</h3><p>加载是类加载的一个阶段，注意不要混淆。</p><p>加载过程完成以下三件事：</p><ul><li>通过类的完全限定名称获取定义该类的二进制字节流。</li><li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构。</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。</li></ul><p>其中二进制字节流可以从以下方式中获取：</p><ul><li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从网络中获取，最典型的应用是 Applet。</li><li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。</li><li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类。</li></ul><h3>2. 验证</h3><p>确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><h3>3. 准备</h3><p>类变量是被 static 修饰的变量，准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。</p><p>实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中。应该注意到，实例化不是类加载的一个过程，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。</p><p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span></code></pre></div><p>如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span></code></pre></div><h3>4. 解析</h3><p>将常量池的符号引用替换为直接引用的过程。</p><p>其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>5. 初始化</h3><p class=\"ztext-empty-paragraph\"><br/></p><p>初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 &lt;clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。</p><p>&lt;clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>                <span class=\"c1\">// 给变量赋值可以正常编译通过\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>  <span class=\"c1\">// 这句编译器会提示“非法向前引用”\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>由于父类的 &lt;clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Parent</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Sub</span> <span class=\"kd\">extends</span> <span class=\"n\">Parent</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n     <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">Sub</span><span class=\"o\">.</span><span class=\"na\">B</span><span class=\"o\">);</span>  <span class=\"c1\">// 2\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 &lt;clinit&gt;() 方法。</p><p>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都会阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕。如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。</p><h2>类初始化时机</h2><h3>1. 主动引用</h3><p>虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）：</p><ul><li> 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这 4 条指令的场景是：使用 new 关键字实例化对象的时候；读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候；以及调用一个类的静态方法的时候。<br/> </li><li> 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行初始化，则需要先触发其初始化。<br/> </li><li> 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。<br/> </li><li> 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类；<br/> </li><li> 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；<br/> </li></ul><h3>2. 被动引用</h3><p>以上 5 种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括：</p><ul><li>通过子类引用父类的静态字段，不会导致子类初始化。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">SubClass</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">);</span>  <span class=\"o\">//</span> <span class=\"n\">value</span> <span class=\"n\">字段在</span> <span class=\"n\">SuperClass</span> <span class=\"n\">中定义</span></code></pre></div><ul><li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">SuperClass</span><span class=\"o\">[]</span> <span class=\"n\">sca</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SuperClass</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span></code></pre></div><ul><li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">ConstClass</span><span class=\"o\">.</span><span class=\"na\">HELLOWORLD</span><span class=\"o\">);</span></code></pre></div><h2>类与类加载器</h2><p>两个类相等，需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。</p><p>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。</p><h2>类加载器分类</h2><p>从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器：</p><ul><li> 启动类加载器（Bootstrap ClassLoader），使用 C++ 实现，是虚拟机自身的一部分；<br/> </li><li> 所有其它类的加载器，使用 Java 实现，独立于虚拟机，继承自抽象类 java.lang.ClassLoader。<br/> </li></ul><p>从 Java 开发人员的角度看，类加载器可以划分得更细致一些：</p><ul><li> 启动类加载器（Bootstrap ClassLoader）此类加载器负责将存放在 &lt;JRE_HOME&gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。<br/> </li><li> 扩展类加载器（Extension ClassLoader）这个类加载器是由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt;JAVA_HOME&gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。<br/> </li><li> 应用程序类加载器（Application ClassLoader）这个类加载器是由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br/> </li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>双亲委派模型</h2><p>应用程序是由三种类加载器互相配合从而实现类加载，除此之外还可以加入自己定义的类加载器。</p><p>下图展示了类加载器之间的层次关系，称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-28349961f153dffda2cd3642e492b244_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb\" width=\"817\" data-original=\"https://pic1.zhimg.com/v2-28349961f153dffda2cd3642e492b244_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;817&#39; height=&#39;771&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"817\" data-original=\"https://pic1.zhimg.com/v2-28349961f153dffda2cd3642e492b244_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-28349961f153dffda2cd3642e492b244_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1. 工作过程</h3><p>一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载。</p><h3>2. 好处</h3><p>使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。</p><p>例如 java.lang.Object 存放在 rt.jar 中，如果编写另外一个 java.lang.Object 并放到 ClassPath 中，程序可以编译通过。由于双亲委派模型的存在，所以在 rt.jar 中的 Object 比在 ClassPath 中的 Object 优先级更高，这是因为 rt.jar 中的 Object 使用的是启动类加载器，而 ClassPath 中的 Object 使用的是应用程序类加载器。rt.jar 中的 Object 优先级更高，那么程序中所有的 Object 都是这个 Object。</p><h3>3. 实现</h3><p>以下是抽象类 java.lang.ClassLoader 的代码片段，其中的 loadClass() 方法运行过程如下：先检查类是否已经加载过，如果没有则让父类加载器去加载。当父类加载器加载失败时抛出 ClassNotFoundException，此时尝试自己去加载。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">ClassLoader</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// The parent class loader for delegation\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ClassLoader</span> <span class=\"n\">parent</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">loadClass</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">loadClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">protected</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">loadClass</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">resolve</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">getClassLoadingLock</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// First, check if the class has already been loaded\n</span><span class=\"c1\"></span>            <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">findLoadedClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">parent</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">parent</span><span class=\"o\">.</span><span class=\"na\">loadClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n                    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                        <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">findBootstrapClassOrNull</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">ClassNotFoundException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// ClassNotFoundException thrown if class not found\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// from the non-null parent class loader\n</span><span class=\"c1\"></span>                <span class=\"o\">}</span>\n\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// If still not found, then invoke findClass in order\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// to find the class.\n</span><span class=\"c1\"></span>                    <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">findClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">resolve</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">resolveClass</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">return</span> <span class=\"n\">c</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">protected</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">findClass</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ClassNotFoundException</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>自定义类加载器实现</h2><p>以下代码中的 FileSystemClassLoader 是自定义类加载器，继承自 java.lang.ClassLoader，用于加载文件系统上的类。它首先根据类的全名在文件系统上查找类的字节代码文件（.class 文件），然后读取该文件内容，最后通过 defineClass() 方法来把这些字节代码转换成 java.lang.Class 类的实例。</p><p>java.lang.ClassLoader 的 loadClass() 实现了双亲委派模型的逻辑，自定义类加载器一般不去重写它，但是需要重写 findClass() 方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">FileSystemClassLoader</span> <span class=\"kd\">extends</span> <span class=\"n\">ClassLoader</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">rootDir</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">FileSystemClassLoader</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">rootDir</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">rootDir</span> <span class=\"o\">=</span> <span class=\"n\">rootDir</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">protected</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">findClass</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">classData</span> <span class=\"o\">=</span> <span class=\"n\">getClassData</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">classData</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ClassNotFoundException</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">defineClass</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">classData</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">classData</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"nf\">getClassData</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">className</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">path</span> <span class=\"o\">=</span> <span class=\"n\">classNameToPath</span><span class=\"o\">(</span><span class=\"n\">className</span><span class=\"o\">);</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">InputStream</span> <span class=\"n\">ins</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">path</span><span class=\"o\">);</span>\n            <span class=\"n\">ByteArrayOutputStream</span> <span class=\"n\">baos</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ByteArrayOutputStream</span><span class=\"o\">();</span>\n            <span class=\"kt\">int</span> <span class=\"n\">bufferSize</span> <span class=\"o\">=</span> <span class=\"n\">4096</span><span class=\"o\">;</span>\n            <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">buffer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">byte</span><span class=\"o\">[</span><span class=\"n\">bufferSize</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">bytesNumRead</span><span class=\"o\">;</span>\n            <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">bytesNumRead</span> <span class=\"o\">=</span> <span class=\"n\">ins</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">))</span> <span class=\"o\">!=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">baos</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">buffer</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">bytesNumRead</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n            <span class=\"k\">return</span> <span class=\"n\">baos</span><span class=\"o\">.</span><span class=\"na\">toByteArray</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"nf\">classNameToPath</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">className</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">rootDir</span> <span class=\"o\">+</span> <span class=\"n\">File</span><span class=\"o\">.</span><span class=\"na\">separatorChar</span>\n                <span class=\"o\">+</span> <span class=\"n\">className</span><span class=\"o\">.</span><span class=\"na\">replace</span><span class=\"o\">(</span><span class=\"sc\">&#39;.&#39;</span><span class=\"o\">,</span> <span class=\"n\">File</span><span class=\"o\">.</span><span class=\"na\">separatorChar</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"s\">&#34;.class&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>参考资料</h2><ul><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html%23jvms-2.5.4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Chapter 2. The Structure of the Java Virtual Machine</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.slideshare.net/benewu/jvm-memory\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Jvm memory</a> <a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Getting Started with the G1 Garbage Collector</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//electrofriends.com/articles/jni/jni-part1-java-native-interface/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JNI Part1: Java Native Interface Introduction and “Hello World” application</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//hackthejava.wordpress.com/2015/01/09/memory-architecture-by-jvmruntime-data-areas/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Memory Architecture Of JVM(Runtime Data Areas)</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.programcreek.com/2013/04/jvm-run-time-data-areas/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JVM Run-Time Data Areas</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.drdobbs.com/architecture-and-design/android-on-x86-java-native-interface-and/240166271\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Android on x86: Java Native Interface and the Android Native Development Kit</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//crowhawk.github.io/2017/08/10/jvm_2/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解 JVM(2)——GC 算法与内存分配策略</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//crowhawk.github.io/2017/08/15/jvm_3/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解 JVM(3)——7 种垃圾收集器</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.jamesdbloom.com/JVMInternals.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JVM Internals</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html%23code6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入探讨 Java 类加载器</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.baeldung.com/java-weakhashmap\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Guide to WeakHashMap in Java</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//alvinalexander.com/java/jwarehouse/apache-tomcat-6.0.16/java/org/apache/el/util/ConcurrentCache.java.shtml\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tomcat example source code file (ConcurrentCache.java)</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68499453", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "Java 基础", 
            "content": "<p></p><h2>一、数据类型</h2><h2>基本类型</h2><ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/\\~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Primitive Data Types</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Java® Virtual Machine Specification</a></li></ul><h2>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>     <span class=\"c1\">// 装箱\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>         <span class=\"o\">//</span> <span class=\"n\">拆箱</span></code></pre></div><h2>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">);</span>    <span class=\"c1\">// false\n</span><span class=\"c1\"></span><span class=\"n\">Integer</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">);</span>   <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Integer</span> <span class=\"nf\">valueOf</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">low</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">high</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">cache</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"o\">(-</span><span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">low</span><span class=\"o\">)];</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128\\~127。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">128</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">high</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Integer</span> <span class=\"n\">cache</span><span class=\"o\">[];</span>\n\n<span class=\"kd\">static</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// high value may be configured by property\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">127</span><span class=\"o\">;</span>\n    <span class=\"n\">String</span> <span class=\"n\">integerCacheHighPropValue</span> <span class=\"o\">=</span>\n        <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">misc</span><span class=\"o\">.</span><span class=\"na\">VM</span><span class=\"o\">.</span><span class=\"na\">getSavedProperty</span><span class=\"o\">(</span><span class=\"s\">&#34;java.lang.Integer.IntegerCache.high&#34;</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">integerCacheHighPropValue</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">parseInt</span><span class=\"o\">(</span><span class=\"n\">integerCacheHighPropValue</span><span class=\"o\">);</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">127</span><span class=\"o\">);</span>\n            <span class=\"c1\">// Maximum array size is Integer.MAX_VALUE\n</span><span class=\"c1\"></span>            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span> <span class=\"o\">-</span> <span class=\"o\">(-</span><span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span><span class=\"o\">(</span> <span class=\"n\">NumberFormatException</span> <span class=\"n\">nfe</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// If the property cannot be parsed into an int, ignore it.\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n\n    <span class=\"n\">cache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">[(</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">low</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n        <span class=\"n\">cache</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">++);</span>\n\n    <span class=\"c1\">// range [-128, 127] must be interned (JLS7 5.1.7)\n</span><span class=\"c1\"></span>    <span class=\"k\">assert</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">high</span> <span class=\"o\">&gt;=</span> <span class=\"n\">127</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n<span class=\"n\">Integer</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">==</span> <span class=\"n\">n</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \\u0000 to \\u007F</li></ul><p>在使用这些基本类型对应的包装类型时，如果该数值范围在缓冲池范围内，就可以直接使用缓冲池中的对象。</p><p>在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的，在启动 jvm 的时候，通过 -XX:AutoBoxCacheMax=&lt;size&gt; 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.IntegerCache.high 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 </a></p><h2>二、String</h2><h2>概览</h2><p>String 被声明为 final，因此它不可被继承。</p><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">String</span>\n    <span class=\"kd\">implements</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">Serializable</span><span class=\"o\">,</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;,</span> <span class=\"n\">CharSequence</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** The value is used for character storage. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">char</span> <span class=\"n\">value</span><span class=\"o\">[];</span>\n<span class=\"o\">}</span></code></pre></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">String</span>\n    <span class=\"kd\">implements</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">Serializable</span><span class=\"o\">,</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;,</span> <span class=\"n\">CharSequence</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** The value is used for character storage. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">byte</span> <span class=\"n\">coder</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2>不可变的好处</h2><p><b>1. 可以缓存 hash 值</b> </p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><b>2. String Pool 的需要</b> </p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b7e94f0c88ab301f3829f92f34071bb4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-b7e94f0c88ab301f3829f92f34071bb4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-b7e94f0c88ab301f3829f92f34071bb4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b7e94f0c88ab301f3829f92f34071bb4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3. 安全性</b> </p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><b>4. 线程安全</b> </p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.programcreek.com/2013/04/why-string-is-immutable-in-java/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Program Creek : Why String is immutable in Java?</a></p><h2>String, StringBuffer and StringBuilder</h2><p><b>1. 可变性</b> </p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><b>2. 线程安全</b> </p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : String, StringBuffer, and StringBuilder</a></p><h2>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">String</span> <span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">==</span> <span class=\"n\">s2</span><span class=\"o\">);</span>           <span class=\"c1\">// false\n</span><span class=\"c1\"></span><span class=\"n\">String</span> <span class=\"n\">s3</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">intern</span><span class=\"o\">();</span>\n<span class=\"n\">String</span> <span class=\"n\">s4</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">intern</span><span class=\"o\">();</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s3</span> <span class=\"o\">==</span> <span class=\"n\">s4</span><span class=\"o\">);</span>           <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>如果是采用 &#34;bbb&#34; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s5</span> <span class=\"o\">=</span> <span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">;</span>\n<span class=\"n\">String</span> <span class=\"n\">s6</span> <span class=\"o\">=</span> <span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">;</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s5</span> <span class=\"o\">==</span> <span class=\"n\">s6</span><span class=\"o\">);</span>  <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/10578984/what-is-string-interning\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : What is String interning?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/in_depth_understanding_string_intern.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入解析 String#intern</a></li></ul><h2>new String(&#34;abc&#34;)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &#34;abc&#34; 字符串对象）。</p><ul><li>&#34;abc&#34; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &#34;abc&#34; 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">NewStringTest</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;abc&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>使用 javap -verbose 进行反编译，得到以下内容：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"n\">Constant</span> <span class=\"nl\">pool:</span>\n<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>   <span class=\"err\">#</span><span class=\"n\">2</span> <span class=\"o\">=</span> <span class=\"n\">Class</span>              <span class=\"err\">#</span><span class=\"n\">18</span>            <span class=\"c1\">// java/lang/String\n</span><span class=\"c1\"></span>   <span class=\"err\">#</span><span class=\"n\">3</span> <span class=\"o\">=</span> <span class=\"n\">String</span>             <span class=\"err\">#</span><span class=\"n\">19</span>            <span class=\"c1\">// abc\n</span><span class=\"c1\">// ...\n</span><span class=\"c1\"></span>  <span class=\"err\">#</span><span class=\"n\">18</span> <span class=\"o\">=</span> <span class=\"n\">Utf8</span>               <span class=\"n\">java</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">String</span>\n  <span class=\"err\">#</span><span class=\"n\">19</span> <span class=\"o\">=</span> <span class=\"n\">Utf8</span>               <span class=\"n\">abc</span>\n<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">String</span><span class=\"o\">[]);</span><span class=\"nl\">\n</span><span class=\"nl\">    descriptor:</span> <span class=\"o\">([</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">String</span><span class=\"o\">;)</span><span class=\"n\">V</span><span class=\"nl\">\n</span><span class=\"nl\">    flags:</span> <span class=\"n\">ACC_PUBLIC</span><span class=\"o\">,</span> <span class=\"n\">ACC_STATIC</span><span class=\"nl\">\n</span><span class=\"nl\">    Code:</span>\n      <span class=\"n\">stack</span><span class=\"o\">=</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">locals</span><span class=\"o\">=</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">args_size</span><span class=\"o\">=</span><span class=\"n\">1</span><span class=\"nl\">\n</span><span class=\"nl\">         0:</span> <span class=\"k\">new</span>           <span class=\"err\">#</span><span class=\"n\">2</span>                  <span class=\"c1\">// class java/lang/String\n</span><span class=\"c1\"></span>         <span class=\"nl\">3:</span> <span class=\"n\">dup</span><span class=\"nl\">\n</span><span class=\"nl\">         4:</span> <span class=\"n\">ldc</span>           <span class=\"err\">#</span><span class=\"n\">3</span>                  <span class=\"c1\">// String abc\n</span><span class=\"c1\"></span>         <span class=\"nl\">6:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"n\">4</span>                  <span class=\"c1\">// Method java/lang/String.&#34;&lt;init&gt;&#34;:(Ljava/lang/String;)V\n</span><span class=\"c1\"></span>         <span class=\"nl\">9:</span> <span class=\"n\">astore_1</span>\n<span class=\"o\">//</span> <span class=\"o\">...</span></code></pre></div><p>在 Constant Pool 中，#19 存储这字符串字面量 &#34;abc&#34;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">String</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">original</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">hash</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>三、运算</h2><h2>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Dog</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n\n    <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">String</span> <span class=\"nf\">getName</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">setName</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">String</span> <span class=\"nf\">getObjectAddress</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">PassByValueExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Dog</span> <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;A&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// A\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">(</span><span class=\"n\">Dog</span> <span class=\"n\">dog</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;B&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@74a14482\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// B\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">PassByValueExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Dog</span> <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;A&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// B\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">(</span><span class=\"n\">Dog</span> <span class=\"n\">dog</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">setName</span><span class=\"o\">(</span><span class=\"s\">&#34;B&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h2>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"o\">//</span> <span class=\"kt\">float</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">.</span><span class=\"na\">1</span><span class=\"o\">;</span></code></pre></div><p>1.1f 字面量才是 float 类型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">float</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">.</span><span class=\"na\">1f</span><span class=\"o\">;</span></code></pre></div><h2>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">short</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">//</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">s1</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">//</span> <span class=\"n\">s1</span><span class=\"o\">++;</span></code></pre></div><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">short</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Why don&#39;t Java&#39;s +=, -=, *=, /= compound assignment operators require casting?</a></p><h2>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s\">&#34;a&#34;</span><span class=\"o\">;</span>\n<span class=\"k\">switch</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"s\">&#34;a&#34;</span><span class=\"o\">:</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">break</span><span class=\"o\">;</span>\n    <span class=\"k\">case</span> <span class=\"s\">&#34;b&#34;</span><span class=\"o\">:</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">break</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// long x = 111;\n</span><span class=\"c1\">// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;\n</span><span class=\"c1\">//     case 111:\n</span><span class=\"c1\">//         System.out.println(111);\n</span><span class=\"c1\">//         break;\n</span><span class=\"c1\">//     case 222:\n</span><span class=\"c1\">//         System.out.println(222);\n</span><span class=\"c1\">//         break;\n</span><span class=\"c1\"></span><span class=\"o\">//</span> <span class=\"o\">}</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Why can&#39;t your switch statement data type be long, Java?</a></p><h2>四、继承</h2><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"n\">id</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getId</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">id</span> <span class=\"o\">+</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setId</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessWithInnerClassExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">InnerClass</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">InnerClass</span> <span class=\"n\">innerClass</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">AccessWithInnerClassExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">innerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InnerClass</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getValue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">innerClass</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">;</span>  <span class=\"c1\">// 直接访问\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>抽象类与接口</h2><p><b>1. 抽象类</b> </p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。如果一个类中包含抽象方法，那么这个类必须声明为抽象类。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">AbstractClassExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func2</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func2&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AbstractExtendClassExample</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractClassExample</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func1&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// AbstractClassExample ac1 = new AbstractClassExample(); // &#39;AbstractClassExample&#39; is abstract; cannot be instantiated\n</span><span class=\"c1\"></span><span class=\"n\">AbstractClassExample</span> <span class=\"n\">ac2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AbstractExtendClassExample</span><span class=\"o\">();</span>\n<span class=\"n\">ac2</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">();</span></code></pre></div><p><b>2. 接口</b> </p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">InterfaceExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">();</span>\n\n    <span class=\"k\">default</span> <span class=\"kt\">void</span> <span class=\"nf\">func2</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func2&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n    <span class=\"c1\">// int y;               // Variable &#39;y&#39; might not have been initialized\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>       <span class=\"c1\">// Modifier &#39;public&#39; is redundant for interface fields\n</span><span class=\"c1\"></span>    <span class=\"c1\">// private int k = 0;   // Modifier &#39;private&#39; not allowed here\n</span><span class=\"c1\"></span>    <span class=\"c1\">// protected int l = 0; // Modifier &#39;protected&#39; not allowed here\n</span><span class=\"c1\"></span>    <span class=\"c1\">// private void fun3(); // Modifier &#39;private&#39; not allowed here\n</span><span class=\"c1\"></span><span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterfaceImplementExample</span> <span class=\"kd\">implements</span> <span class=\"n\">InterfaceExample</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func1&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated\n</span><span class=\"c1\"></span><span class=\"n\">InterfaceExample</span> <span class=\"n\">ie2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InterfaceImplementExample</span><span class=\"o\">();</span>\n<span class=\"n\">ie2</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">();</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">InterfaceExample</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">);</span></code></pre></div><p><b>3. 比较</b> </p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><b>4. 使用选择</b> </p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/java/IandI/abstract.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Abstract Methods and Classes</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/l-javainterface-abstract/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解 abstract class 和 interface</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//dzone.com/articles/when-to-use-abstract-class-and-intreface\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">When to Use Abstract Class and Interface</a></li></ul><h2>super</h2><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SuperExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">SuperExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;SuperExample.func()&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SuperExtendExample</span> <span class=\"kd\">extends</span> <span class=\"n\">SuperExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">SuperExtendExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">);</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">z</span> <span class=\"o\">=</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;SuperExtendExample.func()&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">SuperExample</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SuperExtendExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">3</span><span class=\"o\">);</span>\n<span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">();</span>\n<span class=\"n\">SuperExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">()</span>\n<span class=\"n\">SuperExtendExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">()</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/java/IandI/super.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Using the Keyword super</a></p><h2>重写与重载</h2><p><b>1. 重写（Override）</b> </p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有以下三个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li><li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的三个限制条件。</p><p>下面的示例中，SubClass 为 SuperClass 的子类，SubClass 重写了 SuperClass 的 func() 方法。其中：</p><ul><li>子类方法访问权限为 public，大于父类的 protected。</li><li>子类的返回类型为 ArrayList，是父类返回类型 List 的子类。</li><li>子类抛出的异常类型为 Exception，是父类抛出异常 Throwable 的子类。</li><li>子类重写方法使用 @Override 注解，从而让编译器自动检查是否满足限制条件。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">SuperClass</span> <span class=\"o\">{</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Throwable</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">SubClass</span> <span class=\"kd\">extends</span> <span class=\"n\">SuperClass</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>在调用一个方法时，先从本类中查找看是否有对应的方法，如果没有查找到再到父类中查看，看是否有继承来的方法。否则就要对参数进行转型，转成父类之后看是否有对应的方法。总的来说，方法调用的优先级为：</p><ul><li>this.func(this)</li><li>super.func(this)</li><li>this.func(super)</li><li>super.func(super)</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/*\n</span><span class=\"cm\">    A\n</span><span class=\"cm\">    |\n</span><span class=\"cm\">    B\n</span><span class=\"cm\">    |\n</span><span class=\"cm\">    C\n</span><span class=\"cm\">    |\n</span><span class=\"cm\">    D\n</span><span class=\"cm\"> */</span>\n\n\n<span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;A.show(A)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">C</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;A.show(C)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">B</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;B.show(A)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">C</span> <span class=\"kd\">extends</span> <span class=\"n\">B</span> <span class=\"o\">{</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span> <span class=\"o\">{</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n    <span class=\"n\">B</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n    <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">C</span><span class=\"o\">();</span>\n    <span class=\"n\">D</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">D</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// 在 A 中存在 show(A obj)，直接调用\n</span><span class=\"c1\"></span>    <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(A)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在 A 中不存在 show(B obj)，将 B 转型成其父类 A\n</span><span class=\"c1\"></span>    <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(A)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在 B 中存在从 A 继承来的 show(C obj)，直接调用\n</span><span class=\"c1\"></span>    <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(C)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在 B 中不存在 show(D obj)，但是存在从 A 继承来的 show(C obj)，将 D 转型成其父类 C\n</span><span class=\"c1\"></span>    <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(C)\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 引用的还是 B 对象，所以 ba 和 b 的调用结果一样\n</span><span class=\"c1\"></span>    <span class=\"n\">A</span> <span class=\"n\">ba</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n    <span class=\"n\">ba</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(C)\n</span><span class=\"c1\"></span>    <span class=\"n\">ba</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">);</span> <span class=\"c1\">// A.show(C)\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p><b>2. 重载（Overload）</b> </p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><h2>五、Object 通用方法</h2><h2>概览</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">native</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">equals</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">obj</span><span class=\"o\">)</span>\n\n<span class=\"kd\">protected</span> <span class=\"kd\">native</span> <span class=\"n\">Object</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">getClass</span><span class=\"o\">()</span>\n\n<span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">finalize</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Throwable</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">notify</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">notifyAll</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">nanos</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span></code></pre></div><h2>equals()</h2><p><b>1. 等价关系</b> </p><p>Ⅰ 自反性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅱ 对称性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅲ 传递性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">))</span>\n    <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span><span class=\"o\">;</span></code></pre></div><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">false</span><span class=\"o\">;</span></code></pre></div><p><b>2. 等价与相等</b> </p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">));</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">);</span>      <span class=\"o\">//</span> <span class=\"kc\">false</span></code></pre></div><p><b>3. 实现</b> </p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">EqualExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">EqualExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">z</span> <span class=\"o\">=</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">equals</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span> <span class=\"o\">==</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">getClass</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">o</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">())</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n        <span class=\"n\">EqualExample</span> <span class=\"n\">that</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">EqualExample</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">;</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">!=</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">!=</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">y</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">EqualExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EqualExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">EqualExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EqualExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">));</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"n\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">EqualExample</span><span class=\"o\">&gt;</span> <span class=\"n\">set</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">);</span>\n<span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">());</span>   <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">17</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ToStringExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ToStringExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">number</span> <span class=\"o\">=</span> <span class=\"n\">number</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">ToStringExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ToStringExample</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">());</span>\n<span class=\"n\">ToStringExample</span><span class=\"nd\">@4554617c</span></code></pre></div><h2>clone()</h2><p><b>1. cloneable</b> </p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneExample</span><span class=\"o\">();</span>\n<span class=\"o\">//</span> <span class=\"n\">CloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span> <span class=\"o\">//</span> <span class=\"err\">&#39;</span><span class=\"n\">clone</span><span class=\"o\">()</span><span class=\"err\">&#39;</span> <span class=\"n\">has</span> <span class=\"kd\">protected</span> <span class=\"n\">access</span> <span class=\"n\">in</span> <span class=\"err\">&#39;</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Object</span><span class=\"err\">&#39;</span></code></pre></div><p>重写 clone() 得到以下实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">CloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">CloneExample</span><span class=\"o\">)</span><span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneExample</span><span class=\"o\">();</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">CloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">CloneNotSupportedException</span><span class=\"o\">:</span> <span class=\"n\">CloneExample</span></code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>2. 浅拷贝</b> </p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ShallowCloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ShallowCloneExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">ShallowCloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">ShallowCloneExample</span><span class=\"o\">)</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">ShallowCloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ShallowCloneExample</span><span class=\"o\">();</span>\n<span class=\"n\">ShallowCloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">222</span></code></pre></div><p><b>3. 深拷贝</b> </p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeepCloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">DeepCloneExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">DeepCloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">DeepCloneExample</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">DeepCloneExample</span><span class=\"o\">)</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n        <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">DeepCloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">DeepCloneExample</span><span class=\"o\">();</span>\n<span class=\"n\">DeepCloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><p><b>4. clone() 的替代方案</b> </p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneConstructorExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">CloneConstructorExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">CloneConstructorExample</span><span class=\"o\">(</span><span class=\"n\">CloneConstructorExample</span> <span class=\"n\">original</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneConstructorExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneConstructorExample</span><span class=\"o\">();</span>\n<span class=\"n\">CloneConstructorExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneConstructorExample</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">);</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><h2>六、关键字</h2><h2>final</h2><p><b>1. 数据</b> </p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"c1\">// x = 2;  // cannot assign value to final variable &#39;x&#39;\n</span><span class=\"c1\"></span><span class=\"kd\">final</span> <span class=\"n\">A</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n<span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">a</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p><b>2. 方法</b> </p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><b>3. 类</b> </p><p>声明类不允许被继承。</p><h2>static</h2><p><b>1. 静态变量</b> </p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>         <span class=\"c1\">// 实例变量\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>  <span class=\"c1\">// 静态变量\n</span><span class=\"c1\"></span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>2. 静态方法</b> </p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">(){</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">(){</span>\n        <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"c1\">// int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"c1\">// int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>3. 静态语句块</b> </p><p>静态语句块在类初始化时运行一次。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;123&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"n\">A</span> <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">123</span></code></pre></div><p><b>4. 静态内部类</b> </p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">OuterClass</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">class</span> <span class=\"nc\">InnerClass</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">StaticInnerClass</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"n\">OuterClass</span> <span class=\"n\">outerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">OuterClass</span><span class=\"o\">();</span>\n        <span class=\"n\">InnerClass</span> <span class=\"n\">innerClass</span> <span class=\"o\">=</span> <span class=\"n\">outerClass</span><span class=\"o\">.</span><span class=\"na\">new</span> <span class=\"nf\">InnerClass</span><span class=\"o\">();</span>\n        <span class=\"n\">StaticInnerClass</span> <span class=\"n\">staticInnerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StaticInnerClass</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><b>5. 静态导包</b> </p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">import static</span> <span class=\"nn\">com.xxx.ClassName.*</span></code></pre></div><p><b>6. 初始化顺序</b> </p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"n\">staticField</span> <span class=\"o\">=</span> <span class=\"s\">&#34;静态变量&#34;</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;静态语句块&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"n\">field</span> <span class=\"o\">=</span> <span class=\"s\">&#34;实例变量&#34;</span><span class=\"o\">;</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;普通语句块&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>最后才是构造函数的初始化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">InitialOrderTest</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;构造函数&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2>七、反射</h2><p>每个类都有一个  <b>Class</b>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&#34;com.mysql.jdbc.Driver&#34;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><b>Field</b> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><b>Method</b> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><b>Constructor</b> ：可以用 Constructor 创建新的对象。</li></ul><p><b>反射的优点：</b> </p><ul><li><b>可扩展性</b>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><b>类浏览器和可视化开发环境</b>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><b>调试器和测试工具</b>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><b>反射的缺点：</b> </p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><b>性能开销</b>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。<br/> </li><li><b>安全限制</b>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。<br/> </li><li><b>内部暴露</b>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/reflect/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Trail: The Reflection API</a><br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.sczyh30.com/posts/Java/java-reflection-1/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入解析 Java 反射（1）- 基础</a></li></ul><h2>八、异常</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <b>Error</b>  和 <b>Exception</b>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><b>受检异常</b> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li><li><b>非受检异常</b> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-118d84b4bc7e732e5592961c122c25da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2272\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic3.zhimg.com/v2-118d84b4bc7e732e5592961c122c25da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;2272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic3.zhimg.com/v2-118d84b4bc7e732e5592961c122c25da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-118d84b4bc7e732e5592961c122c25da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.tianmaying.com/tutorial/Java-Exception\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 入门之异常处理</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/7383.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 异常的面试问题及答案 -Part 1</a></li></ul><h2>九、泛型</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// T stands for &#34;Type&#34;\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">T</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">t</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">T</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span> <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/24029.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 泛型详解</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1033693\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">10 道 Java 泛型面试题</a></li></ul><h2>十、注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/acm-bingzi/p/javaAnnotation.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">注解 Annotation 实现原理与自定义注解例子</a></p><h2>十一、特性</h2><h2>Java 各版本的新特性</h2><p><b>New highlights in Java SE 8</b> </p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><b>New highlights in Java SE 7</b> </p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li> Diamond Syntax<br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.selfgrowth.com/articles/difference-between-java-18-and-java-17\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Difference between Java 1.8 and Java 1.7?</a><br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/19345.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 8 特性</a></li></ol><h2>Java 与 C++ 的区别</h2><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li><li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li></ul><p><a href=\"https://link.zhihu.com/?target=http%3A//cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What are the main differences between Java and C++?</a></p><h2>JRE or JDK</h2><ul><li>JRE is the JVM program, Java application need to run on JRE.</li><li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &#34;javac&#34;</li></ul><h2>参考资料</h2><ul><li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;868&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59850978", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 5, 
            "title": "Java 容器", 
            "content": "<p>一、概览</p><p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p><h2>Collection</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6d9ce14cd2c30bd6e9f9eacb2c4b8960_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1065\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb\" width=\"1065\" data-original=\"https://pic1.zhimg.com/v2-6d9ce14cd2c30bd6e9f9eacb2c4b8960_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1065&#39; height=&#39;559&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1065\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1065\" data-original=\"https://pic1.zhimg.com/v2-6d9ce14cd2c30bd6e9f9eacb2c4b8960_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6d9ce14cd2c30bd6e9f9eacb2c4b8960_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>1. Set</h3><ul><li> TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。<br/> </li><li> HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。<br/> </li><li> LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。<br/> </li></ul><h3>2. List</h3><ul><li> ArrayList：基于动态数组实现，支持随机访问。<br/> </li><li> Vector：和 ArrayList 类似，但它是线程安全的。<br/> </li><li> LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。<br/> </li></ul><h3>3. Queue</h3><ul><li> LinkedList：可以用它来实现双向队列。<br/> </li><li> PriorityQueue：基于堆结构实现，可以用它来实现优先队列。<br/> </li></ul><h2>Map</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ea9e21c672612414526ef1dea07b24e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic1.zhimg.com/v2-ea9e21c672612414526ef1dea07b24e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic1.zhimg.com/v2-ea9e21c672612414526ef1dea07b24e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ea9e21c672612414526ef1dea07b24e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li> TreeMap：基于红黑树实现。<br/> </li><li> HashMap：基于哈希表实现。<br/> </li><li> HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。<br/> </li><li> LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。<br/> </li></ul><h2>二、容器中的设计模式</h2><h2>迭代器模式</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7b03112dd4dd4d990a3f0c94434a8b89_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb\" width=\"855\" data-original=\"https://pic2.zhimg.com/v2-7b03112dd4dd4d990a3f0c94434a8b89_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;855&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"855\" data-original=\"https://pic2.zhimg.com/v2-7b03112dd4dd4d990a3f0c94434a8b89_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7b03112dd4dd4d990a3f0c94434a8b89_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p><p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;a&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;b&#34;</span><span class=\"o\">);</span>\n<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">item</span> <span class=\"o\">:</span> <span class=\"n\">list</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">item</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>适配器模式</h2><p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@SafeVarargs</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"nf\">asList</span><span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">...</span> <span class=\"n\">a</span><span class=\"o\">)</span></code></pre></div><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span><span class=\"o\">[]</span> <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">3</span><span class=\"o\">};</span>\n<span class=\"n\">List</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"o\">);</span></code></pre></div><p>也可以使用以下方式调用 asList()：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">List</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">3</span><span class=\"o\">);</span></code></pre></div><h2>三、源码分析</h2><p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p><p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p><h2>ArrayList</h2><h3>1. 概览</h3><p>因为 ArrayList 是基于数组实现的，所以支持快速随机访问。RandomAccess 接口标识着该类支持快速随机访问。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractList</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span>\n        <span class=\"kd\">implements</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;,</span> <span class=\"n\">RandomAccess</span><span class=\"o\">,</span> <span class=\"n\">Cloneable</span><span class=\"o\">,</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">Serializable</span></code></pre></div><p>数组的默认大小为 10。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">DEFAULT_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b6d1cffbc09eb43915ae57fbf7984319_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-b6d1cffbc09eb43915ae57fbf7984319_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;612&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-b6d1cffbc09eb43915ae57fbf7984319_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b6d1cffbc09eb43915ae57fbf7984319_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 扩容</h3><p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p><p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>  <span class=\"c1\">// Increments modCount!!\n</span><span class=\"c1\"></span>    <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">size</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">elementData</span> <span class=\"o\">==</span> <span class=\"n\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">minCapacity</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">DEFAULT_CAPACITY</span><span class=\"o\">,</span> <span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">ensureExplicitCapacity</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">ensureExplicitCapacity</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"c1\">// overflow-conscious code\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">minCapacity</span> <span class=\"o\">-</span> <span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">grow</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">grow</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// overflow-conscious code\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">oldCapacity</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">oldCapacity</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">oldCapacity</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newCapacity</span> <span class=\"o\">-</span> <span class=\"n\">minCapacity</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">minCapacity</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newCapacity</span> <span class=\"o\">-</span> <span class=\"n\">MAX_ARRAY_SIZE</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">hugeCapacity</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n    <span class=\"c1\">// minCapacity is usually close to size, so this is a win:\n</span><span class=\"c1\"></span>    <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOf</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">newCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h3>3. 删除元素</h3><p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">E</span> <span class=\"nf\">remove</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">rangeCheck</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"n\">E</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numMoved</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">index</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">numMoved</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">numMoved</span><span class=\"o\">);</span>\n    <span class=\"n\">elementData</span><span class=\"o\">[--</span><span class=\"n\">size</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"c1\">// clear to let GC do its work\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>4. Fail-Fast</h3><p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p><p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">writeObject</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">ObjectOutputStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">{</span>\n    <span class=\"c1\">// Write out element count, and any hidden stuff\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">expectedModCount</span> <span class=\"o\">=</span> <span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">defaultWriteObject</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// Write out size as capacity for behavioural compatibility with clone()\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeInt</span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">// Write out all elements in the proper order.\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">modCount</span> <span class=\"o\">!=</span> <span class=\"n\">expectedModCount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ConcurrentModificationException</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>5. 序列化</h3><p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p><p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">transient</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">elementData</span><span class=\"o\">;</span> <span class=\"o\">//</span> <span class=\"n\">non</span><span class=\"o\">-</span><span class=\"kd\">private</span> <span class=\"n\">to</span> <span class=\"n\">simplify</span> <span class=\"n\">nested</span> <span class=\"kd\">class</span> <span class=\"nc\">access</span></code></pre></div><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">readObject</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">ObjectInputStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">,</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n    <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">EMPTY_ELEMENTDATA</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// Read in size, and any hidden stuff\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">defaultReadObject</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// Read in capacity\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">readInt</span><span class=\"o\">();</span> <span class=\"c1\">// ignored\n</span><span class=\"c1\"></span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// be like clone(), allocate array based upon size not capacity\n</span><span class=\"c1\"></span>        <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n\n        <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">;</span>\n        <span class=\"c1\">// Read in all elements in the proper order.\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">readObject</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">writeObject</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">ObjectOutputStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">{</span>\n    <span class=\"c1\">// Write out element count, and any hidden stuff\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">expectedModCount</span> <span class=\"o\">=</span> <span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">defaultWriteObject</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// Write out size as capacity for behavioural compatibility with clone()\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeInt</span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">// Write out all elements in the proper order.\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">modCount</span> <span class=\"o\">!=</span> <span class=\"n\">expectedModCount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ConcurrentModificationException</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">ArrayList</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">();</span>\n<span class=\"n\">ObjectOutputStream</span> <span class=\"n\">oos</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjectOutputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"n\">file</span><span class=\"o\">));</span>\n<span class=\"n\">oos</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span></code></pre></div><h2>Vector</h2><h3>1. 同步</h3><p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">boolean</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"n\">ensureCapacityHelper</span><span class=\"o\">(</span><span class=\"n\">elementCount</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">elementCount</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"n\">E</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&gt;=</span> <span class=\"n\">elementCount</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ArrayIndexOutOfBoundsException</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">elementData</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h3>2. 与 ArrayList 的比较</h3><ul><li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li><li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li></ul><h3>3. 替代方案</h3><p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">synList</span> <span class=\"o\">=</span> <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">synchronizedList</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span></code></pre></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CopyOnWriteArrayList</span><span class=\"o\">&lt;&gt;();</span></code></pre></div><h2>CopyOnWriteArrayList</h2><h3>读写分离</h3><p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p><p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p><p>写操作结束之后需要把原始数组指向新的复制数组。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">;</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">elements</span> <span class=\"o\">=</span> <span class=\"n\">getArray</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">elements</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">newElements</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOf</span><span class=\"o\">(</span><span class=\"n\">elements</span><span class=\"o\">,</span> <span class=\"n\">len</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">newElements</span><span class=\"o\">[</span><span class=\"n\">len</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"n\">setArray</span><span class=\"o\">(</span><span class=\"n\">newElements</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">setArray</span><span class=\"o\">(</span><span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">array</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n<span class=\"kd\">private</span> <span class=\"n\">E</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">E</span><span class=\"o\">)</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n<span class=\"o\">}</span></code></pre></div><h3>适用场景</h3><p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p><p>但是 CopyOnWriteArrayList 有其缺陷：</p><ul><li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li><li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li></ul><p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p><h2>LinkedList</h2><h3>1. 概览</h3><p>基于双向链表实现，使用 Node 存储链表节点信息。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"n\">E</span> <span class=\"n\">item</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>每个链表存储了 first 和 last 指针：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">transient</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n<span class=\"kd\">transient</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">last</span><span class=\"o\">;</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-066561db014464cab0a6647a4e038cc6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic3.zhimg.com/v2-066561db014464cab0a6647a4e038cc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic3.zhimg.com/v2-066561db014464cab0a6647a4e038cc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-066561db014464cab0a6647a4e038cc6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 与 ArrayList 的比较</h3><ul><li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li><li>ArrayList 支持随机访问，LinkedList 不支持；</li><li>LinkedList 在任意位置添加删除元素更快。</li></ul><h2>HashMap</h2><p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p><h3>1. 存储结构</h3><p>内部包含了一个 Entry 类型的数组 table。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">transient</span> <span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">table</span><span class=\"o\">;</span></code></pre></div><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值和散列桶取模运算结果相同的 Entry。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b60c7f12c507f14e1120ec2c9399fb10_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"943\" data-rawheight=\"626\" class=\"origin_image zh-lightbox-thumb\" width=\"943\" data-original=\"https://pic1.zhimg.com/v2-b60c7f12c507f14e1120ec2c9399fb10_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;943&#39; height=&#39;626&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"943\" data-rawheight=\"626\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"943\" data-original=\"https://pic1.zhimg.com/v2-b60c7f12c507f14e1120ec2c9399fb10_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b60c7f12c507f14e1120ec2c9399fb10_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n    <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">;</span>\n\n    <span class=\"n\">Entry</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n        <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n        <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n        <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">K</span> <span class=\"nf\">getKey</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">getValue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">setValue</span><span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">newValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">V</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">newValue</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">equals</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(!(</span><span class=\"n\">o</span> <span class=\"k\">instanceof</span> <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">))</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">)</span><span class=\"n\">o</span><span class=\"o\">;</span>\n        <span class=\"n\">Object</span> <span class=\"n\">k1</span> <span class=\"o\">=</span> <span class=\"n\">getKey</span><span class=\"o\">();</span>\n        <span class=\"n\">Object</span> <span class=\"n\">k2</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getKey</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">k1</span> <span class=\"o\">==</span> <span class=\"n\">k2</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">k1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">k1</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k2</span><span class=\"o\">)))</span> <span class=\"o\">{</span>\n            <span class=\"n\">Object</span> <span class=\"n\">v1</span> <span class=\"o\">=</span> <span class=\"n\">getValue</span><span class=\"o\">();</span>\n            <span class=\"n\">Object</span> <span class=\"n\">v2</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">getValue</span><span class=\"o\">();</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"o\">==</span> <span class=\"n\">v2</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">v1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">v1</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">v2</span><span class=\"o\">)))</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">Objects</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">(</span><span class=\"n\">getKey</span><span class=\"o\">())</span> <span class=\"o\">^</span> <span class=\"n\">Objects</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">(</span><span class=\"n\">getValue</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">getKey</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34;=&#34;</span> <span class=\"o\">+</span> <span class=\"n\">getValue</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>2. 拉链法的工作原理</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&#34;K1&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;V1&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&#34;K2&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;V2&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&#34;K3&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;V3&#34;</span><span class=\"o\">);</span></code></pre></div><ul><li>新建一个 HashMap，默认大小为 16；</li><li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li><li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li><li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li></ul><p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p><p>查找需要分成两步进行：</p><ul><li>计算键值对所在的桶；</li><li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d5318e01448321e5217d2fac19da8275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"948\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb\" width=\"948\" data-original=\"https://pic2.zhimg.com/v2-d5318e01448321e5217d2fac19da8275_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;948&#39; height=&#39;516&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"948\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"948\" data-original=\"https://pic2.zhimg.com/v2-d5318e01448321e5217d2fac19da8275_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d5318e01448321e5217d2fac19da8275_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. put 操作</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">table</span> <span class=\"o\">==</span> <span class=\"n\">EMPTY_TABLE</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">inflateTable</span><span class=\"o\">(</span><span class=\"n\">threshold</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 键为 null 单独处理\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">putForNullKey</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 确定桶下标\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">indexFor</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">table</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span> <span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Object</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">)))</span> <span class=\"o\">{</span>\n            <span class=\"n\">V</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">recordAccess</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"c1\">// 插入新键值对\n</span><span class=\"c1\"></span>    <span class=\"n\">addEntry</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">V</span> <span class=\"nf\">putForNullKey</span><span class=\"o\">(</span><span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span> <span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">V</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">recordAccess</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"n\">addEntry</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">addEntry</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">bucketIndex</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">size</span> <span class=\"o\">&gt;=</span> <span class=\"n\">threshold</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"kc\">null</span> <span class=\"o\">!=</span> <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">bucketIndex</span><span class=\"o\">]))</span> <span class=\"o\">{</span>\n        <span class=\"n\">resize</span><span class=\"o\">(</span><span class=\"n\">2</span> <span class=\"o\">*</span> <span class=\"n\">table</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n        <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kc\">null</span> <span class=\"o\">!=</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">:</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">bucketIndex</span> <span class=\"o\">=</span> <span class=\"n\">indexFor</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">table</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">createEntry</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">bucketIndex</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">createEntry</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">bucketIndex</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">bucketIndex</span><span class=\"o\">];</span>\n    <span class=\"c1\">// 头插法，链表头部指向新的键值对\n</span><span class=\"c1\"></span>    <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">bucketIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Entry</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>\n    <span class=\"n\">size</span><span class=\"o\">++;</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Entry</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">,</span> <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n    <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n    <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n    <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>4. 确定桶下标</h3><p>很多操作都需要先确定一个键值对所在的桶下标。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n<span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">indexFor</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">table</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span></code></pre></div><p><b>4.1 计算 hash 值</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">hash</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">hashSeed</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">0</span> <span class=\"o\">!=</span> <span class=\"n\">h</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">k</span> <span class=\"k\">instanceof</span> <span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">misc</span><span class=\"o\">.</span><span class=\"na\">Hashing</span><span class=\"o\">.</span><span class=\"na\">stringHash32</span><span class=\"o\">((</span><span class=\"n\">String</span><span class=\"o\">)</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">h</span> <span class=\"o\">^=</span> <span class=\"n\">k</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// This function ensures that hashCodes that differ only by\n</span><span class=\"c1\"></span>    <span class=\"c1\">// constant multiples at each bit position have a bounded\n</span><span class=\"c1\"></span>    <span class=\"c1\">// number of collisions (approximately 8 at default load factor).\n</span><span class=\"c1\"></span>    <span class=\"n\">h</span> <span class=\"o\">^=</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">20</span><span class=\"o\">)</span> <span class=\"o\">^</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">12</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">h</span> <span class=\"o\">^</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">7</span><span class=\"o\">)</span> <span class=\"o\">^</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">4</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">Objects</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">^</span> <span class=\"n\">Objects</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p><b>4.2 取模</b> </p><p>令 x = 1&lt;&lt;4，即 x 为 2 的 4 次方，它具有以下性质：</p><div class=\"highlight\"><pre><code class=\"language-text\">x   : 00010000\nx-1 : 00001111</code></pre></div><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p><div class=\"highlight\"><pre><code class=\"language-text\">y       : 10110010\nx-1     : 00001111\ny&amp;(x-1) : 00000010</code></pre></div><p>这个性质和 y 对 x 取模效果是一样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">y   : 10110010\nx   : 00010000\ny%x : 00000010</code></pre></div><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p><p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">indexFor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">h</span> <span class=\"o\">&amp;</span> <span class=\"o\">(</span><span class=\"n\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h3>5. 扩容-基本原理</h3><p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p><p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p><p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p><p>| 参数 | 含义 | | :--: | :-- | | capacity | table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。| | size | 键值对数量。 | | threshold | size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 | | loadFactor | 装载因子，table 能够使用的比例，threshold = capacity * loadFactor。|</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">DEFAULT_INITIAL_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">16</span><span class=\"o\">;</span>\n\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">30</span><span class=\"o\">;</span>\n\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">float</span> <span class=\"n\">DEFAULT_LOAD_FACTOR</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">75f</span><span class=\"o\">;</span>\n\n<span class=\"kd\">transient</span> <span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n\n<span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n\n<span class=\"kd\">final</span> <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">;</span>\n\n<span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">modCount</span><span class=\"o\">;</span></code></pre></div><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">addEntry</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">bucketIndex</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">bucketIndex</span><span class=\"o\">];</span>\n    <span class=\"n\">table</span><span class=\"o\">[</span><span class=\"n\">bucketIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Entry</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">++</span> <span class=\"o\">&gt;=</span> <span class=\"n\">threshold</span><span class=\"o\">)</span>\n        <span class=\"n\">resize</span><span class=\"o\">(</span><span class=\"n\">2</span> <span class=\"o\">*</span> <span class=\"n\">table</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">resize</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">newCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">oldTable</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">oldCapacity</span> <span class=\"o\">=</span> <span class=\"n\">oldTable</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">oldCapacity</span> <span class=\"o\">==</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">newTable</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Entry</span><span class=\"o\">[</span><span class=\"n\">newCapacity</span><span class=\"o\">];</span>\n    <span class=\"n\">transfer</span><span class=\"o\">(</span><span class=\"n\">newTable</span><span class=\"o\">);</span>\n    <span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"n\">newTable</span><span class=\"o\">;</span>\n    <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)(</span><span class=\"n\">newCapacity</span> <span class=\"o\">*</span> <span class=\"n\">loadFactor</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">transfer</span><span class=\"o\">(</span><span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">newTable</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Entry</span><span class=\"o\">[]</span> <span class=\"n\">src</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">newTable</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">src</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">src</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">src</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n            <span class=\"k\">do</span> <span class=\"o\">{</span>\n                <span class=\"n\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n                <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">indexFor</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span><span class=\"o\">,</span> <span class=\"n\">newCapacity</span><span class=\"o\">);</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">newTable</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n                <span class=\"n\">newTable</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>6. 扩容-重新计算桶下标</h3><p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p><p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p><div class=\"highlight\"><pre><code class=\"language-html\">capacity     : 00010000\nnew capacity : 00100000</code></pre></div><p>对于一个 Key，</p><ul><li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li><li>如果为 1，那么得到的结果为原来的结果 +16。</li></ul><h3>7. 计算数组容量</h3><p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p><p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p><div class=\"highlight\"><pre><code class=\"language-text\">mask |= mask &gt;&gt; 1    11011000\nmask |= mask &gt;&gt; 2    11111110\nmask |= mask &gt;&gt; 4    11111111</code></pre></div><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p><div class=\"highlight\"><pre><code class=\"language-text\">num     10010000\nmask+1 100000000</code></pre></div><p>以下是 HashMap 中计算数组容量的代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">tableSizeFor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">cap</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">cap</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">4</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">8</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">16</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;=</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>8. 链表转红黑树</h3><p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p><h3>9. 与 HashTable 的比较</h3><ul><li>HashTable 使用 synchronized 来进行同步。</li><li>HashMap 可以插入键为 null 的 Entry。</li><li>HashMap 的迭代器是 fail-fast 迭代器。</li><li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li></ul><h2>ConcurrentHashMap</h2><h3>1. 存储结构</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">HashEntry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">;</span>\n    <span class=\"kd\">final</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n    <span class=\"kd\">volatile</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"kd\">volatile</span> <span class=\"n\">HashEntry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p><p>Segment 继承自 ReentrantLock。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">Segment</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">ReentrantLock</span> <span class=\"kd\">implements</span> <span class=\"n\">Serializable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"n\">serialVersionUID</span> <span class=\"o\">=</span> <span class=\"n\">2249069246763182397L</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAX_SCAN_RETRIES</span> <span class=\"o\">=</span>\n        <span class=\"n\">Runtime</span><span class=\"o\">.</span><span class=\"na\">getRuntime</span><span class=\"o\">().</span><span class=\"na\">availableProcessors</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">1</span> <span class=\"o\">?</span> <span class=\"n\">64</span> <span class=\"o\">:</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">transient</span> <span class=\"kd\">volatile</span> <span class=\"n\">HashEntry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">modCount</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">final</span> <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">final</span> <span class=\"n\">Segment</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">segments</span><span class=\"o\">;</span></code></pre></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">DEFAULT_CONCURRENCY_LEVEL</span> <span class=\"o\">=</span> <span class=\"n\">16</span><span class=\"o\">;</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d39174ecc7c6cc862bc9ff177d26f91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"994\" data-rawheight=\"608\" class=\"origin_image zh-lightbox-thumb\" width=\"994\" data-original=\"https://pic2.zhimg.com/v2-4d39174ecc7c6cc862bc9ff177d26f91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;994&#39; height=&#39;608&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"994\" data-rawheight=\"608\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"994\" data-original=\"https://pic2.zhimg.com/v2-4d39174ecc7c6cc862bc9ff177d26f91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d39174ecc7c6cc862bc9ff177d26f91_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. size 操作</h3><p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * The number of elements. Accessed only either within locks\n</span><span class=\"cm\"> * or among other volatile reads that maintain visibility.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span></code></pre></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p><p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p><p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p><p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * Number of unsynchronized retries in size and containsValue\n</span><span class=\"cm\"> * methods before resorting to locking. This is used to avoid\n</span><span class=\"cm\"> * unbounded retries if tables undergo continuous modification\n</span><span class=\"cm\"> * which would make it impossible to obtain an accurate result.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">RETRIES_BEFORE_LOCK</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">size</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// Try a few times to get accurate count. On failure due to\n</span><span class=\"c1\"></span>    <span class=\"c1\">// continuous async changes in table, resort to locking.\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"n\">Segment</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">segments</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">segments</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n    <span class=\"kt\">boolean</span> <span class=\"n\">overflow</span><span class=\"o\">;</span> <span class=\"c1\">// true if size overflows 32 bits\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"n\">sum</span><span class=\"o\">;</span>         <span class=\"c1\">// sum of modCounts\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">0L</span><span class=\"o\">;</span>   <span class=\"c1\">// previous sum\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">retries</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// first iteration isn&#39;t retry\n</span><span class=\"c1\"></span>    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(;;)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 超过尝试次数，则对每个 Segment 加锁\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">retries</span><span class=\"o\">++</span> <span class=\"o\">==</span> <span class=\"n\">RETRIES_BEFORE_LOCK</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">segments</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span>\n                    <span class=\"n\">ensureSegment</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">).</span><span class=\"na\">lock</span><span class=\"o\">();</span> <span class=\"c1\">// force creation\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n            <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">0L</span><span class=\"o\">;</span>\n            <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n            <span class=\"n\">overflow</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">segments</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">Segment</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">seg</span> <span class=\"o\">=</span> <span class=\"n\">segmentAt</span><span class=\"o\">(</span><span class=\"n\">segments</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">seg</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">seg</span><span class=\"o\">.</span><span class=\"na\">modCount</span><span class=\"o\">;</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">seg</span><span class=\"o\">.</span><span class=\"na\">count</span><span class=\"o\">;</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+=</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n                        <span class=\"n\">overflow</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n            <span class=\"c1\">// 连续两次得到的结果一致，则认为这个结果是正确的\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">last</span><span class=\"o\">)</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">sum</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">retries</span> <span class=\"o\">&gt;</span> <span class=\"n\">RETRIES_BEFORE_LOCK</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">segments</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span>\n                <span class=\"n\">segmentAt</span><span class=\"o\">(</span><span class=\"n\">segments</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">).</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">overflow</span> <span class=\"o\">?</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span> <span class=\"o\">:</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>3. JDK 1.8 的改动</h3><p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p><p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p><p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p><h2>LinkedHashMap</h2><h3>存储结构</h3><p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LinkedHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span></code></pre></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * The head (eldest) of the doubly linked list.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * The tail (youngest) of the doubly linked list.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">tail</span><span class=\"o\">;</span></code></pre></div><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"n\">accessOrder</span><span class=\"o\">;</span></code></pre></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"o\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">afterNodeInsertion</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">evict</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"o\">}</span></code></pre></div><h3>afterNodeAccess()</h3><p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// move node to last\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">accessOrder</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span>\n            <span class=\"o\">(</span><span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">;</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n            <span class=\"n\">last</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"o\">++</span><span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>afterNodeInsertion()</h3><p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p><p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">afterNodeInsertion</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">evict</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// possibly remove eldest\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">evict</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"n\">K</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">;</span>\n        <span class=\"n\">removeNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">eldest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>LRU 缓存</h3><p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p><ul><li>设定最大缓存空间 MAX_ENTRIES  为 3；</li><li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li><li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">LRUCache</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAX_ENTRIES</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span> <span class=\"n\">eldest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">MAX_ENTRIES</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">LRUCache</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">MAX_ENTRIES</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">75f</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">LRUCache</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">cache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LRUCache</span><span class=\"o\">&lt;&gt;();</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"s\">&#34;a&#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"s\">&#34;b&#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"s\">&#34;c&#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">4</span><span class=\"o\">,</span> <span class=\"s\">&#34;d&#34;</span><span class=\"o\">);</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">keySet</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"o\">[</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">4</span><span class=\"o\">]</span></code></pre></div><h2>WeakHashMap</h2><h3>存储结构</h3><p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p><p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">WeakReference</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span></code></pre></div><h3>ConcurrentCache</h3><p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p><p>ConcurrentCache 采取的是分代缓存：</p><ul><li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li><li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li><li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li><li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">ConcurrentCache</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">eden</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">longterm</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ConcurrentCache</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">size</span> <span class=\"o\">=</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ConcurrentHashMap</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">longterm</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">WeakHashMap</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">V</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">longterm</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;=</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">longterm</span><span class=\"o\">.</span><span class=\"na\">putAll</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">);</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">.</span><span class=\"na\">clear</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">eden</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">,</span> <span class=\"n\">v</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>参考资料</h2><ul><li>Eckel B. Java 编程思想 [M]. 机械工业出版社, 2002.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.w3resource.com/java-tutorial/java-collections.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java Collection Framework</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//openhome.cc/Gossip/DesignPattern/IteratorPattern.htm\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Iterator 模式</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/java_hashmap.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 8 系列之重新认识 HashMap</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//javarevisited.blogspot.hk/2010/10/difference-between-hashmap-and.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is difference between HashMap and Hashtable in Java?</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.zhangchangle.com/2018/02/07/Java%25E9%259B%2586%25E5%2590%2588%25E4%25B9%258BHashMap/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 集合之 HashMap</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.programering.com/a/MDO3QDNwATM.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The principle of ConcurrentHashMap analysis</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/java-lo-concurrenthashmap/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">探索 ConcurrentHashMap 高并发性的实现机制</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/75adf47958a7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HashMap 相关面试题及其解答</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//wiki.jikexueyuan.com/project/java-enhancement/java-thirtysix.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 集合细节（二）：asList 的缺陷</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//javaconceptoftheday.com/java-collection-framework-linkedlist-class/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java Collection Framework – The LinkedList Class</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;868&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"868\" data-original=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0cc31b487492e9104150995ef37f51ba_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59850678", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "Java 并发", 
            "content": "<p></p><h2>一、线程状态转换</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-92bfc3cfc5d103d5a97daf2815f960cc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"955\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb\" width=\"955\" data-original=\"https://pic1.zhimg.com/v2-92bfc3cfc5d103d5a97daf2815f960cc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;955&#39; height=&#39;540&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"955\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"955\" data-original=\"https://pic1.zhimg.com/v2-92bfc3cfc5d103d5a97daf2815f960cc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-92bfc3cfc5d103d5a97daf2815f960cc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>新建（New）</h2><p>创建后尚未启动。</p><h2>可运行（Runnable）</h2><p>可能正在运行，也可能正在等待 CPU 时间片。</p><p>包含了操作系统线程状态中的 Running 和 Ready。</p><h2>阻塞（Blocked）</h2><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p><h2>无限期等待（Waiting）</h2><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p><p>| 进入方法 | 退出方法 | | --- | --- | | 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() | | 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕 | | LockSupport.park() 方法 | LockSupport.unpark(Thread) |</p><h2>限期等待（Timed Waiting）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p><p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p><p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p><p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p><p>| 进入方法 | 退出方法 | | --- | --- | | Thread.sleep() 方法 | 时间结束 | | 设置了 Timeout 参数的 Object.wait() 方法 | 时间结束 / Object.notify() / Object.notifyAll()  | | 设置了 Timeout 参数的 Thread.join() 方法 | 时间结束 / 被调用的线程执行完毕 | | LockSupport.parkNanos() 方法 | LockSupport.unpark(Thread) | | LockSupport.parkUntil() 方法 | LockSupport.unpark(Thread) |</p><h2>死亡（Terminated）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p><h2>二、使用线程</h2><p>有三种使用线程的方法：</p><ul><li>实现 Runnable 接口；</li><li>实现 Callable 接口；</li><li>继承 Thread 类。</li></ul><p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p><h2>实现 Runnable 接口</h2><p>需要实现 run() 方法。</p><p>通过 Thread 调用 start() 方法来启动线程。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyRunnable</span> <span class=\"kd\">implements</span> <span class=\"n\">Runnable</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">MyRunnable</span> <span class=\"n\">instance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyRunnable</span><span class=\"o\">();</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">instance</span><span class=\"o\">);</span>\n    <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyCallable</span> <span class=\"kd\">implements</span> <span class=\"n\">Callable</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Integer</span> <span class=\"nf\">call</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ExecutionException</span><span class=\"o\">,</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"n\">MyCallable</span> <span class=\"n\">mc</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyCallable</span><span class=\"o\">();</span>\n    <span class=\"n\">FutureTask</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">ft</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FutureTask</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">mc</span><span class=\"o\">);</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">ft</span><span class=\"o\">);</span>\n    <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">ft</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n<span class=\"o\">}</span></code></pre></div><h2>继承 Thread 类</h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p><p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MyThread</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">MyThread</span> <span class=\"n\">mt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyThread</span><span class=\"o\">();</span>\n    <span class=\"n\">mt</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p><ul><li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li><li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li></ul><h2>三、基础线程机制</h2><h2>Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p><p>主要有三种 Executor：</p><ul><li>CachedThreadPool：一个任务创建一个线程；</li><li>FixedThreadPool：所有任务只能使用固定大小的线程；</li><li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">5</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">MyRunnable</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p><p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>main() 属于非守护线程。</p><p>使用 setDaemon() 方法将一个线程设置为守护线程。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">MyRunnable</span><span class=\"o\">());</span>\n    <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">setDaemon</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p><p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">3000</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>yield()</h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">yield</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>四、中断</h2><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p><h2>InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">MyThread1</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">2000</span><span class=\"o\">);</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Thread run&#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">thread1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyThread1</span><span class=\"o\">();</span>\n    <span class=\"n\">thread1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"n\">thread1</span><span class=\"o\">.</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Main run&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Main</span> <span class=\"n\">run</span>\n<span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">InterruptedException</span><span class=\"o\">:</span> <span class=\"n\">sleep</span> <span class=\"n\">interrupted</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">Native</span> <span class=\"n\">Method</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">InterruptExample</span><span class=\"o\">.</span><span class=\"na\">lambda$main$0</span><span class=\"o\">(</span><span class=\"n\">InterruptExample</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">5</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">InterruptExample$$Lambda$1</span><span class=\"o\">/</span><span class=\"n\">713338599</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">Unknown</span> <span class=\"n\">Source</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Thread</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">745</span><span class=\"o\">)</span></code></pre></div><h2>interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterruptExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">MyThread2</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">interrupted</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// ..\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Thread end&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">thread2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyThread2</span><span class=\"o\">();</span>\n    <span class=\"n\">thread2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"n\">thread2</span><span class=\"o\">.</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Thread</span> <span class=\"n\">end</span></code></pre></div><h2>Executor 的中断操作</h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p><p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">2000</span><span class=\"o\">);</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Thread run&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">});</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdownNow</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Main run&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Main</span> <span class=\"n\">run</span>\n<span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">InterruptedException</span><span class=\"o\">:</span> <span class=\"n\">sleep</span> <span class=\"n\">interrupted</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">Native</span> <span class=\"n\">Method</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">ExecutorInterruptExample</span><span class=\"o\">.</span><span class=\"na\">lambda$main$0</span><span class=\"o\">(</span><span class=\"n\">ExecutorInterruptExample</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">9</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">ExecutorInterruptExample$$Lambda$1</span><span class=\"o\">/</span><span class=\"n\">1160460865</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">Unknown</span> <span class=\"n\">Source</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">concurrent</span><span class=\"o\">.</span><span class=\"na\">ThreadPoolExecutor</span><span class=\"o\">.</span><span class=\"na\">runWorker</span><span class=\"o\">(</span><span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">1142</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">concurrent</span><span class=\"o\">.</span><span class=\"na\">ThreadPoolExecutor$Worker</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">617</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Thread</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">745</span><span class=\"o\">)</span></code></pre></div><p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Future</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">future</span> <span class=\"o\">=</span> <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// ..\n</span><span class=\"c1\"></span><span class=\"o\">});</span>\n<span class=\"n\">future</span><span class=\"o\">.</span><span class=\"na\">cancel</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">);</span></code></pre></div><h2>五、互斥同步</h2><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p><h2>synchronized</h2><p><b>1. 同步一个代码块</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p><p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SynchronizedExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">SynchronizedExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span> <span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span></code></pre></div><p>对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">SynchronizedExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">SynchronizedExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">0</span> <span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">8</span> <span class=\"n\">9</span> <span class=\"n\">9</span></code></pre></div><p><b>2. 同步一个方法</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span> <span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p>它和同步代码块一样，作用于同一个对象。</p><p><b>3. 同步一个类</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">SynchronizedExample</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SynchronizedExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func2</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">SynchronizedExample</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">SynchronizedExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">SynchronizedExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">func2</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">func2</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span> <span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span></code></pre></div><p><b>4. 同步一个静态方法</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">fun</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p>作用于整个类。</p><h2>ReentrantLock</h2><p>ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LockExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Lock</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span> <span class=\"c1\">// 确保释放锁，从而避免发生死锁。\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">LockExample</span> <span class=\"n\">lockExample</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LockExample</span><span class=\"o\">();</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">lockExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">lockExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span> <span class=\"n\">0</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">3</span> <span class=\"n\">4</span> <span class=\"n\">5</span> <span class=\"n\">6</span> <span class=\"n\">7</span> <span class=\"n\">8</span> <span class=\"n\">9</span></code></pre></div><h2>比较</h2><p><b>1. 锁的实现</b> </p><p>synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</p><p><b>2. 性能</b> </p><p>新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p><p><b>3. 等待可中断</b> </p><p>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</p><p>ReentrantLock 可中断，而 synchronized 不行。</p><p><b>4. 公平锁</b> </p><p>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。</p><p>synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p><p><b>5. 锁绑定多个条件</b> </p><p>一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p><h2>使用选择</h2><p>除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</p><h2>六、线程之间的协作</h2><p>当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。</p><h2>join()</h2><p>在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><p>对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">JoinExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;A&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">B</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n\n        <span class=\"kd\">private</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n\n        <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;B&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">test</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"n\">B</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span>\n        <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">JoinExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">JoinExample</span><span class=\"o\">();</span>\n    <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">test</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">A</span>\n<span class=\"n\">B</span></code></pre></div><h2>wait() notify() notifyAll()</h2><p>调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。</p><p>它们都属于 Object 的一部分，而不属于 Thread。</p><p>只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。</p><p>使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">WaitNotifyExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">before</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;before&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">notifyAll</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">after</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">wait</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;after&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">WaitNotifyExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">WaitNotifyExample</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">before</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">before</span>\n<span class=\"n\">after</span></code></pre></div><p><b>wait() 和 sleep() 的区别</b> </p><ul><li>wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；</li><li>wait() 会释放锁，sleep() 不会。</li></ul><h2>await() signal() signalAll()</h2><p>java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p><p>使用 Lock 来获取一个 Condition 对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AwaitSignalExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Lock</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Condition</span> <span class=\"n\">condition</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">before</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;before&#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">signalAll</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">after</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;after&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">AwaitSignalExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AwaitSignalExample</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">before</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">before</span>\n<span class=\"n\">after</span></code></pre></div><h2>七、J.U.C - AQS</h2><p>java.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。</p><h2>CountDownLatch</h2><p>用来控制一个线程等待多个线程。</p><p>维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ef236042d2fa44caa3df65d19713f9a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"392\" class=\"content_image\" width=\"408\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;408&#39; height=&#39;392&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"392\" class=\"content_image lazy\" width=\"408\" data-actualsrc=\"https://pic3.zhimg.com/v2-ef236042d2fa44caa3df65d19713f9a2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CountdownLatchExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">totalThread</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n        <span class=\"n\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CountDownLatch</span><span class=\"o\">(</span><span class=\"n\">totalThread</span><span class=\"o\">);</span>\n        <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">totalThread</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;run..&#34;</span><span class=\"o\">);</span>\n                <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span>\n            <span class=\"o\">});</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;end&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">run</span><span class=\"o\">..</span><span class=\"na\">end</span></code></pre></div><h2>CyclicBarrier</h2><p>用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。</p><p>和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。</p><p>CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。</p><p>CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">CyclicBarrier</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">parties</span><span class=\"o\">,</span> <span class=\"n\">Runnable</span> <span class=\"n\">barrierAction</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">parties</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">();</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">parties</span> <span class=\"o\">=</span> <span class=\"n\">parties</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">count</span> <span class=\"o\">=</span> <span class=\"n\">parties</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">barrierCommand</span> <span class=\"o\">=</span> <span class=\"n\">barrierAction</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">CyclicBarrier</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">parties</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">parties</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7291e2662de3720310912a2780f06cf1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"441\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"441\" data-original=\"https://pic2.zhimg.com/v2-7291e2662de3720310912a2780f06cf1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;441&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"441\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"441\" data-original=\"https://pic2.zhimg.com/v2-7291e2662de3720310912a2780f06cf1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7291e2662de3720310912a2780f06cf1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CyclicBarrierExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">totalThread</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n        <span class=\"n\">CyclicBarrier</span> <span class=\"n\">cyclicBarrier</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CyclicBarrier</span><span class=\"o\">(</span><span class=\"n\">totalThread</span><span class=\"o\">);</span>\n        <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">totalThread</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;before..&#34;</span><span class=\"o\">);</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"n\">cyclicBarrier</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"o\">|</span> <span class=\"n\">BrokenBarrierException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;after..&#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">});</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">before</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span><span class=\"na\">after</span><span class=\"o\">..</span></code></pre></div><h2>Semaphore</h2><p>Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。</p><p>以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SemaphoreExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">clientCount</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">totalRequestCount</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n        <span class=\"n\">Semaphore</span> <span class=\"n\">semaphore</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Semaphore</span><span class=\"o\">(</span><span class=\"n\">clientCount</span><span class=\"o\">);</span>\n        <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">totalRequestCount</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()-&gt;{</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"n\">semaphore</span><span class=\"o\">.</span><span class=\"na\">acquire</span><span class=\"o\">();</span>\n                    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">semaphore</span><span class=\"o\">.</span><span class=\"na\">availablePermits</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                    <span class=\"n\">semaphore</span><span class=\"o\">.</span><span class=\"na\">release</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">});</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">2</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">2</span> <span class=\"n\">2</span> <span class=\"n\">2</span> <span class=\"n\">2</span> <span class=\"n\">1</span> <span class=\"n\">2</span> <span class=\"n\">2</span></code></pre></div><h2>八、J.U.C - 其它组件</h2><h2>FutureTask</h2><p>在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">FutureTask</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">implements</span> <span class=\"n\">RunnableFuture</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span>\n<span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">RunnableFuture</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"kd\">extends</span> <span class=\"n\">Runnable</span><span class=\"o\">,</span> <span class=\"n\">Future</span><span class=\"o\">&lt;</span><span class=\"n\">V</span><span class=\"o\">&gt;</span></code></pre></div><p>FutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">FutureTaskExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ExecutionException</span><span class=\"o\">,</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">FutureTask</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">futureTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FutureTask</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;(</span><span class=\"k\">new</span> <span class=\"n\">Callable</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;()</span> <span class=\"o\">{</span>\n            <span class=\"nd\">@Override</span>\n            <span class=\"kd\">public</span> <span class=\"n\">Integer</span> <span class=\"nf\">call</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">100</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">);</span>\n                    <span class=\"n\">result</span> <span class=\"o\">+=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">computeThread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">futureTask</span><span class=\"o\">);</span>\n        <span class=\"n\">computeThread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">otherThread</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;other task is running...&#34;</span><span class=\"o\">);</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">1000</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">otherThread</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">futureTask</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">other</span> <span class=\"n\">task</span> <span class=\"n\">is</span> <span class=\"n\">running</span><span class=\"o\">...</span>\n<span class=\"n\">4950</span></code></pre></div><h2>BlockingQueue</h2><p>java.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现：</p><ul><li><b>FIFO 队列</b> ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）</li><li><b>优先级队列</b> ：PriorityBlockingQueue</li></ul><p>提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。</p><p><b>使用 BlockingQueue 实现生产者消费者问题</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ProducerConsumer</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">BlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayBlockingQueue</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">5</span><span class=\"o\">);</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Producer</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&#34;product&#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;produce..&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Consumer</span> <span class=\"kd\">extends</span> <span class=\"n\">Thread</span> <span class=\"o\">{</span>\n\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">String</span> <span class=\"n\">product</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">take</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;consume..&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">2</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Producer</span> <span class=\"n\">producer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Producer</span><span class=\"o\">();</span>\n        <span class=\"n\">producer</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">5</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Consumer</span> <span class=\"n\">consumer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Consumer</span><span class=\"o\">();</span>\n        <span class=\"n\">consumer</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">3</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Producer</span> <span class=\"n\">producer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Producer</span><span class=\"o\">();</span>\n        <span class=\"n\">producer</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">produce</span><span class=\"o\">..</span><span class=\"na\">produce</span><span class=\"o\">..</span><span class=\"na\">consume</span><span class=\"o\">..</span><span class=\"na\">consume</span><span class=\"o\">..</span><span class=\"na\">produce</span><span class=\"o\">..</span><span class=\"na\">consume</span><span class=\"o\">..</span><span class=\"na\">produce</span><span class=\"o\">..</span><span class=\"na\">consume</span><span class=\"o\">..</span><span class=\"na\">produce</span><span class=\"o\">..</span><span class=\"na\">consume</span><span class=\"o\">..</span></code></pre></div><h2>ForkJoin</h2><p>主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ForkJoinExample</span> <span class=\"kd\">extends</span> <span class=\"n\">RecursiveTask</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">5</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ForkJoinExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">first</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">last</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">first</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">last</span> <span class=\"o\">=</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">Integer</span> <span class=\"nf\">compute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">-</span> <span class=\"n\">first</span> <span class=\"o\">&lt;=</span> <span class=\"n\">threshold</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 任务足够小则直接计算\n</span><span class=\"c1\"></span>            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">last</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"n\">result</span> <span class=\"o\">+=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 拆分成小任务\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">middle</span> <span class=\"o\">=</span> <span class=\"n\">first</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">-</span> <span class=\"n\">first</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n            <span class=\"n\">ForkJoinExample</span> <span class=\"n\">leftTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ForkJoinExample</span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">,</span> <span class=\"n\">middle</span><span class=\"o\">);</span>\n            <span class=\"n\">ForkJoinExample</span> <span class=\"n\">rightTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ForkJoinExample</span><span class=\"o\">(</span><span class=\"n\">middle</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">last</span><span class=\"o\">);</span>\n            <span class=\"n\">leftTask</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">();</span>\n            <span class=\"n\">rightTask</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">();</span>\n            <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">leftTask</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">rightTask</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">ExecutionException</span><span class=\"o\">,</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"n\">ForkJoinExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ForkJoinExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">10000</span><span class=\"o\">);</span>\n    <span class=\"n\">ForkJoinPool</span> <span class=\"n\">forkJoinPool</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ForkJoinPool</span><span class=\"o\">();</span>\n    <span class=\"n\">Future</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">forkJoinPool</span><span class=\"o\">.</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">);</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n<span class=\"o\">}</span></code></pre></div><p>ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ForkJoinPool</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractExecutorService</span></code></pre></div><p>ForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e2d8c2f9c1492f875a419e037143dff6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb\" width=\"526\" data-original=\"https://pic3.zhimg.com/v2-e2d8c2f9c1492f875a419e037143dff6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;526&#39; height=&#39;293&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"526\" data-original=\"https://pic3.zhimg.com/v2-e2d8c2f9c1492f875a419e037143dff6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e2d8c2f9c1492f875a419e037143dff6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>九、线程不安全示例</h2><p>如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。</p><p>以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadUnsafeExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threadSize</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n    <span class=\"n\">ThreadUnsafeExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadUnsafeExample</span><span class=\"o\">();</span>\n    <span class=\"kd\">final</span> <span class=\"n\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CountDownLatch</span><span class=\"o\">(</span><span class=\"n\">threadSize</span><span class=\"o\">);</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">threadSize</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">();</span>\n            <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span>\n        <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">997</span></code></pre></div><h2>十、Java 内存模型</h2><p>Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。</p><h2>主内存与工作内存</h2><p>处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。</p><p>加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c231562d937b796c26b9ad7075936b3e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"999\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb\" width=\"999\" data-original=\"https://pic3.zhimg.com/v2-c231562d937b796c26b9ad7075936b3e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;999&#39; height=&#39;538&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"999\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"999\" data-original=\"https://pic3.zhimg.com/v2-c231562d937b796c26b9ad7075936b3e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c231562d937b796c26b9ad7075936b3e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。</p><p>线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e38dd19eda24306081985d64c30da476_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"997\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb\" width=\"997\" data-original=\"https://pic3.zhimg.com/v2-e38dd19eda24306081985d64c30da476_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;997&#39; height=&#39;530&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"997\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"997\" data-original=\"https://pic3.zhimg.com/v2-e38dd19eda24306081985d64c30da476_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e38dd19eda24306081985d64c30da476_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>内存间交互操作</h2><p>Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-94fe2e2b92fdac5d624ae5e9f6437564_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb\" width=\"749\" data-original=\"https://pic1.zhimg.com/v2-94fe2e2b92fdac5d624ae5e9f6437564_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;749&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"749\" data-original=\"https://pic1.zhimg.com/v2-94fe2e2b92fdac5d624ae5e9f6437564_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-94fe2e2b92fdac5d624ae5e9f6437564_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>read：把一个变量的值从主内存传输到工作内存中</li><li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中</li><li>use：把工作内存中一个变量的值传递给执行引擎</li><li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store：把工作内存的一个变量的值传送到主内存中</li><li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li><li>lock：作用于主内存的变量</li><li>unlock</li></ul><h2>内存模型三大特性</h2><h3>1. 原子性</h3><p>Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。</p><p>有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。</p><p>为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。</p><p>下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cda140e15c3bc31a72e9a97889b18471_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic2.zhimg.com/v2-cda140e15c3bc31a72e9a97889b18471_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic2.zhimg.com/v2-cda140e15c3bc31a72e9a97889b18471_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cda140e15c3bc31a72e9a97889b18471_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>AtomicInteger 能保证多个线程修改的原子性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6cda5aacfb318f058b60413ffa3cb617_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"475\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb\" width=\"475\" data-original=\"https://pic4.zhimg.com/v2-6cda5aacfb318f058b60413ffa3cb617_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;475&#39; height=&#39;724&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"475\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"475\" data-original=\"https://pic4.zhimg.com/v2-6cda5aacfb318f058b60413ffa3cb617_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6cda5aacfb318f058b60413ffa3cb617_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AtomicExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">cnt</span><span class=\"o\">.</span><span class=\"na\">incrementAndGet</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threadSize</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n    <span class=\"n\">AtomicExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicExample</span><span class=\"o\">();</span> <span class=\"c1\">// 只修改这条语句\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"n\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CountDownLatch</span><span class=\"o\">(</span><span class=\"n\">threadSize</span><span class=\"o\">);</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">threadSize</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">();</span>\n            <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span>\n        <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">1000</span></code></pre></div><p>除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AtomicSynchronizedExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">cnt</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threadSize</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n    <span class=\"n\">AtomicSynchronizedExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicSynchronizedExample</span><span class=\"o\">();</span>\n    <span class=\"kd\">final</span> <span class=\"n\">CountDownLatch</span> <span class=\"n\">countDownLatch</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CountDownLatch</span><span class=\"o\">(</span><span class=\"n\">threadSize</span><span class=\"o\">);</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">threadSize</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">();</span>\n            <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">countDown</span><span class=\"o\">();</span>\n        <span class=\"o\">});</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">countDownLatch</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n<span class=\"o\">}</span>\n<span class=\"n\">1000</span></code></pre></div><h3>2. 可见性</h3><p>可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。</p><p>主要有三种实现可见性的方式：</p><ul><li>volatile</li><li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li><li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li></ul><p>对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。</p><h3>3. 有序性</h3><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。</p><h2>先行发生原则</h2><p>上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。</p><h3>1. 单一线程原则</h3><blockquote> Single Thread rule<br/> </blockquote><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0dbfb4af5360d64a8899ba85e0f6204_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"417\" class=\"content_image\" width=\"280\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;280&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"417\" class=\"content_image lazy\" width=\"280\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0dbfb4af5360d64a8899ba85e0f6204_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. 管程锁定规则</h3><blockquote> Monitor Lock Rule<br/> </blockquote><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fa3d063cb9699fa357de03acee03389d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"563\" data-original=\"https://pic2.zhimg.com/v2-fa3d063cb9699fa357de03acee03389d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;563&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"563\" data-original=\"https://pic2.zhimg.com/v2-fa3d063cb9699fa357de03acee03389d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fa3d063cb9699fa357de03acee03389d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>3. volatile 变量规则</h3><blockquote> Volatile Variable Rule<br/> </blockquote><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d72842da9887a0e9658b1ded49fb5b3e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"670\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"670\" data-original=\"https://pic3.zhimg.com/v2-d72842da9887a0e9658b1ded49fb5b3e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;670&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"670\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"670\" data-original=\"https://pic3.zhimg.com/v2-d72842da9887a0e9658b1ded49fb5b3e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d72842da9887a0e9658b1ded49fb5b3e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>4. 线程启动规则</h3><blockquote> Thread Start Rule<br/> </blockquote><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4a32e3f735a6c830002344b097284f6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"655\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb\" width=\"655\" data-original=\"https://pic3.zhimg.com/v2-4a32e3f735a6c830002344b097284f6e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;655&#39; height=&#39;317&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"655\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"655\" data-original=\"https://pic3.zhimg.com/v2-4a32e3f735a6c830002344b097284f6e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4a32e3f735a6c830002344b097284f6e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>5. 线程加入规则</h3><blockquote> Thread Join Rule<br/> </blockquote><p>Thread 对象的结束先行发生于 join() 方法返回。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-12caec6922872ff0256c0202de583a0a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-12caec6922872ff0256c0202de583a0a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-12caec6922872ff0256c0202de583a0a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-12caec6922872ff0256c0202de583a0a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>6. 线程中断规则</h3><blockquote> Thread Interruption Rule<br/> </blockquote><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h3>7. 对象终结规则</h3><blockquote> Finalizer Rule<br/> </blockquote><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h3>8. 传递性</h3><blockquote> Transitivity<br/> </blockquote><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h2>十一、线程安全</h2><p>多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。</p><p>线程安全有以下几种实现方式：</p><h2>不可变</h2><p>不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。</p><p>不可变的类型：</p><ul><li>final 关键字修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><p>对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ImmutableExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">unmodifiableMap</span> <span class=\"o\">=</span> <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">unmodifiableMap</span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">);</span>\n        <span class=\"n\">unmodifiableMap</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"s\">&#34;a&#34;</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">Exception</span> <span class=\"n\">in</span> <span class=\"n\">thread</span> <span class=\"s\">&#34;main&#34;</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">UnsupportedOperationException</span>\n    <span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">Collections$UnmodifiableMap</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">1457</span><span class=\"o\">)</span>\n    <span class=\"n\">at</span> <span class=\"n\">ImmutableExample</span><span class=\"o\">.</span><span class=\"na\">main</span><span class=\"o\">(</span><span class=\"n\">ImmutableExample</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">9</span><span class=\"o\">)</span></code></pre></div><p>Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">UnsupportedOperationException</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>互斥同步</h2><p>synchronized 和 ReentrantLock。</p><h2>非阻塞同步</h2><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p>互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><h3>1. CAS</h3><p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p><p>乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。</p><h3>2. AtomicInteger</h3><p>J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</p><p>以下代码使用了 AtomicInteger 执行了自增的操作。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">();</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">cnt</span><span class=\"o\">.</span><span class=\"na\">incrementAndGet</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">incrementAndGet</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">unsafe</span><span class=\"o\">.</span><span class=\"na\">getAndAddInt</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">valueOffset</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。</p><p>可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">getAndAddInt</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">var1</span><span class=\"o\">,</span> <span class=\"kt\">long</span> <span class=\"n\">var2</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">var4</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">var5</span><span class=\"o\">;</span>\n    <span class=\"k\">do</span> <span class=\"o\">{</span>\n        <span class=\"n\">var5</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">getIntVolatile</span><span class=\"o\">(</span><span class=\"n\">var1</span><span class=\"o\">,</span> <span class=\"n\">var2</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">while</span><span class=\"o\">(!</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">compareAndSwapInt</span><span class=\"o\">(</span><span class=\"n\">var1</span><span class=\"o\">,</span> <span class=\"n\">var2</span><span class=\"o\">,</span> <span class=\"n\">var5</span><span class=\"o\">,</span> <span class=\"n\">var5</span> <span class=\"o\">+</span> <span class=\"n\">var4</span><span class=\"o\">));</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">var5</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h3>3. ABA</h3><p>如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。</p><p>J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p><h2>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。</p><h3>1. 栈封闭</h3><p>多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">StackClosedExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add100</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">100</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">cnt</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">cnt</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">StackClosedExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StackClosedExample</span><span class=\"o\">();</span>\n    <span class=\"n\">ExecutorService</span> <span class=\"n\">executorService</span> <span class=\"o\">=</span> <span class=\"n\">Executors</span><span class=\"o\">.</span><span class=\"na\">newCachedThreadPool</span><span class=\"o\">();</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">add100</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">add100</span><span class=\"o\">());</span>\n    <span class=\"n\">executorService</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">100</span>\n<span class=\"n\">100</span></code></pre></div><h3>2. 线程本地存储（Thread Local Storage）</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。</p><p>符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。</p><p>对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLocalExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ThreadLocal</span> <span class=\"n\">threadLocal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadLocal</span><span class=\"o\">();</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">thread1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">threadLocal</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">1000</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">threadLocal</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n            <span class=\"n\">threadLocal</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">thread2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">threadLocal</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n            <span class=\"n\">threadLocal</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">();</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">thread1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">thread2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">1</span></code></pre></div><p>为了理解 ThreadLocal，先看以下代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadLocalExample1</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ThreadLocal</span> <span class=\"n\">threadLocal1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadLocal</span><span class=\"o\">();</span>\n        <span class=\"n\">ThreadLocal</span> <span class=\"n\">threadLocal2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadLocal</span><span class=\"o\">();</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">thread1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">threadLocal1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n            <span class=\"n\">threadLocal2</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">thread2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n            <span class=\"n\">threadLocal1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n            <span class=\"n\">threadLocal2</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">thread1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">thread2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>它所对应的底层结构图为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-edf9b9cf387e598fbf4f5f70bb7c3c9f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb\" width=\"904\" data-original=\"https://pic4.zhimg.com/v2-edf9b9cf387e598fbf4f5f70bb7c3c9f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;904&#39; height=&#39;537&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"904\" data-original=\"https://pic4.zhimg.com/v2-edf9b9cf387e598fbf4f5f70bb7c3c9f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-edf9b9cf387e598fbf4f5f70bb7c3c9f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/* ThreadLocal values pertaining to this thread. This map is maintained\n</span><span class=\"cm\"> * by the ThreadLocal class. */</span>\n<span class=\"n\">ThreadLocal</span><span class=\"o\">.</span><span class=\"na\">ThreadLocalMap</span> <span class=\"n\">threadLocals</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span></code></pre></div><p>当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n    <span class=\"n\">ThreadLocalMap</span> <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"n\">getMap</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">createMap</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>get() 方法类似。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">T</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n    <span class=\"n\">ThreadLocalMap</span> <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"n\">getMap</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">map</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ThreadLocalMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">getEntry</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"nd\">@SuppressWarnings</span><span class=\"o\">(</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">)</span>\n            <span class=\"n\">T</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">T</span><span class=\"o\">)</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n            <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">setInitialValue</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。</p><p>在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。</p><h3>3. 可重入代码（Reentrant Code）</h3><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h2>十二、锁优化</h2><p>这里的锁优化主要是指 JVM 对 synchronized 的优化。</p><h2>自旋锁</h2><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。</p><p>在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</p><h2>锁消除</h2><p>锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</p><p>锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。</p><p>对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"nf\">concatString</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">s2</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">s3</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">s2</span> <span class=\"o\">+</span> <span class=\"n\">s3</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"nf\">concatString</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">s1</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">s2</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">s3</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">StringBuffer</span> <span class=\"n\">sb</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StringBuffer</span><span class=\"o\">();</span>\n    <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">s1</span><span class=\"o\">);</span>\n    <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">s2</span><span class=\"o\">);</span>\n    <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">s3</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">sb</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。</p><h2>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。</p><p>上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。</p><h2>轻量级锁</h2><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p>以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-93835fd4b371c071999bb4132ef73217_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"771\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb\" width=\"771\" data-original=\"https://pic4.zhimg.com/v2-93835fd4b371c071999bb4132ef73217_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;771&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"771\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"771\" data-original=\"https://pic4.zhimg.com/v2-93835fd4b371c071999bb4132ef73217_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-93835fd4b371c071999bb4132ef73217_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bd05819104acb1595aa45a068dcb7fb1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"790\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"790\" data-original=\"https://pic2.zhimg.com/v2-bd05819104acb1595aa45a068dcb7fb1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;790&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"790\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"790\" data-original=\"https://pic2.zhimg.com/v2-bd05819104acb1595aa45a068dcb7fb1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bd05819104acb1595aa45a068dcb7fb1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。</p><p>当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f65556e3570d5d22ca9d0c55a7114e6f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"630\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"630\" data-original=\"https://pic4.zhimg.com/v2-f65556e3570d5d22ca9d0c55a7114e6f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;630&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"630\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"630\" data-original=\"https://pic4.zhimg.com/v2-f65556e3570d5d22ca9d0c55a7114e6f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f65556e3570d5d22ca9d0c55a7114e6f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。</p><h2>偏向锁</h2><p>偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。</p><p>当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dd7fa078bb836f8aef4b33898d69378d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb\" width=\"1490\" data-original=\"https://pic2.zhimg.com/v2-dd7fa078bb836f8aef4b33898d69378d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1490&#39; height=&#39;764&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1490\" data-original=\"https://pic2.zhimg.com/v2-dd7fa078bb836f8aef4b33898d69378d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dd7fa078bb836f8aef4b33898d69378d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>十三、多线程开发良好的实践</h2><ul><li> 给线程起个有意义的名字，这样可以方便找 Bug。<br/> </li><li> 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。<br/> </li><li> 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。<br/> </li><li> 使用 BlockingQueue 实现生产者消费者问题。<br/> </li><li> 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。<br/> </li><li> 使用本地变量和不可变类来保证线程安全。<br/> </li><li> 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。<br/> </li></ul><h2>参考资料</h2><ul><li>BruceEckel. Java 编程思想: 第 4 版 [M]. 机械工业出版社, 2007.</li><li>周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se6/html/Threads.doc.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Threads and Locks</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//ifeve.com/thread-signaling/%23missed_signal\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">线程通信</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/12773.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 线程面试题 Top 50</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//tutorials.jenkov.com/java-util-concurrent/blockingqueue.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BlockingQueue</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/11265289/thread-state-java\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">thread state java</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//wiki.expertiza.ncsu.edu/index.php/CSC_456_Spring_2012/ch7_MN\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CSC 456 Spring 2012/ch7 MN</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.logicbig.com/tutorials/core-java-tutorial/java-multi-threading/happens-before.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java - Understanding Happens-before relationship</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.slideshare.net/novathinker/6-thread-synchronization\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">6장 Thread Synchronization</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/1202444/how-is-javas-threadlocal-implemented-under-the-hood/15653015\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How is Java&#39;s ThreadLocal implemented under the hood?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//sites.google.com/site/webdevelopart/21-compile/06-java/javase/concurrent%3Ftmpl%3D%252Fsystem%252Fapp%252Ftemplates%252Fprint%252F%26showPrintDialog%3D1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Concurrent</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.javacreed.com/java-fork-join-example/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JAVA FORK JOIN EXAMPLE</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//ifeve.com/talk-concurrency-forkjoin/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">聊聊并发（八）——Fork/Join 框架介绍</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/technetwork/java/javase/tech/biasedlocking-oopsla2006-preso-150106.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Eliminating SynchronizationRelated Atomic Operations with Biased Locking and Bulk Rebiasing</a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;899&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"899\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"899\" data-original=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d7b61186191042d91d230ccb26a7d99_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59850281", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 5, 
            "title": "Java 基础", 
            "content": "<p></p><h2>一、数据类型</h2><h2>基本类型</h2><ul><li>byte/8</li><li>char/16</li><li>short/16</li><li>int/32</li><li>float/32</li><li>long/64</li><li>double/64</li><li>boolean/\\~</li></ul><p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 并不直接支持 boolean 数组，而是使用 byte 数组来表示 int 数组来表示。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Primitive Data Types</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">The Java® Virtual Machine Specification</a></li></ul><h2>包装类型</h2><p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>     <span class=\"c1\">// 装箱\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>         <span class=\"o\">//</span> <span class=\"n\">拆箱</span></code></pre></div><h2>缓存池</h2><p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p><ul><li>new Integer(123) 每次都会新建一个对象；</li><li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">);</span>    <span class=\"c1\">// false\n</span><span class=\"c1\"></span><span class=\"n\">Integer</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">);</span>   <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Integer</span> <span class=\"nf\">valueOf</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">low</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">high</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">cache</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"o\">(-</span><span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">low</span><span class=\"o\">)];</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128\\~127。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">128</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">high</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Integer</span> <span class=\"n\">cache</span><span class=\"o\">[];</span>\n\n<span class=\"kd\">static</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// high value may be configured by property\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">127</span><span class=\"o\">;</span>\n    <span class=\"n\">String</span> <span class=\"n\">integerCacheHighPropValue</span> <span class=\"o\">=</span>\n        <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">misc</span><span class=\"o\">.</span><span class=\"na\">VM</span><span class=\"o\">.</span><span class=\"na\">getSavedProperty</span><span class=\"o\">(</span><span class=\"s\">&#34;java.lang.Integer.IntegerCache.high&#34;</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">integerCacheHighPropValue</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">parseInt</span><span class=\"o\">(</span><span class=\"n\">integerCacheHighPropValue</span><span class=\"o\">);</span>\n            <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">127</span><span class=\"o\">);</span>\n            <span class=\"c1\">// Maximum array size is Integer.MAX_VALUE\n</span><span class=\"c1\"></span>            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span> <span class=\"o\">-</span> <span class=\"o\">(-</span><span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span><span class=\"o\">(</span> <span class=\"n\">NumberFormatException</span> <span class=\"n\">nfe</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// If the property cannot be parsed into an int, ignore it.\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n\n    <span class=\"n\">cache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">[(</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">low</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;</span> <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\n        <span class=\"n\">cache</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">++);</span>\n\n    <span class=\"c1\">// range [-128, 127] must be interned (JLS7 5.1.7)\n</span><span class=\"c1\"></span>    <span class=\"k\">assert</span> <span class=\"n\">IntegerCache</span><span class=\"o\">.</span><span class=\"na\">high</span> <span class=\"o\">&gt;=</span> <span class=\"n\">127</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n<span class=\"n\">Integer</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">==</span> <span class=\"n\">n</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>基本类型对应的缓冲池如下：</p><ul><li>boolean values true and false</li><li>all byte values</li><li>short values between -128 and 127</li><li>int values between -128 and 127</li><li>char in the range \\u0000 to \\u007F</li></ul><p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/9030817/differences-between-new-integer123-integer-valueof123-and-just-123\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Differences between new Integer(123), Integer.valueOf(123) and just 123 </a></p><h2>二、String</h2><h2>概览</h2><p>String 被声明为 final，因此它不可被继承。</p><p>在 Java 8 中，String 内部使用 char 数组存储数据。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">String</span>\n    <span class=\"kd\">implements</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">Serializable</span><span class=\"o\">,</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;,</span> <span class=\"n\">CharSequence</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** The value is used for character storage. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">char</span> <span class=\"n\">value</span><span class=\"o\">[];</span>\n<span class=\"o\">}</span></code></pre></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">String</span>\n    <span class=\"kd\">implements</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">Serializable</span><span class=\"o\">,</span> <span class=\"n\">Comparable</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;,</span> <span class=\"n\">CharSequence</span> <span class=\"o\">{</span>\n    <span class=\"cm\">/** The value is used for character storage. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** The identifier of the encoding used to encode the bytes in {@code value}. */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"kt\">byte</span> <span class=\"n\">coder</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p><h2>不可变的好处</h2><p><b>1. 可以缓存 hash 值</b> </p><p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p><p><b>2. String Pool 的需要</b> </p><p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4816d51ab7c22bd2ecfd1c59cd418457_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic4.zhimg.com/v2-4816d51ab7c22bd2ecfd1c59cd418457_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic4.zhimg.com/v2-4816d51ab7c22bd2ecfd1c59cd418457_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4816d51ab7c22bd2ecfd1c59cd418457_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3. 安全性</b> </p><p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p><p><b>4. 线程安全</b> </p><p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.programcreek.com/2013/04/why-string-is-immutable-in-java/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Program Creek : Why String is immutable in Java?</a></p><h2>String, StringBuffer and StringBuilder</h2><p><b>1. 可变性</b> </p><ul><li>String 不可变</li><li>StringBuffer 和 StringBuilder 可变</li></ul><p><b>2. 线程安全</b> </p><ul><li>String 不可变，因此是线程安全的</li><li>StringBuilder 不是线程安全的</li><li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2971315/string-stringbuffer-and-stringbuilder\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : String, StringBuffer, and StringBuilder</a></p><h2>String Pool</h2><p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p><p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p><p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">String</span> <span class=\"n\">s2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">==</span> <span class=\"n\">s2</span><span class=\"o\">);</span>           <span class=\"c1\">// false\n</span><span class=\"c1\"></span><span class=\"n\">String</span> <span class=\"n\">s3</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">intern</span><span class=\"o\">();</span>\n<span class=\"n\">String</span> <span class=\"n\">s4</span> <span class=\"o\">=</span> <span class=\"n\">s1</span><span class=\"o\">.</span><span class=\"na\">intern</span><span class=\"o\">();</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s3</span> <span class=\"o\">==</span> <span class=\"n\">s4</span><span class=\"o\">);</span>           <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>如果是采用 &#34;bbb&#34; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s5</span> <span class=\"o\">=</span> <span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">;</span>\n<span class=\"n\">String</span> <span class=\"n\">s6</span> <span class=\"o\">=</span> <span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">;</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">s5</span> <span class=\"o\">==</span> <span class=\"n\">s6</span><span class=\"o\">);</span>  <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/10578984/what-is-string-interning\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : What is String interning?</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/in_depth_understanding_string_intern.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入解析 String#intern</a></li></ul><h2>new String(&#34;abc&#34;)</h2><p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &#34;abc&#34; 字符串对象）。</p><ul><li>&#34;abc&#34; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &#34;abc&#34; 字符串字面量；</li><li>而使用 new 的方式会在堆中创建一个字符串对象。</li></ul><p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">NewStringTest</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">String</span><span class=\"o\">(</span><span class=\"s\">&#34;abc&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>使用 javap -verbose 进行反编译，得到以下内容：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"n\">Constant</span> <span class=\"nl\">pool:</span>\n<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>   <span class=\"err\">#</span><span class=\"n\">2</span> <span class=\"o\">=</span> <span class=\"n\">Class</span>              <span class=\"err\">#</span><span class=\"n\">18</span>            <span class=\"c1\">// java/lang/String\n</span><span class=\"c1\"></span>   <span class=\"err\">#</span><span class=\"n\">3</span> <span class=\"o\">=</span> <span class=\"n\">String</span>             <span class=\"err\">#</span><span class=\"n\">19</span>            <span class=\"c1\">// abc\n</span><span class=\"c1\">// ...\n</span><span class=\"c1\"></span>  <span class=\"err\">#</span><span class=\"n\">18</span> <span class=\"o\">=</span> <span class=\"n\">Utf8</span>               <span class=\"n\">java</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">String</span>\n  <span class=\"err\">#</span><span class=\"n\">19</span> <span class=\"o\">=</span> <span class=\"n\">Utf8</span>               <span class=\"n\">abc</span>\n<span class=\"c1\">// ...\n</span><span class=\"c1\"></span>\n  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">String</span><span class=\"o\">[]);</span><span class=\"nl\">\n</span><span class=\"nl\">    descriptor:</span> <span class=\"o\">([</span><span class=\"n\">Ljava</span><span class=\"o\">/</span><span class=\"n\">lang</span><span class=\"o\">/</span><span class=\"n\">String</span><span class=\"o\">;)</span><span class=\"n\">V</span><span class=\"nl\">\n</span><span class=\"nl\">    flags:</span> <span class=\"n\">ACC_PUBLIC</span><span class=\"o\">,</span> <span class=\"n\">ACC_STATIC</span><span class=\"nl\">\n</span><span class=\"nl\">    Code:</span>\n      <span class=\"n\">stack</span><span class=\"o\">=</span><span class=\"n\">3</span><span class=\"o\">,</span> <span class=\"n\">locals</span><span class=\"o\">=</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">args_size</span><span class=\"o\">=</span><span class=\"n\">1</span><span class=\"nl\">\n</span><span class=\"nl\">         0:</span> <span class=\"k\">new</span>           <span class=\"err\">#</span><span class=\"n\">2</span>                  <span class=\"c1\">// class java/lang/String\n</span><span class=\"c1\"></span>         <span class=\"nl\">3:</span> <span class=\"n\">dup</span><span class=\"nl\">\n</span><span class=\"nl\">         4:</span> <span class=\"n\">ldc</span>           <span class=\"err\">#</span><span class=\"n\">3</span>                  <span class=\"c1\">// String abc\n</span><span class=\"c1\"></span>         <span class=\"nl\">6:</span> <span class=\"n\">invokespecial</span> <span class=\"err\">#</span><span class=\"n\">4</span>                  <span class=\"c1\">// Method java/lang/String.&#34;&lt;init&gt;&#34;:(Ljava/lang/String;)V\n</span><span class=\"c1\"></span>         <span class=\"nl\">9:</span> <span class=\"n\">astore_1</span>\n<span class=\"o\">//</span> <span class=\"o\">...</span></code></pre></div><p>在 Constant Pool 中，#19 存储这字符串字面量 &#34;abc&#34;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p><p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">String</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">original</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">hash</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>三、运算</h2><h2>参数传递</h2><p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p><p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Dog</span> <span class=\"o\">{</span>\n\n    <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n\n    <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">String</span> <span class=\"nf\">getName</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">setName</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">String</span> <span class=\"nf\">getObjectAddress</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">PassByValueExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Dog</span> <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;A&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// A\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">(</span><span class=\"n\">Dog</span> <span class=\"n\">dog</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@4554617c\n</span><span class=\"c1\"></span>        <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;B&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getObjectAddress</span><span class=\"o\">());</span> <span class=\"c1\">// Dog@74a14482\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// B\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">PassByValueExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Dog</span> <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">(</span><span class=\"s\">&#34;A&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">func</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">());</span>          <span class=\"c1\">// B\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">(</span><span class=\"n\">Dog</span> <span class=\"n\">dog</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">dog</span><span class=\"o\">.</span><span class=\"na\">setName</span><span class=\"o\">(</span><span class=\"s\">&#34;B&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p><h2>float 与 double</h2><p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p><p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"o\">//</span> <span class=\"kt\">float</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">.</span><span class=\"na\">1</span><span class=\"o\">;</span></code></pre></div><p>1.1f 字面量才是 float 类型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">float</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">.</span><span class=\"na\">1f</span><span class=\"o\">;</span></code></pre></div><h2>隐式类型转换</h2><p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">short</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">//</span> <span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">s1</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">//</span> <span class=\"n\">s1</span><span class=\"o\">++;</span></code></pre></div><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">s1</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">short</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">s1</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Why don&#39;t Java&#39;s +=, -=, *=, /= compound assignment operators require casting?</a></p><h2>switch</h2><p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">String</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s\">&#34;a&#34;</span><span class=\"o\">;</span>\n<span class=\"k\">switch</span> <span class=\"o\">(</span><span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">case</span> <span class=\"s\">&#34;a&#34;</span><span class=\"o\">:</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;aaa&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">break</span><span class=\"o\">;</span>\n    <span class=\"k\">case</span> <span class=\"s\">&#34;b&#34;</span><span class=\"o\">:</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;bbb&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">break</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// long x = 111;\n</span><span class=\"c1\">// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;\n</span><span class=\"c1\">//     case 111:\n</span><span class=\"c1\">//         System.out.println(111);\n</span><span class=\"c1\">//         break;\n</span><span class=\"c1\">//     case 222:\n</span><span class=\"c1\">//         System.out.println(222);\n</span><span class=\"c1\">//         break;\n</span><span class=\"c1\"></span><span class=\"o\">//</span> <span class=\"o\">}</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow : Why can&#39;t your switch statement data type be long, Java?</a></p><h2>四、继承</h2><h2>访问权限</h2><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p><p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p><ul><li>类可见表示其它类可以用这个类创建实例对象。</li><li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li></ul><p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p><p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p><p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"n\">id</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getId</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">id</span> <span class=\"o\">+</span> <span class=\"s\">&#34;&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setId</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">id</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccessWithInnerClassExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">InnerClass</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">InnerClass</span> <span class=\"n\">innerClass</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">AccessWithInnerClassExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">innerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InnerClass</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getValue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">innerClass</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">;</span>  <span class=\"c1\">// 直接访问\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>抽象类与接口</h2><p><b>1. 抽象类</b> </p><p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p><p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">AbstractClassExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func2</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func2&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AbstractExtendClassExample</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractClassExample</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func1&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// AbstractClassExample ac1 = new AbstractClassExample(); // &#39;AbstractClassExample&#39; is abstract; cannot be instantiated\n</span><span class=\"c1\"></span><span class=\"n\">AbstractClassExample</span> <span class=\"n\">ac2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AbstractExtendClassExample</span><span class=\"o\">();</span>\n<span class=\"n\">ac2</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">();</span></code></pre></div><p><b>2. 接口</b> </p><p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p><p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p><p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p><p>接口的字段默认都是 static 和 final 的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">interface</span> <span class=\"nc\">InterfaceExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">();</span>\n\n    <span class=\"k\">default</span> <span class=\"kt\">void</span> <span class=\"nf\">func2</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func2&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">123</span><span class=\"o\">;</span>\n    <span class=\"c1\">// int y;               // Variable &#39;y&#39; might not have been initialized\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"n\">z</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>       <span class=\"c1\">// Modifier &#39;public&#39; is redundant for interface fields\n</span><span class=\"c1\"></span>    <span class=\"c1\">// private int k = 0;   // Modifier &#39;private&#39; not allowed here\n</span><span class=\"c1\"></span>    <span class=\"c1\">// protected int l = 0; // Modifier &#39;protected&#39; not allowed here\n</span><span class=\"c1\"></span>    <span class=\"c1\">// private void fun3(); // Modifier &#39;private&#39; not allowed here\n</span><span class=\"c1\"></span><span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">InterfaceImplementExample</span> <span class=\"kd\">implements</span> <span class=\"n\">InterfaceExample</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;func1&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">// InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated\n</span><span class=\"c1\"></span><span class=\"n\">InterfaceExample</span> <span class=\"n\">ie2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">InterfaceImplementExample</span><span class=\"o\">();</span>\n<span class=\"n\">ie2</span><span class=\"o\">.</span><span class=\"na\">func1</span><span class=\"o\">();</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">InterfaceExample</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">);</span></code></pre></div><p><b>3. 比较</b> </p><ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li><li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li><li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li><li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul><p><b>4. 使用选择</b> </p><p>使用接口：</p><ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li><li>需要使用多重继承。</li></ul><p>使用抽象类：</p><ul><li>需要在几个相关的类中共享代码。</li><li>需要能控制继承来的成员的访问权限，而不是都为 public。</li><li>需要继承非静态和非常量字段。</li></ul><p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/java/l-javainterface-abstract/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入理解 abstract class 和 interface</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//dzone.com/articles/when-to-use-abstract-class-and-intreface\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">When to Use Abstract Class and Interface</a></li></ul><h2>super</h2><ul><li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li><li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SuperExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">SuperExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;SuperExample.func()&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SuperExtendExample</span> <span class=\"kd\">extends</span> <span class=\"n\">SuperExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">SuperExtendExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"n\">y</span><span class=\"o\">);</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">z</span> <span class=\"o\">=</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">func</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;SuperExtendExample.func()&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">SuperExample</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SuperExtendExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">3</span><span class=\"o\">);</span>\n<span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">();</span>\n<span class=\"n\">SuperExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">()</span>\n<span class=\"n\">SuperExtendExample</span><span class=\"o\">.</span><span class=\"na\">func</span><span class=\"o\">()</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/java/IandI/super.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Using the Keyword super</a></p><h2>重写与重载</h2><p><b>1. 重写（Override）</b> </p><p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p><p>为了满足里式替换原则，重写有有以下两个限制：</p><ul><li>子类方法的访问权限必须大于等于父类方法；</li><li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li></ul><p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p><p><b>2. 重载（Overload）</b> </p><p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p><p>应该注意的是，返回值不同，其它都相同不算是重载。</p><p><b>3. 实例</b> </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">D</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"s\">&#34;A and D&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"s\">&#34;A and A&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">B</span> <span class=\"kd\">extends</span> <span class=\"n\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"s\">&#34;B and B&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">show</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">obj</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"s\">&#34;B and A&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">C</span> <span class=\"kd\">extends</span> <span class=\"n\">B</span> <span class=\"o\">{</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">B</span> <span class=\"o\">{</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"n\">A</span> <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n        <span class=\"n\">B</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n        <span class=\"n\">C</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">C</span><span class=\"o\">();</span>\n        <span class=\"n\">D</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">D</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">));</span> <span class=\"c1\">// A and A\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">));</span> <span class=\"c1\">// A and A\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a1</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">));</span> <span class=\"c1\">// A and D\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">));</span> <span class=\"c1\">// B and A\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">));</span> <span class=\"c1\">// B and A\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">a2</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">));</span> <span class=\"c1\">// A and D\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">));</span>  <span class=\"c1\">// B and B\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">));</span>  <span class=\"c1\">// B and B\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">show</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">));</span>  <span class=\"c1\">// A and D\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>涉及到重写时，方法调用的优先级为：</p><ul><li>this.show(O)</li><li>super.show(O)</li><li>this.show((super)O)</li><li>super.show((super)O)</li></ul><h2>五、Object 通用方法</h2><h2>概览</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">native</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">equals</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">obj</span><span class=\"o\">)</span>\n\n<span class=\"kd\">protected</span> <span class=\"kd\">native</span> <span class=\"n\">Object</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span>\n\n<span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"n\">Class</span><span class=\"o\">&lt;?&gt;</span> <span class=\"n\">getClass</span><span class=\"o\">()</span>\n\n<span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">finalize</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Throwable</span> <span class=\"o\">{}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">notify</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">notifyAll</span><span class=\"o\">()</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kd\">native</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">timeout</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">nanos</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span></code></pre></div><h2>equals()</h2><p><b>1. 等价关系</b> </p><p>Ⅰ 自反性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅱ 对称性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅲ 传递性</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">))</span>\n    <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">z</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span><span class=\"o\">;</span></code></pre></div><p>Ⅳ 一致性</p><p>多次调用 equals() 方法结果不变</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">true</span></code></pre></div><p>Ⅴ 与 null 的比较</p><p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">);</span> <span class=\"o\">//</span> <span class=\"kc\">false</span><span class=\"o\">;</span></code></pre></div><p><b>2. 等价与相等</b> </p><ul><li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li><li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Integer</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">Integer</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">y</span><span class=\"o\">));</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">==</span> <span class=\"n\">y</span><span class=\"o\">);</span>      <span class=\"o\">//</span> <span class=\"kc\">false</span></code></pre></div><p><b>3. 实现</b> </p><ul><li>检查是否为同一个对象的引用，如果是直接返回 true；</li><li>检查是否是同一个类型，如果不是，直接返回 false；</li><li>将 Object 对象进行转型；</li><li>判断每个关键域是否相等。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">EqualExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">EqualExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">z</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">z</span> <span class=\"o\">=</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">equals</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"k\">this</span> <span class=\"o\">==</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">getClass</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">o</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">())</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n        <span class=\"n\">EqualExample</span> <span class=\"n\">that</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">EqualExample</span><span class=\"o\">)</span> <span class=\"n\">o</span><span class=\"o\">;</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">x</span> <span class=\"o\">!=</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">y</span> <span class=\"o\">!=</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">y</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">z</span> <span class=\"o\">==</span> <span class=\"n\">that</span><span class=\"o\">.</span><span class=\"na\">z</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>hashCode()</h2><p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p><p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p><p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">EqualExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EqualExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">EqualExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">EqualExample</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">));</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span><span class=\"n\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">EqualExample</span><span class=\"o\">&gt;</span> <span class=\"n\">set</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">&lt;&gt;();</span>\n<span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">);</span>\n<span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">set</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">());</span>   <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p><p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Override</span>\n<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hashCode</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">17</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n    <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">31</span> <span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">+</span> <span class=\"n\">z</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>toString()</h2><p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ToStringExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ToStringExample</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">number</span> <span class=\"o\">=</span> <span class=\"n\">number</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">ToStringExample</span> <span class=\"n\">example</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ToStringExample</span><span class=\"o\">(</span><span class=\"n\">123</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">example</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">());</span>\n<span class=\"n\">ToStringExample</span><span class=\"nd\">@4554617c</span></code></pre></div><h2>clone()</h2><p><b>1. cloneable</b> </p><p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneExample</span><span class=\"o\">();</span>\n<span class=\"o\">//</span> <span class=\"n\">CloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span> <span class=\"o\">//</span> <span class=\"err\">&#39;</span><span class=\"n\">clone</span><span class=\"o\">()</span><span class=\"err\">&#39;</span> <span class=\"n\">has</span> <span class=\"kd\">protected</span> <span class=\"n\">access</span> <span class=\"n\">in</span> <span class=\"err\">&#39;</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Object</span><span class=\"err\">&#39;</span></code></pre></div><p>重写 clone() 得到以下实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">CloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">CloneExample</span><span class=\"o\">)</span><span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneExample</span><span class=\"o\">();</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">CloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">CloneNotSupportedException</span><span class=\"o\">:</span> <span class=\"n\">CloneExample</span></code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p><p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>2. 浅拷贝</b> </p><p>拷贝对象和原始对象的引用类型引用同一个对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ShallowCloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ShallowCloneExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">ShallowCloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">ShallowCloneExample</span><span class=\"o\">)</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">ShallowCloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ShallowCloneExample</span><span class=\"o\">();</span>\n<span class=\"n\">ShallowCloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">222</span></code></pre></div><p><b>3. 深拷贝</b> </p><p>拷贝对象和原始对象的引用类型引用不同对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DeepCloneExample</span> <span class=\"kd\">implements</span> <span class=\"n\">Cloneable</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">DeepCloneExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">DeepCloneExample</span> <span class=\"nf\">clone</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">CloneNotSupportedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">DeepCloneExample</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">DeepCloneExample</span><span class=\"o\">)</span> <span class=\"kd\">super</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n        <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">DeepCloneExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">DeepCloneExample</span><span class=\"o\">();</span>\n<span class=\"n\">DeepCloneExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">clone</span><span class=\"o\">();</span>\n<span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">CloneNotSupportedException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><p><b>4. clone() 的替代方案</b> </p><p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CloneConstructorExample</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">CloneConstructorExample</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">10</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">CloneConstructorExample</span><span class=\"o\">(</span><span class=\"n\">CloneConstructorExample</span> <span class=\"n\">original</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">original</span><span class=\"o\">.</span><span class=\"na\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">CloneConstructorExample</span> <span class=\"n\">e1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneConstructorExample</span><span class=\"o\">();</span>\n<span class=\"n\">CloneConstructorExample</span> <span class=\"n\">e2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloneConstructorExample</span><span class=\"o\">(</span><span class=\"n\">e1</span><span class=\"o\">);</span>\n<span class=\"n\">e1</span><span class=\"o\">.</span><span class=\"na\">set</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">222</span><span class=\"o\">);</span>\n<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">e2</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">));</span> <span class=\"o\">//</span> <span class=\"n\">2</span></code></pre></div><h2>六、关键字</h2><h2>final</h2><p><b>1. 数据</b> </p><p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p><ul><li>对于基本类型，final 使数值不变；</li><li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"c1\">// x = 2;  // cannot assign value to final variable &#39;x&#39;\n</span><span class=\"c1\"></span><span class=\"kd\">final</span> <span class=\"n\">A</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n<span class=\"n\">y</span><span class=\"o\">.</span><span class=\"na\">a</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p><b>2. 方法</b> </p><p>声明方法不能被子类重写。</p><p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p><p><b>3. 类</b> </p><p>声明类不允许被继承。</p><h2>static</h2><p><b>1. 静态变量</b> </p><ul><li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li><li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>         <span class=\"c1\">// 实例变量\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>  <span class=\"c1\">// 静态变量\n</span><span class=\"c1\"></span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">x</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">y</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>2. 静态方法</b> </p><p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">(){</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">y</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">func1</span><span class=\"o\">(){</span>\n        <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n        <span class=\"c1\">// int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"c1\">// int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>3. 静态语句块</b> </p><p>静态语句块在类初始化时运行一次。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;123&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"n\">A</span> <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"n\">123</span></code></pre></div><p><b>4. 静态内部类</b> </p><p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">OuterClass</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">class</span> <span class=\"nc\">InnerClass</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">StaticInnerClass</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context\n</span><span class=\"c1\"></span>        <span class=\"n\">OuterClass</span> <span class=\"n\">outerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">OuterClass</span><span class=\"o\">();</span>\n        <span class=\"n\">InnerClass</span> <span class=\"n\">innerClass</span> <span class=\"o\">=</span> <span class=\"n\">outerClass</span><span class=\"o\">.</span><span class=\"na\">new</span> <span class=\"nf\">InnerClass</span><span class=\"o\">();</span>\n        <span class=\"n\">StaticInnerClass</span> <span class=\"n\">staticInnerClass</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StaticInnerClass</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p><p><b>5. 静态导包</b> </p><p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">import static</span> <span class=\"nn\">com.xxx.ClassName.*</span></code></pre></div><p><b>6. 初始化顺序</b> </p><p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">String</span> <span class=\"n\">staticField</span> <span class=\"o\">=</span> <span class=\"s\">&#34;静态变量&#34;</span><span class=\"o\">;</span>\n<span class=\"kd\">static</span> <span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;静态语句块&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"n\">field</span> <span class=\"o\">=</span> <span class=\"s\">&#34;实例变量&#34;</span><span class=\"o\">;</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;普通语句块&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>最后才是构造函数的初始化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">InitialOrderTest</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;构造函数&#34;</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>存在继承的情况下，初始化顺序为：</p><ul><li>父类（静态变量、静态语句块）</li><li>子类（静态变量、静态语句块）</li><li>父类（实例变量、普通语句块）</li><li>父类（构造函数）</li><li>子类（实例变量、普通语句块）</li><li>子类（构造函数）</li></ul><h2>七、反射</h2><p>每个类都有一个  <b>Class</b>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p><p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&#34;com.mysql.jdbc.Driver&#34;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p><p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p><p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p><ul><li><b>Field</b> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li><li><b>Method</b> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li><li><b>Constructor</b> ：可以用 Constructor 创建新的对象。</li></ul><p><b>反射的优点：</b> </p><ul><li><b>可扩展性</b>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li><li><b>类浏览器和可视化开发环境</b>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li><li><b>调试器和测试工具</b>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li></ul><p><b>反射的缺点：</b> </p><p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p><ul><li><b>性能开销</b>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。<br/> </li><li><b>安全限制</b>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。<br/> </li><li><b>内部暴露</b>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/tutorial/reflect/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Trail: The Reflection API</a><br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.sczyh30.com/posts/Java/java-reflection-1/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深入解析 Java 反射（1）- 基础</a></li></ul><h2>八、异常</h2><p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <b>Error</b>  和 <b>Exception</b>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p><ul><li><b>受检异常</b> ：需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复；</li><li><b>非受检异常</b> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-963f9f87446d7c56f1ea1ab9241e2293_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2272\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic4.zhimg.com/v2-963f9f87446d7c56f1ea1ab9241e2293_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;2272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"2272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic4.zhimg.com/v2-963f9f87446d7c56f1ea1ab9241e2293_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-963f9f87446d7c56f1ea1ab9241e2293_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.tianmaying.com/tutorial/Java-Exception\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 入门之异常处理</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/7383.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 异常的面试问题及答案 -Part 1</a></li></ul><h2>九、泛型</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Box</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// T stands for &#34;Type&#34;\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">T</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"n\">T</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">t</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">T</span> <span class=\"nf\">get</span><span class=\"o\">()</span> <span class=\"o\">{</span> <span class=\"k\">return</span> <span class=\"n\">t</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/24029.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 泛型详解</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//cloud.tencent.com/developer/article/1033693\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">10 道 Java 泛型面试题</a></li></ul><h2>十、注解</h2><p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/acm-bingzi/p/javaAnnotation.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">注解 Annotation 实现原理与自定义注解例子</a></p><h2>十一、特性</h2><h2>Java 各版本的新特性</h2><p><b>New highlights in Java SE 8</b> </p><ol><li>Lambda Expressions</li><li>Pipelines and Streams</li><li>Date and Time API</li><li>Default Methods</li><li>Type Annotations</li><li>Nashhorn JavaScript Engine</li><li>Concurrent Accumulators</li><li>Parallel operations</li><li>PermGen Error Removed</li></ol><p><b>New highlights in Java SE 7</b> </p><ol><li>Strings in Switch Statement</li><li>Type Inference for Generic Instance Creation</li><li>Multiple Exception Handling</li><li>Support for Dynamic Languages</li><li>Try with Resources</li><li>Java nio Package</li><li>Binary Literals, Underscore in literals</li><li> Diamond Syntax<br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.selfgrowth.com/articles/difference-between-java-18-and-java-17\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Difference between Java 1.8 and Java 1.7?</a><br/> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/19345.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 8 特性</a></li></ol><h2>Java 与 C++ 的区别</h2><ul><li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li><li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li><li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li><li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li><li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li><li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li><li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li><li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li></ul><p><a href=\"https://link.zhihu.com/?target=http%3A//cs-fundamentals.com/tech-interview/java/differences-between-java-and-cpp.php\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What are the main differences between Java and C++?</a></p><h2>JRE or JDK</h2><ul><li>JRE is the JVM program, Java application need to run on JRE.</li><li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &#34;javac&#34;</li></ul><h2>参考资料</h2><ul><li>Eckel B. Java 编程思想[M]. 机械工业出版社, 2002.</li><li>Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>⭐️欢迎关注我的公众号 CyC2018，在公众号后台回复关键字 📚 <b>资料</b> 可领取复习大纲，这份大纲是我花了一整年时间整理的面试知识点列表，不仅系统整理了面试知识点，而且标注了各个知识点的重要程度，从而帮你理清多而杂的面试知识点。可以说我基本是按照这份大纲来进行复习的，这份大纲对我拿到了 BAT 头条等 Offer 起到很大的帮助。你们完全可以和我一样根据大纲上列的知识点来进行复习，就不用看很多不重要的内容，也可以知道哪些内容很重要从而多安排一些复习时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-eaaf41eacfa3bb7288d7b468d46b1fec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic1.zhimg.com/v2-eaaf41eacfa3bb7288d7b468d46b1fec_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655602", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 4, 
            "title": "写好技术简历", 
            "content": "<p>✍🏻</p><h2>1. 重要性</h2><ul><li> 各大公司每年都要接收成千上万份简历，但是考虑到招聘成本，简历要先经过系统和 HR 筛选，简历筛选决定了你是否有笔试和面试资格。HR 需要从这么多的简历中筛选出合适的简历，那么一份简历通常不会花特别多的时间进行筛选，所以就需要让 HR 在很短的筛选时间中认可你的简历。<br/> </li><li> 简历通过筛选之后就被放入人才库中，等待发起笔试和面试。如果简历足够优秀，可以在提前批阶段免笔试直接获得面试机会，或者笔试成绩不理想但也有面试机会，这主要看有没有面试官从人才库中把你的简历捞起来。<br/> </li><li>面试过程通常会按照简历上的内容进行提问，所以简历也可以当成是面试大纲。如果你希望某些内容被面试官问到，那么最好把这些内容放在面试官比较能注意到的位置。</li></ul><p>✍🏻</p><h2>2. 本质</h2><p>简历相当于向企业推销自己的工具，在简历上你需要尽可能展现自己能给企业带来的价值，这种价值从两方面去评估：</p><ul><li> 技能的匹配程度。除了判断技能栈是否和岗位所要求的技能栈匹配之外，还要看是否具备公司目前业务相关的项目经历。<br/> </li><li> 能力证明。即使技能匹配了，但是如果能力不足的话依然不能胜任工作任务。可以通过学历、大赛奖项、工作和实习经历、项目中解决的问题等方面去证明自己的能力。应该分清哪个是你的优势和劣势，突出优势并弱化劣势，比如学历不好的话就把教育经历放后面一些。<br/> </li></ul><p>✍🏻</p><h2>3. 形式</h2><p>除了在招聘网站上填写自己的信息之外，通常还需要附带一份 PDF 简历，并且面试的时候也需要自己携带一份纸质简历（最好多带几份，以免当天有多场面试）。</p><p>除了 PDF 简历之外，通常还有 Markdown、Word、Latex 简历，但是这些形式的简历最后也都需要转换成 PDF 简历，因为 PDF 排版和格式都不容易在传输过程中发生改变，而且也方便打印，所以适合作为正式文档。</p><p>推荐使用 Markdown 简历，然后转换为 PDF 简历。因为 Markdown 排版简洁，而且更容易修改。但是 Markdown 简历有一个不足之处，就是不够紧凑，本来一页的简历可能需要两页。但是可以通过修改样式表的方式来解决这个问题，减小行间距、减小边距、缩小字体。以 Typora 编辑器为例，在样式文件夹下建立 base.user.css 文件，并使用 shift+F12 快捷键打开 DevTools 来修改样式，具体步骤请参考 <a href=\"https://link.zhihu.com/?target=https%3A//support.typora.io/Add-Custom-CSS/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Add Custom CSS</a>。</p><p>上面介绍的简历都以文本为主，如果想要展示图文内容的话，推荐使用 HTML 简历，它可以更详细和直观地演示项目经历等。做好之后部署到 Github Pages 上，并将地址附在 PDF 简历上。</p><p>✍🏻</p><h2>4. 模版</h2><h2>4.1 Markdown-Resume</h2><p>这里提供一下笔者制作的 Markdown 简历模版：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/CyC2018/Markdown-Resume\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Markdown-Resume</a>，clone 到本地，然后使用 Typora 等编辑器修改，并导出成 PDF。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-16dc0905257ed617540c387820020e03_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb\" width=\"1062\" data-original=\"https://pic4.zhimg.com/v2-16dc0905257ed617540c387820020e03_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1062&#39; height=&#39;603&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1062\" data-original=\"https://pic4.zhimg.com/v2-16dc0905257ed617540c387820020e03_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-16dc0905257ed617540c387820020e03_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>4.2 Mobirise</h2><p>笔者的 <a href=\"https://link.zhihu.com/?target=https%3A//cyc2018.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTML 简历</a> 主要使用  <a href=\"https://link.zhihu.com/?target=https%3A//mobirise.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Mobirise</a> 搭建，它是免费的站点生成器，不需要 HTML 等前端知识就可以使用，基本上拖一拖组件就能搭好一个很好看的 HTML 页面。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6249eea2e1cf85450524350aaf05a771_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"577\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-6249eea2e1cf85450524350aaf05a771_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;577&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"577\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-6249eea2e1cf85450524350aaf05a771_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6249eea2e1cf85450524350aaf05a771_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果简历上有很多 GIF 图片，刚进去的时候 GIF 加载不完全的话演示效果特别不好，所以笔者的 HTML 简历增加了一个加载页用来加载图片。加载页没办法使用 Mobirise 来实现，需要有一定的前端基础。</p><p>✍🏻</p><h2>5. 内容</h2><p>必须写的内容：</p><ul><li>姓名相当于你的 ID，应该把姓名放在最显眼的地方。</li><li>为了方便 HR 联系你，也要把联系信息也放在和姓名一样显眼的位置。</li><li>个人博客和 Github 等技术社区账号可以作为加分项。</li><li>教育经历和工作经历按年份逆序来写。</li><li>项目经历可以写科研项目、个人项目、实习和工作项目。</li><li>技能清单最好可以让人一眼就看出你的熟练度，可以使用精通、熟悉、了解等词语，也可以使用 ★★☆ 这种图标。</li></ul><p>需要谨慎考虑的内容：</p><ul><li>有些企业会根据性别、年龄等信息筛选人，最好写上，不写也没什么关系。</li><li>工作经验和期望薪资对于校招生来说不需要写，但是社招生就一定要写。</li><li>只写可以给企业带来价值的兴趣爱好，其它的无关兴趣爱好不要写。</li><li>和技术相关的大赛获奖经历可以写，但是其它一些比赛获奖就不要写。</li><li>三好学生、奖学金、四六级成绩、绩点可以写，以证明你的学习能力，但是尽量不要占太多行，如果不是特别好的话也可以不写。</li><li>个人评价如果要写的话不要太空泛，什么热爱学习吃苦耐劳等就不要写了，要写得话可以写在最后当做是简历其它内容的总结。</li></ul><p>✍🏻</p><h2>6. 排版</h2><p>虽然内容比排版重要，但是好的排版会让人看着舒服，也就会让面试官和 HR 更愿意去发现你的价值。</p><ul><li>中文和数字英文之间加空格，因为中文的字体排版和数字英文的有很大不同，数字英文偏小一些。如果不加空格的话，那么整篇文章看着会非常密集杂乱，中文和数字英文混在一起参差不齐。</li><li>专有名词一定要保证大小写完全正确，例如使用 Java 而不是 java，jQuery 而不是 Jquery。</li><li>内容也应该注意对齐，否则会很乱。</li><li>最重要的是不要太花哨，尽量简洁。</li></ul><p>✍🏻</p><h2>7. 项目介绍</h2><p>前面讲到项目经历一方面可以用于匹配技能，另一方面也可以通过你在项目中解决的问题来展示你的能力。可以按照下面的步骤介绍项目：</p><ul><li>为什么做这个项目；</li><li>项目有哪些功能；</li><li>你在项目中担任的角色；</li><li>碰到了哪些问题；</li><li>使用什么方式去解决问题的；</li><li>解决效果是怎样，和别人相比有什么优势。</li></ul><p>不要用太过主观的语言，而是用数据等客观事实。比如介绍碰到的问题时，不要用“非常难解决”等词语，而是用“并发用户数达到XXX导致响应时间增加到XXX”等数据。</p><p>也不要堆叠无意义的技术名词，比如“基于 Spring、SpringMVC、Hibernate 实现了 XXX 系统，包含增删查改等功能”。</p><h2>原文链接</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xiaozhuanlan.com/topic/5039476182\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xiaozhuanlan.com/topic/</span><span class=\"invisible\">5039476182</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655579", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 8, 
            "title": "从春招惨败到秋招收获 BAT OFFER", 
            "content": "<p>🚀</p><h2>1. Offer 情况</h2><p>经过了长达一年左右的复习，秋招也收到了几个比较满意的 Offer，参加面试的都通过了。</p><ul><li>百度，企业智能平台； </li><li>阿里，高德地图； </li><li>腾讯，IEG 游戏平台，后台研发，SP； </li><li>字节跳动，头条后台研发，SSP； </li><li>华为，Cloud Bu； </li><li>网易游戏，梦幻事业部； </li><li>顺丰科技。 </li></ul><p>🚀</p><h2>2. 前期准备</h2><p>也是在去年十一月份左右，看着身边两年制的同学经历了长时间而又艰难的秋招，我开始意识到自己应该提前准备了，否则自己的秋招会很惨。</p><p>本科的时候，虽然学过计算机网络、操作系统和数据结构等课程，而且 Leetcode 也刷了一两百题，但是离招聘要求还差的很远，学的都很浅只够应付考试，也没有实际的项目经验。</p><p>我的研究生方向是计算机图形学，研究生期间主要做一些科研项目。在选择招聘方向的时候，我也纠结了是不是找图形学相关方向的，但是考虑到图形学的选择不是很多，所以还是决定投后台研发相关的岗位。</p><p>于是开始收集各种学习资料，也买了很多纸质书。最开始的学习效率并不是很高，很迷茫，觉得要学的内容很多无从下手。那时候看别人的面经，感觉自己太弱了，很多内容都没接触过，于是更加迷茫。迷茫的时候总想着逃避，要是不复习多好，玩玩游戏每天多简单。但是游戏玩的越多，那种焦虑感越是强烈。解决焦虑的唯一办法就是想办法解决当前问题。当慢慢地从消极的学习态度中调整过来，掌握的知识越多，那种焦虑感也随之消失。当然这个过程并不容易，不仅需要很好的毅力，也要根据自身情况找到问题的有效解决方法。</p><p>🚀</p><h2>3. 春招</h2><h2>3.1 春招开始</h2><p>三月份各个公司就开始春招了，那时候刚把一些基础知识简单地复习了一下，Leetcode 刷到了三四百题。但是没有后台研发相关的项目，于是花了一个星期左右用 PHP 做了一个微博系统。当时做简历特别痛苦，没内容可以写，看着其他人简历各种新技术，自己都没掌握，所以很虚。</p><h2>3.2 阿里一轮游</h2><p>最开始投的阿里，实验室大几届有个师兄在天猫精灵团队，所以给我内推了。于是我人生中第一场面试就是阿里，很自然地被虐了一遍。记得当时约好下午两点电话面试，午饭都没吃，怕吃完之后犯困影响状态，然后找了一个很安静又没人的地方呆到了两点，调整自己的状态。可是面试官突然打电话来说有个会议要开，所以推迟了大概一个小时。苦苦等到三点左右，面试正式开始，不出所料面得非常糟糕。首先自己表述的很有问题，很多内容没回答到关键点上，自己会的内容也不怎么继续扩展回答。其次知识掌握得确实不够，连线程安全、ThreadLocal、函数式编程都不会。虽然被虐的很惨，但是也有好处，知道了面试到底是怎样的，自己还有哪方面的不足，该怎么准备。</p><h2>3.3 腾讯被鞭尸</h2><p>第二场面试是腾讯，在经历了阿里的面试之后，并且又继续复习了一段时间，我对面试就比较有信心了。一面其实回答的挺理想的，虽然很多问题没有立马回答出来，但是经过面试官的耐心提示之后都能回答一些内容。当时面了一个半小时，面试体验特别好。印象比较深刻的题目有，阅读一个 Redis 源码，分析存在哪些问题。其实就是一个计数器实现的限流算法，会有临界值的问题，但是当时没回答出来，只能听面试官给我解释。还有一个微信扫二维码，这个过程发生了什么，也没回答得很好，不过面试官也很耐心地纠正我回答上的错误。一面顺利通过了，但是总监面挂了。总监面没有问什么技术问题，就是问了问项目和职业规划。自己的项目确实比较 Low，我自己在介绍的时候也说得很不堪。职业规划我说自己希望在一些方面深入学习，因为自己现在在这些方面还很薄弱... 面完之后我就知道挂了，因为整个面试过程我都特别虚，还主动说自己技术能力不行。不出所料，面完的当天晚上，状态变成了不合适。</p><p>但是过了几天，突然收到腾讯的电话，问我是否愿意去深圳参加面试（笔者学校在广州）。当然我毫不犹豫地答应了，很开心腾讯还能给我机会。经过了上一场面试的启示，这次面试我表现地非常自信，自己知道的知识都很有信心地表达出来，被问到不会的内容也不会那么慌张，和面试官探讨一些细节，然后说说自己的想法，还有自己看过相关的内容。由于这是腾讯云部门，对 Linux 内核和 C++ 有很高的要求，问了几个相关的问题我都没回答出来，比如如何实现守护进程，Linux 信号机制，Linux 线程的不可中断阻塞状态如何进入等等。除了这些问题，其它地回答的都还行。遗憾的是，当天晚上面试官打电话告知我面试没通过。但是他说我其它方面都很不错，所以问我愿不愿意参加腾讯云 Java 部门的招聘，于是第二天我又去了一个新的部门面试。</p><p>这次面试是在部门的会议室进行的，进到公司之后说实话没有自己想象中那么好，工位很挤环境一般。一开始就先随便聊聊，学校的研究工作，学习之类的。然后看了看项目，看完之后我就知道凉了一半，这个项目确实太水了，面试官看了之后没有接着问，也能感受到面试官有点嫌弃。然后他就问了一些基础知识，问到进程调度算法，面试官让我实现一个任务调度系统。因为是第一次手写代码，而且之前确实没考虑过这个问题，然后就胡乱写了一堆代码，特别乱，而且到处涂改。显然面试官是不满意的，写了也有十几分钟之后，我自己都知道已经凉了，然后面试官没让我接着写，也没给我任何提示，说就到这里，面试结束了，还有没有什么问题想问的。当然看过任务调度系统相关的文章会觉得挺容易的，比如使用时间轮实现等等。我依然记得面试官送我出门时候的热情，送我坐电梯的时候还很热情地和我说，非常感谢参加本次面试，辛苦了。</p><h2>3.4 虎牙过于自信</h2><p>经过了阿里和腾讯的面试之后，我觉得自己大概已经知道该怎么面试了，面试时候该注意什么，该怎么表达等等。而且腾讯面试表现也不差，虽然最后没通过。所以在虎牙面试的时候特别放松，觉得应该能通过。前面面的也都还行，虽然有几个问题没回答好，比如分析一下微博的时间线。通过了第一轮面试直接等第二轮，等到了晚上七点多才等到我。虎牙面试还是很注重技术的，虽然问的都不是很深入，只要简单回答到点上就不会接着问下去。二面也有一些问题没回答好，比如 ConcurrentHashMap 的并发机制，问 Spring 直接说不会。也有一些问题回答得比较乱，没有条理。但是我觉得大部分问题都回答的不错，应该能通过。可是面试完之后，面试官问有没有什么问题要问他，由于太过放松，我就问你们都加班到这么晚不吃饭吗，好饿啊，周六周日还加班吗... 问完之后面试官就很严肃了，说平常不加班的，我突然意识到了问题的严重性... 最后还是凉了。</p><h2>3.5 百度第一个 Offer</h2><p>被三家连续拒了之后，都开始怀疑自己了，不过还是提醒自己要保持信心。</p><p>幸运的是，百度的面试非常适合我，三轮都是技术面，而且手写算法题目居多，而我准备最多的是算法，所以很顺利通过了面试。但是面试表现并没有特别好，过了比较长的时间才被捞，而且是工程效率部门，做内部工具的，对个人成长并不好，所以不是特别满意。</p><h2>3.6 网易游戏最好的面试体验</h2><p>其实最开始没有打算投网易游戏的，因为被脉脉洗脑，已经放弃了做游戏。但是因为前面面试基本被拒了，担心没有实习 Offer，因此就试试看。</p><p>因为没有特别想去网易游戏，所以面试过程也比较放松，就当去聊聊天。面试官非常 nice，那天下午挤了很久地铁，比较口渴，然后面试官看我说得沙哑了，到门口帮我买了一瓶可乐，非常感激。面试之前我就提出我对 C++ 不熟悉，最近主要看 Java 的内容。面试官还是说没关系，尽量回答就好。当然最后我都把问题往 Java 那里回答了，比如 Map 的实现，内存管理等等。最后聊了一些玩过的游戏，就让我回去等消息。网易游戏就一轮面试，确实就一轮。周五参加的面试，下周一就给 Offer 了，效率特别高。</p><h2>3.7 微众玄学面试</h2><p>通过微众面试我自己都非常吃惊，一面的时候就简单自我介绍了一下，然后面试官开始介绍他自己的工作经历，以及现在部门在做的内容。之后问了我一个场景分析问题，我想了一会儿没想出来，于是面试官拿起草稿纸把各种需求详细说了一遍，然后把系统架构图也画了出来... 最后他问还有什么我优势的地方他没问到的，我问他怎么不问问算法题，他说笔试都通过了没必要再问。面完之后我觉得聊得很开心，但是技术问题没回答好，出乎意料收到了二面通知。二面没问技术，就让介绍了项目，再问问家住哪之类的问题，也顺利通过了。HR 面就不用介绍。收到了微众的 Offer，得知了部门是贷款科技部，非常核心，很吃香，近几年也在扩展一些业务，还是有点小心动的。虽然最后没选择去微众实习，但是一面面试官加了我微信，我很感谢他一面非常耐心给我讲解，并让我通过。他说我是他面试的第一顺位，也就是第一个面试者，所以会放宽很多，也希望我秋招能加入他们。</p><h2>3.8 实习选择</h2><p>其实最理想的是去百度实习，秋招也会容易很多。但是考虑到百度是在北京，部门很边缘，而且需要实习很长时间也不一定能转正，所以还是放弃了。最后只能在网易游戏和微众选，虽然自己不想做游戏，但是考虑到网易游戏的平台认可程度比微众好，秋招肯定会更容易一些。而且秋招如果还想进微众的话也会比较容易，因为面试官和 HR 都说秋招的时候会优先考虑我，所以最后还是去了网易游戏实习。</p><h2>3.9 实习之前的快速学习期</h2><p>经历了春招之后，认识到了自己身上的不足，比如交流表达能力的欠缺，知识积累得不够，项目深度不够。因此在实习之前的两三个月，开始针对这些问题逐个解决。</p><ul><li>交流表达能力欠缺，就提前准备好各种非技术问题，然后对着镜子回答，把自己当成听众，并且也用录音机录下来。 </li><li>知识积累不够，采取的策略是保证广度优先，并且在重要的内容上保证深度。其实之前基础知识已经掌握的比较好了，再学其它技术的时候都有很多相同的地方，所以学起来很快。 </li><li>项目深度不够，就把那个微博系统做了一点改进，学了 Spring 之后改用 Java 实现。 </li></ul><h2>3.10 不那么安心的实习</h2><p>去实习的时候还是挺惊喜的，因为我被安排的工作是游戏引擎相关的，和自己的研究生方向紧密相关，我觉得做完实习项目之后自己的毕业论文也会比较有灵感。</p><p>但不幸的是，在去的第一天部门接待聚餐上，服务端主程就说，我们部门工作制是九九六，现在互联网都是九九六。在实习之前我了解的是实习生六点就可以走，而且只用上五天班，听到他这么一说心都凉透了，因为已经想好了晚上和周末时间用来复习。如果知道是九九六，我会选择去百度。</p><p>其实网易游戏部门氛围还是不错的，对员工很好，而且我的实习导师人也很好，在我生病的那几天很关心我。但是九九六的工作制对秋招复习还是有很大影响的，而且每天上下班花在路上的时间超过了两个小时，下班回寝室之后总想着看会儿视频休息一下，然后又要早早睡觉赶着第二天上班。没办法只能在上下班地铁上复习，还有就是午休时间接着复习。</p><p>🚀</p><h2>4. 秋招</h2><h2>4.1 秋招开始</h2><p>实习之后已经是九月份了，那时候已经错过了所有提前批。而且实习的时候没怎么复习，九月初还是感觉没怎么准备充分，所以就又等了半个月才开始投简历。</p><p>但是这个时候和春招相比，已经把大部分后台研发相关的知识点过了一遍，很多重要的内容前前后后也看了十几遍，没有春招时候那么迷茫和焦虑。即使被问到没有掌握的知识，我也有把握通过讨论的方式，给出大概的思路，因为很多技术确实是相通的。</p><h2>4.2 阿里看不懂的内部流程</h2><p>秋招第一个投递的依然是阿里，最开始系统自动发起了一个新的流程，然后过了几天自动回绝了... 八月末的时候也找人内推了，但是又被阿里直接回绝了... 那时候已经觉得可能是春招面试表现太差，此生无缘阿里了。可是过了一段时间，正式校招的时候，阿里又发起了一个新的流程戏弄我，收到笔试通知的时候，我还犹豫了到底参不参加，因为那时候已经九月中旬，听说阿里已经没有 HC 了。而且按前面回绝我的态度，感觉即使笔试通过面试也通过不了。笔试那天晚上，本来准备看个电影放松一下，后来想了想还是参加了笔试，笔试各种机器学习和数学题，感觉拿错了试卷，笔试完我已经把阿里从我的公司进度列表中删除了，不再纠结阿里。可是过了一段时间收到阿里的面试通知，我以为是走走形式，可能参加笔试的人很少了，所以才选中我参加面试。那时候阿里招聘官网状态一排的已回绝，让我对阿里有一种恐惧感，觉得面试肯定挂。但是真正面试的时候却意外的顺利，收到二面通知的时候特别激动，然后面完二面又让直接等 HR 面，HR 面虽然不是很理想，但是没有很大的问题。又过了很长一段时间，在我去深圳参加腾讯招聘的高铁上，收到了高德地图 HR 的电话，问是否愿意去。虽然得知部门在北京有点小失落，但是还是很开心终于被阿里认可了，摆脱了对阿里的恐惧。</p><p>实验室上届毕业在阿里云的大佬某天突然和我说，他们部门有新的 HC，让我把简历发给他，他要帮我内推，会帮我安排一场线下面试，如果通过的话，到时候和高德的 HR 沟通一下，直接把我从高德捞过来。很感谢大佬向他老大极力推荐我，给我了这次面试机会。线下面试也很顺利，聊聊实习项目，问问我的开源博客，然后问些 Paxos 等分布式的问题，还有就是手写代码，信号量实现生产者消费者，以及一个位运算的问题。其实位运算的问题面试的时候写的不完善，面试官让我之后完善了再发给他，因为面试一个多小时有点长了。过后我写了详细文档讲解了思路，以及使用 JUnit 进行了详细的单元测试，把文档和代码都发给了他。现在面试已经通过了，但是最近阿里集团 HC 比较紧张，也不知道能不能批到 HC。</p><h2>4.3 百度又是不那么满意的部门</h2><p>虽然阿里是最先开始流程，但是第一个参加面试的是百度。因为实习的时候通过了百度的面试，所以这次面试还是比较有信心的。百度面试连续三天，都在同一个地方，最后签约也在同一个地方。还记得每次都坐一个小时左右的地铁去那里，路线已经非常熟悉了，和每天去实习的感觉类似。百度面试比较注重技术，三轮面试基本都是问技术问题，而且问的也比较深入，内容也非常广。但是面的不是那么理想，有两点原因，首先是因为确实有些知识点还没掌握好，比如 AC 自动机，系统故障分析等等；其次是对实习项目的描述上还不够好，没有把实习内容的闪光点描述出来，也没有讲清楚为什么做这个项目，自己通过什么方法去做，以及最后的结果。</p><p>最后百度给了白菜价，部门是企业智能平台，主要是内部系统，虽然会接触到机器学习和大数据。</p><h2>4.4 腾讯虐我千百遍</h2><p>秋招腾讯第一场面试和实习参加腾讯面试的感觉非常像，第一轮技术面感觉很好，手写堆排序算法，二部图分析等等。面完之后通知待会儿二面，听到之后还是很激动的，觉得这次应该没问题了。我在等二面的时候，碰到了室友（他经常不住宿舍，所以不清楚他也去面试），聊着聊着居然发现我两是同一个面试官，而且他是来二面的，也就是等一下我两就要一前一后进去面试。二面的感觉和实习二面非常像，非技术问题回答的支支吾吾，然后面试官开始质疑我说的内容，给我压力，我没有当场反驳，就说了哦，好像是这样的。因为面试官全程都绷着脸，所以我也比较紧张，很多问题没回答好。过了几天，室友和我说收到 HR 面试通知了，我去官网看了一下状态，已经变成了熟悉的不合适。这次面试失败的主要原因是自己在应对这种压力时处理地不是很好，主要体现在失去信心以及紧张。解决方法也简单，做好充分准备来保持信心，受到质疑的时候积极反驳，紧张的时候计时调整心态，可以试试深呼吸或者喝水。</p><p>因为实习有被捞起来的经历，所以被拒之后我特别希望能继续被捞起来，然后把简历上的面试城市改成了深圳。苦苦等到深圳场面试的前几天，在不经意的一个下午手机突然响了，我记得是短信邮件同时收到面试通知。于是又开始了新一轮被腾讯虐的面试之旅。</p><p>一面和之前一样也是意外地顺利，虽然问了一些 C++ 的问题，但是我都说到 Java 相关的实现上。在一些问题上确实回答的深度不够，比如网络编程里面的水平触发和边缘触发等问题。然后问了几个算法，本来要求手写，我说我实现过，所以就讲了讲思路。面试和腾讯第一场面试一样持续了一个半小时，面试官也很好，很多问题都会给提示，即使最开始回答的有问题。二面面试官也很好，问了问实习项目，然后再聊一聊一些技术，经过了之前的面试，到这次面试真的就像在聊天一样而不是面试，我们都会说一些对技术上的理解。HR 面其实面得很差，对于非技术问题的吹水能力我还是不太行。最终和我预期的一样，给了我 SP 的 Offer，因为觉得自己面得还可以，但是也不够好到给 SSP，有些 C++ 问题还是没回答的特别好。</p><h2>4.5 头条意外的惊喜</h2><p>之前看到学弟收到头条的 Offer，薪资非常诱人，所以也想去试试。也听说头条面试难度非常大，主要考察手写算法，因为自己算法方面准备得比较充分，所以觉得会比较顺利，但是也没有特别高的预期。前两面中规中矩，算法题和其它问题我都回答的比较好，到三面的时候，问了一个错排问题，其实最开始我给了正确的递推公式，但不是面试官想要的答案，所以让我再想想。我想了十几分钟还是觉得没问题，那时候觉得自己已经凉了，因为面试官一直不满意。后面的几个问题也没回答的很好，分析一个 SQL 语句的具体执行过程，比如会怎么利用索引，怎么优化之类的，虽然在他的提示下还是回答了，但是感觉并不好。面完之后我立马查了一下那个错排问题，证实了我的答案是正确的，于是写了一个详细的文档，联系 HR 让她发给面试官。出乎意料的是，HR 让我不用担心，他说面试官对我的评价很好... 不过最后还是让她把文档发给了面试官。之后收到了加面通知，头条加面有两种情况，一是三轮评级都是 4 可以评 SSP，二是面试官评价差别很大，再面一轮决定是否录用。收到加面的时候完全不知道自己属于哪一种，感觉两种情况都有可能。加面回答的也不好，主要是问项目，面了 25 分钟就草草结束，最后面试官说有些内容需要找一些文献参考参考。面完之后我觉得，即使我属于第一种要评 SSP 的情况，加面面的那么差应该也没希望了。苦苦等了好多天之后，最后确定是 SSP 之后，还是很惊喜的，感觉是对自己这么长时间复习的一个认可。</p><h2>4.6 顺丰最后的保底</h2><p>投顺丰是因为九月中旬很多公司都结束了招聘，所以那时候比较慌，就投了顺丰当做保底，顺便也练练手。最开始还担心顺丰笔试没通过，因为编程题最后一题没做出来，那题的题目都出错了，而且题目是网上直接 copy 过来的，网上的源码都不能通过，更别说我自己的实现了。顺丰面试主要问了数据库的内容，而且问的特别深，几乎把每种日志的实现和作用都问了一遍。面顺丰的时候也比较早，那时候有些问题的回答上没有组织好，回答得比较凌乱，虽然最后也算给了一个小 SP。</p><h2>4.7 华为特别纠结的部门</h2><p>去华为面试确实是没有压力的，因为都知道华为面试不怎么问技术，虽然还是问了我一些技术问题，不过不是问的很深。面试主要介绍项目，我对自己的实习项目还是比较有信心的，因为觉得做的确实不错，而且面了很多场了，知道该怎么介绍项目。面试官问我个人意愿，我说自己对分布式中间件等比较感兴趣，于是面试官把我推荐到了 Cloud Bu。本来没打算签华为的，现场签约也就去看看到底给我开多少。最开始其实给我开了十四级最高的薪资，我本来不是很想去，虽然对这个部门感兴趣，但是薪资确实比不上头条。然后随口问了一句可不可以给十五级，本来 HR 说是可以试着申请一下，不过最后没申请成功。</p><p>🚀</p><h2>5. 小结</h2><p>很多人都说，面试和考试一样，要背很多没用的东西。最开始我也认同这种看法，可是参加了几场面试之后，我就不这么认为了。因为面试出的问题，有很多是实际开发中碰到的，所以准备面试相当于提前做入职准备。而且面试中考察的思维能力、交流表达能力、应对压力能力，都是真正工作中所需要的。</p><p>我觉得自己比别人做的好的地方是，有很强烈的想找到好工作的意愿，才驱使我不断学习，所以态度很重要。</p><p>信心源自于充分准备，有了信心，面试的时候才能游刃有余。而毫无依据的自我感觉良好，在每次失败之后都看不到自身的不足，而是怪罪于外界因素。</p><p>做好自己的简历，我在简历上花了很长时间，只要允许，我都会用这个简历给面试官演示：<a href=\"https://link.zhihu.com/?target=https%3A//cyc2018.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">个人简历</a>。</p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655484", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 6, 
            "title": "一文帮你理清面试知识点", 
            "content": "<p>⭐️</p><h2>1. 前言</h2><p>面试考察的知识点多而杂，要完全掌握需要花费大量的时间和精力。但是面试中经常被问到的知识点却没有多少，你完全可以用 20% 的时间去掌握 80% 常问的知识点。在这里我将这 80% 常问的知识点整理出来，方便大家快速地掌握。这些知识点也标注了重要程度，从而让大家可以根据知识点的重要程度去制定学习计划。</p><p>如果你想更好的学习这些知识点，可以参考 <a href=\"https://link.zhihu.com/?target=https%3A//xiaozhuanlan.com/topic/4150387926\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">知识总结方法</a> 一文，这篇文章的最后给出了比本文更详细的思维导图。</p><p>下图列出了面试考察的九大知识点，也标出了重要程度和复习难度。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0d02c6abbff188420801c11dc54945e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1071\" data-rawheight=\"481\" class=\"origin_image zh-lightbox-thumb\" width=\"1071\" data-original=\"https://pic2.zhimg.com/v2-0d02c6abbff188420801c11dc54945e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1071&#39; height=&#39;481&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1071\" data-rawheight=\"481\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1071\" data-original=\"https://pic2.zhimg.com/v2-0d02c6abbff188420801c11dc54945e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0d02c6abbff188420801c11dc54945e1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其实重要程度根据不同的公司会有所不同，针对上图做一下几点说明：</p><ul><li>分布式与系统设计部分对于大厂面试来说至关重要，但是小厂面试考察的会少一点。</li><li>语言基础部分，阿里喜欢问 Java、腾讯喜欢问 C++，其它大厂面试考察会少一些，小厂面试会考察多一些。</li><li>数据库、中间件和框架部分对于大厂面试来说不是那么重要，但是对于小厂面试会重要一些。</li></ul><p>最后再说一下项目部分，它在实习招聘阶段中不是特别重要，但是在校园招聘阶段重要程度会增高。但是如果你的学历不好，而且没有博客、开源项目、竞赛等加分项，那么最好做个比较出色的项目来增加简历通过率。</p><p><br/>💻 </p><h2>2. 操作系统</h2><h2>2.1 基础</h2><ul><li>★★★  进程与线程的本质区别、以及各自的使用场景。</li><li>★☆☆ 进程状态。</li><li>★★★ 进程调度算法的特点以及使用场景。</li><li>★☆☆ 线程实现的方式。</li><li>★★☆ 协程的作用。</li><li>★★☆ 常见进程同步问题。</li><li>★★★ 进程通信方法的特点以及使用场景。</li><li>★★★ 死锁必要条件、解决死锁策略，能写出和分析死锁的代码，能说明在数据库管理系统或者 Java 中如何解决死锁。</li><li>★★★ 虚拟内存的作用，分页系统实现虚拟内存原理。</li><li>★★★ 页面置换算法的原理，特别是 LRU 的实现原理，最好能手写，再说明它在 Redis 等作为缓存置换算法。</li><li>★★★ 比较分页与分段的区别。</li><li>★★★ 分析静态链接的不足，以及动态链接的特点。</li></ul><h2>2.2 Linux</h2><ul><li>★★☆ 文件系统的原理，特别是 inode 和 block。数据恢复原理。</li><li>★★★ 硬链接与软链接的区别。</li><li>★★☆ 能够使用常用的命令，比如 cat 文件内容查看、find 搜索文件，以及 cut、sort 等管线命令。了解 grep 和 awk 的作用。</li><li>★★★ 僵尸进程与孤儿进程的区别，从 SIGCHLD 分析产生僵尸进程的原因。</li></ul><p><br/>☁️ </p><h2>3. 网络</h2><h2>3.1 基础</h2><ul><li>★★★ 各层协议的作用，以及 TCP/IP 协议的特点。</li><li>★★☆ 以太网的特点，以及帧结构。</li><li>★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。</li><li>★★☆ IP 数据数据报常见字段的作用。</li><li>★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。</li><li>★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。</li><li>★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。</li><li>★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。</li><li>★★★ 可靠传输原理，并设计可靠 UDP 协议。</li><li>★★☆ TCP 拥塞控制的作用，理解具体原理。</li><li>★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。</li></ul><h2>3.2 HTTP</h2><ul><li>★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。</li><li>★★☆ HTTP 状态码。</li><li>★★★ Cookie 作用、安全性问题、和 Session 的比较。</li><li>★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。</li><li>★★★ 长连接与短连接原理以及使用场景，流水线。</li><li>★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。</li><li>★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。</li><li>★★★ HTTP/1.1 的特性。</li><li>★★☆ HTTP 与 FTP 的比较。</li></ul><h2>3.3 Socket</h2><ul><li>★★☆ 五种 IO 模型的特点以及比较。</li><li>★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。</li></ul><p><br/>💾 </p><h2>4. 数据库</h2><h2>4.1 SQL</h2><ul><li>★★☆ 手写 SQL 语句，特别是连接查询与分组查询。</li><li>★★☆ 连接查询与子查询的比较。</li><li>★★☆ drop、delete、truncate 比较。</li><li>★★☆ 视图的作用，以及何时能更新视图。</li><li>★☆☆ 理解存储过程、触发器等作用。</li></ul><h2>4.2 系统原理</h2><ul><li>★★★ ACID 的作用以及实现原理。</li><li>★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。</li><li>★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。</li><li>★★★ 乐观锁与悲观锁。</li><li>★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。</li><li>★★☆ 范式理论。</li><li>★★★ SQL 与 NoSQL 的比较。</li></ul><h2>4.3 MySQL</h2><ul><li>★★★ B+ Tree 原理，与其它查找树的比较。</li><li>★★★ MySQL 索引以及优化。</li><li>★★★ 查询优化。</li><li>★★★ InnoDB 与 MyISAM 比较。</li><li>★★☆ 水平切分与垂直切分。</li><li>★★☆ 主从复制原理、作用、实现。</li><li>★☆☆ redo、undo、binlog 日志的作用。</li></ul><h2>4.4 Redis</h2><ul><li>★★☆ 字典和跳跃表原理分析。</li><li>★★★ 使用场景。</li><li>★★★ 与 Memchached 的比较。</li><li>★☆☆ 数据淘汰机制。</li><li>★★☆ RDB 和 AOF 持久化机制。</li><li>★★☆ 事件驱动模型。</li><li>★☆☆ 主从复制原理。</li><li>★★★ 集群与分布式。</li><li>★★☆ 事务原理。</li><li>★★★ 线程安全问题。</li></ul><p><br/>🎨 </p><h2>5. 面向对象</h2><h2>5.1 思想</h2><ul><li>★★★  面向对象三大特性</li><li>★☆☆ 设计原则</li></ul><h2>5.2 设计模式</h2><ul><li>★★☆ 设计模式的作用。</li><li>★★★ 手写单例模式，特别是双重检验锁以及静态内部类。</li><li>★★★ 手写工厂模式。</li><li>★★★ 理解 MVC，结合 SpringMVC 回答。</li><li>★★★ 理解代理模式，结合 Spring 中的 AOP 回答。</li><li>★★★ 分析 JDK 中常用的设计模式，例如装饰者模式、适配器模式、迭代器模式等。</li></ul>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": [
                {
                    "userName": "19205", 
                    "userLink": "https://www.zhihu.com/people/1d217c80a62619084cc89f6c7e1735cd", 
                    "content": "非常感谢", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "凌悠然", 
                    "userLink": "https://www.zhihu.com/people/5720e70aa75615e3fb66afeff870c51d", 
                    "content": "<p>好专业</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655630", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 0, 
            "title": "海量数据处理思路", 
            "content": "<h2>1. 计算容量</h2><p>在解决问题之前，要先计算一下海量数据需要占多大的容量。常见的单位换算如下：</p><ul><li>1 byte = 8 bit</li><li>1 KB = 210 byte = 1024 byte ≈ 103 byte</li><li>1 MB = 220 byte ≈ 10 6 byte</li><li>1 GB = 230 byte ≈ 10 9 byte</li><li>1 亿 = 108</li></ul><p>1 个整数占 4 byte，1 亿个整数占 4*108 byte ≈ 400 MB。</p><h2>2. 拆分</h2><p>可以将海量数据拆分到多台机器上和拆分到多个文件上：</p><ul><li>如果数据量很大，无法放在一台机器上，就将数据拆分到多台机器上。这种方式可以让多台机器一起合作，从而使得问题的求解更加快速。但是也会导致系统更加复杂，而且需要考虑系统故障等问题；</li><li>如果在程序运行时无法直接加载一个大文件到内存中，就将大文件拆分成小文件，分别对每个小文件进行求解。</li></ul><p>有以下策略进行拆分：</p><ul><li>按出现的顺序拆分：当有新数据到达时，先放进当前机器，填满之后再将数据放到新增的机器上。这种方法的优点是充分利用系统的资源，因为每台机器都会尽可能被填满。缺点是需要一个查找表来保存数据到机器的映射，查找表可能会非常复杂并且非常大。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-35181f347a8ed9b55dfd35a640da3045_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"819\" data-original=\"https://pic2.zhimg.com/v2-35181f347a8ed9b55dfd35a640da3045_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;819&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"819\" data-original=\"https://pic2.zhimg.com/v2-35181f347a8ed9b55dfd35a640da3045_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-35181f347a8ed9b55dfd35a640da3045_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>按散列值拆分：选取数据的主键 key，然后通过哈希取模 hash(key)%N 得到该数据应该拆分到的机器编号，其中 N 是机器的数量。优点是不需要使用查找表，缺点是可能会导致一台机器存储的数据过多，甚至超出它的最大容量。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3b09df5a675ef78513fbbf1e5292033b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"519\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb\" width=\"519\" data-original=\"https://pic4.zhimg.com/v2-3b09df5a675ef78513fbbf1e5292033b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;519&#39; height=&#39;448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"519\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"519\" data-original=\"https://pic4.zhimg.com/v2-3b09df5a675ef78513fbbf1e5292033b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3b09df5a675ef78513fbbf1e5292033b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>按数据的实际含义拆分：例如一个社交网站系统，来自同一个地区的用户更有可能成为朋友，如果让同一个地区的用户尽可能存储在同一个机器上，那么在查找一个用户的好友信息时，就可以避免到多台机器上查找，从而降低延迟。缺点同样是需要使用查找表。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5088180544134f6c279f18956ebbf9f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"838\" data-original=\"https://pic2.zhimg.com/v2-5088180544134f6c279f18956ebbf9f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;838&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"838\" data-original=\"https://pic2.zhimg.com/v2-5088180544134f6c279f18956ebbf9f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5088180544134f6c279f18956ebbf9f5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>3. 整合</h2><p>拆分之后的结果还只是局部结果，需要将局部结果汇总为整体的结果。</p><h2>参考资料</h2><ul><li>程序员面试金典</li><li>程序员代码面试指南</li></ul><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655639", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "海量数据判重", 
            "content": "<h2>1. 问题描述</h2><p>对于海量数据，要求判断一个数据是否已经存在。这个数据很有可能是字符串，例如 URL。</p><h2>2. HashSet</h2><p>最直观的方法是使用 HashSet 存储，那么就能以 O(1) 的时间复杂度判断一个数据是否已经存在。</p><p>考虑到数据是海量的，那么就需要使用拆分的方式将数据拆分到多台机器上，分别在每台机器上使用 HashSet 存储。我们需要使得相同的数据拆分到相同的机器上，可以使用哈希取模的拆分方式进行实现。</p><h2>3. BitSet</h2><p>如果海量数据是整数，并且范围不大时，就可以使用 BitSet 存储。通过构建一定大小的比特数组，并且让每个整数都映射到这个比特数组上，就可以很容易地知道某个整数是否已经存在。因为比特数组比整型数组小的多，所以通常情况下单机就能处理海量数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f005559bd00ef0c295d8a23380811030_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"575\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"575\" data-original=\"https://pic1.zhimg.com/v2-f005559bd00ef0c295d8a23380811030_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;575&#39; height=&#39;266&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"575\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"575\" data-original=\"https://pic1.zhimg.com/v2-f005559bd00ef0c295d8a23380811030_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f005559bd00ef0c295d8a23380811030_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以下是一个 BitSet 的实现，当然在实际开发中可以直接使用语言内置的实现。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">BitSet</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">bitset</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">BitSet</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">bitset</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[(</span><span class=\"n\">size</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">5</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">];</span> <span class=\"c1\">// divide by 32\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kt\">boolean</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">pos</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">wordNumber</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">5</span><span class=\"o\">);</span> <span class=\"c1\">// divide by 32\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">bitNumber</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">&amp;</span> <span class=\"n\">0x1F</span><span class=\"o\">);</span> <span class=\"c1\">// mod 32\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">bitset</span><span class=\"o\">[</span><span class=\"n\">wordNumber</span><span class=\"o\">]</span> <span class=\"o\">&amp;</span> <span class=\"o\">(</span><span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">bitNumber</span><span class=\"o\">))</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">set</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">pos</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">wordNumber</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">5</span><span class=\"o\">);</span> <span class=\"c1\">// divide by 32\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">bitNumber</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">pos</span> <span class=\"o\">&amp;</span> <span class=\"n\">0x1F</span><span class=\"o\">);</span> <span class=\"c1\">// mod 32\n</span><span class=\"c1\"></span>        <span class=\"n\">bitset</span><span class=\"o\">[</span><span class=\"n\">wordNumber</span><span class=\"o\">]</span> <span class=\"o\">|=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">bitNumber</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>使用 BitSet 还可以很容易地解决一个整数出现次数的问题，例如使用两个比特数组就可以存储 0~3 的信息。其实判重问题也可以简单看成一个数据出现的次数是否为 1，因此一个比特数组就够了。</p><h2>4. 布隆过滤器</h2><p>布隆过滤器能够以极小的空间开销解决海量数据判重问题，但是会有一定的误判概率。它主要用在网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统。</p><p>布隆过滤器也是使用 BitSet 存储数据，但是它进行了一定的改进，从而解除了 BitSet 要求数据的范围不大的限制。在存储时，它要求数据先经过 k 个哈希函得到 k 个位置，并将 BitSet 中对应位置设置为 1。在查找时，也需要先经过 k 个哈希函数得到 k 个位置，如果所有位置上都为 1，那么表示这个数据存在。</p><p>由于哈希函数的特点，两个不同的数通过哈希函数得到的值可能相同。如果两个数通过 k 个哈希函数得到的值都相同，那么使用布隆过滤器会将这两个数判为相同。</p><p>可以知道，令 k 和 m 都大一些会使得误判率降低，但是这会带来更高的时间和空间开销。</p><p>布隆过滤器会误判，也就是将一个不存在的数判断为已经存在，这会造成一定的问题。例如在垃圾邮件过滤系统中，会将一个邮件误判为垃圾邮件，那么就收不到这个邮件。可以使用白名单的方式进行补救。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0539a327cb39d40d2c08f6c1ef7dc1b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-0539a327cb39d40d2c08f6c1ef7dc1b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;579&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-0539a327cb39d40d2c08f6c1ef7dc1b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0539a327cb39d40d2c08f6c1ef7dc1b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>5. Trie</h2><p>Trie 树又叫又叫字典树、前缀树、单词查找树，它是一颗多叉查找树。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。</p><p>如果海量数据是字符串数据，那么就可以用很小的空间开销构建一颗 Trie 树，空间开销和树高有关。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1537433edb77ac7e7c2acb935bec6dcb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"369\" data-rawheight=\"340\" class=\"content_image\" width=\"369\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;369&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"369\" data-rawheight=\"340\" class=\"content_image lazy\" width=\"369\" data-actualsrc=\"https://pic4.zhimg.com/v2-1537433edb77ac7e7c2acb935bec6dcb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/implement-trie-prefix-tree/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode : Implement Trie (Prefix Tree)</a></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Trie</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span><span class=\"o\">[]</span> <span class=\"n\">childs</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">[</span><span class=\"n\">26</span><span class=\"o\">];</span>\n        <span class=\"kt\">boolean</span> <span class=\"n\">isLeaf</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">();</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Trie</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">insert</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">isLeaf</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">indexForChar</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">));</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">childs</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">childs</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">insert</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">childs</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">search</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">word</span><span class=\"o\">,</span> <span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">isLeaf</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">indexForChar</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">));</span>\n        <span class=\"k\">return</span> <span class=\"n\">search</span><span class=\"o\">(</span><span class=\"n\">word</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">childs</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">startsWith</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">prefix</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">startWith</span><span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">,</span> <span class=\"n\">root</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">boolean</span> <span class=\"nf\">startWith</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">prefix</span><span class=\"o\">,</span> <span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">indexForChar</span><span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">));</span>\n        <span class=\"k\">return</span> <span class=\"n\">startWith</span><span class=\"o\">(</span><span class=\"n\">prefix</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">),</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">childs</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">indexForChar</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">c</span> <span class=\"o\">-</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>参考资料</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.abhishek-tiwari.com/bloom-filters-is-element-x-in-set-s/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Bloom Filters: Is element x in set S?</a></li></ul><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56655672", 
            "userName": "CyC2018", 
            "userLink": "https://www.zhihu.com/people/de0dbaba77411ee53dd3207d762ad7d5", 
            "upvote": 1, 
            "title": "TopK", 
            "content": "<h2>1. 问题描述</h2><p>TopK Elements 问题用于找出一组数中最大的 K 个的数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-03f3ac1546c4b95276b254078f524def_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"457\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb\" width=\"457\" data-original=\"https://pic4.zhimg.com/v2-03f3ac1546c4b95276b254078f524def_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;457&#39; height=&#39;152&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"457\" data-rawheight=\"152\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"457\" data-original=\"https://pic4.zhimg.com/v2-03f3ac1546c4b95276b254078f524def_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-03f3ac1546c4b95276b254078f524def_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此外还有一种叫 Kth Element 问题，用于找出一组数中第 K 大的数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a1334f36ce61864d8946fecca86d9418_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb\" width=\"463\" data-original=\"https://pic1.zhimg.com/v2-a1334f36ce61864d8946fecca86d9418_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;463&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"463\" data-original=\"https://pic1.zhimg.com/v2-a1334f36ce61864d8946fecca86d9418_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a1334f36ce61864d8946fecca86d9418_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其实要求解 TopK Elements，可以先求解 Kth Element，因为找到  Kth Element 之后，再遍历一遍，大于等于 Kth Element 的数都是 TopK Elements。</p><h2>2. 一般解法</h2><p>以 <a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/kth-largest-element-in-an-array/description/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Leetcode : 215. Kth Largest Element in an Array</a> 为例，这是一道的 Kth Element 问题，不过这道题要找的是从后往前第 K 个元素，而不是从前往后。为了能和传统的 Kth Element 问题一样求解，可以先执行 <code>k = nums.length - k;</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">Input: [3,2,1,5,6,4] and k = 2\nOutput: 5</code></pre></div><h2>2.1 快速选择</h2><p>快速排序的 partition() 方法，对于数组 nums 的 [l, h] 区间，会返回一个整数 k 使得 nums[l..k-1] 小于等于 nums[k]，且 nums[k+1..h] 大于等于 nums[k]，此时 nums[k] 就是数组的第 k 大元素。可以利用这个特性找出数组的 Kth Element，这种找 Kth Element 的算法称为快速选择算法。</p><ul><li>时间复杂度 O(N)、空间复杂度 O(1)</li><li>只有当允许修改数组元素时才可以使用</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0ead2d41286bf693418dd4a3819c686b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"475\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"475\" data-original=\"https://pic4.zhimg.com/v2-0ead2d41286bf693418dd4a3819c686b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;475&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"475\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"475\" data-original=\"https://pic4.zhimg.com/v2-0ead2d41286bf693418dd4a3819c686b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0ead2d41286bf693418dd4a3819c686b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findKthElement</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">partition</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">h</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">partition</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">h</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[++</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">h</span><span class=\"o\">)</span> <span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[--</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">l</span><span class=\"o\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">l</span><span class=\"o\">)</span> <span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">break</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">swap</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">l</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">j</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">swap</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n    <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n    <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>2.2 堆</h2><p>维护一个大小为 K 的最小堆，堆顶元素就是 Kth Element。</p><p>使用大顶堆来维护最小堆，而不能直接创建一个小顶堆并设置一个大小，企图让小顶堆中的元素都是最小元素。</p><p>维护一个大小为 K 的最小堆过程如下：在添加一个元素之后，如果大顶堆的大小大于 K，那么需要将大顶堆的堆顶元素去除。</p><ul><li>时间复杂度 O(NlogK) 、空间复杂度 O(K)</li><li>特别适合处理海量数据</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"349\" data-thumbnail=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"607\" data-original=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;607&#39; height=&#39;349&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"349\" data-thumbnail=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"607\" data-original=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-151f3e4f4ca418aeeca480b684b15909_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">findKthLargest</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">pq</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">PriorityQueue</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">Comparator</span><span class=\"o\">.</span><span class=\"na\">reverseOrder</span><span class=\"o\">());</span> <span class=\"c1\">// 大顶堆\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span> <span class=\"o\">:</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">pq</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">val</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pq</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">k</span><span class=\"o\">)</span>  <span class=\"c1\">// 维护堆的大小为 K\n</span><span class=\"c1\"></span>            <span class=\"n\">pq</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">pq</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><h2>3. 海量数据</h2><p>在这种场景下，单机通常不能存放下所有数据。</p><ul><li>拆分，可以按照哈希取模方式拆分到多台机器上，并在每个机器上维护最大堆；</li><li>整合，将每台机器得到的最大堆合并成最终的最大堆。</li></ul><h2>4. 频率统计</h2><p>Heavy Hitters 问题要求找出一个数据流的最频繁出现的 K 个数，比如热门搜索词汇等。</p><h2>4.1 HashMap</h2><p>使用 HashMap 进行频率统计，然后使用快速选择或者堆的方式找出频率 TopK。在海量数据场景下，也是使用先拆分再整合的方式来解决空间问题。</p><h2>4.2 Count-Min Sketch</h2><p>维护 d*w 大小的二维统计数组，其中 d 是哈希函数的个数，w 根据情况而定。</p><ul><li>在一个数到来时，计算 d 个哈希值，然后分别将哈希值对 w 取模，把对应统计数组上的值加 1；</li><li>要得到一个数的频率，也是要计算 d 个哈希值并取模，得到 d 个频率，取其中最小值。</li></ul><p>该算法的思想和布隆过滤器类似，具有一定的误差，特别是当 w 很小时。但是它能够在单机环境下解决海量数据的频率统计问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5a5a1364144e9f644269f5598e1bd57f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-5a5a1364144e9f644269f5598e1bd57f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-5a5a1364144e9f644269f5598e1bd57f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5a5a1364144e9f644269f5598e1bd57f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">CountMinSketch</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">d</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">w</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"n\">estimators</span><span class=\"o\">[][];</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">CountMinSketch</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">d</span> <span class=\"o\">=</span> <span class=\"n\">d</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">w</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">d</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">estimators</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)]++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">long</span> <span class=\"nf\">estimateFrequency</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">minimum</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">d</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">minimum</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">minimum</span><span class=\"o\">,</span> <span class=\"n\">estimators</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">][</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">)]);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">minimum</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">hash</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// use ith hash function\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>4.3 Trie</h2><p>Trie 树可以用于解决词频统计问题，只要在词汇对应节点保存出现的频率。它很好地适应海量数据场景，因为 Trie 树通常不高，需要的空间不会很大。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4b525a632738df8437ec93aa220c1676_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"326\" class=\"content_image\" width=\"360\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;360&#39; height=&#39;326&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"326\" class=\"content_image lazy\" width=\"360\" data-actualsrc=\"https://pic3.zhimg.com/v2-4b525a632738df8437ec93aa220c1676_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考资料</h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//dirtysalt.github.io/html/probabilistic-data-structures-for-web-analytics-and-data-mining.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Probabilistic Data Structures for Web Analytics and Data Mining</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/Trie\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Trie</a></li></ul><p></p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/cyc2018"
}
