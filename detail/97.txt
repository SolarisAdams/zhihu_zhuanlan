{
    "title": "区块链技术最前沿", 
    "description": "关注区块链最前沿技术，研读分享最新顶会顶刊区块链相关论文", 
    "followers": [
        "https://www.zhihu.com/people/yang-zhan-peng-54-90", 
        "https://www.zhihu.com/people/shi-lian-zhe-84-69", 
        "https://www.zhihu.com/people/bao-ling-yan-32", 
        "https://www.zhihu.com/people/sunshine-36-37-82", 
        "https://www.zhihu.com/people/wu-zhi-xiao-zi-46", 
        "https://www.zhihu.com/people/kongxiaoshuang", 
        "https://www.zhihu.com/people/18811726980", 
        "https://www.zhihu.com/people/zhangyy91", 
        "https://www.zhihu.com/people/vally-73", 
        "https://www.zhihu.com/people/fei-du-du-zuo-wei-men-45-41-26", 
        "https://www.zhihu.com/people/fenggg-2", 
        "https://www.zhihu.com/people/lin-liang-27-26", 
        "https://www.zhihu.com/people/dong-dong-93-16-9", 
        "https://www.zhihu.com/people/cpm-81", 
        "https://www.zhihu.com/people/yue-guan-49-48", 
        "https://www.zhihu.com/people/bu-ding-long", 
        "https://www.zhihu.com/people/xueguang-yang", 
        "https://www.zhihu.com/people/bella-54-79", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/er-shi-si-30-87"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/89933683", 
            "userName": "SweetCandy", 
            "userLink": "https://www.zhihu.com/people/c5fbcfcab94fdaba06216368972bb1f4", 
            "upvote": 0, 
            "title": "区块链相关论文研读7：通过分片（Sharding）扩展区块链", 
            "content": "<p>这篇论文发表在<b>顶会SIGMOD 2019</b>上，题目为《Towards Scaling Blockchain Systems via Sharding》，作者信息为<i>Hung Dang, Tien Tuan Anh Dinh, Dumitrel Loghin Ee-Chien Chang, Qian Lin, Beng Chin Ooi，National University of Singapore</i>。</p><blockquote>本文章不是论文的<b>直接翻译</b>。本人通过阅读和理解上面论文原文，结合参考其它资料，提取出论文的主体内容，用自己的语言，希望以通俗易懂的方式跟读者分享和交流区块链技术。</blockquote><p>读懂这篇论文需要一点基础知识，所以本人先介绍这些基础知识，再进入论文的主要部分。<b>尽量帮忙读者减少阅读障碍。</b></p><p><b>为什么要分片（Sharding）？</b></p><p>打个比方，如果把所有的商品存放在一个仓库内，该仓库只有一个门用来搬运商品，当有很多工人同时要搬运商品的时候，需要排队。为了提高搬运效率，我们把商品分到十个仓库中，工人分散到这些仓库中搬运商品。</p><p>在传统数据库系统中，如下图所示，通过把一个主机上的一个数据库表分片成保存在两个不同主机上的片，来减少数据读写的网络负担和IO负担，来从整体上提高体统的吞吐量。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ee65bbe0fe8c74cedef8603e3a559dbe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-ee65bbe0fe8c74cedef8603e3a559dbe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-ee65bbe0fe8c74cedef8603e3a559dbe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ee65bbe0fe8c74cedef8603e3a559dbe_b.jpg\"/></figure><p>同样道理，在区块链中，把一个碎片（shard）比作一个仓库，以提高系统的性能。更小的碎片导致更好的整体系统性能，因为（1）一个碎片内节点的通信开销减少，从而提高这个碎片的吞吐量。（2）因为整个系统网络的节点个数一定，那么更小的碎片意味着更多的碎片，因此能够减轻整个系统的压力。（如果N表示整个网络的节点个数；n表示一个碎片内的节点个数，那么整个网络的碎片的个数为k=N/n。所以n表示碎片的大小；k表示碎片的多少。应注意区分）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-630a19bfb357e0def7b4a536ff22d028_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"668\" data-original=\"https://pic1.zhimg.com/v2-630a19bfb357e0def7b4a536ff22d028_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;668&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"668\" data-original=\"https://pic1.zhimg.com/v2-630a19bfb357e0def7b4a536ff22d028_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-630a19bfb357e0def7b4a536ff22d028_b.jpg\"/></figure><p>上图便是传统数据库管理系统和区块链管理系统分片上的区别了。其中一个红圈表示一个碎片，在论文中表示为委员会（committee）。一个委员会包含多个节点，通过拜占庭容错算法来决定这个委员会的共识。共识的作用就是统一意见。这里，可以把一个委员会理解为一个区块链系统。当有一个交易产生时，只需要让一个或者几个委员会来处理这个交易。不同的委员会有时候需要通信，因此我们需要考虑委员会之间通信的问题。</p><p>上面便是区块链分片系统的架构了。在该架构之下，有哪一些问题和挑战呢？</p><p>（1）一个委员会内的共识算法如何设计？在节点数很多的情况下（&gt;100）拜占庭容错算法速度慢。如下图，当系统节点个数大于67的时候，系统吞吐量下降到了很小的数值。我们是否可以在保证安全共识的情况下尽可能减少一个委员会内的节点个数呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e2b170f9f64f9803748eec3357ab8848_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic1.zhimg.com/v2-e2b170f9f64f9803748eec3357ab8848_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;392&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic1.zhimg.com/v2-e2b170f9f64f9803748eec3357ab8848_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e2b170f9f64f9803748eec3357ab8848_b.jpg\"/></figure><p>（2）需要一个有效且安全的方式来分配节点到各个委员会，避免在一个委员会内有过多的恶意节点。假设整个区块链网络有100个节点，分为5个委员会，每一个委员会有20个节点，且使用的是拜占庭容错共识算法。假设其中恶意节点有10个，并且它们之间相互窜通。如果这些恶意节点全部被分配到一个委员会里面，就会有大问题，它们就能够控着这个委员会的共识结果。解决这个问题的一个方法是将这些恶意节点分散到各个委员会里面，使得每一个委员会所包含恶意节点的数量尽可能少。所以，我们需要解决这个分配问题。在第一次分配好之后，攻击者可能会慢慢把一个委员会内的节点一个一个攻破，使之变成恶意节点，导致这个委员会不再安全。因此需要周期性地重新调整或者说洗牌各个委员会的成员，让恶意节点尽可能均匀分散到各个委员会中。</p><p>（3）不同的委员会之间有时候是需要通信的，也就是数据读取或者说跨委员会的交易，我们希望委员会之间的通信具有隔离性和原子性。</p><p>本论文针对这三个问题和挑战提出了解决方案，也就是<b>本论文的贡献点</b>了。下面讲解如何解决这三个问题的。根据第一个挑战，提出了：</p><h3>改进的PBFT算法</h3><p>论文使用了TEE+PBFT来改进共识算法（TEE，可信执行环境，可参考本人<a href=\"https://zhuanlan.zhihu.com/p/89090472\" class=\"internal\">这篇文章</a>）。PBFT算法的安全假设为恶意节点的个数不大于f，其中N=3f+1，N表示一个网络的节点个数，也即是f&lt;N/3。如果使用了TEE+PBFT，可以让f&lt;N/2的前提下实现安全的共识（具体可以查看论文引用17）。这样的好处就是使得这个网络抵抗恶意节点窜通攻击的能力提高了。比如网络中有10个恶意节点，为了实现安全的共识，使用PBFT算法，网络至少需要31个节点，其中包含21个诚信节点；而现在结合TEE，网络至少需要21个节点来实现安全共识，其中包含11个诚信节点。这样子，<b>在一个委会会内，更少节点个数就能实现安全的拜占庭容错共识</b>。</p><p>为了避免大的可信计算基（TCB，trusted computing base）导致的系统安全隐患，系统没有把整个共识协议放到TEE中执行，而是使用论文17的方式，结合日志、消息摘要和TEE密钥加密来实现安全。这里不深入讲解。</p><p>在一个委员会里面的所有节点的通信方面，论文给出了一个小改进。超级账本Hyperledger的共识消息和请求消息共用一个消息队列，导致大量的共识消息被丢弃，特别是在委员会节点数增加的时候，使得吞吐量下降。所以，论文使用两种队列来分别处理共识消息和请求消息。</p><p>针对第二个挑战，提出了如下思路：</p><h3>委员会成员的分配</h3><p>SGX（一种TEE产品）有两个函数用于在Enclave处理：<i>sgx_read_rand</i>和<i>sgx_get_trusted_time，</i>分别用来产生无偏见的随机数和产生一个时间戳。论文借用这两个函数来实现委员会成员分配。</p><p><b>总体思路</b>：假设每一个节点都获取到了一个相同的随机数rnd，那么每一个节点都可以使用rnd作为种子（seed）来获得元素为[1:N]的一个随机全排列<img src=\"https://www.zhihu.com/equation?tex=%5Cpi\" alt=\"\\pi\" eeimg=\"1\"/>。因为种子是一样的，所以每一个节点的随机全排列<img src=\"https://www.zhihu.com/equation?tex=%5Cpi\" alt=\"\\pi\" eeimg=\"1\"/>是一样的。再将<img src=\"https://www.zhihu.com/equation?tex=%5Cpi\" alt=\"\\pi\" eeimg=\"1\"/>划分为k份，每一份便是一个委员会了。</p><p><b>现在问题是，如何让每一个节点都获取到一个相同rnd呢？</b></p><p>本系统是分时期工作的（比如一个时期长24h），每一个时期开始的时候就动态洗牌各个委员会。使用e来表示当前是第几个时期。为了避免攻击者选择性丢弃TEE的enclave的输出结果，导致随机数生成出现偏见，因此每一个时期TEE的enclave只能被调用一次。在每一个时期e开始的时候，执行下列步骤生成一个全网统一的随机数rnd。</p><ul><li>1. 生成两个随机数q和rnd，</li><li>2. 如果q=0，那么该节点就生成一个包含&lt;e,rnd&gt;的签名证书，广播该证书到其它所有节点</li><li>3. 所有节点等待 <img src=\"https://www.zhihu.com/equation?tex=%5CDelta\" alt=\"\\Delta\" eeimg=\"1\"/> 时间之后，锁定所获收集到的最小的rnd</li><li>4. 使用3中的最小rnd来作为当前时期的委员会分配的随机种子seed。</li></ul><p>每一个节点拥有一个相同的随机数rnd之后，就可以根据上述的<b>总体思路</b>来确定一个节点属于哪个委员会了，也就是委员会分配问题的解决。</p><p>如果所有节点生成的q都不等于0，那所有的节点都不能生成上述步骤2的证书，也收不到被广播的证书，那当前时期就无法重新调整委员会了, 怎么办？</p><p>解决思路为，所有节点的e增加，重新执行上面步骤。</p><p>另一个问题是，攻击者可能会慢慢一个一个攻破一个委员会中的节点，使得该委员会的恶意节点个数超过安全共识的临界值。所以我们需要每隔一段时期就要根据rnd重新调整委员会的成员。所有的节点同时调整是不可行的，因为会导致系统在这段时间不可用，因此采用分批调整的方式。在调整的过程中，每一个委员会最多有B个节点调整到其它委员会，这B个节点在这期间不参加共识工作。B的的大小设置需要权衡，更大的B值导致更低的系统安全性。</p><p>针对第三个挑战，提出了下面思路：</p><h3>两阶段锁和两阶段提交</h3><p>论文使用两阶段锁和两阶段提交来解决委员会之间通信的问题，并且满足隔离性和原子性。总体思路如下图所示，委员会之间的通信分为三个阶段，分别是准备，准备提交，提交。R表示参考委员会（Reference Committee），S1，S2，S3便是涉及到本次的transaction的委员会了。参考委员会在构造上面跟其它委员会没有区别，只是它是一个协调者的身份。“协调者”这个角色来自两阶段提交协议，即两阶段里面的协调者和这里的协调者的工作基本是一样的。只是这里的协调者是一个委员会，由很多个节点构成，使用拜占庭容错共识。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0dda052aa22a19d48175df9da261b4a4_b.jpg\" data-size=\"normal\" data-rawwidth=\"682\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb\" width=\"682\" data-original=\"https://pic1.zhimg.com/v2-0dda052aa22a19d48175df9da261b4a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;682&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"682\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"682\" data-original=\"https://pic1.zhimg.com/v2-0dda052aa22a19d48175df9da261b4a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0dda052aa22a19d48175df9da261b4a4_b.jpg\"/><figcaption>传统的两阶段提交和本论文中的两阶段提交算法对比</figcaption></figure><p>一个Transaction可能有多个输入和多个输出，这些输入和输出可能涉及到多个委员会，这些委员会在下图表示为S1，S2和S3。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-937ab7731fd61092803457dfe96b9a2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic4.zhimg.com/v2-937ab7731fd61092803457dfe96b9a2b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;228&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic4.zhimg.com/v2-937ab7731fd61092803457dfe96b9a2b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-937ab7731fd61092803457dfe96b9a2b_b.jpg\"/></figure><p>具体的跨委员会交易执行流程是什么呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-52affb1ca4c7bc859e0b1c5bb46893bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb\" width=\"989\" data-original=\"https://pic1.zhimg.com/v2-52affb1ca4c7bc859e0b1c5bb46893bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;989&#39; height=&#39;433&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"989\" data-original=\"https://pic1.zhimg.com/v2-52affb1ca4c7bc859e0b1c5bb46893bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-52affb1ca4c7bc859e0b1c5bb46893bc_b.jpg\"/></figure><p>参考委员会自身有一个状态机，如上图所示，用户发送一个交易Tx给参考委员会，这里使用R来表示参考委员会，R就进入Started状态，它向相关的委员会发送PrepareTx，同时等待收集各个委员会的回复，如果所有的回复都为PrepareOk, 那么就进入committed状态，R正式提交交易。如果有任何一个委员会回复PrepareNotOK，参考委员会进入Aborted状态。如果任何一个委员会回复消息过时或者不回复，那么R进入Aborted状态。</p><p>参考委员会会成为系统性能的瓶颈吗？论文说不会，通过运行多个参考委员会来并行计算。</p><p>R是否会存在可用性问题呢？因为论文的假设是一个委员会的恶意节点数量小于安全共识的阈值，因此R总是能够执行诚信的共识来完成作为协调者的工作。</p><h3>总结：</h3><p>这篇论文针对上面三个问题和挑战，借用TEE提出了自己的解决方案。这篇论文包含的信息量比较大，阅读和理解这篇论文有一定的难度，因为作者假设读者已经清楚了一些基本概念，比如区块链分片，参考委员会的构造和管理，拜占庭容错算法，TEE，两阶段提交和两阶段锁等等。论文使用了RapidChain和OmniLeger作为对比来叙述跨委员会交易的原子性和隔离性问题。在阅读这篇论文之前，了解RapidChain和OmniLedger这两篇论文有助于理解这篇论文。</p><p>论文中涉及到一些定量的计算问题，比如如何设置合适的委员会大小，这里不给予讲解了。</p><p>对于区块链分片的方案，可以参考：</p><ol><li>ELASTICO</li></ol><a href=\"https://link.zhihu.com/?target=http%3A//people.cs.georgetown.edu/~cnewport/teaching/cosc841-spring19/papers/new/sharding.pdf\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">people.cs.georgetown.edu</span><span class=\"invisible\">/~cnewport/teaching/cosc841-spring19/papers/new/sharding.pdf</span><span class=\"ellipsis\"></span></a><p>2. Near Protocol，在油管有专门的视频讲解</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/nearprotocol\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-fbaee328d50f69d8f77dc4dccdbcab26_ipico.jpg\" data-image-width=\"280\" data-image-height=\"280\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NEAR Protocol</a><p>3.Monoxide</p><a href=\"https://zhuanlan.zhihu.com/p/87307292\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-24662befb3c3caab619c7877b6500905_180x120.jpg\" data-image-width=\"960\" data-image-height=\"638\" class=\"internal\">SweetCandy：区块链相关论文研读4: Monoxide异步共识组</a><p>4. RapidChain， OmniLeger，Zilliqa，Cosmos，Harmoney，具体百度或者google一下就可以找到相关的论文。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>谢谢！点个赞呗 = =</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3f9f55c79d26986406c5bf8df8bb760f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic4.zhimg.com/v2-3f9f55c79d26986406c5bf8df8bb760f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic4.zhimg.com/v2-3f9f55c79d26986406c5bf8df8bb760f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3f9f55c79d26986406c5bf8df8bb760f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "Sharding", 
                    "tagLink": "https://api.zhihu.com/topics/19608429"
                }, 
                {
                    "tag": "SIGMOD", 
                    "tagLink": "https://api.zhihu.com/topics/20775740"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89090472", 
            "userName": "SweetCandy", 
            "userLink": "https://www.zhihu.com/people/c5fbcfcab94fdaba06216368972bb1f4", 
            "upvote": 1, 
            "title": "区块链相关论文研读6: FASTKITTEN,关于比特币的实用智能合约", 
            "content": "<p>这篇文章发表在<b>顶会</b>USENIX Security Symposium 2019上面，题目为《FASTKITTEN: Practical Smart Contracts on Bitcoin》，第一作者为Poulami Das。通过下面的链接可以找到作者在会议上面演讲视频。PPT很好，演讲也很好，建议在看论文之前先看作者的演讲。</p><a href=\"https://link.zhihu.com/?target=https%3A//www.usenix.org/conference/usenixsecurity19/presentation/das\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">FastKitten: Practical Smart Contracts on Bitcoin</a><blockquote>本文章不是论文的<b>直接翻译</b>。本人通过阅读和理解上面论文原文，结合参考其它资料，提取出论文的主体内容，用自己的语言，希望以通俗易懂的方式跟读者分享和交流区块链技术。</blockquote><h2>论文的问题描述</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b8e504d89f0ee5ad720b1d995a297bcb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"275\" data-rawheight=\"352\" class=\"content_image\" width=\"275\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;275&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"275\" data-rawheight=\"352\" class=\"content_image lazy\" width=\"275\" data-actualsrc=\"https://pic4.zhimg.com/v2-b8e504d89f0ee5ad720b1d995a297bcb_b.jpg\"/></figure><p>区块链上的智能合约本质上是区块链上的代码，因此能够进行逻辑运算。比如可以使用智能合约实现上图所示的扑克牌游戏，三个玩家分别向智能合约输入自己的牌，然后智能合约进行逻辑运算，确定赢家，输出结果。智能合约能够让一个区块链网络有不同的用途，同一个区块链中的不同智能合约相当于智能手机中的不同的应用软件。智能合约这么重要，但是现在区块链最成功的应用之一<b>比特币</b>不支持智能合约，它只有一种功能：数字加密货币。那么，</p><p><b>是否可以让比特币网络支持智能合约？</b></p><p>但是现在的加密货币的智能合约（比如以太坊）存在速度慢、贵、运行时无隐私保护等问题。本论文针对比特币网络提出了一个能够在链外执行（off-chain execution）且能执行多个轮回（multi-round）的高效的智能合约协议，叫FastKitten，它具有强的隐私和安全性以及速度快的特点。</p><p>在讲解FastKitten之前，先介绍一下可信执行环境（Trusted Execution Environment，TEE）</p><h2>可信执行环境TEE</h2><p>一个理想的TEE可以理解为一个沙盒，任何人都不能改变和窥探里面的执行逻辑和状态信息。一个TEE能够保证其中的逻辑代码被正确执行，维护其中的隐私状态，并且能够提供TEE中的程序被正确设置的证明。所以，一个TEE的拥有者（论文表示为Operator）只能改变TEE的输入或者输出，停止或者启动TEE。</p><p>下面讲解本论文所提出的协议</p><h2>FastKitten协议</h2><p>该协议可以分为四个主体，分别为TEE，Operator，Parties和区块链。可以把TEE理解为一台特殊的服务器，Operator便是这台服务器的拥有者；Parties是活动的参与者，比如上图中打扑克牌的三个小伙子；这里的区块链就是比特币中的区块链。</p><p>FastKitten协议分为三个阶段，分别是Setup，Round和Finalize。</p><ul><li>Setup阶段</li></ul><p>Operator提交<b>惩罚押金</b>给智能合约，通过向区块链发起一个交易 <img src=\"https://www.zhihu.com/equation?tex=TX_%7B0%7D\" alt=\"TX_{0}\" eeimg=\"1\"/> 来实现。这个交易的输入是Operator未花费的钱，输出是各个parties的地址，也就是把Operator的惩罚押金转给每一个parties，但是它time-lock的，只有到了timeout的时间之后，该交易的输出金额才能被parties花费掉。从后面的分析中会发现，这个设置可以防止Operator作恶。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9c741b166b77954586078782530cab95_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"396\" data-rawheight=\"223\" class=\"content_image\" width=\"396\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;396&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"396\" data-rawheight=\"223\" class=\"content_image lazy\" width=\"396\" data-actualsrc=\"https://pic2.zhimg.com/v2-9c741b166b77954586078782530cab95_b.jpg\"/></figure><p>所以，Operator需要把这个交易分别发给各个parties。如下图所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c16314f432f365c9addfdd63821b4678_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"223\" class=\"content_image\" width=\"377\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;377&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"223\" class=\"content_image lazy\" width=\"377\" data-actualsrc=\"https://pic1.zhimg.com/v2-c16314f432f365c9addfdd63821b4678_b.jpg\"/></figure><p>对于各个Party，她们通过验证Operator发过来的数据，知道Operator已经提交了押金，以及TEE已经设置好了。于是她们需要向智能合约提交惩罚押金，也是通过向区块链发起一个交易TX来实现，对应下图的 <img src=\"https://www.zhihu.com/equation?tex=TX_A%2CTX_B%2C+TX_C\" alt=\"TX_A,TX_B, TX_C\" eeimg=\"1\"/> 。它们不是time-lock的。其输入是Party没有花费的钱，输出为TEE的地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-892fdc1bac5e7c6a869c738def43daed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"218\" class=\"content_image\" width=\"373\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;373&#39; height=&#39;218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"218\" class=\"content_image lazy\" width=\"373\" data-actualsrc=\"https://pic2.zhimg.com/v2-892fdc1bac5e7c6a869c738def43daed_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这样就完成了Setup阶段，进入Round阶段</p><ul><li>Round阶段</li></ul><p>（1）各个parties通过Operator向TEE发送智能合约的输入数据，</p><p>（2）TEE计算得到结果，</p><p>（3）通过Operator向各个parties返回TEE的计算结果。</p><p>这个过程可以根据需要重复多次。所有在网络中传输的数据都通过Transport Layer Security (TLS)来加密，因此Operator无法知道parties的输入内容和TEE的计算结果。并且，这个round阶段在正常情况下是不用访问区块链的，因此该阶段不需等待区块链打包确认，能够很快执行完成。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-741aca2b819b4b848f7a41336c3f3f8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb\" width=\"587\" data-original=\"https://pic3.zhimg.com/v2-741aca2b819b4b848f7a41336c3f3f8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"249\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"587\" data-original=\"https://pic3.zhimg.com/v2-741aca2b819b4b848f7a41336c3f3f8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-741aca2b819b4b848f7a41336c3f3f8e_b.jpg\"/></figure><ul><li>Finalize阶段</li></ul><p>上一个阶段智能合约执行了其中的代码逻辑，得到了扑克牌游戏的赢家，接下来到了结算的时候了。Operator通过TEE的最终计算结果的输出 <img src=\"https://www.zhihu.com/equation?tex=out_%7Bfinal%7D\" alt=\"out_{final}\" eeimg=\"1\"/> 向区块链发起一个交易 <img src=\"https://www.zhihu.com/equation?tex=TX_%7Bfinal%7D\" alt=\"TX_{final}\" eeimg=\"1\"/> ，用于向Operator和各个parties退还押金以及向赢家发送相关报酬等。这一步的操作需要写到区块链中，防止篡改和欺骗。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-93cbf024632a7a21eb4463967761ba94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-93cbf024632a7a21eb4463967761ba94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;797&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"797\" data-original=\"https://pic1.zhimg.com/v2-93cbf024632a7a21eb4463967761ba94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-93cbf024632a7a21eb4463967761ba94_b.jpg\"/></figure><p>上面的三个阶段是在各个参与者都诚信可靠的情况下完成的。但是，</p><p><b>如果有人作恶怎么办？</b></p><p>对于作恶，可以归结为两种，一种是篡改数据，第二种是丢弃数据或者故意停止工作。前者可以通过数字签名来解决。而后者怎么办呢？论文主要讲解后者。</p><h3>情况1，Operator作恶</h3><p>如果Operator故意丢弃数据或者故意停止服务，那么其之前所提交的押金在timeout之后被各个parties消费掉，以此来惩罚operator。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a4617426d1756d4765a6ab35de969590_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"887\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb\" width=\"887\" data-original=\"https://pic1.zhimg.com/v2-a4617426d1756d4765a6ab35de969590_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;887&#39; height=&#39;444&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"887\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"887\" data-original=\"https://pic1.zhimg.com/v2-a4617426d1756d4765a6ab35de969590_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a4617426d1756d4765a6ab35de969590_b.jpg\"/></figure><h3>情况2，Party作恶</h3><p>比如Alice故意停止工作，没有给Operator发送TEE所需要的input数据。这时候TEE没有收到Alice的input数据，但是TEE不确定是Operator丢弃了该数据还是Alice没有发送。Operator为了证明自己的清白，于是，它向区块链发起一个challenge交易，记 <img src=\"https://www.zhihu.com/equation?tex=TX_%7BChallenge%7D\" alt=\"TX_{Challenge}\" eeimg=\"1\"/> ，如下图所示，该交易的输入是Operator自己的一些未花费的钱，输出是Alice的地址，并且有一个数据域Data，里面存储了在当前round中TEE计算结果的输出值 <img src=\"https://www.zhihu.com/equation?tex=out_%7Bi%7D\" alt=\"out_{i}\" eeimg=\"1\"/> 。如果Alice没有作恶，只是她发给Operator的input数据在网络传输途中丢失了。这时候，Alice需要证明自己的清白，因此她需要回应Operator所发起的challenge交易。Alice需要时时检查有没有发给自己的challenge交易，如果有，需要向区块链发起一个交易，记 <img src=\"https://www.zhihu.com/equation?tex=TX_%7Bresponse%7D\" alt=\"TX_{response}\" eeimg=\"1\"/> ,作为对应challenge交易的回应。该response交易的输入是Operator发给Alice的钱，输出是Operator的地址，目的是把这个钱返还给Operator，并且其数据域Data是发送给TEE的input数据。这样，Operator检查到Alice的回应之后，就能够从区块链中拿到这个input数据，然后转发给TEE，TEE正常执行。如果在Operator发起 <img src=\"https://www.zhihu.com/equation?tex=TX_%7BChallenge%7D\" alt=\"TX_{Challenge}\" eeimg=\"1\"/> 过了一定的时间之后Alice还是没有反应，那么TEE中的智能合约就能够断定Alice作恶，因此没收Alice的押金，结束协议。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fcbe67b6d325df6ba2a79a9e100d5ba6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb\" width=\"563\" data-original=\"https://pic3.zhimg.com/v2-fcbe67b6d325df6ba2a79a9e100d5ba6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;563&#39; height=&#39;341&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"563\" data-rawheight=\"341\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"563\" data-original=\"https://pic3.zhimg.com/v2-fcbe67b6d325df6ba2a79a9e100d5ba6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fcbe67b6d325df6ba2a79a9e100d5ba6_b.jpg\"/></figure><p>怎么没收Alice的押金呢？如下图所示，通过向区块链发起一个交易 <img src=\"https://www.zhihu.com/equation?tex=TX_%7BFinal%7D\" alt=\"TX_{Final}\" eeimg=\"1\"/> ,其输出包含Operator的地址和除了Alice的其它parties的地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c466cacc94b9b36b0ace11e001b84298_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic1.zhimg.com/v2-c466cacc94b9b36b0ace11e001b84298_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic1.zhimg.com/v2-c466cacc94b9b36b0ace11e001b84298_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c466cacc94b9b36b0ace11e001b84298_b.jpg\"/></figure><p>以上便是FastKitten协议的主要内容了。</p><h2>该协议存在的缺点：</h2><ul><li>在round阶段，parties需要时时检查区块链是否有发给自己的challenge交易被打包进区块中。</li><li>FastKitten协议使用time-lock的方式来限制恶意智能合约无限循环执行（以太坊使用消耗gas来限制）。如何设置一个合理的timeout时间长度呢？短了，协议没执行完成；长了，可能存在恶意无限循环计算的问题。可否给出一个计算出合理的timeout时间长度的方法呢？</li><li>本协议是基于理想的TEE的。如果TEE被黑客攻破，那么本论文的安全隐私保证就不成立了。TEE是有漏洞的。</li><li>在进入round阶段，需要知道并且确定parties的数量。这在一定程度上限制了FastKitten智能合约的应用。</li></ul><h2>本人存在的疑问：</h2><p>（1）parties提交了押金给TEE中的智能合约之后，operator作恶，把TEE服务关闭，智能合约停止运行。parties如何收回自己的押金呢？论文表示所有所有party可以只依赖单个TEE来完成一个活动（比如打扑克牌）。</p><p>谢谢！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>都看到这里了，给一个赞呗</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-151d1f0eacdd506f4c2b4f844e3804cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-151d1f0eacdd506f4c2b4f844e3804cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;618&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-151d1f0eacdd506f4c2b4f844e3804cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-151d1f0eacdd506f4c2b4f844e3804cb_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "比特币 (Bitcoin)", 
                    "tagLink": "https://api.zhihu.com/topics/19600228"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "智能合约", 
                    "tagLink": "https://api.zhihu.com/topics/20091744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87900715", 
            "userName": "SweetCandy", 
            "userLink": "https://www.zhihu.com/people/c5fbcfcab94fdaba06216368972bb1f4", 
            "upvote": 2, 
            "title": "区块链相关论文研读5：分布式隐私保护可审计的账本，zkLedger", 
            "content": "<p>这篇文章在2018年发表在<b>顶会NSDI</b>上面，题目为《zkLedger: Privacy-Preserving Auditing for Distributed Ledgers》，作者为Neha Narula, <i>MIT Media Lab; </i>Willy Vasquez, <i>University of Texas at Austin; </i>Madars Virza, <i>MIT Media Lab。 </i></p><p>作者在NSDI上面做了演讲，通过下面这个链接可以查看<b>演讲视频</b>，演讲使用的<b>PPT</b>以及<b>论文</b>。在论文里面还可以找到论文实现源码。本人看这篇论文的时候，卡在了关键的部分，最后是结合了论文源码才看懂的。如果你对源码有问题的话，可以在下面留言。作者演讲所使用的PPT虽然简单易懂，但是太笼统了。</p><a href=\"https://link.zhihu.com/?target=https%3A//www.usenix.org/conference/nsdi18/presentation/narula\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">zkLedger: Privacy-Preserving Auditing for Distributed Ledgers</a><blockquote>本文章不是论文的<b>直接翻译</b>。本人通过阅读和理解上面论文原文，结合参考其它资料，提取出论文的主体内容，用自己的语言，希望以通俗易懂的方式跟读者分享和交流区块链技术。</blockquote><h3>论文问题定义</h3><p>银行的交易账本被审计的时候，银行希望不泄露：</p><ul><li>交易的对象信息</li><li>每一条交易的具体金额</li><li>交易图谱（transaction graph）(即不能通过关联多条交易来挖掘出私密信息)</li></ul><p>满足上面条件的情况下，能够做到基本的审计功能有：</p><ul><li><b>某一个银行在某一时刻拥有多少资产？（最基本的功能）</b></li><li>某一个银行平均每一个交易的数额？</li><li>某一个银行所有交易金额的标准差是多少？</li></ul><p>上面便是本文所要解决的问题了。在我们进一步了解之前，有必要知道一点点密码学的知识，这里简单整理和介绍一下。</p><h3>背景知识</h3><p>----------------------start---------虚线里面的内容可以跳过---------------------</p><p><b>群 Group</b>，满足下面四个特性</p><ul><li>1 封闭性（closure）：如果a和b被包含于G ，那么a+b 也一定是G的元素。</li><li>2 结合律(associativity)。</li><li>3 存在一个单位元（identity element）0，使得 a+0 = 0+a = a;[单位元：与任意元素运算不改变其值的元素]</li><li>4 每个数都存在一个相反数(inverse)。</li></ul><p>阿贝尔群(abelian group)，在群的基础之上满足下面特性</p><ul><li>5 交换律(commutativity): a+b = b+a.</li></ul><p>我们可以在椭圆曲线定义一个群，其中一条椭圆曲线就是一组被 y^2=x^3+ax+b定义的且满足 4a^3+27b^2≠0 的点集。使用该曲线实现椭圆曲线加密算法Elliptic Curve Cryptography（ECC）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5d93dd6f202b48deb52837d50da48fa1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1784\" data-rawheight=\"687\" class=\"origin_image zh-lightbox-thumb\" width=\"1784\" data-original=\"https://pic2.zhimg.com/v2-5d93dd6f202b48deb52837d50da48fa1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1784&#39; height=&#39;687&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1784\" data-rawheight=\"687\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1784\" data-original=\"https://pic2.zhimg.com/v2-5d93dd6f202b48deb52837d50da48fa1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5d93dd6f202b48deb52837d50da48fa1_b.jpg\"/></figure><p>上图表示如何在椭圆曲线上面定义加法和乘法。左边的图中，P和Q是曲线上面的一个点，R点是交点关于x轴对称的点，得到P+Q = R。中间的图，P点是一个切点，表示两个P相加。对于右图，先计算P+P = 2P，再计算2P+P = 3P，这样子就可以推导出椭圆曲线上面的乘法了。本论文中主要使用到了乘法。</p><p>-----------------------------------------end------------------------------------</p><p>使用ECC如何根据私钥x生成公钥呢？</p><blockquote>私钥公钥生成：𝑝k=𝑥∗𝐺 </blockquote><p>其中pk 是公钥，x是私钥，G是椭圆曲线上的一个点。特点是，知道x和G，容易计算出pk；知道pk和G,难计算出x。</p><p>同时，它有一个特别重要的特性，那就是它满足交换律和结合律</p><blockquote>v1*G + v2*G = (v1 + v2)*G</blockquote><p>使用上面的等式的特性，我们得出重要的Pedersen Commitment，形式为</p><blockquote>(v1*G + r1*H) + (v2*G + r2*H) = v3*G + r3*H</blockquote><p>其中<i>v3 = v1 + v2; r3 = r1 + r2。G</i>和H是椭圆曲线上面的两个不同的点，v和r是数值标量（scalar）。</p><p>例子 : (6*G + 222222222222*H) + (3 * G + 444444444444 * H) = 9 * G + 666666666666 * H。其中6和3可以表示为交易金额（私密信息）， 222222222222和444444444444是致盲因子。这样就能够让审计者不知道具体交易数据的情况下验证交易成立：只需要告诉审计者9和666666666666.。MimbleWinble协议使用到了Pedersen Commitment，来隐藏区块链中用户交易金额和交易图谱，达到隐私保护的作用。MimbleWinble协议有Grin和Beam两个实现，具体可以了解一下。下面两张图片是Bean一个交易数据的截图，可以发现一个交易的inputs和outputs都是字符串，实际的交易对象和交易金额都被隐藏了。</p><figure data-size=\"small\"><noscript><img src=\"https://pic3.zhimg.com/v2-e728564f233ad9b9359d6acc5722bf7a_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"836\" data-rawheight=\"751\" class=\"origin_image zh-lightbox-thumb\" width=\"836\" data-original=\"https://pic3.zhimg.com/v2-e728564f233ad9b9359d6acc5722bf7a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;836&#39; height=&#39;751&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"836\" data-rawheight=\"751\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"836\" data-original=\"https://pic3.zhimg.com/v2-e728564f233ad9b9359d6acc5722bf7a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e728564f233ad9b9359d6acc5722bf7a_b.jpg\"/></figure><figure data-size=\"small\"><noscript><img src=\"https://pic3.zhimg.com/v2-a123d64fe47c4b1d794a01cd77df3496_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1019\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb\" width=\"1019\" data-original=\"https://pic3.zhimg.com/v2-a123d64fe47c4b1d794a01cd77df3496_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1019&#39; height=&#39;423&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1019\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1019\" data-original=\"https://pic3.zhimg.com/v2-a123d64fe47c4b1d794a01cd77df3496_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a123d64fe47c4b1d794a01cd77df3496_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下面的一张图是比特币的一个交易数据，其中的交易对象的地址和交易金额是公开的。这些是题外话了。下面进入正题。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-eb55f04a572285d8b6b5377d5c28d101_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1145\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb\" width=\"1145\" data-original=\"https://pic2.zhimg.com/v2-eb55f04a572285d8b6b5377d5c28d101_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1145&#39; height=&#39;664&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1145\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1145\" data-original=\"https://pic2.zhimg.com/v2-eb55f04a572285d8b6b5377d5c28d101_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-eb55f04a572285d8b6b5377d5c28d101_b.jpg\"/></figure><h3>系统设计</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6326f0634bb618ab8ede9c64a926b649_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1116\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb\" width=\"1116\" data-original=\"https://pic2.zhimg.com/v2-6326f0634bb618ab8ede9c64a926b649_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1116&#39; height=&#39;504&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1116\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1116\" data-original=\"https://pic2.zhimg.com/v2-6326f0634bb618ab8ede9c64a926b649_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6326f0634bb618ab8ede9c64a926b649_b.jpg\"/></figure><p>总共有三个主体对象，分别是银行，账本和审计员。前两者有自己的本地数据库，存储自己的私密信息。三者通过分布式账本连在一起。</p><p>账本中的隐私交易数据被隐藏了，使用transaction commitment和proof来代替。如下图，所有的银行都对应着表格的一列，一行数据表示一个交易，<b>一个交易的所有交易数据都是由该交易的发起者构造和生成的</b>，交易的接收者和交易无关这不需要构造这一行数据，但是每一行单元格都需要被填写，即使该银行是该交易的无关者。下图中，bank1向bank2转账10^6欧元，bank1的值为-10^6，bank2的值为10^6。其它也有相应的数据，其交易金额为0。这样子就可以隐藏交易的参加者了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a0656a1263509fbd1d81dea43900a32f_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb\" width=\"1218\" data-original=\"https://pic4.zhimg.com/v2-a0656a1263509fbd1d81dea43900a32f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1218&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1218\" data-original=\"https://pic4.zhimg.com/v2-a0656a1263509fbd1d81dea43900a32f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a0656a1263509fbd1d81dea43900a32f_b.png\"/></figure><p><b>如何审计一个银行当前的资产呢？</b>先讲基本的方法，然后再将改进的方法。</p><p>第一种方法：</p><p>根据Pedersen Commitment， 可以构造这样的等式，(v1*G + r1*H) + (v2*G + r2*H) +…+ (vn*G + rn*H)= v3*G + r3*H</p><p>即 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D++%E2%88%97%F0%9D%90%BA+%2B+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D++%E2%88%97%F0%9D%90%BB+%3D+v3%2AG+%2B+r3%2AH.\" alt=\"\\sum_{i=1}^{m}{vi}  ∗𝐺 + \\sum_{i=1}^{m}{ri}  ∗𝐻 = v3*G + r3*H.\" eeimg=\"1\"/> </p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=v3+%3D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D\" alt=\"v3 = \\sum_{i=1}^{m}{vi}\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=r3+%3D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D\" alt=\"r3 = \\sum_{i=1}^{m}{ri}\" eeimg=\"1\"/> ,m表示从开始到当前<b>某个银行</b>的所有交易数量，vi表示第i交易的数额，ri表示第i交易的致盲因子（或者说密钥）。</p><p>审计员知道该银行每条交易的commitment（从账本中），以及该银行当前资产数v3（银行告诉的）和致盲因子之和r3（银行告诉的）审计员验证等式： <img src=\"https://www.zhihu.com/equation?tex=%F0%9D%91%90%F0%9D%91%9C%F0%9D%91%9A%F0%9D%91%9A_%7B1%7D%2B%F0%9D%91%90%F0%9D%91%9C%F0%9D%91%9A%F0%9D%91%9A_%7B2%7D+%2B%E2%80%A6%2B%F0%9D%91%90%F0%9D%91%9C%F0%9D%91%9A%F0%9D%91%9A_%7B%F0%9D%91%9A%7D++%3D%3D+%F0%9D%91%A33%E2%88%97%F0%9D%90%BA%2B%F0%9D%91%9F3+%E2%88%97%F0%9D%90%BB\" alt=\"𝑐𝑜𝑚𝑚_{1}+𝑐𝑜𝑚𝑚_{2} +…+𝑐𝑜𝑚𝑚_{𝑚}  == 𝑣3∗𝐺+𝑟3 ∗𝐻\" eeimg=\"1\"/> ,</p><p>如果等式成立，表示该银行的账单没问题。</p><p>但是，账单表格中的每一行数据是由该交易的发起者构建生成的，其它银行是不知情的，也就是每一个单元格中的 致盲因子<img src=\"https://www.zhihu.com/equation?tex=r_%7Bk%7D\" alt=\"r_{k}\" eeimg=\"1\"/> 只有该行交易的发起者知道。这就有问题了，因为根据上面所述的方法，在审计员审计一个银行的时候，需要该银行提供给审计员 <img src=\"https://www.zhihu.com/equation?tex=r3+%3D+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D\" alt=\"r3 = \\sum_{i=1}^{m}{ri}\" eeimg=\"1\"/> 。怎么解决这个问题呢？可不可以绕开致盲因子ri呢？为了解决这个问题，提出了第二种方法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ede8f455e7e740731b8c6cee4b7de910_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb\" width=\"1218\" data-original=\"https://pic1.zhimg.com/v2-ede8f455e7e740731b8c6cee4b7de910_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1218&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1218\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1218\" data-original=\"https://pic1.zhimg.com/v2-ede8f455e7e740731b8c6cee4b7de910_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ede8f455e7e740731b8c6cee4b7de910_b.png\"/></figure><p>第二种方法</p><ul><li>在每一个单元格中增加一个Token，计算方法为 <img src=\"https://www.zhihu.com/equation?tex=Token_i++%3D%F0%9D%91%9F_%F0%9D%91%96+%E2%88%97%7Bpk%7D_i\" alt=\"Token_i  =𝑟_𝑖 ∗{pk}_i\" eeimg=\"1\"/> , 其中pk是椭圆曲线上一个点，也是第i银行的公钥，ri表示致盲因子（椭圆曲线算法）。根据Pedersen Commitment，有</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7BCOMM_%7Bi%7D%7D+%3D+G%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D+%2B+H%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D\" alt=\"\\sum_{i=1}^{m}{COMM_{i}} = G*\\sum_{i=1}^{m}{vi} + H*\\sum_{i=1}^{m}{ri}\" eeimg=\"1\"/> </p><p>所以</p><p><img src=\"https://www.zhihu.com/equation?tex=H%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D++\" alt=\"H*\\sum_{i=1}^{m}{ri}  \" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=%3D%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7BCOMM_%7Bi%7D%7D+-+G%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D\" alt=\"=\\sum_{i=1}^{m}{COMM_{i}} - G*\\sum_{i=1}^{m}{vi}\" eeimg=\"1\"/> ,</p><p>发现可以从账本中计算到 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7BCOMM_%7Bi%7D%7D\" alt=\"\\sum_{i=1}^{m}{COMM_{i}}\" eeimg=\"1\"/> ，可以从被审计的银行那里得到 <img src=\"https://www.zhihu.com/equation?tex=G%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D\" alt=\"G*\\sum_{i=1}^{m}{vi}\" eeimg=\"1\"/> ，也就是我们可以<b>绕开 <img src=\"https://www.zhihu.com/equation?tex=ri\" alt=\"ri\" eeimg=\"1\"/> 来计算 <img src=\"https://www.zhihu.com/equation?tex=H%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D++\" alt=\"H*\\sum_{i=1}^{m}{ri}  \" eeimg=\"1\"/> 的值</b>。</p><p>令 <img src=\"https://www.zhihu.com/equation?tex=T+%3D+H%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D+\" alt=\"T = H*\\sum_{i=1}^{m}{ri} \" eeimg=\"1\"/> ，两边做椭圆曲线乘法运算，乘以x，得到</p><p><img src=\"https://www.zhihu.com/equation?tex=x%2AT+%3D+x+%2A+H%2A%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D+\" alt=\"x*T = x * H*\\sum_{i=1}^{m}{ri} \" eeimg=\"1\"/>              (1)</p><p>已知一个单元格的Token表示为 <img src=\"https://www.zhihu.com/equation?tex=Token_i++%3D%F0%9D%91%9F_%F0%9D%91%96+%E2%88%97%7Bpk%7D_i\" alt=\"Token_i  =𝑟_𝑖 ∗{pk}_i\" eeimg=\"1\"/> ，我们又知道通过私钥生成公钥的计算公式为：</p><p><img src=\"https://www.zhihu.com/equation?tex=pk_%7Bk%7D+%3D+x+%2A+H\" alt=\"pk_{k} = x * H\" eeimg=\"1\"/>          (2)</p><p>其中 <img src=\"https://www.zhihu.com/equation?tex=pk_k\" alt=\"pk_k\" eeimg=\"1\"/> 表示被审计的银行的公钥。所以，某一银行所在列的所有Token的和为 <img src=\"https://www.zhihu.com/equation?tex=Total%5C_Token_i++%3Dr1%2Apk_k+%2B+r2%2Apk_k%2B...%2Brm%2Apk_k+%3D+pk_k+%2A+%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D+%3D+x+%2A+H+%2A++%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D\" alt=\"Total\\_Token_i  =r1*pk_k + r2*pk_k+...+rm*pk_k = pk_k * \\sum_{i=1}^{m}{ri} = x * H *  \\sum_{i=1}^{m}{ri}\" eeimg=\"1\"/>         (3)</p><p>根据（1）（3）式，发现 <img src=\"https://www.zhihu.com/equation?tex=Total%5C_Token_i++%3D+x%2AT\" alt=\"Total\\_Token_i  = x*T\" eeimg=\"1\"/>   （4）</p><p>现在，在(2)(4)式子中，除了x，其它所有变量的值都可以计算的得到，<b>最后，通过非交互式零知识证明，证明(2)(4)两式所使用的x是相等的。</b>如果证明为真，审计通过，表示该银行当前拥有 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D\" alt=\"\\sum_{i=1}^{m}{vi}\" eeimg=\"1\"/> 的资产。</p><p><b>小结一下:</b>第二种方法中，被审计的银行只需要向审计员提供 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D\" alt=\"\\sum_{i=1}^{m}{vi}\" eeimg=\"1\"/> 的值即可，不需要提供 <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bri%7D\" alt=\"\\sum_{i=1}^{m}{ri}\" eeimg=\"1\"/> 的值。</p><h3>一致性证明 <img src=\"https://www.zhihu.com/equation?tex=%5Cpi%5E%7BC%7D\" alt=\"\\pi^{C}\" eeimg=\"1\"/> </h3><p>上面的证明是基于一个假设前提， <img src=\"https://www.zhihu.com/equation?tex=COMM_k%28v_i%2C+r_i%29\" alt=\"COMM_k(v_i, r_i)\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=Token_i++%3D%F0%9D%91%9F_%F0%9D%91%96+%E2%88%97%7Bpk%7D_i\" alt=\"Token_i  =𝑟_𝑖 ∗{pk}_i\" eeimg=\"1\"/> 使用的是相同的ri。所以，我们要让交易发起者在构造数据的时候，保证使得两个ri相等。但是我们不信任他，因此我们要求他构造一个一致性证明（proof of consistency），表示为 <img src=\"https://www.zhihu.com/equation?tex=%5Cpi%5E%7BC%7D\" alt=\"\\pi^{C}\" eeimg=\"1\"/> ,并把这个证明保存到每一个单元格中，以便让其它用户认证：如果通过，表示两个式子中的ri是相等的。</p><p>具体怎么构造这个零知识证明中的一致性证明，可以参考相关论文，或者查看论文实现源码。</p><h3>其它零知识证明</h3><ul><li>资产证明 <img src=\"https://www.zhihu.com/equation?tex=%5Cpi%5E%7BA%7D\" alt=\"\\pi^{A}\" eeimg=\"1\"/> </li></ul><p>proof of assets, 用来证明这个银行在某一时刻有某数量的资产。</p><ul><li>范围证明Range Proof</li></ul><p>用来证明交易金额在一定的范围内，比如大于0.这里还涉及到造币和毁币的问题，具体这里不深入。在本论文中，每一个单元格都需要这个证明。</p><ul><li>Proof of Balance</li></ul><p>来证明一个转账交易的所有数额之和为0， <img src=\"https://www.zhihu.com/equation?tex=%5Csum_%7Bi%3D1%7D%5E%7Bm%7D%7Bvi%7D+%3D+0\" alt=\"\\sum_{i=1}^{m}{vi} = 0\" eeimg=\"1\"/> ，付款者资产减少，收款者资产增加，总和为0.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>谢谢！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2df93a1766dd9cd3d380aa3c8b16d29e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic3.zhimg.com/v2-2df93a1766dd9cd3d380aa3c8b16d29e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic3.zhimg.com/v2-2df93a1766dd9cd3d380aa3c8b16d29e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2df93a1766dd9cd3d380aa3c8b16d29e_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "隐私保护", 
                    "tagLink": "https://api.zhihu.com/topics/19569709"
                }, 
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/blockchain-top-paper"
}
