{
    "title": "小慢哥Linux运维", 
    "description": "专注Linux运维、云计算、虚拟化、基础架构研究", 
    "followers": [
        "https://www.zhihu.com/people/zhao-mo-xi", 
        "https://www.zhihu.com/people/chiles-93", 
        "https://www.zhihu.com/people/liu-lei-mi-tu", 
        "https://www.zhihu.com/people/zuo-you-shou-chang-ban-wu-shen", 
        "https://www.zhihu.com/people/ben-wu-xin", 
        "https://www.zhihu.com/people/larvayang", 
        "https://www.zhihu.com/people/peng-jin-yi", 
        "https://www.zhihu.com/people/jing-wai-33", 
        "https://www.zhihu.com/people/gong-fan", 
        "https://www.zhihu.com/people/cheng-zi-big", 
        "https://www.zhihu.com/people/lipaopao", 
        "https://www.zhihu.com/people/hyt_yuntao", 
        "https://www.zhihu.com/people/DemosJohn", 
        "https://www.zhihu.com/people/logirl.cc", 
        "https://www.zhihu.com/people/beepnow", 
        "https://www.zhihu.com/people/anhuang-14", 
        "https://www.zhihu.com/people/pobpob", 
        "https://www.zhihu.com/people/fangfetty", 
        "https://www.zhihu.com/people/xiao-hui-hui-21-97", 
        "https://www.zhihu.com/people/yang-yang-24-38-52-47", 
        "https://www.zhihu.com/people/harley-21-60", 
        "https://www.zhihu.com/people/wu-suijian", 
        "https://www.zhihu.com/people/wang-yong-xing-15-80", 
        "https://www.zhihu.com/people/huang-jun-93-72", 
        "https://www.zhihu.com/people/ling-yun-4-56-64", 
        "https://www.zhihu.com/people/ma-ke-ke-41", 
        "https://www.zhihu.com/people/manybirds", 
        "https://www.zhihu.com/people/zhi-tian-xia-12-26", 
        "https://www.zhihu.com/people/lizhihua0925", 
        "https://www.zhihu.com/people/zhang-zhi-hao-18-52", 
        "https://www.zhihu.com/people/meng-xiang-xiang-51", 
        "https://www.zhihu.com/people/bail-3", 
        "https://www.zhihu.com/people/normanhere", 
        "https://www.zhihu.com/people/fu-sheng-ruo-meng-95", 
        "https://www.zhihu.com/people/smark-share", 
        "https://www.zhihu.com/people/catcherxuefeng", 
        "https://www.zhihu.com/people/lu-hong-2-87", 
        "https://www.zhihu.com/people/xu-hai-long-20-7", 
        "https://www.zhihu.com/people/chpchcpc", 
        "https://www.zhihu.com/people/huang-qi-chun", 
        "https://www.zhihu.com/people/lao-mao-38-1", 
        "https://www.zhihu.com/people/eric-wu-1", 
        "https://www.zhihu.com/people/wu-kong-95-10", 
        "https://www.zhihu.com/people/li-xiao-wu-28-43-76", 
        "https://www.zhihu.com/people/huang-yue-lai-49", 
        "https://www.zhihu.com/people/sweet-shaw", 
        "https://www.zhihu.com/people/wu-hao-le-77", 
        "https://www.zhihu.com/people/wangofjian", 
        "https://www.zhihu.com/people/xiao-zhou-53-84", 
        "https://www.zhihu.com/people/luo-xing-ke", 
        "https://www.zhihu.com/people/saintfei", 
        "https://www.zhihu.com/people/he-chong-88", 
        "https://www.zhihu.com/people/wo-shi-jiao-colin", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/datura-10", 
        "https://www.zhihu.com/people/shicui-33", 
        "https://www.zhihu.com/people/tie-dao-zhuan-jia-zhang-shi-mai", 
        "https://www.zhihu.com/people/zgaoq", 
        "https://www.zhihu.com/people/kylingx", 
        "https://www.zhihu.com/people/xvjiahe", 
        "https://www.zhihu.com/people/jun-lei-15", 
        "https://www.zhihu.com/people/liu-hao-39-60", 
        "https://www.zhihu.com/people/zhou-le-yan-18", 
        "https://www.zhihu.com/people/vincent-19-69", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/yang-jun-yi-98-1"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88747987", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "EFK教程 - 基于多节点ES的EFK安装部署配置", 
            "content": "<p><b>通过部署elasticsearch（三节点）+filebeat+kibana快速入门EFK，并搭建起可用的demo环境测试效果</b></p><p>作者：<b>“发颠的小狼”</b>，欢迎转载与投稿</p><hr/><h2>目录</h2><p>▪ 用途</p><p>▪ 实验架构</p><p>▪ EFK软件安装</p><p>▪ elasticsearch配置</p><p>▪ filebeat配置</p><p>▪ kibana配置</p><p>▪ 启动服务</p><p>▪ kibana界面配置</p><p>▪ 测试</p><p>▪ 后续文章</p><hr/><h2>用途</h2><p>▷ 通过filebeat实时收集nginx访问日志、传输至elasticsearch集群</p><p>▷ filebeat将收集的日志传输至elasticsearch集群</p><p>▷ 通过kibana展示日志</p><hr/><h2>实验架构</h2><p>▷ 服务器配置</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a31cfb931a0fec56bd354cd978271cd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1052\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"1052\" data-original=\"https://pic4.zhimg.com/v2-a31cfb931a0fec56bd354cd978271cd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1052&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1052\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1052\" data-original=\"https://pic4.zhimg.com/v2-a31cfb931a0fec56bd354cd978271cd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a31cfb931a0fec56bd354cd978271cd7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>▷ 架构图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b9550d20a262320d4a89e161be86f569_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1534\" data-rawheight=\"1406\" class=\"origin_image zh-lightbox-thumb\" width=\"1534\" data-original=\"https://pic2.zhimg.com/v2-b9550d20a262320d4a89e161be86f569_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1534&#39; height=&#39;1406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1534\" data-rawheight=\"1406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1534\" data-original=\"https://pic2.zhimg.com/v2-b9550d20a262320d4a89e161be86f569_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b9550d20a262320d4a89e161be86f569_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>EFK软件安装</h2><p><b>版本说明</b></p><p>▷ elasticsearch 7.3.2</p><p>▷ filebeat 7.3.2</p><p>▷ kibana 7.3.2</p><p><b>注意事项</b></p><p>▷ 三个组件版本必须一致</p><p>▷ elasticsearch必须3台以上且总数量为单数</p><p><b>安装路径</b></p><p>▷ /opt/elasticsearch</p><p>▷ /opt/filebeat</p><p>▷ /opt/kibana</p><p><b>elasticsearch安装</b>：3台es均执行相同的安装步骤</p><div class=\"highlight\"><pre><code class=\"language-text\">mkdir -p /opt/software &amp;&amp; cd /opt/software\nwget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.3.2-linux-x86_64.tar.gz\ntar -zxvf elasticsearch-7.3.2-linux-x86_64.tar.gz\nmv elasticsearch-7.3.2 /opt/elasticsearch\nuseradd elasticsearch -d /opt/elasticsearch -s /sbin/nologin\nmkdir -p /opt/logs/elasticsearch\nchown elasticsearch.elasticsearch /opt/elasticsearch -R\nchown elasticsearch.elasticsearch /opt/logs/elasticsearch -R\n\n# 限制一个进程可以拥有的VMA(虚拟内存区域)的数量要超过262144，不然elasticsearch会报max virtual memory areas vm.max_map_count [65535] is too low, increase to at least [262144]\necho &#34;vm.max_map_count = 655350&#34; &gt;&gt; /etc/sysctl.conf \nsysctl -p</code></pre></div><p><b>filebeat安装</b></p><div class=\"highlight\"><pre><code class=\"language-text\">mkdir -p /opt/software &amp;&amp; cd /opt/software\nwget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.3.2-linux-x86_64.tar.gz\nmkdir -p /opt/logs/filebeat/\ntar -zxvf filebeat-7.3.2-linux-x86_64.tar.gz \nmv filebeat-7.3.2-linux-x86_64 /opt/filebeat</code></pre></div><p><b>kibana安装</b></p><div class=\"highlight\"><pre><code class=\"language-text\">mkdir -p /opt/software &amp;&amp; cd /opt/software\nwget https://artifacts.elastic.co/downloads/kibana/kibana-7.3.2-linux-x86_64.tar.gz\ntar -zxvf kibana-7.3.2-linux-x86_64.tar.gz \nmv kibana-7.3.2-linux-x86_64 /opt/kibana\nuseradd kibana -d /opt/kibana -s /sbin/nologin\nchown kibana.kibana /opt/kibana -R</code></pre></div><p><b>nginx安装</b>（用于生成日志，被filebeat收集）</p><div class=\"highlight\"><pre><code class=\"language-text\"># 只在192.168.1.11安装\nyum install -y nginx\n/usr/sbin/nginx -c /etc/nginx/nginx.conf</code></pre></div><hr/><h2>elasticsearch配置</h2><p>▷ 192.168.1.31 /opt/elasticsearch/config/elasticsearch.yml</p><div class=\"highlight\"><pre><code class=\"language-text\"># 集群名字\ncluster.name: my-application\n\n# 节点名字\nnode.name: 192.168.1.31\n\n# 日志位置\npath.logs: /opt/logs/elasticsearch\n\n# 本节点访问IP\nnetwork.host: 192.168.1.31\n\n# 本节点访问\nhttp.port: 9200\n\n# 节点运输端口\ntransport.port: 9300\n\n# 集群中其他主机的列表\ndiscovery.seed_hosts: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合\ncluster.initial_master_nodes: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 启用跨域资源共享\nhttp.cors.enabled: true\nhttp.cors.allow-origin: &#34;*&#34;\n\n# 只要有2台数据或主节点已加入集群，就可以恢复\ngateway.recover_after_nodes: 2</code></pre></div><p>▷ 192.168.1.32 /opt/elasticsearch/config/elasticsearch.yml</p><div class=\"highlight\"><pre><code class=\"language-text\"># 集群名字\ncluster.name: my-application\n\n# 节点名字\nnode.name: 192.168.1.32\n\n# 日志位置\npath.logs: /opt/logs/elasticsearch\n\n# 本节点访问IP\nnetwork.host: 192.168.1.32\n\n# 本节点访问\nhttp.port: 9200\n\n# 节点运输端口\ntransport.port: 9300\n\n# 集群中其他主机的列表\ndiscovery.seed_hosts: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合\ncluster.initial_master_nodes: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 启用跨域资源共享\nhttp.cors.enabled: true\nhttp.cors.allow-origin: &#34;*&#34;\n\n# 只要有2台数据或主节点已加入集群，就可以恢复\ngateway.recover_after_nodes: 2</code></pre></div><p>▷ 192.168.1.33 /opt/elasticsearch/config/elasticsearch.yml</p><div class=\"highlight\"><pre><code class=\"language-text\"># 集群名字\ncluster.name: my-application\n\n# 节点名字\nnode.name: 192.168.1.33\n\n# 日志位置\npath.logs: /opt/logs/elasticsearch\n\n# 本节点访问IP\nnetwork.host: 192.168.1.33\n\n# 本节点访问\nhttp.port: 9200\n\n# 节点运输端口\ntransport.port: 9300\n\n# 集群中其他主机的列表\ndiscovery.seed_hosts: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合\ncluster.initial_master_nodes: [&#34;192.168.1.31&#34;, &#34;192.168.1.32&#34;, &#34;192.168.1.33&#34;]\n\n# 启用跨域资源共享\nhttp.cors.enabled: true\nhttp.cors.allow-origin: &#34;*&#34;\n\n# 只要有2台数据或主节点已加入集群，就可以恢复\ngateway.recover_after_nodes: 2</code></pre></div><hr/><h2>filebeat配置</h2><p>192.168.1.11 /opt/filebeat/filebeat.yml</p><div class=\"highlight\"><pre><code class=\"language-text\"># 文件输入\nfilebeat.inputs:\n  # 文件输入类型\n  - type: log\n    # 开启加载\n    enabled: true\n    # 文件位置\n    paths:\n      - /var/log/nginx/access.log\n    # 自定义参数\n    fields:\n      type: nginx_access  # 类型是nginx_access,和上面fields.type是一致的\n\n# 输出至elasticsearch\noutput.elasticsearch:\n  # elasticsearch集群\n  hosts: [&#34;http://192.168.1.31:9200&#34;,\n          &#34;http://192.168.1.32:9200&#34;,\n          &#34;http://192.168.1.33:9200&#34;]\n\n  # 索引配置\n  indices:\n    # 索引名\n    - index: &#34;nginx_access_%{+yyy.MM}&#34;\n      # 当类型是nginx_access时使用此索引\n      when.equals:\n        fields.type: &#34;nginx_access&#34;\n\n# 关闭自带模板\nsetup.template.enabled: false\n\n# 开启日志记录\nlogging.to_files: true\n# 日志等级\nlogging.level: info\n# 日志文件\nlogging.files:\n  # 日志位置\n  path: /opt/logs/filebeat/\n  # 日志名字\n  name: filebeat\n  # 日志轮转期限，必须要2~1024\n  keepfiles: 7\n  # 日志轮转权限\n  permissions: 0600</code></pre></div><hr/><h2>kibana配置</h2><p>192.168.1.21 /opt/kibana/config/kibana.yml</p><div class=\"highlight\"><pre><code class=\"language-text\"># 本节点访问端口\nserver.port: 5601\n\n# 本节点IP\nserver.host: &#34;192.168.1.21&#34;\n\n# 本节点名字\nserver.name: &#34;192.168.1.21&#34;\n\n# elasticsearch集群IP\nelasticsearch.hosts: [&#34;http://192.168.1.31:9200&#34;,\n                      &#34;http://192.168.1.32:9200&#34;,\n                      &#34;http://192.168.1.33:9200&#34;]</code></pre></div><hr/><h2>启动服务</h2><div class=\"highlight\"><pre><code class=\"language-text\"># elasticsearch启动（3台es均启动）\nsudo -u elasticsearch /opt/elasticsearch/bin/elasticsearch\n\n# filebeat启动\n/opt/filebeat/filebeat -e -c /opt/filebeat/filebeat.yml -d &#34;publish&#34;\n\n# kibana启动\nsudo -u kibana /opt/kibana/bin/kibana -c /opt/kibana/config/kibana.yml</code></pre></div><p>上面的启动方法是位于前台运行。systemd配置方法，会在《EFK教程》系列后续文章中提供，敬请关注！</p><hr/><h2>kibana界面配置</h2><p>1️⃣ 使用浏览器访问192.168.1.21:5601，看到以下界面表示启动成功</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-26afa71f754062debe61f5bcce43863c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1390\" data-rawheight=\"1346\" class=\"origin_image zh-lightbox-thumb\" width=\"1390\" data-original=\"https://pic1.zhimg.com/v2-26afa71f754062debe61f5bcce43863c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1390&#39; height=&#39;1346&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1390\" data-rawheight=\"1346\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1390\" data-original=\"https://pic1.zhimg.com/v2-26afa71f754062debe61f5bcce43863c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-26afa71f754062debe61f5bcce43863c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2️⃣ 点&#34;Try our sample data&#34;</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-482d92ebf9cf2b1365e55e841a191be9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1322\" data-rawheight=\"1406\" class=\"origin_image zh-lightbox-thumb\" width=\"1322\" data-original=\"https://pic2.zhimg.com/v2-482d92ebf9cf2b1365e55e841a191be9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1322&#39; height=&#39;1406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1322\" data-rawheight=\"1406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1322\" data-original=\"https://pic2.zhimg.com/v2-482d92ebf9cf2b1365e55e841a191be9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-482d92ebf9cf2b1365e55e841a191be9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3️⃣ &#34;Help us improve the Elastic Stack by providing usage statistics for basic features. We will not share this data outside of Elastic&#34;点&#34;no”</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9942018e1428eff7de2b9463000188e3_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2306\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"2306\" data-original=\"https://pic4.zhimg.com/v2-9942018e1428eff7de2b9463000188e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2306&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2306\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2306\" data-original=\"https://pic4.zhimg.com/v2-9942018e1428eff7de2b9463000188e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9942018e1428eff7de2b9463000188e3_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4️⃣ &#34;Add Data to kibana&#34;点&#34;Add data&#34;</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b6a5c049e269ead1623b3b6bf979cdd0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2568\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"2568\" data-original=\"https://pic1.zhimg.com/v2-b6a5c049e269ead1623b3b6bf979cdd0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2568&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2568\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2568\" data-original=\"https://pic1.zhimg.com/v2-b6a5c049e269ead1623b3b6bf979cdd0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b6a5c049e269ead1623b3b6bf979cdd0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>5️⃣ 进入视图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6e8eb299fa2ac963e293ac45044c25ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2696\" data-rawheight=\"1310\" class=\"origin_image zh-lightbox-thumb\" width=\"2696\" data-original=\"https://pic3.zhimg.com/v2-6e8eb299fa2ac963e293ac45044c25ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2696&#39; height=&#39;1310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2696\" data-rawheight=\"1310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2696\" data-original=\"https://pic3.zhimg.com/v2-6e8eb299fa2ac963e293ac45044c25ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6e8eb299fa2ac963e293ac45044c25ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>测试</h2><p><b>访问nginx，生成日志</b></p><div class=\"highlight\"><pre><code class=\"language-text\">curl -I &#34;http://192.168.1.11&#34;</code></pre></div><p><b>在kibana上查看数据</b></p><p>1️⃣ 创建索引模板</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-af96b1bda598633983a23fbcb3ad5f74_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1777\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"1777\" data-original=\"https://pic1.zhimg.com/v2-af96b1bda598633983a23fbcb3ad5f74_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1777&#39; height=&#39;628&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1777\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1777\" data-original=\"https://pic1.zhimg.com/v2-af96b1bda598633983a23fbcb3ad5f74_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-af96b1bda598633983a23fbcb3ad5f74_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2️⃣ 输入你要创建的索引模板的名字</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3ec728e47b82b800560b3c21269aab14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"1177\" data-original=\"https://pic1.zhimg.com/v2-3ec728e47b82b800560b3c21269aab14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1177&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1177\" data-original=\"https://pic1.zhimg.com/v2-3ec728e47b82b800560b3c21269aab14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3ec728e47b82b800560b3c21269aab14_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-daf8655ac0e687611144f0817472091d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb\" width=\"1177\" data-original=\"https://pic2.zhimg.com/v2-daf8655ac0e687611144f0817472091d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1177&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1177\" data-original=\"https://pic2.zhimg.com/v2-daf8655ac0e687611144f0817472091d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-daf8655ac0e687611144f0817472091d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3️⃣ 查看之前curl的数据</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-235cb59287ef60854e331a477fbb58e5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1903\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb\" width=\"1903\" data-original=\"https://pic2.zhimg.com/v2-235cb59287ef60854e331a477fbb58e5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1903&#39; height=&#39;483&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1903\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1903\" data-original=\"https://pic2.zhimg.com/v2-235cb59287ef60854e331a477fbb58e5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-235cb59287ef60854e331a477fbb58e5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-87a1f9fa2edef1c59c2655d8b55bd54c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1856\" data-rawheight=\"878\" class=\"origin_image zh-lightbox-thumb\" width=\"1856\" data-original=\"https://pic1.zhimg.com/v2-87a1f9fa2edef1c59c2655d8b55bd54c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1856&#39; height=&#39;878&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1856\" data-rawheight=\"878\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1856\" data-original=\"https://pic1.zhimg.com/v2-87a1f9fa2edef1c59c2655d8b55bd54c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-87a1f9fa2edef1c59c2655d8b55bd54c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>后续文章</h2><p>本文是《EFK教程》系列文章的第一篇，后续EFK文章将逐步发布，包含角色分离、性能优化等许多干货，敬请关注！</p>", 
            "topic": [
                {
                    "tag": "Kibana", 
                    "tagLink": "https://api.zhihu.com/topics/20182678"
                }, 
                {
                    "tag": "Filebeat", 
                    "tagLink": "https://api.zhihu.com/topics/20207373"
                }, 
                {
                    "tag": "Elasticsearch", 
                    "tagLink": "https://api.zhihu.com/topics/19899427"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87637717", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 1, 
            "title": "基于KVM的SRIOV直通配置及性能测试", 
            "content": "<p><b>SRIOV介绍、VF直通配置，以及包转发率性能测试</b></p><p>小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 1. SRIOV介绍</p><p>▪ 2. 环境说明</p><p>▪ 3. 开启SRIOV</p><p>▪ 4. 生成VF</p><p>▪ 5. VF直通</p><p>▪ 6. 开启irqbalance</p><p>▪ 7. VM迁移</p><p>▪ 8. 带宽限速</p><p>▪ 9. 安全</p><p>▪ 10. 其他使用限制</p><p>▪ 11. 性能测试</p><p>▪ 12. windows虚拟机使用VF</p><p>▪ 13. 运维命令</p><p>▪ 14. 宿主屏蔽VF驱动</p><p>▪ 附. 包转发率测试方法</p><p>▪ 附. 参考文档</p><hr/><h2>1. SRIOV介绍</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aabe91d369c5478d0914db75169fc6ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1195\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb\" width=\"1195\" data-original=\"https://pic3.zhimg.com/v2-aabe91d369c5478d0914db75169fc6ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1195&#39; height=&#39;396&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1195\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1195\" data-original=\"https://pic3.zhimg.com/v2-aabe91d369c5478d0914db75169fc6ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aabe91d369c5478d0914db75169fc6ea_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>▷ <b>传统方式的瓶颈</b>：qemu的网卡，传统方式是使用tap网卡，桥接到宿主的bridge上，但性能很差，尤其是包转发率很低，难以满足对性能要求比较高的场景。性能差的主要原因是路径太长，经过的内核设备太多，根本原因在于linux/unix内核本身就不是为高性能而设计的，linux/unix更适合做控制平面，而不是转发平面。</p><p>▷ <b>解决思路</b>：减少中间路径，最简单有效的方法就是bypass内核。SRIOV的作用就是bypass宿主内核。</p><p>▷ <b>PF和VF</b>：每个物理网卡（比如p1p1）就是一个PF，在开启SRIOV后，每个PF可以生成固定数量的VF，每个VF都可以在宿主上作为一张网卡直接使用，或者直通到QEMU虚拟机里作为虚拟机里的网卡使用，这就实现了bypass宿主内核。</p><p><b>先给出性能测试的结论，SRIOV VF直通相比传统tap+bridge方案，性能提升：</b></p><p>▷ 发包转发率提高: 677%</p><p>▷ 收包转发率提高: 171%</p><hr/><h2>2. 环境说明</h2><p>机型：Dell PowerEdge R620</p><p>网卡：Intel X520（82599ES）</p><p>宿主OS：CentOS 7</p><p>VM OS：CentOS 7</p><hr/><h2>3. 开启SRIOV</h2><p>1️⃣ <b>在BIOS里开启SRIOV，如图所示</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-81ab2f411fcaea2191273fe7cc507fab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"920\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"920\" data-original=\"https://pic4.zhimg.com/v2-81ab2f411fcaea2191273fe7cc507fab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;920&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"920\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"920\" data-original=\"https://pic4.zhimg.com/v2-81ab2f411fcaea2191273fe7cc507fab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-81ab2f411fcaea2191273fe7cc507fab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注：即使BIOS里开启全局SRIOV，网卡也依然可以当作普通网卡使用</p><p>2️⃣ <b>需要在BIOS里开启VT-d</b></p><p>3️⃣ <b>grub配置iommu</b></p><div class=\"highlight\"><pre><code class=\"language-text\">iommu=pt intel_iommu=on</code></pre></div><hr/><h2>4. 生成VF</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 启动网卡\nip link set p1p1 up\n\n# 查看pf的pci编号\nlshw -c network -businfo\n\n# 查看网卡支持的vf数量\ncat /sys/bus/pci/devices/0000:41:00.0/sriov_totalvfs\n\n# 生成vf，建议加入开机启动\necho 63 &gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs</code></pre></div><p>注意：若没有屏蔽宿主的VF驱动，则在生成vf后还必须等待一会时间才能在宿主上看到所有命名完成的网卡（否则会看到一堆ethX网卡），vf数量越多需要等待时间越长，63个vf，差不多需要10秒</p><hr/><h2>5. VF直通</h2><p>如果qemu是通过libvirt管理的，有3种配置方法：</p><p>▷ <b>方法1（interface）：在devices段落里加入</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;interface type=&#39;hostdev&#39; managed=&#39;yes&#39;&gt;\n  &lt;mac address=&#39;52:54:00:ad:ef:8d&#39;/&gt;\n  &lt;source&gt;\n    &lt;address type=&#39;pci&#39; domain=&#39;0x0000&#39; bus=&#39;0x41&#39; slot=&#39;0x10&#39; function=&#39;0x0&#39;/&gt;\n  &lt;/source&gt;\n  &lt;vlan&gt;\n    &lt;tag id=&#39;4010&#39;/&gt;\n  &lt;/vlan&gt;\n&lt;/interface&gt;</code></pre></div><p>上面中address的地址，可以根据“lshw -c network -businfo”来配置，比如</p><div class=\"highlight\"><pre><code class=\"language-text\">pci@0000:41:10.0 p1p1_0</code></pre></div><p>▷ <b>方法2（hostdev）：在devices段落里加入</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;hostdev mode=&#39;subsystem&#39; type=&#39;pci&#39; managed=&#39;yes&#39;&gt;\n  &lt;source&gt;\n    &lt;address domain=&#39;0x0000&#39; bus=&#39;0x41&#39; slot=&#39;0x10&#39; function=&#39;0x0&#39;/&gt;\n  &lt;/source&gt;\n&lt;/hostdev&gt;</code></pre></div><p>上面中address的地址，也是根据“lshw -c network -businfo”来配置</p><p>▷ <b>方法3（net-pool）</b></p><p>为每个PF网卡定义一个net-pool，即分别编辑一个xml文件。这里仅展示一个PF，编辑sriov-int.xml</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;network&gt;\n  &lt;name&gt;sriov-int&lt;/name&gt;\n  &lt;forward mode=&#39;hostdev&#39; managed=&#39;yes&#39;&gt;\n    &lt;pf dev=&#39;p1p1&#39;/&gt;\n  &lt;/forward&gt;\n&lt;/network&gt;</code></pre></div><p>加入到libvirt net-pool、激活、并设置开机启动</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh net-define sriov-int.xml\nvirsh net-start sriov-int\nvirsh net-autostart sriov-int</code></pre></div><p>虽然配置了net-autostart，但并不管用，因为物理机启动时候，经常会在启动生成vf（假设在rc.local里生成vf）之前就启动libvirt，而这个net-pool（sriov-int）本应该在vf生成后才能启动，因此建议在rc.local里增加如下内容来确保启动</p><div class=\"highlight\"><pre><code class=\"language-text\">ip link set p1p2 up\necho 63 &gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs\nvirsh net-start sriov-int</code></pre></div><p>然后，在vm的xml里增加</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;interface type=&#39;network&#39;&gt;\n  &lt;mac address=&#39;52:54:00:ad:ef:8d&#39;/&gt;\n  &lt;source network=&#39;sriov-int&#39;/&gt;\n  &lt;vlan&gt;\n    &lt;tag id=&#39;4010&#39;/&gt;\n  &lt;/vlan&gt;\n&lt;/interface&gt;</code></pre></div><p><b>3种方法如何选择</b></p><p>▷ 方法1：功能多，可以配置mac和vlan</p><p>▷ 方法2：mac和vlan需要自己在宿主上敲ip命令设置</p><p>▷ 方法3：有2个问题</p><p>▪ 存在一个bug，当本宿主所有vm使用某个PF的VF总数超过VF上限后，不会报错，也能启动，但是可能会有异常，并且vm如果被destroy关机，那么对应的VF就会出问题，比如使用ip link set p1p1 vf 0 mac 00:00:00:00:00:00来做重置时候，会提示“RTNETLINK answers: Cannot allocate memory”，而且难以修复，即使修复，也不知道有没有看不见的异常存在。</p><p>▪ 没有办法知道某个vm使用的是哪个vf，因此如果要对vf设置限速或者开关spoofchk时候，只能先在宿主上通过“ip link show dev p1p1 | grep MAC地址”方式来获得vf号，然后才能设置限速等操作</p><p>综上所述：使用方法3最便捷，但是存在bug，因此需要做好逻辑来防止vm使用vf总数超过上限的情况。</p><hr/><h2>6. 开启irqbalance</h2><p>x520是2队列，x710是4队列，需要在vm里启动中断平衡服务（irqbalance），否则只会有一个cpu来处理数据包。</p><p>另外，这与宿主上vf的query_rss无关。</p><hr/><h2>7. VM迁移</h2><p>直通网卡属于PCI设备，而libvirt和qemu却不支持带有非USB的PCI设备的vm做迁移，包括冷迁移和热迁移。因此热迁移无法实现。</p><p>冷迁移，有2种方案:</p><p>▷ detach掉vf网卡，然后使用libvirt做迁移，迁移过去后，再在新宿主上attach vf网卡</p><p>▷ undefine vm，然后在新宿主上重新渲染并define vm</p><p>注意：不能在vm关机时候用libvirt的迁移功能，有时候会导致虚拟机消失掉，包括原宿主和新宿主</p><hr/><h2>8. 带宽限速</h2><p><b>只能限制出站带宽，无法限制入站带宽</b></p><div class=\"highlight\"><pre><code class=\"language-text\">ip link set p1p1 vf 0 max_tx_rate 100</code></pre></div><p>表示出站带宽限速100Mbps，不同网卡有差别:</p><p>▷ x520网卡最小限速11Mbps，最大限速10000Mbps，设为0表示不限速。<b>若小于11或大于10000则会报错</b></p><p>▷ x710网卡最小限速50Mbps，最大限速10000Mbps，设为0表示不限速。<b>若小于50则自动设为50，若大于10000则会报错</b></p><p>注意：vm关机后vf的带宽限速不会复位</p><hr/><h2>9. 安全</h2><p>仅支持源mac过滤和网卡mac防篡改，不支持其他安全防护（防arp欺骗就无法实现）</p><p><b>源mac过滤</b></p><div class=\"highlight\"><pre><code class=\"language-text\">ip link set p1p1 vf 0 spoofchk on</code></pre></div><p>表示vm里发出的包，如果源mac不是指定mac，那么数据包不允许通过。注意：vm关机后vf的spoofchk不会复位</p><p><b>网卡mac防篡改</b></p><p>▷ 在宿主上修改mac，vm里的mac不会跟着改；在vm里修改mac，在宿主上可以看到变化</p><p>▷ 如果在vm关机状态下改了mac地址，那么当vm开机后会改为vm的mac，当vm又关机后，又回改为原先改的mac</p><p>▷ 只有在宿主上看到的当前vf的mac为全0，才能在vm里修改mac地址，即使vf的spoofchk为off。但有一种例外，若使用上面方法2来配置xml，虽然宿主上看到的vf的mac不为0，但vm里可以修改</p><p>▷ 当在宿主上设置了mac后，虚拟机里的mac就无法篡改了</p><p>▪ 方法1（interface）来配置xml，估计vm启动时候就自动帮忙在宿主上设置了mac，所以就直接实现了防篡改功能</p><p>▪ 方法2（hostdev）来配置xml，需要在宿主上手动再设置一次mac地址才能实现防篡改</p><p>在宿主上手动修改mac方法（vm关机和开机情况下都可以改）:</p><div class=\"highlight\"><pre><code class=\"language-text\">ip link set p1p1 vf 0 mac aa:bb:cc:dd:ee:ff</code></pre></div><p>建议:</p><p>▷ 在vm启动前对vf做一次重置</p><p>▷ 在vm undefine后对vf做一次重置</p><hr/><h2>10. 其他使用限制</h2><p>▷ 直通到vm里的vf网卡里无法桥接到vm里的linux bridge，这也导致ebtables无法使用，iptables可以使用</p><p>▷ 直通到vm里的vf网卡可以加入ovs桥接</p><p>▷ 一个vm最多只能支持32个vf，超过数量会报错</p><hr/><h2>11. 性能测试</h2><p><b>测试方法：</b></p><p>▷ 多台vm同时发包，一台vm收包，分别观察发包性能和收包性能</p><p>▷ 发包vm在同一台宿主上，收包vm在另一台宿主上</p><p>▷ 测试工具：modprobe pktgen</p><p>▷ 测试包大小: udp包，size为64 bytes</p><p><b>配置：</b></p><p>▷ vm配置均为4核8G</p><p>▷ 物理网卡均为x520（vf队列默认为2）</p><p>▷ 宿主和vm均开启irqbalance、均关闭numad</p><p>▷ 不配置cpu绑定、不配置numa绑定</p><p>▷ 开启大页</p><p><b>测试结果：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ad719d098d9a8e421ece71a5bddec438_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2718\" data-rawheight=\"840\" class=\"origin_image zh-lightbox-thumb\" width=\"2718\" data-original=\"https://pic1.zhimg.com/v2-ad719d098d9a8e421ece71a5bddec438_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2718&#39; height=&#39;840&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2718\" data-rawheight=\"840\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2718\" data-original=\"https://pic1.zhimg.com/v2-ad719d098d9a8e421ece71a5bddec438_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ad719d098d9a8e421ece71a5bddec438_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>测试结论：</b></p><p>使用SR-IOV+VF直通方式可以明显提升包转发率，1对1的测试结果看到<b>kernel态发包可以达到3.5Mpps，收包可以达到1.9Mpps</b></p><p>▷ 发包比vxlan提高: 1196%，比vlan提高: 677%。此结果参考1对1（1个发包vm，1个收包vm）</p><p>▷ 收包比vxlan提高: 363%，比vlan提高: 171%。此结果参考3对1（3个发包vm，1个收包vm）</p><p><b>说明：</b></p><p>▷ kernel态单核数据包(64B)处理能力为2Mpps</p><p>▷ 2Mpps是因为kernel态瓶颈是2Mpps，如果通过dpdk走用户态，则可以大于2M，原因：收包端要将数据包中断平衡到不同的cpu上，方法：可以通过多队列方式，把每个队列分配到单独cpu上（irqbalance会自动均衡），然后source ip不一样，就会对应到不同队列，也就是不同的中断上。即1个VF，2个队列，VM有至少2核，那么当符合负载均衡条件（mac、ip不同），则理论上最大可以达到4Mpps</p><p><b>更多测试结果：</b></p><p>以下测试使用的packet大小为64B</p><p>▷ kernel态，3层转发性能:发包器使用不同的source ip</p><p>▪ BCM57800:2Mpps</p><p>▪ Intel X520:10Mpps</p><p>▪ Intel X710:12Mpps</p><p>▷ kernel态，2层转发性能:发包器使用不同的source mac</p><p>▪ BCM57800:2Mpps</p><p>▪ Intel X520:7.3Mpps</p><p>▪ Intel X710:7.8Mpps</p><p>▷ kernel态下vxlan封装能力</p><p>▪ vxlan内层使用不同的source ip发包</p><p>▪ 收包在:1.1-1.2Mpps</p><p>▷ dpdk用户态，2层转发性能:发包器使用不同的source ip</p><p>▪ BCM57800:不支持</p><p>▪ Intel X520:14.8Mpps</p><p>▪ Intel X710:14.8Mpps</p><p>▷ SR-IOV模式</p><p>▪ X520总量11.2Mpps，每vm为11.2Mpps/vm总数(即VF数)</p><p><b>总结：</b></p><p>▷ kernel态下的中断平衡的依据因素:2层依据source mac,3层依据source ip</p><p>▷ kernel态下使用传统中断模式的单核转发能力极限2Mpps</p><p><b>注意：</b></p><p>▷ kernel态下，利用多队列RSS中断平衡提升吞吐率，会导致cpu非常高</p><p>▷ 用户态下即使source mac或source ip固定，吞吐率基本接近限速14.8Mpps</p><p>▷ vxlan不能利用多核来提升吞吐，主要原因为外层source ip不够多</p><hr/><h2>12. windows虚拟机使用VF</h2><p>到网卡官网下载对应驱动并安装，经测试，win2012默认就有82599（x520）驱动，但版本旧</p><hr/><h2>13. 运维命令</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 查看网卡支持的vf数量\ncat /sys/bus/pci/devices/0000:41:00.0/sriov_totalvfs\n\n# 宿主屏蔽VF驱动后查看vf和pf的对应\nhttps://github.com/intel/SDN-NFV-Hands-on-Samples/blob/master/SR-IOV_Network_Virtual_Functions_in_KVM/listvfs_by_pf.sh\n载下来后执行./listvfs_by_pf.sh即可\n\n# 宿主屏蔽VF后查看哪些VF正在被使用\nyum install dpdk-tools\ndpdk-devbind --status\n\n# 查看网卡对应哪个socket\nlstopo-no-graphics\n\n# lspci查看网卡信息\nlspci -Dvmm|grep -B 1 -A 4 Ethernet\n\n# 宿主上查看具体VF流量（仅支持x520，x710查不到）\nethtool -S p1p1 | grep VF</code></pre></div><hr/><h2>14. 宿主屏蔽VF驱动</h2><div class=\"highlight\"><pre><code class=\"language-text\">echo &#34;blacklist ixgbevf&#34; &gt;&gt; /etc/modprobe.d/blacklist.conf</code></pre></div><p>表示当物理机启动时候，默认不加载ixgbevf驱动，但是如果手动modprobe ixgbevf，则也会加载驱动。</p><p>如果当前已经加载了ixgbevf，想卸载，则需要如下步骤</p><div class=\"highlight\"><pre><code class=\"language-text\">echo 0 &gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs\nrmmod ixgbevf\necho 63 &gt; /sys/bus/pci/devices/0000:41:00.0/sriov_numvfs</code></pre></div><hr/><h2>附. 包转发率测试方法</h2><p><b>modprobe pktgen</b>：发包通过pktgen来发，收包通过sar -n DEV来看，发的是udp包</p><div class=\"highlight\"><pre><code class=\"language-text\">#!/bin/bash\n\nNIC=&#34;eth1&#34;\nDST_IP=&#34;192.168.1.2&#34;\nDST_MAC=&#34;52:54:00:43:99:65&#34;\n\nmodprobe pktgen\n\npg() {\n    echo inject &gt; $PGDEV\n    cat $PGDEV\n}\n\npgset() {\n    local result\n    echo $1 &gt; $PGDEV\n\n    result=`cat $PGDEV | fgrep &#34;Result: OK:&#34;`\n    if [ &#34;$result&#34; = &#34;&#34; ]; then\n         cat $PGDEV | fgrep Result:\n    fi\n}\n# Config Start Here -----------------------------------------------------------\n\n# thread config\n# Each CPU has own thread. Two CPU exammple. We add ens7, eth2 respectivly.\n\nPGDEV=/proc/net/pktgen/kpktgend_0\necho &#34;Removing all devices&#34;\npgset &#34;rem_device_all&#34;\necho &#34;Adding ${NIC}&#34;\npgset &#34;add_device ${NIC}&#34;\n\n# device config\n# delay 0 means maximum speed.\n\nCLONE_SKB=&#34;clone_skb 1000000&#34;\n# NIC adds 4 bytes CRC\nPKT_SIZE=&#34;pkt_size 64&#34;\n\n# COUNT 0 means forever\nCOUNT=&#34;count 0&#34;\nDELAY=&#34;delay 0&#34;\n\nPGDEV=/proc/net/pktgen/${NIC}\necho &#34;Configuring $PGDEV&#34;\npgset &#34;$COUNT&#34;\npgset &#34;$CLONE_SKB&#34;\npgset &#34;$PKT_SIZE&#34;\npgset &#34;$DELAY&#34;\npgset &#34;dst ${DST_IP}&#34;\npgset &#34;dst_mac ${DST_MAC}&#34;\n\n# Time to run\nPGDEV=/proc/net/pktgen/pgctrl\n\necho &#34;Running... ctrl^C to stop&#34;\npgset &#34;start&#34;\necho &#34;Done&#34;\n\n# Result can be vieved in /proc/net/pktgen/eth[3,4]</code></pre></div><p>▷ 将脚本开头的eth1改为发包对应的网卡 ▷ 将脚本开头的192.168.1.2改为目标ip ▷ 将脚本开头的52:54:00:43:99:65改为目标mac</p><p><b>pktgen-dpdk</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 固定ip固定mac\nset 0 dst ip 192.168.10.240\nset 0 src ip 192.168.10.245/24\nset 0 dst mac c8:1f:66:d7:58:ba\nset 0 src mac a0:36:9f:ec:4a:28\n\n\n# 可变source ip可变source mac\nstop 0\nrange 0 src ip 192.168.0.1 192.168.0.1 192.168.200.200 0.0.0.1\nrange 0 dst ip 10.1.1.241 10.1.1.241 10.1.1.241 0.0.0.0\nrange 0 dst mac c8:1f:66:d7:58:ba c8:1f:66:d7:58:ba c8:1f:66:d7:58:ba 00:00:00:00:00:00\nrange 0 src mac a0:36:9f:ec:4a:28 a0:36:9f:ec:4a:28 a0:36:9f:ec:ff:ff 00:00:00:00:01:01\nrange 0 src port 100 100 65530 1\nrange 0 dst port 100 100 65530 1\nrange 0 size 64 64 64 0\nenable 0 range\nenable 0 latency\nstart 0\n\n\n# 按50%的速率发包\nset 0 rate 50</code></pre></div><hr/><h2>附. 参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\"># openstack关于sriov的限制\nhttps://docs.openstack.org/mitaka/networking-guide/config-sriov.html\n\n# 迁移\nhttps://wenku.baidu.com/view/d949db67998fcc22bcd10dfd.html \nhttps://www.chenyudong.com/archives/live-migrate-with-pci-pass-through-fail-with-libvirt-and-qemu.html\n\n# sriov配置\nhttps://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/virtualization_host_configuration_and_guest_installation_guide/sect-virtualization_host_configuration_and_guest_installation_guide-sr_iov-how_sr_iov_libvirt_works\n\n# 线速\nhttp://netoptimizer.blogspot.tw/2014/05/the-calculations-10gbits-wirespeed.html</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "KVM（Kernel-based Virtual Machine）", 
                    "tagLink": "https://api.zhihu.com/topics/19607498"
                }, 
                {
                    "tag": "QEMU", 
                    "tagLink": "https://api.zhihu.com/topics/19636090"
                }, 
                {
                    "tag": "性能测试", 
                    "tagLink": "https://api.zhihu.com/topics/19618663"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85220601", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 3, 
            "title": "IPv6系列-详解自动分配IPv6地址", 
            "content": "<p><b>深入研究自动分配IPv6地址的Stateless(无状态)与Stateful(有状态)方式</b></p><p>小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 一. Link-Local Address的生成方式</p><p>▪ 二. Global Address的生成方式</p><p>▪ 三. RA报文中3个关键的Flag</p><p>▪ 四. 流程示意图</p><p>▪ 五. 测试获得IP效果</p><p>▪ 六. 应用场景（选择无状态还是有状态）</p><p>▪ 七. 后续内容</p><p>▪ 附. 参考文档</p><hr/><h2>一. Link-Local Address的生成方式</h2><p>生成“链路本地地址”，有2种方式</p><p>▷ 手动配置</p><p>▷ 自动配置</p><p>其中“自动配置”根据算法，又分为</p><p>▷ eui64：根据mac地址换算而来</p><p>▷ stable_secret：跟随网络环境的变化而变化，处于固定网络环境时其值将固定</p><p>▷ random：随机生成</p><hr/><h2>二. Global Address的生成方式</h2><p><b>生成“全球单播地址”（或者“唯一本地地址”），有2种方式</b></p><p>▷ 手动配置</p><p>▷ 自动配置</p><p><b>其中“自动配置”根据获取方式，又分为</b></p><p>▷ 无状态（Stateless）：根据路由通告报文RA（Router Advertisement）包含的prefix前缀信息自动配置IPv6地址，组成方式是Prefix + (EUI64 or 随机)。Stateless也可以称为SLAAC（Stateless address autoconfiguration）</p><p>▷ 有状态（Stateful）：通过DHCPv6方式获得IPv6地址</p><p><b>其中“有状态”又分为2种</b></p><p>▷ 有状态DHCPv6（Stateful DHCPv6）：IPv6地址、其他参数（如DNS）均通过DHCPv6获取</p><p>▷ 无状态DHCPv6（Stateless DHCPv6）：IPv6地址依然通过路由通告RA方式生成，其他参数（如DNS）通过DHCPv6获取</p><p><b>为了避免混淆，在此解释下有状态、无状态到底是什么意思</b>：首先，请明确一点，有状态、无状态仅针对于IPv6地址分配方式，并不包含其他参数</p><p>▷ 有状态：可控、可管理。在网络中存在一个IP地址管理者，它能够识别客户端，根据不同的客户端，分配对应的IPv6地址，客户端与服务端之间需要维护IP地址的租期及续约。目前实现这种效果的，就是DHCPv6协议，IP地址管理者就是DHCPv6 Server</p><p>▷ 无状态：不可控、难管理。在网络中只有网关，没有IP地址管理者。因此无人去识别客户端，每个客户端根据网关发送的相同的RA报文内容，自行配置IPv6地址</p><hr/><h2>三. RA报文中3个关键的Flag</h2><p>RA报文中存在3个关键的flag bit：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-58fab81d1e2b3817de0e462c444bb640_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2960\" data-rawheight=\"1770\" class=\"origin_image zh-lightbox-thumb\" width=\"2960\" data-original=\"https://pic1.zhimg.com/v2-58fab81d1e2b3817de0e462c444bb640_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2960&#39; height=&#39;1770&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2960\" data-rawheight=\"1770\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2960\" data-original=\"https://pic1.zhimg.com/v2-58fab81d1e2b3817de0e462c444bb640_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-58fab81d1e2b3817de0e462c444bb640_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>▷ <b>Autonomous flag</b>（简称A flag）：表示是否配置无状态IP。在一个RA报文中，可存在多个prefix，比如2401::/64、2402::/64、2403::/64，每个prefix都可以独立配置A flag</p><p>▪ 为on时（对应bit位为1）：表示客户端应当在该prefix范围内自动生成IPv6地址（客户端通过DAD自行保证地址可用），并配置子网路由条目、网关</p><p>▪ 为off时（对应bit位为0）：表示客户端不应当在该prefix范围内自动生成IPv6地址，但是可以配置子网路由条目、网关</p><p>▷ <b>Managed flag</b>（简称M flag）：表示是否配置有状态IP。M flag是RA报文的全局参数，一个RA报文只有一个M flag</p><p>▪ 为on时（对应bit位为1）：表示在stateless流程结束后开始stateful流程，也就是告诉客户端可以通过DHCPv6来获得IPv6地址和其他参数（如DNS列表）</p><p>▪ 为off时（对应bit位为0）：表示不通过DHCPv6来获得IPv6地址。</p><p>▷ <b>Other flag</b>（简称O flag）：表示是否通过DHCPv6获得除IP以外的其他参数（如DNS列表）。O flag也是RA报文中的全局参数，一个RA报文只有一个O flag。注意：仅当M flag为off时，该参数才会被读取。</p><p>▪ 为on时（对应bit位为1）：当M flag为on，或者M flag为off且至少有一个A flag为on时，将通过DHCPv6获得其他参数</p><p>▪ 为off时（对应bit位为0）：当M flag为on时，依然将通过DHCPv6获得其他参数；当M flag也为off时，将不通过DHCPv6获得其他参数</p><hr/><h2>四. 流程示意图</h2><p>无状态和有状态并不是相互对立的，他们可以同时存在，也就是一张网卡上可以同时出现通过RA生成的IP以及通过DHCPv6获得的IP。通过下面这张笔者绘制的流程图可知晓其中奥秘。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f99b35995da86ec0d054aad261dfe567_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2450\" data-rawheight=\"3428\" class=\"origin_image zh-lightbox-thumb\" width=\"2450\" data-original=\"https://pic4.zhimg.com/v2-f99b35995da86ec0d054aad261dfe567_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2450&#39; height=&#39;3428&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2450\" data-rawheight=\"3428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2450\" data-original=\"https://pic4.zhimg.com/v2-f99b35995da86ec0d054aad261dfe567_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f99b35995da86ec0d054aad261dfe567_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中可以看到，顺序为：</p><p>1️⃣ Stateless自动配置“链路本地地址”</p><p>2️⃣ Stateless自动配置“全球地址”（或“唯一本地地址”）</p><p>3️⃣ Stateful自动配置“全球地址”（或“唯一本地地址”）和其他参数，其中Stateful阶段中存在Stateful DHCPv6或Stateless DHCPv6</p><p>注意：部分客户端操作系统或网络管理器当Stateless阶段没有收到RA报文后，就到此结束，不会走Stateful阶段，比如CentOS 7、Ubuntu 17的默认逻辑都是这样，而windows server 2012就会继续走Stateful阶段。</p><hr/><h2>五. 测试获得IP效果</h2><p><b>测试环境</b>：客户端基于CentOS 7+NetworkManager（即系统默认的网络管理方式）进行测试</p><p>▪ 网关会发送RA报文，包含一个prefix</p><p>▪ DHCPv6 Server会分配IP、DNS</p><p><b>测试内容</b>：测试M、O、A flag在所有排列组合的情况下</p><p>▪ 客户端是否会通过RA报文配置无状态IP</p><p>▪ 客户端是否会通过RA报文配置prefix子网路由</p><p>▪ 客户端是否会通过RA报文配置gateway</p><p>▪ 客户端是否会通过DHCPv6获得有状态IP</p><p>▪ 客户端是否会通过DHCPv6获得DNS</p><p><b>测试结果</b>：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-62589560c6a7fcc4f5604884b4e8d40f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1580\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"1580\" data-original=\"https://pic4.zhimg.com/v2-62589560c6a7fcc4f5604884b4e8d40f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1580&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1580\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1580\" data-original=\"https://pic4.zhimg.com/v2-62589560c6a7fcc4f5604884b4e8d40f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-62589560c6a7fcc4f5604884b4e8d40f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>六. 应用场景（选择无状态还是有状态）</h2><p>何时采用无状态、何时采用有状态，关键看应用场景。核心在于是否需要控制IP地址，比如保持IP不变，如果需要控制，就采用有状态；如果无需控制，就采用无状态。</p><p>▷ 服务端领域：如对外提供服务，通常需要采用有状态IP。因为业务IP的突然变化容易导致业务中断（除非做好服务发现）</p><p>▷ 客户端领域：如移动设备、办公室内PC机，只需要上IPv6互联网，并不需要对外提供服务，可以采用无状态IP</p><hr/><h2>七. 后续内容</h2><p>由于篇幅有限，本文尚未贴出实验的详细配置。将会在《IPv6系列》后续文章里，贴出实验的完整信息，包括RA、DHCPv6的配置，以及客户端的配置，敬请关注。</p><hr/><h2>附. 参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\">http://www.6deploy.eu/tutorials/080-6deploy_ipv6_autoconfiguration_mechs_v0_4.pdf\nhttps://cshihong.github.io/2018/02/01/DHCPv6基础/</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "TCP/IP", 
                    "tagLink": "https://api.zhihu.com/topics/19614019"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }, 
                {
                    "tag": "IPv6", 
                    "tagLink": "https://api.zhihu.com/topics/19556734"
                }
            ], 
            "comments": [
                {
                    "userName": "m0618", 
                    "userLink": "https://www.zhihu.com/people/4aea6e5d20da8ca3b4198c0b749c94b8", 
                    "content": "大佬赶紧发下一篇吧，就等你发啦，等着学习呢", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "谢谢支持[捂嘴]", 
                            "likes": 0, 
                            "replyToAuthor": "m0618"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>最近看过对IPv6自动分配地址解释得最简明扼要的一篇。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "谢谢[害羞]", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "chiles", 
                    "userLink": "https://www.zhihu.com/people/e5bbaaf93d9a6cae8e1577ea76bc088d", 
                    "content": "<p>大佬，我发现SLAAC方式拿不到网关地址，这个是正常的吗？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "具体情况描述下", 
                            "likes": 0, 
                            "replyToAuthor": "chiles"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82594400", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "GO学习笔记 - 数据校验", 
            "content": "<p><b>本文主题：基于asaskevich/govalidator实现Golang数据校验</b></p><p>小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 一. asaskevich/govalidator介绍</p><p>▪ 二. 字符串匹配</p><p>▪ 三. struct元素匹配</p><p>▪ 四. struct元素可选验证</p><p>▪ 五. struct嵌套校验</p><p>▪ 六. 无法实现嵌套的可选校验</p><p>▪ 七. 个人最佳实践</p><p>▪ 八. 其他功能</p><p>▪ 附录1. 字符串合法性校验</p><p>▪ 附录2. struct元素校验项</p><p>▪ 附录3. 数据特征匹配</p><p>▪ 附录4. 类型转换</p><p>▪ 附录5. 裁剪、处理、填充、遍历等</p><hr/><h2>一. asaskevich/govalidator介绍</h2><p>godoc里可以搜到若干相似的第三方数据校验模块，但笔者推荐使用asaskevich/govalidator，原因：</p><p>▷ star最多、持续更新发布</p><p>▷ 功能完善、使用便利</p><p>▷ 丰富的字符串校验、数据匹配、裁剪拼接处理等</p><p>▷ 支持struct元素合法性校验，并且支持嵌套检查</p><p>▷ 源码值得学习，就是一个百宝箱</p><div class=\"highlight\"><pre><code class=\"language-text\">// 下载\ngo get github.com/asaskevich/govalidator</code></pre></div><p>注意：查看使用方法到github，查看支持的函数列表到godoc</p><div class=\"highlight\"><pre><code class=\"language-text\">https://github.com/asaskevich/govalidator\nhttps://godoc.org/github.com/asaskevich/govalidator</code></pre></div><hr/><h2>二. 字符串匹配</h2><p>govalidator支持非常多种字符串匹配，先贴上一个简单例子</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;fmt&#34;\n    &#34;github.com/asaskevich/govalidator&#34;\n)\n\nfunc main() {\n    // 判断字符串值是否为合法的IPv4地址\n    ip4 := &#34;192.168.1.1&#34;\n    fmt.Println(govalidator.IsIPv4(ip4)) // true\n\n    // 判断字符串值是否为合法的MAC\n    mac := &#34;aa:bb:cc:dd:ee:ffffff&#34;\n    fmt.Println(govalidator.IsMAC(mac)) // false\n\n    // 判断数字是否在指定范围内\n    dig := 101    // string类型也可以用\n    fmt.Println(govalidator.InRange(dig, 0, 100)) // false\n}</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">true\nfalse\nfalse</code></pre></div><p><b>完整的可用校验方法列表详见本文附录1、3</b></p><hr/><h2>三. struct元素匹配</h2><p>govalidator专门提供了一个函数，用于校验struct的元素</p><div class=\"highlight\"><pre><code class=\"language-text\">govalidator.ValidateStruct()</code></pre></div><p>简单例子</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;fmt&#34;\n    &#34;github.com/asaskevich/govalidator&#34;\n)\n\ntype foo struct {\n    A string `valid:&#34;ipv4&#34;`\n    B string `valid:&#34;mac&#34;`\n    C string `valid:&#34;range(0|100)&#34;`    // 也可以使用int类型\n}\n\nfunc main() {\n    f := foo{\n        A: &#34;192.168.1.1&#34;,\n        B: &#34;aa:bb:cc:dd:ee:ffffff&#34;,\n        C: &#34;101&#34;,\n    }\n\n    result, err := govalidator.ValidateStruct(f)\n    if err != nil {\n        fmt.Println(&#34;error: &#34; + err.Error())\n    }\n    fmt.Println(result)\n}</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">error: B: aa:bb:cc:dd:ee:ffffff does not validate as mac;C: 101 does not validate as range(0|100)\nfalse</code></pre></div><p>注意：</p><p>▪ struct元素只支持部分常用的校验，详见本文附录2</p><p>▪ struct元素必须是导出型，也就是必须大写字母开头，govalidator才会去理会</p><p>▪ struct元素匹配较为智能，比如range(min|max)不仅支持string也支持int类型</p><hr/><h2>四. struct元素可选验证</h2><p>govalidator有一个bool类型的全局变量，可通过函数govalidator.SetFieldsRequiredByDefault()进行设置：</p><p>▷ 当设置为true时，如果没有定义valid tag，则会提示错误</p><p>▷ 当设置为false时，如果没有定义valid tag，不会提示错误。默认值就是false</p><p>另外，valid tag里，可以通过显式设置方式更细颗粒度地控制：当遇到zero value时是需要验证还是提示错误。此设置可以覆盖SetFieldsRequiredByDefault()。所以，valid tag有如下几种写法</p><div class=\"highlight\"><pre><code class=\"language-text\">`valid:&#34;&#34;` // 等同于空tag，即``\n`valid:&#34;-&#34;`\n`valid:&#34;,&#34;`\n`valid:&#34;,optional`\n`valid:&#34;,required`</code></pre></div><p>接下来，分别测试：假设一个struct元素的值为空字符&#34;&#34;（即zero value）</p><p>▷ govalidator.SetFieldsRequiredByDefault(true)</p><div class=\"highlight\"><pre><code class=\"language-text\">`valid:&#34;&#34;`    // 报错：All fields are required to at least have one validation defined\n`valid:&#34;-&#34;`    // true\n`valid:&#34;,&#34;`    // 报错：Missing required field\n`valid:&#34;,optional`    // true\n`valid:&#34;,required`    // 报错：non zero value required\n`valid:&#34;ipv4&#34;`    // 报错：Missing required field\n`valid:&#34;ipv4,optional&#34;`    // true\n`valid:&#34;ipv4,required&#34;`    // 报错：non zero value required</code></pre></div><p>▷ govalidator.SetFieldsRequiredByDefault(false)</p><div class=\"highlight\"><pre><code class=\"language-text\">`valid:&#34;&#34;`    // true\n`valid:&#34;-&#34;`    // true\n`valid:&#34;,&#34;`    // true\n`valid:&#34;,optional`    // true\n`valid:&#34;,required`    // non zero value required\n`valid:&#34;ipv4&#34;`    // true\n`valid:&#34;ipv4,optional&#34;`    // true\n`valid:&#34;ipv4,required&#34;`    // 报错：non zero value required</code></pre></div><p>继续测试，当struct元素的值为不合法的ipv4地址字符串（非空字符串），如&#34;192.168.1.1.1&#34;</p><p>▷ govalidator.SetFieldsRequiredByDefault(true)</p><div class=\"highlight\"><pre><code class=\"language-text\">`valid:&#34;&#34;`    // 报错：All fields are required to at least have one validation defined\n`valid:&#34;-&#34;`    // true\n`valid:&#34;,&#34;`    // true\n`valid:&#34;,optional`    // true\n`valid:&#34;,required`    // true\n`valid:&#34;ipv4&#34;`    // 报错：192.168.1.1.1 does not validate as ipv4\n`valid:&#34;ipv4,optional&#34;`    // 报错：192.168.1.1.1 does not validate as ipv4\n`valid:&#34;ipv4,required&#34;`    // 报错：192.168.1.1.1 does not validate as ipv4</code></pre></div><p>▷ govalidator.SetFieldsRequiredByDefault(false)：测试效果和上述完全相同</p><p>另外，还有一个全局变量参数，通过govalidator.SetNilPtrAllowedByRequired()设置，但由于笔者尚未测试过，因此直接贴出官方解释</p><div class=\"highlight\"><pre><code class=\"language-text\">// 来自github\nSetNilPtrAllowedByRequired causes validation to pass when struct fields marked by required are set to nil. This is disabled by default for consistency, but some packages that need to be able to determine between nil and zero value state can use this. If disabled, both nil and zero values cause validation errors.\n\n// 来自godoc\nSetNilPtrAllowedByRequired causes validation to pass for nil ptrs when a field is set to required. The validation will still reject ptr fields in their zero value state. Example with this enabled:\n\ntype exampleStruct struct {\n    Name *string `valid:&#34;required&#34;\n\nWith `Name` set to &#34;&#34;, this will be considered invalid input and will cause a validation error. With `Name` set to nil, this will be considered valid by validation. By default this is disabled.</code></pre></div><hr/><h2>五. struct嵌套校验</h2><p>嵌套元素名必须是导出型，也就是大写字母开头，举例</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;fmt&#34;\n    &#34;github.com/asaskevich/govalidator&#34;\n)\n\ntype Foo struct {\n    A string `valid:&#34;ipv4&#34;`\n    B string `valid:&#34;mac&#34;`\n    C int `valid:&#34;range(0|100)&#34;`\n}\n\ntype bar struct {\n    X string `valid:&#34;ipv4&#34;`\n    Foo `valid:&#34;,required&#34;`\n}\n\nfunc main() {\n    govalidator.SetFieldsRequiredByDefault(true)\n\n    b := bar{\n        X: &#34;192.168.1.1&#34;,\n    }\n\n    b.Foo.A = &#34;192.168.1.1.1&#34;\n    b.Foo.B = &#34;aa:bb:cc:dd:ee:ff&#34;\n    b.Foo.C = 100\n\n    result, err := govalidator.ValidateStruct(b)\n    if err != nil {\n        fmt.Println(&#34;error: &#34; + err.Error())\n    }\n    fmt.Println(result)\n}</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">error: Foo.A: 192.168.1.1.1 does not validate as ipv4;A: 192.168.1.1.1 does not validate as ipv4\nfalse</code></pre></div><p>注意：可以给Foo设置一个元素名，但也必须是大写字母开头，比如</p><div class=\"highlight\"><pre><code class=\"language-text\">MyFoo Foo `valid:&#34;,required&#34;`    // 正确，可以读取到\nmyFoo Foo `valid:&#34;,required&#34;`    // 错误，无法读取到</code></pre></div><hr/><h2>六. 无法实现嵌套的可选校验</h2><p>无法实现以嵌套为颗粒度的可选校验，比如下面这样是没有效果的</p><div class=\"highlight\"><pre><code class=\"language-text\">type bar struct {\n    X string `valid:&#34;ipv4&#34;`\n    Foo `valid:&#34;,optional&#34;`    // 不可行\n}</code></pre></div><p>因为上面代码实际会被转换为这样</p><div class=\"highlight\"><pre><code class=\"language-text\">type bar struct {\n    X string `valid:&#34;ipv4&#34;`\n    Foo.A string `valid:&#34;ipv4&#34;`\n    Foo.B string `valid:&#34;mac&#34;`\n    Foo.C int `valid:&#34;range(0|100)&#34;`\n}</code></pre></div><p>这就导致没有办法实现Foo全校验或者全不校验</p><hr/><h2>七. 个人最佳实践</h2><p>建议全部显式配置校验，因为使用隐式一旦配置有误，难以及时发现</p><p>▷ govalidator.SetFieldsRequiredByDefault(true)</p><p>▷ valid tag写法：带上required，例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">想做验证使用`valid:ipv4,required`\n不想做验证使用`valid:&#34;,required&#34;`</code></pre></div><hr/><h2>八. 其他功能</h2><p>govalidator的校验功能还支持自定义tag与自定义校验函数，由于笔者尚未深度实践过，因此请参考官方github文档。</p><p>govalidator除了支持校验，还支持较为丰富的字符串裁剪、处理、正则等功能，以及若干类型转换功能，详见本文附录4、5（本文相比godoc和官网文档进行了更为细致的分类）。但笔者不推荐直接使用这些裁剪、处理、正则功能，因为实际上就是做了一层封装和一些细节处理，并不复杂，但可以学习。</p><p>笔者认为在使用govalidator的任何功能时，先看看源码，这是一个大而全的源码宝库，非常值得学习和借鉴。</p><hr/><h2>附录1. 字符串合法性校验</h2><p>下面都是业务级别的合法校验，比如是否为IPv4格式，是否为URL</p><div class=\"highlight\"><pre><code class=\"language-text\">func IsBase64(str string) bool\nfunc IsCIDR(str string) bool    // 是否为合法的CIDR格式，包含了IPv4与IPv6\nfunc IsCreditCard(str string) bool\nfunc IsDNSName(str string) bool\nfunc IsDataURI(str string) bool\nfunc IsEmail(str string) bool\nfunc IsExistingEmail(email string) bool\nfunc IsFilePath(str string) (bool, int)\nfunc IsHash(str string, algorithm string) bool\nfunc IsHexcolor(str string) bool\nfunc IsHost(str string) bool\nfunc IsIP(str string) bool    // 是否为合法的IP地址，包含了IPv4与IPv6\nfunc IsIPv4(str string) bool\nfunc IsIPv6(str string) bool\nfunc IsISBN(str string, version int) bool\nfunc IsISBN10(str string) bool\nfunc IsISBN13(str string) bool\nfunc IsISO3166Alpha2(str string) bool\nfunc IsISO3166Alpha3(str string) bool\nfunc IsISO4217(str string) bool\nfunc IsISO693Alpha2(str string) bool\nfunc IsISO693Alpha3b(str string) bool\nfunc IsJSON(str string) bool    // 通过json.Unmarshal()是否返回error进行判断\nfunc IsLatitude(str string) bool\nfunc IsLongitude(str string) bool\nfunc IsMAC(str string) bool    // 支持aa:bb:cc:dd:ee:ff，以及aabb.ccdd.eeff格式\nfunc IsMongoID(str string) bool\nfunc IsPort(str string) bool\nfunc IsRFC3339(str string) bool\nfunc IsRFC3339WithoutZone(str string) bool\nfunc IsRGBcolor(str string) bool\nfunc IsRequestURI(rawurl string) bool\nfunc IsRequestURL(rawurl string) bool\nfunc IsRsaPub(str string, params ...string) bool\nfunc IsRsaPublicKey(str string, keylen int) bool\nfunc IsSSN(str string) bool\nfunc IsSemver(str string) bool\nfunc IsTime(str string, format string) bool\nfunc IsURL(str string) bool\nfunc IsUUID(str string) bool    // 包含UUIDv3、UUIDv4、UUIDv5\nfunc IsUUIDv3(str string) bool\nfunc IsUUIDv4(str string) bool\nfunc IsUUIDv5(str string) bool</code></pre></div><hr/><h2>附录2. struct元素校验项</h2><p>有2种，第一种是不带参数的，第二种是带参数的</p><p>▷ 第一种：不带参数（第一列表示在valid tag里怎么写，第二列表示相当于govalidator的哪个导出函数）</p><div class=\"highlight\"><pre><code class=\"language-text\">&#34;email&#34;: IsEmail,\n&#34;url&#34;: IsURL,\n&#34;dialstring&#34;: IsDialString,\n&#34;requrl&#34;: IsRequestURL,\n&#34;requri&#34;: IsRequestURI,\n&#34;alpha&#34;: IsAlpha,\n&#34;utfletter&#34;: IsUTFLetter,\n&#34;alphanum&#34;: IsAlphanumeric,\n&#34;utfletternum&#34;: IsUTFLetterNumeric,\n&#34;numeric&#34;: IsNumeric,\n&#34;utfnumeric&#34;: IsUTFNumeric,\n&#34;utfdigit&#34;: IsUTFDigit,\n&#34;hexadecimal&#34;: IsHexadecimal,\n&#34;hexcolor&#34;: IsHexcolor,\n&#34;rgbcolor&#34;: IsRGBcolor,\n&#34;lowercase&#34;: IsLowerCase,\n&#34;uppercase&#34;: IsUpperCase,\n&#34;int&#34;: IsInt,\n&#34;float&#34;: IsFloat,\n&#34;null&#34;: IsNull,\n&#34;uuid&#34;: IsUUID,\n&#34;uuidv3&#34;: IsUUIDv3,\n&#34;uuidv4&#34;: IsUUIDv4,\n&#34;uuidv5&#34;: IsUUIDv5,\n&#34;creditcard&#34;: IsCreditCard,\n&#34;isbn10&#34;: IsISBN10,\n&#34;isbn13&#34;: IsISBN13,\n&#34;json&#34;: IsJSON,\n&#34;multibyte&#34;: IsMultibyte,\n&#34;ascii&#34;: IsASCII,\n&#34;printableascii&#34;: IsPrintableASCII,\n&#34;fullwidth&#34;: IsFullWidth,\n&#34;halfwidth&#34;: IsHalfWidth,\n&#34;variablewidth&#34;: IsVariableWidth,\n&#34;base64&#34;: IsBase64,\n&#34;datauri&#34;: IsDataURI,\n&#34;ip&#34;: IsIP,\n&#34;port&#34;: IsPort,\n&#34;ipv4&#34;: IsIPv4,\n&#34;ipv6&#34;: IsIPv6,\n&#34;dns&#34;: IsDNSName,\n&#34;host&#34;: IsHost,\n&#34;mac&#34;: IsMAC,\n&#34;latitude&#34;: IsLatitude,\n&#34;longitude&#34;: IsLongitude,\n&#34;ssn&#34;: IsSSN,\n&#34;semver&#34;: IsSemver,\n&#34;rfc3339&#34;: IsRFC3339,\n&#34;rfc3339WithoutZone&#34;: IsRFC3339WithoutZone,\n&#34;ISO3166Alpha2&#34;: IsISO3166Alpha2,\n&#34;ISO3166Alpha3&#34;: IsISO3166Alpha3,</code></pre></div><p>▷ 第二种：带参数（第一列表示在valid tag里怎么写，第二列表示相当于govalidator的哪个导出函数）</p><div class=\"highlight\"><pre><code class=\"language-text\">&#34;range(min|max)&#34;: Range,\n&#34;length(min|max)&#34;: ByteLength,\n&#34;runelength(min|max)&#34;: RuneLength,\n&#34;stringlength(min|max)&#34;: StringLength,\n&#34;matches(pattern)&#34;: StringMatches,\n&#34;in(string1|string2|...|stringN)&#34;: IsIn,\n&#34;rsapub(keylength)&#34; : IsRsaPub,</code></pre></div><hr/><h2>附录3. 数据特征匹配</h2><p>下面是非业务的数据校验，比如在一个字符串中是否包含固定字符、是否包含空白符、是否正整数</p><div class=\"highlight\"><pre><code class=\"language-text\">func ByteLength(str string, params ...string) bool\nfunc Contains(str, substring string) bool\nfunc HasLowerCase(str string) bool\nfunc HasUpperCase(str string) bool\nfunc HasWhitespace(str string) bool\nfunc HasWhitespaceOnly(str string) bool\nfunc InRange(value interface{}, left interface{}, right interface{}) bool\nfunc InRangeFloat32(value, left, right float32) bool\nfunc InRangeFloat64(value, left, right float64) bool\nfunc InRangeInt(value, left, right interface{}) bool\nfunc IsASCII(str string) bool\nfunc IsAlpha(str string) bool\nfunc IsAlphanumeric(str string) bool\nfunc IsByteLength(str string, min, max int) bool\nfunc IsDialString(str string) bool\nfunc IsDivisibleBy(str, num string) bool\nfunc IsFloat(str string) bool\nfunc IsFullWidth(str string) bool\nfunc IsHalfWidth(str string) bool\nfunc IsHexadecimal(str string) bool\nfunc IsIn(str string, params ...string) bool\nfunc IsInt(str string) bool\nfunc IsLowerCase(str string) bool\nfunc IsMultibyte(str string) bool\nfunc IsNatural(value float64) bool\nfunc IsNegative(value float64) bool\nfunc IsNonNegative(value float64) bool // &gt;=0\nfunc IsNonPositive(value float64) bool // &lt;=0\nfunc IsNull(str string) bool // 空字符串\nfunc IsNumeric(str string) bool // 字符串里仅包含数字\nfunc IsPositive(value float64) bool // 正数\nfunc IsPrintableASCII(str string) bool\nfunc IsUTFDigit(str string) bool\nfunc IsUTFLetter(str string) bool\nfunc IsUTFLetterNumeric(str string) bool\nfunc IsUTFNumeric(str string) bool\nfunc IsUpperCase(str string) bool\nfunc IsVariableWidth(str string) bool\nfunc IsWhole(value float64) bool // 整数\nfunc Matches(str, pattern string) bool // 正则匹配\nfunc Range(str string, params ...string) bool // 字符串长度，params的string会转换成float64然后调用InRange()，主要是用于struct tag的range(min|max)\nfunc RuneLength(str string, params ...string) bool // alias for StringLength\nfunc Sign(value float64) float64 // 如果大于0则返回1，等于0返回0，小于0返回-1\nfunc StringLength(str string, params ...string) bool // 字符串长度在指定范围内（视为utf8）\nfunc StringMatches(s string, params ...string) bool // 正则匹配，等同于Matches()，主要是用于struct tag的range(min|max)</code></pre></div><hr/><h2>附录4. 类型转换</h2><div class=\"highlight\"><pre><code class=\"language-text\">func ToBoolean(str string) (bool, error)\nfunc ToFloat(str string) (float64, error)\nfunc ToInt(value interface{}) (res int64, err error)\nfunc ToString(obj interface{}) string\nfunc ToJSON(obj interface{}) (string, error)\nfunc NormalizeEmail(str string) (string, error)    // 输出规范化的电子邮件格式</code></pre></div><hr/><h2>附录5. 裁剪、处理、填充、遍历等</h2><div class=\"highlight\"><pre><code class=\"language-text\">func Abs(value float64) float64 // 获得绝对值\nfunc BlackList(str, chars string) string // 从字符串中移除指定字符\nfunc CamelCaseToUnderscore(str string) string // 将驼峰拼写法转换为下划线分割写法，如MyFunc =&gt; my_func\nfunc Count(array []interface{}, iterator ConditionIterator) int // 通过自定义ConditionIterator（实现了迭代器）来实现判断count\nfunc Each(array []interface{}, iterator Iterator) // 通过自定义Iterator（实现了迭代器）来实现操作，不做任何返回，自行处理，比如打印一些东西\nfunc Filter(array []interface{}, iterator ConditionIterator) []interface{} // 通过自定义ConditionIterator（实现了迭代器）来对[]interface{}的元素进行遍历处理\nfunc Find(array []interface{}, iterator ConditionIterator) interface{} // 通过自定义ConditionIterator（实现了迭代器）来对[]interface{}的元素进行遍历查找，返回第一个找到的，若都没找到则返回nil\nfunc GetLine(s string, index int) (string, error) // 从含多行的字符串中返回指定行内容（0为第一行），res, err := valid.GetLine(&#34;aa\\nbb\\ncc\\n&#34;, 1) 返回bb\nfunc GetLines(s string) []string // 将字符串的换行符去掉，返回由每一行组成的slice，原理就是strings.Split(s, &#34;\\n&#34;)\nfunc LeftTrim(str, chars string) string // 若字符串最左边匹配了chars，则删除，如果chars为&#34;&#34;，则删除前导符（空格、tab、换行符）\nfunc Map(array []interface{}, iterator ResultIterator) []interface{}\nfunc PadBoth(str string, padStr string, padLen int) string // 字符串首尾填充字符\nfunc PadLeft(str string, padStr string, padLen int) string // 字符串开头填充字符\nfunc PadRight(str string, padStr string, padLen int) string // 字符串末尾填充字符\nfunc RemoveTags(s string) string // RemoveTags remove all tags from HTML string\nfunc ReplacePattern(str, pattern, replace string) string // 将正则匹配到的字符用指定字符替换\nfunc Reverse(s string) string // 字符反转\nfunc RightTrim(str, chars string) string // 若字符串最右边匹配了chars，则删除，如果chars为&#34;&#34;，则删除前导符（空格、tab、换行符）\nfunc SafeFileName(str string) string // 返回安全的文件名，裁剪掉空格等符号，转小写字母等\nfunc Trim(str, chars string) string // 就是LeftTrim+RightTrim\nfunc Truncate(str string, length int, ending string) string\nfunc UnderscoreToCamelCase(s string) string // 将下划线分割写法转换为驼峰拼写法\nfunc WhiteList(str, chars string) string // 从字符串中移除非指定字符</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81170645", 
            "userName": "李志华", 
            "userLink": "https://www.zhihu.com/people/e7009c787baa7392923957166cad7942", 
            "upvote": 0, 
            "title": "手写一个systemd管理的service", 
            "content": "<p>5分钟快速学会使用systemd管理你的服务启动、开机启动、自动重启</p><p>在运维过程中，常常遇到需要将一个服务设置为开机启动，并且需要监控服务down后马上启动起来，传统的方式是写了一个daemon程序或者supervisor，然后配置监控并启动指定的程序。</p><p>在RHEL/Centos7+、Ubuntu 16.04+的发行版中使用systemd来管理服务的启动、自动重启等，而且不再使用以前的的init script，标准并简化了服务的启动管理。下面让我们开始使用systemd管理自己的服务：</p><div class=\"highlight\"><pre><code class=\"language-php\">// server.php\n<span class=\"cp\">&lt;?php</span>\n<span class=\"nv\">$sock</span> <span class=\"o\">=</span> <span class=\"nx\">socket_create</span><span class=\"p\">(</span><span class=\"nx\">AF_INET</span><span class=\"p\">,</span> <span class=\"nx\">SOCK_DGRAM</span><span class=\"p\">,</span> <span class=\"nx\">SOL_UDP</span><span class=\"p\">);</span>\n<span class=\"nx\">socket_bind</span><span class=\"p\">(</span><span class=\"nv\">$sock</span><span class=\"p\">,</span> <span class=\"s1\">&#39;0.0.0.0&#39;</span><span class=\"p\">,</span> <span class=\"mi\">10000</span><span class=\"p\">);</span>\n<span class=\"k\">for</span> <span class=\"p\">(;;)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">socket_recvfrom</span><span class=\"p\">(</span><span class=\"nv\">$sock</span><span class=\"p\">,</span> <span class=\"nv\">$message</span><span class=\"p\">,</span> <span class=\"mi\">1024</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">$ip</span><span class=\"p\">,</span> <span class=\"nv\">$port</span><span class=\"p\">);</span>\n    <span class=\"nv\">$reply</span> <span class=\"o\">=</span> <span class=\"nx\">str_rot13</span><span class=\"p\">(</span><span class=\"nv\">$message</span><span class=\"p\">);</span>\n    <span class=\"nx\">socket_sendto</span><span class=\"p\">(</span><span class=\"nv\">$sock</span><span class=\"p\">,</span> <span class=\"nv\">$reply</span><span class=\"p\">,</span> <span class=\"nx\">strlen</span><span class=\"p\">(</span><span class=\"nv\">$reply</span><span class=\"p\">),</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nv\">$ip</span><span class=\"p\">,</span> <span class=\"nv\">$port</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>手动启动</p><div class=\"highlight\"><pre><code class=\"language-text\"># php server.php</code></pre></div><p>测试</p><div class=\"highlight\"><pre><code class=\"language-text\">$ nc -u 127.0.0.1 10000\nfsfs\nsfsf\nfsfsdf\nsfsfqs\n^C</code></pre></div><p>将其变成一个service</p><div class=\"highlight\"><pre><code class=\"language-text\"># vim /etc/systemd/system/demo.service\n[Unit]\nDescription=demo service\nAfter=network.target\nStartLimitIntervalSec=0\n\n[Service]\nType=simple\nRestart=always     \nRestartSec=1\nUser=root\nExecStart=/usr/bin/env php /root/server.php\n\n[Install]\nWantedBy=multi-user.target</code></pre></div><p>启动服务</p><div class=\"highlight\"><pre><code class=\"language-text\"># systemctl start demo\n# systemctl enable demo</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>指令</p><p>After 表示在哪个service/target启动后启动</p><p>Restart=always  总是重启服务</p><p>RestartSec=1     间隔1s重启</p><p>ExecStart=cmd  启动命令</p><p>StartLimitIntervalSec  0永远重启，n&gt;0代表尝试n秒后放弃</p><p>StartLimitAction=reboot  超过StartLimit条件后尝试reboot</p>", 
            "topic": [
                {
                    "tag": "Linux 运维", 
                    "tagLink": "https://api.zhihu.com/topics/19648078"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80122020", 
            "userName": "李志华", 
            "userLink": "https://www.zhihu.com/people/e7009c787baa7392923957166cad7942", 
            "upvote": 0, 
            "title": "git merge or rebase", 
            "content": "<p>git merge 和 git rebase两者的目的是一致的，都是用来整合多个分支的代码到一个分支中，只是所使用的方式不一样。</p><p>所有的纷争都源于认知不同</p><h2>结果一样</h2><p>git merge 将需要合并的分支的commit依次merge到当前分支，当前分支改变，被合并分支不变。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ git checkout master    # 切换到master branch\n$ git merge develop      # 合并develop到master</code></pre></div><p>git rebase 将需要合并的分支的改动与当前分支的内容比较，产生一个临时的patch，然后将该patch作为一个commit放入当前分支。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ git checkout feature\n$ git rebase master      # 将feature以master rebase</code></pre></div><h2>分支历史不一样</h2><p>两者最后的结果是一致的，都是将分支的修改合并到了当前分支上，当由于方式不一样，导致分支历史不一样。</p><p>git merge 是通过依次整合commit</p><ul><li>当前分支中会保留分支的commit</li><li>保留了历次的提交历史，但比较混乱</li><li>revert和reset都比较麻烦（需要注意多个branch的commit）</li></ul><p>git rebase 是通过patch整合内容</p><ul><li>当前分支中形成一个提交的commit</li><li>提交历史干净、线性</li><li>方便执行revert、reset（每个commit都是一个commit或者一个branch的完成修改）</li><li>方便使用git bisect查问题（<a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2018/12/git-bisect.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ruanyifeng.com/blog/201</span><span class=\"invisible\">8/12/git-bisect.html</span><span class=\"ellipsis\"></span></a>）</li></ul><h2>常见使用场景</h2><p>自己开发阶段：使用feature branch，建议在提pull request之前做一次git rebase</p><p>提pull request后：大家能看到你的提交了，这时候后续开发直接添加新的commit就好</p><p>pr accepted后：这时可以先git rebase master，然后git pull upstream master</p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80303098", 
            "userName": "李志华", 
            "userLink": "https://www.zhihu.com/people/e7009c787baa7392923957166cad7942", 
            "upvote": 0, 
            "title": "Go database/sql 要点", 
            "content": "<p>go database/sql只是一套统一的抽象的<b>接口</b>，真正与数据库打交道的是各个数据库对应的驱动实现，在使用时需要先注册对应驱动，然后就可以使用sql中定义的接口统一操作数据库。</p><h2>连接池sql.DB</h2><div class=\"highlight\"><pre><code class=\"language-text\">import (\n\t&#34;database/sql&#34;\n\t_ &#34;github.com/go-sql-driver/mysql&#34;\n)\nfunc main() {\n\tdb, err := sql.Open(&#34;mysql&#34;,\n\t\t&#34;user:password@tcp(127.0.0.1:3306)/hello&#34;)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer db.Close()\n        err = db.Ping()\n        if err != nil {\n\t     // do something here\n        }\n}</code></pre></div><p>sql.DB刚开始建立时是懒加载的，不会自动创建新的连接，只有使用Ping()或者运行查询时才会自动生成一个新的连接然后去连接数据库，只有这个时候才能确定数据库是否真的OK，所以建议<b>一定要在sql.Open后运行Ping()确定数据连接正常运行</b>。</p><p>sql.DB是连接后初始化的一个连接池，通常全局就初始化这一个连接池，并且长期运行，所有后续数据库操作都使用该连接池进行。sql.DB<b>内部自动维护连接池</b>，当需要连接时自动选择一个空闲的连接，如果没有空闲就建立一个新的连接，当连接不再使用时放回连接池中，内部会自动管理空闲回收。</p><p>数据库的连接是一个比较大的耗时和资源消耗操作，首选需要经典的TCP三次握手，tcp连接后数据库需要分配连接资源，同时根据连接信息鉴权等，所以建议使用长连接。对应到我们的go中，sql.DB会自动管理连接池，最好<b>全局使用一个连接池</b>，不要重复的open或者close。</p><h2>查询</h2><p>sql.DB支持4种查询：</p><div class=\"highlight\"><pre><code class=\"language-text\">db.Query()    \ndb.QueryRow()\ndb.Prepare(sql)   stmt.Query(args)\ndb.Exec()</code></pre></div><ul><li>db.Query() 返回多行数据，需要依次遍历，并且需要自己关闭查询结果集</li><li>db.QueryRow() 是专门查询一行数据的一个语法糖，返回ErrNoRow或者一行数据，不需要自己关闭结果集</li><li>db.Prepare() 是预先将一个数据库连接（con）和一个条sql语句绑定并返回stmt结构体代表这个绑定后的连接，然后运行stmt.Query()或者stmt.QueryRow()；stmt是并发安全的。之所以这样设计，是因为每次直接调用db.Prepare都会自动选择一个可用的con，每次选择的可能不是同一个con</li><li>db.Exec() 适用于执行insert、update、delete等不需要返回结果集的操作</li></ul><h2>结果集</h2><p>只有db.Query()返回结果集</p><div class=\"highlight\"><pre><code class=\"language-text\">var (\n\tid int\n\tname string\n)\nrows, err := db.Query(&#34;select id, name from users where id = ?&#34;, 1)\nif err != nil {\n\tlog.Fatal(err)\n}\ndefer rows.Close()\nfor rows.Next() {\n\terr := rows.Scan(&amp;id, &amp;name)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(id, name)\n}\nerr = rows.Err()\nif err != nil {\n\tlog.Fatal(err)\n}</code></pre></div><ul><li>首先检查结果集返回时是否有error</li></ul><ol><li>如果有error，直接操作error</li><li>如果无error，defer rows.Close()，确保结果集最终关闭，这样才能释放连接回连接池，Close是可以重复调用的，关闭已经关闭的结果集不会报错</li></ol><ul><li>遍历结果集</li></ul><ol><li>使用for rows.Next()遍历结果集，这样迭代<b>一行一行处理结果</b>，节约内存分配，同时防止出现OOM的问题</li><li>使用rows.Scan将一行数据填入指定的变量中，<b>scan会自动根据目标变量的类型处理类型转换</b>的问题，比如数据库中是varchar，但目标变量是int，那么scan会自动转换，当然如果转化出现error会返回error</li></ol><h2>事务</h2><div class=\"highlight\"><pre><code class=\"language-text\">tx := db.Begin()\ntx.Commit()\ntx.Rollback()</code></pre></div><p>事务是使用db.begin开始，以db.commit/db.rollback结束</p><p>普通的db.Query/db.QueryRow自动从连接池中选择一个可用连接，运行结束后会自动将连接放回连接池，下次运行再次重复这个过程</p><p><b>db.begin会自动从连接池中选择一个连接并返回一直持有该连接的tx</b>（和db.Prepare有点像），后续所有事务操作都用tx，这样能保证是在用一个连接内运行事务，只有commit/rollback才会释放连接</p><h2>Error处理</h2><ul><li>结果集遍历后error，每次for rows.Next结束后要跟一个rows.Err()检测</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">for rows.Next() {\n\t// ...\n}\nif err = rows.Err(); err != nil {\n\t// handle the error here\n}</code></pre></div><ul><li>结果集遍历close error</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">if err = rows.Close(); err != nil {\n\t// but what should we do if there&#39;s an error?\n\tlog.Println(err)\n}</code></pre></div><ul><li>QueryRow() Error</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">err = db.QueryRow(&#34;select name from users where id = ?&#34;, 1).Scan(&amp;name)\nif err != nil {\n\tlog.Fatal(err)\n}</code></pre></div><p>QueryRow的结果是在Scan时才会出现</p><ul><li>Mysql特定Error</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">if driverErr, ok := err.(*mysql.MySQLError); ok { // Now the error number is accessible directly\n\tif driverErr.Number == 1045 {\n\t\t// Handle the permission-denied error\n\t}\n}</code></pre></div><ul><li>连接没释放问题</li></ul><ol><li>事务没有commit或者rollback</li><li>查询集没有close</li></ol><ul><li>查询参数问题</li></ul><ol><li>Mysql使用？做参数，防止sql注入</li><li>既然是参数，就只能当参数，不可以用于其他部分，也不能做插值</li></ol><h2>标准库sql不支持但常用的特性</h2><ul><li>不支持多条sql执行</li><li>不支持返回多个结果集</li><li>不支持存储过程（Mysql驱动目前不支持）</li><li>不支持Scan到map、struct</li><li>不建议uint64</li></ul><h2>第三方扩展库<a href=\"https://link.zhihu.com/?target=http%3A//github.com/jmoiron/sqlx\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.com/jmoiron/sqlx</span><span class=\"invisible\"></span></a></h2><p>简化连接</p><div class=\"highlight\"><pre><code class=\"language-text\">db = sqlx.MustConnect(&#34;sqlite3&#34;, &#34;:memory:&#34;)  // sql.Open+db.Ping</code></pre></div><p>便捷功能</p><ul><li>StructScan 、SliceScan、MapScan</li><li>Get、Select</li><li>MustExec</li><li>支持命名参数</li><li>支持IN查询自动展开参数</li></ul><p>Get、Select类似于QueryRow和Query，但Get和Select可以自动将结果Scan到特定数据</p><p><i>Struct字段必须能导出，且根据db tag（如果没有就用小写字段名）进行匹配</i></p><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "Go 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052037"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78667979", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "GO学习笔记 - 模版渲染及多种输出", 
            "content": "<p><b>本文主题：基于内置的text/template实现Golang模版渲染，并将结果写入文件、屏幕、变量。</b></p><p>小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 定义结构体</p><p>▪ 定义模版文本</p><p>▪ 模版渲染及输出方式</p><p>▪ 完整例子</p><hr/><h2>定义结构体</h2><p>首先，定义一个结构体，用于后面的模版渲染</p><div class=\"highlight\"><pre><code class=\"language-text\">type Person struct {\n    Name string\n    Age int\n    Boy bool\n}</code></pre></div><p><b>注意：struct的元素必须要可导出（大写打头），否则渲染时候找不到</b></p><p>实例化结构体，用于模版渲染时候获得对应值</p><div class=\"highlight\"><pre><code class=\"language-text\">foo := Person{\n    Name: &#34;foo&#34;,\n    Age: 18,\n    Boy: false,\n}</code></pre></div><hr/><h2>定义模版文本</h2><p>接下来，定义一个模版文本，此处直接定义了一个常量，表示模版文本</p><div class=\"highlight\"><pre><code class=\"language-text\">const text = `My name is {{.Name}},\nI&#39;m {{.Age}} years old,\nI&#39;m a {{if .Boy}}boy{{else}}girl{{end}}.\n`</code></pre></div><p>读取文本，获取template的handler</p><div class=\"highlight\"><pre><code class=\"language-text\">tmpl, err := template.New(&#34;&#34;).Parse(text)\nif err != nil {\n    log.Fatalln(err)\n}</code></pre></div><hr/><h2>模版渲染及输出方式</h2><p>在渲染时候需要传递一个参数，用于指定输出到何处，常见的有3种目的地：</p><p>▷ 输出到文件</p><p>▷ 输出到变量</p><p>▷ 输出到屏幕</p><p>输出到文件：需要先open一个文件并获得文件句柄</p><div class=\"highlight\"><pre><code class=\"language-text\">f, err := os.OpenFile(&#34;/tmp/test&#34;, os.O_WRONLY|os.O_CREATE, 0644)\ndefer f.Close()\nif err != nil {\n    log.Fatalln(err)\n}\n\n// 渲染并写入文件\nif err := tmpl.Execute(f, foo); err != nil {\n    log.Fatalln(err)\n}</code></pre></div><p>输出到变量</p><div class=\"highlight\"><pre><code class=\"language-text\">var buf bytes.Buffer\n\nif err := tmpl.Execute(&amp;buf, foo); err != nil {\n    log.Fatalln(err)\n}\nfmt.Println(buf.String())</code></pre></div><p>输出到屏幕</p><div class=\"highlight\"><pre><code class=\"language-text\">if err := tmpl.Execute(os.Stdout, foo); err != nil {\n    log.Fatalln(err)\n}</code></pre></div><hr/><h2>完整例子</h2><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;log&#34;\n    &#34;os&#34;\n    &#34;text/template&#34;\n)\n\ntype Person struct {\n    Name string\n    Age int\n    Boy bool\n}\n\nfunc main() {\n    // 实例化结构体\n    foo := Person{\n        Name: &#34;foo&#34;,\n        Age: 18,\n        Boy: false,\n    }\n\n    // 定义模版文本\n    const text = `My name is {{.Name}},\nI&#39;m {{.Age}} years old,\nI&#39;m a {{if .Boy}}boy{{else}}girl{{end}}.\n`\n\n    // 根据指定模版文本生成handler\n    tmpl, err := template.New(&#34;&#34;).Parse(text)\n    if err != nil {\n        log.Fatalln(err)\n    }\n\n    // 模版渲染，并写入文件\n    f, err := os.OpenFile(&#34;/tmp/test&#34;, os.O_WRONLY|os.O_CREATE, 0644)\n    defer f.Close()\n    if err != nil {\n        log.Fatalln(err)\n    }\n    if err := tmpl.Execute(f, foo); err != nil {\n        log.Fatalln(err)\n    }\n\n    // 模版渲染，并赋值给变量\n    var buf bytes.Buffer\n    if err := tmpl.Execute(&amp;buf, foo); err != nil {\n        log.Fatalln(err)\n    }\n    fmt.Println(buf.String())\n\n    // 模版渲染，并输出到屏幕标准输出\n    if err := tmpl.Execute(os.Stdout, foo); err != nil {\n        log.Fatalln(err)\n    }\n}</code></pre></div><p>测试效果</p><div class=\"highlight\"><pre><code class=\"language-text\"># 编译\ngo build template.go\n./template\n\n# 输出\nMy name is foo,\nI&#39;m 18 years old,\nI&#39;m a girl.\n\nMy name is foo,\nI&#39;m 18 years old,\nI&#39;m a girl.\n\n# 查看文件（/tmp/test）内容\nMy name is foo,\nI&#39;m 18 years old,\nI&#39;m a girl.</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74581740", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "GO学习笔记 - 命令行解析", 
            "content": "<p><b>本文主题：基于os.Args与flag实现Golang命令行解析。</b></p><p>小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 一. os.Args</p><p>▪ 二. flag</p><p>▪ 三. 结合os.Args与flag实现子命令</p><p>▪ 附. 参考文档</p><hr/><h2>一. os.Args</h2><p>os.Args用于获取通过命令行传入的参数</p><p>▷ <b>os.Args[0]</b>：程序执行路径</p><p>▷ <b>os.Args[1]</b>：第1个参数</p><p>▷ <b>os.Args[2]</b>：第2个参数</p><p>▷ <b>len(os.Args)</b>：参数数量</p><p>示例如下</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;fmt&#34;\n    &#34;os&#34;\n)\n\nfunc main() {\n    fmt.Println(&#34;Program:&#34;, os.Args[0])\n    for i, v := range os.Args[1:] {\n        fmt.Printf(&#34;Arg[%d]: %v\\n&#34;, i, v)\n    }\n}</code></pre></div><p>测试效果</p><div class=\"highlight\"><pre><code class=\"language-text\"># 编译执行\ngo build arg.go\n./arg foo &#34;hello world&#34; bar\n\n# 输出\nProgram: ./arg\nArg[0]: foo\nArg[1]: hello world\nArg[2]: bar</code></pre></div><hr/><h2>二. flag</h2><p>golang内置的flag模块可以实现命令行flag解析。</p><p>什么是flag，举例说明（加粗部分就是flag）：</p><p>▷ wc <b>-l</b></p><p>▷ ./configure <b>--prefix=/usr/local/nginx</b></p><p>示例如下（摘取自gobyexample）</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;flag&#34;\n    &#34;fmt&#34;\n)\n\nfunc main() {\n    // flag.String返回的是指针\n    // word表示参数名，foo表示默认值，a string表示参数释义（在-h或解析异常时候会看到）\n    // flag.Int、flag.Bool与flag.String同理，不再赘述\n    wordPtr := flag.String(&#34;word&#34;, &#34;foo&#34;, &#34;a string&#34;)\n    numbPtr := flag.Int(&#34;numb&#34;, 42, &#34;an int&#34;)\n    boolPtr := flag.Bool(&#34;fork&#34;, false, &#34;a bool&#34;)\n\n    // flag.StringVar返回的是非指针\n    var svar string\n    flag.StringVar(&amp;svar, &#34;svar&#34;, &#34;bar&#34;, &#34;a string var&#34;)\n\n    // 进行flag解析\n    flag.Parse()\n\n    fmt.Println(&#34;word:&#34;, *wordPtr)\n    fmt.Println(&#34;numb:&#34;, *numbPtr)\n    fmt.Println(&#34;fork:&#34;, *boolPtr)\n    fmt.Println(&#34;svar:&#34;, svar)\n    fmt.Println(&#34;tail:&#34;, flag.Args())\n}</code></pre></div><p>测试效果</p><div class=\"highlight\"><pre><code class=\"language-text\"># 编译\ngo build flag.go\n\n./flag -word=opt -numb=7 -fork -svar=flag\n# 输出\nword: opt\nnumb: 7\nfork: true\nsvar: flag\ntail: []\n\n./flag -word=opt\n# 输出\nword: opt\nnumb: 42\nfork: false\nsvar: bar\ntail: []\n\n./flag -word=opt a1 a2 a3\n# 输出\nword: opt\nnumb: 42\nfork: false\nsvar: bar\ntail: [a1 a2 a3]\n\n./flag -word=opt a1 a2 a3 -numb=7\n# 输出\nword: opt\nnumb: 42\nfork: false\nsvar: bar\ntail: [a1 a2 a3 -numb=7]\n\n./flag -h\n# 输出\nUsage of ./flag:\n  -fork\n        a bool\n  -numb int\n        an int (default 42)\n  -svar string\n        a string var (default &#34;bar&#34;)\n  -word string\n        a string (default &#34;foo&#34;)\n\n./flag -wat\n# 输出\nflag provided but not defined: -wat\nUsage of ./flag:\n...</code></pre></div><p>该例子，在测试时候只使用了“单横线+参数名”，实际有4种方式，效果是相同的</p><div class=\"highlight\"><pre><code class=\"language-text\">-word opt\n-word=opt\n--word opt\n--word=opt</code></pre></div><hr/><h2>三. 结合os.Args与flag实现子命令</h2><p>如果想实现子命令效果，例如：</p><p>▷ docker ps --last 10</p><p>▷ docker images --help</p><p>这需要将os.Args和flag结合使用。基本原理：创建多个flag集合（即*flag.FlagSet），每个flag集合对应不同的os.Args</p><p>示例如下（摘取自gobyexample）</p><div class=\"highlight\"><pre><code class=\"language-text\">package main\n\nimport (\n    &#34;flag&#34;\n    &#34;fmt&#34;\n    &#34;os&#34;\n)\n\nfunc main() {\n    fooCmd := flag.NewFlagSet(&#34;foo&#34;, flag.ExitOnError)\n    fooEnable := fooCmd.Bool(&#34;enable&#34;, false, &#34;enable&#34;)\n    fooName := fooCmd.String(&#34;name&#34;, &#34;&#34;, &#34;name&#34;)\n\n    barCmd := flag.NewFlagSet(&#34;bar&#34;, flag.ExitOnError)\n    barLevel := barCmd.Int(&#34;level&#34;, 0, &#34;level&#34;)\n\n    if len(os.Args) &lt; 2 {\n        fmt.Println(&#34;expected &#39;foo&#39; or &#39;bar&#39; subcommands&#34;)\n        os.Exit(1)\n    }\n\n    switch os.Args[1] {\n    case &#34;foo&#34;:\n        fooCmd.Parse(os.Args[2:])\n        fmt.Println(&#34;subcommand &#39;foo&#39;&#34;)\n        fmt.Println(&#34; enable:&#34;, *fooEnable)\n        fmt.Println(&#34; name:&#34;, *fooName)\n        fmt.Println(&#34; tail:&#34;, fooCmd.Args())\n    case &#34;bar&#34;:\n        barCmd.Parse(os.Args[2:])\n        fmt.Println(&#34;subcommand &#39;bar&#39;&#34;)\n        fmt.Println(&#34; level:&#34;, *barLevel)\n        fmt.Println(&#34; tail:&#34;, barCmd.Args())\n    default:\n        fmt.Println(&#34;expected &#39;foo&#39; or &#39;bar&#39; subcommands&#34;)\n        os.Exit(1)\n    }\n}</code></pre></div><p>测试效果</p><div class=\"highlight\"><pre><code class=\"language-text\"># 编译\ngo build subflag.go\n\n./subflag foo -enable -name=joe a1 a2\n# 输出\nsubcommand &#39;foo&#39;\n  enable: true\n  name: joe\n  tail: [a1 a2]\n\n./subflag bar -level 8 a1\n# 输出\nsubcommand &#39;bar&#39;\n  level: 8\n  tail: [a1]\n\n./subflag bar -enable a1\n# 输出\nflag provided but not defined: -enable\nUsage of bar:\n  -level int\n        level</code></pre></div><hr/><h2>附. 参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\"># os.Args\nhttps://gobyexample.com/command-line-arguments\n\n# flag\nhttps://gobyexample.com/command-line-flags\n\n# 子命令\nhttps://gobyexample.com/command-line-subcommands</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }, 
                {
                    "tag": "command line", 
                    "tagLink": "https://api.zhihu.com/topics/19584941"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69329383", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "IPv6通讯原理(1) - 不能忽略的网卡启动过程", 
            "content": "<p><b>本文主题：通过抓包分析，深入观察网卡启动过程的每个步骤，从而逐步掌握通讯原理。</b></p><p>🍀小慢哥的原创文章，欢迎转载</p><hr/><h2>目录</h2><p>▪ 一. 为什么不能忽略网卡启动过程</p><p>▪ 二. 实验环境</p><p>▪ 三. 网卡启动前/后的样子</p><p>▪ 四. 结论写在前</p><p>▪ Step1. 生成“链路本地地址”</p><p>▪ Step2. 生成“被请求节点多播地址”</p><p>▪ Step3. “多播成员报告”</p><p>▪ Step4. “重复地址检测”</p><p>▪ Step5. “无状态地址自动配置”</p><p>▪ 思考题</p><p>▪ 附. 实验脚本与抓包文件</p><hr/><h2>一. 为什么不能忽略网卡启动过程</h2><p>掌握网络技术，除了看RFC协议外，最直接高效的方法就是<b>“亲眼所见”</b>。</p><p>其中<b>抓包分析</b>是最为关键的方法，能了解到：</p><p>▷ What：对应哪个协议</p><p>▷ Why：协议用途</p><p>▷ When：协议之间的关联</p><p>▷ How：报文地址和内容</p><p><b>网卡启动是网络通讯的第一步，只有夯实基础方能展翅高飞。</b></p><hr/><h2>二. 实验环境</h2><p>本文以CentOS 7为实验环境，创建两个network namespace（名字分别为ns1和ns2），并通过veth网卡桥接到同一个linux bridge（名字为br0），来模拟最简单的环境，即两台同二层服务器。</p><p>🍀 <b>先贴出mac地址：</b></p><p>▷ ns1内的mac：52:54:00:00:00:01</p><p>▷ ns2内的mac：52:54:00:00:00:02</p><p>🍀 <b>实验步骤：</b></p><p>1️⃣ 在ns1里启动网卡，但不抓包查看</p><p>2️⃣ 在ns2里启动网卡，同时在br0上进行抓包分析</p><p>🍀 <b>观察：</b></p><p>▷ ns2会产生哪些包</p><p>▷ ns1是否会对ns2进行响应</p><p><b>本文最后会附上实验脚本和抓包文件的下载地址。</b></p><hr/><h2>三. 网卡启动前/后的样子</h2><p>🍀 <b>网卡启动前的样子</b></p><p>在ns2里启动网卡之前，先对ns2里的网络环境进行查看，命令如下</p><div class=\"highlight\"><pre><code class=\"language-text\"># 查看网卡状态\nip netns exec ns2 ip link\n\n# 查看ipv6地址\nip netns exec ns2 ip -6 addr\n\n# 查看ipv6路由\nip netns exec ns2 ip -6 route\n\n# 查看ipv6多播地址\nip netns exec ns2 ip -6 maddr</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4ca4128e9586b49310653ca4262e1bf5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2100\" data-rawheight=\"1146\" class=\"origin_image zh-lightbox-thumb\" width=\"2100\" data-original=\"https://pic2.zhimg.com/v2-4ca4128e9586b49310653ca4262e1bf5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2100&#39; height=&#39;1146&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2100\" data-rawheight=\"1146\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2100\" data-original=\"https://pic2.zhimg.com/v2-4ca4128e9586b49310653ca4262e1bf5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4ca4128e9586b49310653ca4262e1bf5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到此时eth0处于DOWN的状态，接下去，对eth0进行UP。</p><p>🍀 <b>网卡启动后的样子</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 启动网卡\nip netns exec ns2 ip link set eth0 up</code></pre></div><p>进入ns2里查看</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e1dda12c00f2ab9f5c581823b169e06f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2358\" data-rawheight=\"1146\" class=\"origin_image zh-lightbox-thumb\" width=\"2358\" data-original=\"https://pic4.zhimg.com/v2-e1dda12c00f2ab9f5c581823b169e06f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2358&#39; height=&#39;1146&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2358\" data-rawheight=\"1146\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2358\" data-original=\"https://pic4.zhimg.com/v2-e1dda12c00f2ab9f5c581823b169e06f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e1dda12c00f2ab9f5c581823b169e06f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看到，此时网卡已启动，并获得了一个链路本地地址（图中fe80开头的）</p><p>🍀 <b>抓到了哪些包呢</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2c9c3c945f2cb2f6d10f627fb637d586_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2484\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"2484\" data-original=\"https://pic3.zhimg.com/v2-2c9c3c945f2cb2f6d10f627fb637d586_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2484&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2484\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2484\" data-original=\"https://pic3.zhimg.com/v2-2c9c3c945f2cb2f6d10f627fb637d586_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2c9c3c945f2cb2f6d10f627fb637d586_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些包都是什么意思，如何产生，为何产生，请接着往下看。</p><hr/><h2>四. 结论写在前</h2><p>网卡启动过程一共有5步，详见示意图（右边的数字，表示对应抓包图中的第几个包）：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ad08de9bbdb388872f1badce5970cc3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"1212\" class=\"origin_image zh-lightbox-thumb\" width=\"1168\" data-original=\"https://pic3.zhimg.com/v2-ad08de9bbdb388872f1badce5970cc3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1168&#39; height=&#39;1212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"1212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1168\" data-original=\"https://pic3.zhimg.com/v2-ad08de9bbdb388872f1badce5970cc3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ad08de9bbdb388872f1badce5970cc3a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来，将对这5步进行逐步讲解。</p><hr/><h2>Step1. 生成“链路本地地址”</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-00ed1125b8d4f3bb3ce1ab77d2229bbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2098\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb\" width=\"2098\" data-original=\"https://pic4.zhimg.com/v2-00ed1125b8d4f3bb3ce1ab77d2229bbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2098&#39; height=&#39;530&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2098\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2098\" data-original=\"https://pic4.zhimg.com/v2-00ed1125b8d4f3bb3ce1ab77d2229bbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-00ed1125b8d4f3bb3ce1ab77d2229bbf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（本步骤尚未产生数据包）</p><p>🍀 <b>“链路本地地址”是什么</b></p><p>▷ 当网卡启动时会根据某种算法自动生成链路本地地址（Link-Local Address）。</p><p>▷ 具体生成的地址，与操作系统有关，有的根据MAC地址换算而来（EUI-64），有的则是随机生成，并不统一。</p><p>▷ “链路本地地址”是范围为<b>fe80::/10</b>的单播地址。</p><p>▷ “链路本地”顾名思义，只在同一个二层内传播，不会被路由器转发。</p><p>🍀 <b>“链路本地地址”有什么作用</b></p><p>▷ 地址自动配置</p><p>▷ 邻居发现协议</p><p>▷ 路由转发（可以作为下一跳地址）</p><hr/><h2>Step2. 生成“被请求节点多播地址”</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8f86573aacd2ae7809c57b269c1c8275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"597\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb\" width=\"597\" data-original=\"https://pic2.zhimg.com/v2-8f86573aacd2ae7809c57b269c1c8275_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;597&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"597\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"597\" data-original=\"https://pic2.zhimg.com/v2-8f86573aacd2ae7809c57b269c1c8275_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8f86573aacd2ae7809c57b269c1c8275_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（本步骤尚未产生数据包）</p><p>🍀 <b>“被请求节点多播地址”是什么</b></p><p>在IPv6的世界中，每生成一个ip地址（准确说是单播地址），无论什么类型，都会对应生成一个“被请求节点多播地址”（Solicited-Node multicast address）。</p><p>组成方式：<b>FF02::1:FF00:0/104 + 单播地址的最后24bit</b>。可以看到，该地址是通过单播地址推导而成，不是随机的。上图中红框里的地址就是“链路本地地址”对应的“被请求节点多播地址”。</p><p>🍀 <b>为什么需要“被请求节点多播地址”</b></p><p>就4个字：“地址解析”</p><p>▷ IPv4中用ARP做地址解析，ARP是基于广播的。</p><p>▷ IPv6没有广播，只有多播。既然是多播，就总得有一个多播地址才行，于是应运而生。</p><p>🍀 <b>“被请求节点多播地址”工作原理</b></p><p>当他人想解析我的MAC地址时，发送一个“地址解析请求包”到这个多播地址，然后属于该多播地址的成员（也就是“我”）就会收到该数据包，最后“我”返回MAC地址给对方。这样就完成了“地址解析”的流程。</p><p>🍀 <b>“被请求节点”这5个字到底是什么意思</b></p><p>别人请求解析我的地址，那么我就是被请求的节点。我生成“被请求节点多播地址”的目的，就是让别人能够请求到我。</p><hr/><h2>Step3. “多播成员报告”</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0aa8d7270c2b1186c36b86f3e403d230_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1217\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"1217\" data-original=\"https://pic1.zhimg.com/v2-0aa8d7270c2b1186c36b86f3e403d230_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1217&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1217\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1217\" data-original=\"https://pic1.zhimg.com/v2-0aa8d7270c2b1186c36b86f3e403d230_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0aa8d7270c2b1186c36b86f3e403d230_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（对应抓包图中的No. 1/2/4/6）</p><p>🍀 <b>什么是“多播成员报告”</b></p><p>▷ MLDv2协议（多播控制协议）中的一种报文类型（Membership Report）。</p><p>▷ 通俗理解就是对外宣称“我要加入某某多播组”。</p><p>▷ 成员报告是单向的，不会收到回应包。</p><p>🍀 <b>为什么要进行“多播成员报告”</b></p><p>▷ 只要生成多播地址，就要进行成员报告，这是多播的工作机制。</p><p>▷ 成员报告的目的是为了减少网络中的多播流量。</p><p>🍀 <b>要报告的是哪个成员</b></p><p>▷ 要报告的成员不是单播地址，而是多播地址。</p><p>▷ 这里指的就是“被请求节点多播地址”。即“我要加入ff02::1:ff00:2多播组”</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1149978fa29ab051787930be0b0192d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"770\" data-original=\"https://pic2.zhimg.com/v2-1149978fa29ab051787930be0b0192d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;770&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"770\" data-original=\"https://pic2.zhimg.com/v2-1149978fa29ab051787930be0b0192d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1149978fa29ab051787930be0b0192d5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>Step4. “重复地址检测”</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-402728d18a5fc72d93616e2ea9540b3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1216\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"1216\" data-original=\"https://pic3.zhimg.com/v2-402728d18a5fc72d93616e2ea9540b3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1216&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1216\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1216\" data-original=\"https://pic3.zhimg.com/v2-402728d18a5fc72d93616e2ea9540b3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-402728d18a5fc72d93616e2ea9540b3a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（对应抓包图中的No. 3）</p><p>🍀 <b>什么是“重复地址检测”</b></p><p>▷ 为了防止IP地址冲突，每生成一个单播地址，都会进行一次“重复地址检测”（Duplicate Address Detection，简称DAD）。</p><p>▷ 此刻，就是对Step1生成的“链路本地地址”进行检测。</p><p>🍀 <b>何时进行“重复地址检测”</b></p><p>▷ 在生成单播地址并完成发送一次“MLDv2成员报告”后，就会随机延时一小段时间进行检测。</p><p>▷ 在centos7里检测次数可通过内核参数net.ipv6.conf.eth0.dad_transmits进行修改，若设置为0表示不进行检测。</p><p>🍀 <b>“重复地址检测”的工作原理</b></p><p>▷ 举个例子：我想给我家小狗取名，叫“球球”，但不想和邻居家的小狗重名，于是我大声喊：“球球”。如果没有任何狗狗看过来，那就可以认定此名字没有冲突。</p><p>▷ 专业解释：发送一个地址解析包（Neighbor Solicitation，简称NS），请求解析的地址就是自己的地址，并等待回应，若超时仍未得到回应（Neighbor Advertisement，简称NA），即可认为地址可用。</p><hr/><h2>Step5. “无状态地址自动配置”</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-242ee966c321b190c792a36906b98497_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2468\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"2468\" data-original=\"https://pic4.zhimg.com/v2-242ee966c321b190c792a36906b98497_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2468&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2468\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2468\" data-original=\"https://pic4.zhimg.com/v2-242ee966c321b190c792a36906b98497_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-242ee966c321b190c792a36906b98497_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（对应抓包图中的No. 5/7/8）</p><p>🍀 <b>什么是“无状态地址自动配置”</b></p><p>在IPv6中，有2种自动配置IP地址的方法：</p><p>▷ DHCPv6：也叫做“有状态分配”</p><p>▷ SLAAC：“无状态地址自动配置”（Stateless Address Autoconfiguration）</p><p>🍀 <b>SLAAC的作用是什么</b></p><p>▷ 自动配置IP地址</p><p>▷ 自动配置网关</p><p>注：这里说的IP地址，是指“全球单播地址”或者“唯一本地地址”，也就是俗称的公网地址和私网地址。而不是“链路本地地址”。</p><p>🍀 <b>工作原理</b></p><p>涉及到这2种报文：</p><p>▷ “路由器请求”（Router Solicitation，简称RS）</p><p>▷ “路由器通告”（Router Advertisement，简称RA）</p><p>当收到路由器回应的RA报文后，就会根据报文中的IP前缀信息，自动生成IP地址，并将网关指向该路由器的“链路本地地址”。</p><p>🍀 <b>如何能够收到RA报文呢</b></p><p>有2种办法：</p><p>▷ 路由器定期发送RA报文</p><p>▷ 自己主动发送RS报文，路由器收到后就会立刻回应RA报文</p><p>由于本次实验中没有路由器，因此截图中仅能看到主动发送的RS报文，而没有得到回应。</p><hr/><h2>思考题</h2><p>1️⃣ 在生成“全球单播地址”或“唯一本地地址”之后，还会采用“链路本地地址”做基础通讯吗？</p><p>2️⃣ 为什么“多播成员报告”可以减少网络中不必要的多播流量，接入层交换机要进行额外配置吗？</p><p>3️⃣ “地址重复”时，是否会自动更换IP？</p><p>4️⃣ RA包只能包含一个IP前缀信息吗？一个前缀只能生成一个IP地址吗？生成的地址是什么样的？</p><p>5️⃣ 若存在多台路由器，网关会指向谁？</p><p>6️⃣ 如果不想自动配置IP，只想手工配置IP，可以忽视RA包吗？如何忽视?</p><p>上述问题，将在《IPv6系列》的下一篇文章中进行解答。</p><hr/><h2>附. 实验脚本与抓包文件</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 实验脚本\nhttps://fzxiaomange.com/attachment/ipv6-init.sh\n\n# 抓包文件\nhttps://fzxiaomange.com/attachment/ipv6-init.pcap</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "IPv6", 
                    "tagLink": "https://api.zhihu.com/topics/19556734"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67843942", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 2, 
            "title": "IPv6系列-初学者的10个常见困扰", 
            "content": "<p>本文是《IPv6系列》文章的第二篇《常见困扰》，紧接《入门指南》，用于解答IPv6的10个常见困扰。</p><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ 本文缘由</p><p>▪ 困扰1. IPv4和IPv6只有地址格式不同吗</p><p>▪ 困扰2. IPv4到IPv6对应用程序是透明无感知的吗</p><p>▪ 困扰3. 提供WEB服务，需要每台服务器都配置IPv6地址吗</p><p>▪ 困扰4. IPv4和IPv6要配在同一张网卡上吗</p><p>▪ 困扰5. 我的网卡有fe80开头的地址，可以用来上公网吗</p><p>▪ 困扰6. IPv6地址如何配置</p><p>▪ 困扰7. 没有了ARP，如何解析MAC地址</p><p>▪ 困扰8. IPv6使用多播替代广播，需要做哪些改造</p><p>▪ 困扰9. IPv6真的安全吗</p><p>▪ 困扰10. 如何学习IPv6</p><p>▪ 后续说明</p><hr/><h2>本文缘由</h2><p>在笔者的上一篇文章《IPv6系列-入门指南》里，简要阐述了以下内容：</p><p>▷ 掌握IPv6的必要性</p><p>▷ IPv6的3个常见顾虑</p><p>▷ IPv6基础知识</p><p>▷ 常用测试方法</p><p><b>而在进一步的实践学习中，会遇到很多的困扰</b>。笔者结合自己以及身边的同行兄弟们遇到的困扰，精心挑选出<b>10个困扰</b>在本文中进行解答。</p><p><b>如果没有阅读过《IPv6系列-入门指南》，敬请劳神垂阅，以便知识的连贯。</b></p><hr/><h2>困扰1. IPv4和IPv6只有地址格式不同吗</h2><p>除了地址格式不同，IPv4与IPv6协议栈也不同，他们在逻辑上是<b>完全不同的2个世界</b></p><p>以下实践中经常会遇到的4个不同之处：</p><p>▷ <b>基本通讯过程</b>：ND替代ARP、多播替代广播、fe80地址成为标配、ICMP成为通讯核心</p><p>▷ <b>IP配置方式</b>：客户端以无状态自动配置IP成为主流，弱化DHCP</p><p>▷ <b>DNS域名解析</b>：AAAA记录替代IPv4的A记录、对应用存在优先级问题（优先解析AAAA还是A）</p><p>▷ <b>应用层适应性</b>：socket编程中AF_INET仅支持IPv4，AF_INET6仅支持IPv6</p><hr/><h2>困扰2. IPv4到IPv6对应用程序是透明无感知的吗</h2><p><b>错，是有感知的</b>，上层应用程序需要进行改造。</p><p>举个例子，当访问<a href=\"https://link.zhihu.com/?target=http%3A//fzxiaomange.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">fzxiaomange.com</span><span class=\"invisible\"></span></a>时候，是要优先解析IPv6地址（AAAA）还是IPv4地址（A），因为总得选一条线路来发送请求。现在许多框架会优先选择IPv6。</p><p>注意：如果解析出AAAA记录，即使本机没有可路由IPv6地址，也有可能<b>依然尝试通过IPv6进行请求，导致请求失败</b>。</p><p>还有一个典型的例子，是程序会在<b>应用层里交互底层IP地址</b>，比如FTP主动模式会在应用层里交互IPv4地址，而如果实际可用的是IPv6地址，就可能导致后续连接的异常。</p><p><b>无法做到透明无感知，是导致产生IPv4到IPv6的部分过渡方案的原因之一。</b></p><hr/><h2>困扰3. 提供WEB服务，需要每台服务器都配置IPv6地址吗</h2><p>现在有一种言论，说“IPv6地址无限多，每台服务器都可以配一个IP地址，不用做NAT”。</p><p><b>这很容易误导人，具体如何使用IPv6，还得根据场景而定</b>。比如笔者的个人博客<a href=\"https://link.zhihu.com/?target=http%3A//fzxiaomange.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">fzxiaomange.com</span><span class=\"invisible\"></span></a>，由nginx-&gt;php-&gt;mysql组成，分别位于3台服务器上，那只需要在nginx上配置IPv6地址，并在DNS上添加一条AAAA记录指向L7的IPv6地址即可。完全没必要在php、mysql服务器上配置IPv6地址，而且一旦配置了，就直接暴露内网了。</p><p>每个设备都配置IPv6，主要适用于<b>偏客户端以及地址需求量大的场景</b>，诸如物联网设备、手机4G、家庭宽带等。</p><p>另外，<b>IPv6有NAT</b>，适用于办公PC、机房服务器等需要访问IPv6网络，而不想被别人主动访问的场景。</p><hr/><h2>困扰4. IPv4和IPv6要配在同一张网卡上吗</h2><p>都可以，首先需要先了解2个词<b>“单栈”</b>和<b>“双栈”</b>：</p><p><b>以节点为角度</b>（通用的解释）：</p><p>▷ 单栈：表示一个IPv6节点，也就是一台服务器，或一部手机，仅有IPv6地址，或仅有IPv4地址，前者叫做<b>“IPv6单栈”</b>或<b>“IPv6-Only”</b>，后者叫<b>“IPv4单栈”</b>或<b>“IPv4-Only”</b>。</p><p>▷ 双栈：表示一个IPv6节点，同时拥有IPv6地址和IPv4地址</p><p><b>以网卡为角度</b>：</p><p>▷ 单栈：表示一张网卡仅有IPv6地址，或仅有IPv4地址，示意图如下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-224ca444947e2e6100f0ca2a202b9ba6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2062\" data-rawheight=\"838\" class=\"origin_image zh-lightbox-thumb\" width=\"2062\" data-original=\"https://pic3.zhimg.com/v2-224ca444947e2e6100f0ca2a202b9ba6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2062&#39; height=&#39;838&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2062\" data-rawheight=\"838\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2062\" data-original=\"https://pic3.zhimg.com/v2-224ca444947e2e6100f0ca2a202b9ba6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-224ca444947e2e6100f0ca2a202b9ba6_b.jpg\"/></figure><p>▷ 双栈：表示一张网卡同时拥有IPv6地址和IPv4地址</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a469762a633c24fc3bce05be45a6bf4b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2060\" data-rawheight=\"662\" class=\"origin_image zh-lightbox-thumb\" width=\"2060\" data-original=\"https://pic4.zhimg.com/v2-a469762a633c24fc3bce05be45a6bf4b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2060&#39; height=&#39;662&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2060\" data-rawheight=\"662\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2060\" data-original=\"https://pic4.zhimg.com/v2-a469762a633c24fc3bce05be45a6bf4b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a469762a633c24fc3bce05be45a6bf4b_b.jpg\"/></figure><p>IPv4和IPv6在逻辑上是两个完全不相交的世界。如果终端处位于同一个物理层，比如同一个VLAN，那么网卡就只能同时配置IPv6地址和IPv4地址；反之，就必须一张网卡配置IPv6，另一张网卡配置IPv4。所以，<b>关键看网络架构是如何设计，各有利弊</b>。比如放同一张网卡上，就可以做到带宽共享，而放不同网卡，可以做到带宽分别限制与计费。</p><hr/><h2>困扰5. 我的网卡有fe80开头的地址，可以用来上公网吗</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9c17f93f0990c5cf28fd0abc166f1041_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"1120\" class=\"origin_image zh-lightbox-thumb\" width=\"838\" data-original=\"https://pic2.zhimg.com/v2-9c17f93f0990c5cf28fd0abc166f1041_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;838&#39; height=&#39;1120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"1120\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"838\" data-original=\"https://pic2.zhimg.com/v2-9c17f93f0990c5cf28fd0abc166f1041_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9c17f93f0990c5cf28fd0abc166f1041_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-45879c85a75a536f5d27c9fb6d252e13_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2060\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb\" width=\"2060\" data-original=\"https://pic4.zhimg.com/v2-45879c85a75a536f5d27c9fb6d252e13_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2060&#39; height=&#39;618&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2060\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2060\" data-original=\"https://pic4.zhimg.com/v2-45879c85a75a536f5d27c9fb6d252e13_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-45879c85a75a536f5d27c9fb6d252e13_b.jpg\"/></figure><p>当网卡启动的时候，会自动生成<b>“链路本地地址”（Link-Local Address）</b>，这是一个<b>fe80::/10</b>的单播地址。“链路本地地址”用于<b>IP自动配置</b>、<b>邻居发现</b>等。</p><p><b>注意事项</b>：</p><p>▷ 核心：每张网卡都会存在“链路本地地址”，这是IPv6协议通讯的核心，不应当删掉</p><p>▷ 范围：仅在同一个二层范围内进行传播，不会被路由器做转发</p><p>▷ 地址：“链路本地地址”的算法不统一，有的操作系统会根据mac地址计算而来（EUI-64），而有的则是随机或其他某种算法计算而来</p><p>▷ 服务：“链路本地地址”虽然可以在二层内互通，但主要用于核心通讯以及某些网络高级协议。不适用于上层应用业务之间的通讯。因此不能用来上公网，也不能用于对外提供服务</p><hr/><h2>困扰6. IPv6地址如何配置</h2><p><b>公网地址和私网地址</b></p><p>▷ 公网地址：“全球单播地址”（Global Unicast Address，2000::/3）</p><p>▷ 私网地址：“唯一本地地址”（Unique-Local Address，fc00::/7）</p><p>细心的人可能会发现，为什么这里叫做“全球单播地址”，而“唯一本地地址”却不叫做“唯一本地单播地址”，好吧，其实都是简称，在RFC里是这么定义的：“Global Unicast Addresses”、“Link-Local IPv6 Unicast Addresses”。其实“全球单播地址”是可以叫做“全球地址”的，只是这样显得有点别扭。</p><p><b>自动生成还是固定IP</b></p><p>在IPv6里，任何单播地址都可以自动生成，也可以手工配置固定IP，具体看应用场景：</p><p>▷ 客户端：如果我想访问ipv6互联网，而不对外提供服务，那么使用自动生成即可，无需使用固定的ip地址</p><p>▷ 服务端：如果需要对外提供服务，那么ip地址就需要固定了，不能使用自动生成</p><p><b>自动配置IP</b></p><p>在ipv6里还分为2种方法：“有状态”与“无状态”</p><p>▷ 有状态（Stateful）：地址由DHCPv6 Server统一管理，DHCPv6 Client从中获得一个可用的IP地址</p><p>▷ 无状态（Stateless，简称<b>SLAAC</b>）：路由器发出<b>“路由通告”报文（Router Advertisement，简称RA）</b>，报文内包含了IPv6地址的前缀信息。当收到RA包后，就会根据其中前缀信息，自动生成一个或多个IP地址</p><hr/><h2>困扰7. 没有了ARP，如何解析MAC地址</h2><p>ARP协议是IPv4用于解析目标MAC地址的协议，而在IPv6里，解析地址采用的是<b>邻居发现（Neighbor Discovery Protocol，简称NDP或ND）</b></p><p>ND不是一个具体协议，而是用来描述多个相关功能的协议的<b>抽象集合</b>，所涵盖的所有协议均是基于ICMPv6。其中有2种报文与解析MAC地址有关：</p><p>▷ <b>邻居请求报文NS（Neighbor Solicitation）</b>：请求解析</p><p>▷ <b>邻居通告报文NA（Neighbor Advertisement）</b>：响应解析</p><p>这与ping是非常类似的：</p><p>▷ ping：发送icmp的echo request报文，对端响应icmp的echo reply报文</p><p>▷ 地址解析：发送icmp的ns报文，对端响应icmp的na报文</p><hr/><h2>困扰8. IPv6使用多播替代广播，需要做哪些改造</h2><p>IPv6使用多播替代了广播，多播的特点是不会像广播那样完全泛洪，而是数据包只发送给加入了多播组的机器。</p><p>但是，这有个前提，就是<b>交换机要能识别并维护多播组的信息</b>，主流交换机都具备此功能，然而并不都是默认开启的。对于二层交换机来说，需要开启<b>MLDv2 Snooping</b>。</p><p>顾名思义，就是交换机会识别<b>“MLDv2成员报告”</b>报文从哪个端口发来的，并记录下来，之后当交换机收到多播包后，会先查找其多播地址是否能在缓存里匹配上</p><p>▷ 匹配成功：仅会将数据包从相应的端口发出</p><p>▷ 匹配失败：就会泛洪，此时和广播毫无差异</p><hr/><h2>困扰9. IPv6真的安全吗</h2><p><b>理想很美好</b>，IPv6从设计之初，就进行了大量的安全方面的设计，“完整的”IPv6在安全方面有至少以下3个优势：</p><p>▷ 原生支持的端到端加密</p><p>▷ 安全的邻居发现（<b>Secure Neighbor Discovery，简称SEND</b>）</p><p>▷ 更大的地址空间</p><p><b>现实很残酷</b>，只有第3点发挥了作用，更大的地址空间，减少了被非法扫描到的概率。而第1、2点并没真正普及起来，因为<b>协议本身就很复杂、学习难度很大、实现起来也很不容易</b>。因此IETF为了加速IPv6的普及，<b>对安全性不再强制要求</b>。这也导致了IPv6实际上并没有预期中的那么安全，在IPv4里存在的地址欺骗、虚假网关等情况，在IPv6里依然存在。</p><hr/><h2>困扰10. 如何学习IPv6</h2><p>网上能找到非常多的IPv6教程，其中有很多教程都是通篇讲IPv6地址、IP包格式、ICMP包格式，这很容易让初学者打退堂鼓。笔者虽然不是专业的网工，但愿能抛砖引玉，推荐的学习步骤如下：</p><p>1️⃣ IPv6的历史、设计理念</p><p>2️⃣ IPv6的地址格式、分类、前缀计算，以及与IPv4的对比</p><p>3️⃣ IP地址、网关路由的配置与查看</p><p>4️⃣ 服务端实践，尝试给自己的网站增加IPv6</p><p>5️⃣ 客户端实践，让自己的PC访问IPv6互联网</p><p>6️⃣ 应用层实践，自己写一对C/S程序，能同时支持IPv4与IPv6</p><p>7️⃣ IPv6通讯原理，抓包分析每个包，熟悉ND、DHCPv6等</p><p>8️⃣ IPv4与IPv6的互访、过渡</p><p>9️⃣ IPv6安全</p><p>🔟 具体领域的IPv6，例如移动IPv6</p><hr/><h2>后续说明</h2><p>在《IPv6系列》后续文章中，笔者会有选择性地对“困扰10”中提到的部分内容整理成文。为什么是有选择性，因为笔者并非网工出身，没有把握写出更好的文章，不能误人子弟。</p>", 
            "topic": [
                {
                    "tag": "IPv6", 
                    "tagLink": "https://api.zhihu.com/topics/19556734"
                }
            ], 
            "comments": [
                {
                    "userName": "hutudan", 
                    "userLink": "https://www.zhihu.com/people/8c5bdfe44208f455c3dd2e2cf4ea39e9", 
                    "content": "有还有个困惑，局域网内ipv6比ipv4传输速度快吗？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64598841", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 30, 
            "title": "IPv6系列-入门指南", 
            "content": "<p>本文是《IPv6系列》文章的第一篇《入门指南》，用于快速了解并上手IPv6。</p><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ 一. 为什么要了解IPv6</p><p>▪ 二. 顾虑：IPv6地址太复杂了，记不住啊</p><p>▪ 三. 顾虑：每台服务器都有IPv6地址，会暴露整个内网，不安全</p><p>▪ 四. 顾虑：IPv6地址有好几种类型，很难区分和记忆</p><p>▪ 五. 需要学哪些知识</p><p>▪ 六. IPv6基础知识</p><p>▪ 七. IPv6地址生成</p><p>▪ 八. 常用命令</p><p>▪ 九. 在线测试工具</p><p>▪ 十. 开启与关闭IPv6</p><p>▪ 十一. 在CentOS7上配置静态IPv6地址</p><p>▪ 十二. 如何让我的网站对外提供IPv6服务</p><hr/><h2>一. 为什么要了解IPv6</h2><p>你以为我会讲些<b>“正确的废话”</b>，比如IPv6地址空间巨大，可以让地球上的每一粒沙子拥有一个IP地址？比如IPv6更加安全？</p><p><b>错！</b>我才不在意这些，这跟我们有什么关系。</p><p>我要讲的，是不上IPv6，会有哪些后果。</p><p>1️⃣ <b>势不可挡</b>：各大运营商已经在全面铺设IPv6，包括手机、家庭宽带，比如笔者所在地福州的移动4G手机，已经获得IPv6地址。</p><p>2️⃣ <b>坐以待毙</b>：当IPv6占用率达到一定比例的时候，我相信已有的网站、新申请备案的网站，会被强制要求上IPv6，如果不配置，已有网站停止运营、申请备案不予通过。甚至，到那时，手机、家庭宽带，会仅获得IPv6地址，无法获得IPv4地址。最后，IPv4从中国互联网中废除。</p><p>通过上述2点，可以知道，<b>作为服务端（如WEB服务提供方）是必须要上IPv6的</b>，否则不仅无法运营、连用户也都无法访问。</p><p><b>那么，内网需要IPv6吗</b></p><p>▪ 家庭内网，比如连着wifi的手机、电脑</p><p>▪ 企业内网，比如办公室内每个工位上的电脑</p><p>▪ 数据中心内网，比如机房内的服务器、公有云主机</p><p>这些内网环境，是否也需要配置ipv6地址？</p><p>答：<b>只要你想访问IPv6互联网，就必须要在终端上配置IPv6地址</b>。原因在于<b>“IPv6优先原则”</b>，越来越多的程序，比如各大编程语言的许多主流模块/框架，在进行域名解析时，会通过dns优先查询AAAA记录（对应IPv4的A记录） ，若该域名有提供IPv6访问，就必然会解析出AAAA记录。接着，就会优先通过IPv6来访问（即使本机没有配置IPv6，甚至没有启用IPv6），如果IPv6网络不通，则该访问直接失败，即便有的模块/框架在失败后会尝试IPv4，但已经增加了许多的延时</p><p><b>综上所述，IPv6已经来临，而不是还在讨论中，现在没有任何理由继续固守IPv4了。与其坐以待毙，不如主动学习</b></p><hr/><h2>二. 顾虑：IPv6地址太复杂了，记不住啊</h2><p>说的好像IPv4地址你能背下来似的，其实IPv6地址只是长度增加，并且展示方式从十进制改为十六进制，具体的计算方式是一样的。而且有dns在，没必要去背IP地址，就算是内网的IPv6地址，也可以通过DHCPv6或者路由器发送RA包来自动生成IPv6地址。</p><hr/><h2>三. 顾虑：每台服务器都有IPv6地址，会暴露整个内网，不安全</h2><p>担心是对的，但解决方案也和IPv4一样，有2种：</p><p>▷ 可以在内网服务器上配置<b>“IPv6私网地址”</b>，这样公网就访问不到了。在IPv6中，私网地址是<code>fd00::/8</code>，这相当于IPv4的10.0.0.0/8、172.16.0.0/12、192.168.0.0/16。然后在网关上配置<b>NAT</b></p><p>▷ 依然用“IPv6公网地址”（即全球单播地址），但在网关上配置<b>“有状态防火墙”</b></p><p>无论是哪种方案，最终都实现了“只出不进”，即服务器可以主动访问IPv6公网，但公网无法主动访问进来，保证了内网的安全。</p><hr/><h2>四. 顾虑：IPv6地址有好几种类型，很难区分和记忆</h2><p>什么全球单播、唯一本地、链路本地，类型太多了吧？其实，常用的IPv6地址，在IPv4中都能一一对应找到。</p><p>▷ <b>全球单播</b>：对应IPv4的公网</p><p>▷ <b>唯一本地</b>：对应IPv4的私网</p><p>▷ <b>链路本地</b>：在IPv4中也有对应，就是<code>169.254.x.x</code>（这在IPv4中也叫链路本地）</p><p>至于其他类型的地址，要不然是被废弃的，要不然就是很少用到的，除非工作所需碰到，否则完全不用理会，上面这3种类型已经足够用了。除了这3种，下面这2个特殊地址一定很常见</p><p>▷ <code>::1</code>，表示环回地址，对应IPv4中的<code>127.0.0.1</code></p><p>▷ <code>::</code>，表示未指定地址，对应IPv4中的<code>0.0.0.0</code></p><hr/><h2>五. 需要学哪些知识</h2><p>▷ 开发、测试、DBA：只需简单了解IPv6即可，也就是本文看明白后基本就够了</p><p>▷ 运维人员：除了需要了解IPv6，还需要掌握IPv6通讯的工作原理、防火墙的配置等等，详见《IPv6系列》后续文章</p><p>▷ 网工：需要深入了解IPv6，包括IPv6的各类数据包格式、各种架构、多播路由通讯等等</p><hr/><h2>六. IPv6基础知识</h2><p>关于IPv6的教程，网络上已经有非常多写的很棒的教程了，笔者没有把握能写出更好的，因此《IPv6系列》文章，将把重点放在一些概念、解决方案、很多人没注意到的坑、工作原理等等</p><p><b>IPv6地址长度</b></p><p>▷ IPv4：32 bit</p><p>▷ IPv6：128 bit</p><p>可以这么记忆，IPv6比IPv4多了一倍的段落，并且每个段落里增加了一倍的长度，所以IPv6比IPv4长了2x2=4倍</p><p><b>IPv6地址组成</b></p><p>▷ IPv4：网络号+主机号/子网掩码，如<code>192.168.1.2/24</code></p><p>▷ IPv6：前缀ID+接口ID/前缀长度，如<code>2001:0000:0000:0000:0011:0000:0000:0010/64</code></p><p><b>地址简写</b></p><p>▷ IPv4：不支持</p><p>▷ IPv6：压缩0</p><p>注意：IPv6单个段落内可重复压缩，比如上述可压缩为2001:0:0:0:11:0:0:10/64；若多个段落连续为0，可压缩，但只能压缩一次，比如上述可进一步压缩为2001::11:0:0:10/64，或者2001:0:0:0:11::10/64，通常为前者</p><p><b>检验方法</b></p><p>找一台linux服务器，比如centos7系统，执行<code>ip addr add ${IPv6地址} dev eth0</code>，然后<code>ip addr show dev eth0</code>看一下会如何压缩</p><p><b>IPv6地址分类</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-478c424e74820d7c28ba4516826b29ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"841\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"841\" data-original=\"https://pic1.zhimg.com/v2-478c424e74820d7c28ba4516826b29ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;841&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"841\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"841\" data-original=\"https://pic1.zhimg.com/v2-478c424e74820d7c28ba4516826b29ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-478c424e74820d7c28ba4516826b29ec_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：表格列出的是比较常见的地址，并非全部地址</p><p>另外，除了单播、多播，IPv6相比IPv4新增了一种任播（anycast），任播是属于单播范畴内的，无法单纯从地址识别出任播</p><p><b>术语</b></p><p>▪ 节点：任何运行IPv6的设备</p><p>▪ 路由器：转发不是发给自己的IPv6报文的节点</p><p>▪ 主机：非路由器的节点</p><p>▪ 接口：节点和链路相连的物理或逻辑配件</p><p>▪ 链路：由路由器分割的网络接口集合</p><p>▪ 邻居：同一链路上的节点</p><p>▪ 链路MTU：链路能传输的最大单位，即最大的IPv6报文字节数</p><p>▪ 路径MTU：IPv6源端和目的端之间能传输的最大的IPv6报文字节数，通常是路径中所有链路的最小链路MTU</p><hr/><h2>七. IPv6地址生成</h2><p>▷ IPv4：手工指定、dhcp分配</p><p>▷ IPv6：手工指定、dhcp分配、自动生成</p><p>在IPv6里，主流方案就是<b>自动生成IP</b>，而不是手工指定或dhcp分配。当然，作为服务端是需要手工指定的，但对于更广阔的客户端来说，基本都是自动生成。这种自动生成的，叫做“无状态”，相对于“无状态”，通过dhcp获取到的固定IP，就叫做“有状态”（dhcp也支持“无状态”，这里不做详解）</p><p>除了协议规定的特殊地址，其他可自行分配的地址，都是可以在具体范围内自动生成的，包括链路本地、全球单播、唯一本地。其中全球单播、唯一本地，是在接收到路由器发送的RA包后自动生成，具体生成的是全球单播还是唯一本地，是根据RA包内容中的前缀而定</p><p><b>如何自动生成的</b></p><p>无需关心，只要记住一点，能用即可。因为有多种自动生成的方法，有通过mac地址换算而来，有通过某种算法获得，也可能是完全随机而来，而且有的自动生成的地址还会每隔一段时间自动更换，不同的操作系统实现方法不一样，无法统一</p><p><b>为什么会出现这种无法统一的情况</b></p><p>原因在于IPv6协议一直在发展，新协议推翻老协议，每个实现者（也就是不同的操作系统）的诞生时间不同，所参考的协议就有可能不同，而且有的协议还支持不只一种方式，不同实现者出于不同的考量就会采用不同的方式。怎么办？没办法，要不然不理会，要不然投入精力去研究其不同之处，没有一劳永逸的方法。（这段话不仅适用IPv6地址，还适用其他方面，比如DHCPv6等等）</p><hr/><h2>八. 常用命令</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 查看ip\nip -6 addr\n\n# 查看路由\nip -6 route\n\n# 查看多播地址\nip -6 maddr\nnetstat -gn\n\n# 查dns AAAA记录（走ipv4线路）\ndig -t AAAA fzxiaomange.com\nnslookup -query=AAAA fzxiaomange.com\n\n# 查dns AAAA记录（走ipv6线路）\ndig @2620:0:ccc::2 -6 -t AAAA fzxiaomange.com \nnslookup -query=AAAA fzxiaomange.com 2620:0:ccc::2\n\n# 查dns AAAA记录（走ipv6线路的最纯粹、最完整、最靠谱方法）\ndig @2620:0:ccc::2 -t AAAA -6 fzxiaomange.com +trace\n\n# curl\ncurl -6 https://fzxiaomange.com\n\n# ping\nping6 fzxiaomange.com\n\n# trace route\nmtr -6 fzxiaomange.com\ntraceroute6 fzxiaomange.com\ntracert6 fzxiaomange.com\ntracepath6 fzxiaomange.com\n\n# 邻居地址解析，类似ipv4的arping\nndisc6 -n 2002::102 eth0\n\n# iptables查看\nip6tables-save\n\n# tcpdump\ntcpdump -nnn -i eth0 ip6</code></pre></div><hr/><h2>九. 在线测试工具</h2><p>▷ <b>公共dns列表</b></p><div class=\"highlight\"><pre><code class=\"language-text\">https://dns.icoa.cn/ipv6/</code></pre></div><p>▷ <b>查询网站是否提供IPv6</b></p><div class=\"highlight\"><pre><code class=\"language-text\">https://ready.chair6.net/\nhttp://ip6tools.com/#checkWebServer</code></pre></div><p>▷ <b>查询我自己是否拥有公网IPv6地址</b></p><div class=\"highlight\"><pre><code class=\"language-text\">http://www.test-ipv6.com\nhttp://ip6tools.com/#WhatisMyIPv6Address</code></pre></div><hr/><h2>十. 开启与关闭IPv6</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 检查ipv6是否开启\nsysctl -a | grep ipv6 | grep disable # 如果输出的值是一堆0则表示ipv6是开启的\nip -6 addr | grep inet6，如果有看到fe80则表示ipv6是开启的\n\n# 临时禁用ipv6\nsysctl -w net.ipv6.conf.all.disable_ipv6=1\n\n# 临时开启ipv6\nsysctl -w net.ipv6.conf.all.disable_ipv6=0\n\n# 彻底禁用ipv6\n在grub里添加ipv6.disable=1，然后重启操作系统</code></pre></div><hr/><h2>十一. 在CentOS7上配置静态IPv6地址</h2><p>1️⃣ <b>内核参数</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># /etc/sysctl.conf里增加\nnet.ipv6.conf.all.disable_ipv6=0\nnet.ipv6.conf.default.disable_ipv6=0\nnet.ipv6.conf.lo.disable_ipv6=0\n\n# 立即生效\nsysctl -p</code></pre></div><p>2️⃣ <b>/etc/sysconfig/network里增加一行</b></p><div class=\"highlight\"><pre><code class=\"language-text\">NETWORKING_IPV6=yes</code></pre></div><p>3️⃣ <b>/etc/sysconfig/network-scripts/ifcfg-eth0</b></p><div class=\"highlight\"><pre><code class=\"language-text\">DEVICE=eth0\nBOOTPROTO=none\nONBOOT=yes\nIPV6INIT=yes\nIPV6ADDR=2002::102/64\nIPV6_DEFAULTGW=2002::1</code></pre></div><p>4️⃣ <b>重启网络</b></p><div class=\"highlight\"><pre><code class=\"language-text\">systemctl restart network</code></pre></div><hr/><h2>十二. 如何让我的网站对外提供IPv6服务</h2><p>1️⃣ <b>找你的运营商要IPv6地址</b></p><p>▷ 如果你的服务器是托管在电信机房里，那么就找电信运营商要，通常会给你一个/48或/56的地址段 ▷ 如果你的服务器用的是公有云，比如阿里云、腾讯云，就找他们要，只不过由于IPv6还未全面普及，因此有的地域有提供IPv6，有的没有。另外，提供IPv6的方案也不完全一样，有的是以双栈方式，就是你的云主机里可以直接看到IPv6地址，而有的是负载均衡或者弹性IP方式提供。笔者的网站是放在腾讯云上，用的就是IPv6的L4负载均衡</p><p>2️⃣ <b>接下来，在dns里为自己的网站域名增加AAAA记录</b>。（其实现在很多大厂dns服务器，即NS，还未提供纯IPv6线路的解析，比如笔者的个人网站域名解析商当前不支持ipv6-only，这点会在后续文章里进行详细说明）</p><p>3️⃣ <b>最后一步，测试IPv6</b>，可通过<code>https://ready.chair6.net/</code>进行查询</p><p>这里展示下笔者个人网站支持IPv6后的效果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9c5e5a55208a2fd2eae4c927a031edf8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1796\" data-rawheight=\"794\" class=\"origin_image zh-lightbox-thumb\" width=\"1796\" data-original=\"https://pic1.zhimg.com/v2-9c5e5a55208a2fd2eae4c927a031edf8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1796&#39; height=&#39;794&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1796\" data-rawheight=\"794\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1796\" data-original=\"https://pic1.zhimg.com/v2-9c5e5a55208a2fd2eae4c927a031edf8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9c5e5a55208a2fd2eae4c927a031edf8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-476b0cbaa193b4f8fde2676cae372aa9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2556\" data-rawheight=\"1372\" class=\"origin_image zh-lightbox-thumb\" width=\"2556\" data-original=\"https://pic2.zhimg.com/v2-476b0cbaa193b4f8fde2676cae372aa9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2556&#39; height=&#39;1372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2556\" data-rawheight=\"1372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2556\" data-original=\"https://pic2.zhimg.com/v2-476b0cbaa193b4f8fde2676cae372aa9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-476b0cbaa193b4f8fde2676cae372aa9_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "IPv6", 
                    "tagLink": "https://api.zhihu.com/topics/19556734"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "私网地址是fc00::/7", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "<p>是的，但fc00::/8未得到定义，已得到认可的是fd00::/8</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "如何查看端口暴露情况。  路由器后面的设备的iov6地址，端口如何开放？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "ipv6如果得到公网ip,端口全开了。不受nat路由器控制。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "现在，似乎没有nat66,但又一个叫nptv6的东西，这个直接是一对一映射为一个公网地址，理论上这时端口全开。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>我的路由能获取2开头的单播地址，路由器后的设备获取不了怎么办？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "如果你不打算做nat提供ipv6上网的话，你要向运营商申请ipv6段，让他路由一个ipv6段到你的路由器上", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>现在运营商提供的都是ipv6段。后面需要分配一下就行了。已经搞定了。3q。</p>", 
                            "likes": 1, 
                            "replyToAuthor": "小慢哥"
                        }
                    ]
                }, 
                {
                    "userName": "m0618", 
                    "userLink": "https://www.zhihu.com/people/4aea6e5d20da8ca3b4198c0b749c94b8", 
                    "content": "问下唯一本地地址中间那段伪随机生成的前缀怎么在设备和主机上配置啊", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小慢哥", 
                            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
                            "content": "不是很明白你的意思，你是指静态配置还是什么方式配置", 
                            "likes": 0, 
                            "replyToAuthor": "m0618"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61584503", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "通过QEMU-GuestAgent实现从外部注入写文件到KVM虚拟机内部", 
            "content": "<p>本文将以宿主上直接写文件到VM内部为例讲解为何要注入以及如何实现</p><p>tag: qemu-ga, qemu guest agent, kvm, guest-file-write, inject</p><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ 为什么要“注入”到VM内部</p><p>▪ 如何实现“注入”</p><p>▪ Step1. 为VM配置channel</p><p>▪ Step2. 部署qemu-ga</p><p>▪ Step3. 注入操作说明</p><p>▪ Step4. Base64计算</p><p>▪ Step5. 开始注入</p><p>▪ 附1. qemu-ga支持的所有指令</p><p>▪ 附2. 配置多个channel</p><p>▪ 参考文档</p><hr/><h2>为什么要“注入”到VM内部</h2><p><b>原因很简单：在VM外部无法实现，只能进入到VM内来实现</b></p><p>KVM不像Docker(container)只是对进程进行cgroup隔离，KVM是全封闭的环境。</p><p>对于基于KVM的虚拟机来说，通常存在如下需求：</p><p>▷ <b>在线修改密码</b></p><p>▷ <b>在线增加公钥</b></p><p>▷ <b>在线采集性能</b>（如cpu使用率、负载、内存使用量等性能指标）</p><p>▷ <b>其他各种在线功能</b></p><p>上述这些场景的共性：仅在VM外部是无法实现的。因此就有了多种解决方案，但无论哪种解决方案都要同时满足以下2点才能实现：</p><p>▷ <b>通道</b>：在VM内部与外部（宿主）之间打开一个通道，可以进行数据交互</p><p>▷ <b>agent</b>：在VM内部种下一个agent，用于接收外部的指令并反馈结果</p><p>在VM内部种下agent的做法可以形象地称之为<b>&#34;inject 注入&#34;</b></p><hr/><h2>如何实现“注入”</h2><p><b>第一步，打开通道</b></p><p>有2类方法：</p><p>▷ <b>走网络</b>：会复杂一些，需要提前预插入一张管理网卡，或者利用已有网卡+特殊的路由来确保数据能走出去，这带来了较为复杂的网络拓扑</p><p>▷ <b>走设备</b>：简单很多，只需在VM内部和宿主之间建立一个设备通道即可。比如为KVM虚拟机增加一个字符设备，并在宿主上映射为一个socket文件。字符设备与socket之间形成了一个channel，通过该channel就可以进行内外数据互通</p><p>“走网络”不是本文想要介绍的，接下来所有内容均为“走设备”</p><p><b>第二步，启动agent</b></p><p>在虚拟机里启动一个agent，实时读取字符设备，实现与宿主的数据交互。</p><p>在channel中发送与接收什么样的数据，是可以自己定义的，也可以使用KVM官方实现的解决方案，称为Qemu Guest Agent，简称qemu-ga。它包含2方面：</p><p>▷ <b>channel中传送数据的协议定义</b>：基于JSON的格式</p><p>▷ <b>VM内的agent</b>：启动一个名叫qemu-ga的守护进程，该进程将从字符设备里获取传进来的json指令，然后根据指令执行相关命令，并将结果通过字符设备返回给宿主</p><p>qemu-ga的好用之处在于其封装的指令兼容了一些不同的操作系统，比如写文件指令guest-file-write，既可以用于linux也可以用于windows。</p><p>关于qemu-ga的配置与使用，笔者之前已写过一篇文章《基于QMP实现对qemu虚拟机进行交互》，详细介绍其工作原理及基本使用方法，这里附上地址</p><div class=\"highlight\"><pre><code class=\"language-text\">https://www.toutiao.com/i6646012291059810823/</code></pre></div><p>由于本文主题是“注入写文件”，因此接下来将重点阐述如何写文件，不过也会将qemu-ga的部署与启用方法再次贴出。</p><hr/><h2>Step1. 为VM配置channel</h2><p>通过libvirt启动的虚拟机，可以在XML里增加一段配置</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;channel type=&#39;unix&#39;&gt;\n  &lt;source mode=&#39;bind&#39; path=&#39;/tmp/channel.sock&#39;/&gt;\n  &lt;target type=&#39;virtio&#39; name=&#39;org.qemu.guest_agent.0&#39;/&gt;\n&lt;/channel&gt;</code></pre></div><p>注意：上面这段配置要放在<code>&lt;devices&gt;</code>段落中</p><hr/><h2>Step2. 部署qemu-ga</h2><p>1️⃣ <b>安装qemu-ga</b></p><p>在VM内部安装并启动qemu-ga，linux和windows均支持qemu-ga，许多linux发行商都会提供自己的qemu-ga，比如rhel/centos、fedora、ubuntu、opensuse都有提供编译好的qemu-ga，可以直接下载使用。而windows系统需要下载virtio-win，其中有包含一些virtio的win驱动以及qemu-ga安装包，也可以仅下载qemu-ga安装包</p><div class=\"highlight\"><pre><code class=\"language-text\"># rhel/centos\nyum install qemu-guest-agent\n\n# windows，最新virtio-win iso\nhttps://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-virtio/\n# windows，最新qemu-ga安装包\nhttps://fedorapeople.org/groups/virt/virtio-win/direct-downloads/latest-qemu-ga/</code></pre></div><p>windows的qemu-ga安装包如图所示</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-414eb507d1076239041a382b1a13e2b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1818\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"1818\" data-original=\"https://pic2.zhimg.com/v2-414eb507d1076239041a382b1a13e2b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1818&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1818\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1818\" data-original=\"https://pic2.zhimg.com/v2-414eb507d1076239041a382b1a13e2b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-414eb507d1076239041a382b1a13e2b9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2️⃣ <b>启动qemu-ga</b></p><p>以centos7为例</p><div class=\"highlight\"><pre><code class=\"language-text\"># 启动qemu-ga守护进程\nsystemctl start qemu-guest-agent\n\n# 加入开机启动\nsystemctl enable qemu-guest-agent</code></pre></div><p>启动后通过<code>systemctl status qemu-guest-agent</code>应当能看到进程已启动，如图所示</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d3170195cc9e0ef4a8607750f51b9ede_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2134\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb\" width=\"2134\" data-original=\"https://pic3.zhimg.com/v2-d3170195cc9e0ef4a8607750f51b9ede_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2134&#39; height=&#39;442&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2134\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2134\" data-original=\"https://pic3.zhimg.com/v2-d3170195cc9e0ef4a8607750f51b9ede_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d3170195cc9e0ef4a8607750f51b9ede_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：有的qemu-ga会拒绝部分指令，这是因为qemu-ga的配置文件里将某些指令给禁用了，比如在centos7里，配置文件为/etc/sysconfig/qemu-ga</p><div class=\"highlight\"><pre><code class=\"language-text\"># 修改/etc/sysconfig/qemu-ga，将以下内容注释掉，或直接删掉\nBLACKLIST_RPC=guest-file-open,guest-file-close,guest-file-read,guest-file-write,guest-file-seek,guest-file-flush,guest-exec,guest-exec-status\n\n# 重启qemu-ga才能生效\nsystemctl restart qemu-guest-agent</code></pre></div><p>3️⃣ <b>测试qemu-ga</b></p><p>在VM的宿主机上，执行以下命令：</p><div class=\"highlight\"><pre><code class=\"language-text\"># ${DOMAIN}表示虚拟机名字或UUID\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-ping&#34;}&#39;</code></pre></div><p>如果返回以下内容则表示qemu-ga可用</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;return&#34;:{}}</code></pre></div><p>接下来查看下qemu-ga支持哪些指令</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-agent-command ${DOMAIN} --pretty &#39;{&#34;execute&#34;:&#34;guest-info&#34;}&#39;</code></pre></div><p>应该会看到支持很多命令，由于接下来做的实验需要用到如下命令，因此请先确认是否均支持</p><p>▪ guest-exec：执行命令（异步操作）</p><p>▪ guest-exec-status：查看执行命令的结果</p><p>▪ guest-file-open：打开文件，获得句柄</p><p>▪ guest-file-write：写文件（传递base64）</p><p>▪ guest-file-close：关闭文件</p><hr/><h2>Step3. 注入操作说明</h2><p>实验目标：<b>将RSA的公钥内容写入到/root/.ssh/authorized_keys</b></p><p>这涉及到如下3个步骤：</p><p>1. 创建/root/.ssh目录且权限为700</p><p>2. 创建/root/.ssh/authorized_keys文件且权限为600</p><p>3. 将RSA公钥文本进行Base64编码（guest-file-write不支持明文，仅支持base64），并将编码后的内容写入/root/.ssh/authorized_keys</p><hr/><h2>Step4. Base64计算</h2><p>这里先假设RSA公钥内容为</p><div class=\"highlight\"><pre><code class=\"language-text\">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVKog04pbbLaarjbpvK7CRaIuUwWxehJIH8tqtX/oV4GYN5WGYPFa1tzsd4Vyoblm4LePX79WeI4kFHgSbH5P6H9i8l3KCTFHHeJT/g0P55/c60yDb3o6lqpWu9IKE3I4lsTp05Y/W0Ks7W27Jndr162ni0Ybthgd9CQyoiburoh35ECiPGwWUOBVJ4IEpSpOZdDUJLS/vVuSQgvEH0fq/G1DP3SOyR+DNasJ00mwonfaUKHZXmWAlH8marNwPmWapyTSQwCFKKh1HwlJEWETV4fYuFwm3iennb8cX1y4aX9AJWnA2cc35rpulivMijeXs/ssT5iFljXXGYzmkX6nR root@localhost.localdomain</code></pre></div><p>进行Base64编码</p><div class=\"highlight\"><pre><code class=\"language-text\">echo &#39;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDVKog04pbbLaarjbpvK7CRaIuUwWxehJIH8tqtX/oV4GYN5WGYPFa1tzsd4Vyoblm4LePX79WeI4kFHgSbH5P6H9i8l3KCTFHHeJT/g0P55/c60yDb3o6lqpWu9IKE3I4lsTp05Y/W0Ks7W27Jndr162ni0Ybthgd9CQyoiburoh35ECiPGwWUOBVJ4IEpSpOZdDUJLS/vVuSQgvEH0fq/G1DP3SOyR+DNasJ00mwonfaUKHZXmWAlH8marNwPmWapyTSQwCFKKh1HwlJEWETV4fYuFwm3iennb8cX1y4aX9AJWnA2cc35rpulivMijeXs/ssT5iFljXXGYzmkX6nR root@localhost.localdomain&#39; | base64 -w 0</code></pre></div><p>这样就获得了base64编码内容</p><div class=\"highlight\"><pre><code class=\"language-text\">c3NoLXJzYSBBQUFBQjNOemFDMXljMkVBQUFBREFRQUJBQUFCQVFEVktvZzA0cGJiTGFhcmpicHZLN0NSYUl1VXdXeGVoSklIOHRxdFgvb1Y0R1lONVdHWVBGYTF0enNkNFZ5b2JsbTRMZVBYNzlXZUk0a0ZIZ1NiSDVQNkg5aThsM0tDVEZISGVKVC9nMFA1NS9jNjB5RGIzbzZscXBXdTlJS0UzSTRsc1RwMDVZL1cwS3M3VzI3Sm5kcjE2Mm5pMFlidGhnZDlDUXlvaWJ1cm9oMzVFQ2lQR3dXVU9CVko0SUVwU3BPWmREVUpMUy92VnVTUWd2RUgwZnEvRzFEUDNTT3lSK0ROYXNKMDBtd29uZmFVS0haWG1XQWxIOG1hck53UG1XYXB5VFNRd0NGS0toMUh3bEpFV0VUVjRmWXVGd20zaWVubmI4Y1gxeTRhWDlBSlduQTJjYzM1cnB1bGl2TWlqZVhzL3NzVDVpRmxqWFhHWXpta1g2blIgcm9vdEBsb2NhbGhvc3QubG9jYWxkb21haW4K</code></pre></div><hr/><h2>Step5. 开始注入</h2><p>1️⃣ <b>创建/root/.ssh目录且权限为700</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># mkdir /root/.ssh\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec&#34;,&#34;arguments&#34;:{&#34;path&#34;:&#34;mkdir&#34;,&#34;arg&#34;:[&#34;-p&#34;,&#34;/root/.ssh&#34;],&#34;capture-output&#34;:true}}&#39;\n\n# 假设上一步返回{&#34;return&#34;:{&#34;pid&#34;:911}}，接下来查看结果（通常可忽略）\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec-status&#34;,&#34;arguments&#34;:{&#34;pid&#34;:911}}&#39; \n\n# chmod 700 /root/.ssh，此行其实可不执行，因为上面创建目录后就是700，但为了防止权限不正确导致无法使用，这里还是再刷一次700比较稳妥\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec&#34;,&#34;arguments&#34;:{&#34;path&#34;:&#34;chmod&#34;,&#34;arg&#34;:[&#34;700&#34;,&#34;/root/.ssh&#34;],&#34;capture-output&#34;:true}}&#39; \n\n# 假设上一步返回{&#34;return&#34;:{&#34;pid&#34;:912}}，接下来查看结果（通常可忽略）\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec-status&#34;,&#34;arguments&#34;:{&#34;pid&#34;:912}}&#39;</code></pre></div><p>2️⃣ <b>创建/root/.ssh/authorized_keys文件且权限为600</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># touch /root/.ssh/authorized_keys\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec&#34;,&#34;arguments&#34;:{&#34;path&#34;:&#34;touch&#34;,&#34;arg&#34;:[&#34;/root/.ssh/authorized_keys&#34;],&#34;capture-output&#34;:true}}&#39;\n\n# 假设上一步返回{&#34;return&#34;:{&#34;pid&#34;:913}}，接下来查看结果（通常可忽略）\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec-status&#34;,&#34;arguments&#34;:{&#34;pid&#34;:913}}&#39;\n\n# chmod 600 /root/.ssh/authorized_keys，此行其实可不执行，因为上面创建文件后就是600，但为了防止权限不正确导致无法使用，这里还是再刷一次600比较稳妥\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec&#34;,&#34;arguments&#34;:{&#34;path&#34;:&#34;chmod&#34;,&#34;arg&#34;:[&#34;600&#34;,&#34;/root/.ssh/authorized_keys&#34;],&#34;capture-output&#34;:true}}&#39;\n\n# 假设上一步返回{&#34;return&#34;:{&#34;pid&#34;:914}}，接下来查看结果（通常可忽略）\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-exec-status&#34;,&#34;arguments&#34;:{&#34;pid&#34;:914}}&#39;</code></pre></div><p>3️⃣ <b>将Base64编码写入/root/.ssh/authorized_keys</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 打开文件（以读写方式打开），获得句柄\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-file-open&#34;, &#34;arguments&#34;:{&#34;path&#34;:&#34;/root/.ssh/authorized_keys&#34;,&#34;mode&#34;:&#34;w+&#34;}}&#39;\n\n# 写文件，假设上一步返回{&#34;return&#34;:1000}，1000就是句柄\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-file-write&#34;, &#34;arguments&#34;:{&#34;handle&#34;:1000,&#34;buf-b64&#34;:&#34;c3NoLXJzYSBBQUFBQjNOemFDMXljMkVBQUFBREFRQUJBQUFCQVFEVktvZzA0cGJiTGFhcmpicHZLN0NSYUl1VXdXeGVoSklIOHRxdFgvb1Y0R1lONVdHWVBGYTF0enNkNFZ5b2JsbTRMZVBYNzlXZUk0a0ZIZ1NiSDVQNkg5aThsM0tDVEZISGVKVC9nMFA1NS9jNjB5RGIzbzZscXBXdTlJS0UzSTRsc1RwMDVZL1cwS3M3VzI3Sm5kcjE2Mm5pMFlidGhnZDlDUXlvaWJ1cm9oMzVFQ2lQR3dXVU9CVko0SUVwU3BPWmREVUpMUy92VnVTUWd2RUgwZnEvRzFEUDNTT3lSK0ROYXNKMDBtd29uZmFVS0haWG1XQWxIOG1hck53UG1XYXB5VFNRd0NGS0toMUh3bEpFV0VUVjRmWXVGd20zaWVubmI4Y1gxeTRhWDlBSlduQTJjYzM1cnB1bGl2TWlqZVhzL3NzVDVpRmxqWFhHWXpta1g2blIgcm9vdEBsb2NhbGhvc3QubG9jYWxkb21haW4K&#34;}}&#39;\n\n# 关闭文件\nvirsh qemu-agent-command ${DOMAIN} &#39;{&#34;execute&#34;:&#34;guest-file-close&#34;, &#34;arguments&#34;:{&#34;handle&#34;:1000}}&#39;</code></pre></div><p>查看效果：此时到VM里查看/root/.ssh/authorized_keys，应该能看到新增加的一行</p><hr/><h2>附1. qemu-ga支持的所有指令</h2><p>不同的qemu-ga版本、不同的操作系统，支持的指令都会有所差异，下面是从官网上看到的当前所有参数</p><p>▪ guest-exec</p><p>▪ guest-exec-status</p><p>▪ guest-file-close</p><p>▪ guest-file-flush</p><p>▪ guest-file-open</p><p>▪ guest-file-read</p><p>▪ guest-file-seek</p><p>▪ guest-file-write</p><p>▪ guest-fsfreeze-freeze</p><p>▪ guest-fsfreeze-freeze-list</p><p>▪ guest-fsfreeze-status</p><p>▪ guest-fsfreeze-thaw</p><p>▪ guest-fstrim</p><p>▪ guest-get-fsinfo</p><p>▪ guest-get-host-name</p><p>▪ guest-get-memory-block-info</p><p>▪ guest-get-memory-blocks</p><p>▪ guest-get-osinfo</p><p>▪ guest-get-time</p><p>▪ guest-get-timezone</p><p>▪ guest-get-users</p><p>▪ guest-get-vcpus</p><p>▪ guest-info</p><p>▪ guest-network-get-interfaces</p><p>▪ guest-ping</p><p>▪ guest-set-memory-blocks</p><p>▪ guest-set-time</p><p>▪ guest-set-user-password</p><p>▪ guest-set-vcpus</p><p>▪ guest-shutdown</p><p>▪ guest-suspend-disk</p><p>▪ guest-suspend-hybrid</p><p>▪ guest-suspend-ram</p><p>▪ guest-sync</p><p>▪ guest-sync-delimited</p><p>具体使用方法，请参考官网文档</p><div class=\"highlight\"><pre><code class=\"language-text\">https://qemu.weilnetz.de/doc/qemu-ga-ref.html</code></pre></div><hr/><h2>附2. 配置多个channel</h2><p>1️⃣ <b>可以在XML里配置多个channel，这样就可以创建多个设备通道</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;channel type=&#39;unix&#39;&gt;\n  &lt;source mode=&#39;bind&#39; path=&#39;/tmp/channel.sock&#39;/&gt;\n  &lt;target type=&#39;virtio&#39; name=&#39;org.qemu.guest_agent.0&#39;/&gt;\n&lt;/channel&gt;\n&lt;channel type=&#39;unix&#39;&gt;\n  &lt;source mode=&#39;bind&#39; path=&#39;/tmp/channel.sock-1&#39;/&gt;\n  &lt;target type=&#39;virtio&#39; name=&#39;org.qemu.guest_agent.1&#39;/&gt;\n&lt;/channel&gt;</code></pre></div><p>2️⃣ <b>在VM里要启动2个qemu-ga守护进程，可以将原有的service文件拷贝一份出来进行修改</b></p><div class=\"highlight\"><pre><code class=\"language-text\">cd /usr/lib/systemd/system\ncp qemu-guest-agent.service qemu-guest-agent-1.service</code></pre></div><p>然后修改qemu-guest-agent-1.service</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-03e6b1aa42aedfb3f9e2a03cedabd914_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1190\" data-rawheight=\"888\" class=\"origin_image zh-lightbox-thumb\" width=\"1190\" data-original=\"https://pic1.zhimg.com/v2-03e6b1aa42aedfb3f9e2a03cedabd914_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1190&#39; height=&#39;888&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1190\" data-rawheight=\"888\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1190\" data-original=\"https://pic1.zhimg.com/v2-03e6b1aa42aedfb3f9e2a03cedabd914_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-03e6b1aa42aedfb3f9e2a03cedabd914_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3️⃣ <b>启动服务</b></p><div class=\"highlight\"><pre><code class=\"language-text\">systemctl start qemu-guest-agent-1</code></pre></div><hr/><h2>参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\"># qemu-ga介绍与使用：QEMU Guest Agent\n# qemu-ga完整参数：https://qemu.weilnetz.de/doc/qemu-ga-ref.html\n# 笔者另一篇相关文章《基于QMP实现对qemu虚拟机进行交互》：https://www.toutiao.com/i6646012291059810823/</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "KVM（Kernel-based Virtual Machine）", 
                    "tagLink": "https://api.zhihu.com/topics/19607498"
                }, 
                {
                    "tag": "QEMU", 
                    "tagLink": "https://api.zhihu.com/topics/19636090"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59649017", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "基于macOS+VMware的GNS3内VM上公网", 
            "content": "<p>笔者经常需要做网络实验，GNS3就是笔者最喜欢用的模拟器，为了便于实验，需要能从macos上直接ssh登陆模拟出来的vm，并且vm需要上公网。经过研究，已解决此问题，并以此分享出来</p><p>tag: macos, vmware, gns3, vm上公网</p><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>环境说明</h2><p>本文基于以下环境：</p><p>▷ 宿主：macOS Mojave<br/>▷ GNS3版本：2.1.14<br/>▷ GNS3内部的VM运行在：GNS3 VM里<br/>▷ GNS3 VM运行在：VMware Fusion 专业版 11.0.1<br/>▷ centos7.3是运行在GNS3 VM里的Qemu虚拟机</p><p>可以理解为在macOS上运行了VMware，在VMware里运行了GNS3 VM，在GNS3 VM里运行了Qemu虚拟机。</p><p>对，就是&#34;俄罗斯套娃&#34;。</p><p>想让GNS3内的VM上Internet公网，有2种方法，接下来分别详细讲解</p><h2><b>方法1（内置）</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a23c731f90c6b21a0e9144d33835678b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-a23c731f90c6b21a0e9144d33835678b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-a23c731f90c6b21a0e9144d33835678b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a23c731f90c6b21a0e9144d33835678b_b.jpg\"/></figure><p>GNS3内置一个nat cloud，只要将vm连上这个nat cloud就可以上公网（上图中的Nat1就是nat cloud）</p><p>实现原理：nat cloud会对数据包进行SNAT，将源IP转换成macOS上出公网对应的本机ip。比如macOS是用wifi上网，wifi dhcp分配给macOS的ip是192.168.1.10，那么nat cloud就会将自己的ip出公网数据包的源IP转换为192.168.1.10</p><p>▪ 优点：无需任何额外配置，GNS3内置实现<br/>▪ 缺点：无法从macOS上直接ssh连接到vm（即图上的centos7.3-1，本文接下去的部分若无特殊说明，均用vm表示），只能通过vnc连接</p><h2><b>方法2（推荐）</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-852f4d4f0183ed8f1cdeef93501d0910_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic1.zhimg.com/v2-852f4d4f0183ed8f1cdeef93501d0910_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"250\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic1.zhimg.com/v2-852f4d4f0183ed8f1cdeef93501d0910_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-852f4d4f0183ed8f1cdeef93501d0910_b.jpg\"/></figure><p>采用vmnet + GNS3 VM加网卡 + 自定义cloud + pfctl + 开启ip_forward</p><p>▪ 优点：vm不仅可以上网，还可以从mac上连接到vm里做管理<br/>▪ 缺点：配置相对复杂，需要对macos、vmware、gns3、网络原理有一定了解</p><p>1️⃣ <b>vmware偏好设置里新增一张网卡，这里为vmnet2，然后按下图所示进行配置</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a218775f04c3890f552af5c6a938e93a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"527\" class=\"origin_image zh-lightbox-thumb\" width=\"562\" data-original=\"https://pic3.zhimg.com/v2-a218775f04c3890f552af5c6a938e93a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;562&#39; height=&#39;527&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"527\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"562\" data-original=\"https://pic3.zhimg.com/v2-a218775f04c3890f552af5c6a938e93a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a218775f04c3890f552af5c6a938e93a_b.jpg\"/></figure><p>▷ “允许该网络上的虚拟机连接到外部网络（使用NAT）”不要勾选，因为测试发现bug（比如虚拟机里访问Internet公网，响应时有时无，延时也很严重，怀疑是GNS3 VM的bug）<br/>▷ “将Mac主机连接到该网络”要勾选，这样在macos上才能出现vmnet2网卡<br/>▷ 子网IP是自动生成的，这里是172.16.71.0/24，对应macos上vmnet2的ip是172.16.71.1/24</p><p>2️⃣ <b>GNS3 VM加网卡</b></p><p>在vmware里打开GNS3 VM的配置，添加一张网卡，如下图红框里的网络适配器3就是笔者添加的网卡</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-471b86f4ed486e19d1ccfe79d06d7c2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb\" width=\"620\" data-original=\"https://pic4.zhimg.com/v2-471b86f4ed486e19d1ccfe79d06d7c2b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;620&#39; height=&#39;368&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"620\" data-original=\"https://pic4.zhimg.com/v2-471b86f4ed486e19d1ccfe79d06d7c2b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-471b86f4ed486e19d1ccfe79d06d7c2b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c50927544579defe8a13340dbd19f692_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"397\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-c50927544579defe8a13340dbd19f692_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;397&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"397\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-c50927544579defe8a13340dbd19f692_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c50927544579defe8a13340dbd19f692_b.jpg\"/></figure><p>3️⃣ <b>自定义cloud</b></p><p>如下图，要选择“Run the cloud node on the GNS3 VM”</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-666867cad65dd1d4c6527ce70f131296_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1936\" data-rawheight=\"1388\" class=\"origin_image zh-lightbox-thumb\" width=\"1936\" data-original=\"https://pic3.zhimg.com/v2-666867cad65dd1d4c6527ce70f131296_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1936&#39; height=&#39;1388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1936\" data-rawheight=\"1388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1936\" data-original=\"https://pic3.zhimg.com/v2-666867cad65dd1d4c6527ce70f131296_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-666867cad65dd1d4c6527ce70f131296_b.jpg\"/></figure><p>名字任意，这里叫做mgr-cloud</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b9bd3f7366a498cd805a8432ea33e9f2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1152\" data-rawheight=\"870\" class=\"origin_image zh-lightbox-thumb\" width=\"1152\" data-original=\"https://pic3.zhimg.com/v2-b9bd3f7366a498cd805a8432ea33e9f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1152&#39; height=&#39;870&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1152\" data-rawheight=\"870\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1152\" data-original=\"https://pic3.zhimg.com/v2-b9bd3f7366a498cd805a8432ea33e9f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b9bd3f7366a498cd805a8432ea33e9f2_b.jpg\"/></figure><p>注意，只需要将eth2（即上一步新增的网络适配器3）Add进来</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7dbd6aa86ec02ffc3a5d7f1cb808ec59_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1140\" data-rawheight=\"926\" class=\"origin_image zh-lightbox-thumb\" width=\"1140\" data-original=\"https://pic2.zhimg.com/v2-7dbd6aa86ec02ffc3a5d7f1cb808ec59_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1140&#39; height=&#39;926&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1140\" data-rawheight=\"926\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1140\" data-original=\"https://pic2.zhimg.com/v2-7dbd6aa86ec02ffc3a5d7f1cb808ec59_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7dbd6aa86ec02ffc3a5d7f1cb808ec59_b.jpg\"/></figure><p>4️⃣ <b>在macos上通过pfctl配置nat，以及允许vmnet2流量进出</b></p><p>a. sudo vim /etc/pf.anchors/vmware-gns3，内容如下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9b21d82ffe3fe17499d3cb3fcdab5cfa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"928\" data-original=\"https://pic3.zhimg.com/v2-9b21d82ffe3fe17499d3cb3fcdab5cfa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;928&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"928\" data-original=\"https://pic3.zhimg.com/v2-9b21d82ffe3fe17499d3cb3fcdab5cfa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9b21d82ffe3fe17499d3cb3fcdab5cfa_b.jpg\"/></figure><p>图上的en7是笔者mac上的有线网卡，en0是我mac上的wifi网卡（因为在公司是用有线网卡，在家里是用wifi上网，所以按上面这样配置2条，就无需担心网络切换会导致nat失败）</p><p>b. sudo vim /etc/pf.conf，内容如下（红框内容是需要增加的）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-79fedb7bf5a69cb2490faaae8e3282d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"1220\" data-original=\"https://pic2.zhimg.com/v2-79fedb7bf5a69cb2490faaae8e3282d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1220&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1220\" data-original=\"https://pic2.zhimg.com/v2-79fedb7bf5a69cb2490faaae8e3282d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-79fedb7bf5a69cb2490faaae8e3282d1_b.jpg\"/></figure><p>c. 校验配置文件并生效：</p><div class=\"highlight\"><pre><code class=\"language-text\"># 校验\nsudo pfctl -vnf /etc/pf.anchors/vmware-gns3\nsudo pfctl -vnf /etc/pf.conf\n\n# 生效\nsudo pfctl -ef /etc/pf.conf</code></pre></div><p>pfctl会在mac开机时自动执行，无需每次都手工执行</p><p>5️⃣ <b>开启ip_forward</b></p><div class=\"highlight\"><pre><code class=\"language-text\">sudo sysctl -w net.inet.ip.forwarding=1</code></pre></div><p>注意：该命令在mac重启后就会失效，因此在使用GNS3时候需要手工执行一次</p><h2><b>测试</b></h2><p>方法1不符合需求，就不再赘述</p><p>方法2的测试：此时，vm里应该已经通过dhcp获得ip地址，并且可以直接从mac上ssh登陆vm。然后在vm里只需要手工增加一条网关（网关指向mac上vmnet2的ip，笔者环境对应的是172.16.71.1），就可以通过mac上公网。另外，vm里的dns需要手工配置（比如指向8.8.8.8）</p><h2><b>附：多台vm上公网</b></h2><p>如果需要多台vm上公网，可以自行添加一个hub或switch</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bc3de83d2fc8e2783b78e4e1b99a9773_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"772\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb\" width=\"772\" data-original=\"https://pic4.zhimg.com/v2-bc3de83d2fc8e2783b78e4e1b99a9773_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;772&#39; height=&#39;716&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"772\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"772\" data-original=\"https://pic4.zhimg.com/v2-bc3de83d2fc8e2783b78e4e1b99a9773_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bc3de83d2fc8e2783b78e4e1b99a9773_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "GNS3", 
                    "tagLink": "https://api.zhihu.com/topics/20011940"
                }, 
                {
                    "tag": "VMware Fusion", 
                    "tagLink": "https://api.zhihu.com/topics/19683657"
                }, 
                {
                    "tag": "macOS", 
                    "tagLink": "https://api.zhihu.com/topics/19550290"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56892392", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 14, 
            "title": "基于RHEL8/CentOS8的网络IP配置详解", 
            "content": "<p></p><blockquote> ➡ 在rhel8(含centos8)上，没有传统的network.service，在/etc/sysconfig/network-scripts/里也看不到任何脚本文件，那么该如何进行网络配置呢。<br/> ➡ 本文详细阐述基于rhel8的网络配置，包含多种配置方法。<br/> ➡ 事先声明：本文提及的所有内容，仅适用rhel8/centos8，因为不同linux系统的NetworkManager行为存在部分差异。<br/> </blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ rhel8与7的区别</p><p>▪ NetworkManager介绍</p><p>▪ nmcli使用方法</p><p>▪ nmcli常用命令一览</p><p>▪ nmcli connection重点</p><p>▪ nmcli device重点</p><p>▪ 3种网络配置方法</p><p>▪ Tips</p><h2><b>rhel8与7的区别</b></h2><p>在rhel7上，同时支持network.service和NetworkManager.service（简称NM）。默认情况下，这2个服务都有开启，但许多人都会将NM禁用掉。</p><p>在rhel8上，已废弃network.service，因此只能通过NM进行网络配置，包括动态ip和静态ip。换言之，在rhel8上，必须开启NM，否则无法使用网络。</p><blockquote> rhel8依然支持network.service，只是默认没安装，详见本文最后的Tips。</blockquote><h2><b>NetworkManager介绍</b></h2><p>NetworkManager是2004年Red Hat启动的项目，旨在能够让Linux用户更轻松地处理现代网络需求，尤其是无线网络，能自动发现网卡并配置ip地址。</p><blockquote> 类似在手机上同时开启wifi和蜂窝网络，自动探测可用网络并连接，无需手动切换。</blockquote><p>虽然初衷是针对无线网络，但在服务器领域，NM已大获成功。</p><p><b>NM能管理各种网络</b></p><p>▷ 有线网卡、无线网卡</p><p>▷ 动态ip、静态ip</p><p>▷ 以太网、非以太网</p><p>▷ 物理网卡、虚拟网卡</p><p><b>使用方法</b></p><p>▷ nmcli：命令行。这是最常用的工具，本文将详细讲解该工具使用。</p><p>▷ nmtui：在shell终端开启文本图形界面。示意图见本文最后的Tips</p><p>▷ Freedesktop applet：如GNOME上自带的网络管理工具</p><p>▷ cockpit：redhat自带的基于web图形界面的&#34;驾驶舱&#34;工具，具有dashborad和基础管理功能。示意图见本文最后的Tips</p><p><b>为什么要用NM</b></p><p>▷ 工具齐全：命令行、文本界面、图形界面、web</p><p>▷ 广纳天地：纳管各种网络，有线、无线、物理、虚拟</p><p>▷ 参数丰富：多达200多项配置参数（包括ethtool参数）</p><p>▷ 一统江湖：RedHat系、Suse系、Debian/Ubuntu系，均支持</p><p>▷ 大势所趋：下一个大版本的rhel只能通过NM管理网络</p><h2><b>nmcli使用方法</b></h2><p>nmcli使用方法非常类似linux ip命令、cisco交换机命令，并且支持tab补全（详见本文最后的Tips），也可在命令最后通过-h、--help、help查看帮助。在nmcli中有2个命令最为常用：</p><p>🍀 <b>nmcli connection</b></p><p>译作<b>连接</b>，可理解为配置文件，相当于ifcfg-ethX。可以简写为nmcli c</p><p>🍀 <b>nmcli device</b></p><p>译作<b>设备</b>，可理解为实际存在的网卡（包括物理网卡和虚拟网卡）。可以简写为nmcli d</p><p>在NM里，有2个维度：<b>连接（connection）</b>和<b>设备（device）</b>，这是多对一的关系。想给某个网卡配ip，首先NM要能纳管这个网卡。设备里存在的网卡（即<code>nmcli d</code>可以看到的），就是NM纳管的。接着，可以为一个设备配置多个连接（即<code>nmcli c</code>可以看到的），每个连接可以理解为一个ifcfg配置文件。同一时刻，一个设备只能有一个连接活跃。可以通过<code>nmcli c up</code>切换连接。</p><p><b>connection有2种状态</b>：</p><p>▷ 活跃（带颜色字体）：表示当前该connection生效</p><p>▷ 非活跃（正常字体）：表示当前该connection不生效</p><p><b>device有4种常见状态</b>：</p><p>▷ connected：已被NM纳管，并且当前有活跃的connection</p><p>▷ disconnected：已被NM纳管，但是当前没有活跃的connection</p><p>▷ unmanaged：未被NM纳管</p><p>▷ unavailable：不可用，NM无法纳管，通常出现于网卡link为down的时候（比如ip link set ethX down）</p><h2><b>nmcli常用命令一览</b></h2><div class=\"highlight\"><pre><code class=\"language-text\"># 查看ip（类似于ifconfig、ip addr）\nnmcli\n\n# 创建connection，配置静态ip（等同于配置ifcfg，其中BOOTPROTO=none，并ifup启动）\nnmcli c add type ethernet con-name ethX ifname ethX ipv4.addr 192.168.1.100/24 ipv4.gateway 192.168.1.1 ipv4.method manual\n\n# 创建connection，配置动态ip（等同于配置ifcfg，其中BOOTPROTO=dhcp，并ifup启动）\nnmcli c add type ethernet con-name ethX ifname ethX ipv4.method auto\n\n# 修改ip（非交互式）\nnmcli c modify ethX ipv4.addr &#39;192.168.1.200/24&#39;\nnmcli c up ethX\n\n# 修改ip（交互式）\nnmcli c edit ethX\nnmcli&gt; goto ipv4.addresses\nnmcli ipv4.addresses&gt; change\nEdit &#39;addresses&#39; value: 192.168.1.200/24\nDo you also want to set &#39;ipv4.method&#39; to &#39;manual&#39;? [yes]: yes\nnmcli ipv4&gt; save\nnmcli ipv4&gt; activate\nnmcli ipv4&gt; quit\n\n# 启用connection（相当于ifup）\nnmcli c up ethX\n\n# 停止connection（相当于ifdown）\nnmcli c down\n\n# 删除connection（类似于ifdown并删除ifcfg）\nnmcli c delete ethX\n\n# 查看connection列表\nnmcli c show\n\n# 查看connection详细信息\nnmcli c show ethX\n\n# 重载所有ifcfg或route到connection（不会立即生效）\nnmcli c reload\n\n# 重载指定ifcfg或route到connection（不会立即生效）\nnmcli c load /etc/sysconfig/network-scripts/ifcfg-ethX\nnmcli c load /etc/sysconfig/network-scripts/route-ethX\n\n# 立即生效connection，有3种方法\nnmcli c up ethX\nnmcli d reapply ethX\nnmcli d connect ethX\n\n# 查看device列表\nnmcli d\n\n# 查看所有device详细信息\nnmcli d show\n\n# 查看指定device的详细信息\nnmcli d show ethX\n\n# 激活网卡\nnmcli d connect ethX\n\n# 关闭无线网络（NM默认启用无线网络）\nnmcli r all off\n\n# 查看NM纳管状态\nnmcli n\n\n# 开启NM纳管\nnmcli n on\n\n# 关闭NM纳管（谨慎执行）\nnmcli n off\n\n# 监听事件\nnmcli m\n\n# 查看NM本身状态\nnmcli\n\n# 检测NM是否在线可用\nnm-online</code></pre></div><blockquote> 本文提及的ifcfg均指代/etc/sysconfig/network-scripts/ifcfg-ethX及/etc/sysconfig/network-scripts/route-ethX</blockquote><h2><b>nmcli connection重点</b></h2><p>🍀 <b>nmcli c show</b></p><p>▪ 第一列是connection名字，简称con-name（注意con-name不是网卡名）</p><p>▪ 第二列是connection的UUID</p><p>▪ 最后一列才是网卡名（标准说法叫device名），可通过nmcil d查看device</p><p>对connection做操作时需要指定标识，标识可以是con-name、UUID、如果存在ifcfg文件则也可以用ifcfg的完整路径，即/etc/sysconfig/network-scripts/ifcfg-ethX</p><div class=\"highlight\"><pre><code class=\"language-text\">nmcli c show ethX\nnmcli c show cae3f1ef-e79a-46c3-8e0c-946b91a65e11\nnmcli c show /etc/sysconfig/network-scripts/ifcfg-ethX</code></pre></div><p>🍀 <b>nmcli c的con-name</b></p><p>同时对应ifcfg的文件名以及内容中的NAME=，该参数表示连接（connection）的名字，无需和网卡名相同，可以为一个设备（device）创建多个连接，但同一时刻只能有一个连接生效。当有多个连接时候，<code>nmcli c delete</code>删除当前连接，就会自动选择同一个设备的其他连接来顶替生效。可以通过<code>nmcli c up</code>来将指定连接切换生效。</p><blockquote> 注意：通过nmcli c modify修改con-name，只会对应修改ifcfg文件中的NAME，而不会更改ifcfg文件名。</blockquote><p>🍀 <b>nmcli c的ipv4.method</b></p><p>对应ifcfg文件内容的BOOTPROTO，ipv4.method默认为auto，对应为BOOTPROTO=dhcp，这种时候如果指定ip，就可能导致网卡同时有dhcp分配的ip和静态ip。设置为manual表示BOOTPROTO=none，即只有静态ip。</p><p><b>例子：创建一个连接（connection）</b></p><div class=\"highlight\"><pre><code class=\"language-text\">nmcli c add type ethernet con-name ethX-test ifname ethX ipv4.addresses &#39;192.168.1.100/24,192.168.1.101/32&#39; ipv4.routes &#39;10.0.0.0/8 192.168.1.10,192.168.0.0/16 192.168.1.11&#39; ipv4.gateway 192.168.1.254 ipv4.dns &#39;8.8.8.8,4.4.4.4&#39; ipv4.method manual</code></pre></div><p>▪ type ethernet：创建连接时候必须指定类型，类型有很多，可以通过<code>nmcli c add type -h</code>看到，这里指定为ethernet。</p><p>▪ con-name ethX ifname ethX：第一个ethX表示连接（connection）的名字，这个名字可以任意定义，无需和网卡名相同；第二个ethX表示网卡名，这个ethX必须是在<code>nmcli d</code>里能看到的。</p><p>▪ ipv4.addresses &#39;192.168.1.100/24,192.168.1.101/32&#39;：配置2个ip地址，分别为192.168.1.100/24和192.168.1.101/32</p><p>▪ ipv4.gateway 192.168.1.254：网关为192.168.1.254</p><p>▪ ipv4.dns &#39;8.8.8.8,4.4.4.4&#39;：dns为8.8.8.8和4.4.4.4</p><p>▪ ipv4.method manual：配置静态IP</p><p>对应的ifcfg和dns就是</p><div class=\"highlight\"><pre><code class=\"language-text\"># /etc/sysconfig/network-scripts/ifcfg-ethX-test\nTYPE=Ethernet\nPROXY_METHOD=none\nBROWSER_ONLY=no\nBOOTPROTO=none\nIPADDR=192.168.1.100\nPREFIX=24\nIPADDR1=192.168.1.101\nPREFIX1=32\nGATEWAY=192.168.1.254\nDNS1=8.8.8.8\nDNS2=4.4.4.4\nDEFROUTE=yes\nIPV4_FAILURE_FATAL=no\nIPV6INIT=yes\nIPV6_AUTOCONF=yes\nIPV6_DEFROUTE=yes\nIPV6_FAILURE_FATAL=no\nIPV6_ADDR_GEN_MODE=stable-privacy\nNAME=ethX-test\nUUID=9a10ad89-437c-4caa-949c-a394a6d28c8d\nDEVICE=ethX\nONBOOT=yes\n\n# /etc/resolv.conf\nnameserver 8.8.8.8\nnameserver 4.4.4.4</code></pre></div><p>此时，通过<code>nmcli c</code>应该可以看到增加了一条连接</p><blockquote> 注意：如果这是为ethX创建的第一个连接，则自动生效；如果此时已有连接存在，则该连接不会自动生效，可以执行<code>nmcli c up ethX-test</code>来切换生效</blockquote><h2><b>nmcli device重点</b></h2><p>🍀 <b>nmcli d connect ethX</b></p><p>由NM对指定网卡进行管理，同时刷新该网卡对应的活跃connection（如果之前有修改过connection配置）；如果有connection但是都处于非活跃状态，则自动选择一个connection并将其活跃；如果没有connection，则自动生成一个并将其活跃。</p><p>🍀 <b>nmcli d disconnect ethX</b></p><p>让NM暂时不管理指定网卡，此操作不会变更实际网卡的link状态，只会使对应的connection变成非活跃。若重启系统则又会自动connect。另外，如果手工将该网卡的connection全部删掉，该网卡状态也会自动变为disconnected。</p><p>🍀 <b>nmcli d reapply ethX</b></p><p>专门用于刷新connection，前提是网卡的device处于connected状态，否则会报错。</p><p>🍀 <b>nmcli d set ethX autoconnect yes|no managed yes|no</b></p><p>可以设置是否自动连接和是否自动管理，但经测试只能用于当前开机状态， 如果这2个参数都设置为no，然后重启系统，又会自动恢复成connected和managed yes的状态。所以该命令用途不大。注意事项：如果managed设置为no，那么<code>nmcli c reload</code>会读取配置文件，但是不会立即生效，接着如果执行nmcli c up ethX，就会立即生效，同时managed自动变为yes。</p><blockquote> 重启系统自动恢复成connected和managed yes的状态，这种逻辑并不实用也不够合理，笔者已将此问题提交给redhat，据回复，这么设计是因为目前没有一个有效的手段来证明“我是我”，比如当网卡重新拔插到其他插槽时候，网卡名有很大可能性会发生变化，因此无法确定关机前设置的是对应开机后的哪个网卡，目前暂无办法解决，笔者将持续跟进。</blockquote><h2><b>3种网络配置方法</b></h2><p>在讲3种配置方法前，需要先明白ifcfg和NM connection的关联：虽然network.service被废弃了，但是redhat为了兼容传统的ifcfg，通过NM进行网络配置时候，会自动将connection同步到ifcfg配置文件中。也可以通过<code>nmcli c reload</code>或者<code>nmcli c load /etc/sysconfig/network-scripts/ifcfg-ethX</code>的方式来让NM读取ifcfg配置文件到connection中。因此ifcfg和connection是一对一的关系，另外上面有提到，connection和device是多对一的关系。</p><p><b>在rhel8上，有3种方法进行网络配置</b></p><p>▷ 1. 手工配置ifcfg，通过NM来生效</p><p>▷ 2. 通过NM自带工具配ip，比如nmcli</p><p>▷ 3. 手工配置ifcfg，通过传统network.service来生效</p><p><b>建议：</b></p><p>推荐使用上述第1种网络配置方法（手工配置ifcfg，通过NM生效），因为这样既兼容了传统的ifcfg配置，又能熟悉nmcli。举例：</p><div class=\"highlight\"><pre><code class=\"language-text\">cat &gt; /etc/sysconfig/network-scripts/ifcfg-eth0 &lt;&lt;EOF\nNAME=eth0\nDEVICE=eth0\nONBOOT=yes\nBOOTPROTO=none\nTYPE=Ethernet\nIPADDR=192.168.1.10\nNETMASK=255.255.255.0\nGATEWAY=192.168.1.1\nEOF\n\nnmcli c reload\n# nmcli c up eth0 # 如果之前没有eth0的connection，则上一步reload后就已经自动生效了</code></pre></div><p>这么做有2个好处：</p><p>▷ 按官方建议使用NM而不是network.service</p><p>▷ 当还不太熟悉nmcli命令时候，这样最稳妥</p><h2><b>Tips</b></h2><p>🍀 <b>1.</b> nmcli命令支持tab补全，但是需要<code>yum install bash-completion</code></p><p>🍀 <b>2.</b> 如果希望NM不要纳管网卡，只有一个办法最彻底最靠谱，就是自己写ifcfg，内容加上<code>NM_CONTROLLED=no</code>，这样该device的状态就会始终保持unmanaged。nmcli c up、nmcli c reload、nmcil c load都不会对其起任何作用。</p><p>🍀 <b>3.</b> NM只能对link状态为up的网卡进行操作，如果手动<code>ip link set ethX down</code>，那么NM就无法对该网卡做任何操作（即使nmcli d connect也没有用）。</p><p>🍀 <b>4.</b> 可以通过<code>yum install network-scripts</code>来安装传统的network.service，不过redhat说了，在下一个rhel的大版本里将彻底废除，因此不建议使用network.service。</p><p>🍀 <b>5.</b> 手工创建新的ifcfg或者在ifcfg里修改ip等配置，NM不会自动读取，需要手工执行<code>nmcli c reload</code>或者<code>nmcli c load /etc/sysconfig/network-scripts/ifcfg-ethX</code>。这一点可能和其他系统的NM行为不太一样，但这种做法实则更适合服务器。</p><p>🍀 <b>6.</b> 不手工配置ifcfg，使用默认的dhcp情况下，网卡的增减是不会自动生成ifcfg，此时nmcli c看到的con-name将类似&#39;System ethX&#39;或者&#39;Wired connection 1&#39;。</p><p>🍀 <b>7.</b> NetworkManager支持3种获取dhcp的方式：dhclient、dhcpcd、internal，当/etc/NetworkManager/NetworkManager.conf配置文件中的[main]部分没配置<code>dhcp=</code>时候，默认使用internal（rhel7/centos7默认是dhclient）。internal是NM内部实现的dhcp客户端。</p><p>🍀 <b>8.</b> 关于手动指定网关ip的方法，经过实测，/etc/sysconfig/network中的GATEWAY仅在3种情况下有效：<code>NM_CONTROLLED=no</code>或<code>ipv4.method manual</code>或<code>从ipv4.method manual第一次转到ipv4.method auto时候</code>。建议：当NM_CONTROLLED=no时，将网关写在/etc/sysconfig/network（GATEWAY）；当使用NM时候，使用nmcli c命令配置网关（比如<code>nmcli c modify ethX ipv4.gateway 192.168.1.1</code>）。</p><p>🍀 <b>9.</b> NM默认会从dhcp里获取dns信息，并修改/etc/resolv.conf，如果不想让NM管理/etc/resolv.conf，则只需在/etc/NetworkManager/NetworkManager.conf里的[main]里增加<code>dns=none</code>即可。</p><p>🍀 <b>10.</b> 如果想让NM不要自动管理新网卡（比如不要给新网卡获取ip地址），则只需在/etc/NetworkManager/NetworkManager.conf里的[main]里增加<code>no-auto-default=*</code>即可，改完后通过<code>systemctl restart NetworkManager</code>或者重启系统来生效。除了手工在NetworkManager.conf里加配置，也可以<code>yum install NetworkManager-config-server</code>，这会生成/usr/lib/NetworkManager/conf.d/00-server.conf，内容为如下截图。建议使用前者方案，因为后者的ingore-carrier是不被推荐的参数。</p><p>🍀 <b>11.</b> 更多NetworkManager参数详见man NetworkManager.conf</p><p>🍀 <b>12.</b> nmtui示意图:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cee61eb6e0243a538a71a2c3043c4102_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"792\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb\" width=\"792\" data-original=\"https://pic3.zhimg.com/v2-cee61eb6e0243a538a71a2c3043c4102_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;792&#39; height=&#39;517&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"792\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"792\" data-original=\"https://pic3.zhimg.com/v2-cee61eb6e0243a538a71a2c3043c4102_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cee61eb6e0243a538a71a2c3043c4102_b.jpg\"/></figure><p>🍀 <b>13.</b> cockpit示意图:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e337d1d7b2f231ded5c53e5d400b48eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1276\" data-rawheight=\"813\" class=\"origin_image zh-lightbox-thumb\" width=\"1276\" data-original=\"https://pic4.zhimg.com/v2-e337d1d7b2f231ded5c53e5d400b48eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1276&#39; height=&#39;813&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1276\" data-rawheight=\"813\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1276\" data-original=\"https://pic4.zhimg.com/v2-e337d1d7b2f231ded5c53e5d400b48eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e337d1d7b2f231ded5c53e5d400b48eb_b.jpg\"/></figure><blockquote> 在rhel8.0 beta时候，必须要先将浏览器语言设置为英语，才可以使用，如果为中文，在登陆后是空白页面。笔者已将该<a href=\"https://link.zhihu.com/?target=https%3A//bugzilla.redhat.com/show_bug.cgi%3Fid%3D1653544\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bug</a>提交给redhat，据回复会在RHEL8.0正式版修复，笔者将持续跟进。</blockquote>", 
            "topic": [
                {
                    "tag": "RHEL（Red Hat Enterprise Linux）", 
                    "tagLink": "https://api.zhihu.com/topics/19581199"
                }, 
                {
                    "tag": "CentOS", 
                    "tagLink": "https://api.zhihu.com/topics/19577255"
                }, 
                {
                    "tag": "network", 
                    "tagLink": "https://api.zhihu.com/topics/20182839"
                }
            ], 
            "comments": [
                {
                    "userName": "smark-share", 
                    "userLink": "https://www.zhihu.com/people/3c9becc6a973c2c163ac86d2b883d936", 
                    "content": "rhel8中文输入法如何配置", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56892259", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "负载均衡获得真实源IP的6种方法", 
            "content": "<p></p><blockquote>除了X-FORWARD-FOR，负载均衡中获得真实源IP的方法还有很多种。 本文抛砖引玉，主要介绍获得真实源IP的多种方法，而不是具体配置。 负载均衡获得真实IP的方法有很多种，将形成专题文章。 本文为第一篇，主要做介绍和优劣对比。</blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2><b>获得真实IP的6种方法</b></h2><p>当数据包从负载均衡器往后端转发时候，真实源IP可在L3、L4、L7实现，并且分别有2种方法可以获得真实IP，因此共有6种方法:</p><p><b>保持L3层源IP不变，根据连接次数可以分为</b> - 一次连接模式，如lvs - 二次连接模式，如haproxy的透明模式</p><p><b>在L4层数据里，添加源IP信息，有2种模式</b> - 在4层的option字段里增加源IP信息，比如tcp option、udp option - 在4层末尾和7层开头之间，增加proxy protocol信息</p><p><b>在L7层数据里，增加源IP信息，有2种模式</b> - 协议自带，例如HTTP的X-FORWARD-FOR - 业务程序自行实现</p><h2><b>一次连接与二次连接</b></h2><p>一次连接：负载均衡器对数据包仅做转发，而不对后端重新发起三次握手</p><p>二次连接：和一次连接相对应，在tcp转发时候，对后端重新进行了三次握手。上面所讲的L4和L7方法的负载均衡，都是二次连接</p><p>可以通过对比源端口是否有改变来简单判断是一次连接还是二次连接，端口没改变，可以理解为一次连接，有改变就是二次连接</p><h2><b>方法1: L3的一次连接模式</b></h2><p>介绍：是指在网络层不对源IP做修改，直接将数据包转发给后端，当后端接收到数据的时候，源IP就是真实IP。</p><p>实现：LVS-DR、LVS-NAT、LVS-TUNNEL模式。其中LVS-TUNNEL比较特别，是在原有数据包的开头封装了IP头，当后端收到数据的时候，将封装的IP头进行解封装，获得的就是原有数据包。</p><p>优点：逻辑简单，当负载均衡器故障切换的时候，从客户端到后端的tcp连接不会中断</p><p>缺点：对网络架构有要求，比如DR模式，要求后端配VIP，并且回包要能直接回到客户机；NAT模式，要求回包经过负载均衡器；TUNNEL模式要求后端支持IPIP隧道</p><h2><b>方法2: L3的二次连接模式</b></h2><p>介绍：是指负载均衡器和后端重新进行三次握手，但保持数据包的源IP为真实IP。</p><p>实现：haproxy（开启tproxy透明代理模式）+ iptables（fwmark打标记）+ 策略路由这3者组合才能实现</p><p>优点：可以实现L7层（如HTTP/HTTPS）的负载均衡，而一次连接主要实现L4层的负载均衡</p><p>缺点：配置最复杂，同时要求回包经过负载均衡器</p><h2><b>方法3: L4的toa模式</b></h2><p>介绍：在4层的option字段里增加源IP信息，比如在tcp option里增加源IP信息（称为toa）、udp option里增加源IP信息（称为uoa）</p><p>实现：负载均衡器配置lvs-fullnat（只支持toa），iqiyi/dpvs（支持toa和uoa）；后端要加载toa、uoa模块，这个模块的作用是替换了后端应用程序获取IP的系统接口的钩子</p><p>优点：对网络架构要求低</p><p>缺点：lvs-fullnat需要编译内核，且只支持rhel/centos 6的内核，另外多年未更新；iqiyi/dpvs功能强大，但需要dpdk的支持；后端都需要加载toa/uoa模块，且只支持linux系统。</p><h2><b>方法4: L4的proxy protocol模式</b></h2><p>介绍：在L7层开头增加proxy protocol数据（该协议是haproxy发明），目前有v1（明文）和v2（二进制）版本</p><p>实现：负载均衡器和后端同时开启proxy protocol，haproxy和nginx均支持，不过haproxy的配置颗粒度更小，另外nginx转发数据时候只支持v1</p><p>优点：对网络架构要求低，只要程序支持即可，因此理论上没有操作系统限制</p><p>缺点：目前支持proxy protocol的程序较少，且两端只能都开启或者都不开启该协议，不能一端开一端不开</p><h2><b>方法5: L7协议自带，例如HTTP的X-FORWARD-FOR</b></h2><p>介绍：最常见的方法，协议自带源IP信息，或者可定制插入</p><p>实现：例如HTTP协议有X-FORWARD-FOR，也可以自己将源IP插入到HTTP头部信息里</p><p>优点：对网络架构要求低，配置简便</p><p>缺点：容易被伪造</p><h2><b>方法6: L7层业务程序自行实现</b></h2><p>介绍：最好的方法，就是业务方自行实现</p><p>实现：业务自行实现，例如在client端插入源IP信息，带到server端</p><p>优点：对网络架构无要求，只要网络可通即可，只要安全做好，不容易被伪造</p><p>缺点：业务方要有一定开发能力</p><h2><b>总结</b></h2><p>如果能做到无状态，不需要真实源IP，是最好的。因为这样对底层架构没有要求，底层架构就可以做的更高级更弹性。</p><p>如果一定要获得真实源IP，推荐方案的顺序就是倒推，从L7到L3，即首选方法6，如果不行再选用方法5，以此类推到方法1</p>", 
            "topic": [
                {
                    "tag": "负载均衡", 
                    "tagLink": "https://api.zhihu.com/topics/19596611"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56891725", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 2, 
            "title": "基于mkdocs-material搭建个人静态博客", 
            "content": "<p></p><blockquote> 基于mkdocs-material搭建个人纯静态博客，没有php，没有mysql 如果你只是想安安静静的放一些技术文章，发布到个人站点或github-pages，mkdocs-material很适合你</blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><ul><li>本文仅是缩略，笔者已将详细内容发布到github上</li><li>可点击本文最后的&#34;阅读更多&#34;进行访问，或者在github上搜&#34;cyent markdown&#34;也可以看到</li></ul><h2><b>目录</b></h2><ul><li>本文概述</li><li>mkdocs-material介绍</li><li>安装</li><li>初始化项目</li><li>修改主题</li><li>运行</li><li>发布到GitHub pages</li><li>发布到个人HTTP Server</li><li>mkdocs.yml注意事项</li><li>添加页面</li><li>添加扩展</li><li>markdown语法</li><li>其他功能</li><li>最佳实践</li></ul><hr/><h2><b>本文概述</b></h2><p>mkdocs-material入门，包括安装、运行、发布至github-pages及个人站点</p><h2><b>mkdocs-material介绍</b></h2><p>符合google material ui规范的静态文档网站生成器，使用markdown进行文档书写</p><p><b>mkdocs</b></p><ul><li>python编写的markdown解释器、编译器，带有本地cli工具</li><li>自带基于Tornado的小型http服务，用于本地调试</li><li>内置一键式发布至GitHub Pages</li><li>内置mkdocs风格、readthedocs风格的主题，并支持自定义主题</li><li>支持调用python模块实现语法及渲染的扩展</li></ul><p><b>mkdocs-material</b></p><ul><li>python模块，符合google material ui规范的mkdocs自定义主题</li><li>针对特定语法、功能做了渲染优化</li><li>根据客户端浏览器页面尺寸自动缩放，对PC、移动设备都友好</li><li>丰富的页面配色，多达19种主体配色和16种悬停链接文字配色</li><li>支持中文搜索</li><li>支持统计功能，如百度统计，谷歌统计</li></ul><h2><b>安装</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">pip install mkdocs mkdocs-material</code></pre></div><p>若下载慢，可更换安装源为豆瓣</p><div class=\"highlight\"><pre><code class=\"language-text\">pip install --trusted-host pypi.douban.com -i http://pypi.douban.com/simple/ mkdocs mkdocs-material</code></pre></div><h2><b>初始化项目</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">mkdocs new my-project</code></pre></div><p>会生成my-project目录，进入该目录里，可以看到默认放置了一些文件，包括mkdocs.yml，这是主配置文件</p><h2><b>修改主题</b></h2><p>mkdocs.yml里添加:</p><div class=\"highlight\"><pre><code class=\"language-text\">theme:\n  name: material</code></pre></div><h2><b>运行</b></h2><div class=\"highlight\"><pre><code class=\"language-text\"># 在my-project目录里执行\nmkdocs serve</code></pre></div><p>通过浏览器访问本地ip的8000端口（比如<a href=\"https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8000/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">127.0.0.1:8000/</span><span class=\"invisible\"></span></a>） 查看效果，如图所示</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-17a42103f504fddde32964377f4a0f25_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"646\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-17a42103f504fddde32964377f4a0f25_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;646&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"646\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-17a42103f504fddde32964377f4a0f25_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-17a42103f504fddde32964377f4a0f25_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>发布到GitHub pages</b></h2><p>通过<code>mkdocs gh-deploy</code>自动编译出html并发布至GitHub pages，步骤如下</p><p><b>初始化repo</b></p><p>1.在github上创建一个repo，名字叫my-project（可以是其他名，这里先假设叫my-project），创建repo时候选择初始化带有README.md</p><p>2.将repo同步到本地，使用git clone</p><p><b>导入项目</b></p><p>1.将mkdocs根目录（即my-project目录）下的所有东西移到刚刚git clone下来的git目录下</p><p>2.然后可以将最早创建的mkdocs根目录（即my-project目录）删除了</p><p><b>发布</b></p><p>在本地git目录下执行</p><div class=\"highlight\"><pre><code class=\"language-text\">mkdocs gh-deploy</code></pre></div><h2><b>发布到个人HTTP Server</b></h2><p>通过<code>mkdocs build</code>编译出html并手动同步至http server的根目录</p><p><b>生成站点文件</b></p><p>在git目录下执行命令</p><div class=\"highlight\"><pre><code class=\"language-text\">mkdocs build</code></pre></div><p>命令执行完毕后可以看到site目录</p><p><b>发布至http server</b></p><p>将site目录里的所有东西拷贝到http server的根目录下</p><h2><b>mkdocs.yml注意事项</b></h2><p>由于是yaml格式，因此首先要符合yaml的语法要求</p><p>docs下需要一个index.md，作为站点首页</p><p>文档层次结构虽然可以很多层，但最佳实践是控制在2层内，最多不要超过3层，否则展示会不够友好</p><h2><b>添加页面</b></h2><p>在my-project/docs/里放置.md文件，可以自行组织目录结构</p><p>然后在mkdocs.yml里添加，比如这样:</p><div class=\"highlight\"><pre><code class=\"language-text\">nav:\n  - 介绍: index.md\n  - 安装:\n      - 本地环境搭建: install/local.md\n      - 发布至GitHub Pages: install/github-pages.md\n      - 发布至自己的HTTP Server: install/http-server.md\n  - 语法:\n      - 语法总览: syntax/main.md\n      - 标题: syntax/headline.md\n      - 段落: syntax/paragraph.md</code></pre></div><ul><li>上面的index.md就是放置在my-project/docs/index.md</li><li>上面的local.md就是放置在my-project/docs/install/local.md</li></ul><h2><b>添加扩展</b></h2><p>只有添加了扩展，才能完美使用mkdocs-material官方支持的所有markdown语法</p><p>mkdocs.yml里添加:</p><div class=\"highlight\"><pre><code class=\"language-text\">markdown_extensions:\n  - admonition\n  - codehilite:\n      guess_lang: false\n      linenums: false\n  - toc:\n      permalink: true\n  - footnotes\n  - meta\n  - def_list\n  - pymdownx.arithmatex\n  - pymdownx.betterem:\n      smart_enable: all\n  - pymdownx.caret\n  - pymdownx.critic\n  - pymdownx.details\n  - pymdownx.emoji:\n      emoji_generator: !!python/name:pymdownx.emoji.to_png\n  - pymdownx.inlinehilite\n  - pymdownx.magiclink\n  - pymdownx.mark\n  - pymdownx.smartsymbols\n  - pymdownx.superfences\n  - pymdownx.tasklist\n  - pymdownx.tilde</code></pre></div><h2><b>markdown语法</b></h2><p>mkdocs-material支持几十种markdown语法，有许多很酷炫的功能与效果，由于篇幅有限，无法在这一一展示，因此这里仅列举下所支持的主要语法</p><p>1.标题</p><p>2.段落</p><p>3.引用</p><p>4.表格</p><p>5.代码</p><ul><li>行内</li><li>区块</li><li>高亮</li></ul><p>6.字体样式</p><ul><li>斜体,粗体,粗斜体</li><li>上标,下标</li><li>下划线</li><li>横线</li><li>下划线+横线</li></ul><p>7.列表</p><ul><li>无序列表</li><li>有序列表</li><li>任务列表</li></ul><p>8.分割线</p><p>9.链接</p><ul><li>普通链接</li><li>自动链接</li><li>锚点提示</li></ul><p>10.图片</p><ul><li>行内式</li><li>参考式</li></ul><p>11.转义</p><p>12.高亮</p><ul><li>代码高亮</li><li>背景高亮</li></ul><p>13.注解</p><ul><li>介绍</li><li>完整格式</li><li>空标题</li><li>无标题</li><li>无类型</li><li>折叠</li><li>11种颜色样式</li><li>嵌套</li></ul><p>14.脚注</p><p>15.元信息</p><p>16.数学公式</p><ul><li>介绍</li><li>导入js</li><li>用法</li></ul><p>17.emoji</p><ul><li>介绍</li><li>工作原理</li><li>最佳实践</li></ul><p>18.特殊符号</p><p>19.嵌套</p><ul><li>介绍</li><li>注解-注解</li><li>列表-列表</li><li>引用-引用</li><li>注解-代码块</li><li>列表-代码块</li><li>引用-代码块</li><li>黄色区块-代码</li><li>绿色区块-代码</li><li>红色区块-代码</li><li>绿接红区块-代码</li><li>注解-列表-引用</li><li>列表-列表-引用</li><li>引用-引用-代码</li></ul><h2><b>其他功能</b></h2><p>mkdocs-material本身还支持如下功能：</p><ul><li>添加js，可用于站点统计（如百度统计，谷歌统计）</li><li>页面以及跳转文字的配色</li><li>中文搜索</li></ul><h2><b>最佳实践</b></h2><p>如果希望自己所写的markdown可以兼容各个markdown编辑器，那么只需了解markdown的传统语法即可</p><p>如果想让自己所写的markdown发布到web服务器，例如GitHub Pages、自己搭建的HTTP Server，那么可以考虑使用本文所介绍的语法，以实现丰富多样的渲染效果。</p><p>笔者建议：尽量使用传统语法，只在必要时候才使用本文介绍的语法。因为排版简洁、条理清晰才能带来最舒服的阅读感受。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//cyent.github.io/markdown-with-mkdocs-material/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">阅读更多</a></p>", 
            "topic": [
                {
                    "tag": "Markdown", 
                    "tagLink": "https://api.zhihu.com/topics/19590742"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56890755", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "最详细的CentOS 6与7对比（三）：性能测试对比", 
            "content": "<p>本主题将从3个角度进行对比</p><ol><li><a href=\"https://zhuanlan.zhihu.com/p/56889964\" class=\"internal\">常见设置（CentOS 6 vs CentOS 7）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890303\" class=\"internal\">服务管理（Sysvinit vs Upstart vs Systemd）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890755\" class=\"internal\">性能测试（cpu/mem/io/oltp）</a></li></ol><p>本文为第三部分：性能测试的对比</p><hr/><h2>1. CPU测试</h2><p>工具: 通过sysbench对cpu进行压力测试</p><p>参数设置</p><ul><li>素数: 10000</li><li>测试时间: 900秒</li><li>线程数: 1、6、12、18、24、30、36、42</li></ul><p>分别测试使用睿频和不实用睿频</p><p><b>&gt; 图1: cpu测试 - 每秒events</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dd4cbd158e095b9fac69d1a5513eb69b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-dd4cbd158e095b9fac69d1a5513eb69b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;752&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-dd4cbd158e095b9fac69d1a5513eb69b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dd4cbd158e095b9fac69d1a5513eb69b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越高越好</p><p>此图结论：</p><ul><li>cpu性能基本一致</li><li>CentOS 7固定频率（不使用睿频），并没有提升性能，因此没有关闭睿频的必要</li></ul><p><b>&gt; 图2: cpu测试 - event数量标准差</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b4c9f3b4e405fdb9c59c73c2b1c4e033_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"829\" class=\"origin_image zh-lightbox-thumb\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-b4c9f3b4e405fdb9c59c73c2b1c4e033_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;752&#39; height=&#39;829&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"829\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-b4c9f3b4e405fdb9c59c73c2b1c4e033_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b4c9f3b4e405fdb9c59c73c2b1c4e033_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越少越好</p><p>此图结论：</p><ul><li>通过标准差可以看出在稳定性方面，CentOS 7要稳定很多（包括不使用睿频）</li></ul><h2>2. 内存测试</h2><p>工具: 通过sysbench对内存进行压力测试</p><p>参数设置</p><ul><li>读写方式: 随机</li><li>测试时间: 900秒</li><li>分别测试读和写</li><li>块大小: 4K、16K、2M</li><li>线程数: 1、12、24、36、48</li></ul><p><b>&gt; 图1: 内存测试 - 速率</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-20f8fb716fad9cd1f90e23bb942303dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1179\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"1179\" data-original=\"https://pic1.zhimg.com/v2-20f8fb716fad9cd1f90e23bb942303dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1179&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1179\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1179\" data-original=\"https://pic1.zhimg.com/v2-20f8fb716fad9cd1f90e23bb942303dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-20f8fb716fad9cd1f90e23bb942303dc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越高越好</p><p>此图结论：</p><ul><li>CentOS 6和CentOS 7性能一致</li></ul><p><b>&gt; 图2: 内存测试 - event数量标准差</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-503ae15d424176d79aa6f5ae71bdeb20_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"1810\" class=\"origin_image zh-lightbox-thumb\" width=\"1177\" data-original=\"https://pic1.zhimg.com/v2-503ae15d424176d79aa6f5ae71bdeb20_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1177&#39; height=&#39;1810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1177\" data-rawheight=\"1810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1177\" data-original=\"https://pic1.zhimg.com/v2-503ae15d424176d79aa6f5ae71bdeb20_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-503ae15d424176d79aa6f5ae71bdeb20_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越少越好</p><p>此图结论：</p><ul><li>通过标准差可以看出在稳定性方面，CentOS 7要稳定很多</li></ul><h2>3. IO测试</h2><p>工具: 通过fio对io进行压力测试</p><p>参数设置</p><ul><li>ioengine: libaio</li><li>iodepth: 16</li><li>测试时间: 900秒</li><li>文件大小: 100G</li><li>运行方式: 线程</li><li>缓存方式: 无缓存（non-buffered I/O）</li><li>读写方式: 随机读写</li><li>块大小: 分别测试4K和16K</li><li>线程数: 1、12、24、36、48</li></ul><p><b>&gt; 图1: io测试 - iops</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0a37faa04a8ccfcb2f81ede64170c95e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-0a37faa04a8ccfcb2f81ede64170c95e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;515&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-0a37faa04a8ccfcb2f81ede64170c95e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0a37faa04a8ccfcb2f81ede64170c95e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越高越好</p><p>此图结论：</p><ul><li>CentOS 6（默认ext4）不如CentOS 7（默认xfs）</li><li>CentOS 6（默认ext4）不如CentOS 6（xfs）</li></ul><p><b>&gt; 图2: io测试 - 读写平均延时</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f66ef87cab0528125b69a246654fa66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-9f66ef87cab0528125b69a246654fa66_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;517&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-9f66ef87cab0528125b69a246654fa66_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f66ef87cab0528125b69a246654fa66_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越少越好</p><p>此图结论：</p><ul><li>CentOS 7的写延时和CentOS 6（默认ext4）接近</li><li>CentOS 7的读延时比CentOS 6（默认ext4）好很多</li></ul><h2>4. OLTP测试</h2><p>工具: 通过tpcc-mysql对整机性能进行测试</p><p>参数设置</p><ul><li>文件系统: 均为xfs</li><li>mysql版本: mysql-8.0.12</li><li>tpcc_load:</li><ul><li>warehouse: 100</li><li>sql: create_table.sql、add_fkey_idx.sql</li><li>运行时长: 没有限制，跑完将近1小时</li></ul><li>tpcc_start:</li><ul><li>warehouse: 100</li><li>warmup: 300秒</li><li>运行时长: 1800秒</li><li>线程数: 16、32、64、128、256、512、1024</li></ul></ul><p><b>&gt; 图: oltp测试 - tpmc</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3d19cdb667a9fdd1af4a2c07ce513c47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-3d19cdb667a9fdd1af4a2c07ce513c47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;752&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"752\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"752\" data-original=\"https://pic4.zhimg.com/v2-3d19cdb667a9fdd1af4a2c07ce513c47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3d19cdb667a9fdd1af4a2c07ce513c47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如何看图：越高越好</p><p>此图结论：</p><ul><li>CentOS 7比CentOS 6（默认ext4）高</li></ul><h2>5. 总结</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1e560bdc193c1e8a96edf7d8ec05d05c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1430\" data-rawheight=\"818\" class=\"origin_image zh-lightbox-thumb\" width=\"1430\" data-original=\"https://pic1.zhimg.com/v2-1e560bdc193c1e8a96edf7d8ec05d05c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1430&#39; height=&#39;818&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1430\" data-rawheight=\"818\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1430\" data-original=\"https://pic1.zhimg.com/v2-1e560bdc193c1e8a96edf7d8ec05d05c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1e560bdc193c1e8a96edf7d8ec05d05c_b.jpg\"/></figure><p>如图所示，本次一共做了7项，其中有2项是CentOS 6与7基本一致，另外5项都是CentOS 7明显胜出，因此可以得出结论：CentOS 7的性能比CentOS 6强！</p>", 
            "topic": [
                {
                    "tag": "CentOS", 
                    "tagLink": "https://api.zhihu.com/topics/19577255"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56890303", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 1, 
            "title": "最详细的CentOS 6与7对比（二）：服务管理对比", 
            "content": "<p>本主题将从3个角度进行对比</p><ol><li><a href=\"https://zhuanlan.zhihu.com/p/56889964\" class=\"internal\">常见设置（CentOS 6 vs CentOS 7）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890303\" class=\"internal\">服务管理（Sysvinit vs Upstart vs Systemd）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890755\" class=\"internal\">性能测试（cpu/mem/io/oltp）</a></li></ol><p>本文为第二部分：服务管理的对比</p><hr/><h2>1. sysvinit、upstart、systemd简介</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-15f1bdd3ac7efa67cbe676c48cffbb68_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2212\" data-rawheight=\"874\" class=\"origin_image zh-lightbox-thumb\" width=\"2212\" data-original=\"https://pic1.zhimg.com/v2-15f1bdd3ac7efa67cbe676c48cffbb68_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2212&#39; height=&#39;874&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2212\" data-rawheight=\"874\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2212\" data-original=\"https://pic1.zhimg.com/v2-15f1bdd3ac7efa67cbe676c48cffbb68_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-15f1bdd3ac7efa67cbe676c48cffbb68_b.jpg\"/></figure><h2>2. sysvinit、upstart、systemd常用命令</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e4e526a6a419a8e666c77530b6b4f01e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"858\" class=\"origin_image zh-lightbox-thumb\" width=\"2210\" data-original=\"https://pic3.zhimg.com/v2-e4e526a6a419a8e666c77530b6b4f01e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2210&#39; height=&#39;858&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"858\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2210\" data-original=\"https://pic3.zhimg.com/v2-e4e526a6a419a8e666c77530b6b4f01e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e4e526a6a419a8e666c77530b6b4f01e_b.jpg\"/></figure><h2>3. runlevel运行级别</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cbec52f4ef369b40c0f7a74cdbe69b58_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"860\" class=\"origin_image zh-lightbox-thumb\" width=\"2210\" data-original=\"https://pic1.zhimg.com/v2-cbec52f4ef369b40c0f7a74cdbe69b58_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2210&#39; height=&#39;860&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"860\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2210\" data-original=\"https://pic1.zhimg.com/v2-cbec52f4ef369b40c0f7a74cdbe69b58_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cbec52f4ef369b40c0f7a74cdbe69b58_b.jpg\"/></figure><h2>4. 日志查询</h2><p>CentOS 6: 手工在/var/log/messages、/var/log/dmesg、/var/log/secure中grep，麻烦且效率低</p><p>CentOS 7: 统一使用journalctl，可以使用多个因素匹配，比如时间段、服务名、日志级别等等。另外，systemd日志默认经过压缩，是二进制文件，无法直接查看</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-199e6127684abd182dd51283650c8d5c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"868\" class=\"origin_image zh-lightbox-thumb\" width=\"2210\" data-original=\"https://pic1.zhimg.com/v2-199e6127684abd182dd51283650c8d5c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2210&#39; height=&#39;868&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2210\" data-rawheight=\"868\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2210\" data-original=\"https://pic1.zhimg.com/v2-199e6127684abd182dd51283650c8d5c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-199e6127684abd182dd51283650c8d5c_b.jpg\"/></figure><h2>5. 实现守护进程</h2><p>CentOS 6</p><ul><li>sysvinit需要自行实现</li><ul><li>nohup &amp;</li><li>screen</li><li>supervisor</li></ul><li>upstart和systemd类似，将程序运行在前台即可</li></ul><p>CentOS 7</p><ul><li>由systemd启动，将程序运行在前台即可</li></ul><h2>6. sysvinit、upstart、systemd例子</h2><p>sysvinit</p><div class=\"highlight\"><pre><code class=\"language-text\">cat &gt; /etc/init.d/mytest &lt;&lt;EOF\n. /etc/rc.d/init.d/functions\n\nstart() { … }\nstop() { … }\nrestart() { … }\nreload() { … }\nstatus() { … }\n\ncase &#34;$1&#34; in\n        start)\n                start\n                ;;\n        stop)\n                stop\n                ;;\n…\nesac\nexit $RETVAL\nEOF\n\nchmod +x /etc/init.d/mytest\nservice mytest start</code></pre></div><p>upstart</p><div class=\"highlight\"><pre><code class=\"language-text\">cat &gt; /etc/init/mytest.conf &lt;&lt;EOF\nstart on runlevel [3]\ndescription “mytest&#34;\nexec /root/mytest.sh\nEOF\n\ninitctl start mytest</code></pre></div><p>systemd</p><div class=\"highlight\"><pre><code class=\"language-text\">cat &gt; /usr/lib/systemd/system/mytest.service &lt;&lt;EOF\n[Unit]\nDescription=mytest\n\n[Service]\nType=simple\nExecStart=/root/mytest.sh\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\nsystemctl start mytest</code></pre></div><h2>7. PID管理</h2><ul><li>sysvinit: 需要生成PID文件，用于后期关闭、重启等使用</li><li>upstart: 无需PID文件，upstart会记录主进程ID，子进程ID没有记录</li><li>systemd: 无需PID文件，所有进程ID由cgroup统一接管</li></ul><h2>8. 内置的资源限制</h2><p>CentOS 6: 除了ulimit，没有其他限制进程资源的简便方法 CentOS 7: 除了ulimit，还支持部分cgroup限制，可对进程做内存限制和cpu资源限制等</p><div class=\"highlight\"><pre><code class=\"language-text\">[Service]\nExecStart=...\nMemoryLimit=500M\nCPUShares=100</code></pre></div><p>另外，CentOS 7可以通过<code>systemd-cgtop</code>命令查看cgroup里的性能数据</p><h2>9. 服务异常自动重启</h2><p>upstart</p><div class=\"highlight\"><pre><code class=\"language-text\">start on runlevel [3]\n\ndescription &#34;mytest&#34;\n\nexec /root/mytest.sh\npost-stop exec sleep 5\nrespawn\nrespawn limit unlimited</code></pre></div><p>systemd</p><div class=\"highlight\"><pre><code class=\"language-text\">[Unit]\nDescription=mytest\n\n[Service]\nType=simple\nExecStart=/root/mytest.sh\nRestart=always\nRestartSec=5\nStartLimitInterval=0\n\n[Install]\nWantedBy=multi-user.target</code></pre></div><p>上面2种方式均表示，无限次自动重启，每次重启前等待5秒</p><h2>10. 写日志方式</h2><p>CentOS 6: 自行输出到文件中，或通过syslog记录（如logger命令）</p><p>CentOS 7: 只要程序由systemd启动，只需将输出日志到标准输出或标准错误</p><ul><li>建议centos7只将应用程序的一些元信息输出到标准输出或标准错误，比如启动成功、启动失败等等</li><li>不建议将业务日志输出到journal。因为journal中所有日志都存在一个文件中，会导致2个问题：</li><ul><li>如果没有做日志持久化，则默认存在内存中，会导致最多一半的内存被占用</li><li>存储量很大，会导致查询其他日志很耗时</li></ul><li>解决办法：输出到syslog，[Service]支持StandardOutput=syslog</li></ul><h2>11. 指定每条日志级别</h2><p>CentOS 6: 通过syslog将不同级别的日志输出到不同文件</p><p>CentOS 7: 只需在输出的每一行开头加&lt;日志级别&gt;，比如</p><div class=\"highlight\"><pre><code class=\"language-text\">echo &#39;&lt;0&gt;hello, emerg&#39;\necho &#39;&lt;1&gt;hello, alert&#39;\necho &#39;&lt;2&gt;hello, crit&#39;\necho &#39;&lt;3&gt;hello, err&#39;\necho &#39;&lt;4&gt;hello, warning&#39;\necho &#39;&lt;5&gt;hello, notice&#39;\necho &#39;&lt;6&gt;hello, info&#39;\necho &#39;&lt;7&gt;hello, debug&#39;</code></pre></div><h2>12. systemd日志永久保存</h2><p>systemd日志默认保存在内存中，因此当服务器重启后，就无法通过journalctl来查看之前的日志，解决方法:</p><div class=\"highlight\"><pre><code class=\"language-text\">mkdir -p /var/log/journal\nsystemctl restart systemd-journald</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "CentOS", 
                    "tagLink": "https://api.zhihu.com/topics/19577255"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56889964", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 3, 
            "title": "最详细的CentOS 6与7对比（一）：常见设置对比", 
            "content": "<p>本主题将从3个角度进行对比</p><ol><li><a href=\"https://zhuanlan.zhihu.com/p/56889964\" class=\"internal\">常见设置（CentOS 6 vs CentOS 7）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890303\" class=\"internal\">服务管理（Sysvinit vs Upstart vs Systemd）</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/56890755\" class=\"internal\">性能测试（cpu/mem/io/oltp）</a></li></ol><p>本文为第一部分：常见设置的对比</p><hr/><h2>1. 字符集</h2><p>CentOS 6</p><ul><li>方法: /etc/sysconfig/i18n</li></ul><p>CentOS 7</p><ul><li>方法1: localectl set-locale LANG=en_GB.utf8</li><li>方法2: /etc/locale.conf中的LANG=</li></ul><h2>2. 主机名</h2><p>CentOS 6</p><ul><li>在线生效: hostname</li><li>重启生效: /etc/sysconfig/network中的HOSTNAME=</li></ul><p>CentOS 7</p><ul><li>在线+重启生效: hostnamectl set-hostname</li></ul><h2>3. 时区</h2><p>CentOS 6</p><ul><li>方法: ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</li></ul><p>CentOS 7</p><ul><li>方法1: 同CentOS 6</li><li>方法2: timedatectl set-timezone Asia/Shanghai</li></ul><h2>4. 时间同步</h2><p>CentOS 6</p><ul><li>逐步: ntpd或ntpdate</li><li>直接: ntpdate -b（通常加到crontab）</li></ul><p>CentOS 7</p><ul><li>方法1: systemctl start chronyd</li><li>方法2: timedatectl set-ntp yes（同systemctl start chronyd）     &gt; 可以通过timedatectl | grep &#34;NTP synchronized&#34;判断当前时间是否已同步     &gt; 不建议用ntpd和ntpdate，redhat强烈推荐chrony，可用于网络不稳定的环境     &gt; chrony.conf关键参数makestep 1.0 -1     &gt; <a href=\"https://link.zhihu.com/?target=https%3A//access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-configuring_ntp_using_the_chrony_suite%23sect-differences_between_ntpd_and_chronyd\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ntpd和chronyd区别</a></li></ul><h2>5. 手动更改时间</h2><p>CentOS 6</p><ul><li>方法: date -s &#34;2018-07-08 11:11:11&#34;</li></ul><p>CentOS 7</p><ul><li>方法1: 同CentOS 6</li><li>方法2: timedatectl set-time &#34;2018-07-08 11:11:12&#34;（前提是timedatectl set-ntp false）</li></ul><h2>6. 单用户修改密码</h2><p>CentOS 6: <code>grub</code>界面键入<code>e</code>，在<code>kernel</code>行最后加<code>1</code>，键入<code>b</code>启动进入单用户模式，之后输入<code>passwd</code>修改密码</p><p>CentOS 7: <code>grub</code>界面键入<code>e</code>，在<code>linux16</code>行上将<code>ro</code>改为<code>rw</code>，并在当前行最后加<code>init=/bin/sh</code>，键入<code>ctrl-x</code>进入，之后输入<code>passwd</code>修改密码</p><ul><li>如果有开启selinux，则需要在修改密码后，重启前，执行<code>touch /.autorelabel</code></li><li>passwd执行后，最好执行sync，防止强制重启导致修改密码没有落地</li></ul><h2>7. grub添加参数</h2><p>CentOS 6:</p><ul><li>/boot/grub/grub.conf的kernel中加入需要添加的参数</li></ul><p>CentOS 7:</p><ul><li>步骤1：/etc/default/grub的GRUB_CMDLINE_LINUX中加入需要添加的参数</li><li>步骤2：grub2-mkconfig -o /boot/grub2/grub.cfg</li></ul><h2>8. 查看开机记录</h2><p>CentOS 6: last</p><p>CentOS 7: journalctl --list-boots或last</p><h2>9. 修改启动内核</h2><p><b>    查看当前启动内核</b></p><ul><ul><li>CentOS 6: cat /boot/grub/grub.conf中的default</li><li>CentOS 7: grub2-editenv list</li></ul></ul><p><b>查看有哪些内核</b></p><ul><ul><li>CentOS 6: cat /boot/grub/grub.conf | sed -n &#39;/^title/s/^title //p&#39;</li><li>CentOS 7: cat /boot/grub2/grub.cfg | grep &#39;^menuentry&#39; | awk -F&#34;&#39;&#34; &#39;{print $2}&#39;</li></ul></ul><p><b>    设置启动内核</b></p><ul><ul><li>CentOS 6:</li><ul><li>修改/boot/grub/grub.conf中的default </li></ul><li>CentOS 7:</li><ul><li>步骤1：确保/etc/default/grub中的<code>GRUB_DEFAULT</code>为saved</li><li>步骤2：grub2-set-default &#39;CentOS Linux (3.10.0-693.el7.x86_64) 7 (Core)&#39;</li></ul></ul></ul><h2>10. rc.local</h2><p>执行顺序</p><ul><li>CentOS 6: 串行的最后一个执行</li><li>CentOS 7: 和其他服务并行执行</li></ul><p>可执行权限</p><ul><li>CentOS 6: 默认有可执行权限</li><li>CentOS 7: 默认没有可执行权限（官方不推荐使用rc.local），需要自行增加（chmod +x /etc/rc.d/rc.local）</li></ul><p>CentOS 7的注意事项</p><ul><li>rc.local由rc-local.service执行，并行执行，仅能保证在network之后启动，因此建议rc.local里增加sleep 10来尽可能在最后执行</li><li>需要在rc.local的最后一行增加exit 0，否则可能导致已启动的进程被关闭（echo &#39;exit 0&#39; &gt;&gt; /etc/rc.d/rc.local）</li><li>建议尽量使用systemd来配置服务，不要使用rc.local</li></ul><h2>11. limit配置</h2><p>CentOS 6:</p><ul><li>全局设置: 没有全局设置的方法（/etc/security/limits.conf仅针对使用pam的进程，且有加载pam_limits.so的模块，因为limits.conf是pam_limits.so的配置文件）</li><li>服务设置: 只能在服务启动前设置ulimit，才能在启动后看到效果</li></ul><p>CentOS 7:</p><ul><li>全局设置: /etc/systemd/system.conf里DefaultLimitNOFILE=65535</li><li>服务设置: [Service]里增加LimitNOFILE=65535</li></ul><h2>12. yum仅使用ipv4</h2><p>CentOS 6: yum没有自带方法</p><p>CentOS 7: yum.conf里增加ip_resolve=4</p><h2>13. 彻底禁用ipv6</h2><p>CentOS 6和CentOS 7相同</p><ul><li>在grub上增加ipv6.disable=1</li></ul><p>查看是否彻底关闭</p><ul><li>sysctl -a | grep -i ipv6如果没有任何输出，则表示彻底关闭</li></ul><h2>14. 防火墙</h2><p>CentOS 6</p><ul><li>默认开启iptables服务，只不过默认没有条目</li></ul><p>CentOS 7</p><ul><li>默认安装并开启firewalld服务</li><li>默认不安装iptables服务（yum install iptables-services）</li></ul><h2>15. NetworkManager</h2><p>CentOS 6: 默认未安装</p><p>CentOS 7: 默认安装并启动</p><h2>16. 网卡名</h2><p>CentOS 6:</p><ul><li>系统安装完，默认是em1开始，这其实是在装机完成时在udev里做的绑定</li><li>把/etc/udev/rules.d/70-persistent-net.rules内容清空，则恢复成eth0开始编号</li></ul><p>CentOS 7:</p><ul><li>不再通过udev绑定网卡名，默认是em1开始，有的是eno、enp、ens等名字</li><li>如果想恢复eth0，则/etc/default/grub里增加net.ifnames=0 biosdevname=0</li><li>如果想让CentOS 6的网卡名不受udev影响，达到CentOS 7的效果，则删除3个文件即可</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">rm -f /etc/udev/rules.d/70-persistent-net.rules\nrm -f /lib/udev/write_net_rules\nrm -f /lib/udev/rules.d/75-persistent-net-generator.rules</code></pre></div><p>网卡名规则 - eno：主板板载网卡 - enp：独立网卡（PCI网卡） - ens：热插拔网卡（usb之类） - 参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/chia/p/7379775.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/chia/p/7379</span><span class=\"invisible\">775.html</span><span class=\"ellipsis\"></span></a></p><h2>17. CPU频率(performance)</h2><p>CentOS 6</p><ul><li>始终：2.1GHz</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-23e189b94329f7236d4652e6b241a2c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1181\" data-rawheight=\"1145\" class=\"origin_image zh-lightbox-thumb\" width=\"1181\" data-original=\"https://pic2.zhimg.com/v2-23e189b94329f7236d4652e6b241a2c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1181&#39; height=&#39;1145&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1181\" data-rawheight=\"1145\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1181\" data-original=\"https://pic2.zhimg.com/v2-23e189b94329f7236d4652e6b241a2c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-23e189b94329f7236d4652e6b241a2c1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>CentOS 7:</p><ul><li>空闲：1.2GHz</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-39b1fda87e1fe703d84bb3fe90979525_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1037\" data-rawheight=\"1147\" class=\"origin_image zh-lightbox-thumb\" width=\"1037\" data-original=\"https://pic2.zhimg.com/v2-39b1fda87e1fe703d84bb3fe90979525_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1037&#39; height=&#39;1147&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1037\" data-rawheight=\"1147\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1037\" data-original=\"https://pic2.zhimg.com/v2-39b1fda87e1fe703d84bb3fe90979525_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-39b1fda87e1fe703d84bb3fe90979525_b.jpg\"/></figure><ul><li>sysbench 1线程压测：一个物理cpu所有核的频率瞬间增长，其中最高打到2.6GHz</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7d7702ff5f761fcb04cae2a4d9b3e231_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1035\" data-rawheight=\"1147\" class=\"origin_image zh-lightbox-thumb\" width=\"1035\" data-original=\"https://pic2.zhimg.com/v2-7d7702ff5f761fcb04cae2a4d9b3e231_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1035&#39; height=&#39;1147&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1035\" data-rawheight=\"1147\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1035\" data-original=\"https://pic2.zhimg.com/v2-7d7702ff5f761fcb04cae2a4d9b3e231_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7d7702ff5f761fcb04cae2a4d9b3e231_b.jpg\"/></figure><ul><li>sysbench 42线程压测：所有cpu所有核的频率全部达到2.4GHz</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-39fa64e527645f447e3fa917fa5e2bc1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1033\" data-rawheight=\"1145\" class=\"origin_image zh-lightbox-thumb\" width=\"1033\" data-original=\"https://pic2.zhimg.com/v2-39fa64e527645f447e3fa917fa5e2bc1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1033&#39; height=&#39;1145&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1033\" data-rawheight=\"1145\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1033\" data-original=\"https://pic2.zhimg.com/v2-39fa64e527645f447e3fa917fa5e2bc1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-39fa64e527645f447e3fa917fa5e2bc1_b.jpg\"/></figure><ul><li>若要和6一样保持频率，则在/etc/default/grub里增加intel_pstate=disable（不建议，因为性能没有任何提升，还在某些情况下降）</li></ul>", 
            "topic": [
                {
                    "tag": "CentOS", 
                    "tagLink": "https://api.zhihu.com/topics/19577255"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56889721", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 4, 
            "title": "systemd实践: 依据情况自动重启服务", 
            "content": "<p></p><blockquote>systemd服务异常自动重启很好用，但有的时候希望某些服务只在特定情况下进行重启，其他时候不要自动重启(比如OOM，需要人工介入)。 本文抛砖引玉，旨在能够让读者对systemd的重启机制有一定了解。<br/> </blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>1.最简单的自动重启范例</h2><div class=\"highlight\"><pre><code class=\"language-text\">[Unit]\nDescription=mytest\n\n[Service]\nType=simple\nExecStart=/root/mytest.sh\nRestart=always\nRestartSec=5\nStartLimitInterval=0\n\n[Install]\nWantedBy=multi-user.target</code></pre></div><p>参数详解</p><ul><li>Restart=always: 只要不是通过systemctl stop来停止服务，任何情况下都必须要重启服务，默认值为no</li><li>RestartSec=5: 重启间隔，比如某次异常后，等待5(s)再进行启动，默认值0.1(s)</li><li>StartLimitInterval: 无限次重启，默认是10秒内如果重启超过5次则不再重启，设置为0表示不限次数重启</li></ul><h2>2.案例需求</h2><p>需求：有个业务，当程序因受到OOM而退出的时候，不希望自动重启（此时需要人工介入排查），其他情况下可以自动重启</p><p>分析：OOM就是通过kill -9来杀进程，因此只要找到方法，告诉systemd当该服务遇到kill -9时候不自动重启即可</p><h2>3.RestartPreventExitStatus参数</h2><p>查询man systemd.service发现，systemd的[Service]段落里支持一个参数，叫做RestartPreventExitStatus</p><p>该参数从字面上看，意思是当符合某些退出状态时不要进行重启。</p><p>该参数的值支持exit code和信号名2种，可写多个，以空格分隔，例如</p><div class=\"highlight\"><pre><code class=\"language-text\">RestartPreventExitStatus=143 137 SIGTERM SIGKILL</code></pre></div><p>表示，当退出情况只要符合以下4种情况中任意一种时候，则不再进行重启</p><ul><li>exit code为143</li><li>exit code为137</li><li>信号为TERM</li><li>信号为KILL</li></ul><p>但实际情况并没这么简单，请继续往下看</p><h2>4.测试方法</h2><p>/usr/lib/systemd/system/mytest.service</p><div class=\"highlight\"><pre><code class=\"language-text\">[Unit]\nDescription=mytest\n\n[Service]\nType=simple\nExecStart=/root/mem\nRestart=always\nRestartSec=5\nStartLimitInterval=0\nRestartPreventExitStatus=SIGKILL\n\n[Install]\nWantedBy=multi-user.target</code></pre></div><p>/root/mem.c（不断消耗内存直至发生OOM）</p><div class=\"highlight\"><pre><code class=\"language-text\">#include &lt;stdio.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n\nint main ()\n{\n    char *p = NULL;\n    int count = 1;\n    while(1){\n        p = (char *)malloc(1024*1024*100);\n        if(!p){\n            printf(&#34;malloc error!\\n&#34;);\n            return -1;\n        }\n        memset(p, 0, 1024*1024*100);\n        printf(&#34;malloc %dM memory\\n&#34;, 100*count++);\n        usleep(500000);\n    }\n}</code></pre></div><p>编译及执行</p><div class=\"highlight\"><pre><code class=\"language-text\">gcc -o /root/mem /root/mem.c\nsystemctl daemon-reload\nsystemctl start mytest</code></pre></div><h2>5.测试结果</h2><div class=\"highlight\"><pre><code class=\"language-text\">[root@fzxiaomange ~]# systemctl status mytest\n● mytest.service - mytest\n   Loaded: loaded (/usr/lib/systemd/system/mytest.service; disabled; vendor preset: disabled)\n   Active: failed (Result: signal) since Sat 2018-10-20 23:32:24 CST; 45s ago\n  Process: 10555 ExecStart=/root/mem (code=killed, signal=KILL)\n Main PID: 10555 (code=killed, signal=KILL)\n\nOct 20 23:31:55 fzxiaomange.com systemd[1]: Started mytest.\nOct 20 23:31:55 fzxiaomange.com systemd[1]: Starting mytest...\nOct 20 23:32:24 fzxiaomange.com systemd[1]: mytest.service: main process exited, code=killed, status=9/KILL\nOct 20 23:32:24 fzxiaomange.com systemd[1]: Unit mytest.service entered failed state.\nOct 20 23:32:24 fzxiaomange.com systemd[1]: mytest.service failed.</code></pre></div><blockquote> 重点看上面第6行<code>Main PID: 10555 (code=killed, signal=KILL)</code>，这行表示主进程的状态，常见有2种情况 - code=exited, status=143：表示systemd认为主进程自行退出的，exit code为143 - code=killed, signal=KILL：表示systemd认为主进程是被kill的，接收到的信号是SIGKILL<br/> </blockquote><p>等待5秒后，并没有自动重启，符合预期</p><p>此时将RestartPreventExitStatus=SIGKILL改为RestartPreventExitStatus=SIGTERM</p><p>执行systemctl restart mytest，再进行一次观察，等待5秒后，服务自动重启，符合预期</p><h2>6.注意事项</h2><h2>6.1.RestartPreventExitStatus与Restart的关系</h2><p>配置RestartPreventExitStatus=后，并没有完全忽略Restart=，而是指当退出情况与RestartPreventExitStatus=匹配的时候，才忽略Restart=，若没有匹配，根据Restart=该怎么样还怎么样（具体详见后面的扩展部分）</p><h2>6.2.kill子进程会是什么情况</h2><p>若systemd启动的不是一个简单进程，而是会派生子进程的情况（比如执行shell脚本，shell脚本里启动多个程序），那么当另外开一个窗口通过<code>kill -信号</code>测试时，会是什么情况呢，先贴出测试方法</p><p>ExecStart=/root/mem改为ExecStart=/root/mytest.sh</p><p>/root/mytest.sh内容为</p><div class=\"highlight\"><pre><code class=\"language-text\">#!/bin/bash\nsleep 100000 &amp;\nsleep 200000</code></pre></div><p>测试结果</p><ul><li>若kill 主进程PID（kill不带参数），则主进程状态为<code>code=killed, signal=TERM</code></li><li>若kill -9 主进程PID，则主进程状态为<code>code=killed, signal=KILL</code></li><li>若kill 最后一个子进程PID（kill不带参数），则systemd不认为是接收到信号，而是根据最后一个进程的exit code进行处理，此时主进程状态为<code>code=exited, status=143</code></li><li>若kill -9 最后一个子进程PID，此时主进程状态为<code>code=exited, status=137</code></li></ul><h2>7.扩展</h2><p>上面有提到RestartPreventExitStatus和Restart的关系，但没有数据说明</p><p>另外，kill和kill -9的区别，也需要有一份数据说明</p><p>因此做了一个详细对比，这里附上详细数据</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-513b6d8a84a345ee3b8c2ce08809cf4a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb\" width=\"1632\" data-original=\"https://pic3.zhimg.com/v2-513b6d8a84a345ee3b8c2ce08809cf4a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1632&#39; height=&#39;746&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic3.zhimg.com/v2-513b6d8a84a345ee3b8c2ce08809cf4a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-513b6d8a84a345ee3b8c2ce08809cf4a_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "systemd", 
                    "tagLink": "https://api.zhihu.com/topics/20041648"
                }, 
                {
                    "tag": "重启", 
                    "tagLink": "https://api.zhihu.com/topics/19846243"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56889337", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "linux sysbench: CPU性能测试详解", 
            "content": "<blockquote> 网上sysbench教材众多，但没有一篇中文教材对cpu测试参数和结果进行详解。<br/>本文旨在能够让读者对sysbench的cpu有一定了解。<br/> </blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>1.sysbench基础知识</h2><p>sysbench的cpu测试是在指定时间内，循环进行素数计算</p><blockquote> 素数（也叫质数）就是从1开始的自然数中，无法被整除的数，比如2、3、5、7、11、13、17等。<br/>编程公式：对正整数n，如果用2到根号n之间的所有整数去除，均无法整除，则n为素数。<br/> </blockquote><h2>2.sysbench安装</h2><div class=\"highlight\"><pre><code class=\"language-text\"># CentOS7下可使用yum安装\nyum install sysbench</code></pre></div><h2>3.CPU压测命令</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 默认参数，素数上限10000，时间10秒，单线程\nsysbench cpu run</code></pre></div><h2>4.常用参数</h2><p><b>--cpu-max-prime</b>: 素数生成数量的上限</p><div class=\"highlight\"><pre><code class=\"language-text\">- 若设置为3，则表示2、3、5（这样要计算1-5共5次）\n- 若设置为10，则表示2、3、5、7、11、13、17、19、23、29（这样要计算1-29共29次）\n- 默认值为10000</code></pre></div><p><b>--threads</b>: 线程数</p><div class=\"highlight\"><pre><code class=\"language-text\">- 若设置为1，则sysbench仅启动1个线程进行素数的计算\n- 若设置为2，则sysbench会启动2个线程，同时分别进行素数的计算\n- 默认值为1</code></pre></div><p><b>--time</b>: 运行时长，单位秒</p><div class=\"highlight\"><pre><code class=\"language-text\">- 若设置为5，则sysbench会在5秒内循环往复进行素数计算，\n  从输出结果可以看到在5秒内完成了几次，\n  比如配合--cpu-max-prime=3，则表示第一轮算得3个素数，\n  如果时间还有剩就再进行一轮素数计算，直到时间耗尽。\n  每完成一轮就叫一个event\n- 默认值为10\n- 相同时间，比较的是谁完成的event多</code></pre></div><p><b>--events</b>: event上限次数</p><div class=\"highlight\"><pre><code class=\"language-text\">- 若设置为100，则表示当完成100次event后，即使时间还有剩，也停止运行\n- 默认值为0，则表示不限event次数\n- 相同event次数，比较的是谁用时更少</code></pre></div><h2>5.案例结果分析</h2><p><b>执行命令</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 素数上限2万，默认10秒，2个线程\nsysbench cpu --cpu-max-prime=20000 --threads=2 run</code></pre></div><p><b>结果分析</b></p><div class=\"highlight\"><pre><code class=\"language-text\">sysbench 1.0.9 (using system LuaJIT 2.0.4)\nRunning the test with following options:\nNumber of threads: 2 // 指定线程数为2\nInitializing random number generator from current time\nPrime numbers limit: 20000 // 每个线程产生的素数上限均为2万个\nInitializing worker threads...\nThreads started!\n\nCPU speed:\n    events per second: 650.74 // 所有线程每秒完成了650.74次event\n\nGeneral statistics:\n    total time: 10.0017s // 共耗时10秒\n    total number of events: 6510 // 10秒内所有线程一共完成了6510次event\n\nLatency (ms):\n         min: 3.03 // 完成1次event的最少耗时3.03秒\n         avg: 3.07 // 所有event的平均耗时3.07毫秒\n         max: 3.27 // 完成1次event的最多耗时3.27毫秒\n         95th percentile: 3.13 // 95%次event在3.13秒毫秒内完成\n         sum: 19999.91 // 每个线程耗时10秒，2个线程叠加耗时就是20秒\n\nThreads fairness:\n    events (avg/stddev): 3255.0000/44.00 // 平均每个线程完成3255次event，标准差为44\n    execution time (avg/stddev): 10.0000/0.00 // 每个线程平均耗时10秒，标准差为0</code></pre></div><blockquote><b>event</b>: 完成了几轮的素数计算<br/><b>stddev(标准差)</b>: 在相同时间内，多个线程分别完成的素数计算次数是否稳定，如果数值越低，则表示多个线程的结果越接近(即越稳定)。该参数对于单线程无意义。<br/> </blockquote><h2>6.结果分析</h2><p>如果有2台服务器进行CPU性能对比，当素数上限和线程数一致时：</p><ul><li> 相同时间，比较event谁更多<br/> </li><li> 相同event，比较时间谁更少<br/> </li><li> 时间和event都相同，比较stddev(标准差)谁更低</li></ul>", 
            "topic": [
                {
                    "tag": "性能测试", 
                    "tagLink": "https://api.zhihu.com/topics/19618663"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "中央处理器 (CPU)", 
                    "tagLink": "https://api.zhihu.com/topics/19553309"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56887210", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "基于QMP实现对qemu虚拟机进行交互", 
            "content": "<p></p><blockquote> 本文详解QMP，包含qmp、hmp、qemu-guest-agent的介绍、工作原理、配置方法、范例<br/> </blockquote><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ QMP介绍</p><p>▪ QMP语法</p><p>▪ 单独使用qemu，启用QMP</p><p>▪ 通过libvirt启动qemu，启用QMP</p><p>▪ qemu-guest-agent（qemu-ga）</p><p>▪ 官方参考文档</p><h2>QMP介绍</h2><p>qemu对外提供了一个socket接口，称为qemu monitor，通过该接口，可以对虚拟机实例的整个生命周期进行管理，主要有如下功能</p><p>▷ 状态查看、变更</p><p>▷ 设备查看、变更</p><p>▷ 性能查看、限制</p><p>▷ 在线迁移</p><p>▷ 数据备份</p><p>▷ 访问内部操作系统</p><p>通过该socket接口传递交互的协议是qmp，全称是qemu monitor protocol，这是基于json格式的协议</p><p>在继续往下讲之前，需要先了解qemu、kvm、libvirt之间的区别（因为有很多童鞋对这三者的理解是混乱的）</p><p>▷ qemu：虚拟机仿真器。通过软件模拟出cpu、内存、磁盘、主板、网卡等设备</p><p>▷ kvm：高性能的cpu仿真器。由于软件模拟的cpu性能很差，因此出现了kvm，这是通过硬件与内核的支持实现接近native性能的cpu仿真器，可以理解为虚拟机里的cpu任务直接交给物理机cpu完成。</p><p>▷ libvirt：虚拟机管理平台。能纳管qemu、lxc、esx等虚拟化软件，通过编写xml实现对虚拟机、存储、网络等进行配置和管理</p><blockquote> 上面只描述最核心的功能，另有一些高级功能，以及互相重叠的功能在这里不做描述，否则容易混淆<br/> </blockquote><h2>QMP语法</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 不带参数的指令\n{ &#34;execute&#34; : &#34;XXX&#34; }\n\n# 带参数的指令\n{ &#34;execute&#34; : &#34;XXX&#34;, &#34;arguments&#34; : { ... } }</code></pre></div><h2>单独使用qemu，启用QMP</h2><p>启动qemu虚拟机</p><div class=\"highlight\"><pre><code class=\"language-text\"># qemu monitor采用tcp方式，监听在127.0.0.1上，端口为4444\n/usr/libexec/qemu-kvm -qmp tcp:127.0.0.1:4444,server,nowait\n\n# qemu monitor采用unix socket，socket文件生成于/opt/qmp.socket\n/usr/libexec/qemu-kvm -qmp unix:/opt/qmp.socket,server,nowait</code></pre></div><p>连接qemu monitor</p><div class=\"highlight\"><pre><code class=\"language-text\"># tcp可以通过telnet进行连接，方法如下\n&gt; telnet 127.0.0.1 4444\nTrying 127.0.0.1...\nConnected to 127.0.0.1.\nEscape character is &#39;^]&#39;.\n{&#34;QMP&#34;: {&#34;version&#34;: {&#34;qemu&#34;: {&#34;micro&#34;: 0, &#34;minor&#34;: 12, &#34;major&#34;: 2}, &#34;package&#34;: &#34;qemu-kvm-ev-2.12.0-18.el7_6.1.1&#34;}, &#34;capabilities&#34;: []}}\n\n# unix socket可以通过nc -U进行连接，方法如下\n&gt; nc -U qmp.socket\n{&#34;QMP&#34;: {&#34;version&#34;: {&#34;qemu&#34;: {&#34;micro&#34;: 0, &#34;minor&#34;: 12, &#34;major&#34;: 2}, &#34;package&#34;: &#34;qemu-kvm-ev-2.12.0-18.el7_6.1.1&#34;}, &#34;capabilities&#34;: []}}</code></pre></div><p>按照上面执行完命令后，不会退出而是继续等待输入，但这个时候还无法使用，接着，需要输入一条qmp指令才可以</p><div class=\"highlight\"><pre><code class=\"language-text\">{ &#34;execute&#34; : &#34;qmp_capabilities&#34; }</code></pre></div><p>此时屏幕会输出以下内容，表示从&#34;capabilities negotiation模式&#34;进入了&#34;command&#34;模式</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;return&#34;: {}}</code></pre></div><p>接下来，就可以执行qmp的指令了，qmp指令非常多，由于篇幅有限，这里仅举几个例子（更多内容请参考官方文档，本文最后附上网址）</p><div class=\"highlight\"><pre><code class=\"language-text\"># 查看支持哪些qmp指令\n{ &#34;execute&#34;: &#34;query-commands&#34; }\n\n# 虚拟机状态\n{ &#34;execute&#34;: &#34;query-status&#34; }\n\n# 虚拟机暂停\n{ &#34;execute&#34;: &#34;stop&#34; }\n\n# 磁盘查看\n{ &#34;execute&#34;: &#34;query-block&#34; }\n\n# 磁盘在线插入\n{ &#34;execute&#34;: &#34;blockdev-add&#34;, &#34;arguments&#34;: { &#34;driver&#34;: &#34;qcow2&#34;, &#34;node-name&#34;: &#34;drive-virtio-disk1&#34;, &#34;file&#34;: { &#34;driver&#34;: &#34;file&#34;, &#34;filename&#34;: &#34;/opt/data.qcow2&#34; } } }\n{ &#34;execute&#34;: &#34;device_add&#34;, &#34;arguments&#34;: { &#34;driver&#34;: &#34;virtio-blk-pci&#34;, &#34;drive&#34;: &#34;drive-virtio-disk1&#34; } }\n\n# 磁盘完整备份\n{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;full&#34; , &#34;target&#34; : &#34;/opt/backuptest/fullbackup.img&#34; } }</code></pre></div><p>除了使用telnet、nc从外部连接，还可以在qemu启动时候进入一个交互的cli界面，直接输入指令，只不过这个时候输入的是hmp（human monitor protocol），而不是qmp。hmp简化了qmp的使用，但实际在底层依然是转化为qmp进行操作的，配置方法如下</p><div class=\"highlight\"><pre><code class=\"language-text\">/usr/libexec/qemu-kvm -qmp tcp:127.0.0.1:4444,server,nowait -monitor stdio</code></pre></div><p>此时会出现交互界面，输入help，就可以看到hmp支持的所有命令</p><div class=\"highlight\"><pre><code class=\"language-text\">(qemu) help</code></pre></div><blockquote> 使用hmp不需要输入类似qmp的{ &#34;execute&#34; : &#34;qmp_capabilities&#34; }<br/> </blockquote><p>这里列出几个范例</p><div class=\"highlight\"><pre><code class=\"language-text\"># 直接输入info回车，可以看到所有查询类的指令使用方法\n(qemu) info\n\n# 查看块设备\n(qemu) info block\n\n# 在线增加磁盘\n(qemu) drive_add 0 file=/opt/data.qcow2,format=qcow2,id=drive-virtio-disk1,if=none\n(qemu) device_add virtio-blk-pci,scsi=off,drive=drive-virtio-disk1</code></pre></div><h2>通过libvirt启动qemu，启用QMP</h2><p>有2种方法：</p><p>1. xml里不做任何额外配置，默认就会启用QMP，但通过这种方法启用的QMP，只能通过libvirt接口（比如virsh命令或libvirt api）来进行QMP指令的输入，而不能通过telnet、nc之类的，因为默认启用的QMP，只会生成unix socket（位于/var/lib/libvirt/qemu/domain-xx-DOMAIN/monitor.sock），而该socket被libvirtd始终连接占用着。此时通过ps aux命令可以看到qemu进程参数，和之前有点不太一样，不是-qmp，而是如下</p><div class=\"highlight\"><pre><code class=\"language-text\">-chardev socket,id=charmonitor,fd=36,server,nowait \\\n-mon chardev=charmonitor,id=monitor,mode=control</code></pre></div><blockquote> qemu命令参数支持2种方法配置qmp，即-qmp和-mon<br/> </blockquote><p>这里通过virsh做个简单示范</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39;</code></pre></div><blockquote> 使用--pretty是为了让json的输出具有换行缩进的格式化效果，而不是打印在一行里 不需要在执行其他指令前执行{ &#34;execute&#34; : &#34;qmp_capabilities&#34; }<br/> </blockquote><p>2. 在xml里额外增加2段配置，注意看下面这个xml的第一行，需要增加一个xmlns:qemu，另外在里增加</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;domain type=&#39;kvm&#39; xmlns:qemu=&#39;http://libvirt.org/schemas/domain/qemu/1.0&#39;&gt;\n  ...\n  &lt;devices&gt;\n    ...\n  &lt;/devices&gt;\n  &lt;qemu:commandline&gt;\n    &lt;qemu:arg value=&#39;-qmp&#39;/&gt;\n    &lt;qemu:arg value=&#39;unix:/tmp/qmp-sock,server,nowait&#39;/&gt;\n  &lt;/qemu:commandline&gt;\n&lt;/domain&gt;</code></pre></div><p>接着通过libvirt启动qemu（比如virsh start xxx），就创建了2个qmp通道，一个是libvirt默认创建的，可以依然使用libvirt接口来执行QMP指令，另一个就是自定义的qmp，可以通过上面提到的nc来使用</p><div class=\"highlight\"><pre><code class=\"language-text\">nc -U /tmp/qmp-sock</code></pre></div><p>libvirt也支持hmp：</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --hmp &#39;info block&#39;</code></pre></div><h2>qemu-guest-agent（qemu-ga）</h2><p>通过qmp还可以对虚拟机内的操作系统进行RPC操作，其原理是：</p><p>1. 先在xml里配置channel段，然后启动虚拟机，会在宿主机上生成一个unix socket，同时在vm里生成一个字符设备，生成的unix socket和字符设备可以理解为一个channel隧道的两端</p><p>2. 虚拟机里要启动qemu-guest-agent守护进程，该守护进程会监听字符设备</p><p>3. 然后可以在宿主机上将虚拟机里的qemu-guest-agent所支持的RPC指令经过channel发送到虚拟机里，虚拟机里的qemu-guest-agent从字符设备收到数据后，执行指令，比如读写文件、修改密码等等</p><p>若要使用qemu-guest-agent需要满足以下条件</p><p>1. xml里配置channel，范例：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;domain type=&#39;kvm&#39;&gt;\n  ...\n  &lt;devices&gt;\n    ...\n    &lt;channel type=&#39;unix&#39;&gt;\n      &lt;source mode=&#39;bind&#39; path=&#39;/tmp/channel.sock&#39;/&gt;\n      &lt;target type=&#39;virtio&#39; name=&#39;org.qemu.guest_agent.0&#39;/&gt;\n    &lt;/channel&gt;\n  &lt;/devices&gt;\n&lt;/domain&gt;</code></pre></div><blockquote> 注意，path可以自定义，但name需要保持org.qemu.guest_agent.0，因为这会影响虚拟机里字符设备的文件名，而虚拟机里的qemu-guest-agent服务默认读取的是对应org.qemu.guest_agent.0的字符设备，如果改了name，那么qemu-guest-agent的配置文件也要跟着改，改成对应name的路径<br/> </blockquote><p>2. 虚拟机内的操作系统内核需要支持（linux、windows均支持）</p><p>3. 虚拟机里要安装并启动qemu-ga的服务（比如centos可以yum install qemu-ga &amp;&amp; systemctl start qemu-guest-agent，windows通过导入virtio-win的iso，该iso里包含有qemu-ga程序）</p><p>当按照上述配置好后，可以在宿主机上进行RPC操作</p><div class=\"highlight\"><pre><code class=\"language-text\"># 测试虚拟机里的qemu-guest-agent是否可用\nvirsh qemu-agent-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;guest-ping&#34; }&#39;\n\n# 查看支持的qemu-guest-agent指令\nvirsh qemu-agent-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;guest-info&#34; }&#39;\n\n# 获得网卡信息\nvirsh qemu-agent-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;guest-network-get-interfaces&#34; }&#39;\n\n# 执行命令，这是异步的，第一步会返回一个pid，假设为797，在第二步需要带上这个pid\nvirsh qemu-agent-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;guest-exec&#34;, &#34;arguments&#34;: { &#34;path&#34;: &#34;ip&#34;, &#34;arg&#34;: [ &#34;addr&#34;, &#34;list&#34; ], &#34;capture-output&#34;: true } }&#39;\nvirsh qemu-agent-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;guest-exec-status&#34;, &#34;arguments&#34;: { &#34;pid&#34;: 797 } }&#39;</code></pre></div><blockquote> qemu-guest-agent不支持hmp调用<br/> </blockquote><p>虚拟机里的/etc/sysconfig/qemu-ga内容中的BLACKLIST_RPC参数可以配置禁止哪些指令</p><h2>官方参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\"># qemu\nhttps://qemu.weilnetz.de/doc/qemu-doc.html\n\n# qmp\nhttps://qemu.weilnetz.de/doc/qemu-qmp-ref.html\n\n# qemu-guest-agent\nhttps://qemu.weilnetz.de/doc/qemu-ga-ref.html</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "QEMU", 
                    "tagLink": "https://api.zhihu.com/topics/19636090"
                }, 
                {
                    "tag": "KVM（Kernel-based Virtual Machine）", 
                    "tagLink": "https://api.zhihu.com/topics/19607498"
                }, 
                {
                    "tag": "虚拟化", 
                    "tagLink": "https://api.zhihu.com/topics/19578791"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56886705", 
            "userName": "小慢哥", 
            "userLink": "https://www.zhihu.com/people/415688c551d8cd8a37f1133bf4d69d5b", 
            "upvote": 0, 
            "title": "QEMU/KVM磁盘在线备份", 
            "content": "<p></p><blockquote>QEMU/KVM磁盘的在线完整及增量备份，是“打包”方案的一种具体实现，可实现基于时间点的备份，同时支持本地与远程2种备份方式，并可指定备份文件进行恢复。<br/> </blockquote><p>tag: qemu, kvm, disk, live, backup, incremental, bitmap</p><p><b>小慢哥的原创文章，欢迎转载</b></p><hr/><h2>目录</h2><p>▪ 1. 本文缘由</p><p>▪ 2. 最终能实现什么</p><p>▪ 3. 环境说明</p><p>▪ 4. 常用命令一览</p><p>▪ 5. 磁盘在线备份的4种方式</p><p>▪ 6. 查询磁盘对应的设备名</p><p>▪ 7. 什么是bitmap</p><p>▪ 8. 创建与查询bitmap</p><p>▪ 9. 基于bitmap做增量备份</p><p>▪ 10. 删除bitmap</p><p>▪ 11. 重置bitmap</p><p>▪ 12. 备份逻辑</p><p>▪ 13. 远程备份</p><p>▪ 14. 备份任务管理</p><p>▪ 15. 事件查看</p><p>▪ 16. 备份链、数据恢复、合并</p><p>▪ 17. 参考文档</p><h2>1. 本文缘由</h2><p>在虚拟化底层技术中，存储是重中之重，没有人愿意丢数据。因此备份就显得尤为重要</p><p>根据备份的实现方案可分为2类：</p><p>▷ <b>副本</b>：可以单纯从后端存储上直接实现，而无需计算层面的帮助，比如Ceph可以做多副本，本地盘文件形式可以通过DRBD技术做实时同步。副本方案提高了存储的整体可靠性</p><p>▷ <b>打包</b>：表示对磁盘数据进行定期打包导出，当需要恢复的时候，可以指定备份文件来恢复</p><p>副本与打包是互补的，副本无法根据时间点来做备份恢复，而打包也没有宕机前一刻的数据。本文阐述的所有内容，均是“打包”</p><h2>2. 最终能实现什么</h2><p>经过调研和测试，最终本文的内容，可以实现如下几大功能：</p><p>▷ 在线完整备份、在线增量备份</p><p>▷ 事件查看</p><p>▷ 任务管理</p><p>▷ 不限存储形式，可以是本地盘qcow2、raw，也可以是ceph rbd等各种形式</p><p>▷ 远程备份</p><h2>3. 环境说明</h2><p>本文所有内容，除特殊说明，均是基于以下环境</p><p>▷ 操作系统：CentOS 7.5 x86_64</p><p>▷ qemu：基于ovirt-4.3 yum源的qemu-2.12.0</p><p>▷ libvirt：基于centos-update yum源的libvirt-4.5.0</p><h2>4. 常用命令一览</h2><p><b>获取磁盘设备名</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 通过qmp查看\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39;\n\n# 通过hmp查看\nvirsh qemu-monitor-command DOMAIN --hmp &#39;info block&#39;</code></pre></div><p><code>--pretty</code>表示将输出的json进行换行格式化展示，否则只有一行，该参数和<code>--hmp</code>互斥</p><p><b>备份命令</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 完整备份（包含backing file）：“full”\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;full&#34; , &#34;target&#34; : &#34;/opt/backup/full.img&#34; } }&#39;\n\n# 完整备份（不包含backing file，仅备份当前文件）：“top”\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;top&#34; , &#34;target&#34; : &#34;/opt/backup/top.img&#34; } }&#39;\n\n# 实时导出新IO：“none”\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;none&#34; , &#34;target&#34; : &#34;/opt/backup/none.img&#34; } }&#39;\n\n# 增量备份：“bitmap”\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.0.qcow2&#34; } }&#39;\n\n# 增量备份：“bitmap”，通过iscsi远程导出\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;iscsi://192.168.1.100:3260/iqn.2019-01.com.iaas/0&#34; } }&#39;</code></pre></div><p><b>bitmap操作</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 创建非持久bitmap（qemu &gt;= 2.4）\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap0&#34;}}&#39;\n\n# 创建持久bitmap（qemu &gt;= 2.10）\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmapY&#34;, &#34;persistent&#34;: true}}&#39;\n\n# 删除bitmap\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;block-dirty-bitmap-remove&#34;, &#34;arguments&#34; : { &#34;node&#34; : &#34;drive-virtio-disk0&#34;, &#34;name&#34; : &#34;bitmap0&#34; } }&#39;\n\n# 重置bitmap\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-clear&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap0&#34;}}&#39;\n\n# 查询虚拟机所有磁盘的块信息，含bitmap\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39;\n\n# 查询虚拟机指定磁盘的bitmap（查询第一块磁盘使用[0]，第二块用[1]，以此类推）\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39; | jq .return[0] | sed -n &#39;/dirty\\-bitmaps/,/]/p&#39;</code></pre></div><p><b>事件监听</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 始终监听事件\nvirsh qemu-monitor-event DOMAIN --timestamp --loop\n\n# 当收到特定事件后停止监听\nvirsh qemu-monitor-event DOMAIN --event BLOCK_JOB_COMPLETED</code></pre></div><p><b>备份任务管理</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 通过qmp查看运行中的任务\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block-jobs&#34; }&#39;\n\n# 通过hmp查看运行中的任务\nvirsh qemu-monitor-command DOMAIN --hmp &#39;info block-jobs&#39;\n\n# 停止备份任务\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34;: &#34;block-job-cancel&#34;, &#34;arguments&#34;: { &#34;device&#34;: &#34;drive-virtio-disk0&#34;, &#34;force&#34;: true } }&#39;\n\n# 暂停备份任务\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;block-job-pause&#34;, &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; } }&#39;\n\n# 恢复已暂停的备份任务\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;block-job-resume&#34;, &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; } }&#39;</code></pre></div><h2>5. 磁盘在线备份的4种方式</h2><p>▷ <b>full</b>：完整备份，会将指定磁盘及其链上的所有母盘（backing file），合并输出到本地</p><p>▷ <b>top</b>：仅备份当前磁盘，而不包含backing file。此项仅对本地盘有效，对于ceph rbd，top和full的效果一样都是完整备份</p><p>▷ <b>none</b>：new I/O，即从执行备份命令起，一旦有IO变化，就会实时导出有变化的数据，直到虚拟机关机或者手工停止job才会停止。仅支持qcow2格式的块设备，不支持raw格式（注意，这里指的是qcow2格式，而并非要求qcow2本地盘）</p><p>▷ <b>incremental</b>：指定dirty bitmap进行备份，目前qemu的增量备份就是指基于dirty bitmap的备份</p><p>上述4种备份是互斥的：任意一种备份job运行中，都无法执行其他类型的备份，也无法再开启同种备份的新job</p><p><b>full、top、none这三种备份的操作方法非常简单，在前面“常用命令一览”中已经提到，不再赘述，而增量备份会稍微复杂点，本文的重点将放在增量备份上</b></p><h2>6. 查询磁盘对应的设备名</h2><p>由于qemu不支持一键备份所有磁盘，因此无论有几块盘，必须先找到要备份的磁盘设备名</p><p>可通过qmp或者hmp查找设备名，qmp是qemu原生方法，hmp是为了简化qmp的使用而增加的一层翻译器（其中的h就是human，表示友好可读），hmp虽然好用，但不确定其能否支持所有qmp功能，因此这里只是简单演示下hmp的使用，之后主要还是通过qmp进行操作</p><div class=\"highlight\"><pre><code class=\"language-text\"># 通过qmp查看\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39;\n\n# 通过hmp查看\nvirsh qemu-monitor-command DOMAIN --hmp &#39;info block&#39;</code></pre></div><p>输出中的<code>drive-virtio-disk0</code>、<code>drive-virtio-disk1</code>就是设备名</p><p>关于qmp和hmp的详细使用，详见笔者的另一篇文章《基于QMP实现对qemu虚拟机进行交互》</p><div class=\"highlight\"><pre><code class=\"language-text\">https://mp.weixin.qq.com/s/HUo0HO6Sl9xn5-FWiexXoA</code></pre></div><h2>7. 什么是bitmap</h2><p><b>本文将重点讲解bitmap备份</b></p><p>在qemu里，“增量备份”指的就是基于dirty bitmap的incremental备份方式。请注意，这里提到了2个词，dirty bitmap和incremental，接下来，要详细讲解：什么是bitmap、bitmap怎么用、有哪些特性与注意事项，只有了解清楚bitmap，才能做好增量备份</p><p><b>什么是bitmap</b></p><p>通过dirty bitmap可以实现qemu磁盘的在线增量备份，而无需创建一长串的快照</p><blockquote> qemu的增量备份通常来说就是指通过dirty bitmap实现的备份<br/> </blockquote><p>dirty bitmap是qemu实现的，跟踪需要在下次进行增量备份的数据</p><p>▷ v2.4开始，支持dirty bitmap，但这时的bitmap只是记录在qemu的仿真器内存中，并没有记录在底层块设备中（底层块设备指ceph rbd、本地盘qcow2等），这种bitmap称为in-memory bitmap，笔者习惯叫做非持久bitmap</p><p>▷ v2.10开始，qemu开始支持persistent dirty bitmap，笔者习惯叫做持久bitmap</p><p><b>bitmap、dirty bitmap、persistent dirty bitmap区别</b></p><p>▷ <b>bitmap</b>：是qemu支持的一个高级功能，直到本文编写完成时（v3.1.0），bitmap只有一种类型，就是dirty bitmap</p><p>▷ <b>dirty bitmap</b>：是bitmap的一种类型，也是唯一的类型，因此dirty bitmap和bitmap是一回事。由于dirty bitmap是记录在内存中而非磁盘上，因此可以支持任意类型的底层磁盘，比如本地盘、ceph rbd，也支持任意格式的磁盘格式，比如qcow2、raw等等。</p><p>▷ <b>persistent dirty bitmap</b>：是dirty bitmap的改进版，因为dirty bitmap是记录在内存中的，当qemu虚拟机关机后，dirty bitmap就消失了，就会导致需要重新做一次完整备份。persistent dirty bitmap是v2.10开始才支持</p><blockquote> 持久bitmap仅支持qcow2，不支持raw格式（例如本地盘raw文件或者ceph-rbd）<br/> </blockquote><p><b>bitmap的名称</b></p><p>▷ 对于节点是唯一的，但附加到不同节点的bitmap可以共享相同的名称。对于同一节点，持久bitmap和非持久bitmap的名称也不能冲突）</p><p>▷ 为qemu内部使用而创建的bitmap可能是匿名的，没有名称。但用户创建的bitmap肯定不是匿名的。每个节点可以有任意数量的bitmap</p><p>▷ 用户创建的bitmap名称不能是空（即&#34;&#34;）</p><p><b>基于bitmap做增量备份的工作原理</b></p><p>▷ 首先，在虚拟机启动状态下，针对虚拟机某个磁盘（称为node），打上bitmap，此时bitmap存在qemu内存中，并且bitmap的count属性为0</p><p>▷ 其次，当磁盘数据有变化的时候，bitmap会将变化记录下来，可以看到count不断递增（不会超过磁盘virtual size）</p><p>▷ 最后，指定bitmap做备份时候，qemu会根据bitmap记录，导出对应的增量数据到本地或远程</p><h2>8. 创建与查询bitmap</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 创建非持久bitmap（qemu &gt;= 2.4）\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap0&#34;}}&#39;\n\n# 创建持久bitmap（qemu &gt;= 2.10）\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap1&#34;, &#34;persistent&#34;: true}}&#39;\n\n# 查询虚拟机的所有磁盘的bitmap\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39;\n\n# 查询虚拟机第一块磁盘的bitmap\nvirsh qemu-monitor-command DOMAIN--pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39; | jq .return[0] | sed -n &#39;/dirty\\-bitmaps/,/]/p&#39;\n\n# 查询虚拟机第二块磁盘的bitmap\nvirsh qemu-monitor-command DOMAIN--pretty &#39;{ &#34;execute&#34;: &#34;query-block&#34; }&#39; | jq .return[1] | sed -n &#39;/dirty\\-bitmaps/,/]/p&#39;</code></pre></div><h2>9. 基于bitmap做增量备份</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 备份\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.0.qcow2&#34; } }&#39;\n\n# 在备份过程中，可以查看任务\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block-jobs&#34; }&#39;</code></pre></div><h2>10. 删除bitmap</h2><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;block-dirty-bitmap-remove&#34;, &#34;arguments&#34; : { &#34;node&#34; : &#34;drive-virtio-disk0&#34;, &#34;name&#34; : &#34;bitmap0&#34; } }&#39;</code></pre></div><h2>11. 重置bitmap</h2><p>重置bitmap就是将bitmap的count值置为0，重新跟踪磁盘变化</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-clear&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap0&#34;}}&#39;</code></pre></div><h2>12. 备份逻辑</h2><p>到这里，已经知道如何做完整备份和增量备份了，但如何把二者结合起来呢？</p><p><code>“等下，结合什么，先做完整备份，然后创建bitmap，过段时间后做增量备份，不行吗”</code></p><p>“真要这么简单就好了，但你漏了一个关键点，在开机状态下，磁盘的数据可能实时变化，当你还在做完整备份的过程中，磁盘数据可能已经变化了，然后你再创建bitmap，已经太迟了”</p><p><code>“那我就先创建bitmap，然后再做完整备份，这样就不会缺少数据了吧”</code></p><p>“看起来可以，但从理论上来说，也是不行的，你看，分别执行2条QMP命令，先执行bitmap的创建，再执行完整备份，虽然创建bitmap是毫秒级完成的，但若磁盘IO变化很快，毫厘之间，也有可能产生数据的变化”</p><p><code>“那怎么办”</code></p><p>“接着往下看就知道了”</p><p><b>虚拟机启动前就确定要备份</b></p><p>若虚拟机第一次启动之前，就确定要备份磁盘，那么可以paused状态启动虚拟机，这样可以保证磁盘IO不会变化，就没有上面的那么多担心了，具体操作如下：</p><p>1️⃣ 以paused状态启动虚拟机（virsh start DOMAIN --paused）</p><p>2️⃣ 对磁盘进行完整备份（&#34;sync&#34;:&#34;top&#34;）</p><p>3️⃣ 对磁盘创建bitmap（block-dirty-bitmap-add）</p><p>4️⃣ 恢复虚拟机状态（virsh resume DOMAIN）</p><p>5️⃣ 接下来可以做incremental备份（&#34;sync&#34;:&#34;incremental&#34;）</p><p>范例如下</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh start DOMAIN --paused\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;top&#34; , &#34;target&#34; : &#34;/opt/backup/top.img&#34; } }&#39;\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;arguments&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;,&#34;name&#34;: &#34;bitmap0&#34;}}&#39;\nvirsh resume DOMAIN\n\n# ...运行一段时间...\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.0.qcow2&#34; } }&#39;\n\n# ...又运行一段时间...\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.1.qcow2&#34; } }&#39;</code></pre></div><p><b>虚拟机运行过程中确定要备份</b></p><p>如果是虚拟机已经运行一段时间了，才决定做备份，就需要用到QMP的“事务”</p><p>1️⃣ 以事务方式对磁盘创建bitmap（block-dirty-bitmap-add）及对磁盘做完整备份（&#34;sync&#34;:&#34;top&#34;）</p><p>2️⃣ 接下来可以做incremental备份（&#34;sync&#34;:&#34;incremental&#34;）</p><p>QMP部分功能支持事务性（事务的目的是当其中一件事失败后，会自动回滚，保证数据一致性，但这里也可用于保证创建bitmap和开始备份之间没有缺少数据），因此上述1️⃣通过事务操作</p><div class=\"highlight\"><pre><code class=\"language-text\">{ &#34;execute&#34;: &#34;transaction&#34;,\n  &#34;arguments&#34;: {\n    &#34;actions&#34;: [\n      {&#34;type&#34;: &#34;block-dirty-bitmap-add&#34;,\n       &#34;data&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;, &#34;name&#34;: &#34;bitmap0&#34;} },\n      {&#34;type&#34;: &#34;drive-backup&#34;,\n       &#34;data&#34;: {&#34;device&#34;: &#34;drive-virtio-disk0&#34;, &#34;target&#34;: &#34;/path/to/full_backup.img&#34;, &#34;sync&#34;: &#34;top&#34;} }\n    ]\n  }\n}</code></pre></div><p>范例如下</p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;transaction&#34;, &#34;arguments&#34;: { &#34;actions&#34;: [ { &#34;type&#34;: &#34;block-dirty-bitmap-add&#34;, &#34;data&#34;: {&#34;node&#34;:&#34;drive-virtio-disk0&#34;, &#34;name&#34;:&#34;bitmap0&#34;}}, { &#34;type&#34;: &#34;drive-backup&#34;, &#34;data&#34;: {&#34;device&#34;: &#34;drive-virtio-disk0&#34;, &#34;target&#34;: &#34;/opt/backup/top.img&#34;,&#34;sync&#34;:&#34;top&#34; }} ]} }&#39;\n\n# ...运行一段时间...\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.0.qcow2&#34; } }&#39;\n\n# ...又运行一段时间...\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;/opt/backup/inc.1.qcow2&#34; } }&#39;</code></pre></div><p>如果之前已经创建过bitmap，此刻想忽略bitmap，重新做一次完整备份，并重置bitmap（用于接下来的增量备份），则可以</p><div class=\"highlight\"><pre><code class=\"language-text\">{ &#34;execute&#34;: &#34;transaction&#34;,\n  &#34;arguments&#34;: {\n    &#34;actions&#34;: [\n      {&#34;type&#34;: &#34;block-dirty-bitmap-clear&#34;,\n       &#34;data&#34;: {&#34;node&#34;: &#34;drive-virtio-disk0&#34;, &#34;name&#34;: &#34;bitmap0&#34;} },\n      {&#34;type&#34;: &#34;drive-backup&#34;,\n       &#34;data&#34;: {&#34;device&#34;: &#34;drive-virtio-disk0&#34;, &#34;target&#34;: &#34;/path/to/new_full_backup.img&#34;, &#34;sync&#34;: &#34;top&#34;} }\n    ]\n  }\n}</code></pre></div><h2>13. 远程备份</h2><p>经测试，qemu仅支持一种远程备份方法：iscsi，方法就是在drive-backup的target里使用iscsi的格式即可：</p><div class=\"highlight\"><pre><code class=\"language-text\"># target内容\n格式 iscsi://[&lt;username&gt;[%&lt;password&gt;]@]&lt;host&gt;[:&lt;port&gt;]/&lt;target-iqn-name&gt;/&lt;lun&gt;\n例子 iscsi://192.168.1.100:3260/iqn.2019-01.com.iaas/0\n\nvirsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;drive-backup&#34; , &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; , &#34;sync&#34; : &#34;incremental&#34; , &#34;bitmap&#34; : &#34;bitmap0&#34; , &#34;target&#34; : &#34;iscsi://192.168.1.100:3260/iqn.2019-01.com.iaas/0&#34; } }&#39;</code></pre></div><h2>14. 备份任务管理</h2><blockquote> 如果迟迟没有收到事件，要如何查看备份任务是否还在进行中呢，或者想中断备份，又如何操作呢<br/> </blockquote><p><b>查看备份任务</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># 通过qmp查看\nvirsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;query-block-jobs&#34; }&#39;\n\n# 通过hmp查看\nvirsh qemu-monitor-command DOMAIN --hmp &#39;info block-jobs&#39;</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\"># 通过qmp查看，有任务时候的输出\n{\n  &#34;return&#34;: [\n    {\n      &#34;auto-finalize&#34;: true,\n      &#34;io-status&#34;: &#34;ok&#34;,\n      &#34;device&#34;: &#34;drive-virtio-disk1&#34;,\n      &#34;auto-dismiss&#34;: true,\n      &#34;busy&#34;: true,\n      &#34;len&#34;: 1073741824,\n      &#34;offset&#34;: 2424832,\n      &#34;status&#34;: &#34;running&#34;,\n      &#34;paused&#34;: false,\n      &#34;speed&#34;: 0,\n      &#34;ready&#34;: false,\n      &#34;type&#34;: &#34;backup&#34;\n    },\n    {\n      &#34;auto-finalize&#34;: true,\n      &#34;io-status&#34;: &#34;ok&#34;,\n      &#34;device&#34;: &#34;drive-virtio-disk0&#34;,\n      &#34;auto-dismiss&#34;: true,\n      &#34;busy&#34;: true,\n      &#34;len&#34;: 21474836480,\n      &#34;offset&#34;: 163840000,\n      &#34;status&#34;: &#34;running&#34;,\n      &#34;paused&#34;: false,\n      &#34;speed&#34;: 0,\n      &#34;ready&#34;: false,\n      &#34;type&#34;: &#34;backup&#34;\n    }\n  ],\n  &#34;id&#34;: &#34;libvirt-45&#34;\n}\n\n# 通过qmp查看，无任务时候的输出\n{\n  &#34;return&#34;: [\n\n  ],\n  &#34;id&#34;: &#34;libvirt-360&#34;\n}\n\n# 通过hmp查看，有任务时候的输出\nType backup, device drive-virtio-disk1: Completed 20185088 of 1073741824 bytes, speed limit 0 bytes/s\nType backup, device drive-virtio-disk0: Completed 181403648 of 21474836480 bytes, speed limit 0 bytes/s\n\n# 通过hmp查看，无任务时候的输出\nNo active jobs</code></pre></div><p><b>停止备份任务</b></p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN --pretty &#39;{ &#34;execute&#34;: &#34;block-job-cancel&#34;, &#34;arguments&#34;: { &#34;device&#34;: &#34;drive-virtio-disk1&#34;, &#34;force&#34;: true } }&#39;</code></pre></div><blockquote> 如果不带force参数，则默认为false，在false情况下当任务处于暂停状态时无法停止<br/> </blockquote><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;return&#34;:{},&#34;id&#34;:&#34;libvirt-5880&#34;}</code></pre></div><p>同时收到事件</p><div class=\"highlight\"><pre><code class=\"language-text\">2019-02-03 13:02:58.535+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;aborting&#34;,&#34;id&#34;:&#34;drive-virtio-disk1&#34;}\n2019-02-03 13:02:58.541+0000: event BLOCK_JOB_CANCELLED for domain DOMAIN: {&#34;device&#34;:&#34;drive-virtio-disk1&#34;,&#34;len&#34;:2147483648,&#34;offset&#34;:29687808,&#34;speed&#34;:0,&#34;type&#34;:&#34;backup&#34;}\n2019-02-03 13:02:58.541+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;concluded&#34;,&#34;id&#34;:&#34;drive-virtio-disk1&#34;}\n2019-02-03 13:02:58.541+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;null&#34;,&#34;id&#34;:&#34;drive-virtio-disk1&#34;}</code></pre></div><p>▷ 根据官方文档，JOB_STATUS_CHANGE事件是从qemu-3.0才出现的，但在qemu-2.12时就能看到了（2.9看不到），尚未深究</p><p>▷ 因此，若qemu是2.12，当收到JOB_STATUS_CHANGE事件，应当不予理会，后面不再赘述</p><p><b>暂停备份任务</b></p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;block-job-pause&#34;, &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; } }&#39;</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;return&#34;:{},&#34;id&#34;:&#34;libvirt-5882&#34;}</code></pre></div><p>同时收到事件（假设之前任务处于running状态）</p><div class=\"highlight\"><pre><code class=\"language-text\">2019-01-22 02:42:55.503+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;paused&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}</code></pre></div><p><b>恢复已暂停的备份任务</b></p><div class=\"highlight\"><pre><code class=\"language-text\">virsh qemu-monitor-command DOMAIN &#39;{ &#34;execute&#34; : &#34;block-job-resume&#34;, &#34;arguments&#34; : { &#34;device&#34; : &#34;drive-virtio-disk0&#34; } }&#39;</code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;return&#34;:{},&#34;id&#34;:&#34;libvirt-5999&#34;}</code></pre></div><p>同时收到事件</p><div class=\"highlight\"><pre><code class=\"language-text\">2019-01-22 02:46:04.928+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;running&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}</code></pre></div><h2>15. 事件查看</h2><p><b>监听事件</b></p><p>在备份操作前，可以另外再开一个shell窗口，实时监听qmp的事件</p><div class=\"highlight\"><pre><code class=\"language-text\"># 始终监听事件\nvirsh qemu-monitor-event DOMAIN --timestamp --loop\n\n# 当收到特定事件后停止监听\nvirsh qemu-monitor-event DOMAIN --event BLOCK_JOB_COMPLETED</code></pre></div><p><b>开始备份时会收到的事件</b></p><div class=\"highlight\"><pre><code class=\"language-text\">2019-01-29 03:14:54.516+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;created&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-29 03:14:54.516+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;running&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}</code></pre></div><p><b>备份完成时收到的事件</b></p><div class=\"highlight\"><pre><code class=\"language-text\">2019-01-24 06:25:21.629+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;created&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-24 06:25:21.629+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;running&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-24 06:26:34.935+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;waiting&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-24 06:26:34.935+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;pending&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-24 06:26:34.935+0000: event BLOCK_JOB_COMPLETED for domain DOMAIN: {&#34;device&#34;:&#34;drive-virtio-disk0&#34;,&#34;len&#34;:21474836480,&#34;offset&#34;:21474836480,&#34;speed&#34;:0,&#34;type&#34;:&#34;backup&#34;}\n2019-01-24 06:26:34.935+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;concluded&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}\n2019-01-24 06:26:34.935+0000: event JOB_STATUS_CHANGE for domain DOMAIN: {&#34;status&#34;:&#34;null&#34;,&#34;id&#34;:&#34;drive-virtio-disk0&#34;}</code></pre></div><p>▷ 重点看上面的BLOCK_JOB_COMPLETED事件，该事件从qemu-1.1就已经出现的</p><p>▷ 遗憾的是，事件内容并不详细，无法识别出是full、top、none还是bitmap，也看不到备份产生的文件路径</p><h2>16. 备份链、数据恢复、合并</h2><blockquote> 其实，本章节应该放到本文最后面，但本文篇幅较多，放后面担心容易被遗漏<br/> </blockquote><p><b>备份链</b></p><p>经过增量备份后，会形成一条备份链：full.qcow2 &lt;- inc.0.qcow2 &lt;- inc.1.qcow2 &lt;- inc.2.qcow2</p><p><b>数据恢复</b></p><p>当需要使用备份进行数据恢复时候，就可以使用该链上的文件进行恢复，比如要恢复到inc.1.qcow2的末尾，那么有2种方案：保持链、合并</p><p>▷ <b>保持链</b></p><p>1️⃣ 将full.qcow2、inc.0.qcow2、inc.1.qcow2拷贝到目标宿主机上</p><p>2️⃣ 通过qemu-img rebase -u来确保链的顺序</p><p>3️⃣ 虚拟机xml里指定inc.1.qcow2</p><p>▷ <b>合并</b></p><p>1️⃣ 将full.qcow2、inc.0.qcow2、inc.1.qcow2合并成为一个qcow2</p><div class=\"highlight\"><pre><code class=\"language-text\"># 将inc.1.qcow2合并到inc.0.qcow2\nqemu-img commit inc.1.qcow2\n\n# 将inc.0.qcow2合并到full.qcow2\nqemu-img commit inc.0.qcow2</code></pre></div><p>2️⃣ 然后xml里指定这个合并好的qcow2（即full.qcow2）就行</p><h2>17. 参考文档</h2><div class=\"highlight\"><pre><code class=\"language-text\"># 作者最初的想法\nhttp://lists.gnu.org/archive/html/qemu-devel/2013-11/msg03035.html\n\n# 官方文章\nqcow2介绍：https://chromium.googlesource.com/external/qemu/+/v2.12.0/docs/interop/qcow2.txt\nbitmap介绍：https://chromium.googlesource.com/external/qemu/+/v2.12.0/docs/interop/bitmaps.rst\nqmp使用：https://qemu.weilnetz.de/doc/qemu-qmp-ref.html\nqemu使用：https://qemu.weilnetz.de/doc/qemu-doc.html\n\n# 关于qemu磁盘备份的文章\n2011年：https://www.linux-kvm.org/images/b/b6/2011-forum-LiveBackup.pdf\n2015年：http://events17.linuxfoundation.org/sites/events/files/slides/kvm2015_rh_light_44_vfinal.pdf\n2016年：https://www.linux-kvm.org/images/6/65/02x08B-Max_Reitz-Backups_with_QEMU.pdf\n2017年：https://www.linux-kvm.org/images/e/e6/Kvm-forum2017_backup.pdf\n2018年：https://events.linuxfoundation.org/wp-content/uploads/2017/12/2018-libvirt-incremental-backup-expanded._Eric-Blake.pdf\n2018年：https://archive.fosdem.org/2018/schedule/event/vai_qemu_live_dev_operations/attachments/slides/2391/export/events/attachments/vai_qemu_live_dev_operations/slides/2391/Live_Block_Device_Operations_in_QEMU_FOSDEM2018.pdf\n\n# iscsi\nhttp://atodorov.org/blog/2015/04/07/how-to-configure-iscsi-target-on-red-hat-enterprise-linux-7/\nhttp://linux-iscsi.org/wiki/Targetcli</code></pre></div><p><b>QEMU磁盘的在线备份，是“打包”方案的一种具体实现，可实现基于时间点的备份，同时支持本地与远程2种备份方式，并可指定备份文件进行恢复</b></p>", 
            "topic": [
                {
                    "tag": "KVM（Kernel-based Virtual Machine）", 
                    "tagLink": "https://api.zhihu.com/topics/19607498"
                }, 
                {
                    "tag": "QEMU", 
                    "tagLink": "https://api.zhihu.com/topics/19636090"
                }, 
                {
                    "tag": "虚拟化", 
                    "tagLink": "https://api.zhihu.com/topics/19578791"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/fzxiaomange"
}
