{
    "title": "顾先生的数据挖掘", 
    "description": "欢迎关注我的公众号：顾先生的AI研习社", 
    "followers": [
        "https://www.zhihu.com/people/jin-niu-le-ma", 
        "https://www.zhihu.com/people/zhu-zhu-xia-87-27", 
        "https://www.zhihu.com/people/jin-mh", 
        "https://www.zhihu.com/people/luna-59-57-63", 
        "https://www.zhihu.com/people/li-da-da-61-42", 
        "https://www.zhihu.com/people/xi-hong-shi-ji-dan-mian-46", 
        "https://www.zhihu.com/people/zhu-forrest", 
        "https://www.zhihu.com/people/zheng-run-ze-89", 
        "https://www.zhihu.com/people/chu-jian-92-69", 
        "https://www.zhihu.com/people/zhang-meng-han-34-14", 
        "https://www.zhihu.com/people/myyao", 
        "https://www.zhihu.com/people/li-zhu-7-39", 
        "https://www.zhihu.com/people/elgong", 
        "https://www.zhihu.com/people/xiaotang-21", 
        "https://www.zhihu.com/people/lu-lu-lu-lu-lu-lu-zhu-6", 
        "https://www.zhihu.com/people/cai-zhong-kai-20", 
        "https://www.zhihu.com/people/ssss-61-24-2", 
        "https://www.zhihu.com/people/bu-ji-de-feng-87-35", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/yami-53-71", 
        "https://www.zhihu.com/people/FrankFJ", 
        "https://www.zhihu.com/people/kiki-84-35", 
        "https://www.zhihu.com/people/lai-ge-tu-zi", 
        "https://www.zhihu.com/people/yanghuaizhi", 
        "https://www.zhihu.com/people/ni-hui-51-23", 
        "https://www.zhihu.com/people/wang-zhou-yang", 
        "https://www.zhihu.com/people/lzp-9", 
        "https://www.zhihu.com/people/null-71-8", 
        "https://www.zhihu.com/people/xu-feng-93-80-84", 
        "https://www.zhihu.com/people/mu-tou-36-87", 
        "https://www.zhihu.com/people/iron-13-51-73", 
        "https://www.zhihu.com/people/horkychen", 
        "https://www.zhihu.com/people/chinalingbo-58", 
        "https://www.zhihu.com/people/shen-vt", 
        "https://www.zhihu.com/people/wang-zhi-yuan-39-20", 
        "https://www.zhihu.com/people/4recommend", 
        "https://www.zhihu.com/people/guijie-wang", 
        "https://www.zhihu.com/people/yiwan-yang-guang-91", 
        "https://www.zhihu.com/people/feng-liu-ren-wu-10", 
        "https://www.zhihu.com/people/yang-mao-tong", 
        "https://www.zhihu.com/people/xia-zhu-71-61", 
        "https://www.zhihu.com/people/yu-yang-51-61-72", 
        "https://www.zhihu.com/people/ke-xue-xia", 
        "https://www.zhihu.com/people/li-xiang-4-52", 
        "https://www.zhihu.com/people/zhang-ming-feng-91", 
        "https://www.zhihu.com/people/zhou-xiao-jie-1-65", 
        "https://www.zhihu.com/people/chen-cong-65-81", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/li-jian-jian-66", 
        "https://www.zhihu.com/people/sun-chuang-89-99", 
        "https://www.zhihu.com/people/colin-48-22", 
        "https://www.zhihu.com/people/zhou-zheng-yi-87", 
        "https://www.zhihu.com/people/p-s-8", 
        "https://www.zhihu.com/people/kt37-62", 
        "https://www.zhihu.com/people/ni-shi-jiang-hu-wo-da-jie", 
        "https://www.zhihu.com/people/wang-ruo-tian-92", 
        "https://www.zhihu.com/people/han-xiao-yi-64-91", 
        "https://www.zhihu.com/people/li-xiang-63-96-84", 
        "https://www.zhihu.com/people/hua-dong-yue", 
        "https://www.zhihu.com/people/yu-zhou-wu-di-zi-xin-xiao-wang-zi", 
        "https://www.zhihu.com/people/sang-ji-bao", 
        "https://www.zhihu.com/people/mo-mo-ha-ha-96-21", 
        "https://www.zhihu.com/people/liu-xu-feng-53", 
        "https://www.zhihu.com/people/li-nick-36", 
        "https://www.zhihu.com/people/sha-pi-gou-97-64", 
        "https://www.zhihu.com/people/j-ceo", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/cao-ni-ma-94-85", 
        "https://www.zhihu.com/people/na-nian-40", 
        "https://www.zhihu.com/people/wu-xing-59-49", 
        "https://www.zhihu.com/people/robert-21-47", 
        "https://www.zhihu.com/people/tan-yang-21-70", 
        "https://www.zhihu.com/people/ting-feng-chui-yu-48", 
        "https://www.zhihu.com/people/jeremyh-41", 
        "https://www.zhihu.com/people/lee-87-75", 
        "https://www.zhihu.com/people/jianxinwang", 
        "https://www.zhihu.com/people/rui-dian-xiao-ke-tong-xue", 
        "https://www.zhihu.com/people/zhun-zhun-68", 
        "https://www.zhihu.com/people/wang-ming-66-71", 
        "https://www.zhihu.com/people/li-chen-hui-40", 
        "https://www.zhihu.com/people/hai-pa-chen-pi", 
        "https://www.zhihu.com/people/gong-liang-quan", 
        "https://www.zhihu.com/people/gu-kai-dong-42", 
        "https://www.zhihu.com/people/jin-liang-21-65", 
        "https://www.zhihu.com/people/zou-yihong-3", 
        "https://www.zhihu.com/people/yuan-meng-feng-hua", 
        "https://www.zhihu.com/people/hou-sai-lei-29-39", 
        "https://www.zhihu.com/people/xin-yong-hu-30-35", 
        "https://www.zhihu.com/people/aitracker", 
        "https://www.zhihu.com/people/tmhhhh", 
        "https://www.zhihu.com/people/matrix-48", 
        "https://www.zhihu.com/people/dai-du-96", 
        "https://www.zhihu.com/people/cheng-peng-90-99", 
        "https://www.zhihu.com/people/mo-yun-93-61", 
        "https://www.zhihu.com/people/shuai-ge-35-22", 
        "https://www.zhihu.com/people/ta-xiao-liao-wo-zou-liao", 
        "https://www.zhihu.com/people/violentdinosaur-77", 
        "https://www.zhihu.com/people/fab0830", 
        "https://www.zhihu.com/people/sumuli", 
        "https://www.zhihu.com/people/tiyamo", 
        "https://www.zhihu.com/people/zhao-xian-sheng-43-29", 
        "https://www.zhihu.com/people/xiao-ming-51-9", 
        "https://www.zhihu.com/people/he-an-50", 
        "https://www.zhihu.com/people/shu-jian-piao-ling-19", 
        "https://www.zhihu.com/people/qiu-qiu-10-63-51", 
        "https://www.zhihu.com/people/yorkj", 
        "https://www.zhihu.com/people/wang-tian-29-14", 
        "https://www.zhihu.com/people/eric-sun-6", 
        "https://www.zhihu.com/people/xu-zhang-10-77", 
        "https://www.zhihu.com/people/ttt-87-19", 
        "https://www.zhihu.com/people/li-zeng-quan-97", 
        "https://www.zhihu.com/people/han-meng-jun-25", 
        "https://www.zhihu.com/people/you-long-fei", 
        "https://www.zhihu.com/people/yu-yi-51-29", 
        "https://www.zhihu.com/people/xiao-ye-46-72", 
        "https://www.zhihu.com/people/jimmy-wen-94", 
        "https://www.zhihu.com/people/hhb-63", 
        "https://www.zhihu.com/people/lu-xiao-feng-26-11", 
        "https://www.zhihu.com/people/liu-xu-cheng-70", 
        "https://www.zhihu.com/people/leo-55-46-56", 
        "https://www.zhihu.com/people/charles-cui-27", 
        "https://www.zhihu.com/people/hu-zhe-23-79", 
        "https://www.zhihu.com/people/nicky-ai", 
        "https://www.zhihu.com/people/seesaw-2", 
        "https://www.zhihu.com/people/eyeyey", 
        "https://www.zhihu.com/people/yang-yang-11-26-34", 
        "https://www.zhihu.com/people/1994m8u2l372012", 
        "https://www.zhihu.com/people/liu-yi-xin-62", 
        "https://www.zhihu.com/people/jixiangfeifei", 
        "https://www.zhihu.com/people/lockon-89", 
        "https://www.zhihu.com/people/li-xiang-25-89", 
        "https://www.zhihu.com/people/fan-xing-zhong", 
        "https://www.zhihu.com/people/sir-30-4", 
        "https://www.zhihu.com/people/min-da-39", 
        "https://www.zhihu.com/people/morphy-10", 
        "https://www.zhihu.com/people/ke-ke-23-12", 
        "https://www.zhihu.com/people/ding-yong-fei-29", 
        "https://www.zhihu.com/people/bohuanshi", 
        "https://www.zhihu.com/people/yao-shuang-rui-57", 
        "https://www.zhihu.com/people/ye-bu-xu", 
        "https://www.zhihu.com/people/ma-er-ji-23", 
        "https://www.zhihu.com/people/wu-ling-5", 
        "https://www.zhihu.com/people/earthxiao-pi-xiong", 
        "https://www.zhihu.com/people/error1996", 
        "https://www.zhihu.com/people/oakenshield-72", 
        "https://www.zhihu.com/people/matthew.he", 
        "https://www.zhihu.com/people/li-xiao-ming-2-53", 
        "https://www.zhihu.com/people/scholze-50", 
        "https://www.zhihu.com/people/li-sheng-da", 
        "https://www.zhihu.com/people/zhou-jie-77-75", 
        "https://www.zhihu.com/people/yin-hai-yang-83", 
        "https://www.zhihu.com/people/xue-shun-yuan", 
        "https://www.zhihu.com/people/zhu-jie-qiang", 
        "https://www.zhihu.com/people/zhan-ge-hui", 
        "https://www.zhihu.com/people/zero-35-40", 
        "https://www.zhihu.com/people/jiu-shi-xi-huan-wan-kr", 
        "https://www.zhihu.com/people/zhou-ming-jin-ke", 
        "https://www.zhihu.com/people/guo-hao-38-7", 
        "https://www.zhihu.com/people/huo-hua-de-41", 
        "https://www.zhihu.com/people/yi-yie-wu-qing-feng", 
        "https://www.zhihu.com/people/rioli", 
        "https://www.zhihu.com/people/zhou-zhen-yi", 
        "https://www.zhihu.com/people/enbark0123", 
        "https://www.zhihu.com/people/yang-zhi-gang-70-1", 
        "https://www.zhihu.com/people/chang-jin-jchang", 
        "https://www.zhihu.com/people/xiong-fu-si-ji", 
        "https://www.zhihu.com/people/xrr0717", 
        "https://www.zhihu.com/people/yang-67-97-18", 
        "https://www.zhihu.com/people/fan-zhen-zhong-23", 
        "https://www.zhihu.com/people/xiong-xue-wei-94", 
        "https://www.zhihu.com/people/wang-chen-zhi-35", 
        "https://www.zhihu.com/people/qinlibo_nlp", 
        "https://www.zhihu.com/people/freedom_forever", 
        "https://www.zhihu.com/people/adam-li-17", 
        "https://www.zhihu.com/people/charming-15", 
        "https://www.zhihu.com/people/kittylion", 
        "https://www.zhihu.com/people/zheng-gao-54-35", 
        "https://www.zhihu.com/people/mei-xi-tuan-zi", 
        "https://www.zhihu.com/people/hen-wen-yi-de-ni-cheng", 
        "https://www.zhihu.com/people/zzx-47-7", 
        "https://www.zhihu.com/people/yiyi-68-12", 
        "https://www.zhihu.com/people/cao-lao-ban-92", 
        "https://www.zhihu.com/people/liang-cai-55", 
        "https://www.zhihu.com/people/chen-chen-86-65", 
        "https://www.zhihu.com/people/xifengwugu", 
        "https://www.zhihu.com/people/xie-xiao-gui", 
        "https://www.zhihu.com/people/mattxia", 
        "https://www.zhihu.com/people/ta-xue-14-33", 
        "https://www.zhihu.com/people/noeltoby", 
        "https://www.zhihu.com/people/da-ben-xiong-de-chang-bi-zi", 
        "https://www.zhihu.com/people/zhangjiyang", 
        "https://www.zhihu.com/people/young0736-20", 
        "https://www.zhihu.com/people/dason", 
        "https://www.zhihu.com/people/ruan-qing-94", 
        "https://www.zhihu.com/people/liu-shi-hao-13-30", 
        "https://www.zhihu.com/people/dong-feng-zao-ji", 
        "https://www.zhihu.com/people/tao-yi-si-21", 
        "https://www.zhihu.com/people/jin-se-liang-dian-ban", 
        "https://www.zhihu.com/people/haimeng-xu-58", 
        "https://www.zhihu.com/people/xu-bo-11-5", 
        "https://www.zhihu.com/people/luozhongbin", 
        "https://www.zhihu.com/people/tou-wong-64", 
        "https://www.zhihu.com/people/lqynydyxf"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/89353177", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 1, 
            "title": "循环神经网络：从RNN到LSTM（学习笔记01）", 
            "content": "<p>人类不会每秒都从头开始思考，也不会像鱼一样，只有七秒钟的记忆。在阅读文章的时候，你会通过先前的每一个单词，每一句话，来了解和思考接下去的每一句话。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而在传统的神经网络中就不能解决这个问题，于是就有了循环神经网络。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是一个典型的循环神经网络：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-969729b9530e38f568493e00719a0b97_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"686\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"686\" data-original=\"https://pic4.zhimg.com/v2-969729b9530e38f568493e00719a0b97_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;686&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"686\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"686\" data-original=\"https://pic4.zhimg.com/v2-969729b9530e38f568493e00719a0b97_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-969729b9530e38f568493e00719a0b97_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这是一个循环神经网络按照时间展开的网络。我们可以看到，每一个时间迭代t时刻，每个神经元都能同时接收到输入向量x(i)和前一个时间迭代是输出量h(t-1)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>RNN</b>可以有以下几种模式：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4f3bd0ae5eb6a9ec1d3c7884d46e1cdd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"543\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb\" width=\"543\" data-original=\"https://pic2.zhimg.com/v2-4f3bd0ae5eb6a9ec1d3c7884d46e1cdd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;543&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"543\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"543\" data-original=\"https://pic2.zhimg.com/v2-4f3bd0ae5eb6a9ec1d3c7884d46e1cdd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4f3bd0ae5eb6a9ec1d3c7884d46e1cdd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>一对多：在第一个时间迭代给网络输入一个单词（其他时间迭代都是零），并让他出输一个序列的向量到序列网络。</li><li>多对一：提供网络一系列的输入并忽略除了最后一个之外的所有输出的序列到向量的网络。</li><li>多对多：同时获得输入序列并产生输出序列的序列到序列网络或者延迟的序列到序列网络。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>当然，和其他深层的神经网络一样，RNN也会遇到梯度消失/爆炸问题。一般我们解决此类问题用的是良好的初始化参数，非饱和激活的方法，批次归一化，梯度剪切，更快的优化器等。但是最简单的方法还是在有限的时间迭代上展开RNN，这种方法被称之为时间截断反向传播。但是这也会带来诸如模型无法学习长期模式，会忽略掉长时间细粒度中的关键信息等问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>除了这个问题，我们还会面对第一个输入的记忆逐渐衰退的问题。由于数据经过RNN的时候会经过转换，所以会丢弃掉一些信息，长时间累加起来后，我们就会失去第一个输入的痕迹，这会对训练产生很大的干扰。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如说：在评价某人之前的第一句话先表明了关系：我是xx的爸爸，我觉得xx如何如何。或者我是xx的远房亲戚的邻居的同学的大姨妈的后院的一条狗，我觉得xx如何如何。在多次迭代后，我们已经失去了第一句话的信息了，但是评价人与xx的关系在评价中具有很大的权重，是至关重要的一个信息，丢失会大大影响训练。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以就有了<b>LSTM</b>！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们先来看一下RNN的模型结构：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f6de21119574cb2beb879eb71c534f1b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"827\" data-rawheight=\"306\" class=\"origin_image zh-lightbox-thumb\" width=\"827\" data-original=\"https://pic4.zhimg.com/v2-f6de21119574cb2beb879eb71c534f1b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;827&#39; height=&#39;306&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"827\" data-rawheight=\"306\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"827\" data-original=\"https://pic4.zhimg.com/v2-f6de21119574cb2beb879eb71c534f1b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f6de21119574cb2beb879eb71c534f1b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们再来看一下LSTM的模型结构：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-97299db4f3e9d43b64783ba02ebd9099_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb\" width=\"822\" data-original=\"https://pic2.zhimg.com/v2-97299db4f3e9d43b64783ba02ebd9099_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;822&#39; height=&#39;293&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"822\" data-original=\"https://pic2.zhimg.com/v2-97299db4f3e9d43b64783ba02ebd9099_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-97299db4f3e9d43b64783ba02ebd9099_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以看到，和RNN相比，LRTM多了一个输入，他把状态分为了两个向量。你可以认为h(t)是短期状态（偏下的那个），c(t)是长期状态（偏上的那个）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在，让我们关注下盒子里面，其关键思维就是可以学习在长期状态下什么要储存，什么要丢弃，以及从什么中读取。我们可以看到，长期记忆c(t-1)从左至右贯穿网络，首先通过一个忘记门，丢失了一些记忆，再通过输入门增加了一些记忆。同时长期记忆一部分被直接输出，一部分被复制后传入tanh函数，然后被输出限制，于是就有了短期状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来让我们看看盒子里的其他东西。主层就是tanh层， 它的主要作用就是分析输入x(y)和前一个短期状态h(t-1)，并直接输出y(t)和h(t)。在RNN中，基本单元就只有这一个层。相比之下，LSTM就没有直接输出，而是将部分输出放在了长期状态中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其他还有一些门限：</p><ul><li>忘记门限：控制哪些长期状态将要被抛弃。</li><li>输入门限：控制哪些部分将要被长期加入到长期状态。</li><li>输出门限：控制哪些长期门限将要在这个迭代被读取和输出。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>简而言之，LSTM单元可以学习识别重要输入，将其储存到长期状态中，学习需要时保护它，以及学习需要时提取它。这就解释了它为什么能成功捕获到时间序列中的长期模式，长文字，录音等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天的学习笔记就分享到这了，我们下回见！~！</p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "RNN", 
                    "tagLink": "https://api.zhihu.com/topics/20086967"
                }, 
                {
                    "tag": "LSTM", 
                    "tagLink": "https://api.zhihu.com/topics/20023220"
                }, 
                {
                    "tag": "神经网络", 
                    "tagLink": "https://api.zhihu.com/topics/19607065"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88921408", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 1, 
            "title": "浅谈类别特征处理", 
            "content": "<p>在XGBoost和其他的Boosting Tree中，使用的Tree都是cart回归树，这也就意味着该类提升树算法只接受数值特征输入，不直接支持类别特征，因为xgboost会把类别型的特征当成数值型。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那我们需要怎么做类别处理呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结起来，大概有两大条：</p><ol><li>对于类别有序的特征，比如age等，是可以当成数值型变量处理。对于非类别有序变量，比如仓库编号，推荐使用one-hot，虽然one-hot会增加内存开销以及训练开销。</li><li>类别型变量在范围较小的时候（如[10-100]），推荐使用。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>xgboost是不支持category特征的，所以在训练模型前，需要进行预处理，可以根据特征的具体形式来选择：</p><ul><li>无序特征：one-hot encoding，比如城市</li><li>有序特征：label encoding，比如版本号</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>one-hot encoding</b></h2><p>一些特征是分类值，而非连续值，比如说城市名称：上海和湖州之间并没有特定的联系，所以我们要对这类特征进行特征数字化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子[&#39;上海&#39;,&#39;杭州&#39;,&#39;株洲&#39;,&#39;湖州&#39;],要将这几个特征数字化。最简单的方式就是[0,2,3,7]，但这并不能直接用于我们的分类器中，因为0，2，3，7只是我们机器随机给的数字，并没有特定的含义，而分类器并不知道这到底是随机的数字还是有其他的含义。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以我们采用独热编码（one-hot encoding）。它实质上就是利用n位寄存器来表示n个状态，且在任何时候，只有一位是有效的。而他的维度是由多少个可能值决定的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再拿上面城市这个栗子来说，一共有四座不同城市，所以对应的独热编码就是[0001,0010,0100,1000]，维度是四维。当然，如果是三座不同的城市，就是[001,010,100]，以此类推。在这期间，这些特征互斥，每次只有一个激活，所以特征也会变得稀疏。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>使用one-hot encoding原因</b></p><p>使用了one-hot编码，就是将离散特征的取值扩展到了欧式空间。在回归分类聚合的机器学习算法中，特征之间的距离计算是很重要的，比如说特征重要性的计算就是基于特征之间的距离的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>基于one-hot编码，特征之间的距离计算更加合理。比如上面的栗子，如果各个城市取三个不同的值，计算出来的特征距离是不合理的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>one-hot encoding的优缺点</b></p><p><b>优点</b>：解决了分类器不好处理数据属性的问题，而它的取值只是0和1，所以不存在距离计算不合理的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>缺点</b>：在类别数量特别多的时候，会使得特征维度变得特别大，造成维数灾难。解决办法一般是使用PCA主成分分析来减少维度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>one-hot encoding使用场景</b></p><p>我们一般用它来解决类别特征的离散值问题，将离散值进行one-hot编码，就是为了让它的距离计算更加合理。如果离散特征不需要one-hot编码就能得到合理的距离计算，那我们就不需要独热编码了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>基于树的方法就不需要特征的归一化了，例如随机森林，bagging，boosting等。对于树模型来说，one-hot就是增加树模型的深度，树模型是没有特征大小的概念的，本质上就是不停地做选择，特征更偏向哪一块的概念。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>实例：</b></p><p>基于sklearn 的one hot encoding：</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"k\">as</span> <span class=\"nn\">pd</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.preprocessing</span> <span class=\"k\">import</span> <span class=\"n\">LabelEncoder</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sklearn.preprocessing</span> <span class=\"k\">import</span> <span class=\"n\">OneHotEncoder</span>\n \n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">([</span>\n    <span class=\"p\">[</span><span class=\"s1\">&#39;tianshi&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;ts&#39;</span><span class=\"p\">,</span> <span class=\"mi\">2017</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span><span class=\"s1\">&#39;rinv&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;baolan&#39;</span><span class=\"p\">,</span> <span class=\"mi\">2018</span><span class=\"p\">],</span>\n    <span class=\"p\">[</span><span class=\"s1\">&#39;xkzn&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;jkl&#39;</span><span class=\"p\">,</span> <span class=\"mi\">2019</span><span class=\"p\">],</span>\n<span class=\"p\">])</span>\n<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">columns</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;name&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;use&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;year&#39;</span><span class=\"p\">]</span>\n \n<span class=\"n\">le_color</span> <span class=\"o\">=</span> <span class=\"n\">LabelEncoder</span><span class=\"p\">()</span>\n<span class=\"n\">le_make</span> <span class=\"o\">=</span> <span class=\"n\">LabelEncoder</span><span class=\"p\">()</span>\n<span class=\"n\">df</span><span class=\"p\">[</span><span class=\"s1\">&#39;color_encoded&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">le_color</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">color</span><span class=\"p\">)</span>\n<span class=\"n\">df</span><span class=\"p\">[</span><span class=\"s1\">&#39;make_encoded&#39;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">le_make</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">make</span><span class=\"p\">)</span>\n \n<span class=\"n\">color_ohe</span> <span class=\"o\">=</span> <span class=\"n\">OneHotEncoder</span><span class=\"p\">()</span>\n<span class=\"n\">make_ohe</span> <span class=\"o\">=</span> <span class=\"n\">OneHotEncoder</span><span class=\"p\">()</span>\n<span class=\"n\">X</span> <span class=\"o\">=</span> <span class=\"n\">color_ohe</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">color_encoded</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">toarray</span><span class=\"p\">()</span>\n<span class=\"n\">Xm</span> <span class=\"o\">=</span> <span class=\"n\">make_ohe</span><span class=\"o\">.</span><span class=\"n\">fit_transform</span><span class=\"p\">(</span><span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">make_encoded</span><span class=\"o\">.</span><span class=\"n\">values</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span><span class=\"o\">.</span><span class=\"n\">toarray</span><span class=\"p\">()</span>\n \n<span class=\"n\">dfOneHot</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&#34;Color_&#34;</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])])</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">concat</span><span class=\"p\">([</span><span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"n\">dfOneHot</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n \n<span class=\"n\">dfOneHot</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">(</span><span class=\"n\">Xm</span><span class=\"p\">,</span> <span class=\"n\">columns</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"s2\">&#34;Make&#34;</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">))</span> <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])])</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">concat</span><span class=\"p\">([</span><span class=\"n\">df</span><span class=\"p\">,</span> <span class=\"n\">dfOneHot</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a8919ce1e451a4a5dec223fc11cd8165_b.png\" data-rawwidth=\"697\" data-rawheight=\"116\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"697\" data-original=\"https://pic2.zhimg.com/v2-a8919ce1e451a4a5dec223fc11cd8165_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;697&#39; height=&#39;116&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"697\" data-rawheight=\"116\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"697\" data-original=\"https://pic2.zhimg.com/v2-a8919ce1e451a4a5dec223fc11cd8165_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a8919ce1e451a4a5dec223fc11cd8165_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>基于pandas的one hot encoding：</p><p>在 pandas 中用自带的get_dummies函数即可</p><div class=\"highlight\"><pre><code class=\"language-text\"> df = pd.DataFrame([\n    [&#39;tianshi&#39;, &#39;ts&#39;, 2017],\n    [&#39;rinv&#39;, &#39;baolan&#39;, 2018],\n    [&#39;xkzn&#39;, &#39;jkl&#39;, 2019],\n])\ndf.columns = [&#39;name&#39;, &#39;use&#39;, &#39;year&#39;]\n \n \ndf_processed = pd.get_dummies(df, prefix_sep=&#34;_&#34;, columns=df.columns[:-1])\nprint(df_processed)</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-be42b83f0601e827e7e23f488a2b68ce_b.png\" data-rawwidth=\"169\" data-rawheight=\"115\" data-size=\"normal\" data-caption=\"\" class=\"content_image\" width=\"169\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;169&#39; height=&#39;115&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"169\" data-rawheight=\"115\" data-size=\"normal\" data-caption=\"\" class=\"content_image lazy\" width=\"169\" data-actualsrc=\"https://pic3.zhimg.com/v2-be42b83f0601e827e7e23f488a2b68ce_b.png\"/></figure><p>get_dummies的优势在于:</p><ol><li>本身就是 pandas 的模块，所以对 DataFrame 类型兼容很好</li><li>不管你列是数值型还是字符串型，都可以进行二值化编码</li><li>能够根据指令，自动生成二值化编码后的变量名</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Label encoding</b></h2><p>label encoding是使用字典的形式，将每个不同的类别标签和不断增加的整数关联，即生成一个数组索引。 </p><div class=\"highlight\"><pre><code class=\"language-text\">from sklearn.preprocessing import LabelEncoder\n \nle = LabelEncoder()\n \ncity_list = [&#34;paris&#34;, &#34;paris&#34;, &#34;tokyo&#34;, &#34;amsterdam&#34;]\n \nle.fit(city_list)\nprint(le.classes_)  # 输出为：[&#39;amsterdam&#39; &#39;paris&#39; &#39;tokyo&#39;]\n \ncity_list_le = le.transform(city_list)  # 进行Encode\nprint(city_list_le)  # 输出为：[1 1 2 0]\n \ncity_list_new = le.inverse_transform(city_list_le)  # 进行decode\nprint(city_list_new) # 输出为：[&#39;paris&#39; &#39;paris&#39; &#39;tokyo&#39; &#39;amsterdam&#39;]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>如果是多列，该怎么进行编码呢？</p><div class=\"highlight\"><pre><code class=\"language-text\">from sklearn.preprocessing import LabelEncoder\nfrom collections import defaultdict\nimport pandas as pd\n \nd = defaultdict(LabelEncoder)\n \ndf = pd.DataFrame({\n    &#39;pets&#39;: [&#39;cat&#39;, &#39;dog&#39;, &#39;cat&#39;, &#39;monkey&#39;, &#39;dog&#39;, &#39;dog&#39;],\n    &#39;owner&#39;: [&#39;Champ&#39;, &#39;Ron&#39;, &#39;Brick&#39;, &#39;Champ&#39;, &#39;Veronica&#39;, &#39;Ron&#39;],\n    &#39;location&#39;: [&#39;San_Diego&#39;, &#39;New_York&#39;, &#39;New_York&#39;, &#39;San_Diego&#39;, &#39;San_Diego&#39;,\n                 &#39;New_York&#39;]\n})\n \n\n# Encoding the variable\nfit = df.apply(lambda x: d[x.name].fit_transform(x))\n \n# Inverse the encoded\nfit.apply(lambda x: d[x.name].inverse_transform(x))\n \n# Using the dictionary to label future data\ndf.apply(lambda x: d[x.name].transform(x))</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a87d9f1f7ae3fac49cb2639d50bb87e4_b.png\" data-rawwidth=\"180\" data-rawheight=\"190\" data-size=\"normal\" data-caption=\"\" class=\"content_image\" width=\"180\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;180&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"180\" data-rawheight=\"190\" data-size=\"normal\" data-caption=\"\" class=\"content_image lazy\" width=\"180\" data-actualsrc=\"https://pic1.zhimg.com/v2-a87d9f1f7ae3fac49cb2639d50bb87e4_b.png\"/></figure><p>今天就将讲到这了，下次再和你们分享！~！</p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "数据预处理", 
                    "tagLink": "https://api.zhihu.com/topics/19965355"
                }, 
                {
                    "tag": "xgboost", 
                    "tagLink": "https://api.zhihu.com/topics/20035241"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>题目写错了</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "风轻袖影翻", 
                            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
                            "content": "改好了😂", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "yiduobo", 
                    "userLink": "https://www.zhihu.com/people/f5a6560b1146eae538a5929c7e75c19d", 
                    "content": "可以了解一下lightgbm，在二分类的情况下对category类的特征有更好的处理能力", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "风轻袖影翻", 
                            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
                            "content": "这个主要是我查完资料整理下顺手写了篇文章，不过lgb确实好用", 
                            "likes": 0, 
                            "replyToAuthor": "yiduobo"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83983383", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 2, 
            "title": "2019讯飞开发者大赛营销算法赛复盘", 
            "content": "<p>最近刚打完讯飞开发者大赛营销算法大赛，进了复赛，但后期因为个人原因以及硬件资源上的缺失，止步决赛。</p><p>这里做一个比赛总结，包含自己的方案，也参考了开赛以来各位选手的开源。作为一个刚开始打比赛的菜鸟，算是对一个多月来的比赛做一个交代。</p><h2><b>一.EDA</b></h2><p>首先进行数据探索分析，了解数据集。数据探索分析主要做以下几个部分的工作:</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.</b>查看每个数据特征的缺失情况、特征中是否含有异常点，错误值。</p><p><b>2.</b>查看每个特征的分布情况，主要包括连续特征是否存在偏移，也就是不服从正态分布的情况；离散特征的值具体分布。</p><p><b>3.</b>查看一般特征之间的相关性以及一般特征与目标特征之间的相关性。</p><p><b>4.</b>查看0，1样本之间是否平衡，有无违反“相同分布”的假设（如有大佬就提出idfamd5和adidmd5连个特征在训练集和测试集分布极度不平衡）</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二.数据预处理</b></h2><p>接下来就针对EDA部分得出的结果，来进行数据的预处理工作,主要做了以下工作:</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.</b>先是对特征中不符合类型的数据进行类别转换（如model替换成相应手机型号，ntt清洗，make替换成相应厂商），进一步减少数据的噪声。</p><p><b>2.</b>利用众数来对缺失值填充，异常值的剔除，以及错误值进行修正。</p><p>关于这一点，可以参考知乎上的回答<a href=\"https://www.zhihu.com/question/34725788\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/question/3472</span><span class=\"invisible\">5788</span><span class=\"ellipsis\"></span></a></p><p><b>3.</b>有些连续特征分布不均匀，对于前面的数据可能出现上万次，但是到后面的数据仅仅只有1、2次，可以直接选择排名前N位的数据， 对于后面的数据我们直接归为一类。或者直接使用对数或者Box-Cox进行转换，使其满足正太分布。</p><p><b>4.</b>对于离散值，使用类别编码(LabelEncoder)来对离散特征进行编码，对部分连续特征进行分箱操作，将其离散化。</p><p><b>5.</b>增加新特征，如size,ratio,px,mj,ip的子字段,day,hour,day_of_week等。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>三.特征工程</b></h2><p>这个比赛可以参考的是kaggle上的TalkingData AdTracking Fraud Detection Challenge和IEEE两个比赛，但是我之前试了前两个比赛的方案，发现效果并不好。</p><p>个人觉得原因主要是因为kaggle上的比赛，重要信息主要在时间中，所以类似于next_click以及衍生的特征重要度很高。而这个比赛的重要信息主要在IP，pkgname等特征及其衍生的交叉特征中，所以我在后期开始放弃复现kernel，尝试着从业务角度来做特征工程。</p><p>我的特征工程主要由以下几部分构成：</p><p><b>一. </b>原始特征 </p><p><b>二.</b> 统计特征 ： 对于一些强特征做了大量的统计特征，如mean，max，min，count，var，cumcount，nunique等。</p><p><b>三.</b> 组合特征 : 将重要性较高的特征与其他的特征进行组合。</p><p><b>四. </b>从业务角度分析构造新的特征，具体尝试如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.</b>IP离散度密集：可能会出现同一个IP反复点击广告的情况出现，造成过度访问/重复访问的问题，我尝试了设置用户（day,hour,minute）点击阈值。</p><p><b>2.</b>同IP段的多次激活也可以认为异常激活，如来自同一IP地址的多次点击或者同一广告点击IP大部分来自同一地理区域。</p><p><b>3.</b>时间周期反复：同IP离散度密集的原理一样，作弊用户会在一个固定的时间周期内频繁的点击广告（发送请求），或者说是每(week,day,hour,day_week)多次有规律的访问</p><p><b>4.</b>归因时间差：正常情况下用户从点击广告，到产生激活行为，需要一定量的时间阅览了解，若这个时间太短，我认为可能有异常。</p><p><b>5.</b>点击时间差，包括间隔一次和两次之间的点击时间差，顺便从中得到top_counts，top2_counts，top3_counts，同时尝试了按天抽取特征。</p><p><b>6.</b>比率特征: 如每个ip-广告的点击与每个广告的点击之比</p><p><b>7.</b>能否运用外部数据基于历史信息和行业平均水平来判断（后期又说不能用外部数据了==）。</p><p><b>8.</b>有用户点击后会被免费赠送流量，如用户点击一次后，作弊方就获取了用户的 IP 和 cookie，于是就赠送几次点击，有大佬提出傅立叶变换（见参考资料《互联网广告作弊十八般武艺（上）》），即将时域的点击放到频域上来，这样频域中哪些点击数是包含大礼包的就很显然了。</p><p><b>17.</b>频繁地变更用户身份：在比赛中，有选手放出了和官方的聊天截图，即如果排除脏数据，用户是可以改变设备信息的，如果是正常用户为啥需要改变设备信息呢？</p><p><b>9.</b>尝试找出肉鸡：如操作系统的比重。</p><p><b>10.</b>有没有做honey ad，能否找出来。</p><p><b>11.</b>是否为全新流量，即第一次访问。</p><p><b>12.</b>判断广告点击率是否过高。</p><p><b>13.</b>客户信息的完整度。</p><p><b>14.</b>点击点在屏幕中会有一个坐标，同一坐标重复过多会被怀疑是机器行为，视为作弊。（这个我不知道怎么实现。。。）</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>注：</b>有些idea效果好，有些不太理想，我都放上来了，排名不分先后哈哈</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>四.训练及验证</b></h2><p>跑的模型主要是lgb和xgb，尝试过使用catboost。</p><p>我对每做一个新的特征都会进行线上验证（大佬就构建和线上一致的线下验证，菜鸟就老老实实线上验证），每个模型的特征重要度都是不一样的，如xgb，lgb和catboost给的特征重要性排行就完全不一样，这涉及到特征重要度的计算原理。</p><p>不管怎么说，还是尽量构造一个比较稳定一致的，和测试集分布接近的线下验证集比较靠谱。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>五.反思和总结：</b></h2><p><b>1.</b>最终我一共构造了244维度，共12g的data，导致我在跑catboost的时候屡次失败。</p><p>原因第一是因为我没做好特征选择，第二是我没有尝试PCA降维，后期看有大佬使用PCA进行降维，152个特征进行PCA降维之后仅仅用20个特征解释率就能达到99%，学习了。</p><p><b>2.</b>可以尝试利用lgb和xgb模型来生成部分叶子节点特征。</p><p><b>3.</b>特征选择主要依赖树型结构中的重要性特征选择方法以及线下线上验证，可以尝试其他选择方法，如高百分比的缺失值特征选择法，高度相关特征选择方法(如果一般变量之间的相关性很高，则可去掉其中的某些特征)，低重要性特征选择方法，唯一值特征选择方法。</p><p><b>4.</b>最后只把效果不错的submit做了个merge，没有尝试多模型的融合，来进行提分，下个比赛尝试集成学习，bagging,boosting,stacking,blending。</p><p>可以看下其他大佬分享的融合方案：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/dTJKTgSffft31jhqsJOmrQ\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s/dTJK</span><span class=\"invisible\">TgSffft31jhqsJOmrQ</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>六.参考资料</b></h2><p><b>其他大佬的分享：</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jiangzhongkai/ifly-algorithm_challenge\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/jiangzhongka</span><span class=\"invisible\">i/ifly-algorithm_challenge</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_41776781/article/details/100868083\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_417767</span><span class=\"invisible\">81/article/details/100868083</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_41776781/article/details/97387261\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/qq_417767</span><span class=\"invisible\">81/article/details/97387261</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/sleepingxin/XF2019_Fraud_Detection\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/sleepingxin/</span><span class=\"invisible\">XF2019_Fraud_Detection</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/bochuanwu/IFLY_advertisement-cheating_2019\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/bochuanwu/IF</span><span class=\"invisible\">LY_advertisement-cheating_2019</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>参考资料：</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Onp15qJluqPDXJnUXLsU_Q\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s/Onp1</span><span class=\"invisible\">5qJluqPDXJnUXLsU_Q</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/H1r3Sc3eAFjS4R8rFBMooA\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s/H1r3</span><span class=\"invisible\">Sc3eAFjS4R8rFBMooA</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/X8G0QaScFjUHxFd8RRqBuA\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s/X8G0</span><span class=\"invisible\">QaScFjUHxFd8RRqBuA</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/O2jW5joWV8OGMT7SKp/article/details/78129831\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/O2jW5joWV</span><span class=\"invisible\">8OGMT7SKp/article/details/78129831</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/u011627980/article/details/85167167\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/u01162798</span><span class=\"invisible\">0/article/details/85167167</span><span class=\"ellipsis\"></span></a></p><p><b> <a href=\"https://link.zhihu.com/?target=http%3A//www.ouyangchen.com/download\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ouyangchen.com/download</span><span class=\"invisible\"></span></a></b></p><p>《Measuring and Fingerprinting Click-Spam in Ad Networks》Vacha Dave etc. </p><p>2014，《DECAF: Detecting and Characterizing Ad Fraud in Mobile Apps》</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下哈！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "科大讯飞", 
                    "tagLink": "https://api.zhihu.com/topics/19569325"
                }, 
                {
                    "tag": "反欺诈", 
                    "tagLink": "https://api.zhihu.com/topics/20057362"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70983652", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "leetcode刷题(十六）：数学2（字符串加法减法，相遇问题，多数投票问题，etc）", 
            "content": "<p>大家好，这是leetcode刷题系列的最后一篇文章了，接下去我会更新一些其他方面的文章。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我明年找工作的时候应该会再出一些刷题笔记。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>希望大家学业进步，月月加薪。</p><h2><b>67. 二进制求和</b></h2><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为非空字符串且只包含数字 1 和 0。</p><p><br/>示例 1:</p><p>输入: a = &#34;11&#34;, b = &#34;1&#34;</p><p>输出: &#34;100&#34;</p><p><br/>示例 2:</p><p>输入: a = &#34;1010&#34;, b = &#34;1011&#34;</p><p>输出: &#34;10101&#34;</p><p><br/><b>方法一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def addBinary(self, a, b):\n        return bin(int(a,2) + int(b,2))[2:]</code></pre></div><p><br/><b>方法二：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def addBinary(self, a: str, b: str) -&gt; str:\n\n        # 短字符串前端补零，保证两者长度相等\n        if len(a) &gt; len(b):\n            b = &#39;0&#39;* (len(a)-len(b)) + b\n        elif len(a) &lt; len(b):\n            a = &#39;0&#39;* (len(b) - len(a)) + a\n\n\n        res, carry = &#39;&#39;, &#39;0&#39;\n        for a_, b_ in reversed(list(zip(a, b))):\n \n            if a_ == &#39;0&#39; and b_ == &#39;0&#39;:                                 # 当前位两个数都是0\n                r = carry\n                carry = &#39;0&#39;\n            elif a_ == &#39;1&#39; and b_ == &#39;0&#39; or a_ == &#39;0&#39; and b_ == &#39;1&#39;:    # 当前位两个数不同\n                r = &#39;1&#39; if carry == &#39;0&#39; else &#39;0&#39;\n                carry = &#39;1&#39; if carry == &#39;1&#39; else &#39;0&#39;\n            else:                                                       # 当前位两个数都是1\n                r = &#39;1&#39; if carry == &#39;1&#39; else &#39;0&#39;\n                carry = &#39;1&#39;\n\n\n            res = r + res\n\n\n        if carry == &#39;1&#39;:                                                # 如果还有进位\n            res = &#39;1&#39; + res\n \n        return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>415. 字符串相加</b></h2><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p><br/>注意：</p><p>num1 和num2 的长度都小于 5100.</p><p>num1 和num2 都只包含数字 0-9.</p><p>num1 和num2 都不包含任何前导零。</p><p>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def addStrings(self, num1, num2):\n        &#34;&#34;&#34;\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        &#34;&#34;&#34;\n        l = max(len(num1),len(num2))\n        num1 = num1.zfill(l)\n        num2 = num2.zfill(l)\n \n        p = 0\n        r = &#39;&#39;\n        for i in range(l):\n            n1 = num1[l-i-1]\n            n2 = num2[l-i-1]\n            rr = int(n1) + int(n2) + p\n            p = rr // 10\n            r = str(rr%10) + r\n        if p:\n            r = &#39;1&#39; + r \n        return r</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>462. 最少移动次数使数组元素相等 II</b></h2><p>给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。</p><p><br/>例如:</p><p>输入:</p><p>[1,2,3]</p><p>输出:</p><p>2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>说明：</p><p>只有两个动作是必要的（记得每一步仅可使其中一个元素加1或减1）： </p><p>[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def minMoves2(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        mid = (len(nums) - 1 )/ 2 \n        nums = sorted(nums)\n        result = 0\n        for i in nums:\n            result += abs(nums[mid] - i)\n        return result</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>169. 求众数</b></h2><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [3,2,3]</p><p>输出: 3</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [2,2,1,1,1,2,2]</p><p>输出: 2</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法一：摩尔投票法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def majorityElement(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        count = 1\n        tmp = nums[0]\n        for i in range(1,len(nums)):\n            if count == 0:\n                tmp = nums[i]\n            if tmp == nums[i]:\n                count += 1\n            else:\n                count -= 1\n        return tmp</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法二：排序找中位数法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def majorityElement(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        nums.sort()\n        return nums[len(nums)//2]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>367. 有效的完全平方数</b></h2><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p><p>说明：不要使用任何内置的库函数，如  sqrt。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1：</p><p>输入：16</p><p>输出：True</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2：</p><p>输入：14</p><p>输出：False</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法一：最简单的遍历</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPerfectSquare(self, num):\n        &#34;&#34;&#34;\n        :type num: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        for i in range(num+1):\n            if i**2 &gt; num:\n                return False\n            if i**2 == num:\n                return True </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法二：一种很奇妙的想法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPerfectSquare(self, num):\n        &#34;&#34;&#34;\n        :type num: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        return int(num**0.5) == num**0.5</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法三：二分法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPerfectSquare(self, num):\n        &#34;&#34;&#34;\n        :type num: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        left,right = 0,num\n        while left &lt;= right:\n            mid = left + (right - left) // 2\n            if mid**2 == num:\n                return True \n            elif mid**2 &lt; num:\n                left = mid + 1\n            else:\n                right = mid - 1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>628. 三个数的最大乘积</b></h2><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [1,2,3]</p><p>输出: 6</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [1,2,3,4]</p><p>输出: 24</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意:</p><p>给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。</p><p>输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maximumProduct(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        nums.sort()\n        res = [nums[0]*nums[1]*nums[-1],nums[-1]*nums[-2]*nums[-3]]\n        return max(res)</code></pre></div><p>希望本文能对你有所帮助！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68809532", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "阶乘leetcode刷题(十五）：数学1（素数，最大公约数，进制转换，阶乘）", 
            "content": "<p>今天来讲讲剩下几块内容：素数，最大公约数，进制转换，阶乘.</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>素数</b></h2><p><b>素数分解</b></p><p>每一个数都可以分解成素数的乘积，例如 84 = 2^2 * 3^1 * 5^0 * 7^1 * 11^0 * 13^0 * 17^0 * …</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>整除</b></p><p>令 x = 2^m0 * 3^m1 * 5^m2 * 7^m3 * 11^m4 * … 令 y = 2^n0 * 3^n1 * 5^n2 * 7^n3 * 11^n4 * …</p><p>如果 x 整除 y（y mod x == 0），则对于所有 i，mi &lt;= ni。</p><p>x 和 y 的 最大公约数 为：gcd(x,y) = 2^min(m0,n0) * 3^min(m1,n1) * 5^min(m2,n2) * ...</p><p>x 和 y 的 最小公倍数 为：lcm(x,y) = 2^max(m0,n0) * 3^max(m1,n1) * 5^max(m2,n2) * ...</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>最大公约数</b></h2><p>对于最大公约数问题，因为需要计算 a % b ，而这个操作是比较耗时的，可以利用减法和移位操作来替换它。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于 a 和 b 的最大公约数 f(a, b)，有：</p><p><br/>1. 如果 a 和 b 均为偶数，f(a, b) = 2*f(a/2, b/2);</p><p>2. 如果 a 是偶数 b 是奇数，f(a, b) = f(a/2, b); </p><p>3. 如果 b 是偶数 a 是奇数，f(a, b) = f(a, b/2); </p><p>4. 如果 a 和 b 均为奇数，f(a, b) = f(a, a-b);</p><p class=\"ztext-empty-paragraph\"><br/></p><p>乘 2 和除 2 都可以转换为移位操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>204. 计数质数</b></h2><p>统计所有小于非负整数 n 的质数的数量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>输入: 10</p><p>输出: 4</p><p>解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这题搜到一个非常牛逼的算法,叫做厄拉多塞筛法. 比如说求20以内质数的个数,首先0,1不是质数.2是第一个质数,然后把20以内所有2的倍数划去.2后面紧跟的数即为下一个质数3,然后把3所有的倍数划去.3后面紧跟的数即为下一个质数5,再把5所有的倍数划去.以此类推.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>代码的实现上用了非常好的技巧:</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">def countPrimes(self, n: int) -&gt; int:\n        if n &lt; 3:\n            return 0     \n        else:\n            # 首先生成了一个全部为1的列表\n            output = [1] * n\n            # 因为0和1不是质数,所以列表的前两个位置赋值为0\n            output[0],output[1] = 0,0\n             # 此时从index = 2开始遍历,output[2]==1,即表明第一个质数为2,然后将2的倍数对应的索引\n             # 全部赋值为0. 此时output[3] == 1,即表明下一个质数为3,同样划去3的倍数.以此类推.\n            for i in range(2,int(n**0.5)+1): \n                if output[i] == 1:\n                    output[i*i:n:i] = [0] * len(output[i*i:n:i])\n         # 最后output中的数字1表明该位置上的索引数为质数,然后求和即可.\n        return sum(output)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>在上面遍历索引的时候用到了一个非常好的技巧. 即i是从(2,int(n**0.5)+1)而非(2,n).这个技巧是可以验证的,比如说求9以内的质数个数,那么只要划掉sqrt(9)以内的质数倍数,剩下的即全为质数. 所以在划去倍数的时候也是从i*i开始划掉,而不是i+i.</p><p><br/>这个解法真是太赞了!又学到了很多~~~ 和大家分享一下</p><h2><br/><b>504. 七进制数</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个整数，将其转化为7进制，并以字符串形式输出。</p><p><br/>示例 1:</p><p>输入: 100</p><p>输出: &#34;202&#34;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: -7</p><p>输出: &#34;-10&#34;</p><p>注意: 输入范围是 [-1e7, 1e7] 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def convertToBase7(self, num):\n        &#34;&#34;&#34;\n        :type num: int\n        :rtype: str\n        &#34;&#34;&#34;\n        A = []\n        if num == 0:\n            return &#34;0&#34;\n        if num &lt; 0:\n            s = &#39;-&#39;\n        else:\n            s = &#39;&#39;\n        num = abs(num)\n        while(num &gt; 0):\n            A.append(num % 7)\n            num = num // 7 \n        A = A[::-1]\n        for i in A:\n            s = s + str(i)\n        return s</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>172. 阶乘后的零</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><p><br/>示例 1:</p><p>输入: 3</p><p>输出: 0</p><p>解释: 3! = 6, 尾数中没有零。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: 5</p><p>输出: 1</p><p>解释: 5! = 120, 尾数中有 1 个零.</p><p>说明: 你算法的时间复杂度应为 O(log n) 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def trailingZeroes(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n \n        if n &lt; 5:\n            return 0\n        else:\n            m = 1\n            sum = 0\n            while n&gt;= (5**m):\n                sum += n // (5**m)\n                m += 1\n        return sum</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>67. 二进制求和</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p><br/>输入为非空字符串且只包含数字 1 和 0。</p><p><br/>示例 1:</p><p>输入: a = &#34;11&#34;, b = &#34;1&#34;</p><p>输出: &#34;100&#34;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: a = &#34;1010&#34;, b = &#34;1011&#34;</p><p>输出: &#34;10101&#34;</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法一：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def addBinary(self, a, b):\n        return bin(int(a,2) + int(b,2))[2:]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法二：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def addBinary(self, a: str, b: str) -&gt; str:\n        # 短字符串前端补零，保证两者长度相等\n\n        if len(a) &gt; len(b):\n            b = &#39;0&#39;* (len(a)-len(b)) + b\n        elif len(a) &lt; len(b):\n            a = &#39;0&#39;* (len(b) - len(a)) + a\n\n        res, carry = &#39;&#39;, &#39;0&#39;\n        for a_, b_ in reversed(list(zip(a, b))):\n \n            if a_ == &#39;0&#39; and b_ == &#39;0&#39;:                                 # 当前位两个数都是0\n                r = carry\n                carry = &#39;0&#39;\n            elif a_ == &#39;1&#39; and b_ == &#39;0&#39; or a_ == &#39;0&#39; and b_ == &#39;1&#39;:    # 当前位两个数不同\n                r = &#39;1&#39; if carry == &#39;0&#39; else &#39;0&#39;\n                carry = &#39;1&#39; if carry == &#39;1&#39; else &#39;0&#39;\n            else:                                                       # 当前位两个数都是1\n                r = &#39;1&#39; if carry == &#39;1&#39; else &#39;0&#39;\n                carry = &#39;1&#39;\n\n            res = r + res\n\n        if carry == &#39;1&#39;:                                                # 如果还有进位\n            res = &#39;1&#39; + res\n        return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>415. 字符串相加</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</p><p>注意：</p><p><br/>num1 和num2 的长度都小于 5100.</p><p>num1 和num2 都只包含数字 0-9.</p><p>num1 和num2 都不包含任何前导零。</p><p>你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def addStrings(self, num1, num2):\n        &#34;&#34;&#34;\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        &#34;&#34;&#34;\n        l = max(len(num1),len(num2))\n        num1 = num1.zfill(l)\n        num2 = num2.zfill(l)\n \n        p = 0\n        r = &#39;&#39;\n        for i in range(l):\n            n1 = num1[l-i-1]\n            n2 = num2[l-i-1]\n            rr = int(n1) + int(n2) + p\n            p = rr // 10\n            r = str(rr%10) + r\n        if p:\n            r = &#39;1&#39; + r \n        return r</code></pre></div><p>希望本文能对你有所帮助！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67865694", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 2, 
            "title": "leetcode刷题(十四）：动态规划3（0-1 背包，数组区间，字符串编辑，etc）", 
            "content": "<p>这是动态规划的最后一个章节了，主要讲讲0-1 背包，数组区间，字符串编辑和其他一些动态规划的经典问题，那我们开始吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>0-1 背包</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>问题描述</b>：有n 个物品，它们有各自的重量和价值，现有给定容量的背包，如何让背包里装入的物品具有最大的价值总和？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>总体思路</b>：根据动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）找出01背包问题的最优解以及解组成，然后编写代码实现；</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>区间动态规划</b></h2><p>区间 DP是指在一段区间上进行的一系列动态规划。 对于区间 DP 这一类问题，我们需要计算区间 [1,n] 的答案，通常用一个二维数组 dp 表示，其中 dp[x][y] 表示区间 [x,y]。</p><p>有些题目，dp[l][r] 由 dp[l][r−1] 与 dp[l+1][r] 推得；也有些题目，我们需要枚举区间 [l,r] 内的中间点，由两个子问题合并得到，也可以说 dp[l][r] 由 dp[l][k] 与 dp[k+1][r] 推得，其中 l≤k&lt;r。 对于长度为 n 的区间 DP，我们可以先计算 [1,1],[2,2]…[n,n] 的答案，再计算 [1,2],[2,3]…[n−1,n]，以此类推，直到得到原问题的答案。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是真题时间，这次真题有点多，可以慢慢看看。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>416. 分割等和子集</b></h2><p>给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p>注意:</p><p>每个数组中的元素不会超过 100</p><p>数组的大小不会超过 200</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [1, 5, 11, 5]</p><p>输出: true</p><p>解释: 数组可以分割成 [1, 5, 5] 和 [11].</p><p>示例 2:</p><p>输入: [1, 2, 3, 5]</p><p>输出: false</p><p>解释: 数组不能分割成两个元素和相等的子集.<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def canPartition(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: bool\n        &#34;&#34;&#34;\n        sum_nums = sum(nums)\n        if sum_nums%2 != 0:\n            return False\n        avg = sum_nums//2\n        n = len(nums)\n \n        dp = [[1] + [0] * avg for _ in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,avg + 1):\n                dp[i][j] = dp[i-1][j]\n                if j-nums[i-1] &gt;= 0:\n                    if dp[i][j] == 0 and dp[i-1][j-nums[i-1]] == 1:\n                        dp[i][j] = 1\n        return True if dp[-1][-1] == 1 else False</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>139. 单词拆分</b></h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。</p><p>说明：</p><p>拆分时可以重复使用字典中的单词。</p><p>你可以假设字典中没有重复的单词。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1：</p><p>输入: s = &#34;leetcode&#34;, wordDict = [&#34;leet&#34;, &#34;code&#34;]</p><p>输出: true</p><p>解释: 返回 true 因为 &#34;leetcode&#34; 可以被拆分成 &#34;leet code&#34;。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2：</p><p>输入: s = &#34;applepenapple&#34;, wordDict = [&#34;apple&#34;, &#34;pen&#34;]</p><p>输出: true</p><p>解释: 返回 true 因为 &#34;applepenapple&#34; 可以被拆分成 &#34;apple pen apple&#34;。</p><p>     注意你可以重复使用字典中的单词。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 3：</p><p>输入: s = &#34;catsandog&#34;, wordDict = [&#34;cats&#34;, &#34;dog&#34;, &#34;sand&#34;, &#34;and&#34;, &#34;cat&#34;]</p><p>输出: false</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def wordBreak(self, s, wordDict):\n        &#34;&#34;&#34;\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        &#34;&#34;&#34;\n        if not s:\n            return True\n        temp = [0]\n \n        for i in range(len(s) + 1):\n            for j in temp:\n                if s[j:i] in wordDict:\n                    temp.append(i)\n                    break\n        return temp[-1] == len(s)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>494. 目标和</b></h2><p>给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。</p><p><br/>返回可以使最终数组和为目标数 S 的所有添加符号的方法数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: nums: [1, 1, 1, 1, 1], S: 3</p><p>输出: 5</p><p>解释: </p><p>-1+1+1+1+1 = 3</p><p>+1-1+1+1+1 = 3</p><p>+1+1-1+1+1 = 3</p><p>+1+1+1-1+1 = 3</p><p>+1+1+1+1-1 = 3<br/></p><p>一共有5种方法让最终目标和为3。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def findTargetSumWays(self, nums, S):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type S: int\n        :rtype: int\n        &#34;&#34;&#34;\n        sum_n = sum(nums)\n        if (sum_n+S) % 2 != 0 or sum_n&lt;S:\n            return 0\n        return self.get_nums(nums,(S+sum_n)//2)\n \n    def get_nums(self,nums,S):\n        dp = [0]*(S+1)\n        dp[0] = 1\n        for num in nums:\n            for i in range(S,num-1,-1):\n                dp[i] += dp[i-num]\n        return dp[S]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>322. 零钱兑换</b></h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p><br/>示例 1:</p><p>输入: coins = [1, 2, 5], amount = 11</p><p>输出: 3 </p><p>解释: 11 = 5 + 5 + 1</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: coins = [2], amount = 3</p><p>输出: -1</p><p>说明:</p><p>你可以认为每种硬币的数量是无限的。</p><p>dp[i]表示金额为i需要最少的金额多少,</p><p>对于任意金额j,dp[j] = min(dp[j],dp[j-coin]+1),如果j-coin存在的话.</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def coinChange(self, coins, amount):\n        &#34;&#34;&#34;\n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        &#34;&#34;&#34;\n        dp = [float(&#34;inf&#34;)] * (amount+1)\n        dp[0] = 0\n        for i in range(1,amount+1):\n\n\n            for coin in coins:\n                if i &gt;= coin and dp[int(i - coin)] != float(&#39;inf&#39;):\n                    dp[i] = min(dp[i],dp[i-coin]+1)\n        # print(dp)\n        return dp[-1] if dp[-1]!= float(&#34;inf&#34;) else -1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>121. 买卖股票的最佳时机</b></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]</p><p>输出: 5</p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p><p>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [7,6,4,3,1]</p><p>输出: 0</p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxProfit(self, prices):\n        &#34;&#34;&#34;\n        :type prices: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(prices)\n        min_p,max_p = 99999,0\n        for i in range(n):\n            min_p = min(min_p,prices[i])\n            max_p = max(max_p,prices[i] - min_p)\n        return max_p</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>303. 区域和检索 - 数组不可变</b></h2><p>给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。</p><p><br/>示例：</p><p>给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()</p><p>sumRange(0, 2) -&gt; 1</p><p>sumRange(2, 5) -&gt; -1</p><p>sumRange(0, 5) -&gt; -3</p><p>说明:</p><p>你可以假设数组不可变。</p><p>会多次调用 sumRange 方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class NumArray(object):\n    def __init__(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        &#34;&#34;&#34;\n        self.nums = nums\n\n\n    def sumRange(self, i, j):\n        &#34;&#34;&#34;\n        :type i: int\n        :type j: int\n        :rtype: int\n        &#34;&#34;&#34;\n        return sum(self.nums[i:j+1])</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>413. 等差数列划分</b></h2><p>如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。</p><p>例如，以下数列为等差数列:</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1, 3, 5, 7, 9</p><p>7, 7, 7, 7</p><p>3, -1, -5, -9</p><p>以下数列不是等差数列。</p><p>1, 1, 2, 5, 7</p><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。<br/></p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>元素 A[P], A[p + 1], ..., A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>A = [1, 2, 3, 4]</p><p>返回: 3, A 中有三个子等差数组: [1, 2, 3], [2, 3, 4] 以及自身 [1, 2, 3, 4]。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>说明</b>：dp[i] 表示比A[:i]到A[:i+1]新增加的等差数列子数组个数</p><p>拿[1,2,3,4]来说 1,2,3是等差数列，所有dp[2]=1,2,3,4相比于1,2,3来说增加了[2,3,4],[1,2,3,4]两个等差数列</p><p>对于[1,2,3,4,5],dp[4]新增加了[2,3,4,5],[3,4,5],[1,2,3,4,5],所以dp[5]=dp[4]+1=5</p><p>对于[1,2,3,4,5,7] 由于在7这里中断了前面等差数列,没有增加子等差数组,后面又就需要重新计数了</p><p>对于整个序列A,最后结果的就是sum(dp)</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def numberOfArithmeticSlices(self, A):\n        &#34;&#34;&#34;\n        :type A: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(A)\n        dp = [0] * n\n        for i in range(2,n):\n            if A[i] - A[i-1] == A[i-1] -A[i-2]:\n                dp[i] = dp[i-1] + 1\n        return sum(dp)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>583. 两个字符串的删除操作</b></h2><p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><p>示例 1:</p><p>输入: &#34;sea&#34;, &#34;eat&#34;</p><p>输出: 2</p><p>解释: 第一步将&#34;sea&#34;变为&#34;ea&#34;，第二步将&#34;eat&#34;变为&#34;ea&#34;</p><p>说明:</p><p>给定单词的长度不超过500。</p><p>给定单词中的字符只含有小写字母。</p><p><br/><b>思路</b>：这道题给了我们两个单词，问我们最少需要多少步可以让两个单词相等，每一步我们可以在任意一个单词中删掉一个字符。可以用dp来做，就定义一个二维的dp数组，其中dp[i][j]表示word1的前i个字符和word2的前j个字符组成的两个单词，能使其变相同的最小的步数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面来看递推式dp[i][j]怎么求，首先来考虑dp[i][j]和dp[i-1][j-1]之间的关系，我们可以发现，如果当前的两个字符相等，那么dp[i][j] = dp[i-1][j-1] + 1，因为最长相同子序列又多了一个相同的字符，所以长度加1。由于我们dp数组的大小定义的是(n1+1) x (n2+1)，所以我们比较的是word1[i-1]和word2[j-1]。那么我们想如果这两个字符不相等呢，难道我们直接将dp[i-1][j-1]赋值给dp[i][j]吗，当然不是，我们还要错位相比嘛，比如就拿题目中的例子来说，”sea”和”eat”，当我们比较第一个字符，发现’s’和’e’不相等，下一步就要错位比较啊，比较sea中第一个’s’和eat中的’a’，sea中的’e’跟eat中的第一个’e’相比，这样我们的dp[i][j]就要取dp[i-1][j]跟dp[i][j-1]中的较大值了，最后我们求出了最大共同子序列的长度，就能直接算出最小步数了，参见代码如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def minDistance(self, word1, word2):\n        &#34;&#34;&#34;\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(word1)\n        m = len(word2)\n        dp = [[0]*(m+1) for _ in range(n+1)]\n        for i in range(1,n+1):\n            for j in range(1,m+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1] + 1\n                else:\n                    dp[i][j] = max(dp[i-1][j],dp[i][j-1])\n        return m+n-2*dp[-1][-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>646. 最长数对链</b></h2><p>给出 n 个数对。 在每一个数对中，第一个数字总是比第二个数字小。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在，我们定义一种跟随关系，当且仅当 b &lt; c 时，数对(c, d) 才可以跟在 (a, b) 后面。我们用这种形式来构造一个数对链。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个对数集合，找出能够形成的最长数对链的长度。你不需要用到所有的数对，你可以以任何顺序选择其中的一些数对来构造。</p><p><br/>示例 :</p><p>输入: [[1,2], [2,3], [3,4]]</p><p>输出: 2</p><p>解释: 最长的数对链是 [1,2] -&gt; [3,4]</p><p>注意：</p><p>给出数对的个数在 [1, 1000] 范围内。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def findLongestChain(self, pairs):\n        &#34;&#34;&#34;\n        :type pairs: List[List[int]]\n        :rtype: int\n        &#34;&#34;&#34;\n        pairs.sort(key = lambda ele:ele[1])\n        cur,res = -sys.maxsize,0\n        for pair in pairs:\n            if pair[0] &gt; cur:\n                res += 1\n                cur = pair[1]\n            else:\n                continue\n        return res</code></pre></div><p>希望本文能对你有所帮助！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "动态规划", 
                    "tagLink": "https://api.zhihu.com/topics/19660018"
                }, 
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57483610", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "数据的关联规则挖掘", 
            "content": "<h2><b>关联规则简介</b></h2><p><b>数据挖掘</b>是⼀项从⼤量的记录数据中提取有价值的、⼈们感兴趣的知识，这些知识是隐含的、事先未知的有⽤信息，提取的知识⼀般可表⽰为概念(Concepts)、规则(Rules)、规律(Regular ides)、模式(Patterns)等形式。</p><p><b>关联规则</b>是当前数据挖掘研究的主要⽅法之⼀，它反映⼀个事物与其他事物之间的相互依存性和关联性。如果两个或者多个事物之间存在⼀定的关联关系，那么，其中⼀个事物就能够通过其他事物预测到。</p><p><b>典型的关联规则发现问题</b>是对超市中的货篮数据（Market Basket）进行分析。通过发现顾客放⼊货篮中的不同商品之间的关系来分析顾客的购买习惯。</p><p><b>关联规则的基本概念</b></p><p>设I={i1, i2,…, im}为所有项的集合，D为事务数据库，事务T是⼀个<b>项目子集</b>（T⊆I）。设A是⼀个由项目构成的集合，称为<b>项集</b>。事务T包含项集A，当且仅当A⊆T。如果项集A中包含k个项目，则称其为<b>k项集</b>。</p><p>项集A在事务数据库D中出现的次数占D中总事务的百分⽐叫做项集的<b>支持度</b>。如果项集的⽀持度超过用户给定的最小支持度阈值，就称该项集是<b>频繁项集</b>。</p><p>关联规则是形如X⇒Y的逻辑蕴含式，其中X⊂I，Y⊂I，且X∩Y=∅。</p><p>如果事务数据库D中有s%的事务包含X∪Y，则称关联规则X⇒Y的<b>支持度</b>为s%。</p><p>关联规则的<b>信任度</b>为support (X∪Y)／support (X)。</p><p><b>通俗的讲</b>，就是项集A在所有数据库中所占的百分比即为A的<b>支持度</b>。</p><p>项集A和项集B同时发生的概率比上项集A发生的概率称之为项集A的<b>信任度</b>。</p><p>我们在实际运用当中，往往会给予支持度和信任度一定的阈值，是否满足这一阈值我们称之为<b>强关联规则</b>，强关联规则就是⽀持度和信任度分别满足用户给定阈值的规则。</p><p>接下来，我们要介绍一种用于挖掘出数据关联规则的常用算法--<b>Apriori算法。</b>它用来找出数据值中频繁出现的数据集合，找出这些集合的模式有助于我们做一些决策。比如在常见的超市购物数据集，或者电商的网购数据集，如果我们找到了频繁出现的数据集，那么对于超市，我们可以优化产品的位置摆放，对于电商，我们可以优化商品所在的仓库位置，达到节约成本，增加经济效益的目的。</p><hr/><h2><b>Apriori算法</b></h2><p>Apriori算法将发现关联规则的过程分为<b>两个步骤</b>：</p><ol><li>通过迭代，<b>检索出事务数据库中的所有频繁项集</b>，即⽀持度不低于⽤户设定的阈值的项集。</li><li>利⽤频繁项集<b>构造出满足用户最小信任度的规则</b>。</li></ol><p>挖掘或识别出所有频繁项集是该算法的核心，占整个计算量的⼤部分。</p><p><b>Apriori的两条重要性质：</b></p><p>性质1：频繁项集的所有非空子集必为频繁项集。</p><p>性质2：非频繁项集的超集⼀定是⾮频繁的。</p><p><b>Apriori的具体步骤：</b></p><p>连接步：为找Lk ，通过将Lk-1与⾃⾝连接产⽣候选k项集的<b>集合Ck</b></p><p>剪枝步：Ck是Lk 的<b>超集</b>，也就是说，Ck的成员可以是也可以不是频繁的，但所有的频繁k项集都包含在Ck中。任何非频繁的（k-1）项集都不是频繁k项集的⼦集。</p><p>依靠之前的两条性质，我们可以在实际应用当中省去很多资源，比如在电商里面有百万级别的商品上新，两两组合后的维度是很惊人的，所以我们可以用到上面的方法，重复Apriori的步骤，在集合Ck中先行过滤掉支持度低的项集(性质2：非频繁项集的超集⼀定是⾮频繁的)，在多次重复后，可以大大降低统计的量。</p><p><b>Apriori算法的不足</b></p><ol><li> Ck中的每个元素需在交易数据库中进⾏验证来决定其是否加入Lk，频繁的扫描调用是对数据库和服务器造成很大的压力</li><li> 验证过程是性能瓶颈</li><li> 交易数据库可能⾮常⼤</li><li> 比如频集最多包含10个项，那么就需要扫描交易数据库10遍</li><li> 需要很⼤的I/O负载</li></ol><p>因为Apriori算法本质是<b>时间换空间</b>的，换句话说就是利用多次的读取来利用有限的空间来完成计算，但是随着摩尔定律，我们的空间不在像之前那样宝贵和捉襟见肘了，所以，我们开始思考能不能有一种算法，<b>利用空间，来换取时间</b>，一次获得<b>更快的速度</b>。</p><p>如下个算法，只扫描一两次数据库，同时利用这两次扫描的来存储下的关键数据来获得相应的规则。</p><h2><b>FP-tree算法</b></h2><p>2000年，Han等提出了⼀个称为FP-tree的算法。FP-tree算法特点是只进⾏2次数据库扫描。</p><ol><li> no候选集</li><li> 直接压缩数据库成⼀个频繁模式树</li><li>通过这棵树⽣成关联规则</li></ol><p>FP-tree<b>两个主要步骤</b></p><ol><li> 利用事务数据库中的数据构造FP-tree</li><li>从FP-tree中挖掘频繁模式</li></ol><p><b>步骤1：构造 FP-tree树</b></p><p>具体过程：</p><ol><li>扫描数据库⼀次，得到频繁1-项集</li><li>把项按⽀持度递减排</li><li>再⼀次扫描数据库，建⽴FP-tree</li></ol><p><b>步骤2：频繁模式的挖掘</b></p><p>具体过程:</p><p>根据事务数据库D 和最⼩⽀持度min_sup， 调⽤建树过程建⽴FP-tree;</p><p>    if (FP-tree 为简单路径)：</p><p>        将路径上⽀持度计数⼤于等于min_sup 的节点任意组合，得到所需</p><p>        的频繁模式；</p><p>    else：</p><p>        初始化最⼤频繁模式集合为空；</p><p>按照⽀持频率升序，以每个1- 频繁项为后缀，调用挖掘算法挖掘最大频繁模式集。</p><p>根据最⼤频繁模式集合中最⼤频繁模式，输出全部的频繁模式。</p><p><b>FP - tree 算法的优缺点</b></p><p><b>优点</b></p><p>FP-tree 算法只需对事务数据库进⾏⼆次扫描。</p><p>避免产⽣的⼤量候选集。</p><p><b>缺点</b></p><p>要递归⽣成条件数据库和条件FP-tree，所以内存开销⼤。</p><p>只能用于挖掘单维的布尔关联规则。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据挖掘", 
                    "tagLink": "https://api.zhihu.com/topics/19553534"
                }, 
                {
                    "tag": "关联分析", 
                    "tagLink": "https://api.zhihu.com/topics/20181761"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61354685", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 2, 
            "title": "leetcode刷题(七）：栈和队列", 
            "content": "<p>今天讲的是栈和队列的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个问题不难，大家就当是复习下吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>栈</b></h2><p>首先我们来复习下栈的基本概念。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们把允许插入和删除的一端称之为栈顶，另一端称之为栈底，不含任何元素的称之为空栈。栈又称之为后进先出的线性表，简称为LIFO结构。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>栈的插入操作，叫做进栈，也称之为压栈，入栈。栈的删除操作，叫做出栈，也称之为弹栈。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>栈的顺序储存结构类似于出栈进栈操作，这个我也就不多废话了，今天我们来讲讲两栈的<b>共享空间</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果我们有两个栈，一个已经满了，再加入就要溢出了，而另一个栈还是空空如也，这是一种可耻的浪费啊！~！我们完全可以用一个数组来存储两个栈，只不过需要一点小技巧。<br/></p><p>我们的做法很简单，数组有两个端点，两个栈有两个栈底。我们让一个栈的栈底为数组的始端，即下标为0处，一个栈的栈底为数组的末端，即下标为n-1处。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实关键思路是：他们是在数组的两端，向中间靠拢。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其他思路也就很清楚了，当栈1为空的时候，就是top==-1，当top==n时，栈2为空。当然了，我们还需要一个stackNumber参数来判断时栈1还是栈2。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>实际上，在外面实际运用当中，这种数据结构往往都是用在两个栈有相反关系的情况下，就是一个栈增长一个栈缩短的情况下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>讲完了这些基本操作，我们来聊一些有趣的东西：栈的运用-<b>-四则运算表达式求值</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里的四则运算就是我们小学时候学过的四则混合运算，先算括号里面的，再算乘除，最后算加减。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这很容易理解，但是对电脑来说并不是这样的，特别是在引入了括号以后。但是我们在进一步引入栈这个概念以后，事情就变得简单多了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们观察后发现，括号都是成对出现的，也就是说有左括号就一定有右括号，对于多重括号，最后也是完全嵌套匹配的。这与栈的结构完全合适，只要是左括号就进栈，不管表达式有多重括号，反正遇到左括号就进栈，后面遇到右括号的时候就让栈顶的左括号出栈，期间让数字运算，这样，最终由括号的表达式从左到右巡查一遍，栈应该是由空到有元素，最终再因全部匹配成功后成为空栈。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>后来，波兰有位大佬，想出了一种不需要括号的后缀表达法，我们也称之为逆波兰表达式。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>老规矩，举个栗子：9 +（ 3 - 1 ）* 3 + 10 / 2，如果用后缀表达式应该怎么写呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>                                               9 3 1 - 3 * + 10 2 / +</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为所有符号都在运算数字后面出现，所以称之为后缀表达式。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体的运算方式也很简单：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号就将位于栈顶的两个数字出栈，进行运算，运算结果再进栈，一直到最终获得结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>既然后缀表达式这么流批，那么我们怎么将它从中缀表达式转换成后缀表达式呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>还是举老栗子，把中缀表达式9 +（ 3 - 1 ）* 3 + 10 / 2转换成后缀表达式9 3 1 - 3 * + 10 2 / +。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>规则如下：从左到右遍历中缀表达式的各个数字和符号。若是数字就输出，成为后缀表达式的一部分；若是符号，则判断其与栈顶符号的优先级，是右括号或者优先级不高于栈顶符号（乘除高于加减）则栈顶元素依次出栈并输出，并将当前元素入栈，直到最终输出后缀表达式为止。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>队列</b></h2><p>队列就是只允许在一段进行插入操作，在另一端进行删除操作的线性表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>队列是一种先进先出的线性表，简称FIFO，允许插入的一端称之为队尾，允许删除的一端称之为队头。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所谓的入队操作呢，就是在队尾增加一个元素，所谓的出队操作呢，就是在队头删去一个元素。为了进一步方便起见，我们引入两个指针，front指针指向队头元素，rear元素指向队尾元素。这样当front==rear时，为空队列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么问题来了，假设这个队列总数不超过5个，但是不停地有元素入队，那么就会产生数组越界的错误。可实际上，队头的部分（比如说下标为0和1的部分）还是空闲的。我们把这种情况称之为“假溢出”。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解决“假溢出”的办法就是后面满了，我们再从头开始，也就是头尾相接的循环。我们把队伍的这种头尾相接的顺序存储结构称之为循环队列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然，下一个问题就出来了，当空队列时，front==rear，当满队列时，也是front==rear。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以要设置一个标志位flag，当front==rear，且flag=0时，队列为空；当front==rear，且flag=1时，队列为满。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以总结一下：队满的条件：（rear+1）%QueueSize() == front</p><p>计算队列的长度：（rear-front+QueueSize）%QueueSize</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来是真题时间！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>232. 用栈实现队列</h3><p>使用栈实现队列的下列操作：</p><p>push(x) -- 将一个元素放入队列的尾部。</p><p>pop() -- 从队列首部移除元素。</p><p>peek() -- 返回队列首部的元素。</p><p>empty() -- 返回队列是否为空。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>MyQueue queue = new MyQueue();</p><p>queue.push(1);</p><p>queue.push(2);  </p><p>queue.peek();  // 返回 1</p><p>queue.pop();   // 返回 1</p><p>queue.empty(); // 返回 false</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class MyQueue(object):\n\n    def __init__(self):\n        &#34;&#34;&#34;\n        Initialize your data structure here.\n        &#34;&#34;&#34;\n        self.input = []\n        self.output = []\n \n\n    def push(self, x):\n        &#34;&#34;&#34;\n        Push element x to the back of queue.\n        :type x: int\n        :rtype: None\n        &#34;&#34;&#34;\n        self.input.append(x)\n \n\n    def pop(self):\n        &#34;&#34;&#34;\n        Removes the element from in front of queue and returns that element.\n        :rtype: int\n        &#34;&#34;&#34;\n        self.peek()\n        return self.output.pop()\n \n\n    def peek(self):\n        &#34;&#34;&#34;\n        Get the front element.\n        :rtype: int\n        &#34;&#34;&#34;\n        while not self.output:\n            while self.input:\n                self.output.append(self.input.pop())\n        return self.output[-1]\n \n\n    def empty(self):\n        &#34;&#34;&#34;\n        Returns whether the queue is empty.\n        :rtype: bool\n        &#34;&#34;&#34;\n        return not self.input and not self.output    </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>20. 有效的括号</h3><p>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。</p><p>左括号必须以正确的顺序闭合。</p><p>注意空字符串可被认为是有效字符串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: &#34;()&#34;</p><p>输出: true</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: &#34;()[]{}&#34;</p><p>输出: true<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isValid(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        mapping = {&#39;)&#39;:&#39;(&#39;,&#39;]&#39;:&#39;[&#39;,&#39;}&#39;:&#39;{&#39;}\n        left = mapping.keys()\n        right = mapping.values()\n        stack = []\n        for str in s:\n            if str in left:\n                if stack and stack[-1] == mapping[str]:\n                    stack.pop()\n                else:\n                    return False\n            elif str in right:\n                stack.append(str)\n        return not stack</code></pre></div><h3>739. 每日温度</h3><p>根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高的天数。如果之后都不会升高，请输入 0 来代替。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的都是 [30, 100] 范围内的整数。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def dailyTemperatures(self, T):\n        &#34;&#34;&#34;\n        :type T: List[int]\n        :rtype: List[int]\n        &#34;&#34;&#34;\n        t_length = len(T)\n        stack = list()\n        res_list = [0 for _ in range(t_length)]\n \n        for key,value in enumerate(T):\n            if stack:\n                while stack and T[stack[-1]] &lt; value:\n                    res_list[stack[-1]] = key - stack[-1]\n                    stack.pop()\n            stack.append(key)\n        return res_list    </code></pre></div><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }, 
                {
                    "tag": "栈（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20183311"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67380399", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "”京东杯“用户对品类下店铺的购买预测（复盘）", 
            "content": "<p>最近参加了“京东杯”比赛，题目是用户对品类下店铺的购买预测。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第一次玩比赛，不知道江湖险恶，一开始还好好的，到了B榜，藏分大佬们就开始表演了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>止步初赛，理所当然的了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-adc382d46e135e1038e07f9abdbf3f07_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"300\" data-thumbnail=\"https://pic4.zhimg.com/v2-adc382d46e135e1038e07f9abdbf3f07_b.jpg\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"300\" data-thumbnail=\"https://pic4.zhimg.com/v2-adc382d46e135e1038e07f9abdbf3f07_b.jpg\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-adc382d46e135e1038e07f9abdbf3f07_b.gif\"/></figure><p>这是我自己做一个比赛记录和复盘，以方便日后总结。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以。。。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>大佬们就可以散了！</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-13ca2549e6192ed3c7f15090d99a475d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"270\" class=\"content_image\" width=\"270\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;270&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"270\" class=\"content_image lazy\" width=\"270\" data-actualsrc=\"https://pic2.zhimg.com/v2-13ca2549e6192ed3c7f15090d99a475d_b.jpg\"/></figure><p><br/>先简单介绍下这次的比赛内容：</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=https%3A//jdata.jd.com/html/detail.html%3Fid%3D8\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-eba82a7777f58b404e40d0c7b131e33f_180x120.jpg\" data-image-width=\"960\" data-image-height=\"580\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JDATA竞赛详情页</a><p class=\"ztext-empty-paragraph\"><br/></p><p><b>01 /评分</b></p><p>参赛者提交的结果文件中包含对所有用户购买意向的预测结果。对每一个用户的预测结果包括两方面：</p><p>（1）该用户2018-04-16到2018-04-22是否对品类有购买，提交的结果文件中仅包含预测为下单的用户和品类（预测为未下单的用户和品类无须在结果中出现）。评测时将对提交结果中重复的“用户-品类”做排重处理，若预测正确，则评测算法中置label=1，不正确label=0。</p><p>（2）如果用户对品类有购买，还需要预测对该品类下哪个店铺有购买，若店铺预测正确，则评测算法中置pred=1，不正确pred=0。</p><p>对于参赛者提交的结果文件，按如下公式计算得分：score=0.4F11+0.6F12</p><p>此处的F1值定义为：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8faaa4fc557c55a77921663c6cd978fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"109\" class=\"content_image\" width=\"264\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;109&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"109\" class=\"content_image lazy\" width=\"264\" data-actualsrc=\"https://pic4.zhimg.com/v2-8faaa4fc557c55a77921663c6cd978fb_b.jpg\"/></figure><p>其中：Precise为准确率，Recall为召回率； <i>F11</i> 是label=1或0的F1值，<i>F12</i> 是pred=1或0的F1值。</p><p><b>02 /赛题数据</b></p><p>2.1 训练数据</p><p>提供2018-02-01到2018-04-15用户集合U中的用户，对商品集合S中部分商品的行为、评价、用户数据。</p><p>2.2 预测数据</p><p>提供 2018-04-16 到 2018-04-22 预测用户U对哪些品类和店铺有购买，用户对品类下的店铺只会购买一次。</p><p>2.3 数据表说明</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e66ac2ba80d4df17afe3c0f7914259bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"882\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb\" width=\"882\" data-original=\"https://pic2.zhimg.com/v2-e66ac2ba80d4df17afe3c0f7914259bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;882&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"882\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"882\" data-original=\"https://pic2.zhimg.com/v2-e66ac2ba80d4df17afe3c0f7914259bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e66ac2ba80d4df17afe3c0f7914259bd_b.jpg\"/></figure><p>1）行为数据（jdata_action）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cda77d0bc276a98f3e3079f942fbf022_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-cda77d0bc276a98f3e3079f942fbf022_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;201&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-cda77d0bc276a98f3e3079f942fbf022_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cda77d0bc276a98f3e3079f942fbf022_b.jpg\"/></figure><p>2）评论数据（jdata_comment）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6756649d85a2f6b4a178c5ca6dd3ec36_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-6756649d85a2f6b4a178c5ca6dd3ec36_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-6756649d85a2f6b4a178c5ca6dd3ec36_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6756649d85a2f6b4a178c5ca6dd3ec36_b.jpg\"/></figure><p>3）商品数据（jdata_product）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c987f535bfd6dfbac1a83d0a51927595_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"567\" data-original=\"https://pic2.zhimg.com/v2-c987f535bfd6dfbac1a83d0a51927595_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;567&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"567\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"567\" data-original=\"https://pic2.zhimg.com/v2-c987f535bfd6dfbac1a83d0a51927595_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c987f535bfd6dfbac1a83d0a51927595_b.jpg\"/></figure><p>4）商家店铺数据（jdata_shop）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-942786732a49583f08fa89ca77c2369e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-942786732a49583f08fa89ca77c2369e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-942786732a49583f08fa89ca77c2369e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-942786732a49583f08fa89ca77c2369e_b.jpg\"/></figure><p>5）用户数据（jdata_user）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-39bcf250799b9a212297ee1a5936a379_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"564\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb\" width=\"564\" data-original=\"https://pic2.zhimg.com/v2-39bcf250799b9a212297ee1a5936a379_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;564&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"564\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"564\" data-original=\"https://pic2.zhimg.com/v2-39bcf250799b9a212297ee1a5936a379_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-39bcf250799b9a212297ee1a5936a379_b.jpg\"/></figure><p><b>03 /任务描述及作品要求</b></p><p>3.1 任务描述</p><p>对于训练集中出现的每一个用户，参赛者的模型需要预测该用户在未来7天内对某个目标品类下某个店铺的购买意向。</p><p>3.2 作品要求</p><p>提交的CSV文件要求如下：</p><p>1. UTF-8无BOM格式编码；</p><p>2. 第一行为字段名，即：user_id,cate,shop_id（数据使用英文逗号分隔）</p><p>其中：user_id：用户表（jdata_user）中用户ID；cate：商品表（jdata_product）中商品sku_id对应的品类cate ；shop_id：商家表（jdata_shop）中店铺ID；</p><p>3. 结果不存在重复的记录行数，否则无效；</p><p>对于预测出没有购买意向的用户，在提交的CSV文件中不要包含该用户的信息。</p><p>提交结果示例如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-77594436d42ac287c32cb37c8654eb36_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"193\" data-rawheight=\"87\" class=\"content_image\" width=\"193\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;193&#39; height=&#39;87&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"193\" data-rawheight=\"87\" class=\"content_image lazy\" width=\"193\" data-actualsrc=\"https://pic3.zhimg.com/v2-77594436d42ac287c32cb37c8654eb36_b.png\"/></figure><p>本次大赛通过给出近两个月左右购买过目标商品的用户以及他们在前一年的浏览、购买、评价等数据信息，需要参赛者预测可能购买的用户以及相应用户购买的店铺品类，提交的结果文件中仅包含预测为下单的用户和品类。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据主要包括用户的基本信息，商品的基本信息，用户订单信息，用户浏览信息，用户评论信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我首先尝试从建模的方向出发：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>参考baseline：</p><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU1Nzc1NjI0Nw%3D%3D%26mid%3D2247484129%26idx%3D1%26sn%3Dbc4602f53531eea473e9e02ff0e909cd%26chksm%3Dfc31b8d9cb4631cfd765a7c353c32449c9899225bf5f19ef19d604d2a8dc84577839b303056f%26scene%3D21%23wechat_redirect\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【科普建模】JDATA3 用户对品类下店铺的购买预测</a><p class=\"ztext-empty-paragraph\"><br/></p><p>首先这是一个复购的问题，要根据历史行为来预测未来用户是否会进行购买。所以对行为数据的分析是这次比赛的重点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为我要预测未来7天也就是4月16-22日用户的购买情况，所以我往前推7天，用4月9日到4月15日做为线下验证集。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我先简单看了看数据：每周购买情况，每个月的购买情况，一个月每天的购买情况，并没有出现像去年比赛数据中双十一，双十二或者618这样的剁手日带来的流量波动。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我对订单表和行为表去重，对缺失值进行了填充。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里会遇到一个问题，正负样本的比例太悬殊了。正样本，即购买的样本太少，负样本，即不购买的样本太多了。所以为了平衡正负样本，必须要做点筛选。所以要想办法提取出有质量的负样本。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>众所周知（通过潜水观察群里大佬们讨论），我们知道，有两种样本是最好的：</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>高概率发生而未发生的。</li><li>低概率发生的，却发生的。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>结合到本案例，我提取了浏览，关注，加购物车三连击却不下单的家伙作为主要负样本，删掉了大量长时间多次重复浏览也不下单的家伙（我怀疑他们是爬虫来着！~！）</p><p><br/>这里讲个小tip，因为文件挺大的，而我的笔记本内存只有8g，稍微做个特征工程就memory error了，所以大家可以分块提取，防止一次读入造成那内存失败，也可以使用kaggle上的一段读写函数，可以有效减小内存。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">def reduce_mem_usage(df, verbose=True):\n    numerics = [&#39;int16&#39;, &#39;int32&#39;, &#39;int64&#39;, &#39;float16&#39;, &#39;float32&#39;, &#39;float64&#39;]\n    start_mem = df.memory_usage().sum() / 1024**2\n    for col in df.columns:\n        col_type = df[col].dtypes\n        if col_type in numerics:\n            c_min = df[col].min()\n            c_max = df[col].max()\n            if str(col_type)[:3] == &#39;int&#39;:\n                if c_min &gt; np.iinfo(np.int8).min and c_max &lt; np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif c_min &gt; np.iinfo(np.int16).min and c_max &lt; np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif c_min &gt; np.iinfo(np.int32).min and c_max &lt; np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                elif c_min &gt; np.iinfo(np.int64).min and c_max &lt; np.iinfo(np.int64).max:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                if c_min &gt; np.finfo(np.float16).min and c_max &lt; np.finfo(np.float16).max:\n                    df[col] = df[col].astype(np.float16)\n                elif c_min &gt; np.finfo(np.float32).min and c_max &lt; np.finfo(np.float32).max:\n                    df[col] = df[col].astype(np.float32)\n                else:\n                    df[col] = df[col].astype(np.float64)\n    end_mem = df.memory_usage().sum() / 1024**2\n    if verbose: print(&#39;Mem. usage decreased to {:5.2f} Mb ({:.1f}% reduction)&#39;.format(end_mem, 100 * (start_mem - end_mem) / start_mem))\n    return df</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-79474ebaaedcc101f9d710148fe02788_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb\" width=\"856\" data-original=\"https://pic1.zhimg.com/v2-79474ebaaedcc101f9d710148fe02788_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;856&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"856\" data-original=\"https://pic1.zhimg.com/v2-79474ebaaedcc101f9d710148fe02788_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-79474ebaaedcc101f9d710148fe02788_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我尝试了LightGBM模型和XGBoost模型，但是很奇怪，不管是单模还是融合，效果都不好，想了很久，我还是觉得应该是我太菜的缘故2333</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后我就在建模上走进了死胡同，后来经过群里大佬的提醒，我意识到其实可以按照规则来做这个题：</p><p><br/>在日常生活中，我们购买东西常常会分为以下三种场景：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1.<b>购买大件商品</b>：比如说想买台彩电，大多数人就会货比三家，将不同型号的彩电采取 收藏和加购物车 的行为，最后进行购买。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2.<b>临时起意的购买</b>：我们逛京东的的时候，可能会觉得某件商品挺不错，价格也合适，就直接购买了，这种场景是不涉及到历史数据的，完全的临时的一个购买（CTR推荐做得的好），所以很难去预测。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3.<b>周期性的购买</b>：这种场景往往适用于购买周期性的，生活必需品，比如说卫生纸，大米啥的。因为是生活必需品+周期性+有强烈的复购趋势，所以这种场景就和历史数据产生了较大的相关性，也是较容易被预测的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我大胆地做出了假设，既然题目给了我们历史数据要我们预测复购的情况，<b>那么我就假设我们属于第三种场景，也就是根据历史的购买来预测我们未来什么时间可能进行购买</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>想到了这一点，接下来的规则就很显然了，我主要分析的是用户购买间隔的来做的数据分析，即通过<b>用户购买间隔时间来预测用户下次的购买。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>就是这么简单粗暴的操作，结果是0.022左右。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>后来我还对其进行了进一步改进，如有收藏行为的用户购买间隔天数，有浏览行为的用户购买间隔天数。也就是对user_id更加细致的划分，分数有一定的提升。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是第一次打比赛，我也只能做到这里了，希望前十进入复赛的大佬能开源吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>这次比赛的不足：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>可以尝试下滑窗采样，我只简单地用时间划分了线下训练集。</li><li>特征工程没做好，不能直接甩特征，要先进行业务建模，然后才进行特征选择。</li><li>模型效果很差也有可能是没有把噪声处理好的缘故。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>其他大佬的比赛分享：</p><a href=\"https://zhuanlan.zhihu.com/p/65337009\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/zhihu-card-default.jpg\" class=\"internal\">李凯东：JData非官方答疑（二）</a><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/64357013?tdsourcetag=s_pctim_aiomsg\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-b70c1b0a003c8e0f803fb4f1bf069aa5_ipico.jpg\" data-image-width=\"780\" data-image-height=\"778\" class=\"internal\">六号：jdata baseline-用户对品类下店铺的购买预测（top12）</a><p class=\"ztext-empty-paragraph\"><br/></p><p>欢迎大家吐槽，如果有不对的地方，也欢迎大佬们前来打脸。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大家有好的想法可以加我私下交流。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我的个人微信放下面了，祝大家身体健康，天天开心！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c70f9fb191cccf0b44b15d77d6f1c223_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"896\" class=\"origin_image zh-lightbox-thumb\" width=\"674\" data-original=\"https://pic4.zhimg.com/v2-c70f9fb191cccf0b44b15d77d6f1c223_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;674&#39; height=&#39;896&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"896\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"674\" data-original=\"https://pic4.zhimg.com/v2-c70f9fb191cccf0b44b15d77d6f1c223_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c70f9fb191cccf0b44b15d77d6f1c223_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }
            ], 
            "comments": [
                {
                    "userName": "Derak", 
                    "userLink": "https://www.zhihu.com/people/89269f99f2cad0026f0c6a6d8287e8df", 
                    "content": "<p>请问有百度网盘的数据集分享吗？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65727827", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "leetcode刷题(十三）：动态规划2（斐波那契数列，最长递增子序列，最长公共子系列）", 
            "content": "<p>我们接上一期的内容，继续来讲动态规划：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>动态规划原理</b></p><p>适合应用动态规划方法求解的最优化问题，应该具备两个要素：最优子结构和子问题重叠。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1.最优子结构</b></p><p>用动态规划方法求解最优化问题的第一步就是刻画<b>最优解的结构</b>，如果一个问题的最优解包含其子问题的最优解，就称此问题具有<b>最优子结构性质</b>。某个问题是否能用动态规划方法解决，是否具有最优子结构是关键因素，当然具有最优子结构的性质也适合贪心策略。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用动态规划方法时，用子问题的最优解来构造原问题的最优解，因此，必须小心确保考察了最优解中用到的所有子问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在求解最优解的过程中，需要作出选择，这个选择产生出若干子问题。作为构成原问题最优解的组成部分，<b>每个子问题的解也是最优解</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于不同的问题领域，最优子结构的不同体现在：原问题的最优解涉及多少个子问题，以及在确定最优解使用哪些子问题时，需要观察多少种选择。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以用子问题的总数，以及每个子问题需要考察多少种选择，这两个因素的乘积分析动态规划算法的运行时间。比如钢条切割问题，总共有Θ(n)个子问题，每个子问题最多需要考察n种选择，因此运行时间为O(n^2 )。矩阵链乘法问题中，总共有Θ(n^2 )个子问题，每个子问题最多需要考察n-1种选择，所以运行时间为O(n^3 )。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>贪心算法与动态规划有类似之处，他们之间最大的区别在于：贪心算法并不是寻找子问题的最优解，然后在其中进行选择，而是首先做出“贪心”选择—在当时(局部)看来最优的选择。然后求解出该子问题。因而不必费心求解所有可能相关的子问题。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2.重叠子问题</b></p><p>适合用动态规划方法解决的最优化问题应该具备的第二个性质是子问题重叠性质，也就是问题的递归算法会反复求解相同的子问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>利用子问题重叠的性质，可以再自顶向下的递归算法中，加入备忘机制，记录已经求解的子问题，这样，再次遇到事就不必重复计算了；或者采用自底向上的方法，从最小的子问题开始计算，这样在求解某个子问题时，它所依赖的子子问题已经知道答案了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>通常情况下，如果所有的子问题都至少要被计算一次，则一个自底向上的动态规划算法通常要比一个自顶向下的备忘算法好出一个常数因子，因为前者无需递归的代价。或者，如果子问题空间中的某些子问题根本没有必要求解。自顶向下的备忘方法就会体现出优势了，因为它只会求解哪些绝对必要的子问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>斐波那契数列</b></p><p>斐波那契数列记为{f(n)}，其表达式如下：</p><p>        f(0)=0,f(1)=1,f(n)=f(n-1)+f(n-2),n&gt;1.</p><p>具体写出前几项，就是：0,1,1,2,3,5,8,13,21,34,55,89,144,233......</p><p>接下来，我们用动态规划伪代码来求解该数列的第n项，即f(n)的值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>伪代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">function fib(n)\n\n    var previousFib := 0, currentFib := 1\n \n    if n = 0\n    return 0\n    else if n = 1\n    return 1\n \n    repeat n−1 times\n        var newFib := previousFib + currentFib\n        previousFib := currentFib\n        currentFib := newFib\n \n    return currentFib</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>动态规划法会在运行过程中，保存上一个子问题的解，从而避免了重复求解子问题。对于求解斐波那契数列的第n项，我们在使用动态规划法时，需要保存f(n-1)和f(n-2)的值，牺牲一点内存，但是可以显著地提升运行效率。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>最长递增子序列</b></p><p>已知一个序列 {S1, S2,...,Sn} ，取出若干数组成新的序列 {Si1, Si2,..., Sim}，其中 i1、i2 ... im 保持递增，即新序列中各个数仍然保持原数列中的先后顺序，称新序列为原序列的一个 子序列 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果在子序列中，当下标 ix &gt; iy 时，Six &gt; Siy，称子序列为原序列的一个递增子序列 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>定义一个数组 dp 存储最长递增子序列的长度，dp[n] 表示以 Sn 结尾的序列的最长递增子序列长度。对于一个递增子序列 {Si1, Si2,...,Sim}，如果 im &lt; n 并且 Sim &lt; Sn ，此时 {Si1, Si2,..., Sim, Sn} 为一个递增子序列，递增子序列的长度增加 1。满足上述条件的递增子序列中，长度最长的那个递增子序列就是要找的，在长度最长的递增子序列上加上 Sn 就构成了以 Sn 为结尾的最长递增子序列。因此 dp[n] = max{ dp[i]+1 | Si &lt; Sn &amp;&amp; i &lt; n} 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为在求 dp[n] 时可能无法找到一个满足条件的递增子序列，此时 {Sn} 就构成了递增子序列，因此需要对前面的求解方程做修改，令 dp[n] 最小为 1，即：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e3c7331c3f29b366fa5675de5c6e5da8_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"347\" data-rawheight=\"19\" class=\"content_image\" width=\"347\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;347&#39; height=&#39;19&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"347\" data-rawheight=\"19\" class=\"content_image lazy\" width=\"347\" data-actualsrc=\"https://pic1.zhimg.com/v2-e3c7331c3f29b366fa5675de5c6e5da8_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于一个长度为 N 的序列，最长子序列并不一定会以 SN 为结尾，因此 dp[N] 不是序列的最长递增子序列的长度，需要遍历 dp 数组找出最大值才是所要的结果，即 max{ dp[i] | 1 &lt;= i &lt;= N} 即为所求。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>最长公共子系列</b></p><p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 dp[i][j] 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1 ，即 dp[i][j] = dp[i-1][j-1] + 1。</li><li>当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，与 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，它们的最大者，即 dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }。</li></ol><p>综上，最长公共子系列的状态转移方程为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-34dcf16138b7d27547c3985f2374f3ad_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb\" width=\"445\" data-original=\"https://pic2.zhimg.com/v2-34dcf16138b7d27547c3985f2374f3ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;445&#39; height=&#39;45&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"445\" data-original=\"https://pic2.zhimg.com/v2-34dcf16138b7d27547c3985f2374f3ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-34dcf16138b7d27547c3985f2374f3ad_b.png\"/></figure><p>对于长度为 N 的序列 S1 和 长度为 M 的序列 S2，dp[N][M] 就是序列 S1 和序列 S2 的最长公共子序列长度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>与最长递增子序列相比，最长公共子序列有以下不同点：</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>针对的是两个序列，求它们的最长公共子序列。</li><li>在最长递增子序列中，dp[i] 表示以 Si 为结尾的最长递增子序列长度，子序列必须包含 Si ；在最长公共子序列中，dp[i][j] 表示 S1 中前 i 个字符与 S2 中前 j 个字符的最长公共子序列长度，不一定包含 S1i 和 S2j 。 </li><li>由于 2 ，在求最终解时，最长公共子序列中 dp[N][M] 就是最终解，而最长递增子序列中 dp[N] 不是最终解，因为以 SN 为结尾的最长递增子序列不一定是整个序列最长递增子序列，需要遍历一遍 dp 数组找到最大者。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>来做点真题！</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>70. 爬楼梯</b></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><br/>注意：给定 n 是一个正整数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1：</p><p>输入： 2</p><p>输出： 2</p><p>解释： 有两种方法可以爬到楼顶。</p><p>1.  1 阶 + 1 阶</p><p>2.  2 阶</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2：</p><p>输入： 3</p><p>输出： 3</p><p>解释： 有三种方法可以爬到楼顶。</p><p>1.  1 阶 + 1 阶 + 1 阶</p><p>2.  1 阶 + 2 阶</p><p>3.  2 阶 + 1 阶</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>分析</b></p><p>只有两种办法爬楼，每次一步或者每次两步。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以这样想，n个台阶，一开始可以爬 1 步，也可以爬 2 步，那么n个台阶爬楼的爬楼方法就等于 一开始爬1步的方法数 + 一开始爬2步的方法数，这样我们就只需要计算n-1个台阶的方法数和n-2个台阶方法数，同理，计算n-1个台阶的方法数只需要计算一下n-2个台阶和n-3个台阶，计算n-2个台阶需要计算一下n-3个台阶和n-4个台阶……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是就是一个斐波那契数列？！</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def climbStairs(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        a = 1\n        b = 1\n        for i in range(n):\n            # a = b\n            # b = a + b\n            a,b = b,a+b\n        return a</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>198. 打家劫舍</b></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [1,2,3,1]</p><p>输出: 4</p><p>解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</p><p>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [2,7,9,3,1]</p><p>输出: 12</p><p>解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</p><p>     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def rob(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        if len(nums) == 0:\n            return 0\n        elif len(nums) == 1:\n            return nums[0]\n        elif len(nums) == 2:\n            return max(nums[0],nums[1])\n        elif len(nums) == 3:\n            return max(nums[0]+nums[2],nums[1])\n        else:\n            dp = [0]*len(nums)\n            dp[0] = nums[0]\n            dp[1] = max(nums[0],nums[1])\n            dp[2] = max(nums[1],nums[0]+nums[2])\n            for i in range(3,len(nums)):\n                dp[i] = max(dp[i-2]+nums[i],dp[i-1])\n            return dp[-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>213. 打家劫舍 II</b></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [2,3,2]</p><p>输出: 3</p><p>解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [1,2,3,1]</p><p>输出: 4</p><p>解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</p><p>     偷窃到的最高金额 = 1 + 3 = 4 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def rob(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(nums)\n        if not n:\n            return 0\n        if n &lt;= 3:\n            return max(nums)\n        dp1 = self.helper(nums[1:])\n        dp2 = self.helper(nums[:-1])\n        return max(dp1,dp2)\n \n    def helper(self,nums):\n        n = len(nums)\n        if not n:\n            return False\n        elif n == 1:\n            return nums\n        elif n == 2:\n            return max(nums)\n        elif n == 3:\n            return max(nums[1],nums[0]+nums[2])\n        dp = n*[0]\n        dp[0] = nums[0]\n        dp[1] = max(nums[1],nums[0]+nums[2])\n        for i in range(n):\n            dp[i] = max(dp[i-1],dp[i-2]+nums[i])\n        return dp[-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>300. 最长上升子序列</b></p><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>输入: [10,9,2,5,3,7,101,18]</p><p>输出: 4 </p><p>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</p><p>说明:</p><p>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。</p><p>你算法的时间复杂度应该为 O(n2) 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def lengthOfLIS(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(nums)\n        if n &lt;= 1:\n            return n\n        dp = n*[1]\n        for i in range(1,n):\n            for j in range(i):\n                if nums[j]&lt;nums[i]:\n                    dp[i] = max(dp[i],dp[j]+1)\n        return max(dp)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>376. 摆动序列</b></p><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p><p><br/>示例 1:</p><p>输入: [1,7,4,9,2,5]</p><p>输出: 6 </p><p>解释: 整个序列均为摆动序列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [1,17,5,10,13,15,10,5,16,8]</p><p>输出: 7</p><p>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 3:</p><p>输入: [1,2,3,4,5,6,7,8,9]</p><p>输出: 2</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def wiggleMaxLength(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        def wiggleLength(type,nums):\n            n = len(nums)\n            if n == 0:\n                return 0\n            pre,cnt = nums[0],1\n            for i in range(1,n):\n                if type and nums[i] &gt; pre:\n                    type = False\n                    cnt += 1\n                elif not type and nums[i] &lt; pre:\n                    type = True   \n                    cnt+= 1\n                pre = nums[i]\n            return cnt\n        return max(wiggleLength(True,nums),wiggleLength(False,nums))</code></pre></div><p>希望本文能对你有所帮助！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，会写点学习心得，喜欢可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "动态规划", 
                    "tagLink": "https://api.zhihu.com/topics/19660018"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "斐波那契（Leonardo Fibonacci）", 
                    "tagLink": "https://api.zhihu.com/topics/19558921"
                }
            ], 
            "comments": [
                {
                    "userName": "Skye", 
                    "userLink": "https://www.zhihu.com/people/82e8ae5254e416d633692f3f72cce6c9", 
                    "content": "最长公共子序列和删除字符使两个字符串相等的题目很像", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64215625", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 1, 
            "title": "leetcode刷题(十一）：链表", 
            "content": "<p>今天来讲一下链表大家族：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>链表主要分为<b>顺序存储结构</b>以及<b>链式存储结构</b>，其中链式存储结构又可以分为<b>单链表</b>，<b>静态链表</b>，<b>循环链表</b>以及<b>双向链表</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>先来讲讲<b>顺序存储结构</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>简单来讲，顺序存储结构，就是一段地址连续的存储单元依次存储线性表的数据元素。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么他又那些优缺点呢？首先是缺点，因为是顺序结构嘛，在插入和删除的时候，前面做插入删除动作时候，后面的元素是否要依次做出后退或者前进一位的当作？是不是很麻烦！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在最糟糕的情况下，第一位插入或者删除一位，那么时间复杂度就会飙到O(n)，容易造成存储的碎片。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然了，优点也是有的，比如无需为表中元素之间的逻辑关系而增加额外的外储空间。同时因为是顺序结构，所以可以快速存取表中任一位置的元素。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再来讲讲<b>链式存储结构</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面说到了，顺序存储最大的缺点就是插入和删除需要移动大量元素，很浪费时间。呢么有没有好点的办法来解决呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里就是引进链式存储了，我们不必去纠结元素之间的相邻位置了，我们直接告诉上个元素下个元素的位置数据不就行了！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为了表示每个数据元素ai与其直接后继数据元素ai+ 1之间的逻辑关系。对数据元素ai来说,除了存储其本身的信息之外,还需存储一个指示其后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为<b>数据域</b>,把存储后继的位置的域称为<b>指针域</b>.指针域中存储的信息称做<b>指针</b>或<b>链</b>.这两部分信息组成的元素ai的<b>存储映像</b>,称为<b>结点</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>n个结点(ai的存储映像)链结成一个链表,即为线性表(a1,a2,...an)的链式存储结构,因为此链表的每个结点中只包含一个指针域,所有叫做<b>单链表</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里要将一个小tip：单链表插入和删除</p><p><b>插入</b>：s-&gt;next = p-&gt;next , p-&gt;next = s</p><p><b>删除</b>：q = p-&gt;next , p-&gt;next = q-&gt;next</p><p>那么问题来了，为什么要这么写呢？如果将两句的顺序调换一下可不可以呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们来对比下单链结构和顺序存储结构的优缺点吧：</p><h2><b>存储分配方式</b></h2><p>顺序存储用一段连续的存储单元依次存储线性表的数据元素</p><p>单链表采用链式存储结构,用一组任意的存储单元存放线性表元素</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>时间性能</b></h2><p><b>查找：</b></p><p>顺序存储O(1)</p><p>单链表O(n)</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>插入和删除：</b></p><p>顺序存储平均需要移动表长一半的元素 时间为0(n)</p><p>单链表在计算出某位置的指针后,插入和删除时间仅为O(1)</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>空间性能</b></h2><p>顺序存储结构需要预分配存储空间,分大了,容易造成空间浪费,分小了,容易发生溢出</p><p>单链表不需要分配存储空间,只要有就可以分配,元素个数也不受限制</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面简单讲讲其他链式存储方式：</p><h2><b>静态链表</b></h2><p>用数组描述的链表，即称为静态链表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>优点</b>：再插入和删除时候，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中插入和删除操作需要移动大量元素的缺点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>缺点</b>：没有解决连续存储分配带来的表长难以确定的问题；失去了顺序存储结构随机存取的特性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>链表家族成员差不多就介绍到这里了，下面是真题时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>160. 相交链表</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如下面的两个链表：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-98641a5bfe436dc0e60d9f9162e25020_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-98641a5bfe436dc0e60d9f9162e25020_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-98641a5bfe436dc0e60d9f9162e25020_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-98641a5bfe436dc0e60d9f9162e25020_b.jpg\"/></figure><p>在节点 c1 开始相交。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8d82514cb46dbb8a8ec46e79a8535bfe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-8d82514cb46dbb8a8ec46e79a8535bfe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-8d82514cb46dbb8a8ec46e79a8535bfe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8d82514cb46dbb8a8ec46e79a8535bfe_b.jpg\"/></figure><p>示例 1：</p><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3</p><p>输出：Reference of the node with value = 8</p><p class=\"ztext-empty-paragraph\"><br/></p><p>输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这题比较有趣，我先简单说说。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要两种思维：</p><p>1.先算出A和B的长度，算出长度差n，先让长的跑n步，然后再一起跑，只要是相同就找到intersectVal啦</p><p>2.A和B一起走，短的一个，比方说A先到底了，就把指针指向B的头，B走到底后把指针指向A的头，这样走下来两个指针走的路长短都是相同的，而且只要有相同的地方，两个指针必然会C1处相遇。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面代码选用了第二种思维</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        &#34;&#34;&#34;\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        &#34;&#34;&#34;\n        a = headA\n        b = headB\n        while(a != b):\n            a = headB if a == None else a.next\n            b = headA if b == None else b.next\n        return a</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>206. 反转链表</h2><p>反转一个单链表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</p><p>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def reverseList(self, head):\n        &#34;&#34;&#34;\n        :type head: ListNode\n        :rtype: ListNode\n        &#34;&#34;&#34;\n        p = head\n        rev = None\n        while p:\n            rev, rev.next, p = p, rev, p.next\n        return rev</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>这段代码妙不可言，利用了多元赋值的时候，右边的值不会随着赋值而改变的特性，下面有解释可以看看</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前置条件：迭代指针：p = head、结果指针：res = none</p><p class=\"ztext-empty-paragraph\"><br/></p><p>以1-&gt;2-&gt;3-&gt;4-&gt;5为例：</p><p>过程：</p><p>res:None</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第一层循环</p><p>res:1-&gt;2-&gt;3-&gt;4-&gt;5\tres = p</p><p>res:1-&gt;None\tres.next = res</p><p>p:2-&gt;3-&gt;4-&gt;5\tp = p.next</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第二层循环</p><p>res:2-&gt;3-&gt;4-&gt;5\tres = p</p><p>res:2-&gt;1-&gt;None\tres.next = res</p><p>p:3-&gt;4-&gt;5\tp = p.next</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第三层循环</p><p>res:3-&gt;4-&gt;5\tres = p</p><p>res:3-&gt;2-&gt;1-&gt;None\tres.next = res</p><p>p:4-&gt;5\tp = p.next</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第四层循环</p><p>res:4-&gt;5\tres = p</p><p>res:4-&gt;3-&gt;2-&gt;1-&gt;None\tres.next = res</p><p>p:5\tp = p.next</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第五层循环</p><p>res:5\tres = p</p><p>res:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;None\tres.next = res</p><p>p:None\tp = p.next</p><p>end...</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>234. 回文链表</h2><p>请判断一个链表是否为回文链表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: 1-&gt;2</p><p>输出: false</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: 1-&gt;2-&gt;2-&gt;1</p><p>输出: true<br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def isPalindrome(self, head):\n        &#34;&#34;&#34;\n        :type head: ListNode\n        :rtype: bool\n        &#34;&#34;&#34;\n        if head == None:\n            return True\n        p = head\n        val = []\n        while(p != None):\n            val.append(p.val)\n            p = p.next\n        return val == val[::-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>83. 删除排序链表中的重复元素</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: 1-&gt;1-&gt;2</p><p>输出: 1-&gt;2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</p><p>输出: 1-&gt;2-&gt;3</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        &#34;&#34;&#34;\n        :type head: ListNode\n        :rtype: ListNode\n        &#34;&#34;&#34;\n        prev = head\n        curr = head\n        form = set()\n        while curr is not None:\n            if curr.val not in form:\n                form.add(curr.val)\n                prev = curr\n            else:\n                prev.next = curr.next \n            curr = curr.next\n        return head</code></pre></div><p>希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "链表", 
                    "tagLink": "https://api.zhihu.com/topics/19649942"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65111787", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 1, 
            "title": "leetcode刷题(十二）：动态规划1（分割整数，矩阵路径）", 
            "content": "<p>动态规划是个值得讨论的话题，我准备分几次进行讨论。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天讲的是动态规划中的分割整数和矩阵路径。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态规划与<u><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU5ODY4NTY3OQ%3D%3D%26mid%3D2247483763%26idx%3D1%26sn%3Daff54c1078897ebe8a1055e92948c3cd%26scene%3D19%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">分治算法</a></u>类似，都是通过组合子问题的解来求解原问题。不一样的是分治算法是将原问题分解为互不相交的子问题，递归的求解子问题，然后将解组合起来。而动态规划应用于求解子问题重叠的情况，也就是不同的子问题会涉及相同的子子问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>普通的递归方法会反复的求解那些公共子问题，因而浪费了时间，动态规划则是对公共子问题只求解一次，然后将其解保存在表格中，避免了不必要的重复工作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态规划通常用来解决最优化问题，这类问题通常有很多可行解，每个解法都有一个值，希望找到具有最优值（最小值或者最大值）的解。这样的解为一个最优解，有可能会有多个解都能得到最优值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态规划的算法步骤如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>       a：描述一个最优解的结构特征；</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>       b：递归定义最优解的值；</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>       c：计算最优解的值，通常采用自底向上的方式计算最优解的值；</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>       d：利用计算出的信息构造一个最优解。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>第1-3步是动态规划求解问题的基础。如果仅需要一个最优解的值，而非最优解本身，则第4步可以忽略。如果需要求得一个最优解，则有时要在第3步的计算中记录一些附加信息，以便用来构造一个最优解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如说，这次的分割整数问题可以看成典型的钢条切割问题，处理这种问题，我们往往遵循着问题的最优解由相关子问题的最优解组合而成，这些子问题可以独立求解来解决。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态规划方法有两种等价的实现方法：<b>自顶向下的方法</b>和<b>自底向上的方法</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>两种方法具有相同的渐进时间，仅有的差异是某些特殊情况下，自顶向下的方法没有真正递归考察所有可能的子问题，因为没有使用递归，所以自底向上的方法的时间复杂度函数通常具有更小的系数。下面来简单介绍下这两种方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1.带备忘的自顶向下方法，该方法与之前的普通递归方法类似，只是会在过程中保存子问题的解，当需要一个子问题的解的时候，先查看是否已经保存过了，如果是，则直接使用即可。否则，按常规的递归方式计算子问题。所以称为带备忘的，因为它记住了之前已经计算出的结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2.自底向上的方法：这种方法要恰当定义子问题的规模，使得任意子问题的求解只依赖于“更小的“子问题解。所以通常按照规模从小到大的顺序进行求解。当求救某个子问题时，它所依赖的更小的子问题的解都已经求解完毕了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天先讲到这，剩下的内容下会慢慢分解吧！~！</p><p>来做点真题！！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>分割整数</b></h2><p><b>343. 整数拆分</b></p><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: 2</p><p>输出: 1</p><p>解释: 2 = 1 + 1, 1 × 1 = 1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: 10</p><p>输出: 36</p><p>解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。</p><p>说明: 你可以假设 n 不小于 2 且不大于 58。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def integerBreak(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        res = 1\n        lookup = {2,3,4}\n        if n == 3:\n            return 2\n        if n == 2:\n            return 1\n        while n:\n            while n &gt; 4:\n                n -= 3\n                res *= 3\n            if n in lookup:\n                res *= n\n                n -= n\n        return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>279. 完全平方数</b></p><p>给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: n = 12</p><p>输出: 3 </p><p>解释: 12 = 4 + 4 + 4.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: n = 13</p><p>输出: 2</p><p>解释: 13 = 4 + 9.</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def numSquares(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        while n % 4 == 0:\n            n /= 4\n        while (n-7)%8 == 0:\n            return 4\n        a = 0\n        while a**2 &lt;n:\n            b = int((n - a**2)**0.5)\n            if a**2 + b**2 == n:\n                return (not not a) + (not not b)\n            a += 1\n        return 3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>这题本质上是一道数学题，我们需要用到一个定律：<b>四平方和定理</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>四平方定理： 任何一个正整数都可以表示成不超过四个整数的平方之和。<br/></blockquote><p>那么我们这个问题的解法就变得很简单了，我们的结果只有1,2,3,4，四种可能。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>另外还有一个非常重要的推论：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>满足四数平方和定理的数n（这里要满足由四个数构成，小于四个不行），必定满足 n=4a(8b+7) n = 4^a(8b + 7)n</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>知道这个重要的推论后，代码就很简单了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们首先将输入的n迅速缩小。然后我们再判断，这个缩小后的数是否可以通过两个平方数的和或一个平方数组成，不能的话我们返回3，能的话我们返回平方数的个数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在我们的问题已经缩减到了，怎么判断一个数是由一个还是由两个平方数的和构成？对于这个问题，我们当然可以暴力破解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>91. 解码方法</b></p><p>一条包含字母 A-Z 的消息通过以下方式进行了编码：</p><p>&#39;A&#39; -&gt; 1</p><p>&#39;B&#39; -&gt; 2</p><p>...</p><p>&#39;Z&#39; -&gt; 26</p><p>给定一个只包含数字的非空字符串，请计算解码方法的总数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: &#34;12&#34;</p><p>输出: 2</p><p>解释: 它可以解码为 &#34;AB&#34;（1 2）或者 &#34;L&#34;（12）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: &#34;226&#34;</p><p>输出: 3</p><p>解释: 它可以解码为 &#34;BZ&#34; (2 26), &#34;VF&#34; (22 6), 或者 &#34;BBF&#34; (2 2 6) 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def numDecodings(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: int\n        &#34;&#34;&#34;\n        if len(s) == 1:\n            if s in list(&#39;123456789&#39;):\n                return 1\n            return 0\n        if not s:\n            return 0\n        if len(s) == 2:\n            res = 0\n            if 9&lt;int(s)&lt;27:\n                res += 1\n            if s[0] in list(&#39;123456789&#39;) and s[1] in list(&#39;123456789&#39;):\n                res += 1\n            return res\n        res = 0\n        if s[0] in list(&#39;123456789&#39;):\n            res += self.numDecodings(s[1:])\n        if 9&lt;int(s[:2])&lt;27:\n            res += self.numDecodings(s[2:])\n        return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>矩阵路径</b></h2><p><b>62. 不同路径</b></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-577e28874d813f6092c18f1df82451e5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"183\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;183&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"183\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic2.zhimg.com/v2-577e28874d813f6092c18f1df82451e5_b.jpg\"/></figure><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如，上图是一个7 x 3 的网格。有多少可能的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p>解释:</p><p>从左上角开始，总共有 3 条路径可以到达右下角。</p><p>1. 向右 -&gt; 向右 -&gt; 向下</p><p>2. 向右 -&gt; 向下 -&gt; 向右</p><p>3. 向下 -&gt; 向右 -&gt; 向右</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def uniquePaths(self, m, n):\n        &#34;&#34;&#34;\n        :type m: int\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        if n &lt; 0 and m &lt; 0:\n            return 0\n        res = [0 for i in range(n)]\n        res[0] = 1\n        for i in range(m):\n            for j in range(1,n):\n                res[j] += res[j-1]\n        return res[-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>64. 最小路径和</b></p><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><p>说明：每次只能向下或者向右移动一步。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>输入:</p><p>[ [1,3,1],</p><p>  [1,5,1],</p><p>  [4,2,1]]</p><p>输出: 7</p><p>解释: 因为路径 1→3→1→1→1 的总和最小。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def minPathSum(self, grid):\n        &#34;&#34;&#34;\n        :type grid: List[List[int]]\n        :rtype: int\n        &#34;&#34;&#34;\n        if not grid or not grid[0]:\n            return 0\n        m,n = len(grid),len(grid[0])    \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        dp[0][0] = grid[0][0]\n        for i in range(1,n):\n            dp[0][i] = grid[0][i] + dp[0][i-1]\n        for i in range(1,m):\n            dp[i][0] = grid[i][0] + dp[i-1][0]\n        for i in range(1,m):\n            for j in range(1,n):\n                dp[i][j] = grid[i][j] + min(dp[i-1][j],dp[i][j-1])\n        return dp[m-1][n-1]</code></pre></div><p>希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习心得，喜欢可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "动态规划", 
                    "tagLink": "https://api.zhihu.com/topics/19660018"
                }, 
                {
                    "tag": "整数规划", 
                    "tagLink": "https://api.zhihu.com/topics/20029794"
                }, 
                {
                    "tag": "路径规划", 
                    "tagLink": "https://api.zhihu.com/topics/20206646"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63272157", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "leetcode刷题(十）：树（红黑树，B树）", 
            "content": "<p>接上篇文章，这次来讲讲红黑树和B树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>先来讲红黑树：</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>红黑树</b></h2><h3>定义和性质</h3><p>在了解红黑树之前，我们先要了解下二叉查找树（其实就是下面的B树，怕我的文章小伙伴没耐心看，所以把难的红黑树先放上来讲哈哈）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二叉查找树其实很简单，就是一颗树，每个左孩子都比双亲小，每个右孩子都比双亲大，同时左右二叉树必须为二分排查序树。<br/></p><p>所以在插着一个特定数字的时候就很显然了，如果根比所求数字小，转到右孩子，否则转到左孩子，知道找到所求的数字位为止，妥妥的二分查找法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是你有没有想过一种可能，最大的数字作为根，第二大的作为左孩子，第三大的作为左孩子的左孩子，就这样成为了一个坡脚的二叉树？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为了解决这个问题，我们给红黑树增加了一些限制，它必须满足下面性质：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>性质1：每个节点要么是黑色，要么是红色。</p><p>性质2：根节点是黑色。</p><p>性质3：每个叶子节点（NIL）是黑色。</p><p>性质4：每个红色结点的两个子结点一定都是黑色。</p><p>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解决了这个问题后，我们就能进行红黑树的查找：</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>红黑树查找</b></h3><p>因为红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡，所以查找跟二叉平衡树的查找无异：<br/></p><p>从根结点开始查找，把根结点设置为当前结点；</p><p>若当前结点为空，返回null；</p><p>若当前结点不为空，用当前结点的key跟查找key作比较；</p><p>若当前结点key等于查找key，那么该key就是查找目标，返回当前结点；</p><p>若当前结点key大于查找key，把当前结点的左子结点设置为当前结点，重复步骤2；</p><p>若当前结点key小于查找key，把当前结点的右子结点设置为当前结点，重复步骤2；</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ddbe0f7b6931f92a9b8f0b098a9499f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"782\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-ddbe0f7b6931f92a9b8f0b098a9499f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;782&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"782\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic1.zhimg.com/v2-ddbe0f7b6931f92a9b8f0b098a9499f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ddbe0f7b6931f92a9b8f0b098a9499f4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们要讲讲插入和删除的操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>删除操作</b>： </h3><ol><li>如果删除的是叶节点，可以直接删除； </li><li>如果被删除的元素有一个子节点，可以将子节点直接移到被删除元素的位置； </li><li>如果有两个子节点，这时候就可以把被删除元素的右支的最小节点（被删除元素右支的最左边的节点）和被删除元素互换，我们把被删除元素右支的最左边的节点称之为后继节点（后继元素），然后在根据情况1或者情况2进行操作。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>插入操作和删除操作差不多，重点在下面！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在插入和删除过程中，我们往往会违反五条性质，这时候我们就需要作相应的调整，我们称之为变色和旋转。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>变色就是红变黑，黑变红，为了满足五条性质。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而旋转的目的是<b>将节点多的一支出让节点给另一个节点少的一支</b>，我从网上找来了几张gif，希望能帮你更好地理解。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>右旋：</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-772eb4f59b7f5ba6da045f220a506d04_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"258\" data-thumbnail=\"https://pic1.zhimg.com/v2-772eb4f59b7f5ba6da045f220a506d04_b.jpg\" class=\"content_image\" width=\"301\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;301&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"258\" data-thumbnail=\"https://pic1.zhimg.com/v2-772eb4f59b7f5ba6da045f220a506d04_b.jpg\" class=\"content_image lazy\" width=\"301\" data-actualsrc=\"https://pic1.zhimg.com/v2-772eb4f59b7f5ba6da045f220a506d04_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>左旋：</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a67ef9b23e69dd62784dda2dda9b922a_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"241\" data-thumbnail=\"https://pic3.zhimg.com/v2-a67ef9b23e69dd62784dda2dda9b922a_b.jpg\" class=\"content_image\" width=\"329\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;329&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"241\" data-thumbnail=\"https://pic3.zhimg.com/v2-a67ef9b23e69dd62784dda2dda9b922a_b.jpg\" class=\"content_image lazy\" width=\"329\" data-actualsrc=\"https://pic3.zhimg.com/v2-a67ef9b23e69dd62784dda2dda9b922a_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>总结一下</b></h3><ol><li>红黑树的实现其实是一个2、3、4树，只是将双节点或者三节点用红色进行了标示，如果你将红色节点放到和它父元素相同的高度，并把它和父元素看做是一个元素，你就会发现，变成了一个高度为lgN的二叉树，这个2.3.4树对红黑树很有启发意义。 </li><li>具体变化的步骤其实可以不用死记硬背，是可以推导出来的，因为我们是把一个平衡但通过插入或者删除破坏了平衡的红黑树再次平衡，同过旋转让位，改变红黑颜色，使之符合那五条基本性质。比如遇到删除操作情况四的时候，我们可以把那个删除元素去除，发现左边比右边少一个黑元素，这个时候，怎么办，我们发现兄弟节点的子元素有一个红元素，操作这个不会影响那五条性质，所以我们通过变换颜色，旋转，即可让左右两边的的黑色数目一样。 </li><li>旋转操作的目的是出让一个元素到另外的地方并且符合二叉树左小右大的性质，交换颜色的目的是为了保持红黑树的那五条性质。 </li><li>要时刻记得 ，一切的操作都是为了保持那五条性质。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是用python实现红黑树的过程：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># coding=utf-8\n# 红黑树Python实现\n\n\n# 颜色常量\nRED = 0\nBLACK = 1\n\n\n\n\ndef left_rotate(tree, node):\n    if not node.right:\n        return False\n    node_right = node.right\n    node_right.p = node.p\n    if not node.p:\n        tree.root = node_right\n    elif node == node.p.left:\n        node.p.left = node_right\n    else:\n        node.p.right = node_right\n    if node_right.left:\n        node_right.left.p = node\n    node.right = node_right.left\n    node.p = node_right\n    node_right.left = node\n\n\n\n\ndef right_rotate(tree, node):\n    if not node.left:\n        return False\n    node_left = node.left\n    node_left.p = node.p\n    if not node.p:\n        tree.root = node_left\n    elif node == node.p.left:\n        node.p.left = node_left\n    elif node == node.p.right:\n        node.p.right = node_left\n    if node_left.right:\n        node_left.right.p = node\n    node.left = node_left.right\n    node.p = node_left\n    node_left.right = node\n\n\n\n\ndef transplant(tree, node_u, node_v):\n    &#34;&#34;&#34;\n    用 v 替换 u\n    :param tree: 树的根节点\n    :param node_u: 将被替换的节点\n    :param node_v: 替换后的节点\n    :return: None\n    &#34;&#34;&#34;\n    if not node_u.p:\n        tree.root = node_v\n    elif node_u == node_u.p.left:\n        node_u.p.left = node_v\n    elif node_u == node_u.p.right:\n        node_u.p.right = node_v\n    # 加一下为空的判断\n    if node_v:\n        node_v.p = node_u.p\n\n\n\n\ndef tree_maximum(node):\n    &#34;&#34;&#34;\n    找到以 node 节点为根节点的树的最大值节点 并返回\n    :param node: 以该节点为根节点的树\n    :return: 最大值节点\n    &#34;&#34;&#34;\n    temp_node = node\n    while temp_node.right:\n        temp_node = temp_node.right\n    return temp_node\n\n\n\n\ndef tree_minimum(node):\n    &#34;&#34;&#34;\n    找到以 node 节点为根节点的树的最小值节点 并返回\n    :param node: 以该节点为根节点的树\n    :return: 最小值节点\n    &#34;&#34;&#34;\n    temp_node = node\n    while temp_node.left:\n        temp_node = temp_node.left\n    return temp_node\n\n\n\n\ndef preorder_tree_walk(node):\n    if node:\n        print (node.value, node.color)\n        preorder_tree_walk(node.left)\n        preorder_tree_walk(node.right)\n\n\n\n\nclass RedBlackTreeNode(object):\n    def __init__(self, value):\n        self.value = value\n        self.left = None\n        self.right = None\n        self.p = None\n        self.color = RED\n\n\n\n\nclass RedBlackTree(object):\n    def __init__(self):\n        self.root = None\n\n\n    def insert(self, node):\n        # 找到最接近的节点\n        temp_root = self.root\n        temp_node = None\n        while temp_root:\n            temp_node = temp_root\n            if node.value == temp_node.value:\n                return False\n            elif node.value &gt; temp_node.value:\n                temp_root = temp_root.right\n            else:\n                temp_root = temp_root.left\n        # 在相应位置插入节点\n        if not temp_node:\n            self.root = node\n            node.color = BLACK\n        elif node.value &lt; temp_node.value:\n            temp_node.left = node\n            node.p = temp_node\n        else:\n            temp_node.right = node\n            node.p = temp_node\n        # 调整树\n        self.insert_fixup(node)\n\n\n    def insert_fixup(self, node):\n        if node.value == self.root.value:\n            return\n        # 为什么是这个终止条件？\n        # 因为如果不是这个终止条件那就不需要调整\n        while node.p and node.p.color == RED:\n            # 只要进入循环则必有祖父节点 否则父节点为根节点 根节点颜色为黑色 不会进入循环\n            if node.p == node.p.p.left:\n                node_uncle = node.p.p.right\n                # 1. 没有叔叔节点 若此节点为父节点的右子 则先左旋再右旋 否则直接右旋\n                # 2. 有叔叔节点 叔叔节点颜色为黑色\n                # 3. 有叔叔节点 叔叔节点颜色为红色 父节点颜色置黑 叔叔节点颜色置黑 祖父节点颜色置红 continue\n                # 注: 1 2 情况可以合为一起讨论 父节点为祖父节点右子情况相同 只需要改指针指向即可\n                if node_uncle and node_uncle.color == RED:\n                    node.p.color = BLACK\n                    node_uncle.color = BLACK\n                    node.p.p.color = RED\n                    node = node.p.p\n                    continue\n                elif node == node.p.right:\n                    left_rotate(self, node.p)\n                    node = node.left\n                node.p.color = BLACK\n                node.p.p.color = RED\n                right_rotate(self, node.p.p)\n                return\n            elif node.p == node.p.p.right:\n                node_uncle = node.p.p.left\n                if node_uncle and node_uncle.color == RED:\n                    node.p.color = BLACK\n                    node_uncle.color = BLACK\n                    node.p.p.color = RED\n                    node = node.p.p\n                    continue\n                elif node == node.p.left:\n                    right_rotate(self, node)\n                    node = node.right\n                node.p.color = BLACK\n                node.p.p.color = RED\n                left_rotate(self, node.p.p)\n                return\n        # 最后记得把根节点的颜色改为黑色 保证红黑树特性\n        self.root.color = BLACK\n\n\n    def delete(self, node):\n        # 找到以该节点为根节点的右子树的最小节点\n        node_color = node.color\n        if not node.left:\n            temp_node = node.right\n            transplant(self, node, node.right)\n        elif not node.right:\n            temp_node = node.left\n            transplant(self, node, node.left)\n        else:\n            # 最麻烦的一种情况 既有左子 又有右子 找到右子中最小的做替换 类似于二分查找树的删除\n            node_min = tree_minimum(node.right)\n            node_color = node_min.color\n            temp_node = node_min.right\n            if node_min.p != node:\n                transplant(self, node_min, node_min.right)\n                node_min.right = node.right\n                node_min.right.p = node_min\n            transplant(self, node, node_min)\n            node_min.left = node.left\n            node_min.left.p = node_min\n            node_min.color = node.color\n        # 当删除的节点的颜色为黑色时 需要调整红黑树\n        if node_color == BLACK:\n            self.delete_fixup(temp_node)\n\n\n    def delete_fixup(self, node):\n        # 实现过程还需要理解 比如为什么要删除 为什么是那几种情况\n        while node != self.root and node.color == BLACK:\n            if node == node.p.left:\n                node_brother = node.p.right\n                if node_brother.color == RED:\n                    node_brother.color = BLACK\n                    node.p.color = RED\n                    left_rotate(self, node.p)\n                    node_brother = node.p.right\n                if (not node_brother.left or node_brother.left.color == BLACK) and \\\n                        (not node_brother.right or node_brother.right.color == BLACK):\n                    node_brother.color = RED\n                    node = node.p\n                else:\n                    if not node_brother.right or node_brother.right.color == BLACK:\n                        node_brother.color = RED\n                        node_brother.left.color = BLACK\n                        right_rotate(self, node_brother)\n                        node_brother = node.p.right\n                    node_brother.color = node.p.color\n                    node.p.color = BLACK\n                    node_brother.right.color = BLACK\n                    left_rotate(self, node.p)\n                node = self.root\n                break\n            else:\n                node_brother = node.p.left\n                if node_brother.color == RED:\n                    node_brother.color = BLACK\n                    node.p.color = RED\n                    left_rotate(self, node.p)\n                    node_brother = node.p.right\n                if (not node_brother.left or node_brother.left.color == BLACK) and \\\n                        (not node_brother.right or node_brother.right.color == BLACK):\n                    node_brother.color = RED\n                    node = node.p\n                else:\n                    if not node_brother.left or node_brother.left.color == BLACK:\n                        node_brother.color = RED\n                        node_brother.right.color = BLACK\n                        left_rotate(self, node_brother)\n                        node_brother = node.p.left\n                    node_brother.color = node.p.color\n                    node.p.color = BLACK\n                    node_brother.left.color = BLACK\n                    right_rotate(self, node.p)\n                node = self.root\n                break\n        node.color = BLACK\n\n\n\n\ndef main():\n    number_list = (7, 4, 1, 8, 5, 2, 9, 6, 3)\n    tree = RedBlackTree()\n    for number in number_list:\n        node = RedBlackTreeNode(number)\n        tree.insert(node)\n        del node\n    preorder_tree_walk(tree.root)\n    tree.delete(tree.root)\n    preorder_tree_walk(tree.root)\n\n\nif __name__ == &#39;__main__&#39;:\n    main()</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>B树</b></h2><p>接下来介绍下B树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B树即就是之前说过的二叉查找树（BST）：</p><ol><li>所有非叶子结点至多拥有两个儿子（Left和Right）；</li><li>所有结点存储一个关键字；</li><li>非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>B树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；</p><p><br/>如果B树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树</p><p>的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变B树结构</p><p>（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>红黑树家族还有很多成员，我来简单做个介绍！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B树：二叉树，每个结点只存储一个关键字，等于则命中，小于走左结点，大于走右结点；</p><p>B-树：多路搜索树，每个结点存储M/2到M个关键字，非叶子结点存储指向关键字范围的子结点；</p><p>所有关键字在整颗树中出现，且只出现一次，非叶子结点可以命中；</p><p>B+树：在B-树基础上，为叶子结点增加链表指针，所有关键字都在叶子结点中出现，非叶子结点作为叶子结点的索引；B+树总是到叶子结点才命中；</p><p>B*树：在B+树基础上，为非叶子结点也增加链表指针，将结点的最低利用率从1/2提高到2/3；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是看着和红黑树很像？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么我们为什么还需要B树呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我来讲一下红黑树和B树的区别。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的 B树的高度也为O（lgn） ，但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以， B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B树是为了磁盘或其它存储设备而设计的一种多叉（之前提到过，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。与红黑树很相似，但在降低磁盘I/0操作方面要更好一些。 许多数据库系统都一般使用B树或者B树的各种变形结构。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是B树有个缺点，就是维护起来比较麻烦（插入和删除之后，都需要rebalance，而且每次插入和删除的平均旋转次数应该是远大于红黑树）。但是，红黑树通过它规则的设定，确保了插入和删除的最坏的时间复杂度是O(log N) 。设计红黑树的目的，就是解决平衡树的维护起来比较麻烦的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>208. 实现 Trie (前缀树)</h3><p>实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>Trie trie = new Trie();</p><p>trie.insert(&#34;apple&#34;);</p><p>trie.search(&#34;apple&#34;);   // 返回 true</p><p>trie.search(&#34;app&#34;);     // 返回 false</p><p>trie.startsWith(&#34;app&#34;); // 返回 true</p><p>trie.insert(&#34;app&#34;);   </p><p>trie.search(&#34;app&#34;);     // 返回 true</p><p class=\"ztext-empty-paragraph\"><br/></p><p>说明:</p><p>你可以假设所有的输入都是由小写字母 a-z 构成的。</p><p>保证所有输入均为非空字符串。</p><p><br/>这题有点头疼，我来分析下</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1. insert操作：</p><p>对于insert操作，我们可以只需要遍历字符串，如果当前字符不存在的话，就新建字符节点，如果存在的话，就继续遍历下一个字符，当遍历完最后一个节点的时候，需要把最后一个节点的isTrie设置为true，代表着这里保存了一个字符串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2. search操作</p><p>对于search操作，我们可以只需要遍历字符串，从trie树的根节点查找，如果匹配则继续，不匹配则返回FALSE。当遍历完最后一个字符串的时候，需要判断最后一个节点是否保存了字符串，如果没有，则返回FALSE，反之返回TRUE</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3. startsWith操作</p><p>startsWith的操作和search操作一样，唯一不同点在于，当遍历结束后，可以直接返回TRUE<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class TrieNode():\n    def __init__(self):\n        self.nodes = [None] * 26\n        self.last = False\nclass Trie(object):\n\n\n    def __init__(self):\n        &#34;&#34;&#34;\n        Initialize your data structure here.\n        &#34;&#34;&#34;\n        self.root = TrieNode()\n\n\n    def insert(self, word):\n        &#34;&#34;&#34;\n        Inserts a word into the trie.\n        :type word: str\n        :rtype: None\n        &#34;&#34;&#34;\n        tree = self.root\n        while (word):\n            temp = word[0]\n            word=word[1:]\n            if tree.nodes[ord(temp) - ord(&#39;a&#39;)]==None:\n                tree.nodes[ord(temp) - ord(&#39;a&#39;)] = TrieNode()\n            tree = tree.nodes[ord(temp) - ord(&#39;a&#39;)]\n        tree.last = True\n\n\n    def search(self, word):\n        &#34;&#34;&#34;\n        Returns if the word is in the trie.\n        :type word: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        if word==&#39;&#39;:\n            return True\n        tree=self.root\n        while(word):\n            temp = word[0]\n            word = word[1:]\n            if tree.nodes[ord(temp)-ord(&#39;a&#39;)]==None:\n                return False\n            tree=tree.nodes[ord(temp)-ord(&#39;a&#39;)]\n        return tree.last\n\n\n\n\n    def startsWith(self, prefix):\n        &#34;&#34;&#34;\n        Returns if there is any word in the trie that starts with the given prefix.\n        :type prefix: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        tree=self.root\n        while(prefix):\n            temp=prefix[0]\n            prefix=prefix[1:]\n            if tree.nodes[ord(temp)-ord(&#39;a&#39;)]==None:\n                return False\n            tree=tree.nodes[ord(temp)-ord(&#39;a&#39;)]\n        return True</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>543. 二叉树的直径</h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过根结点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 :</p><p>给定二叉树</p><p class=\"ztext-empty-paragraph\"><br/></p><p>          1</p><p>         / \\</p><p>        2   3</p><p>       / \\     </p><p>      4   5    </p><p class=\"ztext-empty-paragraph\"><br/></p><p>返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：两结点之间的路径长度是以它们之间边的数目表示。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution(object):\n    def diameterOfBinaryTree(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: int\n        &#34;&#34;&#34;\n        self.max_deep = 0\n        self.deep_tree(root)\n        return self.max_deep\n \n    def deep_tree(self,root):\n        if root is None:\n            return 0\n        left_deep = self.deep_tree(root.left)\n        right_deep = self.deep_tree(root.right)\n        if left_deep + right_deep &gt; self.max_deep:\n            self.max_deep = left_deep + right_deep\n        return max(left_deep+1,right_deep+1)</code></pre></div><p>希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "红黑树", 
                    "tagLink": "https://api.zhihu.com/topics/19648609"
                }, 
                {
                    "tag": "B/B+树", 
                    "tagLink": "https://api.zhihu.com/topics/20091609"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62859435", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 2, 
            "title": "leetcode刷题(九）：树（二叉树）", 
            "content": "<p>今天我们来讲一讲树吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这次主要以普通的二叉树为主，我们下次再讲红黑树和B树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>树的基本概念很简单，我们就粗略过一下吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>树是一种数据结构，它是由n（n&gt;=1）个有限结点组成一个具有层次关系的集合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>结点拥有的子树的个数称之为结点的度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>书中结点的最大层次称之为树的深度或者高度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在树的存储结构中，我没有很多种表示方法：双亲表示法，孩子表示法，孩子兄弟表示法等。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>双亲表示法：</b></h3><p>就是在下标，data的基础上，根据需要增加所需要的域，比如parent，firstchild，rightsib等，这是一个非常灵活的过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>孩子表示法：</b></h3><p>把每个结点的孩子排列起来，以单链表作为储存结构，则n个结点有n个孩子链表，如果叶子节点，则此链表为空。然后n个头指针又组成一个线性表，采用顺序储存结构，存放进一个一维数组中。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b> 孩子兄弟表示法：</b></h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们要设置两个指针，分别指向该节点的第一个孩子和此节点的右兄弟。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二叉树的性质：</b></h2><ol><li>在二叉树的i层上至多有2^(i-1)个结点（i&gt;=1）</li><li>深度为k的二叉树至多有2^k-1个结点</li><li>对于任何一棵二叉树，如果其终端结点为n0，度为2的节点数为n2，则n0=n2+1</li><li>具有n个结点的完全二叉树的深度为lgn+1</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二叉树的遍历：</b></h2><p>前序，中序，后序，层序遍历，这些我也就不多嘴了。</p><p>就讲一个小tip，如何确定一棵二叉树呢？</p><p>我们必须要知道前序和中序，或者后序和中序。</p><p>那么只知道前序和后序可以吗？</p><p>为什么不可以呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>树，二叉树，森林的转换：</b></h2><h3><b>树转换为二叉树</b></h3><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。树中的每个结点，只保留它与第一个孩子结点的连线，删除它与其它孩子结点之间的连线。</li><li>层次调整。以树的根节点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明。（注意第一个孩子是结点的左孩子，兄弟转换过来的孩子是结点的右孩子）</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>森林转换为二叉树</b></h3><ol><li>把每棵树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。<br/></li></ol><h3><b>二叉树转换为树</b></h3><p>这是树转换为二叉树的逆过程。</p><ol><li>加线。若某结点X的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点…，都作为结点X的孩子。将结点X与这些右孩子结点用线连接起来。</li><li>去线。删除原二叉树中所有结点与其右孩子结点的连线。</li><li>层次调整。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>赫夫曼树</b></h2><p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径WPL长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。给定n个权值作为n的叶子结点，构造一棵二叉树，若带权路径WPL长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>如何构造赫夫曼树：</b></h3><ol><li>根据给定的n个权值{w1, w2, w3 … wn}构成n棵二叉树的集合F={T1, T2, … Tn}。其中每棵二叉树Ti中只有一个带权为wi根节点，其左右子树均为空。</li><li>在F中选取两棵根节点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的根节点的权值为其左右子树上跟结点的权值之和。</li><li>在F中删除这两棵树，同时将新得到的二叉树加入F中。</li><li>重复2和3，直到F只包含一棵树为止，这棵树就是赫夫曼树。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>赫夫曼树的应用：赫夫曼编码</b></h3><p>假设我们要给别人发送BADCADFEED，全部展开成二进制，是3*10共30位。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>按照二进制的编码来计算是很自然的想法：A:000,B:001,C:010,D:011,E:100,F:101</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但这多浪费啊，如F只出现了一次，而我们却硬生生给他单独创造了一个二进制数，有没有更好的办法呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但其实出现的是有概率的，比如E出现的多，F出现的少，我们就可以假定6个字母的频率为A27 B8 C15 D15 E30 F5</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再把它们转换成赫夫曼树，然后将权值左分支改为0，右分支改为1，得到：A:01,B:1001,C:101,D:00,E:11,F:1000</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可以看出，使用频率高的字母所对应的二进制编码也比较短，而出现概率低的字母所对应的二进制编码就比较长了。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>这次就先讲到这了，下回我们再讲红黑树和B树，这次真题也蛮多的，大家可以好好练练！~！<br/></p><hr/><h3>104. 二叉树的最大深度</h3><p>给定一个二叉树，找出其最大深度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br/></p><p>说明: 叶子节点是指没有子节点的节点。<br/></p><p>示例：</p><p>给定二叉树 [3,9,20,null,null,15,7]，</p><p>    3</p><p>   / \\</p><p>  9  20</p><p>      /  \\</p><p>    15   7</p><p>返回它的最大深度 3 。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution(object):\n    def maxDepth(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: int\n        &#34;&#34;&#34;\n        if not root:\n            return 0\n        left = self.maxDepth(root.left) + 1\n        right = self.maxDepth(root.right) + 1\n\n        return max(left,right)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>617. 合并二叉树</h3><p>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: </p><p>\tTree 1                     Tree 2                  </p><p>          1                         2                             </p><p>         / \\                       / \\                            </p><p>        3   2                     1   3                        </p><p>       /                               \\   \\                      </p><p>      5                                 4   7                  </p><p>输出: </p><p>合并后的树:</p><p>\t     3</p><p>\t    / \\</p><p>\t   4   5</p><p>\t  / \\     \\ </p><p>\t 5   4     7</p><p>注意: 合并必须从两个树的根节点开始。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution(object):\n    def mergeTrees(self, t1, t2):\n        &#34;&#34;&#34;\n        :type t1: TreeNode\n        :type t2: TreeNode\n        :rtype: TreeNode\n        &#34;&#34;&#34;\n        if not t1:\n            return t2\n        if not t2:\n            return t1\n        t1.val += t2.val\n        t1.left = self.mergeTrees(t1.left,t2.left)\n        t1.right = self.mergeTrees(t1.right,t2.right)\n        return t1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>112. 路径总和</h3><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>说明: 叶子节点是指没有子节点的节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例: </p><p>给定如下二叉树，以及目标和 sum = 22，</p><p>              5</p><p>             / \\</p><p>            4   8</p><p>           /   / \\</p><p>          11  13  4</p><p>         /  \\       \\</p><p>        7    2       1</p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution(object):\n    def hasPathSum(self, root, sum):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        if root == None:\n            return False\n        sum -= root.val\n        if root.left == None  and root.right == None:\n            return sum == 0\n        else:\n            return self.hasPathSum(root.left,sum) or self.hasPathSum(root.right,sum)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>230. 二叉搜索树中第K小的元素</h3><p>给定一个二叉搜索树，编写一个函数 kthSmallest 来查找其中第 k 个最小的元素。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>说明：</p><p>你可以假设 k 总是有效的，1 ≤ k ≤ 二叉搜索树元素个数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: root = [3,1,4,null,2], k = 1</p><p>   3</p><p>  / \\</p><p> 1   4</p><p>    \\</p><p>     2</p><p>输出: 1</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: root = [5,3,6,2,4,null,null,1], k = 3</p><p>       5</p><p>      / \\</p><p>     3   6</p><p>    / \\</p><p>   2   4</p><p>  /</p><p> 1</p><p>输出: 3</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\n\nclass Solution(object):\n    def countNodes(self,root):\n        if root == None:\n            return 0\n        else:\n            return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n \n    def kthSmallest(self, root, k):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :type k: int\n        :rtype: int\n        &#34;&#34;&#34;\n        if root == None:\n            return None\n        leftcount = self.countNodes(root.left)\n        if k &lt; leftcount + 1:\n            return self.kthSmallest(root.left,k)\n        elif k == leftcount + 1:\n            return root.val\n        else:\n            return self.kthSmallest(root.right,k-1-leftcount)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>101. 对称二叉树</h3><p>给定一个二叉树，检查它是否是镜像对称的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>    1</p><p>   / \\</p><p>  2   2</p><p> / \\ / \\</p><p>3  4 4  3</p><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><p class=\"ztext-empty-paragraph\"><br/></p><p>    1</p><p>   / \\</p><p>  2   2</p><p>     \\   \\</p><p>      3    3</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isSymmetric(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: bool\n        &#34;&#34;&#34;\n        def check(root1,root2):\n            if not root1 and not root2:\n                return True \n            elif not root1 or not root2:\n                return False\n            if root1.val != root2.val:\n                return False\n            return check(root1.left,root2.right) and check(root1.right,root2.left)\n        return check(root,root)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>669. 修剪二叉搜索树</h3><p>给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R&gt;=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: </p><p>    1</p><p>   / \\</p><p>  0   2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  L = 1</p><p>  R = 2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>输出: </p><p>    1</p><p>      \\</p><p>       2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: </p><p>    3</p><p>   / \\</p><p>  0   4</p><p>   \\</p><p>    2</p><p>   /</p><p>  1</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  L = 1</p><p>  R = 3</p><p class=\"ztext-empty-paragraph\"><br/></p><p>输出: </p><p>      3</p><p>     / </p><p>   2   </p><p>  /</p><p> 1</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def trimBST(self, root, L, R):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :type L: int\n        :type R: int\n        :rtype: TreeNode\n        &#34;&#34;&#34;\n        if not root:\n            return \n        if L &gt; root.val:\n            return self.trimBST(root.right,L,R)\n        elif R &lt; root.val:\n            return self.trimBST(root.left,L,R)\n        else:\n            root.left = self.trimBST(root.left,L,R)\n            root.right = self.trimBST(root.right,L,R)\n            return root</code></pre></div><p> 差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "树（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/19680489"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "二叉树", 
                    "tagLink": "https://api.zhihu.com/topics/19698867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62230128", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 2, 
            "title": "leetcode刷题(八）：哈希表和字符串", 
            "content": "<p>今天我们要来讲讲哈希表和字符串的故事，今这一期的题目也会比较多一点，方便大家练练手。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>哈希表</h2><p>哈希表也称之为散列表，散列技术是指记录在存储位置和它的关键字之间建立一个稳定的对应关系f，每个关键字key对应一个存储位置f（key）。查找时，根据这个确定的对应关系找到给定的key值的映射f（key），若查找集合中存在这个记录，则必定在f（key）的位置上。</p><p>采用散列技术将记录存储在一块连续的存储空间中，这块连续的存储空间称之为散列表或者哈希表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是我们有时回遇到一个问题：如果有两个关键字key1!=key2，但是却有f(key1)=f(key2)，我们把这称之为冲突，那么该怎么解决冲突呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我要介绍两种最简单的解决冲突的方法：链接法和开放寻址法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>链接法</b></h3><p>在链接法中，我们把所有散列到同一槽中的元素都放入一个链表中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子，k1,k2,k3都指向了同一个槽的位置，那么我们可以把指向这个槽的三个关键字放在一个链表上，从而产出一个长度为3的链表。当然了，如果链表是支持删除操作的。为了更快的删除某一元素，我们应该将链表设计成双向链接的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>开放寻址法</b></h3><p>开放寻址法把所有的元素都存放在散列表中，也就是每个表项包含动态集合的一个元素，如果没有，就指向NIL。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个思想有点像桶排序！~！当查找一个元素时，要检查所有的表项，直到找到所需的元素，或者最终发现元素不在表中。不像在链接法中，这里没有链表，也没有元素存放在散列表外。在这里散列表有可能会被填满，但是装载因子（动态集合元素/散列槽数）绝对不会大于1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>开放寻址法的好处在于它不需要使用指针，而是计算出需要存取的槽序列。所以不用存储指针而节省空间，使得可以使用同样的空间来提供更多的槽，潜在地减少了冲突，提高了检索速度。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>字符串</b></h3><p>字符串就是由零个或者多个字符组成的有限序列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再多的介绍我就不讲了，都是基础，下面我主要讲的就是串的匹配模式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>朴素的模式匹配算法</b></h2><p>简单来说，就是对于主串的每一个字符作为字串的开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或者全部遍历完成为止。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们来看下时间复杂度，如果从001000000000里面去查找001，那么时间复杂度就是O(n+m)，其中n是主串的长度，而m是匹配的子串的长度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是在最坏的情况下呢？举个栗子：在0000000001中查找001字符串，那么每次匹配失败都发生在最后一个字符串匹配的时候，这是个很极端的栗子，时间复杂度为O((n-m+1)*m)。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>KMP模式匹配算法</b></h2><p>你能忍受这么低效的朴素模式匹配吗？反正有些大佬就不能，所以他们提出了KMP模式匹配算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们还是用栗子来说明下吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子，我们要在12345678912346中匹配12346，第一次匹配是1234成功直到最后一位6没有匹配成功。那么我们就直接进行下一轮匹配了吗？等等，我们发现匹配串12346中，第一位1和后面几位2346都不一样，而前面我们已经知道匹配串中，1234这几位是匹配成功的，这也意味着我们知道后面234的匹配都是没有必要的，因为我们不匹配也知道它们是不可能相等的，我们可以直接进行第五位的匹配。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这其实就是KMP算法的关键。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们先把主串中的指针设为i，匹配串中的指针设为j，我们发现，在之前的朴素匹配算法中，i是不停地回溯来完成成匹配的。而我们的KMP就是为了摒弃这种不必要的回溯的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>既然i不需要回溯，也就是i不会变小，那么我们就要从j下手了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前面我们反复提到匹配串首字符会反复和后面字符进行比较，如果有相同的字符，那么j的变化就会有所不同。也就是说，j值的变化其实换个主串没有什么关系，关键是匹配串中是否有重复的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们把匹配串中的j值变化定义作为一个数组next，那么next的长度就是匹配串的长度。我们可以得到以下的函数定义：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>next[j] = 0（当j=1时）；Max{k | 1&lt;k&lt;j}（当集合不为空时）；1（其他情况）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>整个算法的时间复杂度为O(n+m)，相比较朴素匹配算法的O((n-m+1)*m)要好很多。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>KMP模式匹配算法的改进</b></h2><p>后来，人们发现KMP算法还是有缺陷的，举个栗子：主串为111123456，匹配串为111119，那么next就是012345，我们看见匹配串的第二，三，四，五位置的字符和首位置的字符相同，所以我们可以用首位next[1]的值去取代后续next[j]的值。具体就不说下去了，大家有兴趣可以自己钻研下。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>RK算法</b></h2><p>这是另一种匹配算法，如果两个字符串hash后的值不相同，则它们肯定不相同；如果它们hash后的值相同，它们不一定相同。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>RK算法的基本思想就是：<b>将模式串P的hash值跟主串S中的每一个长度为|P|的子串的hash值比较。如果不同，则它们肯定不相等；如果相同，则再诸位比较之。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>将我们用来比较的字符串的全集设为∑={a,b,…,z}，设∑的长度为d=|∑|，则主串和匹配串都可以看作是d进制数。例如只由数字组成的字符串，它的全集∑={0,1,2,3,4,5,6,7,8,9}，d=10。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>设模式串为P，其长度为m，主串为S，其长度为n。则模式串P可以看作是一个m位的d进制数A，主串S可以看作是一个n位的d进制数。我们的模式匹配过程就是将A与主串中的每个长度为m的d进制数S[t…t+m-1] （t=0,1,2,…,n-m+1）的值做比较，所以整个模式匹配过程就变成了两个d进制数之间的比较过程。例如模式串为123，主串为65127451234，就是将十进制数123跟十进制数651, 512, 127, 274, 745, 451, 512, 123的逐个比较过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面就是求解A和求解S[t…t+m-1] （t=0,1,2,…,n-m+1）的过程：</p><ol><li>求解A。根据多项式计算方法，A = P[m-1] + d * (P[m-2] + d * (P[m-3] + …+ d * (P[1] + d*P[0])…))<br/></li><li>求解S[t…t+m-1]。为了方便表示，我们设S[t…t+m-1] = St，则S[t+1…t+m] = St+1</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>假设已求得St，现在要求St+1，需要注意的是St+1是St去掉高位数据，其余的m-1位乘以d后再在最低位加一位得到。可得</p><p class=\"ztext-empty-paragraph\"><br/></p><p>                                            St+1 = d * (St – dm-1*S[t]) + S[t+m]</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子：主串是65127451234。S2=127，那么S3=10×（127-102×1）+ 4 = 274</p><p class=\"ztext-empty-paragraph\"><br/></p><p>还有个问题是，如果A的值太大，比较的过程会比较耗时，这个时候我们可以将这个大数对一个素数进行取模，同理，st也取模,将两个取模之后的数相比较。如果两个取模后的数相同，就是伪命中，因为取模后的数相同不代表两个数就一定相同，还需要后续的比较。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来就是刷题时间了！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>594. 最长和谐子序列</b></h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [1,3,2,2,5,2,3,7]</p><p>输出: 5</p><p class=\"ztext-empty-paragraph\"><br/></p><p>原因: 最长的和谐数组是：[3,2,2,2,3].</p><p>说明: 输入的数组长度最大不超过20,000.</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def findLHS(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        r = []\n        a = {}\n        for i in nums:\n            a[i] = a.get(i,0) + 1\n        for i in a:\n            if i+1 in a:\n                r.append(a[i]+a[i+1])\n        if r == []:\n            return 0\n        return max(r)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>242. 有效的字母异位词</b></h3><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: s = &#34;anagram&#34;, t = &#34;nagaram&#34;</p><p>输出: true</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: s = &#34;rat&#34;, t = &#34;car&#34;</p><p>输出: false</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isAnagram(self, s, t):\n        &#34;&#34;&#34;\n        :type s: str\n        :type t: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        letter = [0 for i in range(26)]\n        if len(s) != len(t):\n            return False\n        for ss in s:\n            letter[ord(ss) - ord(&#39;a&#39;)] += 1\n        for tt in t:\n            if letter[ord(tt) - ord(&#39;a&#39;)] == 0:\n                return False\n            else:\n                letter[ord(tt) - ord(&#39;a&#39;)] -= 1\n        return True</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>205. 同构字符串</b></h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: s = &#34;egg&#34;, t = &#34;add&#34;</p><p>输出: true</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: s = &#34;foo&#34;, t = &#34;bar&#34;</p><p>输出: false</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isIsomorphic(self, s, t):\n        &#34;&#34;&#34;\n        :type s: str\n        :type t: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        if len(s) != len(t):\n            return False\n        if len(set(zip(list(s),list(t)))) == len(set(s)) == len(set(t)):\n            return True\n        else:\n            return False</code></pre></div><h3><b>409. 最长回文串</b></h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在构造过程中，请注意区分大小写。比如 &#34;Aa&#34; 不能当做一个回文字符串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意:</p><p>假设字符串的长度不会超过 1010。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入:</p><p>&#34;abccccdd&#34;</p><p>输出:</p><p>7</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解释:</p><p>我们可以构造的最长的回文串是&#34;dccaccd&#34;, 它的长度是 7。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def longestPalindrome(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: int\n        &#34;&#34;&#34;\n        res = 0\n        a = 0\n        letter = [0 for i in range(128)]\n        for i in s:\n            letter[ord(i) - ord(&#39;a&#39;)] += 1\n        for j in range(128):\n            if letter[j] % 2 == 1:\n                a += 1\n        if a &gt; 1:\n            return (len(s) - a + 1)\n        else:\n            return len(s)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>9. 回文数</b></h3><p>判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p><br/>示例 1:</p><p>输入: 121</p><p>输出: true</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: -121</p><p>输出: false</p><p>解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPalindrome(self, x):\n        &#34;&#34;&#34;\n        :type x: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        if x &lt; 0:\n            return False\n        if str(x) == str(x)[::-1]:\n            return True\n        else:\n            return False</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>647. 回文子串</b></h3><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: &#34;abc&#34;</p><p>输出: 3</p><p>解释: 三个回文子串: &#34;a&#34;, &#34;b&#34;, &#34;c&#34;.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: &#34;aaa&#34;</p><p>输出: 6</p><p>说明: 6个回文子串: &#34;a&#34;, &#34;a&#34;, &#34;a&#34;, &#34;aa&#34;, &#34;aa&#34;, &#34;aaa&#34;.</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def countSubstrings(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: int\n        &#34;&#34;&#34;\n        n = len(s)\n        self.res = 0\n \n        def find(i,j):\n            while i&gt;=0 and j&lt;n and s[i] == s[j]:\n                self.res += 1\n                i -= 1\n                j += 1\n \n        for i in range(n):\n            find(i,i)\n            find(i,i+1)\n        return self.res</code></pre></div><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "字符串", 
                    "tagLink": "https://api.zhihu.com/topics/19660131"
                }, 
                {
                    "tag": "字符串搜索算法", 
                    "tagLink": "https://api.zhihu.com/topics/20747406"
                }
            ], 
            "comments": [
                {
                    "userName": "厚德载物丶", 
                    "userLink": "https://www.zhihu.com/people/57a83295fd74b236225aadafffc325bf", 
                    "content": "<p>感谢总结</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61682657", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "天池精准医疗大赛-糖尿病预测（复刻）", 
            "content": "<p>最近我复刻了天池精准医疗大赛——人工智能辅助糖尿病遗传风险预测，现在和大家分享下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体赛题可以看下天池官网！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=https%3A//tianchi.aliyun.com/competition/entrance/231638/introduction\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tianchi.aliyun.com/comp</span><span class=\"invisible\">etition/entrance/231638/introduction</span><span class=\"ellipsis\"></span></a><p class=\"ztext-empty-paragraph\"><br/></p><p>这是一个典型的小样本问题，很考验模型的泛化能力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们知道症状的出现通常由多个因素影响给他造成的，而且选出的主特征只能从概率的角度来判断其影响力，所以在处理的时候要注意个体和群体的差异性，从而做到精准医疗，即个性化风险预测。<br/></p><p>我借鉴了top大佬的分享，结合自己的总结，分几个步骤来复刻下比赛的过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>数据处理</b></h2><p>数据处理主要分三步：</p><ol><li>去除缺失比例非常高的基本特征</li><li>去除对模型预测无影响的基本特征和离群值</li><li>处理缺失值和对数据集的基本特征做平滑处理</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我们一一来细说：<br/></p><h3><b>1.去除高缺失比例数据</b></h3><p>去除<b>缺失比例非常高</b>的基本特征，是指删除缺失比例超过70%的数据，一些基本特征缺失比例超过70%，且对于预测模型的影响权重较小，因为没有合理的办法对这些缺失的数据进行填充，所以选择将这些缺失比例很高的基本特征剔除。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>2.去除离群值与无意义值</b></h3><p>去除对预测模型无影响的基本特征和离群值，是指删除在预测模型构建过程中，影响权重为零的基本特征，这些特征也符合常识的认知。离群值是指数据集中，明显与大部分的数据分布之间存在着极端的差距，离群值的存在往往会扭曲预测结果进而影响模型的精度，比如说在此次比赛中，个别病人的极端情况会影响实验模型的准确性。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>3.缺失值处理</b></h3><p>处理缺失值，是指对于数据集中所有缺失的数据采取恰当的方式进行填充的过程。在各种实用的数据库中，数据缺失的情况经常发全甚至是不可避免的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据缺失在数据挖掘的过程中，会造成了以下影响：</p><ol><li>系统丢失了大量的有用信息。</li><li>系统中所表现出的不确定性更加显著，系统中蕴涵的确定性成分更难把握。</li><li>包含空值的数据会使挖掘过程陷入混乱，导致不可靠的输出。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>对于数据缺失这一问题，数据挖掘领域有以下几种处理方法：特殊值填充、平均值填充、中位数填充、K最近距离邻法（K-means clustering）、回归方程法（Regression）、期望值最大化法（Expectation maximization）等。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>4.特征平滑处理</b></h3><p>对数据集的基本特征做平滑处理，是由于数据集的基础特征的分布与推理条件中先验高斯分布之间存在较大的差异，如果数据集中的特征是不平滑的，这对于模型的拟合来说会有负面影响，同时有的噪声数据会影响拟合的函数的准确性，因此在特征工程工作和数据挖掘之前，先要对数据集进行平滑处理操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我来讲讲数据平滑处理是怎么做的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>数据平滑处理 -- log1p( ) 和 exmp1( )</b></h2><p>1.  数据预处理时首先可以对偏度比较大的数据用零log1p函数进行转化，使其更加服从高斯分布，此步处理可能会使我们后续的分类结果得到一个好的结果。</p><p>2. 平滑问题很容易处理掉，导致模型的结果达不到一定的标准，log1p( )能够避免复值的问题 — 复值指一个自变量对应多个因变量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>log1p( ) 的使用就像是一个数据压缩到了一个区间，与数据的标准类似。其逆运算就是expm1的函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>由于使用的log1p（）对数据进行了压缩，最后需要将预测出的平滑数据进行一个还原，而还原过程就是log1p的逆运算expm1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>                                                              log1p = log（x+1）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当x较大时直接计算，当x较小时用泰勒展开式计算。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>特征工程</b></h2><p>特征工程的目的是筛选出更好的特征，获取更好的训练数据。因为好的特征具有更强的灵活性，可以用简单的模型做训练，更可以得到优秀的结果。优越的特征可以缩短模型参数调优的过程，降低模型的复杂度使模型趋于简单。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在医疗领域，数据质量差，数据量少是个常态。同时，再给出诊断结果时，还需要提供合理的解释，所以想通过海量数据来分析基本是不太现实的。我们需要预测的结果尽量稳定，并不追求当前数据集的极值，因为当前数据集的极值往往都是过拟合的。过拟合带来的结果往往就是线上线下的差异过大。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>特征分析方法</b></h2><p>常见的特征分析方法有很多，例如IV值分析（information value），入模分析，残差分析，PCA（principle component analysis），ANOVA（Analysis of variance）等等。考虑数据集的特点，以及对特征分析结果的可解释性，最后选择了残差分析的结果来入模。其他部分分析方法也适用，大家有时间也可以试一试，最后的分析结果差距也不算大，一般只是在排序上有差距，子集包含的特征也极为相似。当然，这几种方法在原理上是不太一致的，能提供的信息含义也有所不同，各自有各自的优缺点，所以是需要理解不同的方法在什么时候用最好。ANOVA在这里不太适用，主要是因为数据量太小。当数据量非常大的时候，ANOVA是一种很好的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>模型选择</b></h2><p>Xgboost一把梭一直是最棒的，比传统的决策树和随机森林的效果会好很多。这两个算法都属于GBDT类的算法。这类算法属于树的集成学习，对组合特征的探索与群体特征分析(个体或群体差异)都非常适合，因此已开始我们的探索目标就是此类GBDT模型。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>经过几轮探索，我们发现Xgboost与LightGBD的线上与线下差距还是蛮大，需要大量调参并使用很多加强稳定性的手段（比如CV）才能缩小线上与线下的差距。这说明训练集与测试集的特征分布情况还是有较大的差距，这一类比赛中能给的测试算法的次数不多，特别是全样本测试。那么我们如果无法找到一个合适的方案来解决偏差的问题，最后的结果就和摸奖真的一样了。我们必须要解决<b>小样本对泛化能力要求</b>的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个方案必须满足两个条件：</p><p>（1）在无需过多的针对数据分布特点进行的调参下依然能够使得线上评分较高。</p><p>（2）线上和线下F1值尽量接近。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实总结一下，就是实际偏差和期望偏差基本一致。所以我们把目光聚焦在了catboost上。Catboost常用在解决小样本数据集问题上。Catboost和lightGBM与Xgboost类似，都属于GBDT类的算法。但是catboost的一个优势在于，作者对实际采样的样本与真实样本之间的差异做了一个假设，认为他们的特征分布是不可能完全一致的。这类假设其实很符合实际中遇到的情况，特别是样本数量不足够充分的情况下。Catboost在公司的其他项目中的表现在小样本集上的稳定性是强于lightGBM和xgboost的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>后续处理</b></h2><p>其实在得到模型线上分数之前，还缺少一个步骤。这个步骤对线上的结果影响非常大。同一个模型，同一个参数，但处理不好这个步骤，成绩就会差很多。这个步骤就是确定分类阈值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么要确定分类阈值？在使用catboost或者xgboost,lightGBM这类工具的时候，如果直接使用predict这个函数，出来的结果将是0或1的标签。这个0或者1是怎么来的？其实是根据预测的置信度算出来的。从模型的结构设计来讲，最后给出是正样本的一个概率，即0-1范围内的一个小数。predict函数简单的将大于0.5的归位类别1，其余的为0。 这里的0.5便是阈值。显然这个阈值的划分非常简单粗暴。很多人可能会认为，大于0.5的概率划分成类别1说的通啊，说明有超过的50%概率都是1了。简单的一思考，好像没什么大毛病。但实际上，这个0.5并不是真正的分类概率。所以我更愿意用置信度来描述它。那么怎么来选这个阈值？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们会从2个方向来思考这个问题。最后发现两个方向汇聚成的结果很一致：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）从业务场景需求来讲，在一个任意宽度的阈值范围内，对落在该阈值范围内的样本的预测准确率大于50%才有意义。因为训练集中，正负样本比值接近1：1.1 。如果区间准确率没有达到50%的话，对该阈值范围内的样本预测还不如随机猜。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）从F1值最大化的情况来看，在区间准确率大于某个值时，该区间下的样本预测为1会对F1值有增强效果。（最后发现在预测1的数量在130以内时，区间准确率达到40%以上对F1值都会有帮助，在考虑到训练集过拟合、以及测试集特征分布会出现变化，我们将这个准确率提到了50%）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么，什么是区间准确率？其实就是模型对每个样本的预测值在排序后，按照一个区间固定的样本个数，将全样本划分成N个区间。（我们以5%的样本量为一个区间，一共划分了20个）。然后算得每个区间的准确率。在实际操作中，我们选取的阈值便是找到最后一个50%以上准确率的区间（在此区间之后再无区间的准确率达到过50%），然后取该区间的最小预测值为划分0和1标签的阈值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>通常在业务场景的探索工作就止步于此了。但比赛毕竟是比赛，我们需求追求极值。那么如何在保证稳定性的同时，又进一步提高F1值呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先我们想到的就是集成学习。例如投票法，平均法等等。但其实这些效果并不好，因为我们并不是训练了一群能力相当，能力有差异的弱分类器。这种条件根本不满足。我们想到，只要某个区间的准确率能够超过50%，那么对F1值将会有较大的贡献。如果我们能提升catboost后50%的某些样本，使得对被选择的这些样本的预测准确率超过50%，且预测总数小于130个，就一定能提升F1值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，我们采用了级联方法，将catboost作为主模型，让xgboost和lightGBM的模型作为副模型。这里级联的思路是，catboost预测出来的值如果排在后50%，但排在xgboost与lightGBM前25%的时候，这个样本将被认为是正样本。否则为负样本。之所以选择25%这个阈值，是因为这两个模型的训练结果上，排名前25%的样本区间准确度超过70%。这样我们用更高的要求防止因为训练自身以及训练与测试集特征分布差异带来的过拟合。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>重要性排序</b></h2><p>考虑到GBDT类模型树分叉的特点，我们认为工具包从自带的feature importance这个函数已经可以对特征重要性做出说明。当某个特征之所以被考虑成分裂特征，也是因为这些特征在一定的数据子集里，拥有最好的全局影响力。再结合级联的分叉特性，这种判断方式也考虑到了特征之间的组合影响。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最终，我们的重要排序是将catboost,xgboost与lightGBM三模模型的feature importance输出后做了归一化，然后取了平均，得到了最终的重要性排序结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>总结</b></h2><h3>1.多特征组合</h3><p>一般是现有特征加减乘除的组合，真的是简单粗暴的加减乘除！！当然在特征多的情况下，先取强特征相互组合。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>2.数据分析 </h3><p>常用分析方法：IV值分析（information value），方差，残差，单变量分析，PCA等等． 特征的相关性与去冗余：特征和结果的相关性分析可能找不出一些非线性相关，但是特征之间的强相关，可以帮助去掉一些冗余。 小数据集中某些特征，可能引起过拟合。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>3.缺失值填充</h3><p>Nuclear，MICE，最近邻填充。对于不同缺失比例，可使用不同方法填充。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>4.算法</h3><ol><li>因子分解机FM</li><li>适合小数据量的catboost模型</li><li>用遗传算法调参</li><li>模型级联 先用A算法筛，筛出的疑似再用其它算法筛。 弱模型组合时需要注意模型差异性。</li><li>分类时可用回归模型，回归时可用分类模型。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h3>5.最终结果处理</h3><ol><li>把重要数据和规则存下来，在没模型的情况下也能使用．</li><li>除了精确度，还要考虑召回率，医疗领域我们还是要注重召回率，因为在医疗中，误诊的代价很大。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>我把复刻的源码和相关数据集都放在下面了，随手给个小星星吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/gyx0827/Diabets_Forecast/tree/Diabets_Forecast\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-17d78fec2751edc66ea5e35055022f1b_ipico.jpg\" data-image-width=\"420\" data-image-height=\"420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gyx0827/Diabets_Forecast</a><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "阿里天池", 
                    "tagLink": "https://api.zhihu.com/topics/20139645"
                }, 
                {
                    "tag": "完美复刻", 
                    "tagLink": "https://api.zhihu.com/topics/20028051"
                }, 
                {
                    "tag": "大数据分析", 
                    "tagLink": "https://api.zhihu.com/topics/19831849"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60607387", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 1, 
            "title": "leetcode刷题(六）：路径规划问题", 
            "content": "<p>由于最近接触了大量关于路径规划的算法，所以这一期我们来讨论下路径规划的问题！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先，我要介绍下关于路径规划问题的一些基本概念。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>图</b></h2><p>在最短路径问题中，我们往往给定一个带权重的有向图，G=(V,E)，以及权重函数w：E-&gt;R，改权重函数将每条边映射到实数值的权重上。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>松弛操作</b></h2><p>对于一条边(u,v)的松弛过程就是：首先测试一下对s到v的最短路径进行改善。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试方法就是：将从结点s到结点u的最短路径加上结点u到结点v的权重值，并与当前结点s到结点v的最短路径进行比较。如果前者更小，就进行更新。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我会介绍下几种主要的路径规划算法：</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Dijkstra算法</b></h2><p>Dijkstra算法使用了广度优先搜索解决赋权有向图或者无向图的单源最短路径问题，算法最终得到一个最短路径树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Dijkstra算法采用的是一种贪心的策略：</p><p>他首先声明一个数组dis来保存源点s到各个结点的最短距离，以及一个保存已经找到最短的结点的集合T。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>初始后，他先将s的路径权重设置为0，再将对于s能直接到达的u结点的权重设置为w，即dis[u]=w，同时把其他（s不能直接到的结点）路径长度设置为无穷大。此时T里面只包含u一个结点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>此时dis[]里面的值是否就是s结点能到达的最短路径呢？不着急，我们先看看新加入的结点是否可以到达其他节点，并且看看经由此节点到达其他结点的路径是否比从s源点直接到达更短，也就是一个松弛的过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后，重复上述动作，直到T中包含了图的所有顶点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>此算法有也衍生出很多应用在不同场景下的算法，比如说用于稀疏图的<b>Johnson算法</b>。Johnson算法使用技术称之为重新赋予权重。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>原理如下：</b></h3><p>如果图中所有边的权重赋值为非负数，我们可以通过对每个结点对运行一次<b>Dijkstra算法</b>来找到所有结点对之间的最短路径。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果图中包含有负数的权重的边，且不包含权重为负的环路，那么我们只要计算出一组新的非负权重值，然后用相同的方法重新计算即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>A*算法</b></h2><p>A*算法的关键是下面这个等式：</p><p>                                                         F = G + H</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其中，G为从起点 A 移动到指定方格的移动代价，沿着到达该方格而生成的路径。H为从指定的方格移动到终点 B 的估算成本。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>步骤如下：</b></h3><ol><li>我们从起点 A 开始，并把它就加入到一个<b>open list</b>( 开放列表 ) 中。现在 open list 里只有一项，它就是起点 A ，后面会慢慢加入更多的项。基本上 open list 是一个待检查的方格列表。</li><li>查看与起点 A 相邻的方格，把其中可走的或可到达的方格也加入到 open list 中。把起点 A设置为这些方格的父亲。</li><li>把A从 open list 里取出，放到 <b>close list</b> 中，close list 中的每个元素都是现在不需要再关注的。</li><li>检查所有与它相邻的方格，忽略其中在 close list 中的元素，如果方格不在open lsit 中，则把它们加入到 open list 中。同时把我们选定的方格设置为这些新加入的方格的父亲。</li><li>如果某个相邻的方格已经在 open list 中，则检查这条路径是否更优，也就是说经由当前方格 ( 我们选中的方格 ) 到达那个方格是否具有更小的 G 值。如果没有，不做任何操作。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>Ok ，现在你已经看完了整个的介绍，再来看看我们把所有步骤放在一起的伪代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>把起点加入 open list 。</p><p>重复如下过程：</p><p>a.遍历 open list ，查找 F 值最小的节点，把它作为当前要处理的节点。</p><p>b.把这个节点移到 close list 。</p><p>c.对当前方格的 8 个相邻方格的每一个方格？</p><p>    ◆如果它是不可抵达的或者它在 close list 中，忽略它。否则，做如下操作。</p><p>    ◆如果它不在 open list 中，把它加入 open list ，并且把当前方格设置为它的父亲，记录该方格的F、G和H 值。</p><p>    ◆如果它已经在 open list 中，检查这条路径 ( 即经由当前方格到达它那里 ) 是否更好，用 G 值作参考。更小的 G 值表示这是更好的路径。如果是这样，把它的父亲设置为当前方格，并重新计算它的 G 和 F 值。</p><p>d.停止，当你</p><p>    ◆把终点加入到了 open list 中，此时路径已经找到了，或者</p><p>    ◆查找终点失败，并且 open list 是空的，此时没有路径。</p><p>e.保存路径。从终点开始，每个方格沿着父节点移动直至起点，这就是你的路径。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>蚁群算法</b></h2><p>蚁群算法，顾名思义，就是模拟蚁群寻找最佳路径的一种算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>蚂蚁行进时会释放出信息素，世上本没路，走的蚂蚁多了，信息素自然就浓了，路也自然就有了。路径越短，蚂蚁往返越快，信息素自然就越浓，所以信息素最浓的路径就是最佳路径了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里以TSP问题为例，算法设计的流程如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>对相关参数进行初始化，包括蚁群规模、信息素因子、启发函数因子、信息素挥发因子、信息素常数、最大迭代次数等，以及将数据读入程序，并进行预处理：比如将城市的坐标信息转换为城市间的距离矩阵。</li><li>随机将蚂蚁放于不同出发点，对每个蚂蚁计算其下个访问城市，直到有蚂蚁访问完所有城市。</li><li>计算各蚂蚁经过的路径长度Lk，记录当前迭代次数最优解，同时对路径上的信息素浓度进行更新。</li><li>判断是否满足终止条件（如达到最大迭代次数），若否，返回步骤2；是，结束程序。</li><li>输出结果，并根据需要输出寻优过程中的相关指标，如运行时间、收敛迭代次数等。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>当然，真实的算法没有这么简单，我们还需要考虑到很多细节，我简单缕一缕吧。<br/></p><h3><b>随机问题：</b></h3><p>在迭代中，我们将一部分蚂蚁根据信息素浓度进行任务分配，另一部分采用随机分配策略。</p><p>因为如果每只蚂蚁都将任务分配给信息素浓度最高的节点处理，那么就会出现停滞现象。也就是算法过早地收敛至一个局部最优解，无法发现全局最优解。 因此需要一部分蚂蚁遵循信息素最高的分配策略，还需要一部分蚂蚁遵循随机分配的策略，以发现新的局部最优解。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>信息素问题：</b></h3><p>我们模拟真实的蚁群中，蚂蚁分泌的信息素会随着时间的推移而渐渐衰减。所以在算法中，我们使得信息素每完成一次迭代后进行衰减，但在一次迭代过程中，信息素浓度保持不变。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们同时也模拟真实的蚁群中，蚂蚁会在行进过程中分泌信息素。所以在算法中，我们使得算法每完成一次迭代后，就将蚂蚁经过的路径上增加信息素q，但在一次迭代过程中，信息素浓度不变。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3><b>局部最优解问题：</b></h3><p>在整个蚁群算法中，每一次迭代都会产生当前的最优分配策略，也就是“局部最优解”。迭代的次数越多，那么局部最优解就越接近于全局最优解。但是，迭代次数过多会造成时间的消耗和性能上的开销，从而无法满足任务的调度。但迭代次数太少了，可能得到的并不是全局最优解。这个问题有两种解决办法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1.限定迭代次数 </p><p>为了避免过多的迭代，我们可以事先设置一个迭代次数，从而迭代了这么多次后，就把当前的局部最优解当作全局最优解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2.设置误差允许范围 </p><p>我们还可以事先设置一个允许的误差范围。当迭代N次后，当前最优的任务处理时间在这个允许范围之内了，那么就停止迭代。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>模拟退火算法</b></h2><p>模拟退火算法是通过赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优的串行结构的优化算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是没看懂？我还是喜欢用一个好玩的栗子来说明模拟退火算法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>普通贪婪算法：兔子朝着比现在低的地方跳去。它找到了不远处的最低的山谷。但是这座山谷不一定最低的。这就是普通贪婪算法，它不能保证局部最优值就是全局最优值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>模拟退火：兔子喝醉了。它随机地跳了很长时间。这期间，它可能走向低处，也可能踏入平地。但是，它渐渐清醒了并朝最低的方向跳去。这就是模拟退火。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>贪婪算法可以看我之前的文章：</p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU5ODY4NTY3OQ%3D%3D%26mid%3D2247483728%26idx%3D1%26sn%3Da311c2ab8595a7112502334df289b6bb%26chksm%3Dfe4123d0c936aac65975aa3162896cbc307e232226163bd91b0c5ba0e8aaa88508d8119590e9%26scene%3D0%26xtrack%3D1%26key%3D69be76faff27ea4a1fb8d6cc44aa22a5d4d3b3945182ac0bf709500c2cc9a18ed2b477bef1621fc5e884d3d047ee8f370c34cb95f7ed3957a5ac0457d2213676cbba08660b64883726de2ea275136efc%26ascene%3D1%26uin%3DNjI3NDc4NzQw%26devicetype%3DWindows%2B10%26version%3D62060720%26lang%3Dzh_CN%26pass_ticket%3DIWvR4FVhAebDCg5MXjVupNDMsnaCocfkfK5GkbKG3p4afdGwElCGoKSnL%252BUcTWBn\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">leetcode刷题（一）：贪心算法</a><p class=\"ztext-empty-paragraph\"><br/></p><p>说白了模拟退火其实也是一种贪婪算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那模拟退火又是怎么回事呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>控制参数t模拟了物理过程中的温度T，目标函数模拟了物理过程中的能量E，而解模拟了粒子群的微观状态。即得到解组合优化问题的模拟退火演算法：对于控制参数的每一取值，算法持续进行”产生新解—判断—接受/舍弃”的迭代，同时逐步衰减 t 值的过程就对应着固体在某一恒定温度下趋于热平衡的过程，也就是执行了一次Metropolis算法。算法终止时的当前解即为所得近似最优解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结起来就是：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>若f( Y(i+1) ) &lt;= f( Y(i) )  (即移动后得到更优解)，则总是接受该移动；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>若f( Y(i+1) ) &gt; f( Y(i) )  (即移动后的解比当前解要差)，则以一定的概率接受移动，而且这个概率随着时间推移逐渐降低（逐渐降低才能趋向稳定）。如果这个坡特别长，那么很有可能最终我们并不会翻过这个坡。如果它不太长，这很有可能会翻过它，这取决于衰减 t 值的设定。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>关于路径规划问题leetcode上没有太多的题目可以参考，所以我只找了一题。感兴趣的朋友可以自己把各个算法用代码敲一敲！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>62. 不同路径</p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</p><p>问总共有多少条不同的路径？</p><p>说明：m 和 n 的值均不超过 100。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: m = 3, n = 2</p><p>输出: 3</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解释:</p><p>从左上角开始，总共有 3 条路径可以到达右下角。</p><p>1. 向右 -&gt; 向右 -&gt; 向下</p><p>2. 向右 -&gt; 向下 -&gt; 向右</p><p>3. 向下 -&gt; 向右 -&gt; 向右</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: m = 7, n = 3</p><p>输出: 28</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def uniquePaths(self, m, n):\n        &#34;&#34;&#34;\n        :type m: int\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        if n &lt; 0 and m &lt; 0:\n            return 0\n        res = [0 for i in range(n)]\n        res[0] = 1\n        for i in range(m):\n            for j in range(1,n):\n                res[j] += res[j-1]\n        return res[-1]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "路径规划", 
                    "tagLink": "https://api.zhihu.com/topics/20206646"
                }, 
                {
                    "tag": "最短路径", 
                    "tagLink": "https://api.zhihu.com/topics/19841010"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59535870", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "CTR广告预估（二）", 
            "content": "<p>这是我的第二篇CTR的文章，还是一些概念的介绍和CTR在工业方面的处理。过段时间我会打打些这方面的比赛，之后会尽量给大家分享比赛复盘和这方面的心得。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现代社会是互联网大爆炸，信息过载的社会。举个栗子，我们一天会看到20mb左右的文字信息，会听到600mb左右声音信息，每秒看到2mb左右图像信息，每天有10w左右的新闻报，每秒钟优酷土豆爱奇艺搜狐腾讯B站会多出时长几百小时的视频，淘宝京东亚马逊当当一天上架上百万商品。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对用户而言：我们往往希望能找到好玩的东西，帮助决策，发现新鲜事物。</p><p>而对商家而言：他们更希望能提供个性化服务，提高信任度和粘性来增加营收。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以这个时候，推荐系统就显得尤为重要了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那推荐系统是什么呢？ </p><p class=\"ztext-empty-paragraph\"><br/></p><p>推荐系统就是<b>对用户进行侧写</b>，根据用户的历史行为，所处的社交关系和兴趣点去判断用户的当前需求或者感兴趣的item。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>推荐系统之评定标准</b></h2><p><b>准确度：</b></p><p>打分系统，即用户对物品的实际打分作为的参考。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里的数据更多的是用户处理后的行为，因为用户大多不会做出点击这样的行为，他们更多的是浏览和停留，我们可以根据用户在某个网页停留时间的长短来判断他看没看，是否感兴趣。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>覆盖率：</b></p><p>表示对<b>物品长尾</b>的发掘能力（推荐系统希望消除马太效应）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实在实际中，大部分的用户会浏览常规的热门的商品，有些冷门的、小众的商品就会落在长尾后面。所以我们就希望能尽量多的推荐物品的种类，也就是发掘物品的长尾能力，不希望热门的物品越热门，冷门的物品越冷门。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>多样性：</b></p><p>表示推荐列表中物品两两之间的不相似性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里有个问题，覆盖率和多样性有什么区别呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>覆盖率</b>就是对平台而言，平台所拥有的产品展示的越多，覆盖率就越大。举个栗子，哪怕你的平台全卖牙膏，你推荐的全是牙膏，但是因为你把平台的东西都推荐出去了，所以覆盖率还是很高的。而<b>多样性</b>是对于用户而言的，用户来说全部推荐牙膏，那多样性肯定是很差的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>新颖度</b>：给用户surprise(推荐他们不知道的商品) 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>惊喜度</b>：推荐和用户历史兴趣不相似，却满意的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>信任度</b>：提供可靠的推荐理由。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>实时性</b>：实时更新程度。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>基于内容的推荐特点</b></h2><ol><li>基于用户喜欢的item的属性/内容进行推荐。</li><li>需要分析内容，无需考虑其他用户的行为。</li><li>通常使用在文本相关产品上进行推荐。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>Item往往通过内容(比如关键词)关联，举个栗子：我们要推荐一个文本。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先，对于每个要推荐的内容，我们需要建立一份资料，比如词kj在文件dj中的权重wij，我们常用<b>TF-IDF</b>来完成 (TF-IDF具体可以看我之前的文章)，接下我们需要对用户也建立一份资料，因为客户之前也会看文档，有相应的记录，建立方法同上。最后我们计算匹配度，即用用户的文档和推荐的文档做一个相似度，比如说余弦相似度(余弦距离在我之前的文章里面也讲过啦)。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>协同过滤</b></h2><p>协同过滤分分为<b>基于用户的协同过滤算法</b>和<b>基于物品的协同过滤算法</b>。基于用户的协同过滤算法的关键是找到相同偏好的用户，找到了偏好最近的几个用户，找到他们看/买过但是前用户没看/买过的item，根据距离加权打分，找得分最高的，将其推荐给你。而基于物品的协同过滤算法的关键是根据用户对商品/内容的行为，计算其它物品和历史物品的相似度，相似度最近的几个物品便是要推荐的物品。</p><p>我举个栗子来说明协同过滤吧。比如我们想知道电影A对用户1的推荐度：首先是基于物品的协同过滤，我们先找到和电影A相似度最高的几部电影，比如说是电影B和电影C，然后基于电影B和电影C的打分和用户1对电影B和电影C的打分来计算出电影A对用户1的推荐度。接下来是基于用户的协同过滤：我们先计算出每一个用户和用户1的相似度，然后再挑选出相似度top的用户，再根据几个top对电影A的评价来计算出电影A对用户1的推荐度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不知道你们听懂了没有，我可能讲得不好，不过没事，反正我的文章一向很少有人看hhhhh</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在我们实际工程运用当中往往使用到的是基于物品的itemCF，因为一个是用户的数量远远多于物品的种类。另一个原因是用户的兴趣爱好是会变的，这样的话用户的变化度会非常高，而物品的稳定度是很高的。最后一个原因是基于物品的协同过滤能更好的给用户理由，在我们推荐的时候往往会给出相应的理由来增进用户对我们的信任度，而比如说买了手机的用户都买了手机壳，所以我们推荐你了手机壳，这样的推荐理由用户是很认可的。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>协同过滤优点</b></h2><p>这是基于用户行为，因此对推荐内容无需先验知识，不需要对内容做太多的处理只需要用户和商品关联矩阵即可，结构比较简单在用户行为丰富的情况下，效果好。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>协同过滤缺点</b></h2><ol><li>需要大量的显性/隐性用户行为，解决不了冷启动问题。</li><li>需要通过完全相同的商品关联，相似的不行，比如说同款商品就不行。</li><li>假定用户的兴趣完全取决于之前的行为，而和当前上下文环境无关。</li><li>在数据稀疏的情况下受影响。可以考虑二度关联，比如说A和B，A和C有关联，那我们就可以通过A使得B和C产生联系。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>推荐系统之冷启动问题</b></h2><ol><li>所有推荐系统对于新用户都有这个问题，我们一般有以下的解决方案：</li><li>推荐非常热门的商品，收集一些信息。</li><li>在用户注册的时候收集一些信息。</li><li>在用户注册完之后，用一些互动游戏等确定喜欢与不喜欢。</li><li>根据本身的属性，求与原来商品的相似度进而进行推荐。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>推荐系统之推荐算法进阶 </b></h2><p>比如说我们有一个用户评分矩阵，但是有一些位置是空着的（没打分）。我们要做的事情是，尽量填满未打分的项（预测得分）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要想法是，应该有一些隐藏的因素，影响用户的打分，比如电影：演员、题材、主题、年代… 这些不一定是人直接可理解的隐藏因子，所以我们需要找到隐藏因子，从而对user和item进行关联。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个简单的栗子吧，我们对电影和用户进行关联，先将其分解，因为M*N=(M*F)*(F*N)，所以可以将矩阵分解为(M*F)和(F*N)，所以就得出了隐变量F。M个用户在N部电影在变量上的作用。举个栗子，我喜欢科幻片，所以作用在F上为正数，而电影对应的是韩剧，作用在F上为负数，两个一乘就变成了负数，自然推荐度就不符合要求了。在这里，隐变量F就是我们搭起用户和产品的桥梁。，做乘法的意义就是看看是否一致，一致就是正得分，不一致就是负得分。 <br/></p><p>为了完成这一步骤，我们首先想到<b>SVD矩阵分解</b>。但是SVD矩阵分解往往会给空缺值赋值为0。要知道用户没评论不代表她的评论值为0，所以会给结果带来很大的影响。所以我们使用另一种方式来进行矩阵分解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们假定有U个用户，D个item，R为打分矩阵。我们再假定有K个隐含变量，我们需要找到矩阵P(U*K)和Q(D*K): P*(Q^T)我们就能得到R的预测值了。<br/></p><p>所以我们需要找到矩阵P(U*K)和Q(D*K)就可以了。那我们如何才能找到最佳的P和Q呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里就要用到机器学习的知识了。我们先定义一个<b>损失函数</b>，损失函数就是实际的得分和预测出来的值的差距。然后就是<b>梯度下降</b>：<b>求解梯度</b>，<b>迭代更新</b>。然后进行<b>正则化</b>，再次<b>求梯度/偏导更新迭代公式</b>。再<b>还原回矩阵乘积</b>，即可补充未打分项。通常情况下，我们会限定分解得到的P和Q中的元素都非负，因为不存在减法操作，因此可以看做对隐变量特征的线性加权。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>进一步优化</b></h2><p>我们在之前的损失函数中，我们可以在原来预测的R基础上加上三个变量：所有人所有的预测的平均得分、用户的平均得分、电影的平均得分。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们的想法是在每个movie上和每个user上都给它一个平均的偏移量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "ctr", 
                    "tagLink": "https://api.zhihu.com/topics/20175751"
                }, 
                {
                    "tag": "推荐系统", 
                    "tagLink": "https://api.zhihu.com/topics/19563024"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58965364", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 12, 
            "title": "leetcode刷题(五）：分治算法", 
            "content": "<p>今天我们来讲一下分治算法，废话不多说了，我们开始吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在分支策略中，我们对一个问题求以下三步递归：</p><ol><li>分解：将问题分解为一些子问题，子问题和原问题形式一样，只是规模更小。</li><li>解决：递归地求解子问题，如果子问题规模足够小，则停止递归，直接求解。</li><li>合并：将子问题的解合并成原问题的解。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>本文我会从一个求解最大子数组问题出发，进而介绍矩阵乘法的Strassen算法，最后再介绍三种求解递归的方式：代入法，递归树法，主方法。</p><h2><br/><b>最大子数组问题</b></h2><p>我发现这个问题和leetcode的一道题目很像，我们就按照那题来作为例子吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>121. 买卖股票的最佳时机</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]</p><p>输出: 5</p><p>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</p><p>注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 2:</p><p>输入: [7,6,4,3,1]</p><p>输出: 0</p><p>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们很容易得出一个<b>暴力求解</b>的方法来解决本问题：简单地尝试买入和卖出的时间组合，只要卖出在买入之前即可。所以运行时间也就是所有的日期组合，即O(n^2)。具体代码如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void MaxSubArraySum_Force(int arr[], vector&lt;int&gt; &amp;subarr, int len)\n{\nif (len == 0):\nreturn;\nint nMax = INT_MIN;\nint low = 0, high = 0;\nfor (int i = 0 , i &lt;= len , i ++){\nint nsum = 0\nfor (int j = i , j &lt;= len , j ++){\nnmax += arr[j]\nif (nSum &gt; nMax) {\n                   nMax = nSum;\n                   low = i;\n                  high = j;\n              }\n          }\n       }\n       for (int i = low; i &lt;= high; i ++) {\n           subarr.push_back(arr[i]);\n      }\n   }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>很明显，这样做有悖于我们的原则，那么我们可不可以把问题转个方向看待呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们的目的是寻找一段日期，使得第一天到最后一天的净增变值最大。我们可以把第i天的数据改为第i-1天和第i天的价格差。如果将这一行新的数据看作数组A，那么问题就可以转换成寻找A和最大非空连续子数组。我们称这样的最大非空连续子数组为最大子数组。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那我我们得到了什么优化呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以重新组织计算方式，利用之前计算出的子数组的和来计算出当前子数组的和，此时每一个子数组的和的时间复杂度为O(1)，而暴力求解的时间复杂度为O(n^2)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后我们用分治的策略来思考这个问题，使用分治思想意味着我们需要将数组尽可能地分成两个相同的数组。也就是说，求出数组的中央位置mid，然后考虑[low，mid]，[mid+1，high]两种情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>显然，[low，high]的连续子数组[i……j]必然又以下三种情况：</p><ol><li>处于[low，mid]。</li><li>处于[mid+1，high]。</li><li>跨越了中点，所以low&lt;=i&lt;=mid&lt;=j&lt;=high。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>第一、第二种情况还好处理，因为它本质上还是一个最大子数组的问题，只是规模更小，我们只需要将其递归求解即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>关键是求解第三种情况，因为它加入了限制：必须包含中间位置 mid。因此，我们只需要找出[low，mid]，[mid+1，high]的最大子数组，然后将它们合并即可，条件是两个最大子数组都必须包含mid。我们直接上代码吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">int Find_Max_Crossing_Subarray(int arr[], int low, int mid, int high)\n {\n     const int infinite = -9999;\n     int left_sum = infinite;\n     int right_sum = infinite;\n \n     int max_left = -1, max_right = -1;\n \n     int sum = 0; //from mid to left;\n     for (int i = mid; i &gt;= low; i --) {\n         sum += arr[i];\n         if (sum &gt; left_sum) {\n             left_sum = sum;\n             max_left = i;        \n         }\n     }\n     sum = 0;  //from mid to right\n     for (int j = mid + 1; j &lt;= high; j ++) {\n         sum += arr[j];\n         if (sum &gt; right_sum) {\n             right_sum = sum;\n             max_right = j;\n         }\n     }\n     return (left_sum + right_sum);\n }\n \n int Find_Maximum_Subarray(int arr[], int low, int high)\n {\n     if (high == low) //only one element;\n         return arr[low];\n     else {\n         int mid = (low + high)/2;\n         int leftSum = Find_Maximum_Subarray(arr, low, mid);\n         int rightSum = Find_Maximum_Subarray(arr, mid+1, high);\n         int crossSum = Find_Max_Crossing_Subarray(arr, low, mid, high);\n \n         if (leftSum &gt;= rightSum &amp;&amp; leftSum &gt;= crossSum)\n             return leftSum;\n         else if (rightSum &gt;= leftSum &amp;&amp; rightSum &gt;= crossSum)\n             return rightSum;\n         else \n             return crossSum;\n     }\n   }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>我们来看下时间复杂度吧，两个子问题的时间复杂度为2T(n/2)，而最后调用Find_Maximum_Subarray需要用到O(n)，所以得到运行时间为：</p><p>T(n) =  O(1)（若 n = 1）；2T(n/2) + O(n) （若 n &gt; 1）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以我们得到了一个渐进复杂性优于暴力求解法的算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>矩阵乘法的Strassen算法</b></h2><p>相信大家一定都知道矩阵乘法，我这里主要讲一下著名的n*n矩阵相乘的递归算法。简单起见，我们先想一下用分治思想来计算矩阵乘积C=A*B。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们先把n*n的矩阵划分成4个n/2*n/2的矩阵，所以A=[A11,A12,A21,A22],B=[B11,B12,B21,B22],C=[C11,C12,C21,C22]，由此可得：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>C11 = A11*B11 + A12*B21</p><p>C12 = A11*B12 + A12*B22</p><p>C21 = A21*B11 + A21*B22</p><p>C22 = A21*B12 + A22*B22</p><p class=\"ztext-empty-paragraph\"><br/></p><p>讲到这，相信大家已经都差不多了，代码就不打了，大家都懂。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>递归情况的总时间由分解时间，递归调用以及矩阵加法时间组成：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>T(N) = T(n/2) + O(n^2)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这是分治思想的结果，而Strassen思想的核心是令递归树稍微不那么茂盛一点，即只递归进行7而非8次n/2*n/2矩阵的乘法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体步骤：</p><ol><li>将输入矩阵A、B和输出矩阵C分解为n/2 * n/2 的子矩阵。采用下标计算方法，此步骤花费Θ(1)Θ(1)时间，与SQUARE-MATRIX-MULTIPLY-RECURSIVE相同。</li><li>创建10个n/2 * n/2的矩阵 S1,S2,...,S10S1,S2,...,S10每个矩阵保存步骤 1 中创建的两个矩阵的和或差。花费时间为Θ(n2)Θ(n2) 。</li><li>用步骤1中创建的子矩阵和步骤2中创建的10个矩阵，递归的计算7个矩阵积P1,P2,..P7P1,P2,..P7。每个矩阵PiPi都是n/2 * n/2 的。 </li><li>通过PiPi矩阵的不同组合进行加减运算，计算出结果矩阵C的子矩阵C11,C12,C21,C22C11,C12,C21,C22.花费时间Θ(n2)Θ(n2)。<br/></li></ol><p>这样我们就用常数次的矩阵乘法减少了一次矩阵乘法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我就简单地说一下代入法，递归树法，主方法来求解递归式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用代入法求解递归式</b></h2><ol><li>猜测解的形式。</li><li>用数学归纳法求出解中的常数，并证明解是正确的。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是看着很扯，就是靠猜！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但这的确是这样的，先猜一个，再证明递归式的上界和下界，最后缩小不确定的范围！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用递归树方法求解递归树</b></h2><p>在递归树中，每个节点表示一个单一问题的代价，子问题对应某次递归函数的调用，我们将树中每层的代价求和，得到每层代价，然后将所有层数代价求和，得到所有层数调用递归的总代价。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>用主方法求解递归式</b></h2><p>主方法提供了一种“菜谱式”的求解方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>T(n) = aT(n/b) + f(n)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>递归式描述的是这样一种算法运行时间：它将规模为n的问题分解为a个子问题，每个子问题的规模为n/b，其中a和b都是正常数。a个子问题递归的求解，每个问题花费时间T(n/b)，函数f(n)包含了问题分解和子问题解合并的代价。</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>若对某个常数 ε&gt;0 有 f(n) = O(nlogba-ε)，则 T(n) = Θ(nlogba) 。</li><li>若 f(n) = Θ(nlogba)，则 T(n) = Θ(nlogba lgn) 。</li><li>若对某个常数 ε&gt;0 有 f(n) = Ω(nlogba+ε)，且对某个常数 c&lt;1 和所有足够大的 n 有 af(n/b) ≤ cf(n)，则 T(n) = Θ(f(n)) 。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>对于三种情况，我们都将函数 f(n) 与函数 nlogba 进行比较。直觉上，递归式的解取决于两个函数中的较大者。如情况一是 nlogba 较大，情况3是 f(n) 较大。而情况2是两者一样大，这种情况需要乘上一个对数因子。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不知不觉，写了这么多，刚开始开这个系列本意是想以刷题为主的，没想到到现在是算法介绍为主了，这当然也有自己想做点输出来巩固记忆。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>好吧，下面是真题时间！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>53. 最大子序和</p><p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],</p><p>输出: 6</p><p>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>暴力求解</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxSubArray(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        # for i in range(n):\n        #     arr[i] = arr[i] - arr[i-1]\n        max_sum = nums[0]\n        sum = 0\n        for num in nums:\n            sum += num\n            if max_sum &lt; sum:\n                max_sum = sum\n            if sum &lt; 0:\n                sum = 0\n        return max_sum</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>动态规划</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxSubArray(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        if len(nums) == 0:\n            return null\n        res = nums[0]\n        n_num = -1\n        for num in nums:\n            n_num = max(num,n_num + num)\n            res = max(n_num,res)\n        return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "分治策略", 
                    "tagLink": "https://api.zhihu.com/topics/20096482"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }
            ], 
            "comments": [
                {
                    "userName": "lonelyprince", 
                    "userLink": "https://www.zhihu.com/people/90c0af7aaf025e3778cf6a8121358885", 
                    "content": "这题动态规划才是正解", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57300671", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "Map-Reduce原理简介", 
            "content": "<p><b>首先我们来思考下，当计算机集群在计算时，往往会遇到哪些的问题呢？</b></p><p>    1.高故障率</p><p>1000台服务器的集群 =&gt; 平均故障率 1 次/天</p><p>100万台服务器的集群 =&gt; 平均故障率 1000 次/天</p><p>故障率这么高，如何保持数据的持续性，即在某些节点故障的情形下不影响依旧能够使用数据？</p><p>在运行时间较长的集群运算中，如何应对节点故障呢？</p><p>    2.网络带宽瓶颈</p><p>如果网络带宽 = 1 Gbps ，那么移动10TB 数据需要花费将近一天</p><p>    3.分布式编程非常复杂</p><p>能否有一个简单的模型能够隐去所有的复杂性？<br/></p><p><b>Map-Reduce集群运算时问题的解决方案</b></p><p>    1.在多节点上冗余地存储数据，以保证数据的持续性和一直可取性</p><p>    2.将计算移向数据端，以最大程度减少数据移动</p><p>    3.简单的程序模型隐藏所有的复杂度</p><p class=\"ztext-empty-paragraph\"><br/></p><p>同时，我们也创造了<b>分布式文件存储系统</b></p><p>以提供全局的文件命名空间，冗余度和可获取性</p><p>例如Google 的 GFS; Hadoop 的 HDFS </p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>典型的应用场景与模式</b></p><p>超大级别的数据量(100GB到100TB级别)，数据很少就地整个被替换；</p><p>最常见的操作为读取和追加数据；</p><p>数据以“块状”形式在多台机器上存储；</p><p>每个数据块都会重复地在多台机器上存储，保证数据的持续性和随时可取性；</p><hr/><p><b>计算模型示例</b></p><p>假设我们手头上有个超大的文本文件，我们需要统计每个文本中的词所出的次数</p><p>假设所有的词和频次对&lt;word, count&gt; 都超出了内存大小，无法一次性放入内存进行计算</p><p><br/>我们使用Linux命令：</p><p>words(doc.txt)| sort | uniq -c</p><p>其实这行代码体现了MapReduce的精髓，我们来看一下：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>words(doc.txt)| sort | uniq -c</p><blockquote>words命令输出一个文本内容中所有词，一个一行<br/>sort是进行排序<br/>uniq -c是去重并统计重复的数字</blockquote><p>对应Map-Reduce就是：</p><p><b>Map </b></p><p>逐个文件逐行扫描</p><p>扫描的同时抽取出我们感兴趣的内容</p><p><b>(Keys)Group by key </b></p><p>排序和洗牌</p><p><b>Reduce </b></p><p>聚合、总结、过滤或转换</p><p>写入结果<br/></p><p>我们可以看到总体框架都和上述描述过程一致，只是Map和Reduce函数要根据具体问题具实现<br/></p><p>所以在工程上，我们基本是写Map或者Reduce，再写个运行脚本就行了</p><p>如果不理解Linux，可以看看鸟哥的私房菜基础版（广告费麻烦结下！~！）<br/></p><p><b>我们总结下总流程</b></p><p>1.首先是利用map函数读取输入文本，产生一系列的键值对</p><p>2.接下来是key-value，即将所有有相同key的键值对排在一起</p><p>3.最后输出key-value，即把不同key的value加起来，就能最终的输出结果，每个key的统计结果value</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>故障及处理</b></p><p>    1.Map任务节点故障</p><p>所有运行中和已经完成的map任务，都被重置为待初始</p><p>所有这些待初始Map任务，将重新被分配到能工作的节点worker</p><p>    2.Reduce任务节点故障</p><p>只有运行中而未完成的reduce任务被设定为待初始。</p><p>这些待初始reduce任务被重新分配至其他worker</p><p>    3.主节点故障</p><p>整个Map-Reduce任务中断，同时通知客户端管理员。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "MapReduce", 
                    "tagLink": "https://api.zhihu.com/topics/19621083"
                }, 
                {
                    "tag": "分布式计算", 
                    "tagLink": "https://api.zhihu.com/topics/19552071"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58585315", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 3, 
            "title": "leetcode刷题（四）：搜索(深度优先搜索,广度优先搜索）拓扑排序，强连通分量", 
            "content": "<p>在开始今天的话题之前，我们先了解一个概念，什么是图的遍历？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>图的遍历</b>就是从图中某一点出发访遍图中其余剩余定点，且每个顶点仅被访问一次，这个过程叫做图的遍历。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图的遍历主要被分为<b>深度优先遍历</b>和<b>广度优先遍历</b>。</p><p><br/>此外，我们还要了解两个概念，<b>邻接链表</b>和<b>邻接矩阵</b>：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>邻接链表</b>的存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>邻接矩阵</b>的逻辑结构分为两部分：V和E集合。因此，用一个一维数组存放图中所有顶点数据；用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>邻接链表的一个潜在缺陷就是无法快速判断一条边（u，v）是否是图中的某一边，唯一的解决办法就是再A[u]里面搜索节点v。而邻接矩阵就克服了这个缺陷，而付出的代价是更大的存储空间消耗。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>深度优先搜索</b></h2><p>深度优先搜索总是对最近才发现的点v的出发搜索，直到该点所有的出发边都被发现为止。一旦该节点v所有的出发边都被发现，搜索则回溯到v的前驱结点，来搜索该节点的出发边。该过程一直持续到从源节点可以到达的所有节点都被发现为止。如果存在还未发现的节点，则深度优先搜索将会从这些尚未发现的节点中任选一个作为新的源节点，并重复整个过程，直到所有的节点都被搜索到为止。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>DFS实现算法：</p><ol><li>先创建一个visited数组，初始化为false。</li><li>调用遍历函数，实现递归。</li><li>当相邻节点为false时（即没有被访问过），以该节点进行递归。</li><li>否则返回上一节点。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>我们上伪代码吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">n = len(M)\nvisited = [False]*n\t#创建一个长度为n的visited数组\n\n\ndef dfs(i):\nvisited[i] = True\t#将visited数组上对应的i设置为True\nfor i in range(n):\nif M[i][j] == 1 and not visited[j]:\t#前提是没被访问过\n             dfs(j)\t#递归\n\n\ncount = 0\n        for i in range(n):\n            if visited[i] == False:\n                dfs(i)\n                count += 1\n        return count</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>深度优先遍历有点像<b>二叉树的前序遍历</b>过程：</p><ol><li>以某一节点开始，访问该节点</li><li>以该节点开始，重复１．（这里需要定义一个节点数大小的bool类型数组visited，来记录哪些节点访问过了，哪些节点没有访问过．）</li><li>当某个节点的邻接节点都访问过了，回退到上一个节点，访问上一个节点的其他相邻节点．</li><li>重复３．直至返回开始节点．</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>这是连通图的遍历方法，对于非连通图，我们只需循环调用递归，直至所有节点都访问过．</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>广度优先搜索 </b></h2><p>如果说，深度优先遍历类似于树的前序遍历，那么广度优先遍历就类似于<b>树的层序遍历</b>了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>广度优先遍历通过队列实现：</p><ol><li>从某一节点开始，将该节点入队，找到该节点的所有相邻节点，将他们入队。</li><li>将该节点出队，再将队头节点的所有相邻节点入队。（这里也需要一个visited数组，已经入队过的节点不再入队．）</li><li>检查队列，对队头元素进行操作，出队。 </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>为了更好的说明，我们上伪代码把！</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void BFSTraverse(Graph G, Status(*Visit)(int v))\n{/*按广度优先非递归遍历图G。使用辅助队列Q 和访问标志数组visited*/\n\tfor (v=0;v&lt;G,vexnum;++v)\n\t\tvisited[v]=FALSE;\n\tInitQueue(Q); /*置空的国债队列Q*/\n \n\tif (!visited[v]) /*v 尚未访问*/\n\t\t{EnQucue(Q,v); /*v 入队列*/\n\t\twhile (!QueueEmpty(Q))\n\t\t\t{ DeQueue(Q,u); /*队头元素出队并置为u*/\n\t\t\tvisited[u]=TRUE; visit(u); /*访问u*/\n\t\t\tfor(w=FistAdjVex(G,u); w; w=NextAdjVex(G,u,w))\n\t\t\t\tif (!visited[w]) \n\t\t\t\t\tEnQueue(Q,w); /*u 的尚未访问的邻接顶点w 入队列Q*/\n\t\t\t}\n\t\t}\n}/*BFSTraverse*/</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>两个算法的总结</b></h2><p>遍历的目的是为了找到合适的定点，那么选择哪一种遍历就要仔细斟酌了，深度优先遍历适合于目标明确，以找到目标为主要目的的情况，而广度优先遍历适合于在不断扩大遍历范围时，找到相对最优的情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是几道真题，我特意把深度优先搜索和广度优先搜索的真题混在一起了，大家在看真题的时候先要自己判断下是哪种类型的搜索哦！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Leetcode : 695. Max Area of Island (Easy)</b></p><p>给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 1:</p><p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],</p><p> [0,0,0,0,0,0,0,1,1,1,0,0,0],</p><p> [0,1,1,0,1,0,0,0,0,0,0,0,0],</p><p> [0,1,0,0,1,1,0,0,1,0,1,0,0],</p><p> [0,1,0,0,1,1,0,0,1,1,1,0,0],</p><p> [0,0,0,0,0,0,0,0,0,0,1,0,0],</p><p> [0,0,0,0,0,0,0,1,1,1,0,0,0],</p><p> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def dfs(self,grid,i,j):\n        cnt = 1\n        m = len(grid)\n        n = len(grid[0])\n        grid[i][j] = -1\n        out = [[-1,0],[1,0],[0,-1],[0,1]]\n        for k in range(4):\n            p = i + out[k][0]\n            q = j + out[k][1]\n            if(p&gt;=0 and p&lt;m and q&gt;=0 and q&lt;n and grid[p][q] == 1):\n                cnt += self.dfs(grid,p,q)\n        return cnt\n    def maxAreaOfIsland(self, grid):\n        &#34;&#34;&#34;\n        :type grid: List[List[int]]\n        :rtype: int\n        &#34;&#34;&#34;\n        big = 0\n        m = len(grid)\n        n = len(grid[0])\n        for i in range(0,m):\n            for j in range(0,n):\n                if grid[i][j] == 1:\n                    big = max(big,self.dfs(grid,i,j))\n        return big</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Leetcode : 547. Friend Circles (Medium)</b></p><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例 :</p><p>输入: </p><p>[[1,1,0],</p><p> [1,1,0],</p><p> [0,0,1]]</p><p>输出: 2 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>说明：已知学生0和学生1互为朋友，他们在一个朋友圈。</p><p>第2个学生自己在一个朋友圈。所以返回2。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def findCircleNum(self, M):\n        &#34;&#34;&#34;\n        :type M: List[List[int]]\n        :rtype: int\n        &#34;&#34;&#34;\n        if M == [] or M[0] == []:\n            return 0\n        n = len(M)\n        visited = [False]*n\n \n        def dfs(i):\n            visited[i] = True\n            for j in range(n):\n                if M[i][j] == 1 and not visited[j]:\n                    dfs(j)\n \n        count = 0\n        for i in range(n):\n            if visited[i] == False:\n                dfs(i)\n                count += 1\n        return count</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Leetcode : 130. Surrounded Regions (Medium)</b></p><p>给定一个二维的矩阵，包含 &#39;X&#39; 和 &#39;O&#39;（字母 O）。</p><p>找到所有被 &#39;X&#39; 围绕的区域，并将这些区域里所有的 &#39;O&#39; 用 &#39;X&#39; 填充。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>示例:</p><p>X X X X</p><p>X O O X</p><p>X X O X</p><p>X O X X</p><p>运行你的函数后，矩阵变为：</p><p>X X X X</p><p>X X X X</p><p>X X X X</p><p>X O X X</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def solve(self, board):\n        &#34;&#34;&#34;\n        :type board: List[List[str]]\n        :rtype: void Do not return anything, modify board in-place instead.\n        &#34;&#34;&#34;\n        if board == None :\n            return []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == &#39;O&#39;:\n                    if i == 0 or i == len(board) -1 or j == 0 or j == len(board[0]) -1:\n                        self.robot(board,i,j,len(board),len(board[0]))\n \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == &#39;O&#39;:\n                    board[i][j] = &#39;X&#39;\n                elif board[i][j] == &#39;*&#39;:\n                    board[i][j] = &#39;O&#39;\n \n    def robot(self,board,i,j,m,n):\n        dx = [0,0,1,-1]\n        dy = [1,-1,0,0]\n        board[i][j] = &#39;*&#39;\n        for idx in range(4):\n            if i + dx[idx] &gt;= 0 and i + dx[idx] &lt; m and j + dy[idx] &gt;= 0 and j + dy[idx] &lt; n and board[i + dx[idx]][j + dy[idx]] == &#34;O&#34;:\n                self.robot(board,i+dx[idx],j+dy[idx],m,n)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们再顺带介绍下拓扑排序和强连通分量吧，之所以把它们和上面两个算法放在一起讲，是因为都属于图的范畴，大家可以了解下。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>拓扑排序</b></h2><p>对于一个有向无环图G来说，拓扑排序是G中所有节点的一种先行次序，该次序满足以下条件：如果图G包含（u，v），那么节点u处于在节点v的前面。可以将拓扑排序看作是将图的节点在一条水平线上排开，图的所有有向边都从左指向右。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>强连通分量</b></h2><p> 在有向图G中，如果两点互相可达，则称这两个点强连通，如果G中任意两点互相可达，则称G是强连通图。</p><ol><li>一个有向图是强连通的，当且仅当G中有一个回路，它至少包含每个节点一次。</li><li>非强连通有向图的极大强连通子图，称为强连通分量</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>我们有两种方法来判断是否为强连通图，我们来分别介绍下：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法1：Korasaju算法</b></p><p>首先理解一下转置图的定义:将有向图G中的每一条边反向形成的图称为G的转置GT 。(注意到原图和GT 的强连通分支是一样的)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>算法流程：</p><ol><li>深度优先遍历G,算出每个结点u的结束时间f[u],起点如何选择无所谓。</li><li>深度优先遍历G的转置图GT ,选择遍历的起点时,按照结点的结束时间从大到小进行。遍历的过程中,一边遍历,一边给结点做分类标记,每找到一个新的起点,分类标记值就加1。</li><li>第2步中产生的标记值相同的结点构成深度优先森林中的一棵树,也即一个强连通分量</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>简而言之，就是先深度优先遍历，再将图转置后进行深度优先遍历，如果标记相同，可以理解为两点可以相互到达，就是强连通分量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>方法二：Tarjan算法</b></p><p>Tarjan算法是基于对图深度优先搜索的算法，每个强连通分量为搜索树中的一棵子树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>算法思想如下：</p><p>　　 dfn[u]表示dfs时达到顶点u的次序号，low[u]表示以u为根节点的dfs树中次序号最小的顶点的次序号，所以当dfn[u] = low[u]时，以u为根的搜索子树上所有节点是一个强连通分量。 先将顶点u入栈，dfn[u] = low[u] = ++idx,扫描u能到达的顶点v，如果v没有被访问过，则dfs(v)，low[u] = min(low[u],low[v])，如果v在栈里，low[u] = min(low[u],dfn[v])，扫描完v以后，如果dfn[u] = low[u]，则将u及其以上顶点出栈。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>简而言之，就是根据深度优先将节点压到栈中，然后观察栈顶的节点能到达的距离栈底最近的那个节点，将其提取出来，就是强连通分量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "搜索", 
                    "tagLink": "https://api.zhihu.com/topics/19552128"
                }, 
                {
                    "tag": "tinyxml", 
                    "tagLink": "https://api.zhihu.com/topics/19927778"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57563953", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 0, 
            "title": "浅谈人工智能及对未来研究方向的浅见", 
            "content": "<p>这是一篇去年写的文章，一直放在我的公众号上，今天想起来就搬运过来，希望你们会喜欢！~！</p><p>笔者近日参加了阿里巴巴组织的云栖大会，在会上聆听了众多大牛对于AI的看法以及展望，感慨良多，现将与会记录和自己的一些想法和大家分享，希望对大家有所帮助。</p><p>人工智能旨在为机器人赋予人的智能，机器学习是人工智能的一个分支，专门研究计算机如何模拟或者实现人类的学习行为。</p><p>深度学习是实现机器学习的一种技术使得机器学习能够实现诸多的应用，并拓展了人工智能的领域范围。</p><p>传统机器学习描述学习样本的特征通常由专家设计，称为特征工程；深度学习则通过机器学习来产生特征，即特征学习或者表示学习；因此在数据的初始表示与解决任务所需要的合适表示相距甚远时，可以尝试深度学习的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>传统机器学习</b></p><p>数据样本----&gt;专家设计特征----&gt;学习</p><p><b>深度学习</b></p><p>数据样本----&gt;机器学习特征----&gt;学习</p><p><b>机器学习的基本定理</b></p><p>模型出错率=模型的复杂程度/样本大小</p><p>测量设备（获得数据）----&gt;预处理（去噪，特征提取）----&gt;维度约减（特征选择）----&gt;</p><p>模型训练（分类或回归）----&gt;模型测试（交叉验证）----&gt;结果验证</p><p><b>挑战问题一：泛化问题</b></p><p>几乎所有领域，都希望越准越好！提高泛化能力是永远的追求</p><p>目前泛化能力较好的技术：支持向量机（SVM）产生途径：理论----&gt;实践</p><p>集成学习 产生途径：实践----&gt;理论</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>挑战问题二：速度与精度</b></p><p>几乎所有领域，都希望越快越好</p><p><b>训练速度VS测试速度</b></p><p>训练速度快的往往测试速度慢：K近邻</p><p>测试速度快的往往训练速度慢：神经网络</p><p>训练速度和测试速度都较快的：极限学习机ELM</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>挑战问题三：可解释性</b></p><p>绝大多数领域都希望可解释性</p><p>但是性能较好的技术几乎都是黑盒子：神经网络，支持向量机，集成学习</p><p><b>深度学习时代：</b></p><p><b>数据的获取与清洗技术</b></p><p>异常数据筛检--奇异性检测</p><p>数据去量纲化----归一化处理</p><p>数据预处理----降噪、修复、增强</p><p><b>模型构建与网络选择</b></p><p>图像处理----卷积神经网络</p><p>语音处理----递归神经网络</p><p>数据扩充与生成----深度生成模型</p><p>技巧----归一化、权值剪枝、稀疏</p><p><b>软计算和硬件平台</b></p><p>学习算法----批量随机梯度下降</p><p>硬件平台----Caffe等平台搭建</p><p>平构计算----权值共享、迁移学习</p><p><b>深度学习的思考：</b></p><p>利用前人的工作（fourier形式的初始化和pooling），关键是利用频域卷积定理，将每层的卷积操作用（逆）快速傅里叶变化和Hadamard Pointwise Product操作来等价代替，实现了更快速高效的训练拟合。不过必须要说明的是，利用卷积定理做快速卷积操作在信号处理中已经不是新鲜事了，因此可以实现更快的卷积一点都不意外。真正值得挖掘的是，基于傅里叶变化的层操作是否可以提供更多的中间可视化层来为CNN的可解释性带来更多素材。</p><p><b>深度学习模型有三个基本的问题：</b></p><p>1.网络模型的容量估计问题：TestLoos-TrainLoss&lt;=√(C/N)  其中C为深度网络的容量，N为样本的个数。如何刻画样本的容量的问题</p><p>2.泛化理论，本质上是正则化问题，可以详看（理解深度学习需要重新考虑泛化）</p><p>3.考量优化算法避免梯度弥散和梯度爆炸的有效性</p><p>深度学习只是解决问题的一种方法，不是万能的，为了更好的解释模型，其<b>理论方面的研究</b>包括：</p><p>1.嵌入深度研究的特性，包括随机性，稀疏性等，对网络性能的影响</p><p>2.学习算法的创新性，以及实现深度网络的有效更新</p><p>3.深度学习中的结构性，引入稀疏，张量，低秩等操作和约束</p><p>4.网络的加速，利用频域卷积定理实现卷积操作的有效加速</p><p>5.深度网络中层特征的对称结构，即差分结构</p><p>6.信息模态单一，泛化迁移能力差</p><p>7.面向小样本的深度学习</p><p><b>五个关键问题：</b></p><p> 随机算法（缺乏实验的可重复性）----&gt;各有所长的算法（无免费午餐定理）----&gt;缺乏理论证；缺乏实际应用（理论与实际的鸿沟）----&gt;没有最优的通用参数（参数调节与控制）----&gt;非EC专家（缺乏用户友好性）</p><p>最后打个小广告，我的公众号，喜欢写点零零散散的小东西，不介意可以关注下</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "AI技术", 
                    "tagLink": "https://api.zhihu.com/topics/20106982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57923159", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "leetcode刷题（三）：排序算法（快速排序）", 
            "content": "<p>今天，我们要来讲讲排序算法中的快速排序，说到快速排序，这可是大家以后在笔试面试中都绕不过去的一道坎，连快排都不会，那笔试基本就凉凉了。所以我们开始吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>快排：</b></h2><p>对于包含n个数的输入数组来说，快排是一种最坏情况时间复杂度O(n^2)的排序算法，虽然快排在最坏情况时间复杂度很差，但是它是实际排序运用中最好的选择，因为它的平衡性能特别好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>快排的基本思想就是通过一趟排序将待排序的序列分成两块独立的序列，其中一块序列的子序列均比另一块序列的子序列要大，重复多次，就能达到整个序列有序的目的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>和归并排序一样，快排也使用了分治思想，下面我们对一个典型的子数组A[p……r]来进行散步分治思想的过程：</p><p>分解：数组A[p……r]被分成两个（可能是空集）数组，A1[p……q]和A2[q……r]，其中A1中每个元素都小于q，而A2中每个元素都大于q。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我用伪代码来进行更好的说明：</p><div class=\"highlight\"><pre><code class=\"language-text\">QOICKSORT(A，p，r)\n  if p &lt; r\n    q = PARTITION(A,p,r)\n    QUICKSORT(A,p,q-1)\n    QUICKSORT(A,q+1,r)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>其中，PARTITION是调用的关键，他实现了对子数组A[p……r]的原址重排，下面是PARTITION的伪代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">PARTITION(A,p,r).\n  x = A[r]\n  i = p-1\n  for j = p to r-1\n    if A[j] &lt;= x\n      i += 1\n      exchange A[i] with A[j]\n    j += 1\n  return i + 1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>在这个过程中，PARTITION维护了四个区，分别是[p，i]：这个区间的元素都&lt;=x；[i,j]：这个群区间的元素都&gt;=x；[j，x]：这个区间的元素可能属于任何一种情况；[x]：x的区间。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>简单来讲,在PARTITION过程中，会出现两种情况：</p><ol><li>A[j]&gt;x,需要做的就是j+1，继续循环；</li><li>A[j]&lt;x,此时需要将A[i+1]和A[j]交换，然后j+1即可，此时，循环不变量得到保持。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>再通俗地讲，就是将选取的pivotkey不断交换，将比它小的换到左边，比它大的换到右边，在这个过程中自己也不断移动，知道满足这个要求位置。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以在终止时，j=r，我们得到了三个集合，分别是包含所有大于x的集合，所有包含小于x的集合，以及元素x的集合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面我们来来聊一下快速排序的性能：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>快速排序运行时间依赖于排序是否平衡，而平衡与否又依赖于用于划分的元素。如果划分平衡，那快速排序的算法性能和归并排序一样，如果划分不平衡，那快速排序的算法性能接近于插入排序了。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>最坏情况的划分：</b></h2><p>当划分的两个子数组里面存在0和n-1时，最坏划分情况就发生了，此时算法运行时间的递归式是T(n) = T(n-1) + T(0) + O(n) = T(n - 1) + O(n)此时解为<b>O(n^2)</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，如果在算法的每一层递归上，划分都是最大程度的不平衡，那么，算法的时间复杂度是O(n^2)，也就是说，在最坏的情况下，快速排序的运行时间并不比插入排序好，此外，当输入数组已经完全有序的时候，快速排序的时间复杂度依然是O(n^2)，而在同样的情况下，插入排序的时间复杂度为O(n)。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>最好情况的划分：</b></h2><p>在最平衡的划分当中，PARTITION得到的两个子数组的规模都不大于n/2，一个数组规模为[n/2]，另一个数组的 规模为[n/2]-1，那么快排的性能就会特别好，算计你发运行时间的递归式是T(n) = 2T(n/2) + O(n/2)，此时解为O(nlgn),通过在每一层上都进行平衡划分，我们得到了一个渐进时间上更快的算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>快排的运行时间更接近于最好的情况，而非最坏的情况，事实上，任何一种常熟比例的划分都会产生深度为O(lgn)的递归树，其中每一层的时间代价都是O(n)，只要划分的是常数比例的，算法的运行时间都是<b>O(nlgn)</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>从直观上看，差的划分代价O(n-1)可以被吸收到好的划分代价O(n)，从而得到的划分代价也挺好的。因此，当好的划分代价和差的交替出现的时候，快速排序的时间复杂度和全是好的时候划分是一样的，还是O(nlgn)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此我们可以得出结论，在使用PANDOMIZED-PARTITION，在输入元素互异的情况下，快速排序的期望时间复杂度还是O(nlgn)。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>这就完了吗？当然没有啦，根据往年经验，面试官大概率会问问你怎么优化的问题，那我们就来谈谈怎么优化快排把！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.优化选取枢轴</b></h2><p>前面我们说过的最好情况和最坏情况的区别，就是选区枢轴的不退缩造成的。所以我们可以优化选区枢轴，我们之前的代码选取是固定地选择第一个关键字，但太大或者太小都会影响效率。所以我们就有了<b>三数取中法</b>，即随机取三个关键字进行排序，然后将中间数所谓枢轴，一般我们选区左端，右端和中间三个数。这样至少中间的书不是最大和最小数。可以自己打一打代码。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>三数取中对小数组来说有很大的概率选择到一个较好的pivotkey，但是对于大型的数组来说还不够，所以进一步还有<b>九数取中</b>，取三次样本，每一次都去三个，每三个样本的中数中再取出一个中数当作枢轴。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.优化不必要的交换</b></h2><p>我们将pivotkey备份到A[0]中，然后之前是swap时，我们只需要做替换的工作，最终A[i]和A[j]融合，再将A[0]位置的数值赋值回A[i]。因为这里少了多次交换数据的操作，在性能上又得到了部分的提高。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.优化小数组时的排序方案</b></h2><p>如果数组特别小，其实快速排序反而不如直接插入来的快，所以我们可以自己做一个阈值判断，如果i-j大于某个常数时(一般认为，，没个准，具体数值看自己心情吧)，就使用直接插入排序，这样就能最大限度使用两种排序的优势来完成任务了。<br/></p><p>讲了这么多，做做真题吧！~！</p><p>Leetocde : 215. Kth Largest Element in an Array (Medium)</p><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2</p><p>输出: 5</p><p>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</p><p>输出: 4</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def partition(self,nums,l,r):\n        v = nums[l]\n        j = 1\n        for i in range(l+1,r+1):\n            if nums[i] &gt; v:\n                j += 1\n                nums[i],nums[j] = nums[j],nums[i]\n            nums[l],nums[j] = nums[j],nums[l]\n        return j\n \n \n    def findKthLargest(self, nums, k):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        &#34;&#34;&#34;\n        l = 0\n        r = len(nums) - 1\n        j = self.partition(nums, l, r)\n        while j != k - 1:\n            if k - 1 &gt; j:\n                j = self.partition(nums, j+1,r)\n            if k - 1 &lt; j:\n                j = self.partition(nums, l, j-1)\n        # print(nums[j])\n        return nums[j] </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>差不多就是这样了，希望本文能帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "快速排序", 
                    "tagLink": "https://api.zhihu.com/topics/19644323"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }
            ], 
            "comments": [
                {
                    "userName": "Gavin", 
                    "userLink": "https://www.zhihu.com/people/0ee334d3469be05ca74bc29edcb10efe", 
                    "content": "三数取中 引入插入排序 很有收获", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "风轻袖影翻", 
                            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
                            "content": "多谢夸奖😜", 
                            "likes": 0, 
                            "replyToAuthor": "Gavin"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>很好的文章，让我重温了一下快排：）最后代码好像有个小问题判定条件好像是 `while j != len(nums)-k` 因为要求的是第 k 大的数...</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58130758", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 4, 
            "title": "海量高维数据与近似最近邻", 
            "content": "<p>在实际工程当中，我们常常会遇到海量的数据，那作为一个数据挖掘准从业人员，如何从海量的数据当中挖掘出他们数据之间的关系和规律就显得尤为重要了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天我要讲的时海量高维数据及其近似最近邻方案。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>K-近邻算法（KNN）概述 </b></h2><p>KNN是通过测量不同特征值之间的距离进行分类。它的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别，其中K通常是不大于20的整数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。</p><h2><b>距离准则</b></h2><p>在聊接下去的内容之前，我们首先要了解一个概念，叫<b>距离准则</b>：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>距离准则有欧氏距离，Jaccard相似度，余弦相似度，Pearson相似度这几种，我们来分别解释下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>欧式距离</b>就是指在m维空间中两个点之间的真实距离，或者向量的自然长度（即该点到原点的距离）。在二维和三维空间中的欧氏距离就是两点之间的实际距离，所以它实现的是绝对距离。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>余弦相似度</b>是通过计算两个向量的夹角余弦值来评估他们的相似度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Jaccard相似度</b>是用于比较有限样本集之间的相似性与差异性，其中Jaccard系数值越大，样本相似度越高。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Pearson相似度</b>是余弦相似度的升级版，它把每个向量都中心化了，即每个向量会减去所有向量的平均数，来实现数据更好的平衡，所以它实现的是相对距离。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>近似最近邻问题（KNN=&gt;ANN）</b></h2><p>我们具体在哪些情景中会需要用到近似最近邻呢？举几个简单的例子：</p><ol><li>Google/Baidu每天有海量新增的网页，怎么判断内容是否抄袭之前的网页，哪个网页为原创？</li><li>论文如何快速查重？</li><li>如何快速推荐用户所需要的商品，冷启动问题？</li><li>图像检索的问题？<br/></li></ol><p>这就轮到我们近似最近邻（ANN）大显身手的时候了！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>近似最近邻</b></h2><p>首先，我们要明白，不管哪种算法，都是需要在空间和时间上做出取舍的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们可以事先对数据预先做一些划分和索引，在这个过程中，我们会损失了⼀点准确率（划分和索引会产生错误），但是能换取搜索速度的极大提升。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>工程上常用算法：</p><ol><li>LSH（Local Sensitive Hash / 局部敏感度哈希）</li><li>K-Means Tree </li><li>K-D Tree </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们就逐一讨论下这几个算法吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>局部敏感度哈希</b></h2><p>LSH保证高维空间相近的点在低维空间相近的概率很高，举个栗子，在高维度上我们有两个样本A,B离得很近，在我们在进行压缩降维，映射到一个低维空间以后，我们还能保证A,B的距离还是很近。这是一个映射，取回的过程。</p><p><b>LSH的直观理解</b></p><p>首先，我们把原始的样本点映射成⻓度为N的⼀个2进制串，这个我相信大家都能理解。其次我们在其中划分多次，平面的上下分别设为0/1。可以理解为每个位次在空间取了⼀个超平面去做。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子，100这个二进制串，我们怎么划分呢？因为它有三个位次，我们需要划分三次，划一刀x，它在x的1这边。再划一刀y，它在y的0这一边，再划一刀z，它在z的0这边。所以它所代表的点在100，再多划几刀就是超平面了，这个过程和SVM很像。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那会不会有<b>误差</b>呢？当然有了！之前我们就说过，在这个过程中，我们会损失⼀点准确率。比如说000和100所代表的点其实离得很近，但是因为x这一刀恰好划在了两个点之间，所以两个实际上离得很近的点就被分开了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那有没有办法把<b>精度补偿</b>回来呢？当然有啦！But no pay , no gain ! 你需要付出一些时间成本和计算成本来交换。比如说：多次划分！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面介绍一个在工业运用中的实例，用<b>LSH</b>来实现相似网页的查找：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Google每天会使用<b>Simhash</b>来完成完成亿级别的网页去重，具体就是将每个网页映射成64bit，当汉明距离&lt;=3的网页就会被认为非常相近的网页。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>嗯，我再举个经典的栗子吧，比如说有这么句话，“顾先生是大帅比！”。</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>我们把这句话分词，分词以后是“顾先生”，“是”，“大帅比”。</li><li>我们分别给每个词一个权重，比如说“顾先生”为8，“是”为2，“大帅比”为5。</li><li>我们对每个词做一个哈希，比如说“顾先生”为10，“是”为01，“大帅比”为11。</li><li>我们在它的基础上乘上权重，(这里要注意一点，如果位置上为0，那就权重*-1，而非*0)，得到(8,-8)，(-1,2)，(5,5)。</li><li>将其纵向累加起来，得到(12,-1)，然后做一个降维，得到(1,-1)<br/>这就是LSH的全过程。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>这就是LSH的全过程。<br/></p><p>再多嘴一句，给每个词的权重不是我瞎给的哦，可以去Google下<b>tf-idf</b>，简单来讲就是“顾先生”这个词在本篇文档里面出现了100次，但在总的文档里面也就出现了200次，那我们就可以认为这个词在这篇文档里面很重要，我们自然就给予它很重的权重。如果像“是”这个词在本篇文档里面出现了100次，但在总的文档里面却足足出现了两万次，那我们就可以认为这个词在这篇文档里面不太重要，我们当然也不会给它太大的权重了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那除文本之外的其他格式的数据，如何求近似最近邻呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其实都是换汤不换药的，先把数据表示成向量格式，比如文本使用bag of words，ti-idf的方式， 图像使用GIST，HOG，SIFT，或者卷积神经网络尾层的方式，用户数据使用交互的商品和用户行为的统计值向量来完成从数据到向量的改变。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来就是使用库完成向量向低维度2进制空间映射的过程，也就是之前的找到合适的“超平面”切分得到01。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>除了LSH算法，我们还有其他的算法，比如说<b>K-means Tree</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>K-means Tree</b></h2><p>K-means是⼤家都熟知的聚类算法。K-means Tree实际就是对数据做了多层K-means 。每⼀层到当前的划分“叶子节点”包含样本数都少于T个。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体来说就是在总体上先划分，如果在划分后还剩下很多样本，远大于我们设置的阈值T，那我们对剩下的样本在做划分，直到每⼀层到当前的划分“叶子节点”包含样本数都少于T个。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们聊一聊ANN里面的<b>K-D Tree</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>K-D Tree</b></h2><p>K-dimension tree，对数据点在k维空间中划分的⼀种数据结构。K-D tree实际上是⼀种⼆叉树。我们来简单说⼀下构建和检索近似最近邻过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个栗子，我们有{(2,3 ),(5,4),(9,6),(4,7), (8,1), (7,2)} 6个样本点，首先我们要找波动/方差最大的维度做二叉树切分，我们来看，第一个维度是{2，4，5，7，8，9}，第二个维度是{1，2，3，4，6，7}，很显然，第一个维度波动大。接着我们来找一下第一个维度的划分点。划分点要求左右可以平衡，可以直观地理解成中位数，那么第一个维度就是7。第一个维度完成后再找第二个维度，同理，第二个我们选择4。我们递归地完成这个过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有时候为了增加多样性，我们会随机取样本来确定哪些维度波动高，从而建立多棵树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面介绍几个<b>ANN常用的库</b>：</p><p><b>ANNOY</b>：建索引与最近邻查找，可以直接用list作为向量</p><p>举个栗子：</p><div class=\"highlight\"><pre><code class=\"language-text\">from annoy import AnnoyIndex\nimport random\nf = 40 #建索引的维度\nt = AnnoyIndex(f) #初始化一个对象\nfor i in range(1000): #产出1000个88维度的样本\n    v = [random.gauss(0,1) for z in range(f)] #用高斯分布产生随机数后把它丢进克\n    t.add_item(i,v) #丢进去的是list形式\n \n    t.build(8) #产生8棵树\n    t.save(&#39;test.ann&#39;) #保存模型\n \n    #模型保存好了，如果我们以后要用它时，改怎么调用呢？\n \n    u = AnnoyIndex(f)\n    u.load(&#39;test.ann&#39;)\n    print(u.get_nns_by_item(0,1000))</code></pre></div><p><b>FLANN：</b></p><p>集成了多种最近邻检索方式，可以<b>指定准确率</b>。</p><p>可以选择自动模式，它会<b>帮你选最合适的模型和方式</b>。</p><p>载入数据量大模型的时候速度稍微有点慢。<br/></p><p>举个栗子：</p><div class=\"highlight\"><pre><code class=\"language-text\">from pyflann import *\nfrom numpy import *\nfrom numpy.random import *\n\n\ndataset = rand(10000, 128) #random生成了10000个128维的向量\ntestset = rand(1000, 128) #random生成了1000个128维的向量\n\n\nflann = FLANN()\nparams = flann.build_index(dataset, algorithm=&#34;autotuned&#34;, target_precision=0.9, log_level = &#34;info&#34;); #自动调优，准确度为90%\nprint (params)\n\n\nresult, dists = flann.nn_index(testset,5, checks=params[&#34;checks&#34;]);</code></pre></div><p>差不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "K近邻算法", 
                    "tagLink": "https://api.zhihu.com/topics/20688152"
                }, 
                {
                    "tag": "高维数据分析", 
                    "tagLink": "https://api.zhihu.com/topics/20010341"
                }, 
                {
                    "tag": "数据挖掘", 
                    "tagLink": "https://api.zhihu.com/topics/19553534"
                }
            ], 
            "comments": [
                {
                    "userName": "秦景坤", 
                    "userLink": "https://www.zhihu.com/people/be66ca3e888b8ff8f6054122660964c2", 
                    "content": "<p>没想到我是首赞</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "风轻袖影翻", 
                            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
                            "content": "感谢老哥捧场", 
                            "likes": 0, 
                            "replyToAuthor": "秦景坤"
                        }, 
                        {
                            "userName": "秦景坤", 
                            "userLink": "https://www.zhihu.com/people/be66ca3e888b8ff8f6054122660964c2", 
                            "content": "<p>可惜flann 只支持2.6，2.7，3.2-3.4版本</p>", 
                            "likes": 0, 
                            "replyToAuthor": "风轻袖影翻"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51121228", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 4, 
            "title": "关于CTR广告预估的分享", 
            "content": "<p>今天我想分享的是CTR广告预估<br/>之前一段时间做了kaggle上的CTR及其类似的项目<br/>一般来说，做CTR问题，用到的算法基本有LR，Random Forest，GBDT，FM以及FFM<br/><br/>这次我主要想分享这几种算法以及做数据处理时遇到的问题和收获<br/><br/>在工业实际运用中，由于模型替换，数据分布不一致，解决性不一致等限制，用到最多的还是LR，正如师兄所说，最简单的，也是最难的。<br/><br/><br/><b>CTR的核心问题主要是点击率</b><br/>*广告排序<br/>– ECPM=CTR*Bid<br/>– 排序时Bid已知，但CTR未知<br/>*扣费<br/>– CPCi = (CTRi+1*CPCi+1)/CTRi<br/>– 当前广告的扣费依赖当前及后一条广告的CTR<br/>所以，计算每条广告的CTR是排序和扣费的核心<br/><br/><b>数据样本过大</b><br/>我们现在做的比赛样本都比较小，几个G上下，在自己的PC上还是能凑和的，但是在实际运用中，样本往往会很大，往往达到几百G，所以一般有两种方法可以来处理：<br/>1.下采样：直到样本大小达到我们能够训练的程度。注意在采样时尽量让样本达到均衡的状态如：正样本采样率多一点，负样本采样率少一些<br/>2.借助工具：Spark MLlib <br/><a href=\"https://link.zhihu.com/?target=http%3A//spark.apache.org/mllib/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spark.apache.org/mllib/</span><span class=\"invisible\"></span></a><br/><br/><b>数据维度过大</b><br/>降维即可，方法如下：<br/>1.可以把用户名做一个聚类<br/>2.可以将时间分段，达到降维的效果<br/><br/>tip：在处理大数据的时候，如果用pandas，不出意外，内存肯定会爆掉，所以推荐使用LIBSVM，这是台湾大学的一位教授开发的一款简单快捷的SVM模式识别与回归软件包，这款软件在数据处理（比如One-Hot Encoding后）能有效减少所需内存<br/><br/><b>从FM到FFM</b><br/>FM和FFM模型是最近几年提出的模型，因其在数据量比较大并且特征稀疏的情况下，仍然能够得到优秀的性能和效果的特性，屡次在CTR预估比赛中获得不错的战绩。<br/>FM：有三个库，台大的LIBMF;原作者的LIBFM；还有上交的svdfeature<br/>FFM：LIBFFM<br/>关于这两个算法，网上已经有很多优秀的资料了，在这里我主要讲一下自己的理解<br/><br/><b>FM：</b><br/>首先通过观察大量的样本数据可以发现，某些特征经过关联之后，与label之间的相关性就会提高。例如，“男人”和“游戏”、“女人”与“化妆品”这样的关联特征，对用户的点击有着正向的影响。这种关联特征与label的正向相关性在实际问题中是普遍存在的，所以引入两个特征的组合是非常有意义的。<br/><br/>然而，在经过One-Hot Encoding之后，大部分样本数据特征是比较稀疏的，大多数样本的维度都是零值，导致样本数据的稀疏性。<br/><br/>其次，之前提过，需要引入两个特征的组合，但这也会导致特征空间大。举个栗子：如果类别有100维，那组合后的维度会达到100*100=10000，而且在组合中，绝大多数是零值，从而导致的结果有：1.太费电脑了2.模型结果不准。<br/><br/>为了解决此问题，我们将所有二次项参数Wij可以组成一个对称阵W(W=(V^T)*V)，V的第j列便是第j维特征的隐向量。通俗来说，还是上面的例子，100维的类别组合后是10000个参数，但是如果我引入一个隐向量j：8，如下[100*8]*[8*100]，结果是一样的，而且[8*100]只不过是[100*8]的转置，就可以大大减小参数个数和训练的复杂度。<br/><br/><b>FFM:</b><br/>然而，还是有人觉得FM的组合太硬了，可以有更灵活的组合方式，所以FFM应运而生。<br/><br/>在FFM中增加了“域”这个参数，比如说，“情人节”和“玫瑰”往往是有联系的，但是“情人节”和“春节”又有啥联系呢，所以它们之间的组合就是一种可耻的浪费，为了避免这种浪费，我们把“情人节”和“春节”归到一个名叫“节日”的域当中，接下我们分别对特征和域进行编号i、j，最后我们对不同域的不同特征进行组合，来找出它们之间的联系，而且FFM不会带来稀疏性的问题。<br/><br/><b>模型融合：</b><br/>在实际运用中，我们常常会有将不同的算法进行分布式处理，最后在进行模型的融合，举个栗子：在kaggle的avazu比赛中rank2就分别用GBDT,FM,VM以及RF进行预测，根据各个模型最终的准确率给予不同的权重，最后将模型融合起来，达到了不错的效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "ctr", 
                    "tagLink": "https://api.zhihu.com/topics/20175751"
                }, 
                {
                    "tag": "推荐系统", 
                    "tagLink": "https://api.zhihu.com/topics/19563024"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57217890", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 17, 
            "title": "leetcode刷题（一）：贪心算法", 
            "content": "<p>求解最优化的问题常常会有一系列的步骤，而每个步骤往往会面临着选择。</p><p>而贪心算法就是这样的算法，它在每一步都做出最优解，也就是说，它总是做出局部最优解，寄希望于通过局部最优解来获得全局最优解。</p><p>我们首先举个栗子：调度竞争资源来完成任务，比如我们要利用有限的资源（如一个阶梯教室）来实现任务（举办活动），每个活动的时间不一样，分别有开始时间和就结束时间，拿如何得到最优解呢？</p><p>我们看到虽然用动态规划来求解活动选择问题，但是并不需要这么做，我们可以反复选择最早结束的活动，同时保留与此兼容的活动，重复这一过程，直到不再有剩余活动。我们选择了活动结束的最早时间，所以活动结束时间必然是单调递增的，所以我们只需要按照结束时间的单调递增顺序处理所有活动，直到活动结束，每个活动只考察一次。</p><blockquote>定理：考虑任何非空子集问题S，a是S中最早结束的活动，所以a必然在S中某个最大兼容活动子集中。</blockquote><p>贪心算法往往是这种自顶向下的设计，先做出一个选择，然后再求解下一个问题，而不是自底向上解出许多子问题，然后再做出选择。</p><p>在做贪心选择时，我们直接做出当前问题中看起来最优的解，而不是考虑到子问题的解，这也是贪心算法和动态规划的不同之处，在动态规划中，我们往往每一个步骤都求做一个选择，这个选择往往依赖于子问题的解。而在贪心算法中，我们总是做出当时看来最佳的选择，然后再求解剩下唯一的子问题。贪心算法做出选择时可能会依赖于之前的选择或者子问题的解，但是绝对不依赖于将来的选择或者子问题的解。就是我们前面所说的，一个动态规划问题是自底向上的，而一个贪心算法问题是自顶向下的。</p><p>下面是几道leetcode题，解法思路都是贪心算法，我用的是python：</p><p>1.分配饼干</p><p>Leetcode : 455. Assign Cookies (Easy)</p><p>Input: [1,2], [1,2,3]</p><p>Output: 2</p><p>题目描述：每个孩子都有一个满足度，每个饼干都有一个大小，只有饼干的大小大于一个孩子的满足度，该孩子才会获得满足。求解最多可以获得满足的孩子数量。</p><blockquote>思路：因为最小的孩子最容易得到满足，因此先满足最小孩子。给一个孩子的饼干应当尽量小又能满足该孩子，这样大饼干就能拿来给满足度比较大的孩子。<br/>假设在某次选择中，贪心策略选择给第 i 个孩子分配第 m 个饼干，并且第 i 个孩子满足度最小，第 m 个饼干为可以满足第 i 个孩子的最小饼干，利用贪心策略最终可以满足 k 个孩子。假设最优策略在这次选择中给 i 个孩子分配第 n 个饼干，并且这个饼干大于第 m 个饼干。我们发现使用第 m 个饼干去替代第 n 个饼干完全不影响后续的结果，因此不存在比贪心策略更优的策略，即贪心策略就是最优策略。</blockquote><div class=\"highlight\"><pre><code class=\"language-haml\">class Solution:\n   def findContentChildren(self, g, s):\n       &#34;&#34;&#34;\n       :type g: List[int]\n       :type s: List[int]\n       :rtype: int\n       &#34;&#34;&#34;\n       g.sort()\n       s.sort()\n       i=j=res=0\n       while i&lt;len(g) and j&lt;len(s):\n           if g[i]&lt;=s[j]:\n               res += 1\n               i += 1\n           j += 1\n       return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>2.投飞镖刺破气球</p><p>Leetcode : 452. Minimum Number of Arrows to Burst Balloons (Medium)</p><p>Input:</p><p>[[10,16], [2,8], [1,6], [7,12]]</p><p>Output:</p><p>2</p><p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p><blockquote>思路：从左往右投飞镖，并且在每次投飞镖时满足以下条件：<br/>1.左边已经没有气球了；<br/>2.本次投飞镖能够刺破最多的气球。</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n   def findMinArrowShots(self, points):\n       &#34;&#34;&#34;\n       :type points: List[List[int]]\n       :rtype: int\n       &#34;&#34;&#34;\n \n       points.sort(key = lambda x:(x[0],x[1]))\n       n = len(points)\n       if n == 0:return 0\n       S = points[0][0]\n       E = points[0][1]\n       res = 1\n       for i in range(1,n):\n           if E&gt;points[i][1]:\n               E = points[i][1]\n           elif S&lt;points[i][0]:\n               S = points[i][0]\n           if S&gt;E:\n               res += 1\n               S = points[i][0]\n               E = points[i][1]\n       return res</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>3.股票的最大收益</p><p>Leetcode : 122. Best Time to Buy and Sell Stock II (Easy)</p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:</p><p>input: [7,1,5,3,6,4]</p><p>output: 7</p><p>思路: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</p><p>随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</p><blockquote>对于 [a, b, c, d]，如果有 a &lt;= b &lt;= c &lt;= d ，那么最大收益为 d - a。而 d - a = (d - c) + (c - b) + (b - a) ，因此当访问到一个 prices[i] 且 prices[i] - prices[i-1] &gt; 0，那么就把 prices[i] - prices[i-1] 添加加到收益中，从而在局部最优的情况下也保证全局最优。</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n   def maxProfit(self, prices):\n       &#34;&#34;&#34;\n       :type prices: List[int]\n       :rtype: int\n       &#34;&#34;&#34;\n       profit = 0\n       for i in range(len(prices)-1):\n           if prices[i+1]&gt;prices[i]:\n               profit += (prices[i+1]-prices[i])\n       return profit</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>4.种植花朵</p><p>Leetcode : 605. Can Place Flowers (Easy)</p><p>Input: flowerbed = [1,0,0,0,1], n = 1</p><p>Output: True</p><p>假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</p><p>给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。</p><p>示例 1:</p><p>input: flowerbed = [1,0,0,0,1], n = 1</p><p>output: True</p><blockquote>思路：自己想吧，不难的</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n   def canPlaceFlowers(self, flowerbed, n):\n       &#34;&#34;&#34;\n       :type flowerbed: List[int]\n       :type n: int\n       :rtype: bool\n       &#34;&#34;&#34;\n       flowerbed.append(0)\n       flowerbed.insert(0,0)\n       num = 0\n       res = 0\n       for i in range(len(flowerbed)):\n           if flowerbed[i] == 0:\n               num += 1\n           else :\n               num = 0\n           if num == 3:\n               res += 1\n               num = 1\n       return res&gt;=n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57820305", 
            "userName": "风轻袖影翻", 
            "userLink": "https://www.zhihu.com/people/e82eed3b967d9c35207f760811254284", 
            "upvote": 5, 
            "title": "leetcode刷题（二）：排序算法（归并排序，堆排序，桶排序）", 
            "content": "<p>今天，我们要来讲讲排序问题，这次讲的排序算法主要是归并排序，堆排序和桶排序。</p><h2><b>归并排序</b></h2><p>归并一词在中文的含义就是“合并，并入”的意思，在数据结构里面就是将两个或者两个以上的有序数组列表合并成一个的意思。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>归并排序就是利用归并思想实现排序的方法。它的原理就是假设有n个初始数据，即n个有序子序列，它们的长度都是1，将它们两两合并，得到了n/2个长度为2的有序子序 列。再两两合并，如此重复，知道得到一个长度为n的有序子序列为止，这种排序方法称之为2路归并排序。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>老规矩，上伪代码吧：</p><div class=\"highlight\"><pre><code class=\"language-text\">void MergeSort (int SR[ ] , int TR[ ], int s , int t )\n    {\n        int m ;\n        int TR2[MAXSIZE + 1]\n        if (s == t):\n            TR1[s] = SR[s]\n        else:\n        {\n            m = (m + s) / 2\n            MSort(SR , TR2 , s , m)\n            MSort(SR , TR2 , s + 1 , m)\n            Merge(TR2 , TR2 ,s ,m , t) \n        }\n    }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>简单讲一下，这段函数利用到了递归，假设初始子序列有10个关键字，第一个MSort就是将初始子序列下标0-4的关键字归并到TR2，第二个MSort就是将初始子序列下标5-9的关键字归并到TR2，可以认为将子序列分割成了两块，那么Merge函数就负责把这两块分割的子序列归并成一个完整的子序列。由于是递归，所以我们会一直分割分割直到分割成大小为1的子序列为止，然后再递归回来归并成一个完整有序的子序列。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再讲下Merge函数是怎么归并的，因为在归并前，因为是递归，两个子函数就已经是有序的了，我们假设到最后一种情况，两个有序的，长度为5的有序子序列进行归并，设第一个子序列下标为i，第二个下标为j。</p><div class=\"highlight\"><pre><code class=\"language-text\">    if  (SR[i] &lt; SR[j]):\n        TR[k] = SR[i]\n        i ++\n    else:\n        TR[k] = SR[j]\n        j ++</code></pre></div><p>差不多就是这样的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们来谈谈对比排序的复杂度吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先分析时间复杂度，一趟归并排序需要将SR[1]-SR[n]中长度为h的相邻元素两两归并，并将结果放在SR[1]-SR[n]中，所以需要将序列全部扫描一遍，时间复杂度为O(n)，再根据完全二叉树的深度可知，整个归并排序需要进行O(lgn)次，所以总的时间复杂度为O(nlgn)，这是归并排序最好最坏的平均性能。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>至于空间复杂度，由于再归并过程中需要和原子序列相同大小的存储空间存放归并结果并且需要深度为lgn的栈空间，所以空间复杂度为O(n+lgn)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那能不能优化呢？当然可以啊，试试能不能将递归换成迭代就行了，具体代码我就不打了（lan不解释！~！），因为非递归函数在空间上不需要(lgn)的栈空间，所以空间复杂度是O(n)，时间复杂度上也有所提升，可以说在归并算法中，我们应该尽量避免使用递归方法。<br/></p><p>下面做一道真题：<br/></p><p>Leetcode : 88. Merge Sorted Array (Easy)</p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</p><p>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p>示例:</p><p>输入:</p><p>nums1 = [1,2,3,0,0,0], m = 3</p><p>nums2 = [2,5,6],       n = 3</p><p>输出: [1,2,2,3,5,6]</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def merge(self, nums1: &#39;List[int]&#39;, m: &#39;int&#39;, nums2: &#39;List[int]&#39;, n: &#39;int&#39;) -&gt; &#39;None&#39;:\n        &#34;&#34;&#34;\n        Do not return anything, modify nums1 in-place instead.\n        &#34;&#34;&#34;\n        for x in nums2:\n            i = m-1\n            while i&gt;-1:\n                if nums1[i]&gt;x:\n                    nums1[i+1] = nums1[i]\n                    i-=1\n                else:\n                    nums1[i+1] = x\n                    break\n            if i == -1:\n                nums1[0] = x\n            m+=1</code></pre></div><h2><b>堆排序</b></h2><p>说到堆排序，让我们先想一个问题，如果在待排序的n个子序列中寻找一个最小的子序列，需要n-1次比较没错吧，但是我们本没有将这次排序的结果过程保存下来，那么在下次排序中，比如说找到第二小的子序列，是不是又需要走一遍？这样很浪费资源和时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么我们做到每次选择到最小记录的同时，比较结果并对其他记录做出相应的调整，这样我们的效率就大大提高了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而我们的堆排序，就是对相对简单的堆排序的一种改进，而且效果非常明显。<br/></p><p>首先我们要明白，堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右节点的值，称之为大顶堆；每个结点的值都小于或等于其左右节点的值，称之为小顶堆。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>堆排序就是利用堆进行排序的方法(假设使用大顶堆)：将待排序的序列组成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点了，我们将它移走(其实就是将他和数组的末尾元素交换)，然后将剩余的n-1个元素继续构成一个大顶堆，这样就会得到n个元素中的第二大的值，如此反复执行，我们就能得到一个有序序列了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>相信大家对堆排序的基本思想有一定的理解了，不过实现它还需要解决两个问题：</p><p>1.如何由一个无序序列构成一个堆？</p><p>2.在输出顶堆元素后，剩下的元素如何形成一个新的堆？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解决这两个问题嘛，老规矩，上代码！！</p><div class=\"highlight\"><pre><code class=\"language-text\">void HeapSort(SqList *L)\n    {\n        int i ;\n        for(i = L-&gt;length/2;i&gt;0;i--)\n            HeapAdjust(L,i,L-&gt;length);\n        for(i = L-&gt;length;i&gt;0;i--)\n            swap(L,l,i);\n            HeapAdjust(L,i,i-1);\n    }</code></pre></div><p>这里可以看到有两个循环，第一个循环是将现有的序列构成一个大顶堆，第二个循环就是将每个最大值的根节点和末尾元素交换，并且将剩余元素构成大顶堆。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>现在我们来看看关键元素HeapAdjust(堆调整)是怎样实现的吧！</p><div class=\"highlight\"><pre><code class=\"language-text\">void HeapAdjust(SqList *L ,int s , int m)\n    {\n        int temp , j;\n        temp = L-&gt;r[s];\n        for( j = 2*s , j &lt;= m ,j *= 2 )\n        {\n            if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1])\n                ++j;\n            if (temp &gt;= L-&gt;r[j])\n                break;\n            L-&gt;r[s] = L-&gt;r[j];\n            s = j;\n        }\n        L-&gt;r[s] = temp\n    }\n</code></pre></div><p>代码不长吧，相信大家都能看得懂，我这边就讲几个我认为的难点吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先j变量为什么从2*s开始呢？因为这是二叉树的性质，因为我们的二叉树都是完全二叉树，所以它的节点为s，那么它的左孩子一定是2s，右孩子一定是2*s+1。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我用简洁的话讲一下基本思想：先将结点的左右孩子进行比较，如果右孩子大，j++。将比较完后较大的数和双亲进行比较，如L-&gt;r[j] &gt; L-&gt;r[s]，将他们exchange即可。<br/></p><p>接下来我们讨论下堆排序的效率吧！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>它的消耗主要是在初始建堆和重新建堆的反复筛选上面。在构建堆以后，我们从二叉树最下层最右边的非终端节点开始，将它对其孩子进行比较和有必要的互换。所以对每个非终端节点来说，最多进行两次比较和互换操作，所以整个构建堆的时间复杂度为O(n)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在正式排序时，第 i 次取顶记录重建堆需要的时间是O(logi)(根据完全二叉树某个节点到根节点的距离为[logi]+1)。因此，重建堆的时间复杂度为O(nlogn)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以总体来说，堆排序的时间复杂度为O(nlogn)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是真题时间：</p><p>Leetocde : 215. Kth Largest Element in an Array (Medium)</p><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>示例 1:</p><p>输入: [3,2,1,5,6,4] 和 k = 2</p><p>输出: 5</p><p>示例 2:</p><p>输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</p><p>输出: 4</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def findKthLargest(self, nums, k):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        &#34;&#34;&#34;\n        length = len(nums)\n        # 构建大顶堆\n        for i in reversed(range(0, length / 2)):\n            self.adjustHeap(nums, i, length)\n        count = 0\n        for j in reversed(range(0,length)):\n            count += 1\n            if count == k:\n                return nums[0]\n            self.swap(nums,0,j)\n            length -= 1\n            self.adjustHeap(nums,0,length)\n            \n    def adjustHeap(self,nums,i,length):\n        while True:\n            k = i*2+1\n            if k &gt;= length:\n                return\n            if k + 1 &lt; length and nums[k+1] &gt; nums[k]:\n                k += 1\n            if nums[k] &gt; nums[i]:\n                self.swap(nums,i,k)\n                i = k\n            else:\n                return\n    def swap(self,nums,i,j):\n        temp = nums[i]\n        nums[i] = nums[j]\n        nums[j] = temp</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>桶排序</b></h2><p>到目前为止，我们已经介绍了归并排序和堆排序这两种比较排序算法，我们知道，在最坏情况下任何比较排序算法都要做O(nlgn)次比较，而归并排序和堆排序都是渐进最优的比较排序算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我要介绍是是线性时间排序，它是一种非比较排序，它最主要的优点就是稳定。下面我来讲几种典型的线性时间排序：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>计数排序：</b></p><p>计数排序的基本思想是对于每个输入元素，确定小于x的元素的个数，利用这一信息，我们可以直接把x放到它输出数组的位置上了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>基数排序：</b></p><p>基数排序是一种很古老的排序了，我们举个栗子就很明白了，比如我们要排序10个三位数，那我们可以先按最低有效位进行排序来解决卡片的排序问题。即先比较个位数，再比较十位数，最后比较百位数就行了！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上两种线性时间算法都比较简单，所以我就不展开讲了，接下来我要重点讲一下一种运用比较多是算法--桶排序算法<b>。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>桶排序是假设数据服从均匀分布，在平均情况下，它们的时间代价为O(n)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>桶排序是将[0，1]区间划分为n个大小相同的子区间，或者称之为桶，然后将n个输入分别输入到对应的桶中，然后我们对每个桶中的元素进行排序，遍历每个桶，按照次序，将桶中的元素输出即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再举一个通俗栗子，我们有100个元素，其中每个元素x都满足(1 &lt;= x &lt;= 1000)<b> ，</b>求其中个数最多的元素<b>，</b>解决这个问题那我们只需要准备1000个桶，每个桶的编号为1，2，3，4，……1000即可，然后遍历元素，将每个元素的个数最高者输出即可！~！  </p><p class=\"ztext-empty-paragraph\"><br/></p><p>真题时间到了！~！</p><p>Leetcode : 347. Top K Frequent Elements (Medium)</p><p>给定一个非空的整数数组，返回其中出现频率前 k 高的元素。</p><p>示例 1:</p><p>输入: nums = [1,1,1,2,2,3], k = 2</p><p>输出: [1,2]</p><p>示例 2:</p><p>输入: nums = [1], k = 1</p><p>输出: [1]</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def topKFrequent(self, nums, k):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        &#34;&#34;&#34;\n        a = {}\n        for i in nums:\n            if i in a.keys():\n                a[i] += 1\n            else:\n                a[i] = 1\n        b = sorted(a.items(),key=lambda x:x[1],reverse = True)\n        result = []\n        for i in range(k):\n            result.append(b[i][0])\n        return result</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>不多就这样了，希望本文能够帮到你！~！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后打个小广告，我的公众号，喜欢写点学习中的小心得，不介意可以关注下!~!</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-ad29f79a992b242f689fdf5227bc1545_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "归并排序", 
                    "tagLink": "https://api.zhihu.com/topics/20095856"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1084133116221870080"
}
