{
    "title": "数据之路", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/zhihuzl", 
        "https://www.zhihu.com/people/wei-nei-tuo-61", 
        "https://www.zhihu.com/people/kris-xu-51", 
        "https://www.zhihu.com/people/KorsLoveJ", 
        "https://www.zhihu.com/people/fun1-93", 
        "https://www.zhihu.com/people/wang-jun-55-23", 
        "https://www.zhihu.com/people/xin-guang-wen-77", 
        "https://www.zhihu.com/people/crazySnailDad", 
        "https://www.zhihu.com/people/geng-zhi-kui", 
        "https://www.zhihu.com/people/snowy-10-91", 
        "https://www.zhihu.com/people/san-zhang-10-36", 
        "https://www.zhihu.com/people/zheng-kai-92-3", 
        "https://www.zhihu.com/people/ben-pao-de-shu-shen", 
        "https://www.zhihu.com/people/smitch-tom", 
        "https://www.zhihu.com/people/luozhongbin", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/feiyuhit-59", 
        "https://www.zhihu.com/people/xie-luo-zhi-qiu-74-75", 
        "https://www.zhihu.com/people/zy.yuan", 
        "https://www.zhihu.com/people/yun-huan-61", 
        "https://www.zhihu.com/people/si-chen-23-31", 
        "https://www.zhihu.com/people/kan-shu-da-ke-shui", 
        "https://www.zhihu.com/people/chen-xi-75", 
        "https://www.zhihu.com/people/qqqq-liu", 
        "https://www.zhihu.com/people/xiao-zui-tian-ya", 
        "https://www.zhihu.com/people/tony-3-25-34", 
        "https://www.zhihu.com/people/yifdu", 
        "https://www.zhihu.com/people/fansz-7", 
        "https://www.zhihu.com/people/tomao2014-65", 
        "https://www.zhihu.com/people/liuhui-61", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/qi-zhi-zou-nuan", 
        "https://www.zhihu.com/people/ji-zhi-de-xiao-chen", 
        "https://www.zhihu.com/people/xliuphy", 
        "https://www.zhihu.com/people/firetaker", 
        "https://www.zhihu.com/people/das-universum", 
        "https://www.zhihu.com/people/herbie_j", 
        "https://www.zhihu.com/people/fengdu-46", 
        "https://www.zhihu.com/people/qi-xian-sen", 
        "https://www.zhihu.com/people/iyangdong", 
        "https://www.zhihu.com/people/xiao-zhi-112", 
        "https://www.zhihu.com/people/nofriend", 
        "https://www.zhihu.com/people/maple119", 
        "https://www.zhihu.com/people/wang-xing-xiao-99", 
        "https://www.zhihu.com/people/hu-yong-tao-67", 
        "https://www.zhihu.com/people/ka-hao-71", 
        "https://www.zhihu.com/people/zhao-ju-hui-49", 
        "https://www.zhihu.com/people/zhi-xing-he-yi-14-9", 
        "https://www.zhihu.com/people/jing-fang-49", 
        "https://www.zhihu.com/people/zou-xiao-zhu-520", 
        "https://www.zhihu.com/people/xiong-er-2-29", 
        "https://www.zhihu.com/people/da-xiang521", 
        "https://www.zhihu.com/people/madha", 
        "https://www.zhihu.com/people/hu-ying-heng", 
        "https://www.zhihu.com/people/yige-fang-yang-wa-23", 
        "https://www.zhihu.com/people/liu-qing-han-73", 
        "https://www.zhihu.com/people/liu-long-92-61", 
        "https://www.zhihu.com/people/yang-guang-48-37", 
        "https://www.zhihu.com/people/symboint", 
        "https://www.zhihu.com/people/zha-zha-43-33", 
        "https://www.zhihu.com/people/Ha-SiKi-47-94", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/zhang-heng-93-1", 
        "https://www.zhihu.com/people/cha-liang-zhi", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/cherish-9-70", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/xie-xuan-72-60", 
        "https://www.zhihu.com/people/flyerabc", 
        "https://www.zhihu.com/people/hong-yun-11-32", 
        "https://www.zhihu.com/people/moting-91", 
        "https://www.zhihu.com/people/xiao-ming-7-76-73", 
        "https://www.zhihu.com/people/kenan-sun", 
        "https://www.zhihu.com/people/zhang-xiao-nao-42", 
        "https://www.zhihu.com/people/yu-shuo-24", 
        "https://www.zhihu.com/people/li-chy", 
        "https://www.zhihu.com/people/skysun210", 
        "https://www.zhihu.com/people/chao-chao-22-27-32", 
        "https://www.zhihu.com/people/dalianjun", 
        "https://www.zhihu.com/people/zhu-ke-76", 
        "https://www.zhihu.com/people/xi-yang-chen-xue", 
        "https://www.zhihu.com/people/li-zhu-7-39", 
        "https://www.zhihu.com/people/zhanghl72", 
        "https://www.zhihu.com/people/wu-yu-17-53", 
        "https://www.zhihu.com/people/will-32-88-4", 
        "https://www.zhihu.com/people/wu-ren-ji-ni-44", 
        "https://www.zhihu.com/people/tg3h", 
        "https://www.zhihu.com/people/pang-xie-64-17", 
        "https://www.zhihu.com/people/pei-jie-zhang", 
        "https://www.zhihu.com/people/sol-55-81", 
        "https://www.zhihu.com/people/zhao-qi-hong-5", 
        "https://www.zhihu.com/people/denis-liu-66", 
        "https://www.zhihu.com/people/jong-36-35", 
        "https://www.zhihu.com/people/li-jie-30-68-88", 
        "https://www.zhihu.com/people/hao-hao-hao-42-31-87", 
        "https://www.zhihu.com/people/bai-ri-meng0__0", 
        "https://www.zhihu.com/people/a-da-38-85", 
        "https://www.zhihu.com/people/ding-zi-xuan-79", 
        "https://www.zhihu.com/people/gf-cug", 
        "https://www.zhihu.com/people/sha-tian-cai-72", 
        "https://www.zhihu.com/people/song-wen-30", 
        "https://www.zhihu.com/people/yu-kobe", 
        "https://www.zhihu.com/people/manson-30-75", 
        "https://www.zhihu.com/people/witwolf", 
        "https://www.zhihu.com/people/a-zhong-ahzhong", 
        "https://www.zhihu.com/people/dda2048", 
        "https://www.zhihu.com/people/ai-shi-deng-dai-shi-xi-shui-chang-liu-14", 
        "https://www.zhihu.com/people/lao-an-shu", 
        "https://www.zhihu.com/people/zhangchen2397", 
        "https://www.zhihu.com/people/mai-dou-74-32-79", 
        "https://www.zhihu.com/people/wang-hu-10", 
        "https://www.zhihu.com/people/xiao-jian-38-77", 
        "https://www.zhihu.com/people/wen-zhi-hong", 
        "https://www.zhihu.com/people/she-liang", 
        "https://www.zhihu.com/people/wang-lun-72", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/you-wei-98", 
        "https://www.zhihu.com/people/onescruise", 
        "https://www.zhihu.com/people/antinomy-67", 
        "https://www.zhihu.com/people/cuda", 
        "https://www.zhihu.com/people/caiknife", 
        "https://www.zhihu.com/people/fresh-57-4", 
        "https://www.zhihu.com/people/xi-dong-yang", 
        "https://www.zhihu.com/people/lei-zi-hai", 
        "https://www.zhihu.com/people/zhou-yun-wei-25", 
        "https://www.zhihu.com/people/iweisi", 
        "https://www.zhihu.com/people/xiaokey-76", 
        "https://www.zhihu.com/people/zhang-ke-12-73", 
        "https://www.zhihu.com/people/xi-can-hao-chi", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/su-duo-duo-43", 
        "https://www.zhihu.com/people/xiao-lin-57-47", 
        "https://www.zhihu.com/people/mynamezhulei", 
        "https://www.zhihu.com/people/kevin-hill", 
        "https://www.zhihu.com/people/ghostx", 
        "https://www.zhihu.com/people/xiao-lin-99", 
        "https://www.zhihu.com/people/peng-peng-9-27", 
        "https://www.zhihu.com/people/alexway", 
        "https://www.zhihu.com/people/thinkingMy", 
        "https://www.zhihu.com/people/xin-ping-63", 
        "https://www.zhihu.com/people/web-13", 
        "https://www.zhihu.com/people/xu-wu-16", 
        "https://www.zhihu.com/people/seven-cool", 
        "https://www.zhihu.com/people/zhang-liang-25-79", 
        "https://www.zhihu.com/people/ning-meng-xin-73-58", 
        "https://www.zhihu.com/people/lao-xian-sheng-38-19", 
        "https://www.zhihu.com/people/zhou-jie-4", 
        "https://www.zhihu.com/people/tracy-jenet", 
        "https://www.zhihu.com/people/michael-89-52"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/70424048", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 8, 
            "title": "由浅入深docker系列： (6)镜像分层", 
            "content": "<p>这篇文章我们简单聊聊 docker 的镜像分层。</p><h2><b>思考题</b></h2><p>在第四篇文章<a href=\"https://zhuanlan.zhihu.com/p/51836305\" class=\"internal\">容器与虚拟机</a>中，我们说到 docker 其实就是把可执行程序及其所有的依赖打包成镜像文件，然后调用宿主机内核接口运行容器。可以想象，像 ubuntu等基础镜像，体积必然不小。那么，思考以下几个问题：</p><ul><li>我们基于同一个镜像（ubuntu 18.4）启动了两个容器，会占用两倍磁盘空间吗？</li><li>我们在容器内修改或者新建了某个文件，要修改原镜像吗？</li><li>我们基于某镜像（ubuntu 18.04）新建一个镜像（myubuntu），需要将原镜像文件全部拷贝到新镜像中吗？</li></ul><p>首先，让我们尝试思考下，如果我们去做，该如何高效的解决这些问题？</p><ul><li>问题 1，只要将同一个镜像文件加载到内存不同位置就行了，没必要在磁盘上存储多份，可以节省大量存储空间。</li><li>问题 2，我们可以参考 Linux 内核管理内存的 <i>Copy-On-Write 策略，也即读时大家共用一份文件，如果需要修改再复制一份进行修改，而大部分文件是其实不会修改的，这样可以最大限度节省空间，提升性能。</i></li><li><i>问题 3，我们可以将镜像文件分为多个独立的层，然后新镜像文件只要引用基础镜像文件就可以了，这样可以节省大量空间。至于修改基础镜像文件的情况，参考问题 2 。</i></li></ul><p><i>如果你能想到以上思路，那么恭喜你，因为 Docker 就是这么做的，你已经具备为写docker 写一套文件系统的实力了（哈哈哈哈，不要飘，还有大量技术细节需要思考）。</i></p><hr/><h2>Docker的镜像分层</h2><p>接下来，我们来看看 Docker的镜像分层机制。</p><p>Docker镜像是分层构建的，Dockerfile 中每条指令都会新建一层。例如以下 Dockerfile:</p><div class=\"highlight\"><pre><code class=\"language-docker\"><span class=\"k\">FROM</span><span class=\"s\"> ubuntu:18.04</span><span class=\"err\">\n</span><span class=\"err\"></span>COPY . /app<span class=\"err\">\n</span><span class=\"err\"></span><span class=\"k\">RUN</span> make /app<span class=\"err\">\n</span><span class=\"err\"></span><span class=\"k\">CMD</span><span class=\"s\"> python /app/app.py</span></code></pre></div><p>以上四条指令会创建四层，分别对应基础镜像、复制文件、编译文件以及入口文件，每层只记录本层所做的更改，而这些层都是只读层。当你启动一个容器，Docker 会在最顶部添加读写层，你在容器内做的所有更改，如写日志、修改、删除文件等，都保存到了读写层内，一般称该层为容器层，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4b2318880b12c3220fa59a9d9992dc90_b.jpg\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic1.zhimg.com/v2-4b2318880b12c3220fa59a9d9992dc90_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"339\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic1.zhimg.com/v2-4b2318880b12c3220fa59a9d9992dc90_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4b2318880b12c3220fa59a9d9992dc90_b.jpg\"/><figcaption>docker layer</figcaption></figure><p>事实上，容器（container）和镜像（image）的最主要区别就是容器加上了顶层的读写层。所有对容器的修改都发生在此层，镜像并不会被修改，也即前面说的 COW(copy-on-write)技术。容器需要读取某个文件时，直接从底部只读层去读即可，而如果需要修改某文件，则将该文件拷贝到顶部读写层进行修改，只读层保持不变。</p><p>每个容器都有自己的读写层，因此多个容器可以使用同一个镜像，另外容器被删除时，其对应的读写层也会被删除（如果你希望多个容器共享或者持久化数据，可以使用 Docker volume）。</p><p>最后，执行命令 docker ps -s，可以看到最后有两列 size 和 virtual size。其中 size就是容器读写层占用的磁盘空间，而 virtual size 就是读写层加上对应只读层所占用的磁盘空间。如果两个容器是从同一个镜像创建，那么只读层就是 100%共享，即使不是从同一镜像创建，其镜像仍然可能共享部分只读层（如一个镜像是基于另一个创建）。因此，docker 实际占用的磁盘空间远远小于 virtual size 的总和。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b71caf2dbcc2fa95e8545cb7c97998ac_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb\" width=\"851\" data-original=\"https://pic1.zhimg.com/v2-b71caf2dbcc2fa95e8545cb7c97998ac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;851&#39; height=&#39;73&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"851\" data-original=\"https://pic1.zhimg.com/v2-b71caf2dbcc2fa95e8545cb7c97998ac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b71caf2dbcc2fa95e8545cb7c97998ac_b.png\"/></figure><p>以上就是 Docker 镜像分层的主要内容，至于这些层的交互、管理就需要存储驱动程序，也即联合文件系统（<b>UnionFS</b>）。Docker 可使用多种驱动，如目前已经合并入 Linux 内核、官方推荐的overlay， 曾在 Ubuntu、Debian等发行版中得到广泛使用的 AUFS，以及devicemapper、zfs等等，需要根据 Docker以及宿主机系统的版本，进行合适的选择。接下来以 AUFS 为例，简单介绍 UnionFS 的使用。</p><hr/><h2>AUFS</h2><p>AUFS 是一种 UnionFS，所谓 UnionFS 就是把不同物理位置的目录合并到同一个目录中。例如把 CD和硬盘 mount 到一起，就可以对 CD上的文件进行修改，再比如上面所讲 docker 的使用场景。</p><p>AUFS是Another UnionFS的首字母缩略字，2006年由冈岛顺治郎开发，是之前的 UnionFS 的完全重写，其稳定性和性能上确实好很多，但从第 2 版开始它代表advanced multi-layered unification filesystem。</p><p>这里插播一个悲情的小故事，AUFS被 Linus 拒绝合并到主线 Linux，其代码被批评为“稠密，不可读，无注释”。然后作者不断改进代码，不断提交，不断被 Linus 拒掉，最终放弃。而2014年，OverlayFS被合并到 Linux 内核 3.18版本，冈岛顺治郎再无希望。</p><p>言归正传，下面我们简单试验下 AUFS 的使用。（Ubuntu 18.04环境）</p><p>首先，创建两个文件夹代表只读层以及读写层。</p><div class=\"highlight\"><pre><code class=\"language-bash\">mkdir readLayer\n<span class=\"nb\">echo</span> <span class=\"s2\">&#34;original read file content&#34;</span> &gt;&gt; readLayer/readFile\nmkdir writeLayer\n<span class=\"nb\">echo</span> <span class=\"s2\">&#34;original write file content&#34;</span> &gt;&gt; writeLayer/writeFile</code></pre></div><p>然后，将两个文件夹进行联合挂载。命令中默认dirs后第一个文件夹为读写权限，之后的文件夹为只读权限。</p><div class=\"highlight\"><pre><code class=\"language-bash\">mkdir unionFs\nmount -t aufs -o <span class=\"nv\">dirs</span><span class=\"o\">=</span>./writeLayer:./readLayer none ./unionFs</code></pre></div><p>接下来，我们可以查看下 unionFs文件夹下的内容，发现已经有了readFile、writeFile两个文件，说明挂载成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d2a9e15d12f019dce0abcd3b230e1161_b.jpg\" data-size=\"normal\" data-rawwidth=\"348\" data-rawheight=\"136\" class=\"content_image\" width=\"348\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;348&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"348\" data-rawheight=\"136\" class=\"content_image lazy\" width=\"348\" data-actualsrc=\"https://pic2.zhimg.com/v2-d2a9e15d12f019dce0abcd3b230e1161_b.jpg\"/><figcaption>unionFs挂载成功</figcaption></figure><p>然后，我们再来测试下对文件的修改操作，我们分别修改读写层以及只读层的文件。</p><div class=\"highlight\"><pre><code class=\"language-text\">cd unionFs\necho &#34;edit writeable file&#34; &gt;&gt; writeFile\necho &#34;edit readonly file&#34; &gt;&gt; readFile</code></pre></div><p>根据我们之前的分析，针对读写层writeLayer的 writeFile 的修改，应该是直接在源文件上生效；而针对只读层readLayer的 readFile 的修改，应该是源文件保持不变，将文件拷贝到 writeLayer，然后再修改，我们来检查下。</p><p>首先，查看下只读层readLayer，文件内容并没有改变。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-595b01ba2fc44077f4f4c94d309cfdae_b.jpg\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"92\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"92\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic3.zhimg.com/v2-595b01ba2fc44077f4f4c94d309cfdae_b.jpg\"/><figcaption>readLayer</figcaption></figure><p>然后查看下读写层，可以看到新增的文件 readFile，且文件内容为修改后内容。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3e1b2efe3f1f5661f99799f8e54b0c16_b.jpg\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"167\" class=\"content_image\" width=\"373\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;373&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"167\" class=\"content_image lazy\" width=\"373\" data-actualsrc=\"https://pic3.zhimg.com/v2-3e1b2efe3f1f5661f99799f8e54b0c16_b.jpg\"/><figcaption>writeLayer</figcaption></figure><p>可以看到，我们成功模拟了只读层、读写层的联合使用，Docker的镜像分层也是此原理，只是实现更加复杂。</p><hr/><h2>参考资料</h2><p>以上即是 docker 镜像分层技术的简单介绍，通过这项技术，节省了大量的存储空间，也提升了容器的下载、构建、启动速度，推动了 Docker 技术的广泛使用。</p><p>如果你想更进一步了解相关细节，可以参考以下文章：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//coolshell.cn/articles/17061.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DOCKER基础技术：AUFS</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/storage/storagedriver/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">About storage drivers</a></p><hr/><h2>闲言</h2><p>前后拖了 7 个月，终于把六篇文章更完了，把自己学习时的困惑、自己的理解都尽量简洁的写出来，希望能帮大家更快的理解学习。在整理的过程中，我对 Docker 技术的认知也更加清晰完整，收获很大。</p><p>每写一篇文章都很痛苦，文采、技术都不好，纠结怎么能以更清晰的方式，说更多的技术点。每写完一篇也很充实，又前近了一步。看着专栏的读者一个个增加，很开心，也很有成就感，接下来还会更新，不保证频繁，但每一篇都会尽量写好。千里之行，始于足下，加油！</p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "aufs", 
                    "tagLink": "https://api.zhihu.com/topics/20090938"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67021108", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 6, 
            "title": "由浅入深docker系列： (5)资源隔离", 
            "content": "<p>上篇文章说了容器只是宿主机中的一个用户进程，和虚拟机完全不同，那么，为什么在容器内看不到宿主机进程，容器又是如何实现进程、文件、网络等资源的隔离呢？</p><p>这就牵涉到今天要介绍的linux内核的Namespace和Cgroups特性了。</p><h2>1.<b>Namespace</b></h2><p>Linux 内核从版本 2.4.19 开始陆续引入了 namespace 的概念。其目的是将某个特定的全局系统资源通过抽象方法使得namespace 中的进程看起来拥有它们自己的隔离的全局系统资源实例。Linux 内核中实现了六种 namespace，按照引入的先后顺序，列表如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e7ade4269dd31d43713fe4ccf02c6bef_b.jpg\" data-size=\"normal\" data-rawwidth=\"849\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb\" width=\"849\" data-original=\"https://pic4.zhimg.com/v2-e7ade4269dd31d43713fe4ccf02c6bef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;849&#39; height=&#39;521&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"849\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"849\" data-original=\"https://pic4.zhimg.com/v2-e7ade4269dd31d43713fe4ccf02c6bef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e7ade4269dd31d43713fe4ccf02c6bef_b.jpg\"/><figcaption>Linux Namespace</figcaption></figure><p>例如，容器进程启动时，只要启用了Mount Namespace，并将自己打包的文件系统挂载好，就可以实现每个容器仅看到自己的文件，实现文件资源的隔离。总之，Docker 守护进程创建容器实例时都启用了相应的namespace，使得容器中的进程都处于一种隔离的运行环境之中。</p><p><b>那么如何启用相应Namespace呢？</b></p><p>通过系统调用clone()来创建一个具有独立Namespace的进程是最常见的做法，它可以通过flags参数传入相应标志位来控制进程的各种状态，如以下示意代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">pid</span> <span class=\"o\">=</span> <span class=\"n\">clone</span><span class=\"p\">(</span><span class=\"n\">fun</span><span class=\"p\">,</span><span class=\"n\">stack</span><span class=\"p\">,</span><span class=\"n\">flags</span><span class=\"p\">,</span><span class=\"n\">clone_arg</span><span class=\"p\">);</span>\n<span class=\"p\">(</span><span class=\"nl\">flags</span><span class=\"p\">:</span><span class=\"n\">CLONE_NEWPID</span>  <span class=\"o\">|</span> <span class=\"n\">CLONE_NEWNS</span> <span class=\"o\">|</span>\n    <span class=\"n\">CLONE_NEWUSER</span> <span class=\"o\">|</span> <span class=\"n\">CLONE_NEWNUT</span> <span class=\"o\">|</span>\n    <span class=\"n\">CLONE_NEWIPC</span>  <span class=\"o\">|</span> <span class=\"n\">CLONE_NEWUTS</span> <span class=\"o\">|</span>\n    <span class=\"p\">...)</span>\n</code></pre></div><p><b>docker run中namespace相关参数</b></p><ul><li>--ipc string IPC namespace to use</li><li>--pid string PID namespace to use</li><li>--userns string User namespace to use</li><li>--uts string UTS namespace to use</li></ul><p>你可以在容器启动的时候，指定这些参数，从而强制容器运行在特定namespace之中。例如，你可以指定 --pid host，从而让容器进程使用宿主机进程空间，此时容器可以看到host上所有的进程（想象这样一个场景，你把常用的性能诊断工具都打包到一个镜像中，然后必要的时候在服务器上使用此镜像进行问题分析，此时加上该参数会很方便）。</p><h2>2.Cgroups</h2><p>通过Namespace，容器实现了资源的隔离，从而每个容器看起来都像是拥有自己独立的运行环境。注意，只是看起来。因为容器使用cpu、内存等并不受限制，假如某个容器占用这些资源过高，就可能会造成其它容器运行迟缓甚至异常，这就需要Cgroups了。</p><p>cgroups 的全称是control groups，是Linux内核提供的一种可以限制单个进程或者多个进程所使用资源的机制，可以对 cpu，内存等资源实现精细化的控制。</p><p>其典型的子系统如下：</p><ul><li>cpu 子系统，主要限制进程的 cpu 使用率。</li><li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li><li>cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li><li>memory 子系统，可以限制进程的 memory 使用量。</li><li>blkio 子系统，可以限制进程的块设备 io。</li><li>devices 子系统，可以控制进程能够访问某些设备。</li><li>net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li><li>freezer 子系统，可以挂起或者恢复 cgroups 中的进程。</li><li>ns 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li></ul><p>而Cgroups的实现也很有意思，它并不是一组系统调用，linux将其实现为了文件系统，这很符合Unix一切皆文件的哲学，因此我们可以直接查看。</p><p>例如，我在ubuntu18.04系统中，直接执行mount -t cgroup即可看到，系统已经自动在sys/fs/cgroup目录下挂载好了相应文件，每个文夹件代表了上面所讲的某种资源类型。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-89849f0978758acae24baec11564bd6b_b.jpg\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb\" width=\"834\" data-original=\"https://pic4.zhimg.com/v2-89849f0978758acae24baec11564bd6b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;834&#39; height=&#39;213&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"834\" data-original=\"https://pic4.zhimg.com/v2-89849f0978758acae24baec11564bd6b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-89849f0978758acae24baec11564bd6b_b.jpg\"/><figcaption>mount -t cgroup</figcaption></figure><p>我们可以查看sys/fs/cgroup/cpu文件夹下的文件，它代表对cpu资源的控制，其中tasks文件中是我们系统的进程pid，表示对这些进程进行资源控制，其它文件如cpu.cfs_quota_us表示cpu的利用率，默认值为-1，表示不做限制。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f6689c222d810f2829ef6fb16dfbfc7b_b.png\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"132\" class=\"origin_image zh-lightbox-thumb\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-f6689c222d810f2829ef6fb16dfbfc7b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;801&#39; height=&#39;132&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"801\" data-rawheight=\"132\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"801\" data-original=\"https://pic4.zhimg.com/v2-f6689c222d810f2829ef6fb16dfbfc7b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f6689c222d810f2829ef6fb16dfbfc7b_b.png\"/><figcaption>Cgroup/cpu</figcaption></figure><p><b>如何使用Cgroups呢</b></p><p>很简单，我们可以直接在相应资源控制组目录下创建文件夹，系统会自动创建需要的文件，例如，在上述cpu目录下创建hello目录，然后看到相应文件已自动创建。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-70d93e3b7f63c72b5a07d6ea5e28d9ce_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic3.zhimg.com/v2-70d93e3b7f63c72b5a07d6ea5e28d9ce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic3.zhimg.com/v2-70d93e3b7f63c72b5a07d6ea5e28d9ce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-70d93e3b7f63c72b5a07d6ea5e28d9ce_b.jpg\"/></figure><p>然后我们写一个死循环，代码如下，然后编译执行</p><div class=\"highlight\"><pre><code class=\"language-text\">//deadLoop.c\nint main(void)\n{\n    int i = 0;\n    for(;;) i++;\n    return 0;\n}\n//编译 gcc deadLoop.c -o deadLoop\n//执行 ./deadLoop</code></pre></div><p>执行top命令，很容易发现，cpu使用率达到了100%左右，怎么办呢？</p><p>进入刚才创建的hello目录，将cpu.cfs_quota_us的值改为20000（此参数表示1秒周期内进程使用cpu的最大微秒数，因此20000表示20%），然后将deadLoop进程的Pid写入tasks文件中去，再次执行top命令，你将看到cpu使用率只有20%了！</p><p>命令如下：</p><div class=\"highlight\"><pre><code class=\"language-powershell\"><span class=\"n\">top</span>\n<span class=\"n\">cd</span> <span class=\"p\">/</span><span class=\"n\">sys</span><span class=\"p\">/</span><span class=\"n\">fs</span><span class=\"p\">/</span><span class=\"n\">cgroup</span><span class=\"p\">/</span><span class=\"n\">cpu</span><span class=\"p\">/</span><span class=\"n\">hello</span>\n<span class=\"n\">echo</span> <span class=\"n\">20000</span> <span class=\"p\">&gt;</span> <span class=\"n\">cpu</span><span class=\"p\">.</span><span class=\"n\">cfs_quota_us</span>\n<span class=\"n\">ps</span> <span class=\"n\">aux</span> <span class=\"p\">|</span> <span class=\"n\">grep</span> <span class=\"n\">deadLoop</span>\n<span class=\"n\">echo</span> <span class=\"n\">pid</span> <span class=\"p\">&gt;</span> <span class=\"n\">tasks</span>\n<span class=\"n\">top</span></code></pre></div><p>很直观吧，其它资源的控制也与此类似。</p><p><b>docker对Cgroups的使用</b></p><p>默认情况下，docker 启动一个容器后，就会在 /sys/fs/cgroup 目录下的各个资源目录下生成以容器 ID 为名字的目录，在容器被 stopped 后，该目录被删除。那么，对容器资源进行控制的方式，就同上边的例子一样，显而易见了。</p><p>至于docker run提供的Cgroups相关参数，就请你自己查阅文档吧。</p><h2>3.其它</h2><p>本篇简单介绍了下Linux内核的Namespace和Cgroups功能，从而理解容器中资源的隔离和控制技术的实现原理，主要是帮助你建立基本的概念，而关于这些功能的使用细节以及内核中的实现原理，还很复杂，想了解的话还需要你投入大量精力。</p><p>另外，我们也可以看到，docker并不是全新的技术，它是对很多已有技术的封装、抽象，只要深入的学习下去，你就会看到很多熟悉的东西，你对容器的理解也会越来越深刻，加油！</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>参考资料：</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/docker-kernel-knowledge-namespace-resource-isolation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker背后的内核知识——Namespace资源隔离 - InfoQ</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/sammyliu/p/5886833.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">理解Docker（4）：Docker 容器使用 cgroups 限制资源使用</a></p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60556069", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 3, 
            "title": "后端开发：如何写出可靠的接口", 
            "content": "<p>毕业进入现在的公司已近一年，完整参与了部门新项目两期的开发上线过程，作为一名后端开发，觉得最痛苦的是上线前和上线后的改 bug 阶段，面对各种突如其来、莫名其妙的bug，头昏脑涨、手忙脚乱、越改越懵，经常导致实验式改 bug、改一个 bug 又出现俩 bug 的之类的惨剧，我就忍不住想，为什么每次上线前都会有这么多bug呢？</p><p>前几天还读到一篇豆瓣文章，没有总结的就不是经验，只是经历。程序员也不能业务来了就写代码，有bug了就改bug，这样技术很难提升，也就难怪每次都会有那么多bug了。有的开发人员工作多年，接口还是时不时500，前期忙着写代码，后期忙着改bug，心累。</p><p>我从一期熟悉业务、框架，写一写边缘接口，到二期负责一个小模块，尝试数据库、程序的设计，中间磕磕绊绊，昨天也顺利上线，模模糊糊也感觉到了一些经验，于是努力总结下，虽然简单，也许能给自己和读者一些启发。（本文只针对初级水平，简单的bug，不涉及高并发、海量数据等复杂问题）</p><hr/><h3><b>一. 接口为什么出bug？</b></h3><p>辛辛苦苦写的接口，自己测的时候好好的，怎么别人一调就出错了呢？？（此处应有表情包，请自行脑补）当然可能是运行环境的问题，不过程序统一部署在服务器上，这一般是架构师或者运维负责的工作，至于编程语言或者操作系统的问题，也通通不在今天考虑范围内，今天，我们只考虑自己写出的bug。</p><p>事实上，运行中的程序所涉及的，无非三样：资源（cpu、内存等）+ 算法（程序运行流程）+ 数据（用户输入、数据库、第三方接口等）。通常我们认为资源是可靠的，出现bug主要是由于算法的不可靠或者数据的异常。</p><p>更进一步，机器严格按照0/1执行指令，算法上一次执行正常，为什么这一次会失败？本质上还是因为数据变了，而算法没能覆盖此情况，因此，要想保证接口的稳定，主要从两方面考虑：保证数据的可靠性、算法的健壮性，而算法的健壮性也就是考虑到数据的各种情况，两者密不可分。</p><hr/><h3><b>二. 如何写出bug更少的接口?</b></h3><p>如前分析，数据的变化是接口bug最常见、本质的原因。而其中，用户输入又是数据变化最主要的原因。而程序必然要有用户输入，否则毫无意义。</p><p>编程界有句名言：永远不要相信用户输入。你永远不知道，用户会在一个期待姓名的输入框里都输入些什么。不要因为前端做了过滤你就放心，一方面是用户可能会使用爬虫等手段直接访问你的接口，另一方面，前端也是你的用户，沟通也存在误差，前端可能会使用错误的方式调用你的接口，而这种错误可能会更加隐蔽。</p><p><b>第一条建议：严格校验用户的输入，包括格式、内容。</b></p><p>我知道很多人都懒得去逐条检验用户输入，觉得只要功能正常就ok了，但是，这经常会导致后期改bug时投入更多的经历。经常测试提了bug，你查来查去，发现是前端传错了参数，或者没有合理限制用户输入，当然你可以很刚，让前端去改，但这个过程已经浪费了你大量的时间精力，还不如一开始自己做好检验，返回合适的错误消息，会为你后期节省大量的精力。</p><p>对于PHP等动态语言，尤其如此，例如我们使用Laravel框架，我会在所有接口入口处，首先使用$request-&gt;validate()检验所有输入数据的格式，如有必要，还会写代码进一步校验输入内容，比如时间范围、请求数据是否有效等等。</p><p><b>第二条建议：考虑用户的骚操作，重复提交、延时提交</b></p><p>重复提交应该是大多数后端都能想到的情况，也就是接口的幂等性，有些资源只能操作一次，必须进行校验，其实不仅是重复提交，还包括同一事件被两人重复处理的情况。</p><p>而对于延时提交，其实是测试给我提bug后我才意识到的问题模式。例如我们通过get接口返回给用户某种资源，用户可以通过post接口回传资源id并提交修改，由于是自己的get接口返回的，我们可能想着只验证id合法就行了，看似形成严格闭环，但如果用户停留在此页面延时提交，则可能在此期间资源过期，或者资源已被他人修改，而改用户也成功修改的bug。其实进一步思考，你会发现，这跟高并发情景下的资源失效有异曲同工之处。</p><p><b>第三条建议：检验数据库、第三方接口的返回数据</b></p><p>除了用户输入，常见的数据来源还有数据库、第三方接口。相对而言，这些数据接口会可靠的多，而且内容格式也更规范。不过为了接口的稳定性，最好也做一些检验。如常见的数据为空的情况，就要及时中止程序执行并抛出合适的信息。</p><p>对了，对于数据库，我还遇到过bug，就是主从延迟导致的数据更新问题，由于经验尚浅，这类问题不很擅长，就不再写。</p><p><b>第四条建议：程序算法尽可能覆盖异常情况</b></p><p>这条实际上是对前三条的补充，有些不合法的用户输入你可以直接中止程序并返回错误信息，但有些情况可能需要程序继续运行，进行特殊处理，这些情况你在程序设计之初应该尽量考虑周全，后期bug会少很多，也更容易维护。</p><hr/><h3>三. 如何写出更高效的接口</h3><p>最后，再写一点点关于关于接口效率、代码质量的思考。</p><ol><li><b>影响接口效率的主要是数据库操作</b></li></ol><p>以我有限的经历来看，接口耗时长基本都是因为数据库操作不合理，我们大多数的业务代码并不会有性能问题。我见过不少在for循环里查询数据库的代码，一定要避免，我们可以先一次性取出所有数据，然后逐个去处理。例如我们会在框架层记录所有数据库操作，调试接口时即可看到所有数据库操作以及相应耗时，该合并的查询要合并，该优化的耗时查询相应去优化。</p><p><b>2. 合理使用Exception，日志</b></p><p>这条主要针对php语言，由于历史原因，我看到不少代码靠return中止程序并传递错误信息，这样在代码复杂、调用层次深了以后极难维护，远没有Exception机制直观方便。还有，重要信息一定要写日志，便于后期发现问题及调试，也可用来自证清白。</p><p><b>3. 代码要合理划分、抽象</b></p><p>不要复制粘贴代码，重复的功能要独立出来；设计时要合理考虑需求变更、扩展；写小而专注的函数，不要把复杂功能一坨实现；这样写的代码才易于修改、测试以及扩展。这块我做的也不好，上线后看自己的代码都是一坨一坨，难以维护，接下来还要多思考，多实践。</p><hr/><h3>四. 结束语</h3><p>祝大家写的代码都没有bug！</p>", 
            "topic": [
                {
                    "tag": "代码质量", 
                    "tagLink": "https://api.zhihu.com/topics/19585332"
                }, 
                {
                    "tag": "后端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19686604"
                }
            ], 
            "comments": [
                {
                    "userName": "Kune", 
                    "userLink": "https://www.zhihu.com/people/92167d798ad9d3b1c8a970c8cb8aff17", 
                    "content": "[赞同]对于初级程序员来说真的很有用", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "z展新", 
                    "userLink": "https://www.zhihu.com/people/5ac88a1beaebcdafc1bc0bf7702d3a22", 
                    "content": "很感谢作者写的关于Docker的系列文章，简单易懂让我快速入门。看到这篇文章，我知道每一位用心努力成长的程序员，都会思考软件开发容易复杂度爆表的问题，其实很多问题都已经被业界解决，并且有更好的方法实践。只是觉大多数人并不知道有更好的技术、更好的工具、更好的编程语言、更好的理念，只能随波逐流。作为回馈，我想给您安利一下Clojure这门语言，请一定要去看完所有Rich Hickey（Clojure作者）的演讲，同时学习函数式编程，了解Clojure的各种核心/周边函数库，了解Datomic数据库，相信你一定会被颠覆的。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "加油！", 
                            "likes": 0, 
                            "replyToAuthor": "z展新"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51836305", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 9, 
            "title": "由浅入深docker系列：(4)容器与虚拟机", 
            "content": "<p>如果你认真对着前三篇教程做了练习，那么想必现在对 docker 的使用已经比较熟悉，对于不太复杂的需求也能做到胸有成竹，但是，你还是不敢声称熟悉 docker，因为你完全不了解 docker 的内部原理，对于你它完全是个孤立的黑匣子。</p><p>那么接下来，我将带领你去认识它，让它不再陌生。</p><hr/><p><b><i>一：Ubuntu 18.04和 16.04的内核版本一样么</i></b></p><p>首先，容器和虚拟机的区别是什么呢？你一定看到过很多答案，说容器更轻量，更快，虚拟机要虚拟化硬件等等，还有这张经典图，但是可能你并不是很理解，至少我当时看的一头雾水。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-457fcb52f6e887b6df55477202a5d559_b.png\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-457fcb52f6e887b6df55477202a5d559_b.png\"/><figcaption>虚拟机、容器架构</figcaption></figure><p>我们知道，ubuntu 16.04和 ubuntu18.04的内核版本是不一样的，ubuntu16.04的虚拟机和 ubuntu18.04的虚拟机的内核版本也必定不一致。那么，如果是 ubuntu16.04和 ubuntu18.04的 docker 环境呢？</p><p>我们来试一下：查看linux 系统内核信息可以使用命令 uname -a，剩下的你应该知道怎么做了。不知道的话，再去看一下前几篇。</p><p>这是我在 macos上的执行结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f43fe20b01f268e0573e1b80e073f3af_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-f43fe20b01f268e0573e1b80e073f3af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;58&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-f43fe20b01f268e0573e1b80e073f3af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f43fe20b01f268e0573e1b80e073f3af_b.png\"/></figure><p>我们发现，debian 和 ubuntu 的内核版本竟然是一样的！如果你有兴趣，还可以试验 debian或者其他系统，你会发现他们都是一样的！</p><p><b><i>二：内核 VS 用户程序</i></b></p><p>我们知道，操作系统分为内核和用户程序，进而存在内核空间（kernel space）和用户空间（user Space）。简单说，Kernel Space 是 Linux 内核的运行空间，User space 是用户程序的运行空间。Kernel space 可以执行任意命令，调用系统的一切资源；User space 只能执行简单的运算，不能直接调用系统资源，必须通过系统接口（又称 system call），才能向内核发出指令。</p><p>而容器事实上就是一个用户程序，它同样通过调用系统接口实现功能。对于 docker 而言，如果宿主机是 linux，它就直接使用宿主机内核，如果宿主机是 macos 或者 windows，docker服务会提供一个公用的 linux内核供各容器调用，因此你会看到 ubuntu18.04和16.04的内核版本是一致的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b1b2db82026a3056afb1dc08e7f0d0e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-b1b2db82026a3056afb1dc08e7f0d0e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-b1b2db82026a3056afb1dc08e7f0d0e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b1b2db82026a3056afb1dc08e7f0d0e1_b.jpg\"/></figure><p>而容器镜像里的文件，包括了可执行程序以及它的依赖，例如 ubuntu18.04镜像，就是把18.04的所有可执行程序以及它们的依赖进行打包，容器启动的时候文件被加载进内存，事实上就对应着用户空间，而这些程序的运行，还需要调用系统接口。</p><p>你一定会说，那现在容器依赖内核接口，如果内核接口变了，容器不就无法正常运行了？</p><p>事实上，内核接口的变更是比较慎重、缓慢的，在短时间内，我们可以预期容器能够正常运行。但是，随着宿主系统尤其是内核的升级，我们并不能保证 docker 容器永远可以正常运行。</p><p><b><i>三：容器与虚拟机</i></b></p><p>现在，你应该明白了为什么ubuntu16.04和18.04的 docker 容器内核版本一样，那么，容器和虚拟机的区别也就明显了，它们虚拟化的层次并不一样。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-692fc453a0d7cf653e19420ff4ad0d56_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb\" width=\"1060\" data-original=\"https://pic3.zhimg.com/v2-692fc453a0d7cf653e19420ff4ad0d56_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1060&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1060\" data-original=\"https://pic3.zhimg.com/v2-692fc453a0d7cf653e19420ff4ad0d56_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-692fc453a0d7cf653e19420ff4ad0d56_b.jpg\"/></figure><p>虚拟机完整虚拟了内核和用户空间，而 docker 仅仅虚拟了用户空间，那么 docker 必然更轻量、更快。</p><p>再回头看第一张图，也就清晰了。虚拟机建立在虚拟硬件层之上，每个虚拟机都有独立的内核和用户程序以及依赖库；而 docker 容器建立在宿主机内核和 docker 服务之上，使用共同的内核，每个容器仅仅是用户程序、依赖库不同；再更进一步，普通的程序都使用共同的依赖库，只有程序文件不同。</p><p>纵观全局，从普通的应用程序，到docker 容器，再到虚拟机技术，无非是对磁盘空间、系统资源和隔离性、安全性的权衡取舍而已。至于 docker 的自动化，对比虚拟机似乎并不公平，于 Vagrant 这样的工具相比倒是更加合适。</p><p><b><i>四：其它</i></b></p><p>再解释下之前的问题，既然 docker容器仅仅是一个进程，与虚拟机并不一样，也就不适合以虚拟机的方式使用 docker。 docker 容器的创建、关闭代价很小，我们应该使用独立的docker 容器执行独立的任务，就像之前 mysql、app、nginx各自起独立的 docker 容器，这样更方便容器的复用及更新，也方便对系统资源进行管理。</p><p>既然 docker 容器只是一个进程，为什么我们使用的时候感觉和虚拟机很像？在容器里使用 ps 看不到其它进程，看不到其它文件等等。这就涉及到了 linux 内核提供的Namespace和CGroups机制，它为进程提供了文件、cpu、内存、网络等资源的隔离和控制，是虚拟化技术的基础，也即是我们第五篇要介绍的内容，敬请期待。</p><p>参考资料：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.v2ex.com/t/267641\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">什么是 docker</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//rhelblog.redhat.com/2015/07/29/architecting-containers-part-1-user-space-vs-kernel-space/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Architecting Containers</a></p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }
            ], 
            "comments": [
                {
                    "userName": "Wang Fungtion", 
                    "userLink": "https://www.zhihu.com/people/7b691abce9756f404fed26e7635ba209", 
                    "content": "<p>如果不牵涉内核操作，把docker当作虚拟机使用会出现什么问题呢？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "你硬要用当然也可以，只是丧失了隔离性、易维护等等这些优点而已", 
                            "likes": 0, 
                            "replyToAuthor": "Wang Fungtion"
                        }
                    ]
                }, 
                {
                    "userName": "z展新", 
                    "userLink": "https://www.zhihu.com/people/5ac88a1beaebcdafc1bc0bf7702d3a22", 
                    "content": "请问Docker是否能完全替代vagrant？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "z展新", 
                            "userLink": "https://www.zhihu.com/people/5ac88a1beaebcdafc1bc0bf7702d3a22", 
                            "content": "只针对开发环境的搭建", 
                            "likes": 0, 
                            "replyToAuthor": "z展新"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51055141", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 38, 
            "title": "由浅入深docker系列： (3)docker-compose", 
            "content": "<p>在第二篇文章中，我们学会了使用 dockerfile 构建 docker 镜像，看起来已经能够满足我们的日常需求了。无论需要什么环境，在 dockerfile 里逐步构建，然后 build、run，就 ok 了，也满足了我们docker 隔离性、快速部署的要求，那为什么还会有这一节？</p><p>来看一个网站开发最常见的场景：我们要有数据库，网站应用，nginx，互相配合才是完整的环境。是的，我们完全可以以 ubuntu 为基础镜像，把这些一股脑全装进去，然后运行。但是这样有很多缺点，比如我们每次都要重新装 mysql 而不是直接利用 mysql 官方的基础镜像，升级维护不方便；如果我们的应用要扩展也很难，因为每个应用都连接的自己内部的数据库，无法共享数据；事实上，这种方式是典型的虚拟机的使用方式，不是 docker 的正确打开方式。</p><p>docker 是轻量化的应用程序，docker 官方推荐每个 docker 容器中只运行一个进程（下篇文章你将明白这是为什么），那么就是说，我们需要分别为我们的应用、数据库、nginx 创建单独的 docker 容器，然后分别启动它。想象一下，构建好 docker 之后，每次启动我们的网站，都要至少 docker run 三次，是不是很繁琐？而且此时这几个 docker 是分散独立的，很不方便管理。既然这几个 docker 都是为了同一个网站服务，是不是应该把它们放到一起？这就引出了 docker-compose 项目。</p><hr/><p>docker-compose是 docker 官方的开源项目，使用 python 编写，实现上调用了 Docker 服务的 API 进行容器管理。其官方定义为为 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）），其实就是上面所讲的功能。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>一：安装</i></b></p><p>默认情况下，windows 和 mac 下的 docker 已经自带了 docker-compose 工具，可以使用 `docker-compose -v` 命令查看。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c3620197e28c6fe604aebaaa723eba45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"750\" data-original=\"https://pic2.zhimg.com/v2-c3620197e28c6fe604aebaaa723eba45_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;750&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"750\" data-original=\"https://pic2.zhimg.com/v2-c3620197e28c6fe604aebaaa723eba45_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c3620197e28c6fe604aebaaa723eba45_b.jpg\"/></figure><p>对于 linux 系统，需要自己手动安装，可以直接下载二进制文件安装，参考<a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/compose/install/%23install-compose\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方文档</a>，更酷的是，可以直接使用 pip 安装，甚至可以使用 docker-compose 容器（比较复杂，不推荐~）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>二：简介</i></b></p><p>类似 docker 的Dockerfile文件，docker-compose使用 YAML 文件对容器进行管理。</p><p>对于 docker-compose 有两个基本的概念：</p><ul><li>服务(service)：一个应用容器，即 docker 容器，比如之前所说的mysql 容器、nginx 容器</li><li>项目(project)：由一组关联的应用容器组成的一个完整业务单元，比如上面所讲的由 mysql、web app、nginx 容器组成的网站。docker-compose 面向项目进行管理。</li></ul><p>再简单说下 YAML 文件格式。</p><p>1.大小写敏感，缩进表示表示层级关系</p><p>2.缩进空格数不重要，相同层级左侧对齐即可。（不允许使用 tab 缩进！）</p><p>3.由冒号分隔的键值对表示对象；一组连词线开头的行，构成一个数组；字符串默认不使用引号</p><p>这些基本够我们使用了，详细的格式说明可参考这篇<a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/07/yaml.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">YAML 语言教程-阮一峰</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>三：使用</i></b></p><p>接下来我们使用 docker-compose 构建一个php 网站项目，并逐步讲解其使用。</p><ol><li>我们需要一个网站项目，这里以 summerblue 的<a href=\"https://link.zhihu.com/?target=https%3A//github.com/summerblue/larabbs\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">larabbs论坛系统</a>为例，这个项目使用了 mysql、redis，我们可以验证搭建是否成功。从远程仓库把其克隆到本地，然后开始我们今天的工作。</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f82b37eaf60ce3ec0cc77ef61a43b490_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1185\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb\" width=\"1185\" data-original=\"https://pic1.zhimg.com/v2-f82b37eaf60ce3ec0cc77ef61a43b490_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1185&#39; height=&#39;77&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1185\" data-rawheight=\"77\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1185\" data-original=\"https://pic1.zhimg.com/v2-f82b37eaf60ce3ec0cc77ef61a43b490_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f82b37eaf60ce3ec0cc77ef61a43b490_b.jpg\"/></figure><p>2. 在项目文件夹下创建 docker-compose.yml文件。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b10c87ce180a79660e3e9e76fdc5faaf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"413\" data-rawheight=\"18\" class=\"content_image\" width=\"413\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;413&#39; height=&#39;18&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"413\" data-rawheight=\"18\" class=\"content_image lazy\" width=\"413\" data-actualsrc=\"https://pic4.zhimg.com/v2-b10c87ce180a79660e3e9e76fdc5faaf_b.jpg\"/></figure><p>3. 先在 docker-compose.yml 文件里添加如下代码，构建我们的 php 应用。</p><div class=\"highlight\"><pre><code class=\"language-yaml\">version<span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s1\">&#39;2&#39;</span><span class=\"w\">\n</span><span class=\"w\"></span>services<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"c\"># our web application</span><span class=\"w\">\n</span><span class=\"w\">    </span>app<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">        </span>build<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>context<span class=\"p\">:</span><span class=\"w\"> </span>./<span class=\"w\">\n</span><span class=\"w\">            </span>dockerfile<span class=\"p\">:</span><span class=\"w\"> </span>app.dockerfile<span class=\"w\">\n</span><span class=\"w\">        </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span>./<span class=\"p\">:</span>/var/www<span class=\"w\">\n</span><span class=\"w\">        </span>working_dir<span class=\"p\">:</span><span class=\"w\"> </span>/var/www<span class=\"w\">\n</span><span class=\"w\">        </span>environment<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span>DB_HOST=database<span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span>REDIS_HOST=redis</code></pre></div><p>下面解释下我们的代码。</p><ul><li>version： 表示我们的compose文件的版本，目前有1，2，3，每个版本语法不尽相同，这里以版本2为例，具体可参考 <a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/compose/compose-file/compose-versioning/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">docker-compose 文档</a>。</li><li>services： 即我们要开始定义服务，每个docker容器为一个服务。</li><li>app： 这里我们定义了第一个服务，app 为其名字</li><li>build： 指定该容器构建参数</li><li>volumes： 与 dockerfile 中 -v 参数相似，这里是将当前文件夹挂载到容器的/var/www 目录下</li><li>working_dir： 指定容器工作目录</li><li>environment： 设置环境变量。由于 laravel 框架在环境变量已有值的情况下不会加载.env 配置，这里 DB_HOST和 REDIS_HOST 就是.env 文件中配置数据库连接的参数，我们设置它以便连接docker 的数据库，database 和 redis 是接下来定义的服务名称。</li></ul><p>这是 app.dockerfile 文件的内容，之前都讲过，不再细说。</p><div class=\"highlight\"><pre><code class=\"language-docker\"><span class=\"k\">FROM</span><span class=\"s\"> php:7.1.22-fpm</span><span class=\"err\">\n</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"c\"># 安装必要的 php 依赖包</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"k\">RUN</span> apt-get update <span class=\"se\">\\\n</span><span class=\"se\"></span>    <span class=\"o\">&amp;&amp;</span> apt-get install -qq git curl libmcrypt-dev libjpeg-dev libpng-dev libfreetype6-dev libbz2-dev <span class=\"se\">\\\n</span><span class=\"se\"></span>    <span class=\"o\">&amp;&amp;</span> apt-get clean<span class=\"err\">\n</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"c\"># 安装 php 扩展</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"k\">RUN</span> docker-php-ext-install pdo pdo_mysql mcrypt zip gd</code></pre></div><p>4. 创建一个 composer 服务以安装 composer 依赖，docker-compose.yml 文件添加以下内容</p><div class=\"highlight\"><pre><code class=\"language-yaml\"><span class=\"c\"># install dependencies</span><span class=\"w\">\n</span><span class=\"w\">    </span>composer<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">        </span>image<span class=\"p\">:</span><span class=\"w\"> </span>prooph/composer<span class=\"p\">:</span><span class=\"m\">7.1</span><span class=\"w\">\n</span><span class=\"w\">        </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span>./<span class=\"p\">:</span>/var/www<span class=\"w\">\n</span><span class=\"w\">        </span>working_dir<span class=\"p\">:</span><span class=\"w\"> </span>/var/www<span class=\"w\">\n</span><span class=\"w\">        </span>command<span class=\"p\">:</span><span class=\"w\"> </span>install</code></pre></div><p>注意这里同样将当前文件夹挂载到了容器中，因此对文件所做的更改都直接作用于本地文件，而我们的 app 容器也挂载了当前文件夹，这里安装的包文件都能生效。</p><p>5. 创建一个 nginx 服务，docker-compose.yml 文件添加以下内容</p><div class=\"highlight\"><pre><code class=\"language-yaml\"><span class=\"c\"># web server</span><span class=\"w\">\n</span><span class=\"w\">    </span>nginx<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">        </span>build<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>context<span class=\"p\">:</span><span class=\"w\"> </span>./<span class=\"w\">\n</span><span class=\"w\">            </span>dockerfile<span class=\"p\">:</span><span class=\"w\"> </span>nginx.dockerfile<span class=\"w\">\n</span><span class=\"w\">        </span>volumes<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span>./public<span class=\"p\">:</span>/var/www/public<span class=\"w\">\n</span><span class=\"w\">        </span>ports<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">            </span>-<span class=\"w\"> </span><span class=\"m\">80</span><span class=\"p\">:</span><span class=\"m\">80</span></code></pre></div><ul><li>这里将 public 文件夹挂载到了容器中， nginx 直接返回了静态文件，否则你将看到网站格式乱了，因为获取不到 css 等文件，如果是单纯后端可以不挂载此文件夹</li><li>ports 将nginx容器的80端口映射到本机80端口</li></ul><p>nginx.dockerfile 文件内容，为了添加默认配置文件</p><div class=\"highlight\"><pre><code class=\"language-docker\"><span class=\"k\">FROM</span><span class=\"s\"> nginx:1.10</span><span class=\"err\">\n</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"k\">ADD</span><span class=\"s\"> vhost.conf /etc/nginx/conf.d/default.conf</span></code></pre></div><p>vhost.conf 文件，nginx 配置文件</p><div class=\"highlight\"><pre><code class=\"language-nginx\"><span class=\"k\">server</span> <span class=\"p\">{</span>\n    <span class=\"kn\">listen</span> <span class=\"mi\">80</span><span class=\"p\">;</span>\n    <span class=\"kn\">server_name</span> <span class=\"s\">www.larabbs.test</span>\n    <span class=\"s\">index</span> <span class=\"s\">index.php</span> <span class=\"s\">index.html</span><span class=\"p\">;</span>\n    <span class=\"kn\">root</span> <span class=\"s\">/var/www/public</span><span class=\"p\">;</span>\n\n    <span class=\"kn\">error_log</span> <span class=\"s\">/var/log/nginx/error.log</span> <span class=\"s\">notice</span><span class=\"p\">;</span>\n    <span class=\"kn\">access_log</span> <span class=\"s\">/var/log/nginx/access.log</span> <span class=\"s\">main</span><span class=\"p\">;</span>\n\n    <span class=\"kn\">location</span> <span class=\"s\">/</span> <span class=\"p\">{</span>\n        <span class=\"kn\">try_files</span> <span class=\"nv\">$uri</span> <span class=\"s\">/index.php?</span><span class=\"nv\">$args</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kn\">location</span> <span class=\"p\">~</span> <span class=\"sr\">\\.php$</span> <span class=\"p\">{</span>\n        <span class=\"kn\">fastcgi_split_path_info</span> <span class=\"s\">^(.+\\.php)(/.+)</span>$<span class=\"p\">;</span>\n        <span class=\"kn\">fastcgi_pass</span> <span class=\"n\">app</span><span class=\"p\">:</span><span class=\"mi\">9000</span><span class=\"p\">;</span>\n        <span class=\"kn\">fastcgi_index</span> <span class=\"s\">index.php</span><span class=\"p\">;</span>\n        <span class=\"kn\">include</span> <span class=\"s\">fastcgi_params</span><span class=\"p\">;</span>\n        <span class=\"kn\">fastcgi_param</span> <span class=\"s\">SCRIPT_FILENAME</span> <span class=\"nv\">$document_root$fastcgi_script_name</span><span class=\"p\">;</span>\n        <span class=\"kn\">fastcgi_param</span> <span class=\"s\">PATH_INFO</span> <span class=\"nv\">$fastcgi_path_info</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><ul><li>这里配置了 server_name，因为 larabbs 使用了<a href=\"https://link.zhihu.com/?target=https%3A//github.com/viacreative/sudo-su\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">sudo-su</a>包，不配置域名访问会有权限问题。</li><li>fastcgi_pass app:9000 这里将动态请求转发给了 app 容器的9000端口，即 php-fpm 服务的端口，默认 docker-compose 同一项目下的容器是在同一个网络中，无需映射可以直接互相访问。</li></ul><p>6. 创建数据库服务，docker-compose.yml 文件添加以下内容</p><div class=\"highlight\"><pre><code class=\"language-yaml\"><span class=\"c\"># mysql database</span><span class=\"w\">\n</span><span class=\"w\">    </span>database<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">        </span>image<span class=\"p\">:</span><span class=\"w\"> </span>mysql<span class=\"p\">:</span><span class=\"m\">5.7</span><span class=\"w\">\n</span><span class=\"w\">        </span>environment<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">          </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;MYSQL_ROOT_PASSWORD=root&#34;</span><span class=\"w\">\n</span><span class=\"w\">          </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;MYSQL_DATABASE=larabbs&#34;</span><span class=\"w\">\n</span><span class=\"w\">          </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;MYSQL_USER=homestead&#34;</span><span class=\"w\">\n</span><span class=\"w\">          </span>-<span class=\"w\"> </span><span class=\"s2\">&#34;MYSQL_PASSWORD=secret&#34;</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"c\"># redis database</span><span class=\"w\">\n</span><span class=\"w\">    </span>redis<span class=\"p\">:</span><span class=\"w\">\n</span><span class=\"w\">        </span>image<span class=\"p\">:</span><span class=\"w\"> </span>redis<span class=\"p\">:</span><span class=\"m\">5</span></code></pre></div><ul><li>这里 database 和 redis 是服务名，也即在 app 服务的 environment 变量设置的参数，因此 app 才能访问到我们容器中的数据库，当然你也可以使用其它名字。</li><li>environment 这里我们设置了 mysql 的数据库及用户名密码，即是 env 文件中配置的用户名密码，mysql 容器会自动初始化，然后应用才有权限连接。</li></ul><p>到目前为止配置文件已经写完了，完整的文件可以在<a href=\"https://link.zhihu.com/?target=https%3A//github.com/lixiang9194/laravel-docker\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">我的 github</a> 看到。</p><p>7. 启动项目</p><p>docker-compose 最常用的命令就是 docker-compose up 了，该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p><p>因此，在项目文件夹下执行此命令。注意要在项目文件夹下，否则 docker-compose 找不到 docker-compose.yml 文件，也不知道你是如何配置的。</p><p>时间可能较长，请耐心等待。如果遇到网络故障，可以重试。</p><p>简单介绍下输出：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d31f9edad2bdc8d3b2a099f4626d7ce7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"584\" data-rawheight=\"36\" class=\"origin_image zh-lightbox-thumb\" width=\"584\" data-original=\"https://pic4.zhimg.com/v2-d31f9edad2bdc8d3b2a099f4626d7ce7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;584&#39; height=&#39;36&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"584\" data-rawheight=\"36\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"584\" data-original=\"https://pic4.zhimg.com/v2-d31f9edad2bdc8d3b2a099f4626d7ce7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d31f9edad2bdc8d3b2a099f4626d7ce7_b.jpg\"/></figure><p>可以看到 此时app 服务已启动，等待连接。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-79f3cc2679081bc421338c1fd4b03c21_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"22\" class=\"origin_image zh-lightbox-thumb\" width=\"592\" data-original=\"https://pic2.zhimg.com/v2-79f3cc2679081bc421338c1fd4b03c21_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;592&#39; height=&#39;22&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"22\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"592\" data-original=\"https://pic2.zhimg.com/v2-79f3cc2679081bc421338c1fd4b03c21_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-79f3cc2679081bc421338c1fd4b03c21_b.jpg\"/></figure><p>redis 服务已启动。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-286ea03f151817aa8461815292303158_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"922\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb\" width=\"922\" data-original=\"https://pic1.zhimg.com/v2-286ea03f151817aa8461815292303158_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;922&#39; height=&#39;39&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"922\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"922\" data-original=\"https://pic1.zhimg.com/v2-286ea03f151817aa8461815292303158_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-286ea03f151817aa8461815292303158_b.jpg\"/></figure><p> database 服务已启动，在3306端口等待连接。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-561d51f9b9f7498fec77bc29aa60796f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"40\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-561d51f9b9f7498fec77bc29aa60796f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;40&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"40\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-561d51f9b9f7498fec77bc29aa60796f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-561d51f9b9f7498fec77bc29aa60796f_b.jpg\"/></figure><p>composer 服务准备开始安装依赖。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-597d721be80fc537e8585456ec3b6ab1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"447\" data-rawheight=\"34\" class=\"origin_image zh-lightbox-thumb\" width=\"447\" data-original=\"https://pic2.zhimg.com/v2-597d721be80fc537e8585456ec3b6ab1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;447&#39; height=&#39;34&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"447\" data-rawheight=\"34\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"447\" data-original=\"https://pic2.zhimg.com/v2-597d721be80fc537e8585456ec3b6ab1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-597d721be80fc537e8585456ec3b6ab1_b.jpg\"/></figure><p>composer 服务完成任务退出。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然顺序可能不同，但正常情况下nginx、mysql、redis、app 服务都已经启动，运行正常。</p><p>另外，你可以给命令加上-d 参数，以忽略输出，当然第一次运行还是仔细观察输出为好，将来使用时可以这么做。</p><p>8. 项目使用</p><p>首先执行下 docker ps，可以看到目前有4个容器，容器名都加上了项目前缀。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-665f1bf7a51a5094870d08830dce0107_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1252\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb\" width=\"1252\" data-original=\"https://pic4.zhimg.com/v2-665f1bf7a51a5094870d08830dce0107_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1252&#39; height=&#39;112&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1252\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1252\" data-original=\"https://pic4.zhimg.com/v2-665f1bf7a51a5094870d08830dce0107_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-665f1bf7a51a5094870d08830dce0107_b.jpg\"/></figure><p>此时你可以使用 docker exec 命令进入相应容器执行初始化操作，因为 docker-compose 本身也是调用的 docker api，但是既然使用了 docker-compose 来管理项目，我们必然有更方便的方式。</p><p>执行 docker-compose ps,可以至查看当前项目的容器状态。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f920e0fd02e937e47ca2da4830e10b09_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-f920e0fd02e937e47ca2da4830e10b09_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;153&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic2.zhimg.com/v2-f920e0fd02e937e47ca2da4830e10b09_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f920e0fd02e937e47ca2da4830e10b09_b.jpg\"/></figure><p>可以看到，四个服务正在运行，而 composer 服务已经执行完任务退出。</p><p>如果要容器执行命令，直接 docker-compose  exec service_name command 更方便。</p><p>比如，进入我们的 nginx 容器，nginx 即是 YAML 文件里定义的服务名。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1b716263a1282e25e5b4b29018829738_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"44\" class=\"origin_image zh-lightbox-thumb\" width=\"498\" data-original=\"https://pic1.zhimg.com/v2-1b716263a1282e25e5b4b29018829738_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;498&#39; height=&#39;44&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"44\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"498\" data-original=\"https://pic1.zhimg.com/v2-1b716263a1282e25e5b4b29018829738_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1b716263a1282e25e5b4b29018829738_b.jpg\"/></figure><p>接下来，我们进行网站的初始化工作。即生成秘钥、初始化数据库等。</p><p>app 也是 YAML 文件里定义的服务名。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-384032943dc67398bf3f87bb3b0264d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-384032943dc67398bf3f87bb3b0264d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;701&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-384032943dc67398bf3f87bb3b0264d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-384032943dc67398bf3f87bb3b0264d5_b.jpg\"/></figure><p>一切都顺利进行。</p><p>对了，因为上面提到 sudo-su的原因，你必须使用域名访问网站，在 host 文件添加 larabbs.test到127.0.0.1的映射即可。</p><p>然后，你应该就可以正常访问 <a href=\"https://link.zhihu.com/?target=http%3A//larabbs.test\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">larabbs.test</span><span class=\"invisible\"></span></a> 网站了。</p><p>8. 容器的停止</p><p>直接 control-c 或者 docker-compose stop 即可。</p><p>注意下次docker-compose up 默认仍会继续使用之前的容器和数据。</p><p>必要时你可以添加--build 参数重新构建镜像，或者--force-recreate参数重新创建容器。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>更多资料：<a href=\"https://link.zhihu.com/?target=https%3A//yeasy.gitbooks.io/docker_practice/compose/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">docker 三剑客-compose</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/compose/overview/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">docker-compose 官方文档</a></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p><b>闲言</b></p><p>这个系列写了三篇了，算是把 docker 的基本使用介绍完了，更准确的说，应该是把我会用的介绍完了。因为本身是开发工程师，更着重于日常开发过程中使用，经验不多，对于运维视角的 docker不甚了解，而 docker 更大的意义应该是在运维层，所以有介绍的不合适甚至错误的地方，欢迎指出，或者分享你对 docker 的理解与使用。</p><p>另外，接下来会介绍 docker 与虚拟机的区别，docker 的原理等，写起来会比较难，但我会尽快完成。相信看了之后，会对 docker 的实质有更深的理解，就算是吹牛逼也会更有自信，欢迎关注~</p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "Docker Compose", 
                    "tagLink": "https://api.zhihu.com/topics/20104983"
                }
            ], 
            "comments": [
                {
                    "userName": "奎爷再就业", 
                    "userLink": "https://www.zhihu.com/people/a0950b6709e9a9db19e858a1a1d1f471", 
                    "content": "一口气看完3篇，受用，谢谢！", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>哈哈，有收获就好，欢迎交流</p>", 
                            "likes": 1, 
                            "replyToAuthor": "奎爷再就业"
                        }
                    ]
                }, 
                {
                    "userName": "吴彤", 
                    "userLink": "https://www.zhihu.com/people/dadf52fa5e7909905cb3ccdf6d81aad2", 
                    "content": "可不可以解释一下为什么建议一个容器跑一个应用，这样做的好处？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "本文第二段，还有第四篇文章，仔细读下", 
                            "likes": 0, 
                            "replyToAuthor": "吴彤"
                        }
                    ]
                }, 
                {
                    "userName": "杨大爷", 
                    "userLink": "https://www.zhihu.com/people/22fdcc466b1a17057fbdb1370898d867", 
                    "content": "- DB_HOST=database<br>            - REDIS_HOST=redis加这两行的意义是什么呢", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "枕月", 
                    "userLink": "https://www.zhihu.com/people/a19fa65c2bdae778e29b485eceab0887", 
                    "content": "<p>前三篇对于日常使用docker的人来说，很受用</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "KimWeb", 
                    "userLink": "https://www.zhihu.com/people/f24fc466d306ee5d3b4e31e75c712972", 
                    "content": "很赞。受教了。感谢作者。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "MG033", 
                    "userLink": "https://www.zhihu.com/people/c08943e37dba78c1f9922a535b657172", 
                    "content": "最近遇到一个问题，fastcgi_param PATH_INFO $fastcgi_path_info; 这段的$fastcgi_path_info获取不到值，导致$_SERVER[‘PATH_INFO’]只是一个空字符串，求助[拜托]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我也没有经验</p>", 
                            "likes": 0, 
                            "replyToAuthor": "MG033"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49912239", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 11, 
            "title": "由浅入深docker系列： (2)docker构建", 
            "content": "<p>在上一篇教程里，我们学会了docker的使用，也体验了docker的隔离性，在里面随意增删软件，不用的时候直接删除镜像容器，很方便。但是，还有问题，如果你的朋友也想试用你的软件，怎么办呢？或者你换了台电脑，又要重新pull然后在docker里install么？</p><p>当然不用，我们说过docker具有快速部署的优点。今天我们学习怎么构建我们自己的docker镜像。</p><hr/><p><b>一：docker commit</b></p><p>最直观的思路，自然是将我们的容器保存下来。而docker也为此提供了很方便的命令，即 docker commit。其格式为</p><div class=\"highlight\"><pre><code class=\"language-docker\">docker commit -a <span class=\"s2\">&#34;author&#34;</span> -m <span class=\"s2\">&#34;message&#34;</span> &lt;exiting-container&gt; &lt;hub-user&gt;/&lt;repo-name&gt;<span class=\"o\">[</span>:&lt;tag&gt;<span class=\"o\">]</span></code></pre></div><p>是不是很像 git的commit命令？其中 exiting-container为你的容器名称或 id，hub-user 为你登录的 DockerHub 用户名，repo-name 为你想给新镜像起的名字。</p><p>镜像构建成功之后，就可以分享了</p><p>你可以使用 docker save &lt;image&gt; | gzip &gt; fileName 将 image 保存为文件，然后拷贝给他人，再通过 docker load -i fileName导入使用。</p><p>这么做太麻烦了。推荐方式是使用 docker push 命令将其推送到 DockerHub，当然你需要先登录。</p><p>我把上次的 ubuntu 做了commit，并 push 到了 DockerHub，成功之后就可以在<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DockerHub</a>看到自己的镜像了，之后可以随时拉取使用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-48e10a88b700b76d2c1c342e3bc7971f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1670\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"1670\" data-original=\"https://pic4.zhimg.com/v2-48e10a88b700b76d2c1c342e3bc7971f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1670&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1670\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1670\" data-original=\"https://pic4.zhimg.com/v2-48e10a88b700b76d2c1c342e3bc7971f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-48e10a88b700b76d2c1c342e3bc7971f_b.jpg\"/></figure><p>另外，通过docker history 可以看到容器的创建历史，我们可以试下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f1f6160383dbc7d6e05016a7e752cc2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1516\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb\" width=\"1516\" data-original=\"https://pic4.zhimg.com/v2-f1f6160383dbc7d6e05016a7e752cc2b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1516&#39; height=&#39;246&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1516\" data-rawheight=\"246\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1516\" data-original=\"https://pic4.zhimg.com/v2-f1f6160383dbc7d6e05016a7e752cc2b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f1f6160383dbc7d6e05016a7e752cc2b_b.jpg\"/></figure><p>我们发现，在软件内部增删软件、文件等操作在这里都无法体现，因此我们的镜像事实上成了一个黑盒，没有文档就不知道其具体有什么功能，即使你添加了文档，经过一次次更改文档很可能也没有同步了，非常不方便别人或者自己以后使用。事实上，docker 提供了更方便强大的方式构建镜像，即 Dockerfile。</p><p>另外，commit 方式在特定场景下也有其用途，比如程序崩溃、被入侵后保存现场时，就很有用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二：Dockerfile</b></p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令，描述我们的镜像该如何构建，就像我们程序的源码。在这之前，补充一个知识，就是我们的 docker 镜像文件事实上是分层的。你应该注意到拉取 ubuntu 的时候，它pull 了很多次。而分层的操作也方便不同镜像间共享相同的层，这显著的节省了客户机的存储空间以及下载时间。</p><p>例如，我再拉取一个 nginx 镜像，你会发现第一层已经存在了，直接复用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a55535afeb6485b913b3937865705311_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-a55535afeb6485b913b3937865705311_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-a55535afeb6485b913b3937865705311_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a55535afeb6485b913b3937865705311_b.jpg\"/></figure><p>为什么要讲这个？因为 Dockfile 的每一条指令的内容，就是描述该层应当如何构建。</p><p>我们首先来定制一个 nginx 镜像。</p><p>任意新建一个文件夹，建立一个文本文件，命名为 Dockerfile。</p><p>文本内容如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">FROM nginx\nRUN echo &#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39; &gt; /usr/share/nginx/html/index.html</code></pre></div><p>然后执行docker build命令构建镜像</p><div class=\"highlight\"><pre><code class=\"language-text\">docker build -t &#34;name:tag&#34; path</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c8361c75a5eb701c3b3b07b9fab1e301_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1302\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb\" width=\"1302\" data-original=\"https://pic2.zhimg.com/v2-c8361c75a5eb701c3b3b07b9fab1e301_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1302&#39; height=&#39;342&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1302\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1302\" data-original=\"https://pic2.zhimg.com/v2-c8361c75a5eb701c3b3b07b9fab1e301_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c8361c75a5eb701c3b3b07b9fab1e301_b.jpg\"/></figure><p>可以发现，如之前所说，新的容器分两层构建。注意命令最后有一个点，表示当前文件夹。</p><p>然后，执行 docker run 启动镜像。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3fd3efe20019bbb70532eececc573fd8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"1046\" data-original=\"https://pic1.zhimg.com/v2-3fd3efe20019bbb70532eececc573fd8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1046&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1046\" data-original=\"https://pic1.zhimg.com/v2-3fd3efe20019bbb70532eececc573fd8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3fd3efe20019bbb70532eececc573fd8_b.jpg\"/></figure><p>这时访问<a href=\"https://link.zhihu.com/?target=http%3A//127.0.0.1%3A8080\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">127.0.0.1:8080</span><span class=\"invisible\"></span></a>应该就能看到我们的页面了。注意之前的镜像可能已经绑定了本机8080端口，你需要停止它或者换一个端口。还有-d 参数表示后台运行，注意-d 并不影响容器的运行时间，只是将其放到了后台，换句话说，如果你的容器本身没有运行不退出的进程，即使加了-d 容器依然会自动退出。</p><p>同样你可以将其推送到 DockerHub，或者仅仅将你的 Dockerfile 分享给他人就可使用。另外，你可以将 Dockerfile 与你的代码一同上传 github 或其他系统，更方便你的应用环境搭建，也可以进行docker 的版本管理。甚至，你还可以设置<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/CHENYUFENG1991/article/details/79839766\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker Hub结合Github自动化构建镜像</a>。</p><p>接下介绍常用的 Dockerfile 命令。</p><ol><li>FROM 命令</li></ol><p> FROM为指定基础镜像，像之前我们基于官方 nginx 进行定制，这样可以省略大量的重复工作。DockerHub 上有大量的镜像，ubuntu、mysql、php、python 等等，一定要选择合适的作为基础镜像，比如开发 django 就选用 python 或者django 镜像，而不要去用 php 镜像。</p><p>2. RUN 命令</p><p>RUN 命令即用来在容器中执行命令的，相当于你之前手动在 docker 里面执行命令。</p><p>其格式也很简单，RUN &lt;command&gt;即可，command可以是容器能执行的任何命令。</p><p>这里说下本人的经验，RUN 命令不一定能成功执行，你不必一遍遍更改然后 build 实验，可以直接 run 一个基础镜像，然后去执行命令，等成功了再写入 Dockerfile，会方便很多。</p><p>另外，之前说过，每条命令会构建一层，所以不要写太多层 RUN，也不要只有一层，单独的功能模块组合到一层，更利于快速构建以及复用。比如下面这个例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">FROM php:7.1.22-fpm\n\n# Install PHP and composer dependencies\nRUN apt-get update \\\n    &amp;&amp; apt-get install -qq git curl libmcrypt-dev libjpeg-dev libpng-dev libfreetype6-dev libbz2-dev \\\n    &amp;&amp; RUN apt-get clean\n\n# Install needed extensions\nRUN docker-php-ext-install pdo pdo_mysql mcrypt zip gd</code></pre></div><p>3. COPY 命令</p><p>COPY 命令用于将文件拷贝到镜像中。</p><div class=\"highlight\"><pre><code class=\"language-text\">COPY &lt;源路径&gt; &lt;目标路径&gt;</code></pre></div><p>你可以将需要的文件拷贝到镜像内，注意这里源路径是相对路径，即相对上文构建命令里的最后一个参数所指定的目录（上文例子为`.`），不能随意引用其它文件。另外，尽量不要在构建目录里放入无关文件，因为 docker 会将目录下所有文件打包发送给服务进程，如图所示</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a51f723615c797206440321f7b253b9f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1192\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"1192\" data-original=\"https://pic4.zhimg.com/v2-a51f723615c797206440321f7b253b9f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1192&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1192\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1192\" data-original=\"https://pic4.zhimg.com/v2-a51f723615c797206440321f7b253b9f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a51f723615c797206440321f7b253b9f_b.jpg\"/></figure><p>4. CMD命令</p><p>CMD 命令为容器启动时的默认命令，因为容器其实本质是一个进程（后面会细讲）。比如 ubuntu 镜像默认CMD 命令为/bin/bash，因此事实上我们只要执行 docker run -it ubuntu就可以得到一个交互式 shell。如果我们传入其它命令，比如 执行 docker run ubuntu uname，容器就会执行我们指定的命令。</p><p>以上就是最常用的Dockerfile 命令，建议大家自己尝试构建一个，会有更深的体会。另外还有很多命令以及细节，可以参考<a href=\"https://link.zhihu.com/?target=https%3A//yeasy.gitbooks.io/docker_practice/image/build.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这篇文章</a>。</p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }
            ], 
            "comments": [
                {
                    "userName": "王宇翔", 
                    "userLink": "https://www.zhihu.com/people/8b037e8a0e4ea18bea0057cfd52432d7", 
                    "content": "谢谢，入门docker的好文章", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/49492290", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 34, 
            "title": "由浅入深docker系列： (1)安装使用", 
            "content": "<p>最近公司在做一个项目，为了方便程序员配置环境以及线上自动测试，架构师配置了docker环境，之前就经常听说docker却不会用，这次也就顺便学习了下，看了很多资料，解决了很多困惑，也觉得很多文章写的不够清晰深入，因此想自己写一个系列，能帮助别人更快的入门、更彻底的认识docker。</p><p>初步计划共有六篇文章，第一篇介绍docker的安装及简单使用，docker pull、run、start等等；第二篇介绍单个docker的构建，Dockfile相关指令；第三篇介绍如何方便的使用多个docker容器组合提供服务，即docker-compose项目；第四篇介绍kernel与user space，容器与虚拟机的区别、优劣等等；第五篇介绍docker的资源隔离，主要为linux内核的cgroups功能；第六篇介绍docker的文件分层，即Union File System。</p><p>相信这个系列文章看完，你能够熟悉docker的基本使用、构建，对docker的整体架构、原理、优劣有清晰的认识，在使用中遇到问题也能够快速准确的定位、解决，不至于连关键点都找不到，只能靠试，效率极低。</p><p>这个系列主要是为了讲自己学习中困惑，以及觉得别人没有讲明白的地方，本人水平有限，难免有错误或者遗漏之处，欢迎留言讨论~</p><hr/><h2><b><i>一：docker的产生是为了解决什么问题？有什么优点？</i></b></h2><p>新技术产生必然是为了解决某些需求、痛点，否则这项技术就没有意义。而docker的出现，解决了应用快速部署、隔离性等问题。举例来说，现在Python很火，你想学习写个爬虫，然后要装python、scrapy以及一堆依赖；过几天你又要装django，它们之间依赖的包版本可能冲突，很痛苦，如果用docker则它们是独立的环境，互不影响，这就是隔离性，（当然你也可以用virtualEnv等工具）；但是可能你朋友看到你的程序觉得哇好酷，我也想试试，你又得指导他安装环境，又很痛苦，如果用docker则你把配置文件发给他，一条命令启动，这就是快速部署，想想这能带来多少方便，当然docker还有其它优势，轻量、安全等，我们慢慢说，逐步体会。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b><i>二：docker的安装</i></b></h2><p>docker官方提供了 windows和 mac平台的一键安装包，这是最省心的安装方式，可以在<a href=\"https://link.zhihu.com/?target=https%3A//www.docker.com/products/docker-desktop\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">docker官网</a>下载（需要注册账号，记住，接下来还要使用），直接运行，如果需要权限同意即可。</p><p>不过这对系统版本有要求，根据官方说明，windows 要求 win10 64位，教育版或专业版，主板开启虚拟化(一般默认开启)，4G 内存。mac 要求macos 10.11以后，不能安装 VirtualBox 4.3.30以前版本。如果你无法满足这些，可以尝试<a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/toolbox/overview/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker Toolbox</a>。</p><p>对于 linux 安装或者更详细的指导，可以参考<a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/install/linux/docker-ce/ubuntu/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方文档</a>。</p><h2><b><i>三：docker的基本概念</i></b></h2><p>docker 安装之后需要手动启动，看到如下界面，即代表启动成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-80bbbac231ec4efcc42647465386c572_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"196\" data-rawheight=\"256\" class=\"content_image\" width=\"196\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;196&#39; height=&#39;256&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"196\" data-rawheight=\"256\" class=\"content_image lazy\" width=\"196\" data-actualsrc=\"https://pic3.zhimg.com/v2-80bbbac231ec4efcc42647465386c572_b.png\"/></figure><p>打开终端，执行 docker -v，能看到 docker 版本信息。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-70a6e0ba5b5245f3c512b6843d320ef5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"335\" data-rawheight=\"40\" class=\"content_image\" width=\"335\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;335&#39; height=&#39;40&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"335\" data-rawheight=\"40\" class=\"content_image lazy\" width=\"335\" data-actualsrc=\"https://pic2.zhimg.com/v2-70a6e0ba5b5245f3c512b6843d320ef5_b.jpg\"/></figure><p>接下来，我们介绍下 docker 的基本概念， image<b>镜像</b>，container<b>容器</b>，Repository<b>仓库。</b>docker 本意是集装箱，但在这里，我们暂时不用这个比喻，到后面讲解文件系统时再用，更好理解。之前讲过，docker 的出现是为了应用的可移植、快速部署，对此来说，docker 镜像就是安装文件，你从网上下载的 exe 或其它文件；容器就是你安装到本机的程序；仓库，就是你下载软件的地方。</p><p>既然仓库是下载软件的地方，你自然会想到，是不是有很多地方可以下载？是的，有很多公开或者私人仓库。而其中，<a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker Hub</a>是 docker 官方的仓库注册服务器，上面有众多官方和私人仓库，接下来我们都将从这里下载需要的镜像。首先你需要登录，使用之前注册的 docker 账号，可以在启动界面输入用户密码或者命令行输入 docker login 登录。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3e793846bb3e125f99eac6cc07043cfe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"70\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-3e793846bb3e125f99eac6cc07043cfe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;70&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"70\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-3e793846bb3e125f99eac6cc07043cfe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3e793846bb3e125f99eac6cc07043cfe_b.jpg\"/></figure><h2><b><i>四：docker 的使用</i></b></h2><ol><li><b><i>HelloWorld</i></b></li></ol><p>一切准备好了，当然要先运行下 helloWorld，简单执行 docker run hello-world，即可看到Hello -world 输出及docker对此做的解释。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-077d7b954b8beb43f6f405e0ea6015ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"255\" class=\"content_image\" width=\"325\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;325&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"255\" class=\"content_image lazy\" width=\"325\" data-actualsrc=\"https://pic4.zhimg.com/v2-077d7b954b8beb43f6f405e0ea6015ab_b.jpg\"/></figure><p>我们发现，docker 没有在本地找到hello-world，于是从仓库下载然后运行。 docker 镜像名称全称为repository/image:tag，repository 代表不同的开发者仓库，默认为 docker 官方仓库即library；tag 代表标签，可以理解为版本，默认为 latest，因此实际上我们上面下载的是library/hello-world:latest。</p><p>2. <b>Ubuntu</b></p><p>但是，这个运行的 hello-world 对我们毫无帮助。假如我们想运行一个 ubuntu 试试，该如何做呢？</p><p>第一步，需要找一个合适的镜像，我们可以在命令行搜索，docker search ubuntu，然后会得到一系列镜像名称，以及简介，star数，是否官方维护等信息，你可以选择一个合适的使用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6b1e3eef2f02fb16525d8a66ed82deb0_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"738\" data-rawheight=\"115\" class=\"origin_image zh-lightbox-thumb\" width=\"738\" data-original=\"https://pic1.zhimg.com/v2-6b1e3eef2f02fb16525d8a66ed82deb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;738&#39; height=&#39;115&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"738\" data-rawheight=\"115\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"738\" data-original=\"https://pic1.zhimg.com/v2-6b1e3eef2f02fb16525d8a66ed82deb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6b1e3eef2f02fb16525d8a66ed82deb0_b.png\"/></figure><p>当然，你也可以到 <a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DockerHub</a>手动搜索，在这里你能得到更多镜像的介绍、帮助，重要的是有版本信息，我们可以选择想要的版本，比如16.04。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8b4bfb202a7edc8bb63aee20590dd92d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"310\" class=\"content_image\" width=\"397\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;397&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"310\" class=\"content_image lazy\" width=\"397\" data-actualsrc=\"https://pic2.zhimg.com/v2-8b4bfb202a7edc8bb63aee20590dd92d_b.jpg\"/></figure><p>第二步，将镜像下载到本地，以便重复使用。命令：docker pull ubuntu：16.04</p><p>如果执行 docker image ls，可以看到所有你下载过的镜像。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-425c05ad57dc48e552a4b16a727cc063_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"477\" data-rawheight=\"184\" class=\"origin_image zh-lightbox-thumb\" width=\"477\" data-original=\"https://pic4.zhimg.com/v2-425c05ad57dc48e552a4b16a727cc063_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;477&#39; height=&#39;184&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"477\" data-rawheight=\"184\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"477\" data-original=\"https://pic4.zhimg.com/v2-425c05ad57dc48e552a4b16a727cc063_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-425c05ad57dc48e552a4b16a727cc063_b.jpg\"/></figure><p>第三步，运行容器。命令：docker run ubuntu:16.04</p><p>你会发现，并没有任何输出。这是因为，docker 本质上是一个进程，我们并没有给他传入命令，因此我们给它传入 uname -a，看下它的内核版本。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0b74e13809c4b2dfcf0ed4e2d7be427e_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb\" width=\"859\" data-original=\"https://pic3.zhimg.com/v2-0b74e13809c4b2dfcf0ed4e2d7be427e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;859&#39; height=&#39;38&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"859\" data-original=\"https://pic3.zhimg.com/v2-0b74e13809c4b2dfcf0ed4e2d7be427e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0b74e13809c4b2dfcf0ed4e2d7be427e_b.png\"/></figure><p>可以看到，程序正常输出了。当然你的输出可能不大一样，后面介绍 docker 原理时你就知道原因了。这里你可以将 uname 换位任何你想执行的命令。</p><p>但是还不够，既然是 ubuntu，我们可能想进入系统，安装软件，做一些操作。这就需要-it 参数，执行 docker run -it ubuntu:16.04 /bin/bash，可以发现我们得到了一个 shell，你可以正常的安装软件或者使用了,你所做的一切都在容器内部，不影响你的系统。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-acfb8bc9ae34e9873d7190829efad3d6_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"367\" data-rawheight=\"40\" class=\"content_image\" width=\"367\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;367&#39; height=&#39;40&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"367\" data-rawheight=\"40\" class=\"content_image lazy\" width=\"367\" data-actualsrc=\"https://pic3.zhimg.com/v2-acfb8bc9ae34e9873d7190829efad3d6_b.png\"/></figure><p>这里，-i 表示interactive交互式，-t 表示得到一个 terminal。</p><p>如果你安装了一些软件，比如 git，然后 exit退出，再次执行 run 命令进入，你会发现 git 找不到了，这是因为每次执行 run 命令都将从我们下载的镜像新建一个容器，而 git 是装在上一个容器里，自然找不到了。那我们需要如何做呢？</p><p>首先，执行 docker container ls -a 查看所有的容器（不加-a 只能看到正在运行的容器），你应该能看到不止一个 ubuntu 的容器，注意它们的 id、commamd、names不同。</p><p>找到我们执行 /bin/bash 命令的 ubuntu 容器的 id 或者 name，然后执行 docker start -i，就可以进入之前创建的容器，可以继续之前的工作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f284f0cdb01f497548002ef200c614e8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"129\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-f284f0cdb01f497548002ef200c614e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;129&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"129\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-f284f0cdb01f497548002ef200c614e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f284f0cdb01f497548002ef200c614e8_b.jpg\"/></figure><p>当然，你应该还会用到其它的一些参数，比如-name指定容器名字，后面再 start 这个容器就不用查 id 了；-v挂载文件，将你本地的代码挂载进 docker；或者-p映射端口，将 docker 的端口映射到本机，以便提供http 等服务。</p><p>例如，创建一个名字为 lixiang-ubuntu的镜像，将我本地 code下的代码挂载到镜像/root/app目录下，并将虚拟机的80端口映射到本机8080，命令如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bf8c7d614b230249a0532296cd27df23_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"771\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"771\" data-original=\"https://pic4.zhimg.com/v2-bf8c7d614b230249a0532296cd27df23_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;771&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"771\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"771\" data-original=\"https://pic4.zhimg.com/v2-bf8c7d614b230249a0532296cd27df23_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bf8c7d614b230249a0532296cd27df23_b.png\"/></figure><p>可以看到，app 目录下已经有了本机的文件，你可以将你的代码、ssh 文件等共享给 docker，注意你对docker 里挂载的文件的修改，实质是对本机文件的修改。这样你就可以在本地用 IDE 编辑文件，然后用docker 里的环境运行程序。如果你需要提供 http 服务，则在docker 内80端口起服务，在本机8080端口即可正常访问。</p><p>同样，如果你关闭了此容器，下次执行 docker start -i lixiang-ubuntu 就可以继续工作了。</p><p>如果你需要其它的环境，比如 python、Scrapy、TensorFlow 等，尽管在 DockerHub 上搜索，然后 docker pull、docker run、docker start 就好了，应该已经能够满足你的大多数需求。</p><p>最后，再简单说下 docker 容器、镜像的删除等。</p><p>首先，执行 docker ps 或者 docker container ls 可以看到正在运行的容器。</p><p>执行docker ps -a或者 docker container ls -a可以看到本机所有的容器</p><p>执行 docker container rm [id/name]可以删除对应容器，一次可以指定多个容器。</p><p>执行 docker image ls 可以查看本机所有的镜像文件。</p><p>执行 docker image rm [id/name] 可以删除对应镜像，如果镜像正在被容器引用则无法删除。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "入门好文", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>谢谢，刚开始写，欢迎提出建议~</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>看了你的文章 让我有下载一个docker玩玩</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "山中浪漫", 
                    "userLink": "https://www.zhihu.com/people/6596aec3e9324909edd746c3b8147a0a", 
                    "content": "<p>图片挂啦</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>哪里图片有问题？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "山中浪漫"
                        }
                    ]
                }, 
                {
                    "userName": "fresh", 
                    "userLink": "https://www.zhihu.com/people/85336cc308bdb400765c804310f3a015", 
                    "content": "<p>图片看不到字，都是黑的</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "能截个图么？我这还挺清晰的", 
                            "likes": 0, 
                            "replyToAuthor": "fresh"
                        }
                    ]
                }, 
                {
                    "userName": "Wu rose", 
                    "userLink": "https://www.zhihu.com/people/8d8438bc2c53a72b7b32c0ab36d624f1", 
                    "content": "<p>图片确实有部分看不到呢，黑乎乎的</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "无人及你", 
                    "userLink": "https://www.zhihu.com/people/0ffce960aef8d0407387567e7947345b", 
                    "content": "<p>图片确实看不到呀</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>是字体比较小看不清还是图片就挂了？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "无人及你"
                        }
                    ]
                }, 
                {
                    "userName": "枕月", 
                    "userLink": "https://www.zhihu.com/people/a19fa65c2bdae778e29b485eceab0887", 
                    "content": "<p>excellent</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/40987633", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 8, 
            "title": "数据结构—思路", 
            "content": "<p>      最近读了清华大学邓俊辉老师的数据结构，深感这些数据结构的精妙，在此做简要总结，重点在于理清思路，不细写算法细节，感兴趣的可直接查阅书籍。（邓老师的这本书写的真好，逻辑清晰，深入浅出，学堂在线还有公开课，强烈推荐。）</p><hr/><h2><b><i>一：线性数据结构</i></b></h2><p>       1.最简单的数据结构，就是<b>数组</b>了，理科生应该都懂。各元素依次存放于一段连续地址空间内，数据查找、修改仅需O(1)时间，但是对于数据插入、删除，则需移动其后所有元素，需O(n)时间。</p><p>        根据数据抽象性原则，我们可以将数组结构进行推广，即得到<b>向量</b>。向量是由具有线性次序的元素构成的集合（并不限定各元素属于同一基本类型），元素循秩访问。我们定义其常用操作接口，无论采用何种实现方式，均可以方便地相互调用或集成，很好的体现了程序的封装性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4e43e45a259bb7f27d950dbb0e5db178_b.jpg\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"47\" class=\"content_image\" width=\"325\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;325&#39; height=&#39;47&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"47\" class=\"content_image lazy\" width=\"325\" data-actualsrc=\"https://pic1.zhimg.com/v2-4e43e45a259bb7f27d950dbb0e5db178_b.jpg\"/><figcaption>向量</figcaption></figure><p>       2.对于需要经常插入、删除的数据，如果采用向量存储，明显效率很低。究其原因，在于“各元素物理地址连续”的约定，也即“静态存储”策略。那么相应的，列表结构尽管要求各元素在逻辑上具有线性次序，但对其物理地址并未做任何限制，也即“动态存储”策略。<b>列表</b>通过指针或引用等机制，确定各元素实际物理地址。而<b>链表</b>，就是一种典型的动态存储结构。此时，数据的插入、删除仅需局部操作，变为了O(1)复杂度，但同时，访问元素则必须沿着链表指针，从某端出发逐个扫描，变成了O(n)复杂度。可以看到，向量和列表，对于静态和动态操作，各有优劣，无法兼顾。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-464694c6a4e2d772db383081b2381e40_b.jpg\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"56\" class=\"origin_image zh-lightbox-thumb\" width=\"440\" data-original=\"https://pic1.zhimg.com/v2-464694c6a4e2d772db383081b2381e40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;440&#39; height=&#39;56&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"56\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"440\" data-original=\"https://pic1.zhimg.com/v2-464694c6a4e2d772db383081b2381e40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-464694c6a4e2d772db383081b2381e40_b.jpg\"/><figcaption>列表</figcaption></figure><p>       3.在向量和列表基础上，我们可以实现更为常用的两种数据结构：栈与队列。<b>栈</b>，先进后出，定义很简单，用处极为广泛。函数运行栈、浏览器浏览历史记录、四则计算等，均可通过栈简单高效实现。<b>队列</b>，先进先出，在需要资源管理、分配的场合，银行排队系统、计算机进程调度、打印机共享，均可以使用队列。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d85f98e7a03270f60717e9777f7d303c_b.jpg\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"163\" class=\"content_image\" width=\"265\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;265&#39; height=&#39;163&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"163\" class=\"content_image lazy\" width=\"265\" data-actualsrc=\"https://pic1.zhimg.com/v2-d85f98e7a03270f60717e9777f7d303c_b.jpg\"/><figcaption>栈操作</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p><i><b>二：树</b></i></p><p>       4.我们已经看到，向量和列表，对于静态和动态操作，各有优劣，那么，我们能不能综合其优点呢？事实上，这就引出了树。<b>树</b>元素间并不存在天然的次序关系，但只要施加某种约束（如前序遍历），也可以确定其次序，因此属于半线性结构。树是一种分层结构，而层次化这一特征几乎蕴含于所有事物及其联系之中，如进化树、公司结构、域名系统等等，树结构在算法理论即实际应用中也扮演着最为关键的角色。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-45f0d93dc8b5c630a175452d348a35de_b.jpg\" data-size=\"normal\" data-rawwidth=\"212\" data-rawheight=\"254\" class=\"content_image\" width=\"212\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;212&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"212\" data-rawheight=\"254\" class=\"content_image lazy\" width=\"212\" data-actualsrc=\"https://pic3.zhimg.com/v2-45f0d93dc8b5c630a175452d348a35de_b.jpg\"/><figcaption>树</figcaption></figure><p>       5.作为树的特例，<b>二叉树</b>并不失一般性。事实上，任何有根有序多叉树，均可等价转为二叉树。对二叉树的基本操作，有前序、中序、后续以及层次遍历，可以确定其元素的线性次序。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e974d6787015590e58fefdfee5e9c6ba_b.jpg\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-e974d6787015590e58fefdfee5e9c6ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;276&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-e974d6787015590e58fefdfee5e9c6ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e974d6787015590e58fefdfee5e9c6ba_b.jpg\"/><figcaption>二叉树中序遍历</figcaption></figure><p>       6.如果二叉树中序遍历单调非降，则此树为<b>二叉搜索树</b>。分析得知，对二叉搜索树的查找、插入、删除操作，复杂度均正比于树的高度。随机意义下，二叉树平均高度为O(logn)，因此效率较高，相较于向量和列表，其静态与动态操作效率得到了平衡。但是，最坏情况下，每个节点均只有一个孩子，此时树退化为了列表，查找效率降至O(n)。</p><p>       7.既然二叉搜索树性能取决于其高度，那我们自然想到尽可能降低其高度，使兄弟子树的高度彼此接近。由于包含n个节点的二叉树，高度不可能小于[log2n]，若恰好高为[log2n]，则称为<b>理想平衡树</b>，如<b>完全二叉树</b>、<b>满二叉树</b>均属此类。然而，叶节点只能出现于最底两层的限制过于苛刻，此类二叉树所占比例极低，从算法可行性角度来看，应当依照某种相对宽松的标准，重新定义。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a3ee6d556fdfec37e992513529f4e2a_b.jpg\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-3a3ee6d556fdfec37e992513529f4e2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-3a3ee6d556fdfec37e992513529f4e2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a3ee6d556fdfec37e992513529f4e2a_b.jpg\"/><figcaption>完全二叉树及满二叉树拓扑结构特征</figcaption></figure><p>       8.定义任一节点的平衡因子为其左右子树的高度差，则<b>AVL树</b>定义为：各节点平衡因子的绝对值均不超过1。AVL树可实现近乎理想的平衡，其高度在O(logn)内，因此查找、插入、删除均可在O(logn)时间内完成。但是，在插入、删除操作之后，节点高度可能发生变化，二叉树失衡，也就需要重平衡操作，有单旋、双旋、以及3+4重构几种方案，可以在Ω(logn)次之内完成更新。但AVL树几乎每次插入删除都要重新平衡，其代价仍然相对较高，实际应用并不广泛，主要见于教学中。当然，如果场景中插入删除不频繁，只是对查找特别有要求，AVL树还是具有优势。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8c8df37766ac77a297ba3dfd57c37c8d_b.jpg\" data-size=\"normal\" data-rawwidth=\"515\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb\" width=\"515\" data-original=\"https://pic2.zhimg.com/v2-8c8df37766ac77a297ba3dfd57c37c8d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;515&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"515\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"515\" data-original=\"https://pic2.zhimg.com/v2-8c8df37766ac77a297ba3dfd57c37c8d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8c8df37766ac77a297ba3dfd57c37c8d_b.jpg\"/><figcaption>AVL树的重平衡</figcaption></figure><p>       9.既然AVL树对平衡要求仍然较高，会造成动态操作时失衡一直传递至根节点，那么进一步放宽条件，即得到<b>红黑树</b>。红黑树定义为：树根及外部节点为黑色；若某节点为红色，则其孩子必为黑色；任一外部节点到根节点沿途黑节点数目相等，从而巧妙保证了任一节点左、右子树的高度相差不超过两倍。红黑树插入、删除之后也可能失衡，需要进行修正，但由于其限制更宽松，其分摊意义上仅涉及O(1)个节点。一般工业界把红黑树作为一种更通用的平衡搜索树来用，Java用它来实现TreeMap，C++的std::set/map/multimap等等，著名的linux进程调度Completely Fair Scheduler也用红黑树管理进程控制块。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ba2141dc9b85fe54e829285f75ee4d19_b.jpg\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb\" width=\"498\" data-original=\"https://pic2.zhimg.com/v2-ba2141dc9b85fe54e829285f75ee4d19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;498&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"498\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"498\" data-original=\"https://pic2.zhimg.com/v2-ba2141dc9b85fe54e829285f75ee4d19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ba2141dc9b85fe54e829285f75ee4d19_b.jpg\"/><figcaption>红黑树</figcaption></figure><p>      10.评估算法性能时我们通常假设各元素被访问概率相等，然而实际上存在极强的“数据局部性”，即刚刚被访问的元素，极有可能在不久之后再次被访问；将被访问的下一元素，极有可能处于不久前被访问过的某个元素的附近。基于这一原理，通过“即用即前移”的启发式策略，我们得到了<b>伸展树</b>。伸展树在每次访问某节点后，会通过旋转使该节点成为树根，以加速后续该节点的访问速度。伸展树单次操作可在分摊O(logn)时间内完成，且不需维护节点高度等额外信息，空间性能更优，实现复杂度低。例如在网络应用中，热点内容会被大量重复访问，伸展树可让此类重复搜索以很高的效率完成。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-754b7e2e368194096514eb22ad63e43a_b.jpg\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"452\" data-original=\"https://pic3.zhimg.com/v2-754b7e2e368194096514eb22ad63e43a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;452&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"452\" data-original=\"https://pic3.zhimg.com/v2-754b7e2e368194096514eb22ad63e43a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-754b7e2e368194096514eb22ad63e43a_b.jpg\"/><figcaption>伸展树较深节点被访问后，对应分支长度大致减半</figcaption></figure><p>     11.到目前为止，我们有了适用于不同需求的多种数据结构，很好。但以上分析全部基于数据全部存在于内存中的假设，而从实际应用需求看，问题规模的膨胀远远快于存储能力的增长，通常我们需要将数据全集存放于外存中，计算过程中将内存作为高速缓存，借助调度算法，将内存的高速度与外存的大容量结合起来。</p><p>      连个相邻存储级别间的数据传输，统称I/O操作。而各级存储器访问速度相差悬殊，应该尽可能减少I/O操作。因此，为减少对外存的一次访问，我们宁愿访问内存百次、千次甚至万次。为此，我们可以利用磁盘之类外部存储器的另一特性：就时间成本而言，读取物理连续的一千字节，与读取单个字节几乎没有区别。因此，我们想到，不妨每次从磁盘上读取多个节点，然后在内存中多次比较，从而减少成本极高的单次外存操作。因此可将通常的二叉搜索树，改造成<b>多路搜索树</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dce834b94bd39fdcc5fa76530579ecf6_b.jpg\" data-size=\"normal\" data-rawwidth=\"549\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb\" width=\"549\" data-original=\"https://pic3.zhimg.com/v2-dce834b94bd39fdcc5fa76530579ecf6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;549&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"549\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"549\" data-original=\"https://pic3.zhimg.com/v2-dce834b94bd39fdcc5fa76530579ecf6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-dce834b94bd39fdcc5fa76530579ecf6_b.jpg\"/><figcaption>二叉搜索树 -&amp;amp;amp;gt; 四路搜索树</figcaption></figure><p>       例如，将二叉搜索树以两层为间隔，各节点进行合并，改造后每个大节点拥有四个分支，故称为<b>四路搜索树</b>。不难想象，多路搜索树同样支持查找等操作，然而重要的是，搜索每下降一层，以大节点为单位从外存读取一组（不再是一个）关键码，而这组关键码物理上彼此相邻，所需时间与读取单个关键码几乎一样。当然，每组关键码的最佳数目，取决于外存的访问特性，比如根据旋转式磁盘扇区的容量和关键码的大小，换算得到每组的最佳规模。而数据库中常见的m阶<b>B-树</b>(读B树，-是连字符，不是减号)，即m路平衡搜索树（m≥2），为保证磁盘利用率，其要求每个节点分支节点介于[m/2]与m之间。(事实上，适当转换后，红黑树与B-树相互等价)</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c68b02329a83ff941a7aec612b90498a_b.jpg\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic3.zhimg.com/v2-c68b02329a83ff941a7aec612b90498a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;156&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic3.zhimg.com/v2-c68b02329a83ff941a7aec612b90498a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c68b02329a83ff941a7aec612b90498a_b.jpg\"/><figcaption>B-树宏观结构</figcaption></figure><p>      B-树在插入或删除节点后，节点关键码树可能不再符合（[m/2],m）约定，称为上溢或者下溢，相应进行分裂或者合并操作，修复过程可在O(logmN)次内完成。B树充分利用了磁盘块的原理，树高降低，磁盘IO次数减少，因此查找效率大幅提高。</p><p>      12.<b>B+树</b>是B-树的升级版，其更充分的利用了节点的空间，查询速度更稳定。其改变主要为：非叶子节点不再保存关键字记录指针，只进行数据索引，因此内部节点占用空间更小，同样空间可保存更多节点，同时每个数据必须要搜索到叶节点，所有查询次数一样。另外，所有数据都在叶子结点，而叶子结点存储了指向下个叶子结点的指针，因此可以更高效的进行范围查询及数据遍历操作，在数据库中常用来建立索引。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ac2cb68d91527b9bb8a81b2193b8253b_b.jpg\" data-size=\"normal\" data-rawwidth=\"535\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"535\" data-original=\"https://pic4.zhimg.com/v2-ac2cb68d91527b9bb8a81b2193b8253b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;535&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"535\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"535\" data-original=\"https://pic4.zhimg.com/v2-ac2cb68d91527b9bb8a81b2193b8253b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ac2cb68d91527b9bb8a81b2193b8253b_b.jpg\"/><figcaption>B+树</figcaption></figure><p>       13.另外，数据库领域还有<b>R树</b>，它是为了解决高维空间搜索等问题，是B-树在高维空间的扩展。例如，查找方圆20公里内的餐厅问题。它逐层对空间进行分割，节点越往上，表示的空间越大，查找时若该节点代表空间满足要求，则子节点全部满足，反之全部不满足，不必向下查找，仅有两者相交时才向下查找，因此效率很高。而<b>KD-树</b>思想与之相似，在此不做进一步介绍。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9e37cef668b70014d62c07eb0ec0e925_b.jpg\" data-size=\"normal\" data-rawwidth=\"233\" data-rawheight=\"194\" class=\"content_image\" width=\"233\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;233&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"233\" data-rawheight=\"194\" class=\"content_image lazy\" width=\"233\" data-actualsrc=\"https://pic2.zhimg.com/v2-9e37cef668b70014d62c07eb0ec0e925_b.jpg\"/><figcaption>R树</figcaption></figure><hr/><p><b><i>三：词典  </i></b> </p><p>      14.前面介绍，为了结合向量和列表的优点，相继引入了多种树结构，然而其相关操作往往较为复杂，因此我们试图寻找另外一种简单直观的数据结构，这即是<b>跳转表</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bc4f32d5433b1c5db4f0cf8edd081695_b.jpg\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-bc4f32d5433b1c5db4f0cf8edd081695_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;451&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"451\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"451\" data-original=\"https://pic2.zhimg.com/v2-bc4f32d5433b1c5db4f0cf8edd081695_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bc4f32d5433b1c5db4f0cf8edd081695_b.jpg\"/><figcaption>跳转表</figcaption></figure><p>       跳转表内部沿横向分层，同层之间定义前驱后继关系，层次不同的节点间组成塔，同样以高度定义前驱后继。尽管塔内节点相互重复，但可以加速查找。其查找从顶层开始，若查找不到则相应向下搜索。通过控制各塔高度随机分布，可以保证其查找、删除等操作复杂度均为O(logn)。其原理直观易懂，代码实现简单，在Redis中是有序集合键的底层实现之一。</p><p>       15.<b>散列表</b>，通过适当的散列函数将数据映射到地址空间，其实质与数组相似。若地址既无重复又无浪费，即为<b>完美散列</b>。而散列的冲突及解决，本质就是对空间及时间的取舍。散列技术可在期望常数时间内实现查找、删除等操作，在数据库中也可用来做索引，速度极快，但它无法支持范围查找。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-000551551d1d588995551235ef4f7201_b.jpg\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-000551551d1d588995551235ef4f7201_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-000551551d1d588995551235ef4f7201_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-000551551d1d588995551235ef4f7201_b.jpg\"/><figcaption>散列表</figcaption></figure><hr/><p><b>四：总结</b></p><p>本文尝试把常见数据结构理了一遍，目的在于引出为什么要有这些结构，每种结构适合于做什么，其本质有哪些异同点；对于每种数据结构的定义、具体操作并没有详述，因为网上资料很多，可对应搜索查看，希望能帮助读者加深对数据结构的理解。</p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "树（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/19680489"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/32200778", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 0, 
            "title": "机器学习之一：环境选择", 
            "content": "<p>伴随着大数据时代的到来，知识爆炸让我们无所适从，面对巨量、杂乱的信息，曾经的经验式直观分析方式已经力所难及，唯有借助于数学精准的表达能力与计算机强大的计算能力，才能从数据中发现规律，创造价值，这也就是最近大火的机器学习。</p><p>那么，我们当然也不能被时代抛弃了。最近我也在学习机器学习以及深度学习，感觉网上资料多且乱，也踩了不少坑，计划接下来把自己的经验整理下，加以学习巩固，也希望能给大家一点帮助，共同进步。</p><p>面对众多的系统平台(windows、Linux、Mac)， 编程语言(C++、Java、Python)， 机器学习框架(Tensorflow、Caffee、CNTK)， 是不是有种乱花渐欲迷人眼的感觉。。。。</p><h2>我的建议是：Linux/Mac + Python + Tensorflow</h2><hr/><h2>1. 为什么选择Linux/Mac</h2><ul><li>也许大家都用惯了Windows，听说Linux很难用，然而，Windows是为消费者设计的，Linux才是为开发人员诞生的，Linux的命令行或许初始会让你畏惧，但是用习惯了，你就会发现它的方便、强大，最终爱不释手。尤其是，使用Python以及Tensorflow，在Windows下你可能会遇到各种莫名其妙的依赖问题，在Linux下将会顺心许多。</li><li>关于Linux的安装，推荐使用VMware虚拟机，Ubuntu16.04系统，前几天试用了下，不得不说，比起当年我装12.04，简直好用到天上去了，具体安装步骤，请百度，有时间我也会补一篇。</li><li>当然，虚拟机性能有点差，而且Linux图形界面有点丑，所以，如果你不差钱，我建议你选Mac Pro，因为macOS始于UNIX内核，命令行的使用与Linux基本一致，再加上漂亮的图形界面，好吧，我就是体验了一把，就被圈粉了。</li><li>如果这还不能说服你，来看张图片吧  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1f11892ba8a0a8aa4382c7ca3ae2cf0a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic3.zhimg.com/v2-1f11892ba8a0a8aa4382c7ca3ae2cf0a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;317&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic3.zhimg.com/v2-1f11892ba8a0a8aa4382c7ca3ae2cf0a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1f11892ba8a0a8aa4382c7ca3ae2cf0a_b.jpg\"/></figure><p><i>是不是资历老的、挣钱多的开发者更倾向于Linux/Mac？</i></p><hr/><h2>2. 为什么选择Python</h2><ul><li>好吧，这个应该不用多说，因为入门快、简单、优雅啊，来，喊口号：Life is short, I use Python.</li><li>再来看张图片 </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-222d1c01b3d5aeb1bb71cb513d92d1fb_b.jpg\" data-size=\"normal\" data-rawwidth=\"276\" data-rawheight=\"201\" class=\"content_image\" width=\"276\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;276&#39; height=&#39;201&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"276\" data-rawheight=\"201\" class=\"content_image lazy\" width=\"276\" data-actualsrc=\"https://pic4.zhimg.com/v2-222d1c01b3d5aeb1bb71cb513d92d1fb_b.jpg\"/><figcaption>(与上张图片来源相同) </figcaption></figure><p><i>写Python的高收入者更多</i></p><hr/><blockquote>为什么选择Tensorflow</blockquote><ul><li>TensorFlow是由Jeff Dean领头的谷歌大脑团队基于谷歌内部第一代深度学习系统DistBelief改进而来的通用计算框架。</li><li>Google家的产品，当然要支持啊</li><li>老套路，看图说话  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d199f7b8557c7cec82c62b901c18e00a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic3.zhimg.com/v2-d199f7b8557c7cec82c62b901c18e00a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic3.zhimg.com/v2-d199f7b8557c7cec82c62b901c18e00a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d199f7b8557c7cec82c62b901c18e00a_b.jpg\"/></figure><p>（上图总结了在GitHub 中最受欢迎的开源深度学习框架排名，该排名是基于各大框架在GitHub 里的收藏数，这个数据由Mitch De Felice 在2017 年5 月初完成。）</p>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "深度学习（Deep Learning）", 
                    "tagLink": "https://api.zhihu.com/topics/19813032"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/32193509", 
            "userName": "李想", 
            "userLink": "https://www.zhihu.com/people/7aa46eaca920334f2e2eeed382da610e", 
            "upvote": 1, 
            "title": "机器学习之二：Python + virtualenv + Tensorflow 环境配置", 
            "content": "<p></p><h2>进入正题，环境安装。</h2><blockquote><b>Python开发必备神器: virtualenv</b></blockquote><ul><li>Linux、Mac下都默认自带了Python2.7，因此不再讲Python2.7的安装，你可以输入python -V查看已安装的版本。</li><li>因为python、Tensorflow版本众多，很有可能你今天用了python2.7、Tensorflow1.1，明天另一个项目又要用3.6、1.2，怎么办；或者你今天写的代码，明天更新系统，Tensorflow也跟着更新了，报错了，多难受。因此，我们需要一个虚拟环境管理工具，<a href=\"https://link.zhihu.com/?target=https%3A//virtualenv.pypa.io/en/stable/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">virtualenv</a>，它可以为你的每个项目建立彼此独立的Python运行环境。</li><li>第一步，使用easy_install安装pip  <code>sudo easy_install pip</code> <br/>然后使用pip工具来安装virtualenv  <code>sudo pip install virtualenv</code></li><li>第二步，新建项目环境 <br/>命令virtualenv可以新建一个独立的Python运行环境，我们将其命名为env，注意到我们加了参数--no-site-packages，这样已经安装到系统中的任何第三方包都不会复制过来，我们就得到了一个干净的Python运行环境</li></ul><p><code>mkdir tensorflow_project</code></p><p><code>cd tensorflow_project</code></p><p><code>virtualenv env --no-site-packages</code> </p><p>你将会看到tensorflow_project目录下多了一个env文件夹，这里存放着我们新建的Python运行环境。</p><ul><li>第三步，激活项目环境  <code>source env/bin/activate</code> </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-520fdb740120a914ce329943cb099ce1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic2.zhimg.com/v2-520fdb740120a914ce329943cb099ce1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic2.zhimg.com/v2-520fdb740120a914ce329943cb099ce1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-520fdb740120a914ce329943cb099ce1_b.jpg\"/></figure><p>注意到，此时提示符变成了env，提示我们已经处于虚拟环境中，正常使用pip进行安装即可，此时将不再需要sudo，因为所有包都将被安装到env目录下，对系统无影响。 <br/>如果你要退出虚拟环境，输入deactivate即可，同样注意提示符的变化，此后再做的操作都将是对系统默认环境的改变。</p><hr/><blockquote><b>安装Tensorflow</b></blockquote><ul><li>因为tensorfow仍在持续开发中，目前最新版本为1.4(2017.12)，新的版本api会有修改，这里，我们使用stanford大学<a href=\"https://link.zhihu.com/?target=https%3A//web.stanford.edu/class/cs20si/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CS20SI</a>课程使用的版本1.2.1，顺便推荐下，这门课程很适合作为Tensorflow的入门课程。</li><li>将以下内容保存为requirements.txt</li></ul><p><code>tensorflow==1.2.1</code></p><p><code>scipy==0.19.1</code></p><p><code>scikit-learn==0.18.2</code></p><p><code>matplotlib==2.0.2</code></p><p><code>xlrd==1.0.0</code></p><p><code>ipdb==0.10.1</code></p><p><code>Pillow==4.2.1</code></p><p><code>lxml==3.8.0</code> </p><ul><li>我们没必要一个个包手动去安装，上面的包列表是经过验证可以正常组合工作的，因此，我们直接安装它们。使用pip -r参数从文件中读取包列表并进行安装</li></ul><p><code>source env/bin/activate</code></p><p><code>pip install -r requirements.txt</code> </p><ul><li>安装成功后，我们可以输入pip freeze查看已经安装的包列表</li><li>简单运行tensorflow的小例子进行测试下</li></ul><p><code>import tensorflow as tf</code></p><p><code>a = tf.constant(2)</code></p><p><code>b = tf.constant(3)</code></p><p><code>x = tf.add(a, b)</code></p><p><code>with tf.Session()</code> <code>as sess:</code></p><p><code>  print(sess.run(x))</code> <code>#5</code> </p><hr/><p><b>备注*踩坑</b></p><blockquote>好麻烦。。。我也觉得。。。那使用在线的tensorflow环境吧  <a href=\"https://link.zhihu.com/?target=https%3A//cocalc.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">cocalc.com/</span><span class=\"invisible\"></span></a></blockquote><hr/><blockquote>mac加上sudo后还是提示permission denied</blockquote><ul><li>El Capitan引入了SIP机制(System Integrity Protection)，默认下系统启用SIP系统完整性保护机制，无论是对于硬盘还是运行时的进程限制对系统目录的写操作 <br/>现在的解决办法是取消SIP机制，具体做法是：</li><li>重启电脑，按住Command+R(直到出现苹果标志)进入Recovery Mode(恢复模式) <br/>左上角菜单里找到实用工具 -&gt; 终端 <br/>输入csrutil disable回车 <br/>重启Mac即可 <br/>如果想重新启动SIP机制重复上述步骤改用csrutil enable即可</li></ul><hr/><blockquote>matplotlib报错： <br/>error: Python is not installed as a framework</blockquote><ul><li>添加~/.matplotlib/matplotlibrc文件，内容为：backend: TkAgg  <code>echo &#39;backend: TkAgg&#39; &gt;&gt; ~/.matplotlib/matplotlibrc</code></li><li>或者，在代码中显式调用</li></ul><p><code>import matplotlib</code></p><p><code>matplotlib.use(&#34;TkAgg&#34;)</code> </p><hr/><blockquote>Tensorflow提示gpu编译信息，以下代码可隐藏</blockquote><p><code>import os</code></p><p><code>os.environ[&#39;TF_CPP_MIN_LOG_LEVEL&#39;]=&#39;2&#39;</code> </p><hr/><blockquote>virtualenv sublimerepl</blockquote><ul><li>经实测，在ubuntu下先激活虚拟环境从终端打开sublime即可使用sublimerepl调用虚拟环境</li><li>但macOS下却不行，可以在settings文件里显式设置python环境</li></ul><p><code>vim sublimerepl-settings-user</code></p><p><code>{&#34;default_extend_env&#34;:</code> <code>{&#34;PATH&#34;:</code> <code>&#34;/Users/lixiang/tensorflow/env/bin:{PATH}&#34;</code> <code>}}</code> </p>", 
            "topic": [
                {
                    "tag": "TensorFlow", 
                    "tagLink": "https://api.zhihu.com/topics/20032249"
                }, 
                {
                    "tag": "深度学习（Deep Learning）", 
                    "tagLink": "https://api.zhihu.com/topics/19813032"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/lzypost"
}
