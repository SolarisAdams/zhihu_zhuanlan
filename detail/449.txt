{
    "title": "码农学习之路", 
    "description": "这里会记录我成为程序员的点滴。同时会分享有关：数据结构和算法、Java、LeetCode题解以及实例项目", 
    "followers": [
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/spongebob-53-24", 
        "https://www.zhihu.com/people/yang-shao-i-98", 
        "https://www.zhihu.com/people/judy-72-67-53", 
        "https://www.zhihu.com/people/xu-you-chang-43", 
        "https://www.zhihu.com/people/xiao-tong-91-83", 
        "https://www.zhihu.com/people/xiao-jiang-zi-15", 
        "https://www.zhihu.com/people/li-zhi-wen-95-92", 
        "https://www.zhihu.com/people/zhang-zi-lin-60-19", 
        "https://www.zhihu.com/people/peter-wang-18", 
        "https://www.zhihu.com/people/hao-jing-de-xiang", 
        "https://www.zhihu.com/people/stargate", 
        "https://www.zhihu.com/people/alston-3-13-37", 
        "https://www.zhihu.com/people/johnny-63-54", 
        "https://www.zhihu.com/people/xiao-shao-shao-tian-bai-shao", 
        "https://www.zhihu.com/people/aupup-67", 
        "https://www.zhihu.com/people/qi-qi-wei-14-23-2", 
        "https://www.zhihu.com/people/qiong-xiong-je", 
        "https://www.zhihu.com/people/spd-92-24", 
        "https://www.zhihu.com/people/cocytus-56", 
        "https://www.zhihu.com/people/an-dong-ni-75-23-76", 
        "https://www.zhihu.com/people/xi-gua-10-11", 
        "https://www.zhihu.com/people/mess-72-14", 
        "https://www.zhihu.com/people/zhang-jin-long-14-90", 
        "https://www.zhihu.com/people/zhang-cheng-11-36", 
        "https://www.zhihu.com/people/shui-wang-zhuo", 
        "https://www.zhihu.com/people/VintLi", 
        "https://www.zhihu.com/people/wang-hg", 
        "https://www.zhihu.com/people/xiao-tao-47-89", 
        "https://www.zhihu.com/people/rao-zhu-fa", 
        "https://www.zhihu.com/people/shen-shao-jie-80", 
        "https://www.zhihu.com/people/li-wen-tao-83", 
        "https://www.zhihu.com/people/meng-xian-sheng-34-93", 
        "https://www.zhihu.com/people/xiao-yang-59-7", 
        "https://www.zhihu.com/people/lu-ming-51-57", 
        "https://www.zhihu.com/people/emptysea", 
        "https://www.zhihu.com/people/yao-xin-15-79", 
        "https://www.zhihu.com/people/dan-zi-se-de-lan", 
        "https://www.zhihu.com/people/liu-en-chen-77", 
        "https://www.zhihu.com/people/yu-gua-31-91", 
        "https://www.zhihu.com/people/codingted", 
        "https://www.zhihu.com/people/yi-shu-24-53", 
        "https://www.zhihu.com/people/slichen", 
        "https://www.zhihu.com/people/feng-lin-tian-xia-18", 
        "https://www.zhihu.com/people/herongwei", 
        "https://www.zhihu.com/people/feng-wu-lei-yun", 
        "https://www.zhihu.com/people/liucen", 
        "https://www.zhihu.com/people/da-cheng-xiao-zhao", 
        "https://www.zhihu.com/people/Big_Rotor", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/sha-tian-cai-72", 
        "https://www.zhihu.com/people/ricardo-tian", 
        "https://www.zhihu.com/people/focussimple", 
        "https://www.zhihu.com/people/lucky-45-9-77", 
        "https://www.zhihu.com/people/yi-ling-79-31", 
        "https://www.zhihu.com/people/li-ying-97-91-47", 
        "https://www.zhihu.com/people/oier09wa", 
        "https://www.zhihu.com/people/xu-bing-lin-29", 
        "https://www.zhihu.com/people/liu-qi-10-14-98", 
        "https://www.zhihu.com/people/jiapengchen", 
        "https://www.zhihu.com/people/programjerry", 
        "https://www.zhihu.com/people/ju-shang-38", 
        "https://www.zhihu.com/people/zhimengrensheng", 
        "https://www.zhihu.com/people/tan-lei-13-5", 
        "https://www.zhihu.com/people/li-chang-long-56", 
        "https://www.zhihu.com/people/hlyu", 
        "https://www.zhihu.com/people/xue-hao-79", 
        "https://www.zhihu.com/people/le-le-42-76-8", 
        "https://www.zhihu.com/people/Zopen", 
        "https://www.zhihu.com/people/lichangke", 
        "https://www.zhihu.com/people/long-cheng-61-93", 
        "https://www.zhihu.com/people/bai-ma-ju-shi-69", 
        "https://www.zhihu.com/people/xi-xi-36-25-52", 
        "https://www.zhihu.com/people/lu-huan-cheng-40", 
        "https://www.zhihu.com/people/ruan-ruan-61-72", 
        "https://www.zhihu.com/people/li-rui-80-14", 
        "https://www.zhihu.com/people/chadhans", 
        "https://www.zhihu.com/people/yaoli-xu", 
        "https://www.zhihu.com/people/wty9sky"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/89943115", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第五十周", 
            "content": "<h2>左耳听风 第五十周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>BFS</b> 相关，以下为个人题解：</p><p>LeetCode695. 岛屿的最大面积</p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/cracking-the-data-science-interview/greedy-algorithm-and-dynamic-programming-a8c019928405\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Greedy Algorithm and Dynamic Programming</a>」（<b>贪婪算法和动态规划</b>）</p><p>在算法设计里没有「<b>银弹</b>」可以解决所有的计算问题。对于不同类型的问题我们需要使用不同的技术（算法）。而一个好的程序员能够基于不同类型的问题来使用他的技术。</p><p><b>贪婪算法</b>（也称贪心算法），就像它名字所暗示的那样，总是做当前状态下最好的选择，希望通过不断做最好的选择得到全局最优解。</p><p>贪婪算法的特点，只计算一次最优解，永不回退或反转决策。</p><p>贪婪算法的优势与难点：</p><ol><li>贪婪算法很容易想出。（不用像动态规划一样需要复杂的推导）</li><li>分析贪婪算法的时间复杂度远比「<a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E5%2588%2586%25E6%25B2%25BB%25E6%25B3%2595/2407337%3Ffr%3Daladdin\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">分治算法</a>」等更容易分析。</li><li>贪婪算法的难点在于，你很难正确的理解问题。很多时候，你并不能确定，你的问题是否该使用贪婪算法解题。</li></ol><p><b>Dynamic Programming 动态规划</b>，像是对「分治法」的一种模仿，同样是将一个大的问题，分解为一个个小问题，但是对于其中重复的子问题我们进行记录，避免重复计算。未来的结果受之前状态的影响，经典问题：最长增长子序列、最长公共子序列问题等。</p><p>二者的不同</p><p>贪婪算法不做重复选择，只考虑当下。而动态规划当下的决定受之前的影响，基于全局来考虑最优解。</p><h2>Tip</h2><p>下周要开始用公司的苹果电脑了，之前都是用的 Windows 系统，找了篇少数派的苹果电脑新手教程，可以作为入门指南。</p><p>「<a href=\"https://zhuanlan.zhihu.com/p/64983686\" class=\"internal\">Mac 电脑入门指南</a>」</p><h2>share</h2><p><a href=\"https://zhuanlan.zhihu.com/p/89814923\" class=\"internal\">一道面试题引发的思考</a></p><p>﻿好的面试官能够能好的和面试者互动，而一场好的面试也能带给面试者更多的思考。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89814923", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "一道面试题引发的思考", 
            "content": "<p>﻿好的面试官能够能好的和面试者互动，而一场好的面试也能带给面试者更多的思考</p><h2>面试题：有 N 个数，求能够组成最大值的 n-1 个数，不能使用除法</h2><p>面试官给我出题后的 1 分钟内，我给出了第一种思路：<b>排序</b>。</p><p>将数字按升序排序，去除最小的那个数即可。</p><p>存在问题：<b>时间复杂度高，只考虑了正数的情况</b>。</p><p>面试官给出了第一次提示时间复杂度过高，要求降低时间复杂度。</p><p>这里其实已经把思考的范围缩小了，因为之前的排序时间度大概为 O(nlogn) （可参照快排和归并排序均摊时间复杂度），那要降低的话就是 O(n) 了，即在线性的时间复杂度（遍历几次数组）就能获得答案。</p><p>于是在经过几分钟思考后，我给出了一个错误的 <b>动态规划</b> 的思路。</p><p>面试官进一步提示我：<b>这道题可以用很简单的方法解题，不用什么高深的算法。</b></p><p>于是我调整了一下思路继续思考问题，根据基本的几种情况进行了推导。</p><p>1、无负数情况下，取出最小值即可。</p><p>2、有负数情况下，根据负数的计数偶数个数来判断是取出，负数绝对值最小值，还是非负数绝对值最小值。</p><p>根据这个推断我们只需要一次遍历，记录负数个数，同时记录负数、非负数绝对值最小者。</p><p>于是我将思路讲给面试官，他笑了笑说，这个思路是对的，但是不能给我满分，要我再好好想一下，检查一下。</p><p>我知道，应该是有一些边界值还没有处理好，但是看了几分钟，还是没有找出问题。（人在紧张的情况下，思路会不太清晰）</p><p>于是，面试官指出了我面试中存在的问题，纯负数情况下，奇数个负数，应该排除绝对值奇数个，对于 0 这个边界值，也没有考虑到。一共应该是有 12 个分支，而我的代码只考虑了其中的 3、4 个（文章后面会画图解释）。</p><p>面试官进一步指导：<b>在实际的代码开发中，可能并不会用太多高深的算法，但是像这道题一样的简单问题却很常见，我们需要考虑代码的健壮性，上线的代码仅考虑到 90% 的情况是错误的</b>。</p><h2>问题复盘</h2><p>为什么是 12 个分支？ </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-312880bfcf1a6f70fa9e9204a783d8c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1335\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb\" width=\"1335\" data-original=\"https://pic4.zhimg.com/v2-312880bfcf1a6f70fa9e9204a783d8c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1335&#39; height=&#39;822&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1335\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1335\" data-original=\"https://pic4.zhimg.com/v2-312880bfcf1a6f70fa9e9204a783d8c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-312880bfcf1a6f70fa9e9204a783d8c3_b.jpg\"/></figure><p> 三个初始分支 n 个数都为非负数、n 个数有正有负、n 个数都为负数，以及 n 个数中是否存在 0，负数个数的奇偶个数 推导 3<i>3</i>2 = 12 个分支（0个负数视作偶数个，去除 2 个不存在情况，还剩 10 种需要考虑的情况）</p><p>实际可能出现的答案有三种：</p><p>1、无负数、有正有负且负数个数为偶数时，去除非负数绝对值最小者。</p><p>2、n 个数都为负数且负数个数个数为偶数时，去除负数绝对值最大者。</p><p>3、负数个数为奇数时，取负数绝对值最小者。（有正有负且存在 0，负数个数为奇数个可以去除任意非 0 数）</p><p>转换为实际代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/*\n</span><span class=\"cm\">    找出去除后集合乘积能达到最大的那个数\n</span><span class=\"cm\">*/</span>\n<span class=\"kt\">int</span> <span class=\"nf\">findMaxProductNum</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">minMinus</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MIN_VALUE</span><span class=\"o\">,</span> <span class=\"n\">maxMinus</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">minNum</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">,</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">boolean</span> <span class=\"n\">hasZero</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n         <span class=\"c1\">// 一次遍历，统计负数个数，并判断 0 是否存在，更新负数/非负数 最大/小 绝对值\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">count</span><span class=\"o\">++;</span>\n                <span class=\"n\">maxMinus</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">maxMinus</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n                <span class=\"n\">minMinus</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">minMinus</span><span class=\"o\">,</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">hasZero</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"n\">minNum</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">minNum</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">minNum</span> <span class=\"o\">?</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">:</span> <span class=\"n\">minNum</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">||(</span><span class=\"n\">count</span><span class=\"o\">&lt;</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">&amp;&amp;(</span><span class=\"n\">count</span><span class=\"o\">&amp;</span><span class=\"n\">1</span><span class=\"o\">)==</span><span class=\"n\">0</span><span class=\"o\">))</span> <span class=\"o\">{</span> <span class=\"c1\">// 无负数、有正有负且负数个数为偶数时\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span> <span class=\"n\">minNum</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">&amp;&amp;(</span><span class=\"n\">count</span><span class=\"o\">&amp;</span><span class=\"n\">1</span><span class=\"o\">)==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// n 个数都为负数且负数个数个数为偶数时\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span> <span class=\"n\">maxMinus</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span> <span class=\"c1\">// 负数个数为奇数时\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span> <span class=\"n\">minMinus</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p><b>这道题的目的是什么</b>？</p><p>考察一个求职者代码的健壮性，即能不能考虑全面，将问题的每个分支处理好。（可以先分解出输入的边界值，根据不同组合的分支推导结果。）</p><h2>总结</h2><p>1、 面试过程中，不要急于解题，要 <b>和面试官确认好问题的边界</b>。如果未明确，代码的健壮性就很有可能出现问题。</p><p>2、出错不要怕，好的面试官会引导你解题，<b>注意提出问题后面试官给出的提示</b>，这都是解题的方向。</p><p>3、几轮的面试是很累的，前一天做好休息，面试过程中 <b>不要太紧张</b>，会影响发挥，喝喝水调整下呼吸，放松下自己。</p>", 
            "topic": [
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }, 
                {
                    "tag": "面试技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19591490"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88765523", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第四十九周", 
            "content": "<h2>左耳听风 第四十九周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>双指针、排序贪心</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode633.%2520%25E5%25B9%25B3%25E6%2596%25B9%25E6%2595%25B0%25E4%25B9%258B%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode633. 平方数之和</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode345.%2520%25E5%258F%258D%25E8%25BD%25AC%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E4%25B8%25AD%25E7%259A%2584%25E5%2585%2583%25E9%259F%25B3%25E5%25AD%2597%25E6%25AF%258D.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode345. 反转字符串中的元音字母</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode524.%2520%25E9%2580%259A%25E8%25BF%2587%25E5%2588%25A0%25E9%2599%25A4%25E5%25AD%2597%25E6%25AF%258D%25E5%258C%25B9%25E9%2585%258D%25E5%2588%25B0%25E5%25AD%2597%25E5%2585%25B8%25E9%2587%258C%25E6%259C%2580%25E9%2595%25BF%25E5%258D%2595%25E8%25AF%258D.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode524. 通过删除字母匹配到字典里最长单词</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode347.%2520%25E5%2589%258D%2520K%2520%25E4%25B8%25AA%25E9%25AB%2598%25E9%25A2%2591%25E5%2585%2583%25E7%25B4%25A0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode347. 前 K 个高频元素</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode75.%2520%25E9%25A2%259C%25E8%2589%25B2%25E5%2588%2586%25E7%25B1%25BB.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode75. 颜色分类</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode455.%2520%25E5%2588%2586%25E5%258F%2591%25E9%25A5%25BC%25E5%25B9%25B2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode455. 分发饼干</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode435.%2520%25E6%2597%25A0%25E9%2587%258D%25E5%258F%25A0%25E5%258C%25BA%25E9%2597%25B4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode435. 无重叠区间</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode452.%2520%25E7%2594%25A8%25E6%259C%2580%25E5%25B0%2591%25E6%2595%25B0%25E9%2587%258F%25E7%259A%2584%25E7%25AE%25AD%25E5%25BC%2595%25E7%2588%2586%25E6%25B0%2594%25E7%2590%2583.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode452. 用最少数量的箭引爆气球</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode605.%2520%25E7%25A7%258D%25E8%258A%25B1%25E9%2597%25AE%25E9%25A2%2598.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode605. 种花问题</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode763.%2520%25E5%2588%2592%25E5%2588%2586%25E5%25AD%2597%25E6%25AF%258D%25E5%258C%25BA%25E9%2597%25B4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode763. 划分字母区间</a></p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//www.keycdn.com/blog/http-security-headers\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What I’m Telling  Business People  About Why Relational Databases Are So Bad</a>」（强化你的 HTTP 安全头）</p><p>我们只需要通过一些简单的 HTTP 安全头配置就可以提高我们 web应用的安全性，让我们来了解下 HTTP 安全头相关的知识吧。</p><p><b>HTTP 安全头是什么</b>？</p><p>当浏览器向服务器请求一个页面时，服务器会回应带有 HTTP 响应头的内容，包括：内容编码、缓存控制、响应状态等，这些都是 HTTP 安全头。HTTP 安全头告诉请求的浏览器，如何处理你的页面内容，例如使用严格传输安全，你可以强制浏览器使用 HTTPS 通讯。</p><p>七种不同的 HTTP 安全头：</p><p>Content Security Policy Header（内容安全策略头）：提供一个额外的安全层，同过定义网站内容的来源以帮助网站抵御<b>跨站脚本攻击、代码注入</b> 等网络攻击。</p><p>X-XSS-Protection Header （防跨站脚本攻击头）面对跨站脚本进行过滤，以保护网站的安全。</p><p>HTTP Strict Transport Security Header（HTTP 严格传输头）。采用 HTPPS 来传输内容，而不是通过有可能被感染的 HTPP 来传输内容建立连接。</p><p>X-Frame-Options Header 通过禁止网站的 iframes 加载来防止网站被挟持。</p><p>Expect-CT Header 通过记录和验证浏览器请求证书的合法性来保护网站安全。</p><p>X-Content-Type-Options Header 通过阻止浏览器的从已声明内容中窃取响应来阻止偷渡式下载，已确保内容的正确。</p><p>Feature-Policy Header 提供禁止嵌入框架的能力已保护网站。</p><p><b>如何验证我们的 HTTP 安全头</b>？</p><p>1、使用 KeyCDN’s HTTP Header Checker Tool 等验证工具来验证</p><p>2、使用谷歌浏览器的开发者工具来查看响应头</p><p>3、使用 <a href=\"https://link.zhihu.com/?target=http%3A//securityheaders.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">securityheaders.io</span><span class=\"invisible\"></span></a> 来查看我们的网站。</p><h2>Tip</h2><p><b>如何定位并优化慢查询 SQL？</b>（以 MySQL 数据库为例） 1、 <b>开启慢 SQL 日志，根据慢 SQL 日志定位慢 SQL 语句。</b><code>show variables like &#39;%quer&#39;%</code> 可查询数据库设置，看是否开启慢 SQL 日志服务以及相应的存储位置</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">set</span> <span class=\"k\">global</span> <span class=\"n\">slow_query_log</span><span class=\"o\">=</span><span class=\"k\">on</span><span class=\"p\">;</span> <span class=\"o\">#</span> <span class=\"err\">开启慢</span> <span class=\"k\">SQL</span> <span class=\"err\">日志</span>\n<span class=\"k\">set</span> <span class=\"k\">global</span> <span class=\"n\">long_query_time</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"o\">#</span> <span class=\"err\">设置慢</span> <span class=\"k\">SQL</span> <span class=\"err\">时间，即查询时间超过阈值则记录在日志</span></code></pre></div><p>2、<b>使用 explain 等工具分析 SQL</b> 使用 <code>show status like &#39;%slow_queries%&#39;;</code> 查看慢 SQL 语句数量，然后打开本地的慢 SQL 日志文件。使用 <code>explain SQL 语句</code> 来分析我们的 SQL 语句。</p><p>3、<b>修改 SQL 语句或让 SQL 使用索引</b>。针对 explain 分析的 SQL 语句问题，添加索引或修改 SQL 语句，进行相应的 </p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/87611318\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-9a2faf2712d7673d07234603d795d045_180x120.jpg\" data-image-width=\"3022\" data-image-height=\"2014\" class=\"internal\">胡sir：你有在深度工作吗？</a><p>经历了几个月的面试，从线上面试到线下宣讲会、招聘会的面试大都体验了一遍，这其中也遇见了一些令我很是讨厌的招聘。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88750719", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "我所讨厌的一些招聘", 
            "content": "<p>﻿经历了几个月的面试，从线上面试到线下宣讲会、招聘会的面试大都体验了一遍，这其中也遇见了一些令我很是讨厌的招聘。</p><h2>挂羊头卖狗肉式</h2><p>在招聘的过程中，最讨厌的一种招聘方式就打着「管培生」的名义，让学生去做柜员或者销售的工作，成为真柜员假「管培生」。</p><p>以我在某银行支行来学校的校招为例，招聘少量的科技岗、管理岗人才，但是在我面试 IT 技术岗工作时，问的都是非技术性问题，而在面试结束的最后，反而问你 <b>是否愿意先在乡镇一级的业务岗（实际就是银行柜员）先工作 2 年，后面再进行调岗</b>（当时有同学表示愿意，招聘人员要求直接向乡镇一级投递简历）。而我，不太能理解这种技术岗要在乡镇做两年接待人员的行为，至少我不认为这对技术人员的成长有任何帮助。</p><p>后来在「 仙人JUMP」的文章「<b>银行管培生的人生美梦，该醒醒了</b>」找到了一种很大的可能。银行的柜员或大堂经理很难吸引 985、211 或是一般本科院校的优质学生，直接以「银行柜员」等岗位去招聘，很难招到需要的人，毕竟高素质人才做业务效率也会相对更高。换成「管培生」的名义就不一样了，宣传一下管培生的美好的职业发展，年薪几十万，迎娶白富美。<b>但是，事实真是如此吗</b>？要成为管理层，当然要去基层了解下各个环节的业务，签个协议，至少要在柜员等岗位待满两年，后期看个人能力进行晋升，听起来好像没什么毛病。可是，去了乡镇一级做柜员，你要怎样才能调回来呢？做的好，乡镇一级不让你走，做的不好，市一级又为什么要你呢？</p><p>类似于这样的要在基础岗待满几年的岗位需求，有多少是工作需要，有多少是职业陷阱，真的有待考究。但是，无论如何，你的工作必须要对你今后的职业成长有所帮助，不然你怎么和其他人进行竞争呢？</p><h2>不明确工作内容和岗位需求</h2><p>在非互联网公司，这种情况尤为常见：<b>仅写一个模糊的工作岗位</b>，例如：计算机、程序员、IT 类人才。<b>没有任何具体的岗位介绍，甚至可能没有具体的岗位需求</b>。没有具体的岗位需求，透露出的是公司也不知道要招什么样的人，而没有任何具体的岗位介绍，很可能你的工作没有边界，即什么事情都要做。</p><p>以我参加的一场传统企业的线下校招为例。在招聘岗位中有一个 IT技术岗，具体的岗位是软件开发或算法工程师，在线下、线上到最终的网申环节中都没有任何对于这个岗位的进一步描述 <b>没有任何具体的岗位介绍，也没有具体的岗位需求</b>。然后在初试的两轮面试中没有任何关于技术的问题，反而面试官（不懂技术）问了一个奇怪的问题：公司的 IT 人员经常会同时接到好几个部门的电话，要处理一些电脑故障，你怎么处理（<b>这不就是修电脑吗</b>？）。虽然，技术人员偶尔帮助同事处理下电脑故障并不是什么问题，但是这并应该是一个开发者的主要工作，难道公司要用程序员的工资来招一个的硬件维护人员？</p><p>在后序的过程中，更是出现了魔幻的一幕，在初试通过后，面试官说因为是 IT岗，要公司的 IT负责人在给我进行一轮技术面试，通过后基本就可以发入职 offer。后来因为技术负责人有事无法来校招现场面试就加了负责人微信，回去等通知了。走了没多久出现了下面的对话： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-593f3ccb250c3ff832e62b3728416ba9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1479\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-593f3ccb250c3ff832e62b3728416ba9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-593f3ccb250c3ff832e62b3728416ba9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-593f3ccb250c3ff832e62b3728416ba9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>两个问题：</p><p>1、没有在一开始讲出自己的岗位需求。如果知道是做运维我不会去面试（实际上很大程度是修电脑）。</p><p>2、对于开发岗有学历要求并没有表明，而是在最后一轮才表示，浪费彼此时间。</p><p>而这样的面试对于面试者来说并没有任何意思，还耽误了几场面试的时间。</p><h2>一些求职经验</h2><p>在面试前，通过互联网、内部工作人员对公司进行了解，筛选掉不合适的公司，提高面试成功的概率。</p><p><b>看清楚公司岗位的需求，做出相应的准备。</b>网上也有很多面经和对应岗位的常见面试题，提前了解可以让你在面试的时候发挥的更好。</p><p><b>个人能力是硬道理。</b>工作其实也是一个双向选择，公司选择你，还是你选择公司，取决于你是否有足够的能力让你的面试官青睐。</p>", 
            "topic": [
                {
                    "tag": "招聘", 
                    "tagLink": "https://api.zhihu.com/topics/19578758"
                }, 
                {
                    "tag": "秋招", 
                    "tagLink": "https://api.zhihu.com/topics/20075475"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87611745", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十八周", 
            "content": "<h2>左耳听风 第四十八周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>字符串、数组、哈希表</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode202.%25E5%25BF%25AB%25E4%25B9%2590%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode202.快乐数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode204.%2520%25E8%25AE%25A1%25E6%2595%25B0%25E8%25B4%25A8%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode204. 计数质数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode55.%2520%25E8%25B7%25B3%25E8%25B7%2583%25E6%25B8%25B8%25E6%2588%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode55. 跳跃游戏</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode54.%2520%25E8%259E%25BA%25E6%2597%258B%25E7%259F%25A9%25E9%2598%25B5.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode54. 螺旋矩阵</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode56.%2520%25E5%2590%2588%25E5%25B9%25B6%25E5%258C%25BA%25E9%2597%25B4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode56. 合并区间</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode58.%2520%25E6%259C%2580%25E5%2590%258E%25E4%25B8%2580%25E4%25B8%25AA%25E5%258D%2595%25E8%25AF%258D%25E7%259A%2584%25E9%2595%25BF%25E5%25BA%25A6.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode58. 最后一个单词的长度</a></p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/free-code-camp/code-comments-the-good-the-bad-and-the-ugly-be9cc65fbf83%3Fsource%3Dsearch_post---------6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What I’m Telling  Business People  About Why Relational Databases Are So Bad</a>」（在代码中添加注释：好的、坏的以及丑陋的）</p><p>注释可以分为两类：</p><p>一类是文档注释，用于 API 文档，方便开发者在使用代码库或框架，根据特定的语法规则写在代码中由特定的工具抽取生成。</p><p>另一类是说明注释，方便维护、重构或扩展代码。而这类代码的注释的好坏直接影响后来者的工作，好的注释能够帮助维护，而坏的注释会让后续的工作变得困难以至于根本不愿意去维护代码。</p><p>作者认为，注释其实是代码的一种气味，当<b>你的注释写的又长又晦涩难懂时，说明你的代码过于复杂</b>，这时你就要考虑是否要重构你的代码，让代码简化（通常搞复杂度 = 更多的 BUG）。</p><p>好的代码：帮助我们解释易混淆的代码，帮助我们理解代码。</p><p>坏的代码：让代码的理解变得更为复杂，使代码看起来一团乱。</p><p>丑陋的代码：没有意义的代码出现在生产线，可能是对开发过程的吐槽或是对长期加班的不满，这些可以写在自己的电脑里，但是不应放在上线的代码中，干扰别人的情绪对代码产生误解。</p><p><b>总结</b>：不要写没有意义的注释，让代码替你说话，只有当代码无法直接表达你的意图时，我们才需要注释。</p><h2>Tip</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f672c5740101e042a5eb08f252541147_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1391\" data-rawheight=\"819\" class=\"origin_image zh-lightbox-thumb\" width=\"1391\" data-original=\"https://pic4.zhimg.com/v2-f672c5740101e042a5eb08f252541147_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1391&#39; height=&#39;819&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1391\" data-rawheight=\"819\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1391\" data-original=\"https://pic4.zhimg.com/v2-f672c5740101e042a5eb08f252541147_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f672c5740101e042a5eb08f252541147_b.jpg\"/></figure><p> 数据库方面的知识是后端面试中必考的，我们可以通过事务的特性来推导出事务并发处理异常和事务的隔离级别（不死记概念）。</p><p>事务的四大特性简称为 ACID，对应着：</p><p><b>原子性、一致性、隔离性</b> 以及 <b>持久性</b>，而事务的并发异常正是破坏事务的几个特性，如：<b>脏读</b>，读出了未提交的数据，正是破坏了事务的 <b>原子性</b>。而事务的隔离级别正是针对于三种异常来的，在 <b>读未提交</b> 的情况下，可能出现三种并非异常，读已提交保证了事务的原子性，则 <b>脏读</b> 异常被消除，而隔离级别最高的 <b>可串行化</b> 在牺牲事务的并发效率的情况下消除了所有的并发异常。</p><p>不应死记某个答案，而是应该理解思想，去学习答案是如何推导的。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/87611318\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-9a2faf2712d7673d07234603d795d045_180x120.jpg\" data-image-width=\"3022\" data-image-height=\"2014\" class=\"internal\">胡sir：你有在深度工作吗？</a><p>网络似乎剥夺了我们专注以及沉思的能力？许多人因快速地收发电子邮件和在社交媒体上发信息所带来的繁忙假象而慰藉，而 <b>深度工作</b> 却是要我们摆脱这些。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87611318", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "你有在深度工作吗？", 
            "content": "<p>﻿前言 ： <b>深度工作并不是适合所有人</b>。你需要为此付出艰苦的努力，从根本上改变你的 。对于很多人来说，快速地收发电子邮件和在社交媒体上发信息所带来的繁忙假象会给他们带来慰藉，深度工作却是要你摆脱这些东西.</p><h2>什么是深度工作？</h2><p><b>深度工作</b> 的定义 ： <b>在无干扰状态下进行专注的职业活动， 使个人的认知能力达到极限</b>。</p><p>有 <b>深度工作</b> 自然也有其对应的反面 —— <b>浮浅工作</b> （对认知要求不高的事务性任务 ， 往往在收到干扰的情况下开展。 此类工作通常不会为世界创造太多新的价值 ， 且 <b>容易复制</b>）。</p><p>而在当下网络工作时代，我们大多数人越来越多的陷入的肤浅工作，那这样的变化会给我们带来什么呢？你又是否有意识到呢？</p><p>在《深度工作》一书中指出： 越来越多的证据表明向 <b>浮浅工作</b> 发展的趋势并不是很容易转变的， 越是过多的陷入浮浅工作越是难以找到 深度工作的感觉， 这将 <b>永久性的降低我们深度工作的能力</b>。</p><p>而在实际生活中， 抖音、微博、知乎 等应用，让我们很轻易的脱离工作状态。 而且这类产品的算法比我们自己还了解自己的喜好， 推送给我们的视频等内容都是我们这类人最喜欢的内容。 我们总是能发现， 这类产品让我们不经意间耗费了大量的时间。想想每年这些大厂所招聘的人都是什么水平，而他们的工作就是想方设法让我们在应用山花费更多的时间。</p><p>网络似乎剥夺了我们专注以及沉思的能力 ？</p><h2>如何找回我们的专注力</h2><p>首先， <b>找到你想要提升的某方面的技能或是某种学科理论</b> ， 在接下来的时间中将自己的注意力投入其中。 （ 先明确目的能够极大的提高你的专注力， 很多时候目标过多更容易让你迷失方向 ）</p><p>其次， 你要 <b>在你投入的方面得到反馈</b>。 因为不同时期你需要使用的学习方法是不同的。 例如学习编程， 在初期你啃书或是看视频的效果可能会非常好， 但在你专注一段时间以后， 你会发现如果开始写一些综合型的项目更有利于你在某一编程语言上得到提高。 所以， 我们需要间隔的调整我们的方法， 从而让注意力的投入达到产出最佳化。 </p><p>在学习的过程中， <b>和你朋友或是更优秀的人分享你的方法经历</b>，从中收到正反馈， 一方面可以让你更合理化的调整自己的方法， 另一方面也让你吸收到更多的正能量进入下一轮的深度工作， 以此形成正循环来提高自己。</p><p><b>培养允许坏的小事发生的习惯</b>。 否则， 你将永远无法发现改变命运的大事。 生活中小问题不断， 如果你的情绪总是被这种小问题影响 例如 丢了支笔、弄脏了件衣服。 这就让你变的气急败坏， 一整天抱怨， 那你就很难关注更大的事， 别人也不敢让你负责更为重要的事。</p><p>如果你想抵御娱乐网站对你时间和精力的诱惑， 那么就给大脑找一些高质量的替代活动。 以此体验到 <b>何为生活， 何为生存</b>。</p><p>如果你愿意 <b>跨过这些舒适区和恐惧</b>， 将自己的头脑发挥到极致， 创造出有价值的东西你将会和前人一样发现深度工作能够造就富有效率和意义的生活。</p><p>诚然，<b>深度学习或深度工作 并非是我们个人发展中唯一有价值的技能</b>， 不培养这种能力可能我们也可以将事情做的很好， 但是以目前自动化不断取代重复劳动的趋势来看不需要深度工作的职业只会越来越少。 除非你的工作领域中分散精力会让你的工作做的更好。</p><p>文章内容出自《<b>深度工作</b>》一书的摘录，如果这篇文章读完对你有所启发，推荐你去阅读原书，更系统的学习深度工作的理念。</p>", 
            "topic": [
                {
                    "tag": "深度工作（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20126424"
                }, 
                {
                    "tag": "高效工作", 
                    "tagLink": "https://api.zhihu.com/topics/19550928"
                }, 
                {
                    "tag": "工作", 
                    "tagLink": "https://api.zhihu.com/topics/19588006"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84892426", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十七周", 
            "content": "<h2>左耳听风 第四十七周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>栈</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode84.%2520%25E6%259F%25B1%25E7%258A%25B6%25E5%259B%25BE%25E4%25B8%25AD%25E6%259C%2580%25E5%25A4%25A7%25E7%259A%2584%25E7%259F%25A9%25E5%25BD%25A2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode84. 柱状图中最大的矩形</a></p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//codeburst.io/what-im-telling-business-people-about-why-relational-databases-are-so-bad-6f38d3d6c995\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What I’m Telling  Business People  About Why Relational Databases Are So Bad</a>」（我要告诉商人们关系型数据库如此糟糕的原因）</p><p>作者在文章中讲述了关于「关系型数据库」糟糕的几个原因：</p><p>1、存在 「SQL 注入」等隐患，谷歌等大型企业每天要遭受大量的SQL 注入攻击。许多企业也因此损失了大量的金钱。</p><p>2、因关系数据库的数据存储方式，我们存取数据时需要大量的连接操作，这种连接操作总是大量重复的，这并不符合 DRY（ Don&#39;t repeat youself ）原则，而数据连接带来的是程序的复杂性、无序性的上升，在软件开发中这等于错误的增加。</p><p>对于关系型数据库的连接操作，有一个形象的比喻，主人把车开回家，把车的零件拆下来挂在墙上，第二天早上起来上班前再把零件装回车上，再开车上班。（重复不必要的工作）</p><p>这篇文章的大部分观点，我并不是很认同，许多观点比较片面，不过在评论区有一则非常不错的<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40vlad_ko/sql-injections-arent-caused-by-the-relational-databases-they-are-a-byproduct-of-poor-quality-of-2deb1a4ac625\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">评论</a></p><p>该评论者的观点如下：</p><p>1、「SQL 注入」并不只存在于关系型数据库，非关系型数据库也存在「SQL 注入」问题。</p><p>2、单纯说 好/坏 并没有任何实质意义，我们需要的不仅是提出问题，更重要的是能够实际解决问题的方案。</p><p>3、关系型数据库从目前的应用来看并没有太多的不好，教育、医疗、金融服务等应用中都有对关系型数据库的使用，每天有数百万人因使用关系型数据库而收益。</p><p>4、事情不是好是坏，而是事实</p><h2>Tip</h2><p>数据库列名与实体类属性名不一致解法方法：</p><p>方法1：对数据库查询的列名取别名，直接在数据库层面解决问题</p><p>方法2：在 XML 配置文件中配置 resultMap 对实体类属性与列名进行映射 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4e47baba594c4495a8db8d2fa4bb310b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"731\" data-original=\"https://pic4.zhimg.com/v2-4e47baba594c4495a8db8d2fa4bb310b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;731&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"731\" data-original=\"https://pic4.zhimg.com/v2-4e47baba594c4495a8db8d2fa4bb310b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4e47baba594c4495a8db8d2fa4bb310b_b.jpg\"/></figure><p><b>差异</b>：</p><p>前者，效率更高但是对每一条 SQL 查询语句都需要修改别名更繁琐，可以利用视图机制来解决</p><p>后者，效率相对更低，但是一次定以后对每一条查询都可用</p><h2>share</h2><p>阿德勒心理学认为每个人的烦恼都指向【人际关系】问题。而解决问题的方法在于正确认识自己，将自己与他人的课题分离。</p><p>如何正确认识自己呢？接受自己的不完美，承认自己在某些方面并不比别人更好，正视自己的不足，不应和别人比较好坏，而应该和自己比较，看看自己比一年前、一个月前有什么变化，是变好还是变化了，正确看待自己才是我们解决自身烦恼的关键。</p><p>如何分离自己和他人的课题。遇到问题，先从自己身上寻找答案，无法改变他人也不能改变他人的行为和思想，不将自己的意志强加于他人。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83632576", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 2, 
            "title": "左耳听风 第四十六周", 
            "content": "<h2>左耳听风 第四十六周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>动态规划</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode53.%2520%25E6%259C%2580%25E5%25A4%25A7%25E5%25AD%2590%25E5%25BA%258F%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode53. 最大子序和</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode62.%2520%25E4%25B8%258D%25E5%2590%258C%25E8%25B7%25AF%25E5%25BE%2584.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode62. 不同路径</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode63.%2520%25E4%25B8%258D%25E5%2590%258C%25E8%25B7%25AF%25E5%25BE%2584%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode63. 不同路径</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode64.%2520%25E6%259C%2580%25E5%25B0%258F%25E8%25B7%25AF%25E5%25BE%2584%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode64. 最小路径和</a></p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40lydiahallie/advice-from-a-19-y-o-girl-software-developer-88737bcc6be5\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Advice From A 19 Year Old Girl &amp; Software Developer</a>」（来自 19 岁的女孩 &amp; 软件开发者的建议）</p><p>作者是一名 Instagram 的网红女程序员（@theavocoder）</p><p>在文章中她介绍了自己成为程序员的历程。在 15 岁时接触 JavaScript，在 18 岁大学毕业后没有选择去上大学而是下定决心学习编程，一个人去陌生的城市参加培训，却在三个月的培训后收到了来自领英的几家公司的面试邀请。对于大多数公司：<b>他们关注的是你的编程能力，以及你是否热爱编程</b>。<b>而这些并不是只在学校能学习到的</b>。</p><p>同时作者也给出了自己工作之余的时间安排。</p><p><b>每天至少看两个小时的编程网络课</b>。通过网络课程学习新的技术，跟着视频课中的代码进行项目实战。与课程教授的项目相似，却有着细微的不同，在学习项目结构设计的同时，感受自己的创造力。</p><p><b>在自己的个人项目上工作至少 4 个小时</b>。因为要使用自己从未使用的技术或编程语言，这可能会让你感到非常不适，但是当你坚持做下来，你所做的那部分工作一定会让你有所收获，体验到更多不同的东西。当然这个过程中你可能会遇到许多问题，你可以在 <b>Stack Overflow</b> 写下你的问题，并尝试不同的解决方法，直到你找到正确的答案，当你完成这一个过程，你会发现，你已学了不少，之前的问题已经难不倒你了。</p><p><b>看至少两个小时的文章</b>。可以是不同方面，是解决某一类型的问题 or 最酷的新技术是什么？ 什么文章并不重要，重点在于保持学习的心态。</p><p><b>尝试解决 5 个 CodeWar（类似于 LeetCode） 问题</b>。改善你的代码质量，让你学会代码审阅，同时学习别人的代码和思路。</p><p><b>尝试不吃垃圾食物</b>。吃健康的食物会让你更有精力，同时也能让你更开心。更好的精力会让你编程更有动力，可以直接改善你的编程能力，从长远来看，这也能改善你的身体和头脑，使你更好的编程。</p><p>让工作和休息达到一种平衡，我们大多数人都是普通人，而不是超人不需要休息。</p><p>作者的结论：</p><p>1、当你真正决定不去上大学，投入你所有的激情去编程。</p><p>2、无论何时，当你能做到时，去做的更好。</p><p>3、把健康放在首位，休息非常重要。</p><p>4、提醒自己走了多远。试试和一个月前的自己比较下。</p><p>5、不要因为别人的言论便觉得自己的编程语言不好。</p><h2>Tip</h2><a href=\"https://zhuanlan.zhihu.com/p/83570390\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-96fc410e60335afbd7049b108520c7ab_180x120.jpg\" data-image-width=\"900\" data-image-height=\"383\" class=\"internal\">胡sir：GitHub / 码云 Pages 打造个人在线简历</a><p>前期准备：一个 GitHub / 码云的账号、git 基础命令使用、html 基础</p><h2>share</h2><p>最近看了 吴军博士 的《见识》一书，数中的一章讲的是「<b>先让父母成熟起来</b>」。</p><p>这是我们以前可能没有考虑过的，许多人抱怨自己受家庭的影响没有收到良好的教育、性格不好、起点比别人低，于是在我们接收更多新事物，接受更高层次的教育后，我们开始「嫌弃」父母，觉得他们思想陈旧，见识短浅，越来越少的和他们交流，甚至总是因为一些观念问题而争吵。</p><p>有多少中国式家庭的孩子有想过「<b>让父母成熟起来</b>」。父母们呆在七八线的小县城或是乡村，每日只有工作和电视，甚至有一部分不会使用微信，不会上网看新闻。我们是不是应该在他们对这个时代的科技发展感兴趣时为他们提供一些帮助，让他们也能在这个时代进行一些成长呢？</p><p>很多时候父母并非不想与我们交流，而是他们的并了解我们的世界，除了日常琐事、人情世故外，他们没有任何熟知的领域与我们有关。</p><p>那我是不是应该主动建立起沟通的桥梁，让这些与我们更亲近的人对我们的生活或者圈子更多些了解呢？例如：帮他们在手机里装起微信，教他们如何看我们的朋友圈，如何发语音发视频，给他们讲讲自己在看的书籍，给他们装上一些可以了解互联网的 App（网易新闻、哔哩哔哩等），让他们在这个飞速发展的信息时代得到一些成长，也让他们和我们多一些可以沟通的话题。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83570390", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "GitHub / 码云 Pages 打造个人在线简历", 
            "content": "<p>﻿效果展示 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7338afd212d0c1c4585e92af2b5d1e9c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1605\" data-rawheight=\"1258\" class=\"origin_image zh-lightbox-thumb\" width=\"1605\" data-original=\"https://pic1.zhimg.com/v2-7338afd212d0c1c4585e92af2b5d1e9c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1605&#39; height=&#39;1258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1605\" data-rawheight=\"1258\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1605\" data-original=\"https://pic1.zhimg.com/v2-7338afd212d0c1c4585e92af2b5d1e9c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7338afd212d0c1c4585e92af2b5d1e9c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>前期准备</h2><ol><li>注册好 Github / 码云 账号，创建好 1 个仓库（名字自取，可以和我一样用 <b>resume</b>）</li><li><b>1 个静态的简历网页模板</b>。你可以直接 clone 我的模板，<a href=\"https://link.zhihu.com/?target=https%3A//gitee.com/hackhu96/resume\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">码云地址</a>：<code>https://gitee.com/hackhu96/resume</code> 、<a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/resume\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub 地址</a>：<code>https://github.com/hackhu2019/resume</code>，或者自己 DIY 一个简历网页，其他资源：<code>https://gitee.com/cool-resume?from=weekly-82</code> 码云优秀求职简历展示，你可以在里面选择一个自己喜欢的进行修改。</li><li><b>Git 基本命令的使用</b>，git init（初始化 git 仓库）、git clone（克隆现有仓库）、git add（暂存已修改文件）、git commit（提交变更） 、git remote add（添加远程仓库）、git push（数据推送）</li></ol><h2>修改简历，推送至 GitHub / 码云仓库</h2><p>下载好 / 制作好简历模板后，我们需要针对自己的需要对简历模板进行修改，至少 <b>不能在自己的简历信息中出现别人的内容 / 链接</b>。</p><p>注意，clone 我简历项目的朋友，要记得修改 index.js 中的内容，把链接替换成你的博客链接或者删除 html 中对 js 文件的引入。</p><div class=\"highlight\"><pre><code class=\"language-text\">window.onload = function(){\n    console.log(&#34;感谢您的浏览，期待能够加入贵公司！我的 GitHub：https://github.com/hackhu2019&#34;); // 我的链接，记得修改\n}</code></pre></div><blockquote> Pages 是一项网站托管服务，将静态网页托管。简单说就是帮我们展示静态网页。<br/> </blockquote><p>推送到 GitHub / 码云仓库后，我们要做的就是开启 GitHub Pages/ 码云 Pages</p><p>码云 Pages 开启： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f41a23e6128742c184107fe1d696dde4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1610\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"1610\" data-original=\"https://pic1.zhimg.com/v2-f41a23e6128742c184107fe1d696dde4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1610&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1610\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1610\" data-original=\"https://pic1.zhimg.com/v2-f41a23e6128742c184107fe1d696dde4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f41a23e6128742c184107fe1d696dde4_b.jpg\"/></figure><p> 根据提示开启服务。简历的网址通常为：https:// 你的用户名.<a href=\"https://link.zhihu.com/?target=http%3A//gitee.io/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">gitee.io/</span><span class=\"invisible\"></span></a> 仓库名称。你可以将网址转换为二维码，放在你的纸质简历上，方便面试官扫描查阅。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a9592cac4bd6a0458b77bc8197ec69d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"963\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb\" width=\"963\" data-original=\"https://pic2.zhimg.com/v2-a9592cac4bd6a0458b77bc8197ec69d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;963&#39; height=&#39;642&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"963\" data-rawheight=\"642\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"963\" data-original=\"https://pic2.zhimg.com/v2-a9592cac4bd6a0458b77bc8197ec69d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a9592cac4bd6a0458b77bc8197ec69d5_b.jpg\"/></figure><p> Github开启 Pages </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e95bd6f823a430b57e4106d0351e7611_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"894\" class=\"origin_image zh-lightbox-thumb\" width=\"1248\" data-original=\"https://pic2.zhimg.com/v2-e95bd6f823a430b57e4106d0351e7611_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1248&#39; height=&#39;894&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"894\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1248\" data-original=\"https://pic2.zhimg.com/v2-e95bd6f823a430b57e4106d0351e7611_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e95bd6f823a430b57e4106d0351e7611_b.jpg\"/></figure><p> 进入仓库设置，找到 Github Pages 一栏，修改设置，将 Source 项由 None 改为 master branch。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c4ce5644ca6386122a472e6cc8e9e04a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1015\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb\" width=\"1015\" data-original=\"https://pic3.zhimg.com/v2-c4ce5644ca6386122a472e6cc8e9e04a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1015&#39; height=&#39;574&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1015\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1015\" data-original=\"https://pic3.zhimg.com/v2-c4ce5644ca6386122a472e6cc8e9e04a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c4ce5644ca6386122a472e6cc8e9e04a_b.jpg\"/></figure><p> 页面刷新后，会给出你的简历网址，通常为：https:// 你的用户名.<a href=\"https://link.zhihu.com/?target=http%3A//github.io/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.io/</span><span class=\"invisible\"></span></a> 仓库名称。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f8a919c86ec38cbec14077dac68ac4fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"969\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb\" width=\"969\" data-original=\"https://pic3.zhimg.com/v2-f8a919c86ec38cbec14077dac68ac4fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;969&#39; height=&#39;716&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"969\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"969\" data-original=\"https://pic3.zhimg.com/v2-f8a919c86ec38cbec14077dac68ac4fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f8a919c86ec38cbec14077dac68ac4fe_b.jpg\"/></figure><p> 这时你就可以愉快的输入你获得的简历网址进行网址了，通常来说 <b>码云的内容在国内访问会更流畅些</b>，如果你想让别人浏览时有更好的体验可以考虑优先放在码云的仓库里。</p>", 
            "topic": [
                {
                    "tag": "简历", 
                    "tagLink": "https://api.zhihu.com/topics/19560329"
                }, 
                {
                    "tag": "GitHub", 
                    "tagLink": "https://api.zhihu.com/topics/19566035"
                }, 
                {
                    "tag": "Github Pages", 
                    "tagLink": "https://api.zhihu.com/topics/19792731"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82593408", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十五周", 
            "content": "<h2>左耳听风 第四十五周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>并查集</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode200.%2520%25E5%25B2%259B%25E5%25B1%25BF%25E6%2595%25B0%25E9%2587%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode200. 岛屿数量</a></p><h2>review</h2><p>「<b><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40hanilim/http-codes-as-valentines-day-comics-8c03c805faa0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTP codes as Valentine’s Day comics</a></b>」 把 HTTP 代码看做情人节漫画</p><p>这是一篇有趣的文章，作者以漫画的形式展现了 HTPP 4 类状态码的不同含义。</p><p><b>1、200，快乐的结束</b>。状态码 200 通常代表一切 OK，请求被解释且正确解释，在服务端没有发生任何错误。</p><p><b>2、300，重定向</b>。状态码 300 最常出现在搜索引擎的搜索结果。301，代表永久的移动，就像是搬家到了新地方。302、303、307 都代表着暂时的移动。304 代表重定向的资源未改变，浏览器可以根据缓存资源减少不必要的请求，不用重复向服务器请求资源。</p><p><b>3、400，客户端错误</b>。可能是浏览器或者 URL 错误。401，未授权请求，服务端无法识别客服端身份。403，服务被拒绝。404，资源未找到，也是最著名的 HTTP 错误代码。407 需要代理才能访问服务器，就像是谈恋爱，需要对方父亲的允许。408，响应超时，服务端等待很久却未收到完整的请求信息。409，请求冲突，该资源正在被其他人访问。410，资源永远移除。</p><p><b>4、500，服务端错误</b>。502 网关错误，网关无法解析服务端的响应。502，服务端暂时不可用。504，网关超时，服务端响应时间过长，网关放弃等待。</p><h2>Tip</h2><p>压力测试：使用 Apache ab 测试工具模拟压力测试，检测自己的并发处理是否正确。</p><p>下载地址：<a href=\"https://link.zhihu.com/?target=https%3A//www.apachehaus.com/cgi-bin/download.plx\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">apachehaus.com/cgi-bin/</span><span class=\"invisible\">download.plx</span><span class=\"ellipsis\"></span></a></p><p>安装步骤：<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/crazycoderl/p/7799216.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/crazycoderl</span><span class=\"invisible\">/p/7799216.html</span><span class=\"ellipsis\"></span></a></p><p>测试方法：启动 Apache2.4 服务后 在命令行输入以下命令 <code>ab -n 100 -c 100 http://www.baidu.com/</code> </p><p>ab 为测试工具名称缩写</p><p>-n 指请求次数 （可用 -t 请求时间 -秒  替换）</p><p>-c 指并发数</p><p>http:// */  * 代表要测试的 域名 / IP 地址</p><p>后面还可以再接上请求的参数。在单一模块完成后，可以用 Apache ab 测试工具来简单测试下我们并发的代码是否有误，比手动测试更贴近实际场景，也更容易找出错误。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/82576863\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8ada40744e8eee57642ea06abd6d994c_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2730\" class=\"internal\">胡sir：同学喊我去创业</a><p>大学时期的创业太玄，没有任何特别的资源和优势不如好好学一学真正对以后有帮助的东西，例如：精通任意一名编程语言。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82576863", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "同学喊我去创业", 
            "content": "<p>﻿故事背景：</p><p>同学 A：我想组建一个 IT 技术团队，做个项目，你或者你同学有没有感兴趣的？</p><p>我心里想：现在还有人想着学生创业，难道是个技术大佬自己做项目？</p><h2>了解清楚再下判断</h2><p>突然有人找上门说要创业，还是挺唬人的（主要还是经历的少），想着 <b>先了解下情况再做判断</b>。</p><p>于是先问了以下几个问题： 1. 所做的项目是什么？ 2. 项目目前的进度是怎样？ 3. 项目的主要负责人，以及目标市场是什么？</p><p>同学 A 第一个问题的回答中规中矩，介绍了下自己项目是要做一个 C2C 的服务平台。</p><p>在回答第二个问题，「项目进度」时，问题出现了。项目只是做了简单的 <b>市场调研</b>（似乎只是在朋友圈发了个问卷调查），写了一份我没见到的项目计划书，然后团队成员已有 7 人？</p><p>从这里可以看出这个创业项目的几个问题：</p><p><b>成员过多，成本过高</b>。项目未正式启动，就 7 个成员，即使是学生每个月兼职也是有收入的，把 兼职/ 娱乐 的时间投入创业也是一种成本。以最低的每月 2000 来算，团队一个月就需要承担 1.4 万的人力成本。</p><p><b>以理想状态假设</b>，团队不再招人，无任何其他支出，项目半年后开始盈利（团队成员已经每人投入 0.2 * 6 =1.2 万），平台每月收入为 2 万，扣除人力成本 2 - 1.4 = 0.6，平分到个人 0.6/7 每个人每月盈利不到 1 千，每个人的投入成本为 1.2 / 0.1 = 12 个月，则团队成员每个人在项目发展最理想且不再支出任何其他项目的情况下，1.5 年才能开始赚钱，每个月 1 千不到。<b>这样的创业是你想要的那种吗？</b></p><p><b>任务分配不均</b>。一个项目计划书，一个人就能写，小规模的「<b>市场调研</b>」，1~3 人就足够了，剩下的 3 个团队成员干什么？大家做着不同程度的事，最后怎么分配利润？<b>想一想你愿意给多少人分钱，再考虑你要招多少人</b>。</p><h2>不单凭感觉做事</h2><p>接下来我又问了同学 A ：项目的技术负责人是谁？</p><p>同学 A ：目前没有技术负责人。计划的是从小程序入手，快速获客。目前团队需要技术人员完成项目的开发。</p><p>我：推荐你去淘宝上购买现成的平台类项目，这样的项目现在已经比较成熟了，也不贵。</p><p>同学 A：想要自己组建团队开发项目，保证开发程序的稳定性、安全性。</p><p>这也是一个典型的创业问题，<b>不信任别人开发的项目，一定要自己组建团队</b>（凭感觉认定）。但是实际情况恰好相反。</p><p>自己组建的团队，尤其是学生等开发能力较差、经验严重不足的初级开发者会带来更多问题。</p><ol><li><b>开发流程不规范，项目开发周期长</b>。</li><li><b>经验缺乏，BUG 频出，难以扩展</b>。</li><li><b>实际开发成本远高于购买现有成品，后期鸡肋</b>。一个小点的技术团队，至少也得 设计师兼产品经理、前端开发、后端开发兼任运维 各一个。快一点三个月完成 设计—— 开发 —— 上线。每个人开 3000 元 / 月。光做完项目，人力成本也要 2.7 万，而国内知名 SaaS 「有赞商城」，一年的服务费最高也才 2.68 万。 </li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c7cf548cbc9d8cf86aae262da1dde6d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1692\" data-rawheight=\"1202\" class=\"origin_image zh-lightbox-thumb\" width=\"1692\" data-original=\"https://pic1.zhimg.com/v2-c7cf548cbc9d8cf86aae262da1dde6d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1692&#39; height=&#39;1202&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1692\" data-rawheight=\"1202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1692\" data-original=\"https://pic1.zhimg.com/v2-c7cf548cbc9d8cf86aae262da1dde6d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c7cf548cbc9d8cf86aae262da1dde6d8_b.jpg\"/></figure><p> SaaS提供商为企业搭建信息化所需要的所有网络基础设施及软件、硬件运作平台，并负责所有前期的实施、后期的维护等一系列服务，企业无需购买软硬件、建设机房、招聘IT人员，即可通过互联网使用信息系统。—— 百度百科<br/> <br/> </p><p>创业应当考虑好：<b>自己的优势是什么</b>？如果是优质的客户渠道，更贴心的服务，<b>那为什么要舍本逐末</b>，将重心放在技术提升上？如果本就是技术为优势，<b>那如何保持现有优势</b>？</p><p>这才是真正所要考虑的，<b>以事实来做决定而不仅依赖于自己的感觉</b>。</p><h2>该不该创业？</h2><p>创业并没有对错之分，错误的是没有任何计划、准备的就去做一件很容易失败的事。</p><p>创业 <b>不局限于</b> 做一个 App，然后推广盈利。它有着多元化的方式。打造个人 IP，做个自媒体博主，开通知识星球，做知识付费是一种创业。找到合适的货源，在朋友圈中推广销售也是一种创业。</p><p>什么才是有准备、有计划呢？</p><p><b>从自己所熟悉的行业出发，做自己有优势的领域</b>。如果已经在一个行业工作了 3-5 年，那你已经对某一领域有很深入的了解了，你可以从自己的工作横向拓展，结合自己的优势创业。</p><p><b>创业不是梭哈，不要随随便便就全面投入</b>。先试错，用自己工作以外的时间来探索自己想要创业的方向是否正确，而不是还未了解就匆匆辞职全身心的投入。<b>万一创业失败了怎么办？</b></p><p><b>大学生该不该创业？</b></p><p>你觉得自己很闲，而且确实很感兴趣，当然可以和朋友一起做做看了。但是， <b>不要借钱创业</b>。在自己所能承担的风险内做尝试。别只想成功后的事，而不考虑失败后的风险承担问题。<b>当失败的风险你承担不下时，谁来承担呢</b>？</p>", 
            "topic": [
                {
                    "tag": "创业", 
                    "tagLink": "https://api.zhihu.com/topics/19550560"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81720183", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十四周", 
            "content": "<h2>左耳听风 第四十四周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：<b>位运算</b>、<b>动态规划</b>、<b>贪心算法</b>、<b>字典树</b> 相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode122.%2520%25E4%25B9%25B0%25E5%258D%2596%25E8%2582%25A1%25E7%25A5%25A8%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E6%2597%25B6%25E6%259C%25BA%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode122. 买卖股票的最佳时机 II</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode104.%2520%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E7%259A%2584%25E6%259C%2580%25E5%25A4%25A7%25E6%25B7%25B1%25E5%25BA%25A6.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode104. 二叉树的最大深度</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode111.%2520%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E7%259A%2584%25E6%259C%2580%25E5%25B0%258F%25E6%25B7%25B1%25E5%25BA%25A6.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode111. 二叉树的最小深度</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode51.%2520N%25E7%259A%2587%25E5%2590%258E.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode51. N皇后</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode52.%2520N%25E7%259A%2587%25E5%2590%258E%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode52. N皇后 II</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode69.%2520x%2520%25E7%259A%2584%25E5%25B9%25B3%25E6%2596%25B9%25E6%25A0%25B9.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode69. x 的平方根</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode79.%2520%25E5%258D%2595%25E8%25AF%258D%25E6%2590%259C%25E7%25B4%25A2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode79. 单词搜索</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode208.%2520%25E5%25AE%259E%25E7%258E%25B0%2520Trie%2520%28%25E5%2589%258D%25E7%25BC%2580%25E6%25A0%2591%29.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode208. 实现 Trie (前缀树)</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode212.%2520%25E5%258D%2595%25E8%25AF%258D%25E6%2590%259C%25E7%25B4%25A2%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode212. 单词搜索 II</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode191.%2520%25E4%25BD%258D1%25E7%259A%2584%25E4%25B8%25AA%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode191. 位1的个数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode231.%25202%25E7%259A%2584%25E5%25B9%2582.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode231. 2的幂</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode338.%2520%25E6%25AF%2594%25E7%2589%25B9%25E4%25BD%258D%25E8%25AE%25A1%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode338. 比特位计数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode70.%2520%25E7%2588%25AC%25E6%25A5%25BC%25E6%25A2%25AF.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode70. 爬楼梯</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode120.%2520%25E4%25B8%2589%25E8%25A7%2592%25E5%25BD%25A2%25E6%259C%2580%25E5%25B0%258F%25E8%25B7%25AF%25E5%25BE%2584%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode120. 三角形最小路径和</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode121.%2520%25E4%25B9%25B0%25E5%258D%2596%25E8%2582%25A1%25E7%25A5%25A8%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E6%2597%25B6%25E6%259C%25BA.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode121. 买卖股票的最佳时机</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode188.%2520%25E4%25B9%25B0%25E5%258D%2596%25E8%2582%25A1%25E7%25A5%25A8%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E6%2597%25B6%25E6%259C%25BA%2520IV.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode188. 买卖股票的最佳时机 IV</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode123.%2520%25E4%25B9%25B0%25E5%258D%2596%25E8%2582%25A1%25E7%25A5%25A8%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E6%2597%25B6%25E6%259C%25BA%2520III.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode123. 买卖股票的最佳时机 III</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode300.%2520%25E6%259C%2580%25E9%2595%25BF%25E4%25B8%258A%25E5%258D%2587%25E5%25AD%2590%25E5%25BA%258F%25E5%2588%2597.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode300. 最长上升子序列</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode322.%2520%25E9%259B%25B6%25E9%2592%25B1%25E5%2585%2591%25E6%258D%25A2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode322. 零钱兑换</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode72.%2520%25E7%25BC%2596%25E8%25BE%2591%25E8%25B7%259D%25E7%25A6%25BB.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode72. 编辑距离</a></p><h2>review</h2><p>「<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/free-code-camp/follow-these-steps-to-solve-any-dynamic-programming-interview-problem-cc98e508cd0e\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Follow these steps to solve any Dynamic Programming interview problem</a>」 跟着这些步骤去解决所有面试中的动态规划问题</p><p>动态规划问题的解决可以分为 7 步： 1. <b>识别一个问题是否为动态规划问题</b>。当一个问题可以分解为一系列子问题，而这些子问题的计算存在大量重复时，它就可以用动态规划来解决。 2. <b>定义问题的变量</b>。通过定义不同的变量来比较是否能够解决动态规划问题。当一维无法推导出状态方程时，我们可以用更多的维度来推导。 3. <b>将复杂的关系清楚的表达</b>。即前后状态之间的联系，是从哪几个状态中选择出的。 4. <b>定义基础案例</b>。明确问题的边界，用基础的案例去测试推导的状态方程是否正确。 5. <b>决定你是要用迭代还是回溯来实现</b>。相比较，回溯的问题在于肯能会压栈过深导致栈溢出，而迭代的难点在于不符合人的正常思维，不易实现。 6. <b>添加备忘录</b>。将未存储过的结果计算并存储，每次计算前，先判断是否已经计算过，若已计算过，从备忘录中取出存取的计算结果，避免重复计算。 7. <b>明确时间复杂度</b>。通常动态规划的时间复杂度由方法参数的长度 N 以及每一次状态计算的时间复杂度 S 决定 —— N*S。</p><p>记住，动态规划本质上是一种 <b>优化技术</b>。</p><h2>Tip</h2><p><b>用枚举代替看不出意义的数字</b>。例如，在一个商城系统中，订单可能会出现：新订单、已完成、已取消 等 3 个状态。而一个订单创建时默认就是「新订单状态」，如果只是单纯的用 0,1,2 三个数字来代替，时间一长，自己也记不住到底每个数字代表什么意思，来维护项目的人也更看不明白这串代码在写什么。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">OrderMaster</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 订单状态，默认为 0 新下单\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">Integer</span> <span class=\"n\">orderStatus</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>如果选择用字符串来定义 orderStatus 又太浪费资源，存储数据需要更多的空间，订单状态的判断和修改也需要更多的系统资源（比较字符串是否相等消耗的资源可比数值类型大得多），这些都是不必要的开销，而且容易出现定义的不规范。第一天开发的时候定义 orderStatus = &#34; 新下单 &#34;，第二天上班，脑门一拍叫「新订单」，一上线匹配不到正确的订单状态，加班改 BUG 不说，还得扣工资。</p><p>更好的实践是，orderStatus 还是定义为整数类型，但是用一个统一的枚举类型来定义状态。代码参考：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Getter</span> <span class=\"c1\">// lombok 自动为字段生成 Get 方法\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kd\">enum</span> <span class=\"n\">OrderStatusEnum</span> <span class=\"o\">{</span>\n    <span class=\"n\">NEW</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"s\">&#34;新订单&#34;</span><span class=\"o\">),</span>\n    <span class=\"n\">FINISHED</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"s\">&#34;订单完成&#34;</span><span class=\"o\">),</span>\n    <span class=\"n\">CANCEL</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"s\">&#34;已取消&#34;</span><span class=\"o\">);</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Integer</span> <span class=\"n\">code</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">status</span><span class=\"o\">;</span>\n\n    <span class=\"n\">OrderStatusEnum</span><span class=\"o\">(</span><span class=\"n\">Integer</span> <span class=\"n\">code</span><span class=\"o\">,</span><span class=\"n\">String</span> <span class=\"n\">status</span><span class=\"o\">){</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">code</span> <span class=\"o\">=</span> <span class=\"n\">code</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">status</span> <span class=\"o\">=</span> <span class=\"n\">status</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>而原本 orderStatus 的赋值可以升级成 <code>orderStatus = OrderStatusEnum.NEW.getCode();</code> 比最初的纯数字更直观的表现出订单状态的含义，也规范了订单状态的赋值，如果有新的订单状态，只需要在 OrderStatusEnum 中再添加一个实例，声明不同的 code 和 status 即可。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/81683166\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-796626dc39bbb34b7c94b598456e29a3_180x120.jpg\" data-image-width=\"3353\" data-image-height=\"2514\" class=\"internal\">胡sir：年轻人为什么想留在大城市？</a><p>年轻人为什么想留在大城市，其实我们只是选择了自己看来更好的选择。即使这条路看起来更累但至少还有希望，能够让还年轻的人为之奋斗。不怕年纪到了心也老了，而是害怕明明年纪还不大，却要守着老年人的心态，过着中年人的生活。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81683166", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 2, 
            "title": "年轻人为什么想留在大城市？", 
            "content": "<h2>﻿因为没得选 </h2><p>如果家里条件不错，有着几百万的存款，父母身体健康，有着稳定的工作，业余时间还有自己的兴趣爱好，而自己毕业完家里就能安排不错的工作，拿着和同学工作差不多的工资甚至还有可能高出不少，却上着更轻松的班，不用加班，没有 996 或 997，你会不乐意呆在家？</p><p>白天起来，和整天谈论家长里短的同事一起工作，才工作几天就开始摸鱼，或者做着「前辈」们都不愿意干的杂活。拿着和在大城市工作的同学差着好几倍的工资，看着自己都觉得没啥意思的偶像剧，数着时间准备下班。<b>为什么不认真点干活呢？</b> 领导才四十来岁呢，再熬个二十几年，他才退休，没人退休就没法升职。就算你干着好，有岗位空着，不说你做的事有多少能算在你头上，隔壁工位的小王家里早就安排好了，上面可都是「熟人」呢。</p><p>回到家，看着逐渐失去劳动力的父母白头发又多了不少，他们没有养老保险，也不会用智能手机，多年来 <b>做着最辛苦的工作却处于收入的最底层</b>，抗拒去医院，生怕检查出什么大病，没钱治好就算了，还要欠上一大笔债，何必呢？</p><p>晚上空了，想想毕业了年纪也不小了，也该结婚了。看了看家里的房子，盖了十几二十年了，好歹要装修一下。至少屋顶下雨天不能漏水了，空调也该装一下了，仔细算算里里外外装修下来，少说也要二十几万了。再算算彩礼钱，至少二十万，这还算便宜的了。要结婚，车总得有辆吧，国产的十万左右，装装样子也行。这样一加起来，超过五十来万了！看了看自己第一个月的工资条， 3000 元，想着近几年变动不会太大的岗位，平均算下来一年也最多攒下 4 万（吃住都算爸妈的），再找爸妈借点（最多 10 万），那不是要三十几岁才能有钱结婚，oh no。</p><p>呆在家，虽然拿着稳定的工资，但是升职遥遥无期，父母生病既没人照顾，也承担不起任何一场大病。结婚和以后有孩子的事甚至不能多想。不是不选呆在家里，而是呆在家并不是正确的选择，现实的状态逼你走出小县城看似稳定，实则禁不起任何打击的生活。</p><h2>因为家里待不住</h2><p><b>年轻人都走了，没有同学也没有适合交流的同龄人</b>。现在回到小县城，能看到家里工作的人大多在三、四十岁，再不然就是毕业后，老早就结了婚，有了孩子的人。平常在办公室里，没钱的聊着家长里短，有钱的聊着下班后去哪喝喝酒。一个刚从一二线城市的你似乎很难融入到他们的圈子里。这个年龄段还在家里的，不是走在相亲准备结婚的路上，就是已经开始接送小孩上学了。不会有人和你聊什么「分布式」、「区块链」、「微服务」、「哈希加密」，仅有的这么几家科技公司，项目不是外包就是用的盗版的。</p><p><b>除了工资很难有其他收入，还要应付复杂的人际关系</b>。家里手里有钱的人很少，毕竟大家都是那么点工资。仅有的一批老板也都冲进了房地产，不然就是开着加工厂，招着临时工，很难有人和你聊投资，真有和你讲投资，拉人头，做分销，月入百万的，你还得小心别上套，这是传销。做点小生意却寸步难行，想开实体店，那些真正能赚钱的店面早就给人包下了。</p><p><b>一眼能看到今后几十年不会太大变化的生活，却通过互联网看到了太多精彩的世界</b>，这太残酷了。小县城，没有外来资本的注入，也没有更大的市场，公司 / 企业只能缓慢的发展或者维持现状，仅有的几个管理岗位，都是老板的亲戚，小县城的公司，谁放心让「外人」来管呢？何况本来也没多少事可做。再看看同期毕业的同学，在大城市由当初月入几千到几万，经常全国各地跑业务，每年都要国外学习，经常看到他发凌晨还在赶进度。虽然这种生活可能很累，但是忙着有「奔头」，努力点多少可以往上走走，提点工资，胆子大的还有可能自己创业，做自己的事业。而自己，慢慢的变成自己曾经最讨厌的样子，市侩、空虚、没有理想。</p><p><b>出去了混不好还能再回来，在家里混不下去了，就真的没地方可去了</b>。去大城市闯闯，奋斗个三五年，总能收获点钱和阅历，即使最后还是选择回来，至少比一直呆在小县城的人多了些见识，自己也不会有太多的遗憾，毕竟曾经尝试过。而早早的就回到家，心不甘情不愿的过着剩下四五十年单调的生活。扛不住家庭的压力，也受不起生活的任何打击，最终退无可退。</p><p>年轻人为什么想留在大城市，其实我们只是选择了自己看来更好的选择。即使这条路看起来更累但至少还有希望，能够让还年轻的人为之奋斗。不怕年纪到了心也老了，而是害怕明明年纪还不大，却要守着老年人的心态，过着中年人的生活。</p>", 
            "topic": [
                {
                    "tag": "毕业", 
                    "tagLink": "https://api.zhihu.com/topics/19561849"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81614394", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode104. 二叉树的最大深度", 
            "content": "<h2>二叉树的最大深度</h2><blockquote> 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br/> 说明: 叶子节点是指没有子节点的节点。<br/>示例： 给定二叉树 [3,9,20,null,null,15,7]， 返回最大深度：3 </blockquote><p>思路分析：深度优先遍历，若还有子节点则继续往下遍历层数+1， 无子结点则返回当前层数,max 记录最大层数</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maxDepth</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">maxDepth</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">max</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">maxDepth</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">depth</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">max</span> <span class=\"o\">&lt;</span> <span class=\"n\">depth</span> <span class=\"o\">?</span> <span class=\"n\">depth</span> <span class=\"o\">:</span> <span class=\"n\">max</span><span class=\"o\">;</span> <span class=\"c1\">// 记录最大层数\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">maxDepth</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">depth</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">);</span> <span class=\"c1\">// 遍历下一层，层数+1\n</span><span class=\"c1\"></span>        <span class=\"n\">maxDepth</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">depth</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80696054", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十三周", 
            "content": "<h2>左耳听风 第四十三周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按照类型来刷题，本周为：二叉树、递归、回溯相关，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode229.%2520%25E6%25B1%2582%25E4%25BC%2597%25E6%2595%25B0%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode229. 求众数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode235.%2520%25E4%25BA%258C%25E5%258F%2589%25E6%2590%259C%25E7%25B4%25A2%25E6%25A0%2591%25E7%259A%2584%25E6%259C%2580%25E8%25BF%2591%25E5%2585%25AC%25E5%2585%25B1%25E7%25A5%2596%25E5%2585%2588.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode235. 二叉搜索树的最近公共祖先</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/startup-grind/how-to-not-suck-at-design-a-5-minute-guide-for-the-non-designer-291efac43037\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to not suck at design, a 5 minute guide for the non-designer.</a>「如何不被嘲笑设计，给非设计师的 5 分钟指南」</p><p>1、<b>Use plenty of contras</b>。使用大量的对比，将不同的设计放在一起你可以更明显的知道哪个更合适。</p><p>2、<b>Almost Black is easier to read than Black</b>。不完全黑比纯黑更适合阅读，用 #333333 RGB (51,51,51) 代替纯黑，纯黑在白色背景中更不容易集中注意力。</p><p>3、<b>Important Content First</b>。将重要的内容放在首位，突出重点，例如：抖音的沉静式体验。</p><p>4、<b>Align all the things</b>。对齐所有的东西，最简单的改善就是把所有东西对齐，你会有更好的感官。</p><p>5、<b>Text size with spacing</b>。文字大小带上间距，不要让文字难以阅读。</p><p>6、<b>Use a list view for results, if order is important</b>。如果有序很重要，用列表的形式来展现。例如谷歌、百度等搜索引擎的结果，权重更高的网站放在前面。</p><p>7、<b>Design in black and white first, add color later</b>。先设计黑白的样式，再加上颜色。黑白会让你更专注核心功能的设计，而色彩是强烈情绪的反映，过早着色会让你忽略某些设计。</p><p>8、<b>Create comfortable design</b>。创造舒适的设计。例如：手机屏幕的解锁滑动，划 1/3 屏是轻松，划 2/3 屏是还能接受，那让你划一整个屏幕才能解锁呢？</p><p>9、<b>Borrow Color Palettes</b>。借用调色板，颜色的搭配是一门深奥的学问，借用调色板工具是不错的选择。推荐：<a href=\"https://link.zhihu.com/?target=https%3A//dribbble.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dribbble</a> 、<a href=\"https://link.zhihu.com/?target=https%3A//coolors.co/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Coolors</a></p><p>10、<b>Use Apple and Google OS Conventions</b>。使用苹果和谷歌系统的习惯。谷歌和苹果在设计上已经给出了一系列可靠的设计规范、参考，这是不错的参考。</p><p>作为程序员，也要设计合适的功能、界面，尤其是前端界面，学点设计基础，做个程序设计更人性化的程序员。</p><h2>Tip</h2><p>分享一个 IntelliJ IDEA 中快速生成单元测试的技巧，右键选择某个非测试类（或按下快捷键 Ctrl+Shift+T），选择创建新测试类， </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-da1e65c3a4f037aecdbef72ea0dbe9ca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1475\" data-rawheight=\"1189\" class=\"origin_image zh-lightbox-thumb\" width=\"1475\" data-original=\"https://pic3.zhimg.com/v2-da1e65c3a4f037aecdbef72ea0dbe9ca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1475&#39; height=&#39;1189&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1475\" data-rawheight=\"1189\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1475\" data-original=\"https://pic3.zhimg.com/v2-da1e65c3a4f037aecdbef72ea0dbe9ca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-da1e65c3a4f037aecdbef72ea0dbe9ca_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4379e9102f8dafcc96f836b19b33cc38_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb\" width=\"1087\" data-original=\"https://pic1.zhimg.com/v2-4379e9102f8dafcc96f836b19b33cc38_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1087&#39; height=&#39;591&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1087\" data-original=\"https://pic1.zhimg.com/v2-4379e9102f8dafcc96f836b19b33cc38_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4379e9102f8dafcc96f836b19b33cc38_b.jpg\"/></figure><p> 会在 test 包下生成对应包和测试类文件。可以在弹出的选项框中选择需要测试的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f70d79d3e288d973d11283b707880d0e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1481\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb\" width=\"1481\" data-original=\"https://pic3.zhimg.com/v2-f70d79d3e288d973d11283b707880d0e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1481&#39; height=&#39;698&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1481\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1481\" data-original=\"https://pic3.zhimg.com/v2-f70d79d3e288d973d11283b707880d0e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f70d79d3e288d973d11283b707880d0e_b.jpg\"/></figure><p> 生成的测试类为被测试类类名+Test，测试方法与原方法名一致。借用 IDEA 工具就不用再繁琐的创建测试类，将时间放在如何编写代码上。强烈推荐。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5473816cf06ebff336b7c4010ca1d5aa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1820\" data-rawheight=\"1210\" class=\"origin_image zh-lightbox-thumb\" width=\"1820\" data-original=\"https://pic3.zhimg.com/v2-5473816cf06ebff336b7c4010ca1d5aa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1820&#39; height=&#39;1210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1820\" data-rawheight=\"1210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1820\" data-original=\"https://pic3.zhimg.com/v2-5473816cf06ebff336b7c4010ca1d5aa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5473816cf06ebff336b7c4010ca1d5aa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>share</h2><p class=\"ztext-empty-paragraph\"><br/></p><a href=\"https://zhuanlan.zhihu.com/p/80695764\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-35a52606d8b8da7d0530c7dfca34ed06_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2730\" class=\"internal\">胡sir：如果重学计算机</a><p>如果重学计算机，你会选择怎样的方式来学习，哪些是你觉得至关重要的？我给出了我的看法，欢迎探讨。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80695764", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 19, 
            "title": "如果重学计算机", 
            "content": "<p>﻿如果回到学习计算机的最开始，你会选择如何学习计算机呢？</p><h2>怎么开始？</h2><p>做为学习了 4 年计算机专业的学生，从大专到本科的学习，可以明显的感受不同的老师，不同的学校，不同的学习方式对一个人的学习成长尤其是计算机方面，有着非常大的影响。</p><p>指出学生时期曾经相信的一段谬论：<b>学校对你没有什么用，只要有能力就可以。</b> 其实大多数时候这句话都是 <b>自我安慰</b>。临近实习工作，才发现如今计算机专业的学生差距如此之大！</p><p>有人学了几年计算机，连学习的编程语言所用的编译器是什么也不知道，因为没怎么去上过课，或者说上课也没怎么听。毕业之后很大概率也是做着和专业不相关的事。</p><p>而如今国内一流的学校，多少有一些计算机的实验室或是社团，寒暑假都在忙着准备比赛 / 做项目，在毕业的时候就具备了两三年的水准的工作能力，这也是为什么应届毕业生能够拿到几十万高薪的真正原因。<b>企业的本质目的是盈利</b>，所以要想凭借工作获得更多的收入，首先你要给企业带来更多的利润。</p><p>如果是在一所不太出众的学校，去找一些培训机构基础班的课学习，豆瓣上搜一下相关的书单或是评分较高的书进行系统性的书籍学习，当然如果你有能力学习国外的一手资源自然是首选。如果能做到这一步，起步阶段你就超越了大多数计算机专业的学生。</p><p>当然，如果你已经在一所国内顶尖的学校学习了，那尽早加入相关的 实验室/社团 早点接触实际的项目，培养自己学习计算机的兴趣，找到自己要发展的方向当然是最好的。当然一定不要忘记参加 <b>ACM 竞赛</b>，这是计算机专业最有含金量的比赛了。</p><blockquote> ACM国际大学生程序设计竞赛：英文全称：ACM International Collegiate Programming Contest（简称ACM-ICPC或ICPC） 是一项旨在展示大学生创新能力、团队精神和在压力下编写程序、分析和解决问题能力的年度竞赛。经过30多年的发展，国际大学生程序设计竞赛已经发展成为最具影响力的大学生计算机竞赛</blockquote><h2>学习什么语言？</h2><p>对于第一门编程语言，我推荐 python / JavaScript ，这也是皓叔在「<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/intro/48\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">左耳听风</a>」专栏所推荐的，入门语言最重要的是培养对于编程的兴趣，同时训练出自己的编程思维，学会如何用编程来解决实际问题。</p><p>当然 C 语言是我认为系统性的学习计算机所要了解的，至少要学习完 C 语言的指针到底是什么，当你学习完 C 语言中的指针再回过头看 Java、C# 等高级编程语言中的引用传递、值传递就会更清晰。</p><p>Java 是皓叔专栏所推荐的正式入门语言，作为长期占据编程语言使用人数榜首的 Java，你应该仔细感受它的魅力（对于初学者，这可是一门劝退的语言），尤其是国内的就业环境，学习静态的面向对象语言，它是首选。</p><h2>有什么专业课一定要学？</h2><p>如果只是做些小项目，做做简单的增删改查，不学习计算机的专业课当然问题不大。但是做一个程序员，谁又甘心只做「脚本小子」呢？</p><p>计算机专业有 5 门核心专业课：<b>计算机组成原理</b>、<b>计算机操作系统</b>、<b>数据结构与算法</b>、<b>数据库原理</b>、<b>计算机网络</b>。</p><p><b>到底有什么重要的</b>？</p><p><b>计算机组成原理</b>，告诉你代码中 int、for、break 是怎么在计算机中转换成指令，进行运算的，即一个程序究竟是怎么跑起来的。</p><p><b>计算机操作系统</b>，告诉你，一个 2 G 内存条，怎么运行 4 G 大的游戏或者软件。多个程序运行怎么安排他们的执行顺序，按部就班，谁先来谁先运行（FIFO 先进先出）；效率优先，谁先跑完谁先做（JSF 短进程优先）；都别吵，露水均沾，一人玩几分钟（时间片轮转）... 小小的 CPU 如何管理整个计算机资源 —— 大型分布式系统中，如何做到负载均衡？</p><p><b>数据库原理</b>，如何把业务转换成具体的数据模型，该如何设计数据表（范式），同样查询一张表，为什么加了索引快了十倍？数据插入了一半，系统重启了，怎么把原有数据恢复？</p><p><b>数据结构与算法</b>，数组为什么可以按下标随机访问数据，链表只能傻傻的从头结点一个个遍历为什么要创造这种数据结构？吃东西，每次都把能吃的全吃了（<b>贪婪算法</b> —— 最好的，我都要）一定是最好吗？<b>动态规划</b> 告诉你，按照计划来，长远规划才能取得最优解。</p><p><b>计算机网络</b>，微信聊天，一段文字是怎么传到对方手机上的。视频聊天怎么有时候网络不好的时候画面不太连贯（<b>UDP 协议</b>，不提供可靠交付），文字怎么不会少几个字（<b>TCP 协议</b>，尽最大努力交付）。</p><p>这 5 门课并没有直接的告诉你，如何设计一个合格的程序，编写出可靠的代码，但是它们本身就是计算机领域的经典或是最佳的实践。</p><p>推荐一门课：哈佛大学的 <a href=\"https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/av45936507%3Ffrom%3Dsearch%26seid%3D12647017297091578254\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CS50</a>，B 站上有资源，作为计算机的入门了解，这门课超越了国内绝大多数老师所讲述的专业课（既有趣味性又有一定的专业了解）。</p><h2>英语真的很重要吗？</h2><p>只有英语不太好，平时不怎么看国外资料的人会觉得英语不重要。</p><p>最好的编程问答网站—— StackOverflow 都是英文交流，而 GitHub 上面的优质项目/ 交流 也都是英文。更不用说一手的编程学习资料，都是英文的（例如：Spring 官网只有英文资料），许多优秀的外国书籍都需要经过四五年才会被翻译成中文。</p><p>学习英语也不局限于学习国外的一手资源，也是打开新的思路，例如不同的编程语言，动态的和静态的，面向对象和面向过程的不同的类型会加深你对编程的认识也会让你有更广阔的思维去思考问题。</p><p>随着高校对计算机专业的重视，学生能力的差异变得更大了。加上近几年互联网红利的褪去，如果说以前可以高中毕业通过培训进入一流公司做程序员，现在来看似乎不太可能了，即使是科班生也可能不太知道该如何学习计算机这个专业，甚至面试也不具备与岗位相匹配的实力，只有真正在大学四年中认真学习计算机专业的知识，并多参与项目的实践，寒暑假参加大厂的实习才有可能获得大厂的 offer。</p><p>如果重学计算机，以上我所提到的 4 个方面是我认为至关重要的，如果你还是一个尚在大学的学生，可以借鉴我的看法好好规划自己剩下几年的大学生涯，早日成为一名合格的程序员；若你已经要走向职场，或已经工作，那不妨想想，如果你重新回去学习计算机，你会怎样规划你的学习，又有什么是你认为至关重要的呢？</p><p><b>过去是定数，未来是未知数，要想求解未来，先计算好现在</b>，加油。</p>", 
            "topic": [
                {
                    "tag": "大学生", 
                    "tagLink": "https://api.zhihu.com/topics/19555480"
                }, 
                {
                    "tag": "计算机专业", 
                    "tagLink": "https://api.zhihu.com/topics/19599444"
                }
            ], 
            "comments": [
                {
                    "userName": "孤尘无羡", 
                    "userLink": "https://www.zhihu.com/people/6d28da2704cfed26888a5e63f85b151a", 
                    "content": "感谢您的建议", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "浪久", 
                    "userLink": "https://www.zhihu.com/people/2d0d1f469bbde0158e7785ccf80f6b24", 
                    "content": "谢谢", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "希望对你们有帮助", 
                            "likes": 0, 
                            "replyToAuthor": "浪久"
                        }
                    ]
                }, 
                {
                    "userName": "小丑", 
                    "userLink": "https://www.zhihu.com/people/2377599bbfb22f819015d0f93878589d", 
                    "content": "谢谢", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "怀坏", 
                    "userLink": "https://www.zhihu.com/people/55bf86bbfcf3d8e3298de0e0bad77d52", 
                    "content": "技校的计算机网络应用 有用吗？ 我现在就是在技校学习计算机网络应用感觉前途迷茫", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "<p>说实话大专很多老师上的课不如你看培训机构的视频，因为很多就是看视频学完再来教学生的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "怀坏"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79727520", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十二周", 
            "content": "<h2>左耳听风 第四十二周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode49.%2520%25E5%25AD%2597%25E6%25AF%258D%25E5%25BC%2582%25E4%25BD%258D%25E8%25AF%258D%25E5%2588%2586%25E7%25BB%2584.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode49. 字母异位词分组</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode50.%2520Pow%28x%252C%2520n%29.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode50. Pow(x, n)</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40kasunpdh/garbage-collection-how-its-done-d48135c7fe77\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Garbage Collection: How it’s done</a> 「垃圾回收：它是怎么做的呢？」</p><p>在早期的编程语言：C 、C++ 中，例如数组这样的引用类型我们需要手动分配内存，并在使用完手动回收内存，产生了大量的重复操作：分配内存 —— 释放内存。</p><p>于是在高级语言中，引入了「垃圾回收机制」，帮助我们解决了内存分配与释放问题。例如：C#、JAVA 。</p><p>早期的「垃圾回收」采用的是「<b>引用计数法</b>」，对象创建时，引用计数 1，每多一个对象的引用 计数+1，同样，每减少一个引用，计数 -1。当引用计数为 0 时，该对象所分配的内存空间就可以被回收。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Object</span> <span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">();</span> <span class=\"c1\">// 创建对象，计数 1\n</span><span class=\"c1\"></span><span class=\"n\">Object</span> <span class=\"n\">obj2</span> <span class=\"o\">=</span> <span class=\"n\">obj</span><span class=\"o\">;</span> <span class=\"c1\">// 多一个对象的引用，计数+1 =2\n</span><span class=\"c1\"></span><span class=\"n\">obj2</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"c1\">// 移除一个对象的引用，计数 -1 = 1\n</span><span class=\"c1\"></span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"o\">//</span> <span class=\"n\">再移除一个对象的引用</span><span class=\"err\">，</span><span class=\"n\">计数</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"err\">，</span><span class=\"n\">此时该对象内存可被回收</span></code></pre></div><p>后来，在实际引用中，出现循环引用，计数无法被清除置 0，容易出现内存泄露情况，例如以下代码：A、B 都指向了 null，但是因为其内部成员变量互相应用，所以二者标记计数还是 1，但是已没有可以访问二者的方式，导致了内存泄露，无法正确回收。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">B</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setB</span><span class=\"o\">(</span><span class=\"n\">B</span> <span class=\"n\">b</span><span class=\"o\">){</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">b</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"nc\">B</span><span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setA</span><span class=\"o\">(</span><span class=\"n\">A</span> <span class=\"n\">a</span><span class=\"o\">){</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">a</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Client</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">A</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">A</span><span class=\"o\">();</span>\n        <span class=\"n\">B</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">setB</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">);</span>\n        <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">setA</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span>\n        <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>于是「<b>标记清除法</b>」成为了更适合的选择，垃圾回收分为了「标记」、「清除」两个时期。</p><p>标记时期，垃圾回收器将所有还可使用的对象（引用可达 —— 存在强引用）标记。</p><p>清除时间，将所有未标记的对象内存进行回收。</p><p>但是「<b>标记清除法</b>」存在一个问题：被标记的内存散列分布在堆中，当创建的对象过多，会产生许多小块的内存，而缺乏足够大的连续内存存储新的内存空间。</p><p>于是垃圾回收中，增加了一个「压缩」事情，将原有散列分布的内存（依旧存活的对象）压缩到一块，将原本散列的小块内存整合成一大块完整内存。—— 「<b>标记清除压缩法</b>」</p><p>但是这样做似乎又有点麻烦，我们不知道什么时候压缩比较合适，于是「<b>标记复制法</b>」出现了，将内存分为两块，每次内存都分配在同一块区域，当该区域内存分配结束（内存用完），触发垃圾回收，将所有标记可用的对象内存复制到另一款未使用过的内存区，然后清除之前存储对象的内存区，下一次内存分配完时重复操作。</p><p>在 Java 中采用的是「分代垃圾回收」，将堆内存分为「新生代」、「老年代」两个区域，新创建的对象放入新生代，当新生代内存分完时触发垃圾回收，将新生代被标记对象放入老年代，清楚「新生代」未被标记的对象。</p><h2>Tip</h2><p>Java 1.7 版本之前，try catch finlly 中包含了多个资源需要循环嵌套，即影响代码可读性，也存在诸多问题，很难正确释放资源，最重要的是出现异常时，内嵌的异常很容易被吞，导致程序出错难以调试。</p><p>传统写法：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n        <span class=\"n\">InputStream</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"s\">&#34;C:\\\\&#34;</span><span class=\"o\">);;</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"n\">OutputStream</span> <span class=\"n\">os</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"s\">&#34;C:\\\\&#34;</span><span class=\"o\">);</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">buf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">byte</span><span class=\"o\">[</span><span class=\"n\">1024</span><span class=\"o\">];</span>\n                <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n                <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buf</span><span class=\"o\">)</span> <span class=\"o\">)&gt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">buf</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">);</span> <span class=\"c1\">// 写入\n</span><span class=\"c1\"></span>                <span class=\"o\">}</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span> <span class=\"c1\">// 关闭资源\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>在 1.7 版本以后，官方推出了 try with resource 为推荐的释放资源的异常处理。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n        <span class=\"k\">try</span> <span class=\"o\">(</span><span class=\"n\">InputStream</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"s\">&#34;C:\\\\&#34;</span><span class=\"o\">);</span>\n             <span class=\"n\">OutputStream</span> <span class=\"n\">os</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"s\">&#34;C:\\\\&#34;</span><span class=\"o\">);)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">buf</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">byte</span><span class=\"o\">[</span><span class=\"n\">1024</span><span class=\"o\">];</span>\n            <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">;</span>\n            <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">buf</span><span class=\"o\">))</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">os</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">buf</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">n</span><span class=\"o\">);</span> <span class=\"c1\">// 写入\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">IOException</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>相比传统写法，try with resource，写法更为简洁易懂，也更容易诊断，将 Java 开发人员从繁琐的资源正确释放中释放，而且提高了代码的可靠性，希望大家在日常使用中，注意传统写法的替换。</p><h2>share</h2><p>分享一下最近整理的设计模式七原则：</p><p>1、<b>Single Responsibility Principle</b>。单一责任原则。即每一个类所负责的应当是某一个功能的实现，如果一个类中出现了超过 1 个的责任时，就应考虑分解这个类的责任。这也符合软件工程所提倡的「低耦合，高聚合」（耦合指模块内部应该职责同一，非共同职责的功能不应放在同一模块。聚合指的是模块之间，彼此相互联系）。</p><p>2、 <b>Open-Closed Principle</b>。开闭原则。即对扩展开放，对修改闭合。对于类、模块、方法等我们应该更多的提高其可拓展性，而非不断的因新数据的出现而修改。（对应着面向对象的「继承」）</p><p>3、<b>Liskov Substitution Principle</b>。里式替换原则。子类和父类之间应当对应 「is a」关系，即子类一定是父类中的成员，对于子类中都需要实现却彼此不同的功能，可以抽象到父类中形成抽象方法。</p><p>4、<b>Interface Segregation Principle</b>。接口分离原则。不应强制一个类实现接口中不使用的方法。即多个专用接口胜过一个聚合功能的端口。</p><p>5、<b>Dependency Inversion Principle</b>。依赖倒置原则。高层模块不应依赖底层模块，二者都应依赖于抽象。抽象不依赖于细节，细节依赖抽象。</p><p>6、<b>Demeter principle</b>。迪米特法则 —— 最少知道原则。只与最直接的朋友通信，被依赖类将逻辑封在内部，只对外提供 public 方法。</p><p>7、<b>Composite Reuse Principle</b>。合成复用原则。尽量使用 合成/聚合 的方式，而不是继承。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6455c55b0cb2c7affa270b91b1b2bc27_b.jpg\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"1125\" class=\"origin_image zh-lightbox-thumb\" width=\"4096\" data-original=\"https://pic4.zhimg.com/v2-6455c55b0cb2c7affa270b91b1b2bc27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4096&#39; height=&#39;1125&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"4096\" data-rawheight=\"1125\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4096\" data-original=\"https://pic4.zhimg.com/v2-6455c55b0cb2c7affa270b91b1b2bc27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6455c55b0cb2c7affa270b91b1b2bc27_b.jpg\"/><figcaption>设计模式七原则</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79707696", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 3, 
            "title": "二面来了~", 
            "content": "<h2>﻿讲一下你学的专业课？</h2><p>计算机专业的 5 门核心课：数据结构、计算机网络、操作系统、计算机组成原理、数据库，以及软件工程的核心课：软件工程导论、UML，编程语言：C# 系列等</p><h2>讲一下你了解的设计模式？</h2><p>单例模式、工厂模式、装饰者模式、代理模式、原型模式、建筑者模式 —— <b>不清楚的概念不要说</b></p><h2>解释一下装饰器模式？</h2><p>从定义上来说：装饰器是动态的将新的功能添加到对象上。</p><p>通常由四个角色：被装饰者/主体（Component）、装饰者（Decorator）、具体主体（ConcreteComponent）、具体装饰者（ConcreteDecorator）。</p><p>装饰者和被装饰者为 <b>抽象类</b>，在装饰者与被装饰者为 <b>聚合</b> 关系。在装饰者实现类中我们可以对<b>被装饰者/主体</b> 的方法进行 <b>装饰</b>（包装成我们想要的具体方法）</p><h2>解释一下软件工程中的耦合？</h2><p>不同功能模块写在一起，导致某处出现问题时整块代码受影响。</p><h2>讲一下你学习的编程语言？</h2><p>C、C#、Java、JavaScript 等。</p><h2>解释一下面向对象的语言的特点？</h2><p>封装 —— 封装具体实现的细节，只对外提供必要的接口。</p><p>继承 —— 对于公有的特性可以抽象成父类，子类可以继承父类的属性和方法，提高了代码重用性</p><p>多态 —— 子类可以重写父类的方法，对于同一个父类方法，不同的子类可以有不同的实现。</p><h2>快速排序的原理？</h2><p>快速排序也是分治算法的一种体现，但是是自顶向下的。我们每次默认最末尾数（其他数也可，放置末尾即可）为当前排序数据的中间值，将大于它的放在右边，将小于放在它左边，最后将中间值放置中间。</p><p>当左右分好，再将左右也分区排序重复这一步骤，直到最后区间为 1 时左右都为有序，快速排序完成。—— 实际上是改造后的插入排序</p><h2>解释一下索引？</h2><p>数据库提高快速查询数据的一种技术。替代原有低效的遍历查询</p><p>根据数据库底层数据结构来划分有两种索引：</p><ol><li><b>哈希索引</b>。底层数据结构为「<b>哈希表</b>」，可以在常数级时间查询数据，但是不适用于数据大量重复的字段。 —— 同一个索引值，只会对应一条数据</li><li><b>B树索引</b>。底层数据结构为「<b>B+ 树</b>」，支持区间查询，但是查询效率相比 <b>哈希索引</b> 略低。是 MySQL 数据库中默认的索引方式。</li></ol><h2>编程学习中遇见的问题如何解决？</h2><p>如果是一项新技术，会先在豆瓣上看一下有哪些好评比较高的书，去阅读进行系统性的学习。</p><p>日常遇见的问题也会在 StackOverflow、CSDN 或者 掘金 等网站上查找对应的解决方案。</p><p>具体实现问题，会在 GitHub 以及相关社区查看对应的源码和帖子。</p><h2>对于移动开发的看法——安卓和 IOS？</h2><p>前端框架的不断发展，跨平台能力不断加强，同一个项目 web 只需要开发一个版本，而 安卓和 IOS 需要开发多个版本，应该会更偏向于 web 开发。</p><h2>公司的开发需要的主要是业务代码，而你希望的是更深入的技术，你如何看待这个问题？</h2><p>先完成公司业务代码，个人技术的深入学习可以在工作之余选好有兴趣的方法进行研究，而且一家成熟的公司，对于员工的技术发展肯定有所考虑。</p><h2>对于未来几年的职业规划？</h2><p>向 web 后端深入学习，希望能够成为一名合格的全栈工程师</p><h2>还有什么要问的？</h2><p>鉴于我今天的表现，如果后面有机会和师兄你一起工作这段时间可以准备一些什么。</p><h2>总结</h2><p>结合上一次的 <b><a href=\"https://zhuanlan.zhihu.com/p/78432644\" class=\"internal\">电话一面</a></b> 可以看出电话面主要考察的还是简历上所罗列的知识，所以在投递简历时 <b>一定要将你的技术栈写详细，引导你的面试官向你所熟悉的方面提问</b>。</p><p>而校招中考察的不仅有你 <b>对基础知识的掌握</b> 更有你对自己 <b>个人职业规划</b> 的思考。思考清楚 <b>为什么要选择这个岗位/职业？在 3-5 年的工作后你希望成长到怎样的高度。</b></p><p>扎实的技术才是面试收获心仪 offer 的不二法门，你可以欺骗别人，但欺骗不了自己，加油！</p>", 
            "topic": [
                {
                    "tag": "程序员面试", 
                    "tagLink": "https://api.zhihu.com/topics/19579066"
                }
            ], 
            "comments": [
                {
                    "userName": "leacoder", 
                    "userLink": "https://www.zhihu.com/people/b5394a59027b05124e89b96d8d0eeb68", 
                    "content": "加油(ง •̀_•́)ง", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "胡sir", 
                    "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                    "content": "<p>共勉</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78697023", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十一周", 
            "content": "<h2>左耳听风 第四十一周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode45.%2520%25E8%25B7%25B3%25E8%25B7%2583%25E6%25B8%25B8%25E6%2588%258F%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode45. 跳跃游戏 II</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode46.%2520%25E5%2585%25A8%25E6%258E%2592%25E5%2588%2597.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode46. 全排列</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode48.%2520%25E6%2597%258B%25E8%25BD%25AC%25E5%259B%25BE%25E5%2583%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode48. 旋转图像</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/javarevisited/want-to-learn-java-quickly-burn-all-your-java-tutorial-books-6d06f5d77e84\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Finally understanding how references work in Android and Java</a> 「彻底弄懂引用时如何在 安卓 和 Java 中工作的」</p><p>首先要知道 Java 中默认的 4 类引用：<b>强引用</b>（Strong reference）、<b>软引用</b>（SoftReference）、<b>弱引用</b>（WeakReference）、<b>幻象引用</b>（PhantomReference）</p><p><b>强引用</b>，是我们日常编程中最常见的引用，当我们创建一个新的对象时，默认就是强引用。例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">Object object = new Object();</code></pre></div><p>这里要衍生到 Java 垃圾回收的机制，当有对象处于 <b>强引用</b> 状态时，Java 的垃圾收集器是不会帮我们回收这部分内存的。</p><p>于是这就有可能引发「<b>内存泄漏</b>」问题。当一个对象，我们不再需要使用时，却有其他对象持有其 <b>强引用</b>，该对象内存就无法被垃圾收集器回收。</p><p>于是，基于内存正确回收的需要，<b>弱引用</b> 承担了这部分责任。被弱引用所引用对象的内存，随时可能被垃圾收集器回收。但是能够在对象还存在时继续或者该对象的使用。</p><p>好了， <b>强引用</b>、<b>弱引用</b> 各有优势，但是编程的要求总是多变的。即不想一直保持对象的引用、又不想对象在内存足够的被垃圾收集器清零怎么办？<b>软引用</b> 出现了，二者综合，在内存足够的时候保持对对象的引用，在内存不够的时候，把相应的引用清理，然后再被垃圾收集器释放内存。—— 综合通常是计算机的具体实践，不做最极端，但做最适用。</p><p><b>幻象引用</b>，当一个对象在垃圾收集器收集时，它可以被 <b>幻象引用</b> 引用。（很少见，作者所在正式的生产环境中掰手指也能数出遇见的次数）</p><p>总结，通过这篇文章，我们能够对于 Java 中的四种引用有一定的认识，当我们的程序出现「<b>内存泄漏</b>」时，我们可以从错误的引用来排查一些问题，了解这些是为了让我们写出更健壮的代码以及如何改善，希望对你有所帮助。</p><h2>Tip</h2><p>从 Java HashMap 中学习的技巧，putVal() 函数中用位运算 &amp; 代替求余数 <code>(n - 1) &amp; hash</code>。</p><p>这里 hash 是经过哈希函数计算出的哈希值（Int），n 代表的是哈希表的容量 n-1 代表哈希表下标的取值范围（底层结构为 数组，索引从 0 开始）。</p><p>根据与运算的特性，只有当前运算的两个数二进制位都为 1 时，结果为 1，其余都为 0。则  <code>(n - 1) &amp; hash</code> 的取值范围为 [ 0,n-1 ]，相同 hash 计算的结果一致。相比 % 运算（底层还是转换为二进制操作），&amp; 运算直接操作二进制位效率更高，在 HashMap  想要达到的效果一致。</p><p>同样，当我们在相同场景中也可以使用 &amp; 运算帮我们提高效率。</p><p>附上异或运算交换值的技巧。（原理：二进制数，A^A=0，任意数 ^ 0=它本身）</p><p>交换 A、B 的值，不借助辅助空间。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">A</span><span class=\"o\">=</span><span class=\"n\">A</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"o\">;</span>\n    <span class=\"n\">B</span><span class=\"o\">=</span><span class=\"n\">A</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"o\">;</span>\n    <span class=\"n\">A</span><span class=\"o\">=</span><span class=\"n\">A</span><span class=\"o\">^</span><span class=\"n\">B</span><span class=\"o\">;</span></code></pre></div><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/78338143\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-3134f1285e87e2336ec168a5e3499180_180x120.jpg\" data-image-width=\"3252\" data-image-height=\"2374\" class=\"internal\">胡sir：《剑指offer》攻略</a><p>把《剑指 offer》的题目用 Java 语言（书中是 C++）实现了一遍，希望能给大家一些参考。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/offer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub 地址</a>：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/offer\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/hackhu2019/o</span><span class=\"invisible\">ffer</span><span class=\"ellipsis\"></span></a></p><p>附上我整理的思维导图，有一些做题技巧。</p><p></p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78432644", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "BAT电话面 问题 —— 你怎么看？", 
            "content": "<p>﻿BAT 电话面会问你什么问题呢？假设你突然接到了电话，面试官问你以下问题，你会说出怎样的回答呢？</p><p>以下是我的复盘，仅给大家做个参考。</p><h2>讲一下你了解的排序算法？</h2><p>可以根据 <b>时间复杂度</b> 来划分: - 时间复杂度为 O(n²) 的主要有：冒泡排序、选择排序、插入排序。 - O(nlogn) 的主要有：快速排序、归并排序、堆排序。 - 比较特殊的有：基数排序、桶排序等。</p><h2>从有序数组中找出第 K 大的数，你会用哪些方法？</h2><p>比较常用的有两种方法：</p><ol><li>在数组中，基于 <b>快速排序</b>，当分界点 mid 索引为 k-1 （从 0 开始）时，左边的数都小于 mid，右边数都大于 mid，此时分界点 mid 为第 K 大的数。注意这里改变了数组元素的位置。</li><li>维护一个 K 大的「<b>大顶堆</b>」（父节点值大于等于子节点值），遍历数组完成建堆和堆化的过程，当数组便利完成堆顶数就是第 K 大的数了。（推荐使用，不改变原有数据顺序）</li></ol><p>这道题还能进一步扩展：<b>找出前 K 大的数</b>。这里快排解法思路不变，方法 2 由「<b>大顶堆</b>」换成「<b>小顶堆</b>」（父节点值小于子节点值）。</p><h2>讲一下你对 TCP 协议的理解？</h2><p>这个范围太广了，我也只记住一些常听见的名词。</p><p>首先，从网络的体系结构来看，TCP 协议是位于 <b>传输层</b>（运输层）的协议。是一种 <b>面向连接、可靠的、基于字节流、尽最大努力交付</b> 的传输协议。</p><p>其次，TCP 数据传输特点：<b>无差错、不丢失、不重复、按序到达</b>。</p><p>Telnet、SMTP、HTTP、POP3 等应用层协议都是基于 TCP 的。</p><p>TCP 传输过程可以概括为：三次握手（建立连接），四次挥手（断开连接）。</p><p><b>三次握手</b>：1、客户端向服务端发送建立连接的请求；2、服务端接收到请求，发送确认连接请求；3、客户端接收到确认，发送客户端确认信息，服务端接收确认，连接建立成功。</p><p><b>四次挥手</b>：1、客户端发送断开连接请求；2、服务端接收到断开连接请求，发送确认断开。3、等待一段时间后服务端发送服务端断开连接请求（处理完未发送消息）；4、客户端接收到服务端确认断开、服务端连接断开请求后发送确认关闭，服务端接收确认关闭，关闭本次 TCP 连接，完成四次挥手。</p><h2>介绍一下你简历中出现的 XX 项目？</h2><p>主要介绍一下项目使用的技术栈、功能模块，面试官会根据你的回答针对性问你下面的问题，所以你需要对你的项目比较熟悉，最好写一份相应的文档介绍。</p><h2>开发这个项目你所遇到的最大的困难？</h2><p>这个各有不同，我的项目里的技术栈大部分来自于自学，而且国内这方面的资源比较少，所以通过 Github、Google、Stackoverflow 我慢慢入门了 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 最终实现了我的项目。</p><h2>为什么选用这项技术？</h2><p>和现有的技术栈向关联，而且对比 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> 前后端耦合，<a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 前后端分离的更彻底，网页的设计更方便，其中也集成了类似于 JPA 等技术，可以更快的完成一个网站项目的搭建。</p><h2>对于未来三年的规划？</h2><p>自己选择了计算机专业，同时对计算机、互联网也很有兴趣，希望能够在 BAT 这样的公司工作，在技术上成长更多。</p><h2>岗位方向的选择？</h2><p>因为面试的岗位是「移动应用开发」，随着 web 2.0 的发展，网页跨平台能力的发展，和 ios 、 Android 等原生语言开发的功能体验差距越小，相对来说网页这一块的潜力更大一些，所以希望是 web 后端的方向，但是具体工作的可以根据公司的需要来安排。</p><h2>有没有什么想要问的？</h2><p>问了下接下来还有哪些面试环节，以及这段时间还需要哪些准备。（因为是电话面，面试官没有讲太多，只是建议我好好做好未来几年的规划）</p><p>这些题目的答案只是我的一家之言，仅给大家做个参考，如果你有什么更好的答案不妨在留言区给出。菜鸟踩坑，希望大家都能收到自己心仪的 offer​。​</p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "秋招", 
                    "tagLink": "https://api.zhihu.com/topics/20075475"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78338143", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 19, 
            "title": "《剑指offer》攻略", 
            "content": "<p>﻿把《<a href=\"https://link.zhihu.com/?target=https%3A//book.douban.com/subject/25910559/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">剑指 offer</a>》的题目用 Java 语言（书中是 C++）实现了一遍，希望能给大家一些参考。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/offer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub 地址</a>：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/offer\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/hackhu2019/o</span><span class=\"invisible\">ffer</span><span class=\"ellipsis\"></span></a></p><p>注：我的看的是 2014 年出版的，题目序号和 2017 版有差异，2017 中的贪婪算法部分在 2014 版中没有。</p><p>我的代码和其他人的有什么不同：</p><p>我的代码中不仅包括解题的代码，还有我解题的思路分析，你可以根据我的分析来理解代码。在比较复杂的地方我也添加了相应的注释。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1cf932bb418cfa593da750e9b3e41ead_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1418\" data-rawheight=\"1177\" class=\"origin_image zh-lightbox-thumb\" width=\"1418\" data-original=\"https://pic2.zhimg.com/v2-1cf932bb418cfa593da750e9b3e41ead_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1418&#39; height=&#39;1177&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1418\" data-rawheight=\"1177\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1418\" data-original=\"https://pic2.zhimg.com/v2-1cf932bb418cfa593da750e9b3e41ead_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1cf932bb418cfa593da750e9b3e41ead_b.jpg\"/></figure><p> 每一题我都有对应的主程序，里面有相应的测试案例，可以独立运行，所有题目我都有相应测试。（当时忘了分出单独的单元测试有点小缺陷） </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-61b1b1c9ec6105a57929613f6d38b4f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1263\" data-rawheight=\"1237\" class=\"origin_image zh-lightbox-thumb\" width=\"1263\" data-original=\"https://pic4.zhimg.com/v2-61b1b1c9ec6105a57929613f6d38b4f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1263&#39; height=&#39;1237&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1263\" data-rawheight=\"1237\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1263\" data-original=\"https://pic4.zhimg.com/v2-61b1b1c9ec6105a57929613f6d38b4f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-61b1b1c9ec6105a57929613f6d38b4f3_b.jpg\"/></figure><p> 我的项目结构，都位于 com.hack 包下，每一题都是 <b>Question+题号</b> 命名，还包含部分题目需要的数据结构，例如：BinaryTree（二叉树）、Node （链表）。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7005ab63fb366176afab7dd6328df3b5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1487\" data-rawheight=\"1245\" class=\"origin_image zh-lightbox-thumb\" width=\"1487\" data-original=\"https://pic2.zhimg.com/v2-7005ab63fb366176afab7dd6328df3b5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1487&#39; height=&#39;1245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1487\" data-rawheight=\"1245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1487\" data-original=\"https://pic2.zhimg.com/v2-7005ab63fb366176afab7dd6328df3b5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7005ab63fb366176afab7dd6328df3b5_b.jpg\"/></figure><p> 我的运行环境：</p><p>编译器：Intelli IDEA （你只要能跑起 Java 程序就好了，别的都不重要）</p><p>Java 版本：1.8  （不同版本对我项目的使用影响不大，1.5 以上即可）</p><h2>介绍</h2><p>书中的题目大致可以分为数据结构、算法两大部分。根据题目的特点我做了张思维导图，你可以根据题目的特点进行针对性做题，思维导图里也指出了一些相关知识点、技巧。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-afa6c2592c15702e21d6aa44592b323b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3252\" data-rawheight=\"2374\" class=\"origin_image zh-lightbox-thumb\" width=\"3252\" data-original=\"https://pic4.zhimg.com/v2-afa6c2592c15702e21d6aa44592b323b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3252&#39; height=&#39;2374&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3252\" data-rawheight=\"2374\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3252\" data-original=\"https://pic4.zhimg.com/v2-afa6c2592c15702e21d6aa44592b323b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-afa6c2592c15702e21d6aa44592b323b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>数据结构篇</h2><p>数据结构系列包括：数组、字符串、链表、栈&amp;队列、Hash、树、堆以及位运算。</p><p>数据结构篇的主要考察点在于每一种特定数据结构的特性，尤其是：<b>栈&amp;队列</b>，通常在题目中出现：「<b>后进先出</b>」、「<b>先进先出</b>」等关键字。</p><p>对于 <b>链表</b> 和 <b>树</b> 很容易和他们的操作以及特性结合出题，当然也会有一定的解题技巧。</p><p>例如：删除链表中的结点。使用「<b>哨兵结点</b>」可以帮我们处理「<b>头结点删除</b>」、「<b>尾结点删除</b>」等边界问题。</p><p>使用「快慢指针/双指针」可以很容易处理：「<b>找出链表中环的入口结点</b>」、「<b>删除倒数第 K 个结点</b>」等问题。</p><p>而树的「前序遍历」、「中序遍历」、「后序遍历」都有不同的特点，前序遍历和中序遍历的结合可以帮我们解决「<b>NO6.重建二叉树</b>」问题。</p><p>查找二叉树的中序遍历可以输出一个有序列。那它的「后序遍历」又有怎样的特点呢？去 <b>NO.24</b> 找找答案。</p><h2>算法篇</h2><p>书中对于算法方面考察的知识点不多，2014 版出现的算法类题目涉及：递归、排序、二分查找、回溯、动态规划。</p><p>以「二分查找」为例，每种算法大都有特定的使用场景，而「二分查找」适用于有序数组，所以通常题目中出现：有序数组、查找等关键字，很可能就是用二分了。（不是只有二分才能解，而是用了二分更高效）</p><p>算法的核心思想不变，但是题目能够变化的就有很多，将二分查找法改变下就可以变成：<b>数字在排序数组中出现的次数（NO.38）</b>—— 可以用二分法查找该数字首次出现、最后出现的位置，索引值之差+1 就可以求出次数了。</p><h2>总结</h2><p><b>正难则反</b>。对于部分题目，我们反过来看可能更容易得出结果。例如：<b>NO.37 两个链表的第一个公共结点</b>。从起点找两个链表的公共结点并不容易，但是倒过来看，链表相交类似于「Y」，两个链表倒序遍历（结合栈），当下一个结点不相同时，当前结点就是第一个公共结点了。</p><p><b>解题 != 最优解</b>。例如递归类经典题：<b>NO9.斐波那契数列</b>。使用递归：f(n)=f(n-1)+f(n-2)。存在大量重复计算、递归层数过多堆栈溢出等问题，你怎么解决递归中的重复计算问题呢？<b>哈希表</b>（存储已计算值） or <b>循环</b>（所有递归都可以换成循环来做）。</p><p><b>分解问题，找出规律</b>。例如：位运算一类的题，很考验问题的分解和归纳分析。<b>NO47.不使用加减乘除做加法</b>。 你需要先将加法的运算过程分解为：相同位的数字变化、进位。 1. 联想二进制加法 1、0 变化，只有当二者为（1、0）或（0，1）时相加结果为 1，其余都为 0,与异或运算相似。 2. 进位发生在二者都是 1 的时候，同与运算一致，进位操作可以看作左移。</p><p>这样分解问题并一步步找到规律可以帮我们更好的解题。</p><p>我的代码中也有一些自己的思路，如果出现错误你可以直接提交你的代码到我的仓库，或直接 <a href=\"https://www.zhihu.com/people/hu-hao-77-99/activities\" class=\"internal\">联系我</a> 都可以。祝大家和我都能收获自己心仪的 offer。</p>", 
            "topic": [
                {
                    "tag": "剑指Offer（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20121522"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76643206", 
            "userName": "沐羽", 
            "userLink": "https://www.zhihu.com/people/3a28e1345890a771c6f691c6af754b3f", 
            "upvote": 1, 
            "title": "020  JAVA   多线程", 
            "content": "<h2><b>   程序:Program,是一个指令的集合 。（可能包含多个进程）  </b></h2><h2><b>   进程:Process,(正在执行中的程序)是一个静态的概念进程是程序的一次静态态执行过程, 占用特定的地址空间.每个进程都是独立的，由 3 部分组成 cpu,data,code。</b></h2><p><b>         进程的缺点：内存的浪费，cpu 的负担</b></p><h2><b>注意：</b></h2><p><b>   1.一个进程可拥有多个并行的(concurrent)线程</b></p><p><b>   2.即便用同一份程序产生好几个进程，它们之间还是拥有自己的这3样东西      缺点是：浪费内存，cpu的负担较重</b></p><h2><b>   线程:是进程中一个“单一的连续控制流程” (a singlesThread,equential flow of control)/执行路径。线程又被称为轻量级进程(lightweight process)。</b></h2><h2><b>注意：</b></h2><p><b>  1. 一个进程中的多个线程共享相同的内存单元/内存地址空间，可以访问相同的变量和对象，而且它们从同一堆中分配对象并进行通信、数据交换和同步操作</b></p><p><b>  2. 由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快</b></p><p><b>  3. 线程的启动、中断、消亡，消耗的资源非常少</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5b7fe4b649acb8277571cde8eda43ae7_b.jpg\" data-size=\"normal\" data-rawwidth=\"1526\" data-rawheight=\"791\" class=\"origin_image zh-lightbox-thumb\" width=\"1526\" data-original=\"https://pic4.zhimg.com/v2-5b7fe4b649acb8277571cde8eda43ae7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1526&#39; height=&#39;791&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1526\" data-rawheight=\"791\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1526\" data-original=\"https://pic4.zhimg.com/v2-5b7fe4b649acb8277571cde8eda43ae7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5b7fe4b649acb8277571cde8eda43ae7_b.jpg\"/><figcaption>程序、进程与线程图形描述</figcaption></figure><h2>程序与进程的区别：------进程是程序的一部分，程序运行的时候会产生进程</h2><p><b>1.  程序是一组指令的集合，它是静态的实体，没有执行的含义。而进程是一个动态的实体，有自己的生命周期</b></p><p><b>     2. 一般说来，一个进程肯定与一个程序相对应，并且只有一个，但是一个程序可以有多个进程，或者一个进程都没有</b></p><p><b>     3. 进程还有并发性和交往性</b></p><h2>进程与程序的区别：</h2><p><b>1.  每个进程都有独立的代码和数据空间(进程上下文)，进程间的切换会有较大的开销</b></p><p>2.   线程是进程的一部分，所以线程有的时候被称为轻量级进程</p><p><b>3.   线程可以看成是轻量级的进程，属于同一进程的线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换的开销小</b></p><p><b>4.   线程和进程最根本的区别在于：进程是资源分配的单位，线程是调度和执行的单位</b></p><p> 4.  多进程: 在操作系统中能同时运行多个任务(程序)。</p><p> 5.  多线程: 在同一应用程序中有多个顺序流同时执行。</p><p><b>7.   一个没有线程的进程是可以被看作单线程的，如果一个进程内拥有多个线程，进程的执行过程不是一条线(线程)的，而是多条线(线程)共同完成的</b></p><p><b>8.   系统在运行的时候会为每个进程分配不同的内存区域，但是不会为线程分配内存(线程所使用的资源是它所属的进程的资源)，线程组只能共享资源。那就是说，除了CPU之外(线程在运行的时候要占用CPU资源)，计算机内部的软硬件资源的分配与线程无关，线程只能共享它所属进程的资源</b></p><h2><b>实现多线程的两种方式：</b></h2><h2><b>1.通过继承（extends）Thread类实现多线程</b></h2><p><b>通过继承Thread类实现多线程的步骤:</b></p><p><b>          1.继承Thread类</b></p><p><b>          2.重写run()方法</b></p><p><b>          3.调用start()方法启动线程</b></p><p><b>   注意：必须重写run()方法及调用start()方法启动线程</b></p><p><b>继承Thread类：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class MyThread extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(&#34;MyThread--------&#34;);\n\t}\n}</code></pre></div><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"n\">MyThread</span> <span class=\"n\">my</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MyThread</span><span class=\"o\">();</span><span class=\"c1\">//创建线程对象\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">my</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span><span class=\"c1\">//启动线程\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;---------main方法&#34;</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9559ab69794be09b08e44870b388d426_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"104\" class=\"content_image\" width=\"352\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;352&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"352\" data-rawheight=\"104\" class=\"content_image lazy\" width=\"352\" data-actualsrc=\"https://pic3.zhimg.com/v2-9559ab69794be09b08e44870b388d426_b.jpg\"/></figure><p>继承Thread类：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class MyThread2 extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(&#34;MyThread--------&#34;+i);\n\t\t}\n\t}\n}</code></pre></div><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test2 {\n\tpublic static void main(String[] args) {\n\t\tMyThread2 my = new MyThread2();//创建线程对象\n\t\tmy.start();//启动线程\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(&#34;---------main方法&#34;+i);\n\t\t}\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1ac9e6512b7b9fb0befd033938c1cdd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"345\" data-rawheight=\"515\" class=\"content_image\" width=\"345\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;345&#39; height=&#39;515&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"345\" data-rawheight=\"515\" class=\"content_image lazy\" width=\"345\" data-actualsrc=\"https://pic4.zhimg.com/v2-1ac9e6512b7b9fb0befd033938c1cdd7_b.jpg\"/></figure><h2><b>2.通过实现（implements）接口Runnable实现多线程</b></h2><p><b>         1.编写类实现 Runnable 接口 </b></p><p><b>         2.实现 run()方法 </b></p><p><b>         3.通过 Thread 类的 start()方法启动线程</b></p><p><b>实现类：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class MyRunnable implements Runnable{\n\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(&#34;MyRunnable-----&#34;+i);\n\t\t}\n\t}\n\n}</code></pre></div><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n\tpublic static void main(String[] args) {\n\t\tMyRunnable my = new MyRunnable();\n\t\t//start是Thread类中的方法\n\t\tThread thread = new Thread(my);\n\t\tthread.start();\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(&#34;-----------main&#34;+i);\n\t\t}\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-20e700d04e15b4d4c6587ee5005152a7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"316\" data-rawheight=\"500\" class=\"content_image\" width=\"316\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;316&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"316\" data-rawheight=\"500\" class=\"content_image lazy\" width=\"316\" data-actualsrc=\"https://pic4.zhimg.com/v2-20e700d04e15b4d4c6587ee5005152a7_b.jpg\"/></figure><p>测试2：</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.sxt.runnable;\n/*\n * 通过实现Runnable接口实现多线程\n * 实现步骤：\n *       1.实现Runnable接口\n *       2.实现/重写Runnable中的run方法\n *       3.启动线程：通过Thread代理启动线程（本质调用start()方法）\n */\npublic class Test02 implements Runnable{\n\tprivate String name;\n\tprivate int age;\n\t\n\tpublic Test02(String name, int age) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(name+age+&#34;--&#34;+i);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tTest02 t1 = new Test02(&#34;sbh&#34;, 12);\n\t\tThread thread = new Thread(t1);\n\t\tthread.start();\n\t\tTest02 t2 = new Test02(&#34;sbcdh&#34;, 11);\n\t\tThread thread2 = new Thread(t2);\n\t\tthread2.start();\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6535992bdb8b08502ffbc1aa14626973_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"527\" class=\"content_image\" width=\"271\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;271&#39; height=&#39;527&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"527\" class=\"content_image lazy\" width=\"271\" data-actualsrc=\"https://pic4.zhimg.com/v2-6535992bdb8b08502ffbc1aa14626973_b.jpg\"/></figure><p><b>代理设计模式:</b></p><p><b>       为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用</b></p><p>   Thread  代理角色 </p><p>   MyRunnable 真实角色 </p><p>   代理角色与真实角色实现共同的接口 Runnable 接口</p><h2>线程状态：</h2><p><b>新生状态(New) ：</b></p><p>      用 new 关键字建立一个线程后，该线程对象就处于新生 状态。处于新生状态的线程有自己的内存空间，通过调用 start()方法进入就绪状态</p><p><b>就绪状态(Runnable)：</b></p><p>     处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象后，它就会进入执行状态。一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：</p><p>   1. 新建线程：调用start()方法，进入就绪状态;</p><p>   2. 阻塞线程：阻塞解除，进入就绪状态;</p><p>   3. 运行线程：调用yield()方法，直接进入就绪状态;</p><p>   4. 运行线程：JVM将CPU资源从本线程切换到其他线程</p><p><b>运行状态(Running)：</b></p><p>     在运行状态的线程执行自己run方法中的代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。也可能由于某些“导致阻塞的事件”而进入阻塞状态</p><p><b>阻塞状态(Blocked)：</b></p><p>阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。<b>有4种原因会导致阻塞</b>：</p><p>           1. 执行sleep(int millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。</p><p>           2. 执行wait()方法，使当前线程进入阻塞状态。当使用nofity()方法唤醒这个线程后，它进入就绪状态。</p><p>          3. 线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。</p><p>          4. join()线程联合: 当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法</p><p><b>死亡状态(Terminated)：</b></p><p>       死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个。一个是正常运行的线程完成了它run()方法内的全部工作; 二是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)；三是线程抛出未捕获异常</p><p>     注意：当一个线程进入死亡状态以后，就不能再回到其它状态了</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-78e8b1892216ac249cd5b270d4217dd3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1286\" data-rawheight=\"639\" class=\"origin_image zh-lightbox-thumb\" width=\"1286\" data-original=\"https://pic4.zhimg.com/v2-78e8b1892216ac249cd5b270d4217dd3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1286&#39; height=&#39;639&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1286\" data-rawheight=\"639\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1286\" data-original=\"https://pic4.zhimg.com/v2-78e8b1892216ac249cd5b270d4217dd3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-78e8b1892216ac249cd5b270d4217dd3_b.jpg\"/></figure><h2><b>终止线程的典型方式：</b></h2><p>     通常的做法是提供一个boolean型的终止变量，当这个变量置为false，则终止线程的运行（一般不使用JDK提供的stop()/destroy()方法----它们本身也被JDK废弃了-）</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.sxt.threadmethod;\n/*\n * 终止线程一般不使用JDK提供的stop()、destory()方法    已过时\n *    通常做法是提供一个博哦了安类型的终止变量，当这个变量值为false时，终止程序的运行\n */\npublic class Test01 implements Runnable{\n\tString name;\n\tboolean live = true;//标识是否终止\n\t\n\tpublic Test01(String name) {\n\t\tthis.name = name;\n\t }\n\tpublic Test01() {\n\t\t\n\t}\n\t@Override\n\tpublic void run() {\n\t\tint i = 0;\n\t\twhile(live) {\n\t\t\tSystem.out.println(name+&#34;----&#34;+i++);\n\t\t}\n\t}\n\t//终止线程\n\tpublic void terminate() {\n\t\tlive = false;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tTest01 t1 = new Test01(&#34;子线程&#34;);\n\t\tThread t = new Thread(t1);\n\t\tt.start();//启动线程\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(&#34;主线程&#34;+i);\n\t\t}\n\t\tt1.terminate();//终止\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e232858a655dd2b081e7b181dc0e8e30_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"176\" data-rawheight=\"249\" class=\"content_image\" width=\"176\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;176&#39; height=&#39;249&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"176\" data-rawheight=\"249\" class=\"content_image lazy\" width=\"176\" data-actualsrc=\"https://pic1.zhimg.com/v2-e232858a655dd2b081e7b181dc0e8e30_b.png\"/></figure><h2><b>获取线程基本信息的方法：</b></h2><p><b>* getName():返回此线程的名称</b></p><p><b> * isAlive():测试此线程是否还在运行</b></p><p><b> * getPriority():返回此线程的优先级   最小值为1  最大值为10  默认为5</b></p><p><b> * setPriority(int newPriority):更改此线程的优先级</b></p><p><b> * currentThread():返回当前对象正在执行的线程对象的引用</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test02 {\n\tpublic static void main(String[] args) throws InterruptedException {\n\t\tRunnable ru = new MyThread();\n\t\tThread t = new Thread(ru);\n\t\tt.start();\n\t\tSystem.out.println(&#34;name is :&#34;+t.getName());\n\t\tSystem.out.println(&#34;优先级:&#34;+t.getPriority());\n\t\tThread.currentThread().sleep(5000);\n\t\tSystem.out.println(&#34;线程是否还在运行:&#34;+t.isAlive());\n\t\tSystem.out.println(&#34;over!&#34;);\n\t}\n}\n\nclass MyThread implements Runnable{\n\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n\t\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3f0305955d54a9155f88f534c15e611a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"344\" class=\"content_image\" width=\"420\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;420&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"344\" class=\"content_image lazy\" width=\"420\" data-actualsrc=\"https://pic3.zhimg.com/v2-3f0305955d54a9155f88f534c15e611a_b.jpg\"/></figure><p><b>在Thread类中有一个int类型的静态变量，用来统计创建线程的个数，并且在Thread类中：</b></p><p><b>   1.toString()方法得到的内容为:[线程名称，线程的优先级，线程组的名称]</b></p><p><b>   2.线程的默认命名规则:Thread-int类型的变量值</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.sxt.threadmethod;\n\npublic class ThreadMethod01{\n\tpublic static void main(String[] args) {\n\t\tThread t = Thread.currentThread();\n\t\t//toString()方法得到的内容为:[线程名称，线程的优先级，线程组的名称]\n\t\tSystem.out.println(t);\n\t\tMyRunnable my = new MyRunnable();\n\t\tThread t1 = new Thread(my);\n\t\tThread t2 = new Thread(my);\n\t\tThread t3 = new Thread(my);\n\t\tt1.start();\n\t\tt2.start();\n\t\tt3.start();\n\t\t/*在Thread类中有一个int类型的静态变量，用来统计创建线程的个数*/\n\t}\n}\n\n\nclass MyRunnable implements Runnable{\n\n\t@Override\n\tpublic void run() {\n\t\tThread t = Thread.currentThread();\n\t\tSystem.out.println(t);\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1f6222634aa1ee94aed17021389a9147_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"315\" data-rawheight=\"157\" class=\"content_image\" width=\"315\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;315&#39; height=&#39;157&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"315\" data-rawheight=\"157\" class=\"content_image lazy\" width=\"315\" data-actualsrc=\"https://pic4.zhimg.com/v2-1f6222634aa1ee94aed17021389a9147_b.jpg\"/></figure><h2><b>暂停线程执行sleep/yield：</b></h2><p> sleep()方法：可以让正在运行的线程进入阻塞状态，直到休眠时间满了，进入就绪状态</p><p>  yield()方法：可以让正在运行的线程直接进入就绪状态，让出CPU的使用权</p><div class=\"highlight\"><pre><code class=\"language-text\">public class TestThreadState {\n    public static void main(String[] args) {\n        StateThread thread1 = new StateThread();\n        thread1.start();\n        StateThread thread2 = new StateThread();\n        thread2.start();\n    }\n}\n\nclass StateThread extends Thread {\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            System.out.println(this.getName() + &#34;:&#34; + i);\n            try {\n                Thread.sleep(2000);//调用线程的sleep()方法；\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public class TestThreadState {\n    public static void main(String[] args) {\n        StateThread thread1 = new StateThread();\n        thread1.start();\n        StateThread thread2 = new StateThread();\n        thread2.start();\n    }\n}\n\nclass StateThread extends Thread {\n    public void run() {\n        for (int i = 0; i &lt; 100; i++) {\n            System.out.println(this.getName() + &#34;:&#34; + i);\n            Thread.yield();//调用线程的yield()方法；\n        }\n    }\n}</code></pre></div><h2><b>线程的优先级：</b></h2><p> 1. 处于就绪状态的线程，会进入“就绪队列”等待JVM来挑选。</p><p> 2. 线程的优先级用数字表示，范围从1到10，一个线程的缺省优先级是5。</p><p> 3. 使用下列方法获得或设置线程对象的优先级。</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.sxt.threadbeforeandafter;\n\npublic class Test01 {\n\tpublic static void main(String[] args) {\n\t\tMythread mythread = new Mythread(&#34;thread0&#34;);\n\t\tmythread.setPriority(1);\n\t\tmythread.start();\n\t\tMythread mythread2 = new Mythread(&#34;thread1&#34;);\n\t\tmythread2.setPriority(10);\n\t\tmythread2.start();\n\t}\n}\n\n\nclass Mythread extends Thread{\n\t\n\t\n\tpublic Mythread(String name) {\n\t\tsuper(name);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\tSystem.out.println(this.getName()+&#34;---&#34;+i);\n\t\t}\n\t}\n\t\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d911cb05dd269e0960c52e0031949149_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"253\" data-rawheight=\"500\" class=\"content_image\" width=\"253\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;253&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"253\" data-rawheight=\"500\" class=\"content_image lazy\" width=\"253\" data-actualsrc=\"https://pic2.zhimg.com/v2-d911cb05dd269e0960c52e0031949149_b.jpg\"/></figure><h2><b>线程的联合join()：</b></h2><p><b>线程A在运行期间，可以调用线程B的join()方法，让线程B和线程A联合。这样，线程A就必须等待线程B执行完毕后，才能继续执行</b>。</p><p>     如下面示例中，“爸爸线程”要抽烟，于是联合了“儿子线程”去买烟，必须等待“儿子线程”买烟完毕，“爸爸线程”才能继续抽烟。</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.sxt.threadbeforeandafter;\n\npublic class TestSmoking {\n\tpublic static void main(String[] args) {\n\t\tThread t1 = new FatherThread();\n\t\tt1.start();\n\t\t\n\t}\n}\n\n\nclass FatherThread extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(&#34;爸爸想抽烟，没烟了......&#34;);\n\t\tSonThread son = new SonThread();\n\t\tson.start();\n\t\tSystem.out.println(&#34;爸爸等儿子回来...&#34;);\n\t\ttry {\n\t\t\tson.join();\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\tSystem.out.println(&#34;爸爸已经拿到了&#34;);\n\t}\n}\n\nclass SonThread extends Thread{\n\t@Override\n\tpublic void run() {\n\t\tSystem.out.println(&#34;出门买烟需要十分钟&#34;);\n\t\tfor(int i=0;i&lt;10;i++) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(1000);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(&#34;第&#34;+(i+1)+&#34;分钟&#34;);\n\t\t}\n\t\tSystem.out.println(&#34;买烟回来了&#34;);\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-123d346d9a0b9a8e713eaf00d00fc7ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"383\" class=\"content_image\" width=\"297\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;297&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"383\" class=\"content_image lazy\" width=\"297\" data-actualsrc=\"https://pic4.zhimg.com/v2-123d346d9a0b9a8e713eaf00d00fc7ff_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77607271", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第四十周", 
            "content": "<h2>左耳听风 第四十周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode39.%2520%25E7%25BB%2584%25E5%2590%2588%25E6%2580%25BB%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode39. 组合总和</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode40.%2520%25E7%25BB%2584%25E5%2590%2588%25E6%2580%25BB%25E5%2592%258C%2520II.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode40. 组合总和 II</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode42.%2520%25E6%258E%25A5%25E9%259B%25A8%25E6%25B0%25B4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode42. 接雨水</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/javarevisited/want-to-learn-java-quickly-burn-all-your-java-tutorial-books-6d06f5d77e84\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Want to Learn Java Quickly? Burn All Your Java Tutorial Books</a> 「想要快速的学习 Java，先烧掉你所有的 Java 教程书」</p><p>Java 的学习可以说是没有尽头的了，作为全球使用人数最多、需求量最大的编程语言，每年都有不少人开始学习 Java，但是大部分人还没正式入门就要面临失业了。</p><p>在看到标题的第一眼，很自然的蹦出一个问题：<b>学 Java 为什么要把教程书烧掉</b>？作者在文章中给出了自己的看法：</p><ul><li>在编程的一开始，看太多的教程书只会抽干你学习的热情和动力。它并没有教你如何编程，反而把你和学习 Java 分离。</li><li>过多的理论会降低你学习的速度。通常对于新手，看完一本教程书只会让他们变得更混淆，到底该怎样编程呢？</li></ul><p>那有什么更好的学习 Java 的方式呢？</p><ol><li>做好计划，<b>娱乐最小化</b>，严格按照制定的计划来学习。</li><li>问正确的问题。既要学会在遇到问题时寻求他人的帮助，也要学会问 <b>有必要</b>的问题（不重复问问题，不问已有正确答案的问题）。</li><li>从基础开始，不要因为觉得简单而跳到更高级别的学习。（正如皓叔说的：你真的理解了例子中的方方面面吗？）</li><li>每天编程。练习成就完美，坚持每天编程的习惯，让编程变成你的习惯。</li><li>结合二八原则，80% 的编程，20% 的理论。</li><li>继续学习，即使你认为你已成功。</li></ol><h2>Tip</h2><p>MySQL 存储过程的使用</p><p>数据库中的存储过程类似于编程中的函数，我们可以通过创建储存过程来帮我们提高 SQL 语句重用性。</p><p>首先要注意的是，存储过程中可能存在多条 SQL 语句（默认逐条执行），所以我们需要重新声明结束标记，可以是 // 或 $$ 。在创建前声明新的结束标记，创建和恢复回默认设置。</p><p>SQL 中存储过程关键字为  <code>PROCEDURE</code> 创建存储过程和编程中声明函数类似通过，IN、OUT 表明输入或输出的参数名称（某表结构字段名称）以及类型。</p><p>通过 <code>BEGIN END</code> 来包裹要执行的语句块（类似编程语言中的 {}）</p><p><code>SELECT INTO</code>：查询数据，并输出到指定变量</p><p>这里给出我定义的一个存储过程定义示范</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">DELIMITER</span> <span class=\"err\">$$</span> <span class=\"o\">#</span> <span class=\"err\">声明结束标识为</span> <span class=\"err\">$$</span>\n<span class=\"k\">CREATE</span> <span class=\"k\">PROCEDURE</span> <span class=\"o\">`</span><span class=\"n\">get_hero_scores</span><span class=\"o\">`</span><span class=\"p\">(</span>\n            <span class=\"k\">OUT</span> <span class=\"n\">max_max_hp</span> <span class=\"nb\">FLOAT</span><span class=\"p\">,</span> <span class=\"o\">#</span> <span class=\"err\">输出参数名称以及类型</span>\n            <span class=\"k\">OUT</span> <span class=\"n\">max_max_mp</span> <span class=\"nb\">FLOAT</span><span class=\"p\">,</span>\n            <span class=\"k\">OUT</span> <span class=\"n\">avg_max_attack</span> <span class=\"nb\">FLOAT</span><span class=\"p\">,</span>\n            <span class=\"n\">s</span> <span class=\"nb\">VARCHAR</span><span class=\"p\">(</span><span class=\"mi\">255</span><span class=\"p\">))</span> <span class=\"o\">#</span> <span class=\"err\">输入参数名称以及类型</span>\n<span class=\"k\">BEGIN</span>\n    <span class=\"k\">SELECT</span> <span class=\"k\">MAX</span><span class=\"p\">(</span><span class=\"n\">hp_max</span><span class=\"p\">),</span><span class=\"k\">MAX</span><span class=\"p\">(</span><span class=\"n\">mp_max</span><span class=\"p\">),</span><span class=\"k\">AVG</span><span class=\"p\">(</span><span class=\"n\">attack_max</span><span class=\"p\">)</span> \n    <span class=\"k\">FROM</span> <span class=\"n\">heros</span> \n    <span class=\"k\">WHERE</span> <span class=\"n\">role_main</span><span class=\"o\">=</span><span class=\"n\">s</span>\n    <span class=\"k\">INTO</span> <span class=\"n\">max_max_hp</span><span class=\"p\">,</span><span class=\"n\">max_max_mp</span><span class=\"p\">,</span><span class=\"n\">avg_max_attack</span><span class=\"p\">;</span>\n<span class=\"k\">END</span><span class=\"err\">$$</span>\n<span class=\"k\">DELIMITER</span> <span class=\"p\">;</span></code></pre></div><p>存储过程的调用要使用 CALL 关键字，并传入指定的参数。</p><p>使用参照：</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">CALL</span> <span class=\"n\">get_hero_scores</span><span class=\"p\">(</span><span class=\"o\">@</span><span class=\"n\">max_max_hp</span><span class=\"p\">,</span><span class=\"o\">@</span><span class=\"n\">max_max_hp</span><span class=\"p\">,</span><span class=\"o\">@</span><span class=\"n\">avg_max_attack</span><span class=\"p\">,</span><span class=\"s1\">&#39;战士&#39;</span><span class=\"p\">);</span>  <span class=\"o\">#</span> <span class=\"err\">调用存储过程</span>\n<span class=\"k\">SELECT</span> <span class=\"o\">@</span><span class=\"n\">max_max_hp</span><span class=\"p\">,</span><span class=\"o\">@</span><span class=\"n\">max_max_hp</span><span class=\"p\">,</span><span class=\"o\">@</span><span class=\"n\">avg_max_attack</span><span class=\"p\">;</span> <span class=\"o\">#</span> <span class=\"err\">查询存储过程结果</span></code></pre></div><p>存储过程的优点：<b>一次创建，多次使用</b>。类似于编程中的函数，定好后可以在数据库中直接使用，减少代码重复。</p><p>缺点</p><ol><li>可移植性差。不同数据库的存储过程并不一致。</li><li>调试困难。</li><li>版本迭代困难。数据库的字段名修改等，都需要我们手动修改存储过程的代码</li><li>高并发场景下，数据库压力大。</li></ol><p>来自极客时间「<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/intro/192\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SQL 必知必会</a>」第13篇的学习。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/77596446\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8ada40744e8eee57642ea06abd6d994c_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2730\" class=\"internal\">胡sir：校招踩坑记——线上笔试篇</a><p>复盘一下昨晚的贝壳线上笔试，希望对其他准备校招的小伙伴一个参考。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77596446", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 5, 
            "title": "校招踩坑记——线上笔试篇", 
            "content": "<p>﻿昨天参加了 <b>贝壳</b> 的线上笔试，四道编程题，只做出一道，复盘一下，也希望对其他准备校招的小伙伴一个参考。</p><h2>笔试环境</h2><p>这场笔试是在「<b><a href=\"https://link.zhihu.com/?target=https%3A//www.acmcoder.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">赛码网</a></b>」:<a href=\"https://link.zhihu.com/?target=https%3A//www.acmcoder.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">acmcoder.com</span><span class=\"invisible\"></span></a> 进行的，一共四道题，难度从低到高，<b>限时 120 分钟</b>，编程语言不限。</p><p>这里讲一下和「<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode</a></b>」 的不同点：</p><p>1、「<b><a href=\"https://link.zhihu.com/?target=https%3A//www.acmcoder.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">赛码网</a></b>」是写完整的程序，通过标准的输入输出来测试是否通过。 「<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode</a></b>」是写方法，根据方法的调用结果来判断是否通过测试。如果没有 ACM 等比赛经验，单纯刷 「<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode</a></b>」  会不太习惯这种方式，除了写功能还要注意处理输入输出。</p><p>2、<b>提示机制不同</b>，「<b><a href=\"https://link.zhihu.com/?target=https%3A//www.acmcoder.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">赛码网</a></b>」题目中会给出 1~2 个测试用例，但是提交代码后，只会提示 <b>测试不通过或者超时</b>。这时候就会有个问题了，你不清楚是在哪个地方出错了，要自己重新理解下题目，检查代码问题。而「<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problemset/all/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode</a></b>」会给出不通过的用例，然后你可以对着题目和代码，更快的定位自己的错误。</p><p>总结：看了看赛码网的官网，似乎挺多公司是通过它来做线上笔试的。如果平时不熟悉这一类的环境建议注册一个账号，在里面做一下往年试题，提前适应，不至于在考试时手忙脚乱。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-19bdfcc8aa8e2ffc0da470680cceef4d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1519\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"1519\" data-original=\"https://pic2.zhimg.com/v2-19bdfcc8aa8e2ffc0da470680cceef4d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1519&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1519\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1519\" data-original=\"https://pic2.zhimg.com/v2-19bdfcc8aa8e2ffc0da470680cceef4d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-19bdfcc8aa8e2ffc0da470680cceef4d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>笔试内容</h2><p>四道题，第一道算是送分题，两个循环，参加校招的应该都能做出来，后面三道题都是回溯、动态规划。</p><p>可以很明显的看出，这场比赛对于算法这一块的侧重点更高，数据结构没有怎么涉及。</p><p>结合「贝壳」在国内互联网只能算二三线水平（个人观点），以及我面试的岗位是「前端工程师」，可以看出校招笔试环节，对于应届生的 <b>算法能力</b> 要求很高，越是好的互联网企业在笔试中给出的编程题难度肯定是更高的。</p><h2>总结与建议</h2><p>1、<b>实力永远是第一位</b>。如果在大学期间你一直有参加 ACM 等编程竞赛，对于数据结构和算法有着系统性的认识和学习，那这一类笔试应该是很容易刷过的。（听说算法工程师的面试都是神仙打架？）</p><p>2、<b>多投简历，查缺补漏</b>。现在秋招提前批已经开始了，没投简历的赶紧投投试一试，有不少提前批会直接免笔试的，算法不强，面试来凑。不投简历不去面试，永远没机会收到 offer。真正面试感受下差距，才能让你更好的认识自己。</p><p>3、<b>调整心态</b>。无论是面试前的准备或是面试时做题，都需要一颗良好的心态，<b>不怕都不会，就怕不会还不学</b>。提前批才刚开始，还没在秋招的过程中好好准备下一场面试，只要你始终保持学习的良好心态（不要使蛮力，不会学，去看大佬们怎么踩坑的）一定能找到适合你的公司，加油！</p><p>关于秋招，不知道你有什么好的建议或者想法，欢迎在留言区看到你给出的建议，感谢你的支持。</p>", 
            "topic": [
                {
                    "tag": "秋招", 
                    "tagLink": "https://api.zhihu.com/topics/20075475"
                }
            ], 
            "comments": [
                {
                    "userName": "谁填真名啊", 
                    "userLink": "https://www.zhihu.com/people/e330186431b020540d2ad8ee5a8fae30", 
                    "content": "塞码网挺垃圾的", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76628802", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十九周", 
            "content": "<h2>左耳听风 第三十九周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode35.%2520%25E6%2590%259C%25E7%25B4%25A2%25E6%258F%2592%25E5%2585%25A5%25E4%25BD%258D%25E7%25BD%25AE.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode35. 搜索插入位置</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode36.%2520%25E6%259C%2589%25E6%2595%2588%25E7%259A%2584%25E6%2595%25B0%25E7%258B%25AC.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode36. 有效的数独</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode37.%2520%25E8%25A7%25A3%25E6%2595%25B0%25E7%258B%25AC.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode37. 解数独</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode38.%2520%25E6%258A%25A5%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode38. 报数</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Object-Oriented Programming — The Trillion Dollar Disaster</a> 「面向对象编程，万亿美元的灾难」</p><p>文章非常长，看之前做好心理准备。</p><p>开发最终的目的是程序的可靠 —— 更少BUG、可靠的代码。而直接影响的因素是程序的复杂度。</p><p>而「面向对象」编程，在使项目的组织结构更清晰的同时，又引入了一系列设计模式，使得程序比原有的更为复杂，更难以理解，也就更容易出错。</p><p>放一张文中给出的图片，项目中的一层层抽象，让人们更加难以理解项目，偏离了面向对象宣传的简单易于理解。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a81b5535c854f29b8307afe9982007db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"875\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb\" width=\"875\" data-original=\"https://pic4.zhimg.com/v2-a81b5535c854f29b8307afe9982007db_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;875&#39; height=&#39;385&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"875\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"875\" data-original=\"https://pic4.zhimg.com/v2-a81b5535c854f29b8307afe9982007db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a81b5535c854f29b8307afe9982007db_b.jpg\"/></figure><p>Image source: <a href=\"https://link.zhihu.com/?target=https%3A//www.reddit.com/r/ProgrammerHumor/comments/418x95/theory_vs_reality/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">reddit.com/r/Programmer</span><span class=\"invisible\">Humor/comments/418x95/theory_vs_reality/</span><span class=\"ellipsis\"></span></a></p><p>文章末尾，作者指出面向对象所带来的种种危害，同时指出了另一种选择「函数式编程」。</p><blockquote> 函数式编程（英语：functional programming）或称函数程序设计、泛函编程，是一种编程范式，它将计算机运算视为函数运算，并且避免使用程序状态以及易变对象。其中，λ演算（lambda calculus）为该语言最重要的基础。而且，λ演算的函数可以接受函数当作输入（引数）和输出（传出值）。 比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。 —— 维基百科<br/> </blockquote><p>「函数式编程」做为另一种编程范式，或许能够解决 OOP 编程所存在的一些问题，但是短时间内还是无法取代「面向对象编程」的主导地位。（Java 在 1.8 版本中也引入了不少函数式编程的机制，例如：lambda 表达式）</p><h2>Tip</h2><p>Lombok 插件</p><p>在 <a href=\"https://link.zhihu.com/?target=https%3A//projectlombok.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lombok 官网</a>是这样介绍自己的：</p><blockquote> Project Lombok是一个java库，可以自动插入编辑器并构建工具，为您的java增添色彩。 永远不要再写另一个getter或equals方法，使用一个注释，您的类具有一个功能齐全的构建器，自动化您的日志记录变量等等。 （翻译后）<br/> </blockquote><p>简单说，lombok 就是通过注解的形式帮我们简化 java 代码编辑，同时使得代码变得整洁。</p><p>lombok 的使用分为两步，首先是给自己的编译器 idea 或者 eclipse 安装 lombok 插件。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e9693ad8514d104228e8712440092ff5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1258\" data-rawheight=\"836\" class=\"origin_image zh-lightbox-thumb\" width=\"1258\" data-original=\"https://pic2.zhimg.com/v2-e9693ad8514d104228e8712440092ff5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1258&#39; height=&#39;836&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1258\" data-rawheight=\"836\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1258\" data-original=\"https://pic2.zhimg.com/v2-e9693ad8514d104228e8712440092ff5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e9693ad8514d104228e8712440092ff5_b.jpg\"/></figure><p> 然后导入 lombok jar 包，或是在 maven 项目引入依赖。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"o\">&lt;</span><span class=\"n\">dependency</span><span class=\"o\">&gt;</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">groupId</span><span class=\"o\">&gt;</span><span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">projectlombok</span><span class=\"o\">&lt;/</span><span class=\"n\">groupId</span><span class=\"o\">&gt;</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">artifactId</span><span class=\"o\">&gt;</span><span class=\"n\">lombok</span><span class=\"o\">&lt;/</span><span class=\"n\">artifactId</span><span class=\"o\">&gt;</span>\n            <span class=\"o\">&lt;</span><span class=\"n\">optional</span><span class=\"o\">&gt;</span><span class=\"kc\">true</span><span class=\"o\">&lt;/</span><span class=\"n\">optional</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&lt;/</span><span class=\"n\">dependency</span><span class=\"o\">&gt;</span></code></pre></div><p>就可以在 Java 项目中使用 Lombok 提供的注解了。</p><p>常用的注解有：</p><p>@Data，包含重写的 ToString、EqualsAndHashCode、所有非 final 修饰的成员的 Getter / Setter 以及一个构造函数</p><p>对应的注解  @ToString, ToString 方法 @EqualsAndHashCode,equals 方法，以及 hashCode 方法 @Getter / @Setter  Getter / Setter  方法</p><p>@NonNull ,使用在构造函数或普通函数上，要求参数不能为空，否则抛出空指针异常。等同于：<code>if (param == null) throw new NullPointerException(&#34;param is marked @NonNull but is null&#34;);</code></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">import</span> <span class=\"nn\">lombok.NonNull</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">NonNullExample</span> <span class=\"kd\">extends</span> <span class=\"n\">Something</span> <span class=\"o\">{</span>\n  <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n\n  <span class=\"kd\">public</span> <span class=\"nf\">NonNullExample</span><span class=\"o\">(</span><span class=\"nd\">@NonNull</span> <span class=\"n\">Person</span> <span class=\"n\">person</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"s\">&#34;Hello&#34;</span><span class=\"o\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">person</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">();</span>\n  <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>@Cleanup，在要必须要释放的资源前标注，会在使用完毕自动帮我们释放资源。例如：<code>@Cleanup InputStream in = new FileInputStream(args[0]);</code></p><p>等同于：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span> <span class=\"o\">{</span>\n    <span class=\"n\">InputStream</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]);</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n      <span class=\"n\">OutputStream</span> <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"n\">args</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]);</span>\n      <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"kt\">byte</span><span class=\"o\">[]</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">byte</span><span class=\"o\">[</span><span class=\"n\">10000</span><span class=\"o\">];</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n          <span class=\"kt\">int</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">read</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">);</span>\n          <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"k\">break</span><span class=\"o\">;</span>\n          <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">write</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">r</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n      <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">out</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n          <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span></code></pre></div><p>更多注解的使用大家可以自行访问其官网文档：<a href=\"https://link.zhihu.com/?target=https%3A//projectlombok.org/features/all\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">projectlombok.org/featu</span><span class=\"invisible\">res/all</span><span class=\"ellipsis\"></span></a> ，去学习具体的使用。</p><h2>share</h2><p><a href=\"https://zhuanlan.zhihu.com/p/76628244\" class=\"internal\">Java 基础面试题</a></p><p>​这段时间在刷「牛客网」的 Java 基础面试题，挑一些里面比较有代表性的题目，和大家分享下我的理解。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76628244", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "Java 基础面试题", 
            "content": "<p>﻿这段时间在刷「牛客网」的 Java 基础面试题，挑一些里面比较有代表性的题目，和大家分享下我的理解。</p><h2>类型一：初始化</h2><p><b>what</b>：类内部初始化顺序，静态成员、非静态成员、构造器方法是以怎样的顺序完成初始化的？</p><p><b>how？</b> 以下程序会有怎样的输出结果</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Animal</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;静态代码块执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">Other</span> <span class=\"n\">other</span>  <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Other</span><span class=\"o\">(</span><span class=\"s\">&#34;非静态&#34;</span><span class=\"o\">);</span>\n    <span class=\"kd\">static</span> <span class=\"n\">Other</span> <span class=\"n\">staticOther</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Other</span><span class=\"o\">(</span><span class=\"s\">&#34;静态&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;非静态代码块执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">sayHi</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;你好，我是 Animal 类&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Animal</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;兽类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Animal</span> <span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Animal</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>输出：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">静态代码块执行</span>\n<span class=\"n\">静态Other</span> <span class=\"n\">类初始化</span>\n<span class=\"n\">非静态Other</span> <span class=\"n\">类初始化</span>\n<span class=\"n\">非静态代码块执行</span>\n<span class=\"n\">兽类被初始化</span></code></pre></div><p>在同一类中，先初始静态成员（包括静态代码块）——&gt; 非静态成员 ——&gt; 执行构造器内部操作。同一级别中，按照代码先后顺序执行。</p><p><b>why？</b> 1. <b>静态成员不属于任意实例，而是属于类</b>。在我们声明类对象时，静态成员就会执行初始化。Animal  类在加载至内存时，就会自动初始化静态成员，不需要任何实例（new 构造器）。 2. 成员优先于构造器内部操作，先初始化（基本类型有对应的默认值，引用类型初始化为 null）。因为构造器（构造函数），可以访问成员变量，在构造器可能会对成员变量进行某些操作，而未赋值的变量编译器是不允许使用的（即编译不通过）。但是编译器的隐式初始化未必是我们想要的值，所以建议我们在定义时初始化或在使用前初始化。 3. 同一级别中，按照代码先后顺序执行。Java 程序经过编译器编译成字节码，而字节码经过虚拟机解释器转化为机器码，最终变成一条条指令，而计算机执行指令通常是逐行执行的（特殊情况：跳转指令）。</p><p><b>what</b>：继承关系，子类的初始化和父类的初始化有关吗？</p><p><b>how？</b> 以下程序会有怎样的输出结果</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Animal</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Animal</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;兽类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Golden</span> <span class=\"n\">golden</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Golden</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">class</span> <span class=\"nc\">Dog</span> <span class=\"kd\">extends</span> <span class=\"n\">Animal</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Dog</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Dog 类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Golden</span> <span class=\"kd\">extends</span> <span class=\"n\">Dog</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Golden</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Golden 类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>执行结果：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">兽类被初始化</span>\n<span class=\"n\">Dog</span> <span class=\"n\">类被初始化</span>\n<span class=\"n\">Golden</span> <span class=\"n\">类被初始化</span></code></pre></div><p>在调用子类构造器创建子类实例时，父类无参构造器会先执行。</p><p><b>why?</b></p><p>子类继承了父类所有成员和方法（包括 private 成员），在子类构造器中可以通过 super 显式调用父类的成员和方法。为确保子类在使用时，父类成员可用，要先调用父类构造器，完成父类初始化。</p><p><b>扩展</b></p><p>在子类构造器中会隐式调用父类无参构造器，这是我们未意识到父类构造器的原因（编译器简化我们的代码）。所以，<b>当父类不存在无参构造器时，我们需要显式调用父类构造器，且必须为子类构造器第一条执行语句。</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Dog</span> <span class=\"kd\">extends</span> <span class=\"n\">Animal</span> <span class=\"o\">{</span>\n    <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Dog</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Dog 类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Golden</span> <span class=\"kd\">extends</span> <span class=\"n\">Dog</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Golden</span><span class=\"o\">(){</span>\n        <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"s\">&#34;金毛&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Golden 类被初始化&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>类型二：封装与多态的结合</h2><p><b>what</b>: 实例化父类对象却调用子类的构造函数，那执行方法时，调用的是父类方法，还是子类方法，那方法中所调用的成员呢？</p><p><b>how</b>：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Test1</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">12</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">printId</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">idAdd</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">idAdd</span><span class=\"o\">(){</span>\n        <span class=\"k\">return</span> <span class=\"n\">id</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test2</span> <span class=\"kd\">extends</span> <span class=\"n\">Test1</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Test1</span> <span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Test2</span><span class=\"o\">();</span>\n        <span class=\"n\">test</span><span class=\"o\">.</span><span class=\"na\">printId</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>输出：13</p><p><b>why？</b></p><p>Java 中，<b>调用谁的构造方法，就访问谁的作用域</b>。但是，<b>父类的方法只能访问父类成员</b>。当<b> 子类重写父类方法时，子类作用域调用的就是子类的方法</b>。</p><p>修改 Test2 代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Test2</span> <span class=\"kd\">extends</span> <span class=\"n\">Test1</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">idAdd</span><span class=\"o\">(){</span>\n        <span class=\"k\">return</span> <span class=\"n\">id</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Test1</span> <span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Test2</span><span class=\"o\">();</span>\n        <span class=\"n\">test</span><span class=\"o\">.</span><span class=\"na\">printId</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>此时的输出的答案就是 2。</p><p>此时父类 <code>public void printId()</code>  调用的是子类重写的 idAdd()，而子类的 idAdd() 访问的 id 是其本身的成员变量。由于子类方法的重写，二者的答案截然不同，这就是「多态」的一种体现。</p><h2>类型三：值传递还是引用传递？</h2><p><b>what</b>：参数传递，会改变原有变量的值或引用吗？</p><p><b>how？</b> 以下程序会有怎样的输出结果</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">,</span><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span><span class=\"o\">){</span>\n        <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"s\">&#34;新字符串&#34;</span><span class=\"o\">;</span>\n        <span class=\"n\">chars</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;0&#39;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Test</span> <span class=\"n\">test</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Test</span><span class=\"o\">();</span>\n        <span class=\"n\">String</span> <span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"s\">&#34;字符串&#34;</span><span class=\"o\">;</span>\n        <span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">chars</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"sc\">&#39;1&#39;</span><span class=\"o\">,</span><span class=\"sc\">&#39;2&#39;</span><span class=\"o\">,</span><span class=\"sc\">&#39;3&#39;</span><span class=\"o\">};</span>\n        <span class=\"n\">test</span><span class=\"o\">.</span><span class=\"na\">update</span><span class=\"o\">(</span><span class=\"n\">str</span><span class=\"o\">,</span> <span class=\"n\">chars</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;str:&#34;</span> <span class=\"o\">+</span> <span class=\"n\">str</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;chars:&#34;</span> <span class=\"o\">+</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">(</span><span class=\"n\">chars</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span></code></pre></div><p>输出结果：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nl\">str:</span><span class=\"n\">字符串</span><span class=\"nl\">\n</span><span class=\"nl\">chars:</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">2</span><span class=\"o\">,</span> <span class=\"n\">3</span><span class=\"o\">]</span></code></pre></div><p>String 的引用未改变，但是 chars[0] 的值被改变</p><p><b>why？</b></p><p>Java 中所有的参数都是「值传递」，简单说就是「拷贝」（复制）。对于基本类型，就是复制其值，引用类型则复制其引用。</p><p>方法中的 <code>str = &#34;新字符串&#34;;</code> 实际上是将传入的引用地址改变，但是原有的 str 引用是没有发生改变的，而 chars 虽然也是复制引用，但是通过下标访问到到的是 chars[0] 实际内存地址，实际修改了它的值。</p><p>为了方便理解我将代码改造，并做了标注，方便理解。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bf9aa7264b6239c6343efca8c474e01a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2213\" data-rawheight=\"1119\" class=\"origin_image zh-lightbox-thumb\" width=\"2213\" data-original=\"https://pic3.zhimg.com/v2-bf9aa7264b6239c6343efca8c474e01a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2213&#39; height=&#39;1119&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2213\" data-rawheight=\"1119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2213\" data-original=\"https://pic3.zhimg.com/v2-bf9aa7264b6239c6343efca8c474e01a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bf9aa7264b6239c6343efca8c474e01a_b.jpg\"/></figure><p> 类似于成语「刻舟求剑」所讲述的故事，虽然在舟上做了丢剑处的标记，但是舟下的那片江却不是丢剑的江了。</p><p>三道典型的 Java 基础面试讲完了，没准你有什么不一样的看法或者技巧，欢迎你给出评论，或是默默点点赞给个好看，这都是对我的一种认可。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75550488", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十八周", 
            "content": "<h2>左耳听风 第三十八周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode32.%2520%25E6%259C%2580%25E9%2595%25BF%25E6%259C%2589%25E6%2595%2588%25E6%258B%25AC%25E5%258F%25B7.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode32. 最长有效括号</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode33.%2520%25E6%2590%259C%25E7%25B4%25A2%25E6%2597%258B%25E8%25BD%25AC%25E6%258E%2592%25E5%25BA%258F%25E6%2595%25B0%25E7%25BB%2584.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode33. 搜索旋转排序数组</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode.34.%2520%25E5%259C%25A8%25E6%258E%2592%25E5%25BA%258F%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E6%259F%25A5%25E6%2589%25BE%25E5%2585%2583%25E7%25B4%25A0%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AA%25E5%2592%258C%25E6%259C%2580%25E5%2590%258E%25E4%25B8%2580%25E4%25B8%25AA%25E4%25BD%258D%25E7%25BD%25AE.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode.34. 在排序数组中查找元素的第一个和最后一个位置</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/free-code-camp/what-ive-learned-from-a-year-of-coding-bf39c5823e9b\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How I completed the #100DaysOfCode challenge by coding 30 minutes a day</a> 「我是如何完成编程100天，每日编程 30 分钟的调整的？」</p><p>作者讲述了自己是如何完成编程 100 天挑战的，结合 ARST 的挑战，非常有感觉。</p><p>在文章的开头作者就讲述了自己为什么将每日的编程时间设为「30 分钟」，很多人第一眼看上去可能会认为仅仅 30 分钟一天，简直不要太轻松，可是当你真正开始实践的时候，你会发现，远没有看起来这么容易。想象下工作日的一天，除去 8 小时的工作时间，一两个小时的通勤，还有其他的一些杂事，扣去睡眠时间，这么疲惫的你还会愿意花多少时间来学习呢？<b>时间不在于多少，而在于有多少是你真正拥有的</b>。</p><p>想清楚「你的挑战是为自己」，在坚持挑战的某天，你忘了，或是因为某些突发事件而不能完成，你是选择放弃，还是继续完成挑战呢？就像现在因为某些某些原因而中断每周 <b>ARST</b> 的小伙伴，断了再续上就好了，打卡的目的不就是让自己变得更好吗？</p><p>「分享，收获」。找到一个合适的地方输出，找到志同道合的人共同进步，结伴同行，才能走的更远。</p><h2>Tip</h2><p>在 Hexo、spring boot 中可以看到 .yml .yaml 结尾的文件，在维基百科上的解释如下：</p><blockquote> YAML（/ˈjæməl/，尾音类似camel骆驼）是一个可读性高，用来表达数据序列化的格式。YAML参考了其他多种语言，包括：C语言、Python、Perl，并从XML、电子邮件的数据格式（RFC 2822）中获得灵感。Clark Evans在2001年首次发表了这种语言[1]，另外Ingy döt Net与Oren Ben-Kiki也是这语言的共同设计者[2]。当前已经有数种编程语言或脚本语言支持（或者说解析）这种语言。 </blockquote><p>常用于配置文件的编写，语法简洁。</p><p>yml 需要注意的一点是 「:」 后需要先空一格再写相应的属性值</p><div class=\"highlight\"><pre><code class=\"language-text\">name: hackhu</code></pre></div><p>以空格缩减来划分层级：</p><div class=\"highlight\"><pre><code class=\"language-text\">Person1:\n    name: hackhu\n    sex: man\nPerson2:\n    name: coder\n    sex:man\n# Person1、Person2 层级一致，name、sex 层级一致，# 为注释标识</code></pre></div><p>对于数组等符合结构可以有两种表示方式</p><div class=\"highlight\"><pre><code class=\"language-text\"># 缩进式, 缩进 + - \nname:\n    - hackhu\n    - coder\n# 行内表示法\nPerson: [p1,p2]</code></pre></div><p>想要更深入的了解 yml 文件的编写可以参看 阮一峰老师的这篇文章「<a href=\"https://link.zhihu.com/?target=http%3A//www.ruanyifeng.com/blog/2016/07/yaml.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">YAML 语言教程</a>」</p><h2>share</h2><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/FyJH2gYk1Kiej0Q3QOFFZg\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-3d4ca536811f7ba016e4046fe8f6c19a_180x120.jpg\" data-image-width=\"693\" data-image-height=\"296\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ASP.NET MVC vs Spring MVC</a><p>开始学习 SpringMVC，刚好一个月前结束自己 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 的小项目，对比下这两门最相像的语言，看看有何差异</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75542832", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "ASP.NET MVC vs Spring MVC", 
            "content": "<p>﻿C# 是微软出品对标 Java 的语言，在 web 开发方面，二者都在表现层实现了自己的 MVC 框架。从一个简单的项目开始对比，看看二者有何差异。</p><h2>项目结构</h2><p>首先来看由 SpringBoot 生成的 MVC 项目模板（勾选了 web、Thymeleaf 、mybatis），controller、model 文件夹与 SpringBoot 项目主文件 XXspringbootApplication 位于同一目录下，view 文件位于应用 Thymeleaf 模板文件夹（templates）下。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-946e7adf4bfd6214b5cd5c0b1eb4a365_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1787\" data-rawheight=\"863\" class=\"origin_image zh-lightbox-thumb\" width=\"1787\" data-original=\"https://pic2.zhimg.com/v2-946e7adf4bfd6214b5cd5c0b1eb4a365_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1787&#39; height=&#39;863&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1787\" data-rawheight=\"863\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1787\" data-original=\"https://pic2.zhimg.com/v2-946e7adf4bfd6214b5cd5c0b1eb4a365_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-946e7adf4bfd6214b5cd5c0b1eb4a365_b.jpg\"/></figure><p> 再看官配编辑器 VS 生成的 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 基本项目。controller、model 、view 文件夹位于同一级，每一个  controller 有对应的model 、view 子文件夹。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2b0427dbd05aa1df80d4967f81ece4df_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2082\" data-rawheight=\"912\" class=\"origin_image zh-lightbox-thumb\" width=\"2082\" data-original=\"https://pic4.zhimg.com/v2-2b0427dbd05aa1df80d4967f81ece4df_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2082&#39; height=&#39;912&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2082\" data-rawheight=\"912\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2082\" data-original=\"https://pic4.zhimg.com/v2-2b0427dbd05aa1df80d4967f81ece4df_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2b0427dbd05aa1df80d4967f81ece4df_b.jpg\"/></figure><p> 结论，相对来说，由 VS 生成的 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 基本项目文件目录结构完整，不需要再手动添加文件或者代码，直接可以跑起一个 HelloWorld 网页。而由 SpringBoot 生成的 MVC 项目模板，还需要自己手动添加 controller、model 、view 文件，相对来说更为繁琐。</p><h2>Controller 差异</h2><p>Spring MVC 控制器通过<code>@Controller</code> 注解和普通的类区分，没有默认的文件路径，而控制器中的方法对应前端发送的请求，<code>@RequestMapping(path = &#34;hi&#34;,method = RequestMethod.GET)</code> <b>注解</b> 来定义控制器访问路径、对应的请求方式。未在类上添加<code>@RestController</code>、方法上添加 <code>@ResponseBody</code> 注解，则  <code>public String hi()</code> 返回的是视图名称。当返回值为 void 时（例：<code>public void hi()</code> ）默认返回与方法名称同名的视图。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Controller</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HiController</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@RequestMapping</span><span class=\"o\">(</span><span class=\"s\">&#34;hi&#34;</span><span class=\"o\">)</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">hi</span><span class=\"o\">(){</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;index&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 中所有的控制器都 <b>继承</b> 自 Controller 类，默认以 XX+Controller 为控制器名称，默认以控制器前缀（除 Controller 部分）为访问路径，访问对应的方法为「/Home/Index」控制器名称+对应的方法名称。请求方式通过注解方式声明，默认为所有请求方法都响应。在方法的返回值方面，ActionResult 是 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 所封装的抽象类，可以返回视图、Json 等多种类型。当方法放回值为 void 时不会有默认返回页面。<code>return View()</code> 会返回 VIEW 文件下 Home 文件夹（与控制器名称一致）的 Index.cshtml 视图（文件名与方法名称一致）。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HomeController</span> <span class=\"o\">:</span> <span class=\"n\">Controller</span> <span class=\"c1\">// 继承\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"o\">[</span><span class=\"n\">HttpGet</span><span class=\"o\">]</span> <span class=\"c1\">// 显式声明，默认为都响应\n</span><span class=\"c1\"></span>        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Index</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span></code></pre></div><h2>Model 差异</h2><p>在 Spring MVC 中，Model 层和普通的 JavaBean 一样，更多的是定义 view 所需要的数据模型</p><p>而在 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC ，Model 层位于同一目录下，建立 model 文件时，会自动引入 <code>using System.ComponentModel.DataAnnotations;</code> 可以让我们使用注解配合 jquery.validate.js 在 view 层对数据进行验证或别名展示，在表现层对数据进行多重验证，确保最终获取或发送数据有效。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SetPasswordViewModel</span>\n    <span class=\"o\">{</span>\n        <span class=\"o\">[</span><span class=\"n\">Required</span><span class=\"o\">]</span>\n        <span class=\"o\">[</span><span class=\"n\">StringLength</span><span class=\"o\">(</span><span class=\"n\">100</span><span class=\"o\">,</span> <span class=\"n\">ErrorMessage</span> <span class=\"o\">=</span> <span class=\"s\">&#34;{0} 必须至少包含 {2} 个字符。&#34;</span><span class=\"o\">,</span> <span class=\"n\">MinimumLength</span> <span class=\"o\">=</span> <span class=\"n\">6</span><span class=\"o\">)]</span> <span class=\"c1\">// 定义字段的取值范围以及出错提示信息\n</span><span class=\"c1\"></span>        <span class=\"o\">[</span><span class=\"n\">DataType</span><span class=\"o\">(</span><span class=\"n\">DataType</span><span class=\"o\">.</span><span class=\"na\">Password</span><span class=\"o\">)]</span>\n        <span class=\"o\">[</span><span class=\"n\">Display</span><span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"o\">=</span> <span class=\"s\">&#34;新密码&#34;</span><span class=\"o\">)]</span>\n        <span class=\"kd\">public</span> <span class=\"n\">string</span> <span class=\"n\">NewPassword</span> <span class=\"o\">{</span> <span class=\"n\">get</span><span class=\"o\">;</span> <span class=\"n\">set</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">DataType</span><span class=\"o\">(</span><span class=\"n\">DataType</span><span class=\"o\">.</span><span class=\"na\">Password</span><span class=\"o\">)]</span>\n        <span class=\"o\">[</span><span class=\"n\">Display</span><span class=\"o\">(</span><span class=\"n\">Name</span> <span class=\"o\">=</span> <span class=\"s\">&#34;确认新密码&#34;</span><span class=\"o\">)]</span>\n        <span class=\"o\">[</span><span class=\"n\">Compare</span><span class=\"o\">(</span><span class=\"s\">&#34;NewPassword&#34;</span><span class=\"o\">,</span> <span class=\"n\">ErrorMessage</span> <span class=\"o\">=</span> <span class=\"s\">&#34;新密码和确认密码不匹配。&#34;</span><span class=\"o\">)]</span>\n        <span class=\"kd\">public</span> <span class=\"n\">string</span> <span class=\"n\">ConfirmPassword</span> <span class=\"o\">{</span> <span class=\"n\">get</span><span class=\"o\">;</span> <span class=\"n\">set</span><span class=\"o\">;</span> <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><h2>VIEW 差异</h2><p>在 Spring MVC 中，可以在 VIEW 层使用 EL 表达式，有限的使用 Java 编写代码，通常以${} 表示，内置了 Page   PageScope、Request、RequestScope、Session、SessionScope、Application 等变量。</p><p>而  <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 在视图层提供的功能很强大，Razor 标题语法可以任意的 HTML 插入 C# 语句，只需要在 C# 语句前加上「@」符号即可。同时也可以在 C# 语句块中写入 HTML 语句，在页面加载时会只能感知以区分 C# 语句和 HTML 语句。</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n@for (int i = 0; i <span class=\"p\">&lt;</span> <span class=\"nt\">10</span><span class=\"err\">;</span> <span class=\"na\">i</span><span class=\"err\">++)</span> <span class=\"err\">{</span>\n<span class=\"err\">&lt;</span><span class=\"na\">li</span><span class=\"p\">&gt;</span>@i<span class=\"p\">&lt;/</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n}\n<span class=\"p\">&lt;/</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span></code></pre></div><p>同时 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 也提供了一系列 HTML 辅助方法，减少了 JavaScript 的工作量，更容易和后台交互。</p><div class=\"highlight\"><pre><code class=\"language-csharp\"><span class=\"n\">@using</span> <span class=\"p\">(</span><span class=\"n\">Html</span><span class=\"p\">.</span><span class=\"n\">BeginForm</span><span class=\"p\">(</span><span class=\"s\">&#34;Login&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;Account&#34;</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">ReturnUrl</span> <span class=\"p\">=</span> <span class=\"n\">ViewBag</span><span class=\"p\">.</span><span class=\"n\">ReturnUrl</span> <span class=\"p\">},</span> <span class=\"n\">FormMethod</span><span class=\"p\">.</span><span class=\"n\">Post</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">@class</span> <span class=\"p\">=</span> <span class=\"s\">&#34;form-horizontal&#34;</span><span class=\"p\">,</span> <span class=\"n\">role</span> <span class=\"p\">=</span> <span class=\"s\">&#34;form&#34;</span> <span class=\"p\">}))</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">@Html</span><span class=\"p\">.</span><span class=\"n\">AntiForgeryToken</span><span class=\"p\">()</span>\n                <span class=\"p\">&lt;</span><span class=\"n\">h4</span><span class=\"p\">&gt;</span><span class=\"err\">使用本地帐户登录。</span><span class=\"p\">&lt;/</span><span class=\"n\">h4</span><span class=\"p\">&gt;</span>\n                <span class=\"p\">&lt;</span><span class=\"n\">hr</span> <span class=\"p\">/&gt;</span>\n                <span class=\"n\">@Html</span><span class=\"p\">.</span><span class=\"n\">ValidationSummary</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">,</span> <span class=\"s\">&#34;&#34;</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">@class</span> <span class=\"p\">=</span> <span class=\"s\">&#34;text-danger&#34;</span> <span class=\"p\">})</span>\n                <span class=\"p\">&lt;</span><span class=\"n\">div</span> <span class=\"n\">class</span><span class=\"p\">=</span><span class=\"s\">&#34;form-group&#34;</span><span class=\"p\">&gt;</span>\n                    <span class=\"n\">@Html</span><span class=\"p\">.</span><span class=\"n\">LabelFor</span><span class=\"p\">(</span><span class=\"n\">m</span> <span class=\"p\">=&gt;</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">Email</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">@class</span> <span class=\"p\">=</span> <span class=\"s\">&#34;col-md-2 control-label&#34;</span> <span class=\"p\">})</span>\n                    <span class=\"p\">&lt;</span><span class=\"n\">div</span> <span class=\"n\">class</span><span class=\"p\">=</span><span class=\"s\">&#34;col-md-10&#34;</span><span class=\"p\">&gt;</span>\n                        <span class=\"n\">@Html</span><span class=\"p\">.</span><span class=\"n\">TextBoxFor</span><span class=\"p\">(</span><span class=\"n\">m</span> <span class=\"p\">=&gt;</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">Email</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">@class</span> <span class=\"p\">=</span> <span class=\"s\">&#34;form-control&#34;</span> <span class=\"p\">})</span>\n                        <span class=\"n\">@Html</span><span class=\"p\">.</span><span class=\"n\">ValidationMessageFor</span><span class=\"p\">(</span><span class=\"n\">m</span> <span class=\"p\">=&gt;</span> <span class=\"n\">m</span><span class=\"p\">.</span><span class=\"n\">Email</span><span class=\"p\">,</span> <span class=\"s\">&#34;&#34;</span><span class=\"p\">,</span> <span class=\"k\">new</span> <span class=\"p\">{</span> <span class=\"n\">@class</span> <span class=\"p\">=</span> <span class=\"s\">&#34;text-danger&#34;</span> <span class=\"p\">})</span>\n                    <span class=\"p\">&lt;/</span><span class=\"n\">div</span><span class=\"p\">&gt;</span>\n                <span class=\"p\">&lt;/</span><span class=\"n\">div</span><span class=\"p\">&gt;</span>\n            <span class=\"p\">}</span>\n</code></pre></div><h2>总结</h2><p>C# 之前的闭源和 Java 的开源，再加上发布时间的落后于 Java，导致 C# 和 Java 再编程语言的流行排行差异巨大。</p><p>还一部份原因是，C# 的社区远不如 Java 活跃，国内除了 MSDN 官方找不到什么合适的学习资源，而 MSDN 官网的资源不是很适合入门。对于入门的人来说，遇到问题不知道该如何解决，也没有合适的学习资源。</p><p>C# 对于细节方面屏蔽的更多，程序员只需要关注自己业务的需要即可，很少需要配置，而 Java 的开发相对繁琐（不使用 SpringBoot 手动配置的部分更多），需要注意更多的细节。</p><p>总而言之，言而总之，做为个人项目的开发我会选择 C# 因为可以节省更多的时间来开发自己项目，但是要系统的学习后端开发，我更推荐学习 Java，自己手动实现一些细节会让你对项目的理解更为深刻。</p>", 
            "topic": [
                {
                    "tag": "ASP.NET MVC", 
                    "tagLink": "https://api.zhihu.com/topics/19667789"
                }, 
                {
                    "tag": "Spring MVC", 
                    "tagLink": "https://api.zhihu.com/topics/20033636"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74561589", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十七周", 
            "content": "<h2>﻿左耳听风 第三十七周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode31.%2520%25E4%25B8%258B%25E4%25B8%2580%25E4%25B8%25AA%25E6%258E%2592%25E5%2588%2597.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode31. 下一个排列</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/complete-coding/how-i-doubled-my-salary-in-5-months-and-got-an-amazing-job-1110d1779e0b\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How I Doubled my Salary in Five Months and Got an Amazing Job</a> 「我是如何在 5 个月内让工资翻倍并获得一份令人吃惊的工作？」</p><p>作者讲述了自己在 5个月的东南亚旅行中提升自己的技术，最后入职了一家心仪的公司。</p><p>在提升自己技术的这段时间作者做了几件事：列出自己提升技术需要完成的几个目标，规划自己的时间、做好计划，通过观看技术书籍、付费课程来加速自己技术的提升，同时用博客来记录自己的成长。</p><p>我的思考：不要盲目的去做事，像软件工程一样，管理好自己的项目。作者在享受旅行的过程中还能一边学习提升自己的技术，而很多人并没有想好自己要做的事，反而花费了大量的时间囤积资源，对技术也只是浅尝辄止，最后只有焦虑却没有享受技术提升的快乐。</p><p>推荐阅读《刻意练习》，一万小时定律未必就能让你成为某一方面的一名大师，而有技巧的做事可以为你节省更多的时间。</p><h2>Tip</h2><p>mybatis 连接数据库，中文数据存储乱码问题解决。</p><p>首先，可以查看一下 MySQL 数据库的编码格式，大多数时候是因为没有设置成 utf-8 等支持中文字符的编码格式，可以在 MySQL 命令窗口输入 <code>SHOW VARIABLES LIKE &#39;character%&#39;;</code> 查看数据库编码，若编码格式不对，可以通过以下语句进行设置</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SET</span> <span class=\"n\">character_set_client</span> <span class=\"o\">=</span> <span class=\"n\">utf8</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">character_set_server</span> <span class=\"o\">=</span> <span class=\"n\">utf8</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">character_set_connection</span> <span class=\"o\">=</span> <span class=\"n\">utf8</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">character_set_database</span> <span class=\"o\">=</span> <span class=\"n\">utf8</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">character_set_results</span> <span class=\"o\">=</span> <span class=\"n\">utf8</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">collation_connection</span> <span class=\"o\">=</span> <span class=\"n\">utf8_general_ci</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">collation_database</span> <span class=\"o\">=</span> <span class=\"n\">utf8_general_ci</span><span class=\"p\">;</span>\n<span class=\"k\">SET</span> <span class=\"n\">collation_server</span> <span class=\"o\">=</span> <span class=\"n\">utf8_general_ci</span><span class=\"p\">;</span></code></pre></div><p>如果还是存在乱码问题,那可能是后台写入的编码格式不对，可以在数据库连接语句中进行设置</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nl\">jdbc:mysql:</span><span class=\"o\">//</span><span class=\"nl\">localhost:</span><span class=\"n\">3306</span><span class=\"o\">/</span><span class=\"n\">mybatis</span><span class=\"o\">?</span><span class=\"n\">useUnicode</span><span class=\"o\">=</span><span class=\"kc\">true</span><span class=\"o\">&amp;</span><span class=\"n\">amp</span><span class=\"o\">;</span><span class=\"n\">characterEncoding</span><span class=\"o\">=</span><span class=\"n\">UTF</span><span class=\"o\">-</span><span class=\"n\">8</span></code></pre></div><p>注意 &amp; 连接字符要转义</p><h2>share</h2><p><a href=\"https://zhuanlan.zhihu.com/p/74561240\" class=\"internal\">坚持 540 天，我有怎样的感受？</a></p><p>﻿截止到今天，2019-07-21 ，我已经在扇贝阅读上打卡 540 天，ARTS 也连续打卡 37 周。有人对我能够坚持这多天表示惊讶，我觉得并没有太多神奇的地方，但是坚持了这么久多少有些感悟，所以希望写下来，能够对看到这篇文章的人有所帮助。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74561240", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 3, 
            "title": "坚持 540 天，我有怎样的感受？", 
            "content": "<p>﻿截止到今天，2019-07-21 ，我已经在扇贝阅读上打卡 540 天，ARTS 也连续打卡 37 周。有人对我能够坚持这多天表示惊讶，我觉得并没有太多神奇的地方，但是坚持了这么久多少有些感悟，所以希望写下来，能够对看到这篇文章的人有所帮助。</p><p><b>千里之行始于足下</b>，与其犹豫是否会有怎样的收获不如现在开始。而开始也是需要一点勇气的，虽然未必会收获你想要的结果，但是，<b>不开始，你一定收获不到你想要的</b>。</p><p>定好一个小目标，<b>目标未必是你要达到的终点，但是能够为你指明前进的方向</b>。</p><p><b>做好输入输出</b>。<b>所听所看未必是所得</b>，你的思考才是你的收获。</p><p><b>一天能做的事不多，一年能做的事很多</b>。不要给自己的每天定太多的目标，要能坚持做完。就像我每天坚持看两篇英文文章，坚持一年，也能让一个对英语毫无兴趣的人不再害怕面对英语，积攒下几十万字的阅读量。</p><p><b>即使身边并没有陪你一起学习、进步的人，也不也放弃让自己变好</b>。因为选择放弃，你就会变成你讨厌的样子，熬夜刷视频、打游戏，做一些让自己变得更麻木的事。学会成长，成年人总是要单打独斗，你不变得更优秀又怎么能认识更优秀的人呢？古人云：「<b>物以类聚，人以群分</b>」，你所处的圈子，核心不在于环境，而在于你自己。</p><p>最后一句：「不要给自己的人生设限」。社会决定你所处的环境，但是你决定了自己的发展。</p>", 
            "topic": [
                {
                    "tag": "坚持", 
                    "tagLink": "https://api.zhihu.com/topics/19579252"
                }
            ], 
            "comments": [
                {
                    "userName": "leacoder", 
                    "userLink": "https://www.zhihu.com/people/b5394a59027b05124e89b96d8d0eeb68", 
                    "content": "<p>nb   <a href=\"http://link.zhihu.com/?target=https%3A//pic3.zhimg.com/50/v2-fa3cb6bc9ec57da84ab53a60f48d0c6f_hd.gif\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">pic3.zhimg.com/50/v2-fa</span><span class=\"invisible\">3cb6bc9ec57da84ab53a60f48d0c6f_hd.gif</span><span class=\"ellipsis\"></span></a>，之前英语我最多的是在流利说上面坚持了250+天。<br>很有感触的一篇文章。ARTS我也已连续打卡十八，中间难受过迷茫过怀疑过也想过放弃不过最后还是坚持下来了。过去偷过的懒最后都是要还的。最后借用你的文中的话，不要给自己的人生设限。</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "<p>共勉</p>", 
                            "likes": 1, 
                            "replyToAuthor": "leacoder"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>一起加油吧</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73557485", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "﻿左耳听风 第三十六周", 
            "content": "<h2>﻿左耳听风 第三十六周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题，以下为个人题解：</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode26.%25E5%2588%25A0%25E9%2599%25A4%25E6%258E%2592%25E5%25BA%258F%25E6%2595%25B0%25E7%25BB%2584%25E4%25B8%25AD%25E7%259A%2584%25E9%2587%258D%25E5%25A4%258D%25E9%25A1%25B9.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode26.删除排序数组中的重复项</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode27.%2520%25E7%25A7%25BB%25E9%2599%25A4%25E5%2585%2583%25E7%25B4%25A0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode27. 移除元素</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode28.%2520%25E5%25AE%259E%25E7%258E%25B0strStr%28%29.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode28. 实现strStr()</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode29.%2520%25E4%25B8%25A4%25E6%2595%25B0%25E7%259B%25B8%25E9%2599%25A4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode29. 两数相除</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/free-code-camp/am-i-a-real-software-engineer-yet-a0f38a2248c0\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Am I a “real” Software Engineer yet?</a> 「我真的是一个软件工程师吗？」</p><p>作者讲述了自己开始自学编程，做出项目，找到工作却在这个过程中不断遭受「不是一个真正的软件工程师」的质疑，最终找到了自己想要的答案，继续从事编程的故事。</p><p>谁呢说清楚「软件工程师」的真正定义呢？是要能够独立做出一个项目？还是需要找到一份软件工程师的工作？还是一定要获得软件工程学位证书，学会各种高大上的技术，在软件行业从事几十年呢？</p><p>对于你编程能力的成长来说，这些并没有多大的意义。而且在你从一个菜鸟码农成长为一个能够编程大牛前，会遇到更多的质疑，甚至更多的是 <b>你对自己能力的质疑</b>。</p><p>回应别人的质疑的最好答案就是将恐惧、不安转化为你更为努力的动力，努力的学习你工作中所缺乏的知识，通过编程去解决问题（或者更好的解决问题），获得成长，这才是面对问题的正确态度。不要轻易给自己的人生设限，你能够做的更好。</p><h2>Tip</h2><p>基于 MySQL 数据库提供的限制语句 limit arg1,arg （参数1「arg1」代表查询结果的起始索引限制，参数2「arg2」代表对查询结果数量限制），实现分页功能 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dfa2ecfaead0fe3631a05b50de8ac0d5_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-dfa2ecfaead0fe3631a05b50de8ac0d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-dfa2ecfaead0fe3631a05b50de8ac0d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dfa2ecfaead0fe3631a05b50de8ac0d5_b.png\"/></figure><p> 参考代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Hero</span><span class=\"o\">&gt;</span> <span class=\"nf\">findByPage</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">start</span><span class=\"o\">,</span><span class=\"n\">String</span> <span class=\"n\">row</span><span class=\"o\">){</span>\n        <span class=\"c1\">// sql 语句\n</span><span class=\"c1\"></span>        <span class=\"n\">String</span> <span class=\"n\">sql</span> <span class=\"o\">=</span> <span class=\"s\">&#34;SELECT name,role_main,attack_range,hp_growth FROM heros limit &#34;</span> <span class=\"o\">+</span> <span class=\"n\">start</span> <span class=\"o\">+</span> <span class=\"s\">&#34;,&#34;</span> <span class=\"o\">+</span> <span class=\"n\">row</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 通过 BeanPropertyRowMapper 将查询结果封装成 heros 集合\n</span><span class=\"c1\"></span>        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Hero</span><span class=\"o\">&gt;</span> <span class=\"n\">heroes</span> <span class=\"o\">=</span> <span class=\"n\">template</span><span class=\"o\">.</span><span class=\"na\">query</span><span class=\"o\">(</span><span class=\"n\">sql</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">BeanPropertyRowMapper</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">Hero</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">));</span>\n        <span class=\"c1\">// 返回查询的分页结果\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">heroes</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>前端只需要将对应的页号以及默认每页所显示的行数发送给后端即可。</p><p>SQL语句中的 <b>起始索引</b> start = （页号-1）*行数。（索引从 0 开始，页号从 1 开始）</p><p>行数与前端传递一致</p><p>总页数为：查询总数/行数（若能整除不变否则再 +1）</p><h2>share</h2><p>根据最近学习的 HTTP 方面的基础知识整理成了文章。</p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzU4NzA5NzE0Mw%3D%3D%26mid%3D2247483931%26idx%3D1%26sn%3D7ee9febe1b05df9bda27da8c6811a351%26chksm%3Dfdf07743ca87fe55db693e09678a891df74596563035b303454a07c70e60220a07287d3d2403%26token%3D1472094287%26lang%3Dzh_CN%23rd\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">初探 HTTP</a><p></p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73525517", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "初探HTTP", 
            "content": "<h2>HTTP 是什么？</h2><p><b>HTTP</b> : HyperText Transfer Protocol 。根据字面意思我们可以翻译为超文本传输协议。</p><p>它是一种位于「<b>应用层</b>」，专门为 web浏览器 和 web服务器 之间通信的而设计的协议。因为网页上通常传输的是 HTML 这样的超媒体文档，所以被称超文本传输协议。</p><p><b>HTTP</b> 是基于「 TCP协议」之上的，所以它也具有的 「 TCP协议」的特点：<b>可靠，传输效率相对较低</b>。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5859f530634f2f7f9277922afb940c75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"856\" data-original=\"https://pic2.zhimg.com/v2-5859f530634f2f7f9277922afb940c75_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;856&#39; height=&#39;414&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"856\" data-original=\"https://pic2.zhimg.com/v2-5859f530634f2f7f9277922afb940c75_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5859f530634f2f7f9277922afb940c75_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>HTTP 首部</h2><p>HTTP 首部可以分为 4 个部分：一般头、请求头、响应头、实体头。</p><p>我们可以在任意浏览器中「右键 —— 检查」查看服务器与浏览器之间的网络情况。（推荐 Firefox） </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a27908d763531d056659399b22e4342_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1322\" class=\"origin_image zh-lightbox-thumb\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-3a27908d763531d056659399b22e4342_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2560&#39; height=&#39;1322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-3a27908d763531d056659399b22e4342_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a27908d763531d056659399b22e4342_b.jpg\"/></figure><p> 以百度为例，一般头里存放的是请求信息，主要包括：请求网址、请求方法、返回状态码、连接采用的协议等。</p><div class=\"highlight\"><pre><code class=\"language-text\">请求网址:https://www.baidu.com/\n请求方法:GET\n远程地址:180.101.49.11:443\n状态码:\n200\n版本:HTTP/1.1\nReferrer 政策:no-referrer-when-downgrade</code></pre></div><p>而作为 web 开发，我们需要重点关注的是 <b>request</b>（请求头）、<b>response</b>（响应头）两部份。</p><p><b>request</b>（请求头），会把客户端的信息放在里面发送给服务器。例如：可接收数据、接受编码格式、语言、连接是否保存、请求的主机域名（可以让多台服务器的任意一台响应）、浏览器信息、<b>Cookie</b> 、<b>来源网址</b>（防盗链）等。</p><div class=\"highlight\"><pre><code class=\"language-text\">Host: www.baidu.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:67.0) Gecko/20100101 Firefox/67.0\nAccept: text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate, br\nReferer: https://www.baidu.com/\nX-Requested-With: XMLHttpRequest\nConnection: keep-alive\nCookie: BAIDUID=03E141A2389016553988E825286E0A2F:FG=1;\n1\nUser-Agent  \nMozilla/5.0 (Windows NT 10.0; …) Gecko/20100101 Firefox/67.0</code></pre></div><p><b>response</b>（响应头）：服务器接受到请求根据需要发送数据给客户端。会包含：请求的结果（状态码）、返回数据的长度、编码格式、时间等</p><div class=\"highlight\"><pre><code class=\"language-text\">HTTP/1.1 200 OK\nContent-Length: 74\nContent-Type: text/plain; charset=UTF-8\nDate: Sun, 14 Jul 2019 01:45:57 GMT</code></pre></div><h2>常见请求方法</h2><p>常与后端打交道的两种请求方法有：get、post。</p><p>GET 方法，将请求的参数位于 URL 后，例如：<a href=\"https://link.zhihu.com/?target=https%3A//www.sogou.com/web%3Fquery%3D123%26_asf%3Dwww.sogou.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">sogou.com/web?</span><span class=\"invisible\">query=123&amp;_asf=www.sogou.com</span><span class=\"ellipsis\"></span></a>，请求的网址为 <a href=\"https://link.zhihu.com/?target=https%3A//www.sogou.com/web\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">sogou.com/web</span><span class=\"invisible\"></span></a>，以「?」来分割请求网址和请求参数信息，query 为参数名称，123 为参数值，以等号来对应参数名称和值，多个参数之间以「&amp;」区分。</p><p>POST 方法，将见于：表单提交，带有敏感信息的请求，所发送的数据隐藏在 HTTP 包中，不显式可见。</p><p>二者区别：</p><ul><li><b>传输数据方面</b>：「GET 方法」通过 URL 传递数据，而 URL 的长度是有限制的，无法传输图片、视频等大数据。而「POST 方法」数据存在于 HTTP 包中，理论上不受限制。</li><li><b>安全性方面</b>：「GET 方法」数据显示在 URL 中，容易被窃取，而「POST 方法」不显式可见，更不易被窃取，相对安全。</li></ul><h2>HTTP 无状态，有会话</h2><p><b>无状态</b>：同一连接上的任意两个请求没有链接。服务器无法直接通过连接知道上一请求的状态。</p><p>HTTP 的解决，通过 <b>cookie</b>，来记录上一次请求的状态，服务器通过 cookie 告知上一请求的状态，与客户端建立会话。</p><p><b>cookie</b>：  1. 由服务器建立，存储于客户端。  2. 客户端每次请求 <b>自动</b> 将已有 Cookie 发送给客户端。例：<code>Cookie: BAIDUID=03E141A2389016553988E825286E0A2F:FG=1</code>。  3. 默认存储在内存中，随着浏览器的关闭而销毁。可以手动设置 Cookie 的存活时间（写入本地硬盘 ），例：<code>Cache-Control: max-age= 300</code>，单位为秒。  4. 大小限制在 4KB。</p><p>由 cookie 写入本地硬盘引发的问题： 1. <b>不安全性</b>。黑客可以通过获取本地的 cookie 获得信息，本地文件可以人为修改。 2. <b>存储数据量不足</b>。随着 web服务的升级，会话所需要传递的数据远不止 4KB。</p><p>所以，cookie 仅用来存储一些不太重要的信息。</p><p>解决方案 session：</p><p>session 将数据存储在 <b>服务器</b>，客户端仅用 cookie 存储 session 的 id。</p><h2>HTTP 状态码</h2><p>HTTP 状态码可分为 5 种： 1.  1XX。以 1 开头，表示 <b>该响应尚未完成</b>。常见的有：101，表示 HTTP 协议的切换。 2. 2XX。以 2 开头，表示 <b>成功响应</b>。常见代码：200 OK，表示请求成功。 3. 3XX。以 3 开头，表示<b>重定向</b>。</p><blockquote> 常见代码：304：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码<br/> </blockquote><ol><li>4XX。以 4 开头，通常表示客户端错误。常见代码 404 ，表示客户端所请求的资源并未在服务器上找到。 </li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1a43800ca2873855b85a0e88fea431be_b.jpg\" data-size=\"normal\" data-rawwidth=\"1808\" data-rawheight=\"1206\" class=\"origin_image zh-lightbox-thumb\" width=\"1808\" data-original=\"https://pic3.zhimg.com/v2-1a43800ca2873855b85a0e88fea431be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1808&#39; height=&#39;1206&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1808\" data-rawheight=\"1206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1808\" data-original=\"https://pic3.zhimg.com/v2-1a43800ca2873855b85a0e88fea431be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1a43800ca2873855b85a0e88fea431be_b.jpg\"/><figcaption>404</figcaption></figure><ol><li>5XX。以 5 开头，通常表示服务端响应错误。常见代码 500，表示服务器运行出错。 </li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e0b87e96134dc3f522e0fb0b429baef0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb\" width=\"1042\" data-original=\"https://pic1.zhimg.com/v2-e0b87e96134dc3f522e0fb0b429baef0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1042&#39; height=&#39;559&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1042\" data-original=\"https://pic1.zhimg.com/v2-e0b87e96134dc3f522e0fb0b429baef0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e0b87e96134dc3f522e0fb0b429baef0_b.jpg\"/></figure><p> 总结，1XX、2XX、3XX 都属于正常的响应，而 4XX、5XX 都是非正常响应，需要程序员去处理，不能直接将错误暴露给用户。</p><p>本篇文章，参考了 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/HTTP\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MDN官方文档</a>，感兴趣的朋友可以自己去官网查看文档，也可以评论发表你的看法。</p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "计算机网络", 
                    "tagLink": "https://api.zhihu.com/topics/19572894"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72570388", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "编程能力不足的表现", 
            "content": "<p>「<b>缺乏好奇心</b>」。这是编程入门者最常挂在嘴边的话，「我对编程一点兴趣也没有」、「学编程对我来说太痛苦了」，可是你是否有换过不同的学习方式呢？看不来编程的书，可以可以看看教学视频。不喜欢老师枯燥乏味的课，你可能会对培训机构风趣的讲解感兴趣。</p><p>可是如果你一点也不愿意尝试，那你可能真的不适合做一个程序员，需要开始选择另一个职业了。</p><p>「<b>缺乏自主性，面对问题缺乏坚持</b>」。学习是一个自发的过程，如果你心里不愿意去学，你只会越学越心烦最终收获的只有糟糕的心情。面对问题，先学会自己去寻找一些答案，不要像小孩一样总想着有人会给你「喂饭」，成年人尤其是一名程序员，是需要我们自己去学习在异常、出错中找到我们的问题，并以此寻找解决的办法。</p><p>「<b>解决问题却没有成就感</b>」。同第一点一样，说明你没有把编程当做一种挑战，没有收获感、成就感。这真是个大问题，或许是你解决的问题过于简单，让你没有成就感，又或者你的问题并没有自己动手解决，而是别人帮你完成的。试试看，当你绞尽脑汁，终于把你手上的 BUG 解决时，那种成就感是对你自己能力的自信，是旁人所无法感受的。</p><p>「<b>缺乏耐心去学习和理解</b>」。编程是需要长期学习，以至于终生学习的技术。每一天都会有新的技术出现，web 前端方向更是如此，一周一小变、一月一大变，或许你半年没去了解行业，可能你就错过了许多门新技术。所以，你要静下心来，去学习那些编程最为核心和基础的东西：数据结构和算法、操作系统、计算机网络、数据库、计算机组成原理，这样才能不被技术的迭代而淘汰。</p><p>「<b>追求正确的答案，而忽略评定好坏的标准</b>」。每一段代码或者某种编程语言都有他们的应用场景，超出这个范围，或许答案就会变化。所以不要单一的去记答案，而是理解它的由来，最终根据你的实际需求得出你想要的答案。</p><p>可能你会发现你也具有以上列出的几项特征，但是不必给自己贴上不适合编程的标签。所有提出的问题都是可以改变和解决的，而我们真正需要做的就是开始行动，开始改变。</p><p>文章出自我对 <a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/10-signs-you-will-suck-at-programming-5497a6a52c5c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">10 Signs You Will Suck at Programming</a>  一文的感触，你可以根据链接观看原文，也可以于评论区发表你的看法。</p>", 
            "topic": [
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72550296", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第三十五周", 
            "content": "<h2>左耳听风 第三十五周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode21.%2520%25E5%2590%2588%25E5%25B9%25B6%25E4%25B8%25A4%25E4%25B8%25AA%25E6%259C%2589%25E5%25BA%258F%25E9%2593%25BE%25E8%25A1%25A8.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode21. 合并两个有序链表</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode24.%2520%25E4%25B8%25A4%25E4%25B8%25A4%25E4%25BA%25A4%25E6%258D%25A2%25E9%2593%25BE%25E8%25A1%25A8%25E4%25B8%25AD%25E7%259A%2584%25E8%258A%2582%25E7%2582%25B9.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode24. 两两交换链表中的节点</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode25.%2520K%2520%25E4%25B8%25AA%25E4%25B8%2580%25E7%25BB%2584%25E7%25BF%25BB%25E8%25BD%25AC%25E9%2593%25BE%25E8%25A1%25A8.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode25. K 个一组翻转链表</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/java-multithreading-part-1-ec0c42bbead6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java: Multithreading — Part 1</a> 「Java ：多线程 —— 第一部分」</p><p>操作系统控制多个应用程序 —— 进程</p><p>一个应用程序里的多个功能 —— 线程</p><p>并发：同一时间段执行多个任务</p><p>并行：同一时刻执行多个任务</p><p>线程、进程出现的原因：有效的利用计算机资源，并发执行多个任务。</p><p>单线程与多线程的对比：</p><ul><li>单线程：复杂性低（程序运行不容易出错），资源利用率低。 </li><li>多线程：复杂性高（程序运行容易出错），资源利用率高。</li></ul><p>栈：用来存储私有变量（局部变量、方法参数），使用完栈帧立即释放该部分内存。不可共享。</p><p>堆：存储类对象代码，共享资源，可以被 <b>多个线程读写</b>。只有在对象被垃圾回收器回收时才会释放该部分内存。</p><p>而每一个线程都有自己独立的栈，存储自己的私有变量，对于存储在堆中的对象（共享资源）访问时可能会修改其状态（例如类对象的成员变量值），所以 Java 中引入了锁机制帮我们确保程序执行的「<b>原子性</b>」、「<b>一致性</b>」。</p><p>维基百科解释：</p><blockquote> Atomicity（原子性）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。 <br/>Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。<br/> Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。 <br/>Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</blockquote><p>线程可能会因为资源不足由执行状态进入阻塞状态，此时若该线程事务未执行完，而其他线程继续访问该数据就会出现「<b>读脏数据</b>」、问题。</p><p>举例说明：线下购物，小明购买商品转账给商户，小明账户扣款，因系统故障商户账户金额到账未执行。此时读取小明、商户账户金额就会读出错误的数据。</p><p>通过锁机制，确保事务执行时，其他线程无法读取正在修改的数据，确保程序的有效运行</p><h2>Tip</h2><p>Java Lambda 表达式，简写函数式接口的实现，这也是 Java 8 中的新特性。</p><p>首先我们需要一个函数式接口：有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。</p><p>例如：调用 Collections.sort() 方法对非基本类型排序（通常可能是我们自己定义的类），我们需要实现一个 Comparator 接口，对要排序的非基本类型数组进行升序或降序以及其他自定义规则的排序。</p><p>在 Java 8 以前如果只调用一次，那该接口的实现我们可能会选择匿名类</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"n\">Random</span> <span class=\"n\">rd</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Random</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">rd</span><span class=\"o\">.</span><span class=\"na\">nextInt</span><span class=\"o\">(</span><span class=\"n\">100</span><span class=\"o\">));</span> <span class=\"c1\">// 随机生成 10 个 [0,100) 之间的数\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n        <span class=\"c1\">// 普通写法，匿名类实现 Comparator 接口\n</span><span class=\"c1\"></span>        <span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">Comparator</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;()</span> <span class=\"o\">{</span>\n            <span class=\"nd\">@Override</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">compare</span><span class=\"o\">(</span><span class=\"n\">Integer</span> <span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">Integer</span> <span class=\"n\">o2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">o1</span> <span class=\"o\">-</span> <span class=\"n\">o2</span><span class=\"o\">;</span> <span class=\"c1\">// 升序排序\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n        <span class=\"o\">});</span></code></pre></div><p>而 lambda 表达式可以帮我们简写这一段代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// Lambda 表达式写法\n</span><span class=\"c1\"></span><span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">Integer</span> <span class=\"n\">o1</span><span class=\"o\">,</span> <span class=\"n\">Integer</span> <span class=\"n\">o2</span><span class=\"o\">)-&gt;</span> <span class=\"o\">{</span><span class=\"k\">return</span> <span class=\"n\">o1</span><span class=\"o\">-</span><span class=\"n\">o2</span><span class=\"o\">;});</span></code></pre></div><p>我们还可以进一步简化</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 简写法,省略参数类型、关键字、以及括号\n</span><span class=\"c1\"></span><span class=\"n\">Collections</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">,(</span><span class=\"n\">o1</span><span class=\"o\">,</span><span class=\"n\">o2</span><span class=\"o\">)-&gt;</span><span class=\"n\">o1</span><span class=\"o\">-</span><span class=\"n\">o2</span><span class=\"o\">);</span></code></pre></div><p>Lambda 表达式是对「函数式」接口的实现简写，可以帮我们简化代码，可以一句写完的干嘛要四句呢？作为程序员要能够简化自己的工作。</p><h2>share</h2><p>最近在看理财方面的入门书籍《富爸爸穷爸爸》，对于其中的两个问题很有感触，「<b>什么是你的事业？什么是你的职业</b>？」、「<b>现金流不足，你却买了自己相要的奢侈品？现金流充足你买了自己想要的奢侈品？感觉有何不同</b>？」</p><p>这两个问题在当下很常见，我给出了自己的思考：<a href=\"https://zhuanlan.zhihu.com/p/72549085\" class=\"internal\">关注自己的事业</a>，欢迎讨论。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d79469830a7cba4dfd8573a5934eb4e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"2113\" class=\"origin_image zh-lightbox-thumb\" width=\"884\" data-original=\"https://pic3.zhimg.com/v2-d79469830a7cba4dfd8573a5934eb4e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;884&#39; height=&#39;2113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"2113\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"884\" data-original=\"https://pic3.zhimg.com/v2-d79469830a7cba4dfd8573a5934eb4e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d79469830a7cba4dfd8573a5934eb4e6_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71615908", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十四周", 
            "content": "<h2>左耳听风 第三十四周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode18.%2520%25E5%259B%259B%25E6%2595%25B0%25E4%25B9%258B%25E5%2592%258C.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode18. 四数之和</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode19.%2520%25E5%2588%25A0%25E9%2599%25A4%25E9%2593%25BE%25E8%25A1%25A8%25E7%259A%2584%25E5%2580%2592%25E6%2595%25B0%25E7%25AC%25ACN%25E4%25B8%25AA%25E8%258A%2582%25E7%2582%25B9.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode19. 删除链表的倒数第N个节点</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/10-signs-you-will-suck-at-programming-5497a6a52c5c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">10 Signs You Will Suck at Programming</a> 「你编程很差的 10 个迹象」</p><p>作者更具他多年「全栈工程师」的培训经验，总结出了 10 个他认为在编程中能力差的迹象。</p><p>「缺乏好奇心」。对编程提不起兴趣？你应该认真对待这个问题看看是不是真的要做一名程序员。</p><p>「缺乏自主性和智慧」。无法自动去学习一些知识，只等着别人教你。</p><p>「面对问题缺乏坚持」。一遇到难题就放弃？但是编程的本质便是「<b>解决问题</b>」。</p><p>「解决问题却没有成就感」。同第一点一样，说明你没有把编程当做一种挑战，没有收获感、成就感。</p><p>「缺乏耐心去学习和理解」。编程是需要长期学习，以至于终生学习的技术。</p><p>「对思考厌烦」。没有思考，永远不会有真正的收获。</p><p>「无法独立思考」。</p><p>「僵硬、有限或无组织的思考」。</p><p>「需要“正确”的答案，而不是认识到一系列“好”和“坏”的答案」。问题的答案并不唯一，而是会根据环境的变化以及人物的不同而改变。编程也是一门科学类的学科，你需要做的是理解这个过程的得来，再需要自己认为最满意的答案。</p><p>「不关注细节」。计算机是一门精细的仪器，任何微小的错误都会导致程序运行的失败，与其编写了数万行代码后再头疼的逐句检测错误，不如在开始就关注好细节问题。</p><p>这些问题不限于编程，应该是每一个领域发展都可以参照的，这里所有的问题都是可以改变和解决的，而我们真正需要做的就是开始行动，开始改变。</p><h2>Tip</h2><p>来自极客时间专栏「<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/article/103782\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SQL 必知必会</a>」的评论和老师的解答 通常 SQL 会使用到 count(*)等函数 然后对于统计的结果进行排序，这时如果字段名字过长可以采用别名的形式来代替长名称</p><p>给 COUNT(<i> ) 取上别名 num ，可以直接在排序中使用 num 代替  COUNT(</i>) </p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">SELECT</span> <span class=\"k\">COUNT</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">AS</span> <span class=\"n\">num</span><span class=\"p\">,</span><span class=\"n\">ROUND</span><span class=\"p\">(</span> <span class=\"k\">AVG</span><span class=\"p\">(</span><span class=\"n\">hp_max</span><span class=\"o\">+</span><span class=\"n\">mp_max</span><span class=\"p\">),</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"n\">ROUND</span><span class=\"p\">(</span><span class=\"k\">MAX</span><span class=\"p\">(</span><span class=\"n\">hp_max</span><span class=\"o\">+</span><span class=\"n\">mp_max</span><span class=\"p\">),</span><span class=\"mi\">2</span><span class=\"p\">),</span><span class=\"n\">ROUND</span><span class=\"p\">(</span><span class=\"k\">MIN</span><span class=\"p\">(</span><span class=\"n\">hp_max</span><span class=\"o\">+</span><span class=\"n\">mp_max</span><span class=\"p\">),</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"k\">FROM</span> <span class=\"n\">heros</span>\n<span class=\"k\">WHERE</span> <span class=\"n\">hp_max</span><span class=\"o\">+</span><span class=\"n\">mp_max</span><span class=\"o\">&gt;</span><span class=\"mi\">7000</span>\n<span class=\"k\">GROUP</span> <span class=\"k\">BY</span> <span class=\"n\">attack_range</span>\n<span class=\"k\">ORDER</span> <span class=\"k\">BY</span>  <span class=\"n\">num</span> <span class=\"k\">DESC</span><span class=\"p\">;</span></code></pre></div><p>原理：虽然字段的执行顺序在 ORDER BY 之后，但是 COUNT(*)、AVG（）等函数会在 select 字段之前先执行，所以这里直接使用聚合函数的别名并不会出现错误。聚集函数在 GROUP BY 之后、HAVING之前执行。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/71597055\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8ada40744e8eee57642ea06abd6d994c_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2730\" class=\"internal\">胡sir：浅谈 Java 中的初始化</a><p>﻿Java 中类初始所遵循的原则： ﻿ ﻿1、类构造函数调用时，先初始化类中的成员变量，所有成员变量初始化完成后，再执行构造函数代码。 ﻿ 2、父类构造函数完成再执行子类构造函数。</p><p>3、静态（static）成员初始化后再初始化非静态成员</p><p>4、同一优先级，按照代码的先后顺序执行。</p><p>若文章中有错误欢迎指正。期待你给出的评论，默默点点赞、给个好看也是对我的一种认可。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71597055", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "浅谈 Java 中的初始化", 
            "content": "<h2>Java 内存分布 </h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3844e752172c3945f90f0a16c6a7dfe4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1499\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb\" width=\"1499\" data-original=\"https://pic1.zhimg.com/v2-3844e752172c3945f90f0a16c6a7dfe4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1499&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1499\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1499\" data-original=\"https://pic1.zhimg.com/v2-3844e752172c3945f90f0a16c6a7dfe4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3844e752172c3945f90f0a16c6a7dfe4_b.jpg\"/></figure><p> 需要注意的是，<b>方法中的参数属于局部变量</b> ，类似于 <code>String str=&#34;字符串&#34;</code> 这样定义的字符串是存放在堆内存中的「字符串常量池」（常量池中不会添加已有成员）中。</p><p>而 <code>String str1 = new String()</code> 内存是直接位于堆中，每一次对象的实例化都会在堆中开辟新的内存空间。</p><h2>成员变量与局部变量的区别</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9d33daadf7d8af7ab3ecf96243021eba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1203\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"1203\" data-original=\"https://pic3.zhimg.com/v2-9d33daadf7d8af7ab3ecf96243021eba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1203&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1203\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1203\" data-original=\"https://pic3.zhimg.com/v2-9d33daadf7d8af7ab3ecf96243021eba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9d33daadf7d8af7ab3ecf96243021eba_b.jpg\"/></figure><p> 结合代码分析</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Person</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Person</span><span class=\"o\">(){</span> <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Person</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 两个参数属于局部变量，调用完成后被销毁，且只能在该方法内部访问\n</span><span class=\"c1\"></span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">=</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">showInfo</span><span class=\"o\">(){</span> <span class=\"c1\">// 类内部访问成员变量\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;name =&#34;</span> <span class=\"o\">+</span> <span class=\"n\">name</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;age = &#34;</span><span class=\"o\">+</span><span class=\"n\">age</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">TestDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Person</span> <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Person</span><span class=\"o\">();</span>\n        <span class=\"n\">p1</span><span class=\"o\">.</span><span class=\"na\">showInfo</span><span class=\"o\">();</span>\n        <span class=\"n\">Person</span> <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Person</span><span class=\"o\">(</span><span class=\"s\">&#34;hack-hu&#34;</span><span class=\"o\">,</span><span class=\"n\">18</span><span class=\"o\">);</span>\n        <span class=\"n\">p2</span><span class=\"o\">.</span><span class=\"na\">showInfo</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>输出结果：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// p1 输出缺省值，两个成员变量都被自动初始化\n</span><span class=\"c1\"></span><span class=\"n\">name</span> <span class=\"o\">=</span><span class=\"kc\">null</span>\n<span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">0</span>\n<span class=\"c1\">// p2 输出赋值后结果，重载的构造方法在调用完成后销毁\n</span><span class=\"c1\"></span><span class=\"n\">name</span> <span class=\"o\">=</span><span class=\"n\">hack</span><span class=\"o\">-</span><span class=\"n\">hu</span>\n<span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">18</span></code></pre></div><p>提示：虽然成员变量会自动完成初始化，但是在定义时或使用前先初始化是个好习惯。</p><h2>类中数据的初始化顺序</h2><p>原则：</p><ul><li> 1、类构造函数调用时，先初始化类中的成员变量，<b>所有成员变量初始化完成后</b>，再执行构造函数代码。<br/> </li><li> 2、父类构造函数完成再执行子类构造函数。<br/> </li><li> 3、静态（static）成员初始化后再初始化非静态成员<br/> </li><li> 4、同一优先级，按照代码的先后顺序执行。<br/> </li></ul><p>代码实践</p><p>定义父类 Person </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Person</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;父类静态块代码执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Person</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;父类构造函数执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Person</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">=</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">showInfo</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;name =&#34;</span> <span class=\"o\">+</span> <span class=\"n\">name</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;age = &#34;</span><span class=\"o\">+</span><span class=\"n\">age</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>定义其旁类 Nationality （国籍）</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Nationality</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;旁类静态块执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Nationality</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;旁类构造方法执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>定义 Person 子类 Student</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Student</span> <span class=\"kd\">extends</span> <span class=\"n\">Person</span> <span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"n\">Nationality</span> <span class=\"n\">nation</span><span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Nationality</span><span class=\"o\">();</span>\n    <span class=\"kd\">static</span> <span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;子类静态块执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Student</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;子类构造函数执行&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>输出结果：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">父类静态块代码执行</span>\n<span class=\"n\">旁类静态块执行</span>\n<span class=\"n\">旁类构造方法执行</span>\n<span class=\"n\">子类静态块执行</span>\n<span class=\"n\">父类构造函数执行</span>\n<span class=\"n\">子类构造函数执行</span></code></pre></div><p>注意，子类中的静态对象 nation，要比父类的构造函数先执行，说明所有的静态成员都要先初始化。当 nation 不为静态时，则先完成父类构造，再初始化子类非静态成员。</p><p>总结：实践出真知，对于含糊不清的概念，可以实践一些案例来参照理解。若文章中有错误欢迎指正，欢迎你给出评论，或是默默点点赞给个好看，这都是对我的一种认可。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71253047", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode19. 删除链表的倒数第N个节点", 
            "content": "<h2>删除链表的倒数第N个节点 </h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-nth-node-from-end-of-list/submissions/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-5aef94ed53c22bbb9cf77c6a92ef921a_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除链表的倒数第N个节点 - 力扣（LeetCode）</a><blockquote> 给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。<br/> 示例：  给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br/> 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-5.</blockquote><p>双指针法解题思路：  - node 指针指向头结点，fast 指针指向 node 后的第 n+1 个结点   - 双指针同时向后遍历，当 fast 遍历至链尾时， node  指针指向下一结点的下一结点即可   - 特殊情况，要删除的结点为头结点，即 fast 在定义时就遍历至链尾，则返回头结点的下一结点即可</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">removeNthFromEnd</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">node</span><span class=\"o\">=</span><span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n            <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">fast</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">){</span> <span class=\"c1\">// 若已遍历至链尾说明要删除的就是头结点\n</span><span class=\"c1\"></span>                <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">fast</span><span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span><span class=\"o\">!=</span><span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">fast</span><span class=\"o\">=</span><span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">node</span><span class=\"o\">=</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">=</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span>  <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71252688", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode18. 四数之和", 
            "content": "<h2>﻿四数之和 </h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/4sum/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">题目链接</a><blockquote> 给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。<br/> 注意： 答案中不可以包含重复的四元组。</blockquote><p>解题思路：</p><ol><li>在三数之和的思路上修改，首先是对数组进行排序，将 nums 升序排序 </li><li>先选取 nums 中的一个数（第一层外循环），再在剩余数中选取第二个数（第二层循环）  剩余两个数分别从剩余数的最小端 left 、最大端 right扫描数组 </li><li>当四数之和与 target 相等时 ，加入当前四数组合，继续查找下一四数组合。（HashSet 去除重复项）</li><li>若大于 target ，则 right 向左端扫描</li><li>若小于 target ，则 left 向右端扫描</li></ol><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"nf\">fourSum</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">lists</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"n\">HashSet</span><span class=\"o\">&lt;</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">map</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">HashSet</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">lists</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">);</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">len</span><span class=\"o\">-</span><span class=\"n\">3</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++){</span>\n            <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span><span class=\"n\">j</span><span class=\"o\">&lt;</span><span class=\"n\">len</span><span class=\"o\">-</span><span class=\"n\">2</span><span class=\"o\">;</span><span class=\"n\">j</span><span class=\"o\">++){</span>\n                <span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"o\">=</span><span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"o\">=</span><span class=\"n\">len</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">left</span><span class=\"o\">&lt;</span><span class=\"n\">right</span><span class=\"o\">){</span>\n                    <span class=\"kt\">int</span> <span class=\"n\">sum</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]+</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]+</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">]+</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">];</span>\n                    <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"o\">){</span>\n                        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;()</span> <span class=\"o\">;</span>\n                        <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span><span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]);</span><span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">left</span><span class=\"o\">]);</span><span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">right</span><span class=\"o\">]);</span>\n                        <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span> <span class=\"c1\">// 用哈希表去重,将匹配的四数集合放入 map\n</span><span class=\"c1\"></span>                        <span class=\"n\">left</span><span class=\"o\">++;</span>\n                        <span class=\"n\">right</span><span class=\"o\">--;</span>\n                        <span class=\"k\">continue</span><span class=\"o\">;</span> <span class=\"c1\">// 继续查找下一可能组合\n</span><span class=\"c1\"></span>                    <span class=\"o\">}</span>\n                    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">sum</span><span class=\"o\">&gt;</span><span class=\"n\">target</span><span class=\"o\">){</span>\n                        <span class=\"n\">right</span><span class=\"o\">--;</span> <span class=\"c1\">// 减小四数和\n</span><span class=\"c1\"></span>                    <span class=\"o\">}</span>\n                    <span class=\"k\">else</span> <span class=\"o\">{</span>\n                        <span class=\"n\">left</span><span class=\"o\">++;</span> <span class=\"c1\">// 增大四数和\n</span><span class=\"c1\"></span>                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">lists</span><span class=\"o\">.</span><span class=\"na\">addAll</span><span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">);</span> <span class=\"c1\">// 将所有非重复结果加入 lists\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">lists</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70312708", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十三周", 
            "content": "<h2>左耳听风 第三十三周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%252017.%2520%25E7%2594%25B5%25E8%25AF%259D%25E5%258F%25B7%25E7%25A0%2581%25E7%259A%2584%25E5%25AD%2597%25E6%25AF%258D%25E7%25BB%2584%25E5%2590%2588.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 17. 电话号码的字母组合</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/sololearn/warning-your-programming-career-b9579b3a878b\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Warning: Your programming career</a> 「警告：你的职业生涯」</p><p>这是一篇非常适合初级程序员的文章。对于一名初级程序员或是入门者，最常见的问题就是：我该选择什么语言？我该从哪开始？我该如何获得一份程序员的工作？</p><p>而作者推荐的「<b>被一家科技公司雇为程序员我该知道些什么？</b>」。</p><p>首先要知道的是你想要从那一块开始：</p><p>1、<b>Web</b>。做类似于谷歌搜索、亚马逊商城、推特这样的网站。</p><p>2、<b>桌面开发</b>。做 Photoshop, Visual Studio 这样的桌面应用。</p><p>3、<b>移动开发</b>。各类手机 App。</p><p>根据你的兴趣选择方向，然后再进一步细分。</p><p>前端还是后端，想要实现视觉效果或者感觉还是想要实际的解决需求。至于到底该选择怎样的语言或者技术，取决于你所期望的公司所使用的技术栈。</p><p>除了选择一门技术或者语言外，一名程序员还需要掌握：基本的数据结构与算法、计算机组成原理、操作系统、编程技巧、安全、系统设计等知识。</p><p>作为新手你不必掌握所有的语言或是以上的所有技术，但是这可以作为一张清单，让你好好规划自己的程序员生涯。</p><h2>Tip</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-22d5fec905a2d8b87742e0553aa94795_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2456\" data-rawheight=\"978\" class=\"origin_image zh-lightbox-thumb\" width=\"2456\" data-original=\"https://pic2.zhimg.com/v2-22d5fec905a2d8b87742e0553aa94795_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2456&#39; height=&#39;978&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2456\" data-rawheight=\"978\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2456\" data-original=\"https://pic2.zhimg.com/v2-22d5fec905a2d8b87742e0553aa94795_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-22d5fec905a2d8b87742e0553aa94795_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//ictclas.nlpir.org/nlpir/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">语义分析系统</a> 分享一个之前收集的网站，「语义分析系统」，可以根据文本对文章进行语义分析。我常用的功能是：关键词提取、摘要提取，可以帮助你快速对文章进行分析、提取出重点，同样可以用这部分数据来做你文章的题图（文字云）。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c54b0f03b01e37a5b2bf80c1060b27b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1393\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb\" width=\"1393\" data-original=\"https://pic3.zhimg.com/v2-c54b0f03b01e37a5b2bf80c1060b27b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1393&#39; height=&#39;719&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1393\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1393\" data-original=\"https://pic3.zhimg.com/v2-c54b0f03b01e37a5b2bf80c1060b27b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c54b0f03b01e37a5b2bf80c1060b27b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/70308777\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-9a2faf2712d7673d07234603d795d045_180x120.jpg\" data-image-width=\"3022\" data-image-height=\"2014\" class=\"internal\">胡sir：学如逆水行舟</a><p>﻿2019 年已过了快一半，身边的很多人包括我自己渐渐有了疲态。打起了游戏、看起了网络小说、没日没夜的刷起了抖音，我们似乎离我们开年初所定的「2019 年计划」越走越远。</p><p>那不想努力的原因是什么？我们又能做些什么呢？</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70308777", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 7, 
            "title": "学如逆水行舟", 
            "content": "<p>﻿2019 年已过了快一半，身边的很多人包括我自己渐渐有了疲态。打起了游戏、看起了网络小说、没日没夜的刷起了抖音，我们似乎离我们开年初所定的「2019 年计划」越走越远。</p><h2>为什么我们不再那么努力</h2><p>在我看来这样的原因有以下几点：</p><p><b>努力学习的反馈周期太长</b>。比如之前学习的「数据结构和算法」，学习周期很长，一些概念需要花上一礼拜或者更长时间去理解，学了三四个月似乎在表面上没有和别人拉开多大的差距。学习一门新的语言（例如：Java），花上一个月可能也才学会基本的语法。</p><p>于此相比，<b>休闲享乐的反馈触手可得</b>。打上一场游戏，马上就能体会到快乐，看一本小说，可以有主角的代入感，刷一刷抖音，全部都是我们爱看的。</p><h2>我们可以怎么做</h2><p><b>改变自己，去掉不合理的计划</b>。一天能做的事不多，但是一年能做的事不少。不要给每天定太多的事，做不完累积下来都是负面情绪。</p><p><b>适当总结，调整方向和方法</b>。「静坐常思己过」，半年或者一个月，看看自己最近的方法、方向是否有问题，看看别人在这方面是怎么踩坑，参考调整自己的方案。</p><p><b>改变外因，打破「马尔可夫链」</b>。之前在池大的文章</p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/BZyPGwQPgYXezCwGewUqCA\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-268630a046c6d044d3f508460df4eb6b_180x120.jpg\" data-image-width=\"1280\" data-image-height=\"543\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">多玩会手机还是多看书？</a><p>看到了「马尔可夫链」。</p><blockquote> 假设你在看书和玩手机两个状态之间的切换概率是固定的。读书的时候，有 40% 的概率转去玩手机，玩手机的时候，有 10% 的概率转去读书。 一旦这四个前提成立，那么无论你怎么分配时间，用了多久，最终的结果只有一个，80% 的时间玩手机，20% 读书。</blockquote><p>通俗来讲，<b>只要你提供了玩手机的条件，最后你学习的时间总会被分出去一部分用来玩手机</b>，再考虑你的自控力、受影响到恢复正常学习时间差，最终你能够真正用来学习的时间不足开始设想的 20%。</p><p>对于打破「马尔可夫链」，你的办法很简单，把玩手机这个条件从链中拿去，即：消除你学习时玩手机的条件。这样你才能确保你学习的时间不被分给玩手机。 具体的做法可以是：手机静音（不要震动）、把社交、休闲软件以及网站同工作区隔离等。</p><p><b>吸收正能量</b>。吸收正能量有很多种，我常用的方式有两种：</p><ul><li> 1、<b>同他人分享自己的文章和成果</b>。从别人给我的点赞、评论中获取认可。当自我动力不足时，别人对我的认可也是一剂强心剂。<br/> </li><li> 2、<b>去学习的环境中吸收正能量</b>。同考研、考公、考编的人处于同一个环境之下，他们身上认真学习的气氛会感染你。图书馆、书店、教室，找一个安静的地方，和一些积极向上的人做一些对你有帮助的事。<br/> </li></ul><p><b>远离负面情绪</b>。我是一个很容易受身边人影响的人，正如能够吸收周围的正能量一般，负面情绪也总会对你有所影响。每天处于：丧、悲、不想努力的氛围之中，多少也会对你学习的积极性有所影响。<b>做不到改变别人，就好好改变自己，换一换所处的环境，去体会更积极的事物</b>。</p><h2>写给自己和朋友的话</h2><p>「<b>学如逆水行舟，不进则退</b>」。好好想想自己年初的计划，最好能看看自己当时写下的文章，我们离自己的目标还有多远。如果已经走远，调整好方向走回正轨。</p><p><b>不要被身边的事务局限自己的判断和思考</b>。大家都不努力我为什么还要努力？别人已经这么优秀了，我却还一事无成？</p><p>这些既和你有关又与你无关。有关是因为这些事确实来自于你的所见所闻所感，但是你是否应当努力不是由旁人决定，而是 <b>你自己是否想要跳出自己当下所处的圈子？是否想要改变当下的自己？是否愿意为自己的改变而付出行动？</b>。</p><p>没有华丽的文藻，也没有什么奇淫巧计，只是不想成为身边的大多数，想去见识更多人和事，成为一个有趣的人。没准你有什么不一样的看法或者技巧，欢迎你给出评论，或是默默点点赞给个好看，这都是对我的一种认可。</p>", 
            "topic": [
                {
                    "tag": "学习", 
                    "tagLink": "https://api.zhihu.com/topics/19550581"
                }
            ], 
            "comments": [
                {
                    "userName": "马克酒", 
                    "userLink": "https://www.zhihu.com/people/7165470e922a1f38e1ca819cdcfd77b1", 
                    "content": "<p>看完了马尔可夫链，才知道自己为什么学不进去，我得把手机放远点。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "改变环境，也能帮你改变自己", 
                            "likes": 0, 
                            "replyToAuthor": "马克酒"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69363122", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十二周", 
            "content": "<h2>左耳听风 第三十二周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）<br/> </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode16.%2520%25E6%259C%2580%25E6%258E%25A5%25E8%25BF%2591%25E7%259A%2584%25E4%25B8%2589%25E6%2595%25B0%25E4%25B9%258B%25E5%2592%258C.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/javascript-scene/tdd-changed-my-life-5af0ce099f80\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TDD Changed My Life</a> 「测试驱动开发改变我的生活」</p><p>TDD（ Test Driven Development）：测试驱动开发。每开发某步功能或模块，先做测试确保所有测试通过后再进行下一步的开发。</p><blockquote> Murphy’s Law of Debugging: The thing you believe so deeply can’t possibly be wrong so you never bother testing it is definitely where you’ll find the bug after you pound your head on your desk and change it only because you’ve tried everything else you can possibly think of.<br/> </blockquote><p>调试的「墨菲定律」：你深信这东西不会出错，所以你永远不会测试这部分内容，当你用你的头敲桌子然后修改这部分内容后你会找打 BUG，只是因为你已经尝试了一切你所能想到。</p><p>所以，程序出错不能完全依赖自己的直觉，实际的单元测试、覆盖测试等通过才能确保这部分代码目前没有问题。</p><p>对自己的代码进行单元测试也可以帮助我们写出更好的代码，例如我最近开发的项目在 JavaScript 代码中 val() 漏写，导致数据验证出错，修改密码对表单提交的无效数据没有拦截过滤导致程序的功能出错。</p><p>在完整的项目开发中既不能离开全面的需求分析也不能脱离实际开发中对代码的测试。</p><h2>Tip</h2><a href=\"https://zhuanlan.zhihu.com/p/69337265\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-d1bae71dd739566b20a00098d3b08b3b_180x120.jpg\" data-image-width=\"900\" data-image-height=\"383\" class=\"internal\">胡sir：ASP.NET MVC 项目添加单元测试</a><p>尝试了下给自己的 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 添加单元测试。</p><p>两种方式：</p><p>1、在项目新建时勾选选择添加单元测试。</p><p>2、在后序的开发中手动添加单元测试。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/69362576\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-d1bae71dd739566b20a00098d3b08b3b_180x120.jpg\" data-image-width=\"900\" data-image-height=\"383\" class=\"internal\">胡sir：个人项目复盘</a><p>复盘之前的独立开发的项目：</p><p>1、<b>在 BUG 中成长</b>。对于我这样的初级码农来说，BUG 出现最大的可能性是对于某一方面的知识尚未掌握，在解决 BUG 的同时填补自己的知识盲区。</p><p>2、<b>实际说话，不主观判断</b>。程序出错后，不主观判断某一段程序的正确与否，而是根据测试的结果来推荐出错的位置，有时候可能是你打错字了。（学会自己做测试）</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69362576", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "个人项目复盘", 
            "content": "<p>﻿作为一个新手，该怎样从头到尾完整的开发一个项目呢？我将从：开发前、开发过程中、开发完成后，三个方面来分享我的思考。</p><h2>项目开发前</h2><p>项目开发前你要做的就是：<b>需求分析</b>。</p><p>需求分析就是理清楚：<b>你的项目要解决的问题有哪些？你所面对的用户分别有哪些需求（可能是个多用户系统）？</b></p><p>如果学过  UML 你可以画「用例图」 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6be327504699c742ec531a0141871794_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"984\" class=\"origin_image zh-lightbox-thumb\" width=\"1061\" data-original=\"https://pic1.zhimg.com/v2-6be327504699c742ec531a0141871794_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1061&#39; height=&#39;984&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"984\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1061\" data-original=\"https://pic1.zhimg.com/v2-6be327504699c742ec531a0141871794_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6be327504699c742ec531a0141871794_b.jpg\"/></figure><p> 画用例图是描述系统需求的方式之一，你可以用简单的思维导图来代替 UML。</p><p>注意：你个人开发的项目最好是自己平时所接触的，这样你才容易找到自己的需求，明白自己要做的到底是什么。</p><p><b>如果开发时一头雾水不知该如何开始，你可以「借鉴、参考」。模仿所开发方向同行业优秀案例，结合自己的想法进行改造优化。</b></p><p>比如我开发的图书管理系统，我就参考了百度排名比较靠前的：北京大学图书馆、温州市图书馆的主页布局。</p><h2>开发过程中</h2><p>开发的过程要做的就是，根据需求具体实现功能，将「<b>做什么</b>？」变成「<b>怎么做</b>？」。先根据自己的项目需求画出系统的具体结构。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-93d4a624b6956fa49c2481f5ccef004d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1374\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"1374\" data-original=\"https://pic2.zhimg.com/v2-93d4a624b6956fa49c2481f5ccef004d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1374&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1374\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1374\" data-original=\"https://pic2.zhimg.com/v2-93d4a624b6956fa49c2481f5ccef004d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-93d4a624b6956fa49c2481f5ccef004d_b.jpg\"/></figure><p> 根据项目的结构图，逐步的按照模块来实现自己的系统。</p><p>作为新手，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub</a> 上类似的开源项目可以给你不少参考。我在开发时也在上面参考了一些项目，在学习别人代码的同时，提高了自己的编程能力。</p><p>开发的过程中可能会遇见不少困难，<a href=\"https://link.zhihu.com/?target=https%3A//www.google.com.hk/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Google</a> <b>英文</b> 搜索可以让你更快的找到优质答案，基本上（初级码农）能遇见的问题网上都已经有了解决方案。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow</a>，是我问题搜索结果指向最多的网站，编程界也有「面向 StackOverflow」编程的玩笑，这里的答案比百度搜索到的 CSDN 的答案更专业跟具体，可以帮你更好的 <b>了解问题并解决问题</b>。</p><p><b>系统界面的美观很重要</b>。善用一些前端的 UI 框架，例如：Bootstrap、Semantic UI、JQuery UI 等。如果不是有很强的个人设计能力，对色彩的敏感度很高，采用以上的 UI 框架可以很好的帮你美化界面。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e886a1000422907f6e160c223eac3f43_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2559\" data-rawheight=\"1252\" class=\"origin_image zh-lightbox-thumb\" width=\"2559\" data-original=\"https://pic4.zhimg.com/v2-e886a1000422907f6e160c223eac3f43_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2559&#39; height=&#39;1252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2559\" data-rawheight=\"1252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2559\" data-original=\"https://pic4.zhimg.com/v2-e886a1000422907f6e160c223eac3f43_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e886a1000422907f6e160c223eac3f43_b.jpg\"/></figure><p><b>提高用户体验，和用户互动</b>。用 JavaScript 和 Ajax 在表单提交等地方给用户 正确/错误 的输入反馈。</p><p><b>设计一个良好的数据库</b>。这里也要考虑你的项目是以「代码优先」，还是「数据优先」。一个良好的数据库设计可以降低你项目的耦合性。可以参考数据数库设计的「第一范式」、「第二范式」、「第三范式」来优化你的数据库设计。</p><h2>开发完成后</h2><p>项目开发完成后，要进行必要的功能测试。对每一模块的每一个功能进行测试根据测试结果对项目中出错的代码进行修改。</p><p><b>没有经过测试的代码，谁也不能保证不会出错</b>。例如：我的项目 1.0 版本，对于读者修改密码的表单验证就有两个错误。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">$</span><span class=\"p\">(</span><span class=\"s2\">&#34;#submit&#34;</span><span class=\"p\">).</span><span class=\"nx\">click</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">pwd1</span><span class=\"p\">.</span><span class=\"nx\">val</span><span class=\"p\">().</span><span class=\"nx\">trim</span><span class=\"p\">().</span><span class=\"nx\">length</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">layer</span><span class=\"p\">.</span><span class=\"nx\">msg</span><span class=\"p\">(</span><span class=\"s1\">&#39;请勿更改为空密码&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">icon</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">time</span><span class=\"o\">:</span> <span class=\"mi\">1000</span> <span class=\"p\">});</span>\n        <span class=\"nx\">pwd1</span><span class=\"p\">.</span><span class=\"nx\">focus</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">pwd2</span><span class=\"p\">.</span><span class=\"nx\">val</span><span class=\"p\">().</span><span class=\"nx\">trim</span><span class=\"p\">().</span><span class=\"nx\">length</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nx\">layer</span><span class=\"p\">.</span><span class=\"nx\">msg</span><span class=\"p\">(</span><span class=\"s1\">&#39;请勿更改为空密码&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">icon</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">time</span><span class=\"o\">:</span> <span class=\"mi\">1000</span> <span class=\"p\">});</span>\n        <span class=\"nx\">pwd2</span><span class=\"p\">.</span><span class=\"nx\">focus</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">pwd1</span><span class=\"p\">.</span><span class=\"nx\">val</span> <span class=\"o\">!=</span> <span class=\"nx\">pwd2</span><span class=\"p\">.</span><span class=\"nx\">val</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// val 没有带括号，结果恒等\n</span><span class=\"c1\"></span>        <span class=\"nx\">layer</span><span class=\"p\">.</span><span class=\"nx\">msg</span><span class=\"p\">(</span><span class=\"s1\">&#39;二次输入密码不一致，请重新输入密码！&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span> <span class=\"nx\">icon</span><span class=\"o\">:</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"nx\">time</span><span class=\"o\">:</span> <span class=\"mi\">1000</span> <span class=\"p\">});</span>\n        <span class=\"nx\">pwd2</span><span class=\"p\">.</span><span class=\"nx\">focus</span><span class=\"p\">();</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>pwd1.val != pwd2.val 导致表单提交验证检测出错，控制台并不会报错。在实际的功能测试中才发现了这行代码的错误。</p><p>这里推荐：单元测试，这也是开发者必须掌握的技能，针对每个独立的模块进行测试，不盲目的判断自己的代码正确与否。根据测试的结果来看是否要修改自己的代码</p><h2>总结</h2><p>1、<b>在 BUG 中成长</b>。对于我这样的初级码农来说，BUG 出现最大的可能性是对于某一方面的知识尚未掌握，在解决 BUG 的同时填补自己的知识盲区。</p><p>2、<b>实际说话，不主观判断</b>。程序出错后，不主观判断某一段程序的正确与否，而是根据测试的结果来推荐出错的位置，有时候可能是你打错字了。（学会自己做测试）</p>", 
            "topic": [
                {
                    "tag": "复盘", 
                    "tagLink": "https://api.zhihu.com/topics/19858238"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69337265", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "ASP.NET MVC 项目添加单元测试", 
            "content": "<h2><a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 项目添加单元测试 </h2><p>给 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 项目添加单元测试有两种（实际上一样）。</p><p>第一种在新建项目时勾选「添加单元测试」。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-71f0e0f1da4c7c716d4ac5b7ef75bd70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1513\" data-rawheight=\"1129\" class=\"origin_image zh-lightbox-thumb\" width=\"1513\" data-original=\"https://pic1.zhimg.com/v2-71f0e0f1da4c7c716d4ac5b7ef75bd70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1513&#39; height=&#39;1129&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1513\" data-rawheight=\"1129\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1513\" data-original=\"https://pic1.zhimg.com/v2-71f0e0f1da4c7c716d4ac5b7ef75bd70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-71f0e0f1da4c7c716d4ac5b7ef75bd70_b.jpg\"/></figure><p> 第二种建立网站后，添加新项目 —— 选择测试—— 单元测试 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d449b9aca7283d6a0d70e3bb3372e5d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1876\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb\" width=\"1876\" data-original=\"https://pic2.zhimg.com/v2-d449b9aca7283d6a0d70e3bb3372e5d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1876&#39; height=&#39;822&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1876\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1876\" data-original=\"https://pic2.zhimg.com/v2-d449b9aca7283d6a0d70e3bb3372e5d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d449b9aca7283d6a0d70e3bb3372e5d1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>出错&amp;解决</h2><p>自己为项目添加单元测试，可能会出现除少引用，无法进行单元测试。例如： 缺少 System.Web.Mvc 引用。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bc0e747601ede9ab40ec0b8137fb26de_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1133\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"1133\" data-original=\"https://pic3.zhimg.com/v2-bc0e747601ede9ab40ec0b8137fb26de_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1133&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1133\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1133\" data-original=\"https://pic3.zhimg.com/v2-bc0e747601ede9ab40ec0b8137fb26de_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bc0e747601ede9ab40ec0b8137fb26de_b.jpg\"/></figure><p> 可以根据报错中提示的引用，在 NuGet 包管理器中搜索对应的依赖给测试项目安装。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5d30dcae5813ab2c7bde3131bc9445cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1117\" data-rawheight=\"947\" class=\"origin_image zh-lightbox-thumb\" width=\"1117\" data-original=\"https://pic4.zhimg.com/v2-5d30dcae5813ab2c7bde3131bc9445cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1117&#39; height=&#39;947&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1117\" data-rawheight=\"947\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1117\" data-original=\"https://pic4.zhimg.com/v2-5d30dcae5813ab2c7bde3131bc9445cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5d30dcae5813ab2c7bde3131bc9445cf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>测试参考</h2><p>控制器代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HomeController</span> <span class=\"o\">:</span> <span class=\"n\">Controller</span>\n    <span class=\"o\">{</span>\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Index</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">BookSort</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Info</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;NIT图书馆信息&#34;</span><span class=\"o\">;</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Sort</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;NIT图书分类&#34;</span><span class=\"o\">;</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">List</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;NIT图书排行&#34;</span><span class=\"o\">;</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kd\">public</span> <span class=\"n\">ActionResult</span> <span class=\"nf\">Contact</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;联系我们&#34;</span><span class=\"o\">;</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">View</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>单元测试代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"o\">[</span><span class=\"n\">TestClass</span><span class=\"o\">]</span> <span class=\"c1\">// 单元测试类必须在前面添加 [TestClass]\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">HomeControllerUnitTest</span>\n    <span class=\"o\">{</span>\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span> <span class=\"c1\">// 单元测试方法必须在前面添加 [TestMethod]\n</span><span class=\"c1\"></span>        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Index</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controllor</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controllor</span><span class=\"o\">.</span><span class=\"na\">Index</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">IsNotNull</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"o\">);</span> <span class=\"c1\">// 判断控制器是否有返回视图\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">BookSort</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controller</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controller</span><span class=\"o\">.</span><span class=\"na\">BookSort</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">IsNotNull</span><span class=\"o\">(</span><span class=\"n\">result</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Info</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controllrt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controllrt</span><span class=\"o\">.</span><span class=\"na\">Info</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">AreEqual</span><span class=\"o\">(</span><span class=\"s\">&#34;NIT图书馆信息&#34;</span><span class=\"o\">,</span><span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span><span class=\"o\">);</span> <span class=\"c1\">// 判断控制器是否有写入 ViewBag.Message 数据\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Sort</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controllrt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controllrt</span><span class=\"o\">.</span><span class=\"na\">Sort</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">AreEqual</span><span class=\"o\">(</span><span class=\"s\">&#34;NIT图书分类&#34;</span><span class=\"o\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">List</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controllrt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controllrt</span><span class=\"o\">.</span><span class=\"na\">List</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">AreEqual</span><span class=\"o\">(</span><span class=\"s\">&#34;NIT图书排行&#34;</span><span class=\"o\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"o\">[</span><span class=\"n\">TestMethod</span><span class=\"o\">]</span>\n        <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">Contact</span><span class=\"o\">()</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">HomeController</span> <span class=\"n\">controllrt</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HomeController</span><span class=\"o\">();</span>\n            <span class=\"n\">ViewResult</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">controllrt</span><span class=\"o\">.</span><span class=\"na\">Contact</span><span class=\"o\">()</span> <span class=\"n\">as</span> <span class=\"n\">ViewResult</span><span class=\"o\">;</span>\n            <span class=\"n\">Assert</span><span class=\"o\">.</span><span class=\"na\">AreEqual</span><span class=\"o\">(</span><span class=\"s\">&#34;联系我们&#34;</span><span class=\"o\">,</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">ViewBag</span><span class=\"o\">.</span><span class=\"na\">Message</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "单元测试", 
                    "tagLink": "https://api.zhihu.com/topics/19605413"
                }, 
                {
                    "tag": "ASP.NET MVC", 
                    "tagLink": "https://api.zhihu.com/topics/19667789"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68470868", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第三十一周", 
            "content": "<h2>左耳听风 第三十一周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode13.%2520%25E7%25BD%2597%25E9%25A9%25AC%25E6%2595%25B0%25E5%25AD%2597%25E8%25BD%25AC%25E6%2595%25B4%25E6%2595%25B0.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode14.%2520%25E6%259C%2580%25E9%2595%25BF%25E5%2585%25AC%25E5%2585%25B1%25E5%2589%258D%25E7%25BC%2580.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/devgorilla/the-console-object-provides-access-to-the-browsers-debugging-console-354eda9d2d50\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What devs need to know about Encoding / Encryption / Hashing / Salting / Stretching</a> 「关于编码、加密、哈希、加盐、秘钥延伸」</p><p>作者对数据加密方面的知识进行了普及：</p><p>首先是指出编码和加密的不同。<b>编码</b> ，是对特定代码的加工。而「<b>加密</b>」，是把数据转化为特定格式的过程，加密需要钥匙来加锁或解锁，只有少部分人可以看到真实的数据（例如：管理员），大部分人只能看到加密的文本。</p><p>加密又可以分为两大类：<b>Symmetric Key Encryption（对称秘钥加密）</b>，即加密和解密用相同的钥匙，最常用的加密方式；<b>Asymmetric Key Encryption（非对称秘钥加密）</b>，加密和解密用不同的钥匙，最著名的应用就是 HTTPS 。</p><p>「<b>非对称加密</b>」常用的方式就是 <b>hash + salt</b>，哈希函数可以帮助我们生成定长的加密数据，但是单纯的 hash 函数可以被黑客用彩虹表等破解，这就需要我们 salting(加盐) 了，即在原始数据中掺杂其他数据，使得黑客不能直接通过「撞库」来得到明文密码以及加密的方式。</p><p><b>Stretching 秘钥延伸</b>，是进一步加密，最简单的实践就是在加密后，再对已加密的数据重复加密，最终得出复杂的加密文件，若黑客想要破解密码，就需要在原有加密时间上花上指数倍时间破解，甚至在理论时间上无法破解。</p><p>说了这么多，为什么要对数据库加密？直接目的就是抵御「黑客」的攻击，避免数据库泄露，造成公司以及个人的财务以及隐私的损失。<b>而加密的实质是给黑客增加解密的门槛，让黑客在理论上无法解密。</b></p><h2>Tip</h2><p>根据 Review 的文章看了一下 C# SHA256 的实践，将 salt 作为加密的钥匙对文本进行加密，密码验证的时候，实际上是比较二者转换的 hash 值是否一致。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">string</span> <span class=\"nf\">Encrypt</span><span class=\"o\">(</span><span class=\"n\">string</span> <span class=\"n\">encryptStr</span><span class=\"o\">,</span><span class=\"n\">string</span> <span class=\"n\">salt</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">var</span> <span class=\"n\">hmac</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HMACSHA256</span><span class=\"o\">(</span><span class=\"n\">Encoding</span><span class=\"o\">.</span><span class=\"na\">UTF8</span><span class=\"o\">.</span><span class=\"na\">GetBytes</span><span class=\"o\">(</span><span class=\"n\">salt</span><span class=\"o\">));</span> <span class=\"c1\">// salt 转换为字节，作为加密的钥匙\n</span><span class=\"c1\"></span>\n            <span class=\"k\">return</span> <span class=\"n\">Convert</span><span class=\"o\">.</span><span class=\"na\">ToBase64String</span><span class=\"o\">(</span><span class=\"n\">hmac</span><span class=\"o\">.</span><span class=\"na\">ComputeHash</span><span class=\"o\">(</span><span class=\"n\">Encoding</span><span class=\"o\">.</span><span class=\"na\">UTF8</span><span class=\"o\">.</span><span class=\"na\">GetBytes</span><span class=\"o\">(</span><span class=\"n\">encryptStr</span><span class=\"o\">)));</span>\n        <span class=\"o\">}</span>\n\n<span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">Main</span><span class=\"o\">(</span><span class=\"n\">string</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">string</span> <span class=\"n\">salt</span> <span class=\"o\">=</span> <span class=\"s\">&#34;salt&#34;</span><span class=\"o\">;</span> <span class=\"c1\">// 盐，也是钥匙\n</span><span class=\"c1\"></span>            <span class=\"n\">string</span> <span class=\"n\">password</span> <span class=\"o\">=</span> <span class=\"s\">&#34;admin123&#34;</span><span class=\"o\">;</span> <span class=\"c1\">// 明文密码\n</span><span class=\"c1\"></span>\n            <span class=\"n\">string</span> <span class=\"n\">newPwd</span> <span class=\"o\">=</span> <span class=\"n\">newPassword</span><span class=\"o\">(</span><span class=\"n\">salt</span><span class=\"o\">,</span> <span class=\"n\">password</span><span class=\"o\">);</span> <span class=\"c1\">// 存储在数据库的加密文本\n</span><span class=\"c1\"></span>\n            <span class=\"n\">Console</span><span class=\"o\">.</span><span class=\"na\">Write</span><span class=\"o\">(</span><span class=\"s\">&#34;判断密码判断是否一致: &#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">var</span> <span class=\"n\">pwd</span> <span class=\"o\">=</span> <span class=\"n\">Console</span><span class=\"o\">.</span><span class=\"na\">ReadLine</span><span class=\"o\">();</span>\n            <span class=\"n\">Console</span><span class=\"o\">.</span><span class=\"na\">WriteLine</span><span class=\"o\">(</span><span class=\"n\">newPassword</span><span class=\"o\">(</span><span class=\"n\">salt</span><span class=\"o\">,</span> <span class=\"n\">pwd</span><span class=\"o\">).</span><span class=\"na\">Equals</span><span class=\"o\">(</span><span class=\"n\">newPwd</span><span class=\"o\">));</span> <span class=\"c1\">// 根据 SHA256 生成的加密文本是否一致来判断密码是否正确\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span></code></pre></div><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/68470467\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-b8c12c0dab395a8b9e5caa68c872da8a_180x120.jpg\" data-image-width=\"693\" data-image-height=\"532\" class=\"internal\">胡sir：ASP.NET MVC 入门</a><p>如何入门一门新语言或是一门新技术?</p><p><b>找到适合自己的学习方式</b>。看视频、看专栏、看博客、看纸质书都是不错的学习方式，找到自己喜欢的，投入时间去学习。</p><p><b>系统性、整体性的学习</b>。可以以官方的参考文档文档为主，再参考一些别人的路线图（思维导图），有条件的尽量用英文在谷歌搜索答案，CSDN 上的许多博客很多时候都有没有讲清楚问题。系统性、整体性的了解知识可以让你在出现问题的时候快速定位，更好的去解决问题。</p><p><b>看源码，多实践</b>。编程是理工科的学科，需要通过实践才能发现问题。先学习别人的源码，在实践中吸取知识，会让你真正的对某些概念有所了解，BUG 的出现并全是坏事，这只是说明你对某一块的知识尚未理解，攻克它，你会有新的收获。当然你不能一味的死磕，可以在网上搜索自己出现的问题，看看别人是怎么解决到。如果找不到，说明你还没找准问题，那就需要找人帮忙了，<a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Stack Overflow</a> 可以帮你解决问题。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68470467", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 16, 
            "title": "ASP.NET MVC 入门", 
            "content": "<figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e4e14c60b32738cd02f841509bc7a44c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2926\" data-rawheight=\"1328\" class=\"origin_image zh-lightbox-thumb\" width=\"2926\" data-original=\"https://pic1.zhimg.com/v2-e4e14c60b32738cd02f841509bc7a44c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2926&#39; height=&#39;1328&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2926\" data-rawheight=\"1328\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2926\" data-original=\"https://pic1.zhimg.com/v2-e4e14c60b32738cd02f841509bc7a44c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e4e14c60b32738cd02f841509bc7a44c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>入门基础</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 是微软系列基于 C# 语言的 Web 开发框架，并不适合 0 基础入门，在学习之前你必须要了解 4 个知识点：</p><p>1、HTML 基础。网页的基本标签，结合 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 自带的 HTML 辅助方法来开发网页。</p><p>2、CSS 基础。修改页面样式，使得页面看起来更美观。</p><p>3、JavaScript 基础。和用户进行交互，表单验证是最基本的。</p><p>4、C# 基础语法。根据我们需要的数据模型设计类，以及 Controller 控制器中做数据的处理。</p><h2>学习资源</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 现在微软已经升级成 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC Core 了，MSDN官网所提供的 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> 中文学习文档也只有  <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC Core 了，这里我提供了一些我入门学习所使用的资源。</p><p>首先是视频资源，我参考的是 B 站视频「【淘米】从零开始的网站构筑」，视频很短，可以简单的带你使用 EntityFramework 框架制作一个简单的 ToDo List 网站。这个过程可以让你对 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 的开发有一个基础的了解，接下来就可以系统性的学习了。</p><p>这里推荐微软官方团队出品的《<a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC5 高级编程》,由浅入深的带你了解 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 。如果你觉得这本书对你来说太有难度了，你可以以看一下由「葡萄城」技术团队出品的《<a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC5 入门指南》（电子书）。也可以直接看他们的</p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/powertoolsteam/p/MVC_one.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-a74326808ee5c9ccc80214a719b4e96f_ipico.jpg\" data-image-width=\"229\" data-image-height=\"228\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">七天学会ASP.NET MVC (一)--深入理解ASP.NET MVC</a><p>当然，</p><a href=\"https://link.zhihu.com/?target=https%3A//docs.microsoft.com/en-us/aspnet/core/getting-started/%3Fview%3Daspnetcore-2.2%26tabs%3Dwindows\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-20ef38870667e71aeabbc54da52663b7_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Get started with ASP.NET Core</a><p>是不可或缺的，但是对于新手来说可能不是很友好，在你有一定了解后再去看官网的文档可能会更好一些。</p><h2>实战项目</h2><p>在 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 入门一个多月的学习中，我也从0 开始搭建了我的 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC 项目 「</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/NITBook\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/NITBook</a><p>」，你可以直接在 GitHub 上搜 NITBook 唯一一个项目就是我的了。</p><p>NITBook 是一个图书管理系统，目前前台界面还是静态，后台管理系统功能基本实现。根据 读者/ 管理员 角色的不同分为了两个后台。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4780688c14dc39392b88555e07053038_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2545\" data-rawheight=\"1274\" class=\"origin_image zh-lightbox-thumb\" width=\"2545\" data-original=\"https://pic1.zhimg.com/v2-4780688c14dc39392b88555e07053038_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2545&#39; height=&#39;1274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2545\" data-rawheight=\"1274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2545\" data-original=\"https://pic1.zhimg.com/v2-4780688c14dc39392b88555e07053038_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4780688c14dc39392b88555e07053038_b.jpg\"/></figure><p><b>管理员</b>，可以对于图书类别、图书、用户信息、借阅信息进行增删改查。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2342f87480d581f223359c38f84cbad2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1272\" class=\"origin_image zh-lightbox-thumb\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-2342f87480d581f223359c38f84cbad2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2560&#39; height=&#39;1272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-2342f87480d581f223359c38f84cbad2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2342f87480d581f223359c38f84cbad2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>读者</b>，可以对自己的密码进行修改、图书查找以及借阅归还。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fc4f0036cd0d75d806e51b59fd9520ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1273\" class=\"origin_image zh-lightbox-thumb\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-fc4f0036cd0d75d806e51b59fd9520ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2560&#39; height=&#39;1273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-fc4f0036cd0d75d806e51b59fd9520ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fc4f0036cd0d75d806e51b59fd9520ba_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>项目还比较粗糙，评价、主站管理等功能可能会在以后的实践中继续开发。作为入门者，可以作为一个实战项目来学习，参照我的代码来搭建你自己的网站。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-91aaaa7a3ecfcbd1242b1b0ac96bbdd2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1274\" class=\"origin_image zh-lightbox-thumb\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-91aaaa7a3ecfcbd1242b1b0ac96bbdd2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2560&#39; height=&#39;1274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-91aaaa7a3ecfcbd1242b1b0ac96bbdd2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-91aaaa7a3ecfcbd1242b1b0ac96bbdd2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>如何入门一门新语言或是一门新技术?</p><p><b>找到适合自己的学习方式</b>。看视频、看专栏、看博客、看纸质书都是不错的学习方式，找到自己喜欢的，投入时间去学习。</p><p><b>系统性、整体性的学习</b>。可以以官方的参考文档文档为主，再参考一些别人的路线图（思维导图），有条件的尽量用英文在谷歌搜索答案，CSDN 上的许多博客很多时候都有没有讲清楚问题。系统性、整体性的了解知识可以让你在出现问题的时候快速定位，更好的去解决问题。</p><p><b>看源码，多实践</b>。编程是理工科的学科，需要通过实践才能发现问题。先学习别人的源码，在实践中吸取知识，会让你真正的对某些概念有所了解，BUG 的出现并全是坏事，这只是说明你对某一块的知识尚未理解，攻克它，你会有新的收获。当然你不能一味的死磕，可以在网上搜索自己出现的问题，看看别人是怎么解决到。如果找不到，说明你还没找准问题，那就需要找人帮忙了，</p><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-2d47e939feed796bcf7483d306661c88_ipico.jpg\" data-image-width=\"316\" data-image-height=\"316\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Stack Overflow - Where Developers Learn, Share, &amp; Build Careers</a><p> 可以帮你解决问题。</p><p>感谢你的观看，你有任何想法都可以在评论或者留言中指出，欢迎探讨。</p>", 
            "topic": [
                {
                    "tag": "ASP.NET MVC", 
                    "tagLink": "https://api.zhihu.com/topics/19667789"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "感谢分享。有什么可以配合<a href=\"http://link.zhihu.com/?target=http%3A//asp.net\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">asp.net</span><span class=\"invisible\"></span></a>使用的前端框架么？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "直接上 <a href=\"http://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> NET core 吧，前后端分离的。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "废了来", 
                    "userLink": "https://www.zhihu.com/people/0271c34d085718c1e16e7d3e7ef6f85e", 
                    "content": "正在纠结<a href=\"http://link.zhihu.com/?target=http%3A//asp.net\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">asp.net</span><span class=\"invisible\"></span></a> core和abp哪个做网站快，<br>有人建议我core.mvc更快，<br>那么需要真的需要js吗？<br>你花了多久时间？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "没有接触过ABP，JS 基本可以不写", 
                            "likes": 0, 
                            "replyToAuthor": "废了来"
                        }, 
                        {
                            "userName": "废了来", 
                            "userLink": "https://www.zhihu.com/people/0271c34d085718c1e16e7d3e7ef6f85e", 
                            "content": "你花了一个月就做出了这个网站？<br>之前有基础吗？", 
                            "likes": 0, 
                            "replyToAuthor": "胡sir"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68341662", 
            "userName": "樱木天亥", 
            "userLink": "https://www.zhihu.com/people/04b4483801387a082455fa58d0e67cfb", 
            "upvote": 0, 
            "title": "ARTS 第十周", 
            "content": "<blockquote> ARTS是什么？<br/> </blockquote><p><b>Algorithm</b>：每周至少做一个leetcode的算法题； <b>Review</b>：阅读并点评至少一篇英文技术文章； <b>Tip/Techni</b>：学习至少一个技术技巧； <b>Share</b>：分享一篇有观点和思考的（技术）文章。</p><h2>Algorothm</h2><p>这次的算法做了 leetcode 上的一道 3sum 算法题：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Big_Rotor/article/details/90354566\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode15.3sum</a></p><h2>Review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/free-code-camp/5-github-tips-for-new-coders-2f312689ffd5\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《送给初学编程者的 5 个 GitHub 技巧》</a></p><p>这篇文章中，作为一个已经在 gitHub  工作了 5 年的员工，作者根据自己经验和所踩过的坑给初学的程序员提供了 5 个 github 的技巧。</p><p>1、<b>Change your default text editor associated with Git</b>。更改与 Git 关联的默认文本编辑器 VIM。因为对于大部分 hacker 甚至 <a href=\"https://link.zhihu.com/?target=https%3A//twitter.com/haacked\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">@haacked</a>本人来说，VIM 都是很不友好的。特别是党羽要合并冲突的时候更是欲哭无泪，当你想要使用 VIM 来解决冲突的时候，你得记住一大推详细命令。</p><p>那有没有什么更好的办法呢？我们可以将 VIM 切换成 Atom, Sublime 或 TextMate 这些文本编辑器，将大大便利我们的操作。具体可以跟着 <a href=\"https://link.zhihu.com/?target=https%3A//help.github.com/en/articles/associating-text-editors-with-git\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub Help</a> 这个教程来。</p><p>2、<b>Change your dotfiles</b>。Dotfiles允许自定义终端提示，以便我们可以看到所使用的 git 分支以及是否有未经提交的更改。具体可以跟着 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/alysonla/dotfiles\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">my dotfiles</a> 这个教程来学习。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cc88518d6b71936b95136c24cc24a7b7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1675\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb\" width=\"1675\" data-original=\"https://pic4.zhimg.com/v2-cc88518d6b71936b95136c24cc24a7b7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1675&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1675\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1675\" data-original=\"https://pic4.zhimg.com/v2-cc88518d6b71936b95136c24cc24a7b7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cc88518d6b71936b95136c24cc24a7b7_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-553328bf361e210d6208d951577860a5_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1675\" data-rawheight=\"55\" class=\"origin_image zh-lightbox-thumb\" width=\"1675\" data-original=\"https://pic2.zhimg.com/v2-553328bf361e210d6208d951577860a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1675&#39; height=&#39;55&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1675\" data-rawheight=\"55\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1675\" data-original=\"https://pic2.zhimg.com/v2-553328bf361e210d6208d951577860a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-553328bf361e210d6208d951577860a5_b.png\"/></figure><p> 3、<b>Install Hub</b>。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/github/hub\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hub</a>是一个命令行工具，可以更轻松地使用 GitHub。通常在终端上的仓库工作，但是想在 GitHub 上查看问题或提取请求的时候，会分散我们的注意力。不过，通过在终端中键入 <code>hub browe</code>，将直接在浏览器中自动神奇地打开存储库的 URL，以免分散注意力。</p><p>4、<b>Practice merge conflicts</b>。使用 Git 遇到冲突是我们无法避免的坑，所以建议建一个专门的仓库来练习。当然，可以参照步骤 1，切换文本编辑器，而不是使用 VIM 来操作。具体可以跟着 <a href=\"https://link.zhihu.com/?target=https%3A//github.blog/2016-12-12-resolve-simple-merge-conflicts-on-github/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">fix simple merge conflicts</a>这个简单的教程或者 <a href=\"https://link.zhihu.com/?target=https%3A//youtu.be/sfT0WrChMrM\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Git &amp; GitHub: Merge Conflicts</a>这个 youtube 视频来。</p><p>5、<b>Make a GitHub Page</b>。GitHub page 是 GitHub 免费托管的个人或项目网站！有一个实际的项目来推动 GitHub 练习你的 Git 和 GitHub 技能总是有帮助的。</p><p>具体可以使用编码教程中的 HTML，CSS 和 JavaScript 创建一个简单的网站，然后按照<a href=\"https://link.zhihu.com/?target=https%3A//pages.github.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">步骤</a>在 GitHub 上托管它，或者跟着这个<a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DrRGrT0wsJxI\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">视频</a>手把手来，也可以尝试更简单的<a href=\"https://link.zhihu.com/?target=https%3A//github.com/jlord/forkngo\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">方法</a>。</p><blockquote> PS：作为一个合格的程序员，平时要想完全不跟 Git 和 GitHub 是不太现实的，讲真，由此听到一个同事说他不知道 GitHub 是什么的时候，我和我的小伙伴真的是惊呆了都。扯远了，话说回来，学会更好地使用 GitHub 无疑将会是一笔巨大的财富。<br/>不过，毕竟 GitHub 也就是一个工具，工欲善其事，必先利其器，所以，学会一些技巧可以帮助我们更加便利地使用 GitHub，同时减少一些不必要地时间浪费和精力分散。</blockquote><h2>Tip/Techni</h2><p>在项目中我们估计多多少少都会用到 <code>SimpleDateFormat</code> 这个类来做一些时间的转换，有些同学通常会直接定义为  <code>private static SimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy-MM-dd&#34;);</code>这样的形式，也没考虑太多，但其实这是不安全的，因为 SimpleDateFormat 是线程不安全的类，所以使用的时候尽量不要定义为 static 变量。</p><p>这一块《阿里巴巴Java开发手册》中第六个模块<b>并发处理</b>的第 5 条有专门说这个事情。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6e0dfaf5cf01c0445708dd8861790009_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1013\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb\" width=\"1013\" data-original=\"https://pic2.zhimg.com/v2-6e0dfaf5cf01c0445708dd8861790009_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1013&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1013\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1013\" data-original=\"https://pic2.zhimg.com/v2-6e0dfaf5cf01c0445708dd8861790009_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6e0dfaf5cf01c0445708dd8861790009_b.jpg\"/></figure><p> 另外，看到有一篇关于 SimpleDateFormat 线程不安全的博客《<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/zemliu/archive/2013/08/29/3290585.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SimpleDateFormat的线程安全问题与解决方案</a>》写得挺好的，有兴趣也可以看一下。</p><h2>Share</h2><p><code>阅读是唯一短期内可能没什么太大帮助，但长期积累下来一堆会对你有巨大影响的一件事</code>这句话对我影响很大，其实主要想说的还是<code>学习是有滞后性的</code>。现在很多同学都很浮躁，觉得买了一个课程，看了几篇文章立马就能提升一大截，立马就能变大 V 一样。其实这很不可取，可能我们每个人身上多多少少都会经历过这样的阶段，但是能够静下来，长期坚持阅读，坚持积累，技术也好其他也好，坚持下来才会看到知识的复利作用，毕竟人生是一条复利增长曲线，不是看谁走得快，而是看谁走得远。</p><p>之前只坚持了九周的 ARTS 着实有些忏愧，希望这次能认真的重拾起来，不要好高骛远，其实每周认真写一下 ARTS还是挺有收获的，以房买你能够督促自己不要偷懒，另一方面其实对自己的表达和写作能力也是有帮助的。</p><p>这次就不 share 技术文章了，在知识大爆炸的今天，学会做好个人知识管理很重要，接受过几次知识管理的咨询和答疑后，返现确实还是不过错的，有助于管理自己的知识和接触到的信息，减少大脑的压力，提高效率。分享一篇自己的知识管理学习笔记——《<a href=\"https://link.zhihu.com/?target=https%3A//app.yinxiang.com/fx/6a08ecea-2bf0-4878-8e1d-88c2fa7eff32\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">为什么需要学习个人知识管理</a>》，有兴趣可以看看。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54202465", 
            "userName": "樱木天亥", 
            "userLink": "https://www.zhihu.com/people/04b4483801387a082455fa58d0e67cfb", 
            "upvote": 0, 
            "title": "ARTS 第五周", 
            "content": "<p>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Big_Rotor/article/details/84933991\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ARTS 第五周</a></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote><b>ARTS是什么？</b><br/> <b>Algorithm</b>：每周至少做一个leetcode的算法题；<br/><b>Review</b>：阅读并点评至少一篇英文技术文章；<br/><b>Tip/Techni</b>：学习至少一个技术技巧；<br/><b>Share</b>：分享一篇有观点和思考的技术文章。<br/> </blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Algorithm</b></h2><p><b>230. Kth Smallest Element in a BST(查找二叉查找树中的第 K 个元素)</b></p><p><b>题目描述</b></p><blockquote> Given a binary search tree, write a function kthSmallest to find the<br/>kth smallest element in it.<br/> </blockquote><p><b>Note:</b></p><blockquote> Given a binary search tree, write a function kthSmallest to find the<br/>kth smallest element in it.<br/> </blockquote><p><b>Example</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-23a98288550c821dc1a43507330bd87a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"433\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;433&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"433\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic3.zhimg.com/v2-23a98288550c821dc1a43507330bd87a_b.jpg\"/></figure><p><b>解答</b></p><p>要查找二叉查找树的第 K 个元素，自然而然想到的方法是利用二叉查找树的中序遍历解决，通过中序遍历二叉查找树，可以得到有小到大的有序数组，从而可以得知第 K 个元素。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * Definition for a binary tree node.\n</span><span class=\"cm\"> * public class TreeNode {\n</span><span class=\"cm\"> *     int val;\n</span><span class=\"cm\"> *     TreeNode left;\n</span><span class=\"cm\"> *     TreeNode right;\n</span><span class=\"cm\"> *     TreeNode(int x) { val = x; }\n</span><span class=\"cm\"> * }\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// 计数器\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">kthSmallest</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">inOrder</span><span class=\"o\">(</span><span class=\"n\">TreeNode</span> <span class=\"n\">node</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n        <span class=\"n\">count</span> <span class=\"o\">++;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">inOrder</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">,</span> <span class=\"n\">k</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div><h2><b>Review</b></h2><p>今天要 review 的文章是 Meduim 上的一篇关于软件工程和编程之间的思考的一篇文章，题为《<a href=\"https://link.zhihu.com/?target=https%3A//edgecoders.com/software-engineering-is-different-from-programming-b108c135af26\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Software Engineering is different from Programming</a>》。文章的题目直译过来很直白，也就是软件工程不同于编程。其实标题下面还有一个副标题，很有意思，<code>所有的软件工程师都会编程，但是并不是所有的程序员都会开发软件</code>。非常的简洁明了，简单粗暴，仔细想想，好像还真是那么一回事。</p><p>编程其实相对来说是比较容易的，门槛也不怎么高，所以很多人都会点编程的。但是，知道如何编程并不会让你成为一名软件工程师。就好比说：</p><ul><li>每个人都会唱歌（有些人可能五音不全，自己开心就行哈哈），通过唱唱歌来自娱自乐，但并不意味着 TA 们能够出唱片</li><li>我们在学校的时候都学习过数学和写作，但那并不会让我们成为数学家和作家（能不能成为当然还是得靠自己）</li><li>我们当中的大多数人都能够很容易的就学会烹饪，但是当我们宴请多人吃饭的时候，还是会找专门的厨师来弄</li><li>等等<br/>作者通过各种论述无非就是想要说明<code>简单程序与工程程序差别是非常巨大的</code>。所以，作为一名软件工程师，要了解要解决的问题是什么并给出相应的解决方案，以及这些解决方案有哪些局限性，有哪些可能的影响和安全隐患。</li></ul><p>那么，如何成为一名软件工程师呢？</p><ul><li><code>要有思考解决方案的心态。</code>要学会从满足需求和解决问题的角度去思考，而不是永远只会想着编码，并不是什么问题都是通编码解决的。</li><li><code>代码质量。</code>优秀的程序是清晰、可读并且易维护的。</li><li><code>环境和测试。</code>作为一名软件工程师，在编写程序时，要确保程序能够在不同的环境中或是在资源不同的机器上以及在不同的时区中运行起来。</li><li><code>成本和效率。</code>在很多情况下，作为一名软件工程师要能够快速解决问题，节约成本。</li><li><code>可用性。</code>优秀程序的设计要考虑用户体验，要注重可用性、实用性。</li><li><code>可靠性和安全性。</code>这点很重要，真正的软件工程师会往往会意识到编写安全可靠的解决方案是他们的职责所在。</li><li><code>拥抱工具。</code>有句话说得好嘛，工欲善其事必先利其器，说得就是这个理。毋庸置疑，我们需要学会使用很多好的工具，好的工具是可以极大地提升效率的。<br/> 那是不是说，只要跟以上几条沾边了你就是所谓的（优秀的）软件工程师了呢？答案是否定的，文章的最后，作者谈到，没有人是能够通过两个月、六个月甚至是一年时间来学通软件工程的，更不可能在所谓的训练营中学习成为软件工程师。毕竟像作者这样一位软件工程的大牛，也是通过 20 多年的不断学习和实践，并且如今还在坚持不断的学习才达到了现在的水平的。</li></ul><p>这让我想起了之前在看耗子叔的一篇文章中提到的，要端正学习态度， 要做好不断学习，坚持学习，十年如一日的默默坚持的准备。渍渍渍，历史总是惊人的相似，大佬们的认知好像都异曲同工。说句玩笑话，<code>一入 IT 深似海嘛</code>，不多说，扶我起来，还能再战。。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Tip/Techni</b></h2><p>这周工作比较忙，没有学到很多的技术技巧。工作之余，主要抽空看了《Spring Boot 实战》，还有就是重新回顾、学习了下链表、二叉查找树、栈等数据结构。</p><p>工作中，开发项目的时候公司都是直接将 Spring Boot 整合到公司的平台中，封装的比较死，所以对于 Spring Boot 也仅仅局限于会用，对很多的一些原理和细节不是很了解。所以这周工作之余主要在学习 Spring Boot 的一些知识。主要学习了 Spring Boot 的自动配置、起步依赖以及自定义配置、外置配置等。<br/><br/></p><h2><b>Share</b></h2><p>很多时候，当我们想要放弃一件事的时候，都会找借口说什么不合适，在这方面没有天赋等等。正如学习这件事，本身就是反人类的事，很多人想要偷懒不想学习的时候总会找点借口，自己不适合学这些东西，在这些地方没有天赋。想想，是不是这样?就拿编程来说吧，肯定有不少人学习编程的过程中都是半途而废的状态，学着学着就学不下去了，是真的学不下去了吗？未必，可能真有极少部分的人确实不适合，但是放弃的这部分人中，大部分都是在为自己的懒找借口罢了。理由无非就是自己没有编程的天赋，在编程上面没有激情，没有耐心等等，试想，就算换成其他的真就有天赋了？就有激情了？未必，不过是为自己的不愿努力编织一个理由而已。</p><p>《<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40WordcorpGlobal/programming-doesnt-require-talent-or-even-passion-11422270e1e4\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Programming Doesn’t Require Talent or Even Passion</a>》这篇文章中的观点挺不错的，值得好好思考一番。文中通过 PHP 之父 Rasmus Lerdorf 、Django 之父 Jacob Kaplan-Moss、Rails 之父 David Heinemeier Hansson 等编程界的鬼才、怪才的一些采访或言论，来表达了作者的观点：<code>编程其实很多时候并不需要天赋，也并不需要激情</code>。其实仔细想想，是有一定道理的，很多事情其实根本就没轮到拼天赋的时候，只有为之拼尽全力以致无能为力的时候才有资格说放弃，才有资格说不合适，才有资格说在这方面没天赋。不然说实在的，其实就是在为自己的懒找借口，连最基本的努力都做不到，何来轻言放弃呢？</p><p>文章的最后，作者提出了几点。</p><ul><li>要多尝试多种不同的方法来学习，不要去做一些无畏的担心。</li><li>问题常常在于你的学习方式，或者你对学习编程的态度。</li><li>永远不要轻言放弃，除非努力拼尽全力仍旧无能为力。</li><li>编程不要求天赋，甚至不要求激情。</li></ul><p>所以，即使天冷了，少年们该奋斗还是要奋斗啊，生命不息，奋斗不止，别总是连基本的努力都没做到呢就轻言放弃，轻易断言没有天赋！</p>", 
            "topic": [
                {
                    "tag": "程序", 
                    "tagLink": "https://api.zhihu.com/topics/19565652"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "编程学习", 
                    "tagLink": "https://api.zhihu.com/topics/19593616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50201578", 
            "userName": "樱木天亥", 
            "userLink": "https://www.zhihu.com/people/04b4483801387a082455fa58d0e67cfb", 
            "upvote": 1, 
            "title": "左耳听风 ARTS 第二周", 
            "content": "<h2>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Big_Rotor/article/details/84194481\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ARTS 第二周</a></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2>ARTS是什么？</h2><ul><li><b>Algorithm</b>：每周至少做一个leetcode的算法题；</li><li><b>Review</b>：阅读并点评至少一篇英文技术文章；</li><li><b>Tip/Techni</b>：学习至少一个技术技巧；</li><li><b>Share</b>：分享一篇有观点和思考的技术文章。</li></ul><h2>Algorithm</h2><p><b>876. Middle of the Linked List</b></p><blockquote>Given a non-empty, singly linked list with head node head, return a middle node of linked list.<br/>If there are two middle nodes, return the second middle node.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Example 1</b></p><blockquote>Input: [1,2,3,4,5]<br/>Output: Node 3 from this list (Serialization: [3,4,5])<br/>The returned node has value 3.  (The judge&#39;s serialization of this node is [3,4,5]).<br/>Note that we returned a ListNode object ans, such that:<br/>ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, and <a href=\"https://link.zhihu.com/?target=http%3A//ans.next.next.next/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ans.next.next.next</a> = NULL.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Example 2</b></p><blockquote>Input: [1,2,3,4,5,6]<br/>Output: Node 4 from this list (Serialization: [4,5,6])<br/>Since the list has two middle nodes with values 3 and 4, we return the second one.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>note</b></p><blockquote>The number of nodes in the given list will be between 1 and 100.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>解答</b></p><p>这个题目不难，这是一道典型的单链表反转的题目，但是这里有一点需要注意一下，就是当有连个中间结点的时候，按要求返回的是后面一个，稍一不小心返回的是前面一个，提交就会不通过，虽然返回的也是中间结点，但不符合题目要求，所以这是一个小小的坑，需要注意。</p><p>这里，如果我们按常规的方法的话，想到的肯定是先遍历一遍链表获取链表的长度 n，然后再重新遍历一遍链表找到中间结点。但是，这样子性能会很低，开销很大，时间复杂度会是 O(n) + O(n/2)。</p><p>所以，我们可以想到这一类题目惯用的「快慢指针」的方法来解答，因为快慢指针有一个很重要的性质：`慢指针走的长度等于快、慢指针之间的距离`。我们设置慢指针每次`走一步`，快指针每次`走两步`，这样，当快指针遍历到链表尾时，慢指针正好是中间结点。但是，这里需要注意，当结点个数为`奇数`个的的时候，这时候慢指针正好是中间结点；而结点个数为`偶数`个的时候，中间结点有两个，这时候慢指针指向的是`前一个中间结点`，而题目要求返回的是后一个中间结点，所以我们需要判断一下再返回。多的就不说了，<b>Talk is cheap, show you the code</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * Definition for singly-linked list.\n</span><span class=\"cm\"> * public class ListNode {\n</span><span class=\"cm\"> *     int val;\n</span><span class=\"cm\"> *     ListNode next;\n</span><span class=\"cm\"> *     ListNode(int x) { val = x; }\n</span><span class=\"cm\"> * }\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">middleNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"n\">ListNode</span> <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">//fast.next 不为 null，说明有偶数个结点，此时的 slow 指向前一个中间结点\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">slow</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>Review</h2><p>这周在 Medium、DZone 等平台多多少少看了几篇技术文章，这里暂且选一篇来谈一谈吧。今天要谈的这篇文章是一篇关于 Java 异常的文章，同时也是一篇面试类的文章，不过说实在的，这篇文章虽然是作者总结的关于 Java 异常的面试题，但其实可以说是很详尽了，几乎囊括了 Java 异常的方方面面。</p><p>文中一种整理了 21 个面试中经常遇到的 Java 异常的题目，并且按照问题的先后顺序依次展开，给出了一些基本的、详细的、亦或是思考性的「参考答案」，其中有些问题的参考答案中又给我们做了「引路人」，正如耗子叔专栏中一样，让我们自己到源头找水源，让你发现更大的桃花源。</p><p>Java 面试中基本都少不了异常这块，看了这篇文章会对异常有个更系统的了解和认知。看了这篇文章突然觉得以前所了解的异常基本就停留在了所谓 `try ... catch` 这些表层了，相信看了这篇文章，对于 Java 异常这块会有个更全面的认识，或者说是开开眼界哈哈（`大神请忽视这条`）。</p><p>文章的链接是 《<a href=\"https://link.zhihu.com/?target=https%3A//dzone.com/articles/java-exception-handling-interview-questions-and-an-1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java Exceptions Handling Interview Questions and Answers</a>》，有兴趣建议可以看一看。</p><h2>Tip/Techni</h2><p>技术技巧谈不上吧，因为数据结构与算法这块确实很薄弱，所以这周主要是继续学了和巩固了一下链表的一些操作：链表的反转、合并两个有序链表、判断链表是否有环、求出链表倒数第 k 个值等，以及二分查找、跳表等数据结构的知识。</p><p>其中，在学习跳表这一块的时候，知道了 redis 之所以用跳表来实现（严格来讲，也用到了散列表），而不用红黑树来实现，主要是因为总体上红黑树的效率没有跳表高。虽然对于`插入、删除、查找以及迭代输出有序序列`这几个操作而言，效率是一样的，但是对于按照区间查找数据而言，跳表效率更高。</p><p>当然，还有另外一个原因是因为跳表的代码相对于红黑树而言更容易写，这就意味着代码更容易读，更容易维护。</p><h2>Share</h2><p>这几天在 Medium 上看到一篇有点意思的文章《<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40cscalfani/goodbye-object-oriented-programming-a59cda4c0e53\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Goodbye, Object Oriented Programming</a>》，这篇文章咋一看有点标题党的感觉，作者是一位有着多年面向对象编程经验的开发者，文中开始就谈到了面向对象的三个主要特征：`继承、封装、多态`，这三个特征可谓是面向对象编程语言的优势。但文中作者对于面向对象编程的思考值得我们好好体会一番。</p><p>文中提到了三个非常有意思的观点，作者先后阐述了`继承是面向堕落的第一个原因、封装是面向对象堕落的第二原因、多态是面向对象堕落的第三个原因`，我想平时谈论面向对象的三个特征的时候都会觉得这是面向对象原因的三大优势，面向对象编程带来了极大的方便，虽然偶尔还是会有些缺点和不足，但还是会觉得优点远远大于不足。</p><p>文中对这三点都做了非常详细有力的阐述，有些不是很看得懂，但文章可以说是非常精彩了，在文章最后作者极力推荐函数式编程，这有点意思。这篇文章在 Medium 上也很热门，有兴趣可以去看看。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "信息技术（IT）", 
                    "tagLink": "https://api.zhihu.com/topics/19556498"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50198401", 
            "userName": "樱木天亥", 
            "userLink": "https://www.zhihu.com/people/04b4483801387a082455fa58d0e67cfb", 
            "upvote": 0, 
            "title": "左耳听风 ARTS 第一周", 
            "content": "<p>左耳听风 ARTS 第一周（原文博客地址：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/Big_Rotor/article/details/83965527\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ARTS|001 - 樱木天亥 - CSDN博客</a>）</p><p><b>ARTS是什么？</b></p><ul><li><b>Algorithm</b>：每周至少做一个leetcode的算法题；</li><li><b>Review</b>：阅读并点评至少一篇英文技术文章；</li><li><b>Tip/Techni</b>：学习至少一个技术技巧；</li><li><b>Share</b>：分享一篇有观点和思考的技术文章。</li></ul><h2>Algorithm</h2><p><b>26. Remove Duplicates from Sorted Array</b></p><blockquote>Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.  Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Example 1</b></p><blockquote>Given nums = [1,1,2], Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn&#39;t matter what you leave beyond the returned length.</blockquote><p><b>Example 2    </b> </p><blockquote>Given nums = [0,0,1,1,1,2,2,3,3,4], Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively. It doesn&#39;t matter what values are set beyond the returned length.</blockquote><p><b>解答</b></p><p>在一个排好序的数组里面删除重复的元素，首先我们需要知道，对于一个排好序的数组来说， a[n + 1] &gt;= a[n] ，那我们使用两个游标 i 和 j 来处理，假设现在 i = j + 1，如果 a[i] == a[j]，那么递增 i，直到 a[i] != a[j]，这时候设置a[j + 1] = a[i]，同时递增 i 和 j，重复上述过程直到遍历结束。</p><p>譬如一个数组为 1，1，2，3，首先 i = 1，j = 0，这时候 a[i] = a[j]，于是递增 i，此时 a[i] =  2，不等于1，所以设置 a[j + 1] = a[i]，也就是 a[1] = a[2]，同时递增 i 和 j 分别为 3 和 1，此时 a[3] != a[1]，所以设置 a[j + 1] = a[i]，也就是 a[2] = a[3]，再次递增，遍历结束。这时候新的数组长度就为 2 + 1，也就是3。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Solution {\n\tpublic int removeDuplicates(int a[]) {\n\t\tif(a.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tint j = 0;\n\t\tfor(int i = 1; i &lt; a.length; i++) {\n\t\t\tif(a[j] != a[i]) {\n\t\t\t\ta[++j] = a[i];\n\t\t\t}\n\t\t}\n\t\treturn j + 1;\n\t}\n}</code></pre></div><h2>Review</h2><p>《<a href=\"https://link.zhihu.com/?target=http%3A//coding-geek.com/how-does-a-hashmap-work-in-java/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How does a HashMap work in JAVA</a>》这篇文章看成是经典中的经典了，逻辑清晰，讲解更是精辟，虽然没有上一堆代码带你一步步去读源码，但并不影响它的经典性。我想，多数程序员或多或少都会看过或者了解过 HashMap 的源码，这篇文章中，作者从以下几个方面一次展开，为我们慢慢铺开 HashMap 的清明上河图，我想，如果多度几遍，肯定会有不少收获。《<a href=\"https://link.zhihu.com/?target=http%3A//coding-geek.com/how-does-a-hashmap-work-in-java/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How does a HashMap work in JAVA</a>》这篇文章看成是经典中的经典了，逻辑清晰，讲解更是精辟，虽然没有上一堆代码带你一步步去读源码，但并不影响它的经典性。我想，多数程序员或多或少都会看过或者了解过 HashMap 的源码，这篇文章中，作者从以下几个方面一次展开，为我们慢慢铺开 HashMap 的清明上河图，我想，如果多度几遍，肯定会有不少收获。</p><p class=\"ztext-empty-paragraph\"><br/></p><p> 1. 内部存储器</p><p> 2. 自动扩容</p><p> 3. 线程安全</p><p> 4. 键的不变性</p><p> 5. Java 8 中的改进</p><p> 6. 内存开销</p><p> 7. 性能问题</p><p> 8. 结论</p><h2>Tip</h2><p>这周主要跟着王争老师的《数据结构与算法之美》学习了冒泡排序、插入排序、归并排序、快速排序以及线性排序和排序的优化。这些排序基本以前也都学过，也都写过相应的代码，现在再学一遍算是印象更加深刻吧。经过这些学习，我发现理解特别重要，以前学的因为不经常写很容易就忘了，少练是一方面，但也间接说明了学的时候没有好好的去理解这些排序的核心思想或者说是原理，所以才会那么容易学了就忘。</p><h2>Share</h2><p>今天要分享的这篇文章其实几天之前就看了，是一位法国的编程怪才写的，反复读了几遍，一方面可能是英文不太好，需要通读几遍；另一方面，这篇文章我觉得确实写得很经典，值得每一个程序员去思考，所以有种「爱不释手」的感觉。</p><p>这篇文章的题目是 《<a href=\"https://link.zhihu.com/?target=http%3A//coding-geek.com/the-best-programming-language/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">the best programming language</a>》，翻译过来就是《最好的编程语言》。单看题目，你可能觉得又是一篇侃大山、立山头的文章，其实并不是，这篇文章中，作者给了我们一个不一样的视角去辩证看待各门编程语言的优劣势，我们不能单纯地给出结论，断定哪一门语言是最好的，这是不客观的。</p><p>在一些分析的基础上，作者发表了自己的观点「没有最好的编程语言，好不好都要取决于具体情况」。作者从以下几个维度去论证什么才是最好的编程语言：</p><p>1）你需要性能吗？</p><p>从性能的角度来看，如果我们谈论的是「秒」，那么每种语言都能做到；谈论的是「毫秒」，那每门语言的优秀程序员都能做到；谈论的是「微妙」，那基本所有的解释型语言都可以排除在外了（比如 python，尽管这是门很好的语言），当然一个经过良好调优的 JVM 和非常优秀的 Java 程序员可以做到这一点，C# 也是如此；谈论的是「纳秒」？也许只有汇编和 C 能做到。</p><p>所以，在大多数情况下，开发人员的技能才是最主要的。</p><p>2）什么是生态系统？</p><p>比语言本身更重要的是生态系统。比如，如果你经常用 eclipse、IntelliJ IDEA 或者 Visual Studio，你要学会更好地集成这些工具，形成一个良好丰富的生态系统。正所谓「工欲善其事，必先利其器」嘛，好的工具能够让你用的更舒服，提升学习和工作效率。</p><p>3）什么是在线帮助？</p><p>作者认为学习一门众所周知的编程语言是非常有帮助的，因为一门好的编程语言应该具备好的文档，以及在网上能够很容易找到相应的帮助等等，不然遇到问题很麻烦，站在前人的肩膀上前行往往更好。</p><p>...</p><p>还有几点就不列举了，在论证完这些方方面面之后，作者也得出了相应的结论：</p><p>没有最好的编程语言或者架构；现在最好的也许以后将会不复存在。一门编程语言只是一个工具，最重要的还是你解决问题的能力。</p><p>对于这这结论，我高度认同，授之以鱼不如授之以渔，对于程序员来说，最重要的不是你学了多少语言，懂得多少架构，而是你解决问题的能力有多强。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "信息技术（IT）", 
                    "tagLink": "https://api.zhihu.com/topics/19556498"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67763602", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第三十周", 
            "content": "<h2>﻿左耳听风 第三十周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode11.%2520%25E7%259B%259B%25E6%259C%2580%25E5%25A4%259A%25E6%25B0%25B4%25E7%259A%2584%25E5%25AE%25B9%25E5%2599%25A8.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode11. 盛最多水的容器</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode12.%2520%25E6%2595%25B4%25E6%2595%25B0%25E8%25BD%25AC%25E7%25BD%2597%25E9%25A9%25AC%25E6%2595%25B0%25E5%25AD%2597.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode12. 整数转罗马数字</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/devgorilla/the-console-object-provides-access-to-the-browsers-debugging-console-354eda9d2d50\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript console is more than console.log()</a> </p><p>「JavaScript console 不仅仅是 console.log()」</p><p>console.log() 是 JavaScript 最常用的错误输出代码，但是 console 还内置了很多方法帮助我们查看错误。</p><p>例如：console.warn &amp; console.error ，在控制台输出警告和错误提示。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b9337210e1b8fc214590dc3be6676be7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"80\" class=\"origin_image zh-lightbox-thumb\" width=\"484\" data-original=\"https://pic4.zhimg.com/v2-b9337210e1b8fc214590dc3be6676be7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;484&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"80\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"484\" data-original=\"https://pic4.zhimg.com/v2-b9337210e1b8fc214590dc3be6676be7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b9337210e1b8fc214590dc3be6676be7_b.png\"/></figure><p> console.group()  让报错信息输出组结构    </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e0f93bcc82b59c7cd32dc2e8214d85e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e0f93bcc82b59c7cd32dc2e8214d85e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e0f93bcc82b59c7cd32dc2e8214d85e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e0f93bcc82b59c7cd32dc2e8214d85e4_b.jpg\"/></figure><p>   console.table()，输出变量属性，以表格形式显示。   </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-715642418bbc28cadd1b9f77c9ede08d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb\" width=\"452\" data-original=\"https://pic2.zhimg.com/v2-715642418bbc28cadd1b9f77c9ede08d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;452&#39; height=&#39;201&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"452\" data-rawheight=\"201\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"452\" data-original=\"https://pic2.zhimg.com/v2-715642418bbc28cadd1b9f77c9ede08d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-715642418bbc28cadd1b9f77c9ede08d_b.jpg\"/></figure><p>   还有 console.time() 记录代码执行所用的时间，通过这些方法和 console.log() 组合可以帮我们更好的调试 JavaScript  程序。</p><h2>Tip</h2><p><a href=\"https://zhuanlan.zhihu.com/p/67759518\" class=\"internal\">Ajax 验证登录</a> 记录了下学习 ASP.NET MVC 开发网页的过程中，采用 Ajax 方法验证登录，避免页面刷新的代码。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/67761161\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8ada40744e8eee57642ea06abd6d994c_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2730\" class=\"internal\">胡sir：「凡人」大学生「修炼」指南</a><p>来自于知识星球「路人甲乙丙」的每周一问「大学生如何在一年半赚到 1 万元？」，分享我笨办法赚到 1 万元的经历以及思考。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67199090", 
            "userName": "立鹰", 
            "userLink": "https://www.zhihu.com/people/345903c30efed254105657d1bc716f53", 
            "upvote": 0, 
            "title": "ARTS第四周", 
            "content": "<p>Algorithm：主要是为了编程训练和学习， 每周至少做一个 leetcode 的算法题。</p><p>Review： 主要是为了学习英文， 阅读并点评至少一篇英文技术文章。</p><p>Tip：主要是为了总结和归纳你在日常工作中所遇到的知识点， 学习至少一个技术技巧。</p><p>Share：主要是为了建立影响力，输出价值观，分享一篇有观点和思考的技术文章。</p><h2><b>A: LeetCode 26. Remove Duplicates from Sorted Array  难度【easy】</b></h2><p><b>题目</b>：Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p><p><b>题意</b>：将有序数组中重复的元素移除,并返回去除重复后的数组长度。</p><p><b>思考及解法</b>：</p><p>       数组是有序的，而且题目中明确是元素是数字类型的，所以可以直接对元素前后做比较，取出所有不一样的就满足要求了！本来想new出一个数组去接收，然而题目中已要求不能allocate额外的空间，所以只能对当前传入的数组直接操作了！代码如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5c9a197ab47a3070d6ae82b4b6f20ee3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic4.zhimg.com/v2-5c9a197ab47a3070d6ae82b4b6f20ee3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic4.zhimg.com/v2-5c9a197ab47a3070d6ae82b4b6f20ee3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5c9a197ab47a3070d6ae82b4b6f20ee3_b.jpg\"/></figure><p>       然后对照答案，发现基本一致，步骤一致，复杂度一致，唯一不同的是我是前后对比，将不同的元素按顺序赋值，而它直接将赋值后的数组元素与原来数组对比。答案的代码如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a478596c4700ebf056cfe8c3a46b65fa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-a478596c4700ebf056cfe8c3a46b65fa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-a478596c4700ebf056cfe8c3a46b65fa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a478596c4700ebf056cfe8c3a46b65fa_b.jpg\"/></figure><p>       其性能基本一致，如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-974a205de8f900da562a8d9c486c6213_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb\" width=\"868\" data-original=\"https://pic4.zhimg.com/v2-974a205de8f900da562a8d9c486c6213_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;868&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"868\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"868\" data-original=\"https://pic4.zhimg.com/v2-974a205de8f900da562a8d9c486c6213_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-974a205de8f900da562a8d9c486c6213_b.jpg\"/></figure><h2><b>R: <a href=\"https://link.zhihu.com/?target=http%3A//spring.io/guides\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spring.io/guides</span><span class=\"invisible\"></span></a>  Building Java Projects with Maven</b></h2><p>        本文讲的是如何用maven构建项目</p><p>        1、创建一个普通java项目</p><p>        2、安装maven，准备好maven环境</p><p>        3、在项目根目录建立pom.xml的文件，配置必须包括&lt;modelVersion&gt;、&lt;groupId&gt;、&lt;artifactId&gt;、&lt;version&gt;、&lt;packaging&gt;</p><p>        4、如果只是构建项目，执行mvn complie；如果想要获取项目构建后的jar或者war，执行mvn install。<br/></p><h2><b>T: 基于@Transactional注解实现spring事务</b></h2><p>       项目中碰到spring事务中基本都在用@Transactional，但很多参数却不知道，虽然复制一下都能实现，但了解一些自然会更爽。其参数主要有如下几种：</p><p>      1、propagation，控制事务传播，默认propagation=Propagation.REQUIRED，多重事务执行最上层的方法的事务；</p><p>      2、isolation，控制事务隔离级别，默认和数据库的隔离级别相同</p><p>      3、readOnly，控制事务可读写还是只读，默认可读写</p><p>      4、timeout，控制事务超时时间，默认和数据库控制系统相同</p><p>      5、rollbackFor，控制事务哪些异常回滚，默认rollbackFor=RuntimeException.class</p><p>      6、rollbackForClassName，同上，默认rollbackForClassName=RuntimeException</p><p>      7、noRollbackFor，控制事务哪些异常不回滚，默认非RuntimeException</p><h2><b>S: 最近ARTS打卡的情况及想要的改变</b></h2><p>       ARTS参与接近两个月，包括这篇才4篇，基本上两周才一次，不出局的最低要求。实际上，回顾一下，我真的一周完成不了吗？非得拖到两周的最后一天吗？不，实际上，这几次提交的文章，基本上都是最后一天集中火力整的，如果将火力集中在最开始，那也是一样的效果。只是经常给自己的理由是，加班比较忙，这个先放后，于是真的放到了最后了！正如耗子哥所说，忙，并不是，而是对它的兴趣不够。那些低级不费脑子的东西，如微视频、小说，每天都会去看一下，难道它们更重要吗？所以，不是我忙，而是我把这间事情当成了一件难事而不是要事，所以一直拖到最后，应付了之。这样，即使再过几年，也不会有啥提升把！</p><p>       所以，必须要做点改变。</p><p>       1、积极主动。既然选择了参加ARTS，想要用输出逼迫自己在技术上的输入，那么，必须更多的投入。我选择了它，那我必然有时间去做。这是我乐意为之，也对我及其有意义的事。主动参与群里的互动，学习其他伙伴的打卡内容，点评、勾搭、交流，不亦乐乎！</p><p>       2、要事第一。最重要的事是成长，那么哪方面成长最重要呢？当然是吃饭的家伙了。工作上的很多东西目前并不能刺激自己成长，那么为啥不能把所有和技术有关的全部融入到ARTS呢，为什么ARTS不能成为最重要的东西呢！最重要的东西，那么值得把每天精力最好的时间投入到上面来！每天早上上班前的那一个小时就是它的了！</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67054088", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第二十九周", 
            "content": "<h2>左耳听风 第二十九周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode9.%25E5%259B%259E%25E6%2596%2587%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode9.回文数</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode10.%2520%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E5%258C%25B9%25E9%2585%258D.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode10. 正则表达式匹配</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.freecodecamp.org/how-to-understand-any-programming-task-aea41eabe66e\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to understand any programming task</a> 「如何去理解任意一个编程任务？」</p><p>作者给出了 3 个大步骤</p><p>1、<b>Analyze</b>。分析。这一步要做的是，明确编程的任务是什么。归类问题、总结问题、提炼问题、定义清楚问题。记住明确问题后再思考如何处理问题。</p><p>2、<b>Interpret and Evaluate</b>。理解并评估问题。明确任务中的专业术语（尤其是，你刚接触这类型任务时）。考虑好这些问题的处理你需要做哪些事。明确你是否已完全理解并能够解决这个问题。</p><p>3、<b>Think Critically</b>。批判性思考。在前面两点都达到的情况下，对于任务中的需求你可以提出自己所不认同的地方。但是你要给出原因以及相应的解决方案。</p><p>个人思考：想清楚要做是是什么，再去思考该怎么做。对于问题要有自己的思考，但是不能只凭感觉来判断问题，而是应该结合实际给出相应的依据，最好再带上能够落地的解决方案。</p><h2>Tip</h2><p>最近在学习 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC ，默认采用的是 Code First 代码优先的策略。而我是先建立 Model 再通过 EF 框架生成的数据库，所以在后序修改对应的 Model 文件时再运行网站就会报错。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b22a592339b16300afdd53e1dadcc997_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1727\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"1727\" data-original=\"https://pic4.zhimg.com/v2-b22a592339b16300afdd53e1dadcc997_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1727&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1727\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1727\" data-original=\"https://pic4.zhimg.com/v2-b22a592339b16300afdd53e1dadcc997_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b22a592339b16300afdd53e1dadcc997_b.jpg\"/></figure><p> 提示我们更新数据库，需要在 VS 编译器中的 NuGet 包管理控制台输入命令。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-be712fa7f637563b144c9cb83d16426b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1015\" data-rawheight=\"685\" class=\"origin_image zh-lightbox-thumb\" width=\"1015\" data-original=\"https://pic4.zhimg.com/v2-be712fa7f637563b144c9cb83d16426b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1015&#39; height=&#39;685&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1015\" data-rawheight=\"685\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1015\" data-original=\"https://pic4.zhimg.com/v2-be712fa7f637563b144c9cb83d16426b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-be712fa7f637563b144c9cb83d16426b_b.jpg\"/></figure><p> 未在控制台找到选项可在 VS 编译器导航栏：工具 ——&gt; NuGet 包管理器 ——&gt; 程序包管理控制器 打开。</p><p>1、添加迁移 Enable-Migrations + 你的数据库上下文 Model 名称</p><p>2、Add-Migration + 迁移文件名  添加迁移信息</p><p>3、update-database 更新数据库</p><p>通过这三步就完成了 Model 代码对应的数据库更新。</p><p>你也可以参考这篇文章：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wangzl1163/article/details/51659143\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">asp.net mvc Code First模式下迁移更新数据库</a></p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/66986226\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-1c7b1b500016845e96728a44af7f72bb_180x120.jpg\" data-image-width=\"3670\" data-image-height=\"2462\" class=\"internal\">胡sir：为什么要写作？</a><p>ARST 打卡 217 天分享一下写作的体会。对于「写作」这件比「学习」更逆人性的事，你有怎样的思考？</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66986226", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 2, 
            "title": "为什么要写作？", 
            "content": "<p>﻿从 2018 年 10 月 21 日开始写一些东西，至今 216 天，写一篇关于写作的体会。</p><h2>为什么要写作？</h2><p>对我来说，写作的一开始是为了打卡完成「ARTS」（极客时间《<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/intro/48\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">左耳听风</a>》专栏作业），每周分享一些技术或是其他方面的思考，这也是我正在做的事。</p><p>对于现在的我来说，「赚钱」并不是我的首要目的，而且现在水平还相差甚远。总的来说我写作有以下几个目的：</p><p>1、<b>记录当下的感想，做一些笔记</b>。记录自己的感想是一件很有趣的事，回过头再去看以前写的文章，你会发现时间原来可以过的这么快。而以前的学习笔记，会让你感受到自己的进步，体会自己成长过程的心理变化，更好的调整自己。</p><p>2、<b>提高自己的表达能力</b>。以我为例，一个理工科的学生，习惯于动手实践来表达。但是这种表达方式常常需要另一方具有一定专业水平，而这种沟通交流的方式受限于场景，通常需要面对面。在互联网时代，「远程协作」是一种比较常见的情况，在学习、工作或者生活中「文字表达」通常是我们的第一选择。你需要用比较通俗易懂的文字来描述一些「专业词汇」，或某一特殊场景。随着写作的次数增加，文章的阅读数上升，能够用「简单」、「明了」的话描述清楚你的意图时，表达能力也随之提高。</p><p>3、<b>理清思路，整理自己的逻辑思维</b>。和编程一样，「写作」通常不是一个提笔就能完成的事。我们通常要想好自己要写的主题，再列好提纲，最后根据大纲一步步的去写。粗糙的对应「软件工程」就是：需求分析 —— 总体设计 —— 具体实现。把这个过程变成一种习惯，你会熟练的把问题拆解，这个过程可以理清自己的思路，更好的去解决问题。</p><p>4、<b>对未来的一种长远投资</b>。虽然现在现在写作的能力还很菜，但是长期来看，写作并没有什么不好的。长期写作并分享在提升自己基础能力的同时，也提高了自己的影响力。只要时间够长，写一些真正对别人有帮助的东西，总能收获一些人的关注，或许会在将来给你带来意想不到的收获（没准，你火了）。</p><p>5、<b>用自己的一些经验给别人一些指导</b>。因为还处在从「菜鸟码农到程序员」的阶段，中间会遇见很多坑，希望可以写出来，给其他人一些借鉴。而且皓叔也说过「<b>学习是一件逆人性的事</b>」，既然如此我只有把自己不开心的过程写出来，让大家开心下了。（你们的点赞或者评论都是对我的一种鼓励）</p><h2>写作的收获</h2><p>写了我写作的目的，再讲讲，写作的收获吧。</p><p><b>文字积累，收获关注，赞赏支持</b>。积累了百来篇文章，主要是 LeetCode 题解、「<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/intro/126\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据结构与算法</a>」专栏学习笔记、经历复盘等。微信公众号、知乎专栏在无刻意推广的情况下，收获了一部分人的关注。星球作业、公众号文章收到了赞赏，算起了起来可以加一星期鸡腿了。（<b>感谢支持和鼓励</b>）</p><p><b>倒逼学习，自我提升</b>。随着读者数量的上升，读者会指出文章中的错误，或是未表达清楚的内容。这要求我纠正自己的错误，或者用更通俗的语言和读者描述问题。另一方面，写作需要大量的素材或体验，而我又必须每周至少完成 1 篇分享，这要求我去学习并体会一些知识，这样我才能保证每周都有内容可以输出。</p><h2>一些感想</h2><p>写作是并不是一件容易的事，一篇文章可能需要花上一天或者几天的时间来完成，所以<b>买到一本好书或者订阅了优质「专栏」是「血赚」</b>，不要不舍得花钱在买书上。</p><p><b>对于优质且用心的文章要支持，既利己又利他</b>。支持的方式有很多，有钱的可以捧个钱场（赞赏，给作者加个鸡腿）。没钱的，捧个人场，给优质的文章点赞、评论自己的观点、点个再看或者转发给朋友一起欣赏。你收获了优质的内容，同时也给了作者继续分享优质内容的动力。</p><p><b>把好的事情变成一种习惯</b>。学习已经是逆人性了，那写作分享自己的学习心得就是比学习更逆人性的事了，但是通常这些让你感到痛苦的事总是让你成长的事。让这些事变成一种习惯你的痛苦就会少一些。</p><p>感谢你的观看，你有任何想法都可以在评论或者留言中指出，欢迎探讨。</p>", 
            "topic": [
                {
                    "tag": "写作", 
                    "tagLink": "https://api.zhihu.com/topics/19552516"
                }
            ], 
            "comments": [
                {
                    "userName": "王小波", 
                    "userLink": "https://www.zhihu.com/people/731a36924203a8e851ebdbc7a03a379f", 
                    "content": "666哒[赞同]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66287079", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第二十八周", 
            "content": "<h2>左耳听风 第二十八周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode7.%2520%25E6%2595%25B4%25E6%2595%25B0%25E5%258F%258D%25E8%25BD%25AC.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode7. 整数反转</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%25208.%2520%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E8%25BD%25AC%25E6%258D%25A2%25E6%2595%25B4%25E6%2595%25B0%2520%28atoi%29.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 8. 字符串转换整数 (atoi)</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/edge-coders/coding-tip-try-to-code-without-if-statements-d06799eed231\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Coding Tip: Try to Code Without If-statements</a> 「编程技巧：尝试去写没有 if 语句的代码」</p><p>文章给出了尝试不写 if 语句代码的三点好处：</p><p>1、<b>改善思维</b>。和用不同范式去编程一样，当习惯了用 if 语句去处理问题时，换一种非 if 语句的思路去编程可以为我们提供一个新的思路，不局限于一种方法去解决问题。</p><p>2、<b>提高代码可读性</b>。用三元运算去替换简单的 if 语句可以帮助我们更好的阅读代码，if 分支阅读，代码的可读性就越差，可以用 switch 等语句替换多分支的 if 语句（C# 中 switch 在多分支语句性能稍高于使用 if）。</p><p>3、<b>让你更接近「代码即数据」的概念</b>。这一点有点玄。我的理解是非 if 语句更接近人的思考，在编程中感受更为直观，更利于理解。</p><p>文章中有一个比较有代表性的例子： if 语句代码</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">doubler</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">switch</span> <span class=\"p\">(</span><span class=\"k\">typeof</span> <span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">case</span> <span class=\"s1\">&#39;number&#39;</span><span class=\"o\">:</span>\n      <span class=\"k\">return</span> <span class=\"nx\">input</span> <span class=\"o\">+</span> <span class=\"nx\">input</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"s1\">&#39;string&#39;</span><span class=\"o\">:</span>\n      <span class=\"k\">return</span> <span class=\"nx\">input</span>\n        <span class=\"p\">.</span><span class=\"nx\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">((</span><span class=\"nx\">letter</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">letter</span> <span class=\"o\">+</span> <span class=\"nx\">letter</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">);</span>\n    <span class=\"k\">case</span> <span class=\"s1\">&#39;object&#39;</span><span class=\"o\">:</span>\n      <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span>\n            <span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">((</span><span class=\"nx\">key</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">])));</span>\n      <span class=\"k\">return</span> <span class=\"nx\">input</span><span class=\"p\">;</span>\n    <span class=\"k\">case</span> <span class=\"s1\">&#39;function&#39;</span><span class=\"o\">:</span>\n      <span class=\"nx\">input</span><span class=\"p\">();</span>\n      <span class=\"nx\">input</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"s1\">&#39;hey&#39;</span><span class=\"p\">));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">([</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">]));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">({</span> <span class=\"nx\">a</span><span class=\"o\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"nx\">b</span><span class=\"o\">:</span> <span class=\"s1\">&#39;hello&#39;</span> <span class=\"p\">}));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span>\n  <span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;call-me&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}),</span>\n<span class=\"p\">);</span>\n</code></pre></div><p>无 if 语句代码 将对象的类型绑定到 operationsByType 根据类型的不同执行相应的操作。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">doubler</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nx\">doubler</span><span class=\"p\">.</span><span class=\"nx\">operationsByType</span><span class=\"p\">[</span><span class=\"k\">typeof</span> <span class=\"nx\">input</span><span class=\"p\">](</span><span class=\"nx\">input</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">doubler</span><span class=\"p\">.</span><span class=\"nx\">operationsByType</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">number</span><span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">input</span> <span class=\"o\">+</span> <span class=\"nx\">input</span><span class=\"p\">,</span>\n  <span class=\"nx\">string</span><span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span>\n    <span class=\"nx\">input</span>\n      <span class=\"p\">.</span><span class=\"nx\">split</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">)</span>\n      <span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">((</span><span class=\"nx\">letter</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">letter</span> <span class=\"o\">+</span> <span class=\"nx\">letter</span><span class=\"p\">)</span>\n      <span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">),</span>\n  <span class=\"kd\">function</span><span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">input</span><span class=\"p\">();</span>\n    <span class=\"nx\">input</span><span class=\"p\">();</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">object</span><span class=\"o\">:</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nb\">Object</span><span class=\"p\">.</span><span class=\"nx\">keys</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">)</span>\n          <span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">((</span><span class=\"nx\">key</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"nx\">input</span><span class=\"p\">[</span><span class=\"nx\">key</span><span class=\"p\">])));</span>\n    <span class=\"k\">return</span> <span class=\"nx\">input</span><span class=\"p\">;</span>\n  <span class=\"p\">},</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">10</span><span class=\"p\">));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"s1\">&#39;hey&#39;</span><span class=\"p\">));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">([</span><span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"s1\">&#39;hello&#39;</span><span class=\"p\">]));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">doubler</span><span class=\"p\">({</span> <span class=\"nx\">a</span><span class=\"o\">:</span> <span class=\"mi\">5</span><span class=\"p\">,</span> <span class=\"nx\">b</span><span class=\"o\">:</span> <span class=\"s1\">&#39;hello&#39;</span> <span class=\"p\">}));</span>\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span>\n  <span class=\"nx\">doubler</span><span class=\"p\">(</span><span class=\"kd\">function</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;call-me&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}),</span>\n<span class=\"p\">);</span>\n</code></pre></div><h2>Tip</h2><p>最近重新回顾一遍 JavaScript 的知识，通过 VSCode + Node.js 在本地调试 JavaScript ，分享下简单的配置。 1、首先本地安装好 Node.js 以及 VSCode 编译器。 2、在编译器左侧工具栏（快捷键：Control + Shift + D ），在调试选项中选择添加配置。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-af47dc5a82cc4620576ba7887d50e16e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"437\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb\" width=\"437\" data-original=\"https://pic3.zhimg.com/v2-af47dc5a82cc4620576ba7887d50e16e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;437&#39; height=&#39;518&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"437\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"437\" data-original=\"https://pic3.zhimg.com/v2-af47dc5a82cc4620576ba7887d50e16e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-af47dc5a82cc4620576ba7887d50e16e_b.jpg\"/></figure><p> 3、在 launch.json 文件中敲出 node 四个字，选择启动程序 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9ee89824287bcaf4c19f2521a05e4f74_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb\" width=\"615\" data-original=\"https://pic1.zhimg.com/v2-9ee89824287bcaf4c19f2521a05e4f74_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;615&#39; height=&#39;379&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"615\" data-original=\"https://pic1.zhimg.com/v2-9ee89824287bcaf4c19f2521a05e4f74_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9ee89824287bcaf4c19f2521a05e4f74_b.jpg\"/></figure><p> 4、将 program 配置为当前文件 &#34;program&#34;: &#34;${file}&#34; </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ee1f6f024e62825be2f7c79edf2912db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb\" width=\"625\" data-original=\"https://pic4.zhimg.com/v2-ee1f6f024e62825be2f7c79edf2912db_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;625&#39; height=&#39;735&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"625\" data-original=\"https://pic4.zhimg.com/v2-ee1f6f024e62825be2f7c79edf2912db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ee1f6f024e62825be2f7c79edf2912db_b.jpg\"/></figure><p> 运行本地 js 文件，可以在调试控制台看到输出和报错。</p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E4%25B8%2580%25E6%25AC%25A1%25E4%25B8%258D%25E6%2588%2590%25E5%258A%259F%25E7%259A%2584%25E9%259D%25A2%25E8%25AF%2595%25E7%25BB%258F%25E5%258E%2586.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一次不成功的面试经历</a></p><p>第一次面试技术型岗位，虽然不太正式，但是还是暴露了一些问题，对此进行了复盘总结。每次面试，都是一次经验的收获。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66188448", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "一次不成功的面试经历", 
            "content": "<h2>﻿我的经历 </h2><p>经过：学校组织了一次小的招聘会，我下完课去现场面试了 1 家 IT公司，面试完，感觉面试不成功。（对技术问题不感兴趣的可以直接跳到复盘内容）</p><p>面试岗位：Java 后端</p><p>面试官是公司的技术人员，给出的第一个问题：如何用 1 个 Int 数组存储 1 个 IPv4 的地址？</p><p>这道题我没理解清楚：只说了每 8 位用 1 位存储。（第一问有点紧张，思绪混乱）</p><p>在了解我没有什么项目经历后，给出了面试第二问：列举一些常见的排序算法。</p><p>我的回答：基础的 O(n^2) 算法有「冒泡排序」、「选择排序」、「插入排序」，O(nlogn) 排序算法有「快速排序」、「归并排序」，比较特殊的有「桶排序」、「堆排序」。</p><p>然后问了下我常使用 Java 框架。</p><p>我回答没有，然后说了下以前非技术工作岗位的工作经历（没讲清楚）。</p><p>就留了电话，就没有了。</p><p>我的判断：多半没有获得下一轮的面试机会。（公司招聘的这个岗位对算法要求不高，主要是做业务实现。结尾连基本的「还有什么问题想问的？」也没说。）</p><h2>复盘</h2><p>按照顺序，复盘下这次面试需要改进的地方。</p><p><b>首先，在面试的过程中，尤其是技术问答环节，尽量理解好面试官的问题，要是没有听清楚可以请面试官重新复述或解释下问题</b>。因为技术型面试官肯定不是经常参与面试环节，对于题目的描述未必会很仔细。</p><p>比如第一个问题：面试官实际要问的是 32 位的 IPv4 地址（二进制表示）如何放入只能存储 31 位数据的 Int 数组（32 位，最高位为符号位）中。 如果理解清楚会给出的回答：将 IPv4 地址按照每 8 位转换成 10 进制数，再将转换后的 4 个数存入数组中（12 位空间就足够）。</p><p><b>其次，不要被面试官带走节奏。</b></p><p>其实就算只是完成了平时老师布置的作业，里面也会用到一些基本的技术和框架，例如：数据库连接、MVC 等。大多数情况不是没有，而是你没有把自己学过使用过的技术拎出来。</p><p><b>面试官并不了解你，所以你要带着面试官往你所熟悉的方面走</b>。例如：每学期的大作业，是如何分析设计这个项目？在实现的过程中采用了哪些技术，为什么这样选择。<b>技术水平的展现只是一小部分，重要的是让面试官知道你分析问题解决问题的能力</b>。（对于应届毕业生来说项目开发经验并不是最重要的）</p><p><b>放慢语速</b></p><p>这是面试紧张很容易出现的情况，但是我还是希望能够把语速放慢一点，这样就有足够的时间思考下一句话要说什么。说话的语速过快，语言肯定也还没组织好，很快你就会发现自己没话可说了，面试官也可能听不清你的回答。<b>注意放慢说话语速，要相信面试官会给时间给你组织语言。</b></p><h2>建议</h2><p>根据我看过的一些文章，以及我自己的一些感悟，我给出一些我的建议。</p><p>现在看到这的大概有两种人： 1、还没有面试过，不知道怎么开始？ 2、已经面试过，可能不是很理想？</p><p>对于第一种，我的建议如下：</p><p>1、<b>如果还没有职业规划（想不到要找的岗位）</b>？去各大招聘网站：前程无忧（<a href=\"https://link.zhihu.com/?target=https%3A//search.51job.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">search.51job.com</span><span class=\"invisible\"></span></a>）、智联招聘（<a href=\"https://link.zhihu.com/?target=https%3A//www.zhaopin.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhaopin.com/</span><span class=\"invisible\"></span></a>）、拉勾网（<a href=\"https://link.zhihu.com/?target=https%3A//www.lagou.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">lagou.com/</span><span class=\"invisible\"></span></a>）、Boss 直聘（<a href=\"https://link.zhihu.com/?target=https%3A//www.zhipin.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhipin.com/</span><span class=\"invisible\"></span></a>）等，找出里面招聘需求量最大，你所感兴趣的岗位去发展。</p><p>2、<b>已经有了想要从事的岗位但是不知道该准备什么</b>？参照第一条，招聘的要求就是你该准备的方向。还担心，就在有岗位需求的公司里，找离的最近的几家中小型公司面试一下，找找感觉。人家问的什么你答不上就是你要准备的。</p><p>3、<b>知道了要准备什么，不知道怎么开始</b>？找一找资源，培训机构的视频看一看（B 站可不止有二次元）。要是没什么自制力，想要快速提高，可以考虑花钱报个培训班。<b>不知道该选哪个</b>？去掉百度出来的前几个个，其他都还好，因为他们投入在广告的成本太高，教育投入的就少，水平可想而知。</p><p>对于第二种：</p><p>1、<b>面试感觉很差劲，感觉找不到想要的工作</b>？如果还没有放弃，请再多试试。面试类似于打游戏，是一个打怪升级的过程，每次都能收获经验值，当你有针对性的做攻略或是学习其他人的攻略，在等级相差不大的情况下，可以搞定。要是等级相差比较大，可以考虑换低一层次的公司，要相信，即使你是新手（菜鸟），也会有可以给你刷的怪（公司）。</p><p>2、<b>面试的公司水平不高，薪资待遇达不到自己的要求</b>。那你可能是属于高段位的「玩家」了。可以考虑关注下秋招，看看各大公司的官网，或者去 「V2EX」(<a href=\"https://link.zhihu.com/?target=https%3A//www.v2ex.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">v2ex.com/</span><span class=\"invisible\"></span></a>) 等网站求一些内推。</p><p>嗯，这一次复盘到这里就结束了，你有任何想法都可以在评论或者留言中指出，欢迎探讨。</p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65626928", 
            "userName": "立鹰", 
            "userLink": "https://www.zhihu.com/people/345903c30efed254105657d1bc716f53", 
            "upvote": 0, 
            "title": "ARTS第3周", 
            "content": "<p>Algorithm：主要是为了编程训练和学习， 每周至少做一个 leetcode 的算法题。</p><p>Review： 主要是为了学习英文， 阅读并点评至少一篇英文技术文章。</p><p>Tip：主要是为了总结和归纳你在日常工作中所遇到的知识点， 学习至少一个技术技巧。</p><p>Share：主要是为了建立影响力，输出价值观，分享一篇有观点和思考的技术文章。<br/></p><p><b>A: LeetCode 7.Reverse Integer  难度【easy】</b></p><p>    题目：Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Coud you solve it without converting the integer to a string?</p><p>    题意：判断以integer型的数字是否是回文。用不转成string的方式解决。</p><p>    思考：</p><p>            没有看到不用转成string的方式的说法，所以直接用string的方式处理了，如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ddeadeaf4834feacb329b77695294db2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-ddeadeaf4834feacb329b77695294db2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;831&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-ddeadeaf4834feacb329b77695294db2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ddeadeaf4834feacb329b77695294db2_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4abf464888990cbf947ba6d1c145963c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"891\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"891\" data-original=\"https://pic1.zhimg.com/v2-4abf464888990cbf947ba6d1c145963c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;891&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"891\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"891\" data-original=\"https://pic1.zhimg.com/v2-4abf464888990cbf947ba6d1c145963c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4abf464888990cbf947ba6d1c145963c_b.jpg\"/></figure><p>        用了额外的空间存储转换的字符串，内存的占用却少于100%，惊异加惊喜，虽然是错误的方式。</p><p>        因为要求是integer类型的数值，这就意味着它的值的范围是[−2^31,  2^31 − 1]，所以做比较和转换的时候就必须要尤其注意，至少直接将数字反转再比较肯定是不行的。但是用反转一半后的比较却是没有任何问题，求10的余得到最后一位，求除去10的商得到去除最后一位后的值，然后循环直到中间。中间的标志是什么呢？如果是偶数，分割出去的数字如果和留下的数字相等，那么就是中间；如果是奇数，分割出去的数字第一次比留下的数字大就是到了中间位置了，判断是否是回文，大的除以10和小的相等那就是回文。</p><p>    解法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-69ae762f7c9e574b3d6eb3b762af8025_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-69ae762f7c9e574b3d6eb3b762af8025_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;379&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-69ae762f7c9e574b3d6eb3b762af8025_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-69ae762f7c9e574b3d6eb3b762af8025_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f6e65c038af59fa025f0a2e87bbf8926_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb\" width=\"910\" data-original=\"https://pic3.zhimg.com/v2-f6e65c038af59fa025f0a2e87bbf8926_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;910&#39; height=&#39;651&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"910\" data-original=\"https://pic3.zhimg.com/v2-f6e65c038af59fa025f0a2e87bbf8926_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f6e65c038af59fa025f0a2e87bbf8926_b.jpg\"/></figure><p>很明显，转成string所用的时间大于直接用数字反转的方式，但两者时间复杂度都为O(n)，如果考虑到int型的数字最大也只有个31,也可以认为是O(1)。</p><p><b>R: <a href=\"https://link.zhihu.com/?target=http%3A//spring.io/guides\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spring.io/guides</span><span class=\"invisible\"></span></a>  schedule tasks</b></p><p>    本文讲的是如何调用restful服务，在处理好环境问题后，只剩下两步：</p><p>        1、创建一个javaBean作为接收访问的restful服务的返回信息</p><p>        2、直接new RestTemplate，并使用它的getForObject(String url, javaBean.class)</p><p>注意：可以用spring boot 管理应用，可以用 RestTemplateBuilder 来创建restTemplate。</p><p><b>T: mybatis的批量update</b></p><p>       在实际工作中，经常会碰到对数据库的批量操作，因为不可能在一个循环里面循环连接数据库，所以碰到这类情况，通常需要将数据处理成list后再调用一次数据库做一次的批量处理。</p><p>       增删改查，批量处理，最多的就是增和改了。而增基本上只有一种方式，那就是用&lt;foreach&gt;将传入的list处理成多个临时表dual，作为value添加到对应表中。</p><p>        而update面临的情况就会多一些。</p><p>        一、批量修改相同字段为相同值</p><p>                这个和基本操作比较一致，就多用了一个&lt;foreach&gt;标签</p><p>                 update table1 t1 </p><p>                    set t1.status = &#39;A&#39; </p><p>                where t1.id in  </p><p>                &lt;foreach collection=&#34;list&#34; item=&#34;item&#34; open=&#34;(&#34; close=&#34;)&#34; separator=&#34;,&#34;&gt;</p><p>                      #{item.id}</p><p>                &lt;/foreach&gt; </p><p>                即可。</p><p>       二、不同记录修改成不同的值</p><p>       2.1 简单的update循环，但可能造成sql语句太长而堵塞，如：</p><p>        &lt;foreach collection=&#34;list&#34; item=&#34;item&#34; separator=&#34;;&#34;&gt;</p><p>         update table t1</p><p>            set t1.status = #{item.status}</p><p>         where t1.id = #{item.id}<br/>      &lt;/foreach&gt;</p><p>     2.2 update下foreach字段值，如：</p><p>      update  table</p><p>      &lt;trim prefix=&#34;set&#34; suffixOverrrides=&#34;,&#34;&gt;</p><p>                  &lt;trim prefix=&#34;status=case&#34; suffix=&#34;end,&#34;&gt;</p><p>                           &lt;foreach collection=&#34;list&#34; item=&#34;item&#34;&gt;</p><p>                               &lt;if test=&#34;item.status != null and item.status !=&#39;&#39;&#34;&gt;</p><p>                                  when id=#{item.id} then #{item.status}</p><p>                              &lt;/if&gt;<br/>                         &lt;/foreach&gt;</p><p>                &lt;/trim&gt;</p><p>      &lt;/trim&gt;</p><p><b>S: spring开发工具STS</b></p><p>    从spring官网上看到 Spring Tool Suite（STS），于是下载试了一些。确实，在建立基本的spring项目上，非常方便，相当于直接在官网上down下“<a href=\"https://link.zhihu.com/?target=https%3A//start.spring.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://start.spring.io</a>”中的项目代码并导入工具中一样，默认下载了所有spring的包。步骤如下：</p><p>1、从官网上下载STS</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c0a4287cc706dbb093f33897c3d3b389_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"952\" data-original=\"https://pic2.zhimg.com/v2-c0a4287cc706dbb093f33897c3d3b389_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;952&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"952\" data-original=\"https://pic2.zhimg.com/v2-c0a4287cc706dbb093f33897c3d3b389_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c0a4287cc706dbb093f33897c3d3b389_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2、点击File，选择New/Spring starter Project，出现如下页面，相当于开始进行pom的配置</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bb64500a39150f7693b482ad9061ebc9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1408\" data-rawheight=\"817\" class=\"origin_image zh-lightbox-thumb\" width=\"1408\" data-original=\"https://pic2.zhimg.com/v2-bb64500a39150f7693b482ad9061ebc9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1408&#39; height=&#39;817&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1408\" data-rawheight=\"817\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1408\" data-original=\"https://pic2.zhimg.com/v2-bb64500a39150f7693b482ad9061ebc9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bb64500a39150f7693b482ad9061ebc9_b.jpg\"/></figure><p>3、点击next后，开始选择spring以外的依赖包，如果只是spring的初始化项目，可以不选择，就直接点击Finish结束或者点击Next查看取项目路径后再Finish。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4eac7c068a4fdb7244a17e9a9631224c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1408\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb\" width=\"1408\" data-original=\"https://pic1.zhimg.com/v2-4eac7c068a4fdb7244a17e9a9631224c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1408&#39; height=&#39;822&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1408\" data-rawheight=\"822\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1408\" data-original=\"https://pic1.zhimg.com/v2-4eac7c068a4fdb7244a17e9a9631224c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4eac7c068a4fdb7244a17e9a9631224c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-00d6430ce689a2be4ad90fd66b2f8e80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1411\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb\" width=\"1411\" data-original=\"https://pic1.zhimg.com/v2-00d6430ce689a2be4ad90fd66b2f8e80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1411&#39; height=&#39;816&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1411\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1411\" data-original=\"https://pic1.zhimg.com/v2-00d6430ce689a2be4ad90fd66b2f8e80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-00d6430ce689a2be4ad90fd66b2f8e80_b.jpg\"/></figure><p>       从刚开始项目需要自己一个文件一个文件的建，到直接可以下载初始项目导入，再到现在直接new就能有个完整内容可以直接启动的项目，越来越方便，然后对结构的理解也越来越不熟悉。有了更多的时间去关注上层业务逻辑，也意味着更少时间去关注底层，许多以前程序员觉得很自然的基础内容，对现在很多人来说，却成了根本不知道的事。技术在进步，越来越多的细节要点被装进了黑箱子，想要了解底层也就多了更多的阻碍，但更多的是突破心理上的图方便心理，去追究其本质，才能不再越来越方便的工具面前迷失。</p>", 
            "topic": [
                {
                    "tag": "信息技术（IT）", 
                    "tagLink": "https://api.zhihu.com/topics/19556498"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65499647", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第二十七周", 
            "content": "<h2>左耳听风 第二十七周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>继续按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode5.%2520%25E6%259C%2580%25E9%2595%25BF%25E5%259B%259E%25E6%2596%2587%25E5%25AD%2590%25E4%25B8%25B2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode5. 最长回文子串</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode6.%2520Z%2520%25E5%25AD%2597%25E5%25BD%25A2%25E5%258F%2598%25E6%258D%25A2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode6. Z 字形变换</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.freecodecamp.org/the-main-pillars-of-learning-programming-and-why-beginners-should-master-them-e04245c17c56\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">学习编程的主要支柱以及为什么初学者应当掌握它</a></p><p>总结下来文章比较核心的两点是「掌握基础」、「挑战和动机」。</p><p>现在很多培训或者大学的课程会让学生从框架开始学起，对于基础知识只是捎带，但是缺乏足够扎实的基础知识，是完全无法理解框架的。作者也给出了编程基础的四大元素「a function, a variable, a condition, and a loop  」，即：方法、变量、条件以及循环，这是编程的基础，所有的程序都依赖于这 4 个元素。而编程的初学者往往对这方面的理解和实际有很大的误差。所有的高阶技术都来自于基础，那些不会轻易被时间所淘汰的东西才是我们真正应当花时间和精力掌握的。</p><p>在有一定基础之后我们应当挑战一些我们有兴趣的项目，例如模仿一些知名的 App、网站，他们复杂的布局会让我们对完整的项目有所认识。在实现我们目标时我们会更有动力的在学习编程这条并不容易的道路上走下去。</p><p>最后，记住编程不是两周、一个月、或者半年、一年可以速成的，不要为看似强大的框架打乱自己学习的步骤，「学的太快」可能对你的实力没有太大提高，把看似基础的东西真正理解透彻才是你超越同一层次人的核心方法。</p><h2>Tip</h2><p>分享 1 个 Windows10 操作系统常用的分屏快捷键，「win + ←」或 「win + →」可以快速左分屏/右分屏。、在没有多余的扩展屏是个很实用的快捷键，尤其是在制作网页的时候，经常需要在页面和代码间切换效率较低。</p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E5%25A4%259A%25E8%25A1%25A8%25E6%259F%25A5%25E8%25AF%25A2%25EF%25BC%259A%25E5%25A4%258D%25E6%259D%2582%25E9%2597%25AE%25E9%25A2%2598%25E7%259A%2584%25E6%258B%2586%25E8%25A7%25A3%2520.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">多表查询：复杂问题的拆解」</a></p><p>对于本周做的一个多表查询进行了 1 个复盘，对于复杂问题重要的是如何去理清思路，拆解问题，将大问题分解成小问题解决才是关键。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64616227", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第二十六周", 
            "content": "<h2>左耳听风 第二十六周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>开始按顺序来完成「LeetCode」前 200 题</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode3.%2520%25E6%2597%25A0%25E9%2587%258D%25E5%25A4%258D%25E5%25AD%2597%25E7%25AC%25A6%25E7%259A%2584%25E6%259C%2580%25E9%2595%25BF%25E5%25AD%2590%25E4%25B8%25B2.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode3. 无重复字符的最长子串</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode4.%2520%25E5%25AF%25BB%25E6%2589%25BE%25E4%25B8%25A4%25E4%25B8%25AA%25E6%259C%2589%25E5%25BA%258F%25E6%2595%25B0%25E7%25BB%2584%25E7%259A%2584%25E4%25B8%25AD%25E4%25BD%258D%25E6%2595%25B0.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode4. 寻找两个有序数组的中位数</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//hackernoon.com/5-points-to-improve-your-programming-logic-23c8bbafe8d2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">5 points to improve your programming logic</a></p><p>「<b>改善你逻辑思维的 5 点</b>」，逻辑思维是成为一个优秀的开发者的关键点，只要从事编程一定绕不开算法（后端开发会更为常见），而算法依赖于 <b>逻辑思维</b>，对此作者给出了改善逻辑的 5 点。</p><p>1、<b>Think to solve</b>。思考如何去解决问题。将大的问题分解成小问题，把每个小问题用最合适的方法解决，大问题也就迎刃而解了。通过「伪代码」或者画图的方式可以帮助你更好的解决问题。</p><p>2、<b>Practice</b>。练习。改善逻辑思维最重要的一点就在于：在简单的问题上尝试更好的逻辑去解决。</p><p>3、<b>Learn about Data Strucutures and Algorithms</b>。学习数据结构和算法。程序的定义是：数据 + 算法。程序员就是用更好的算法将数据组合来解决问题。学习数据结构和算法可以帮我们锻炼思维，找到更好的解决方案。我们可以通过「象棋」一类的逻辑游戏来帮助我们训练出数学思维。</p><p>4、<b>Learn programming paradigms</b>。学习编程范式。编程范式（例如：函数式编程、面向对象编程等）代表的其实是编程的起源，亦是它的发展历史。它能告诉我们如何更好的理解编程的思想，通过不同的编程范式来实现同一功能可以极大的改善我们的逻辑思维。</p><p>5、<b>Look at other people&#39;s code</b>。看其他人的代码。每个人的思维都不一样，很多时候看别人的代码可以带给我们新的思路。<a href=\"https://link.zhihu.com/?target=https%3A//github.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GitHub</a> 上有很多优秀的代码给我们参考。</p><h2>Tip</h2><p>这周完成前端方面的小作业，用起了以前收藏的一个实用设计导航网站。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5399591bef6e70eabdd100781d82db42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1447\" data-rawheight=\"1139\" class=\"origin_image zh-lightbox-thumb\" width=\"1447\" data-original=\"https://pic3.zhimg.com/v2-5399591bef6e70eabdd100781d82db42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1447&#39; height=&#39;1139&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1447\" data-rawheight=\"1139\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1447\" data-original=\"https://pic3.zhimg.com/v2-5399591bef6e70eabdd100781d82db42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5399591bef6e70eabdd100781d82db42_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//so.uigreat.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">UI 设计师导航网</a></p><p>你可以在这里寻找一些 UI 设计的灵感和技巧，前端人员也可以在这里学习一些不错的前端网页、同时这里能够教你如何更好的配色。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bffd65151541fd00fc3c2b56ab831fbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1199\" data-rawheight=\"1194\" class=\"origin_image zh-lightbox-thumb\" width=\"1199\" data-original=\"https://pic4.zhimg.com/v2-bffd65151541fd00fc3c2b56ab831fbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1199&#39; height=&#39;1194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1199\" data-rawheight=\"1194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1199\" data-original=\"https://pic4.zhimg.com/v2-bffd65151541fd00fc3c2b56ab831fbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bffd65151541fd00fc3c2b56ab831fbf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E5%2588%259D%25E8%25AF%2586%25E5%258D%2595%25E4%25BE%258B%25E6%25A8%25A1%25E5%25BC%258F.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">初识「单例模式」</a></p><p>接触了一下「单例模式」，了解了「如何保证一个类只生成 1 个实例对象」，同时了解了「单例模式」解决多线程安全问题的「饿汉模式」以及「懒汉模式」。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": [
                {
                    "userName": "微光", 
                    "userLink": "https://www.zhihu.com/people/efa6b238261af2f46e6a29849dfa879f", 
                    "content": "<p>前端小作业指的是？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "<p>自己学习的课程作业</p>", 
                            "likes": 0, 
                            "replyToAuthor": "微光"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64601718", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "初识「单例模式」", 
            "content": "<h2>﻿什么是单例模式 </h2><p><b>Singleton Pattern</b> 被成为「<b>单例模式</b>」（比较常用的称呼），在《Head First 设计模式》中也被翻译为「单件模式」。<b>是一种用来创建独一无二的，只有一个实例对象的设计模式</b>。</p><p><b>单例模式</b> 的主要应用场景：线程池（threadpool）、缓存（cache）、注册表对象、打印机设备对象。<b>通过单一对象实例，避免对多个实例操作导致结果不一致</b>。</p><p>优势：单例模式可以保证重复操作的结果一致性。</p><h2>单例模式的实现</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">(){}</span> <span class=\"c1\">// 将构造函数私有，只能通过静态函数生成或调用\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">GetInstance</span><span class=\"o\">(){</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">uniqueInstance</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">uniqueInstance</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>这是一个「单例模式」的基本模型，但是存在的问题是：<b>当多个线程时，同时调用 Singleton.CreateSingleto() 方法可能会生成多个对象</b>。</p><p>所以我们需要给 Singleton 增加一个同步锁，保证在多个线程调用的时候只能有一个对象存在。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">(){}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kd\">synchronized</span> <span class=\"n\">Singleton</span> <span class=\"nf\">GetInstance</span><span class=\"o\">(){</span> <span class=\"c1\">// 给GetInstance() 方法加上同步锁，确保这个方法不会被多个线程同时调用\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">uniqueInstance</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"c1\">// 若对象实例不存在则创建 1 个实例\n</span><span class=\"c1\"></span>        <span class=\"o\">{</span>\n            <span class=\"n\">uniqueInstance</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span> <span class=\"c1\">// 若对象已存在则直接返回该对象\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>但是在采用同步锁后，会出现问题当多个线程 只是想要调用 uniqueInstance 实例而不是要创建多个实例时，同时调用 GetInstance() 方法时需要检测锁，需要等待其他线程结束使用才可以调用 uniqueInstance 减低了<b>多线程多任务同时处理的性能优势</b>。</p><p>对此我们可以有两种解决方式：</p><p><b>第一种</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span> <span class=\"c1\">// 在静态初始化器中创建单例\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">(){}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">GetInstance</span><span class=\"o\">(){</span>\n        <span class=\"k\">return</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span> <span class=\"c1\">// 直接返回已有单例\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>通过静态初始化器直接构建单例，对于每个想要调用单例的线程直接返回已有单例，而构造器设置为私有也不会生成新的实例。</p><p><b>第二种</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Singleton</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">volatile</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span> <span class=\"c1\">// volatile 表示 uniqueInstance 的值在变化，不需要编译器假设该值\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"nf\">Singleton</span><span class=\"o\">(){}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">Singleton</span> <span class=\"nf\">GetInstance</span><span class=\"o\">(){</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">uniqueInstance</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"c1\">// 当实例不存在再进入同步\n</span><span class=\"c1\"></span>        <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span><span class=\"o\">(</span><span class=\"n\">Singleton</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">){</span> <span class=\"c1\">// 第二重检查\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">uniqueInstance</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"o\">{</span>\n                    <span class=\"n\">uniqueInstance</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">Singleton</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">uniqueInstance</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>在需要单例对象时再去构建单例</b>，在第一次构建实例时再采取同步锁。通过「双重检查+锁」，减少不必要的同步。</p><h2>总结</h2><p>1、单例模式的目的是确保程序中一个类最多只有 1 个实例。</p><p>2、单例模式在保证 1 个类只有 1 个实例的同时提供了全局访问。（GetInstance（）为 public 可以全局访问）</p><p>3、单例模式的依赖于：<b>构造器的私有</b>（private Singleton()）、<b>静态方法</b>（public static Singleton GetInstance()）、<b>静态变量</b>（static Singleton uniqueInstance）。</p><p>4、解决多线程访问资源问题，单例模式有两种解决方案：</p><p>①、通过静态构造器直接生成唯一的单例。直接避免了同步锁的使用，但是需要提前为实例分配空间。（也称「<b>饿汉模式</b>」）</p><p>②、通过「双重检查+锁」，在需要单例时再构建，但是在首次构建时还是需要同步锁来保证只会生成唯一对象。（也称「<b>懒汉模式</b>」）</p><p><b>文章来自对《Head First 设计模式》第四章「单件模式」的学习整理，欢迎讨论。</b></p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64135121", 
            "userName": "立鹰", 
            "userLink": "https://www.zhihu.com/people/345903c30efed254105657d1bc716f53", 
            "upvote": 0, 
            "title": "ARTS第2周", 
            "content": "<p>Algorithm：主要是为了编程训练和学习， 每周至少做一个 leetcode 的算法题。</p><p>Review： 主要是为了学习英文， 阅读并点评至少一篇英文技术文章。</p><p>Tip：主要是为了总结和归纳你在日常工作中所遇到的知识点， 学习至少一个技术技巧。</p><p>Share：主要是为了建立影响力，输出价值观，分享一篇有观点和思考的技术文章。<br/></p><h2><b>A: LeetCode 7.Reverse Integer  难度【easy】</b></h2><p>       题目：Given a 32-bit signed integer, reverse digits of an integer. Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</p><p>       题意：将一个整型的数字反转，调用该算法的环境的int型必须在[−2^31,  2^31 − 1]，将超出该范围的结果返回0.</p><p>       思考：碰到该题，首先考虑到的是将该integer转换为String，用stringbuffer作为一个中间变量，从后面开始取每个字符反转拼接，形成新的字符串再转成integer。于是就有了如下的写法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7a3610ba689029059ec950b6424d8b96_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb\" width=\"1042\" data-original=\"https://pic3.zhimg.com/v2-7a3610ba689029059ec950b6424d8b96_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1042&#39; height=&#39;716&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1042\" data-rawheight=\"716\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1042\" data-original=\"https://pic3.zhimg.com/v2-7a3610ba689029059ec950b6424d8b96_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7a3610ba689029059ec950b6424d8b96_b.jpg\"/></figure><p>       但是该写法运行时间2毫秒，占用内存达到30多M，远远高于其他人。对照了参考答案，才发现自己是多么愚蠢，一个除法就能搞定的事却用了那么复杂的方法取处理。太久没有用过数学了，从没想过一个简单的数学方式可以将代码简化到这个地步，可以节省那么多空间！ 解法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0e5759b64bf9fc6f02803a54a3d6460_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-f0e5759b64bf9fc6f02803a54a3d6460_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;864&#39; height=&#39;504&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"864\" data-original=\"https://pic1.zhimg.com/v2-f0e5759b64bf9fc6f02803a54a3d6460_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0e5759b64bf9fc6f02803a54a3d6460_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b0d114fa810aea03fbd1af909d865497_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb\" width=\"873\" data-original=\"https://pic4.zhimg.com/v2-b0d114fa810aea03fbd1af909d865497_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;873&#39; height=&#39;219&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"873\" data-original=\"https://pic4.zhimg.com/v2-b0d114fa810aea03fbd1af909d865497_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b0d114fa810aea03fbd1af909d865497_b.jpg\"/></figure><p>相对而言，这种解法就简单多了，速度也更快了！完美的利用了数学！</p><h2>R: <a href=\"https://link.zhihu.com/?target=http%3A//spring.io/guides\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spring.io/guides</span><span class=\"invisible\"></span></a>  schedule tasks</h2><p>        本文讲的是spring的定时任务，在处理好环境问题后，只剩下两步：</p><p>        1、注入对应的类，并在想使用定时任务的类上加上注解@Scheduled(fixedRate = 5000)，fixedRate是定时任务发起的间隔时间，单位是毫秒。</p><p>        2、在启动类中添加注解@EnableScheduling，该注解创建定时任务执行器，没有它定时任务无法执行。</p><p>注意：定时任务的间隔方式的注解@Scheduled的属性还可以使用fixedDelay和cron，前者是定时任务启用完成后开始计时，后者是可以配置比较复杂规则的表达式。cron表达式至少有6个（或者7个）有空格分隔的时间元素，按顺序依次为秒、分钟、小时、天（月的天数）、月、星期。</p><h2>T: springcloud 的 foreign的动态链接访问</h2><p>       springcloud使用foreign时一般是固定访问，但有时候会出现访问的地址是变化的，尤其是作为方法回调的时候，步骤如下：</p><p>      1、@FeignClient 对应的接口不带url，改为RequestLine修饰方法，代码如下:</p><p>            @FeignClient(name=&#34;feignApi&#34;)</p><p>            public  interface FeignApi(){</p><p>                    @RequestLine(&#34;POST&#34;)</p><p>                    public void add***(URI uri);</p><p>            }</p><p>       2、调用类必须引入FeignClientConfiguration,代码如下：</p><p>            @Import(FeignClientConfiguration.class)</p><p>            public class GetFeignService{</p><p>                    private FeignApi feignApi; </p><p>                    @Autowired</p><p>                    public GetFeignService(Decoder decoder, Encoder encoder){</p><p> feignApi =Feign.builder().encoder(encoder).decoder(decoder).target(</p><p>                            Target.EmptyTarget.create(FeignApi.class)</p><p>                        )</p><p>                    }</p><p>            }</p><p>       3、调用类必须以构建函数的方式注入FeignClient类，必须有encoder和decoder，如上</p><p>       4、调用时传入动态url的实例作为参数，如下：</p><p>             feignApi.add***(new URI(url));</p><h2>S: 算法的评估指标</h2><p>       算法就是解决指定问题的一串指令，就和我们平时解决问题一样要一步一步去做，这个过程就是算法。做事的方法千千万，但存在方法有用、没用，或者存在最有效的方法，在数学角度上来说，就是存在最优解。算法同样如此，存在最优的算法。所以就需要有个评估优劣的标准，我们在LeetCode上做算法题时经常也给出了两个方面的评估，一个时时间复杂度，一个时空间复杂度，这个就时算法的两个评估指标了。</p><p>       但时间和空间上总存在着矛盾，基本上不可能两则同时最优，所以要根据实际情况做一个协调。但由于目前设备的内存空间基本上都是非常充沛的，所以更多的是考虑时间复杂度，以空间换取时间。</p><p>       算法的时间复杂度是指执行算法所需要的计算工作量，可以用算法所耗费的时间去度量。一个算法所耗费的时间=算法中每条语句的执行时间之和，每条语句的执行时间=语句执行次数*语句执行一次所需的时间。一般来说，语句执行一次所需的时间取决于机器的性能和人为的代码质量，这是难以确定的，这种外在因素不在考虑范围内。所以一个算法的时间耗费可以认为是所有语句的执行次数之和，也叫时间频度，记为T(n)。</p><p>       T(n)是n的函数，随着n的变化而变化，且呈现一定的规律。就像普通数字分为个、十、百、千、万这些级别，时间频度也可以分成这样的类似级别，也就是时间复杂度。比如，T(n)=n^2 + 3n + 4，在充分大的时候，影响T(n)大小的就是n^2，其他都能忽略不计了，所以这个时间频度对应的时间复杂度就是O(n^2)。所以时间复杂度，记作T(n) = O(f(n))，f(n)为一个辅助函数。</p><p>       按数量级递增排序，时间复杂度有：常数阶O(1)、对数阶O(logn)、线性阶O(n)、线性对数阶O(nlogn)、平方阶O(n^2)、立方阶O(n^3)、······、k方阶O(n^k)、指数阶O(2^n)。</p><p>       空间复杂度是指算法在计算机执行时所需要存储空间的度量，记作：S(n)=O(f(n))，与时间复杂度类似。这里所需要的存储空间包括3个部分：1、算法程序所占的空间；2、输入的初始数据所占的存储空间；3、算法执行过程中所需要的额外空间。空间复杂度主要针对第3点，一般是运行过程中为局部变量分配的存储空间的大小。比较常用的有：O(1)、O(n)、O(n^2)。</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64132749", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 第二十五周", 
            "content": "<h2>左耳听风 第二十五周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）<br/> </blockquote><h2>Algorithm</h2><p>主要考察的链表的遍历以及尾结点插入的知识 </p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%25202.%2520%25E4%25B8%25A4%25E6%2595%25B0%25E7%259B%25B8%25E5%258A%25A0.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//hackernoon.com/top-12-things-that-destroy-developer-productivity-2ddf0abc190\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Top 12 Things That Destroy Developer Productivity</a></p><p>「摧毁开发者生产力的 12 件事？」</p><p>被排在第一位的是「Interruptions &amp; Meetings」（打断和会议）。每一次被打断思路，都至少需要 30 分钟来回到状态。而长时间的会议对于开发者来说并没有效果，通常会议能带来的就是更多的需求和功能，这反而会降低生产效率。</p><p>「Vagueness」（模糊）。不清晰的描述通常会极大的降低生产效率，产品和技术之间的沟通不够细致，带来的可能是技术人员自己想象的样子，而这与实际需要往往大相径庭。因为技术人员会考虑更为简单以功能实现为目的，而产品还要考虑交互、界面等因素，这都需要更为细致准确的描述。</p><p>「Lack of Consideration to Technical Debt」，对技术债缺乏考虑。在「敏捷开发」大行其道的今天，快速上线是产品开发考虑的首要因素，这这留下了许多技术债，前期不考虑产品的扩展性，降低功能模块之间的耦合度，最终会在后序的开发过程中带来更多的维护成本，这也是开发人员生产力受限的主要因素之一。</p><h2>Tip</h2><p>Visual Studio 由微软出品被誉为宇宙第一编译器，内置了许多强大的功能以及快捷键，之前介绍过「自定义代码块」，今天介绍一个 VS 中非常常用的代码块快捷键 「prop」。</p><p>在编写 C# 或者 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> 代码时，只要打出 prop 按 2 下 Tab 键就可以生成以下代码块：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"n\">MyProperty</span> <span class=\"o\">{</span> <span class=\"n\">get</span><span class=\"o\">;</span> <span class=\"n\">set</span><span class=\"o\">;</span> <span class=\"o\">}</span></code></pre></div><p>按 Tab 键还可以在字段类型和字段名之间跳转，可以很方便的设置类属性，在实际开发中比较实用。</p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E9%2594%2599%25E8%25AF%25AF%25E7%259A%2584%25E5%25AD%25A6%25E4%25B9%25A0%25E6%2580%259D%25E7%25BB%25B4.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">错误的学习思维</a></p><p>学习进入了误区，在别人的指导下改正了自己学习技术的一些错误认识，同时根据《高效学习》一书列出了整体性学习的框架。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63215144", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "左耳听风 二十四周", 
            "content": "<h2>左耳听风 第二十四周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>对「字符串匹配」以及「DFS 深度优先」、「BFS 广度优先」的知识做一些题巩固一下  <a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%2520102.%2520%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591%25E7%259A%2584%25E5%25B1%2582%25E6%25AC%25A1%25E9%2581%258D%25E5%258E%2586.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 102. 二叉树的层次遍历</a> <a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%2520804.%2520%25E5%2594%25AF%25E4%25B8%2580%25E6%2591%25A9%25E5%25B0%2594%25E6%2596%25AF%25E5%25AF%2586%25E7%25A0%2581%25E8%25AF%258D.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 804. 唯一摩尔斯密码词</a> <a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode%2520559.%2520N%25E5%258F%2589%25E6%25A0%2591%25E7%259A%2584%25E6%259C%2580%25E5%25A4%25A7%25E6%25B7%25B1%25E5%25BA%25A6.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 559. N叉树的最大深度</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/s/story/reflections-on-clean-code-8c9b683277ca\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What Is Clean Code?</a></p><p>「什么才是整洁的代码？」</p><p>这篇文章实际是对《代码整洁之道》（原名：Clean Code）的观后感。作者分享了自己所认为「整洁的代码」应具备的几个原则：</p><p>1、Clean code is simple.过于聪明的技巧最终会变成作者自己的技巧，长期来看，这削弱了产品的价值。</p><p>2、Clean code is readable.整洁的代码应该是可以阅读的。在代码要去有意义的变量名，遵循代码规范。</p><p>3、Clean code is considerate.整洁的代码应当是考虑周到的，需要考虑将来的扩充和维护。</p><p>4、Cleand coed is tested.整洁的代码应当是被测试过的。谁也无法保未经过测试的代码不会在下一秒出错。</p><p>5、Clean code is praticed.整洁的代码应当被练习过。整洁的代码应当是一种习惯而不仅仅是应付工作。</p><p>6、Clean code is relentlessly refactored.整洁的代码应当不断被重构。</p><p>7、Clean code is SOLD.整洁的代码应当遵循 SOLID （面向对象设计 5 原则：单一责任、开闭原则、里式替换原则、接口分离原则、依赖倒置原则）原则。</p><p>《代码整洁之道》也是长期霸占软件工程书籍榜首的书，每一个程序员都应当仔细的阅读这本书，因为它所传达的不止是为什么要设计整洁的代码，更多的是编程以及实际生活中所需要的工程思想。</p><h2>Tip</h2><p>最近在阅读《<a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> MVC5 高级编程》这本书，里面提到了对于 XSS（跨站脚本攻击）的一些技巧。</p><p>首先介绍一下 XSS 跨站脚本工具主要的两种方法</p><p>1、被动注入。直接在页面上输入代码，通过系统数据库呈现在网页。</p><p>2、主动注入。把自己伪造的表单代码嵌入网页，让用户将隐秘的信息提交到自己的服务器。常用于留言评论。</p><p>其实都是因为没有对用户输入的信息进行编码和过滤，要注意，所有用户的输入都是未知且不可信的，黑客也是「用户」的一种，只不过可能不是我们喜欢的。</p><p>对于用户的输入，我们可以通过 「HTML 编码」、「Javascript 编码」以及第三方安全工具等，对于用户的输入进行编码验证，避免恶意的 XXS 攻击。 <a href=\"https://link.zhihu.com/?target=http%3A//ASP.NET\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ASP.NET</span><span class=\"invisible\"></span></a> 4 有现成的工具：Html.Encode、Html.AttruteEncode、Ajax.JavaScriptStringEncode 以及 AntiXSS 库帮助我们预防 XSS 攻击。</p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E5%25AD%2597%25E7%25AC%25A6%25E4%25B8%25B2%25E5%258C%25B9%25E9%2585%258D%25E5%259F%25BA%25E7%25A1%2580%25E5%2585%25A5%25E9%2597%25A8.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">字符串匹配基础入门</a></p><p>对字符串匹配中最为常用的「BF 算法」、「RK 算法」进行学习和实现。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63195645", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "字符串匹配基础入门", 
            "content": "<h2>﻿BF 暴力匹配法 </h2><p><b>BF(Brute - Force) 暴力匹配算法</b>，是字符串匹配算法中最基础，也是最常用的算法。</p><blockquote> BF算法，即暴风(Brute Force)算法，是普通的模式匹配算法，BF算法的思想就是将目标串S的第一个字符与模式串T的第一个字符进行匹配，若相等，则继续比较S的第二个字符和 T的第二个字符；若不相等，则比较S的第二个字符和T的第一个字符，依次比较下去，直到得出最后的匹配结果。BF算法是一种蛮力算法.<br/> </blockquote><p>在字符串匹配中，将源字符串称之为 <b>主串</b> ，需要匹配的子串称之为 <b>模式串</b> 。</p><p>例：在 source 字符串的子串中查找是否有 target 字符串一样的。 source 就是 <b>主串</b>，target 就是 <b>模式串</b>。</p><p><b>而任意 m 大小的主串，只有 m-n+1 个大小为 n 的子串</b>。（注：这里的子串并非是指主串中的元素组合、而是指主串中连续的某一段） 参考代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// source 是主字符串、target 是要匹配的模式串\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">bruteForce</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">source</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// BF 字符串暴力匹配算法，从源字符串的第 1 个字母开始和 target1 首字母比较，若相等则依次向后比较\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 不相等则再寻找下 1 相同字母索引\n</span><span class=\"c1\"></span>        <span class=\"kt\">boolean</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">target</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// 最多需要比较的次数\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">subStrLen</span> <span class=\"o\">=</span> <span class=\"n\">target</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">len</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">subStrLen</span><span class=\"o\">).</span><span class=\"na\">contentEquals</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">result</span> <span class=\"o\">==</span> <span class=\"kc\">true</span><span class=\"o\">)</span>\n                    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span> <span class=\"c1\">// 当出现相等模式串时返回 true\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>思路：遍历主串，在找到第 1 个与模式串首字母相同的字符时，开始匹配，若不一致，则在主串中寻找下一个匹配字符。</p><p>从算法的时间复杂度来看 <b>BF 暴力匹配算法</b> 的时间复杂度是 O( M*N )，M 为主串长度，N 为模式串长度。属于复杂度比较高的算法，但是因为写法简单，不宜出错，所以最为常用，后续的 <b>所有的字符串匹配算法其实就是对 BF 算法的优化</b>。</p><h2>RK 算法</h2><p>RK 算法全名为：Rabin-Karp，由两位创始人的名字组成</p><p>思路：把主串中的 M-N+1 个子串生成哈希值，再让模式串生成哈希值，当子串和模式串生成的哈希值一致时，我们再比较子串和模式串是否一致（存在哈希冲突的可能性），一致则匹配成功，不一致则继续在子串中查找。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">RK</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">source</span><span class=\"o\">,</span><span class=\"n\">String</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()-</span><span class=\"n\">target</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">tarLen</span><span class=\"o\">=</span> <span class=\"n\">target</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">targetValue</span><span class=\"o\">=</span><span class=\"n\">hashValue</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">);</span>\n        <span class=\"n\">String</span> <span class=\"n\">tempStr</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">len</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">tempStr</span><span class=\"o\">=</span><span class=\"n\">source</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">,</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">tarLen</span><span class=\"o\">);</span>\n            <span class=\"c1\">// 注意字符串不能直接用 == 比较，因为 == 比较的是两个字符串是否引用同一对象\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">hashValue</span><span class=\"o\">(</span><span class=\"n\">tempStr</span><span class=\"o\">)==</span><span class=\"n\">targetValue</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">tempStr</span><span class=\"o\">.</span><span class=\"na\">contentEquals</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">))</span> \n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hashValue</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">str</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 哈希函数\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">len</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">value</span><span class=\"o\">+=</span><span class=\"n\">str</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">)-</span><span class=\"sc\">&#39;a&#39;</span><span class=\"o\">;</span> <span class=\"c1\">// 假设所有的字符都是小写英文字母\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>总结，借助哈希算法的思想，RK 算法的时间复杂度大致为 O(M)，M 为主串的长度。但是因为字符串可能为不同的类型（字符大小写、数值），这会增加哈希函数的复杂度，但是总体来说 <b>RK 算法</b> 的效率比 <b>BF 算法</b> 的效率更高。</p><p>回顾一下散列表的知识点。哈希函数的设计主要还是采用了「除留余数法」，将各种类型先转换成整数再放入散列数组。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0956a8f5377b035ea4c50f10664641e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1410\" data-rawheight=\"624\" class=\"origin_image zh-lightbox-thumb\" width=\"1410\" data-original=\"https://pic1.zhimg.com/v2-0956a8f5377b035ea4c50f10664641e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1410&#39; height=&#39;624&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1410\" data-rawheight=\"624\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1410\" data-original=\"https://pic1.zhimg.com/v2-0956a8f5377b035ea4c50f10664641e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0956a8f5377b035ea4c50f10664641e0_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "字符串", 
                    "tagLink": "https://api.zhihu.com/topics/19660131"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62404621", 
            "userName": "夜如白昼", 
            "userLink": "https://www.zhihu.com/people/6e59fba96c92b7274ac250dcd1b0d253", 
            "upvote": 0, 
            "title": "左耳听风 ARTS 第四周", 
            "content": "<blockquote>每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>装最多的水的容器</p><p>给定n个正整数，每个整数加上下标代表一个坐标（i，a(i)）,i为坐标的横向偏移，a(i)为纵向偏移，求给定坐标中能装载的最大容量</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d313346104e2c7671258bc4e55c20646_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"318\" class=\"origin_image zh-lightbox-thumb\" width=\"646\" data-original=\"https://pic3.zhimg.com/v2-d313346104e2c7671258bc4e55c20646_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;646&#39; height=&#39;318&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"646\" data-rawheight=\"318\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"646\" data-original=\"https://pic3.zhimg.com/v2-d313346104e2c7671258bc4e55c20646_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d313346104e2c7671258bc4e55c20646_b.jpg\"/></figure><a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/container-with-most-water/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-0c435ab948b151fd834be55f80a09794_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Loading...</a><p>解法一，最直接简单的方式，将每种可能的组合遍历求出最大容量，时间复杂度 <img src=\"https://www.zhihu.com/equation?tex=n%5E%7B2%7D\" alt=\"n^{2}\" eeimg=\"1\"/> ，空间复杂度1：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maxArea</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">height</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MIN_VALUE</span><span class=\"o\">;</span>\n        \n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">height</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"o\">=</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">&lt;</span><span class=\"n\">height</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">int</span> <span class=\"n\">volume</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">volume</span> <span class=\"o\">&gt;</span> <span class=\"n\">max</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">volume</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"k\">return</span> <span class=\"n\">max</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>解法二，使用双指针，一个初始化为数组头部，一个为数组尾部;求出双指针之间容量;移动指针中较短的那个;直到双指针相等。时间复杂度n，空间复杂度1：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">maxArea</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">height</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MIN_VALUE</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">height</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        \n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">volume</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">],</span> <span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">-</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">max</span><span class=\"o\">,</span> <span class=\"n\">volume</span><span class=\"o\">);</span>\n            \n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">height</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">{</span>\n                <span class=\"n\">i</span><span class=\"o\">++;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">j</span><span class=\"o\">--;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        \n        <span class=\"k\">return</span> <span class=\"n\">max</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>Review</h2><a href=\"https://link.zhihu.com/?target=https%3A//dev.to/brpaz/how-do-i-organize-my-knowledge-as-a-software-engineer-4387%3Futm_source%3Dwanqu.co%26utm_campaign%3DWanqu%2BDaily%26utm_medium%3Dwebsite\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-6c6e98c324cfebfc8652cb70b5561532_180x120.jpg\" data-image-width=\"1000\" data-image-height=\"500\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How I organize my knowledge as a Software Engineer</a><p>作为工程师：我是如何组织知识</p><ol><li>知识包：NotionHQ</li><li>保存感兴趣的文章：pocket</li><li>片段管理器：snippetStore</li><li>备忘录：DevHints</li><li>批注与高亮：diigo</li></ol><h2>Tip</h2><p>命令行几个常用快捷键</p><div class=\"highlight\"><pre><code class=\"language-text\">ctrl-a，光标移到行首\nctrl-e，光标移到行尾\nalt-f，光标移到后一个单词\nalt-b，光标移到前一个单词\nctrl-u，删除整行\nctrl-k，向后删除所有\nctrl-p，上一条命令\nctrl-n，下一条命令\nctrl-r，搜索历史命令</code></pre></div><h2>Share</h2><p>这二周事情比较多一些，公司私人都有，就说一下和同事之间聊天的一些触动点：</p><ol><li>年龄的确是衡量技术的一个指标，什么年龄应该具备什么样的技术/行业储备。比如你30多岁要去大厂应聘的话，他们是会以一个技术/行业专家要求你，不止是只是储备，还有项目经历和总结。所以年轻时要珍惜时光，不要在舒适区停止或者缓慢成长。</li><li>入职新公司不知是熟悉公司的技术框架和流程，还要有大局观，特别是大公司，你去的只是一个小组，你不止是要了解小组的业务知识，还需要去了解小组负责业务的上下文业务。</li></ol>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62408532", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第二十三周", 
            "content": "<h2>左耳听风 第二十三周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>这道题采用的是「桶排序」的方法，问题的关键在于如何合理的分桶。 </p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode164.%2520%25E6%259C%2580%25E5%25A4%25A7%25E9%2597%25B4%25E8%25B7%259D.md\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.freecodecamp.org/how-to-check-if-an-input-is-empty-with-css-1a83715f9f3e\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How to check if an input is empty with CSS</a></p><p>「如何使用 CSS 来检测一个输入是否为空呢？」。</p><p>作者在文章中讲述了自己用纯 CSS 实现检测输入为空的情况。</p><p>首先根据用户的给与回应，在用户输入的正确与否改变文本框颜色。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"c\">/* Show red borders when filled, but invalid */</span>\n<span class=\"nt\">input</span><span class=\"p\">:</span><span class=\"nd\">not</span><span class=\"o\">(</span><span class=\"p\">:</span><span class=\"nd\">placeholder-shown</span><span class=\"o\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">border-color</span><span class=\"p\">:</span> <span class=\"nb\">hsl</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">76</span><span class=\"kt\">%</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"kt\">%</span><span class=\"p\">);;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c\">/* Show green borders when valid */</span>\n<span class=\"nt\">input</span><span class=\"p\">:</span><span class=\"nd\">valid</span> <span class=\"p\">{</span>\n  <span class=\"k\">border-color</span><span class=\"p\">:</span> <span class=\"nb\">hsl</span><span class=\"p\">(</span><span class=\"mi\">120</span><span class=\"p\">,</span> <span class=\"mi\">76</span><span class=\"kt\">%</span><span class=\"p\">,</span> <span class=\"mi\">50</span><span class=\"kt\">%</span><span class=\"p\">);</span>\n<span class=\"p\">}</span></code></pre></div><p>其次，当用户输入空数据时不再向后端提交数据，将光标重新定位到文本框。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"o\">&lt;</span><span class=\"nt\">input</span> <span class=\"nt\">type</span><span class=\"o\">=</span><span class=\"s2\">&#34;text&#34;</span> <span class=\"nt\">name</span><span class=\"o\">=</span><span class=\"s2\">&#34;input&#34;</span> <span class=\"nt\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;input&#34;</span> <span class=\"nt\">required</span> <span class=\"o\">&gt;</span></code></pre></div><p>最后利用 CSS 的正则表达式判断验证输入的数据格式是否正确。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"o\">&lt;</span><span class=\"nt\">input</span> <span class=\"nt\">type</span><span class=\"o\">=</span><span class=\"s2\">&#34;text&#34;</span> <span class=\"nt\">name</span><span class=\"o\">=</span><span class=\"s2\">&#34;input&#34;</span> <span class=\"nt\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;input&#34;</span> <span class=\"nt\">required</span> <span class=\"nt\">placeholder</span><span class=\"o\">=</span><span class=\"s2\">&#34;Type something in here&#34;</span> <span class=\"nt\">pattern</span><span class=\"o\">=</span><span class=\"s2\">&#34;.*\\S.*&#34;</span><span class=\"o\">&gt;</span>\n<span class=\"o\">//</span> <span class=\"o\">.*</span><span class=\"err\">\\</span><span class=\"nt\">S</span><span class=\"o\">.*</span> <span class=\"nt\">正则</span><span class=\"err\">，</span><span class=\"nt\">表示前后两个字符之间必须有一个非空字符串</span></code></pre></div><p>实际上这些都是利用了 <b>HTML5</b> 增加的属性，随着各大浏览器对 HTML5 的支持，新属性的强大功能也不断展现，在微软拥抱谷歌浏览器后，兼容问题已经不是很大了，在《HTML5 权威指南》一书中对 HTML5 新属性有着很全面的介绍，是前端了解 <b>HTML5</b> 应当阅读的一本书。</p><h2>Tip</h2><p>刚接触 SQL 很容易写反各个语句的位置，老师给了 SQL 的基本模板，可以参照以下格式编写 SQL。 SELECT ...  --选择表 FROM ... -- 数据源 WHERE ... -- 筛选数据 GROUP ... -- 对数据进行分组 HAVING ... --  对分组后数据进行筛选，需要放在分组后 ORDER BY ... -- 对数据进行排序，默认升序</p><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share/blob/master/%25E7%25AE%2580%25E5%258D%2595%25E5%2585%25A5%25E9%2597%25A8%25E5%259B%25BE%25E8%25AE%25BA.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">简单入门图论</a></p><p>对于「图」进行了一个简单的入门，关键在于理解「深度遍历」、「广度遍历」的含义以及具体实现。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62403856", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 3, 
            "title": "简单入门图论", 
            "content": "<h2>数据结构中的图是什么？ </h2><p>文章内容来自于对<b>王争</b>老师<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/article/70537\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《数据结构与算法之美》</a>栏的学习整理。</p><p><b>图</b>，通常用来表示复杂的关系，一对一、一对多或是多对多。</p><p>根据根据图中数据的对应关系可分为：</p><p>「无向图」，即 A 关联 B 时，B 同时关联 A。例：微信中当 A 是 B 好友时，B 一定也是 A 的好友（新版本中已支持双向删除好友）。这种关联是双向的。</p><p>「有向图」，即 A 关联 B 时，B 未必关联 A。例：微博中粉丝与博主的关系，粉丝关注了博主，但是博主未必关注了每一个粉丝。这种关联性是单向的。</p><p>「带权图」，除了表示 A 与 B 是否关联外还表示这种关联度的权重。例如：QQ 空间的好友亲密度。在基本的关联度上附加了其他属性，表示更为复杂的关系。</p><p>图中的每一个元素被称为：<b>顶点</b> 。顶点之间表示联系的被称为 <b>边</b>。而顶点所关联的顶点数被称为 <b>度</b>。</p><p>在有向图中，顶点 A 所指向的顶点数被称为 <b>出度</b>，而所有指向 A 的顶点数之和被称为顶点 A 的 <b>入度</b>。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5df3e35355fc42b6a3c372d713755605_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"491\" data-original=\"https://pic2.zhimg.com/v2-5df3e35355fc42b6a3c372d713755605_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;491&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"491\" data-original=\"https://pic2.zhimg.com/v2-5df3e35355fc42b6a3c372d713755605_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5df3e35355fc42b6a3c372d713755605_b.jpg\"/></figure><h2>  表示方式  </h2><p><b>邻接矩阵法</b>。即将图中 N 个定点的关系用 N*N 个点组成的表示彼此之间的关联关系 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7637e569e84785fd2a21e884f33bface_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1211\" data-rawheight=\"712\" class=\"origin_image zh-lightbox-thumb\" width=\"1211\" data-original=\"https://pic3.zhimg.com/v2-7637e569e84785fd2a21e884f33bface_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1211&#39; height=&#39;712&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1211\" data-rawheight=\"712\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1211\" data-original=\"https://pic3.zhimg.com/v2-7637e569e84785fd2a21e884f33bface_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7637e569e84785fd2a21e884f33bface_b.jpg\"/></figure><p><b>邻接矩阵法</b>。通过 <b>数组</b> 的方式来表示图中各个顶点所对应的关系。</p><p>优点：可以通过下标快速获取图中两个顶点所对应的关系。</p><p>缺点：在 <b>稀疏图</b> 中会浪费大量的存储空间。（稀疏图：有联点远小于矩阵所能表示的点数，即矩阵中非 0 点数占矩阵的比例）</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">ArrayGraph</span> <span class=\"c1\">// 数组表示无向表\n</span><span class=\"c1\"></span><span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">graph</span><span class=\"o\">;</span> <span class=\"c1\">// 矩阵表\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"nf\">ArrayGraph</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">)</span> <span class=\"c1\">// N 代表顶点数\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">][</span><span class=\"n\">n</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">)</span> <span class=\"c1\">// a,b 代表关联的两个顶点\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">][</span><span class=\"n\">b</span><span class=\"o\">]=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">][</span><span class=\"n\">a</span><span class=\"o\">]=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>邻接表法</b>。通过 <b>链表</b> 存储每一个顶点的 <b>出度</b> 信息。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e7904095e457cfc472326dad9e577c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"732\" class=\"origin_image zh-lightbox-thumb\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-6e7904095e457cfc472326dad9e577c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;819&#39; height=&#39;732&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"732\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-6e7904095e457cfc472326dad9e577c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e7904095e457cfc472326dad9e577c0_b.jpg\"/></figure><p> 优点，对于 <b>稀疏图</b> 减少了空间消耗。</p><p>缺点，对于 <b>浓密图</b> 数据的访问更慢。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">ListGrapg</span><span class=\"o\">{</span> <span class=\"c1\">// 邻接表法表示图\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;[]</span> <span class=\"n\">graph</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">ListGrapg</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">){</span> <span class=\"c1\">// n 代表图的顶点数\n</span><span class=\"c1\"></span>        <span class=\"n\">graph</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">[</span><span class=\"n\">n</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">n</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">addLink</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"o\">){</span> <span class=\"c1\">// a,b 代表无向表顶点\n</span><span class=\"c1\"></span>        <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">a</span><span class=\"o\">].</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">);</span>\n        <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">b</span><span class=\"o\">].</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> \n<span class=\"o\">}</span></code></pre></div><h2>图的搜索</h2><h2>广度优先遍历 BSF</h2><p><b>广度优先遍历</b> （Breath-First-Search）是图的搜索中最常用的遍历方式之一，常用于 <b>求最短路径</b>。 </p><p> 思路： 把图中的任意顶点看做一棵独立的「树」，顶点直接关联的顶点就是树的第二层，以此类推。在查找顶点与另一顶点的最短路劲其实就是从树的根节点依序向下遍历。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">bfs</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">source</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"c1\">// source 为搜索源， target 为搜索目标\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"o\">;</span> <span class=\"c1\">// 若查找源即为查找目标则直接返回\n</span><span class=\"c1\"></span>        <span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">visted</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span> <span class=\"c1\">// visted 数组表示当前层是否遍历，若已遍历则设置为 true\n</span><span class=\"c1\"></span>        <span class=\"n\">visted</span><span class=\"o\">[</span><span class=\"n\">source</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;&gt;();</span> <span class=\"c1\">// 定义一个数据类型为整数的链表队列，将每次遍历的层加入队列\n</span><span class=\"c1\"></span>        <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">);</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span> <span class=\"c1\">// 定义数组存储遍历的顶点\n</span><span class=\"c1\"></span>        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span> <span class=\"c1\">// 将数组 pre 全部初始化为 -1\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">dot</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()!=</span><span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">dot</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span> <span class=\"c1\">// 返回队列首顶点 \n</span><span class=\"c1\"></span>            <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">dot</span><span class=\"o\">].</span><span class=\"na\">size</span><span class=\"o\">();</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"o\">{</span>\n                <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">dot</span><span class=\"o\">].</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span> <span class=\"c1\">// temp 为每一次遍历的顶点\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">visted</span><span class=\"o\">[</span><span class=\"n\">temp</span><span class=\"o\">])</span> <span class=\"c1\">// 若该顶点已遍历过则跳过\n</span><span class=\"c1\"></span>                    <span class=\"k\">continue</span><span class=\"o\">;</span>\n                <span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"o\">;</span>\n                <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">temp</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"o\">)</span>\n                <span class=\"o\">{</span>\n                    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">+</span><span class=\"s\">&#34;-&gt;&#34;</span><span class=\"o\">);</span>\n                    <span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">);</span> <span class=\"c1\">// 打印深度遍历的路径\n</span><span class=\"c1\"></span>                    <span class=\"k\">return</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"n\">index</span><span class=\"o\">++;</span>\n                <span class=\"n\">visted</span><span class=\"o\">[</span><span class=\"n\">temp</span><span class=\"o\">]=</span><span class=\"kc\">true</span><span class=\"o\">;</span>\n                <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">temp</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">print</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]!=</span><span class=\"n\">target</span><span class=\"o\">)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]+</span><span class=\"s\">&#34;-&gt;&#34;</span><span class=\"o\">);</span>\n            <span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">else</span><span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><h2>深度优先遍历 DFS</h2><p><b>深度遍历</b>（Deep-First-Search）。先按照一定顺序向下遍历，若一条路径遍历结束尚未找到，则返回上一分叉点继续遍历下一条路径，知道找到对应目标，结束遍历。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">dfs</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">source</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> \n    <span class=\"o\">{</span>\n        <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"kc\">false</span> <span class=\"o\">;</span> <span class=\"c1\">// 将查找结果重置回 false\n</span><span class=\"c1\"></span>        <span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">visted</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span> <span class=\"c1\">// 验证该顶点是够已被访问\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">graph</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">fill</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"n\">recurDfs</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">,</span><span class=\"n\">target</span><span class=\"o\">,</span><span class=\"n\">visted</span><span class=\"o\">,</span><span class=\"n\">pre</span><span class=\"o\">,</span><span class=\"n\">0</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">+</span><span class=\"s\">&#34;-&gt;&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">print</span><span class=\"o\">(</span><span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">recurDfs</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">source</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">,</span><span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">visted</span><span class=\"o\">,</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">pre</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"c1\">// 回溯法实现深度遍历\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">source</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"o\">)</span>\n            <span class=\"o\">{</span>\n                <span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]=</span><span class=\"n\">source</span><span class=\"o\">;</span>\n                <span class=\"k\">return</span> <span class=\"o\">;</span> <span class=\"c1\">// 找到对应目标返回\n</span><span class=\"c1\"></span>            <span class=\"o\">}</span>\n        <span class=\"n\">visted</span><span class=\"o\">[</span><span class=\"n\">source</span><span class=\"o\">]=</span><span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">source</span><span class=\"o\">].</span><span class=\"na\">size</span><span class=\"o\">();</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">graph</span><span class=\"o\">[</span><span class=\"n\">source</span><span class=\"o\">].</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n            <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">visted</span><span class=\"o\">[</span><span class=\"n\">temp</span><span class=\"o\">])</span>\n                <span class=\"k\">continue</span><span class=\"o\">;</span>\n            <span class=\"n\">pre</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]=</span><span class=\"n\">temp</span><span class=\"o\">;</span>\n            <span class=\"n\">index</span><span class=\"o\">++;</span>\n            <span class=\"n\">recurDfs</span><span class=\"o\">(</span><span class=\"n\">temp</span><span class=\"o\">,</span> <span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">visted</span><span class=\"o\">,</span> <span class=\"n\">pre</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>总结，<b>深度遍历 </b>像俗话说的「一条道走到黑」，只要路还能往下走就会一直向下遍历，直到撞了南墙才会回头。（文章中出现错误，可以直接在评论中指出）</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "图论", 
                    "tagLink": "https://api.zhihu.com/topics/19582618"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "中二喵叔", 
                    "userLink": "https://www.zhihu.com/people/aad67ae92611e51be830a2376e4f76c6", 
                    "content": "简单明了，谢谢", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61646806", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第二十二周", 
            "content": "<h2>左耳听风 第二十二周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）</blockquote><h2>Algorithm</h2><p>针对「堆」的知识点进行了一些练习，两道题都可以用 Top K 思路解答，即建立一个大小为 K 的小顶堆，根据数据的增加对堆数据进行更新。</p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-9909fa1f650efed8f9e8c7f5506906a2_ipico.jpg\" data-image-width=\"383\" data-image-height=\"383\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hackhu2019/LeetCode</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40bretcameron/12-javascript-tricks-you-wont-find-in-most-tutorials-a9c9331f169d\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">12 JavaScript Tricks You Won’t Find in Most Tutorials</a></p><p>「无法在大多数教程中找到的 12 个 JavaScript 技巧」。</p><p>文章主要描述作者在实践中发现的 12 个 JavaScript  编程技巧，让自己的代码变得更简洁高效。</p><p>因为 JavaScript  是一门动态语言，对数据的要求并不严谨，所以有一些静态语言所没有的技巧。</p><p>例如 23.9|0 实际上就是快速去除了浮点数的尾数，即将浮点型转换成了整型。</p><p>还有快速将数值类型转换成字符串类型的 num =19+&#34;&#34;; 通过 + 号运算符重载，num变成了字符串 &#34;19&#34;。</p><p>直接通过算术运算比通过方法强制转换更为高效，作者在文中还介绍了其他的实用技巧感兴趣可以完整的浏览一遍。</p><h2>Tip</h2><p>一个关于 HTML5 JavaScript  脚本引入的技巧，以前网页加载以前执行某些脚本或是 JavaScript 操作页面元素，我们需要把脚本放在 body 标签的末尾（网页代码的执行顺序是从上到下）。</p><p>HTML5 以前写法</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"o\">&lt;</span><span class=\"nt\">body</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nt\">div</span> <span class=\"nt\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;test&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">test</span><span class=\"o\">&lt;/</span><span class=\"nt\">div</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nt\">script</span><span class=\"o\">&gt;</span>\n    <span class=\"nt\">document</span><span class=\"p\">.</span><span class=\"nc\">getElementById</span><span class=\"o\">(</span><span class=\"s2\">&#34;test&#34;</span><span class=\"o\">)</span><span class=\"p\">.</span><span class=\"nc\">style</span><span class=\"p\">.</span><span class=\"nc\">color</span><span class=\"o\">=</span><span class=\"s2\">&#34;blue&#34;</span><span class=\"o\">;</span> <span class=\"o\">//</span> <span class=\"nt\">将</span> <span class=\"nt\">test</span> <span class=\"nt\">设置成蓝色</span>\n    <span class=\"o\">&lt;</span><span class=\"nt\">script</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&lt;/</span><span class=\"nt\">body</span><span class=\"o\">&gt;</span></code></pre></div><p>HTML5 新增 defer 属性，<code>&lt;script defer&gt;</code>会让脚本在网页元素全部加载后执行，将 JavaScript  和 HTML代码分开写更为清晰（外部引入脚本也可以使用 defer 属性）。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"o\">&lt;</span><span class=\"nt\">head</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&lt;</span><span class=\"nt\">script</span> <span class=\"nt\">defer</span><span class=\"o\">&gt;</span>\n    <span class=\"nt\">document</span><span class=\"p\">.</span><span class=\"nc\">getElementById</span><span class=\"o\">(</span><span class=\"s2\">&#34;test&#34;</span><span class=\"o\">)</span><span class=\"p\">.</span><span class=\"nc\">style</span><span class=\"p\">.</span><span class=\"nc\">color</span><span class=\"o\">=</span><span class=\"s2\">&#34;blue&#34;</span><span class=\"o\">;</span> <span class=\"o\">//</span> <span class=\"nt\">将</span> <span class=\"nt\">test</span> <span class=\"nt\">设置成蓝色</span>\n<span class=\"o\">&lt;</span><span class=\"nt\">script</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&lt;/</span><span class=\"nt\">head</span><span class=\"o\">&gt;</span>\n<span class=\"o\">&lt;</span><span class=\"nt\">body</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nt\">div</span> <span class=\"nt\">id</span><span class=\"o\">=</span><span class=\"s2\">&#34;test&#34;</span><span class=\"o\">&gt;</span><span class=\"nt\">test</span><span class=\"o\">&lt;/</span><span class=\"nt\">div</span><span class=\"o\">&gt;</span>\n\n<span class=\"o\">&lt;/</span><span class=\"nt\">body</span><span class=\"o\">&gt;</span></code></pre></div><h2>share</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/share\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">简单入门「堆」</a></p><p>对于二叉堆进行了一个简单的入门，堆的重点在于掌握堆化，针对不同的应用场景选择不同的堆化。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60978085", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第二十一周", 
            "content": "<h2>左耳听风 第二十周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）<br/> </blockquote><h2>Algorithm</h2><p>针对「二叉树」的知识点进行了一些练习</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode.217.%25E5%2590%2588%25E5%25B9%25B6%25E4%25BA%258C%25E5%258F%2589%25E6%25A0%2591.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode.217.合并二叉树</a> </p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/hackhu2019/LeetCode/blob/master/LeetCode.783.%2520%25E4%25BA%258C%25E5%258F%2589%25E6%2590%259C%25E7%25B4%25A2%25E6%25A0%2591%25E7%25BB%2593%25E7%2582%25B9%25E6%259C%2580%25E5%25B0%258F%25E8%25B7%259D%25E7%25A6%25BB.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode.783. 二叉搜索树结点最小距离</a></p><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40matteozago/why-the-web-3-0-matters-and-you-should-know-about-it-a5851d63c949\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why the Web 3.0 Matters and you should know about it</a></p><p>「为什么 Web 3.0 如此重要，你应当知道它。」。 作者分享了 Web3.0 的重大改变</p><p>首先是在<b>隐私</b>方面的重大改变，网络的加密，会减少各大网络公司对于个人信息的获取。Web 2.0 时代在带来丰富的交互内容的同时，将我们的个人信息不加密的在网络传输，在 3.0 时代都将通过区块链等技术解决这个问题。</p><p>基于分布式技术的发展，<b>数据中心的形式将不再存在</b>，没有人能够控制整个网络的信息。</p><p><b>数据所有权的更改</b>。数据所有权将属于用户，并根据所需要的个人服务选择性开放自己的信息。</p><p>跨平台能力明显。3.0 时代不再受限于操作系统，网页开发的应用在具备同原生 App 流畅体验的同时，可以供多个终端使用（手机、电脑、TV等）。C\\S（客户端到服务端） 模式将逐渐被 B\\S（浏览器\\服务器）所取代。</p><p>总结，前端大统一趋势在 3.0 时代势不可挡。区块链、分布式服务在与 Web 结合后将完善 2.0 时代的隐私问题，会得到显著的改善。正如作者在文中所提到的：</p><blockquote> The wheels have already been set in motion and the train has left the station. Web 3.0 is an revolution in motion, we are past the point of no return.<br/> </blockquote><p>车轮已经启动，火车离开了站台。Web 3.0 是一场革命，我们已无回头路。（个人理解：新的技术的发展是必然的，我们作为见证者所能做的，就是早一点了解并推动它的发展。）</p><h2>Tip</h2><p>把上周 review <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40bretcameron/parallax-images-sticky-footers-and-more-8-useful-css-tricks-eef12418f676\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">文章</a>中的一个网页「视差图」技巧实践了一下</p><p><b>background-attachment</b> 可以将页面设置成 <b>滚动</b> /  <b>固定</b> 两种模式。这里设置为 <b>fixed</b> 固定模式，网页在滚动时图片始终展示在固定位置，在上下浏览时就形成了一个视差图。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"nt\">body</span> <span class=\"p\">{</span>\n    <span class=\"k\">height</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"kt\">vh</span><span class=\"p\">;</span>  <span class=\"c\">/* vh 视口单位，让网页可以完整显示所有元素  */</span>\n<span class=\"p\">}</span>\n<span class=\"nt\">img</span><span class=\"p\">{</span>\n <span class=\"k\">background-size</span><span class=\"p\">:</span> <span class=\"kc\">cover</span><span class=\"p\">;</span> <span class=\"c\">/* 背景全覆盖网页  */</span>\n <span class=\"k\">background-attachment</span><span class=\"p\">:</span> <span class=\"kc\">fixed</span><span class=\"p\">;</span> <span class=\"c\">/* 背景固定 */</span>\n <span class=\"k\">height</span><span class=\"p\">:</span> <span class=\"mi\">100</span><span class=\"kt\">%</span><span class=\"p\">;</span> <span class=\"c\">/* 百分百显示  */</span>\n <span class=\"p\">}</span></code></pre></div><a href=\"https://link.zhihu.com/?target=https%3A//codepen.io/BretCameron/pen/JzjNXp\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-717192032bde46fa77efdf0cf2660780_180x120.jpg\" data-image-width=\"1280\" data-image-height=\"720\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Simple Parallax Image</a><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/60962760\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-56cc8a0caa3489826655e40aafcc77b8_180x120.jpg\" data-image-width=\"4096\" data-image-height=\"2775\" class=\"internal\">胡sir：简单入门二叉树</a><p>对于二叉树进行了一个简单入门，分析了二叉树的实现机制，以及基础的三种遍历（前序、中序、后序）。</p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60962760", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 2, 
            "title": "简单入门二叉树", 
            "content": "<h2> 数据结构中的树是什么？ </h2><p>「<b>树</b>」（Tree）是计算机数据存储的一种结构，因为存储类型和现实生活中的树类似所以被称为树。</p><p>树的源头被称为「<b>根</b>」，树其余分叉点被称为「<b>节点</b>」，而树这种数据结构的起始分叉点被称为「<b>根节点</b>」。树衍生的尽头就是叶，在树这种数据结构中把叶称之为「<b>叶节点</b>」。</p><p>树中每一节点的起源点被称为「<b>父节点</b>」，衍生出去的点被称为「<b>子节点</b>」。没有父节点的就是「<b>根节点</b>」，没有子节点的就是「<b>叶节点</b>」，而同一父节点的就是「<b>兄弟节点</b>」。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8fa39b194b664f2f2c67289aa9e9f85d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"580\" data-original=\"https://pic2.zhimg.com/v2-8fa39b194b664f2f2c67289aa9e9f85d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;580&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"580\" data-original=\"https://pic2.zhimg.com/v2-8fa39b194b664f2f2c67289aa9e9f85d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8fa39b194b664f2f2c67289aa9e9f85d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>「树」的基础概念</h2><p>高度，是从下往上看，用来表示 <b>从根节点到最顶端叶节点所需要遍历的节点数 （包括叶节点）</b>。</p><p>深度与高度相反，是从上往下看，用来表示 <b>从最顶端叶节点到根节点所需要遍历的节点数（包括根节点）</b>。</p><p>层数，即 <b>高度 +1</b>。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b415607a17642814742792708da209c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"582\" data-original=\"https://pic2.zhimg.com/v2-b415607a17642814742792708da209c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"582\" data-original=\"https://pic2.zhimg.com/v2-b415607a17642814742792708da209c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b415607a17642814742792708da209c1_b.jpg\"/></figure><p><b>二叉树</b>，是最常用的树形结构，<b>每个结点最多能够有两个子节点</b>。</p><p><b>完全二叉树</b>，所有的叶节点都分布在最高的两层，除最高层其余层的子节点数都达到最大，且所有叶节点都在左边。</p><p><b>满二叉树</b>，除了叶节点，每一个节点都有两个子节点。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eab1fc6114dcd9f0783d4a4b74a0a81b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"707\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-eab1fc6114dcd9f0783d4a4b74a0a81b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;707&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"707\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-eab1fc6114dcd9f0783d4a4b74a0a81b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eab1fc6114dcd9f0783d4a4b74a0a81b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二叉查找树</b>，所有的左节点值都小于父节点值，所有的右节点值都大于父节点值。</p><h2>二叉树的实现</h2><p>二叉树的最终实现有基于数组和基于链表两种形式。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-acc49afb33901383723a1d02dacd6b78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"601\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"601\" data-original=\"https://pic1.zhimg.com/v2-acc49afb33901383723a1d02dacd6b78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;601&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"601\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"601\" data-original=\"https://pic1.zhimg.com/v2-acc49afb33901383723a1d02dacd6b78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-acc49afb33901383723a1d02dacd6b78_b.jpg\"/></figure><p><b>数组存储</b> 数组表示二叉树，通过浪费索引为 0 的地址，使得所有的 <b>左节点</b> 的索引都变成了 2<i>i （i 为节点的<b>高度</b>），所有的 <b>右节点</b> 的索引都变成了 2</i>i +1。</p><p><b>优点</b>   - 可以通过下标随机访问某已知高度的节点。  - 节省了存储指向子节点地址的指针所需要的空间。</p><p><b>缺点</b></p><ul><li>表示非完全二叉树时要浪费一定的空间。 </li><li>二叉树的扩容操作时间复杂度为 O(n)，要对数组的数据进行搬运。</li></ul><p><b>适用场景</b>：数据存储量小，访问量大，插入删除操作少。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">char</span><span class=\"o\">[]</span> <span class=\"n\">binaryTree</span> <span class=\"o\">=</span> <span class=\"o\">{</span> <span class=\"sc\">&#39; &#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;A&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;B&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;C&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;D&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;E&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;F&#39;</span><span class=\"o\">,</span> <span class=\"sc\">&#39;G&#39;</span> <span class=\"o\">};</span> <span class=\"o\">//</span> <span class=\"n\">数组形式二叉树存储图中数据</span></code></pre></div><p><b>链表存储</b> 在链式存储中更直观的反映了左右节点与父节点的关系。</p><p><b>优点</b>  - 扩容方便  - 插入、删除操作的时间复杂度都是 O(logn) （与 <b>二分查找法</b> 一致）</p><p>缺点</p><ul><li>访问数据的时间复杂度相对数组存储要高，时间复杂度为 O(logn) （与 <b>二分查找法</b> 一致）</li></ul><p><b>适用场景</b>：存储数据量大，插入删除频繁，数据读取操作较少。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span> <span class=\"n\">left</span><span class=\"o\">;</span> <span class=\"c1\">// 左节点\n</span><span class=\"c1\"></span>    <span class=\"n\">Node</span> <span class=\"n\">right</span><span class=\"o\">;</span> <span class=\"c1\">// 右节点\n</span><span class=\"c1\"></span>    <span class=\"kt\">char</span> <span class=\"n\">data</span><span class=\"o\">;</span> <span class=\"c1\">// 存储的数据\n</span><span class=\"c1\"></span>\n    <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">Node</span> <span class=\"n\">right</span><span class=\"o\">,</span> <span class=\"kt\">char</span> <span class=\"n\">data</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 节点初始化时指明子节点与数据\n</span><span class=\"c1\"></span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">char</span> <span class=\"nf\">getData</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">data</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setData</span><span class=\"o\">(</span><span class=\"kt\">char</span> <span class=\"n\">data</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Node</span> <span class=\"nf\">getLeft</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setLeft</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">left</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">left</span> <span class=\"o\">=</span> <span class=\"n\">left</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Node</span> <span class=\"nf\">getRight</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setRight</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">right</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">right</span> <span class=\"o\">=</span> <span class=\"n\">right</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n        <span class=\"n\">Node</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span><span class=\"kc\">null</span><span class=\"o\">,</span><span class=\"sc\">&#39;G&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"sc\">&#39;F&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"sc\">&#39;D&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"sc\">&#39;E&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">f</span><span class=\"o\">,</span> <span class=\"n\">g</span><span class=\"o\">,</span> <span class=\"sc\">&#39;C&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">d</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"sc\">&#39;B&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">Node</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"sc\">&#39;A&#39;</span><span class=\"o\">);</span>\n        <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">inPrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">);</span></code></pre></div><h2>二叉树的遍历</h2><p>此处代码参考了王争老师在极客时间的专栏 <b>《<a href=\"https://link.zhihu.com/?target=https%3A//time.geekbang.org/column/intro/126\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据结构与算法之美</a>》</b> 中的伪代码</p><h2>前序遍历</h2><blockquote> 对任意二叉树树结构，先打印节点本身，再打印左子节点，最后打印右子结点。即：中、左、右。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">prePrint</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">getData</span><span class=\"o\">());</span>\n        <span class=\"n\">prePrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n        <span class=\"n\">prePrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span></code></pre></div><p>输出结果： A B D E C F G</p><h2>中序遍历</h2><blockquote> 对任意二叉树树结构，先打印左子节点，再打印节点本身，最后打印右子结点。即：左、中、右。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">inPrint</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">root</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"n\">inPrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">getData</span><span class=\"o\">());</span>\n        <span class=\"n\">inPrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span></code></pre></div><p>输出结果： D B E A F C G</p><h2>后序遍历</h2><blockquote> 对任意二叉树树结构，先打印左子节点，再打印右子节点，最后打印结点本身。即：左、右、中。<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">nextPrint</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">root</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">root</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"o\">;</span> <span class=\"c1\">// 递归终止\n</span><span class=\"c1\"></span>        <span class=\"n\">nextPrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">left</span><span class=\"o\">);</span>\n        <span class=\"n\">nextPrint</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">right</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"na\">getData</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span></code></pre></div><p>输出结果： D E B F G C A 以上是「二叉树」学习所需要掌握的一些基本知识，核心在于二叉树的遍历，将 3 种遍历多些几遍可以提高自己对于二叉树的理解，文章中有任何问题，都可以在留言中指出。</p>", 
            "topic": [
                {
                    "tag": "二叉树", 
                    "tagLink": "https://api.zhihu.com/topics/19698867"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "leacoder", 
                    "userLink": "https://www.zhihu.com/people/b5394a59027b05124e89b96d8d0eeb68", 
                    "content": "<p>你下一篇文章可以介绍下 DFS（深度优先搜索）和 BFS(广度优先搜索) ，Leetcode  102 这道题可以用DFS和 BFS解</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "胡sir", 
                            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                            "content": "<p>嗯，中间还有堆和图，后面学到这一块会写出自己的理解。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "leacoder"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60241263", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 4, 
            "title": "左耳听风 第二十周", 
            "content": "<h2>左耳听风 第二十周</h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS） </blockquote><h2>Algorithm</h2><p>针对「散列表」的知识点进行了一些练习</p><a href=\"https://zhuanlan.zhihu.com/p/60233941\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode-500-键盘行</a><a href=\"https://zhuanlan.zhihu.com/p/60233999\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode.451-根据字符出现频率排序</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40bretcameron/parallax-images-sticky-footers-and-more-8-useful-css-tricks-eef12418f676\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">8 useful CSS tricks: Parallax images, sticky footers and more</a></p><p>「 8 个有效的 CSS 的技巧 ：视差图、粘性页脚等」。 作者分享了自己 8 个很有技巧性的 CSS 代码，其中最有意思的就是 <b>一行代码</b> 生成夜间模式。在 body 的 CSS 样式中加上这一句话就可以实现 <b>夜间模式</b> 实际上 <b>filter</b> 是 CSS3 的 <b>滤镜</b> 属性，invert（1）就是将 黑色转换为白色、白色转换为灰色，hue-rotate (210deg) 设置的色相，使得夜间模式看起来更舒适。</p><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"nt\">filter</span><span class=\"o\">:</span> <span class=\"nt\">invert</span><span class=\"o\">(</span><span class=\"nt\">1</span><span class=\"o\">)</span> <span class=\"nt\">hue-rotate</span><span class=\"o\">(</span><span class=\"nt\">210deg</span><span class=\"o\">);</span></code></pre></div><h2>Tip</h2><p>MySQL 修改外键。通常外键的设置会放在所有表建立之后，这样就需要对表进行修改</p><div class=\"highlight\"><pre><code class=\"language-mysql\"><span class=\"k\">ALTER</span> <span class=\"k\">TABLE</span> <span class=\"n\">uteacher</span> <span class=\"k\">ADD</span> <span class=\"k\">CONSTRAINT</span> <span class=\"n\">did</span> <span class=\"k\">FOREIGN</span> <span class=\"k\">KEY</span> <span class=\"p\">(</span><span class=\"n\">udept_did</span><span class=\"p\">)</span> <span class=\"k\">REFERENCES</span> <span class=\"nf\">udept</span><span class=\"p\">(</span><span class=\"n\">did</span><span class=\"p\">);</span> \n<span class=\"o\">//</span> <span class=\"err\">设置了</span> <span class=\"n\">uteacher</span> <span class=\"err\">表中</span> <span class=\"n\">did</span> <span class=\"err\">的参照为</span> <span class=\"n\">udept</span> <span class=\"err\">的主键</span> <span class=\"n\">did</span></code></pre></div><p>体验了 SQL 和 MySQL ，感觉 MySQL + SQLyog 配合使用更适合新手，SQLyog 给 MySQL 加上了图形化界面虽然美化程度不如 SQL 但是在 SQLyog 提供了 SQL 语句自动补全以及历史命令查看，对比感觉后者更适合入门和长期学习。</p><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/60241324\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-4acb887a6240279c85ce9d43b7edd987_180x120.jpg\" data-image-width=\"900\" data-image-height=\"383\" class=\"internal\">胡sir：简单了解哈希表</a><p>对于哈希表进行了一个简单入门，散列表（哈希表）的核心在于散列函数，而散列表的存储方式的选择实际上对应的是数组和链表的优势。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": [
                {
                    "userName": "海滨", 
                    "userLink": "https://www.zhihu.com/people/a021f1525c359362fa419bed26a15fd3", 
                    "content": "你的排版格式很赞[赞]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "胡sir", 
                    "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
                    "content": "MarkDown 排版的", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60241324", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 7, 
            "title": "简单了解哈希表", 
            "content": "<h2>什么是哈希表  </h2><p><b>哈希表</b> 是 <b>Hash Table</b> 一词的中文翻译，算法书里通常称这种数据结构为「散列表」。之所以称之为 <b>散列表</b> 和这种数据结构的存储方式有关，每个按序进入的数据经过 <b>散列函数</b> 的计算后会无序的分布在哈希表不同的位置，这是与数组、链表等有序结构所不同的。</p><p><b><i>哈希表实际上是数组的一种扩展</i></b>。在哈希表中通过 <b>哈希函数</b> 我们可以将数字、字符串等数据中比较有代表性的数据作为 <b>键值</b> 转换成数组的 <b>索引</b>，在数组中存储 <b>键值</b> 代表的数据。而通过 <b>哈希函数</b> 转化的数组索引我们称之为 <b>散列值</b>（也称哈希值），键值与哈希值转换的过程我们称之为 <b>散列函数</b>（即 <b>哈希函数</b>）。</p><p><b>哈希表的优点</b></p><ul><li>可以像数组一样通过下标随机访问。</li><li>弥补了数组只能通过整数索引访问的缺陷。</li></ul><p><b>哈希表的缺点</b></p><ul><li>每次存取数据之前要通过散列函数计算对应的散列值，消耗了更多内存。</li></ul><p><b>装载因子</b> 是散列表性能的衡量标准之一。因为散列表实际上还是数组，所以能承载的数据是有限的，当哈希表存储的数据超过数组索引的长度时则必然会出现散列冲突。</p><p>装载因子的计算公式：</p><blockquote> 装载因子 = 散列表元素个数 / 散列表长度。<br/> </blockquote><p>通常，当装载因子大于 0.75 时，我们需要扩容我们的散列表重新计算散列值。</p><h2>应用场景</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a5a40b31daba5da85c5a5d0ce851539b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-a5a40b31daba5da85c5a5d0ce851539b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-a5a40b31daba5da85c5a5d0ce851539b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a5a40b31daba5da85c5a5d0ce851539b_b.jpg\"/></figure><p><b>在 13 亿人中，公安系统快速的查找某一身份证（通常为 18 位数字）信息</b> 可以通过哈希表的来处理。首先根据身份证的前 6 位找到对应的省份区县信息（可以是哈希表，可以是数组），再根据剩下 13 位信息制作哈希表，合理的选定计算散列值的数，可以以身份证后 8 位来生成（前 8 位出生日期容易重复易形成 <b>散列冲突</b>）散列值。因为身份证是整数形式的（X 代表 10），我们假设 1 个区县的人数在 100 万人以内则 100 万对应的就是散列表的长度。散列函数我们可以用身份证后 8 位除以 100 0000 来生成对应的索引，而散列表中可以存放指向公民身份信息的指针。</p><p>而查找每一个身份证号所对应的信息时只要将输入身份证号就可以通过下标在散列表中快速找到公民信息。</p><p>在这个案例中采用的就是常见的散列函数生成法 <b>除留余数法</b>。常用于整数类型的键值生成特定的散列值。</p><p>参考代码（划区县因代码长度没有写出）</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">import</span> <span class=\"nn\">java.util.*</span><span class=\"o\">;</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Test</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">HashTest</span> <span class=\"n\">people</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashTest</span><span class=\"o\">();</span>\n\n        <span class=\"n\">Scanner</span> <span class=\"n\">in</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Scanner</span><span class=\"o\">(</span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">in</span><span class=\"o\">);</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">3</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"c1\">// 输入个人信息,3 个测试数据\n</span><span class=\"c1\"></span>        <span class=\"o\">{</span>\n            <span class=\"n\">String</span> <span class=\"n\">identity</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n            <span class=\"n\">String</span> <span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n            <span class=\"kt\">int</span> <span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">parseInt</span><span class=\"o\">(</span><span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">());</span>\n            <span class=\"n\">ChinesePerson</span> <span class=\"n\">person</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ChinesePerson</span><span class=\"o\">(</span><span class=\"n\">identity</span><span class=\"o\">,</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">age</span><span class=\"o\">);</span>\n            <span class=\"n\">people</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">identity</span><span class=\"o\">,</span> <span class=\"n\">person</span><span class=\"o\">);</span><span class=\"c1\">// 以身份证为键，person 类为值\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;输入你想要查找的身份证号： &#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">String</span> <span class=\"n\">id</span> <span class=\"o\">=</span><span class=\"n\">in</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">();</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">people</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">false</span><span class=\"o\">)</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;你要查找的信息不存在&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">ChinesePerson</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">people</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">);</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span>\n                    <span class=\"s\">&#34;查找成功，&#34;</span> <span class=\"o\">+</span> <span class=\"s\">&#34;居民身份证为：&#34;</span> <span class=\"o\">+</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">getIdCard</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34;，姓名为：&#34;</span> <span class=\"o\">+</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">getName</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34;，年龄为：&#34;</span> <span class=\"o\">+</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">getAge</span><span class=\"o\">());</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">HashTest</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">ChinesePerson</span><span class=\"o\">[]</span> <span class=\"n\">hashTable</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">HashTest</span><span class=\"o\">()</span> <span class=\"c1\">// 初始化散列表\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"n\">hashTable</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ChinesePerson</span><span class=\"o\">[</span><span class=\"n\">10000</span><span class=\"o\">];</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">HashCode</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">identity</span><span class=\"o\">)</span> <span class=\"c1\">// 散列函数，除留余数法\n</span><span class=\"c1\"></span>     <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">valueOf</span><span class=\"o\">(</span><span class=\"n\">identity</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">9</span><span class=\"o\">,</span> <span class=\"n\">17</span><span class=\"o\">))</span> <span class=\"o\">/</span> <span class=\"n\">10000</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">identity</span><span class=\"o\">,</span> <span class=\"n\">ChinesePerson</span> <span class=\"n\">person</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 增加键和值，测试案例不做溢出判断\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">HashCode</span><span class=\"o\">(</span><span class=\"n\">identity</span><span class=\"o\">);</span>\n        <span class=\"n\">hashTable</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">person</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsKey</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 判断键值是否存在\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">HashCode</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">index</span> <span class=\"o\">&gt;=</span> <span class=\"n\">10000</span> <span class=\"o\">||</span> <span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">hashTable</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">ChinesePerson</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// 获取键对应的值\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">containsKey</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">false</span><span class=\"o\">)</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">();</span> <span class=\"c1\">// 若不存在则抛出异常\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">hashTable</span><span class=\"o\">[</span><span class=\"n\">HashCode</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">size</span><span class=\"o\">()</span> <span class=\"o\">{</span> <span class=\"c1\">// 获取散列表对应的元素个数\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">ChinesePerson</span> <span class=\"o\">{</span> <span class=\"c1\">// 定义类存储身份信息\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">idCard</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ChinesePerson</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">identity</span><span class=\"o\">,</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">idCard</span> <span class=\"o\">=</span> <span class=\"n\">identity</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">=</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getIdCard</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">idCard</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setIdCard</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">identity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">idCard</span> <span class=\"o\">=</span> <span class=\"n\">identity</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">getName</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setName</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getAge</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">age</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setAge</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">age</span> <span class=\"o\">=</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>对于非整数类型的键值，通常将其转换成大整数，再采用整数的除留余数法。</b></p><h2>Java 中的散列函数设计原则</h2><ul><li><b>键值生成的散列值必须为非负整数</b></li></ul><p>因为散列值实际为数组的索引所以必须为非负整数</p><ul><li><b>同一散列值对应相同的键值</b> <br/> </li><li><b>同一键值对应相同的散列值</b></li></ul><h2>散列表的冲突</h2><p>表现：<b>不同的键值生成了相同的散列值</b>。</p><p><b>产生的原因</b>：</p><ul><li>散列函数设计的不合理。 </li><li>散列表的容量有限</li></ul><p>解决方法：</p><blockquote> 对散列表扩容。在装载因子达到一定比例（通常设置为 0.75）时，对散列函数动态扩容，则对应的散列函数也应修改。 <br/>开放寻址法。当出现散列冲突时，新的数据放入散列表中空闲块。可以通过 <b>线性探测</b>（按顺序向后遍历空闲区）、<b>二次探测</b>、<b>双重散列</b> 等方法实现。<br/> 拉链法。以链表的形式存储冲突的散列表，散列表只记录指向链表的指针，链表中只存放冲突但不重复的元素。</blockquote>", 
            "topic": [
                {
                    "tag": "哈希函数", 
                    "tagLink": "https://api.zhihu.com/topics/19631819"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "小飞镖", 
                    "userLink": "https://www.zhihu.com/people/36d9ce7a5432780a56645809098be916", 
                    "content": "<p>首赞！</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59855966", 
            "userName": "终端研发部", 
            "userLink": "https://www.zhihu.com/people/0562ae57ba411b146099313075609e94", 
            "upvote": 24, 
            "title": "程序员接私活那些坑", 
            "content": "<h2>前言</h2><p>最近有很多人问我私活怎么样？有什么坑，我之前也是接了几个私活，当然也有稳定的收入。我们也来分享一下。前几天发现了一个帖子很不错，我们来分享一下</p><p>注：本文转自 : <a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/andylin02/article/details/3955935\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.csdn.net/andylin02</span><span class=\"invisible\">/article/details/3955935</span><span class=\"ellipsis\"></span></a></p><p>到网上看看，接私活是多么不容易，技术问题本身是个因素，还有很多有技术的人接私活时被骗，或者是合作到最后以失败告终，所以想请有经验的大侠们出来指点一下，接私活是怎么接的？一般流程怎样？要注意什么？签合同的风险？等等问题，希望高手能将宝贵的经验与大家共享阿?</p><p>最好是朋友或熟人推荐，这样双方都比较放心，项目也好拿一些，一般也不会欠款。 如果是陌生人就不好说了，即使签合同也没用。</p><p>还有就是接项目时，一定要了解对方是否有技术背景。<br/>如果有技术背景，一般的项目费用会比较合适，不会太高也不会太低，关键是需求定义会比较清楚，后期维护修改量不大。<br/>如果对方没有技术背景，就不好办了，即使能蒙对方要个比较高的价格，后期也会被无休止的需求变更累死的。</p><p>还有谈项目时一定要看对方的人品，夸夸其谈的人要敬而远之。</p><h2>程序员接活、新手接，需知：</h2><blockquote>1.接活前，先跟美工把报酬讲好，如果程序员和美编报酬一样的话，那就不要接.因为后期的活程序占绝大多数，而美编的任务比起程序，差的多.<br/>2.接活前,一定要先让,客户把需求写成书面形式,然后根据文本里要求的功能,估价,如果是整个站的话,那最好多要点,因为后期的修改相当烦人.要的少的话,修改起来没劲.<br/>如果客户不会写书面要求 的话,那就不要接了,因为这将是个无头活.<br/>3,做活之前,先跟客户说好了,文本里有的功能实现,后添加的功能不要做.(从书面文本发过来那天算起)<br/>4,跟客户说明,做完活,从结账那天起,就不要管了,除非客户愿意出维护费或者你自愿.<br/>(从客户审核通过,结账那时起,即使是后期客户发现bug,即使是最基本的bug也不要管,除非客户愿意出钱,维护,不要听他们什么,很好改了,就一下就完了,别忘了,改那么一点是要知识的,就一点你怎么不改,这是知识含量.,请不要糟贱自己辛苦学来的程序知识.)<br/>5,一般后期程序维护是需要资金的,如果客户不愿意出,或者认为程序是你写的就理应你来免费,维护,这叫扯蛋!你并没有答应他们程序写完后,就一辈子永远时刻准备为他们免费维护.一般每月维护费在500RMB左右,这点可以跟客户协商.<br/>6,程序和页面一定要分开,这样各做各的,分工明确,而且不易发生什么误会,最主要的是能提高做活效率.后期,美工改起来也不会影响到程序.<br/>7,做活的时间一般不要跟客户定死了,程序这东西,改来改去就会改出问题,需要化时间去修补的,如果你把时间定的很死,一旦发生变化,到时候完不成任务,到时候你一定死的很难看.<br/>8,做活前，先搞清楚客户说的报酬，是税前的还是税后的，有些所谓＇正式＇的单位到结账的时候会说＇要扣掉部分＇个人所得税＇.<br/>9,最好有自己的服务器，把做的活放到自己的服务器上，如果客户满意了，付清全部的钱再把代码给他们，这样避免了客户不发钱，活已经给人家了，自己弄的很被动的局面．切记！切记！<br/>以上只是我个人的几点接活经验,仅供参考</blockquote><p>===================================================================================================================</p><p>可以通过朋友介绍。<br/>也可以通过一些私活中介平台。</p><p>不过，无论什么方式，都要注意事先谈好需求，定好价格，谈好支付方式。有必要的，要收取部分订金。</p><p>对于一些不熟悉，没什么信任感的最好用中介支付。我一般是在淘宝上交易，先付款到支付宝，完成后放款。</p><h2>接网站私活，如何防骗？经验谈</h2><p>我接活很长时间了，被骗过几次，但是最近几乎没被骗过，把经验告诉你大家</p><p>一般接私活，都存在不信任对方，接活的朋友怕做了不给钱，客户怕给你钱了，怕你做不好， 所以我接私活，先做后给钱，比较好接，但是怎么防骗呢？</p><p>把一个网站分成几段，可以协商，比如把网站分为 三期，1、美工 2、后台 3美工和后台的结合每做完一期，客户满意给钱，但是如何防骗呢，</p><p>如果网站有后台那就好办，可以先做后台 ，后做美工，后台基本都有，所以几乎不用做什么，就是根据客户的网站设置改善一下后台，给客户看，客户满意后台给你钱，这样有个好处，后台本来你就有，就是客户不满意你也不损失什么，如果客户看后台满意给钱了，那他基本不是骗子，（记住一定要在网上让客户看后台，不要直接给他，他给你钱了，如果要后台你可以给他）</p><p>如果你要做的网站只有美工，那你要特别注意，一定要求做好网站图片 他们满意了就要付全款（至少要付一半的钱），如果他们不同意，你也不要做了，可能是骗子，不要相信如果不给钱就不是人的话，我就遇见过这样的人，到最后还是不给钱，所以我也不能把他当人看待了</p><p><b>你在做之前给客户说好，做好的网站图片 你要缩小 30% 给他看，（缩小30%图片再放大到原来的状太态将失真）如果他不同意 有一下几种可能</b></p><ul><li>1、他是骗子</li><li>2、他给你的活是转包的</li></ul><p>当您遇到二传单（也就是与您联系也是一家接单的公司或者个人），各位朋友在交涉时一定要当心，因为不是直接客户，二传单你所知晓的需求和分析往往并不是直接客户所想要的东西。遇到这种单 我一般是放弃</p><ul><li>3、这个网站他说话不算数，他可能有老板要让老板看。</li></ul><p>不管是什么情况只要他不同意把图片缩小给他看，那网站就不要做了，再想办法找其他项目</p><p>**还有在最后交付的时候一定要客户把钱给你了再给网站 **</p><h2>接私活项目一般有以下几个过程</h2><p>1、将客户需求调研清楚；</p><p>2、需求调研清楚之后，根据工作量、难度计划费用；</p><p>3、收取定金，一般为全部费用的20％～30％（定金一定要收，否则宁愿不接这个活）；</p><p>4、有的客户签合同，有的客户不签。签合同的占少数；</p><p>5、软件完工之后，加上试用期，再给客户；</p><p>6、付完全款之后，再给正式版；</p><p>7、要源码的，多加20％费用。</p><h2>总之，你需要注意的是</h2><p><b>核对项目</b></p><p>首先核对项目是否有技术难点，自己接过来技术实现是否有难度，比如即时通讯等，自己没有做过，怎么办。</p><p><b>如何评估工作量和报价</b></p><p>一般项目先按模块拆分，每个模块多少工作量，比如一个模块的工作量乘以日薪 工作量 * 日薪 + 紧急程度 = 项目报价。<br/>但是，你要是就这样发给客户了，那就太大意了，应该多加个项目波动期，比如再加个5天，10天的报酬。如果可以不同意的话，我们可以指定一个简单的excel表格，里面描述功能点和每个功能需要的工作量。这样客户就能大致明白了，也能理解。</p><p><b>收定金，收定金，收定金这个很重要。不再强调了。预付款拿20%-30%都是可以的</b></p><p><b>改需求必须的加钱，不然太对不起自己了，功能改来改去的，把自己累得够呛。</b></p><p><b>对于尾款问题。（大多数都收不到了，要有心理准备）</b></p><h2>总结</h2><p><b>最后</b>还要根据自己的时间安排，如果你时间不是特别充足，或者是需求老师变动的话，还是建议不要去碰这个私活，多去思考，向别人请教，有些看似貌似能挣不少钱，但其中隐藏着你意想不到的一些坑，这样，不如不去挣这个钱，努力提高自己，早晚财富就会渠道而成！</p><h2>阅读更多</h2><p><b><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3OTU0MzI4MQ%3D%3D%26mid%3D2247487390%26idx%3D1%26sn%3D7d1188d22d140c83e25d2127946aa51c%26chksm%3Deb476300dc30ea1652cdc99e21f4c588d8354db7be54f6d644d952be2f308898086ecb9e32d9%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用Flutter实现一个涂鸦和加水印功能</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3OTU0MzI4MQ%3D%3D%26mid%3D2247487389%26idx%3D1%26sn%3D4ecfaf1f693d817b4e35751d502cbbc4%26chksm%3Deb476303dc30ea157aa8d82fd0c7f56c25a021d75332266ef2c4450217d0c8296da3e2e37a41%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">2019 Android 高级面试题总结</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3OTU0MzI4MQ%3D%3D%26mid%3D2247487342%26idx%3D1%26sn%3D67808b64c27215a717584c2fca752448%26chksm%3Deb4763f0dc30eae6fa46911095fece661f1082a8fbd4f72d352d6a1858e7562a0243376caea5%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">再见，Python！你好，Go语言</a></b></p><p><b><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3OTU0MzI4MQ%3D%3D%26mid%3D2247487334%26idx%3D1%26sn%3D9fc18a6fabd348be6b2761f91706b772%26chksm%3Deb4763f8dc30eaee0daf361bc00dc70d38a7d235d436736c8ca3603a3682ef69a7e1bf071e48%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一个完整的 Web 请求到底发生了什么</a></b></p><h2>相信自己，没有做不到的，只有想不到的</h2><p>在这里获得的不仅仅是技术！</p><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "全栈工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19940527"
                }, 
                {
                    "tag": "前端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19573936"
                }
            ], 
            "comments": [
                {
                    "userName": "后端开发", 
                    "userLink": "https://www.zhihu.com/people/865377d985a7d10a61498f624ae0ace6", 
                    "content": "<p>JavaScript培训VIP精品课程 价值14800 现在只要3元即可下载 JavaScript培训VIP精品课程 价值14800  现在只要3元即可下载   <a href=\"http://link.zhihu.com/?target=http%3A//www.yushiwangzhe.cn/forum.php%3Fmod%3Dviewthread%26tid%3D602%26extra%3D\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">玉石王者IT社区网页前端编程学院 - Powered by 玉石王者!</a></p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "陈杰深", 
                    "userLink": "https://www.zhihu.com/people/d17665d9bf0beb5f685935f412166739", 
                    "content": "最好有自己的服务器，把做的活放到自己的服务器上，如果客户满意了，付清全部的钱再把代码给他们，这样避免了客户不发钱，活已经给人家了，自己弄的很被动的局面．切记！切记！", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59525528", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "左耳听风 第十九周", 
            "content": "<h2><b>﻿左耳听风 第十九周</b></h2><blockquote> 每周完成一个ARTS： 每周至少做一个 leetcode 的算法题、阅读并点评至少一篇英文技术文章、学习至少一个技术技巧、分享一篇有观点和思考的技术文章。（也就是 Algorithm、Review、Tip、Share 简称ARTS）<br/> </blockquote><h2>Algorithm</h2><p>针对「队列」的知识点进行了一些练习 </p><a href=\"https://zhuanlan.zhihu.com/p/59525262\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode.622. 设计循环队列</a><a href=\"https://zhuanlan.zhihu.com/p/59525325\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode 641. 设计循环双端队列</a><a href=\"https://zhuanlan.zhihu.com/p/59525386\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode 933. 最近的请求次数</a><a href=\"https://zhuanlan.zhihu.com/p/59525462\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3c1e81a8f6d20c491863ccf5989148f7_180x120.jpg\" data-image-width=\"500\" data-image-height=\"260\" class=\"internal\">胡sir：LeetCode 239. 滑动窗口最大值</a><h2>review</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/how-a-googler-solves-coding-problems-ec5d59e73ec5\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How a Googler solves coding problems</a></p><p>「 一个谷歌工作者如何解决一个编程问题」。 作者讲述了自己是如何系统的解决一个编程问题的：</p><p>1、Draw it。画出来。把编程的过程思考并画在纸上，先理清自己的思路。</p><p>2、Write it in English。用英语写出来。在国内应当是用中文写出来，将图中的步骤用更详细的文字描述，明确步骤。</p><blockquote> 伪代码：是用介于自然语言和计算机语言之间的文字和符号（包括数学符号）来描述算法。<br/> </blockquote><p>3、Write pseudocode.。写出伪代码（pseudocode）。伪代码并不是真实的代码，但是能够表现出编程逻辑。</p><p>4、Translate what you can to code.。翻译成你会的代码。根据伪代码用自己要使用的编程语言实现。</p><p>5、Don’t guess.。不要猜。实际上就是对代码进行测试，一段没有经过测试的代码，谁也不能保证它不会出错。实际上即使经过缜密的测试也不能保证不会出错，只能保证测试部分的功能是正确的。</p><p>这实际上是「软件工程」方面的知识，国外对于程序设计的流程确实比较规范，一个良好的设计过程能够极大的改善代码的质量。将理论付诸于实践，做一名合格的 coder。</p><h2>Tip</h2><p>分享一个 「软件测试」课程中老师提到的代码测试方法</p><blockquote><b>StyleCop</b> 微软的一个开源的静态代码分析工具,检查c#代码一致性和编码风格。<br/> </blockquote><p>在 Visual Studio 编辑器中安装这个扩展工具，可以分析自己的代码存在哪些不规范问题。而且 <b>StyleCop</b> 支持自动修复，在自己制作的项目中可以通过这个工具提高代码的规范性。</p><p>项目中通常出现的问题有 3 种。</p><p>1、注释不规范。// 注释符要与后面的说明保留 1 个空格。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">ReadTxt</span><span class=\"o\">()</span> <span class=\"o\">//</span> <span class=\"n\">定义文本读取方法</span></code></pre></div><p>2、语义不明。C# 类中定义的变量默认为 private 类型，但是为了保持代码规范 StyleCop 建议加上修饰符。而在调用中加上 this 指明是当前对象中的成员。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">i</span><span class=\"o\">++;</span>\n<span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">++;</span></code></pre></div><p>3、命名不规范。驼峰命名法。</p><blockquote> 骆驼式命名法就是当变量名或函数名是由一个或多个单词连结在一起，而构成的唯一识别字时，第一个单词以小写字母开始；从第二个单词开始以后的每个单词的首字母都采用大写字母，例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。<br/> </blockquote><h2>share</h2><a href=\"https://zhuanlan.zhihu.com/p/59461282\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-29cc6629e21e28ed5c5f9ea4be69db67_ipico.jpg\" data-image-width=\"3000\" data-image-height=\"3000\" class=\"internal\">胡sir：我学计算机以后</a><p>算是对于自己计算机学习的一些思考，也是对于自己一些网站合集的整理，希望每个对互联网有兴趣的人都能高效的在网上获取自己需要的资源。</p>", 
            "topic": [
                {
                    "tag": "极客活动", 
                    "tagLink": "https://api.zhihu.com/topics/19640296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59525462", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode 239. 滑动窗口最大值", 
            "content": "<h2><b>滑动窗口最大值</b> </h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sliding-window-maximum/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">力扣</a><blockquote> 给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。<br/> 返回滑动窗口最大值。<br/> 示例: 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]  解释: <br/> 滑动窗口的位置                最大值 [1  3  -1] -3  5  3  6  7       3 1 [3  -1  -3] 5  3  6  7       3 1  3 [-1  -3  5] 3  6  7       5 1  3  -1 [-3  5  3] 6  7       5 1  3  -1  -3 [5  3  6] 7       6 1  3  -1  -3  5 [3  6  7]      7<br/> </blockquote><p><b><i>解法一：</i></b></p><p>对数组遍历 nums.length-k+1 次</p><p>每次比较从当前索引起 k 个数中的最大值，并将最大值放入返回的新数组中</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">maxSlidingWindow</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">||</span><span class=\"n\">k</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span> <span class=\"o\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span>  <span class=\"n\">maxNums</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">len</span><span class=\"o\">];;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">max</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">len</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n            <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span><span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">k</span> <span class=\"o\">+</span> <span class=\"n\">i</span> <span class=\"o\">;</span><span class=\"n\">j</span><span class=\"o\">++)</span>\n            <span class=\"o\">{</span>\n                <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">max</span><span class=\"o\">)</span>\n                    <span class=\"n\">max</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">];</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">maxNums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">maxNums</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p><b><i>解法二：</i></b></p><p>创建动态数组队列，将数组索引入队，从数组中第 k 个数开始将每次队列中的索引对应的值和 nums 当前索引值比较，将最大值放入新数组中。</p><p>队列始终维持 K 个数</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">maxSlidingWindowTwo</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">||</span><span class=\"n\">k</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span> <span class=\"o\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">len</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">nums_len</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span>  <span class=\"n\">maxNums</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">len</span><span class=\"o\">];;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">Deque</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">deque</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayDeque</span><span class=\"o\">&lt;&gt;()</span> <span class=\"o\">;</span>\n\n        <span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums_len</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"o\">{</span>\n            <span class=\"k\">if</span><span class=\"o\">(!</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()&amp;&amp;</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()&lt;</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"n\">k</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">)</span>\n                <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span> <span class=\"c1\">// 保持队列长度始终为 k-1 以内\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span><span class=\"o\">(!</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()&amp;&amp;</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">peekLast</span><span class=\"o\">()]&lt;</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span>\n                <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">pollLast</span><span class=\"o\">();</span> <span class=\"c1\">// 队列中最多有两个数，过滤滑动窗口中更小的数\n</span><span class=\"c1\"></span>            <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span><span class=\"c1\">//入队\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">&gt;=</span><span class=\"n\">k</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"c1\">// 从第 k 个数开始放入新数组\n</span><span class=\"c1\"></span>                <span class=\"n\">maxNums</span><span class=\"o\">[</span><span class=\"n\">count</span><span class=\"o\">++]=</span><span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()];</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">maxNums</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59525386", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode 933. 最近的请求次数", 
            "content": "<h2><b>﻿最近的请求次数</b></h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/number-of-recent-calls/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">力扣</a><blockquote> 写一个 RecentCounter 类来计算最近的请求。 它只有一个方法：ping(int t)，其中 t 代表以毫秒为单位的某个时间。 返回从 3000 毫秒前到现在的 ping 数。 任何处于 [t - 3000, t] 时间范围之内的 ping 都将会被计算在内，包括当前（指 t 时刻）的 ping。 保证每次对 ping 的调用都使用比之前更大的 t 值。<br/> 示例： 输入：inputs = [&#34;RecentCounter&#34;,&#34;ping&#34;,&#34;ping&#34;,&#34;ping&#34;,&#34;ping&#34;], inputs = [[],[1],[100],[3001],[3002]] 输出：[null,1,2,3,3]<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">RecentCounter</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Queue</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">que</span> <span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">RecentCounter</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">que</span><span class=\"o\">=</span><span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">ping</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">que</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">t</span><span class=\"o\">);</span> <span class=\"c1\">// 先入队\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(!</span><span class=\"n\">que</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()&amp;&amp;</span><span class=\"n\">que</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">()&lt;</span><span class=\"n\">3000</span><span class=\"o\">-</span><span class=\"n\">t</span><span class=\"o\">)</span> <span class=\"c1\">// 因为 t 会一直增大，所以只要判断队首是否小于 3000-t\n</span><span class=\"c1\"></span>        <span class=\"o\">{</span>\n            <span class=\"n\">que</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span> <span class=\"c1\">// 出队\n</span><span class=\"c1\"></span>        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">que</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span> <span class=\"c1\">// 队列中剩余元素个数即有效请求数\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59525325", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode 641. 设计循环双端队列", 
            "content": "<h2><b>设计循环双端队列</b></h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/design-circular-deque/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">力扣</a><blockquote> 设计实现双端队列。 你的实现需要支持以下操作： MyCircularDeque(k)：构造函数,双端队列的大小为k。 insertFront()：将一个元素添加到双端队列头部。 如果操作成功返回 true。 insertLast()：将一个元素添加到双端队列尾部。如果操作成功返回 true。 deleteFront()：从双端队列头部删除一个元素。 如果操作成功返回 true。 deleteLast()：从双端队列尾部删除一个元素。如果操作成功返回 true。 getFront()：从双端队列头部获得一个元素。如果双端队列为空，返回 -1。 getRear()：获得双端队列的最后一个元素。 如果双端队列为空，返回 -1。 isEmpty()：检查双端队列是否为空。 isFull()：检查双端队列是否满了。<br/> </blockquote><p><b><i>解题思路：</i></b></p><p>这道题和 LeetCode 622. 设计循环队列思路基本一致，可以先完成这题再来看 641</p><p>依旧用三个变量：head 、tail 、count 分别代表队列的首元素位置、尾元素的下一位置（所以 Rear 方法与 Front 稍有不同）、队列的元素个数</p><p>对头和尾变量超出数组长度时做取模运算。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">MyCircularDeque</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">;</span> <span class=\"c1\">// 定义一个顺序队列，用数组来存储队列元素\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// count 来表示队列中当前存在的元素个数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// head 表示队列的头\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">tail</span> <span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// tail 表示队列的尾\n</span><span class=\"c1\"></span>\n    <span class=\"cm\">/** Initialize your data structure here. Set the size of the deque to be k. */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">MyCircularDeque</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">nums</span> <span class=\"o\">=</span>  <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span> <span class=\"c1\">// 根据 k 来初始化数组的长度\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">insertFront</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">&gt;=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素个数超出数组长度则无法再入队\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">head</span><span class=\"o\">-=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span> <span class=\"c1\">// 队列未满则将元素入队，尾指针以及数组元素 +1\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">insertLast</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">&gt;=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素个数超出数组长度则无法再入队\n</span><span class=\"c1\"></span>        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span> <span class=\"c1\">// 队列未满则将元素入队，尾指针以及数组元素 +1\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">tail</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">deleteFront</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列为空则无法删除元素\n</span><span class=\"c1\"></span>        <span class=\"n\">head</span><span class=\"o\">++;</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"c1\">// 减少数组搬运操作直接将队列头移向下一元素\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">deleteLast</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列为空则无法删除元素\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">tail</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// 减少数组搬运操作直接将队列尾移向上一元素\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span>\n            <span class=\"n\">tail</span><span class=\"o\">-=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the front item from the deque. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getFront</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">];</span> \n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the last item from the deque. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getRear</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular deque is empty or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular deque is full or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isFull</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Your MyCircularDeque object will be instantiated and called as such:\n</span><span class=\"cm\"> * MyCircularDeque obj = new MyCircularDeque(k);\n</span><span class=\"cm\"> * boolean param_1 = obj.insertFront(value);\n</span><span class=\"cm\"> * boolean param_2 = obj.insertLast(value);\n</span><span class=\"cm\"> * boolean param_3 = obj.deleteFront();\n</span><span class=\"cm\"> * boolean param_4 = obj.deleteLast();\n</span><span class=\"cm\"> * int param_5 = obj.getFront();\n</span><span class=\"cm\"> * int param_6 = obj.getRear();\n</span><span class=\"cm\"> * boolean param_7 = obj.isEmpty();\n</span><span class=\"cm\"> * boolean param_8 = obj.isFull();\n</span><span class=\"cm\"> */</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59525262", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 0, 
            "title": "LeetCode.622. 设计循环队列", 
            "content": "<h2><b>设计循环队列</b> </h2><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/design-circular-queue/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">力扣</a><blockquote> 设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。<br/> 循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。<br/> 你的实现应该支持如下操作：<br/> MyCircularQueue(k): 构造器，设置队列长度为 k 。 Front: 从队首获取元素。如果队列为空，返回 -1 。 Rear: 获取队尾元素。如果队列为空，返回 -1 。 enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。 deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。 i&gt;sEmpty(): 检查循环队列是否为空。 isFull(): 检查循环队列是否已满。<br/> </blockquote><p>解题思路：</p><p>这里采用的是顺序队列（数组）的方式来实现循环队列。</p><p>用三个变量：head 、tail 、count 分别代表队列的首元素位置、尾元素的下一位置（所以 Rear 方法与 Front 稍有不同）、队列的元素个数</p><p>对头和尾变量超出数组长度时做取模运算。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">MyCircularQueue</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">;</span> <span class=\"c1\">// 定义一个顺序队列，用数组来存储队列元素\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// count 来表示队列中当前存在的元素个数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// head 表示队列的头\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">tail</span> <span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// tail 表示队列的尾\n</span><span class=\"c1\"></span>    <span class=\"cm\">/** Initialize your data structure here. Set the size of the queue to be k. */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">MyCircularQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">nums</span> <span class=\"o\">=</span>  <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span> <span class=\"c1\">// 根据 k 来初始化数组的长度\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Insert an element into the circular queue. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">enQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">&gt;=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素个数超出数组长度则无法再入队\n</span><span class=\"c1\"></span>        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span> <span class=\"c1\">// 队列未满则将元素入队，尾指针以及数组元素 +1\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">tail</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Delete an element from the circular queue. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">deQueue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列为空则无法删除元素\n</span><span class=\"c1\"></span>        <span class=\"n\">head</span><span class=\"o\">++;</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"c1\">// 减少数组搬运操作直接将队列头移向下一元素\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the front item from the queue. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Front</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">];</span> \n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the last item from the queue. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">Rear</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular queue is empty or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular queue is full or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isFull</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59517235", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 1, 
            "title": "简单入门 —— 队列", 
            "content": "<h2><b>队列介绍 </b></h2><p><b>队列</b>（Queue）是计算机中常见的数据结构，是一种操作受限的线性表。队列遵循 <b>FIFO （先进先出）</b> 原则，队列元素的增加在队尾，队列元素的读、取在队首。可以通过数组、链表两种基本的数据结构来实现。</p><p>在 <b>操作系统</b> 中常见的应用有：CPU 进程的调度、内存的分配、磁盘的管理。</p><p>队列的基本操作有：</p><p>1、<b>入队</b>。首先应检测队列中是否能插入元素，不能则不执行插入，能则在队尾插入一个元素。</p><p>2、<b>出队</b>。首先应当检测队列中是否有元素，无元素则无法读取，有元素则读取栈顶元素，并将其从队列中删除。</p><p>3、<b>读取栈顶元素</b>。同出队不同，该元素依旧保存在队首。</p><p>4、<b>判断队列是否为空</b>。</p><p>5、<b>返回数组中的元素个数</b>。</p><p>基于以上 5 个基本操作，分别用数组和链表来实现队列。</p><p><b>数组实现：</b> 用 head、tail、count 分别代表队首、队尾、队列中的元素个数，在 QueueStudy 实例对象构造时将数组大小初始化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">QueueStudy</span>\n<span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">queue</span> <span class=\"o\">;</span> <span class=\"c1\">// 数组队列\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">head</span><span class=\"o\">;</span> <span class=\"c1\">// 队首\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">tail</span><span class=\"o\">;</span> <span class=\"c1\">// 队尾\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素\n</span><span class=\"c1\"></span>\n    <span class=\"kd\">public</span> <span class=\"nf\">QueueStudy</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">len</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">queue</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">len</span><span class=\"o\">];</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">element</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span> <span class=\"n\">queue</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> \n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;队列已满，无法入队&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span><span class=\"o\">{</span>\n            <span class=\"n\">queue</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">;</span>\n            <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">pop</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> \n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">;</span> <span class=\"c1\">// 这里用 -1 代表无元素可出队\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">queue</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">++];</span>\n        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">peek</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> \n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">;</span> <span class=\"c1\">// 这里用 -1 代表队首无元素\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">queue</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Boolean</span> <span class=\"nf\">isEmpty</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">size</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p><b>链表实现</b></p><p>解释：链表队列的实现比数组链表稍微复杂，需要先定义一个链表，每次让 node 指向下一节点，head 始终指向首结点</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"c1\">// 实现一个链表\n</span><span class=\"c1\"></span><span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">element</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">,</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">element</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getElement</span><span class=\"o\">()</span> <span class=\"c1\">// 读取链表结点数据\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">element</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">setElement</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"c1\">// 修改链表结点数据\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">element</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ListQueue</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">head</span> <span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">ListQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"c1\">// 初始化链表队列\n</span><span class=\"c1\"></span>    <span class=\"o\">{</span>\n        <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">,</span><span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span>\n    <span class=\"o\">{</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">pop</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">==</span><span class=\"kc\">null</span><span class=\"o\">)</span> \n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span>  <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">getElement</span><span class=\"o\">();</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">peek</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> \n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">getElement</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"n\">Boolean</span> <span class=\"nf\">isEmpty</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">size</span><span class=\"o\">()</span>\n    <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>循环队列</h2><p><b>循环队列</b> 是队列的特殊形式，队尾连着队首，在队列空间允许存、取的情况下，入队和出队的位置不固定。实际上就是用 count （队列元素个数）来判断队列是否允许入队、出队。</p><p>循环队列的进阶就是<b>循环双端队列</b>，队列的操作不再局限于在队首读取、在队尾插入。增加了<b>队首插入</b>、<b>队尾读取</b> 的操作。</p><p>可以尝试做一下 <a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/design-circular-deque/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LeetCode 641. 设计循环双端队列</a></p><p>以下为实现代码参考</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">MyCircularDeque</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">nums</span><span class=\"o\">;</span> <span class=\"c1\">// 定义一个顺序队列，用数组来存储队列元素\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// count 来表示队列中当前存在的元素个数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// head 表示队列的头\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">tail</span> <span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"c1\">// tail 表示队列的尾\n</span><span class=\"c1\"></span>\n    <span class=\"cm\">/** Initialize your data structure here. Set the size of the deque to be k. */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">MyCircularDeque</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">nums</span> <span class=\"o\">=</span>  <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span> <span class=\"c1\">// 根据 k 来初始化数组的长度\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Adds an item at the front of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">insertFront</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">&gt;=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素个数超出数组长度则无法再入队\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">head</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">head</span><span class=\"o\">-=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span> <span class=\"c1\">// 队列未满则将元素入队，尾指针以及数组元素 +1\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Adds an item at the rear of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">insertLast</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">&gt;=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列元素个数超出数组长度则无法再入队\n</span><span class=\"c1\"></span>        <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span> <span class=\"c1\">// 队列未满则将元素入队，尾指针以及数组元素 +1\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">tail</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Deletes an item from the front of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">deleteFront</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列为空则无法删除元素\n</span><span class=\"c1\"></span>        <span class=\"n\">head</span><span class=\"o\">++;</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span> <span class=\"o\">%</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"c1\">// 减少数组搬运操作直接将队列头移向下一元素\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Deletes an item from the rear of Deque. Return true if the operation is successful. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">deleteLast</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// 队列为空则无法删除元素\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">tail</span><span class=\"o\">=</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// 减少数组搬运操作直接将队列尾移向上一元素\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span>\n            <span class=\"n\">tail</span><span class=\"o\">-=</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">--;</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the front item from the deque. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getFront</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">head</span><span class=\"o\">];</span> \n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the last item from the deque. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">getRear</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">tail</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"o\">[</span><span class=\"n\">tail</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular deque is empty or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Checks whether the circular deque is full or not. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isFull</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">nums</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2><b>用队列实现栈</b></h2><p>需要用到两个 <b>队列</b> 或是一个 <b>双端队列</b> 实现。</p><p>入栈用 1 个队列来存储，出栈将队列 1 中的元素都出队到队列 2，此时队列 2 首的就是应该出栈的元素，将队列 2 队首出队并返回，剩下元素再出队回队列 2 则队列实现栈完成。</p><p>Java 代码实现如下</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">MyStack</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Deque</span> <span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">deque</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Deque</span> <span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">tempDeque</span><span class=\"o\">;</span>\n    <span class=\"cm\">/** Initialize your data structure here. */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">MyStack</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">deque</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayDeque</span><span class=\"o\">&lt;&gt;();</span>     \n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Push element x onto stack. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">push</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Removes the element on top of the stack and returns that element. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">pop</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">tempDeque</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayDeque</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()!=</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">pop</span><span class=\"o\">());</span>\n        <span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()!=</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n        <span class=\"k\">return</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Get the top element. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">top</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">tempDeque</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayDeque</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()!=</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n        <span class=\"kt\">int</span> <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">peek</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()!=</span><span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">push</span><span class=\"o\">(</span><span class=\"n\">tempDeque</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">());</span>\n        <span class=\"k\">return</span> <span class=\"n\">num</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/** Returns whether the stack is empty. */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">empty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">deque</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()==</span><span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59461282", 
            "userName": "胡sir", 
            "userLink": "https://www.zhihu.com/people/a9d95e46d6c830939074d99c4f9569e1", 
            "upvote": 6, 
            "title": "我学计算机以后", 
            "content": "<p>﻿这是我专栏的第一篇文章，希望能给更多对互联网有兴趣的人一些帮助。</p><p>自从学了计算机以后，遇见过的问题多了很多，基础点的有：怎么刷机、怎么从百度网盘下文件...，技术点的有：这个程序为什么这样写不行？网站要如何搭建？，商业点的有：公众号该如何运营?新零售是怎样？</p><p>当最开始遭遇这些问题的时候，说实话我确实是不懂的，但是绝大多数都被我解决了。而我之所以能解决这些问题肯定是离不开我的专业（计算机 —— 软件工程），本质则在于我能借助于「互联网」发现问题并解决问题。</p><p>互联网时代给人们带来了很多便利，例如：「移动支付」、「视频聊天」。但是互联网被称为站在巨人的肩膀上，最重要的是互联网上每一个人分享的资源，就算是一个会上网的小孩子，只要愿意，也能通过互联网知道全球各地的新闻时政，上到造飞机火箭的论文，下到炒菜倒油，前五万年进化，近现代演变，南纬到北纬，东经到西经，这不正是我们所说的「上知天文，下知地理，古今中外，无所不晓」。而这才是互联网真正带给我们的红利，当你连上互联网时，仅在中国你已经超过了 10 亿人（截止 2018 年底，中国尚有 10 亿人未上网）。</p><p>但是实际上我们并没有超过 10 亿人，因为我们根本不知道该如何去利用这些资源，甚至根本不知道该如何去找这部分资源。</p><p><b>我将从大众篇、特定领域篇来分享我是如何利用互联网资源发现并解决问题。</b></p><h2><b>搜索引擎</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ada94458656e1007811d33bd39a138e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1666\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb\" width=\"1666\" data-original=\"https://pic2.zhimg.com/v2-ada94458656e1007811d33bd39a138e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1666&#39; height=&#39;580&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1666\" data-rawheight=\"580\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1666\" data-original=\"https://pic2.zhimg.com/v2-ada94458656e1007811d33bd39a138e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ada94458656e1007811d33bd39a138e9_b.jpg\"/></figure><p> 曾经有段时间大家喜欢说一句话：<b><i>有问题，找度娘</i></b>（即：百度）。事实上我们普通人所遇见的大部分问题，通过搜索引擎就可以解决。</p><p>仅对搜索引擎，就可以很直接的区分每个人的效率和能力。对于国内来说，常用的搜索引擎有：百度、360（<a href=\"https://link.zhihu.com/?target=https%3A//www.so.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">so.com/</span><span class=\"invisible\"></span></a>）、搜狗、必应（<a href=\"https://link.zhihu.com/?target=https%3A//cn.bing.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">cn.bing.com/</span><span class=\"invisible\"></span></a>）。对于中文搜索来说我比较推荐：百度（<a href=\"https://link.zhihu.com/?target=https%3A//www.baidu.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">baidu.com/</span><span class=\"invisible\"></span></a>）、搜狗（<a href=\"https://link.zhihu.com/?target=https%3A//www.sogou.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">sogou.com/</span><span class=\"invisible\"></span></a>）。</p><p>百度是对所有中文网站抓取率最高的，很多人会吐槽百度搜索时带上的广告。这里提供两个百度搜索常用的技巧，直接提高搜索效率 50% 。</p><p>英文引号引住你要搜索的关键字：&#34;码农在途&#34;。所有出现的搜索结果必然会包含「码农在途」四个字。</p><p>关键字空格用 ‘+’ 号连接下一个关键字，例如：&#34;码农在途&#34; +博客，等于限定结果在博客范围。</p><p>关于搜索引擎的语法还有很多，但是多了估计也不愿意记，真正有心的可以搜索「 SEO 高级搜索语法」，还有不少高效的搜索方法。</p><p>对于普通人来说，以上百度、搜狗已经可以解决生活中的绝大多数问题，但是对于计算机尤其是程序员来说，谷歌搜索才是必备的技能，一是能够获取到国外的优质资源，二是减少了信息筛选鉴别的时间（响应国家要求，在大陆谷歌不能直接访问）。</p><p>当然，搜索引擎多了，很多人也记不住，对于懒人来说可以通过网址导航来解决这些问题，我所搜集的比较好的网址导航有：虫大师快搜（<a href=\"https://link.zhihu.com/?target=http%3A//search.chongbuluo.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">search.chongbuluo.com/</span><span class=\"invisible\"></span></a>）、龙喵网（<a href=\"https://link.zhihu.com/?target=http%3A//ailongmiao.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ailongmiao.com/</span><span class=\"invisible\"></span></a>）、龙轩导航（<a href=\"https://link.zhihu.com/?target=http%3A//ilxdh.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">ilxdh.com/</span><span class=\"invisible\"></span></a>）、<a href=\"https://link.zhihu.com/?target=http%3A//start.Me%28https%3A//start.me/cn%29\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">start.Me(https://start.</span><span class=\"invisible\">me/cn)</span><span class=\"ellipsis\"></span></a>。除了搜索引擎、高级搜索，这几个导航网还提供了不少效率网址，善用这些工具一定可以让你效率提升不少。</p><p><b>以下为特定领域篇</b></p><h2><b>程序员必备</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9fc5e842b1c96bc8d2d0ecf140858263_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1835\" data-rawheight=\"981\" class=\"origin_image zh-lightbox-thumb\" width=\"1835\" data-original=\"https://pic4.zhimg.com/v2-9fc5e842b1c96bc8d2d0ecf140858263_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1835&#39; height=&#39;981&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1835\" data-rawheight=\"981\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1835\" data-original=\"https://pic4.zhimg.com/v2-9fc5e842b1c96bc8d2d0ecf140858263_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9fc5e842b1c96bc8d2d0ecf140858263_b.jpg\"/></figure><p> 作为程序员，入门可以好好利用：MDN、W3CSchool 两个网站，从网页开始入门，在这里你可以发掘编程的兴趣。</p><p>入门之后就是系统的学习了，极客时间、慕课、网易云课堂等网站可以给你一个系统学习的路线。</p><p>在程序员正式入门的过程中，你一定绕不开算法，LeetCode 是你程序员进阶道路上必不可少的网站。</p><p>在编程的过程中你会遇见很多 BUG，但是不用担心，在 StackOverflow、CSDN 、博客园上很多人已经越过了这些坑，而我们要做的就是在前人经验的帮助下，早日度过新手期。</p><p>GitHub 应该是当下每个程序员都因知道并使用的网站，你可以在这里找到各种开源项目，也可以在这里分享你的代码，让更多的人认同。</p><p>每个技术人员都可以用博客记录下自己的成长，例如：我，而这样的渠道有很多，CSDN、博客园、思否等等，你可以选择一个你喜欢的，也可以自己动手搭建一个。每隔一段时间回来看看你成长的点滴你会有更多的收获。（Medium 这个国际性的博客分享网站，可以让你更好的看到大牛们是怎么写技术博客的） </p><p>程序员的成长离不开大量的实践，这些网站可以让你快速成长，但是真正能走到哪一步靠的是自己。</p><h2><b>新媒体运营篇</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-beadfc2d79056c9f4c3685af74fa503d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1847\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"1847\" data-original=\"https://pic2.zhimg.com/v2-beadfc2d79056c9f4c3685af74fa503d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1847&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1847\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1847\" data-original=\"https://pic2.zhimg.com/v2-beadfc2d79056c9f4c3685af74fa503d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-beadfc2d79056c9f4c3685af74fa503d_b.jpg\"/></figure><p> 首推的就是「i 排版网址导航」，这个网站几乎整合了所有新媒体运营所需要的工具，从资讯的获取到修图、数据分析都有，能真正用好这些工具真正差的就是运营的方法了。</p><p>而公众号运营的方法，最好的学习来自于对 大V 账号的学习，西瓜助手等第三方平台可以提供一个公众号排名以及细分领域的排行，看看大咖们运营公众号的方法，运用在自己的公众号上就是最好的实践。</p><p>图片和排版是公众号运营绕不开的坎，这两个解决了剩下的就是内容的丰富。</p><h2><b>综合成长篇</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b3ff88c133e4c33487d5900b05a11771_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1485\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"1485\" data-original=\"https://pic2.zhimg.com/v2-b3ff88c133e4c33487d5900b05a11771_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1485&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1485\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1485\" data-original=\"https://pic2.zhimg.com/v2-b3ff88c133e4c33487d5900b05a11771_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b3ff88c133e4c33487d5900b05a11771_b.jpg\"/></figure><p> 首推 <b>知乎</b> ，虽然有很多人在里面吹牛动不动几十万上百万年薪，但是这里也能找到一些专业的回答，很多综合性的问题我会在这里寻找答案。</p><p>例如：作为 IT 行业的过来人，你有什么话想对后辈说的？...有很多优秀的回答和问题，从里面吸收自己需要的知识。</p><p><b>微信公众号</b>，现在有大佬在公众号上分享自己的见闻，这是很好的资源获取渠道，每个人都应该有几个置顶关注的公众号。</p><p><b>知识星球</b>，主要是付费的圈子，活跃度很高的圈子都有自己的特色。付费模式一定程度隔离了很多营销、低素质人群，找到一群志群道合的人可以让你在变强的道路上坚持的更久。</p><p><b>豆瓣</b>，你可以在豆瓣读书、豆瓣电影里发现很多经典有趣的书和电影，里面讨论的影评也能让你对书、电影的感官更深刻，当然你也可以在这里分享你的观点，看看能够获得多少人的赞同。</p><p><b>B站</b>，不仅仅是二次元，这里面还有很多教学视频：SQL 进阶、C 语言学习等等。实际上这是国内版的 YouTube</p><p><b>TED、Course</b>，是国内比较有名的网站，提升自己的同时还可以锻炼一些英语。</p><h2><b>趣站</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-770d9819fffa5181287028eced096c62_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1090\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb\" width=\"1090\" data-original=\"https://pic3.zhimg.com/v2-770d9819fffa5181287028eced096c62_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1090&#39; height=&#39;334&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1090\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1090\" data-original=\"https://pic3.zhimg.com/v2-770d9819fffa5181287028eced096c62_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-770d9819fffa5181287028eced096c62_b.jpg\"/></figure><p><b>吾爱破解</b>，有段时间是我常逛的网站这里可以找到很多资源，更多的是一些对于安卓逆向、破解方面的知识，总之这是个很有趣的地方。</p><p><b>V2EX</b>，关注分享和探索的地方，里面也有很多大厂的招聘，还有不少人分享自己的知识经历。</p><p><b>虎嗅</b>、InfoQ 是不错的资讯网站，这里有可以了解到很多行业动态，更多的是技术和商业方面的解读。</p><h2><b>工作</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b6e886731bc06a89ec7b87c896fe2937_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"912\" data-original=\"https://pic4.zhimg.com/v2-b6e886731bc06a89ec7b87c896fe2937_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;912&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"912\" data-original=\"https://pic4.zhimg.com/v2-b6e886731bc06a89ec7b87c896fe2937_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b6e886731bc06a89ec7b87c896fe2937_b.jpg\"/></figure><p> 身边总有人不知道毕业出去有哪些岗位可以选择，不知道该学些什么，其实很简单，<b>到源头去找答案</b>。工作岗位直接来源于企业的需要，想要知道有什么岗位要学什么，看企业招聘相应岗位的数量以及每个岗位的需求，这就是我们该了解的。</p><p>前程无忧、智联招聘、拉勾网都是比较靠谱的招聘网站，这里你可以查询到比较靠谱的招聘信息。</p><p>而招聘网上展示的企业信息可能审核不严有虚假，可以通过天眼查和国家企业信息公示系统查询企业信息，同时也能了解到企业的架构、经营状况。</p><p>比较推荐天眼查，VIP 账号可以查到更多有效信息，可以在淘宝上租借一个临时账号，找工作时很有用。</p><h2><b>总结</b></h2><p>这篇文章我分享了很多我收集并使用的网站，如果从未接触这些，这将给你带来极大的效率提升，如果已经接触过希望能给你带来一些不同。</p><p>你的点赞和评论是对我这篇文章的认可，而分享则是一种好的传播。希望这篇文章能给更多人带来改变。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//mubu.com/doc/jKsEHltzSd\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">思维导图链接</a></p><p><b>注：可以转载但请先与我取得联系，谢谢。</b></p>", 
            "topic": [
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }, 
                {
                    "tag": "效率", 
                    "tagLink": "https://api.zhihu.com/topics/19556677"
                }, 
                {
                    "tag": "网站", 
                    "tagLink": "https://api.zhihu.com/topics/19556496"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1088398003815100416"
}
