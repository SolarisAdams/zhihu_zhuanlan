{
    "title": "每天一道面试题（java开发）", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/luo-ren-qian", 
        "https://www.zhihu.com/people/super.he", 
        "https://www.zhihu.com/people/zw156052", 
        "https://www.zhihu.com/people/yang-ze-hong-5", 
        "https://www.zhihu.com/people/cca-tu", 
        "https://www.zhihu.com/people/rain-72", 
        "https://www.zhihu.com/people/tan-xiao-yang-95", 
        "https://www.zhihu.com/people/zhong-yu-zi-lu", 
        "https://www.zhihu.com/people/su-mu-zhe-80-32", 
        "https://www.zhihu.com/people/xie-dai-ma-de-xiong", 
        "https://www.zhihu.com/people/wei-82-34-45", 
        "https://www.zhihu.com/people/huang-ri-yan-27", 
        "https://www.zhihu.com/people/qing-fei-bu-de-yi-17", 
        "https://www.zhihu.com/people/andrea-31-83", 
        "https://www.zhihu.com/people/jiu-hua-61", 
        "https://www.zhihu.com/people/wo-men-de-sheng-huo-63-69", 
        "https://www.zhihu.com/people/yu-er-59-60", 
        "https://www.zhihu.com/people/bingovhh", 
        "https://www.zhihu.com/people/rong-ji-91-17", 
        "https://www.zhihu.com/people/hu-shui-shi-nin-de-yan-shen", 
        "https://www.zhihu.com/people/wu-le-bu-zuo-zhu", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/sun-chao-49-67", 
        "https://www.zhihu.com/people/yuan-wen-qi-xiang-82-68", 
        "https://www.zhihu.com/people/babayetu-liu", 
        "https://www.zhihu.com/people/luo-jie-xin-32", 
        "https://www.zhihu.com/people/qi-feng-96", 
        "https://www.zhihu.com/people/si-xue-feng-35", 
        "https://www.zhihu.com/people/feng-jia-xing-47-52", 
        "https://www.zhihu.com/people/ming-wu-ta-i", 
        "https://www.zhihu.com/people/cheng-nuo-yi-guo-qi", 
        "https://www.zhihu.com/people/xiong-mao-de-shi-jie-ni-bu-dong", 
        "https://www.zhihu.com/people/ju-xie-zuo-52", 
        "https://www.zhihu.com/people/winwind", 
        "https://www.zhihu.com/people/hai-dan-2-29", 
        "https://www.zhihu.com/people/li-ying-47-83", 
        "https://www.zhihu.com/people/arisosoftware", 
        "https://www.zhihu.com/people/fan-ming-jie-26", 
        "https://www.zhihu.com/people/yushuai.yin", 
        "https://www.zhihu.com/people/jiakelong", 
        "https://www.zhihu.com/people/le-zi-zi-62", 
        "https://www.zhihu.com/people/454978580", 
        "https://www.zhihu.com/people/xing-ba-tai-ji", 
        "https://www.zhihu.com/people/DeleteZN", 
        "https://www.zhihu.com/people/xing-zi-08", 
        "https://www.zhihu.com/people/mu-you-43-79", 
        "https://www.zhihu.com/people/guo-rong-qin", 
        "https://www.zhihu.com/people/dazzling-73-21", 
        "https://www.zhihu.com/people/ke-sai-en-si", 
        "https://www.zhihu.com/people/t2ek", 
        "https://www.zhihu.com/people/yin-fei-86-79", 
        "https://www.zhihu.com/people/tonyzzz", 
        "https://www.zhihu.com/people/EricW", 
        "https://www.zhihu.com/people/jiu-hu-29", 
        "https://www.zhihu.com/people/qi-zhe-82", 
        "https://www.zhihu.com/people/lierikaoyu", 
        "https://www.zhihu.com/people/chen-jia-90-42", 
        "https://www.zhihu.com/people/nian-you-shi-de-ling-meng-61", 
        "https://www.zhihu.com/people/wang-gang-25-82", 
        "https://www.zhihu.com/people/zheng-jian-yang-56", 
        "https://www.zhihu.com/people/gxz123", 
        "https://www.zhihu.com/people/hua-hua-de-shi-jie-88-73", 
        "https://www.zhihu.com/people/kakaFT", 
        "https://www.zhihu.com/people/ai-xin-jue-luo-zhong-er", 
        "https://www.zhihu.com/people/tenzed", 
        "https://www.zhihu.com/people/zhao-da-han-30", 
        "https://www.zhihu.com/people/pebble.fd", 
        "https://www.zhihu.com/people/qi-sir-66", 
        "https://www.zhihu.com/people/rupeng", 
        "https://www.zhihu.com/people/xue-xiao-bei-45", 
        "https://www.zhihu.com/people/1pha", 
        "https://www.zhihu.com/people/tmhoney-71", 
        "https://www.zhihu.com/people/zheng-xiao-bing-90", 
        "https://www.zhihu.com/people/ityfy", 
        "https://www.zhihu.com/people/qing-qing-jia-de-gu-liang", 
        "https://www.zhihu.com/people/sealseiya", 
        "https://www.zhihu.com/people/apex-40-29", 
        "https://www.zhihu.com/people/qqmm2016", 
        "https://www.zhihu.com/people/you-qu-de-ping-heng", 
        "https://www.zhihu.com/people/sui-yi-23-44", 
        "https://www.zhihu.com/people/da-qi-ge-ge-88", 
        "https://www.zhihu.com/people/freedom-60-75-38", 
        "https://www.zhihu.com/people/hao_yuan", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/chen-guo-jiang-39-83", 
        "https://www.zhihu.com/people/ruo-chu-jian-85", 
        "https://www.zhihu.com/people/deng-yan-song", 
        "https://www.zhihu.com/people/jieyouzahuodian", 
        "https://www.zhihu.com/people/zhu-zhu-hen-cai-de", 
        "https://www.zhihu.com/people/chen-xiao-jian-95-93", 
        "https://www.zhihu.com/people/gai-yao-84", 
        "https://www.zhihu.com/people/hsan-93", 
        "https://www.zhihu.com/people/ssk-4", 
        "https://www.zhihu.com/people/mrglaucus", 
        "https://www.zhihu.com/people/liu-nian-22-42", 
        "https://www.zhihu.com/people/huang-liao-57", 
        "https://www.zhihu.com/people/bu-ke-zhi-82", 
        "https://www.zhihu.com/people/yuge.me", 
        "https://www.zhihu.com/people/day-jay-5", 
        "https://www.zhihu.com/people/adingi", 
        "https://www.zhihu.com/people/gong-sun-shu-23", 
        "https://www.zhihu.com/people/zhang-hong-he-72", 
        "https://www.zhihu.com/people/bo-fei-79", 
        "https://www.zhihu.com/people/bu-ding-long", 
        "https://www.zhihu.com/people/ge-yun-29", 
        "https://www.zhihu.com/people/andrewgyq", 
        "https://www.zhihu.com/people/share-49-35-46", 
        "https://www.zhihu.com/people/zhou-min-jun-73", 
        "https://www.zhihu.com/people/dvan001", 
        "https://www.zhihu.com/people/li-shuai-76-22", 
        "https://www.zhihu.com/people/harris-79", 
        "https://www.zhihu.com/people/shi-shui-ni-22", 
        "https://www.zhihu.com/people/peng-yu-jian-47", 
        "https://www.zhihu.com/people/chen-zhong-yang-68-51", 
        "https://www.zhihu.com/people/qi-ba-61", 
        "https://www.zhihu.com/people/zao-yu-61-77", 
        "https://www.zhihu.com/people/chen-yi-36-8-38", 
        "https://www.zhihu.com/people/wo-mei-26", 
        "https://www.zhihu.com/people/stanley-chang-46", 
        "https://www.zhihu.com/people/laiho-26", 
        "https://www.zhihu.com/people/chuanbao-xu", 
        "https://www.zhihu.com/people/er-dong-hao", 
        "https://www.zhihu.com/people/li-jiang-na", 
        "https://www.zhihu.com/people/anysys66", 
        "https://www.zhihu.com/people/jiebanren-92", 
        "https://www.zhihu.com/people/nunu-60", 
        "https://www.zhihu.com/people/yuan-xiao-rong-57", 
        "https://www.zhihu.com/people/jiang-ye-15", 
        "https://www.zhihu.com/people/4everkalmia77", 
        "https://www.zhihu.com/people/zhao-qing-96-34", 
        "https://www.zhihu.com/people/kiripeng", 
        "https://www.zhihu.com/people/liu-jie-73-66", 
        "https://www.zhihu.com/people/jamebing", 
        "https://www.zhihu.com/people/feng-huang-yuan-xiong-zhen-83", 
        "https://www.zhihu.com/people/Ares-26", 
        "https://www.zhihu.com/people/ticktock-47", 
        "https://www.zhihu.com/people/cloud-22-69", 
        "https://www.zhihu.com/people/da-fei-ya-37", 
        "https://www.zhihu.com/people/westermann", 
        "https://www.zhihu.com/people/du-kang-82-52", 
        "https://www.zhihu.com/people/xiao-yao-90", 
        "https://www.zhihu.com/people/zhang-zi-bu-15", 
        "https://www.zhihu.com/people/shi-ta-ke-43", 
        "https://www.zhihu.com/people/javascript-23", 
        "https://www.zhihu.com/people/allenzbj", 
        "https://www.zhihu.com/people/woshiamiaojiang"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/42792443", 
            "userName": "张晓康", 
            "userLink": "https://www.zhihu.com/people/f0a29ad667f017ecc4f313d8c176525a", 
            "upvote": 9, 
            "title": "第四天：ConcurrentHashMap全解析（上）", 
            "content": "<p>      如果大家看了我的上一篇文章：<a href=\"https://zhuanlan.zhihu.com/p/42703011\" class=\"internal\">第三天：HashMap为什么是线程不安全的</a>，大概就明白了HashMap为什么会存在并发问题，其主要原因还是在链表扩容的时候的两个方法：resize（）和transfer（），那我们顺着这个思路我们会想到如果在这两个方法调用的时候加上同步不就可以了吗？带着这个疑问，我们来看看并发大师<i>Doug Lea </i>是如何巧妙的解决这一问题的。</p><h2><b>Java7中的ConcurrentHashMap</b></h2><p>首先介绍一下ConcurrentHashMap的结构：ConcurrentHashMap 由一个个 Segment 组成，Segment 代表”部分“或”一段“的意思，所以很多地方都会将其描述为<b>分段锁</b>。注意，下文中，很多地方用了“<b>槽</b>”来代表一个 segment。</p><p>      简单理解就是，ConcurrentHashMap 是一个 Segment 数组，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2541e2932c5390dc549a6ea05bfb97a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1636\" data-rawheight=\"1186\" class=\"origin_image zh-lightbox-thumb\" width=\"1636\" data-original=\"https://pic3.zhimg.com/v2-2541e2932c5390dc549a6ea05bfb97a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1636&#39; height=&#39;1186&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1636\" data-rawheight=\"1186\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1636\" data-original=\"https://pic3.zhimg.com/v2-2541e2932c5390dc549a6ea05bfb97a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2541e2932c5390dc549a6ea05bfb97a6_b.jpg\"/></figure><p><b>concurrencyLevel</b>：并行级别、并发数、Segment 数，怎么翻译不重要，理解它。默认是 16，也就是说 ConcurrentHashMap 有 16 个 Segments，所以理论上，这个时候，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。这个值可以在初始化的时候设置为其他值，但是一旦初始化以后，它是不可以扩容的。</p><p>       再具体到每个 Segment 内部，其实每个 Segment 很像之前介绍的 HashMap，不过它要保证线程安全，所以处理起来要麻烦些。</p><p><b>初始化</b></p><div class=\"highlight\"><pre><code class=\"language-abap\">public ConcurrentHashMap(int initialCapacity,\n                         float loadFactor, int concurrencyLevel) {\n    if (!(loadFactor &gt; 0) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)\n        throw new IllegalArgumentException();\n    if (concurrencyLevel &gt; MAX_SEGMENTS)\n        concurrencyLevel = MAX_SEGMENTS;\n    // Find power-of-two sizes best matching arguments\n    int sshift = 0;\n    int ssize = 1;\n    // 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方\n    while (ssize &lt; concurrencyLevel) {\n        ++sshift;\n        ssize &lt;&lt;= 1;\n    }\n    // 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4\n    // 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值\n    this.segmentShift = 32 - sshift;\n    this.segmentMask = ssize - 1;\n\n    if (initialCapacity &gt; MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n\n    // initialCapacity 是设置整个 map 初始的大小，\n    // 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小\n    // 如 initialCapacity 为 64，那么每个 Segment 或称之为&#34;槽&#34;可以分到 4 个\n    int c = initialCapacity / ssize;\n    if (c * ssize &lt; initialCapacity)\n        ++c;\n    // 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，\n    // 插入一个元素不至于扩容，插入第二个的时候才会扩容\n    int cap = MIN_SEGMENT_TABLE_CAPACITY; \n    while (cap &lt; c)\n        cap &lt;&lt;= 1;\n\n    // 创建 Segment 数组，\n    // 并创建数组的第一个元素 segment[0]\n    Segment&lt;K,V&gt; s0 =\n        new Segment&lt;K,V&gt;(loadFactor, (int)(cap * loadFactor),\n                         (HashEntry&lt;K,V&gt;[])new HashEntry[cap]);\n    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])new Segment[ssize];\n    // 往数组写入 segment[0]\n    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]\n    this.segments = ss;\n}</code></pre></div><p>       初始化完成，我们得到了一个 Segment 数组。</p><p>      我们就当是用 new ConcurrentHashMap() 无参构造函数进行初始化的，那么初始化完成后：</p><ul><li>Segment 数组长度为 16，不可以扩容</li><li>Segment[i] 的默认大小为 2，负载因子是 0.75，得出初始阈值为 1.5，也就是以后插入第一个元素不会触发扩容，插入第二个会进行第一次扩容</li><li>这里初始化了 segment[0]，其他位置还是 null，至于为什么要初始化 segment[0]，后面的代码会介绍</li><li>当前 segmentShift 的值为 32 - 4 = 28，segmentMask 为 16 - 1 = 15，姑且把它们简单翻译为<b>移位数</b>和<b>掩码</b>，这两个值马上就会用到</li></ul><p><b>put 过程分析</b></p><p>      我们先看 put 的主流程，对于其中的一些关键细节操作，后面会进行详细介绍。</p><div class=\"highlight\"><pre><code class=\"language-abnf\"><span class=\"nc\">public</span> V <span class=\"nc\">put</span><span class=\"p\">(</span>K <span class=\"nc\">key</span>, V <span class=\"nc\">value</span><span class=\"p\">)</span> {\n    <span class=\"nc\">Segment</span>&lt;K,V&gt; s<span class=\"c1\">;</span>\n    <span class=\"nc\">if</span> <span class=\"p\">(</span><span class=\"nc\">value</span> <span class=\"o\">==</span> <span class=\"nc\">null</span><span class=\"p\">)</span>\n        <span class=\"nc\">throw</span> <span class=\"nc\">new</span> <span class=\"nc\">NullPointerException</span><span class=\"p\">()</span><span class=\"c1\">;</span>\n    <span class=\"o\">//</span> <span class=\"o\">1</span>. 计算 <span class=\"nc\">key</span> 的 <span class=\"nc\">hash</span> 值\n    <span class=\"nc\">int</span> <span class=\"nc\">hash</span> <span class=\"o\">=</span> <span class=\"nc\">hash</span><span class=\"p\">(</span><span class=\"nc\">key</span><span class=\"p\">)</span><span class=\"c1\">;</span>\n    <span class=\"o\">//</span> <span class=\"o\">2</span>. 根据 <span class=\"nc\">hash</span> 值找到 <span class=\"nc\">Segment</span> 数组中的位置 j\n    <span class=\"o\">//</span>    <span class=\"nc\">hash</span> 是 <span class=\"o\">32</span> 位，无符号右移 <span class=\"nc\">segmentShift</span><span class=\"p\">(</span><span class=\"o\">28</span><span class=\"p\">)</span> 位，剩下高 <span class=\"o\">4</span> 位，\n    <span class=\"o\">//</span>    然后和 <span class=\"nc\">segmentMask</span><span class=\"p\">(</span><span class=\"o\">15</span><span class=\"p\">)</span> 做一次与操作，也就是说 j 是 <span class=\"nc\">hash</span> 值的高 <span class=\"o\">4</span> 位，也就是槽的数组下标\n    <span class=\"nc\">int</span> j <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nc\">hash</span> &gt;&gt;&gt; <span class=\"nc\">segmentShift</span><span class=\"p\">)</span> &amp; <span class=\"nc\">segmentMask</span><span class=\"c1\">;</span>\n    <span class=\"o\">//</span> 刚刚说了，初始化的时候初始化了 <span class=\"nc\">segment</span><span class=\"p\">[</span><span class=\"o\">0</span><span class=\"p\">]</span>，但是其他位置还是 <span class=\"nc\">null</span>，\n    <span class=\"o\">//</span> <span class=\"nc\">ensureSegment</span><span class=\"p\">(</span>j<span class=\"p\">)</span> 对 <span class=\"nc\">segment</span><span class=\"p\">[</span>j<span class=\"p\">]</span> 进行初始化\n    <span class=\"nc\">if</span> <span class=\"p\">((</span>s <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nc\">Segment</span>&lt;K,V&gt;<span class=\"p\">)</span><span class=\"nc\">UNSAFE</span>.<span class=\"nc\">getObject</span>          <span class=\"o\">//</span> <span class=\"nc\">nonvolatile</span><span class=\"c1\">; recheck</span>\n         <span class=\"p\">(</span><span class=\"nc\">segments</span>, <span class=\"p\">(</span>j &lt;&lt; <span class=\"nc\">SSHIFT</span><span class=\"p\">)</span> + <span class=\"nc\">SBASE</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"nc\">null</span><span class=\"p\">)</span> <span class=\"o\">//</span>  <span class=\"nc\">in</span> <span class=\"nc\">ensureSegment</span>\n        s <span class=\"o\">=</span> <span class=\"nc\">ensureSegment</span><span class=\"p\">(</span>j<span class=\"p\">)</span><span class=\"c1\">;</span>\n    <span class=\"o\">//</span> <span class=\"o\">3</span>. 插入新值到 槽 s 中\n    <span class=\"nc\">return</span> s.<span class=\"nc\">put</span><span class=\"p\">(</span><span class=\"nc\">key</span>, <span class=\"nc\">hash</span>, <span class=\"nc\">value</span>, <span class=\"nc\">false</span><span class=\"p\">)</span><span class=\"c1\">;</span>\n}</code></pre></div><p>      第一层简单，根据 hash 值很快就能找到相应的 Segment，之后就是 Segment 内部的 put 操作了。</p><p>Segment 内部是由 <b>数组+链表</b> 组成的。</p><div class=\"highlight\"><pre><code class=\"language-text\">final V put(K key, int hash, V value, boolean onlyIfAbsent) {\n    // 在往该 segment 写入前，需要先获取该 segment 的独占锁\n    //    先看主流程，后面还会具体介绍这部分内容\n    HashEntry&lt;K,V&gt; node = tryLock() ? null :\n        scanAndLockForPut(key, hash, value);\n    V oldValue;\n    try {\n        // 这个是 segment 内部的数组\n        HashEntry&lt;K,V&gt;[] tab = table;\n        // 再利用 hash 值，求应该放置的数组下标\n        int index = (tab.length - 1) &amp; hash;\n        // first 是数组该位置处的链表的表头\n        HashEntry&lt;K,V&gt; first = entryAt(tab, index);\n\n        // 下面这串 for 循环虽然很长，不过也很好理解，想想该位置没有任何元素和已经存在一个链表这两种情况\n        for (HashEntry&lt;K,V&gt; e = first;;) {\n            if (e != null) {\n                K k;\n                if ((k = e.key) == key ||\n                    (e.hash == hash &amp;&amp; key.equals(k))) {\n                    oldValue = e.value;\n                    if (!onlyIfAbsent) {\n                        // 覆盖旧值\n                        e.value = value;\n                        ++modCount;\n                    }\n                    break;\n                }\n                // 继续顺着链表走\n                e = e.next;\n            }\n            else {\n                // node 到底是不是 null，这个要看获取锁的过程，不过和这里都没有关系。\n                // 如果不为 null，那就直接将它设置为链表表头；如果是null，初始化并设置为链表表头。\n                if (node != null)\n                    node.setNext(first);\n                else\n                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);\n\n                int c = count + 1;\n                // 如果超过了该 segment 的阈值，这个 segment 需要扩容\n                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)\n                    rehash(node); // 扩容后面也会具体分析\n                else\n                    // 没有达到阈值，将 node 放到数组 tab 的 index 位置，\n                    // 其实就是将新的节点设置成原链表的表头\n                    setEntryAt(tab, index, node);\n                ++modCount;\n                count = c;\n                oldValue = null;\n                break;\n            }\n        }\n    } finally {\n        // 解锁\n        unlock();\n    }\n    return oldValue;\n}</code></pre></div><p>      整体流程还是比较简单的，由于有独占锁的保护，所以 segment 内部的操作并不复杂。至于这里面的并发问题，我们稍后再进行介绍。</p><p>      到这里 put 操作就结束了，接下来，我们说一说其中几步关键的操作。</p><p><b>初始化槽: ensureSegment</b></p><p>      ConcurrentHashMap 初始化的时候会初始化第一个槽 segment[0]，对于其他槽来说，在插入第一个值的时候进行初始化。</p><p>      这里需要考虑并发，因为很可能会有多个线程同时进来初始化同一个槽 segment[k]，不过只要有一个成功了就可以。</p><div class=\"highlight\"><pre><code class=\"language-text\">private Segment&lt;K,V&gt; ensureSegment(int k) {\n    final Segment&lt;K,V&gt;[] ss = this.segments;\n    long u = (k &lt;&lt; SSHIFT) + SBASE; // raw offset\n    Segment&lt;K,V&gt; seg;\n    if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == null) {\n        // 这里看到为什么之前要初始化 segment[0] 了，\n        // 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]\n        // 为什么要用“当前”，因为 segment[0] 可能早就扩容过了\n        Segment&lt;K,V&gt; proto = ss[0];\n        int cap = proto.table.length;\n        float lf = proto.loadFactor;\n        int threshold = (int)(cap * lf);\n\n        // 初始化 segment[k] 内部的数组\n        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])new HashEntry[cap];\n        if ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n            == null) { // 再次检查一遍该槽是否被其他线程初始化了。\n\n            Segment&lt;K,V&gt; s = new Segment&lt;K,V&gt;(lf, threshold, tab);\n            // 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出\n            while ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))\n                   == null) {\n                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))\n                    break;\n            }\n        }\n    }\n    return seg;\n}</code></pre></div><p>      总的来说，ensureSegment(int k) 比较简单，对于并发操作使用 CAS 进行控制。</p><p><b>获取写入锁: scanAndLockForPut</b></p><p>      前面我们看到，在往某个 segment 中 put 的时候，首先会调用 node = tryLock() ? null : scanAndLockForPut(key, hash, value)，也就是说先进行一次 tryLock() 快速获取该 segment 的独占锁，如果失败，那么进入到 scanAndLockForPut 这个方法来获取锁。</p><p>下面我们来具体分析这个方法中是怎么控制加锁的。</p><div class=\"highlight\"><pre><code class=\"language-text\">private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) {\n    HashEntry&lt;K,V&gt; first = entryForHash(this, hash);\n    HashEntry&lt;K,V&gt; e = first;\n    HashEntry&lt;K,V&gt; node = null;\n    int retries = -1; // negative while locating node\n\n    // 循环获取锁\n    while (!tryLock()) {\n        HashEntry&lt;K,V&gt; f; // to recheck first below\n        if (retries &lt; 0) {\n            if (e == null) {\n                if (node == null) // speculatively create node\n                    // 进到这里说明数组该位置的链表是空的，没有任何元素\n                    // 当然，进到这里的另一个原因是 tryLock() 失败，所以该槽存在并发，不一定是该位置\n                    node = new HashEntry&lt;K,V&gt;(hash, key, value, null);\n                retries = 0;\n            }\n            else if (key.equals(e.key))\n                retries = 0;\n            else\n                // 顺着链表往下走\n                e = e.next;\n        }\n        // 重试次数如果超过 MAX_SCAN_RETRIES（单核1多核64），那么不抢了，进入到阻塞队列等待锁\n        //    lock() 是阻塞方法，直到获取锁后返回\n        else if (++retries &gt; MAX_SCAN_RETRIES) {\n            lock();\n            break;\n        }\n        else if ((retries &amp; 1) == 0 &amp;&amp;\n                 // 这个时候是有大问题了，那就是有新的元素进到了链表，成为了新的表头\n                 //     所以这边的策略是，相当于重新走一遍这个 scanAndLockForPut 方法\n                 (f = entryForHash(this, hash)) != first) {\n            e = first = f; // re-traverse if entry changed\n            retries = -1;\n        }\n    }\n    return node;\n}</code></pre></div><p>      这个方法有两个出口，一个是 tryLock() 成功了，循环终止，另一个就是重试次数超过了 MAX_SCAN_RETRIES，进到 lock() 方法，此方法会阻塞等待，直到成功拿到独占锁。</p><p>      这个方法就是看似复杂，但是其实就是做了一件事，那就是<b>获取该 segment 的独占锁</b>，如果需要的话顺便实例化了一下 node。</p><p><b>扩容: rehash</b></p><p>      重复一下，segment 数组不能扩容，扩容是 segment 数组某个位置内部的数组 HashEntry\\[] 进行扩容，扩容后，容量为原来的 2 倍。</p><p>      首先，我们要回顾一下触发扩容的地方，put 的时候，如果判断该值的插入会导致该 segment 的元素个数超过阈值，那么先进行扩容，再插值，读者这个时候可以回去 put 方法看一眼。</p><p>      该方法不需要考虑并发，因为到这里的时候，是持有该 segment 的独占锁的。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。\nprivate void rehash(HashEntry&lt;K,V&gt; node) {\n    HashEntry&lt;K,V&gt;[] oldTable = table;\n    int oldCapacity = oldTable.length;\n    // 2 倍\n    int newCapacity = oldCapacity &lt;&lt; 1;\n    threshold = (int)(newCapacity * loadFactor);\n    // 创建新数组\n    HashEntry&lt;K,V&gt;[] newTable =\n        (HashEntry&lt;K,V&gt;[]) new HashEntry[newCapacity];\n    // 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’\n    int sizeMask = newCapacity - 1;\n\n    // 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置\n    for (int i = 0; i &lt; oldCapacity ; i++) {\n        // e 是链表的第一个元素\n        HashEntry&lt;K,V&gt; e = oldTable[i];\n        if (e != null) {\n            HashEntry&lt;K,V&gt; next = e.next;\n            // 计算应该放置在新数组中的位置，\n            // 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19\n            int idx = e.hash &amp; sizeMask;\n            if (next == null)   // 该位置处只有一个元素，那比较好办\n                newTable[idx] = e;\n            else { // Reuse consecutive sequence at same slot\n                // e 是链表表头\n                HashEntry&lt;K,V&gt; lastRun = e;\n                // idx 是当前链表的头结点 e 的新位置\n                int lastIdx = idx;\n\n                // 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的\n                for (HashEntry&lt;K,V&gt; last = next;\n                     last != null;\n                     last = last.next) {\n                    int k = last.hash &amp; sizeMask;\n                    if (k != lastIdx) {\n                        lastIdx = k;\n                        lastRun = last;\n                    }\n                }\n                // 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置\n                newTable[lastIdx] = lastRun;\n                // 下面的操作是处理 lastRun 之前的节点，\n                //    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中\n                for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {\n                    V v = p.value;\n                    int h = p.hash;\n                    int k = h &amp; sizeMask;\n                    HashEntry&lt;K,V&gt; n = newTable[k];\n                    newTable[k] = new HashEntry&lt;K,V&gt;(h, p.key, v, n);\n                }\n            }\n        }\n    }\n    // 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部\n    int nodeIndex = node.hash &amp; sizeMask; // add the new node\n    node.setNext(newTable[nodeIndex]);\n    newTable[nodeIndex] = node;\n    table = newTable;\n}</code></pre></div><p>      这里的扩容比之前的 HashMap 要复杂一些，代码难懂一点。上面有两个挨着的 for 循环，第一个 for 有什么用呢？</p><p>      仔细一看发现，如果没有第一个 for 循环，也是可以工作的，但是，这个 for 循环下来，如果 lastRun 的后面还有比较多的节点，那么这次就是值得的。因为我们只需要克隆 lastRun 前面的节点，后面的一串节点跟着 lastRun 走就是了，不需要做任何操作。</p><p>      我觉得 Doug Lea 的这个想法也是挺有意思的，不过比较坏的情况就是每次 lastRun 都是链表的最后一个元素或者很靠后的元素，那么这次遍历就有点浪费了。<b>不过 Doug Lea 也说了，根据统计，如果使用默认的阈值，大约只有 1/6 的节点需要克隆</b>。</p><p><b>get 过程分析</b></p><p>      相对于 put 来说，get 真的不要太简单。</p><ol><li>计算 hash 值，找到 segment 数组中的具体位置，或我们前面用的“槽”</li><li>槽中也是一个数组，根据 hash 找到数组中具体的位置</li><li>到这里是链表了，顺着链表进行查找即可</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">public V get(Object key) {\n    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead\n    HashEntry&lt;K,V&gt;[] tab;\n    // 1. hash 值\n    int h = hash(key);\n    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;\n    // 2. 根据 hash 找到对应的 segment\n    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;\n        (tab = s.table) != null) {\n        // 3. 找到segment 内部数组相应位置的链表，遍历\n        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile\n                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);\n             e != null; e = e.next) {\n            K k;\n            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))\n                return e.value;\n        }\n    }\n    return null;\n}</code></pre></div><p><b>并发问题分析</b></p><p>      现在我们已经说完了 put 过程和 get 过程，我们可以看到 get 过程中是没有加锁的，那自然我们就需要去考虑并发问题。</p><p>      加节点的操作 put 和删除节点的操作 remove 都是要加 segment 上的独占锁的，所以它们之间自然不会有问题，我们需要考虑的问题就是 get 的时候在同一个 segment 中发生了 put 或 remove 操作。</p><ol><li><b>put 操作的线程安全性。</b><br/></li><ol><li>初始化槽，这个我们之前就说过了，使用了 CAS 来初始化 Segment 中的数组。</li><li>添加节点到链表的操作是插入到表头的，所以，如果这个时候 get 操作在链表遍历的过程已经到了中间，是不会影响的。当然，另一个并发问题就是 get 操作在 put 之后，需要保证刚刚插入表头的节点被读取，这个依赖于 setEntryAt 方法中使用的 UNSAFE.putOrderedObject。</li><li>扩容。扩容是新创建了数组，然后进行迁移数据，最后面将 newTable 设置给属性 table。所以，如果 get 操作此时也在进行，那么也没关系，如果 get 先行，那么就是在旧的 table 上做查询操作；而 put 先行，那么 put 操作的可见性保证就是 table 使用了 volatile 关键字。</li></ol><li><b>remove 操作的线程安全性。</b><br/>1.remove 操作我们没有分析源码，所以这里说的读者感兴趣的话还是需要到源码中去求实一下的。<br/>2.get 操作需要遍历链表，但是 remove 操作会&#34;破坏&#34;链表。<br/>3.如果 remove 破坏的节点 get 操作已经过去了，那么这里不存在任何问题。<br/>4.如果 remove 先破坏了一个节点，分两种情况考虑。 </li></ol><ul><li>如果此节点是头结点，那么需要将头结点的 next 设置为数组该位置的元素，table 虽然使用了 volatile 修饰，但是 volatile 并不能提供数组内部操作的可见性保证，所以源码中使用了 UNSAFE 来操作数组，请看方法 setEntryAt。</li><li>如果要删除的节点不是头结点，它会将要删除节点的后继节点接到前驱节点中，这里的并发保证就是 next 属性是 volatile 的。</li></ul><p><b>总结</b></p><p>看了这么多不知道大家会不会看得云里雾里，用简单的话总结一下就是：从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>未完待续，由于篇幅有点长，只好分开写，java1.8的ConcurrentHashMap的具体实现请看下一篇<a href=\"https://zhuanlan.zhihu.com/p/42839069\" class=\"internal\">第四天：ConcurrentHashMap全解析（下）</a></b></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }, 
                {
                    "tag": "ConcurrentHashMap", 
                    "tagLink": "https://api.zhihu.com/topics/20033943"
                }
            ], 
            "comments": [
                {
                    "userName": "谷哥", 
                    "userLink": "https://www.zhihu.com/people/03ea6b135ce666753b8f3f9051ee57ea", 
                    "content": "<p>惊了,两三天没看到更新文章,一进来发现被知乎永封了...如果作者还在写的话,可以给我其他文章的地址嘛?</p>", 
                    "likes": 2, 
                    "childComments": [
                        {
                            "userName": "大学不过四年游矣", 
                            "userLink": "https://www.zhihu.com/people/72bae0debfba0487d41450e6986b8218", 
                            "content": "对啊，哭死了，狗乎犯神经病，把博主这么好的人封了。博主才是真的践行了开源原则，让大家都了解计算机，深入浅出地讲解那些复杂的知识点。", 
                            "likes": 1, 
                            "replyToAuthor": "谷哥"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42703011", 
            "userName": "张晓康", 
            "userLink": "https://www.zhihu.com/people/f0a29ad667f017ecc4f313d8c176525a", 
            "upvote": 26, 
            "title": "第三天：HashMap为什么是线程不安全的", 
            "content": "<p>      大家都知道HasnMap在多线程的场景中是不安全的，为什么呢？首先要从它的底层数据结构说起……</p><p><b>JDK7中的HashMap</b></p><p>       HashMap底层维护一个数组，数组中的每一项都是一个Entry</p><div class=\"highlight\"><pre><code class=\"language-abap\">transient Entry&lt;K,V&gt;[] table;</code></pre></div><p>      我们向 HashMap 中所放置的对象实际上是存储在该数组当中； 而Map中的key，value则以Entry的形式存放在数组中</p><div class=\"highlight\"><pre><code class=\"language-abap\">static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {\n        final K key;\n        V value;\n        Entry&lt;K,V&gt; next;\n        int hash;</code></pre></div><p>      而这个Entry应该放在数组的哪一个位置上（这个位置通常称为位桶或者hash桶，即hash值相同的Entry会放在同一位置，用链表相连），是通过key的hashCode来计算的。</p><div class=\"highlight\"><pre><code class=\"language-abap\">final int hash(Object k) {\n        int h = 0;\n        h ^= k.hashCode();\n\n        h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);\n        return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);\n    }</code></pre></div><p>      通过hash计算出来的值将会使用indexFor方法找到它应该所在的table下标：</p><div class=\"highlight\"><pre><code class=\"language-abap\">static int indexFor(int h, int length) {\n        return h &amp; (length-1);\n    }</code></pre></div><p>      这个方法其实相当于对table.length取模。</p><p>      当两个key通过hashCode计算相同时，则发生了hash冲突(碰撞)，HashMap解决hash冲突的方式是用链表。</p><p>      当发生hash冲突时，则将存放在数组中的Entry设置为新值的next（这里要注意的是，比如A和B都hash后都映射到下标i中，之前已经有A了，当map.put(B)时，将B放到下标i中，A则为B的next，所以新值存放在数组中，旧值在新值的链表上）</p><p>示意图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4786adefa190b1c5c872adaccfa3efcb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"508\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"508\" data-original=\"https://pic4.zhimg.com/v2-4786adefa190b1c5c872adaccfa3efcb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;508&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"508\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"508\" data-original=\"https://pic4.zhimg.com/v2-4786adefa190b1c5c872adaccfa3efcb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4786adefa190b1c5c872adaccfa3efcb_b.jpg\"/></figure><p>所以当hash冲突很多时，HashMap退化成链表。</p><p><b>总结一下map.put后的过程：</b></p><p>      当向 HashMap 中 put 一对键值时，它会根据 key的 hashCode 值计算出一个位置， 该位置就是此对象准备往数组中存放的位置。 </p><p>      如果该位置没有对象存在，就将此对象直接放进数组当中；如果该位置已经有对象存在了，则顺着此存在的对象的链开始寻找(为了判断是否值相同，map不允许&lt;key,value&gt;键值对重复)， 如果此链上有对象的话，再去使用 equals方法进行比较，如果对此链上的每个对象的 equals 方法比较都为 false，则将该对象放到数组当中，然后将数组中该位置以前存在的那个对象链接到此对象的后面。 </p><p>      值得注意的是，当key为null时，都放到table[0]中</p><div class=\"highlight\"><pre><code class=\"language-abap\">private V putForNullKey(V value) {\n        for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) {\n            if (e.key == null) {\n                V oldValue = e.value;\n                e.value = value;\n                e.recordAccess(this);\n                return oldValue;\n            }\n        }\n        modCount++;\n        addEntry(0, null, value, 0);\n        return null;\n    }</code></pre></div><p>      当size大于threshold时，会发生扩容。</p><p><b>threshold=capacity*loadFactor</b></p><ul><li>capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。</li><li>loadFactor：负载因子，默认为 0.75。</li><li>threshold：扩容的阈值，等于 capacity * loadFactor</li></ul><div class=\"highlight\"><pre><code class=\"language-abap\">void addEntry(int hash, K key, V value, int bucketIndex) {\n        if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {\n            resize(2 * table.length);\n            hash = (null != key) ? hash(key) : 0;\n            bucketIndex = indexFor(hash, table.length);\n        }\n\n        createEntry(hash, key, value, bucketIndex);\n    }</code></pre></div><p>      jdk7中resize，只有当 size&gt;=threshold并且 table中的那个槽中已经有Entry时，才会发生resize。即有可能虽然size&gt;=threshold，但是必须等到每个槽都至少有一个Entry时，才会扩容。还有注意每次resize都会扩大一倍容量</p><p><b>JDK8中的HashMap</b></p><p>      一直到JDK7为止，HashMap的结构都是这么简单，基于一个数组以及多个链表的实现，hash值冲突的时候，就将对应节点以链表的形式存储。</p><p>      这样子的HashMap性能上就抱有一定疑问，如果说成百上千个节点在hash时发生碰撞，存储一个链表中，那么如果要查找其中一个节点，那就不可避免的花费O(N)的查找时间，这将是多么大的性能损失。这个问题终于在JDK8中得到了解决。在最坏的情况下，链表查找的时间复杂度为O(n),而红黑树一直是O(logn),这样会提高HashMap的效率。</p><p>      JDK7中HashMap采用的是位桶+链表的方式，即我们常说的散列链表的方式，而JDK8中采用的是位桶+链表/红黑树（有关红黑树请查看<a href=\"https://zhuanlan.zhihu.com/p/37470948\" class=\"internal\">数据结构和算法（十一）：红黑树</a>）的方式，也是非线程安全的。当某个位桶的链表的长度达到某个阀值的时候，这个链表就将转换成红黑树。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e02ae02928c0b0c27079c7f638498bb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"387\" class=\"content_image\" width=\"329\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;329&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"329\" data-rawheight=\"387\" class=\"content_image lazy\" width=\"329\" data-actualsrc=\"https://pic1.zhimg.com/v2-e02ae02928c0b0c27079c7f638498bb0_b.jpg\"/></figure><p>      JDK8中，当同一个hash值的节点数大于8时，将不再以单链表的形式存储了，会被调整成一颗红黑树（上图中null节点没画）。这就是JDK7与JDK8中HashMap实现的最大区别。</p><p><b>接下来，我们来看下JDK8中HashMap的源码实现</b>。</p><p>JDK中Entry的名字变成了Node，原因是和红黑树的实现TreeNode相关联。</p><div class=\"highlight\"><pre><code class=\"language-abap\">transient Node&lt;K,V&gt;[] table;</code></pre></div><p>当冲突节点数大于8-1时，转换成红黑树。</p><div class=\"highlight\"><pre><code class=\"language-abap\">static final int TREEIFY_THRESHOLD = 8;</code></pre></div><p>以put方法在JDK8中有了很大的改变</p><div class=\"highlight\"><pre><code class=\"language-abap\">public V put(K key, V value) {\n        return putVal(hash(key), key, value, false, true);\n }\n\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab;\n\tNode&lt;K,V&gt; p; \n\tint n, i;\n\t//如果当前map中无数据，执行resize方法。并且返回n\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n\t //如果要插入的键值对要存放的这个位置刚好没有元素，那么把他封装成Node对象，放在这个位置上就完事了\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n\t//否则的话，说明这上面有元素\n        else {\n            Node&lt;K,V&gt; e; K k;\n\t    //如果这个元素的key与要插入的一样，那么就替换一下，也完事。\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n\t    //1.如果当前节点是TreeNode类型的数据，执行putTreeVal方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else {\n\t\t//还是遍历这条链子上的数据，跟jdk7没什么区别\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n\t\t\t//2.完成了操作后多做了一件事情，判断，并且可能执行treeifyBin方法\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null) //true || --\n                    e.value = value;\n\t\t   //3.\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n\t//判断阈值，决定是否扩容\n        if (++size &gt; threshold)\n            resize();\n\t    //4.\n        afterNodeInsertion(evict);\n        return null;\n    }</code></pre></div><p>treeifyBin()就是将链表转换成红黑树。</p><p>之前的indefFor()方法消失 了，直接用(tab.length-1)&amp;hash，所以看到这个，代表的就是数组的下角标。</p><div class=\"highlight\"><pre><code class=\"language-abap\">static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    }</code></pre></div><h2><b>下面开始正题：为什么说HashMap是线程不安全的呢？它在多线程环境下，会发生什么情况呢？</b></h2><p><b>1. resize死循环</b></p><p>      我们都知道HashMap初始容量大小为16,一般来说，当有数据要插入时，都会检查容量有没有超过设定的thredhold，如果超过，需要增大Hash表的尺寸，但是这样一来，整个Hash表里的元素都需要被重算一遍。这叫rehash，这个成本相当的大。</p><div class=\"highlight\"><pre><code class=\"language-abap\">void resize(int newCapacity) {\n        Entry[] oldTable = table;\n        int oldCapacity = oldTable.length;\n        if (oldCapacity == MAXIMUM_CAPACITY) {\n            threshold = Integer.MAX_VALUE;\n            return;\n        }\n \n        Entry[] newTable = new Entry[newCapacity];\n        transfer(newTable, initHashSeedAsNeeded(newCapacity));\n        table = newTable;\n        threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-abap\">void transfer(Entry[] newTable, boolean rehash) {\n        int newCapacity = newTable.length;\n        for (Entry&lt;K,V&gt; e : table) {\n            while(null != e) {\n                Entry&lt;K,V&gt; next = e.next;\n                if (rehash) {\n                    e.hash = null == e.key ? 0 : hash(e.key);\n                }\n                int i = indexFor(e.hash, newCapacity);\n                e.next = newTable[i];\n                newTable[i] = e;\n                e = next;\n            }\n        }\n}</code></pre></div><p>大概看下transfer：</p><ol><li>对索引数组中的元素遍历</li><li>对链表上的每一个节点遍历：用 next 取得要转移那个元素的下一个，将 e 转移到新 Hash 表的头部，使用头插法插入节点。</li><li>循环2，直到链表节点全部转移</li><li>循环1，直到所有索引数组全部转移</li></ol><p>      经过这几步，我们会发现转移的时候是逆序的。假如转移前链表顺序是1-&gt;2-&gt;3，那么转移后就会变成3-&gt;2-&gt;1。这时候就有点头绪了，死锁问题不就是因为1-&gt;2的同时2-&gt;1造成的吗？所以，HashMap 的死锁问题就出在这个<code>transfer()</code>函数上。</p><p><b>1.1 单线程 rehash 详细演示</b></p><p>单线程情况下，rehash 不会出现任何问题：</p><ul><li>假设hash算法就是最简单的 key mod table.length（也就是数组的长度）。</li><li>最上面的是old hash 表，其中的Hash表的 size = 2, 所以 key = 3, 7, 5，在 mod 2以后碰撞发生在 table[1]</li><li>接下来的三个步骤是 Hash表 resize 到4，并将所有的 <code>&lt;key,value&gt;</code> 重新rehash到新 Hash 表的过程</li></ul><p>如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0269c921771891dad306c52cd6a47e26_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-0269c921771891dad306c52cd6a47e26_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-0269c921771891dad306c52cd6a47e26_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0269c921771891dad306c52cd6a47e26_b.jpg\"/></figure><p><b>1.2 多线程 rehash 详细演示</b></p><p>为了思路更清晰，我们只将关键代码展示出来</p><div class=\"highlight\"><pre><code class=\"language-text\">while(null != e) {\n    Entry&lt;K,V&gt; next = e.next;\n    e.next = newTable[i];\n    newTable[i] = e;\n    e = next;\n}</code></pre></div><ol><li><code>Entry&lt;K,V&gt; next = e.next;</code>——因为是单链表，如果要转移头指针，一定要保存下一个结点，不然转移后链表就丢了</li><li><code>e.next = newTable[i];</code>——e 要插入到链表的头部，所以要先用 e.next 指向新的 Hash 表第一个元素（为什么不加到新链表最后？因为复杂度是 O（N））</li><li><code>newTable[i] = e;</code>——现在新 Hash 表的头指针仍然指向 e 没转移前的第一个元素，所以需要将新 Hash 表的头指针指向 e</li><li><code>e = next</code>——转移 e 的下一个结点</li></ol><p>假设这里有两个线程同时执行了<code>put()</code>操作，并进入了<code>transfer()</code>环节</p><div class=\"highlight\"><pre><code class=\"language-abap\">while(null != e) {\n    Entry&lt;K,V&gt; next = e.next; //线程1执行到这里被调度挂起了\n    e.next = newTable[i];\n    newTable[i] = e;\n    e = next;\n}</code></pre></div><p>那么现在的状态为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2ccb0dfebc58f71bb6a64027afc7fa2a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-2ccb0dfebc58f71bb6a64027afc7fa2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-2ccb0dfebc58f71bb6a64027afc7fa2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2ccb0dfebc58f71bb6a64027afc7fa2a_b.jpg\"/></figure><p>从上面的图我们可以看到，因为线程1的 e 指向了 key(3)，而 next 指向了 key(7)，在线程2 rehash 后，就指向了线程2 rehash 后的链表。</p><p>然后线程1被唤醒了：</p><ol><li>执行e.next = newTable[i]，于是 key(3)的 next 指向了线程1的新 Hash 表，因为新 Hash 表为空，所以e.next = null，</li><li>执行newTable[i] = e，所以线程1的新 Hash 表第一个元素指向了线程2新 Hash 表的 key(3)。好了，e 处理完毕。</li><li>执行e = next，将 e 指向 next，所以新的 e 是 key(7)</li></ol><p>然后该执行 key(3)的 next 节点 key(7)了:</p><ol><li>现在的 e 节点是 key(7)，首先执行<code>Entry&lt;K,V&gt; next = e.next</code>,那么 next 就是 key(3)了</li><li>执行<code>e.next = newTable[i]</code>，于是key(7) 的 next 就成了 key(3)</li><li>执行<code>newTable[i] = e</code>，那么线程1的新 Hash 表第一个元素变成了 key(7)</li><li>执行<code>e = next</code>，将 e 指向 next，所以新的 e 是 key(3)</li></ol><p>这时候的状态图为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-19b22cc0fd11cc40bdd4804966540402_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-19b22cc0fd11cc40bdd4804966540402_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-19b22cc0fd11cc40bdd4804966540402_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-19b22cc0fd11cc40bdd4804966540402_b.jpg\"/></figure><p>然后又该执行 key(7)的 next 节点 key(3)了：</p><ol><li>现在的 e 节点是 key(3)，首先执行<code>Entry&lt;K,V&gt; next = e.next</code>,那么 next 就是 null</li><li>执行<code>e.next = newTable[i]</code>，于是key(3) 的 next 就成了 key(7)</li><li>执行<code>newTable[i] = e</code>，那么线程1的新 Hash 表第一个元素变成了 key(3)</li><li>执行<code>e = next</code>，将 e 指向 next，所以新的 e 是 key(7)</li></ol><p>这时候的状态如图所示</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-581c01dd3b9f11b52fce0bb16b8c6574_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-581c01dd3b9f11b52fce0bb16b8c6574_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;376&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"376\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-581c01dd3b9f11b52fce0bb16b8c6574_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-581c01dd3b9f11b52fce0bb16b8c6574_b.jpg\"/></figure><p>很明显，环形链表出现了！！当然，现在还没有事情，因为下一个节点是 null，所以<code>transfer()</code>就完成了，等<code>put()</code>的其余过程搞定后，HashMap 的底层实现就是线程1的新 Hash 表了。</p><p><b>景象还原</b></p><p>      假设现在有三个线程：T1,T2,T3；在老数组中的第一个数据也就是e引用的对象，我们称它为A,在新数组中的头两个数据分别为B和C，B.next=C。</p><p>       线程T1运行到e.next=newTable[i]时，线程T2运行到next=e.next;然后线程t1去继续运行，会产生什么效果呢？A.next=B，B.next=C。e指向的对象是B,newTable[i]=A。然后继续运行，e.next=newTable[i],也就是B.next=A;同时A.next=B，继续运行newTable[i] = e,e = next;如果没有其它线程捣乱的话，那么此时e应该是C啊，可惜只是如果，如果有第三个线程T3在线程T1执行e.next = newTable[i]的时候去执行next = e.next;那么就中途改变了next的值，本来是保存C的，但是现在成了A了。总结下现在的情况：e引用A，nextTable[i]引用B，A.next=B,B.next=A。现在明白了吧。会一直这么死锁下去的。<b>（这里面确实有点绕，不过大家多读几遍就能理解了^_^）</b></p><p><b>2. fail-fast</b></p><p>如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</p><p>这个异常意在提醒开发者及早意识到线程安全问题，具体原因请查看</p><a href=\"https://link.zhihu.com/?target=http%3A//my.oschina.net/hosee/blog/612718\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-b82f6f5e4758bfe90a1d2d30adeeb452_180x120.jpg\" data-image-width=\"664\" data-image-height=\"132\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ConcurrentModificationException的原因以及解决措施 - God is a Coder.. - 开源中国</a><p>顺便再记录一个HashMap的问题：</p><p><b>为什么String, Interger这样的wrapper类适合作为键？</b> </p><p>String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。</p>", 
            "topic": [
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": [
                {
                    "userName": "谷哥", 
                    "userLink": "https://www.zhihu.com/people/03ea6b135ce666753b8f3f9051ee57ea", 
                    "content": "<p>太棒了,看过的讲的最明白的HashMap的原理了.</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "谷哥", 
                    "userLink": "https://www.zhihu.com/people/03ea6b135ce666753b8f3f9051ee57ea", 
                    "content": "<p>那可不可以麻烦您,在未来的几天,再把ConcurrentHashMap还有HashTable讲解一下,这俩经常和HashMap一起连着问:</p><p>\"HashMap线程安全么?为什么?\",</p><p>\"ConcurrentHashMap,HashTable为什么线程安全?\",</p><p>\"ConcurrentHashMap和HashTable的实现线程的区别是什么?\",</p><p>\"在多线程下,你更倾向于选择ConcurrentHashMap还是HashTable?\"</p><p>这些问题说实话我没整太明白...</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "张晓康", 
                            "userLink": "https://www.zhihu.com/people/f0a29ad667f017ecc4f313d8c176525a", 
                            "content": "<p>正有此意，敬请期待</p>", 
                            "likes": 2, 
                            "replyToAuthor": "谷哥"
                        }, 
                        {
                            "userName": "谷哥", 
                            "userLink": "https://www.zhihu.com/people/03ea6b135ce666753b8f3f9051ee57ea", 
                            "content": "<p>哇,谢谢,期待啊</p>", 
                            "likes": 0, 
                            "replyToAuthor": "张晓康"
                        }
                    ]
                }, 
                {
                    "userName": "人生", 
                    "userLink": "https://www.zhihu.com/people/8951bbfd3fbbf24b9c4df19ef86c5934", 
                    "content": "<p>表示我公司还是jdk1.6hashmap的特性</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "sudo", 
                    "userLink": "https://www.zhihu.com/people/19e7e7d7c959391dfb711b9df8848526", 
                    "content": "<p>bo主很厉害，学习了</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42613805", 
            "userName": "张晓康", 
            "userLink": "https://www.zhihu.com/people/f0a29ad667f017ecc4f313d8c176525a", 
            "upvote": 2, 
            "title": "第二天：foreach和while的区别(编译之后)", 
            "content": "<h2><b>foreach和while的区别(编译之后)  </b>    </h2><p>      两者的不同之处在于它们背后的运作方式。</p><p>      在while循环里，Perl会读入一行输入，把它存入某个变量并且执行循环主体。然后，它再回头去找其他的输入行。</p><p>      在foreach循环中，整行输入操作符会在列表上下文中执行（因为foreach需要逐行处理列表的内容）。在循环开始执行之前，它必须先将输入全部读进来。</p><p>      当输入大容量的文件时，使用foreach会占用大量的内存。两者的差异会十分明显。因此，最好的做法，通常是尽量使用while循环的简写，让它每次处理一行。</p>", 
            "topic": [
                {
                    "tag": "编译", 
                    "tagLink": "https://api.zhihu.com/topics/19629384"
                }, 
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/41957838", 
            "userName": "张晓康", 
            "userLink": "https://www.zhihu.com/people/f0a29ad667f017ecc4f313d8c176525a", 
            "upvote": 7, 
            "title": "第一天：Arrays.sort和Collection实现原理", 
            "content": "<p>      今天是第一次在这个专栏里写稿，这个专栏自己已经创建了一个月了，但是一直没有时间写东西，其实这个理由我自己都不信，希望自己可以坚持下去，养成每天都能写一篇面试题的习惯，有句话说的很好：<b>当一件事成为习惯,就不再去强求结果了,做这件事本身就觉得很安心。</b></p><p>      有些小伙伴可能是因为要去面试了，才临时抱佛脚看到了这片文章，其实我开设这个专栏不是为了只是应付面试用，而是我在自己的工作中感受到了这些面试题的好处。这不仅仅是一个面试题，而是我们开发的一个理论基础，没有这个基础我们只会知其然而不知其所以然。希望大家能够跟着我一起坚持，养成习惯。回到正题：</p><p><b>Arrays.sort和Collection.sort的实现原理是什么？</b></p><p>事实上Collections.sort方法底层就是调用的array.sort方法，而且不论是Collections.sort或者是Arrays.sort方法，我们可以跟踪一下源码：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ae332f384bc79a68599b8cbc4a1e8bcf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"806\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb\" width=\"806\" data-original=\"https://pic4.zhimg.com/v2-ae332f384bc79a68599b8cbc4a1e8bcf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;806&#39; height=&#39;178&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"806\" data-rawheight=\"178\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"806\" data-original=\"https://pic4.zhimg.com/v2-ae332f384bc79a68599b8cbc4a1e8bcf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ae332f384bc79a68599b8cbc4a1e8bcf_b.jpg\"/></figure><p>往下面看，发现collections.sort方法调用的list.sort</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-eac13c61cd583058b76f905abbf83ea5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1019\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb\" width=\"1019\" data-original=\"https://pic2.zhimg.com/v2-eac13c61cd583058b76f905abbf83ea5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1019&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1019\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1019\" data-original=\"https://pic2.zhimg.com/v2-eac13c61cd583058b76f905abbf83ea5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-eac13c61cd583058b76f905abbf83ea5_b.jpg\"/></figure><p>然后跟踪一下，list里面有个sort方法，但是list是一个接口，肯定是调用子类里面的实现，这里我们demo使用的是一个Arrays.asList方法，所以事实上我们的子类就是arraylist了。OK，看arraylist里面sort实现，选择第一个，为什么不选择第二个呢？简单说就是用Arrays.sort创建的ArrayList对象。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-94f1c4a67d8b0fd698acba8f2ea9a64b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1516\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb\" width=\"1516\" data-original=\"https://pic4.zhimg.com/v2-94f1c4a67d8b0fd698acba8f2ea9a64b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1516&#39; height=&#39;592&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1516\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1516\" data-original=\"https://pic4.zhimg.com/v2-94f1c4a67d8b0fd698acba8f2ea9a64b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-94f1c4a67d8b0fd698acba8f2ea9a64b_b.jpg\"/></figure><p>OK，发现里面调用的Arrays.sort(a, c); a是list,c是一个比较器，我们来看一下这个方法</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a07580aa6e2417600dc83c897d814b57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1734\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb\" width=\"1734\" data-original=\"https://pic4.zhimg.com/v2-a07580aa6e2417600dc83c897d814b57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1734&#39; height=&#39;692&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1734\" data-rawheight=\"692\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1734\" data-original=\"https://pic4.zhimg.com/v2-a07580aa6e2417600dc83c897d814b57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a07580aa6e2417600dc83c897d814b57_b.jpg\"/></figure><p>我们没有写比较器，所以用的第二项，LegacyMergeSort.userRequested这个bool值是什么呢？</p><p>跟踪这个值，我们发现有这样的一段定义：</p><div class=\"highlight\"><pre><code class=\"language-text\">  &gt; Old merge sort implementation can be selected (for\n  &gt;  compatibility with broken comparators) using a system property.\n  &gt;  Cannot be a static boolean in the enclosing class due to\n  &gt;  circular dependencies. To be removed in a future release.\n\n  反正是一种老的归并排序，不用管了现在默认是关的</code></pre></div><p>OK，我们走的是sort(a)这个方法，接着进入这个</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-27191d2be9570b5657760455da1bd99a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1732\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb\" width=\"1732\" data-original=\"https://pic3.zhimg.com/v2-27191d2be9570b5657760455da1bd99a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1732&#39; height=&#39;570&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1732\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1732\" data-original=\"https://pic3.zhimg.com/v2-27191d2be9570b5657760455da1bd99a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-27191d2be9570b5657760455da1bd99a_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">       static void sort(Object[] a, int lo, int hi, Object[] work, int workBase, int workLen) {\n                 assert a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;\n\n                 int nRemaining  = hi - lo;\n                 if (nRemaining &lt; 2)\n                     return;  // array的大小为0或者1就不用排了\n\n                 // 当数组大小小于MIN_MERGE(32)的时候，就用一个&#34;mini-TimSort&#34;的方法排序，jdk1.7新加\n                 if (nRemaining &lt; MIN_MERGE) {\n                    //这个方法比较有意思，其实就是将我们最长的递减序列，找出来，然后倒过来\n                     int initRunLen = countRunAndMakeAscending(a, lo, hi);\n                     //长度小于32的时候，是使用binarySort的\n                     binarySort(a, lo, hi, lo + initRunLen);\n                     return;\n                 }\n                //先扫描一次array，找到已经排好的序列，然后再用刚才的mini-TimSort，然后合并，这就是TimSort的核心思想\n                 ComparableTimSort ts = new ComparableTimSort(a, work, workBase, workLen);\n                 int minRun = minRunLength(nRemaining);\n                 do {\n                     // Identify next run\n                     int runLen = countRunAndMakeAscending(a, lo, hi);\n\n                     // If run is short, extend to min(minRun, nRemaining)\n                     if (runLen &lt; minRun) {\n                         int force = nRemaining &lt;= minRun ? nRemaining : minRun;\n                         binarySort(a, lo, lo + force, lo + runLen);\n                         runLen = force;\n                     }\n\n                     // Push run onto pending-run stack, and maybe merge\n                     ts.pushRun(lo, runLen);\n                     ts.mergeCollapse();\n\n                     // Advance to find next run\n                     lo += runLen;\n                     nRemaining -= runLen;\n                 } while (nRemaining != 0);\n\n                 // Merge all remaining runs to complete sort\n                 assert lo == hi;\n                 ts.mergeForceCollapse();\n                 assert ts.stackSize == 1;\n         }</code></pre></div><p>回到5，我们可以看到当我们写了比较器的时候就调用了TimSort.sort方法，源码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">          static &lt;T&gt; void sort(T[] a, int lo, int hi, Comparator&lt;? super T&gt; c,\n                                  T[] work, int workBase, int workLen) {\n                 assert c != null &amp;&amp; a != null &amp;&amp; lo &gt;= 0 &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;\n\n                 int nRemaining  = hi - lo;\n                 if (nRemaining &lt; 2)\n                     return;  // Arrays of size 0 and 1 are always sorted\n\n                 // If array is small, do a &#34;mini-TimSort&#34; with no merges\n                 if (nRemaining &lt; MIN_MERGE) {\n                     int initRunLen = countRunAndMakeAscending(a, lo, hi, c);\n                     binarySort(a, lo, hi, lo + initRunLen, c);\n                     return;\n                 }\n\n                 /**\n                  * March over the array once, left to right, finding natural runs,\n                  * extending short natural runs to minRun elements, and merging runs\n                  * to maintain stack invariant.\n                  */\n           TimSort&lt;T&gt; ts = new TimSort&lt;&gt;(a, c, work, workBase, workLen);\n                int minRun = minRunLength(nRemaining);\n                do {\n                    // Identify next run\n                    int runLen = countRunAndMakeAscending(a, lo, hi, c);\n\n                    // If run is short, extend to min(minRun, nRemaining)\n                    if (runLen &lt; minRun) {\n                        int force = nRemaining &lt;= minRun ? nRemaining : minRun;\n                        binarySort(a, lo, lo + force, lo + runLen, c);\n                        runLen = force;\n                    }\n\n                    // Push run onto pending-run stack, and maybe merge\n                    ts.pushRun(lo, runLen);\n                    ts.mergeCollapse();\n\n                    // Advance to find next run\n                    lo += runLen;\n                    nRemaining -= runLen;\n                } while (nRemaining != 0);\n\n                // Merge all remaining runs to complete sort\n                assert lo == hi;\n                ts.mergeForceCollapse();\n                assert ts.stackSize == 1;\n      }</code></pre></div><p>和上面的sort方法是一样的，其实也就是TimSort的源代码</p><h2>总结</h2><p>不论是Collections.sort方法或者是Arrays.sort方法，底层实现都是TimSort实现的，这是jdk1.7新增的，以前是归并排序。TimSort算法就是找到已经排好序数据的子序列，然后对剩余部分排序，然后合并起来</p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_192384091"
}
