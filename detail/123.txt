{
    "followers": [
        "https://www.zhihu.com/people/zhang-li-bin-22-17", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/hiyzx"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/90162419", 
            "userName": "奔跑", 
            "userLink": "https://www.zhihu.com/people/8eaa7dc56ddfb45c8fea14fce0da9196", 
            "upvote": 0, 
            "title": "SpringBoot集成JWT实现权限认证", 
            "content": "<blockquote> 上一篇文章<a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/4mQsN3cZjYtjmn333thSQg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《一分钟带你了解JWT认证！》</a>介绍了JWT的组成和认证原理，本文将介绍下SpringBoot整合JWT实现认证的过程，带你更深入的了解下JWT。<br/> </blockquote><h3><b>一、JWT认证流程</b> </h3><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;414&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_b.jpg\"/></figure><p>认证流程如下：</p><ol><li>用户使用账号和密码发出post请求；</li><li>服务器使用私钥创建一个jwt；</li><li>服务器返回这个jwt给浏览器；</li><li>浏览器将该jwt串在请求头中像服务器发送请求；</li><li>服务器验证该jwt；</li><li>返回响应的资源给浏览器。</li></ol><h3><b>二、SpringBoot整合JWT</b> </h3><p>新建一个spring boot项目spring-boot-jwt，按照下面步骤操作。</p><ol><li>pom.xml引入jar包</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 引入jwt--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.auth0&lt;/groupId&gt;\n    &lt;artifactId&gt;java-jwt&lt;/artifactId&gt;\n    &lt;version&gt;3.8.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre></div><ol><li>新建Jwt工具类</li></ol><p>Jwt工具类进行token的生成和认证，工具类代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * @description: Jwt工具类，生成JWT和认证\n * @author: Java碎碎念\n */\npublic class JwtUtil {\n\n    private static final Logger logger = LoggerFactory.getLogger(JwtUtil.class);\n    /**\n     * 密钥\n     */\n    private static final String SECRET = &#34;my_secret&#34;;\n\n    /**\n     * 过期时间\n     **/\n    private static final long EXPIRATION = 1800L;//单位为秒\n\n    /**\n     * 生成用户token,设置token超时时间\n     */\n    public static String createToken(User user) {\n        //过期时间\n        Date expireDate = new Date(System.currentTimeMillis() + EXPIRATION * 1000);\n        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();\n        map.put(&#34;alg&#34;, &#34;HS256&#34;);\n        map.put(&#34;typ&#34;, &#34;JWT&#34;);\n        String token = JWT.create()\n                .withHeader(map)// 添加头部\n                //可以将基本信息放到claims中\n                .withClaim(&#34;id&#34;, user.getId())//userId\n                .withClaim(&#34;userName&#34;, user.getUserName())//userName\n                .withClaim(&#34;name&#34;, user.getName())//name\n                .withExpiresAt(expireDate) //超时设置,设置过期的日期\n                .withIssuedAt(new Date()) //签发时间\n                .sign(Algorithm.HMAC256(SECRET)); //SECRET加密\n        return token;\n    }\n\n    /**\n     * 校验token并解析token\n     */\n    public static Map&lt;String, Claim&gt; verifyToken(String token) {\n        DecodedJWT jwt = null;\n        try {\n            JWTVerifier verifier = JWT.require(Algorithm.HMAC256(SECRET)).build();\n            jwt = verifier.verify(token);\n        } catch (Exception e) {\n            logger.error(e.getMessage());\n            logger.error(&#34;token解码异常&#34;);\n            //解码异常则抛出异常\n            return null;\n        }\n        return jwt.getClaims();\n    }\n\n}\n</code></pre></div><ol><li>添加JWT过滤器</li></ol><p>JWT过滤器中进行token的校验和判断，，token不合法直接返回，合法则解密数据并把数据放到request中供后续使用。</p><p>为了使过滤器生效，需要在启动类添加注解@ServletComponentScan(basePackages = &#34;com.example.springbootjwt.filter&#34;)。</p><p>JWT过滤器代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * JWT过滤器，拦截 /secure的请求\n */\n@Slf4j\n@WebFilter(filterName = &#34;JwtFilter&#34;, urlPatterns = &#34;/secure/*&#34;)\npublic class JwtFilter implements Filter {\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n    }\n\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        final HttpServletRequest request = (HttpServletRequest) req;\n        final HttpServletResponse response = (HttpServletResponse) res;\n\n        response.setCharacterEncoding(&#34;UTF-8&#34;);\n        //获取 header里的token\n        final String token = request.getHeader(&#34;authorization&#34;);\n\n        if (&#34;OPTIONS&#34;.equals(request.getMethod())) {\n            response.setStatus(HttpServletResponse.SC_OK);\n            chain.doFilter(request, response);\n        }\n        // Except OPTIONS, other request should be checked by JWT\n        else {\n\n            if (token == null) {\n                response.getWriter().write(&#34;没有token！&#34;);\n                return;\n            }\n\n            Map&lt;String, Claim&gt; userData = JwtUtil.verifyToken(token);\n            if (userData == null) {\n                response.getWriter().write(&#34;token不合法！&#34;);\n                return;\n            }\n            Integer id = userData.get(&#34;id&#34;).asInt();\n            String name = userData.get(&#34;name&#34;).asString();\n            String userName = userData.get(&#34;userName&#34;).asString();\n            //拦截器 拿到用户信息，放到request中\n            request.setAttribute(&#34;id&#34;, id);\n            request.setAttribute(&#34;name&#34;, name);\n            request.setAttribute(&#34;userName&#34;, userName);\n            chain.doFilter(req, res);\n        }\n    }\n\n    @Override\n    public void destroy() {\n    }\n}\n</code></pre></div><ol><li>添加登录Controller</li></ol><p>登录Controller进行登录操作，登录成功后生产token并返回。</p><p>登录Controller代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * 登录Controller\n */\n@Slf4j\n@RestController\npublic class LoginController {\n\n    static Map&lt;Integer, User&gt; userMap = new HashMap&lt;&gt;();\n\n    static {\n        //模拟数据库\n        User user1 = new User(1, &#34;zhangsan&#34;, &#34;张三&#34;, &#34;123456&#34;);\n        userMap.put(1, user1);\n        User user2 = new User(2, &#34;lisi&#34;, &#34;李四&#34;, &#34;123123&#34;);\n        userMap.put(2, user2);\n    }\n\n    /**\n     * 模拟用户 登录\n     */\n    @RequestMapping(&#34;/login&#34;)\n    public String login(User user) {\n        for (User dbUser : userMap.values()) {\n            if (dbUser.getUserName().equals(user.getUserName()) &amp;&amp; dbUser.getPassword().equals(user.getPassword())) {\n                log.info(&#34;登录成功！生成token！&#34;);\n                String token = JwtUtil.createToken(dbUser);\n                return token;\n            }\n        }\n        return &#34;&#34;;\n    }\n}\n</code></pre></div><ol><li>添加SecureController</li></ol><p>SecureController中的请求会被JWT过滤器拦截，合法后才能访问。</p><p>SecureController代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * 需要登录后才能访问\n */\n@Slf4j\n@RestController\npublic class SecureController {\n\n    /**\n     * 查询 用户信息，登录后才能访问\n     */\n    @RequestMapping(&#34;/secure/getUserInfo&#34;)\n    public String login(HttpServletRequest request) {\n        Integer id = (Integer) request.getAttribute(&#34;id&#34;);\n        String name = request.getAttribute(&#34;name&#34;).toString();\n        String userName = request.getAttribute(&#34;userName&#34;).toString();\n        return &#34;当前用户信息id=&#34; + id + &#34;,name=&#34; + name + &#34;,userName=&#34; + userName;\n    }\n}\n</code></pre></div><h3><b>三、测试</b> </h3><p>测试分两步，首先访问登录接口，登录成功后获取token，然后拿着token在访问查询用户信息接口。</p><p>1.访问登录接口  </p><p>打开PostMan，访问http://localhost:8080/login?userName=zhangsan&amp;password=123456，登录成功后接口返回token，请求成功截图如下： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d3101a01d03c245de03229ef14fef8b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1153\" data-rawheight=\"461\" class=\"origin_image zh-lightbox-thumb\" width=\"1153\" data-original=\"https://pic1.zhimg.com/v2-d3101a01d03c245de03229ef14fef8b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1153&#39; height=&#39;461&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1153\" data-rawheight=\"461\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1153\" data-original=\"https://pic1.zhimg.com/v2-d3101a01d03c245de03229ef14fef8b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d3101a01d03c245de03229ef14fef8b4_b.jpg\"/></figure><p>2.访问用户信息接口  </p><p>打开PostMan，访问http://localhost:8080/secure/getUserInfo，header里需要携带token，请求成功截图如下： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6ed8a863ffb518b1da2fb094db547ba1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1148\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"1148\" data-original=\"https://pic2.zhimg.com/v2-6ed8a863ffb518b1da2fb094db547ba1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1148&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1148\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1148\" data-original=\"https://pic2.zhimg.com/v2-6ed8a863ffb518b1da2fb094db547ba1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6ed8a863ffb518b1da2fb094db547ba1_b.jpg\"/></figure><p>到此SpringBoot整合JWT的功能已经全部实现，有问题欢迎留言沟通哦！ </p><p>完整源码地址： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/suisui2019/springboot-study\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/suisui2019/s</span><span class=\"invisible\">pringboot-study</span><span class=\"ellipsis\"></span></a></p><p><b>推荐阅读</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/4mQsN3cZjYtjmn333thSQg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1.一分钟带你了解JWT认证！</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/ikyLQu3bqzk_OyejE4tGRQ\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">2.SpringBoot中如何优雅的读取yml配置文件？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/mjCNtTTyGkieERKPP84fVg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3.SpringBoot中如何灵活的实现接口数据的加解密功能？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/REFo0hRqlVjntz-FEWRGnw\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">4.SpringBoot中神奇的@Enable*注解？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/mBG8GGpNMcaz1PzhEqi0WA\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">5.Java中Integer.parseInt和Integer.valueOf，你还傻傻分不清吗？</a></p><hr/><blockquote> 限时领取免费Java相关资料，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo/Kafka、Hadoop、Hbase、Flink等高并发分布式、大数据、机器学习等技术。<br/>关注下方公众号即可免费领取：<br/> </blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-07ab4521440f40f21f36487f27d129fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-07ab4521440f40f21f36487f27d129fd_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "认证", 
                    "tagLink": "https://api.zhihu.com/topics/19573675"
                }, 
                {
                    "tag": "Spring Boot", 
                    "tagLink": "https://api.zhihu.com/topics/20044714"
                }, 
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/90162022", 
            "userName": "奔跑", 
            "userLink": "https://www.zhihu.com/people/8eaa7dc56ddfb45c8fea14fce0da9196", 
            "upvote": 0, 
            "title": "一分钟带你了解JWT认证！", 
            "content": "<h3><b>一、JWT简介</b> </h3><p>JSON Web Token（JWT）是一个开放的标准（RFC 7519），它定义了一个紧凑且自包含的方式，用于在各方之间作为JSON对象安全地传输信息。由于此信息是经过数字签名的，因此可以被验证和信任。</p><p>更多信息可以查看官网：<a href=\"https://link.zhihu.com/?target=https%3A//jwt.io/introduction/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">jwt.io/introduction/</span><span class=\"invisible\"></span></a></p><h3><b>二、JWT认证和session认证的区别</b> </h3><ol><li>session认证</li></ol><p>http协议是一种无状态的协议，而这就意味着如果用户向我们的应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发送的请求，所以为了让我们的应用能识别是哪个用户发出的，我们只能在服务器存储一份用户登陆的信息，这份登陆信息会在响应时传递给浏览器，告诉其保存为cookie，以便下次请求时发送给我们的应用，这样我们的应用个就能识别请求来自哪个用户了，这就是传统的基于sessino认证。</p><ol><li>JWT认证</li></ol><p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或会话信息。这也就意味着JWT认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p><h3><b>三、JWT认证流程</b> </h3><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;414&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-84e86e9b3a4022d12f6ed911609fd3d9_b.jpg\"/></figure><p>认证流程如下：</p><ol><li>用户使用账号和密码发出post请求；</li><li>服务器使用私钥创建一个jwt；</li><li>服务器返回这个jwt给浏览器；</li><li>浏览器将该jwt串在请求头中像服务器发送请求；</li><li>服务器验证该jwt；</li><li>返回响应的资源给浏览器。</li></ol><h3><b>四、JWT组成</b> </h3><p>先来看一张JWT的信息的截图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3af03db9ba10f0eafd2b5091120c99ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1269\" data-rawheight=\"636\" class=\"origin_image zh-lightbox-thumb\" width=\"1269\" data-original=\"https://pic3.zhimg.com/v2-3af03db9ba10f0eafd2b5091120c99ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1269&#39; height=&#39;636&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1269\" data-rawheight=\"636\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1269\" data-original=\"https://pic3.zhimg.com/v2-3af03db9ba10f0eafd2b5091120c99ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3af03db9ba10f0eafd2b5091120c99ee_b.jpg\"/></figure><p>从上图可以看到，JWT含有三部分：头部（header）、载荷（payload）、签名（signature）。</p><ol><li>头部（header）</li></ol><p>JWT的头部有两部分信息：</p><ul><li>声明类型，这里是JWT</li><li>声明加密的算法，通常直接使用HMAC SHA256</li></ul><p>头部示例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n  &#34;alg&#34;: &#34;HS256&#34;,\n  &#34;typ&#34;: &#34;JWT&#34;\n}\n</code></pre></div><p>头部一般使用base64加密，加密后密文：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</p><ol><li>载荷（payload）</li></ol><p>该部分一般存放一些有效的信息。JWT的标准定义包含五个字段：</p><ul><li>iss：该JWT的签发者</li><li>sub: 该JWT所面向的用户</li><li>aud: 接收该JWT的一方</li><li>exp(expires): 什么时候过期，这里是一个Unix时间戳</li><li>iat(issued at): 在什么时候签发的</li></ul><p>载荷示例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n  &#34;sub&#34;: &#34;1234567890&#34;,\n  &#34;name&#34;: &#34;Java碎碎念&#34;,\n  &#34;iat&#34;: 1516239022\n}\n</code></pre></div><ol><li>签名（signature）</li></ol><p>前面两部分都是使用Base64进行编码的，即前端可以解开知道里面的信息。signature 需要使用编码后的header和payload以及我们提供的一个密钥，然后使用header中指定的签名算法（HS256）进行签名。签名的作用是保证 JWT 没有被篡改过。</p><p>三个部分通过.连接在一起就是我们的 JWT 了，所以我们生成的JWT如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkphdmHnoo7noo7lv7UiLCJpYXQiOjE1MTYyMzkwMjJ9.LLJIkhJs6SVYlzn3n8fThQmhGutjTDI3RURTLtHV4ls\n</code></pre></div><p>注意：密钥就是用来进行JWT的签发和JWT的验证，所以，它就是你服务端的私钥，在任何场景都不应该泄露出去。</p><h3><b>五、JWT使用场景</b> </h3><p>JWT主要使用场景如下：</p><ul><li>授权</li></ul><p>这是JWT使用最多的场景，一旦用户登录，每个后续的请求将包括JWT，从而允许用户访问该令牌允许的路由、服务和资源。</p><ul><li>信息交换：JSON</li></ul><p>JWT可以用在各方之间安全地传输信息，因为JWT可以进行签名，所以您可以确定发件人是他们所说的人。另外，由于签名是使用标头和有效负载计算的，因此您还可以验证内容是否未被篡改。</p><p>到此JWT的基础和认证原理已经讲完了，下一篇文章将介绍下SpringBoot中整合JWT，敬请期待哦。</p><p><b>推荐阅读</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/KFlsdF6iBkYmRlBstZgc9g\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1.利用SpringBoot+Logback手写一个简单的链路追踪</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/ikyLQu3bqzk_OyejE4tGRQ\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">2.SpringBoot中如何优雅的读取yml配置文件？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/mjCNtTTyGkieERKPP84fVg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">3.SpringBoot中如何灵活的实现接口数据的加解密功能？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/REFo0hRqlVjntz-FEWRGnw\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">4.SpringBoot中神奇的@Enable*注解？</a><br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/mBG8GGpNMcaz1PzhEqi0WA\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">5.Java中Integer.parseInt和Integer.valueOf，你还傻傻分不清吗？</a></p><hr/><blockquote> 限时领取免费Java相关资料，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo/Kafka、Hadoop、Hbase、Flink等高并发分布式、大数据、机器学习等技术。<br/>关注下方公众号即可免费领取：<br/> </blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-07ab4521440f40f21f36487f27d129fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-07ab4521440f40f21f36487f27d129fd_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "JSON", 
                    "tagLink": "https://api.zhihu.com/topics/19602492"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58495986", 
            "userName": "奔跑", 
            "userLink": "https://www.zhihu.com/people/8eaa7dc56ddfb45c8fea14fce0da9196", 
            "upvote": 2, 
            "title": "为什么单线程的Redis这么快？", 
            "content": "<h2><b>一. Redis简介</b> </h2><p>Redis是一个开源的内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）等。</p><h2><b>二. Redis为什么这么快</b> </h2><ol><li>完全基于内存，绝大部分请求是纯粹的内存操作。　</li><li>数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。　</li><li>采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。　　</li><li>使用多路I/O复用模型，非阻塞IO。　</li><li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li></ol><h2><b>三. 多路I/O复用模型</b> </h2><p>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。　　<br/>　　这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。</p><p>下面举一个例子，模拟一个tcp服务器处理30个客户socket。假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：</p><ol><li>第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。</li><li>第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。</li><li>第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型，Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。</li></ol><h2><b>四. 单进程单线程好处</b> </h2><ol><li>代码更清晰，处理逻辑更简单</li><li>不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗</li><li>不存在多进程或者多线程导致的切换而消耗CPU</li></ol><blockquote> 多路I/O复用模型例子参考：<a href=\"https://www.zhihu.com/question/28594409/answer/52835876\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/question/2859</span><span class=\"invisible\">4409/answer/52835876</span><span class=\"ellipsis\"></span></a><br/> </blockquote><hr/><p>下面的是我的公众号二维码图片，欢迎关注，欢迎留言，一起学习，一起进步。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-46f490b423412c769b98c68526c2fa16_b.jpg\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"258\" data-rawheight=\"258\" data-size=\"normal\" data-caption=\"\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic3.zhimg.com/v2-46f490b423412c769b98c68526c2fa16_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "Redis Cluster", 
                    "tagLink": "https://api.zhihu.com/topics/20173110"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1086629731398455296"
}
