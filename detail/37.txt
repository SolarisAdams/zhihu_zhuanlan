{
    "title": "软件开发", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/gang-gang-gang-15", 
        "https://www.zhihu.com/people/heng-heng-90-12", 
        "https://www.zhihu.com/people/nurenok-91", 
        "https://www.zhihu.com/people/huang-xiang-feng-72", 
        "https://www.zhihu.com/people/shenkai-61", 
        "https://www.zhihu.com/people/qi-jia-xing-86-13", 
        "https://www.zhihu.com/people/fang-fang-tu-77", 
        "https://www.zhihu.com/people/wu-jian-qing-shan-duo-wu-mei", 
        "https://www.zhihu.com/people/lin-sheng-piao-yang", 
        "https://www.zhihu.com/people/aaron-54-52", 
        "https://www.zhihu.com/people/zhang-guang-hui-9-26", 
        "https://www.zhihu.com/people/mask-97", 
        "https://www.zhihu.com/people/gao-yu-xiao-33", 
        "https://www.zhihu.com/people/qing-sheng-xian-sen-1", 
        "https://www.zhihu.com/people/firetaker", 
        "https://www.zhihu.com/people/gordon-87-99", 
        "https://www.zhihu.com/people/kai-xin-yi-ke-2018", 
        "https://www.zhihu.com/people/callmejay", 
        "https://www.zhihu.com/people/joker-78-24-86", 
        "https://www.zhihu.com/people/zhang-xu-dong-22-32", 
        "https://www.zhihu.com/people/ji-yi-meng-37", 
        "https://www.zhihu.com/people/yang-hang-1-81", 
        "https://www.zhihu.com/people/mei-zi-91-48", 
        "https://www.zhihu.com/people/yi-zhan-shi-ruan-jian-kai-fa", 
        "https://www.zhihu.com/people/mei-you-ming-zi-que-you-xin-shi-de-ren", 
        "https://www.zhihu.com/people/feng-yu-tian-xiang-3", 
        "https://www.zhihu.com/people/pu-liang-jun-20", 
        "https://www.zhihu.com/people/yi-bei-62-19-39", 
        "https://www.zhihu.com/people/rihui-chen", 
        "https://www.zhihu.com/people/wu-yy-23", 
        "https://www.zhihu.com/people/xu-kang-ping-12", 
        "https://www.zhihu.com/people/li-strong-6", 
        "https://www.zhihu.com/people/nuo-mi-mino", 
        "https://www.zhihu.com/people/liu-xiao-sheng-27", 
        "https://www.zhihu.com/people/kgdshb", 
        "https://www.zhihu.com/people/tan-wei-jiang", 
        "https://www.zhihu.com/people/xiao-wo-52-18", 
        "https://www.zhihu.com/people/pumpkin-82-11", 
        "https://www.zhihu.com/people/kai-xin-shi-ke-82", 
        "https://www.zhihu.com/people/mu-zi-jia-zu-56", 
        "https://www.zhihu.com/people/yu-zhi-bo-20-31", 
        "https://www.zhihu.com/people/wang-zhe-99-35", 
        "https://www.zhihu.com/people/huanhuan-67-65", 
        "https://www.zhihu.com/people/cai-cai-43-11-99", 
        "https://www.zhihu.com/people/Ssxy5676376", 
        "https://www.zhihu.com/people/liu-jie-68-89", 
        "https://www.zhihu.com/people/ge-ge-qu-64", 
        "https://www.zhihu.com/people/mu-zi-26-34-78", 
        "https://www.zhihu.com/people/tang-guo-chuan-qi-25", 
        "https://www.zhihu.com/people/zhang-qi-34-75", 
        "https://www.zhihu.com/people/song-jiang-shan-54", 
        "https://www.zhihu.com/people/dehuiyi-zhaopian", 
        "https://www.zhihu.com/people/xue-chang-qing-30", 
        "https://www.zhihu.com/people/chun-cui-3-82", 
        "https://www.zhihu.com/people/ming-yu-69-3", 
        "https://www.zhihu.com/people/wei-chen-69-64-99", 
        "https://www.zhihu.com/people/chan-chan-rong-rong", 
        "https://www.zhihu.com/people/man-chi-74", 
        "https://www.zhihu.com/people/albert-53-21", 
        "https://www.zhihu.com/people/da-lai-46", 
        "https://www.zhihu.com/people/he-xuesong", 
        "https://www.zhihu.com/people/star-13-10-17", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/xuan-mo-94-28", 
        "https://www.zhihu.com/people/you-shi-yitian-21", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/lin-ge-25-50", 
        "https://www.zhihu.com/people/ian-ma-81", 
        "https://www.zhihu.com/people/lazybone-73", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/ku-teng-74-45", 
        "https://www.zhihu.com/people/nan-ke-2", 
        "https://www.zhihu.com/people/mi-cai-96-26", 
        "https://www.zhihu.com/people/hu-hu-8-27-31", 
        "https://www.zhihu.com/people/spearous", 
        "https://www.zhihu.com/people/josephine-22-53", 
        "https://www.zhihu.com/people/cha-na-5-53", 
        "https://www.zhihu.com/people/huang-jia-yue-34-59", 
        "https://www.zhihu.com/people/mu-zi-shan-25-31", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/hai-dian-you-min", 
        "https://www.zhihu.com/people/ekko-26-98", 
        "https://www.zhihu.com/people/feng-ze-33-40", 
        "https://www.zhihu.com/people/chen-xun-37", 
        "https://www.zhihu.com/people/noeltoby", 
        "https://www.zhihu.com/people/le-lang-", 
        "https://www.zhihu.com/people/wuliang-yu-42", 
        "https://www.zhihu.com/people/xiao-xiao-42-87-70", 
        "https://www.zhihu.com/people/gu-feng-yue-ying-92", 
        "https://www.zhihu.com/people/ao-ao-37-76", 
        "https://www.zhihu.com/people/ticktock-47", 
        "https://www.zhihu.com/people/meng-ying-39-92", 
        "https://www.zhihu.com/people/ping-yang-93", 
        "https://www.zhihu.com/people/ylz2445132083", 
        "https://www.zhihu.com/people/chen-jun-li-90", 
        "https://www.zhihu.com/people/tang-dou-37-87", 
        "https://www.zhihu.com/people/yi-dian-hu-lian", 
        "https://www.zhihu.com/people/bei-guan-shi-jie-62-73", 
        "https://www.zhihu.com/people/xiao-guang-ge-99-88", 
        "https://www.zhihu.com/people/tong-97", 
        "https://www.zhihu.com/people/dream_on_sakura_rain", 
        "https://www.zhihu.com/people/dong-28-31-73", 
        "https://www.zhihu.com/people/zhou-zhong-jian-80-97", 
        "https://www.zhihu.com/people/llitfkitfk", 
        "https://www.zhihu.com/people/sportmax", 
        "https://www.zhihu.com/people/di-si-wei-93", 
        "https://www.zhihu.com/people/ren-guo-qiang-49", 
        "https://www.zhihu.com/people/liuliu-23-60-86", 
        "https://www.zhihu.com/people/zhi-tong-dao-he-5", 
        "https://www.zhihu.com/people/hx530", 
        "https://www.zhihu.com/people/rony-79", 
        "https://www.zhihu.com/people/tian-jian-bo", 
        "https://www.zhihu.com/people/wang-hui-tian-xia-ke-ji", 
        "https://www.zhihu.com/people/dou-dou-88-10-12", 
        "https://www.zhihu.com/people/19986022602", 
        "https://www.zhihu.com/people/by-li-11", 
        "https://www.zhihu.com/people/zhang-cheng-11-36", 
        "https://www.zhihu.com/people/da-xia-xia-xia-xia", 
        "https://www.zhihu.com/people/yue-yun-xing-xi", 
        "https://www.zhihu.com/people/xu-dou-bi-20", 
        "https://www.zhihu.com/people/alessandro-zeng", 
        "https://www.zhihu.com/people/you-meng-xiang-de-ma-nong-77", 
        "https://www.zhihu.com/people/xiao-mo-46-9", 
        "https://www.zhihu.com/people/lx09110718", 
        "https://www.zhihu.com/people/pi-feng-6-43", 
        "https://www.zhihu.com/people/min-ding-75", 
        "https://www.zhihu.com/people/wudalu", 
        "https://www.zhihu.com/people/jimmy.li", 
        "https://www.zhihu.com/people/yi-xinglu", 
        "https://www.zhihu.com/people/fu-kan-feng-jing-41", 
        "https://www.zhihu.com/people/chen-xi-64-63", 
        "https://www.zhihu.com/people/shengyinng", 
        "https://www.zhihu.com/people/guo-zhong-ming-26", 
        "https://www.zhihu.com/people/vtan-89", 
        "https://www.zhihu.com/people/yan-yi-jie-34", 
        "https://www.zhihu.com/people/chi-ren-lei-66", 
        "https://www.zhihu.com/people/angeryu", 
        "https://www.zhihu.com/people/tmhoney-71", 
        "https://www.zhihu.com/people/zhang-peng-fei-20-55", 
        "https://www.zhihu.com/people/yao-jin-42", 
        "https://www.zhihu.com/people/song-peng-bo-72", 
        "https://www.zhihu.com/people/ni-yan-ye", 
        "https://www.zhihu.com/people/xiaojichao", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/hu-hu-10-99", 
        "https://www.zhihu.com/people/jie-ge-ge-49", 
        "https://www.zhihu.com/people/jia-chun-da"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/72550059", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "数据库设计", 
            "content": "<p>数据库设计</p><p class=\"ztext-empty-paragraph\"><br/></p><p>项目开发中的环节：</p><ol><li>需求调研</li><li>需求文档+原型</li><li>类工通过原型设计UI----&gt;HTML网页</li><ol><li>设计师，美工</li><li>目前纯粹的后台管理有成熟的模板和框架可选（BootStrap）</li></ol><li>后台开发，设计数据库，创建数据库结构</li><ol><li>项目技术架构选型</li><li>数据库设计</li><ol><li>根据需求文档原型设计</li><li>每个开发者根据自己的模块自己设计</li></ol><li>项目模块代码编写</li><li>后台开发，公共代码编写</li><li>功能编码</li></ol><li>测试</li><ol><li>黑盒测试</li></ol></ol><ul><li>程序内部不可见，以特定的程序或者工具来测试软件</li></ul><li>白盒测试</li><ul><li>单元测试，程序代码直接通过代码测试</li></ul><li>上线运行</li><li>后期不断维护</li><li>项目淘汰</li><p class=\"ztext-empty-paragraph\"><br/></p><p>在数据库设计的时候，通常根据需求画出数据的ER（Entity Relational）图，通过ER图生成数据库的建库脚本，软件开发都是分别从页面设计和数据库设计开始的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据库设计基础理论</p><p>第一步：标识表（实体表、业务表/中间表）</p><p>第二步：标识表的字段</p><p>第三步：标识表与表之间的关系</p><p class=\"ztext-empty-paragraph\"><br/></p><p>标识字段注意事项：</p><p>三范式原则，最终解决数据冗余问题</p><p>数据库三范式是一个规范，实际上，需求&gt;性能&gt;表结构，不能一味追求范式而建立数据库</p><p class=\"ztext-empty-paragraph\"><br/></p><p>三范式：</p><p>第一范式：每列（字段）保持原子性，列值不可分割</p><p>第二范式：非主键列必须依赖主键列的存在</p><p>第三范式：每一列数据都和主键直接相关不能间接相关</p><p class=\"ztext-empty-paragraph\"><br/></p><p>标识表之间的关系：</p><p>一对一</p><p>一对多/多对一</p><p>多对多</p><p>由需求决定其关系</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }, 
                {
                    "tag": "互联网思维", 
                    "tagLink": "https://api.zhihu.com/topics/19635252"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74722694", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "Mybatis-Plus", 
            "content": "<p>Mybatis-Plus</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Mybatis-Plus是在MyBatis框架的基础上，做了一层封装，其主要对数据库单表的各种增删改查，为开发者提供了一个公共的接口，直线代码的0实现，简化开发，提高效率。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一般来说，在业务流程较多的时候，开发者在写mapper层/dao层/持久层的代码会出现大量重复或者类似的sql语句和方法，这会让代码看起来冗余复杂，不利于观看，为了解决这个问题，对其大量重复的代码进行了提取封装，在Mybatis-Plus中就是  BaseMapper&lt;T&gt; 接口，开发者只需要用自己的接口继承这个接口，就可以了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>配置Mybatis-Plus：</p><p>mybatis是基于spring框架实现的，所以需要配置spring</p><ol><li>创建数据库，user表，字段：id，name，age，email</li><li>创建一个maven项目</li><li>配置pom.xml文件，添加相关的依赖包：spring-jdbc，spring-context，mybatis-plus，mysql-connector，druid，spring-test，junit</li><li>创建一个实体类。</li><li>创建UserMapper并继承BaseMapper</li><li>整合Mybatis-Plus和Spring</li><ol><li>数据源（com.alibaba.druid.pool.DruidDataSource），配置四要素driverClassName，url，username，password</li><li>会话工厂（com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean），指定数据源，全局实体类配置（com.baomidou.mybatisplus.entity.GlobalConfiguration），指定分页支持插件（list，com.baomidou.mybatisplus.plugins.PaginationIntercepto），方言，支持sql语句输出。</li></ol><li>扫描动态映射对象（org.mybatis.spring.mapper.MapperScannerConfigurer），指定会话工厂和基础mapper包</li><li>配置事务管理器（org.springframework.jdbc.datasource.DataSourceTransactionManager），数据源</li><li>注解驱动，指定事务管理器</li><li>书写pojo，mapper，test代码，测试</li></ol><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75718558", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "项目（三）", 
            "content": "<p>ActiveMQ</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ActiveMQ是一个消息队列应用服务器，支持JMS（Java Message Service）规范。实现了JMS标准的系统，也叫做JMS Provider</p><p class=\"ztext-empty-paragraph\"><br/></p><p>消息队列中有三个角色存在：</p><p>Producer，消息生产者，负责将消息推送到Broker。</p><p>Broker，消息处理中心（中间件），负责消息的处理一般其中包含多个queue</p><p>Consumer，消息消费者，负责从Broker中获取消息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>常见的消息队列：</p><p>ActiveMQ，ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现。</p><p>RabbitMQ，是一个在AMQP基础上完成的，可复用的企业消息系统。他遵循Mozilla Public License开源协议。开发语言为Erlang。</p><p>RocketMQ，由阿里巴巴定义开发的一套消息队列应用服务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ActiveMQ的主要特点：</p><ol><li>支持多语言、多协议客户端。语言: Java,C,C++,C#,Ruby,Perl,Python,PHP。应用协议： OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li><li>对Spring的支持，ActiveMQ可以很容易整合到Spring的系统里面去。</li><li>支持高可用、高性能的集群模式。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>JMS的常用API说明：</p><p>ConnectionFactory，连接工厂，用于创建连接 的工厂类型。</p><p>Connection，连接，用于创建连接 的工厂类型，由连接工厂创建。</p><p>Session，会话，一次持久有效，有状态的访问，由连接创建。</p><p>Destination，目的地由Session创建，interface Queue extends Destination</p><p>Queue：队列模型，只有一个消费者。消息一旦被消费，默认删除。</p><p>Topic：主题订阅中的消息，会发送给所有的消费者同时处理。</p><p>Message：消息，在消息传递过程中数据载体对象，是所有消息【文本消息TextMessage，对象消息ObjectMessage等】具体类型的顶级接口，可以通过会话创建或通过会话从ActiveMQ服务中获取。</p><p>MessageProducer：消息生成者, 在一次有效会话中, 用于发送消息给ActiveMQ服务的工具，由Session会话创建。</p><p>MessageConsumer：消息消费者【消息订阅者，消息处理者】, 在一次有效会话中, 用于ActiveMQ服务中获取消息的工具，由Session会话创建。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ActiveMQ监听器</p><p>消息队列中消费者获取信息必须每次都执行方法，只能获取单条信息，如果服务器中信息有多条，就需要监听器辅助将信息以流形式全部读出，所以，监听器应运而生。</p><p>定义的监听器必须继承MessageListener，定义监听条件方法。然后在消费者获取消息的方法中调用该监听器的方法以达效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ActiveMQ模式：</p><p>PTP（point to point）使用消息队列,queue，就消息的传输角度来看，是生产者对消费者一对一的模式，消息一旦被消费了就会消失，消费者不可能再次消费已经被消费过（确认）的信息。</p><p>TOPIC，主题订阅模式，生产者（发行者）生产消息到topic中，同时有多个消费者（订阅者）消费该消息，此模式的默认不需要消费者确认，无论消费者有无确认消息，该消息都会消费后就消失，所以在这个模式下一般都是先有订阅者之后才有发行者</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76249227", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "跨域（cross domain）", 
            "content": "<p>跨域</p><p class=\"ztext-empty-paragraph\"><br/></p><p>跨域问题的出现，是因为有浏览器同源策略的存在。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>浏览器同源策略</p><p>其限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互，这个策略是一个仲要的安全机制，主要作用是用于隔离潜在的恶意文件。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>同源</p><p>具有相同的协议，主机和端口（若指定）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>源的继承</p><p>在页面中使用 about:blank 或者 javascript: 的时候，URL执行的脚本会继承已经打开的URL的文档源，因为这类URLs没有明确包含有关原始服务器的源信息。例如： about:blank 通常作为父脚本写入内容的新建空白窗（通过Window.open（）机制）。如果弹窗包含 javascript 代码，则这些代码继承于那些创建它的脚本相同的源。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>IE例外：涉及到同源策略的时候IE主要有两个例外，一个是授权区间（两个相互之间高度互信的域名，例如公司域名，不遵守同源策略的限制），二是端口（IE未将端口号加入到同源策略的组成部分，因此端口号不同被认为是同源），这些例外是非标准的并且不被任何话浏览器支持</p><p class=\"ztext-empty-paragraph\"><br/></p><p>源的更改</p><p>document.domain语法</p><div class=\"highlight\"><pre><code class=\"language-text\">var domainString = document.domain;\ndocument.domain = string;</code></pre></div><p>页面因为一些限制缘故可能会更改它的源。 document.domain 脚本可用于设置其当前域名或者当前域的父域名的值，如果设置了当前域的父域名，则较短的父域名用于同源策略检测。</p><p>例如：在  <a href=\"https://link.zhihu.com/?target=http%3A//store.company.com/dir/other.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">store.company.com/dir/o</span><span class=\"invisible\">ther.html</span><span class=\"ellipsis\"></span></a>  执行脚本 document.domain = &#34;company.com&#34;; 之后，  <a href=\"https://link.zhihu.com/?target=http%3A//store.company.com/dir/other.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://company.com/dir/page.html</a> 执行脚本 document.domain = &#34;company.com&#34;;就可以通过同源检测，但是 company.com不能设置document.domain 为 othercompany.com，因为这不是 company.com的父域名。</p><p>端口号会被浏览器单独检测，任何对 document.domain的赋值，包括 document.domain=document.domain，都会导致端口号被重写为null。因此，其中一个带端口号的域名（<a href=\"https://link.zhihu.com/?target=http%3A//company.com%3A8080\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">company.com:8080</span><span class=\"invisible\"></span></a>）仅仅的设置 document.domain=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//company.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">company.com</span><span class=\"invisible\"></span></a>&#34;; 不能与不带端口号的域名（<a href=\"https://link.zhihu.com/?target=http%3A//company.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">company.com</span><span class=\"invisible\"></span></a>）进行通信。双方都必须对document.domain的赋值，以致于端口号都会变成null。</p><p>注意：当使用 document.domain允许一个子域名去安全地访问父域名的时候，需要将子域名和父域名两边的 document.domain设置为相同的值。即使都进行对document.domain赋值会将父域名单单的设置回原来的初始值，这也是很有必要的。如果不这么做可能会引起权限错误的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>跨源的网络访问</p><p>同源策略控制了不同源之间的交互，例如在使用 XMLHttpRequest 或者&lt;img&gt;元素标签的时候，这些交互一般会被分为三类：</p><ol><li>允许跨源写操作，例如链接，重定向，表单提交，还有一些需要添加预检的HTTP请求。</li><li>允许跨源资源嵌入。</li><li>不允许跨源读操作，但通常可以通过内嵌来资源进行读操作，例如，可以读取内嵌图片的规模大小，内嵌脚本的路径（方法）。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>以下是可能嵌入跨源的资源样式示例：</p><ul><li>JavaScript的&lt;script src=&#34;...&#34;&gt;&lt;/script&gt;标签，语法错误仅仅会在同源脚本中才会被检测</li><li>CSS的标签&lt;link ref=&#34;stylesheet&#34; href=&#34;...&#34;&gt;</li><li>图片标签&lt;img&gt;</li><li>视频播放标签&lt;audio&gt;和&lt;video&gt;</li><li>嵌入插件&lt;object&gt;,&lt;embed&gt;和&lt;applet&gt;</li><li>字体@font-face，一些浏览器支持跨源一些支持同源</li><li>&lt;frame&gt;和&lt;iframe&gt;载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种跨源载入</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>CORS是HTTP的一部分，用于让服务器指定哪些主机是被允许从服务器加载资源的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>阻止跨域写操作</p><ol><li>阻止跨源写操作，在请求中检测到一个不可测的token，通常被称为跨站伪造请求，必须依靠这个token来阻止跨源页面的读操作。</li><li>阻止跨源都区资源操作，确保这些资源是不可嵌入的。通常都有必要阻止嵌入，因为嵌入一个资源总是会泄露一些关于它的信息。</li><li>阻止跨源嵌入，确保你的资源不能是以上列出的可嵌入样式的任意一个，浏览器可能不会遵守Content-Type消息头。比如说：如果你在HTML文档中指定一个&lt;script&gt;标签，浏览器会尝试将HTML解析为JavaScript，当你的资源不是你站点的入口点，可以使用CSRF token来阻止嵌入</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>跨源脚本API访问</p><p>JavaScript的APIs中，例如：iframe.contentWindow , window.parent , window.open 和 window.opener , 允许所有文档相互间直接引用。当两个文档源没有相同的源的时候，这些引用将提供非常严格的访问方式给window和location的对象。</p><p>在不同源的两个文档对象要交互时，要使用window.postMessgae</p><p>详细请参照：</p><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-72382e605ce3eba8154aa310a712c403_ipico.jpg\" data-image-width=\"600\" data-image-height=\"600\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Same-origin policy</a><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }, 
                {
                    "tag": "跨域", 
                    "tagLink": "https://api.zhihu.com/topics/19612046"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76413285", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "spring-cloud入门", 
            "content": "<p>配置Eureka</p><p>技术架构（需要指定，否则有可能会出现初始化失败，或者类型异常）</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;parent&gt;\n\t\t&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n\t\t&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n\t\t&lt;version&gt;1.5.19.RELEASE&lt;/version&gt;\n\t\t&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n&lt;/parent&gt;</code></pre></div><ol><li>创建一个maven项目</li><li>官网下载spring-cloud，选中Eureka Server选项的依赖包</li><li>复制pom.xml和启动类到项目中</li><li>配置文件</li><li>运行启动类</li></ol><p>配置文件：</p><div class=\"highlight\"><pre><code class=\"language-text\">#服务端口\nserver.port=5121\neureka.instance.hostname=localhost\n#指示此实例是否应将其信息注册到eureka服务器以供其他人发现。 在某些情况下，不希望发现你的实例，而只是想要发现其他实例。默认true\neureka.client.register-with-eureka=false\n#指示此客户端是否应从eureka服务器获取eureka注册表信息。默认true\neureka.client.fetch-registry=false\n#对外提供的注册入口\neureka.client.service-url.defaultZone=http://${eureka.instance.hostname}:${server.port}/eureka/</code></pre></div><p>启动类：</p><div class=\"highlight\"><pre><code class=\"language-text\">//标记springboot工程\n@SpringBootApplication\n//标记注册中心eureka server\n@EnableEurekaServer\npublic class EurekaApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(EurekaApplication.class, args);\n\t}\n}</code></pre></div><p>负载均衡：</p><p>只需要在pom文件中加入spring-cloud-starter-ribbon依赖，就支持负载均衡</p><p>在方法上面贴上@LoadBalance可以自动分配负载均衡</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>未完待续。。。</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72549493", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "shiro框架", 
            "content": "<p>Shiro框架</p><p class=\"ztext-empty-paragraph\"><br/></p><p>用于安全校验和授权的框架，可以将所有操作原子化</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Shiro的结构图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-158a81535d694024da941525e50a746d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"487\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"487\" data-original=\"https://pic2.zhimg.com/v2-158a81535d694024da941525e50a746d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;487&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"487\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"487\" data-original=\"https://pic2.zhimg.com/v2-158a81535d694024da941525e50a746d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-158a81535d694024da941525e50a746d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Authentication：权限校验，每次操作校验用户是否有访问权限</p><p>Authorization：授权，用户登录时，授予用户对应的权限</p><p>Session Management：会话管理，用于记录用户的登录状态</p><p>Cryptography：加密，加密算法的实现（SHA、MD5）</p><p>web Support：对Web项目的支持，Shiro的标签！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>shiro中需要理解的几个API</p><p>IniSecurityManagerFactory：作用加载ini配置文件获得SecurityManagerFactory对象，新版api中已过期</p><p>SecurityManager：安全管理容器，就是负责整个Shiro框架授权校验对象的管理</p><p>SecurityUtils ：SecurityManager对象帮助类</p><p>Subject：验证通过后用于存储授权信息的身份对象</p><p>UsernamePasswordToken ：用于设置校验信息的对象</p><p>IncorrectCredentialsException ：密码出错异常</p><p>UnknownAccountException：用户名出错异常</p><p>AuthorizingRealm：支持校验与授权的Realm</p><p>AuthenticationInfo：校验成功返回的信息的父接口</p><p>AuthorizationInfo：授权成功返回的信息类</p><p>SimpleAuthenticationInfo：校验成功返回信息类的父接口</p><p>SimpleAuthorizationInfo：授权成功返回的信息类的实现类</p><p>HashedCredentialsMatcher： 算法校验器</p><p>PrincipalCollection：授予是获得验证信息的类</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Shiro中的Realm机制</p><p>Shiro是通过Realm机制，实现将配置文件的校验用户信息存放在数据库、LDAP等数据存储系统里面。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>shiro中自带加密功能，其加密方式是散列表加密，在SimpleHash类中</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7d58775d3b7ae489f6bf6cdc641610b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"338\" class=\"content_image\" width=\"327\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;327&#39; height=&#39;338&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"338\" class=\"content_image lazy\" width=\"327\" data-actualsrc=\"https://pic3.zhimg.com/v2-7d58775d3b7ae489f6bf6cdc641610b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>HashedCredentialsMatcher类可以用指定hash算法</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3f96a1ff08d65676c085ab85f28bda35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"338\" data-rawheight=\"317\" class=\"content_image\" width=\"338\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;338&#39; height=&#39;317&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"338\" data-rawheight=\"317\" class=\"content_image lazy\" width=\"338\" data-actualsrc=\"https://pic2.zhimg.com/v2-3f96a1ff08d65676c085ab85f28bda35_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>ByteSource接口用于给Hash算法加盐</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2ed32a2783011ab933930d82f9756162_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"320\" data-rawheight=\"117\" class=\"content_image\" width=\"320\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;320&#39; height=&#39;117&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"320\" data-rawheight=\"117\" class=\"content_image lazy\" width=\"320\" data-actualsrc=\"https://pic3.zhimg.com/v2-2ed32a2783011ab933930d82f9756162_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>Realm授权：在我们AuthorizingRealm提供了权限授予的方法doGetAuthorizationInfo可以用于授权。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>作为接收用户传输参数的方式：</p><p>Map：可以接受任何类型的参数，用kv形式存储，在联表查询的时候可以不用创建多余的类；会出现判断数据时，类型不匹配的问题，并且参数对应的字段必须要逻辑清晰自己去对应</p><p>pojo：javabean中的字段与数据库中的表一一对应，运行时不会出现数据类型不匹配的问题；在进行联表查询的时候必须创建新的vo类，不然会出现javabean之间的侵入，耦合度过高，并且需要编写联表查询sql语句</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73469955", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "Redis(二)", 
            "content": "<p>Redis持久化</p><ul><li>Redis持久化，就是将内存中的数据，永久保存到磁盘上。</li><li>Redis持久化有两种方式：RDB(Redis DB)、AOF(AppendOnlyFile)</li></ul><p>RDB（快照模式）</p><p>在默认情况下，Redis 将数据库快照保存在名字为dump.rdb的二进制文件中，可以在redis.conf配置文件中修改持久化信息。</p><p># Save the DB on disk:<br/>#<br/>#   save &lt;seconds&gt; &lt;changes&gt;<br/>#<br/>#   Will save the DB if both the given number of seconds and the given<br/>#   number of write operations against the DB occurred.<br/>#<br/>#   In the example below the behaviour will be to save:<br/>#   after 900 sec (15 min) if at least 1 key changed<br/>#   after 300 sec (5 min) if at least 10 keys changed<br/>#   after 60 sec if at least 10000 keys changed<br/>#<br/>#   Note: you can disable saving completely by commenting out all &#34;save&#34; lines.<br/>#<br/>#   It is also possible to remove all the previously configured save<br/>#   points by adding a save directive with a single empty string  argument<br/>#   like in the following example:<br/>#<br/>#   save &#34;&#34;<br/>save 900 1<br/>save 300 10<br/>save 60 10000</p><p>save后面的语句代表：在有至少1/10/10000个key/keys发生变化之后900/300/60s，将数据保存到硬盘</p><p class=\"ztext-empty-paragraph\"><br/></p><p>AOF（追加模式）</p><p>Append only file，采用追加的方式保存，默认文件appendonly.aof；</p><p>记录所有的写操作命令，在服务启动的时候使用这些命令就可以还原数据库；</p><p>AOF默认关闭，需要在配置文件中手动开启。</p><p># AOF and RDB persistence can be enabled at the same time without  problems.<br/># If the AOF is enabled on startup Redis will load the AOF, that is the  file<br/># with the better durability guarantees.<br/>#<br/># Please check <a href=\"https://link.zhihu.com/?target=http%3A//redis.io/topics/persistence\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">redis.io/topics/persist</span><span class=\"invisible\">ence</span><span class=\"ellipsis\"></span></a> for more information.<br/>appendonly no</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>将appendonly 设置为yes则打开AOF模式，系统默认是关闭的no。并且AOF和RDB两个模式可以同时存在，并且系统服务开启之后会自动使用AOF，因为在数据持久化方面会优于RDB，</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据持久化策略</p><p># The fsync() call tells the Operating System to actually write data on  disk<br/># instead of waiting for more data in the output buffer. Some OS will  really flush<br/># data on disk, some other OS will just try to do it ASAP.<br/>#<br/># Redis supports three different modes:<br/>#<br/># no: don&#39;t fsync, just let the OS flush the data when it wants. Faster.<br/># always: fsync after every write to the append only log. Slow, Safest.<br/># everysec: fsync only one time every second. Compromise.<br/>#<br/># The default is &#34;everysec&#34;, as that&#39;s usually the right compromise  between<br/># speed and data safety. It&#39;s up to you to understand if you can relax  this to<br/># &#34;no&#34; that will let the operating system flush the output buffer when<br/># it wants, for better performances (but if you can live with the idea  of<br/># some data loss consider the default persistence mode that&#39;s  snapshotting),<br/># or on the contrary, use &#34;always&#34; that&#39;s very slow but a bit safer than<br/># everysec.<br/>#<br/># More details please check the following article:<br/># <a href=\"https://link.zhihu.com/?target=http%3A//antirez.com/post/redis-persistence-demystified.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">antirez.com/post/redis-</span><span class=\"invisible\">persistence-demystified.html</span><span class=\"ellipsis\"></span></a><br/>#<br/># If unsure, use &#34;everysec&#34;.<br/># appendfsync always<br/>appendfsync everysec<br/># appendfsync no</p><p>在一般情况下数据持久化策略都是默认每秒刷新持久化，并且它的性能会介always和no之间，是个折衷的方式。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>优缺点总结：</p><p>相同数据集，AOF文件体积较RDB大了很多；</p><p>恢复数据库速度较RDB慢（文本，命令重演）。 </p><p>写入机制，默认fysnc（手工同步）每秒执行，性能很好不阻塞服务，最多丢失一秒的数据；</p><p>重写机制，优化AOF文件；</p><p>如果误操作了（FLUSHALL等），只要AOF未被重写，停止服务移除AOF文件尾部FLUSHALL命令，重启Redis，可以将数据集恢复到FLUSHALL 执行之前的状态。</p><p>RDB执行效率高，folk过程非常耗时，会造成毫秒级不能响应客户端请求。</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69199373", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "SpringMVC", 
            "content": "<h2><b>1.</b> <b>文件上传</b></h2><p>在web开发中一般会有文件上传的操作</p><p>一般JavaWeb开发中文件上传使用的 Apache组织的Commons FileUpload组件</p><p>SpringMVC中使用  <b>MultipartFile file</b>对象接受上传文件,必须保证 后台参数的名称和表单提交的文件的名称一致</p><p>文件上传必须条件</p><p>1. 表单必须post</p><p>2. 表单必须有 file 文件域</p><p>3. 表单的 enctype=<i>&#34;multipart/form-data&#34;</i></p><h2><b>1.1.</b> <b>拷贝jar包</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><h2><b>1.2.</b> <b>准备jsp页面</b></h2><p>&lt;fieldset&gt;</p><p>  &lt;legend&gt;单个文件上传&lt;/legend&gt;</p><p>  &lt;form action=<i>&#34;</i>${pageContext.request.contextPath}<i>/upload.do&#34;</i> method=<i>&#34;post&#34;</i> enctype=<i>&#34;multipart/form-data&#34;</i>&gt;</p><p>   姓名: &lt;input name=<i>&#34;username&#34;</i>&gt;&lt;br&gt;</p><p>   头像: &lt;input type=<i>&#34;file&#34;</i> name=<i>&#34;headImg&#34;</i>&gt;&lt;br&gt;</p><p>   &lt;button type=<i>&#34;submit&#34;</i>&gt;提交&lt;/button&gt;</p><p>  &lt;/form&gt;</p><p> &lt;/fieldset&gt;</p><h2><b>1.3.</b> <b>后台代码</b></h2><p>SpringMVC中使用  MultipartFile file对象接受上传文件,必须保证 后台方法MultipartFile 参数的名称和表单提交的文件的名称一致</p><p>//SpringMVC中使用  MultipartFile file对象接受上传文件,必须保证 后台参数的名称和表单提交的文件的名称一致</p><p> @RequestMapping(&#34;/upload&#34;)</p><p><b>public</b> String singleUpload(<b>MultipartFile headImg</b>,@RequestParam(&#34;username&#34;)String username) <b>throws</b> IOException {</p><p>  System.<b><i>out</i></b>.println(headImg.getName());//获取上传文件的表单名称 </p><p>  System.<b><i>out</i></b>.println(headImg.getContentType());//MIME类型</p><p>  System.<b><i>out</i></b>.println(headImg.getSize());//文件大小</p><p>  System.<b><i>out</i></b>.println(headImg.getOriginalFilename());//获取上传文件的完整名称</p><p>  //获取上传文件对应的输入流</p><p>  //InputStream in = headImg.getInputStream();</p><p>  //创建一个磁盘目录用于保存文件</p><p>  File destFile= <b>new</b> File(&#34;c:/upload&#34;);</p><p><b>if</b>(!destFile.exists()) {</p><p>   destFile.mkdir();</p><p>  }</p><p>  //使用<u>uuid</u>作为文件随机名称</p><p>  String fileName = UUID.<i>randomUUID</i>().toString().replaceAll(&#34;-&#34;, &#34;&#34;);</p><p>  //使用FileNameUtils获取上传文件名的后缀</p><p>  String extension = FilenameUtils.<i>getExtension</i>(headImg.getOriginalFilename());// <u>jpg</u> , <u>png</u> 等等</p><p>  //创建新的文件名称</p><p>  String newFileName = fileName + &#34;.&#34;+extension;</p><p>  //创建要保存文件的File对象</p><p>  File file = <b>new</b> File(destFile, newFileName);</p><p>  //保存文件到本地磁盘</p><p>  headImg.transferTo(file);</p><p><b>return</b> &#34;redirect:/upload.jsp&#34;;</p><p> }</p><h2><b>1.4.</b> <b>配置文件上传解析器</b></h2><p>配置文件上传解析器：<b>bean的名字是固定的</b></p><p>使用spring表达式 #{1024*1024}</p><p>&lt;!-- 配置文件上传解析器：bean的名字是固定的,底层使用的名称注入 --&gt;</p><p>&lt;bean id=<i>&#34;multipartResolver&#34;</i> class=<i>&#34;org.springframework.web.multipart.commons.CommonsMultipartResolver&#34;</i>&gt;</p><p> &lt;!-- 设置上传文件的最大尺寸为1MB --&gt;</p><p> &lt;property name=<i>&#34;maxUploadSize&#34;</i> value=<i>&#34;#{1024 * 1024}&#34;</i>&gt;&lt;/property&gt;</p><p>&lt;/bean&gt;</p><h2><b>1.5.</b> <b>多文件上传</b></h2><p>&lt;fieldset&gt;</p><p>  &lt;legend&gt;单个文件上传&lt;/legend&gt;</p><p>  &lt;form action=<i>&#34;</i>${pageContext.request.contextPath}<i>/uploads.do&#34;</i> method=<i>&#34;post&#34;</i> enctype=<i>&#34;multipart/form-data&#34;</i>&gt;</p><p>   文件1: &lt;input type=<i>&#34;file&#34;</i> name=<i>&#34;headImgs&#34;</i>&gt;&lt;br&gt;</p><p>   文件2: &lt;input type=<i>&#34;file&#34;</i> name=<i>&#34;headImgs&#34;</i>&gt;&lt;br&gt;</p><p>   文件3: &lt;input type=<i>&#34;file&#34;</i> name=<i>&#34;headImgs&#34;</i>&gt;&lt;br&gt;</p><p>   &lt;button type=<i>&#34;submit&#34;</i>&gt;提交&lt;/button&gt;</p><p>  &lt;/form&gt;</p><p> &lt;/fieldset&gt;</p><p>@RequestMapping(&#34;/uploads&#34;)</p><p><b>public</b> String singleUploads(MultipartFile[] headImgs) <b>throws</b> IOException {</p><p>  //创建一个磁盘目录用于保存文件</p><p>  File destFile= <b>new</b> File(&#34;c:/upload&#34;);</p><p><b>if</b>(!destFile.exists()) {</p><p>   destFile.mkdir();</p><p>  }</p><p><b>for</b> (<b>int</b> i = 0; i &lt; headImgs.length; i++) {</p><p>   MultipartFile headImg = headImgs[i];</p><p>   //使用<u>uuid</u>作为文件随机名称</p><p>   String fileName = UUID.<i>randomUUID</i>().toString().replaceAll(&#34;-&#34;, &#34;&#34;);</p><p>   //使用FileNameUtils获取上传文件名的后缀</p><p>   String extension = FilenameUtils.<i>getExtension</i>(headImg.getOriginalFilename());// <u>jpg</u> , <u>png</u> 等等</p><p>   //创建新的文件名称</p><p>   String newFileName = fileName + &#34;.&#34;+extension;</p><p>   //创建要保存文件的File对象</p><p>   File file = <b>new</b> File(destFile, newFileName);</p><p>   //保存文件到本地磁盘</p><p><b>try</b> {</p><p>    headImg.transferTo(file);</p><p>   } <b>catch</b> (Exception e) {</p><p>    e.printStackTrace();</p><p>   }</p><p>  }</p><p><b>return</b> &#34;redirect:/upload.jsp&#34;;</p><p> }</p><h2><b>2.</b> <b>文件下载</b></h2><p>文件下载，SpringMVC并没有做过多的封装,还是使用原来的下载方式</p><p><b>package</b> cn.zj.springmvc.controller;</p><p><b>import</b> java.io.FileInputStream;</p><p><b>import</b> java.io.IOException;</p><p><b>import</b> javax.servlet.ServletOutputStream;</p><p><b>import</b> javax.servlet.http.HttpServletResponse;</p><p><b>import</b> org.apache.commons.io.IOUtils;</p><p><b>import</b> org.springframework.stereotype.Controller;</p><p><b>import</b> org.springframework.web.bind.annotation.RequestMapping;</p><p>@Controller</p><p><b>public</b> <b>class</b> DownloadController {</p><p> /*</p><p>  * 下载文件思路</p><p>  * 1. 接受需要下载文件名称，根据文件名称，找到磁盘对应的文件，读取到内存中形成一个输入流</p><p>  * 2. 将输入流通过响应对象（HttpServletResponse）响应给浏览器（下载）</p><p>  * </p><p>  * 注意：Web一般只会下载小型文件</p><p>  * </p><p>  */</p><p> @RequestMapping(&#34;/download&#34;)</p><p><b>public</b> <b>void</b> upload(String fileName ,HttpServletResponse response) <b>throws</b> IOException {</p><p>  //0. 判断是否<u>vip</u>，有积分，金豆</p><p>  //<b>TODO</b></p><p>  //1. 接受文件名，读取磁盘对应的文件，创建输入流对象</p><p>  FileInputStream inputStream = <b>new</b> FileInputStream(&#34;C:/&#34;+fileName);</p><p>  //2.获取响应对象的输出流</p><p>  ServletOutputStream outputStream = response.getOutputStream();</p><p>  //3.文件下载文件名的编码使用ISO-08859-1编码</p><p>  //我们需要将我们UTF-8的 filename转换ISO-8859-1编码</p><p>  //3.1先将字符串以UTF-8转换成字节数组</p><p><b>byte</b>[] bytes = fileName.getBytes(&#34;UTF-8&#34;);</p><p>  //3.2再将字节数组以 ISO-8859-1转换字符串</p><p>  fileName = <b>new</b> String(bytes, &#34;ISO-8859-1&#34;);</p><p>  //4.响应的内容应该是以附件的形式响应给浏览器(设置响应头)</p><p>  response.setHeader(&#34;Content-Disposition&#34;, &#34;attachment;filename=&#34;+fileName);</p><p>  //5.响应文件给浏览器</p><p>  IOUtils.<i>copy</i>(inputStream, outputStream);</p><p> }</p><p>}</p><h2><b>3.</b> <b>SpringMVC的拦截器</b></h2><p>拦截器 ： Interceptor</p><p>Spring MVC 的拦截器类似于Servlet 开发中的过滤器Filter，用于对Controller进行预处理和后处理。</p><p>使用SpringMVC拦截器步骤:</p><p>1)定义拦截器类,实现接口 org.springframework.web.servlet.<b>HandlerInterceptor</b></p><p>2)在applicationContext.xml中配置拦截器</p><p>拦截器方法的执行时机:</p><p>1):preHandle:控制器方法执行之前执行,返回结果为true表示放行,如果返回为false,表示拦截(可以做权限拦截,登录检查拦截).</p><p>2):postHandle:控制器方法执行后,视图渲染之前执行(可以加入统一的响应信息).</p><p>3):afterCompletion:视图渲染之后执行(处理Controller异常信息,记录操作日志，清理资源等)</p><h2><b>3.1.</b> <b>自定义拦截器</b></h2><p><b>public</b> <b>class</b> CheckLoginInterceptor <b>implements</b> HandlerInterceptor {</p><p> //1):preHandle:控制器方法执行之前执行,返回结果为true表示放行,如果返回为false,表示拦截(可以做权限拦截,登录检查拦截).</p><p> // true : 放行  false :不放行</p><p> @Override</p><p><b>public</b> <b>boolean</b> preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)</p><p><b>throws</b> Exception {</p><p>  System.<b><i>out</i></b>.println(&#34;拦截器执行了......&#34;);</p><p>  //从Session中获取登录信息</p><p>  String username = (String)request.getSession().getAttribute(&#34;username&#34;);</p><p>  System.<b><i>out</i></b>.println(username);</p><p><b>if</b>(username !=<b>null</b>) {</p><p>   //放行</p><p><b>return</b> <b>true</b>;</p><p>  }<b>else</b> {</p><p>   //跳转到登录页面去</p><p>   response.sendRedirect(request.getContextPath()+&#34;/login.jsp&#34;);</p><p><b>return</b> <b>false</b>;</p><p>  }</p><p> }</p><p> //postHandle:控制器方法执行后,视图渲染之前执行(可以加入统一的响应信息).</p><p> @Override</p><p><b>public</b> <b>void</b> postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,</p><p>   ModelAndView modelAndView) <b>throws</b> Exception {</p><p> }</p><p> //afterCompletion:视图渲染之后执行(处理Controller异常信息,记录操作日志，清理资源等</p><p> @Override</p><p><b>public</b> <b>void</b> afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</p><p><b>throws</b> Exception {</p><p> }</p><p>}</p><h3><b>3.1.1.</b> <b>拦截器的配置的配置</b></h3><p>&lt;?xml version=<i>&#34;1.0&#34;</i> encoding=<i>&#34;UTF-8&#34;</i>?&gt;</p><p>&lt;beans xmlns=<i>&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a>&#34;</i></p><p> xmlns:p=<i>&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/p\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/p</span><span class=\"ellipsis\"></span></a>&#34;</i></p><p> xmlns:mvc=<i>&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/mvc\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/mvc</span><span class=\"ellipsis\"></span></a>&#34;</i></p><p> xmlns:xsi=<i>&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34;</i></p><p> xsi:schemaLocation=<i>&#34;</i></p><p><i><a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans</span><span class=\"ellipsis\"></span></a></i></p><p><i>        <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/beans/spring-beans.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/beans/spring-beans.xsd</span><span class=\"ellipsis\"></span></a></i></p><p><i>        <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/mvc\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/mvc</span><span class=\"ellipsis\"></span></a></i></p><p><i>        <a href=\"https://link.zhihu.com/?target=http%3A//www.springframework.org/schema/mvc/spring-mvc.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">springframework.org/sch</span><span class=\"invisible\">ema/mvc/spring-mvc.xsd</span><span class=\"ellipsis\"></span></a></i></p><p><i>        &#34;</i>&gt;</p><p>  &lt;!-- 配置<u>springmvc</u>的注解驱动 --&gt;</p><p>  &lt;mvc:annotation-driven/&gt;</p><p>  &lt;!-- 配置拦截器 :可以有多个拦截器--&gt;</p><p>  &lt;mvc:interceptors&gt;</p><p>   &lt;!--配置检查登录拦截器  --&gt;</p><p>   &lt;mvc:interceptor&gt;</p><p>    &lt;!-- 配置拦截的规则</p><p>        只会拦截 控制器请求，不会拦截<u>jsp</u>页面</p><p>     /*  </p><p>      只能拦截一级 如 ： /list.do /delete.do</p><p>      如：/user/list.do , /user/delete.do 二级 不能拦截</p><p>     /** </p><p>      可以拦截多级 无论几级都可以 如  /a/b/c/d/list.do</p><p>     --&gt;</p><p>    &lt;mvc:mapping path=<i>&#34;/**&#34;</i>/&gt;</p><p>    &lt;!-- 排除拦截的地址，多个地址使用逗号隔开</p><p>     /user/login.do</p><p>     --&gt;</p><p>    &lt;mvc:exclude-mapping path=<i>&#34;/user/login.do&#34;</i>/&gt;</p><p>    &lt;!-- 拦截器的类型 --&gt;</p><p>    &lt;bean class=<i>&#34;cn.tetsuya.ssm.interceptor.CheckLoginInterceptor&#34;</i>/&gt;</p><p>   &lt;/mvc:interceptor&gt;</p><p>  &lt;/mvc:interceptors&gt;</p><p>&lt;/beans&gt;</p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68163596", 
            "userName": "Java小GG", 
            "userLink": "https://www.zhihu.com/people/0ef5f247ebc8acf05e8f4622b612daaa", 
            "upvote": 0, 
            "title": "如何在 Java8 中风骚走位避开空指针异常", 
            "content": "<p>要说 Java 编程中哪个异常是你印象最深刻的，那 <code>NullPointerException</code> 空指针可以说是臭名昭著的。不要说初级程序员会碰到，即使是中级，专家级程序员稍不留神，就会掉入这个坑里。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5ff1eab63955dd4ce7344b90882a96e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"497\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"497\" data-original=\"https://pic1.zhimg.com/v2-5ff1eab63955dd4ce7344b90882a96e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;497&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"497\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"497\" data-original=\"https://pic1.zhimg.com/v2-5ff1eab63955dd4ce7344b90882a96e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5ff1eab63955dd4ce7344b90882a96e0_b.jpg\"/></figure><p><code>Null</code> 引用的发明者 Tony Hoare 曾在 2009 年作出道歉声明，声明中表示，到目前为止，空指针异常大约给企业已造成数十亿美元的损失。</p><p>下面是 Tony Hoare 的原话：</p><blockquote>我将 Null 引用的设计称为是一个数十亿美元的错误。1965 那年，我正在用面向对象语言(ALGOL W) 设计首个功能全面的系统。当时我的考量是，确保所有被使用的引用都是安全的，编译器会自动进行检查。但是，我没有抵住诱惑，加入了 Null 引用，仅仅是为了实现起来省事。这之后，它导致了数不清的 bug、错误和系统崩溃，也为企业导致了不可估量的损失。</blockquote><p>事已至此，我们必须学会面对它。So, 我们要如何防止空指针异常呢？</p><p>唯一的办法就是对可能为 Null 的对象添加检查。但是 Null 检查是繁琐且痛苦的。所以一些比较新的语言为了处理 Null 检查，特意添加了特殊的语法，如空合并运算符。</p><blockquote>在 Groovy 或 Kotlin 这样的语言中也被称为 <code>Elvis</code> 运算符。</blockquote><p>不幸的是，在老版本的 Java 中并没有提供这样的语法糖。Java8 中在这方面做了改进。所以，这篇文章就特意来介绍一下如何在 Java8 中利用新特性来编写防止 <code>NullPointerException</code>的发生。</p><h2>Java8 中如何加强对 Null 对象的检查？</h2><p>在上篇文章 Java8 新特性指导手册 中简单的提了一下如何通过 <code>Optional</code> 类来对对象做空校验。接下来，我们再细说一下：</p><p>在业务系统中，对象中嵌套对象是经常发生的场景，如下示例代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 最外层对象\nclass Outer {\n    Nested nested;\n    Nested getNested () {\n        return nested;\n    }\n}\n// 第二层对象\nclass Nested {\n   Inner inner ;\n   Inner getInner (){\n        return inner ;\n    }\n}\n// 最底层对象\nclass Inner {\n    String foo;\n    String getFoo () {\n        return foo;\n    }\n}</code></pre></div><p>业务中，假设我们需要获取 <code>Outer</code> 对象对底层的 <code>Inner</code> 中的 <code>foo</code> 属性，我们必须写一堆的非空校验，来防止发生 <code>NullPointerException</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 繁琐的代码\nOuter outer = new Outer(); \nif (outer != null &amp;&amp; outer.nested != null &amp;&amp; outer.nested.inner != null) {\n    System.out.println(outer.nested.inner.foo);\n}</code></pre></div><h2>通过 Optional</h2><p>在 Java8 中，我们有更优雅的解决方式，那就是使用 <code>Optional</code>是说，我们可以在一行代码中，进行流水式的 <code>map</code> 操作。而 <b>map 方法内部会自动进行空校验</b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">Optional.of(new Outer())\n .map(Outer::getNested)\n .map(Nested::getInner)\n .map(Inner::getFoo\n .ifPresent(System.out::println); // 如果不为空，最终输出 foo 的值</code></pre></div><h2>通过 suppiler 函数自定义方法</h2><p>上面这种方式个人感觉还是有点啰嗦，我们可以利用 <code>suppiler</code> 函数来出一个终极解决方案：</p><div class=\"highlight\"><pre><code class=\"language-text\">public static &lt;T&gt; Optional&lt;T&gt; resolve(Supplier&lt;T&gt; resolver) {\n    try {\n        T result = resolver.get();\n        return Optional.ofNullable(result);\n    }\n    catch (NullPointerException e) {\n      // 可能会抛出空指针异常，直接返回一个空的 Optional 对象\n       return Optional.empty();\n    }\n}</code></pre></div><p>利用上面的 <code>resolve</code> 方法来重构上述的非空校验代码段：</p><div class=\"highlight\"><pre><code class=\"language-text\">Outer obj = new Outer();\n// 直接调用 resolve 方法，内部做空指针的处理\nresolve(() -&gt; obj.getNested().getInner().getFoo());\n   .ifPresent(System.out::println); // 如果不为空，最终输出 foo 的值\n</code></pre></div><blockquote>个人觉得，真要拿这点性能说事，还不如去优化优化 <code>sql</code> 语句，业务逻辑等。作者：犬小哈   来源：小哈学java</blockquote>", 
            "topic": [
                {
                    "tag": "Java 8", 
                    "tagLink": "https://api.zhihu.com/topics/19936714"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "Lyceum", 
                    "userLink": "https://www.zhihu.com/people/0828ce2c1e0c33c8caf5afbdeb5d3034", 
                    "content": "是不是多了一个分号[不抬杠]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "夏诺多吉", 
                            "userLink": "https://www.zhihu.com/people/d499d44ea30458bfe1e784827fa07c39", 
                            "content": "是的", 
                            "likes": 0, 
                            "replyToAuthor": "Lyceum"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68185547", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "MyBatis学习", 
            "content": "<p>MyBatis</p><p>MyBatis的xml文件</p><p>标签</p><p>&lt;sql&gt;  用于声明公有的SQL语句块.,在操作标签中使用&lt;include&gt;调用 [不建议用]</p><p>不建议的原因，会导致代码难以维护。</p><p>&lt;if&gt;  类似java if(){},用于判断</p><p>&lt;foreach&gt;:类似java的foreach循环,一般用户批量处理的SQL语句</p><p>&lt;trim&gt; :切割标签,主要用于切割关键字的头和尾的字符.新版的Mybatis使用的几率很少.</p><p>&lt;set&gt;:使用 set标签就是SQL语言的set关键字,可以在update 的时候set 关键字后面的,逗号可以自动忽略</p><p>&lt;where&gt;:使用where标签作为SQL语言的where关键字,好处如果where后面的条件都不成立,忽略where关键字.</p><p>&lt;choose&gt; &lt;when&gt; &lt;otherwise&gt; :  java的swithc case</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态sql除了支持xml方式以外，还是支持使用纯注解的方式</p><p>主要一下四个注解+对应动态sql语句的类文件</p><ol><li>@SelectProvider  动态查询SQL语句对应注解</li><li>@InsertProvider  动态插入SQL语句对应注解</li><li>@UpdateProvider  动态修改SQL语句对应注解</li><li>@DeleteProvider  动态删除SQL语句对应注解</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>在Mybatis里面,所谓的缓存就是将已经查询过的记录放在内存的缓冲区或文件上,这样如果再次查询,可以通过配置的策略,命中已经查询过的记录.从而提高查询的效率.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>缓存作用</p><p>提高查询的效率.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Mybatis的缓存分为一级缓存\\ 二级缓存</p><p></p><p>一级缓存:所谓的一级缓存就是会话(SqlSesion对象)级别的缓存,就是同一个会话,如果已经查询过的数据会保存一份在内存中,如果会话没有关闭,再次调用同样的方法查询,不会再查询数据库,而是直接从缓存中取出之前查询的数据.</p><p></p><p>一级缓存默认是打开的,而且是关闭不了的.</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何清空一级缓存.</p><p>1.关闭会话.close()</p><p>2.进行了操作(增删改)，提交了commit();</p><p>3.手工清除缓存clearCache()</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>一级缓存是SqlSession对象级别,在每一次会话中有效</p><p></p><p>二级缓存是 SqlSessionFactory级别,在整个应用都有效,可以在多个会话有效</p><p>MyBatis本身并没有实现二级缓存</p><p></p><p>二级缓存需要第三方缓存提供商的支持</p><p>Ehcache -第三方缓存(Hibernate框架默认就是支持)</p><p></p><p>学习地址</p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.mybatis.org/ehcache-cache/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">mybatis.org/ehcache-cac</span><span class=\"invisible\">he/</span><span class=\"ellipsis\"></span></a></p><p>下载地址ehcache</p><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mybatis/ehcache-cache/releases\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/mybatis/ehca</span><span class=\"invisible\">che-cache/releases</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>导入jar包，需要同时导入日志包（依赖包）：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a324447be51bbcb1f3542b7d0cb3a302_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"184\" data-rawheight=\"43\" class=\"content_image\" width=\"184\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;184&#39; height=&#39;43&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"184\" data-rawheight=\"43\" class=\"content_image lazy\" width=\"184\" data-actualsrc=\"https://pic3.zhimg.com/v2-a324447be51bbcb1f3542b7d0cb3a302_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0774adcd767c287b31e87dace12eca7a_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"186\" data-rawheight=\"47\" class=\"content_image\" width=\"186\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;186&#39; height=&#39;47&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"186\" data-rawheight=\"47\" class=\"content_image lazy\" width=\"186\" data-actualsrc=\"https://pic3.zhimg.com/v2-0774adcd767c287b31e87dace12eca7a_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>创建ehcache.xml配置文件，Ehcache有自己的配置文件,在src下面创建ehcache.xml 配置文件</p><p>&lt;ehcache&gt;<br/>&lt;!-- 缓存的磁盘位置 --&gt;<br/>&lt;diskStore path=&#34;D:/mybatis_cache&#34;/&gt;<br/>&lt;!-- 默认的缓存策略: 如果开发者在某一个需要缓存的文件配置了自定义缓存,就不使用默认的,如果没有配置,就使用默认缓存策略--&gt;<br/>    &lt;defaultCache<br/>        maxElementsInMemory=&#34;10000&#34;<br/>        eternal=&#34;false&#34;<br/>        timeToIdleSeconds=&#34;120&#34;<br/>        timeToLiveSeconds=&#34;120&#34;<br/>        overflowToDisk=&#34;true&#34;<br/>      /&gt;<br/>&lt;/ehcache&gt;</p><p>在映射文件中配置&lt;cache&gt;以及配置对应的缓存策略</p><p>&lt;mapper namespace=&#34;cn.tetsuya.mybatis.dao.UserMapper&#34;&gt;<br/>&lt;!-- 当前表的映射开启支持二级缓存,并设置相关的缓存提供商,以及缓存的相关配置 --&gt;<br/>&lt;cache type=&#34;org.mybatis.caches.ehcache.EhcacheCache&#34; &gt;<br/>       &lt;!--最大的空闲时间  --&gt;<br/>       &lt;property name=&#34;timeToIdleSeconds&#34; value=&#34;10000&#34;/&gt;<br/>       &lt;!-- 最大的在线时间 --&gt;<br/>       &lt;property name=&#34;timeToLiveSeconds&#34; value=&#34;20000&#34;/&gt;<br/>       &lt;!-- 内存的大小 b字节 m1 =1024k 1k=1024b --&gt;<br/>       &lt;property name=&#34;maxEntriesLocalHeap&#34; value=&#34;2000000&#34;/&gt;<br/>       &lt;!-- 文件的大小 b字节--&gt;<br/>       &lt;property name=&#34;maxEntriesLocalDisk&#34; value=&#34;20000000&#34;/&gt;<br/>       &lt;!-- 算法 LRU:最少使用优先, &#34;LFU&#34; or &#34;FIFO:先进先出 --&gt;<br/>       &lt;property name=&#34;memoryStoreEvictionPolicy&#34; value=&#34;LRU&#34;/&gt;<br/>    &lt;/cache&gt;<br/>&lt;select id=&#34;selectAll&#34; resultType=&#34;User&#34;&gt;<br/>select * from user<br/>&lt;/select&gt;<br/>&lt;/mapper&gt;<br/><br/></p><p>因为二级缓存可以将对象序列化到本地，涉及到对象序列化，因此对象对应的javabean必须实现序列化接口</p><p class=\"ztext-empty-paragraph\"><br/></p><p>MyBatis的逆向工程能自动帮开发者生成数据库表对应的 pojo实体文件,自动生成映射文件</p><p>自定生成表的各种(CRUD)的sql语句, 但是只能做单表操作,联合查询还得开发者自己动手</p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }, 
                {
                    "tag": "Java 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19702290"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68293051", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "Spring框架学习（一）", 
            "content": "<p>Spring<br/>Spring是一个JavaEE轻量级的一站式开发框架<br/><br/><br/>优秀的架构：可维护性好，可扩展性好，性能<br/>业界公认标准：高内聚，低耦合<br/><br/><br/>高内聚：尽量将代码卸载与功能描述一致的模块中<br/>低耦合：尽量减少类与类之间的直接关系<br/><br/><br/>Spring框架核心：就是通过loC（控制反转）实现程序的解耦，从而提高程序的维护性和扩展性<br/>Spring在开发中主要是与其他框架进行整合（相当于一个容器）<br/><br/><br/>Spring核心容器包含：Beans、Core、Context 、SpEL<br/><br/><br/>Spring官网----&gt;<a href=\"https://link.zhihu.com/?target=http%3A//spring.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">spring.io</span><span class=\"invisible\"></span></a><br/><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fe220dcafbfe488ff097962d9a86e10c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"447\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic1.zhimg.com/v2-fe220dcafbfe488ff097962d9a86e10c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"447\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic1.zhimg.com/v2-fe220dcafbfe488ff097962d9a86e10c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fe220dcafbfe488ff097962d9a86e10c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p><br/><br/>Spring创建项目<br/></p><ol><li>新建java项目</li><li>导入4个jar包，commons-logging包</li><li>src下创建applicationContext.xml，在官方beans.html中找到代码复制</li><li>新建包，创建类（普通在测试类中new对象是强耦合--正控，需要用&lt;bean&gt;来解耦--反控）</li><li>测试类：</li><ol><li>读取applicationContext.xml配置文件，创建Spring容器对象：ApplicationContext context = new ClassPathXmlApplicationContext(&#34;applicationContext.xml&#34;);</li><li>调用容器对bean管理：CustomService customeService = context.getBean(&#34;customService&#34;,CustomService.class);</li></ol></ol><p><br/><br/>IoC控制反转和依赖注入<br/>IoC（Inverse of Control）相当于使用反射获取对象<br/>DI（Dependency Injection）相当于使用反射中get，set方法为属性赋值<br/><br/><br/></p><ul><li>新建接口和对应的N个接口实现类，service层</li><li>新建web层类，并且声明接口和创建其对应的set方法（IoC和DI）</li><li>配置applicationContext.xml，将接口和实现类写入bean标签并添加接口的依赖关系</li><li>新建测试类，web层类直接调用其接口的方法</li></ul><p><br/><br/>Spring的xml配置中的标签<br/>&lt;alias name=&#34;需要取别名的&lt;bean&gt;id&#34; alias=&#34;别名&#34;/&gt;<br/><br/><br/>&lt;bean <br/>id=&#34;类的唯一标识符&#34; <br/>class=&#34;类的全限定名&#34; <br/>name=&#34;标识，早期可以写特殊字符，可以写多个名称&#34; <br/>scope=&#34;生命周期（singleton,prototype,request,session）&#34; <br/>init-method=&#34;初始化方法创建对象后立即执行，方法名称&#34; <br/>destroy-method=&#34;销毁方法，单例对象会在容器销毁时销毁，多例不会销毁多例对象由开发者管理&#34;&gt;<br/>&lt;/bean&gt;<br/><br/><br/>&lt;property name=&#34;需要注入的属性名称&#34; value=&#34;基本数据类型&#34;/ref=&#34;引用数据类型&#34;/&gt;<br/>&lt;constructor-arg name=&#34;构造方法参数名称&#34; index=&#34;参数位置&#34; type=&#34;参数类型&#34; value=&#34;&#34;/ref=&#34;&#34;/&gt;<br/><br/><br/>获得properties的值，可以通过${key}读取配置文件中的值<br/><br/><br/>Spring最主要使用IoC控制反转和依赖注入，将各个类之间的联系，依赖写xml的在&lt;bean&gt;中，不需要直接new对象，降低耦合度。所以Spring是轻量级（Spring共20个模块，只需要四个模块就可以启动框架，其余按需引入）、一站式（web开发的三层结构全部用Spring完成）的框架<br/><br/><br/>IoC创建实例有四种方式：<br/></p><ol><li>直接使用无参构造函数-推荐</li><li>使用静态工厂</li><li>使用实例工厂</li><li>使用变种实力工厂，工厂实现FactoryBean接口</li></ol><p>DI依赖注入：<br/></p><ol><li>将对象的属性通过Spring赋值</li><li>setter方法（属性）注入</li><li>构造器注入</li><li>p命名空间注入</li><li>支持值类型，引用类型和支持各种集合数据类型的注入</li></ol><p><br/><br/><br/><br/>注解<br/>Spring常用组件注解：@Component , @Controller , @Service , @Repository<br/>Spring中的Compoment注解在spring2.5中就出现了，后面三者都是在3.0之后基于分层需要分化出来的，本质上这些注解的功能都是一样的，都是创建对象，开发中三者分别用于表现层，业务层，持久层<br/><br/><br/>注解的属性<br/>@Scope（表明生命周期，用于类上面）<br/>@PostConstruct（初始化方法，用于方法上面）<br/>@PreDestroy（销毁方法，用于方法上面）<br/><br/><br/>用户依赖注入的注解（字段/成员变量注入）-- 推荐<br/>@Autowired（字段/成员变量注入，默认是按照类型注入，默认会从Spring容器找到对应类型的对象进来。必须保证该类型至少有一个对应的bean，可以使用required属性表明是否必须有对象。用法是直接将其贴在成员变量上面）<br/>@Qulifier(配合@Autowired，可以用于筛选出有多个相同类型的对象，用id区分，用法是直接将其贴在成员变量上面)<br/><br/><br/>用户依赖注入的注解（set方法/属性注入）<br/>@Autowired（set方法/属性注入，默认是按照类型注入，程序是会执行set方法，用法是直接将其贴在set方法上面）<br/>@Qulifier(配合@Autowired，可以用于筛选出有多个相同类型的对象，用id区分，用法是直接将其贴在set方法上面)<br/><br/><br/>用户依赖注入的注解（构造器注入）：使用注解的IoC创建bean的情况下，默认bean中有什么构造器，spring就调用哪个构造器去创建对应的bean对象，并且自动注入<br/>如果构造函数的参数类型有对应的多个bean，可以在参数前面添加@Qulifier<br/><br/><br/>@Resource<br/>字段注入：直接将其放在字段/成员变量上面。默认类型注入。可以用name属性区同类型多个对象，必须要保证注入的类型在Spring容器中最少有一个对象<br/>方法注入：直接放在set方法/属性上面。默认类型注入。可以用name属性区同类型多个对象，必须要保证注入的类型在Spring容器中最少有一个对象<br/>构造器注入：@Resource无法放在构造器上面<br/><br/><br/>@Value<br/>可以将xml文件中读取配置文件的内容，直接贴在字段上，直接可以将其value值直接设置给字段，开发者也可以手动赋值<br/></p><hr/><p>可以写一个java类代替xml文件，使用完全的注解方式<br/><br/><br/>正确的测试Spring容器<br/>JVM--&gt;Spring容器--&gt;Junit--&gt;Test--&gt;测试代码<br/>导入spring的test包<br/>@Runwith(SpringJUnit4ClassRunner)<br/>@ContextConfiguration(&#34;classpath:applicationContext.xml&#34;)<br/>public void testName() throws Exception {<br/><br/>}<br/>可以在容器里面一次运行多个测试方法<br/><br/><br/>Ps：<br/></p><ol><li>注解使用必须在xml文件中配置包扫描位置</li><ol><li>&lt;context:component-scan base-package=&#34;cn.tetsuya.service&#34;/&gt;</li></ol><li>存注解配置替代xml文件，但是所有配置依旧存在，只是配置方式换成在类上面----SpringBoot</li><li>SpringJDBC主要优点是能够让Spring自动控制事务，JdbcTemplate模板类可以进行数据表的增删改查</li><li>JdbcDaoSupport可以将模板类重复代码进行封装，缺点是只能在xml中配置对应的DAO类</li></ol><p></p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }, 
                {
                    "tag": "Java 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19702290"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68607982", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 0, 
            "title": "Spring框架学习（二）", 
            "content": "<p>AOP思想</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>代理模式</li><ol><li>JDK动态代理</li><li>CGLIB第三方代理</li></ol><li>AOP思想在Spring具体体现（AOP底层就是使用的动态代理）</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>AOP（Aspect Oriented Programming）面向切面编程</p><p>主要是可以提高编程效率--解耦，在运行期间，不修改相关的任何已有的源代码，对原有的方法进行增强，可以减少重复代码，维护方便</p><p class=\"ztext-empty-paragraph\"><br/></p><p>动态代理技术</p><p>使用者使用的不是真实对象，而是使用一个代理对象，而这个代理对象包含的就是真实对象，代理对象就是不改变原有对象的功能方法的基础之上封装的新功能</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JDK使用Proxy创建代理对象，Proxy实现Serializable接口</p><p>*创建Proxy实例需要实现InvocationHandler的接口</p><p>JDK动态代理的对象必须要实现接口（至少一个），需要为每个对象创建代理对象（Service），其最小单位是类，该类的所有方法都会被代理，可能有不需要的方法也会被代理</p><p class=\"ztext-empty-paragraph\"><br/></p><p>CGLIB</p><ol><li>使用Enhancer类创建代理对象</li><li>AOP的术语：joinpoint , pointcut , advice , aspect(pointcut+advice) , weaving</li><li>AOP的xml配置标签：config , aspect , pointcut , before , after-returning , after-throwing , after , around</li><li>AOP的注解配置</li></ol>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }, 
                {
                    "tag": "Java 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19702290"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66033213", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 2, 
            "title": "Ajax入门随笔", 
            "content": "<p>Ajax(Asynchronous Javascript And XML)<br/>异步JavaScript和XML<br/>作用&amp;原理：在不刷新整个页面的情况下，通过xhr向后台偷偷发起请求，在通过DOM将查询的数据显示在页面中<br/><br/><br/>(xhr)XMLHttpRequest对象就是ajax的引擎<br/>步骤：<br/></p><ol><li>创建对象</li><ol><li>var xhr = new XMLHttpRequest();</li></ol><li>监听，readystate</li><ol><li>xhr.onreadystatechange = function(){if(xhr.readyState == 4 &amp;&amp; xhr.status == 200 ){xhr.responseText}}</li></ol><li>调用open方法，创建请求</li><ol><li>xhr.open(method,url,async);</li></ol><li>调用dend方法，发送请求</li><ol><li>xhr.send();</li></ol></ol><p><br/><br/><br/><br/>ajax发送数据<br/></p><ol><li>get请求</li><ol><li>将数据放在url后面</li></ol><li>post请求</li><ol><li>将数据放在url后面</li><li>将数据放在send中 （aaa=bbb）</li><li>设定请求头</li></ol></ol><p>xhr.send(&#34;get&#34;,&#34;url?aaa=bbb&#34;,true);//get方式或者post方式都可以用<br/>xhr.send();<br/>xhr.setRequestHeader(&#34;content-type&#34;, &#34;application/x-www-form-urlencoded&#34;);<br/>xhr.send(&#34;aaa=bbb&#34;);//post方式，用于放在请求实体中</p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66117222", 
            "userName": "夜雨寒", 
            "userLink": "https://www.zhihu.com/people/fbf2d45c8afaa36b511c06aa2afc0820", 
            "upvote": 0, 
            "title": "Vue组件开发与发布", 
            "content": "<p>Vue.js 作为当下比较热门的技术，它的核心库只关注视图层，容易上手。组件是Vue.js最强大的功能之一。组件可以扩展HTML元素，封装可重用的代码。在较高层面上，组件是自定义的元素，Vue.js的编译器为它添加特殊功能。在有些情况下，组件也可以是原生HTML元素的形式，以js特性扩展。</p><p>这篇文章带你创建属于自己的组件库，并打包到 npm 供更多人使用。</p><h3>一、 创建 Vue 项目</h3><p>使用 vue-cli 脚手架创建项目 guoxb-ui</p><p><code>vue init webpack guoxb-ui</code></p><p>当然，也可以用 <code>vue init webpack-simple guoxb-ui</code> 创建简洁的项目</p><h3>二、 项目架构目录</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9e80c0989427b20492def81754c4bf45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"309\" class=\"content_image\" width=\"268\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;268&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"309\" class=\"content_image lazy\" width=\"268\" data-actualsrc=\"https://pic2.zhimg.com/v2-9e80c0989427b20492def81754c4bf45_b.jpg\"/></figure><p><br/>ico_jiegou.png</p><p>通过运行上述指令，生成的项目结构如图所示，大结构基本不用动，只需要添加自己的配置文件以及自己的文件夹即可。</p><p>添加的配置如下（从上至下依次拆分）：</p><h3>1. build 目录添加 webpack.dist.config.js</h3><p>build 目录下存放着 webpack 的配置信息，在该目录下添加了一个单独打包插件的配置文件 webpack.dist.config.js</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">path</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;path&#39;</span><span class=\"p\">)</span>\n<span class=\"kd\">var</span> <span class=\"nx\">webpack</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"s1\">&#39;webpack&#39;</span><span class=\"p\">)</span>\n\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n<span class=\"o\">**</span><span class=\"nx\">entry</span><span class=\"o\">:</span> <span class=\"s1\">&#39;./src/plugin/index.js&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// 入口文件\n</span><span class=\"c1\"></span>  <span class=\"nx\">output</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">path</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;../dist&#39;</span><span class=\"p\">),</span> <span class=\"c1\">// 打包后的文件放这里\n</span><span class=\"c1\"></span>    <span class=\"nx\">publicPath</span><span class=\"o\">:</span> <span class=\"s1\">&#39;/dist/&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">filename</span><span class=\"o\">:</span> <span class=\"s1\">&#39;guoxb-ui.js&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">library</span><span class=\"o\">:</span> <span class=\"s1\">&#39;guoxb-ui&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// library指定的是引入项目的模块名\n</span><span class=\"c1\"></span>    <span class=\"nx\">libraryTarget</span><span class=\"o\">:</span> <span class=\"s1\">&#39;umd&#39;</span><span class=\"p\">,</span> <span class=\"c1\">// libraryTarget会生成不同umd的代码,可以只是commonjs标准的，也可以是指amd标准的，也可以只是通过script标签引入的（必须加上）\n</span><span class=\"c1\"></span>    <span class=\"nx\">umdNamedDefine</span><span class=\"o\">:</span> <span class=\"kc\">true</span> <span class=\"c1\">// 会对 UMD 的构建过程中的 AMD 模块进行命名。否则就使用匿名的 define（必须加上）\n</span><span class=\"c1\"></span>  <span class=\"p\">},</span><span class=\"o\">**</span>\n  <span class=\"nx\">module</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">rules</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.css$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">use</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n          <span class=\"s1\">&#39;vue-style-loader&#39;</span><span class=\"p\">,</span>\n          <span class=\"s1\">&#39;css-loader&#39;</span>\n        <span class=\"p\">],</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.scss$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">use</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n          <span class=\"s1\">&#39;vue-style-loader&#39;</span><span class=\"p\">,</span>\n          <span class=\"s1\">&#39;css-loader&#39;</span><span class=\"p\">,</span>\n          <span class=\"s1\">&#39;sass-loader&#39;</span>\n        <span class=\"p\">],</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.sass$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">use</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n          <span class=\"s1\">&#39;vue-style-loader&#39;</span><span class=\"p\">,</span>\n          <span class=\"s1\">&#39;css-loader&#39;</span><span class=\"p\">,</span>\n          <span class=\"s1\">&#39;sass-loader?indentedSyntax&#39;</span>\n        <span class=\"p\">],</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.vue$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">loader</span><span class=\"o\">:</span> <span class=\"s1\">&#39;vue-loader&#39;</span><span class=\"p\">,</span>\n        <span class=\"nx\">options</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"nx\">loaders</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// Since sass-loader (weirdly) has SCSS as its default parse mode, we map\n</span><span class=\"c1\"></span>            <span class=\"c1\">// the &#34;scss&#34; and &#34;sass&#34; values for the lang attribute to the right configs here.\n</span><span class=\"c1\"></span>            <span class=\"c1\">// other preprocessors should work out of the box, no loader config like this necessary.\n</span><span class=\"c1\"></span>            <span class=\"s1\">&#39;scss&#39;</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n              <span class=\"s1\">&#39;vue-style-loader&#39;</span><span class=\"p\">,</span>\n              <span class=\"s1\">&#39;css-loader&#39;</span><span class=\"p\">,</span>\n              <span class=\"s1\">&#39;sass-loader&#39;</span>\n            <span class=\"p\">],</span>\n            <span class=\"s1\">&#39;sass&#39;</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n              <span class=\"s1\">&#39;vue-style-loader&#39;</span><span class=\"p\">,</span>\n              <span class=\"s1\">&#39;css-loader&#39;</span><span class=\"p\">,</span>\n              <span class=\"s1\">&#39;sass-loader?indentedSyntax&#39;</span>\n            <span class=\"p\">]</span>\n          <span class=\"p\">}</span>\n          <span class=\"c1\">// other vue-loader options go here\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.js$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">loader</span><span class=\"o\">:</span> <span class=\"s1\">&#39;babel-loader&#39;</span><span class=\"p\">,</span>\n        <span class=\"nx\">exclude</span><span class=\"o\">:</span> <span class=\"sr\">/node_modules/</span>\n      <span class=\"p\">},</span>\n      <span class=\"p\">{</span>\n        <span class=\"nx\">test</span><span class=\"o\">:</span> <span class=\"sr\">/\\.(png|jpg|gif|svg)$/</span><span class=\"p\">,</span>\n        <span class=\"nx\">loader</span><span class=\"o\">:</span> <span class=\"s1\">&#39;file-loader&#39;</span><span class=\"p\">,</span>\n        <span class=\"nx\">options</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;[name].[ext]?[hash]&#39;</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">resolve</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">alias</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"s1\">&#39;vue$&#39;</span><span class=\"o\">:</span> <span class=\"s1\">&#39;vue/dist/vue.esm.js&#39;</span>\n    <span class=\"p\">},</span>\n    <span class=\"nx\">extensions</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"s1\">&#39;*&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.js&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.vue&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;.json&#39;</span><span class=\"p\">]</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">devServer</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">historyApiFallback</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"nx\">noInfo</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n    <span class=\"nx\">overlay</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">performance</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">hints</span><span class=\"o\">:</span> <span class=\"kc\">false</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">devtool</span><span class=\"o\">:</span> <span class=\"s1\">&#39;#eval-source-map&#39;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">NODE_ENV</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;production&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">devtool</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;#source-map&#39;</span>\n  <span class=\"c1\">// http://vue-loader.vuejs.org/en/workflow/production.html\n</span><span class=\"c1\"></span>  <span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">plugins</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">plugins</span> <span class=\"o\">||</span> <span class=\"p\">[]).</span><span class=\"nx\">concat</span><span class=\"p\">([</span>\n    <span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">DefinePlugin</span><span class=\"p\">({</span>\n      <span class=\"s1\">&#39;process.env&#39;</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">NODE_ENV</span><span class=\"o\">:</span> <span class=\"s1\">&#39;&#34;production&#34;&#39;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}),</span>\n    <span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">optimize</span><span class=\"p\">.</span><span class=\"nx\">UglifyJsPlugin</span><span class=\"p\">({</span>\n      <span class=\"nx\">sourceMap</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span>\n      <span class=\"nx\">compress</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n        <span class=\"nx\">warnings</span><span class=\"o\">:</span> <span class=\"kc\">false</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}),</span>\n    <span class=\"k\">new</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">LoaderOptionsPlugin</span><span class=\"p\">({</span>\n      <span class=\"nx\">minimize</span><span class=\"o\">:</span> <span class=\"kc\">true</span>\n    <span class=\"p\">})</span>\n  <span class=\"p\">])</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这段配置代码实际是 <code>npm init webpack-simple guoxb-ui</code> 生成项目中的 webpack.config.js 文件中的代码，我们只需要改的就是 入口文件 和 输出文件</p><h3>2. src下创建plugin文件夹，所有自定义组件都放这里</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-903e91107cb1bc896f2c1e68df92c795_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"216\" data-rawheight=\"149\" class=\"content_image\" width=\"216\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;216&#39; height=&#39;149&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"216\" data-rawheight=\"149\" class=\"content_image lazy\" width=\"216\" data-actualsrc=\"https://pic2.zhimg.com/v2-903e91107cb1bc896f2c1e68df92c795_b.jpg\"/></figure><p><br/>ico_jiegou3.png</p><p>其中，button 文件夹存放 自定义的button组件 button.vue 以及 用于导出组件的 index.js；</p><p>plugin 目录下的 index.js 用于添加我们的组件内容，以及注册组件。</p><h3>plugin -&gt; button -&gt; button.vue 源码</h3><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"nt\">&lt;template&gt;</span>\n  <span class=\"nt\">&lt;div&gt;</span>\n    <span class=\"nt\">&lt;button</span>\n      <span class=\"na\">class=</span><span class=\"s\">&#34;guoxb-button&#34;</span>\n      <span class=\"na\">:class=</span><span class=\"s\">&#34;[&#39;guoxb-button--&#39; + type, &#39;guoxb-button--&#39; + (round ? &#39;round&#39; : &#39;&#39;)]&#34;</span>\n    <span class=\"nt\">&gt;</span>\n      <span class=\"nt\">&lt;slot&gt;&lt;/slot&gt;</span>\n    <span class=\"nt\">&lt;/button&gt;</span>\n  <span class=\"nt\">&lt;/div&gt;</span>\n<span class=\"nt\">&lt;/template&gt;</span>\n\n<span class=\"nt\">&lt;script&gt;</span>\nexport default {\n  name: &#34;g-button&#34;, // *** 我们是全局注入组件，所以在后面引入我们的组件后，会使用这个命名的标签 ***\n  props: {\n    type: {\n      type: String,\n      default: &#34;normal&#34;\n    },\n    round: {\n      type: Boolean,\n      default: false\n    }\n  }\n};\n<span class=\"nt\">&lt;/script&gt;</span>\n\n<span class=\"nt\">&lt;style</span> <span class=\"err\">scoped</span><span class=\"nt\">&gt;</span>\n.guoxb-button {\n  font-size: 14px;\n  color: #f68;\n  background: #fff;\n  border: 1px solid #eee;\n}\n.guoxb-button--normal {\n  width: 100px;\n  line-height: 40px;\n}\n.guoxb-button--small {\n  width: 80px;\n  line-height: 30px;\n  font-size: 12px;\n}\n.guoxb-button--large {\n  width: 120px;\n  line-height: 50px;\n  font-size: 16px;\n}\n.guoxb-button--round {\n  border-radius: 5px;\n}\n<span class=\"nt\">&lt;/style&gt;</span></code></pre></div><h3>plugin -&gt; button -&gt; index.js 源码</h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">export</span> <span class=\"p\">{</span> <span class=\"k\">default</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./button.vue&#39;</span><span class=\"p\">;</span>\n</code></pre></div><h3>plugin -&gt; index.js 源码</h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"nx\">GButton</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./button&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"o\">***</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./***&#39;</span><span class=\"p\">;</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">install</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">Vue</span><span class=\"p\">,</span> <span class=\"nx\">options</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">install</span><span class=\"p\">.</span><span class=\"nx\">installed</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">component</span><span class=\"p\">(</span><span class=\"nx\">GButton</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"nx\">GButton</span><span class=\"p\">);</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">component</span><span class=\"p\">(</span><span class=\"o\">***</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">,</span> <span class=\"o\">***</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* 支持使用标签的方式引入 */</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"k\">typeof</span> <span class=\"nb\">window</span> <span class=\"o\">!==</span> <span class=\"s1\">&#39;undefined&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">Vue</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">install</span><span class=\"p\">(</span><span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">Vue</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n    <span class=\"nx\">install</span><span class=\"p\">,</span>\n    <span class=\"nx\">GButton</span><span class=\"p\">,</span>\n    <span class=\"o\">***</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3>疑问：为什么在button文件夹下还要创建index.js</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9413f8d7d00000ba5e5d4d1ffa868b15_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb\" width=\"928\" data-original=\"https://pic2.zhimg.com/v2-9413f8d7d00000ba5e5d4d1ffa868b15_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;928&#39; height=&#39;502&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"928\" data-original=\"https://pic2.zhimg.com/v2-9413f8d7d00000ba5e5d4d1ffa868b15_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9413f8d7d00000ba5e5d4d1ffa868b15_b.jpg\"/></figure><p><br/>1556517520350.jpg</p><p>这是从网上找到的答案，可能并没有太大说服力，所以又仔细的查看了<a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fcn.vuejs.org%252Fv2%252Fguide%252Fplugins.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue官方文档</a></p><blockquote>插件通常用来为 Vue 添加全局功能。插件的功能范围没有严格的限制——一般有下面几种：<br/>(1) 添加全局方法或者属性。如: vue-custom-element<br/>(2) 添加全局资源：指令/过滤器/过渡等。如 vue-touch<br/>(3) 通过全局混入来添加一些组件选项。如 vue-router<br/>(4) 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。<br/>(5) 一个库，提供自己的 API，同时提供上面提到的一个或多个功能。如 vue-router</blockquote><p>不难理解，当我们的组件需要为Vue添加全局功能的时候，是需要在index.js导出组件之前，来完成这步操作的！</p><p>所以，官方文档也给出了为Vue添加全局功能的方法：</p><div class=\"highlight\"><pre><code class=\"language-php\">MyPlugin.install = function (Vue, options) {\n  // 1. 添加全局方法或属性\n  Vue.myGlobalMethod = function () {\n    // 逻辑...\n  }\n\n  // 2. 添加全局资源\n  Vue.directive(&#39;my-directive&#39;, {\n    bind (el, binding, vnode, oldVnode) {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 3. 注入组件选项\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n\n  // 4. 添加实例方法\n  Vue.prototype.$myMethod = function (methodOptions) {\n    // 逻辑...\n  }\n}</code></pre></div><p>这段代码是要写在组件内部的 index.js 里面的。</p><h3>三、 测试组件</h3><p>在任一页面引入组件，作测试，例如：</p><p>在src - components - HelloWorld.vue 下引入组件</p><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"nt\">&lt;template&gt;</span>\n  <span class=\"nt\">&lt;div</span> <span class=\"na\">class=</span><span class=\"s\">&#34;hello&#34;</span><span class=\"nt\">&gt;</span>\n   <span class=\"nt\">&lt;g-button</span> <span class=\"na\">:round=</span><span class=\"s\">&#34;true&#34;</span> <span class=\"na\">type=</span><span class=\"s\">&#34;normal&#34;</span><span class=\"nt\">&gt;</span>按钮<span class=\"nt\">&lt;/g-button&gt;</span>\n  <span class=\"nt\">&lt;/div&gt;</span>\n<span class=\"nt\">&lt;/template&gt;</span>\n\n<span class=\"nt\">&lt;script&gt;</span>\n\nimport Vue from &#39;vue&#39;;\n/* 打包前的组件测试 */\nimport GuoUI from &#39;@/plugin/index.js&#39;;\n/* 打包后的组件测试(打包后，会在项目根目录生成dist文件夹) */\n// import GuoUI from &#39;../../dist/guoxb-ui.js&#39;;\nVue.use(GuoUI);\n\nexport default {\n  name: &#39;HelloWorld&#39;,\n  data () {\n    return {\n\n    }\n  }\n}\n<span class=\"nt\">&lt;/script&gt;</span></code></pre></div><p>运行项目，测试组件</p><h3>四、 打包</h3><p>这里需要修改 package.json 文件，如图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1bbc8b88bd4f9886939782fa1fca170c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"872\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb\" width=\"872\" data-original=\"https://pic1.zhimg.com/v2-1bbc8b88bd4f9886939782fa1fca170c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;872&#39; height=&#39;590&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"872\" data-rawheight=\"590\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"872\" data-original=\"https://pic1.zhimg.com/v2-1bbc8b88bd4f9886939782fa1fca170c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1bbc8b88bd4f9886939782fa1fca170c_b.jpg\"/></figure><p><br/>WX20190429-144512.png</p><ul><li>main属性：打包到dist下的文件，也是以后安装引用使用的js文件</li><li>scripts 中添加 <code>&#34;dist&#34;: &#34;webpack --config build/webpack.dist.config.js&#34;</code> 用于打包</li><li>repository 仓库，可以不写，如果不写，npm官网就没有跳到你github上的入口</li></ul><p>做完以上配置，控制台输入 <code>npm run dist</code> 开始打包，打包成功后，会在项目根目录生成 dist 文件夹，里面是package.json -&gt; main属性配置的 guoxb-ui.js 文件</p><p>可以再引入 dist 下的 guoxb-ui.js 文件测试组件</p><h3>五、 发布组件</h3><p>测试ok了，接下来就是发布组件到 npm，首先得有npm账号，如果没有请走注册。</p><p>控制台，项目根目录下，执行命令：<code>npm login</code> 登录 npm，此时会让输入用户名、密码以及邮箱；</p><p>登录成功之后，执行命令：<code>npm publish</code> 即可。</p><p>记住，每次发布，需要修改 package.json 版本号，不然报错。</p><p>发布完之后，就可以转到我们的 npm官网 上查看我们的项目。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fwww.npmjs.com%252Fpackage%252Fguoxb-ui\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.npmjs.com/package/guoxb-ui</a></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "组件", 
                    "tagLink": "https://api.zhihu.com/topics/19612541"
                }, 
                {
                    "tag": "Vue CLI 3", 
                    "tagLink": "https://api.zhihu.com/topics/20673091"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66352492", 
            "userName": "Java小GG", 
            "userLink": "https://www.zhihu.com/people/0ef5f247ebc8acf05e8f4622b612daaa", 
            "upvote": 4, 
            "title": "为什么是520不是521，为此我采访了几位码农....", 
            "content": "<p>今天就是520了，一个有人欢喜有人愁的大日子。作为一个纯北方爷们很不理解为什么是520呢？怎么读也没有那种像极了爱情的感觉。其实这种问题本不应该问程序员的，奈何圈子太小除了程序员就是码农了。还好，据说程序员是对数字非常敏感的物种，于是怀着一颗忐忑的心采访了几位程序员。</p><p><b>NO1</b></p><p>码农阿呆。人如其名，入坑三年、目光呆滞、头顶泛光，团队中的中流砥柱，用三年的时间就把一个中级程序员活成了高级架构师的样子，可以想象他背后的艰辛。没错，至今单身。我找他的时候他正眉头紧蹙盯着电脑，时而自言自语。一看就是在改bug，一副不知道爱情为何物，只愿代码手中敲的面相。</p><p>”阿呆，你知道为什么大家过520而不是521吗？”</p><p>他看了我一眼，又抬头望着天花板闭着眼，自言自语的不知道在默念着什么，出于程序员对码农的了解，他应该是在做计算。果然大概2分钟左右。</p><p>他说，”520 转化成10进制是1000001000，8进制1010.......521转化后….”</p><p>“没事了，我就是随口一问，逗你玩的，就不打扰你改bug了，你继续....”，我立马打住他，否则他该做位移运算了。</p><p>这一刻，我算明白了，码农单身是有道理的。</p><p><b>NO2</b></p><p>伪码农小明。我带的一个实习生，大学还未毕业。目前还算不上一个真正的码农，至少一眼看过去还没有那种码农的感觉，没穿过一件像样的格子衫，算是我们团队中的一股清流，就是不知道在我们的熏陶下还能坚持多久。目前有对象，但貌似实习后就开始有了裂痕，忘记有多少次凌晨见他敲着代码突然就泪两行了。</p><p>小明，“你们是过520还是521啊？”</p><p>他突然看着我，“cao！cao！cao！完啦！完啦！完啦！只顾着做需求竟然忘了！明天就是520，怎么办？礼物还没准备，需求也没做完…”</p><p>那一刻我仿佛看到了多年前的自己，有多少个伪码农的蜕变是从第一次忘记520开始的。“没事，别着急，你抓紧回去，申请好VPN，带着电脑，需求路上做！”这个可能是他真正成为码农后，我教他的第一个技能。</p><p>他噙着泪，不知道是着急还是感动，说了一声，“谢谢。”</p><p>望着他离去的背影，这句话我还是不忍对他说出口，”好好珍惜这次520吧，可能是你最后一次了。”</p><p>他快出门的时候，还没忘了我刚才问的问题，转身说，“520和521指的是表白日，谐音是【我爱你】。在北方‘你’读音是‘ni’，接近1；在南方‘你’读音是‘li’，接近0”。</p><p>其实，码农只求曾经拥有。曾经沧海难为水，为做码农不见云。</p><p>我有点恍然大悟。但仔细一想又觉的有点不妥，照着这个理论，北方人过5.21，南方人过5.20。我准备再找个北方的码农问问。</p><p><b>NO3</b></p><p>码农北哥。年龄比阿呆还小一岁，听说技术过硬，从北京退居而来，有大公司背景，据说是被公司高薪挖过来的，外来的和尚就是好念经，目前在架构组。操着一口北京腔的河北人，一开会就会再三声明”我是架构师，不要和我谈技术细节。“好像是昨天刚刚相亲成功。</p><p>”北哥，听说你们北方人都过521，因为‘你’的读音‘ni’更接近1“。</p><p>他一脸嫌弃的看着我，一副技术经验十足的样子，”作为程序员一定要严谨，不能用接近啊，相似啊就确定一件事，如果做架构的都像你这样想当然，岂不是BUG百出啊“</p><p>他出乎意料的打开一段代码，”你看看我们底层架构是如何定义性别这个字段的？这个定义是我多年工作经验的复制，大公司都是这么定义的，通用！无论到哪里都不会有人说个不字“</p><p>”你能看懂吗？0代表女，1代表男。所以520是男生对女生的表白日而521是女生对男生的表白日。只不过，前者一定要过，后者可有可无。“</p><p>我竟无言以对，反而觉得很有道理。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-58766ad7245193e53a76b8ed7ea746b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-58766ad7245193e53a76b8ed7ea746b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;379&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-58766ad7245193e53a76b8ed7ea746b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-58766ad7245193e53a76b8ed7ea746b6_b.jpg\"/></figure><p>果然，架构师什么都可以抽象。</p><p><b>N04</b></p><p>码农骚年。一个不知道JavaScript是什么的前端开发，偶尔修改一下Html，开着大G上班，家里有矿纯属体验生活的那种。身份比较神秘，我们来之前他就已经在公司了。曾经还面试过上面提到的北哥。为人很豪爽大方，经常请我们吃车厘子，忙的时候就开着大G帮我们到店取餐。公司也潜藏着一个众人皆知的秘密，他是我们公司大大大老板的私生子，怪不得姓都一样。目前，没有女朋友，都是他的女闺蜜。</p><p>北哥言辞凿凿的样子把他逗笑喷了，”大逼哥，不不不，是大北哥。你这个搬运的技术确实牛逼，但作为一个经验丰富的架构师你要透过现象看本质呀，那段代码定义的确实不错，很有内涵，一看就是老司机写的。0确实代表女生，1也代表男生。但你肯定不知道为什么吧？看看这张图，可明白？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8974306a1cef17f5f4e9aaf9f1218f04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-8974306a1cef17f5f4e9aaf9f1218f04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;353&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-8974306a1cef17f5f4e9aaf9f1218f04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8974306a1cef17f5f4e9aaf9f1218f04_b.jpg\"/></figure><p>骚年想表达的意思我还是懂的——”技术源于生活“。但是图，确实没看懂，在线求解释！</p><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "码农提问", 
                    "tagLink": "https://api.zhihu.com/topics/19799199"
                }, 
                {
                    "tag": "520", 
                    "tagLink": "https://api.zhihu.com/topics/19706882"
                }
            ], 
            "comments": [
                {
                    "userName": "荭酒", 
                    "userLink": "https://www.zhihu.com/people/624165ccdec130fddfc86483f36de573", 
                    "content": "没人？   io", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "一只咸鱼", 
                    "userLink": "https://www.zhihu.com/people/b90a68d432d1c34948c38d2918b66d23", 
                    "content": "<p>完蛋了,520我加班忘了给对象打个电话,昨天我又忘了给她发红包了.上班第一件事情打开知乎逛,看到这篇文章猛然醒悟...</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66411791", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 1, 
            "title": "项目（二）", 
            "content": "<p>正则表达式Regex<br/><br/><br/>正则匹配<br/>正则替换<br/>正则分割<br/><br/><br/>语法：<br/></p><ol><li>普通字符：字母，数字，汉字，下划线以及后面没有特殊定义的标点符号，匹配下标因当前编程语言不同可能不同</li><li>简单的转义字符：</li><ol><li>\\n换行符</li><li>\\t制表符</li><li>\\\\表示\\本身</li><li>\\(^,$,(,),{,},+,-,*,/)表示这些符号本身</li></ol><li>标准字符集合</li><ol><li>\\d:任意数字0~9其中一个</li><li>\\w:任意字母数字或下划线，任意一个A~Z,a~z,0~9，_</li><li>\\s:包括空格，制表符，换行等空白字符</li><li>.:匹配除了换行符\\n之外的任意一个字符</li></ol><li>自定义字符集合</li><ol><li>[ ]方括号里面定义需要取到的内容</li></ol><li>修饰匹配次数的特殊符号</li><ol><li>｛n｝n表示匹配重复次数</li><li>｛m , n｝至少m次最多n次</li><li>｛m,｝至少出现m次</li><li>？相当于｛0，1｝</li><li>+相当于｛1，｝</li><li>*表示出现任意次数，相当于｛0，｝</li></ol><li>匹配次数中的贪婪模式</li><ol><li>匹配次数越多越好，默认匹配模式</li></ol><li>匹配次数非贪婪模式</li><ol><li>匹配自出越少越好（在匹配模式后加上“？”），尽可能不匹配</li></ol><li>字符边界</li><ol><li>^:字符开始的地方，以此开头</li><li>$:字符结束的地方，以此结尾</li><li>\\b:匹配一个单词边界，约等于\\W，\\b不参与匹配，相当于将字符隔开</li></ol><li>选择符和分组</li><ol><li>选择符 | ：相当于“或”</li><li>分组 （）：可以将字符作为一个整体</li><li>反向引用：每一个（）会分配一个编号，从1开始编号，通过反向引用可以对已分组的进行引用</li></ol></ol><p></p><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": [
                {
                    "userName": "Mr.龙", 
                    "userLink": "https://www.zhihu.com/people/b6cffea86cff5434038e3e5a714a8782", 
                    "content": "<p>精彩</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65755262", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 2, 
            "title": "EL和JSTL", 
            "content": "<p>EL<br/><br/><br/>EL(Expression Language)<br/>作用：<br/>    在jsp中消灭java代码<br/>语法：<br/>    ${ 表达式内容 }若表达式内容不存在，也不会报错<br/><br/><br/>EL表达式<br/></p><ol><li>EL表达式一般从作用域对象中取值(pageContext , request , session , application)</li><li>EL表达式可以取：基本数据类型，对象.属性，List中的数据（list[index]），map中的数据（map.key）, set是无序的无法取值。</li><li>EL表达式默认从最小的作用域对象中开始寻找，找不到往大的作用域寻找，都找不到就显示为空</li><li>EL表达式从执行作用域中取值${作用域Scope.表达式内容}（pageScope , requestScope , sessionScope , applicationScope）</li><li>EL表达式还可以取请求参数中的值：param、paramValues(在url后面的参数，从？开始)</li><li>${ <a href=\"https://link.zhihu.com/?target=http%3A//param.xxx\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">param.xxx</span><span class=\"invisible\"></span></a> }        ${paramValues.fav[i]}</li><li>EL表达式中还可以用[ ],解析EL子表达式</li><li>EL表达式可以进行一些基本的数学运算（+，-，*，/，%）</li><li>EL表达式可以进行一些逻辑判断（&lt;,&gt;,==,eq）</li><li>EL表达式为空判断（empty） ${empty xxx} ----null,空集合，空字符串，空数组</li></ol><p><br/><br/><br/></p><hr/><p>JSTL<br/><br/><br/>JSTL（ISP Standard Tag Library）<br/><br/><br/>作用：在jsp中消灭java代码<br/><br/><br/>子标签库有：<br/> 核心标签库，格式化标签库，XML标签库，函数标签库，数据库标签库<br/><br/><br/>使用：<br/></p><ol><li>下载jar包并导入lib目录下<br/></li><li>使用&lt;@% taglib uri=&#34;&#34; prefix=&#34;c&#34;%&gt;uri在jstl-impl-1.2.2.jar/META-INF/c.tId</li><li>使用标签&lt;c: &gt;核心标签库</li><ol><li>out</li><ol><li>value 将内容输出到页面</li><li>default 显示默认数据，（若value值为空，则输出默认值，若存在则显示value）</li></ol><li>set（默认在最小作用域中）</li><ol><li>var key值</li><li>value value值</li><li>scope  指定作用域</li></ol><li>remove（将作用域中指定的key数据删除，默认删除所有作用域中指定key的数据，通过scope选择要删除的作用域）</li><li>if(条件判断)</li><ol><li>test  条件表达式</li></ol><li>choose，when，otherwise（条件判断。多条件）</li><ol><li>when必须在otherwise之前出现</li><li>otherwise只能出现一次</li><li>when标签之间和otherwise之前不允许出现其他任何字符</li></ol><li>forEach（循环，属性&#34;begin,end&#34;内只允许出现数字）</li><ol><li>begin  开始，下标</li><li>end  结束，下标</li><li>var  表示每次的循环体</li><li>items  循环体，通常通过EL表达式获取循环内容</li><li>step  增量，步长</li><li>status  </li><ol><li>first  判断第一个是否为true</li><li>last  判断最后一个是否为true</li><li>count  循环的计数</li><li>index  循环的索引</li></ol></ol><li>redirect(重定向)</li><ol><li>url  跳转页面地址</li></ol><li>import(引入一个url页面在本页面中)</li><ol><li>url  引入页面的地址</li></ol></ol><li>格式化标签库&lt;fmt:&gt;</li><ol><li>formateDate  格式化一个时间</li><li>parseDate  解析一个字符串为一个Date对象</li></ol><li>函数标签库${fn:  }(方法大多都是字符串的方法)</li></ol><p></p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65813193", 
            "userName": "Java小GG", 
            "userLink": "https://www.zhihu.com/people/0ef5f247ebc8acf05e8f4622b612daaa", 
            "upvote": 3, 
            "title": "怎样成为一个高级软件工程师?这10条建议给你答案", 
            "content": "<p>本文将覆盖以下内容：</p><ul><li>如何尽力做好面试</li><li>如何在软件工程师的角色中生存（及发展）</li><li>考虑持续改进时可以参考的资源</li></ul><h2><b>1.面试</b></h2><p>当你开始软件工程职业生涯时，你得面对一个无可争议的事实。面试很恶心。</p><p>参与其中的每个人都觉得很恶心。既被人面试过又面试过别人的我可以证明，面试是一项极其耗时、极其有压力的工作，并且面试其实并不是将来工作表现一个的好的指示器。但不管怎样，这都是一个必要之恶，你和你的简历最好还是做好准备为妥。</p><h2><b>2.做好战斗准备</b></h2><p>如果你考虑做软件过程，确保了解一些最常见的编程面试问题，比如“FizzBuzz”：</p><blockquote>写一个程序打印从 1 到 100 的数字。但是如果数字是 3 的倍数的话则打印“Fizz”，如果数字是 5 的倍数则打印“Buzz”。如果同时是 3 和 5 的倍数则打印“FizzBuzz”。</blockquote><p>来自 Coding Horror</p><p>听起来很简单，是吧？</p><p>好吧，但其实绝大部分面试者都没能通过这一简单的测试，且不说更复杂的变种了。</p><p>曾经见过很多角逐资深岗位的候选人在拥有完全互联网访问的情况下没能通过这一测试。所以如果你的简历上面列有编程语言的话，确保你知道如何用它来编写实现 FizzBuzz 程序。否则的话，你只不过是在浪费所有人的时间，包括你自己的。</p><p>当然，为了在面试过后生存，你需要知道的不仅仅只有 FizzBuzz。你还需要确保你知道：</p><ul><li>基础的数据结构和算法：比如链表、数组、树以及排序。</li><li>要知道所选择语言的常见解决办法，比如字符串是否恒定，内存是如何管理的。</li><li>类似类与对象，以及继承等面向对象编程的概念。</li></ul><p>在职业生涯开始时，你需要就这些问题做好准备，因为你并没有经历去证明自己能做好这份工作。在准备面试的时候有两个资源我会经常推荐：</p><ul><li>《Cracking the Coding Interview（破解面试代码）》，这是一本非常好的书，里面介绍了很多的编码问题和解决方案，同时还总结了解决这些问题需要了解的东西。</li><li>CodeWars ，这个网站收集了大量的编程问题，你可以运用各种语言在浏览器里面去解决这些问题。最有用的部分是看看别的用户是如何解决同样问题的。这样你就可以看到解决相同问题的不同办法，并且学到你所选语言的新工具。</li></ul><h2><b>3.赋予自身额外优势</b></h2><p>为了让自己取得那点额外优势，有几件事情你可以去做。</p><p>首先，学会如何沟通你的经验。你应该进行一次电梯演讲来将你的简历总结成连贯的、打动人的个人介绍。</p><p>此外，要了解自己的简历！听起来很蠢是吧，但我就见过很多面试者连解释清楚自己简历上的特定事项都很困难。你应该能够回答任何有关你列上简历的经历方面的问题，并且解释清楚这一经历如何让你成为本工作更好的候选人。</p><p>接着，要在 GitHub（或者其他的公共代码库）上面有一些编码的例子。</p><p>眼见为实，面试官能够看到你的代码将创造奇迹。此外，这还证明了你对版本控制系统有了解。</p><p>你的代码例子不需要太复杂，但是一定要整洁，能够显示出好的编码实践。这是你展示自己在没有编码面试所带来的时间压力情况下代码写得如何的机会。</p><p>一旦你做完了上面的事情后，就得考虑参与一个开源项目了。参加开源项目能表明你能够在已有代码库基础上工作并且可以与其他程序员一些协作。</p><p>这是你在无需实际进入一个行业环境的情况下最接近在行业环境下编程的方式了。这也是目前为止最难最耗时的一项任务，所以等到你把前面我提到的比较容易取得的果实都摘完之后再干这件事。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c31b51e3ad94d018a3a358c1dca56134_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-c31b51e3ad94d018a3a358c1dca56134_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;850&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-c31b51e3ad94d018a3a358c1dca56134_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c31b51e3ad94d018a3a358c1dca56134_b.jpg\"/></figure><h2><b>4.面试你的面试官</b></h2><p>在找工作的匆忙与压力之下，很多候选人都忘了面试是一个双向的过程。在公司努力寻找这份工作的合适人选时，你也应该设法弄清楚这家公司适不适合你。</p><p>确保你也要提出以下一些问题，哪怕对方是以电子邮件的形式回复你。要意识到公司经常把不遵循最佳实践说成是一项技能，所以要体会其言外之意。</p><p><b>以下是一些你可以去提问的例子：</b></p><p><b>“对我来说典型的工作日会是什么样的？”</b></p><p>知道特定岗位预期的样子很重要，因为软件工程工作差别相当大。比方说你的工作既可能是维护服务器，也可能是直接跟客户沟通。</p><p>危险信号：“我不大肯定。” → 意味着面试你的那个人不在你的团队，或者他们对为什么要招你并没有明确的想法。</p><p><b>“你们是如何测试软件的？”</b></p><p>理想情况下，验证代码质量应该是单元测试、人工测试以及自动化测试的结合。</p><p>危险信号：“我们都写不出 bug，哈哈。” → 那些人正是会写出 bug 的人。</p><p><b>“你们使用什么样的版本控制系统？”</b></p><p>版本控制系统对于协作极其有用，在职业环境下没有理由不使用。</p><p>危险信号 #1：“额，版本控制系统？” → 快跑，跑得越远越好。</p><p>永远记得使用版本控制。</p><p>危险信号 #2：“&lt;插入不知名的或者定制的 VCS&gt;” → 这表明他们很有可能没有跟上时代并且很久没有升级自己的基础设施了。</p><p><b>“你们进行同行评审吗？”</b></p><p>同行评审，或者让别人看看你的代码再把它放进代码库，这是识别愚蠢错误的极好办法，同时也是开始你的职业生涯时一个关键的培训机会。</p><p>危险信号：“我们相互信任！”→很有可能那些资深开发者对自己的代码非常警惕不想给人看也不擅长接受反馈。</p><p><b>“你们的继续教育计划是什么样的？”</b></p><p>作为一名软件工程师意味着当新技术出现、成熟并以令人眼花缭乱的速度走向过时的时候要不断学习。因此，很多公司都有培训预算用来买大学和在线课程、会议或者内部交流。</p><p>危险信号：“你是说在闲暇时间读读网上的东西？” →这家公司要么资金紧张，要么把开发者视为可替代的，而不是长期投资。</p><p><b>“你们采用的软件开发流程是什么？”</b></p><p>无论实际的细节是什么，流程对于软件工程都至关重要。至于哪些东西对于优化流程做出了贡献可能大家会有不同的看法，但仅就项目的工作方式达成一致就能将混乱最小化并且确保每个人都能达成共识。</p><p>危险信号：“我们的流程受到了自由风格的爵士的影响。” → 很有可能整个部门都处在救火模式，总是不断地从紧急跳到另一个紧急状态而缺乏任何明确的目标。</p><p><b>“你们是如何处理技术债务的？”</b></p><p>技术债务是过时技术以及代码库中临时应急的解决方案的累积。处理好技术债务对于代码的长期健康很重要，这件事情应该持续地做。</p><p>危险信号：“我们只关注新功能。” → 他们的代码库一团糟或者很快就会一团糟。</p><p><b>“你们的公司文化是什么样的？”</b></p><p>公司文化也许是个非常含糊的概念，但即便像开放办公室还是小隔间这样的小事情都会显著改变你与同事的日常互动。这方面没有普遍性的危险信号，但是要确保他们的答案是你可以按照每周 40+ 小时的节奏持续相处数年的东西。</p><h2><b>5.以软件工程师的身份工作</b></h2><p>在这个阶段，如果你面试过程中表现不错并且喜欢面试官回答你问题的方式，你被录用的可能性就很高了。</p><p>祝贺，你正式成为一名工程师了！</p><p>那现在又该如何呢？好吧，现在是时候重新学习大量编码和工作方面的东西了。既然我们是程序员，我们就从讨论代码开始。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b8e668caa6d8424537fc1b40d61a05ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b8e668caa6d8424537fc1b40d61a05ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-b8e668caa6d8424537fc1b40d61a05ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b8e668caa6d8424537fc1b40d61a05ec_b.jpg\"/></figure><p><b>6.好的行业代码</b></p><p>好的行业代码有以下属性，依序是：</p><ul><li>可读性，因为代码用来读和维护的频次要高于写。代码的意图必须清晰，让其他开发者在多年后依然理解。</li><li>防御性，就是要遵循防御性编码的最佳实践。防御性编码本身就是一个课题，不过其要义是：你必须确保自己所写的类和方法的不恰当使用不会导致你的代码搞得软件都崩溃。</li><li>优化，位列清单的最后未知，因为大多数时候你并不需要真正去担心这个。这并不意味着你应该编写糟糕代码，在存在线性解决方案的情况下以O(n³)的效率去做某个东西。但开发者通常渴望尝试并且会在不需要的情况下过度优化，却牺牲了代码的可读性和防御性。你永远都应该能够证明牺牲了这些属性的特定优化是值得的。</li><li>现在你了解了如何去编写良好的行业代码了。</li></ul><h2><b>7.编码的工作你不会干太多的</b></h2><p>说出来也许有点令人吃惊，但是大多数时候你都不用写新代码，而是相反，要做：</p><ul><li>调试</li><li>读已有代码</li><li>开会或者写电子邮件</li><li>研究该怎么做以便不用写代码</li></ul><p>因此编码以外的技能对你的职业一样关键。</p><p>调试和阅读代码</p><ul><li>调试远不仅仅是用打印语句。一切使用广泛的语言和技术栈都有各种强大的工具。学会使用它们，因为这些会让调试轻而易举，节省你无数的时间。</li><li>理解代码库。大多数技术栈都有某种代码图谱生成工具来帮助你理解代码库的结构。企业级的 IDE 通常都内置了那种功能。你还可以利用 ReSharper、grep 或者 Sourcegraph 之类的工具来探索代码。</li><li>理解产品。你会对居然有这么多开发者在试图“修复”软件前不知道软件应该是怎么工作的感到惊讶。先看看文档再说吧。</li></ul><h2><b>8.组织你的思路</b></h2><p>既然你的大量时间都是用在沟通、研究和多任务上，你需要一些工具来帮助一切井然有序。</p><ul><li>TODO 清单/任务工具：你的公司应该已经有了某种任务管理软件了，但你自己也有类似的个人系统是有帮助的。使用便利贴或者像 Trello 或者 Todoist 之类的软件。</li><li>笔记：开会一定要记笔记，要致力于改进现有文档并且建立个人的知识库。使用 Evernote、OneNote 或者笔记本。使用这些工具似乎有用力过度之嫌，但日后在回顾这一耗掉了你 3 天时间才想清楚的晦涩的开发过程时你会感谢自己的。不做丰富笔记的好的软件开发者我一个都没见过。</li><li>图表/可视化：人是视觉动物，创建流程图和架构可帮助你和其他人理解复杂的话题。在跟非技术人员沟通时图解尤其有用。可使用 Lucidchart、 Visio 或者白板。</li></ul><h2><b>9.知道何时使用库</b></h2><p>简短回答：随时都要。</p><p>详细回答：99% 的时间内你都不应该重新发明轮子。在大多数的软件工程岗位，实现特定类型的东西都属于纯粹浪费时间。这并不意味着你不应该知道所使用的算法和数据结构是怎么工作的，因为这可以帮助你决定用什么以及什么时候用。</p><p>为了成为一名高效的软件工程师，你需要理解自己可以任意支配使用的那些库。大多数流行语言的标准库都是极其有用的，其规模比你想象的要大。此外，代码库也许也会利用了额外的特殊库。阅读其文档，知道什么使用去使用它们。</p><p>你还应该不要害怕去建议额外的库，如果它们将节省时间的话。然而，你需要确保自己选择了一个好的库供行业使用。好的库的标准是：</p><ul><li>开源，这样你就可以验证自身代码的质量，并有可能修补对应用非常关键的 bug。</li><li>按照 MIT 和 BSD 等方式进行的授权，这样你的公司使用起来就不会遇到任何问题。要小心 GPL，因为它会让你不小心就将整个代码库都开源出去。</li><li>成熟，比方说出来已经有一段时间了，并且功能集非常丰富。</li><li>维护性强，新版本推出很密集。</li><li>别的公司或者项目也使用，这个可以充当品质认证确保有行业支持，能持续维护下去。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-13562ad6bd5a50bc45ae4ca9fa69615f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"510\" data-original=\"https://pic4.zhimg.com/v2-13562ad6bd5a50bc45ae4ca9fa69615f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;510&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"510\" data-original=\"https://pic4.zhimg.com/v2-13562ad6bd5a50bc45ae4ca9fa69615f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-13562ad6bd5a50bc45ae4ca9fa69615f_b.jpg\"/></figure><h2><b>10.持续改进</b></h2><p>为了替自己创建新的职业机会，除了学习会让你更擅长日常工作的技能以外，你还需要持续改进自身技能并且学习新技能。</p><p>其实学习的机会有很多，而且其中很多都是你可以负担得起的：</p><ul><li>在线课程：向领域内最好的教授学习的机会，而且方式灵活，不容错过。<a href=\"https://link.zhihu.com/?target=https%3A//www.boxuegu.com/%3Ft%3Dgsz\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">传智播客博学谷</a>，这是一家有着多年IT培训经验的在线教育机构，java、python等课程全面开设，不管是大神还是小白，这里都有适合你的课程。</li><li>在线硕士学位：在线硕士学位是最近在顶级大学流行起来的一个趋势，这种方式可以灵活地继续你的正规教育。相比之下，这种继续教育方式费用没那么昂贵，修完整个学位大多数在 1 万美元左右。乔治亚理工大学、UT 以及加州大学圣地亚哥分校等大学均提供此类学位。我个人推荐乔治亚理工大学的在线硕士虚伪，我去年刚从这里毕业。</li><li>博客：博客是开发者社区的重要组成部分。诸如 Coding Horror、Joel on Software 等博客或者甚至更加诙谐的网站如 The Daily WTF 等都可以为你提供信息，了解到作为软件工程师该干什么不该干什么。浏览 Medium、r/programming, HackerNews 等新闻流也能让你找到好博客和好文章。</li><li>会议：最后但并非最不重要的一个，会议时令人赞叹的学习机会，你绝对应该利用公司的培训预算去参加会议。以下是不完全的好会议清单：GOTO（通用）， Strange Loop（通用）， PyCon （Pytho），CPPCon （C++），DEF CON （安全），Fluent （Web 开发）。上述所有的会议在 YouTube 上都有视频，所以你哪怕不出席也能学到东西！</li></ul><p>希望这篇文章能够用相关知识把你武装起来，让你了解到作为软件工程师的职业生涯伊始应该期待什么，并且提供合适的工具给你在开启这段令人兴奋的旅程中助你一臂之力</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "软件工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19558713"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65219793", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 1, 
            "title": "Tomcat基础认识", 
            "content": "<p>Tomcat<br/><br/><br/>目录：<br/>backup--备份文件<br/>bin--可执行文件（class文件）<br/>conf--配置文件<br/>lib--库文件（jar文件）<br/>logs--日志文件<br/>temp--临时文件<br/>webapps--wed应用<br/>work--编译文件<br/><br/><br/>使用：<br/>1.部署项目<br/>    1）只要把数据放在webapps的某个目录（项目名，静态项目）下，就可以通过浏览器访问<br/>    2）myeclipse会将java代码编译过后的class文件，放在WebRoot/WEB-INF/classes目录下<br/>2.启动服务器<br/>    1）运行bin/startup.bat<br/>3.集成tomcat<br/>    1）window--prefrences--servers--tomcat--tomcat--enabled,配置tomcat home directory--OK<br/>    2）将项目部署在tomcat中：右键--add Deployment--选择项目名--finish<br/>    3）启动：run server<br/><br/><br/>web代码：<br/>      servlet 生命周期 <br/>1.载入并初始化，载入到内存中，init方法，只执行一次 <br/>2.运行，service（）方法<br/>      每当用户发出一次请求，调用一次servlet的service方法。<br/>   1）当用户请求时，服务器会创建一个线程，调用servlet的service--&gt;<br/>      父类service--&gt;父类的doGet/doPost，报错405.只需要重写doGet和doPost方法<br/>   2）servlet是单例(设计模式之单例模式)的,节约内存，不需要每次请求都创建对象 <br/>3.消亡，destroy（）方法，只执行一次<br/><br/><br/><br/>public class LifeCircle extends HttpServlet { <br/> @Override<br/>     public void init() throws ServletException {<br/>           System.out.println(&#34;初始化！&#34;);<br/>     }<br/>     @Override<br/>     protected void doGet(HttpServletRequest req,  HttpServletResponse resp) throws ServletException, IOException {<br/>           System.out.println(&#34;子类doget（）方法&#34;);<br/>     }<br/>     @Override<br/>     protected void doPost(HttpServletRequest req,  HttpServletResponse resp) throws ServletException, IOException {<br/>           System.out.println(&#34;子类dopost（）方法&#34;);<br/>     }<br/>     @Override<br/>     public void destroy() {<br/>           System.out.println(&#34;消亡！&#34;);<br/>     }<br/>}<br/><br/><br/><br/><br/><br/><br/><br/></p><hr/><p>XML<br/>配置：<br/>url-pattern<br/> 写法：<br/> 1）/aaa<br/> 2）*.aaa<br/> 3）/aaa/*<br/><br/><br/>load-on-startup<br/> 启动时加载，初始化并调用init方法，在web应用启动的时候，其数值必须是整型，数值大小表示加载顺序，数字越小越早加载（饿汉），如果数值是负数或者不写明就不加载（懒汉）<br/><br/><br/>welcome-file-list<br/>    welcome-file<br/><br/>表示用户访问一个目录而不是一个html页面时，会默认welcom中寻找欢迎页显示，如果没有欢迎页，会显示404页面或者WebRoot目录列表（取决于listing的值）</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64718799", 
            "userName": "Tetsu.K", 
            "userLink": "https://www.zhihu.com/people/3b547249da10cc0c7f14e60a780d36f2", 
            "upvote": 1, 
            "title": "BOM和DOM", 
            "content": "<p>BOM(Broswer Object Model)<br/>window对象，也是是BOM对象的核心<br/>console.log(window)可以查看window对象的信息<br/><br/><br/>打开窗口：<br/>凡是window的属性和方法，均可省略“window”<br/>警告框（无返回值）<br/>function testAlert( ){<br/>    window.alert( &#34;警告框！&#34; )<br/>}<br/>确认框（返回值为布尔值）<br/>function testConfirm( ){<br/>    window.confirm( &#34;确认离开吗？&#34; )<br/>}<br/>询问框（返回值是用户输入内容）<br/>function testPrompt( ){<br/>    window.prompt(&#34;请输入密码&#34;,&#34;例如：123456&#34;)<br/>}<br/>方法：<br/>打开方法<br/>open(url,windowName,features)<br/>比较少用，基本用&lt;iframe&gt;打开新窗口。<br/>在子窗口中opener表示父窗口window对象，可以调用父窗口方法和属性（子父方法调用）<br/>关闭方法<br/>close( )<br/>关闭本窗口</p><hr/><p>Timeout( )<br/>function setTime( ){<br/>    window.setTimeout( &#34;alert(&#39;hello!&#39;)&#34;,5000 )<br/>}<br/>定时器打开警告框<br/>function sayHello( ){<br/>    alert(&#34;你好！&#34;)<br/>}<br/>直接打开警告框<br/>Interval( )<br/>间隔执行任务，无限循环执行<br/>clearTimeout( )<br/>清除定时任务<br/>clearInterval( )<br/>清除间隔执行任务<br/>var taskid;<br/>window.onload = function(){<br/>    taskid = window.setInterval(closeSelf(),1000);<br/>}<br/>function closeSelf(){<br/>    var secval = document.getElementById(&#34;sec&#34;).innerHTML;<br/>    var secint = parseInt(secval);<br/>    document.getElementById(&#34;sec&#34;).innerHTML = --secint;<br/>    if(secint == 0){<br/>        window.close();<br/>    }<br/>}<br/>function stopTask(){<br/>    window.clearInterval(taskid);<br/>}<br/>function goonTask(){<br/>    taskid = window.setInterval(closeSelf(),1000);<br/>}<br/><br/><br/><br/><br/><br/></p><hr/><p>window属性<br/>screen<br/>function testScreen(){<br/>    console.log(window.screen.width+&#34;*&#34;+window.screen.height);<br/>}<br/>history<br/>function testBack( ){<br/>    window.history.back( );<br/>}<br/>function testForword(){<br/>    window.history.forword( );<br/>}<br/>go(可以前进、后退和刷新)<br/>function testGo( ){<br/>    window.hiestory.go(0);<br/>}<br/>location<br/>function testLocation( ){<br/>    window.location.href = &#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a>&#34;;<br/>}<br/>function testLocation( ){<br/>    window.location.href = window.location.href;<br/>}<br/>function testNavigator( ){<br/>    console.log(window.navigator.userAgent)<br/>}<br/>//访问获取用户代理<br/><br/></p><hr/><p>DOM(Document Object Model)<br/>DOM树，在DOM中，html标签是根结点（node），head和body标签是其子结点。<br/>结点：<br/>1、元素结点<br/>2、属性结点 <br/>3、文本结点<br/><br/><br/>获取元素结点<br/>1、直接获取（Id,Name,TagName）<br/>2、间接获取（父子关系，子父关系，兄弟关系）<br/>操作属性结点<br/>1、通过对象.属性来操作属性，可以动态获取用户修改的属性值，但不可以获取自定义属性值<br/>2、可以获取自定义属性值，但不可以动态获取用户修改的属性值<br/>getAttribute(&#34;key&#34;)<br/>setAttribute(&#34;key&#34;,&#34;value&#34;)<br/>removeAttribute(&#34;key&#34;)<br/>处理文本节点<br/>1、通过对象.innerText获取标签内部的文本信息<br/>2、通过对象.innerHTML获取标签内部的HTML代码<br/><br/><br/>动态改变DOM结构<br/>1、创建一个结点对象(document.createElement(&#34;标签名&#34;))<br/>2、父结点追加子结点对象(fatherNode.appendChild(子结点对象))<br/>3、父结点在指定结点前追加子结点(fatherNode.insertBefore(新结点,参考结点))<br/>4、父结点替换旧的子结点(fatherNode.replaceChild(新结点,参考结点))<br/>5、父节点删除旧子结点对象(fatherNode.removeChild(旧结点对象))</p>", 
            "topic": [
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63698500", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 10, 
            "title": "前端异常处理最佳实践", 
            "content": "<p>前端可以说是最贴近用户的一层，当产品不断的迭代完善，产品的用户体验会更加趋向于完美，然而前端异常却是很另人头疼的一个问题，我们应该怎么去对待这些异常呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image\" width=\"45\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;45&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image lazy\" width=\"45\" data-actualsrc=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\"/></figure><p>一、为什么要处理异常？</p><p>异常是不可控的，会影响最终的呈现结果，但是我们有充分的理由去做这样的事情。<br/></p><ol><li>增强用户体验；</li><li>远程定位问题；</li><li>未雨绸缪，及早发现问题；</li><li>无法复线问题，尤其是移动端，机型，系统都是问题；</li><li>完善的前端方案，前端监控系统；</li></ol><p>对于 JS 而言，我们面对的仅仅只是异常，异常的出现不会直接导致 JS 引擎崩溃，最多只会使当前执行的任务终止。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image\" width=\"45\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;45&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image lazy\" width=\"45\" data-actualsrc=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\"/></figure><p>二、需要处理哪些异常？</p><p>对于前端来说，我们可做的异常捕获还真不少。总结一下，大概如下：</p><ul><li>JS 语法错误、代码异常</li><li>AJAX 请求异常</li><li>静态资源加载异常</li><li>Promise 异常</li><li>Iframe 异常</li><li>跨域 Script error</li><li>崩溃和卡顿</li></ul><p>下面我会针对每种具体情况来说明如何处理这些异常。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image\" width=\"45\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;45&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image lazy\" width=\"45\" data-actualsrc=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\"/></figure><p>三、Try-Catch 的误区</p><p>try-catch 只能捕获到同步的运行时错误，对语法和异步错误却无能为力，捕获不到。</p><p><b>1、同步运行时错误：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-06de0b61ab8daac32c3b688763dd1fe8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-06de0b61ab8daac32c3b688763dd1fe8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;583&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"583\" data-rawheight=\"212\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"583\" data-original=\"https://pic1.zhimg.com/v2-06de0b61ab8daac32c3b688763dd1fe8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-06de0b61ab8daac32c3b688763dd1fe8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>输出：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9643a9bb288fdf9eef2b8874ccccb651_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb\" width=\"799\" data-original=\"https://pic2.zhimg.com/v2-9643a9bb288fdf9eef2b8874ccccb651_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;799&#39; height=&#39;99&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"799\" data-original=\"https://pic2.zhimg.com/v2-9643a9bb288fdf9eef2b8874ccccb651_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9643a9bb288fdf9eef2b8874ccccb651_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2、不能捕获到语法错误，我们修改一下代码，删掉一个单引号：</b><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9ea569413ed5accbd76527932bcd7b95_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"783\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb\" width=\"783\" data-original=\"https://pic2.zhimg.com/v2-9ea569413ed5accbd76527932bcd7b95_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;783&#39; height=&#39;220&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"783\" data-rawheight=\"220\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"783\" data-original=\"https://pic2.zhimg.com/v2-9ea569413ed5accbd76527932bcd7b95_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9ea569413ed5accbd76527932bcd7b95_b.jpg\"/></figure><p><br/>输出：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0e7c11164743100784ebf7458bbab7bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"61\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-0e7c11164743100784ebf7458bbab7bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;61&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"61\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-0e7c11164743100784ebf7458bbab7bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0e7c11164743100784ebf7458bbab7bd_b.jpg\"/></figure><p><br/>不过语法错误在我们开发阶段就可以看到，应该不会顺利上到线上环境。</p><p><b>3、异步错误</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-75d3f14fd7d1638fdc7b329ce9ce0353_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"628\" data-original=\"https://pic4.zhimg.com/v2-75d3f14fd7d1638fdc7b329ce9ce0353_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;628&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"628\" data-original=\"https://pic4.zhimg.com/v2-75d3f14fd7d1638fdc7b329ce9ce0353_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-75d3f14fd7d1638fdc7b329ce9ce0353_b.jpg\"/></figure><p><br/>可以看看日志：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2ff05cfba1c447f7df5497991f3a658f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-2ff05cfba1c447f7df5497991f3a658f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-2ff05cfba1c447f7df5497991f3a658f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2ff05cfba1c447f7df5497991f3a658f_b.jpg\"/></figure><p><br/>并没有捕获到异常，这是需要我们特别注意的地方。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image\" width=\"45\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;45&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"45\" data-rawheight=\"60\" class=\"content_image lazy\" width=\"45\" data-actualsrc=\"https://pic4.zhimg.com/v2-737fe545140283ac66005e7cca00b76b_b.jpg\"/></figure><p>四、window.onerror 不是万能的</p><p>当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-986b142c2783b13d516428e399fa7079_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-986b142c2783b13d516428e399fa7079_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-986b142c2783b13d516428e399fa7079_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-986b142c2783b13d516428e399fa7079_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、首先试试同步运行时错误</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f764bac593cf9336ba9121cbfff46dd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-f764bac593cf9336ba9121cbfff46dd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-f764bac593cf9336ba9121cbfff46dd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f764bac593cf9336ba9121cbfff46dd7_b.jpg\"/></figure><p><br/>可以看到，我们捕获到了异常：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8663ad75b539904378f59398b4e56094_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-8663ad75b539904378f59398b4e56094_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-8663ad75b539904378f59398b4e56094_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8663ad75b539904378f59398b4e56094_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2、再试试语法错误呢？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-140ff0fda56039dbc13a2cb24f55192e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"123\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-140ff0fda56039dbc13a2cb24f55192e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;123&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"123\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-140ff0fda56039dbc13a2cb24f55192e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-140ff0fda56039dbc13a2cb24f55192e_b.jpg\"/></figure><p><br/>控制台打印出了这样的异常：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7763096192d9e3091a48021baa13ceea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb\" width=\"763\" data-original=\"https://pic3.zhimg.com/v2-7763096192d9e3091a48021baa13ceea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;763&#39; height=&#39;52&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"763\" data-original=\"https://pic3.zhimg.com/v2-7763096192d9e3091a48021baa13ceea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7763096192d9e3091a48021baa13ceea_b.jpg\"/></figure><p><br/>竟然没有捕获到语法错误？</p><p><b>3、怀着忐忑的心，我们最后来试试异步运行时错误：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-564c74f519b134989bdab4be69c5ac79_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"182\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-564c74f519b134989bdab4be69c5ac79_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;182&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"182\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-564c74f519b134989bdab4be69c5ac79_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-564c74f519b134989bdab4be69c5ac79_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>控制台输出了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3c9f329016362ff8a222269bb8b3971a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-3c9f329016362ff8a222269bb8b3971a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-3c9f329016362ff8a222269bb8b3971a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3c9f329016362ff8a222269bb8b3971a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4、接着，我们试试网络请求异常的情况：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-591384d8d36d096243365d93f406ee04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-591384d8d36d096243365d93f406ee04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-591384d8d36d096243365d93f406ee04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-591384d8d36d096243365d93f406ee04_b.jpg\"/></figure><p><br/>我们发现，不论是静态资源异常，或者接口异常，错误都无法捕获到。</p><p><b>补充一点：</b>window.onerror 函数只有在返回 true 的时候，异常才不会向上抛出，否则即使是知道异常的发生控制台还是会显示 Uncaught Error: xxxxx</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0ba60fd55969a2a77a6ababb7fd2e57d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-0ba60fd55969a2a77a6ababb7fd2e57d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-0ba60fd55969a2a77a6ababb7fd2e57d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0ba60fd55969a2a77a6ababb7fd2e57d_b.jpg\"/></figure><p><br/>控制台就不会再有这样的错误了：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1b090ecb4f01bdc223e14d291eda2ca0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-1b090ecb4f01bdc223e14d291eda2ca0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"111\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-1b090ecb4f01bdc223e14d291eda2ca0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1b090ecb4f01bdc223e14d291eda2ca0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>需要注意：</b></p><ul><li>onerror 最好写在所有 JS 脚本的前面，否则有可能捕获不到错误；</li><li>onerror 无法捕获语法错误；</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>到这里基本就清晰了：在实际的使用过程中，onerror 主要是来捕获预料之外的错误，而 try-catch 则是用来在可预见情况下监控特定的错误，两者结合使用更加高效。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-69afe27533d4a5043b38eaef1de16446_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"23\" data-rawheight=\"23\" class=\"content_image\" width=\"23\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;23&#39; height=&#39;23&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"23\" data-rawheight=\"23\" class=\"content_image lazy\" width=\"23\" data-actualsrc=\"https://pic3.zhimg.com/v2-69afe27533d4a5043b38eaef1de16446_b.jpg\"/></figure><p><b>问题又来了，捕获不到静态资源加载异常怎么办？</b></p><p><b>一、window.addEventListener</b></p><p>当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的onerror() 处理函数。这些 error 事件不会向上冒泡到 window ，不过（至少在 Firefox 中）能被单一的window.addEventListener 捕获。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c7b3c27395b49839f36fafa8c66267e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-4c7b3c27395b49839f36fafa8c66267e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-4c7b3c27395b49839f36fafa8c66267e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c7b3c27395b49839f36fafa8c66267e_b.jpg\"/></figure><p><br/>控制台输出：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a593faee2fc228e641fe65cd62b9dc42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-a593faee2fc228e641fe65cd62b9dc42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-a593faee2fc228e641fe65cd62b9dc42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a593faee2fc228e641fe65cd62b9dc42_b.jpg\"/></figure><p><br/><br/>由于网络请求异常不会事件冒泡，因此必须在捕获阶段将其捕捉到才行，但是这种方式虽然可以捕捉到网络请求的异常，但是无法判断 HTTP 的状态是 404 还是其他比如 500 等等，所以还需要配合服务端日志才进行排查分析才可以。</p><p><b>需要注意：</b></p><p>不同浏览器下返回的 error 对象可能不同，需要注意兼容处理。<br/>需要注意避免 addEventListener 重复监听。</p><p><b>二、Promise Catch</b></p><p>在 promise 中使用 catch 可以非常方便的捕获到异步 error ，这个很简单。没有写 catch 的 Promise 中抛出的错误无法被 onerror 或 try-catch 捕获到，所以我们务必要在 Promise 中不要忘记写 catch 处理抛出的异常。</p><p><b>解决方案：</b>为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听Uncaught Promise Error。使用方式：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6bbba94dab168e12201c51c4bee1a8a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"121\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-6bbba94dab168e12201c51c4bee1a8a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;121&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"121\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-6bbba94dab168e12201c51c4bee1a8a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6bbba94dab168e12201c51c4bee1a8a2_b.jpg\"/></figure><p><br/>我们继续来尝试一下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f780ea777167f3d5d096da8228582af9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-f780ea777167f3d5d096da8228582af9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-f780ea777167f3d5d096da8228582af9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f780ea777167f3d5d096da8228582af9_b.jpg\"/></figure><p><br/>那如果对 Promise 不进行 catch 呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1345d642f62aaf40e1003d35e401b0b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-1345d642f62aaf40e1003d35e401b0b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-1345d642f62aaf40e1003d35e401b0b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1345d642f62aaf40e1003d35e401b0b6_b.jpg\"/></figure><p><br/>嗯，事实证明，也是会被正常捕获到的。</p><p>所以，正如我们上面所说，为了防止有漏掉的 Promise 异常，建议在全局增加一个对 unhandledrejection 的监听，用来全局监听 Uncaught Promise Error。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>补充一点：如果去掉控制台的异常显示，需要加上：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1dd092ff27fbe365f546e0e1910f5c4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"593\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb\" width=\"593\" data-original=\"https://pic3.zhimg.com/v2-1dd092ff27fbe365f546e0e1910f5c4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;593&#39; height=&#39;99&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"593\" data-rawheight=\"99\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"593\" data-original=\"https://pic3.zhimg.com/v2-1dd092ff27fbe365f546e0e1910f5c4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1dd092ff27fbe365f546e0e1910f5c4e_b.jpg\"/></figure><p><br/><b>三、VUE errorHandler</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7c63eef5a49e1dde6daa2e06c31ce46e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-7c63eef5a49e1dde6daa2e06c31ce46e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;208&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-7c63eef5a49e1dde6daa2e06c31ce46e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7c63eef5a49e1dde6daa2e06c31ce46e_b.jpg\"/></figure><p><br/><b>四、React 异常捕获</b></p><p>React 16 提供了一个内置函数 componentDidCatch，使用它可以非常简单的获取到 react 下的错误信息<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ea513c2ec1f25856471ee386229d90a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb\" width=\"666\" data-original=\"https://pic1.zhimg.com/v2-ea513c2ec1f25856471ee386229d90a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;666&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"666\" data-original=\"https://pic1.zhimg.com/v2-ea513c2ec1f25856471ee386229d90a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ea513c2ec1f25856471ee386229d90a4_b.jpg\"/></figure><p><br/><br/>UI 的某部分引起的 JS 错误不应该破坏整个程序，为了帮 React 的使用者解决这个问题，React 16 介绍了一种关于错误边界（error boundary)的新观念。</p><p>需要注意的是：error boundaries 并不会捕捉下面这些错误。</p><ol><li>事件处理器</li><li>异步代码</li><li>服务端的渲染代码</li><li>在 error boundaries 区域内的错误</li></ol><p>我们来举一个小例子，在下面这个 componentDIdCatch(error,info) 里的类会变成一个 error boundary：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-debbe6148f8f7da144c640237383f07e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-debbe6148f8f7da144c640237383f07e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;537&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-debbe6148f8f7da144c640237383f07e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-debbe6148f8f7da144c640237383f07e_b.jpg\"/></figure><p><br/>然后我们像使用普通组件那样使用它：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ddb9b07b9b1b59dcdaa7543c45d3860e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"389\" data-rawheight=\"99\" class=\"content_image\" width=\"389\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;389&#39; height=&#39;99&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"389\" data-rawheight=\"99\" class=\"content_image lazy\" width=\"389\" data-actualsrc=\"https://pic3.zhimg.com/v2-ddb9b07b9b1b59dcdaa7543c45d3860e_b.jpg\"/></figure><p><br/>componentDidCatch() 方法像 JS 的 catch{} 模块一样工作，但是对于组件，只有 class 类型的组件(class component )可以成为一个 error boundaries 。<br/></p><p>实际上，大多数情况下我们可以在整个程序中定义一个 error boundary 组件，之后就可以一直使用它了！</p><p><b>五、iframe 异常</b></p><p>对于 iframe 的异常捕获，我们还得借力 window.onerror：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a3340d825f9336be5be0a89028b3b057_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-a3340d825f9336be5be0a89028b3b057_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-a3340d825f9336be5be0a89028b3b057_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a3340d825f9336be5be0a89028b3b057_b.jpg\"/></figure><p><br/>一个简单的例子可能如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9c432909319ccb619670d002a517c627_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-9c432909319ccb619670d002a517c627_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-9c432909319ccb619670d002a517c627_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9c432909319ccb619670d002a517c627_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>六、Script error</b></p><p>一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。这时候，是不会有其他太多辅助信息的，但是解决思路无非如下：</p><p>跨源资源共享机制( CORS )：我们为 script 标签添加 crossOrigin 属性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1470a59e6a34e9486a0afd3b7141d909_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-1470a59e6a34e9486a0afd3b7141d909_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-1470a59e6a34e9486a0afd3b7141d909_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1470a59e6a34e9486a0afd3b7141d909_b.jpg\"/></figure><p><br/>或者动态去添加 js 脚本：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0cbde7339f30f465b114ae92cb6a7273_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"127\" class=\"origin_image zh-lightbox-thumb\" width=\"770\" data-original=\"https://pic4.zhimg.com/v2-0cbde7339f30f465b114ae92cb6a7273_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;770&#39; height=&#39;127&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"770\" data-rawheight=\"127\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"770\" data-original=\"https://pic4.zhimg.com/v2-0cbde7339f30f465b114ae92cb6a7273_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0cbde7339f30f465b114ae92cb6a7273_b.jpg\"/></figure><p><br/>特别注意，服务器端需要设置：Access-Control-Allow-Origin<br/>此外，我们也可以试试这个-解决 Script Error 的另类思路：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-868be227341d599ba674e25209c00e06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-868be227341d599ba674e25209c00e06_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-868be227341d599ba674e25209c00e06_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-868be227341d599ba674e25209c00e06_b.jpg\"/></figure><p><br/><b>简单解释一下：</b></p><p>改写了 EventTarget 的 addEventListener 方法；</p><p>对传入的 listener 进行包装，返回包装过的 listener，对其执行进行 try-catch；</p><p>浏览器不会对 try-catch 起来的异常进行跨域拦截，所以 catch 到的时候，是有堆栈信息的；</p><p>重新 throw 出来异常的时候，执行的是同域代码，所以 window.onerror 捕获的时候不会丢失堆栈信息；</p><p>利用包装 addEventListener，我们还可以达到「扩展堆栈」的效果</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-caba77ac2b969949c3ae690613690fe8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-caba77ac2b969949c3ae690613690fe8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-caba77ac2b969949c3ae690613690fe8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-caba77ac2b969949c3ae690613690fe8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>七、崩溃和卡顿</b></p><p>卡顿也就是网页暂时响应比较慢， JS 可能无法及时执行。但崩溃就不一样了，网页都崩溃了，JS 都不运行了，还有什么办法可以监控网页的崩溃，并将网页崩溃上报呢？</p><p>崩溃和卡顿也是不可忽视的，也许会导致你的用户流失。</p><p><b>1、利用window对象的load和beforeunload事件实现了对网页崩溃的监控。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6a1665fd8580eee7bef9016434027ac8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-6a1665fd8580eee7bef9016434027ac8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;364&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-6a1665fd8580eee7bef9016434027ac8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6a1665fd8580eee7bef9016434027ac8_b.jpg\"/></figure><p><b>2、基于以下原因，我们可以使用service Worker来实现对网页崩溃的监控。</b></p><ul><li>Service Worker 有自己独立的工作线程，与网页区分开，网页崩溃了，Service Worker 一般情况下不会崩溃；</li><li>Service Worker 生命周期一般要比网页还要长，可以用来监控网页的状态；</li><li>网页可以通过 navigator.serviceWorker.controller.postMessage API 向掌管自己的 SW 发送消息。</li></ul><p><b>八、错误上报</b></p><p><b>1、通过 Ajax 发送数据</b><br/>因为 Ajax 请求本身也有可能会发生异常，而且有可能会引发跨域问题，一般情况下更推荐使用动态创建 img 标签的形式进行上报。</p><p><b>2、动态创建 img 标签的形式</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-57b00b01cac496e7d8e79b45afc135c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"759\" data-original=\"https://pic1.zhimg.com/v2-57b00b01cac496e7d8e79b45afc135c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;759&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"759\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"759\" data-original=\"https://pic1.zhimg.com/v2-57b00b01cac496e7d8e79b45afc135c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-57b00b01cac496e7d8e79b45afc135c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>收集异常信息量太多，怎么办？实际中，我们不得不考虑这样一种情况：如果你的网站访问量很大，那么一个必然的错误发送的信息就有很多条，这时候，我们需要设置采集率，从而减缓服务器的压力:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-34e7501c88a1674b804527766752a29b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb\" width=\"638\" data-original=\"https://pic4.zhimg.com/v2-34e7501c88a1674b804527766752a29b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;638&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"198\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"638\" data-original=\"https://pic4.zhimg.com/v2-34e7501c88a1674b804527766752a29b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-34e7501c88a1674b804527766752a29b_b.jpg\"/></figure><p><br/>采集率应该通过实际情况来设定，随机数，或者某些用户特征都是不错的选择。<br/></p><p><b>九、总结</b></p><p>回到我们开头提出的那个问题，如何优雅的处理异常呢？</p><ol><li>可疑区域增加 Try-Catch</li><li>全局监控 JS 异常 window.onerror</li><li>全局监控静态资源异常 window.addEventListener</li><li>捕获没有 Catch 的 Promise 异常：unhandledrejection</li><li>VUE errorHandler 和 React componentDidCatch</li><li>监控网页崩溃：window 对象的 load 和 beforeunload</li><li>跨域 crossOrigin 解决</li></ol><p>其实很简单，采用组合方案，分类型的去捕获异常，这样基本 80%-90% 的问题都化于无形。</p><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": [
                {
                    "userName": "王伟", 
                    "userLink": "https://www.zhihu.com/people/eaac62c198d2ebb85d3abadaabad46f9", 
                    "content": "<p>如此完善的错误捕获！怎么能没有评论！</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63699743", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "Java基础之框架设计的灵魂-反射", 
            "content": "<h2>反射是框架设计的灵魂</h2><p>（使用的前提条件：必须先得到代表的字节码的Class，Class类用于表示.class文件（字节码））</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f987b636316aa8ea337498757d8398f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"709\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb\" width=\"709\" data-original=\"https://pic1.zhimg.com/v2-f987b636316aa8ea337498757d8398f8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;709&#39; height=&#39;228&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"709\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"709\" data-original=\"https://pic1.zhimg.com/v2-f987b636316aa8ea337498757d8398f8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f987b636316aa8ea337498757d8398f8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>反射就是把java类中的各种成分映射成一个个的Java对象</p><p>例如：一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。</p><p>（其实：一个类中这些成员方法、构造方法、在加入类中都有一个类来描述）<br/></p><p>如图是类的正常加载过程：反射的原理在与class对象。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>熟悉一下加载的时候：Class对象的由来是将class文件读入内存，并为之创建一个Class对象。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-34c4c6b37eeedfc3ff9132f479811c2c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-34c4c6b37eeedfc3ff9132f479811c2c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-34c4c6b37eeedfc3ff9132f479811c2c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-34c4c6b37eeedfc3ff9132f479811c2c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其中这个Class对象很特殊。我们先了解一下这个Class类</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、查看Class类在java中的api详解（1.7的API）</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>如何阅读java中的api详见java基础之——String字符串处理</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-946a5fc2be00dd0ad14b484805c3f15d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-946a5fc2be00dd0ad14b484805c3f15d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-946a5fc2be00dd0ad14b484805c3f15d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-946a5fc2be00dd0ad14b484805c3f15d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a54f3a49459a2b14f3b30cde8e23b7a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"733\" data-original=\"https://pic3.zhimg.com/v2-a54f3a49459a2b14f3b30cde8e23b7a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;733&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"733\" data-original=\"https://pic3.zhimg.com/v2-a54f3a49459a2b14f3b30cde8e23b7a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a54f3a49459a2b14f3b30cde8e23b7a6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>没有公共的构造方法，方法共有64个太多了。下面用到哪个就详解哪个吧<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a833261647aaa57619b2e1503030d6ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"576\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-a833261647aaa57619b2e1503030d6ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;576&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"576\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-a833261647aaa57619b2e1503030d6ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a833261647aaa57619b2e1503030d6ee_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、反射的使用（这里使用Student类做演示）</h2><p>先写一个Student类。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>1、获取Class对象的三种方式</h2><h3>1.1 Object ——&gt; getClass();<br/>1.2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性<br/>1.3 通过Class类的静态方法：forName（String  className）(常用)</h3><p>其中1.1是因为Object类中的getClass方法、因为所有类都继承Object类。从而调用Object类来获取</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2d5237c6791ac4b17d57bd2b461fbf0f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-2d5237c6791ac4b17d57bd2b461fbf0f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-2d5237c6791ac4b17d57bd2b461fbf0f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2d5237c6791ac4b17d57bd2b461fbf0f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:18px;&#34;&gt;package fanshe;  \n/** \n* 获取Class对象的三种方式 \n* 1 Object ——&gt; getClass(); \n* 2 任何数据类型（包括基本数据类型）都有一个“静态”的class属性 \n* 3 通过Class类的静态方法：forName（String className）(常用)\n* \n*/  \npublic class Fanshe {  \n   public static void main(String[] args) {  \n       //第一种方式获取Class对象    \n       Student stu1 = new Student();//这一new 产生一个Student对象，一个Class对象。\n       Class stuClass = stu1.getClass();//获取Class对象  \n       System.out.println(stuClass.getName());  \n         \n       //第二种方式获取Class对象  \n       Class stuClass2 = Student.class;  \n       System.out.println(stuClass == stuClass2);//判断第一种方式获取的Class对象和第二种方式获取的是否是同一个  \n         \n       //第三种方式获取Class对象  \n       try {  \n           Class stuClass3 = Class.forName(&#34;fanshe.Student&#34;);//注意此字符串必须是真实路径，就是带包名的类路径，包名.类名  \n           System.out.println(stuClass3 == stuClass2);//判断三种方式是否获取的是同一个Class对象  \n       } catch (ClassNotFoundException e) {  \n           e.printStackTrace();  \n       }  \n         \n   }  \n}&lt;/span&gt;</code></pre></div><h2>注意：在运行期间，一个类，只有一个Class对象产生。<br/></h2><p>三种方式常用第三种，第一种对象都有了还要反射干什么。第二种需要导入类的包，依赖太强，不导包就抛编译错误。一般都第三种，一个字符串可以传入也可写在配置文件中等多种方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>2、通过反射获取构造方法并使用：</h2><p>student类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package fanshe;  \n \npublic class Student {  \n     \n   //---------------构造方法-------------------  \n   //（默认的构造方法）  \n   Student(String str){  \n       System.out.println(&#34;(默认)的构造方法 s = &#34; + str);  \n   }  \n     \n   //无参构造方法  \n   public Student(){  \n       System.out.println(&#34;调用了公有、无参构造方法执行了。。。&#34;);  \n   }  \n     \n   //有一个参数的构造方法  \n   public Student(char name){  \n       System.out.println(&#34;姓名：&#34; + name);  \n   }  \n     \n   //有多个参数的构造方法  \n   public Student(String name ,int age){  \n       System.out.println(&#34;姓名：&#34;+name+&#34;年龄：&#34;+ age);//这的执行效率有问题，以后解决。\n   }  \n     \n   //受保护的构造方法  \n   protected Student(boolean n){  \n       System.out.println(&#34;受保护的构造方法 n = &#34; + n);  \n   }  \n     \n   //私有构造方法  \n   private Student(int age){  \n       System.out.println(&#34;私有的构造方法 年龄：&#34;+ age);  \n   }  \n \n}</code></pre></div><p>共有6个构造方法；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package fanshe;  \n \nimport java.lang.reflect.Constructor;  \n \n \n/* \n* 通过Class对象可以获取某个类中的：构造方法、成员变量、成员方法；并访问成员；\n*  \n* 1.获取构造方法：\n* 1).批量的方法：\n* public Constructor[] getConstructors()：所有&#34;公有的&#34;构造方法\npublic Constructor[] getDeclaredConstructors()：获取所有的构造方法(包括私有、受保护、默认、公有)\n\n* 2).获取单个的方法，并调用：\n* public Constructor getConstructor(Class... parameterTypes):获取单个的&#34;公有的&#34;构造方法：\n* public Constructor getDeclaredConstructor(Class... parameterTypes):获取&#34;某个构造方法&#34;可以是私有的，或受保护、默认、公有；\n*       \n* 调用构造方法：\n*          Constructor--&gt;newInstance(Object... initargs) \n*/  \npublic class Constructors {  \n \n   public static void main(String[] args) throws Exception {  \n       //1.加载Class对象  \n       Class clazz = Class.forName(&#34;fanshe.Student&#34;);  \n         \n         \n       //2.获取所有公有构造方法  \n       System.out.println(&#34;**********************所有公有构造方法*********************************&#34;);  \n       Constructor[] conArray = clazz.getConstructors();  \n       for(Constructor c : conArray){  \n           System.out.println(c);  \n       }  \n         \n         \n       System.out.println(&#34;************所有的构造方法(包括：私有、受保护、默认、公有)***************&#34;);  \n       conArray = clazz.getDeclaredConstructors();  \n       for(Constructor c : conArray){  \n           System.out.println(c);  \n       }  \n         \n       System.out.println(&#34;*****************获取公有、无参的构造方法*******************************&#34;);  \n       Constructor con = clazz.getConstructor(null);  \n       //1&gt;、因为是无参的构造方法所以类型是一个null,不写也可以：这里需要的是一个参数的类型，切记是类型\n       //2&gt;、返回的是描述这个无参构造函数的类对象。\n     \n       System.out.println(&#34;con = &#34; + con);  \n       //调用构造方法  \n       Object obj = con.newInstance();  \n   //  System.out.println(&#34;obj = &#34; + obj);  \n   //  Student stu = (Student)obj;  \n         \n       System.out.println(&#34;******************获取私有构造方法，并调用*******************************&#34;);  \n       con = clazz.getDeclaredConstructor(char.class);  \n       System.out.println(con);  \n       //调用构造方法  \n       con.setAccessible(true);//暴力访问(忽略掉访问修饰符)  \n       obj = con.newInstance(&#39;男&#39;);  \n   }  \n     \n}</code></pre></div><p>后台输出：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">**********************所有公有构造方法*********************************  \npublic fanshe.Student(java.lang.String,int)  \npublic fanshe.Student(char)  \npublic fanshe.Student()  \n************所有的构造方法(包括：私有、受保护、默认、公有)***************  \nprivate fanshe.Student(int)  \nprotected fanshe.Student(boolean)  \npublic fanshe.Student(java.lang.String,int)  \npublic fanshe.Student(char)  \npublic fanshe.Student()  \nfanshe.Student(java.lang.String)  \n*****************获取公有、无参的构造方法*******************************  \ncon = public fanshe.Student()  \n调用了公有、无参构造方法执行了。。。\n******************获取私有构造方法，并调用*******************************  \npublic fanshe.Student(char)  \n姓名：男</code></pre></div><p>调用方法：</p><p>1.获取构造方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-09b460b7af2993739e6fc4791d9bf019_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic2.zhimg.com/v2-09b460b7af2993739e6fc4791d9bf019_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;423&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic2.zhimg.com/v2-09b460b7af2993739e6fc4791d9bf019_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-09b460b7af2993739e6fc4791d9bf019_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、newInstance是 Constructor类的方法（管理构造函数的类）</p><p>api的解释为：</p><p>newInstance(Object... initargs)<br/>  使用此 <code>Constructor</code> 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p><p>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3、获取成员变量并调用</h2><p>student类：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.field;  \n \npublic class Student {  \n   public Student(){  \n         \n   }  \n   //**********字段*************//  \n   public String name;  \n   protected int age;  \n   char sex;  \n   private String phoneNum;  \n     \n   @Override  \n   public String toString() {  \n       return &#34;Student [name=&#34; + name + &#34;, age=&#34; + age + &#34;, sex=&#34; + sex  \n               + &#34;, phoneNum=&#34; + phoneNum + &#34;]&#34;;  \n   }  \n     \n     \n}&lt;/span&gt;</code></pre></div><p>测试类：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.field;  \nimport java.lang.reflect.Field;  \n/* \n* 获取成员变量并调用：\n*  \n* 1.批量的 \n*      1).Field[] getFields():获取所有的&#34;公有字段&#34; \n* 2).Field[] getDeclaredFields():获取所有字段，包括：私有、受保护、默认、公有；\n* 2.获取单个的：\n* 1).public Field getField(String fieldName):获取某个&#34;公有的&#34;字段；\n*      2).public Field getDeclaredField(String fieldName):获取某个字段(可以是私有的) \n*  \n* 设置字段的值：\n*      Field --&gt; public void set(Object obj,Object value): \n* 参数说明：\n* 1.obj:要设置的字段所在的对象；\n* 2.value:要为字段设置的值；\n*  \n*/  \npublic class Fields {  \n \n       public static void main(String[] args) throws Exception {  \n           //1.获取Class对象  \n           Class stuClass = Class.forName(&#34;fanshe.field.Student&#34;);  \n           //2.获取字段  \n           System.out.println(&#34;************获取所有公有的字段********************&#34;);  \n           Field[] fieldArray = stuClass.getFields();  \n           for(Field f : fieldArray){  \n               System.out.println(f);  \n           }  \n           System.out.println(&#34;************获取所有的字段(包括私有、受保护、默认的)********************&#34;);  \n           fieldArray = stuClass.getDeclaredFields();  \n           for(Field f : fieldArray){  \n               System.out.println(f);  \n           }  \n           System.out.println(&#34;*************获取公有字段**并调用***********************************&#34;);  \n           Field f = stuClass.getField(&#34;name&#34;);  \n           System.out.println(f);  \n           //获取一个对象  \n           Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();  \n           //为字段设置值  \n           f.set(obj, &#34;刘德华&#34;);//为Student对象中的name属性赋值--》stu.name = &#34;刘德华&#34;  \n           //验证  \n           Student stu = (Student)obj;  \n           System.out.println(&#34;验证姓名：&#34; + stu.name);  \n             \n             \n           System.out.println(&#34;**************获取私有字段****并调用********************************&#34;);  \n           f = stuClass.getDeclaredField(&#34;phoneNum&#34;);  \n           System.out.println(f);  \n           f.setAccessible(true);//暴力反射，解除私有限定  \n           f.set(obj, &#34;18888889999&#34;);  \n           System.out.println(&#34;验证电话：&#34; + stu);  \n             \n       }  \n   }&lt;/span&gt;&lt;span style=&#34;font-size:18px;&#34;&gt;  \n&lt;/span&gt;</code></pre></div><p>后台输出：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">************获取所有公有的字段********************  \npublic java.lang.String fanshe.field.Student.name  \n************获取所有的字段(包括私有、受保护、默认的)********************  \npublic java.lang.String fanshe.field.Student.name  \nprotected int fanshe.field.Student.age  \nchar fanshe.field.Student.sex  \nprivate java.lang.String fanshe.field.Student.phoneNum  \n*************获取公有字段**并调用***********************************  \npublic java.lang.String fanshe.field.Student.name  \n验证姓名：刘德华\n**************获取私有字段****并调用********************************  \nprivate java.lang.String fanshe.field.Student.phoneNum  \n验证电话：Student [name=刘德华, age=0, sex=</code></pre></div><p>由此可见</p><p>调用字段时：需要传递两个参数：</p><p>Object obj = stuClass.getConstructor().newInstance();//产生Student对象--》Student stu = new Student();<br/>//为字段设置值<br/>f.set(obj, &#34;刘德华&#34;);//为Student对象中的name属性赋值--》stu.name = &#34;刘德华&#34;<br/></p><p>第一个参数：要传入设置的对象，第二个参数：要传入实参</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>4、获取成员方法并调用</h2><p>student类：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.method;  \n \npublic class Student {  \n   //**************成员方法***************//  \n   public void show1(String s){  \n       System.out.println(&#34;调用了：公有的，String参数的show1(): s = &#34; + s);  \n   }  \n   protected void show2(){  \n       System.out.println(&#34;调用了：受保护的，无参的show2()&#34;);  \n   }  \n   void show3(){  \n       System.out.println(&#34;调用了：默认的，无参的show3()&#34;);  \n   }  \n   private String show4(int age){  \n       System.out.println(&#34;调用了，私有的，并且有返回值的，int参数的show4(): age = &#34; + age);  \n       return &#34;abcd&#34;;  \n   }  \n}  \n&lt;/span&gt;</code></pre></div><p>测试类：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.method;  \n \nimport java.lang.reflect.Method;  \n \n/* \n* 获取成员方法并调用：\n*  \n* 1.批量的：\n* public Method[] getMethods():获取所有&#34;公有方法&#34;；（包含了父类的方法也包含Object类）\n*      public Method[] getDeclaredMethods():获取所有的成员方法，包括私有的(不包括继承的) \n* 2.获取单个的：\n*      public Method getMethod(String name,Class&lt;?&gt;... parameterTypes): \n* 参数：\n* name : 方法名；\n*                      Class ... : 形参的Class类型对象 \n*      public Method getDeclaredMethod(String name,Class&lt;?&gt;... parameterTypes) \n*  \n* 调用方法：\n*      Method --&gt; public Object invoke(Object obj,Object... args): \n* 参数说明：\n* obj : 要调用方法的对象；\n* args:调用方式时所传递的实参；\n\n): \n*/  \npublic class MethodClass {  \n \n   public static void main(String[] args) throws Exception {  \n       //1.获取Class对象  \n       Class stuClass = Class.forName(&#34;fanshe.method.Student&#34;);  \n       //2.获取所有公有方法  \n       System.out.println(&#34;***************获取所有的”公有“方法*******************&#34;);  \n       stuClass.getMethods();  \n       Method[] methodArray = stuClass.getMethods();  \n       for(Method m : methodArray){  \n           System.out.println(m);  \n       }  \n       System.out.println(&#34;***************获取所有的方法，包括私有的*******************&#34;);  \n       methodArray = stuClass.getDeclaredMethods();  \n       for(Method m : methodArray){  \n           System.out.println(m);  \n       }  \n       System.out.println(&#34;***************获取公有的show1()方法*******************&#34;);  \n       Method m = stuClass.getMethod(&#34;show1&#34;, String.class);  \n       System.out.println(m);  \n       //实例化一个Student对象  \n       Object obj = stuClass.getConstructor().newInstance();  \n       m.invoke(obj, &#34;刘德华&#34;);  \n         \n       System.out.println(&#34;***************获取私有的show4()方法******************&#34;);  \n       m = stuClass.getDeclaredMethod(&#34;show4&#34;, int.class);  \n       System.out.println(m);  \n       m.setAccessible(true);//解除私有限定  \n       Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参  \n       System.out.println(&#34;返回值：&#34; + result);  \n         \n         \n   }  \n}  \n&lt;/span&gt;</code></pre></div><p>控制台输出：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">***************获取所有的”公有“方法*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \npublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException  \npublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedException  \npublic final void java.lang.Object.wait() throws java.lang.InterruptedException  \npublic boolean java.lang.Object.equals(java.lang.Object)  \npublic java.lang.String java.lang.Object.toString()  \npublic native int java.lang.Object.hashCode()  \npublic final native java.lang.Class java.lang.Object.getClass()  \npublic final native void java.lang.Object.notify()  \npublic final native void java.lang.Object.notifyAll()  \n***************获取所有的方法，包括私有的*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \nprivate java.lang.String fanshe.method.Student.show4(int)  \nprotected void fanshe.method.Student.show2()  \nvoid fanshe.method.Student.show3()  \n***************获取公有的show1()方法*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \n调用了：公有的，String参数的show1(): s = 刘德华\n***************获取私有的show4()方法******************  \nprivate java.lang.String fanshe.method.Student.show4(int)  \n调用了，私有的，并且有返回值的，int参数的show4(): age = 20  \n返回值：abcd</code></pre></div><p>由此可见：</p><p>m = stuClass.getDeclaredMethod(&#34;show4&#34;, int.class);//调用制定方法（所有包括私有的），需要传入两个参数，第一个是调用的方法名称，第二个是方法的形参类型，切记是类型。<br/>System.out.println(m);<br/>m.setAccessible(true);//解除私有限定<br/>Object result = m.invoke(obj, 20);//需要两个参数，一个是要调用的对象（获取有反射），一个是实参<br/>System.out.println(&#34;返回值：&#34; + result);//</p><p class=\"ztext-empty-paragraph\"><br/></p><p>控制台输出：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">***************获取所有的”公有“方法*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \npublic final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException  \npublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedException  \npublic final void java.lang.Object.wait() throws java.lang.InterruptedException  \npublic boolean java.lang.Object.equals(java.lang.Object)  \npublic java.lang.String java.lang.Object.toString()  \npublic native int java.lang.Object.hashCode()  \npublic final native java.lang.Class java.lang.Object.getClass()  \npublic final native void java.lang.Object.notify()  \npublic final native void java.lang.Object.notifyAll()  \n***************获取所有的方法，包括私有的*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \nprivate java.lang.String fanshe.method.Student.show4(int)  \nprotected void fanshe.method.Student.show2()  \nvoid fanshe.method.Student.show3()  \n***************获取公有的show1()方法*******************  \npublic void fanshe.method.Student.show1(java.lang.String)  \n调用了：公有的，String参数的show1(): s = 刘德华\n***************获取私有的show4()方法******************  \nprivate java.lang.String fanshe.method.Student.show4(int)  \n调用了，私有的，并且有返回值的，int参数的show4(): age = 20  \n返回值：abcd</code></pre></div><p>其实这里的成员方法：在模型中有属性一词，就是那些setter（）方法和getter()方法。还有字段组成，这些内容在内省中详解</p><h2>5、反射main方法</h2><p>student类：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.main;  \n \npublic class Student {  \n \n   public static void main(String[] args) {  \n       System.out.println(&#34;main方法执行了。。。&#34;);  \n   }  \n}  \n&lt;/span&gt;</code></pre></div><p>测试类：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;span style=&#34;font-size:14px;&#34;&gt;package fanshe.main;  \n \nimport java.lang.reflect.Method;  \n \n/** \n* 获取Student类的main方法、不要与当前的main方法搞混了 \n*/  \npublic class Main {  \n     \n   public static void main(String[] args) {  \n       try {  \n           //1、获取Student对象的字节码  \n           Class clazz = Class.forName(&#34;fanshe.main.Student&#34;);  \n             \n           //2、获取main方法  \n            Method methodMain = clazz.getMethod(&#34;main&#34;, String[].class);//第一个参数：方法名称，第二个参数：方法形参的类型，\n           //3、调用main方法  \n           // methodMain.invoke(null, new String[]{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;});  \n            //第一个参数，对象类型，因为方法是static静态的，所以为null可以，第二个参数是String数组，这里要注意在jdk1.4时是数组，jdk1.5之后是可变参数  \n            //这里拆的时候将 new String[]{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;} 拆成3个对象。。。所以需要将它强转。\n            methodMain.invoke(null, (Object)new String[]{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;});//方式一  \n           // methodMain.invoke(null, new Object[]{new String[]{&#34;a&#34;,&#34;b&#34;,&#34;c&#34;}});//方式二  \n             \n       } catch (Exception e) {  \n           e.printStackTrace();  \n       }  \n         \n         \n   }  \n}&lt;/span&gt;&lt;span style=&#34;font-size:18px;&#34;&gt;  \n&lt;/span&gt;</code></pre></div><p>控制台输出：</p><p>main方法执行了。。。</p><h2>6、反射方法的其它使用之---通过反射运行配置文件内容</h2><p>student类：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Student {  \n   public void show(){  \n       System.out.println(&#34;is show()&#34;);  \n   }  \n}</code></pre></div><p>配置文件以txt文件为例子（pro.txt）：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">className = cn.fanshe.Student  \nmethodName = show</code></pre></div><p>测试类：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.io.FileNotFoundException;  \nimport java.io.FileReader;  \nimport java.io.IOException;  \nimport java.lang.reflect.Method;  \nimport java.util.Properties;  \n \n/* \n* 我们利用反射和配置文件，可以使：应用程序更新时，对源码无需进行任何修改\n* 我们只需要将新类发送给客户端，并修改配置文件即可 \n*/  \npublic class Demo {  \n   public static void main(String[] args) throws Exception {  \n       //通过反射获取Class对象  \n       Class stuClass = Class.forName(getValue(&#34;className&#34;));//&#34;cn.fanshe.Student&#34;  \n       //2获取show()方法  \n       Method m = stuClass.getMethod(getValue(&#34;methodName&#34;));//show  \n       //3.调用show()方法  \n       m.invoke(stuClass.getConstructor().newInstance());  \n         \n   }  \n     \n   //此方法接收一个key，在配置文件中获取相应的value  \n   public static String getValue(String key) throws IOException{  \n       Properties pro = new Properties();//获取配置文件的对象  \n       FileReader in = new FileReader(&#34;pro.txt&#34;);//获取输入流  \n       pro.load(in);//将流加载到配置文件对象中  \n       in.close();  \n       return pro.getProperty(key);//返回根据key获取的value值  \n   }  \n}</code></pre></div><p>控制台输出：</p><p>is show()</p><p class=\"ztext-empty-paragraph\"><br/></p><p>需求：<br/>当我们升级这个系统时，不要Student类，而需要新写一个Student2的类时，这时只需要更改pro.txt的文件内容就可以了。代码就一点不用改动</p><p class=\"ztext-empty-paragraph\"><br/></p><p>要替换的student2类：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Student2 {  \n   public void show2(){  \n       System.out.println(&#34;is show2()&#34;);  \n   }  \n}</code></pre></div><p>配置文件更改为：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">className = cn.fanshe.Student2  \nmethodName = show2</code></pre></div><p>控制台输出：</p><p>is show2();</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>7、反射方法的其它使用之---通过反射越过泛型检查</h2><p>泛型用在编译期，编译过后泛型擦除（消失掉）。所以是可以通过反射越过泛型检查的</p><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.lang.reflect.Method;  \nimport java.util.ArrayList;  \n \n/* \n* 通过反射越过泛型检查 \n*  \n* 例如：有一个String泛型的集合，怎样能向这个集合中添加一个Integer类型的值？\n*/  \npublic class Demo {  \n   public static void main(String[] args) throws Exception{  \n       ArrayList&lt;String&gt; strList = new ArrayList&lt;&gt;();  \n       strList.add(&#34;aaa&#34;);  \n       strList.add(&#34;bbb&#34;);  \n         \n   //  strList.add(100);  \n       //获取ArrayList的Class对象，反向的调用add()方法，添加数据  \n       Class listClass = strList.getClass(); //得到 strList 对象的字节码 对象  \n       //获取add()方法  \n       Method m = listClass.getMethod(&#34;add&#34;, Object.class);  \n       //调用add()方法  \n       m.invoke(strList, 100);  \n         \n       //遍历集合  \n       for(Object obj : strList){  \n           System.out.println(obj);  \n       }  \n   }  \n}</code></pre></div><p>控制台输出：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">aaa\nbbb\n100</code></pre></div><p><b>好了，反射就总结到这。</b></p><ul><li><b>原文：<a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/sinat_38259539/article/details/71799078\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.csdn.net/sinat_382</span><span class=\"invisible\">59539/article/details/71799078</span><span class=\"ellipsis\"></span></a></b></li></ul><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63853401", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 2, 
            "title": "初识Java（Java数字处理类-大数字运算)", 
            "content": "<p></p><p>一、大数字运算</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   在 Java 中提供了大数字的操作类，即 java.math.BigInteger 类与  java.math.BigDecimal 类。这两个类用于高精度计算，体重 BigInteger 类是针对大整数的处理类，而  BigDecimal  类则是针对大小数的处理类。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-99c9ceb892d1f22928b42cd95012e39c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"19\" data-rawheight=\"18\" class=\"content_image\" width=\"19\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;19&#39; height=&#39;18&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"19\" data-rawheight=\"18\" class=\"content_image lazy\" width=\"19\" data-actualsrc=\"https://pic1.zhimg.com/v2-99c9ceb892d1f22928b42cd95012e39c_b.jpg\"/></figure><p>    1.1   BigInteger </p><p class=\"ztext-empty-paragraph\"><br/></p><p>   BigInteger  类型的数字范围较 Integer 类型的数字范围要大得多。Integer 是 int 的包装类， int 的最大值是 2³¹-1 ，如果要计算更大的数字，使用 Integer 数据类型就无法实现了，所以 Java 中提供了 BigInteger 类来处理更大的数字。 BigInteger 支持任意精度的整数，也就是说在运算中 BigInteger 类型可以准确地表示任何大小的整数值而不会丢失任何信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   在 BigInteger 类中封装了多种操作，除了基本的加、减、乘、除操作之外，还提供了绝对值、相反数、最大公约数以及判断是否为质数等操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   使用 BigInteger 类，可以实例化一个 BigInteger 对象，并自动调用相应的构造函数。 BigInteger 类具有很多构造函数，但最直接的一种方式是参数以字符串形式代表要处理的数字。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   语法如下 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public BigInteger(String val)\n其中 ， val 是十进制字符串。\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>   如果将 2 转换为 BigInteger 类型，可以使用一下语句进行初始化操作 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigInteger twoInstance = new BigInteger(&#34;2&#34;);     //将十进制 2 转换为 BigInteger 形式</p><p>   参数 2 的双引号不能省略，因为参数是以字符串的形式存在的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   一旦创建了对象实例，就可以调用 BigInteger 类中的一些方法进行运算操作，包括基本的数学运算和位运算以及一些取相反数、取绝对值等操作。下面列举几种常用运算方法 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（ 1 ） public BigInteger add(BigInteger val)  ：                     做加法运算</p><p>（ 2 ） public BigInteger subtract(BigInteger val)  ：                做减法运算</p><p>（ 3 ） public BigInteger multiply(BigInteger val)  ：                做乘法运算</p><p>（ 4 ） public BigInteger divide(BigInteger val)  ：                  做除法运算</p><p>（ 5 ） public BigInteger remainder(BigInteger val)  ：               做取余运算</p><p>（ 6 ） public BigInteger[] divideAndRemainder (BigInteger val)  ：   用数组返回余数和商，结果数组中第一个值为商，第二个值为余数</p><p>（ 7 ） public BigInteger pow(int exponent)  ：                       进行取参数的 exponent 次方操作</p><p>（ 8 ） public BigInteger negate()  ：                                取相反数</p><p>（ 9 ） public BigInteger shiftLeft(int n)  ：                        将数字左移 n 位，如果 n 为负数，做右移操作</p><p>（ 10 ）public BigInteger shiftRight(int n)  ：                       将数字右移 n 位，如果 n 为负数，做左移操作</p><p>（ 11 ）public BigInteger and(BigInteger val) ：                      做与操作</p><p>（ 12 ）public BigInteger or(BigInteger val)  ：                      做或操作</p><p>（ 13 ）public int compareTo(BigInteger val)  ：                      做数字比较操作</p><p>（ 14 ）public boolean equals(Object x)  ：                           当参数 x 是 BigInteger 类型的数字并且数值相等时，返回 true</p><p>（ 15 ）public BigInteger min(BigInteger val)   ：                    返回较小的数值</p><p>（ 16 ）public BigInteger max(BigInteger val)   ：                    返回较大的数值</p><p>   eg ： 创建类，在类的主方法中创建 BigInteger 类的实例对象，调用该对象的各种方法实现大整数的加、减、乘、除和其他运算，并输出运算结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.math.BigInteger;\npublic class BigIntegerDemo {\n    public static void main(String[] args) {\n        BigInteger bigInteger = new BigInteger(&#34;4&#34;);//实例化一个大数字\nSystem.out.println(&#34;加法操作：&#34; + bigInteger.add(new BigInteger(&#34;2&#34;)));\nSystem.out.println(&#34;减法操作：&#34; + bigInteger.subtract(new BigInteger(&#34;2&#34;)));\nSystem.out.println(&#34;乘法操作：&#34; + bigInteger.multiply(new BigInteger(&#34;2&#34;)));\nSystem.out.println(&#34;除法操作：&#34; + bigInteger.divide(new BigInteger(&#34;2&#34;)));\nSystem.out.println(&#34;取商操作：&#34; + bigInteger.divideAndRemainder(new BigInteger(&#34;3&#34;))[0]);\nSystem.out.println(&#34;取余数操作：&#34; + bigInteger.divideAndRemainder(new BigInteger(&#34;3&#34;))[1]);\nSystem.out.println(&#34;做 2 次方操作：&#34; + bigInteger.pow(2));\nSystem.out.println(&#34;取相反数操作：&#34; + bigInteger.negate());\n    }\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>   运行结果为 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>加法操作：6</p><p>减法操作：2</p><p>乘法操作：8</p><p>除法操作：2</p><p>取商操作：1</p><p>取余数操作：1</p><p>做 2 次方操作：16</p><p>取相反数操作：-4</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-99c9ceb892d1f22928b42cd95012e39c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"19\" data-rawheight=\"18\" class=\"content_image\" width=\"19\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;19&#39; height=&#39;18&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"19\" data-rawheight=\"18\" class=\"content_image lazy\" width=\"19\" data-actualsrc=\"https://pic1.zhimg.com/v2-99c9ceb892d1f22928b42cd95012e39c_b.jpg\"/></figure><p>1.2  BigDecimal</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   BigDecimal 和  BigInteger 都能用来实现大数字的运算，不同的是 BigDecimal 加入了小数的概念。一般的 float 型和 double 型数据只可以用来做科学计算或工程计算，但由于在商业计算中要求数字精度比较高，所以要用到 java.math.BigDecimal 类。 BigDecimal 类支持任何精度的定点数，可以用它来精确计算货币值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   在 BigDecimal 类中常用的两个构造方法如下 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public BigDecimal(double val) :    实例化时将双精度型转换为 BigDecimal 类型</p><p>public BigDecimal(String val) :    实例化时将字符串形式转换为 BigDecimal 类型</p><p>   BigDecimal 类型的数字可以用来做超大的浮点数的运算，如加、减、乘、除等，但是在所有的运算中除法是最复杂的，因为在除不尽的情况下末位小数点的处理是需要考虑的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   下面列举 BigDecimal 类中实现加、减、乘、除的方法 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>public BigDecimal add(BigDecimal augend) ：做加法操作</p><p>public BigDecimal subtract(BigDecimal subtrahend) ：做减法操作</p><p>public BigDecimal multiply(BigDecimal multiplicand) ：做乘法操作</p><p>public BigDecimal divide(BigDecimal divisor , int sacle ,int roundingMode) ：做除法操作，方法中 3 个参数分别代表除数、商的小数点后的位数、近似处理模式</p><p>   在上述方法中，BigDecimal 类中 divide() 方法有多种设置，用于返回商末位小数点的处理，这些模式的名称与含义如下 ：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigDecimal 类中 divide() 方法的多种处理模式</p><p>模式 含义</p><p>BigDecimal.ROUND_UP s商的最后一位如果大于 0 ，则向前进位，正负数都如此</p><p>BigDecimal .ROUND_DOWN 商的最后一位无论是什么数字都省略</p><p>BigDecimal .ROUND_CEILING </p><p>商如果是正数，按照 ROUND_UP 模式处理；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果是负数，按照 ROUND_DOWN 模式处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种模式的处理都会使近似值大于等于实际值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigDecimal .ROUND_FLOOR </p><p>与 ROUND_CEILING 模式相反，</p><p class=\"ztext-empty-paragraph\"><br/></p><p>商如果是正数，按照 ROUND_DOWN 模式处理；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果是负数，按照ROUND_UP 模式处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种模式的处理都会使近似值小于等于实际值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigDecimal .ROUND_HALF_DOWN </p><p>对商进行四舍五入操作，如果商最后一位小于等于 5，则做舍弃操作；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果最后一位大于 5 ，则做进位操作，如 7.5 ≈ 7</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigDecimal .ROUND_HALF_UP </p><p>对商进行四舍五入操作，如果商的最后一位小于 5 则舍弃；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果大于等于 5 ，进行进位操作，如 7.5 ≈ 8</p><p class=\"ztext-empty-paragraph\"><br/></p><p>BigDecimal ROUND_HALF_EVEN </p><p>如果商的倒数第二位为奇数，则按照 ROUND_HALF_UP 处理；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果为偶数，则按照 ROUND_HALF_DOWN 处理，如 7.5 ≈ 8 , 8.5 ≈ 8</p><p class=\"ztext-empty-paragraph\"><br/></p><p>   eg  ： 创建类，在类中分别定义 add() 、sub() 、mul() 和 div() 方法实现加、减、乘、除运算，并输出运算结果。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.math.BigDecimal;\n\npublic class BigDecimalDemo {\n\n    static final int location = 10;\n\n    /**\n\n     * 定义加法方法，参数为加数与被加数\n\n     * @param value1 相加的第一个数\n\n     * @param value2 相加的第二个数\n\n     * @return 两数之和\n\n     */\n\n    public BigDecimal add(double value1 , double value2) {\n\n    //实例化 Decimal 对象\n\n        BigDecimal b1 = new BigDecimal(Double.toString(value1));\n\n        BigDecimal b2 = new BigDecimal(Double.toString(value2));\n\n        return b1.add(b2);        //调用加法方法\n\n    }\n\n    /**\n\n     * 定义减法方法，参数为减数与被减数\n\n     * @param value1 被减数\n\n     * @param value2 减数\n\n     * @return 运算结果\n\n     */\n\n    public BigDecimal sub(double value1 , double value2) {\n\n    //实例化 Decimal 对象\n\n        BigDecimal b1 = new BigDecimal(Double.toString(value1));\n\n        BigDecimal b2 = new BigDecimal(Double.toString(value2));\n\n        return b1.subtract(b2);        //调用减法方法\n\n    }\n\n    /**\n\n     * 定义乘法方法，参数为乘数与被乘数\n\n     * @param value1 第一个乘数\n\n     * @param value2 第二个乘数\n\n     * @return 运算结果\n\n     */\n\n    public BigDecimal mul(double value1 , double value2) {\n\n        //实例化 Decimal 对象\n\n        BigDecimal b1 = new BigDecimal(Double.toString(value1));\n\n        BigDecimal b2 = new BigDecimal(Double.toString(value2));\n\n        return b1.multiply(b2);        //调用乘法方法\n\n    }\n\n    /**\n\n     * 定义除法方法，参数为除数与被除数\n\n     * @param value1 被除数\n\n     * @param value2 除数\n\n     * @return 运算结果\n\n     */\n\n    public BigDecimal div(double value1 , double value2) {\n\n        return div(value1, value2,location);//调用自定义除法方法\n\n    }\n\n    public BigDecimal div(double value1 , double value2 ,int b) {\n\n        if (b&lt;0) {\n\n        System.out.println(&#34;b 值必须大于等于 0&#34;);\n\n        }\n\n        BigDecimal b1 = new BigDecimal(Double.toString(value1));\n\n        BigDecimal b2 = new BigDecimal(Double.toString(value2));\n\n        //调用除法方法，商小数点保留 b 位，并将结果进行四舍五入操作\n\n        return b1.divide(b2,b,BigDecimal.ROUND_HALF_UP);\n\n    }\n\n    public static void main(String[] args) {\n\n        BigDecimalDemo b = new BigDecimalDemo();\n\nSystem.out.println(&#34;两个数字相加结果：&#34; + b.add(-7.5, 8.9));\n\nSystem.out.println(&#34;两个数字相减结果：&#34; + b.sub(-7.5, 8.9));\n\nSystem.out.println(&#34;两个数字相乘结果：&#34; + b.mul(-7.5, 8.9));\n\nSystem.out.println(&#34;两个数字相除结果，结果小数后保留 10 位：&#34; + b.div(10,2));\n\nSystem.out.println(&#34;两个数字相除，保留小数后 5 位：&#34; + b.div(-7.8,8.9,5));\n\n    }\n\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>   运行结果为：</p><p>两个数字相加结果：1.4</p><p>两个数字相减结果：-16.4</p><p>两个数字相乘结果：-66.75</p><p>两个数字相除结果，结果小数后保留 10 位：5.0000000000</p><p>两个数字相除，保留小数后 5 位：-0.87640</p><p>   终于，基础算是要告一段落了，接下来是 Java 的核心技术。继续努力，继续学习。</p><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦编程】，大家一起交流解决！</p><p>--------------------- </p><p>作者：空零之旅</p><p>原文：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/js940814/article/details/80210456\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/js940814/</span><span class=\"invisible\">article/details/80210456</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "运算", 
                    "tagLink": "https://api.zhihu.com/topics/19567088"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63204985", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "Python matplotlib绘图示例 - 绘制三维图形", 
            "content": "<p>Python matplotlib模块是扩展的MATLAB的一个绘图工具库。它可以绘制各种图形，下面就学习了下Python中的matplotlib模块，如何绘制三维图形。<br/></p><p>示例代码一：</p><div class=\"highlight\"><pre><code class=\"language-text\"># coding=utf-8\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport mpl_toolkits.mplot3d\na,b = np.mgrid[-2:2:20j,-2:2:20j]\n#测试数据\nc=a*np.exp(-a**2-b**2)\n#三维图形\nax = plt.subplot(111, projection=&#39;3d&#39;)\nax.set_title(&#39;www.linuxidc.com - matplotlib Code Demo&#39;);\nax.plot_surface(a,b,c,rstride=2, cstride=1, cmap=plt.cm.Spectral)\n#设置坐标轴标签\nax.set_xlabel(&#39;A&#39;)\nax.set_ylabel(&#39;B&#39;)\nax.set_zlabel(&#39;C&#39;)\nplt.show()</code></pre></div><p>运行结果：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4ebf30b8d89ef7d9284fab93378e895_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-b4ebf30b8d89ef7d9284fab93378e895_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;610&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-b4ebf30b8d89ef7d9284fab93378e895_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4ebf30b8d89ef7d9284fab93378e895_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>示例代码二：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\"># coding=utf-8\nimport pylab as pl\nimport numpy as np\nimport mpl_toolkits.mplot3d\nrho, theta = np.mgrid[0:1:40j,0:2*np.pi:40j]\nc = rho**2\na = rho*np.cos(theta)\nb = rho*np.sin(theta)\nax = pl.subplot(111, projection=&#39;3d&#39;)\nax.set_title(&#39;www.linuxidc.com - matplotlib Code Demo&#39;);\n#ax.plot_surface(a,b,c)\nax.plot_surface(a,b,c,rstride=2, cstride=1)\n#设置坐标轴标签\nax.set_xlabel(&#39;A&#39;)\nax.set_ylabel(&#39;B&#39;)\nax.set_zlabel(&#39;C&#39;)\npl.show()</code></pre></div><p>运行结果：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1b6c5f69f822844a5996cea4b4050744_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-1b6c5f69f822844a5996cea4b4050744_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;610&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"610\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-1b6c5f69f822844a5996cea4b4050744_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1b6c5f69f822844a5996cea4b4050744_b.jpg\"/></figure><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63205114", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "WEB 性能测试用例设计及总结", 
            "content": "<p>WEB 性能测试用例设计模型是设计性能测试用例的一个框架，在实际项目中，需要对其进行适当的剪裁，从而确定性能测试用例的范围和类别。剪裁的依据是性能测试策略和测试范围，在测试用例主要框架确定后，接下来就是如何设计各类性能测试用例中具体数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>基于用户的测试多在用户现场进行，为了测试目的而进行的测试多在开发环境即开发团队的内部进行。为了测试目的而设计的测试用例场景主要根据测试设计人员的经验来进行，但是仍要参考用户的实际场景，用户实际使用场景是设计所有测试用例的依据。<br/></p><p>性能测试用例设计首先要分析出用户现实中的典型场景，然后参照典型场景进行设计。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-09cafbaba3d6b6f976b033ebac5a9b57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-09cafbaba3d6b6f976b033ebac5a9b57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-09cafbaba3d6b6f976b033ebac5a9b57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-09cafbaba3d6b6f976b033ebac5a9b57_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>比较常见的用户场景有如下三种</p><p>一天内不同时段的使用场景</p><p>系统运行不同时期的场景</p><p>不同业务模式下的场景</p><p><b>各类测试用例设计的细节</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1. 确定用户使用系统情况的方法</b></p><p>确定用户对系统的使用情况是设计用例具体数据的基础，后面并发用户数据设计，疲劳强度设计以及各种场景设计都要依赖对用户使用系统情况的分析，分析用户使用情况经常采用现场调查和分析系统日志两种方法：</p><p><b>用户现场调查：</b>通过和用户进行沟通，可以确定用户的人员组成情况，这类方法适用于用户群体固定且目标测试系统没有投产前的情况。</p><p><b>分析系统日志：</b>当用户比较分散，现场调查比较困难时，可以采用对系统日志进行分析的方法，作为对用户现场调查的补充。</p><p><b>2. 并发用户数量设计</b></p><p>设计并发用户数量前，首先要了解确定系统最大并发用户数量的方法可，以根据系统的最大使用人数或者最大在线数量来评估最大并发用户数量的方法：</p><p><b>极限法：</b>取最大在线用户数作为最大并发数，这种方法适用于系统已经投产目标用户群体不确定的门户网站，可以通过分析日志来进行测试，也可以使用系统已经注册的用户数量作为系统的用户数量，按照经验公式来估算最大用户数量。</p><p><b>用户趋势分析：</b>对软件生存周期内的用户未来走势进行分析，预测系统可能达到的最大使用用户数目，从而估算系统的最大并发用户数目，这种方法多用于用户数目逐渐增多的情况。</p><p><b>经验评估法：</b>多用于系统的使用用户数目相对稳定而且比较明确的系统。</p><p><b>并发用户数量的设计基本是按照最大并发用户的数量的百分比来设计的，对于某一特定的用例，需要注意：</b><br/></p><p>一、按照各类用户同时递增的方式来设计用户数量，是为了按照由浅入深的方法来发现系统的瓶颈；</p><p>二、并发用户的最大值一般不会超过前面计算的最大并发用户数量的 20% ，除非是为了测试系统能支持的最大并发用户数量；</p><p>三、设计用户数量时要考虑成本，因为每组用户数都意味着至少执行一次测试；</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4a16d5fb83e4d6ba8511db4613690034_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"230\" class=\"content_image\" width=\"360\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;360&#39; height=&#39;230&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"230\" class=\"content_image lazy\" width=\"360\" data-actualsrc=\"https://pic1.zhimg.com/v2-4a16d5fb83e4d6ba8511db4613690034_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3. 系统不同时间段场景的设计</b></p><p>不同时间段的场景更接近用户使用情况，它也是设计核心模块和组合模块并发性能测试用例的基础，不同时间段场景分析的数据主要是前面的需求分析和日志分析结果。</p><p>不同时间段场景的设计基本原则有两个：一是选择典型的场景进行测试，尤其要选择场景中并发用户数目较大的场景；二是要覆盖全面，设计出的用例要覆盖到压力可能较大的时间段，用户场景的设计一般与后面的业务模式结合起来进行。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4. 业务模式的设计</b></p><p>业务模式的设计是不同时间段场景设计的特例，也是设计核心模块和组合模块并发性能测试用例的基础，设计业务模式的目的是专注于某些功能模块的组合，按时间段来设计场景通常会涉及很多模块，如果系统存在的由应用软件引起的瓶颈则很难定位，所以才抽象一些特定的业务模式来进行用例的设计。</p><p>按照业务模式和时间段的场景来设计性能测试用例时，会涉及到如何设计每个模块并发用户数目的问题，通常会取各个相关模块在24小时内最大的并发用户数目进行组合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>5. 大数据量测试用例的设计</b></p><p>历史数据相关的大数据量测试设计与并发用户的测试设计很类似，首先要确定系统数据的最长迁移周期，确定了系统的最大数据量后，接下来选择一些前面的核心模块或者组合模块的并发用户测试用例作为其主要内容即可。</p><p>运行时大数据量测试主要根据模拟系统运行时可能产生的大数据量来进行测试，这类测试用例通常根据实际情况去分析设计。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>6. 一些特定测试用例的设计</b></p><p>疲劳强度测试，最大用户测试，容量测试等一些特殊的测试用例设计，根据用户的需求进行，这类用例的相关要求通常十分明确。</p><p>性能测试用例最重要的是注意用例间的关系，孤立的设计各类用例只能增加测试成本，浪费人力。性能测试用例设计人员应该追求设计既能覆盖性能测试需求，又能以较低的成本来执行测试用例。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-284777760f2aa3a71d47dbadef3d0ad5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-284777760f2aa3a71d47dbadef3d0ad5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-284777760f2aa3a71d47dbadef3d0ad5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-284777760f2aa3a71d47dbadef3d0ad5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>总结</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1. 测试用例可用性总结</b><br/></p><p>对于一个比较完善的性能测试项目，经常会有一些测试用例不能执行，因此测试完成后应该分析哪些用例不能执行以及不能执行的原因，这样可以为下次测试打好基础。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2. 用例执行效果分析</b></p><p>通过对用例执行效果进行分析，可以为升级或者开发新的性能测试用例提供有利的参考，不是所有的用例都能导致系统瓶颈的出现，因此应该分析哪些用例能够发现系统问题，那些用例执行时没有太大效果。</p><p>分析那些设计好的用例不但有助于以后设计用例，还可以为再次执行提供参考，当下次测试进度压力较大时可以先执行重要的用例，跳过那些尝试性的，不容易发现问题的用例。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3. 用例执行时间分析</b></p><p>分析用例的执行时间是为下次规划性能测试提供参考，由于很多用例执行时间不是特别确定，导致性能测试计划也具有一定的不确定性，通过分析用例的执行时间可以为以后的制定测试计划提供参考。</p><p>总之，性能测试用例的设计是需要通过不断分析总结才能做好，不但要分析性能测试用例的可用性、执行效果、执行时间，还应该分析用例的设计方法、设计思路等。</p><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63312216", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 22, 
            "title": "30道C++经典面试题，上“战场”前一定要搞懂", 
            "content": "<figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>1、new、delete、malloc、free关系</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>delete会调用对象的析构函数,和new对应free只会释放内存，new调用构造函数。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>2、delete与 delete []区别</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>delete只会调用一次析构函数，而delete[]会调用每一个成员的析构函数。在More Effective C++中有更为详细的解释：“当delete操作符用于数组时，它为每个数组元素调用析构函数，然后调用operator delete来释放内存。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">”delete与new配套，delete []与new []配套\nMemTest *mTest1=new MemTest[10];\nMemTest *mTest2=new MemTest;\nInt *pInt1=new int [10];\nInt *pInt2=new int;\ndelete[]pInt1; //-1-\ndelete[]pInt2; //-2-\ndelete[]mTest1;//-3-\ndelete[]mTest2;//-4-\n在-4-处报错。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>这就说明：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于内建简单数据类型，delete和delete[]功能是相同的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于自定义的复杂数据类型，delete和delete[]不能互用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>delete[]删除一个数组，delete删除一个指针。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>简单来说，用new分配的内存用delete删除；用new[]分配的内存用delete[]删除。delete[]会调用数组元素的析构函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>内部数据类型没有析构函数，所以问题不大。如果你在用delete时没用括号，delete就会认为指向的是单个对象，否则，它就会认为指向的是一个数组。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>3、C++有哪些性质（面向对象特点）</b></p><p>封装，继承和多态。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>4、子类析构时要调用父类的析构函数吗？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>析构函数调用的次序是先派生类的析构后基类的析构，也就是说在基类的的析构调用的时候,派生类的信息已经全部销毁了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>定义一个对象时先调用基类的构造函数、然后调用派生类的构造函数；析构的时候恰好相反：先调用派生类的析构函数、然后调用基类的析构函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>5、多态，虚函数，纯虚函数</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>多态：是对于不同对象接收相同消息时产生不同的动作。C++的多态性具体体现在运行和编译两个方面：在程序运行时的多态性通过继承和虚函数来体现；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在程序编译时多态性体现在函数和运算符的重载上；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虚函数：在基类中冠以关键字 virtual 的成员函数。它提供了一种接口界面。允许在派生类中对基类的虚函数重新定义。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>纯虚函数的作用：在基类中为其派生类保留一个函数的名字，以便派生类根据需要对它进行定义。作为接口而存在 纯虚函数不具备函数的功能，一般不能直接被调用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>从基类继承来的纯虚函数，在派生类中仍是虚函数。如果一个类中至少有一个纯虚函数，那么这个类被称为抽象类（abstract class）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>抽象类中不仅包括纯虚函数，也可包括虚函数。抽象类必须用作派生其他类的基类，而不能用于直接创建对象实例。但仍可使用指向抽象类的指针支持运行时多态性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>6.求下面函数的返回值（微软）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">int func(x) \n{ \nint countx = 0; \nwhile(x) \n{ \ncountx ++; \nx = x&amp;(x-1); \n} \nreturn countx; \n} </code></pre></div><p>假定x = 9999。答案：8</p><p class=\"ztext-empty-paragraph\"><br/></p><p>思路：将x转化为2进制，看含有的1的个数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>7、什么是“引用”？申明和使用“引用”要注意哪些问题？</b></p><p>答：引用就是某个目标变量的“别名”(alias)，对应用的操作与对变量直接操作效果完全相同。申明一个引用的时候，切记要对其进行初始化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，不能再把该引用名作为其他变量名的别名。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>8、将“引用”作为函数参数有哪些特点？</b></p><h2><br/></h2><p>（1）传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（3）使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用&#34;*指针变量名&#34;的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>9、在什么时候需要使用“常引用”？</b></p><p>如果既要利用引用提高程序的效率，又要保护传递给函数的数据不在函数中被改变，就应使用常引用。常引用声明方式：const 类型标识符 &amp;引用名=目标变量名；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例1：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">int a ;\nconst int &amp;ra=a;\nra=1; //错误\na=1; //正确</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例2：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">string foo( );\nvoid bar(string &amp; s);\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>那么下面的表达式将是非法的：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">bar(foo( ));\nbar(&#34;hello world&#34;);\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>原因在于foo( )和&#34;hello world&#34;串都会产生一个临时对象，而在C++中，这些临时对象都是const类型的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此上面的表达式就是试图将一个const类型的对象转换为非const类型，这是非法的。引用型参数应该在能被定义为const的情况下，尽量定义为const 。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>10、将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?</b></p><p>格式：类型标识符 &amp;函数名（形参列表及类型说明）{ //函数体 }</p><p class=\"ztext-empty-paragraph\"><br/></p><p>好处：在内存中不产生被返回值的副本；（注意：正是因为这点原因，所以返回一个局部变量的引用是不可取的。因为随着该局部变量生存期的结束，相应的引用也会失效，产生runtime error!</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意事项：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）不能返回局部变量的引用。这条可以参照Effective C++[1]的Item 31。主要原因是局部变量会在函数返回后被销毁，因此被返回的引用就成为了&#34;无所指&#34;的引用，程序会进入未知状态。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）不能返回函数内部new分配的内存的引用。这条可以参照Effective C++[1]的Item 31。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（3）可以返回类成员的引用，但最好是const。这条原则可以参照Effective C++[1]的Item 30。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要原因是当对象的属性是与某种业务规则（business rule）相关联的时候，其赋值常常与某些其它属性或者对象的状态有关，因此有必要将赋值操作封装在一个业务规则当中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果其它对象可以获得该属性的非常量引用（或指针），那么对该属性的单纯赋值就会破坏业务规则的完整性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（4）流操作符重载返回值申明为“引用”的作用：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>流操作符&lt;&lt;和&gt;&gt;，这两个操作符常常希望被连续使用，例如：cout &lt;&lt; &#34;hello&#34; &lt;&lt; endl;　因此这两个操作符的返回值应该是一个仍然支持这两个操作符的流引用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可选的其它方案包括：返回一个流对象和返回一个流对象指针。但是对于返回一个流对象，程序必须重新（拷贝）构造一个新的流对象，也就是说，连续的两个&lt;&lt;操作符实际上是针对不同对象的！这无法让人接受。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于返回一个流指针则不能连续使用&lt;&lt;操作符。因此，返回一个流对象引用是惟一选择。这个唯一选择很关键，它说明了引用的重要性以及无可替代性，也许这就是C++语言中引入引用这个概念的原因吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>赋值操作符=。这个操作符象流操作符一样，是可以连续使用的，例如：x = j = 10;或者(x=10)=100;赋值操作符的返回值必须是一个左值，以便可以被继续赋值。因此引用成了这个操作符的惟一返回值选择。</p><div class=\"highlight\"><pre><code class=\"language-text\">＃include&lt;iostream.h&gt;\nint &amp;put(int n);\nint vals[10];\nint error=-1;\nvoid main()\n{\nput(0)=10; //以put(0)函数值作为左值，等价于vals[0]=10; \nput(9)=20; //以put(9)函数值作为左值，等价于vals[9]=20; \ncout&lt;&lt;vals[0]; \ncout&lt;&lt;vals[9];\n} \nint &amp;put(int n)\n{\nif (n&gt;=0 &amp;&amp; n&lt;=9 ) return vals[n]; \nelse { cout&lt;&lt;&#34;subscript error&#34;; return error; }\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>（5）在另外的一些操作符中，却千万不能返回引用：+-*/ 四则运算符。它们不能返回引用，Effective C++[1]的Item23详细的讨论了这个问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要原因是这四个操作符没有side effect，因此，它们必须构造一个对象作为返回值，可选的方案包括：返回一个对象、返回一个局部变量的引用，返回一个new分配的对象的引用、返回一个静态对象引用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>根据前面提到的引用作为返回值的三个规则，2、3两个方案都被否决了。静态对象的引用又因为((a+b) == (c+d))会永远为true而导致错误。所以可选的只剩下返回一个对象了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>11、结构与联合有和区别？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>(1). 结构和联合都是由多个不同的数据类型成员组成, 但在任何同一时刻, 联合中只存放了一个被选中的成员（所有成员共用一块地址空间）, 而结构的所有成员都存在（不同成员的存放地址不同）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>(2). 对于联合的不同成员赋值, 将会对其它成员重写, 原来成员的值就不存在了, 而对于结构的不同成员赋值是互不影响的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>12、试写出程序结果：</b></p><h2><br/></h2><div class=\"highlight\"><pre><code class=\"language-text\">int  a=4;\nint  &amp;f(int  x)\n{    a=a+x;\n      return  a;\n}\nint main(void)\n{    int   t=5;\n     cout&lt;&lt;f(t)&lt;&lt;endl;  a = 9\n    f(t)=20;             a = 20\n    cout&lt;&lt;f(t)&lt;&lt;endl;     t = 5,a = 20  a = 25\n     t=f(t);                a = 30 t = 30\n    cout&lt;&lt;f(t)&lt;&lt;endl;  }    t = 60\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>13、重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？</b></p><h2><br/></h2><p>常考的题目。从定义上来说：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>重载：是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>重写：是指子类重新定义父类虚函数的方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>从实现原理上来说：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>重载：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如，有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>重写：和多态真正相关。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>14、有哪几种情况只能用intialization list 而不能用assignment?</b></p><h2><br/></h2><p>答案：当类中含有const、reference 成员变量；基类的构造函数都需要初始化表。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>15. C++是不是类型安全的？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>答案：不是。两个不同类型的指针之间可以强制转换（用reinterpret cast)。C#是类型安全的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>16. main 函数执行以前，还会执行什么代码？</b></p><h2><br/></h2><p>答案：全局对象的构造函数会在main 函数之前执行。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>17. 描述内存分配方式以及它们的区别?</b></p><h2><br/></h2><p>1） 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static 变量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2） 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc 或new 申请任意多少的内存，程序员自己负责在何时用free 或delete 释放内存。动态内存的生存期由程序员决定，使用非常灵活，但问题也最多。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>18、分别写出BOOL,int,float,指针类型的变量a 与“零”的比较语句。</b></p><h2><br/></h2><p>答案：</p><div class=\"highlight\"><pre><code class=\"language-text\">BOOL : if ( !a ) or if(a)\nint : if ( a == 0)\nfloat : const EXPRESSION EXP = 0.000001\nif ( a &lt; EXP &amp;&amp; a &gt;-EXP)\npointer : if ( a != NULL) or if(a == NULL)\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><br/></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>19.请说出const与#define 相比，有何优点？</b></p><h2><br/></h2><p>答案：</p><p>const作用：定义常量、修饰函数参数、修饰函数返回值三个作用。被Const修饰的东西都受到强制保护，可以预防意外的变动，能提高程序的健壮性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2） 有些集成化的调试工具可以对const 常量进行调试，但是不能对宏常量进行调试。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>20.简述数组与指针的区别？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。指针可以随时指向任意类型的内存块。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>(1)修改内容上的差别</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">char a[] = “hello”;\na[0] = ‘X’;\nchar *p = “world”; // 注意p 指向常量字符串\np[0] = ‘X’; // 编译器不能发现该错误，运行时错误\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>(2) 用运算符sizeof 可以计算出数组的容量（字节数）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>sizeof(p),p 为指针得到的是一个指针变量的字节数，而不是p 所指的内存容量。C++/C 语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">char a[] = &#34;hello world&#34;;\nchar *p = a;\ncout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12 字节\ncout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4 字节\n计算数组和指针的内存容量\nvoid Func(char a[100])\n{\ncout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4 字节而不是100 字节\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>21题：int (*s[10])(int) 表示的是什么？</b></p><h2><br/></h2><p>int (*s[10])(int) 函数指针数组，每个指针指向一个int func(int param)的函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>22题：栈内存与文字常量区</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">        char str1[] = &#34;abc&#34;;\n　　char str2[] = &#34;abc&#34;;\n　　const char str3[] = &#34;abc&#34;;\n　　const char str4[] = &#34;abc&#34;;\n　　const char *str5 = &#34;abc&#34;;\n　　const char *str6 = &#34;abc&#34;;\n　　char *str7 = &#34;abc&#34;;\n　　char *str8 = &#34;abc&#34;;\n　　cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl;//0  分别指向各自的栈内存\n　　cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl;//0  分别指向各自的栈内存\n　　cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl;//1指向文字常量区地址相同\n　　cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl;//1指向文字常量区地址相同</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>结果是：0 0 1 1</p><p class=\"ztext-empty-paragraph\"><br/></p><p>解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间；而str5,str6,str7,str8是指针，它们指向相同的常量区域。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>23题：将程序跳转到指定内存地址</b></p><h2><br/></h2><p>要对绝对地址0x100000赋值，我们可以用(unsigned int*)0x100000 = 1234;那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？</p><div class=\"highlight\"><pre><code class=\"language-text\">  　*((void (*)( ))0x100000 ) ( );\n　　首先要将0x100000强制转换成函数指针,即:\n　　(void (*)())0x100000\n</code></pre></div><p><br/>　　然后再调用它:<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">*((void (*)())0x100000)();\n　　用typedef可以看得更直观些:\n　　typedef void(*)() voidFuncPtr;\n　　*((voidFuncPtr)0x100000)();\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>24题：int id[sizeof(unsigned long)];这个对吗？为什么？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>答案:正确 这个 sizeof是编译时运算符，编译时就确定了  ,可以看成和机器有关的常量。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>25题：引用与指针有什么区别？</b></p><h2><br/></h2><p>【参考答案】   </p><p><br/>1) 引用必须被初始化，指针不必。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2) 引用初始化以后不能被改变，指针可以改变所指的对象。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3) 不存在指向空值的引用，但是存在指向空值的指针。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>26题：const  与 #define 的比较 ，const有什么优点?</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p> 【参考答案】</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1） const 常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换可能会产生意料不到的错误（边际效应） 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）  有些集成化的调试工具可以对 const 常量进行调试，但是不能对宏常量进行调试。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>27题：复杂声明</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void * ( * (*fp1)(int))[10];\nfloat (*(* fp2)(int,int,int))(int);\nint (* ( * fp3)())[10]();\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>分别表示什么意思？</p><p><br/>【标准答案】    </p><p>1、void * ( * (*fp1)(int))[10];   fp1是一个指针，指向一个函数，这个函数的参数为int型，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个void*型指针。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、float (*(* fp2)(int,int,int))(int);   fp2是一个指针，指向一个函数，这个函数的参数为3个int型，函数的返回值是一个指针，这个指针指向一个函数，这个函数的参数为int型，函数的返回值是float型。</p><p><br/>3、int (* ( * fp3)())[10]();   fp3是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是一个指针，这个指针指向一个数组，这个数组有10个元素，每个元素是一个指针，指向一个函数，这个函数的参数为空，函数的返回值是int型。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>28题：内存的分配方式有几种?</b></p><h2><br/></h2><p>【参考答案】</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一、从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二、在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>三、从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image\" width=\"104\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;104&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"104\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"104\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e4a828bbe1e527aa26c57cf4d3511bd_b.jpg\"/></figure><p><b>29题：基类的析构函数不是虚函数，会带来什么问题？</b></p><h2><br/></h2><p>【参考答案】</p><p>派生类的析构函数用不上，会造成资源的泄漏。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>30题：全局变量和局部变量有什么区别？是怎么实现的？操作系统和编译器是怎么知道的？</b><br/></p><p>【参考答案】</p><p class=\"ztext-empty-paragraph\"><br/></p><p>生命周期不同：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用；分配在栈区。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。</p><p>如果您在学习编程的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>nice work</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" data-width=\"\" data-height=\"\">[干杯]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "喽哈啊", 
                    "userLink": "https://www.zhihu.com/people/44c06c884b35c27ac7644689ed978441", 
                    "content": "27题有错误。网络上的问题资料真多，呵呵", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62764861", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "知名系统中的一些有趣bug", 
            "content": "<p>产品的绝大部分bug，会在测试阶段被消灭，但仍然有不少的bug，脱离测试工程师的魔掌，展现在了用户面前。有些bug十分影响用户体验，不过有些bug，反而会娱乐大众，让人笑翻了天。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>中国高铁，已经让外国人领略到，什么是中国速度。“复兴号”高铁已经可以达到350km/h，让外国人震惊不已，可这还不是极限速度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f8ccde1efa61c67f607eee138e09b9fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-f8ccde1efa61c67f607eee138e09b9fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-f8ccde1efa61c67f607eee138e09b9fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f8ccde1efa61c67f607eee138e09b9fb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>当高铁荧屏上，速度显示出现bug时，速度即可达到55785km/h，这个速度都超越宇宙第三速度了，这样一来，这列高铁，可以直接摆脱太阳系，甚至冲出银河系都不是梦。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>欢迎您乘坐G2333次和谐号动车组列车，本次列车开往冥王星北站，沿途停靠火星站、土星北站、天王星南站……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>蒂姆·库克：小王啊，你去把台湾官网左上角的“Jobs at Apple”改成繁体字。</p><p>小王：“好的。”</p><p class=\"ztext-empty-paragraph\"><br/></p><p>于是苹果官网左上角真的变成了繁体字！</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0d45a9669dd97b89f8d9c55dc085cca6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"617\" class=\"origin_image zh-lightbox-thumb\" width=\"479\" data-original=\"https://pic3.zhimg.com/v2-0d45a9669dd97b89f8d9c55dc085cca6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;479&#39; height=&#39;617&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"617\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"479\" data-original=\"https://pic3.zhimg.com/v2-0d45a9669dd97b89f8d9c55dc085cca6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0d45a9669dd97b89f8d9c55dc085cca6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>耿直的程序员估计是被暴打了一顿，没过多久就改正了错误，实在是太可爱了（干过这种事的程序员请举手）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-49ae545bd81b211efb4b7a9bebe002d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-49ae545bd81b211efb4b7a9bebe002d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-49ae545bd81b211efb4b7a9bebe002d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-49ae545bd81b211efb4b7a9bebe002d1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>有网友爆料，apple id注册时，出现了一个令人很无奈的bug：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3f8d9e99dec7b87721a6e9829f6a1c08_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-3f8d9e99dec7b87721a6e9829f6a1c08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-3f8d9e99dec7b87721a6e9829f6a1c08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3f8d9e99dec7b87721a6e9829f6a1c08_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>乍一看，没有什么问题，问题答案嘛，肯定不能太短，限制3个字符可以理解，可是……当看到该问题时，整个人都不好了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e59a2bc8847e3d070e31c4ca3bdb08ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-e59a2bc8847e3d070e31c4ca3bdb08ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-e59a2bc8847e3d070e31c4ca3bdb08ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e59a2bc8847e3d070e31c4ca3bdb08ec_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>“你上小学时最喜欢的老师姓什么？”还不得少于3个字符，看来只有东方、西门、欧阳这类复姓，才能使用这个问题了……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一名网友买了一个养生水壶，功能非常齐全，可以煮蛋、煲汤、煲粥、火锅，样样都行。根据说明书介绍，水壶设定的程序非常人性化，它会根据你的需求，先将温度加热到100°，再根据不同的功能，降至不同的温度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-02f3ec69ed0030900ff0278e73a607d7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-02f3ec69ed0030900ff0278e73a607d7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-02f3ec69ed0030900ff0278e73a607d7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-02f3ec69ed0030900ff0278e73a607d7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这名网友可高兴坏了，终于可以煮小米红豆粥了，放料、加水，之后开开心心的逛街去了。没想到回来之后一看，米粥溢得到处都是，壶里也干了，高温自动断电。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>后来，查了半天，发现这个水壶的程序，有一个严重的bug，这个养生水壶第一步是要把食物加热到100°，然后再降温，但由于家里的海拔有750多米，水98°就开了，根本无法达到100°，于是高大上的养生水壶，变成了一个能定时的电热壶……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>看来，当一名程序员，不仅要会码代码，还得知天文、晓地理，不然遇到这种bug，debug无门啊。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>使用滴滴出行打车，方便了不少，北京一小伙下班打车，发单被接之后，一看屏幕上的显示，直接就哭了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7d3e2948fcd7998eaee2757414cc46b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1138\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7d3e2948fcd7998eaee2757414cc46b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;1138&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"1138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7d3e2948fcd7998eaee2757414cc46b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7d3e2948fcd7998eaee2757414cc46b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个路线，简直就是标准的全国旅行的节奏，明明自己就在车的屁股后面，怎么就得全国巡回一圈呢？不管怎么样，得等！谁叫现在打车这么难呢？830分钟后……算了还是坐公交吧，撤单算了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我曾经穿过山和大海，也穿过人山人海。我曾经快到你的身边，没想到却被撤单。我曾经失望失落失掉所有梦想，绝望着眺望着也哭也笑愤懑着。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>求吴师傅此时的心理阴影面积……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然，不止吴师傅，优步也曾出现过王者司机。</p><p>在故宫正殿的优步车辆，可谓皇家特供出租车，还不抢着下单，更待何时！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>回头我们再看看游戏界，添加屏蔽字，一直是所有互联网企业的惯用做法，但几乎没有人会将单独的汉字，列入屏蔽字，可是早些时候，有一家游戏公司就这么干了。在一次答题活动中，就出现了这么尴尬的一幕：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-26c46a2cd4f7d8f900ecb9eba86742fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-26c46a2cd4f7d8f900ecb9eba86742fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;533&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic1.zhimg.com/v2-26c46a2cd4f7d8f900ecb9eba86742fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-26c46a2cd4f7d8f900ecb9eba86742fc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>“想我泱泱武林群侠，居然无一人答对”，这是赤裸裸的挑衅啊。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>更不用心的游戏开发，出现了如此的bug：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0a658b24a74953628ab6fdfa7f50a7a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0a658b24a74953628ab6fdfa7f50a7a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0a658b24a74953628ab6fdfa7f50a7a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0a658b24a74953628ab6fdfa7f50a7a5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>假扮朱然的徐庶，顶着一张程昱的脸……</p><p class=\"ztext-empty-paragraph\"><br/></p><p>第一次玩游戏，使用软件时，通常我们都要勾选《用户协议》，可接下来这个bug，真的是不能忍了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当用户勾选“同意用户协议”时，提交申请的按钮不可点击：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8d7b73979eb565252b79be6743338536_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"865\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-8d7b73979eb565252b79be6743338536_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;865&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"865\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-8d7b73979eb565252b79be6743338536_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8d7b73979eb565252b79be6743338536_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>而去掉勾选后，变成可以点击状态了：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6e306026bf4038f66a2fb432f86f328e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"865\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-6e306026bf4038f66a2fb432f86f328e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;865&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"865\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-6e306026bf4038f66a2fb432f86f328e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6e306026bf4038f66a2fb432f86f328e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>太良心了！竟然不强迫我同意《用户协议》，估计这名程序员打了个盹，把if else写反了，该扣工资了啊。</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62763789", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 3, 
            "title": "C语言笑话~程序员也幽默", 
            "content": "<p>今天在群里看到一个好东西，下下来看看，哇，程序员也幽默啊……</p><p>谁说学C语言枯燥？马上给你编出原创C语言笑话……</p><p><br/>【原创笑话之一】<br/><br/>《C is the Key!》<br/><br/>一个从不来上课的学生，去参加C语言期末考试。<br/><br/>拿到卷子，盯着第一道题目看了10分钟，完全看不懂。<br/><br/>于是伸长脖子，小声问邻桌同学：<br/><br/>“这到底是在考什么呀？！”<br/><br/>“啊？…… C呀！”<br/><br/>“谢了——兄弟！”<br/><br/>于是他在第一道选择题里填上“C”。<br/><br/>紧接着，又问：<br/><br/>“兄弟，那第二题呢……？”<br/><br/>【原创笑话之二】<br/><br/>《美女同学》<br/><br/>偶然看到班上一位美女同学的C语言课堂笔记：<br/><br/>int —— 整容变量<br/>……<br/><br/>【原创笑话之三】<br/><br/>《牛肉干》<br/><br/>C语言上机课，某女同学偷偷吃起牛肉干。<br/><br/>有一粒牛肉干掉到了键盘上，卡在7和8键之间。<br/><br/>女同学就在键盘上抠啊、抠啊、抠啊……<br/><br/>程序里一行代码变成这个样子：<br/><br/>int *pa=&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;a;<br/><br/>后来的结局是<br/>————程序顺利通过编译，运行结果正确！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>【原创笑话之四】<br/><br/>《谁动了我的女友？》<br/><br/>某男同学编写C程序代码。<br/><br/>有一行是这样的……<br/><br/>Girlfriend my_Girlfriend_1;<br/><br/>男同学在编辑代码时，不小心把这个名字里的“my”碰掉了，于是，代码变成了：<br/><br/>Girlfriend _Girlfriend_1;<br/><br/>按下“编译”按钮……<br/><br/>编译器大骂：<br/><br/>error: Dude! That&#39;s *MY* Girlfriend, not yours!<br/><br/>【原创笑话之五】<br/><br/>《微软的编译器》<br/><br/>有一次，男同学跟女同学炫耀：“我早就不用什么微软的‘首席IDE’了，我都是直接在命令行里用CL编译程序！”<br/><br/>后来，女同学就试着这样做，但是一时记不起来那个命令是啥了，只记得第二个字母是“L”。<br/><br/>她就琢磨……GNU的编译器是gcc，是字母g开头的……<br/><br/>那么，这个微软的编译器，应该就是字母M开头的了！<br/><br/>于是，她在命令行里输入：<br/><br/>C:\\&gt;ML .....<br/><br/>一旁的男同学，看到了，狂汗……<br/><br/>（注）ML是微软MASM的编译器。<br/><br/><br/>【原创笑话之六】<br/><br/>《一劳永逸的终极解决方案》<br/><br/>两位同学为了for循环圆括号里的第三个表达式怎么写“更好”，争得不可开交。<br/><br/>甲坚持i++。<br/><br/>乙坚持++i。<br/><br/>这时候，丙来了，听了他们的争论，很不屑地说：<br/><br/>“嗨——这样写不就行了！”<br/><br/>+i+<br/><br/>………<br/><br/>【原创笑话之七】<br/><br/>《错误的编程语言》<br/><br/>一节课C语言课上，老师讲授枚举类型：<br/><br/>    enum Language {<br/>             A_Ada = 1,<br/>             B_BASIC, //=2<br/>             C_Cpp, //=3<br/>             D_Delphi, //=4<br/>    };<br/><br/>老师问学生：“如果给一个Language枚举类型的变量赋值为5的话，会得到什么？”<br/><br/>学生：“E_易语言。”<br/><br/>老师：“哦——不！那是一个绝对错误的东西！”<br/><br/>【原创笑话之八】<br/><br/>【网友pathuang68贴出的笑话】<br/><br/>我分享很早前看到的一个笑话：<br/>某资深程序员，退休赋闲在家，重拾当年旧好 -- 书法。某日，夫人磨墨相伴于案前，该兄握笔蘸墨，迟疑半晌，茫然不知如何下笔，夫人在旁甚是诧异。正在夫人差异之间，仁兄灵光忽现，伏案疾书，挥毫而就，写完后甚有得意之色，夫人拿过来一看，其上赫然正是：<br/>hello, world!<br/><br/>注：夫人受过高等教育，这两个简单的英文单词还是认识滴。<br/><br/>【原创改编】<br/><br/>《ISO认证》<br/><br/>这位资深程序员写下的，是这麼一行：<br/><br/>void main()<br/><br/>谁知道，这打头的“void”过了一会儿，墨迹居然变红。<br/><br/>程序员拿起墨汁瓶子一看，上面印着：“本企业通过ISO/C99质量管理体系认证”！<br/><br/>……  <br/><br/>【原创笑话之九】<br/><br/>【网友cobra_chen贴出的笑话】<br/><br/>某程序员被一黑客攻击。<br/>大怒，拿起电话，狂按0，1键。<br/>后来，那个黑客再也不敢说自己是黑客了。<br/><br/>【原创改编】<br/><br/>谢谢加菜！不过这个跟C语言关系不大，我来改写一下吧：<br/><br/>《段错误》<br/><br/>某C程序员在拨打电话时，总是先按下星号键，再输入对方号码。<br/><br/>有一次，他按错号码了，电话那头传来女声：<br/><br/>The number you dialed is not accessible due to Segmentation Fault.<br/><br/>【原创笑话之十】<br/><br/>【网友cobra_chen贴出的笑话】<br/><br/>某程序员和另一程序员借钱，<br/>说“借我1000块钱吧。”<br/>另一答道，<br/>“那我再借给你24块凑个整数吧！”<br/><br/>【原创改编】<br/><br/>谢谢加菜！这个也改写一下吧：<br/><br/>《精度丢失》<br/><br/>一个C程序员向另一个C程序员借钱。<br/><br/>他说：“你用double借给我，我用float还给你，可以吗……？”<br/><br/>“……”<br/><br/>【原创笑话之十一】<br/><br/>【网友liubingqian贴出的笑话】<br/><br/>    $ make love<br/>    make: don&#39;t know how to make love. Stop<br/><br/>    $<br/><br/>【原创改编】<br/><br/>我来个加强版……！！<br/><br/>《Always》<br/><br/>    $ make love<br/>    make: love is made. Do you really want to do it one more time?(yes/no/Always)<br/>    …… ……<br/>    ……<br/>    A</p><p>如果您在Java语言学习的过程中遇到难题，欢迎关注微信公众号【潭州筑梦Java】，大家一起交流解决！</p><p><b>稿源：互联网</b></p><p>*  声明：转载文章和图片均来自公开网络，版权归作者本人所有。如果出处有误或侵犯到原作者权益，请与我们联系删除或授权事宜。</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62567063", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "Java 中整型的缓存机制", 
            "content": "<p>本文将介绍Java中Integer的缓存相关知识。这是在Java 5中引入的一个有助于节省内存、提高性能的功能。首先看一个使用Integer的示例代码，从中学习其缓存行为。接着我们将为什么这么实现以及他到底是如何实现的。你能猜出下面的Java程序的输出结果吗。如果你的结果和真正结果不一样，那么你就要好好看看本文了。</p><blockquote>package com.javapapers.java;<br/> <br/>public class JavaIntegerCache {<br/>    public static void main(String... strings) {<br/> <br/>        Integer integer1 = 3;<br/>        Integer integer2 = 3;<br/> <br/>        if (integer1 == integer2)<br/>            System.out.println(&#34;integer1 == integer2&#34;);<br/>        else<br/>            System.out.println(&#34;integer1 != integer2&#34;);<br/> <br/>        Integer integer3 = 300;<br/>        Integer integer4 = 300;<br/> <br/>        if (integer3 == integer4)<br/>            System.out.println(&#34;integer3 == integer4&#34;);<br/>        else<br/>            System.out.println(&#34;integer3 != integer4&#34;);<br/> <br/>    }<br/>}</blockquote><p>我们普遍认为上面的两个判断的结果都是false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个if判断都是false的。在Java中，==比较的是对象应用，而equals比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p><p>上面这段代码真正的输出结果：</p><blockquote>integer1 == integer2<br/>integer3 != integer4</blockquote><p><b>Java中Integer的缓存实现</b></p><p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p><p>适用于整数值区间-128 至 +127。</p><p>只适用于自动装箱。使用构造函数创建对象不适用。</p><p>Java的编译器把基本数据类型自动转换成封装类对象的过程叫做自动装箱，相当于使用valueOf方法：</p><blockquote>Integer a = 10; //this is autoboxing<br/>Integer b = Integer.valueOf(10); //under the hood</blockquote><p>现在我们知道了这种机制在源码中哪里使用了，那么接下来我们就看看JDK中的valueOf方法。下面是JDK 1.8.0 build 25的实现：</p><blockquote>/**<br/>     * Returns an {@code Integer} instance representing the specified<br/>     * {@code int} value.  If a new {@code Integer} instance is not<br/>     * required, this method should generally be used in preference to<br/>     * the constructor {@link #Integer(int)}, as this method is likely<br/>     * to yield significantly better space and time performance by<br/>     * caching frequently requested values.<br/>     *<br/>     * This method will always cache values in the range -128 to 127,<br/>     * inclusive, and may cache other values outside of this range.<br/>     *<br/>     * @param  i an {@code int} value.<br/>     * @return an {@code Integer} instance representing {@code i}.<br/>     * @since  1.5<br/>     */<br/>    public static Integer valueOf(int i) {<br/>        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br/>            return IntegerCache.cache[i + (-IntegerCache.low)];<br/>        return new Integer(i);<br/>    }</blockquote><p>在创建对象之前先从IntegerCache.cache中寻找。如果没找到才使用new新建对象。</p><p><b>IntegerCache Class</b></p><p>IntegerCache是Integer类中定义的一个private static的内部类。接下来看看他的定义。</p><blockquote>/**<br/>   * Cache to support the object identity semantics of autoboxing for values between<br/>   * -128 and 127 (inclusive) as required by JLS.<br/>   *<br/>   * The cache is initialized on first usage.  The size of the cache<br/>   * may be controlled by the {@code -XX:AutoBoxCacheMax=} option.<br/>   * During VM initialization, java.lang.Integer.IntegerCache.high property<br/>   * may be set and saved in the private system properties in the<br/>   * sun.misc.VM class.<br/>   */<br/> <br/>  private static class IntegerCache {<br/>      static final int low = -128;<br/>      static final int high;<br/>      static final Integer cache[];<br/> <br/>      static {<br/>          // high value may be configured by property<br/>          int h = 127;<br/>          String integerCacheHighPropValue =<br/>              sun.misc.VM.getSavedProperty(&#34;java.lang.Integer.IntegerCache.high&#34;);<br/>          if (integerCacheHighPropValue != null) {<br/>              try {<br/>                  int i = parseInt(integerCacheHighPropValue);<br/>                  i = Math.max(i, 127);<br/>                  // Maximum array size is Integer.MAX_VALUE<br/>                  h = Math.min(i, Integer.MAX_VALUE - (-low) -1);<br/>              } catch( NumberFormatException nfe) {<br/>                  // If the property cannot be parsed into an int, ignore it.<br/>              }<br/>          }<br/>          high = h;<br/> <br/>          cache = new Integer[(high - low) + 1];<br/>          int j = low;<br/>          for(int k = 0; k &lt; cache.length; k++)<br/>              cache[k] = new Integer(j++);<br/> <br/>          // range [-128, 127] must be interned (JLS7 5.1.7)<br/>          assert IntegerCache.high &gt;= 127;<br/>      }<br/> <br/>      private IntegerCache() {}<br/>  }</blockquote><p>其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。 缓存通过一个for循环实现。从低到高并创建尽可能多的整数并存储在一个整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p><p>实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？因为这个范围的数字是最被广泛使用的。 在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p><p><b>Java语言规范中的缓存行为</b></p><p>在Boxing Conversion部分的Java语言规范(JLS)规定如下：</p><p>如果一个变量p的值是：</p><ul><li>-128至127之间的整数(§3.10.1)</li><li>true 和 false的布尔值 (§3.10.3)</li><li>‘\\u0000’至 ‘\\u007f’之间的字符(§3.10.4)</li></ul><p>中时，将p包装成a和b两个对象时，可以直接使用a==b判断a和b的值是否相等。</p><p><b>其他缓存的对象</b></p><p>这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型的类都有类似的缓存机制。</p><ul><li>有ByteCache用于缓存Byte对象</li><li>有ShortCache用于缓存Short对象</li><li>有LongCache用于缓存Long对象</li><li>有CharacterCache用于缓存Character对象</li></ul><p>Byte, Short, Long有固定范围: -128 到 127。对于Character, 范围是 0 到 127。除了Integer以外，这个范围都不能改变。</p><p>如果您在Java语言学习的过程中遇到难题，欢迎关注微信公众号【潭州筑梦Java】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62567213", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 1, 
            "title": "Java 编程军规", 
            "content": "<p><b>1、引言：</b></p><p>这个标准是衡量代码本身的缺陷，也是衡量一个研发人员本身的价值。华为作为一家全球化的 IT 公司，十几万员工，无论是人事管理，还是代码管理，都是一件不容易的事情，没有规范的约束，想想都是件可怕的事情。下面挑选了一些网上流传的编程规范，一起来学习下，以下内容不涉及基础的语法规范（请见 Refer），更侧重于一些编程习惯，如何提高程序的健壮性、可维护性等。（PS：以下内容未经官方考证，如阅读者出现不适，请选择立即关闭本页 -_-||| ）</p><p><b>2、军规简介：</b></p><p>军规一：【避免在程序中使用魔鬼数字，必须用有意义的常量来标识。】</p><p>军规二：【明确方法的功能，一个方法仅完成一个功能。】</p><p>军规三：【方法参数不能超过5个】</p><p>军规四：【方法调用尽量不要返回null，取而代之以抛出异常，或是返回特例对象（SPECIAL CASE object，SPECIAL CASE PATTERN）；对于以集合或数组类型作为返回值的方法，取而代之以空集合或0长度数组。】</p><p>军规五：【在进行数据库操作或IO操作时，必须确保资源在使用完毕后得到释放，并且必须确保释放操作在finally中进行。】</p><p>军规六：【异常捕获不要直接catch (Exception ex) ，应该把异常细分处理。】</p><p>军规七：【对于if „ else if „(后续可能有多个else if …)这种类型的条件判断，最后必须包含一个else分支，避免出现分支遗漏造成错误；每个switch-case语句都必须保证有default，避免出现分支遗漏，造成错误。】</p><p>军规八：【覆写对象的equals()方法时必须同时覆写hashCode()方法。】</p><p>军规九：【禁止循环中创建新线程，尽量使用线程池。】</p><p>军规十：【在进行精确计算时(例如:货币计算)避免使用float和double，浮点数计算都是不精确的，必须使用BigDecimal或将浮点数运算转换为整型运算。】 </p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、军规说明</b></p><p>军规一：【避免在程序中使用魔鬼数字，必须用有意义的常量来标识。】</p><p>说明：是否是魔鬼数字要基于容易阅读和便于全局替换的原则。0、1作为某种专业领域物理量枚举数值时必须定义常量，严禁出现类似NUMBER_ZERO的“魔鬼常量”。 </p><p>军规二：【明确方法的功能，一个方法仅完成一个功能。】</p><p>说明：方法功能太多，会增加方法的复杂度和依赖关系，不利于程序阅读和将来的持续维护，无论是方法还是类设计都应符合单一职责原则。 </p><p>军规三：【方法参数不能超过5个】</p><p>说明：参数太多影响代码阅读和使用，为减少参数，首先要考虑这些参数的合理性，保持方法功能单一、优化方法设计，如果参数确实无法减少，可以将多个参数封装成一个类（对象），同时考虑在新的类（对象）中增加相应的行为，以期更符合OOP。 </p><p>军规四：【方法调用尽量不要返回null，取而代之以抛出异常，或是返回特例对象（SPECIAL CASE object，SPECIAL CASE PATTERN）；对于以集合或数组类型作为返回值的方法，取而代之以空集合或0长度数组。】</p><p>说明：返回null会增加不必要的空指针判断，遗漏判断也会导致严重的NullPointerException错误。</p><p>军规五：【在进行数据库操作或IO操作时，必须确保资源在使用完毕后得到释放，并且必须确保释放操作在finally中进行。】</p><p>说明：数据库操作、IO操作等需要关闭对象必须在try -catch-finally 的finally中close()，如果有多个IO对象需要关闭，需要分别对每个对象的close()方法进行try-catch,防止一个IO对象关闭失败其他IO对象都未关闭。推荐做法如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">Connection jdbcConnection = null;\n\n       Statement stmt = null;\n       try\n       {\n\n            ........\n\n       }\n       catch(SQLException e)\n\n       {\n            ........\n       }\n       finally\n       {\n           if(stmt != null)\n\n           {\n                try\n\n                {\n                    stmt.close();\n                }\n                catch(SQLException e)\n\n                {\n                    logger.log(Level.WARNING,&#34;异常说明&#34;, e);\n                }\n           }\n           if(jdbcConnection != null)\n\n           {\n                try\n\n                {\n                    jdbcConnection.close();\n                }\n                catch(SQLException e)\n\n                {\n                    logger.log(Level.WARNING,&#34;异常说明&#34;, e);\n               }\n           }\n       }</code></pre></div><p>军规六：【异常捕获不要直接 catch(Exception ex) ，应该把异常细分处理。】</p><p>说明：catch (Exception ex)的结果会把RuntimeException异常捕获，RuntimeException是运行期异常，是程序本身考虑不周而抛出的异常，是程序的BUG，如无效参数、数组越界、被零除等，程序必须确保不能抛出RuntimeException异常，不允许显示捕获RuntimeException异常就是为了方便测试中容易发现程序问题。 </p><p>军规七：【对于if „ else if „(后续可能有多个elseif …)这种类型的条件判断，最后必须包含一个else分支，避免出现分支遗漏造成错误；每个switch-case语句都必须保证有default，避免出现分支遗漏，造成错误。】</p><p>军规八：【覆写对象的equals()方法时必须同时覆写hashCode()方法。】</p><p>说明：equals和hashCode方法是对象在hash容器内高效工作的基础，正确的覆写这两个方法才能保证在hash容器内查找对象的正确性，同时一个好的hashCode方法能大幅提升hash容器效率。 </p><p>军规九：【禁止循环中创建新线程，尽量使用线程池。】</p><p>军规十：【在进行精确计算时(例如:货币计算)避免使用float和double，浮点数计算都是不精确的，必须使用BigDecimal或将浮点数运算转换为整型运算。】</p><p>说明：浮点运算在一个范围很广的值域上提供了很好的近似，但是它不能产生精确的结果。二进制浮点对于精度计算是非常不适合的，因为它不可能将0.1——或者10的其它任何次负幂精确表示为一个长度有限的二进制小数。</p><p>具体案例请参考：浮点数加法引发的问题：浮点数的二进制表示</p><p><a href=\"https://link.zhihu.com/?target=http%3A//my.oschina.net/leejun2005/blog/156793\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">my.oschina.net/leejun20</span><span class=\"invisible\">05/blog/156793</span><span class=\"ellipsis\"></span></a></p><p><b>4、有关开发效率和协作的几点建议与心得体会</b></p><p>今天看到某同学写给团队成员的一封邮件，发现比较通用，分享出来吧:</p><p>1. 小提交: </p><p>把大的任务拆分成多个独立小任务，每完成小任务确保无 Bug 后就可以提交合并到主分支甚至发布；频繁提交有利于自己把控项目进度、降低风险、同其他人协作和代码 Review ; 每天可以提交合并多次。每个小任务是 1-2 个小时可以完成的粒度，最大的一天完成。并行做多个任务的时候，优先做最短时间能够实现的任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2. 命名规范: </p><p>尽量避免无意义的字符做变量 比如 a, b, t 。可以逐步改善，可以参考:</p><p><a href=\"https://link.zhihu.com/?target=http%3A//google-styleguide.googlecode.com/svn/trunk/javaguide.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">google-styleguide.googlecode.com</span><span class=\"invisible\">/svn/trunk/javaguide.html</span><span class=\"ellipsis\"></span></a></p><p>3. 避免过度设计: </p><p>能够用简单方式实现的功能，不引入复杂的类，对象，避免不必要的 new 对象，避免引入不必要的泛型、线程。开发初期冗余大于抽象和依赖。避免自己重新实现比较通用的组件和函数。调研多种实现方式的时候，选用做简单的实现方式。尽量少写代码。</p><p>4. Web 工程尽量避免在应用内部保存“状态”，这样可以适应频繁发布、重启无影响。</p><p>5. 善于用打日志的方式调试，在程序关键点打日志。尽量少用断点方式，日志方式可以批量调试一批功能，效率相对高。</p><p>6. 避免一屏显示不下的超大函数。</p><p>7. 添加必要、简洁的注释：</p><p>循环中的 continue, break 尽量加上单行注释；尽量避免非函数结尾的 return，必要的时候加注释。类自动生成 toString() 方法，方便调试和打日志。</p><p>8. 不把自己局限到做某个功能，每个人都是整个项目的 Owner ，尽量交叉 Review ，交叉开发。</p><p>9. 遇到问题及时和其他人沟通，避免浪费时间。</p><p>10. 从最终产品的目标审视自己细小的设计，熟悉自己负责部分的上下游代码。时刻关注最终产品(Web 界面和日志)，发现 Bug 和可以改善的地方。</p><p>作者：Java我人生，</p><p>链接：<a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/chenleixing/article/details/44173985\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">blog.csdn.net/chenleixing/article/details/44173985</a></p><p>如果您在Java语言学习的过程中遇到难题，欢迎关注微信公众号【潭州筑梦Java】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62445817", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 1, 
            "title": "Java、JavaScript、C、C++、PHP、Python都是用来开发什么？", 
            "content": "<p>用任何编程语言来开发程序，都是为了让计算机干活，比如编写一篇文章，下载一首MP3等，而计算机干活的CPU只认识机器的指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。理论上任何语言干任何事情几乎都可以, 但是主要干什么那就不一样了。</p><p>对于刚步入IT行业的小白，或许只知道某一语言相对应的薪资是多少，但却不知道主要是做什么的，更不会考虑到以后的职业发展方向问题。以下将对编程语言进行详细的讲解。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\"/></figure><p><b>C和C++</b></p><p>C/C++理论上说可以做任何开发, 只要有合适的硬件驱动和API，特点是效率高，基本上是编译语言里面效率最高的。除非你的系统中连C/C++编译器都不具备. 某些系统当中C++编译器是不具备的, 但是C一般都具备. 目前而言, C语言主要用来开发底层模块(比如驱动,解码器,算法实现), 服务应用(比如web服务器)和嵌入式应用(比如微波炉里的程序). C++也可以做这些, 不过由于C++的复杂性和标准问题, 人们还是更愿意使用C来做. C++更适合比较复杂但又特别需要高效率的设施，比如大型游戏，一些基础库， 大型桌面应用。</p><blockquote>总结：<br/>C: 系统底层, 驱动, 嵌入式开发.<br/>C++: 游戏开发, 大规模, 高性能, 分布式要求的程序开发。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\"/></figure><p><b>JAVA</b></p><p>java常常跟”企业”联系在一起, 因为具备一些很好的语言特性, 以及丰富的框架, 在企业应用中最被青睐, 你总可以听到关于J2EE, JSP, Hibernate之类的东西的讨论. 同时, java在手机领域也有一席之地, 在普遍智能化之前, 很多手机就是以支持java应用作为卖点的, 而智能手机爆发之后, java手机主场变成了android, 作为安卓的标准编程语言而存在。</p><blockquote>总结：<br/>Java: 网页, 企业级开发, 普通应用软件, 游戏后台。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\"/></figure><p><b>JavaScript</b></p><p>Javascript听起来跟java有关系, 其实并没有任何关系, 只是名字像而已.就好比雷峰塔和雷锋的关系一样，虽然只差一个字。 js最广泛的应用毫无疑问是在web前端. 简单的说, 网站给你传过来的是一堆用各种标签表示格式的文档, 而js负责操纵这些文档实现一些客户端动态效果. js的领地还不仅如此, 现在的Node.js还可以用于服务器端的开发。</p><blockquote>总结：<br/>JavaScript是浏览器的脚本语言，一般和Html，CSS这些一起学，主要做网站的前端开发，展现各种酷炫的画面。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\"/></figure><p><b>PHP</b></p><p>php这三个字你常常会在浏览器地址栏里看到, 所以不意外php是用来开发网站的. 也是web后端的王者语言.无数的网站后端都运行着php代码。</p><blockquote>总结：<br/>PHP：主要是网络前端，用于生成网页。也可以整个web服务器都用php，比如很多论坛引擎。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image\" width=\"28\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;28&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"28\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"28\" data-actualsrc=\"https://pic1.zhimg.com/v2-f0227b9508274dae8b29fdbfb228f324_b.jpg\"/></figure><p><b>Python</b></p><p>Python由于具有丰富和强大的库，它又叫做作胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。Python是做服务器开发与物联网开发。信息安全，大数据处理，数据可视化机器学习，物联网开发，各大软件的api，桌面应用，都需要python。</p><blockquote>总结：<br/>Python：动态解释型，开发效率高，开源，灵活，入门门槛低。</blockquote><p>文章来源于：代码湾</p><p>如果您在C语言学习的过程中遇到难题，欢迎关注微信公众号【筑梦C语言】，大家一起交流解决！</p><p></p>", 
            "topic": [
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }, 
                {
                    "tag": "软件开发", 
                    "tagLink": "https://api.zhihu.com/topics/19552332"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62300752", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 1, 
            "title": "C语言32个关键字9种控制语句34种运算符整理", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-062c65fbf89399c516083d87699a95c7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"55\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-062c65fbf89399c516083d87699a95c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;55&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"55\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic4.zhimg.com/v2-062c65fbf89399c516083d87699a95c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-062c65fbf89399c516083d87699a95c7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>32个关键字，如下表所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>关键字                   说明</p><p> auto             声明自动变量</p><p>short            声明短整型变量或函数</p><p>int                声明整型变量或函数</p><p>long            声明长整型变量或函数</p><p>float           声明浮点型变量或函数</p><p>double      声明双精度变量或函数</p><p>char          声明字符型变量或函数</p><p>struct        声明结构体变量或函数</p><p>union       声明共用数据类型</p><p>enum       声明枚举类型</p><p>typedef     用以给数据类型取别名</p><p>const        声明只读变量</p><p>unsigned     声明无符号类型变量或函数</p><p>signed        声明有符号类型变量或函数</p><p>extern      声明变量是在其他文件正声明</p><p>register     声明寄存器变量</p><p>static        声明静态变量</p><p>volatile      说明变量在程序执行中可被隐含地改变</p><p>void      声明函数无返回值或无参数，声明无类型指针</p><p>if           条件语句</p><p>else        条件语句否定分支（与 if 连用）</p><p>switch      用于开关语句</p><p>case    开关语句分支</p><p>for      一种循环语句</p><p>do       循环语句的循环体</p><p>while        循环语句的循环条件</p><p>goto          无条件跳转语句</p><p>continue      结束当前循环，开始下一轮循环</p><p>break      跳出当前循环</p><p>default    开关语句中的“其他”分支</p><p>sizeof      计算数据类型长度</p><p>return     子程序返回语句（可以带参数，也可不带参数）循环条件</p><p>第一个关键字：</p><p>auto 用来声明自动变量。 可以显式的声明变量为自动变量。只要不是声明在所有函数之前的变量，即使没加auto关键字，也默认为自动变量。并且只在声明它的函数内有效。而且当使用完毕后，它的值会自动还原为最初所赋的值。自动变量使用时要先赋值，因为其中包含的是未知的值。例：auto int name=1;</p><p>第二个关键字：</p><p>static 用来声明静态变量。可以显式的声明变量为静态变量。也为局部变量。只在声明它的函数内有效。它的生命周期从程序开始起一直到程序结束。而且即使使用完毕后，它的值仍旧不还原。即使没有给静态变量赋值，它也会自动初始化为0.例：static int name=1.</p><p>第三个关键字：</p><p>extern 用来声明全局变量。同时声明在main函数之前的变量也叫全局变量。它可以在程序的任何地方使用。程序运行期间它是一直存在的。全局变量也会初始化为0.例：extern int name；</p><p>第四个关键字：</p><p>register 用来声明为寄存器变量。也为局部变量，只在声明它的函数内有效。它是保存在寄存器之中的。速度要快很多。对于需要频繁使用的变量使用它来声明会提高程序运行速度。例：register int name=1;</p><p>第五个关键字：</p><p>int 用来声明变量的类型。int为整型。注意在16位和32位系统中它的范围是不同的。16位中占用2个字节。32位中占用4个字节。还可以显式的声明为无符号或有符号：unsigned int signed int .有符号和无符号的区别就是把符号位也当作数字位来存储。也可用short和long来声明为短整型，或长整行。例：int num;</p><p>第六个关键字：</p><p>float 用来声明变量的类型。float为浮点型，也叫实型。它的范围固定为4个字节。其中6位为小数位。其他为整数位。例：float name;</p><p>第七个关键字：</p><p>double 用来声明为双精度类型。它的范围为8个字节。14位为小数位。也可使用更高精度的long double 它的范围则更大，达到10字节。例：double name;</p><p>第八个关键字：</p><p>struct用来声明结构体类型。结构体可以包含各种不同类型的量。比如可以把整型，字符型等类型的变量声明在同一个结构体种，使用的时候使用结构体变量直接可以调用。例：struct some{ int a=1; float b=1.1； double=1.1234567；}kkk;这样就可以使用kkk.a来使用结构体中的成员变量了 。也可以显式的用struct some aaa,bbb;来声明多个结构体变量。</p><p>第九个关键字：</p><p>char 用来定义为字符型变量。它的范围通常为1个字节。它在内存中是以ASC||玛来表示的。所以它也可以跟整型来运算。也可使用无符号或有符号来定义。sigened char unsigned char例：char c;</p><p>第十个关键字：</p><p>break 用来表示中断。一般用在循环中。判断是否满足条件然后中断当前循环。例：break;</p><p>第十一个关键字：</p><p>continue 用来表示跳过当前其后面的语句，继续下一次循环。例：continue;</p><p>第十二个关键字：</p><p>long 用来声明长型的类型。比如long int long double .</p><p>第十三个关键字：</p><p>if 判断语句，用来判断语句是否满足条件，例：if a==b k=n;</p><p>第十四个关键字：</p><p>switch 条件选择语句，常用来判断用户选择的条件来执行特定语句。例：switch (name){ case ok: printf(&#34;yes,ok!&#34;);printf(&#34;yes,ok!&#34;); printf(&#34;yes,ok!&#34;);break; case no: printf(&#34;oh,no!&#34;); default: printf(&#34;error..!&#34;) break; }</p><p>第十五个关键字：</p><p>case 配合switch一起使用，例子同上。</p><p>第十六个关键字：</p><p>enum 用来声明枚举变量。.. 例：enum day{one,two,three,four,five,six,seven };</p><p>第十七的关键子：</p><p>typedef 类型重定义..可以重定义类型，例：typedef unsigned int u_int; //将无符号整形定义为u_int . 第</p><p>十八个关键字：</p><p>return; 返回语句。可以返回一个值。当我们定义一个函数为有返回值的时候则必须返回一个值。 第</p><p>十九个关键字：</p><p>unio 定义联共用体。用法用struct相同。不同的是共用体所有成员共享存储空间. unio kkk{int a; float b; }kka;</p><p>第二十个关键字：</p><p>const 定义为常量.. 例： const int a; //变量a的值不能被改变.</p><p>第二十一个关键字：</p><p>unsigned 定义为无符号的变量.. 默认变量都为有符号的.除非显示的声明为unsigned的.</p><p>第二十二个关键字：</p><p>for 循环语句.可以指定程序循环多少次. 例： for (int i=0;i&lt;5;i++) { printf(&#34;程序将输出5次这段话！&#34;); }</p><p>第二十三个关键字：</p><p>signed 将变量声明为有符号型. 默认变量就为signed 型。一般可省略。</p><p>第二十四个关键字：</p><p>void 空类型.. 一般用于声明函数为无返回值或无参数。</p><p>第二十五个关键字：</p><p>default 用于在switch语句中。定义默认的处理. 用法见switch。</p><p>第二十六个关键字：</p><p>goto 无条件循环语句. 例： int i=1; w_go:i++; if (i&lt;5) goto w_go; else printf(&#34;%d&#34;,i); 第</p><p>二十七个关键子字：</p><p>sizeof 用来获取变量的存储空间大小. 例： int a,b; b=sizeof(a);</p><p>第二十八个关键字：</p><p>volatile 将变量声明为可变的. 用法 volatile int a; 具体用法还是不太明白。标记..！！</p><p>第二十九个关键字：</p><p>do 一般与while语句 配合使用. 构成的形式如 do while 或while do .例见while语句。</p><p>第三十个关键字：</p><p>while 循环控制语句。 只要表达式为真就一直循环. 例： do int a=1; while (a&gt;1) printf(&#34;a&gt;1&#34;);</p><p>第三十一个关键字：</p><p>else 常用来配合if一起使用。例：if a==b</p><p>第三十二个关键字：</p><p>short 用于声明一个短整型变量: 例： short int a;</p><p>C语言中的9中控制语句</p><p>1、if( )~else~ (条件语句)</p><p>2、for（）~ （循环语句）</p><p>3、while（）~ （循环语句）</p><p>4、do~while（） （循环语句）</p><p>5、continue （结束本次循环语句）</p><p>6、break （终止执行switch或循环语句）</p><p>7、switch （多分支选择语句）</p><p>8、goto （转向语句）</p><p>9、return （从函数返回语句）</p><p>括号表示其中是一个条件，~表示内嵌的语句。例如：‘if （）~else~’的具体语句可以写成： if（x&gt;y）z=x;else z=y;</p><p>34种运算符按优先级排序，空行表示优先级下降，01为最高，最先算 14~31均为双目，左结合</p><p>()  01．圆括号</p><p>[]  02．下标</p><p>-&gt;  03．指针型结构成员</p><p>.  04．结构成员</p><p>!  05．逻辑非</p><p>~  06．位非</p><p>++  07．自增</p><p>--  08．自减</p><p>-  09．取负</p><p>(类型)  10．类型转换</p><p>*  11．取内容</p><p>&amp;  12．取地址</p><p>sizeof  13．求字节</p><p>…………………………………………………</p><p>此级（5~13）均为单目运算，且都为右结合</p><p>*  14．乘</p><p>/  15．除</p><p>%  16．求余</p><p>+  17．加</p><p>-  18．减</p><p>&lt;&lt;  19．左移</p><p>&gt;&gt;  20．右移</p><p>&lt;  21．小于</p><p>&lt;=  22．小于等于</p><p>&gt;  23．大于</p><p>&gt;=  24．大于等于</p><p>==  25．等于</p><p>!= 26．不等于</p><p>&amp;  27．位与</p><p>^  28．位异或</p><p>|  29．位或</p><p>&amp;&amp;  30．与</p><p>||  31．或</p><p>?:  32．条件运算</p><p>……………………………………</p><p>此级（32）为三目运算，右结合</p><p>=  33．赋值运算</p><p>………………………………………………………………</p><p>另有10个扩展符+=,-=,*=,/=,%=,&gt;&gt;=,&lt;&lt;=,&amp;=,^=,|=</p><p>,  34．逗号运算</p><p>如果您在C语言学习的过程中遇到难题，欢迎关注微信公众号【筑梦C语言】，大家一起交流解决！</p><p>版权申明：内容来源网络，版权归原创者所有。</p><p>除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。谢谢。</p><p></p>", 
            "topic": [
                {
                    "tag": "C语言函数", 
                    "tagLink": "https://api.zhihu.com/topics/19846590"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62301780", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 1, 
            "title": "JavaScript-html Dom中的HTMLCollection和NodeList", 
            "content": "<p>HTMLCollection对象</p><p>HTMLCollection是元素集合，它和NodeList很像，有length属性来表示HTMLCollection对象的长度，也可以通过elements.item()传入元素索引来访问。当时它还有一个nameItem()方法，可以返回集合中name属性和id属性值得元素。</p><p>可以通过三种方法获取HTMLCollection对象</p><p>1：getElementsByTagName() </p><p>2：document.forms.item()</p><p>3:   document.forms.namedItem()</p><p>HTMLCollection 对象类似 HTML 元素的一个数组,<b>获取的是html元素集合。</b></p><p>NodeList对象</p><p>NodeList 对象是一个从文档中获取的节点列表 (集合) 。一些旧版本浏览器中的方法（如：getElementsByClassName()）返回的是 NodeList 对象，而不是 HTMLCollection 对象。</p><p>所有浏览器的 childNodes 属性返回的是 NodeList 对象。大部分浏览器的 querySelectorAll() 返回 NodeList 对象。NodeList对象有个length属性和item()方法，length表示所获得的NodeList对象的节点个数，这里还是要强调的是节点，而item()可以传入一个索引来访问Nodelist中相应索引的元素。</p><p>NodeList是一个节点的集合<b>(既可以包含元素和其他节点)</b>。</p><p>看如下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\"> &lt;div class=&#39;target&#39;&gt;\n          &lt;!-- 666 --&gt;\n          &lt;span &gt;item1&lt;/span&gt;\n          &lt;span &gt;item2&lt;/span&gt;\n          &lt;span &gt;item3&lt;/span&gt;\n      &lt;/div&gt;\n   &lt;script type=&#34;text/javascript&#34;&gt;\n      var target=document.getElementsByTagName(&#39;div&#39;);\n      console.log(target);    \n   &lt;/script&gt;\n</code></pre></div><p> 打印结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bf9aabe964aec524b806ea132760b2bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"117\" class=\"content_image\" width=\"301\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;301&#39; height=&#39;117&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"301\" data-rawheight=\"117\" class=\"content_image lazy\" width=\"301\" data-actualsrc=\"https://pic2.zhimg.com/v2-bf9aabe964aec524b806ea132760b2bd_b.jpg\"/></figure><p>得到是HTMLCollection对象，我们看一下div,target的ChildNodes，因为它是NodeList对象,</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9c955e906c23327d682fe414dc64971a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"99\" class=\"content_image\" width=\"370\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;370&#39; height=&#39;99&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"370\" data-rawheight=\"99\" class=\"content_image lazy\" width=\"370\" data-actualsrc=\"https://pic3.zhimg.com/v2-9c955e906c23327d682fe414dc64971a_b.jpg\"/></figure><p>我们注意到有9个节点，分别是div与注释节点的空白文本节点，注释节点，注释节点和&lt;span&gt;之间的空白文本节点，然后依次类推，直到最后一个span与div的空白文本节点。</p><p>HTMLColection 与 NodeList 的区别</p><p>HTMLCollection 是 HTML 元素的集合。</p><p>NodeList 是一个文档节点的集合。</p><p>NodeList 与 HTMLCollection 有很多类似的地方。</p><p>NodeList 与 HTMLCollection 都与数组对象有点类似，可以使用索引 (0, 1, 2, 3, 4, ...) 来获取元素。</p><p>NodeList 与 HTMLCollection 都有 length 属性。</p><p>HTMLCollection 元素可以通过 name，id 或索引来获取。</p><p>NodeList 只能通过索引来获取。</p><p>只有 NodeList 对象有包含属性节点和文本节点。</p><p>它们看起来像一个数组但是不是数组，可以叫类数组，无法使用数组的方法： valueOf(), pop(), push(), 或 join()。</p><p>HTMLCollection和NodeList 实时性</p><p>它们能随着文档的改变而改变，当我们用js插入删除节点是它们也随之改变。</p><p><b>querySelectorAll这个接口返回的nodeList对象比较特殊，它是个静态的对象。</b></p><p>看如下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;div class=&#39;target&#39;&gt;\n          &lt;!-- 666 --&gt;\n          &lt;span &gt;item1&lt;/span&gt;\n          &lt;span &gt;item2&lt;/span&gt;\n          &lt;span &gt;item3&lt;/span&gt;\n      &lt;/div&gt;\n   &lt;script type=&#34;text/javascript&#34;&gt;\n      var target1=document.getElementsByTagName(&#39;span&#39;);\n      var target2=document.querySelectorAll(&#39;span&#39;);\n      console.log(target1.length); \n      console.log(target2.length); \n     document.getElementsByTagName(&#39;div&#39;)[0].appendChild(document.createElement(&#39;span&#39;));\n      console.log(target1.length); \n      console.log(target2.length); \n   &lt;/script&gt;\n</code></pre></div><p>这一点需要注意，<b>querySelectorAll没有实时性。</b></p><p>如果您在前端学习的过程中遇到难题，欢迎关注微信公众号【筑梦前端】，大家一起交流解决！</p><p>-------------------- </p><p>作者：wust_cyl </p><p>来源：CSDN </p><p>原文：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wust_cyl/article/details/81267045\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/wust_cyl/</span><span class=\"invisible\">article/details/81267045</span><span class=\"ellipsis\"></span></a> </p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "HTML", 
                    "tagLink": "https://api.zhihu.com/topics/19551323"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62390015", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 0, 
            "title": "从四个属性的角度来理解C语言的指针", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fdc878af4f7037246c190aef88e7797d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-fdc878af4f7037246c190aef88e7797d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-fdc878af4f7037246c190aef88e7797d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fdc878af4f7037246c190aef88e7797d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>关于指针是什么，很多教材已经作出了定义，大多数都会定义为“存放变量内存地址的变量”。<br/></p><p>从这句话中除了让我知道这个定义有11个字以外，其他就没什么用了。</p><p>所以要理解指针，不是光光说一下是变量的地址就万事大吉了，而是要从多个属性来解释指针，为此，这里有一个所谓的多维属性法来理解指针。</p><p>另外，为了能把指针说清楚，关键不在于用苦涩的文字描述，而在于以示意图的形式描述清楚指针的概念。接下来就准备用我的多维属性法，加上画几张图，和一些伪代码，尽量说清楚指针是什么。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e8244a62f0e0dd71b42684a97bb1c4ca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic3.zhimg.com/v2-e8244a62f0e0dd71b42684a97bb1c4ca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic3.zhimg.com/v2-e8244a62f0e0dd71b42684a97bb1c4ca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e8244a62f0e0dd71b42684a97bb1c4ca_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0715e7d87929871ca85980bdc950891a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"83\" data-rawheight=\"95\" class=\"content_image\" width=\"83\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;83&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"83\" data-rawheight=\"95\" class=\"content_image lazy\" width=\"83\" data-actualsrc=\"https://pic3.zhimg.com/v2-0715e7d87929871ca85980bdc950891a_b.jpg\"/></figure></b><p><b>1.要说清楚指针是什么之前，先来看看如何从多维属性来理解普通变量，以及普通变量在内存中是什么样儿的。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如现在有个整型变量：int a = 1;也就是说整型变量a的值是1，在内存中的存放如示意图1所示：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2115c64522ad69a41ef3c37443ff034a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"350\" class=\"content_image\" width=\"221\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;221&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"350\" class=\"content_image lazy\" width=\"221\" data-actualsrc=\"https://pic3.zhimg.com/v2-2115c64522ad69a41ef3c37443ff034a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>相信朋友们对这张图无任何异议，很简单嘛，a就是1,1就是a嘛。好了，我可以提炼出变量a的三个属性出来，分别是有用数据的名字，有用数据的值，有用数据的类型。</p><p>有用数据的名字，就是“a”；</p><p>有用数据的值，就是“1”；</p><p>有用数据的类型，就是“int”；</p><p>之所以用“有用数据”这四个字来描述，是因为程序代码中会经常用到变量“a”，以及它的值“1”，还有它的类型“int”，那不就是有用的嘛，所以我就“有用数据”来描述变量a的三个属性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-624eaf2e3af0c320d682484c495d03a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-624eaf2e3af0c320d682484c495d03a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-624eaf2e3af0c320d682484c495d03a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-624eaf2e3af0c320d682484c495d03a4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>好了，我用下面的表示法来表示变量a的这三个属性：</p><p>变量a=(有用数据的名字，有用数据的值，有用数据的类型)</p><p>好了，假设变量a的地址是“0x380fe0”，则示意图2是从变量a的地址的角度来看变量a在内存中的存放形式：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ec8bbe398c9bd6fe96ea3ce8cf894eb9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"290\" data-rawheight=\"458\" class=\"content_image\" width=\"290\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;290&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"290\" data-rawheight=\"458\" class=\"content_image lazy\" width=\"290\" data-actualsrc=\"https://pic2.zhimg.com/v2-ec8bbe398c9bd6fe96ea3ce8cf894eb9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在图2中，我标记出变量a的地址是16进制的0x380fe0，a为1，也就是在内存地址为“0x380fe0”的地方放了一个值1。用C语言表示地址的术语来说就是“&amp;a”等于“380fe0”。</p><p>“&amp;”是表示变量地址的意思。这张图相信朋友们也没有什么异议，对吧，都是很直观的东西。好，我又可以提炼出变量a的第4个属性，叫做“有用数据的地址”，也就是“&amp;a”啦。</p><p>至此，变量a的四个属性都齐全啦，如下：</p><p>变量a=(有用数据的地址，有用数据的名字，有用数据的值，有用数据的类型)，具体到本例，就是：</p><p>变量a=(0x380fe0，a，1，int)</p><p>从四个属性来说明一般的整型变量在内存中的样儿，好了，下面我要放大招儿了，再说说从四个属性来理解指针变量，以及指针变量在内存中的样儿。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07fe277d7f9e39ddd2ad6af750a2f39e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-07fe277d7f9e39ddd2ad6af750a2f39e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;534&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-07fe277d7f9e39ddd2ad6af750a2f39e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-07fe277d7f9e39ddd2ad6af750a2f39e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我定义一个指针变量：</p><p>int *p = NULL;</p><p>p = 0x380fe0;</p><p>这两句代码朋友们也一定看的懂的，就是一个指针变量p的值用16进制来表示就是“0x380fe0”，这正好是变量a的地址。p在内存中的表示如下示意图3：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8570b38c5b70f005e02ddd1cdc3230d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"245\" data-rawheight=\"412\" class=\"content_image\" width=\"245\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;245&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"245\" data-rawheight=\"412\" class=\"content_image lazy\" width=\"245\" data-actualsrc=\"https://pic3.zhimg.com/v2-8570b38c5b70f005e02ddd1cdc3230d2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>示意图3</p><p>示意图3跟整型变量a的示意图1没任何区别，我也可以说p就是0x380fe0，0x380fe0就是p，跟变量a就是1，1就是a是一个道理。</p><p>好，这里我提炼出指针p的第一个属性，叫做“指针自己的值”，指针变量p的值是0x380fe0，可不就是自己的值嘛！用如下表示发来表示就是：<br/></p><p>指针p=(指针自己的值)</p><p>到此为止，朋友们应该都是无异议的，好，下面再来看“*p”是什么东西，如下示意图4所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-326afa9954eb15b6b86414a620970086_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"403\" class=\"content_image\" width=\"283\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;283&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"403\" class=\"content_image lazy\" width=\"283\" data-actualsrc=\"https://pic3.zhimg.com/v2-326afa9954eb15b6b86414a620970086_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>示意图4</p><p>指针变量p前面加个“*”就变成了“*p”。很多教材会说“指针变量p指向的值是1”，这说了等于没说，谁看的懂。加了星号后，*p就是a的等价物了，是a的别名了，也就是*p就是a，a就是*p。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e836342168bd14cd7f3b8cd343b30438_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-e836342168bd14cd7f3b8cd343b30438_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-e836342168bd14cd7f3b8cd343b30438_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e836342168bd14cd7f3b8cd343b30438_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这样说大家应该都会看懂吧。好了，这里我可以提炼出指针变量p的剩余三个属性了，分别叫做”与星号结合名“，”有用数据的值“，”有用数据的类型“。<br/></p><p>与星号结合名：就是”*“与指针p结合，变成*p；</p><p>有用数据的值：就是1；跟变量a的第三个属性一样；</p><p>有用数据的类型，就是int；跟变量a的第四个属性一样。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样指针变量p的四个属性也齐全了，如下：</p><p>指针变量p=(指针自己的值，与星号结合名，有用数据的值，有用数据的类型)。在本例就是：</p><p>指针变量p=(0x380fe0，*p，1，int)。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0715e7d87929871ca85980bdc950891a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"83\" data-rawheight=\"95\" class=\"content_image\" width=\"83\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;83&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"83\" data-rawheight=\"95\" class=\"content_image lazy\" width=\"83\" data-actualsrc=\"https://pic3.zhimg.com/v2-0715e7d87929871ca85980bdc950891a_b.jpg\"/></figure><p><b>3. 用变量a的四个属性与指针变量p的四个属性对比，一下子就能看出指针的本质了。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我整理下上述的伪代码：<br/></p><p>int a = 1;//假设变量a的地址是0x380fe0</p><p>int *p = NULL;</p><p>p = &amp;a;</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再用我说的多维属性法分别来表示整型变量a和指针变量p，分别如下：</p><p>整型变量a=(有用数据的地址，有用数据的名字，有用数据的值，有用数据的类型)</p><p>指针变量p=(指针自己的值，与星号结合名，有用数据的值，有用数据的类型)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在本例中，它们各自的属性就是：</p><p>整型变量a=(&amp;a的值，a，1，int)</p><p>指针变量p=(p的值，*p，1，int)</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b5cbb1ea5f1e12ed13cf687e81ab4c65_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-b5cbb1ea5f1e12ed13cf687e81ab4c65_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-b5cbb1ea5f1e12ed13cf687e81ab4c65_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b5cbb1ea5f1e12ed13cf687e81ab4c65_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>再细一点，就是：</p><p>整型变量a=(0x380fe0，a，1，int)</p><p>指针变量p=(0x380fe0，*p，1，int)</p><p>看出来了吗？看出来了吗》看出来了吗？它们的四个属性的含义是一一等价的，具体来说就是：</p><p>”&amp;a“ 就是 ”p“.</p><p>”a“就是 ”*p“</p><p>”1“ 就是 ”1“</p><p>”int“ 就是 ”int“</p><p>这才是理解指针p的本质关键所在。</p><p>关于”&amp;a“ 就是 ”p“我再说两句。同样是表示地址，”&amp;a“是用了”&amp;“和”a“两个字符的组合来表示的，而”p“就用了一个字符”p&#34;来表示，这种字符数量上的不一致导致了很多人学指针时会犯晕！</p><p>关于”a“就是 ”*p“我也说两句。同样是表示整型变量的名字，这次”a“就用了一个字符”a“来表示，而”*p“用了字符“*”和”p&#34;两个字符来表示，又是这种字符数量上的不一致又导致了很多人学指针时会犯晕！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-95eebd6efdd963f40ca8dc0448c3a5a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-95eebd6efdd963f40ca8dc0448c3a5a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic2.zhimg.com/v2-95eebd6efdd963f40ca8dc0448c3a5a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-95eebd6efdd963f40ca8dc0448c3a5a1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>说了这么多废话，其实就是为了说明指针变量的四个属性表示法，建议记住这四个属性表示法，以及与一般整型变量、字符变量等一般变量类型的四个属性之间的等价关系。</p><p>当然了，别指望记住这四个属性你就理解指针了，该学习的还是要学习，该多写代码的还是要多写代码，我只是希望你记住四个属性后再学习指针时，不至于被指针碾压的那么惨。</p><p>对于第二个属性，在本文中，就是一个“*”和“p”的结合“*p”，别看它是由两个字符组成的，其实本质上就是变量“a”，因此从这一个属性开始，你完全可以用一般的整型变量“a”来思考问题了，也就是直接将“*p”看做“a”，后面的第3个属性就是这个“a”的值“1”，第4个属性就是“a”的类型“int”。</p><p>记住，从第2个属性开始，就与指针p没有任何关联了，你全部使用整型变量a的思维去思考问题。</p><p>如果您在C语言学习的过程中遇到难题，欢迎关注微信公众号【筑梦C语言】，大家一起交流解决！</p>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }, 
                {
                    "tag": "指针（C / C++）", 
                    "tagLink": "https://api.zhihu.com/topics/19959489"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62411074", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 0, 
            "title": "hadoop环境搭建初探，grep demo演示", 
            "content": "<p>@<a href=\"https://zhuanlan.zhihu.com/p/62411074/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E6%96%87%E7%AB%A0%E5%86%85%E5%AE%B9%E5%88%B0%EF%BC%9A\" class=\"internal\">Toc</a></p><h2>环境准备</h2><div class=\"highlight\"><pre><code class=\"language-text\">centos 7\nhadoop 2.7.7</code></pre></div><h2>环境安装</h2><div class=\"highlight\"><pre><code class=\"language-text\">安装ssh\n[root@swarm02 ~]# yum search ssh\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n * base: centos.ustc.edu.cn\n * extras: ap.stykers.moe\n * updates: centos.ustc.edu.cn\n============================================================================================================================== N/S matched: ssh ==============================================================================================================================\nfence-agents-ilo-ssh.x86_64 : Fence agent for HP iLO devices via SSH\nksshaskpass.x86_64 : A KDE version of ssh-askpass with KWallet support\nlibssh.x86_64 : A library implementing the SSH protocol\nlibssh-devel.x86_64 : Development files for libssh\nlibssh2.i686 : A library implementing the SSH2 protocol\nlibssh2.x86_64 : A library implementing the SSH2 protocol\nlibssh2-devel.i686 : Development files for libssh2\nlibssh2-devel.x86_64 : Development files for libssh2\nlibssh2-docs.noarch : Documentation for libssh2\nopenssh.x86_64 : An open source implementation of SSH protocol versions 1 and 2\nopenssh-askpass.x86_64 : A passphrase dialog for OpenSSH and X\nopenssh-clients.x86_64 : An open source SSH client applications\nopenssh-keycat.x86_64 : A mls keycat backend for openssh\nopenssh-ldap.x86_64 : A LDAP support for open source SSH server daemon\nopenssh-server.x86_64 : An open source SSH server daemon\nopenssh-server-sysvinit.x86_64 : The SysV initscript to manage the OpenSSH server.\npam_ssh_agent_auth.i686 : PAM module for authentication with ssh-agent\npam_ssh_agent_auth.x86_64 : PAM module for authentication with ssh-agent\nsshpass.x86_64 : Non-interactive SSH authentication utility\nansible.noarch : SSH-based configuration management, deployment, and task execution system\njsch.noarch : Pure Java implementation of SSH2\nopenssh-cavs.x86_64 : CAVS tests for FIPS validation\npython-paramiko.noarch : SSH2 protocol library for python\npython-paramiko-doc.noarch : Docs and demo for SSH2 protocol library for python\n\n  Name and summary matches only, use &#34;search all&#34; for everything.\n[root@swarm02 ~]# yum install fence-agents-ilo-ssh.x86_64\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n * base: centos.ustc.edu.cn\n * extras: ftp.sjtu.edu.cn\n * updates: mirrors.cn99.com\nbase                                                                                                                                                                                                                                                   | 3.6 kB  00:00:00     \ndocker-ce-stable                                                                                                                                                                                                                                       | 3.5 kB  00:00:00     \nextras                                                                                                                                                                                                                                                 | 3.4 kB  00:00:00     \nupdates                                                                                                                                                                                                                                                | 3.4 kB  00:00:00     \n(1/2): docker-ce-stable/x86_64/primary_db                                                                                                                                                                                                              |  27 kB  00:00:00     \n(2/2): updates/7/x86_64/primary_db                                                                                                                                                                                                                     | 3.4 MB  00:00:03     \nResolving Dependencies\n--&gt; Running transaction check\n---&gt; Package fence-agents-ilo-ssh.x86_64 0:4.2.1-11.el7_6.7 will be installed\n--&gt; Processing Dependency: fence-agents-common &gt;= 4.2.1-11.el7_6.7 for package: fence-agents-ilo-ssh-4.2.1-11.el7_6.7.x86_64\n--&gt; Processing Dependency: telnet for package: fence-agents-ilo-ssh-4.2.1-11.el7_6.7.x86_64\n--&gt; Running transaction check\n---&gt; Package fence-agents-common.x86_64 0:4.2.1-11.el7_6.7 will be installed\n--&gt; Processing Dependency: pexpect for package: fence-agents-common-4.2.1-11.el7_6.7.x86_64\n---&gt; Package telnet.x86_64 1:0.17-64.el7 will be installed\n--&gt; Running transaction check\n---&gt; Package pexpect.noarch 0:2.3-11.el7 will be installed\n--&gt; Finished Dependency Resolution\n\nDependencies Resolved\n\n==============================================================================================================================================================================================================================================================================\n Package                                                                  Arch                                                       Version                                                                Repository                                                   Size\n==============================================================================================================================================================================================================================================================================\nInstalling:\n fence-agents-ilo-ssh                                                     x86_64                                                     4.2.1-11.el7_6.7                                                       updates                                                      29 k\nInstalling for dependencies:\n fence-agents-common                                                      x86_64                                                     4.2.1-11.el7_6.7                                                       updates                                                      75 k\n pexpect                                                                  noarch                                                     2.3-11.el7                                                             base                                                        142 k\n telnet                                                                   x86_64                                                     1:0.17-64.el7                                                          base                                                         64 k\n\nTransaction Summary\n==============================================================================================================================================================================================================================================================================\nInstall  1 Package (+3 Dependent packages)\n\nTotal download size: 310 k\nInstalled size: 1.1 M\nIs this ok [y/d/N]: y\nDownloading packages:\n(1/4): fence-agents-ilo-ssh-4.2.1-11.el7_6.7.x86_64.rpm                                                                                                                                                                                                |  29 kB  00:00:00     \n(2/4): telnet-0.17-64.el7.x86_64.rpm                                                                                                                                                                                                                   |  64 kB  00:00:00     \n(3/4): fence-agents-common-4.2.1-11.el7_6.7.x86_64.rpm                                                                                                                                                                                                 |  75 kB  00:00:00     \n(4/4): pexpect-2.3-11.el7.noarch.rpm                                                                                                                                                                                                                   | 142 kB  00:00:01     \n------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nTotal                                                                                                                                                                                                                                         261 kB/s | 310 kB  00:00:01     \nRunning transaction check\nRunning transaction test\nTransaction test succeeded\nRunning transaction\n  Installing : pexpect-2.3-11.el7.noarch                                                                                                                                                                                                                                  1/4 \n  Installing : fence-agents-common-4.2.1-11.el7_6.7.x86_64                                                                                                                                                                                                                2/4 \n  Installing : 1:telnet-0.17-64.el7.x86_64                                                                                                                                                                                                                                3/4 \n  Installing : fence-agents-ilo-ssh-4.2.1-11.el7_6.7.x86_64                                                                                                                                                                                                               4/4 \n  Verifying  : 1:telnet-0.17-64.el7.x86_64                                                                                                                                                                                                                                1/4 \n  Verifying  : fence-agents-common-4.2.1-11.el7_6.7.x86_64                                                                                                                                                                                                                2/4 \n  Verifying  : pexpect-2.3-11.el7.noarch                                                                                                                                                                                                                                  3/4 \n  Verifying  : fence-agents-ilo-ssh-4.2.1-11.el7_6.7.x86_64                                                                                                                                                                                                               4/4 \n\nInstalled:\n  fence-agents-ilo-ssh.x86_64 0:4.2.1-11.el7_6.7                                                                                                                                                                                                                              \n\nDependency Installed:\n  fence-agents-common.x86_64 0:4.2.1-11.el7_6.7                                                        pexpect.noarch 0:2.3-11.el7                                                        telnet.x86_64 1:0.17-64.el7                                                       \n\nComplete!\n[root@swarm02 ~]# \n\n安装rsync\nyun install libguestfs-rsync.x86_64</code></pre></div><h2>下载hadoop</h2><div class=\"highlight\"><pre><code class=\"language-text\">前提之前需要配置java的环境变量\nexport JAVA_HOME=/usr/local/jdk1.8.0\nexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport PATH=$PATH:$JAVA_HOME/bin\n\n[root@swarm02 ~]# wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-2.7.7/hadoop-2.7.7.tar.gz\n解压后拷贝文件到指定的目录文件下面，我这里面的文件夹的位置并不做特殊的要求，只要后面的配置满足这个就行了\n[root@swarm02 ~]# tar -zxvf hadoop-2.7.7.tar.gz -C /usr/local</code></pre></div><h2>配置环境变量</h2><div class=\"highlight\"><pre><code class=\"language-text\">配置hadoop的环境变量\nexport HADOOP_HOME=/usr/local/hadoop\nexport PATH=.:$HADOOP_HOME/bin:$JAVA_HOME/bin:$PATH</code></pre></div><h2>环境变量生效</h2><div class=\"highlight\"><pre><code class=\"language-text\">source /etc/profile</code></pre></div><h2>检测安装效果</h2><div class=\"highlight\"><pre><code class=\"language-text\">需要java环境的支持，java环境的配置这里就不在详细讲解安装过程了\n[root@swarm01 ~]# java -version\njava version &#34;1.8.0_201&#34;\nJava(TM) SE Runtime Environment (build 1.8.0_201-b09)\nJava HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)\n[root@swarm01 ~]# hadoop version\nHadoop 2.7.7\nSubversion Unknown -r c1aad84bd27cd79c3d1a7dd58202a8c3ee1ed3ac\nCompiled by stevel on 2018-07-18T22:47Z\nCompiled with protoc 2.5.0\nFrom source with checksum 792e15d20b12c74bd6f19a1fb886490\nThis command was run using /usr/local/hadoop/share/hadoop/common/hadoop-common-2.7.7.jar\n[root@swarm01 ~]#</code></pre></div><h2>grep的demo演示</h2><div class=\"highlight\"><pre><code class=\"language-text\">创建一个文件夹 grep_demo用于存放grep程序的input和output\n\n[root@swarm01 swarm01]# mkdir grep_demo\n[root@swarm01 swarm01]# ll\ntotal 213600\ndrwxr-xr-x. 2 root root         6 Apr 14 21:27 grep_demo\n-rw-r--r--. 1 root root 218720521 Jul 20  2018 hadoop-2.7.7.tar.gz\ndrwxr-xr-x. 3 root root        60 Apr 14 11:37 java-8\n-rw-r--r--. 1 root root      1506 Apr 12 11:00 vi.text\ndrwxr-xr-x. 4 root root        33 Apr 14 13:16 word_regex\n[root@swarm01 swarm01]# \n\n这里可以选择吧hadoop的文件名直接拷贝到这个input文件夹中，也可以自己创建，这里我选择自己创建了，这样更有含义\n\n下面是准备工作，执行命令在gerp_demo文件夹中\n[root@swarm01 swarm01]# cd grep_demo/\n[root@swarm01 grep_demo]# ll\ntotal 0\n[root@swarm01 grep_demo]# mkdir input\n[root@swarm01 grep_demo]# ll\ntotal 0\ndrwxr-xr-x. 2 root root 6 Apr 14 21:29 input\n[root@swarm01 grep_demo]# cd input/\n[root@swarm01 input]# touch sakura_demo.xml\n[root@swarm01 input]# touch licunzhi_demo.xml\n[root@swarm01 input]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Apr 14 21:30 licunzhi_demo.xml\n-rw-r--r--. 1 root root 0 Apr 14 21:30 sakura_rain.xml\n[root@swarm01 input]# \n[root@swarm01 input]# cat licunzhi_demo.xml \nlicunzhi_demo_001\nsakura_demo_licunzhi\n[root@swarm01 input]# cat sakura_demo.xml \nsakura_demo_001\ndemo_001_sakura\n[root@swarm01 input]# \n\n执行命令，将会生成output文件夹，因此这里面不需要创建output，否则一定会报失败的\n\n[root@swarm01 grep_demo]# hadoop jar /usr/local/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.7.jar grep input output &#39;sakura_[a-z.]+&#39;\n19/04/14 09:35:45 INFO Configuration.deprecation: session.id is deprecated. Instead, use dfs.metrics.session-id\n19/04/14 09:35:45 INFO jvm.JvmMetrics: Initializing JVM Metrics with processName=JobTracker, sessionId=\n19/04/14 09:35:47 INFO input.FileInputFormat: Total input paths to process : 4\n19/04/14 09:35:47 INFO mapreduce.JobSubmitter: number of splits:4\n19/04/14 09:35:48 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_local1775879846_0001\n19/04/14 09:35:48 INFO mapreduce.Job: The url to track the job: http://localhost:8080/\n19/04/14 09:35:48 INFO mapreduce.Job: Running job: job_local1775879846_0001\n19/04/14 09:35:48 INFO mapred.LocalJobRunner: OutputCommitter set in config null\n19/04/14 09:35:48 INFO output.FileOutputCommitter: File Output Committer Algorithm version is 1\n。。。。。。。。。。。。。。具体的日志信息这里面就不全部展示了\n\n最终的效果\n[root@swarm01 grep_demo]# ll\ntotal 0\ndrwxr-xr-x. 2 root root 102 Apr 14 21:30 input\ndrwxr-xr-x. 2 root root  88 Apr 14 21:35 output\n[root@swarm01 grep_demo]# cd output/\n[root@swarm01 output]# ll\ntotal 0\n-rw-r--r--. 1 root root 0 Apr 14 21:35 part-r-00000\n-rw-r--r--. 1 root root 0 Apr 14 21:35 _SUCCESS\n[root@swarm01 output]# \n[root@swarm01 grep_demo]# cat output/part-r-00000 \n2   sakura_demo\n[root@swarm01 grep_demo]# \n——SUCCESS是执行成功的标志</code></pre></div><h2>你需要注意的是</h2><ul><li>这里只是简单的介绍</li><li>所谓的安装就是配置基础的环境</li><li>更多的相关分布式以及其他核心组件的内容介绍和实战后续将会继续更新</li></ul>", 
            "topic": [
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62446376", 
            "userName": "编程小知识", 
            "userLink": "https://www.zhihu.com/people/b3397b8e0b8b039eb923b7e667a063f5", 
            "upvote": 4, 
            "title": "Java 能抵挡住 JavaScript 的进攻吗？", 
            "content": "<p>作者 | 刘欣</p><p>本文经授权转自公众号“码农翻身”</p><p><b>JavaScript 的进攻</b></p><p>公元 2014 年，Java 第八代国王终于登上了王位。</p><p>第一次早朝，国王坐在高高的宝座上，看着毕恭毕敬的大臣，第一次体会到了皇权的威力。</p><p>德高望重的 IO 大臣颤悠悠地走上前来：“启禀陛下，昨日收到战报，有个叫做 Node.js 的番邦又一次向我国进攻，我边防将士死伤惨重。”</p><p>“Node.js？ 那是什么东西？”  国王心中一乐， 还真有人自不量力，想蚍蜉撼树。 想我 Java 帝国人口之众多，疆域之广阔，踩死你小番邦还不像踩死一只蚂蚁似的。</p><p>“那是用 JavaScript 写的一个框架。”  IO 大臣看到国王不知道 Node.js，心里一沉。</p><p>“JavaScript？爱卿说笑了，一个在浏览器中运行的东西，怎么可能进攻我 Java 后端。”</p><p>“陛下有所不知，这 JavaScript 发展迅猛，不仅占领了前端，还通过 Node.js 向后端，尤其是我国渗透，臣还听说他们用 Electron 开始蚕食桌面开发了！”</p><p>“竟有这等事！难道他们想通吃？我们不是有 Tomcat 吗？派 Tomcat 去把 Node.js 给镇压了。”</p><p>国王开始怨恨自己的父亲 JDK 7 世和祖父 JDK 6 世没把这个 Node.js 当成一回事，没有把 Node.js 给扼杀在摇篮之中，把这个祸害留给了自己，心里开始发虚。</p><p><b>非阻塞异步 IO</b></p><p>线程大臣走上前来：“陛下，Tomcat 已经率军和 Node.js 恶战了几日，败下阵来， 这 Node.js 有个独门武器，叫做‘非阻塞异步 IO’。”</p><p>“非阻塞？ 我听说我们的 Tomcat 也能实现非阻塞啊！”  国王有点惊讶。</p><p>“不行的，陛下，Tomcat 在处理连接的时候能实现非阻塞，但是在真正处理请求的时候还是需要同步操作，一个请求对应一个线程来处理，不像 Node.js 那样，都是异步操作，只有一个主线程在忙活。”  线程大臣做了一个简明扼要的汇报，不知道国王能否听懂。</p><blockquote>注： Node.js的故事请参见《<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAxOTc0NzExNg%3D%3D%26mid%3D2665513044%26idx%3D1%26sn%3D9b8526e9d641b970ee5ddac02dae3c57%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Node.js： 我只需要一个店小二</a>》</blockquote><p>“众位爱卿，你们说说该怎么办？ 总不能让这小小番邦屡次欺负我堂堂 Java 帝国吧。”</p><p>“臣倒是有一计，” 集合大臣说道，“这 Node.js 虽然来势汹汹，但是它也有个致命的缺点，那 JavaScript 是个动态语言，无法进行编译时类型检查，错误只有等到运行时才能暴露出来。用它开发个小项目还可以，一旦项目变大，代码变多，人员变多，那就会变成噩梦了。”</p><p>“爱卿说说具体怎么办？”</p><p>“我们可以派一些卧底去 Node.js， 到处传播这样的消息，瓦解他们的军心和士气，让他们认为 Node.js 写的系统，很快就会腐化，最终还是要用我堂堂正正的 Java 语言来重写。”</p><p>“嗯，此乃心理战也，至少会稳住一些墙头草，准奏，由爱卿来安排。 ” 国王说道，“不过，此法治标不治本，还是得想办法直接把他们打败。”</p><p>“陛下真乃一代圣君，” 线程大臣马上开始拍马屁，与此同时，巧妙地把矛头转向老不死的 IO 大臣：“我 Java 帝国在第 4 代国王的时候就出现了非阻塞 IO，这么多年过去了，居然还没发展出类似 Node.js 的系统，实在是不应该啊。”</p><p>“老不死”的 IO 大臣是何等精明：“陛下明鉴， 我 Java 帝国应用服务器一直以来都是 Tomcat 独大，他们采用了线程池，每个请求一个线程的方式，我也不好干预。”</p><p>IO 大臣把责任推得一干二净。</p><p>“没错，” 集合大臣为 IO 大臣打抱不平，两肋插刀，“还有一点就是这异步编程，听起来很好，但是写起来可就要命了，那么多的回调，简直就是反人类，臣民们戏称为回调地狱，没人愿意那么写，发展不起来也很正常。”</p><p>线程大臣马上接口：“此言差矣，陛下已经教会了臣民们如何使用 Lambda 表达式，并且现在也出现了 RxJava，已经没什么回调地狱了！”</p><p>“那是现在，以前可没有！”</p><p>“......”</p><p>国王看到这几位大臣要打起来，马上施展和稀泥之术：“众位爱卿各有道理，你们且说说，怎么才能打败着来势汹汹的 Node.js 吧。”</p><p>没人说话。</p><p>国王只好退朝。</p><p><b>京城酒馆</b></p><p>京城的小酒馆向来是一个多方消息的集散地。</p><p>一个金发碧眼的小伙子正在“危言耸听”：“听说了没有，Node.js 又赢了几仗，Tomcat 大军死伤惨重，有不少臣民都投奔到那个番邦去了。”</p><p>“这异步操作真的有这么厉害？” 有人问道。</p><p>小伙子喝了一口酒： “其实不是异步操作更好，而是在高并发的环境异步操作更有效，大家都知道, 一个机器能支持的线程数目是有限的，不可能一直增加。Tomcat 那种一个请求一个线程的方式很快就会遇到瓶颈。”</p><p>“你说说，到底有什么好处？”有人刨根问底。</p><p>“现在服务器端的操作无非就是操作文件，读写数据库，访问远程服务，这些都是所谓阻塞操作。” 小伙子展开了一张图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d956530ed084033a925d719812a2b850_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"602\" class=\"content_image\" width=\"264\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;602&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"602\" class=\"content_image lazy\" width=\"264\" data-actualsrc=\"https://pic1.zhimg.com/v2-d956530ed084033a925d719812a2b850_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>“橙色的都是 IO 操作，绿色的才是真正的线程执行， IO 操作非常耗时，线程大部分时间都浪费在了等待上面！如果能让线程不要等待，去做别的事情，那用少量的线程，甚至一个线程就可以了。”</p><p>众人纷纷点头， 这小伙子已经看出了问题的关键，现在的很多系统，都是 IO 密集的， 高并发情况下，如果一个请求一个线程，浪费巨大。</p><p>“想我 Java 虚拟机如此强悍，如果能实现异步操作，那还不把 Node.js 秒成渣？！”小伙子狠狠地用手锤了一下桌子。</p><p>正在此时，酒馆冲进一队士兵，赶走众人，围住小伙子，领头的喝问到：“大胆刁民，竟然到处宣扬异步思想，给我带走!”</p><p>士兵恶狠狠地把他五花大绑，推出门去， 留下一堆人在那里议论纷纷。</p><p><b>IO 王府</b></p><p>“我让你们把他请来，怎么绑来了？快松绑！” IO 大臣呵斥完下属，转头亲切地问道：“叫什么名字啊？”</p><p>“小人蒂姆， Tomcat 府上的幕僚。 ” 蒂姆一边说一边揉肩膀。</p><p>“Tomcat 府上的人......”  IO 大臣捻着胡须若有所思。</p><p>“是的，大人，我还见过您呢，您上次半夜去 Tomcat 府上密谈......”</p><p>“住口！ ” IO 大臣赶紧转换话题， “我的下属发现你到处宣扬异步思想，究竟要干什么？ ”</p><p>“小人发明了一个系统，叫做 Node.x。 ”</p><p>“为什么不献于 Tomcat 将军？”</p><p>“唉，小人进言多次，可是将军不听啊！”</p><p>“你说说看，这是个什么东西？  是要模仿 Node.js 吗？”  IO 大臣问道。</p><p>之前蒂姆给 Tomcat 将军讲述过 Node.js， 他理都不理，经常是一甩袖子就走， 自己是空有一身本领却无人赏识， 难道这 IO 大臣能帮自己一把？ 想到此处，蒂姆精神大振。</p><p>“确实受到了它的启发, 但是我的 Node.x 在架构和一些关键的抽象上和 Node.js 有很大不同。” 蒂姆不好意思地笑了笑，“先说说相同的部分，既然都是异步操作，那肯定是通过事件驱动的，所以都有一个事件循环。”</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-71fa863d147581b39454dbe50edad6f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"618\" class=\"content_image\" width=\"332\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;332&#39; height=&#39;618&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"618\" class=\"content_image lazy\" width=\"332\" data-actualsrc=\"https://pic1.zhimg.com/v2-71fa863d147581b39454dbe50edad6f8_b.jpg\"/></figure><p>IO 大臣之前和 Swing 大臣聊过， 知道事件循环是怎么回事，这是一个相当古老的概念了。</p><p>无非就是有个线程在检测一个队列，如果队列中有事件，就拿出来处理。</p><p>“只不过我这里有所不同，可以创建多个事件循环出来，比如每一个 CPU 核心有一个，这样可以充分利用 CPU 的多核性能。”  蒂姆得意地说道。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0ac7a37b2b6318a5ae73d2ebf90f3f93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"144\" class=\"content_image\" width=\"311\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;311&#39; height=&#39;144&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"144\" class=\"content_image lazy\" width=\"311\" data-actualsrc=\"https://pic4.zhimg.com/v2-0ac7a37b2b6318a5ae73d2ebf90f3f93_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c04f41b6a2f0b7a15a58d92531c20bab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image\" width=\"1\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1&#39; height=&#39;1&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image lazy\" width=\"1\" data-actualsrc=\"https://pic4.zhimg.com/v2-c04f41b6a2f0b7a15a58d92531c20bab_b.jpg\"/></figure><p>（4 个 CPU Core， 4 个事件循环）</p><p>IO 大臣点头表示赞许， 他听说 Node.js 好像只有一个主线程，没法直接利用多核的能力。想利用多核的话还得开多个进程才行。</p><p><b>异步操作</b></p><p>“你图中的那个 Hanlder 就是具体的业务代码所在地吧？ 具体长什么样子啊，让我看看！”  IO 大臣问道。</p><p>蒂姆赶紧呈上代码，这是简单的 Hello World。</p><div class=\"highlight\"><pre><code class=\"language-text\">import io.vertx.core.AbstractVerticle;\npublic class Server extends AbstractVerticle {\n  public void start() {\n    vertx.createHttpServer().requestHandler(req -&gt; {\n      req.response()\n        .putHeader(&#34;content-type&#34;, &#34;text/plain&#34;)\n        .end(&#34;Hello Word!&#34;);\n    }).listen(8080);\n  }\n}</code></pre></div><p>这段代码生成了一个简单的 HTTP 服务器， 在 8080 端口监听， 每当有请求来的时候，都返回一个字符串“Hello World!”。</p><p>IO 大臣一看，大为吃惊：“你这代码不需要外部容器，自己就搞了一个 HTTP 服务器啊？”</p><p>“是的，这样我们就完全不用 Tomcat 了。我把这种类起了一个名称，叫做 Verticle， 部署以后，这个 Verticle 就可以和一个事件循环关联了。每次有 HTTP 请求过来，Node.x 会封装成事件，然后分派给它处理了。”</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b407d314b80adf50eaeaae158e980e62_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"269\" class=\"content_image\" width=\"311\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;311&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"311\" data-rawheight=\"269\" class=\"content_image lazy\" width=\"311\" data-actualsrc=\"https://pic3.zhimg.com/v2-b407d314b80adf50eaeaae158e980e62_b.jpg\"/></figure><p>真是个二愣子， IO 大臣心想， 怪不得 Tomcat 对你不待见，你这个东西出来，他的位置不保啊！</p><p>IO 大臣问道：“那对于数据库查询，你这个 Handler，哦不，Verticle 该怎么写？ 查询数据库这么慢，岂不是把事件循环都阻塞了？什么事情都做不了了？”</p><p>“大人您忘了，我们这里操作必须都是异步的，查询数据库也不例外。”</p><p>蒂姆说着展示了一段代码， 通过异步的方式来查询数据库。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class DatabaseVerticle extends AbstractVerticle{\n    ......\n    dbClient.getConnection(ar -&gt; {\n        if (ar.succeeded()) {\n            SQLConnection connection = ar.result();\n            connection.query(&#34;select .. from...&#34;, res -&gt; {      \n                 if (res.succeeded()) {\n                   ......\n                 } else {\n                   ......\n                 }\n          });\n        } else {\n           ......\n        }\n    });\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b8407beb2704f89af83f70476ec1d339_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"268\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"268\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic2.zhimg.com/v2-b8407beb2704f89af83f70476ec1d339_b.jpg\"/></figure><p>IO 大臣感慨道：“唉，老了，真是不中用了，连异步都忘了。对了，这些个 Verticle 看起来都是独立的，是被不同的线程调用的，他们之间怎么进行交互啊？难道也通过共享内存的方式？”</p><p>“大人真是厉害，一下子就问到了核心问题，不能让他们共享内存，那样就需要加锁了，我这里引入了 Event Bus 的方法，让他们之间通过消息传递。”</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9687657ae6afd3e0a8737adbf4911d83_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"412\" data-rawheight=\"485\" class=\"content_image\" width=\"412\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;412&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"412\" data-rawheight=\"485\" class=\"content_image lazy\" width=\"412\" data-actualsrc=\"https://pic4.zhimg.com/v2-9687657ae6afd3e0a8737adbf4911d83_b.jpg\"/></figure><p>“嗯，不错，实现了低耦合。”</p><p>“不仅如此，这些 Verticle 还可以部署到不同的 JVM 中，通过 Event Bus 实现真正的分布式通信。” 蒂姆又抛出一个重磅炸弹。</p><p>“如此甚好！”  IO 大臣爱才之心骤起， “你愿不愿意到老夫府上做幕僚啊？”</p><p>“小人愿意追随大人！”</p><p>“好！明日早朝，你随我入宫，面见圣上，老夫保你一世荣华富贵。 ”</p><p><b>为什么是 Vert.x？</b></p><p>第二日早朝，IO 大臣迫不及待地给国王报喜：“陛下，我 Java 帝国也可以采用非阻塞异步编程了！击败 Node.js 之日可待。”</p><p>IO 大臣讲述了昨晚的情况， 细数了 Node.x 的种种好处。</p><p>Tomcat 将军脸上极为难看， 赶紧阻止：“陛下不可，我 Java 帝国采用同步处理已经很久了，臣民们已经习惯了，现在改成异步，怕激起民变。”</p><p>“爱卿不要低估臣民采用新技术的能力嘛， 宣蒂姆进殿，呈上代码。”</p><p>蒂姆都不敢看 Tomcat， 从怀里掏出一张纸，双手奉上。</p><div class=\"highlight\"><pre><code class=\"language-text\">vertx.createHttpServer()\n  .requestHandler(function (req) {\n    req.response()\n      .putHeader(&#34;content-type&#34;, &#34;text/plain&#34;)\n      .end(&#34;Hello World&#34;);\n}).listen(8080);</code></pre></div><p>国王盯着看了半天：“嗯？不对啊，你这不是 Java 代码吧？”</p><p>Tomcat 拿过国王递过来的代码，扫了一眼：““大胆！ 你竟然敢在朝堂之上公然宣传 JavaScript，来人，拿下！”   <br/></p><p>“陛下息怒，这是小人制定的一个策略，我的 Node.x 支持很多语言编程， 除了 Java 之外，还有 JavaScript、Ruby、Scala、Kotlin 等等。”</p><p>“哦？ 是吗？ 这还能把番邦的人给吸引过来呢！你说呢，Tomcat 将军？” 国王说道。</p><p>Tomcat 有些不自在，想找回场子：“嗯嗯，有一定道理，不过这个 Node.x 这个名字不好，拾人牙慧，让人看低我堂堂 Java 帝国。” </p><p>“Node 是节点的意思，朕把他改成 Vertex 如何？也是节点的意思。”</p><p>“ 陛下圣明，可否叫做 Vert.x ？ ” IO 大臣提议。</p><p>“好，准奏，即日起，命你和蒂姆训练臣民使用 Vert.x，一个月后向 Node.js 开战！”  国王已经忍 Node.js 很久了。</p><p>不，不能让 IO 大臣的 Vert.x 一家独大！  </p><p>国王突然想到了亲爹留下来的祖训， 帝王之术是一定要平衡朝局。</p><p>“吩咐下去，今晚朕要和 Spring 将军，嗯，还有线程大臣，共进晚餐，朕有些事情要和他们好好谈谈......”</p><blockquote>*本故事纯属虚构，如有雷同，纯属巧合。<br/><br/>如果您在Java语言学习的过程中遇到难题，欢迎关注微信公众号【筑梦Java】，大家一起交流解决！</blockquote>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61731968", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 0, 
            "title": "swarm操作详解", 
            "content": "<p>@<a href=\"https://zhuanlan.zhihu.com/p/61731968/%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95\" class=\"internal\">Toc</a> 承接上篇的集群搭建操作的结束之后，此篇讲解集群的相关操作命令</p><h2>swarm集群常用操作</h2><ul><li>写在前面:如果集群损坏切在不影响集群业务的下需要重置的</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">使用docker swarm init --force-new-cluste</code></pre></div><h2>节点信息查看</h2><div class=\"highlight\"><pre><code class=\"language-text\">命令位置：集群节点\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active              Reachable           18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n\n筛选查看命令\n\n①只展示id\n[root@swarm01 /]# docker node ls -q\n2g6592p43eonilcjvivw3ww1f\nx64fuzm4y70ov30i5txx327a9\nhka4wtaqt05hsme3c5ycp2nmp\n[root@swarm01 /]# \n②筛选满足条件（支持参数 name id）\n[root@swarm01 /]# docker node ls -f name=swarm01\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4</code></pre></div><h2>修改节点</h2><div class=\"highlight\"><pre><code class=\"language-text\">命令位置：集群节点\n\n节点降低：manager-&gt; worker\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active              Reachable           18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n[root@swarm01 /]# docker node demote swarm02\nManager swarm02 demoted in the swarm.\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n\n节点升级: worker -&gt; manager\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n[root@swarm01 /]# docker node promote swarm02\nNode swarm02 promoted to a manager in the swarm.\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active              Reachable           18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n\n指定参数修改\n--advertise-addr: ip\n--listen-addr: ip与端口\n--availability: 节点的有效性(&#34;active&#34;|&#34;pause&#34;|&#34;drain&#34;)\n--role：worker manager\n\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active              Reachable           18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n[root@swarm01 /]# docker node update --role worker swarm02\nswarm02\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4</code></pre></div><h2>移除节点</h2><div class=\"highlight\"><pre><code class=\"language-text\">移除节点完成操作\n①命令位置： swarm03(准备移除的节点)\n[root@swarm03 ~]# docker swarm leave\nNode left the swarm.\n[root@swarm03 ~]# \n②命令位置：swarm01(控制节点)\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Down                Active                                  18.09.4\n[root@swarm01 /]# docker node rm swarm03\nswarm03\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\n工作节点执行docker node leave之后在集群节点状态变为Down，这样在集群节点执行docker node rm便可以\n\n如果需要强制移除节点，直接执行会报错\n[root@swarm01 /]# docker node rm swarm03\nError response from daemon: rpc error: code = FailedPrecondition desc = node 2wo6hxhxa3loms06o3midxhdj is not down and can&#39;t be removed\n使用强制参数\n[root@swarm01 /]# docker node rm -f swarm03\nswarm03\n[root@swarm01 /]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active                                  18.09.4\n[root@swarm01 /]#</code></pre></div><h2>部署应用</h2><h3>创建服务</h3><p>docker service create --detach , -d: 指定容器运行于前台还是后台，默认为false --name: 服务名称 --network: 网络连接 --publish , -p: 端口映射 --env , -e: 设置环境变量 --tty , -t: 分配tty设备，该可以支持终端登录 --mount: 文件挂载 --replicas: 指定任务数量</p><div class=\"highlight\"><pre><code class=\"language-text\">拉取hello-world最新版本镜像作为演示demo\n[root@swarm01 usr]# docker service create --replicas 3 -p 443:8080 --name hello \\\n&gt; --mount type=bind,source=/storage/apiapp_log,destination=/go/src/logs \\\n&gt; --mount type=bind,source=/root/apiapp/app.conf,destination=/root/app.conf \\\n&gt; --mount type=bind,source=/root/apiapp/run_application.sh,destination=/root/run_application.sh \\\n&gt; -e RUN_MODE=Production \\\n&gt; -td hello-wrold:latest\nimage hello-wrold:latest could not be accessed on a registry to record\nits digest. Each node will access hello-wrold:latest independently,\npossibly leading to different nodes running different\nversions of the image.\n\nxfmlwf4eo9b27jlhrh889wooy\n[root@swarm01 usr]# \n\n查看服务创建情况\n[root@swarm01 usr]# docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE                PORTS\nxfmlwf4eo9b2        hello               replicated          0/3                 hello-wrold:latest   *:443-&gt;8080/tcp\n[root@swarm01 usr]#</code></pre></div><h3>服务参数修改(这里的镜像因为网速原因用的是最小的hello-world，错误地方暂且忽略)</h3><div class=\"highlight\"><pre><code class=\"language-text\">docker service update [OPTIONS] SERVICE\n\n[root@swarm01 /]# docker service update --replicas 2 hello\nhello\noverall progress: 0 out of 2 tasks \n1/2: preparing [=================================&gt;                 ] \n2/2: preparing [=================================&gt;                 ] \nservice update paused: update paused due to failure or early termination of task 4yk09qa7z8rw11517ucmxgxku\n\n针对任务数量修改，支持批量修改的命令为：docker service scale service=replicas。。。 支持批量操作</code></pre></div><h3>查看服务</h3><div class=\"highlight\"><pre><code class=\"language-text\">[root@swarm01 ~]# docker service ls （options）\nID                  NAME                MODE                REPLICAS            IMAGE                PORTS\nxfmlwf4eo9b2        hello               replicated          0/3                 hello-wrold:latest   *:443-&gt;8080/tcp\n\n--filter 同样可以支持参数过滤操作</code></pre></div><h3>查看任务列表</h3><div class=\"highlight\"><pre><code class=\"language-text\">docker service ps [OPTIONS] SERVICE [SERVICE...]  （支持filter过滤操作）【支持批量操作】\n[再次声明，所有展示为了操作命令，运行状态是否正确这里不考虑]\n[root@swarm01 /]# docker service ps hello\nID                  NAME                IMAGE                NODE                DESIRED STATE       CURRENT STATE                 ERROR                              PORTS\njfpqsqh46n4h        hello.1             hello-wrold:latest   swarm02             Running             Preparing 11 seconds ago                                         \nvovkm6h5g4zk         \\_ hello.1         hello-wrold:latest   swarm01             Shutdown            Rejected 12 seconds ago       &#34;invalid mount config for type??   \nunuabe9yy49l         \\_ hello.1         hello-wrold:latest   swarm03             Shutdown            Rejected 38 seconds ago       &#34;invalid mount config for type??   \nl8apmw48cjiq         \\_ hello.1         hello-wrold:latest   swarm02             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??   \nue2057am4lps         \\_ hello.1         hello-wrold:latest   swarm01             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??   \nk1i9e990753w        hello.2             hello-wrold:latest   swarm02             Running             Preparing 40 seconds ago                                         \n2ezv34jno81a         \\_ hello.2         hello-wrold:latest   swarm03             Shutdown            Rejected 41 seconds ago       &#34;invalid mount config for type??   \nk3qwlh6ocukc         \\_ hello.2         hello-wrold:latest   swarm02             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??   \nh9jqy8coh3qd         \\_ hello.2         hello-wrold:latest   swarm03             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??   \nnujear2hj645         \\_ hello.2         hello-wrold:latest   swarm01             Shutdown            Rejected 2 minutes ago        &#34;invalid mount config for type??   \nhyhstj0fngak        hello.3             hello-wrold:latest   swarm02             Running             Preparing 15 seconds ago                                         \nxeqe7xgebbd4         \\_ hello.3         hello-wrold:latest   swarm01             Shutdown            Rejected 15 seconds ago       &#34;invalid mount config for type??   \nelmh2v12o16s         \\_ hello.3         hello-wrold:latest   swarm03             Shutdown            Rejected 51 seconds ago       &#34;invalid mount config for type??   \nd7u4yxhu70db         \\_ hello.3         hello-wrold:latest   swarm01             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??   \nvcwia4wqthfq         \\_ hello.3         hello-wrold:latest   swarm02             Shutdown            Rejected about a minute ago   &#34;invalid mount config for type??</code></pre></div><h3>查看服务详情</h3><div class=\"highlight\"><pre><code class=\"language-text\">docker service inspect [OPTIONS] SERVICE [SERVICE...] 支持多个操作\n\n[root@swarm01 /]# docker service inspect hello</code></pre></div><h3>删除服务</h3><div class=\"highlight\"><pre><code class=\"language-text\">docker service rm SERVICE [SERVICE...]\n\n[root@swarm01 /]# docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE                PORTS\nxfmlwf4eo9b2        hello               replicated          0/3                 hello-wrold:latest   *:443-&gt;8080/tcp\n[root@swarm01 /]# docker service rm hello\nhello\n[root@swarm01 /]# docker service ls\nID                  NAME                MODE                REPLICAS            IMAGE               PORTS\n[root@swarm01 /]#</code></pre></div><h3>查看服务日志</h3><div class=\"highlight\"><pre><code class=\"language-text\">docker service logs [OPTIONS] SERVICE|TASK\n--follow , -f: 跟随输出\n--tail: 显示最新的N条日志\n--since: 显示从某个时间开始的所有日志\n--timestamps , -t: 显示时间戳</code></pre></div><p>此篇文章建立在dokcer swarm集群搭建完成的基础上，可以参见地址：<a href=\"https://zhuanlan.zhihu.com/p/61535537\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/61</span><span class=\"invisible\">535537</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Docker Swarm", 
                    "tagLink": "https://api.zhihu.com/topics/20104973"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61535537", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 0, 
            "title": "Docker环境安装 Swarm集群搭建", 
            "content": "<h2>Centos搭建docker环境（节点环境准备）</h2><ul><li> 系统要求： 目前，CentOS 仅发行版本中的内核支持 Docker。<br/> Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br/> Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。<br/> </li><li> 安装必要工具<br/> </li></ul><div class=\"highlight\"><pre><code class=\"language-text\">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></pre></div><ul><li>添加阿里云下载源</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre></div><ul><li>安装docker-ce</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">sudo yum makecache fast(可选操作)\n\nsudo yum -y install docker-ce</code></pre></div><ul><li>一些无关的优化设置</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">systemctl stop firewalld(关闭防火墙)\n\nsystemctl disable firewalld（开启不开启防火墙）\n\nsystemctl start docker(启动docker)\n\nsystemctl enable docker(开机启动docker)</code></pre></div><h2>swarm单集群</h2><ul><li>环境说明</li></ul><p>hostname | idaddress |  role -|-|- swarm01 | 192.168.198.131 | manager | swarm02 | 192.168.198.132 | manager | swarm03 | 192.168.198.133 | worker |</p><ul><li>操作目的解释</li></ul><p>在swarm01进行节点初始化，默认是manager节点； swarm02作为manager节点加入集群中；swarm02作为worker节点加入集群中。最终的效果展示的大概是这样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">[root@swarm01 ~]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\npxginxl7p0ck7sc6lc3r7yfvg *   swarm01             Ready               Active              Leader              18.09.4\nwwjbu34lqg9diney4e4xpes3l     swarm02             Ready               Active              Reachable           18.09.4\n0pv07jzs0cf4581q283r1nqp5     swarm03             Ready               Active                                  18.09.4</code></pre></div><ul><li>环境准备（这里只配置swarm01，其余两个同理）</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">准备三个docker环境的虚拟机，要求之间具有联通关系\n\nswarm01主机相关操作\n\nhostname swarm01(主机名称命名)\n\n还有可能需要配置静态ip\nvim /etc/sysconfig/network-scripts/ifcfg-en33(编辑网络配置文件，名称可能不是这个，具体系统具体对待)\n\n需要修改部分\nBOOTPROTO=&#34;static&#34;\nBROADCAST=192.168.198.255\nIPADDR=192.168.198.131\nNETMASK=255.255.255.0\nGATEWAY=192.168.198.2\n\n如何获取上面的信息\nifconfig\n\nnetstat -rn\n\n如果没有ifconfig命令，可以进行下面的操作\n[root@swarm01 network-scripts]# yum search ifconfig\nLoaded plugins: fastestmirror\nLoading mirror speeds from cached hostfile\n * base: ap.stykers.moe\n * extras: mirrors.aliyun.com\n * updates: mirrors.aliyun.com\n============================================================================================================================= Matched: ifconfig ==============================================================================================================================\nnet-tools.x86_64 : Basic networking tools</code></pre></div><ul><li>集群初始化 操作位置：swarm01</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">[root@swarm01 network-scripts]# docker swarm init --advertise-addr 192.168.198.131 \\--listen-addr 192.168.198.131:2377\nSwarm initialized: current node (2g6592p43eonilcjvivw3ww1f) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join --token SWMTKN-1-2gyvi3dxuyuw9h5red8hty6hu9rvgwsxfmo296e1ajtfln0rsl-exsbzi1308n0kstnrizfwqyv5 192.168.198.131:2377\n\nTo add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.\n\n[root@swarm01 network-scripts]# \n\n查看集群初始化效果\n[root@swarm01 network-scripts]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\n[root@swarm01 network-scripts]# \n\n获取控制节点的token\n[root@swarm01 network-scripts]# docker swarm join-token manager\nTo add a manager to this swarm, run the following command:\n\n    docker swarm join --token SWMTKN-1-2gyvi3dxuyuw9h5red8hty6hu9rvgwsxfmo296e1ajtfln0rsl-3ujqri9fd63dns6v37z9cxd84 192.168.198.131:2377\n\n[root@swarm01 network-scripts]# \n\n拷贝这句话在swarm02上执行\n[root@swarm02 ~]# docker swarm join --token SWMTKN-1-2gyvi3dxuyuw9h5red8hty6hu9rvgwsxfmo296e1ajtfln0rsl-3ujqri9fd63dns6v37z9cxd84 192.168.198.131:2377\nThis node joined a swarm as a manager.\n[root@swarm02 ~]# \n\n\n获取工作节点的token\n[root@swarm01 network-scripts]# docker swarm join-token worker\nTo add a worker to this swarm, run the following command:\n\n    docker swarm join --token SWMTKN-1-2gyvi3dxuyuw9h5red8hty6hu9rvgwsxfmo296e1ajtfln0rsl-exsbzi1308n0kstnrizfwqyv5 192.168.198.131:2377\n\n[root@swarm01 network-scripts]# \n\n\n拷贝这句话在swarm03执行\n[root@swarm03 ~]#  docker swarm join --token SWMTKN-1-2gyvi3dxuyuw9h5red8hty6hu9rvgwsxfmo296e1ajtfln0rsl-exsbzi1308n0kstnrizfwqyv5 192.168.198.131:2377\nThis node joined a swarm as a worker.\n[root@swarm03 ~]# \n\n集群节点最终查看效果\n[root@swarm01 network-scripts]# docker node ls\nID                            HOSTNAME            STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION\n2g6592p43eonilcjvivw3ww1f *   swarm01             Ready               Active              Leader              18.09.4\nx64fuzm4y70ov30i5txx327a9     swarm02             Ready               Active              Reachable           18.09.4\nhka4wtaqt05hsme3c5ycp2nmp     swarm03             Ready               Active                                  18.09.4\n[root@swarm01 network-scripts]#</code></pre></div><ul><li>swarm集群搭建总结 总的来说操作相对于k8s简直简单的不是一点 这篇文章没有大量的截图不符合我的尿性，失败。 更多集群的操作命令这篇文章就不在介绍了，后续我会新开一篇文章进行介绍，还行大家多多关注。</li></ul>", 
            "topic": [
                {
                    "tag": "Docker Swarm", 
                    "tagLink": "https://api.zhihu.com/topics/20104973"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61107573", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 11, 
            "title": "Java SSM框架相关基础面试题整理", 
            "content": "<p><b>一、Spring面试题</b></p><p><b>1、Spring 在ssm中起什么作用？</b></p><p>Spring：轻量级框架</p><p>作用：Bean工厂，用来管理Bean的生命周期和框架集成。</p><p>两大核心：</p><p><br/>①. IOC/DI(控制反转/依赖注入) ：把dao依赖注入到service层，service层反转给action层，Spring顶层容器为BeanFactory。</p><p><br/>②. AOP：面向切面编程</p><p><b>2、Spring的事务？</b></p><p>编程式事务管理：编程方式管理事务，极大灵活性，难维护。</p><p>声明式事务管理：可以将业务代码和事务管理分离，用注解和xml配置来管理事务。</p><p><b>3、IOC 在项目中的作用？</b></p><p>作用：Ioc解决对象之间的依赖问题，把所有Bean的依赖关系通过配置文件或注解关联起来，降低了耦合度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4、Spring的配置文件中的内容？</b></p><p>开启事务注解驱动</p><p>事务管理器</p><p>开启注解功能，并配置扫描包</p><p>配置数据库</p><p>配置SQL会话工厂，别名，映射文件</p><p>不用编写Dao层的实现类</p><p><b>5、Spring下的注解？</b></p><p>注册：@Controller @Service @Component</p><p>注入：@Autowired @Resource</p><p>请求地址：@RequestMapping</p><p>返回具体数据类型而非跳转：@ResponseBody</p><p><b>6、Spring DI 的三种方式?</b></p><p>构造器注入：通过构造方法初始化</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;constructor-arg index=&#34;0&#34; type=&#34;java.lang.String&#34; value=&#34;宝马&#34;&gt;&lt;/constructor-arg&gt;\n</code></pre></div><p>setter方法注入：通过setter方法初始化</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;property name=&#34;id&#34; value=&#34;1111&#34;&gt;&lt;/property&gt;\n</code></pre></div><p>接口注入</p><p><b>7、Spring主要使用了什么模式？</b></p><p>工厂模式：每个Bean的创建通过方法</p><p>单例模式：默认的每个Bean的作用域都是单例</p><p>代理模式：关于Aop的实现通过代理模式</p><p><b>8、IOC，AOP的实现原理？</b></p><p>IOC：通过反射机制生成对象注入</p><p>AOP：动态代理</p><p><b>二、SpringMvc面试题</b></p><p><b>1、SpringMvc 的控制器是不是单例模式，如果是，有什么问题，怎么解决？</b></p><p>问题：单例模式，在多线程访问时有线程安全问题</p><p>解决方法：不要用同步，在控制器里面不能写字段</p><p><b>2、SpringMvc 中控制器的注解？</b></p><p>@Controller：该注解表明该类扮演控制器的角色</p><p><b>3、@RequestMapping 注解用在类上的作用？</b></p><p>作用：用来映射一个URL到一个类或者一个特定的处理方法上</p><p><b>4、前台多个参数，这些参数都是一个对象，快速得到对象？</b></p><p>方法：直接在方法中声明这个对象，SpringMvc就自动把属性赋值到这个对象里面</p><p><b>5、SpringMvc中函数的返回值？</b></p><p>String，ModelAndView，List，Set 等<br/>一般String，Ajax请求，返回一个List集合</p><p><b>6、SpringMvc中的转发和重定向?</b></p><p>转发： return：“hello”</p><p>重定向 ：return：“redirect:hello.jsp”</p><p><b>7、SpringMvc和Ajax之间的相互调用？</b></p><p>通过JackSon框架把java里面对象直接转换成js可识别的json对象，具体步骤如下：</p><p>加入JackSon.jar</p><p>在配置文件中配置json的映射</p><p>在接受Ajax方法里面直接返回Object，list等，方法前面需要加上注解@ResponseBody</p><p><b>8、SpringMvc的工作流程图?</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5e6fe1f0c1ce2ea0889dfff5a92d3440_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-5e6fe1f0c1ce2ea0889dfff5a92d3440_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;685&#39; height=&#39;402&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-5e6fe1f0c1ce2ea0889dfff5a92d3440_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5e6fe1f0c1ce2ea0889dfff5a92d3440_b.jpg\"/></figure><p><b>9、Struts2 和 SpringMvc的区别?</b></p><p><b>入口不同：</b></p><p>Struts2：filter过滤器</p><p>SpringMvc：一个Servlet即前端控制器</p><p><b>开发方式不同：</b></p><p>Struts2：基于类开发，传递参数通过类的属性，只能设置为多例</p><p>SpringMvc：基于方法开发(一个url对应一个方法)，请求参数传递到方法形参，可以为单例也可以为多例(建议单例)</p><p><b>请求方式不同：</b></p><p>Struts2：值栈村塾请求和响应的数据，通过OGNL存取数据</p><p>SpringMvc：通过参数解析器将request请求内容解析，给方法形参赋值，将数据和视图封装成ModelAndView对象，最后又将ModelAndView中的模型数据通过request域传输到页面，jsp视图解析器默认使用的是jstl。</p><p>三、Mybatis面试题</p><p><b>1、Ibatis和Mybatis？</b></p><p>Ibatis：2010年，apache的Ibatis框架停止更新，并移交给了google团队，同时更名为MyBatis。从2010年后Ibatis在没更新过，彻底变成了一个孤儿框架。一个没人维护的框架注定被mybatis拍在沙滩上。</p><p>Mybatis：Ibatis的升级版本。</p><p><b>2、什么是Mybatis的接口绑定，有什么好处？</b></p><p>Mybatis实现了DAO接口与xml映射文件的绑定，自动为我们生成接口的具体实现，使用起来变得更加省事和方便。</p><p><b>3、什么情况用注解，什么情况用xml绑定？</b></p><p>注解使用情况：Sql语句简单时</p><p>xml绑定使用情况：xml绑定 (@RequestMap用来绑定xml文件)</p><p><b>4、Mybatis在核心处理类叫什么?</b></p><p>SqlSession</p><p><b>5、查询表名和返回实体Bean对象不一致，如何处理？</b></p><p>映射键值对即可</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;result column=&#34;title&#34; property=&#34;title&#34; javaType=&#34;java.lang.String&#34;/&gt;\n</code></pre></div><p>column：数据库中表的列名</p><p>property：实体Bean中的属性名</p><p><b>6、Mybatis的好处？</b></p><p>把Sql语句从Java中独立出来。</p><p>封装了底层的JDBC，API的调用，并且能够将结果集自动转换成JavaBean对象，简化了Java数据库编程的重复工作。</p><p>自己编写Sql语句，更加的灵活。</p><p>入参无需用对象封装（或者map封装）,使用@Param注解</p><p><b>7、Mybatis配置一对多？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;collection property=&#34;topicComment&#34; column=&#34;id&#34; ofType=&#34;com.tmf.bbs.pojo.Comment&#34; select=&#34;selectComment&#34; /&gt;\n</code></pre></div><p>property：属性名</p><p>column：共同列</p><p>ofType：集合中元素的类型</p><p>select：要连接的查询</p><p><b>8、Mybatis配置一对一？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;association property=&#34;topicType&#34; select=&#34;selectType&#34; column=&#34;topics_type_id&#34; javaType=&#34;com.tmf.bbs.pojo.Type&#34;/&gt;\n</code></pre></div><p>property：属性名</p><p>select：要连接的查询</p><p>column：共同列</p><p>javaType：集合中元素的类型</p><p><b>9 、${} 和 #{}的区别？</b></p><p>${}：简单字符串替换，把${}直接替换成变量的值，不做任何转换，这种是取值以后再去编译SQL语句。</p><p>#{}：预编译处理，sql中的#{}替换成？，补全预编译语句，有效的防止Sql语句注入，这种取值是编译好SQL语句再取值。</p><p>总结：一般用#{}来进行列的代替</p><p><b>10、获取上一次自动生成的主键值？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">select last _insert_id()\n</code></pre></div><p><b>11、Mybatis如何分页，分页原理？</b></p><p>RowBounds对象分页</p><p>在Sql内直接书写，带有物理分页</p><p><b>12、Mybatis工作原理？</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7d204a265236fe273a2789563a119f5e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"795\" data-rawheight=\"661\" class=\"origin_image zh-lightbox-thumb\" width=\"795\" data-original=\"https://pic3.zhimg.com/v2-7d204a265236fe273a2789563a119f5e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;795&#39; height=&#39;661&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"795\" data-rawheight=\"661\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"795\" data-original=\"https://pic3.zhimg.com/v2-7d204a265236fe273a2789563a119f5e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7d204a265236fe273a2789563a119f5e_b.jpg\"/></figure><p><b>原理：</b></p><p>通过SqlSessionFactoryBuilder从mybatis-config.xml配置文件中构建出SqlSessionFactory。</p><p>SqlSessionFactory开启一个SqlSession，通过SqlSession实例获得Mapper对象并且运行Mapper映射的Sql语句。</p><p>完成数据库的CRUD操作和事务提交，关闭SqlSession。</p>", 
            "topic": [
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }, 
                {
                    "tag": "Java EE", 
                    "tagLink": "https://api.zhihu.com/topics/19620553"
                }, 
                {
                    "tag": "Java 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19702290"
                }
            ], 
            "comments": [
                {
                    "userName": "蓝色预警", 
                    "userLink": "https://www.zhihu.com/people/1c179821ee5f6649e19cced2791f3b4b", 
                    "content": "@resource是java提供的注解", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61103187", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "12条MySQL优化技巧，提速不止十倍！", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cf206dbc540a69bbb64060c634ad4833_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-cf206dbc540a69bbb64060c634ad4833_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;771&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"771\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-cf206dbc540a69bbb64060c634ad4833_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cf206dbc540a69bbb64060c634ad4833_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>应用程序慢如牛，原因多多，可能是网络的原因、可能是系统架构的原因，还有可能是数据库的原因。</p><p>那么如何提高数据库SQL语句执行速度呢？有人会说性能调优是数据库管理员（DBA）的事，然而性能调优跟程序员们也有莫大的关系。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-abe37891ecd64a9b56a7d1f943b451f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-abe37891ecd64a9b56a7d1f943b451f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-abe37891ecd64a9b56a7d1f943b451f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-abe37891ecd64a9b56a7d1f943b451f3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>程序中嵌入的一行行的SQL语句，如果使用了一些优化小技巧，定能达到事半功倍的效果。</p><p><b>技巧1  比较运算符能用 “=”就不用“&lt;&gt;”</b></p><p>“=”增加了索引的使用几率。</p><p><b>技巧2  明知只有一条查询结果，那请使用 “LIMIT 1”</b></p><p>“LIMIT 1”可以避免全表扫描，找到对应结果就不会再继续扫描了。</p><p><b>技巧3  为列选择合适的数据类型</b></p><p>能用TINYINT就不用SMALLINT，能用SMALLINT就不用INT，道理你懂的，磁盘和内存消耗越小越好嘛。</p><p><b>技巧4  将大的DELETE，UPDATE or INSERT 查询变成多个小查询</b></p><p>能写一个几十行、几百行的SQL语句是不是显得逼格很高？然而，为了达到更好的性能以及更好的数据控制，你可以将他们变成多个小查询。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7b8736730b2a0363c7c90947f4b05ed7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7b8736730b2a0363c7c90947f4b05ed7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7b8736730b2a0363c7c90947f4b05ed7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7b8736730b2a0363c7c90947f4b05ed7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>技巧5  使用UNION ALL 代替 UNION，如果结果集允许重复的话</b></p><h2>因为 UNION ALL 不去重，效率高于 UNION。<br/></h2><p><b>技巧6  为获得相同结果集的多次执行，请保持SQL语句前后一致</b></p><p>这样做的目的是为了充分利用查询缓冲。</p><p>比如根据地域和产品id查询产品价格，第一次使用了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a43bf08f4ffc83bd20b34ed249bd283e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"34\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-a43bf08f4ffc83bd20b34ed249bd283e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;34&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"34\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic3.zhimg.com/v2-a43bf08f4ffc83bd20b34ed249bd283e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a43bf08f4ffc83bd20b34ed249bd283e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>那么第二次同样的查询，请保持以上语句的一致性，比如不要将where语句里面的id和region位置调换顺序。</p><p><b>技巧7  尽量避免使用 “SELECT *”</b></p><p>如果不查询表中所有的列，尽量避免使用 SELECT *，因为它会进行全表扫描，不能有效利用索引，增大了数据库服务器的负担，以及它与应用程序客户端之间的网络IO开销。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8ee3457cfb73086dca98d37e2cb85ab4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8ee3457cfb73086dca98d37e2cb85ab4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8ee3457cfb73086dca98d37e2cb85ab4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8ee3457cfb73086dca98d37e2cb85ab4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>技巧8  WHERE 子句里面的列尽量被索引</b></p><p>只是“尽量”哦，并不是说所有的列。因地制宜，根据实际情况进行调整，因为有时索引太多也会降低性能。</p><p><b>技巧9  JOIN 子句里面的列尽量被索引</b></p><p>同样只是“尽量”哦，并不是说所有的列。</p><p><b>技巧10  ORDER BY 的列尽量被索引</b></p><p>ORDER BY的列如果被索引，性能也会更好。</p><p><b>技巧11  使用 LIMIT 实现分页逻辑</b></p><p>不仅提高了性能，同时减少了不必要的数据库和应用间的网络传输。</p><p><b>技巧12  使用 EXPLAIN 关键字去查看执行计划</b></p><p>EXPLAIN 可以检查索引使用情况以及扫描的行。</p><p><b>其他</b></p><p>SQL调优方法有很多种，同样的查询结果可以有很多种不同的查询方式。其实最好的方法就是在开发环境中用最贴近真实的数据集和硬件环境进行测试，然后再发布到生产环境中。</p>", 
            "topic": [
                {
                    "tag": "数据库性能", 
                    "tagLink": "https://api.zhihu.com/topics/19554130"
                }, 
                {
                    "tag": "SQL优化", 
                    "tagLink": "https://api.zhihu.com/topics/19644211"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61100871", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 23, 
            "title": "常用的设计模式汇总，超详细！", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7608ae96b77f3f570dae9ee5d136b8a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"902\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-7608ae96b77f3f570dae9ee5d136b8a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;902&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"902\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-7608ae96b77f3f570dae9ee5d136b8a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7608ae96b77f3f570dae9ee5d136b8a1_b.jpg\"/></figure><p><b>单例模式</b><br/></p><p>简单点说，就是一个应用程序中，某个类的实例对象只有一个，你没有办法去new，因为构造器是被private修饰的，一般通过getInstance()的方法来获取它们的实例。</p><p>getInstance()的返回值是一个对象的引用，并不是一个新的实例，所以不要错误的理解成多个对象。单例模式实现起来也很容易，直接看demo吧</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Singleton {\n\nprivate static Singleton singleton;\n\nprivate Singleton() {\n}\n\npublic static Singleton getInstance() {\n if (singleton == null) {\n  singleton = new Singleton();\n }\n return singleton;\n}\n}</code></pre></div><p>按照我的习惯，我恨不得写满注释，怕你们看不懂，但是这个代码实在太简单了，所以我没写任何注释，如果这几行代码你都看不明白的话，那你可以洗洗睡了，等你睡醒了再来看我的博客说不定能看懂。</p><p>上面的是最基本的写法，也叫懒汉写法（线程不安全）下面我再公布几种单例模式的写法：</p><p><b>懒汉式写法（线程安全）</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Singleton {  \n   private static Singleton instance;  \n   private Singleton (){}  \n   public static synchronized Singleton getInstance() {  \n   if (instance == null) {  \n       instance = new Singleton();  \n   }  \n   return instance;  \n   }  \n}</code></pre></div><p><b>饿汉式写法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Singleton {  \n   private static Singleton instance = new Singleton();  \n   private Singleton (){}  \n   public static Singleton getInstance() {  \n   return instance;  \n   }  \n}</code></pre></div><p><b>静态内部类</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Singleton {  \n   private static class SingletonHolder {  \n   private static final Singleton INSTANCE = new Singleton();  \n   }  \n   private Singleton (){}  \n   public static final Singleton getInstance() {  \n   return SingletonHolder.INSTANCE;  \n   }  \n}</code></pre></div><p><b>枚举</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public enum Singleton {  \n   INSTANCE;  \n   public void whateverMethod() {  \n   }  \n}</code></pre></div><p>这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏。</p><p><b>双重校验锁</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Singleton {  \n   private volatile static Singleton singleton;  \n   private Singleton (){}  \n   public static Singleton getSingleton() {  \n   if (singleton == null) {  \n       synchronized (Singleton.class) {  \n       if (singleton == null) {  \n           singleton = new Singleton();  \n       }  \n       }  \n   }  \n   return singleton;  \n   }  \n}</code></pre></div><p><b>总结</b>：我个人比较喜欢静态内部类写法和饿汉式写法，其实这两种写法能够应付绝大多数情况了。其他写法也可以选择，主要还是看业务需求吧。</p><p><b>观察者模式</b></p><p>对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e10789ed33e83c38bbd729e0fb2c3dc1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"265\" class=\"content_image\" width=\"401\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;401&#39; height=&#39;265&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"265\" class=\"content_image lazy\" width=\"401\" data-actualsrc=\"https://pic2.zhimg.com/v2-e10789ed33e83c38bbd729e0fb2c3dc1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>观察者模式UML图</p><p>看不懂图的人端着小板凳到这里来，给你举个栗子：假设有三个人，小美（女，22），小王和小李。小美很漂亮，小王和小李是两个程序猿，时刻关注着小美的一举一动。有一天，小美说了一句：“谁来陪我打游戏啊。”这句话被小王和小李听到了，结果乐坏了，蹭蹭蹭，没一会儿，小王就冲到小美家门口了，在这里，小美是被观察者，小王和小李是观察者，被观察者发出一条信息，然后观察者们进行相应的处理，看代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface Person {\n   //小王和小李通过这个接口可以接收到小美发过来的消息\n   void getMessage(String s);\n}</code></pre></div><p>这个接口相当于小王和小李的电话号码，小美发送通知的时候就会拨打getMessage这个电话，拨打电话就是调用接口，看不懂没关系，先往下看</p><div class=\"highlight\"><pre><code class=\"language-text\">public class LaoWang implements Person {\n\n   private String name = &#34;小王&#34;;\n\n   public LaoWang() {\n   }\n\n   @Override\n   public void getMessage(String s) {\n       System.out.println(name + &#34;接到了小美打过来的电话，电话内容是：&#34; + s);\n   }\n\n}\n\npublic class LaoLi implements Person {\n\n   private String name = &#34;小李&#34;;\n\n   public LaoLi() {\n   }\n\n   @Override\n   public void getMessage(String s) {\n       System.out.println(name + &#34;接到了小美打过来的电话，电话内容是：-&gt;&#34; + s);\n   }\n\n}</code></pre></div><p>代码很简单，我们再看看小美的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class XiaoMei {\n   List&lt;Person&gt; list = new ArrayList&lt;Person&gt;();\n    public XiaoMei(){\n    }\n\n    public void addPerson(Person person){\n        list.add(person);\n    }\n\n    //遍历list，把自己的通知发送给所有暗恋自己的人\n    public void notifyPerson() {\n        for(Person person:list){\n            person.getMessage(&#34;你们过来吧，谁先过来谁就能陪我一起玩儿游戏!&#34;);\n        }\n    }\n}</code></pre></div><p>我们写一个测试类来看一下结果对不对</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n   public static void main(String[] args) {\n\n       XiaoMei xiao_mei = new XiaoMei();\n       LaoWang lao_wang = new LaoWang();\n       LaoLi lao_li = new LaoLi();\n\n       //小王和小李在小美那里都注册了一下\n       xiao_mei.addPerson(lao_wang);\n       xiao_mei.addPerson(lao_li);\n\n       //小美向小王和小李发送通知\n       xiao_mei.notifyPerson();\n   }\n}</code></pre></div><p>完美～</p><p><b>装饰者模式</b></p><p>对已有的业务逻辑进一步的封装，使其增加额外的功能，如Java中的IO流就使用了装饰者模式，用户在使用的时候，可以任意组装，达到自己想要的效果。 </p><p>举个栗子，我想吃三明治，首先我需要一根大大的香肠，我喜欢吃奶油，在香肠上面加一点奶油，再放一点蔬菜，最后再用两片面包夹一下，很丰盛的一顿午饭，营养又健康。（ps：不知道上海哪里有卖好吃的三明治的，求推荐～）那我们应该怎么来写代码呢？ 首先，我们需要写一个Food类，让其他所有食物都来继承这个类，看代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Food {\n\n   private String food_name;\n\n   public Food() {\n   }\n\n   public Food(String food_name) {\n       this.food_name = food_name;\n   }\n\n   public String make() {\n       return food_name;\n   };\n}</code></pre></div><p>代码很简单，我就不解释了，然后我们写几个子类继承它：</p><div class=\"highlight\"><pre><code class=\"language-text\">//面包类\npublic class Bread extends Food {\n\n   private Food basic_food;\n\n   public Bread(Food basic_food) {\n       this.basic_food = basic_food;\n   }\n\n   public String make() {\n       return basic_food.make()+&#34;+面包&#34;;\n   }\n}\n\n//奶油类\npublic class Cream extends Food {\n\n   private Food basic_food;\n\n   public Cream(Food basic_food) {\n       this.basic_food = basic_food;\n   }\n\n   public String make() {\n       return basic_food.make()+&#34;+奶油&#34;;\n   }\n}\n\n//蔬菜类\npublic class Vegetable extends Food {\n\n   private Food basic_food;\n\n   public Vegetable(Food basic_food) {\n       this.basic_food = basic_food;\n   }\n\n   public String make() {\n       return basic_food.make()+&#34;+蔬菜&#34;;\n   }\n\n}</code></pre></div><p>这几个类都是差不多的，构造方法传入一个Food类型的参数，然后在make方法中加入一些自己的逻辑，如果你还是看不懂为什么这么写，不急，你看看我的Test类是怎么写的，一看你就明白了</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n   public static void main(String[] args) {\n       Food food = new Bread(new Vegetable(new Cream(new Food(&#34;香肠&#34;))));\n       System.out.println(food.make());\n   }\n}</code></pre></div><p>看到没有，一层一层封装，我们从里往外看：最里面我new了一个香肠，在香肠的外面我包裹了一层奶油，在奶油的外面我又加了一层蔬菜，最外面我放的是面包，是不是很形象，哈哈~ 这个设计模式简直跟现实生活中一摸一样，看懂了吗？ 我们看看运行结果吧</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b5ff2711dddb14075a08c0bc9e49c314_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"172\" data-rawheight=\"41\" class=\"content_image\" width=\"172\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;172&#39; height=&#39;41&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"172\" data-rawheight=\"41\" class=\"content_image lazy\" width=\"172\" data-actualsrc=\"https://pic1.zhimg.com/v2-b5ff2711dddb14075a08c0bc9e49c314_b.jpg\"/></figure><p>运行结果</p><p>一个三明治就做好了～</p><p><b>适配器模式</b></p><p>将两种完全不同的事物联系到一起，就像现实生活中的变压器。假设一个手机充电器需要的电压是20V，但是正常的电压是220V，这时候就需要一个变压器，将220V的电压转换成20V的电压，这样，变压器就将20V的电压和手机联系起来了。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n   public static void main(String[] args) {\n       Phone phone = new Phone();\n       VoltageAdapter adapter = new VoltageAdapter();\n       phone.setAdapter(adapter);\n       phone.charge();\n   }\n}\n\n// 手机类\nclass Phone {\n\n   public static final int V = 220;// 正常电压220v，是一个常量\n\n   private VoltageAdapter adapter;\n\n   // 充电\n   public void charge() {\n       adapter.changeVoltage();\n   }\n\n   public void setAdapter(VoltageAdapter adapter) {\n       this.adapter = adapter;\n   }\n}\n\n// 变压器\nclass VoltageAdapter {\n   // 改变电压的功能\n   public void changeVoltage() {\n       System.out.println(&#34;正在充电...&#34;);\n       System.out.println(&#34;原始电压：&#34; + Phone.V + &#34;V&#34;);\n       System.out.println(&#34;经过变压器转换之后的电压:&#34; + (Phone.V - 200) + &#34;V&#34;);\n   }\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4783f25fc8ca2e5443b65229cb55ac88_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"594\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb\" width=\"594\" data-original=\"https://pic1.zhimg.com/v2-4783f25fc8ca2e5443b65229cb55ac88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;594&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"594\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"594\" data-original=\"https://pic1.zhimg.com/v2-4783f25fc8ca2e5443b65229cb55ac88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4783f25fc8ca2e5443b65229cb55ac88_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>工厂模式</b></p><p>简单工厂模式：一个抽象的接口，多个抽象接口的实现类，一个工厂类，用来实例化抽象的接口</p><div class=\"highlight\"><pre><code class=\"language-text\">// 抽象产品类\nabstract class Car {\n   public void run();\n\n   public void stop();\n}\n\n// 具体实现类\nclass Benz implements Car {\n   public void run() {\n       System.out.println(&#34;Benz开始启动了。。。。。&#34;);\n   }\n\n   public void stop() {\n       System.out.println(&#34;Benz停车了。。。。。&#34;);\n   }\n}\n\nclass Ford implements Car {\n   public void run() {\n       System.out.println(&#34;Ford开始启动了。。。&#34;);\n   }\n\n   public void stop() {\n       System.out.println(&#34;Ford停车了。。。。&#34;);\n   }\n}\n\n// 工厂类\nclass Factory {\n   public static Car getCarInstance(String type) {\n       Car c = null;\n       if (&#34;Benz&#34;.equals(type)) {\n           c = new Benz();\n       }\n       if (&#34;Ford&#34;.equals(type)) {\n           c = new Ford();\n       }\n       return c;\n   }\n}\n\npublic class Test {\n\n   public static void main(String[] args) {\n       Car c = Factory.getCarInstance(&#34;Benz&#34;);\n       if (c != null) {\n           c.run();\n           c.stop();\n       } else {\n           System.out.println(&#34;造不了这种汽车。。。&#34;);\n       }\n\n   }\n\n}</code></pre></div><p>工厂方法模式：有四个角色，抽象工厂模式，具体工厂模式，抽象产品模式，具体产品模式。不再是由一个工厂类去实例化具体的产品，而是由抽象工厂的子类去实例化产品</p><div class=\"highlight\"><pre><code class=\"language-text\">// 抽象产品角色\npublic interface Moveable {\n   void run();\n}\n\n// 具体产品角色\npublic class Plane implements Moveable {\n   @Override\n   public void run() {\n       System.out.println(&#34;plane....&#34;);\n   }\n}\n\npublic class Broom implements Moveable {\n   @Override\n   public void run() {\n       System.out.println(&#34;broom.....&#34;);\n   }\n}\n\n// 抽象工厂\npublic abstract class VehicleFactory {\n   abstract Moveable create();\n}\n\n// 具体工厂\npublic class PlaneFactory extends VehicleFactory {\n   public Moveable create() {\n       return new Plane();\n   }\n}\n\npublic class BroomFactory extends VehicleFactory {\n   public Moveable create() {\n       return new Broom();\n   }\n}\n\n// 测试类\npublic class Test {\n   public static void main(String[] args) {\n       VehicleFactory factory = new BroomFactory();\n       Moveable m = factory.create();\n       m.run();\n   }\n}</code></pre></div><p>抽象工厂模式：与工厂方法模式不同的是，工厂方法模式中的工厂只生产单一的产品，而抽象工厂模式中的工厂生产多个产品</p><div class=\"highlight\"><pre><code class=\"language-text\">/抽象工厂类\npublic abstract class AbstractFactory {\n   public abstract Vehicle createVehicle();\n   public abstract Weapon createWeapon();\n   public abstract Food createFood();\n}\n//具体工厂类，其中Food,Vehicle，Weapon是抽象类，\npublic class DefaultFactory extends AbstractFactory{\n   @Override\n   public Food createFood() {\n       return new Apple();\n   }\n   @Override\n   public Vehicle createVehicle() {\n       return new Car();\n   }\n   @Override\n   public Weapon createWeapon() {\n       return new AK47();\n   }\n}\n//测试类\npublic class Test {\n   public static void main(String[] args) {\n       AbstractFactory f = new DefaultFactory();\n       Vehicle v = f.createVehicle();\n       v.run();\n       Weapon w = f.createWeapon();\n       w.shoot();\n       Food a = f.createFood();\n       a.printName();\n   }\n}</code></pre></div><p><b>代理模式（proxy）</b></p><p><br/>有两种，静态代理和动态代理。先说静态代理，很多理论性的东西我不讲，我就算讲了，你们也看不懂。什么真实角色，抽象角色，代理角色，委托角色。。。</p><p>乱七八糟的，我是看不懂。之前学代理模式的时候，去网上翻一下，资料一大堆，打开链接一看，基本上都是给你分析有什么什么角色，理论一大堆，看起来很费劲，不信的话你们可以去看看，我是看不懂他们在说什么。咱不来虚的，直接用生活中的例子说话。（注意：我这里并不是否定理论知识，我只是觉得有时候理论知识晦涩难懂，喜欢挑刺的人一边去，你是来学习知识的，不是来挑刺的）</p><p><br/>到了一定的年龄，我们就要结婚，结婚是一件很麻烦的事情，（包括那些被父母催婚的）。有钱的家庭可能会找司仪来主持婚礼，显得热闹，洋气～好了，现在婚庆公司的生意来了，我们只需要给钱，婚庆公司就会帮我们安排一整套结婚的流程。整个流程大概是这样的：家里人催婚-&gt;男女双方家庭商定结婚的黄道即日-&gt;找一家靠谱的婚庆公司-&gt;在约定的时间举行结婚仪式-&gt;结婚完毕</p><p><br/>婚庆公司打算怎么安排婚礼的节目，在婚礼完毕以后婚庆公司会做什么，我们一概不知。。。别担心，不是黑中介，我们只要把钱给人家，人家会把事情给我们做好。所以，这里的婚庆公司相当于代理角色，现在明白什么是代理角色了吧。<br/></p><p>代码实现请看：</p><div class=\"highlight\"><pre><code class=\"language-text\">//代理接口\npublic interface ProxyInterface {\n//需要代理的是结婚这件事，如果还有其他事情需要代理，比如吃饭睡觉上厕所，也可以写\nvoid marry();\n//代理吃饭(自己的饭，让别人吃去吧)\n//void eat();\n//代理拉屎，自己的屎，让别人拉去吧\n//void shit();\n}</code></pre></div><p>文明社会，代理吃饭，代理拉屎什么的我就不写了，有伤社会风化～～～能明白就好<br/></p><p>好了，我们看看婚庆公司的代码:</p><div class=\"highlight\"><pre><code class=\"language-text\">public class WeddingCompany implements ProxyInterface {\n\nprivate ProxyInterface proxyInterface;\n\npublic WeddingCompany(ProxyInterface proxyInterface) {\n this.proxyInterface = proxyInterface;\n}\n\n@Override\npublic void marry() {\n System.out.println(&#34;我们是婚庆公司的&#34;);\n System.out.println(&#34;我们在做结婚前的准备工作&#34;);\n System.out.println(&#34;节目彩排...&#34;);\n System.out.println(&#34;礼物购买...&#34;);\n System.out.println(&#34;工作人员分工...&#34;);\n System.out.println(&#34;可以开始结婚了&#34;);\n proxyInterface.marry();\n System.out.println(&#34;结婚完毕，我们需要做后续处理，你们可以回家了，其余的事情我们公司来做&#34;);\n}\n\n}</code></pre></div><p>看到没有，婚庆公司需要做的事情很多，我们再看看结婚家庭的代码:</p><div class=\"highlight\"><pre><code class=\"language-text\">public class NormalHome implements ProxyInterface{\n\n@Override\npublic void marry() {\n System.out.println(&#34;我们结婚啦～&#34;);\n}\n\n}</code></pre></div><p>这个已经很明显了，结婚家庭只需要结婚，而婚庆公司要包揽一切，前前后后的事情都是婚庆公司来做，听说现在婚庆公司很赚钱的，这就是原因，干的活多，能不赚钱吗？</p><p>来看看测试类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\npublic static void main(String[] args) {\n ProxyInterface proxyInterface = new WeddingCompany(new NormalHome());\n proxyInterface.marry();\n}\n}</code></pre></div><p>运行结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-235d01be532d32da9605aadb424cb5a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"523\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb\" width=\"523\" data-original=\"https://pic2.zhimg.com/v2-235d01be532d32da9605aadb424cb5a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;523&#39; height=&#39;202&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"523\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"523\" data-original=\"https://pic2.zhimg.com/v2-235d01be532d32da9605aadb424cb5a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-235d01be532d32da9605aadb424cb5a5_b.jpg\"/></figure><p><br/>在我们预料中，结果正确，这就是静态代理，动态代理我就不想说了，跟java反射有关系，网上资料很多，我以后有时间再更新吧。</p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "设计原则", 
                    "tagLink": "https://api.zhihu.com/topics/19628119"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": [
                {
                    "userName": "星星", 
                    "userLink": "https://www.zhihu.com/people/f7e58946d873817a563340bbe1064b75", 
                    "content": "太厉害了，写的浅显易懂", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "chenyu", 
                    "userLink": "https://www.zhihu.com/people/09b3954318a417b7b9d518585da0e43a", 
                    "content": "不错，写的好", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61100506", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "8 种常被忽视的 SQL 错误用法，舅服你！", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-07ce74b8cae7f807827e31d23a7924c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb\" width=\"683\" data-original=\"https://pic1.zhimg.com/v2-07ce74b8cae7f807827e31d23a7924c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;683&#39; height=&#39;385&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"385\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"683\" data-original=\"https://pic1.zhimg.com/v2-07ce74b8cae7f807827e31d23a7924c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-07ce74b8cae7f807827e31d23a7924c0_b.jpg\"/></figure><p>sql语句的执行顺序：</p><div class=\"highlight\"><pre><code class=\"language-text\">FROM\n    &lt; left_table &gt; ON &lt; join_condition &gt; &lt; join_type &gt;\nJOIN &lt; right_table &gt;\nWHERE\n    &lt; where_condition &gt;\nGROUP BY\n    &lt; group_by_list &gt;\nHAVING\n    &lt; having_condition &gt; SELECT DISTINCT\n        &lt; select_list &gt;\n    ORDER BY\n        &lt; order_by_condition &gt;\n    LIMIT &lt; limit_number &gt;\n</code></pre></div><h3>1、LIMIT 语句</h3><p>分页查询是最常用的场景之一，但也通常也是最容易出问题的地方。比如对于下面简单的语句，一般 DBA 想到的办法是在 type, name, create_time 字段上加组合索引。这样条件排序都能有效的利用到索引，性能迅速提升。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    operation\nWHERE\n    type = &#39;SQLStats&#39;\nAND NAME = &#39;SlowLog&#39;\nORDER BY\n    create_time\nLIMIT 1000,\n 10;\n</code></pre></div><p>好吧，可能90%以上的 DBA 解决该问题就到此为止。但当 LIMIT 子句变成 “LIMIT 1000000,10” 时，程序员仍然会抱怨：我只取10条记录为什么还是慢？</p><p>要知道数据库也并不知道第1000000条记录从什么地方开始，即使有索引也需要从头计算一次。出现这种性能问题，多数情形下是程序员偷懒了。</p><p>在前端数据浏览翻页，或者大数据分批导出等场景下，是可以将上一页的最大值当成参数作为查询条件的。SQL 重新设计如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    operation\nWHERE\n    type = &#39;SQLStats&#39;\nAND NAME = &#39;SlowLog&#39;\nAND create_time &gt; &#39;2017-03-16 14:00:00&#39;\nORDER BY\n    create_time\nLIMIT 10;\n</code></pre></div><p>在新设计下查询时间基本固定，不会随着数据量的增长而发生变化。</p><h3>2、隐式转换</h3><p>SQL语句中查询变量和字段定义类型不匹配是另一个常见的错误。比如下面的语句：</p><div class=\"highlight\"><pre><code class=\"language-text\">mysql &gt; EXPLAIN EXTENDED SELECT\n    * &gt;\nFROM\n    my_balance b &gt;\nWHERE\n    b.bpn = 14000000123 &gt;\nAND b.isverified IS NULL;\n\nmysql &gt; SHOW WARNINGS;\n\n| Warning | 1739 | Cannot USE ref access ON INDEX &#39;bpn&#39; due TO type\nOR COLLATION conversion ON field &#39;bpn&#39;\n</code></pre></div><p>其中字段 bpn 的定义为 varchar(20)，MySQL 的策略是将字符串转换为数字之后再比较。函数作用于表字段，索引失效。</p><p>上述情况可能是应用程序框架自动填入的参数，而不是程序员的原意。现在应用框架很多很繁杂，使用方便的同时也小心它可能给自己挖坑。</p><h3>3、关联更新、删除</h3><p>虽然 MySQL5.6 引入了物化特性，但需要特别注意它目前仅仅针对查询语句的优化。对于更新或删除需要手工重写成 JOIN。</p><p>比如下面 UPDATE 语句，MySQL 实际执行的是循环/嵌套子查询（DEPENDENT SUBQUERY)，其执行时间可想而知。</p><div class=\"highlight\"><pre><code class=\"language-text\">UPDATE operation o\nSET STATUS = &#39;applying&#39;\nWHERE\n    o.id IN (\n        SELECT\n            id\n        FROM\n            (\n                SELECT\n                    o.id,\n                    o. STATUS\n                FROM\n                    operation o\n                WHERE\n                    o. GROUP = 123\n                AND o. STATUS NOT IN (&#39;done&#39;)\n                ORDER BY\n                    o.parent,\n                    o.id\n                LIMIT 1\n            ) t\n    );\n</code></pre></div><p>执行计划：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+\n| id | select_type        | table | type  | possible_keys | key     | key_len | ref   | rows | Extra                                               |\n+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+\n| 1  | PRIMARY            | o     | index |               | PRIMARY | 8       |       | 24   | Using where; Using temporary                        |\n| 2  | DEPENDENT SUBQUERY |       |       |               |         |         |       |      | Impossible WHERE noticed after reading const tables |\n| 3  | DERIVED            | o     | ref   | idx_2,idx_5   | idx_5   | 8       | const | 1    | Using where; Using filesort                         |\n+----+--------------------+-------+-------+---------------+---------+---------+-------+------+-----------------------------------------------------+\n</code></pre></div><p>重写为 JOIN 之后，子查询的选择模式从 DEPENDENT SUBQUERY 变成 DERIVED，执行速度大大加快，从7秒降低到2毫秒。</p><div class=\"highlight\"><pre><code class=\"language-text\">UPDATE operation o\nJOIN (\n    SELECT\n        o.id,\n        o. STATUS\n    FROM\n        operation o\n    WHERE\n        o. GROUP = 123\n    AND o. STATUS NOT IN (&#39;done&#39;)\n    ORDER BY\n        o.parent,\n        o.id\n    LIMIT 1\n) t ON o.id = t.id\nSET STATUS = &#39;applying&#39;\n</code></pre></div><p>执行计划简化为：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+\n| id | select_type | table | type | possible_keys | key   | key_len | ref   | rows | Extra                                               |\n+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+\n| 1  | PRIMARY     |       |      |               |       |         |       |      | Impossible WHERE noticed after reading const tables |\n| 2  | DERIVED     | o     | ref  | idx_2,idx_5   | idx_5 | 8       | const | 1    | Using where; Using filesort                         |\n+----+-------------+-------+------+---------------+-------+---------+-------+------+-----------------------------------------------------+\n</code></pre></div><h3>4、混合排序</h3><p>MySQL 不能利用索引进行混合排序。但在某些场景，还是有机会使用特殊方法提升性能的。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    my_order o\nINNER JOIN my_appraise a ON a.orderid = o.id\nORDER BY\n    a.is_reply ASC,\n    a.appraise_time DESC\nLIMIT 0,\n 20\n</code></pre></div><p>执行计划显示为全表扫描：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+\n| id | select_type | table | type   | possible_keys     | key     | key_len | ref      | rows    | Extra    \n+----+-------------+-------+--------+-------------+---------+---------+---------------+---------+-+\n|  1 | SIMPLE      | a     | ALL    | idx_orderid | NULL    | NULL    | NULL    | 1967647 | Using filesort |\n|  1 | SIMPLE      | o     | eq_ref | PRIMARY     | PRIMARY | 122     | a.orderid |       1 | NULL           |\n+----+-------------+-------+--------+---------+---------+---------+-----------------+---------+-+\n</code></pre></div><p>由于 is_reply 只有0和1两种状态，我们按照下面的方法重写后，执行时间从1.58秒降低到2毫秒。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    (\n        (\n            SELECT\n                *\n            FROM\n                my_order o\n            INNER JOIN my_appraise a ON a.orderid = o.id\n            AND is_reply = 0\n            ORDER BY\n                appraise_time DESC\n            LIMIT 0,\n            20\n        )\n        UNION ALL\n            (\n                SELECT\n                    *\n                FROM\n                    my_order o\n                INNER JOIN my_appraise a ON a.orderid = o.id\n                AND is_reply = 1\n                ORDER BY\n                    appraise_time DESC\n                LIMIT 0,\n                20\n            )\n    ) t\nORDER BY\n    is_reply ASC,\n    appraisetime DESC\nLIMIT 20;\n</code></pre></div><h3>5、EXISTS语句</h3><p>MySQL 对待 EXISTS 子句时，仍然采用嵌套子查询的执行方式。如下面的 SQL 语句：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    my_neighbor n\nLEFT JOIN my_neighbor_apply sra ON n.id = sra.neighbor_id\nAND sra.user_id = &#39;xxx&#39;\nWHERE\n    n.topic_status &lt; 4\nAND EXISTS (\n    SELECT\n        1\n    FROM\n        message_info m\n    WHERE\n        n.id = m.neighbor_id\n    AND m.inuser = &#39;xxx&#39;\n)\nAND n.topic_type &lt;&gt; 5\n</code></pre></div><p>执行计划为：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+--------------------+-------+------+-----+------------------------------------------+---------+-------+---------+ -----+\n| id | select_type        | table | type | possible_keys     | key   | key_len | ref   | rows    | Extra   |\n+----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+\n|  1 | PRIMARY            | n     | ALL  |  | NULL     | NULL    | NULL  | 1086041 | Using where                   |\n|  1 | PRIMARY            | sra   | ref  |  | idx_user_id | 123     | const |       1 | Using where          |\n|  2 | DEPENDENT SUBQUERY | m     | ref  |  | idx_message_info   | 122     | const |       1 | Using index condition; Using where |\n+----+--------------------+-------+------+ -----+------------------------------------------+---------+-------+---------+ -----+\n</code></pre></div><p>去掉 exists 更改为 join，能够避免嵌套子查询，将执行时间从1.93秒降低为1毫秒。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    my_neighbor n\nINNER JOIN message_info m ON n.id = m.neighbor_id\nAND m.inuser = &#39;xxx&#39;\nLEFT JOIN my_neighbor_apply sra ON n.id = sra.neighbor_id\nAND sra.user_id = &#39;xxx&#39;\nWHERE\n    n.topic_status &lt; 4\nAND n.topic_type &lt;&gt; 5\n</code></pre></div><p>新的执行计划：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+\n| id | select_type | table | type   | possible_keys     | key       | key_len | ref   | rows | Extra                 |\n+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+\n|  1 | SIMPLE      | m     | ref    | | idx_message_info   | 122     | const    |    1 | Using index condition |\n|  1 | SIMPLE      | n     | eq_ref | | PRIMARY   | 122     | ighbor_id |    1 | Using where      |\n|  1 | SIMPLE      | sra   | ref    | | idx_user_id | 123     | const     |    1 | Using where           |\n+----+-------------+-------+--------+ -----+------------------------------------------+---------+ -----+------+ -----+\n</code></pre></div><h3>6、条件下推</h3><p>外部查询条件不能够下推到复杂的视图或子查询的情况有：</p><ul><li>聚合子查询；</li><li>含有 LIMIT 的子查询；</li><li>UNION 或 UNION ALL 子查询；</li><li>输出字段中的子查询；</li></ul><p>如下面的语句，从执行计划可以看出其条件作用于聚合子查询之后：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    (\n        SELECT\n            target,\n            Count(*)\n        FROM\n            operation\n        GROUP BY\n            target\n    ) t\nWHERE\n    target = &#39;rm-xxxx&#39;\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+\n| id | select_type | table      | type  | possible_keys | key         | key_len | ref   | rows | Extra       |\n+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+\n|  1 | PRIMARY     | &lt;derived2&gt; | ref   | &lt;auto_key0&gt;   | &lt;auto_key0&gt; | 514     | const |    2 | Using where |\n|  2 | DERIVED     | operation  | index | idx_4         | idx_4       | 519     | NULL  |   20 | Using index |\n+----+-------------+------------+-------+---------------+-------------+---------+-------+------+-------------+\n</code></pre></div><p>确定从语义上查询条件可以直接下推后，重写如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    target,\n    Count(*)\nFROM\n    operation\nWHERE\n    target = &#39;rm-xxxx&#39;\nGROUP BY\n    target\n</code></pre></div><p>执行计划变为：</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+\n| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |\n+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+\n| 1 | SIMPLE | operation | ref | idx_4 | idx_4 | 514 | const | 1 | Using where; Using index |\n+----+-------------+-----------+------+---------------+-------+---------+-------+------+--------------------+\n</code></pre></div><p>关于 MySQL 外部条件不能下推的详细解释说明请参考文章：</p><blockquote><a href=\"https://link.zhihu.com/?target=http%3A//mysql.taobao.org/monthly/2016/07/08\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">mysql.taobao.org/monthl</span><span class=\"invisible\">y/2016/07/08</span><span class=\"ellipsis\"></span></a></blockquote><h3>7、提前缩小范围</h3><p>先上初始 SQL 语句：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    my_order o\nLEFT JOIN my_userinfo u ON o.uid = u.uid\nLEFT JOIN my_productinfo p ON o.pid = p.pid\nWHERE\n    (o.display = 0)\nAND (o.ostaus = 1)\nORDER BY\n    o.selltime DESC\nLIMIT 0,\n 15\n</code></pre></div><p>该SQL语句原意是：先做一系列的左连接，然后排序取前15条记录。从执行计划也可以看出，最后一步估算排序记录数为90万，时间消耗为12秒。</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+\n| id | select_type | table | type   | possible_keys | key     | key_len | ref             | rows   | Extra                                              |\n+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+\n|  1 | SIMPLE      | o     | ALL    | NULL          | NULL    | NULL    | NULL            | 909119 | Using where; Using temporary; Using filesort       |\n|  1 | SIMPLE      | u     | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |\n|  1 | SIMPLE      | p     | ALL    | PRIMARY       | NULL    | NULL    | NULL            |      6 | Using where; Using join buffer (Block Nested Loop) |\n+----+-------------+-------+--------+---------------+---------+---------+-----------------+--------+----------------------------------------------------+\n</code></pre></div><p>由于最后 WHERE 条件以及排序均针对最左主表，因此可以先对 my_order 排序提前缩小数据量再做左连接。SQL 重写后如下，执行时间缩小为1毫秒左右。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    *\nFROM\n    (\n        SELECT\n            *\n        FROM\n            my_order o\n        WHERE\n            (o.display = 0)\n        AND (o.ostaus = 1)\n        ORDER BY\n            o.selltime DESC\n        LIMIT 0,\n        15\n    ) o\nLEFT JOIN my_userinfo u ON o.uid = u.uid\nLEFT JOIN my_productinfo p ON o.pid = p.pid\nORDER BY\n    o.selltime DESC\nLIMIT 0,\n 15\n</code></pre></div><p>再检查执行计划：子查询物化后（select_type=DERIVED)参与 JOIN。虽然估算行扫描仍然为90万，但是利用了索引以及 LIMIT 子句后，实际执行时间变得很小。</p><div class=\"highlight\"><pre><code class=\"language-text\">+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+\n| id | select_type | table      | type   | possible_keys | key     | key_len | ref   | rows   | Extra                                              |\n+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+\n|  1 | PRIMARY     | &lt;derived2&gt; | ALL    | NULL          | NULL    | NULL    | NULL  |     15 | Using temporary; Using filesort                    |\n|  1 | PRIMARY     | u          | eq_ref | PRIMARY       | PRIMARY | 4       | o.uid |      1 | NULL                                               |\n|  1 | PRIMARY     | p          | ALL    | PRIMARY       | NULL    | NULL    | NULL  |      6 | Using where; Using join buffer (Block Nested Loop) |\n|  2 | DERIVED     | o          | index  | NULL          | idx_1   | 5       | NULL  | 909112 | Using where                                        |\n+----+-------------+------------+--------+---------------+---------+---------+-------+--------+----------------------------------------------------+\n</code></pre></div><h3>8、中间结果集下推</h3><p>再来看下面这个已经初步优化过的例子(左连接中的主表优先作用查询条件)：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    a.*, c.allocated\nFROM\n    (\n        SELECT\n            resourceid\n        FROM\n            my_distribute d\n        WHERE\n            isdelete = 0\n        AND cusmanagercode = &#39;1234567&#39;\n        ORDER BY\n            salecode\n        LIMIT 20\n    ) a\nLEFT JOIN (\n    SELECT\n        resourcesid， sum(ifnull(allocation, 0) * 12345) allocated\n    FROM\n        my_resources\n    GROUP BY\n        resourcesid\n) c ON a.resourceid = c.resourcesid\n</code></pre></div><p>那么该语句还存在其它问题吗？不难看出子查询 c 是全表聚合查询，在表数量特别大的情况下会导致整个语句的性能下降。</p><p>其实对于子查询 c，左连接最后结果集只关心能和主表 resourceid 能匹配的数据。因此我们可以重写语句如下，执行时间从原来的2秒下降到2毫秒。</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT\n    a.*, c.allocated\nFROM\n    (\n        SELECT\n            resourceid\n        FROM\n            my_distribute d\n        WHERE\n            isdelete = 0\n        AND cusmanagercode = &#39;1234567&#39;\n        ORDER BY\n            salecode\n        LIMIT 20\n    ) a\nLEFT JOIN (\n    SELECT\n        resourcesid， sum(ifnull(allocation, 0) * 12345) allocated\n    FROM\n        my_resources r,\n        (\n            SELECT\n                resourceid\n            FROM\n                my_distribute d\n            WHERE\n                isdelete = 0\n            AND cusmanagercode = &#39;1234567&#39;\n            ORDER BY\n                salecode\n            LIMIT 20\n        ) a\n    WHERE\n        r.resourcesid = a.resourcesid\n    GROUP BY\n        resourcesid\n) c ON a.resourceid = c.resourcesid\n</code></pre></div><p>但是子查询 a 在我们的SQL语句中出现了多次。这种写法不仅存在额外的开销，还使得整个语句显的繁杂。使用 WITH 语句再次重写：</p><div class=\"highlight\"><pre><code class=\"language-text\">WITH a AS (\n    SELECT\n        resourceid\n    FROM\n        my_distribute d\n    WHERE\n        isdelete = 0\n    AND cusmanagercode = &#39;1234567&#39;\n    ORDER BY\n        salecode\n    LIMIT 20\n) SELECT\n    a.*, c.allocated\nFROM\n    a\nLEFT JOIN (\n    SELECT\n        resourcesid， sum(ifnull(allocation, 0) * 12345) allocated\n    FROM\n        my_resources r,\n        a\n    WHERE\n        r.resourcesid = a.resourcesid\n    GROUP BY\n        resourcesid\n) c ON a.resourceid = c.resourcesid\n</code></pre></div><h3>总结</h3><p>数据库编译器产生执行计划，决定着SQL的实际执行方式。但是编译器只是尽力服务，所有数据库的编译器都不是尽善尽美的。</p><p>上述提到的多数场景，在其它数据库中也存在性能问题。了解数据库编译器的特性，才能避规其短处，写出高性能的SQL语句。</p><p>程序员在设计数据模型以及编写SQL语句时，要把算法的思想或意识带进来。</p><p>编写复杂SQL语句要养成使用 WITH 语句的习惯。简洁且思路清晰的SQL语句也能减小数据库的负担 。</p>", 
            "topic": [
                {
                    "tag": "SQL 语句", 
                    "tagLink": "https://api.zhihu.com/topics/19575650"
                }, 
                {
                    "tag": "SQL优化", 
                    "tagLink": "https://api.zhihu.com/topics/19644211"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61100283", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 4, 
            "title": "老大难的空指针，如何优雅处理？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d0f89eabf7f69ad627156ad64a78c1d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic3.zhimg.com/v2-d0f89eabf7f69ad627156ad64a78c1d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic3.zhimg.com/v2-d0f89eabf7f69ad627156ad64a78c1d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d0f89eabf7f69ad627156ad64a78c1d2_b.jpg\"/></figure><h3><b>导语</b><br/></h3><blockquote>在笔者几年的开发经验中，经常看到项目中存在到处空值判断的情况，这些判断，会让人觉得摸不这头绪，它的出现很有可能和当前的业务逻辑并没有关系。但它会让你很头疼。<br/>有时候，更可怕的是系统因为这些空值的情况，会抛出空指针异常，导致业务系统发生问题。<br/>此篇文章，我总结了几种关于空值的处理手法，希望对读者有帮助。</blockquote><h3><b>业务中的空值</b></h3><h2><b>场景</b></h2><p>存在一个UserSearchService用来提供用户查询的功能:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserSearchService{\n  List&lt;User&gt; listUser();\n\n  User get(Integer id);\n}\n</code></pre></div><h2><b>问题现场</b></h2><p>对于面向对象语言来讲，抽象层级特别的重要。尤其是对接口的抽象，它在设计和开发中占很大的比重，我们在开发时希望尽量面向接口编程。<br/>对于以上描述的接口方法来看，大概可以推断出可能它包含了以下两个含义:</p><p>listUser(): 查询用户列表</p><p>get(Integer id): 查询单个用户</p><p>在所有的开发中，XP推崇的TDD模式可以很好的引导我们对接口的定义，所以我们将TDD作为开发代码的”推动者”。<br/>对于以上的接口，当我们使用TDD进行测试用例先行时，发现了潜在的问题：</p><p>listUser() 如果没有数据，那它是返回空集合还是null呢？</p><p>get(Integer id) 如果没有这个对象，是抛异常还是返回null呢？</p><p>深入listUser研究<br/>我们先来讨论</p><div class=\"highlight\"><pre><code class=\"language-text\">listUser()\n</code></pre></div><p>这个接口，我经常看到如下实现:</p><div class=\"highlight\"><pre><code class=\"language-text\">public List&lt;User&gt; listUser(){\n    List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample());\n    if(CollectionUtils.isEmpty(userList)){//spring util工具类\n      return null;\n    }\n    return userList;\n}\n</code></pre></div><p>这段代码返回是null,从我多年的开发经验来讲，对于集合这样返回值，最好不要返回null，因为如果返回了null，会给调用者带来很多麻烦。你将会把这种调用风险交给调用者来控制。<br/>如果调用者是一个谨慎的人，他会进行是否为null的条件判断。如果他并非谨慎，或者他是一个面向接口编程的狂热分子(当然，面向接口编程是正确的方向)，他会按照自己的理解去调用接口，而不进行是否为null的条件判断，如果这样的话，是非常危险的，它很有可能出现空指针异常！<br/>根据墨菲定律来判断: “很有可能出现的问题，在将来一定会出现!”</p><p>基于此，我们将它进行优化:</p><div class=\"highlight\"><pre><code class=\"language-text\">public List&lt;User&gt; listUser(){\n    List&lt;User&gt; userList = userListRepostity.selectByExample(new UserExample());\n    if(CollectionUtils.isEmpty(userList)){\n      return Lists.newArrayList();//guava类库提供的方式\n    }\n    return userList;\n}\n</code></pre></div><p>对于接口(List listUser())，它一定会返回List，即使没有数据，它仍然会返回List（集合中没有任何元素）;<br/>通过以上的修改，我们成功的避免了有可能发生的空指针异常，这样的写法更安全！</p><h2><b>深入研究get方法</b></h2><p>对于接口</p><div class=\"highlight\"><pre><code class=\"language-text\">User get(Integer id)\n</code></pre></div><p>你能看到的现象是，我给出id，它一定会给我返回User.但事实真的很有可能不是这样的。</p><p>我看到过的实现:</p><div class=\"highlight\"><pre><code class=\"language-text\">public User get(Integer id){\n  return userRepository.selectByPrimaryKey(id);//从数据库中通过id直接获取实体对象\n}\n</code></pre></div><p>相信很多人也都会这样写。<br/>通过代码的时候得知它的返回值很有可能是null! 但我们通过的接口是分辨不出来的!<br/>这个是个非常危险的事情。尤其对于调用者来说！</p><p>我给出的建议是，需要在接口明明时补充文档,比如对于异常的说明,使用注解@exception:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserSearchService{\n\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体\n   * @exception UserNotFoundException\n   */\n  User get(Integer id);\n\n}\n</code></pre></div><p>我们把接口定义加上了说明之后，调用者会看到，如果调用此接口，很有可能抛出“UserNotFoundException(找不到用户)”这样的异常。</p><p>这种方式可以在调用者调用接口的时候看到接口的定义，但是，这种方式是”弱提示”的！<br/>如果调用者忽略了注释，有可能就对业务系统产生了风险，这个风险有可能导致一个亿！</p><p>除了以上这种”弱提示”的方式，还有一种方式是，返回值是有可能为空的。那要怎么办呢？<br/>我认为我们需要增加一个接口，用来描述这种场景.<br/>引入jdk8的Optional,或者使用guava的Optional.看如下定义:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserSearchService{\n\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体,此实体有可能是缺省值\n   */\n  Optional&lt;User&gt; getOptional(Integer id);\n}\n</code></pre></div><p>Optional有两个含义: 存在 or 缺省。</p><p>那么通过阅读接口getOptional()，我们可以很快的了解返回值的意图，这个其实是我们想看到的，它去除了二义性。</p><p>它的实现可以写成:</p><div class=\"highlight\"><pre><code class=\"language-text\">public Optional&lt;User&gt; getOptional(Integer id){\n  return Optional.ofNullable(userRepository.selectByPrimaryKey(id));\n}\n</code></pre></div><h2><b>深入入参</b></h2><p>通过上述的所有接口的描述，你能确定入参id一定是必传的吗？ 我觉得答案应该是：不能确定。除非接口的文档注释上加以说明。</p><p>那如何约束入参呢?</p><p>我给大家推荐两种方式：</p><ol><li>强制约束</li><li>文档性约束（弱提示）</li></ol><p>1.强制约束，我们可以通过jsr 303进行严格的约束声明:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserSearchService{\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体\n   * @exception UserNotFoundException\n   */\n  User get(@NotNull Integer id);\n\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体,此实体有可能是缺省值\n   */\n  Optional&lt;User&gt; getOptional(@NotNull Integer id);\n}\n</code></pre></div><p>当然，这样写，要配合AOP的操作进行验证，但让spring已经提供了很好的集成方案，在此我就不在赘述了。</p><p>2.文档性约束</p><p>在很多时候，我们会遇到遗留代码，对于遗留代码，整体性改造的可能性很小。<br/>我们更希望通过阅读接口的实现，来进行接口的说明。<br/>jsr 305规范，给了我们一个描述接口入参的一个方式(需要引入库 com.google.code.findbugs:jsr305):</p><p>可以使用注解: @Nullable @Nonnull @CheckForNull 进行接口说明。<br/>比如:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserSearchService{\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体\n   * @exception UserNotFoundException\n   */\n  @CheckForNull\n  User get(@NonNull Integer id);\n\n  /**\n   * 根据用户id获取用户信息\n   * @param id 用户id\n   * @return 用户实体,此实体有可能是缺省值\n   */\n  Optional&lt;User&gt; getOptional(@NonNull Integer id);\n}\n</code></pre></div><h2><b>小结</b></h2><p>通过 空集合返回值,Optional,jsr 303，jsr 305这几种方式，可以让我们的代码可读性更强，出错率更低！</p><ol><li>空集合返回值 ： 如果有集合这样返回值时，除非真的有说服自己的理由，否则，一定要返回空集合，而不是null</li><li>Optional: 如果你的代码是jdk8，就引入它！ 如果不是，则使用Guava的Optional,或者升级jdk版本！ 它很大程度的能增加了接口的可读性！</li><li>jsr 303: 如果新的项目正在开发，不防加上这个试试！ 一定有一种特别爽的感觉!</li><li>jsr 305: 如果老的项目在你的手上，你可以尝试的加上这种文档型注解，有助于你后期的重构，或者新功能增加了，对于老接口的理解!</li></ol><h3><b>空对象模式</b></h3><h2><b>场景</b></h2><p>我们来看一个DTO转化的场景，对象:</p><div class=\"highlight\"><pre><code class=\"language-text\">@Data\nstatic class PersonDTO{\n  private String dtoName;\n  private String dtoAge;\n}\n\n@Data\nstatic class Person{\n  private String name;\n  private String age;\n}\n</code></pre></div><p>需求是将Person对象转化成PersonDTO，然后进行返回。<br/>当然对于实际操作来讲，返回如果Person为空，将返回null,但是PersonDTO是不能返回null的（尤其Rest接口返回的这种DTO）。<br/>在这里，我们只关注转化操作，看如下代码:</p><div class=\"highlight\"><pre><code class=\"language-text\">@Test\npublic void shouldConvertDTO(){\n\n  PersonDTO personDTO = new PersonDTO();\n\n  Person person = new Person();\n  if(!Objects.isNull(person)){\n    personDTO.setDtoAge(person.getAge());\n    personDTO.setDtoName(person.getName());\n  }else{\n    personDTO.setDtoAge(&#34;&#34;);\n    personDTO.setDtoName(&#34;&#34;);\n  }\n}\n</code></pre></div><h2><b>优化修改</b></h2><p>这样的数据转化，我们认识可读性非常差，每个字段的判断，如果是空就设置为空字符串(“”)</p><p>换一种思维方式进行思考，我们是拿到Person这个类的数据，然后进行赋值操作(setXXX),其实是不关系Person的具体实现是谁的。</p><p>那我们可以创建一个Person子类:</p><div class=\"highlight\"><pre><code class=\"language-text\">static class NullPerson extends Person{\n  @Override\n  public String getAge() {\n    return &#34;&#34;;\n  }\n\n  @Override\n  public String getName() {\n    return &#34;&#34;;\n  }\n}\n</code></pre></div><p>它作为Person的一种特例而存在，如果当Person为空的时候，则返回一些get*的默认行为.</p><p>所以代码可以修改为:</p><div class=\"highlight\"><pre><code class=\"language-text\">@Test\n public void shouldConvertDTO(){\n\n   PersonDTO personDTO = new PersonDTO();\n\n   Person person = getPerson();\n   personDTO.setDtoAge(person.getAge());\n   personDTO.setDtoName(person.getName());\n }\n\n private Person getPerson(){\n   return new NullPerson();//如果Person是null ,则返回空对象\n }\n</code></pre></div><p>其中getPerson()方法，可以用来根据业务逻辑获取Person有可能的对象（对当前例子来讲，如果Person不存在，返回Person的的特例NUllPerson），如果修改成这样，代码的可读性就会变的很强了。</p><p>使用Optional可以进行优化<br/>空对象模式，它的弊端在于需要创建一个特例对象，但是如果特例的情况比较多，我们是不是需要创建多个特例对象呢，虽然我们也使用了面向对象的多态特性，但是，业务的复杂性如果真的让我们创建多个特例对象，我们还是要再三考虑一下这种模式，它可能会带来代码的复杂性。</p><p>对于上述代码，还可以使用Optional进行优化。</p><div class=\"highlight\"><pre><code class=\"language-text\">@Test\n  public void shouldConvertDTO(){\n\n    PersonDTO personDTO = new PersonDTO();\n\n    Optional.ofNullable(getPerson()).ifPresent(person -&gt; {\n      personDTO.setDtoAge(person.getAge());\n      personDTO.setDtoName(person.getName());\n    });\n  }\n\n  private Person getPerson(){\n    return null;\n  }\n</code></pre></div><p>Optional对空值的使用，我觉得更为贴切，它只适用于”是否存在”的场景。<br/>如果只对控制的存在判断，我建议使用Optional.</p><h2><b>Optioanl的正确使用</b></h2><p>Optional如此强大，它表达了计算机最原始的特性(0 or 1),那它如何正确的被使用呢!</p><h2><b>Optional不要作为参数</b></h2><p>如果你写了一个public方法，这个方法规定了一些输入参数，这些参数中有一些是可以传入null的，那这时候是否可以使用Optional呢？</p><p>我给的建议是: 一定不要这样使用!</p><p>举个例子:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserService{\n  List&lt;User&gt; listUser(Optional&lt;String&gt; username);\n}\n</code></pre></div><p>这个例子的方法 listUser,可能在告诉我们需要根据username查询所有数据集合，如果username是空，也要返回所有的用户集合.</p><p>当我们看到这个方法的时候，会觉得有一些歧义:</p><p>“如果username是absent,是返回空集合吗？还是返回全部的用户数据集合？”</p><p>Optioanl是一种分支的判断，那我们究竟是关注 Optional还是Optional.get()呢？</p><p>我给大家的建议是，如果不想要这样的歧义，就不要使用它！</p><p>如果你真的想表达两个含义，就給它拆分出两个接口:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserService{\n  List&lt;User&gt; listUser(String username);\n  List&lt;User&gt; listUser();\n}\n</code></pre></div><p>我觉得这样的语义更强，并且更能满足 软件设计原则中的 “单一职责”。</p><p>如果你觉得你的入参真的有必要可能传null,那请使用jsr 303或者jsr 305进行说明和验证!</p><p>请记住! Optional不能作为入参的参数!</p><h2><b>Optional作为返回值</b></h2><h3><b>当个实体的返回</b></h3><p>那Optioanl可以做为返回值吗？<br/>其实它是非常满足是否存在这个语义的。</p><p>你如说，你要根据id获取用户信息，这个用户有可能存在或者不存在。</p><p>你可以这样使用:</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserService{\n  Optional&lt;User&gt; get(Integer id);\n}\n</code></pre></div><p>当调用这个方法的时候，调用者很清楚get方法返回的数据，有可能不存在，这样可以做一些更合理的判断，更好的防止空指针的错误！</p><p>当然，如果业务方真的需要根据id必须查询出User的话，就不要这样使用了，请说明，你要抛出的异常.</p><p>只有当考虑它返回null是合理的情况下，才进行Optional的返回</p><h2><b>集合实体的返回</b></h2><p>不是所有的返回值都可以这样用的！ 如果你返回的是集合：</p><div class=\"highlight\"><pre><code class=\"language-text\">public interface UserService{\n  Optional&lt;List&lt;User&gt;&gt; listUser();\n}\n</code></pre></div><p>这样的返回结果，会让调用者不知所措，是否我判断Optional之后，还用进行isEmpty的判断呢？</p><p>这样带来的返回值歧义！ 我认为是没有必要的。</p><p>我们要约定，对于List这种集合返回值，如果集合真的是null的，请返回空集合(Lists.newArrayList);</p><h2><b>使用Optional变量</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">Optional&lt;User&gt; userOpt = ...</code></pre></div><p>如果有这样的变量userOpt,请记住 ：</p><p>一定不能直接使用get ，如果这样用，就丧失了Optional本身的含义 （ 比如userOp.get() ）</p><p>不要直接使用getOrThrow ,如果你有这样的需求：获取不到就抛异常。 那就要考虑，是否是调用的接口设计的是否合理</p><h2><b>getter中的使用</b></h2><p>对于一个java bean,所有的属性都有可能返回null,那是否需要改写所有的getter成为Optional类型呢？</p><p>我给大家的建议是，不要这样滥用Optional.</p><p>即便 我java bean中的getter是符合Optional的，但是因为java bean 太多了，这样会导致你的代码有50%以上进行Optinal的判断，这样便污染了代码。(我想说，其实你的实体中的字段应该都是由业务含义的，会认真的思考过它存在的价值的，不能因为Optional的存在而滥用)</p><p>我们应该更关注于业务，而不只是空值的判断。</p><p>请不要在getter中滥用Optional.</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "异常处理", 
                    "tagLink": "https://api.zhihu.com/topics/19841423"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61099874", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 16, 
            "title": "全面了解Java中的15种锁概念及机制！", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a64c0dfc19b016d4c0e38bbbaeed5523_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic4.zhimg.com/v2-a64c0dfc19b016d4c0e38bbbaeed5523_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;634&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic4.zhimg.com/v2-a64c0dfc19b016d4c0e38bbbaeed5523_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a64c0dfc19b016d4c0e38bbbaeed5523_b.jpg\"/></figure><p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：<br/></p><p>1.公平锁 / 非公平锁</p><p>2.可重入锁 / 不可重入锁</p><p>3.独享锁 / 共享锁</p><p>4.互斥锁 / 读写锁</p><p>5.乐观锁 / 悲观锁</p><p>6.分段锁</p><p>7.偏向锁 / 轻量级锁 / 重量级锁</p><p>8.自旋锁</p><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><h2><b>公平锁/非公平锁</b></h2><p><b>公平锁</b></p><p>公平锁是指多个线程按照申请锁的顺序来获取锁。</p><p><b>非公平锁</b></p><p>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。</p><p>对于<code>Java ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br/>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过<code>AQS</code>的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2><b>可重入锁/不可重入锁</b></h2><p><b>可重入锁</b><br/></p><p>广义上的可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。<code>ReentrantLock</code>和<code>synchronized</code>都是可重入锁</p><div class=\"highlight\"><pre><code class=\"language-text\">synchronized void setA() throws Exception{\n   Thread.sleep(1000);\n   setB();\n}\nsynchronized void setB() throws Exception{\n   Thread.sleep(1000);\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的代码就是一个可重入锁的一个特点，如果不是可重入锁的话，setB可能不会被当前线程执行，可能造成死锁。</p><p><b>不可重入锁</b></p><p>不可重入锁，与可重入锁相反，不可递归调用，递归调用就发生死锁。看到一个经典的讲解，使用自旋锁来模拟一个不可重入锁，代码如下:</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.concurrent.atomic.AtomicReference;\n\npublic class UnreentrantLock {\n\n   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();\n\n   public void lock() {\n       Thread current = Thread.currentThread();\n       //这句是很经典的“自旋”语法，AtomicInteger中也有\n       for (;;) {\n           if (!owner.compareAndSet(null, current)) {\n               return;\n           }\n       }\n   }\n\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       owner.compareAndSet(current, null);\n   }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>代码也比较简单，使用原子引用来存放线程，同一线程两次调用lock()方法，如果不执行unlock()释放锁的话，第二次调用自旋的时候就会产生死锁，这个锁就不是可重入的，而实际上同一个线程不必每次都去释放锁再来获取锁，这样的调度切换是很耗资源的。</p><p><b>把它变成一个可重入锁</b>：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.concurrent.atomic.AtomicReference;\n\npublic class UnreentrantLock {\n\n   private AtomicReference&lt;Thread&gt; owner = new AtomicReference&lt;Thread&gt;();\n   private int state = 0;\n\n   public void lock() {\n       Thread current = Thread.currentThread();\n       if (current == owner.get()) {\n           state++;\n           return;\n       }\n       //这句是很经典的“自旋”式语法，AtomicInteger中也有\n       for (;;) {\n           if (!owner.compareAndSet(null, current)) {\n               return;\n           }\n       }\n   }\n\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       if (current == owner.get()) {\n           if (state != 0) {\n               state--;\n           } else {\n               owner.compareAndSet(current, null);\n           }\n       }\n   }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>在执行每次操作之前，判断当前锁持有者是否是当前对象，采用state计数，不用每次去释放锁。</p><p><b>ReentrantLock中可重入锁实现</b></p><p>这里看非公平锁的锁获取方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">final boolean nonfairTryAcquire(int acquires) {\n   final Thread current = Thread.currentThread();\n   int c = getState();\n   if (c == 0) {\n       if (compareAndSetState(0, acquires)) {\n           setExclusiveOwnerThread(current);\n           return true;\n       }\n   }\n   //就是这里\n   else if (current == getExclusiveOwnerThread()) {\n       int nextc = c + acquires;\n       if (nextc &lt; 0) // overflow\n           throw new Error(&#34;Maximum lock count exceeded&#34;);\n       setState(nextc);\n       return true;\n   }\n   return false;\n}</code></pre></div><p>在AQS中维护了一个private volatile int state来计数重入次数，避免了频繁的持有释放操作，这样既提升了效率，又避免了死锁。</p><h2><b>独享锁/共享锁</b></h2><h2>独享锁和共享锁在你去读C.U.T包下的ReeReentrantLock和ReentrantReadWriteLock你就会发现，它俩一个是独享一个是共享锁。<br/></h2><p><b>独享锁</b>：该锁每一次只能被一个线程所持有。</p><p><b>共享锁</b>：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。</p><p>另外读锁的共享可保证并发读是非常高效的，但是读写和写写，写读都是互斥的。</p><p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。<br/>对于Synchronized而言，当然是独享锁。</p><h2><b>互斥锁/读写锁</b></h2><p><b>互斥锁</b></p><p>在访问共享资源之前对进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。</p><p>如果解锁时有一个以上的线程阻塞，那么所有该锁上的线程都被编程就绪状态， 第一个变为就绪状态的线程又执行加锁操作，那么其他的线程又会进入等待。 在这种方式下，只有一个线程能够访问被互斥锁保护的资源。</p><p><b>读写锁</b></p><p>读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的。</p><p><b>读写锁有三种状态</b>：读加锁状态、写加锁状态和不加锁状态</p><p><b>读写锁在Java中的具体实现就是</b><code>ReadWriteLock</code></p><p>一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁。推荐：<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzUyNDc0NjM0Nw%3D%3D%26mid%3D2247483774%26idx%3D4%26sn%3Dbebf3a4105dc8cc74254ca8b236ff161%26chksm%3Dfa29ea7acd5e636cb26863d113d6720bc8d12870a779793beaaf0bebc5e78f524199edcf691c%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一文横扫Java锁相关的所有知识点！</a><br/>只有一个线程可以占有写状态的锁，但可以有多个线程同时占有读状态锁，这也是它可以实现高并发的原因。当其处于写状态锁下，任何想要尝试获得锁的线程都会被阻塞，直到写状态锁被释放；如果是处于读状态锁下，允许其它线程获得它的读状态锁，但是不允许获得它的写状态锁，直到所有线程的读状态锁被释放；为了避免想要尝试写操作的线程一直得不到写状态锁，当读写锁感知到有线程想要获得写状态锁时，便会阻塞其后所有想要获得读状态锁的线程。所以读写锁非常适合资源的读操作远多于写操作的情况。</p><h2><b>乐观锁/悲观锁</b></h2><p><b>悲观锁</b></p><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（<b>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</b>）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。<code>Java</code>中<code>synchronized</code>和<code>ReentrantLock</code>等独占锁就是悲观锁思想的实现。</p><p><b>乐观锁</b></p><p>总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐<b>观锁适用于多读的应用类型，这样可以提高吞吐量</b>，像数据库提供的类似于<code>write_condition</code>机制，其实都是提供的乐观锁。在<code>Java</code>中<code>java.util.concurrent.atomic</code>包下面的<b>原子变量类就是使用了乐观锁的一种实现方式CAS实现的</b>。推荐：<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzUyNDc0NjM0Nw%3D%3D%26mid%3D2247483774%26idx%3D4%26sn%3Dbebf3a4105dc8cc74254ca8b236ff161%26chksm%3Dfa29ea7acd5e636cb26863d113d6720bc8d12870a779793beaaf0bebc5e78f524199edcf691c%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一文横扫Java锁相关的所有知识点！</a></p><h2><b>分段锁</b></h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code>而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>并发容器类的加锁机制是基于粒度更小的分段锁，分段锁也是提升多并发程序性能的重要手段之一。</p><p>在并发程序中，串行操作是会降低可伸缩性，并且上下文切换也会减低性能。在锁上发生竞争时将通水导致这两种问题，使用独占锁时保护受限资源的时候，基本上是采用串行方式—-每次只能有一个线程能访问它。所以对于可伸缩性来说最大的威胁就是独占锁。</p><p><b>我们一般有三种方式降低锁的竞争程度</b>： <br/>1、减少锁的持有时间 <br/>2、降低锁的请求频率 <br/>3、使用带有协调机制的独占锁，这些机制允许更高的并发性。</p><p>在某些情况下我们可以将锁分解技术进一步扩展为一组独立对象上的锁进行分解，这成为分段锁。</p><p><b>其实说的简单一点就是</b>：</p><p>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效的提高并发访问效率，这就是<code>ConcurrentHashMap</code>所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>比如：在ConcurrentHashMap中使用了一个包含16个锁的数组，每个锁保护所有散列桶的1/16，其中第N个散列桶由第（N mod 16）个锁来保护。假设使用合理的散列算法使关键字能够均匀的分部，那么这大约能使对锁的请求减少到越来的1/16。也正是这项技术使得ConcurrentHashMap支持多达16个并发的写入线程。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>偏向锁/轻量级锁/重要级锁</b></h2><p><b>锁的状态</b>：</p><p>1.无锁状态</p><p>2.偏向锁状态</p><p>3.轻量级锁状态</p><p>4.重量级锁状态</p><p>锁的状态是通过对象监视器在对象头中的字段来表明的。<br/>四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。<br/><b>这四种状态都不是Java语言中的锁</b>，而是Jvm为了提高锁的获取与释放效率而做的优化(<b>使用synchronized时</b>)。</p><p><b>偏向锁</b></p><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p><p><b>轻量级</b></p><p>轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p><p><b>重量级锁</b></p><p>重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p><h2><b>自旋锁</b></h2><h2>我们知道CAS算法是乐观锁的一种实现方式，CAS算法中又涉及到自旋锁，所以这里给大家讲一下什么是自旋锁。</h2><h3><b>简单回顾一下CAS算法</b></h3><p><code>CAS</code>是英文单词<code>Compare and Swap</code>（比较并交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（<code>Non-blocking Synchronization</code>）。CAS算法涉及到三个操作数</p><p>1.需要读写的内存值 V</p><p>2.进行比较的值 A</p><p>3.拟写入的新值 B</p><p>更新一个变量的时候，只有当变量的预期值A和内存地址V当中的实际值相同时，才会将内存地址V对应的值修改为B，否则不会执行任何操作。一般情况下是一个自旋操作，即不断的重试。</p><h3><b>什么是自旋锁？</b></h3><p><b>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环</b>。</p><p>它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。<b>无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁</b>。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。</p><h3><b>Java如何实现自旋锁？</b></h3><p>下面是个简单的例子：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public class SpinLock {\n   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();\n   public void lock() {\n       Thread current = Thread.currentThread();\n       // 利用CAS\n       while (!cas.compareAndSet(null, current)) {\n           // DO nothing\n       }\n   }\n   public void unlock() {\n       Thread current = Thread.currentThread();\n       cas.compareAndSet(current, null);\n   }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>lock（)方法利用的CAS，当第一个线程A获取锁的时候，能够成功获取到，不会进入while循环，如果此时线程A没有释放锁，另一个线程B又来获取锁，此时由于不满足CAS，所以就会进入while循环，不断判断是否满足CAS，直到A线程调用unlock方法释放了该锁。</p><h3><b>自旋锁存在的问题</b></h3><p>1、如果某个线程持有锁的时间过长，就会导致其它等待获取锁的线程进入循环等待，消耗CPU。使用不当会造成CPU使用率极高。<br/>2、上面Java实现的自旋锁不是公平的，即无法满足等待时间最长的线程优先获取锁。不公平的锁就会存在“线程饥饿”问题。</p><h3><b>自旋锁的优点</b></h3><p>1、自旋锁不会使线程状态发生切换，一直处于用户态，即线程一直都是active的；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br/>2、非自旋锁在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换。 （线程被阻塞后便进入内核（Linux）调度状态，这个会导致系统在用户态与内核态之间来回切换，严重影响锁的性能）</p><h3><b>可重入的自旋锁和不可重入的自旋锁</b></h3><p>文章开始的时候的那段代码，仔细分析一下就可以看出，它是不支持重入的，即当一个线程第一次已经获取到了该锁，在锁释放之前又一次重新获取该锁，第二次就不能成功获取到。由于不满足CAS，所以第二次获取会进入while循环等待，而如果是可重入锁，第二次也是应该能够成功获取到的。</p><p>而且，即使第二次能够成功获取，那么当第一次释放锁的时候，第二次获取到的锁也会被释放，而这是不合理的。</p><p>为了实现可重入锁，我们需要引入一个计数器，用来记录获取锁的线程数。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ReentrantSpinLock {\n   private AtomicReference&lt;Thread&gt; cas = new AtomicReference&lt;Thread&gt;();\n   private int count;\n   public void lock() {\n       Thread current = Thread.currentThread();\n       if (current == cas.get()) { // 如果当前线程已经获取到了锁，线程数增加一，然后返回\n           count++;\n           return;\n       }\n       // 如果没获取到锁，则通过CAS自旋\n       while (!cas.compareAndSet(null, current)) {\n           // DO nothing\n       }\n   }\n   public void unlock() {\n       Thread cur = Thread.currentThread();\n       if (cur == cas.get()) {\n           if (count &gt; 0) {// 如果大于0，表示当前线程多次获取了该锁，释放锁通过count减一来模拟\n               count--;\n           } else {// 如果count==0，可以将锁释放，这样就能保证获取锁的次数与释放锁的次数是一致的了。\n               cas.compareAndSet(cur, null);\n           }\n       }\n   }\n}</code></pre></div><h3><b>自旋锁与互斥锁</b></h3><p>1.自旋锁与互斥锁都是为了实现保护资源共享的机制。</p><p>2.无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。</p><p>3获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。</p><h3><b>自旋锁总结</b></h3><p>1.自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。</p><p>2.自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。</p><p>3.自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。</p><p>4.自旋锁本身无法保证公平性，同时也无法保证可重入性。</p><p>5.基于自旋锁，可以实现具备公平性和可重入性质的锁。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61099521", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "14个实用的数据库设计技巧！", 
            "content": "<figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-db5405981e3bc2196ee55a14c08146a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-db5405981e3bc2196ee55a14c08146a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-db5405981e3bc2196ee55a14c08146a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-db5405981e3bc2196ee55a14c08146a6_b.jpg\"/></figure><p><b>1. 原始单据与实体之间的关系</b></p><p>可以是一对一、一对多、多对多的关系。在一般情况下，它们是一对一的关系：即一张原始单据对应且只对应一个实体。在特殊情况下，它们可能是一对多或多对一的关系，即一张原始单证对应多个实体，或多张原始单证对应一个实体。这里的实体可以理解为基本表。明确这种对应关系后，对我们设计录入界面大有好处。</p><blockquote>〖例1〗：一份员工履历资料，在人力资源信息系统中，就对应三个基本表：员工基本情况表、社会关系表、工作简历表。这就是“一张原始单证对应多个实体”的典型例子。</blockquote><p><b>2. 主键与外键</b></p><p> 一般而言，一个实体不能既无主键又无外键。在E—R 图中, 处于叶子部位的实体, 可以定义主键，也可以不定义主键(因为它无子孙), 但必须要有外键(因为它有父亲)。</p><p>主键与外键的设计，在全局数据库的设计中，占有重要地位。当全局数据库的设计完成以后，有个美国数据库设计专家说：“键，到处都是键，除了键之外，什么也没有”，这就是他的数据库设计经验之谈，也反映了他对信息系统核心(数据模型)的高度抽象思想。因为：主键是实体的高度抽象，主键与外键的配对，表示实体之间的连接。<br/></p><p><b>3. 基本表的性质</b></p><p>基本表与中间表、临时表不同，因为它具有如下四个特性：</p><p>(1) 原子性。基本表中的字段是不可再分解的。</p><p>(2) 原始性。基本表中的记录是原始数据（基础数据）的记录。</p><p>(3) 演绎性。由基本表与代码表中的数据，可以派生出所有的输出数据。</p><p>(4) 稳定性。基本表的结构是相对稳定的，表中的记录是要长期保存的。</p><p>理解基本表的性质后，在设计数据库时，就能将基本表与中间表、临时表区分开来。</p><p><b>4. 范式标准</b></p><p>基本表及其字段之间的关系, 应尽量满足第三范式。但是，满足第三范式的数据库设计，往往不是最好的设计。为了提高数据库的运行效率，常常需要降低范式标准：适当增加冗余，达到以空间换时间的目的。</p><blockquote>〖例2〗：有一张存放商品的基本表，如表1所示。“金额”这个字段的存在，表明该表的设计不满足第三范式，因为“金额”可以由“单价”乘以“数量”得到，说明“金额”是冗余字段。但是，增加“金额”这个冗余字段，可以提高查询统计的速度，这就是以空间换时间的作法。</blockquote><p>在Rose 2002中，规定列有两种类型：数据列和计算列。“金额”这样的列被称为“计算列”，而“单价”和“数量”这样的列被称为“数据列”。<br/></p><p>表1 商品表的表结构<br/>商品名称 商品型号 单价 数量 金额<br/>电视机 29吋 2,500 40 100,000</p><p><b>5. 通俗地理解三个范式</b></p><p>通俗地理解三个范式，对于数据库设计大有好处。在数据库设计中，为了更好地应用三个范式，就必须通俗地理解三个范式(通俗地理解是够用的理解，并不是最科学最准确的理解)：</p><p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；</p><p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；</p><p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。</p><p>没有冗余的数据库设计可以做到。但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。具体做法是：在概念数据模型设计时遵守第三范式，降低范式标准的工作放到物理数据模型设计时考虑。降低范式就是增加字段，允许冗余。</p><p><b>6. 要善于识别与正确处理多对多的关系</b></p><p>若两个实体之间存在多对多的关系，则应消除这种关系。消除的办法是，在两者之间增加第三个实体。这样，原来一个多对多的关系，现在变为两个一对多的关系。要将原来两个实体的属性合理地分配到三个实体中去。这里的第三个实体，实质上是一个较复杂的关系，它对应一张基本表。一般来讲，数据库设计工具不能识别多对多的关系，但能处理多对多的关系。</p><blockquote>〖例3〗：在“图书馆信息系统”中，“图书”是一个实体，“读者”也是一个实体。这两个实体之间的关系，是一个典型的多对多关系：一本图书在不同时间可以被多个读者借阅，一个读者又可以借多本图书。为此，要在二者之间增加第三个实体，该实体取名为“借还书”，它的属性为：借还时间、借还标志(0表示借书，1表示还书)，另外，它还应该有两个外键(“图书”的主键，“读者”的主键)，使它能与“图书”和“读者”连接。</blockquote><p><b>7. 主键PK的取值方法</b><br/></p><p>PK是供程序员使用的表间连接工具，可以是一无物理意义的数字串, 由程序自动加1来实现。也可以是有物理意义的字段名或字段名的组合。不过前者比后者好。当PK是字段名的组合时，建议字段的个数不要太多，多了不但索引占用空间大，而且速度也慢。</p><p><b>8. 正确认识数据冗余</b></p><p>主键与外键在多表中的重复出现, 不属于数据冗余，这个概念必须清楚，事实上有许多人还不清楚。非键字段的重复出现, 才是数据冗余！而且是一种低级冗余，即重复性的冗余。高级冗余不是字段的重复出现，而是字段的派生出现。</p><blockquote>〖例4〗：商品中的“单价、数量、金额”三个字段，“金额”就是由“单价”乘以“数量”派生出来的，它就是冗余，而且是一种高级冗余。冗余的目的是为了提高处理速度。只有低级冗余才会增加数据的不一致性，因为同一数据，可能从不同时间、地点、角色上多次录入。因此，我们提倡高级冗余(派生性冗余)，反对低级冗余(重复性冗余)。</blockquote><p><b>9. E--R图没有标准答案</b><br/></p><p>信息系统的E--R图没有标准答案，因为它的设计与画法不是惟一的，只要它覆盖了系统需求的业务范围和功能内容，就是可行的。反之要修改E--R图。尽管它没有惟一的标准答案，并不意味着可以随意设计。好的E—R图的标准是：结构清晰、关联简洁、实体个数适中、属性分配合理、没有低级冗余。</p><p><b>10. 视图技术在数据库设计中很有用</b></p><p>与基本表、代码表、中间表不同，视图是一种虚表，它依赖数据源的实表而存在。视图是供程序员使用数据库的一个窗口，是基表数据综合的一种形式, 是数据处理的一种方法，是用户数据保密的一种手段。为了进行复杂处理、提高运算速度和节省存储空间, 视图的定义深度一般不得超过三层。 若三层视图仍不够用, 则应在视图上定义临时表, 在临时表上再定义视图。这样反复交迭定义, 视图的深度就不受限制了。对于某些与国家政治、经济、技术、军事和安全利益有关的信息系统，视图的作用更加重要。这些系统的基本表完成物理设计之后，立即在基本表上建立第一层视图，这层视图的个数和结构，与基本表的个数和结构是完全相同。并且规定，所有的程序员，一律只准在视图上操作。只有数据库管理员，带着多个人员共同掌握的“安全钥匙”，才能直接在基本表上操作。请读者想想：这是为什么？<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3ODcxMzQzMw%3D%3D%26mid%3D2247487061%26idx%3D1%26sn%3D0dfc867eb90bb9f79d45faf3d2a470ec%26chksm%3Deb538b63dc2402754308364cae71988ed083c85fe6b26e01ce1dda5c183065d2199c9c3912c5%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">37 个 MySQL 数据库小技巧</a>，这个推荐看一下。</p><p><b>11. 中间表、报表和临时表</b></p><p>中间表是存放统计数据的表，它是为数据仓库、输出报表或查询结果而设计的，有时它没有主键与外键(数据仓库除外)。临时表是程序员个人设计的，存放临时记录，为个人所用。基表和中间表由DBA维护，临时表由程序员自己用程序自动维护。</p><p><b>12. 完整性约束表现在三个方面</b></p><p>域的完整性：用Check来实现约束，在数据库设计工具中，对字段的取值范围进行定义时，有一个Check按钮，通过它定义字段的值城。参照完整性：用PK、FK、表级触发器来实现。用户定义完整性：它是一些业务规则，用存储过程和触发器来实现。</p><p><b>13. 防止数据库设计打补丁的方法是“三少原则”</b></p><p> (1) 一个数据库中表的个数越少越好。只有表的个数少了，才能说明系统的E--R图少而精，去掉了重复的多余的实体，形成了对客观世界的高度抽象，进行了系统的数据集成，防止了打补丁式的设计；</p><p>(2) 一个表中组合主键的字段个数越少越好。因为主键的作用，一是建主键索引，二是做为子表的外键，所以组合主键的字段个数少了，不仅节省了运行时间，而且节省了索引存储空间；</p><p>(3) 一个表中的字段个数越少越好。只有字段的个数少了，才能说明在系统中不存在数据重复，且很少有数据冗余，更重要的是督促读者学会“列变行”，这样就防止了将子表中的字段拉入到主表中去，在主表中留下许多空余的字段。所谓“列变行”，就是将主表中的一部分内容拉出去，另外单独建一个子表。这个方法很简单，有的人就是不习惯、不采纳、不执行。</p><p>数据库设计的实用原则是：在数据冗余和处理速度之间找到合适的平衡点。“三少”是一个整体概念，综合观点，不能孤立某一个原则。该原则是相对的，不是绝对的。“三多”原则肯定是错误的。试想：若覆盖系统同样的功能，一百个实体(共一千个属性) 的E--R图，肯定比二百个实体(共二千个属性)的E--R图，要好得多。</p><p>提倡“三少”原则，是叫读者学会利用数据库设计技术进行系统的数据集成。数据集成的步骤是将文件系统集成为应用数据库，将应用数据库集成为主题数据库，将主题数据库集成为全局综合数据库。</p><p>集成的程度越高，数据共享性就越强，信息孤岛现象就越少，整个企业信息系统的全局E—R图中实体的个数、主键的个数、属性的个数就会越少。</p><p>提倡“三少”原则的目的，是防止读者利用打补丁技术，不断地对数据库进行增删改，使企业数据库变成了随意设计数据库表的“垃圾堆”，或数据库表的“大杂院”，最后造成数据库中的基本表、代码表、中间表、临时表杂乱无章，不计其数，导致企事业单位的信息系统无法维护而瘫痪。</p><p> “三多”原则任何人都可以做到，该原则是“打补丁方法”设计数据库的歪理学说。“三少”原则是少而精的原则，它要求有较高的数据库设计技巧与艺术，不是任何人都能做到的，因为该原则是杜绝用“打补丁方法”设计数据库的理论依据。</p><p><b>14. 提高数据库运行效率的办法</b></p><p>在给定的系统硬件和系统软件条件下，提高数据库系统的运行效率的办法是：</p><p>(1) 在数据库物理设计时，降低范式，增加冗余, 少用触发器, 多用存储过程。</p><p>(2) 当计算非常复杂、而且记录条数非常巨大时(例如一千万条)，复杂计算要先在数据库外面，以文件系统方式用C++语言计算处理完成之后，最后才入库追加到表中去。这是电信计费系统设计的经验。</p><p> (3) 发现某个表的记录太多，例如超过一千万条，则要对该表进行水平分割。水平分割的做法是，以该表主键PK的某个值为界线，将该表的记录水平分割为两个表。若发现某个表的字段太多，例如超过八十个，则垂直分割该表，将原来的一个表分解为两个表。</p><p> (4) 对数据库管理系统DBMS进行系统优化，即优化各种系统参数，如缓冲区个数。<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3ODcxMzQzMw%3D%3D%26mid%3D2247487061%26idx%3D1%26sn%3D0dfc867eb90bb9f79d45faf3d2a470ec%26chksm%3Deb538b63dc2402754308364cae71988ed083c85fe6b26e01ce1dda5c183065d2199c9c3912c5%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">37 个 MySQL 数据库小技巧</a>，这个推荐看一下。</p><p> (5) 在使用面向数据的SQL语言进行程序设计时，尽量采取优化算法。</p><p> 总之，要提高数据库的运行效率，必须从数据库系统级优化、数据库设计级优化、程序实现级优化，这三个层次上同时下功夫。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上述十四个技巧，是许多人在大量的数据库分析与设计实践中，逐步总结出来的。对于这些经验的运用，读者不能生帮硬套，死记硬背，而要消化理解，实事求是，灵活掌握。并逐步做到：在应用中发展，在发展中应用。</p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "数据库设计", 
                    "tagLink": "https://api.zhihu.com/topics/19614808"
                }, 
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59473860", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 1, 
            "title": "Git工作级快速入门", 
            "content": "<h2>介绍</h2><p>多图预警（多图鄙人的骚操作 大家量‘量’而行），简单上手工作中需要的基础操作，快速教会你在工作用如何快速使用（备注：在这里我用了idea作为演示工具，eclipse其他之类的以后有心再来补充吧）</p><h2>内容介绍</h2><h2>在这里你将看到：</h2><ul><li>浓缩版本的git安装配置</li><li>初始化一个git项目</li><li>拉取项目到本地</li><li>创建本地分支</li><li>本地副本修改之后commit push操作到远端</li><li>本地pull冲突解决</li><li>发起合并请求 文采不好，不想讲太多的原理性东西，也不会。所以在我这里强调直接上手干<br/> <br/> </li></ul><h2>浓缩版本的git安装配置</h2><p>闲话少说，直接安装 ① 360直接装上去 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-64c7df4dfce02356e0add069a4cab226_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"930\" data-rawheight=\"690\" class=\"origin_image zh-lightbox-thumb\" width=\"930\" data-original=\"https://pic3.zhimg.com/v2-64c7df4dfce02356e0add069a4cab226_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;930&#39; height=&#39;690&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"930\" data-rawheight=\"690\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"930\" data-original=\"https://pic3.zhimg.com/v2-64c7df4dfce02356e0add069a4cab226_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-64c7df4dfce02356e0add069a4cab226_b.jpg\"/></figure><p> ② 去官网找（费劲，还要看英文，虽然我能看懂  嘻嘻嘻） - 地址 <a href=\"https://link.zhihu.com/?target=https%3A//git-scm.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">git-scm.com/</span><span class=\"invisible\"></span></a> - 在这里插入图片描述（如果你觉得你要是不理解原理就要死了的那种感觉，我在这里给你吧官方Document圈出来了，自己看吧；要是以后我有兴趣了我可能会把原理拿出来写写，现在就算了） </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7c30506ba0c29a21244689b231a7b3d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"947\" class=\"origin_image zh-lightbox-thumb\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-7c30506ba0c29a21244689b231a7b3d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1920&#39; height=&#39;947&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"947\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-7c30506ba0c29a21244689b231a7b3d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7c30506ba0c29a21244689b231a7b3d1_b.jpg\"/></figure><p> ③ 一些简单的配置（用户名密码ssh什么的，这里面我用我自己的github做个演示） - 桌面右键 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-db05e1e8773e3f24f9ec978378c67edf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1189\" data-rawheight=\"571\" class=\"origin_image zh-lightbox-thumb\" width=\"1189\" data-original=\"https://pic4.zhimg.com/v2-db05e1e8773e3f24f9ec978378c67edf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1189&#39; height=&#39;571&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1189\" data-rawheight=\"571\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1189\" data-original=\"https://pic4.zhimg.com/v2-db05e1e8773e3f24f9ec978378c67edf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-db05e1e8773e3f24f9ec978378c67edf_b.jpg\"/></figure><p> - 命令配置用户名 邮箱</p><div class=\"highlight\"><pre><code class=\"language-text\">$ git config --global user.name sakura#sakura\n$ git config --global user.email sakura@love.com #将用户邮箱设为sakura@love.com</code></pre></div><ul><li>上面的毛毛雨配置好之后下面就是来一个公钥，放到github上就可以拉自己的代码了 命令</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">ssh-keygen -t rsa -C &#34;这里换上你的邮箱&#34;</code></pre></div><p>一路疯狂回车，之后找到电脑的目录：C:\\Users\\LiCunzhi.ssh  把里面的公钥抠出来 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-958932e46f443306b8838120df4dff52_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1249\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb\" width=\"1249\" data-original=\"https://pic3.zhimg.com/v2-958932e46f443306b8838120df4dff52_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1249&#39; height=&#39;402&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1249\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1249\" data-original=\"https://pic3.zhimg.com/v2-958932e46f443306b8838120df4dff52_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-958932e46f443306b8838120df4dff52_b.jpg\"/></figure><p> 打开自己的github </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8846e0163dfd4a147602a907a925ee6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1599\" data-rawheight=\"757\" class=\"origin_image zh-lightbox-thumb\" width=\"1599\" data-original=\"https://pic3.zhimg.com/v2-8846e0163dfd4a147602a907a925ee6e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1599&#39; height=&#39;757&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1599\" data-rawheight=\"757\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1599\" data-original=\"https://pic3.zhimg.com/v2-8846e0163dfd4a147602a907a925ee6e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8846e0163dfd4a147602a907a925ee6e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>初始化一个项目</h2><p>经过上面一系列基础配置，接下来就在github上新建一个项目，就叫它sakura吧 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d317a2e1c023abf5ef84bf071ea9bb41_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1294\" data-rawheight=\"789\" class=\"origin_image zh-lightbox-thumb\" width=\"1294\" data-original=\"https://pic2.zhimg.com/v2-d317a2e1c023abf5ef84bf071ea9bb41_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1294&#39; height=&#39;789&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1294\" data-rawheight=\"789\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1294\" data-original=\"https://pic2.zhimg.com/v2-d317a2e1c023abf5ef84bf071ea9bb41_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d317a2e1c023abf5ef84bf071ea9bb41_b.jpg\"/></figure><p> 把地址扣下来 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f09d4de21faf9e0f50341105522d58ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1729\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb\" width=\"1729\" data-original=\"https://pic2.zhimg.com/v2-f09d4de21faf9e0f50341105522d58ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1729&#39; height=&#39;614&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1729\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1729\" data-original=\"https://pic2.zhimg.com/v2-f09d4de21faf9e0f50341105522d58ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f09d4de21faf9e0f50341105522d58ed_b.jpg\"/></figure><p> 项目初始化结束</p><h2>拉取项目到本地</h2><ul><li>idea要配置了git的安装位置才可以进行项目拉取，就像下面一样 </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7ffac16bc8231f68837138d03556cf87_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic4.zhimg.com/v2-7ffac16bc8231f68837138d03556cf87_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"485\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic4.zhimg.com/v2-7ffac16bc8231f68837138d03556cf87_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7ffac16bc8231f68837138d03556cf87_b.jpg\"/></figure><p> 选择本地存储的位置和要定义的项目的名字，一路疯狂next（如果要是maven项目，中间有一个选项，可以勾上不勾也没事）</p><h2>创建本地分支</h2><p>拉取远端分支作为本地分支，重新命名 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9cbc40e705bdb72e8e0d9428cf583110_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb\" width=\"534\" data-original=\"https://pic1.zhimg.com/v2-9cbc40e705bdb72e8e0d9428cf583110_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;534&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"534\" data-original=\"https://pic1.zhimg.com/v2-9cbc40e705bdb72e8e0d9428cf583110_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9cbc40e705bdb72e8e0d9428cf583110_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0b736e2333d18baff1d9beac2eb85b6a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1316\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb\" width=\"1316\" data-original=\"https://pic3.zhimg.com/v2-0b736e2333d18baff1d9beac2eb85b6a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1316&#39; height=&#39;735&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1316\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1316\" data-original=\"https://pic3.zhimg.com/v2-0b736e2333d18baff1d9beac2eb85b6a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0b736e2333d18baff1d9beac2eb85b6a_b.jpg\"/></figure><p> 接下来所有的操作都是在sakura和master之间进行操作（包括冲突解决等问题）</p><h2>本地副本修改之后commit操作</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2e0cc42cd52708c2de1d6db65de6f33f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1920\" data-original=\"https://pic4.zhimg.com/v2-2e0cc42cd52708c2de1d6db65de6f33f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1920&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1920\" data-original=\"https://pic4.zhimg.com/v2-2e0cc42cd52708c2de1d6db65de6f33f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2e0cc42cd52708c2de1d6db65de6f33f_b.jpg\"/></figure><p> 之后进行pull和push操作（现在pul操作一定是安全的，远端没有冲突节点）</p><blockquote> 备注：commit不会对远端的代码造成任何影响，只有进行了push操作才会<br/> </blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fd4474e91dfd887a172725ef8d7a60cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"1047\" class=\"origin_image zh-lightbox-thumb\" width=\"1137\" data-original=\"https://pic4.zhimg.com/v2-fd4474e91dfd887a172725ef8d7a60cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1137&#39; height=&#39;1047&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"1047\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1137\" data-original=\"https://pic4.zhimg.com/v2-fd4474e91dfd887a172725ef8d7a60cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fd4474e91dfd887a172725ef8d7a60cf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote> push操作的时候默认提交到你拉的远端分支，不建议这么做，创建属于自己的分支信息之后发起request请求是规范的操作（具体操作还是比较繁琐的，最近打算出一个视屏到时候会发出来）<br/> </blockquote><p>push之后就可以在github上看到了 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cb12da35dc12a1b7c6b8298591df94a8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1450\" data-rawheight=\"851\" class=\"origin_image zh-lightbox-thumb\" width=\"1450\" data-original=\"https://pic1.zhimg.com/v2-cb12da35dc12a1b7c6b8298591df94a8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1450&#39; height=&#39;851&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1450\" data-rawheight=\"851\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1450\" data-original=\"https://pic1.zhimg.com/v2-cb12da35dc12a1b7c6b8298591df94a8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cb12da35dc12a1b7c6b8298591df94a8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>冲突解决</h2><ul><li>新手遇到冲突慌得一笔，我这里在远端修改了文件导致下次提交会出现冲突，针对idea的智能显示，我会有针对的修改文件，使得冲突出现的种类都覆盖上 github上的修改效果如下： </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ddae19601d1f06def5cd46c055198224_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb\" width=\"1087\" data-original=\"https://pic1.zhimg.com/v2-ddae19601d1f06def5cd46c055198224_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1087&#39; height=&#39;371&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"371\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1087\" data-original=\"https://pic1.zhimg.com/v2-ddae19601d1f06def5cd46c055198224_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ddae19601d1f06def5cd46c055198224_b.jpg\"/></figure><p> 可以和上面的未修改的截图对比一下少了什么 ，多了什么下面的解决界面会更加清晰展示，现在看不清也没事</p><p>这是本地的修改，commit之后进行pull操作 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42aaecc6e9349993a3beaf8282138ec7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1155\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"1155\" data-original=\"https://pic4.zhimg.com/v2-42aaecc6e9349993a3beaf8282138ec7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1155&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1155\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1155\" data-original=\"https://pic4.zhimg.com/v2-42aaecc6e9349993a3beaf8282138ec7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42aaecc6e9349993a3beaf8282138ec7_b.jpg\"/></figure><p> PULL操作： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-111263189625fd073032cfb1219f28f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"421\" class=\"origin_image zh-lightbox-thumb\" width=\"562\" data-original=\"https://pic4.zhimg.com/v2-111263189625fd073032cfb1219f28f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;562&#39; height=&#39;421&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"562\" data-rawheight=\"421\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"562\" data-original=\"https://pic4.zhimg.com/v2-111263189625fd073032cfb1219f28f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-111263189625fd073032cfb1219f28f3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>于是会出现下面的冲突界面 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9a24215f2c991339f136ef633f77f7c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1287\" data-rawheight=\"927\" class=\"origin_image zh-lightbox-thumb\" width=\"1287\" data-original=\"https://pic3.zhimg.com/v2-9a24215f2c991339f136ef633f77f7c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1287&#39; height=&#39;927&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1287\" data-rawheight=\"927\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1287\" data-original=\"https://pic3.zhimg.com/v2-9a24215f2c991339f136ef633f77f7c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9a24215f2c991339f136ef633f77f7c2_b.jpg\"/></figure><p> 然后点击进行解决 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-661298c2e90f0570a068456769ad54e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb\" width=\"1576\" data-original=\"https://pic1.zhimg.com/v2-661298c2e90f0570a068456769ad54e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1576&#39; height=&#39;925&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1576\" data-original=\"https://pic1.zhimg.com/v2-661298c2e90f0570a068456769ad54e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-661298c2e90f0570a068456769ad54e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote> 备注： 红色代码段，需要手动进行解决的，可以选择采用自己的或者是远端的  甚至是重新修改代码之后的最终结果 绿色代码是本地新增的，可以直接合并 还有蓝色的代码是内容没有改变的， 但是一般都是在格式出现问题的 灰色的一般都是被删减的代码段，没有意外的冲突情况下可以直接进行合并<br/> </blockquote><p>总结：红色 蓝色 绿色 灰色</p><h2>最后一步，发起合并请求</h2><p>页面展示sakura分支想master分支发起请求，但是在实际工作中一般这个master是特定的开发分支，一般开发都是develop分支，测试的话是test分支 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-62d1a185c23c4abe157a94df389a4609_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"927\" data-rawheight=\"633\" class=\"origin_image zh-lightbox-thumb\" width=\"927\" data-original=\"https://pic2.zhimg.com/v2-62d1a185c23c4abe157a94df389a4609_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;927&#39; height=&#39;633&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"927\" data-rawheight=\"633\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"927\" data-original=\"https://pic2.zhimg.com/v2-62d1a185c23c4abe157a94df389a4609_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-62d1a185c23c4abe157a94df389a4609_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>所有的操作都在个人工作中的实际流程，如有不足之处还望指正</p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59256817", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 1, 
            "title": "快速搭建Swagger项目", 
            "content": "<p>文章简单介绍快速搭建一个swagger的demo，大神可忽略</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大趋势下，目前很多的项目都采用了前后端分离的方式进行开发，最近我接触到的项目大多数都是采用了前后端分离的方式进行开发。既然摆脱了js和html的干扰，更优化的展示接口内容和调用是后端更多需要关注的事情。（非常重要的一点，如果你想简单上手直接使用文章中的项目框架模型，可以直接拉取项目代码：github：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/licunzhi/dream_on_sakura_rain/tree/master/springboot_swagger_demo\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/licunzhi/dre</span><span class=\"invisible\">am_on_sakura_rain/tree/master/springboot_swagger_demo</span><span class=\"ellipsis\"></span></a>）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里介绍使用swagger作为接口文档展示的配置和使用，最终的效果将会是</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-35a82cdd2d056d0ab140d04a84e8b7c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1365\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb\" width=\"1365\" data-original=\"https://pic3.zhimg.com/v2-35a82cdd2d056d0ab140d04a84e8b7c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1365&#39; height=&#39;456&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1365\" data-rawheight=\"456\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1365\" data-original=\"https://pic3.zhimg.com/v2-35a82cdd2d056d0ab140d04a84e8b7c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-35a82cdd2d056d0ab140d04a84e8b7c2_b.jpg\"/></figure><p>首先，需要搭建基础的springboot项目。</p><p>这里推荐大家可以使用 springboot官方推荐模板快速生成工具，地址为：<a href=\"https://link.zhihu.com/?target=https%3A//start.spring.io/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">start.spring.io/</span><span class=\"invisible\"></span></a></p><p>页面的效果是这样的</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-03ce923fb7323695f49e2388c9d246a8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic1.zhimg.com/v2-03ce923fb7323695f49e2388c9d246a8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;644&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic1.zhimg.com/v2-03ce923fb7323695f49e2388c9d246a8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-03ce923fb7323695f49e2388c9d246a8_b.jpg\"/></figure><p>​​</p><p>除了上面的方法支持创建简易的springboot项目的配置模板，实际上在开发工具中也有对这种方法的支持。</p><p>开发中使用idea也可以进行相关的操作，其中引用的地址可以是上面的地址，也可以是自己定义的，效果展示是下面的图片</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5851d352c0814c19589a31df772ee7bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"835\" data-rawheight=\"697\" class=\"origin_image zh-lightbox-thumb\" width=\"835\" data-original=\"https://pic2.zhimg.com/v2-5851d352c0814c19589a31df772ee7bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;835&#39; height=&#39;697&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"835\" data-rawheight=\"697\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"835\" data-original=\"https://pic2.zhimg.com/v2-5851d352c0814c19589a31df772ee7bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5851d352c0814c19589a31df772ee7bd_b.jpg\"/></figure><p>​​</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>你需要引入包文件</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!--swagger jar start--&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.springfox&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.2.2&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;dependency&gt;\n\t\t\t&lt;groupId&gt;io.springfox&lt;/groupId&gt;\n\t\t\t&lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;\n\t\t\t&lt;version&gt;2.2.2&lt;/version&gt;\n\t\t&lt;/dependency&gt;\n\t\t&lt;!--swagger jar end--&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>启动类统计编写配置方法，效果图大概是这样的</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3bbf10cae7628eb97ed2831f5c274066_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic3.zhimg.com/v2-3bbf10cae7628eb97ed2831f5c274066_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;746&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic3.zhimg.com/v2-3bbf10cae7628eb97ed2831f5c274066_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3bbf10cae7628eb97ed2831f5c274066_b.jpg\"/></figure><p>​</p><p class=\"ztext-empty-paragraph\"><br/></p><p>配置代码</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.example.springboot_swagger_demo</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.context.annotation.Bean</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.context.annotation.Configuration</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.builders.ApiInfoBuilder</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.builders.PathSelectors</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.builders.RequestHandlerSelectors</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.service.ApiInfo</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.spi.DocumentationType</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.spring.web.plugins.Docket</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.swagger2.annotations.EnableSwagger2</span><span class=\"o\">;</span>\n\n<span class=\"nd\">@Configuration</span>\n<span class=\"nd\">@EnableSwagger2</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SwaggerConfiguration</span> <span class=\"o\">{</span>\n\n    <span class=\"nd\">@Bean</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Docket</span> <span class=\"nf\">createRestApi</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Docket</span><span class=\"o\">(</span><span class=\"n\">DocumentationType</span><span class=\"o\">.</span><span class=\"na\">SWAGGER_2</span><span class=\"o\">).</span><span class=\"na\">apiInfo</span><span class=\"o\">(</span><span class=\"n\">apiInfo</span><span class=\"o\">()).</span><span class=\"na\">select</span><span class=\"o\">()</span>\n                        <span class=\"o\">.</span><span class=\"na\">apis</span><span class=\"o\">(</span><span class=\"n\">RequestHandlerSelectors</span><span class=\"o\">.</span><span class=\"na\">basePackage</span><span class=\"o\">(</span><span class=\"s\">&#34;com.example.springboot_swagger_demo.controller&#34;</span><span class=\"o\">))</span>\n                        <span class=\"o\">.</span><span class=\"na\">paths</span><span class=\"o\">(</span><span class=\"n\">PathSelectors</span><span class=\"o\">.</span><span class=\"na\">any</span><span class=\"o\">()).</span><span class=\"na\">build</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">ApiInfo</span> <span class=\"nf\">apiInfo</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ApiInfoBuilder</span><span class=\"o\">().</span><span class=\"na\">title</span><span class=\"o\">(</span><span class=\"s\">&#34;Spring Boot中使用Swagger2构建RESTful APIs&#34;</span><span class=\"o\">)</span>\n                        <span class=\"o\">.</span><span class=\"na\">description</span><span class=\"o\">(</span><span class=\"s\">&#34;相关描述&#34;</span><span class=\"o\">)</span>\n                        <span class=\"o\">.</span><span class=\"na\">termsOfServiceUrl</span><span class=\"o\">(</span><span class=\"s\">&#34;http:......&#34;</span><span class=\"o\">).</span><span class=\"na\">contact</span><span class=\"o\">(</span><span class=\"s\">&#34;sakura&#34;</span><span class=\"o\">).</span><span class=\"na\">version</span><span class=\"o\">(</span><span class=\"s\">&#34;1.0&#34;</span><span class=\"o\">).</span><span class=\"na\">build</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>编写控制层的代码（这里面我已经吧经常会用到的注解都写上了，没有考虑到代码的规范性问题，只是为了给大家展示一下注解的含义相关用法）</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">com.example.springboot_swagger_demo.controller</span><span class=\"o\">;</span>\n\n\n<span class=\"kn\">import</span> <span class=\"nn\">com.example.springboot_swagger_demo.domain.Sakura</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">com.example.springboot_swagger_demo.response.ResponseData</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.Api</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.ApiImplicitParam</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.ApiImplicitParams</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.ApiOperation</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.ApiResponse</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">io.swagger.annotations.ApiResponses</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.GetMapping</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.PostMapping</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.PutMapping</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.RequestBody</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.RequestMapping</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">org.springframework.web.bind.annotation.RestController</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">springfox.documentation.annotations.ApiIgnore</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.HashMap</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Map</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.stream.Collectors</span><span class=\"o\">;</span>\n\n<span class=\"nd\">@RestController</span>\n<span class=\"nd\">@RequestMapping</span><span class=\"o\">(</span><span class=\"s\">&#34;/sakura&#34;</span><span class=\"o\">)</span>\n<span class=\"nd\">@Api</span><span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s\">&#34;sakura基础数据接口&#34;</span><span class=\"o\">,</span> <span class=\"n\">tags</span> <span class=\"o\">=</span> <span class=\"s\">&#34;接口标识&#34;</span><span class=\"o\">)</span> <span class=\"c1\">//这里可以不设置，默认的展示效果是该类的名称SakuraController\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SakuraController</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">static</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Sakura</span><span class=\"o\">&gt;</span> <span class=\"n\">sakuras</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;();</span>\n\n    <span class=\"nd\">@ApiOperation</span><span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s\">&#34;创建一个sakura&#34;</span><span class=\"o\">,</span> <span class=\"n\">notes</span> <span class=\"o\">=</span> <span class=\"s\">&#34;对接口的功能备注解释&#34;</span><span class=\"o\">)</span><span class=\"c1\">//接口功能解释\n</span><span class=\"c1\"></span>    <span class=\"nd\">@ApiImplicitParams</span><span class=\"o\">(</span> <span class=\"o\">{</span><span class=\"c1\">// 多个参数的提示的展示方式，也可以单独只使用一个@ApiImplicitParam\n</span><span class=\"c1\"></span>                    <span class=\"c1\">//@ApiImplicitParam(name = &#34;id&#34;, value = &#34;用户ID&#34;, dataType = &#34;Long&#34;, paramType = &#34;path&#34;),//点进注解，会有paramType的其它选项和用法解释\n</span><span class=\"c1\"></span>                    <span class=\"nd\">@ApiImplicitParam</span><span class=\"o\">(</span><span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s\">&#34;sakura&#34;</span><span class=\"o\">,</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s\">&#34;sakura实体类&#34;</span><span class=\"o\">,</span> <span class=\"n\">required</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">,</span> <span class=\"n\">dataType</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Sakura&#34;</span><span class=\"o\">)</span><span class=\"c1\">//参数解释\n</span><span class=\"c1\"></span>    <span class=\"o\">})</span>\n    <span class=\"nd\">@ApiResponses</span><span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"c1\">// 多个返回的提示的展示方式，也可以单独只使用一个@ApiImplicitParam\n</span><span class=\"c1\"></span>                    <span class=\"nd\">@ApiResponse</span><span class=\"o\">(</span><span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">401</span><span class=\"o\">,</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;未未授权&#34;</span><span class=\"o\">),</span> <span class=\"nd\">@ApiResponse</span><span class=\"o\">(</span><span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">500</span><span class=\"o\">,</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;server error&#34;</span><span class=\"o\">),</span>\n                    <span class=\"nd\">@ApiResponse</span><span class=\"o\">(</span><span class=\"n\">code</span> <span class=\"o\">=</span> <span class=\"n\">200</span><span class=\"o\">,</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"s\">&#34;success&#34;</span><span class=\"o\">,</span> <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">ResponseData</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)})</span>\n    <span class=\"nd\">@PostMapping</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">addRequest</span><span class=\"o\">(</span><span class=\"nd\">@RequestBody</span> <span class=\"n\">Sakura</span> <span class=\"n\">sakura</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">sakuras</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">sakura</span><span class=\"o\">.</span><span class=\"na\">getId</span><span class=\"o\">(),</span> <span class=\"n\">sakura</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;success&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@ApiOperation</span><span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s\">&#34;获取sakura信息&#34;</span><span class=\"o\">,</span> <span class=\"n\">notes</span> <span class=\"o\">=</span> <span class=\"s\">&#34;返回sakura所有信息&#34;</span><span class=\"o\">)</span>\n    <span class=\"nd\">@GetMapping</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">getRequest</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">sakuras</span><span class=\"o\">.</span><span class=\"na\">entrySet</span><span class=\"o\">().</span><span class=\"na\">stream</span><span class=\"o\">().</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"n\">entry</span> <span class=\"o\">-&gt;</span> <span class=\"n\">entry</span><span class=\"o\">.</span><span class=\"na\">getValue</span><span class=\"o\">()).</span><span class=\"na\">collect</span><span class=\"o\">(</span><span class=\"n\">Collectors</span><span class=\"o\">.</span><span class=\"na\">toList</span><span class=\"o\">());</span>\n    <span class=\"o\">}</span>\n\n\n    <span class=\"nd\">@ApiIgnore</span><span class=\"c1\">//注解标识不展示在swagger界面上\n</span><span class=\"c1\"></span>    <span class=\"nd\">@PutMapping</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">putRequest</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"s\">&#34;response put result message&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>那么究竟有多少注解需要我们去探究，实际上没有多少，大概。。。。。就这么多吧</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-07b56d6ce4b71fad64bdf3604dc0015d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-07b56d6ce4b71fad64bdf3604dc0015d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;746&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"746\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-07b56d6ce4b71fad64bdf3604dc0015d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-07b56d6ce4b71fad64bdf3604dc0015d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>具体的含义和使用的详情要不然就是网上有了很多的解释，要不然就是点进注解之后英文解释的已经非常详细了，我这里面就不做解释了。</p>", 
            "topic": [
                {
                    "tag": "Swagger", 
                    "tagLink": "https://api.zhihu.com/topics/20080742"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59141657", 
            "userName": "曦曦春风", 
            "userLink": "https://www.zhihu.com/people/13043f7543f9667e8279ad1bee8d8996", 
            "upvote": 3, 
            "title": "SVN在IDEA中快速掌握工作基本要求（分支创建，合并，提交，冲突解决）", 
            "content": "<h2>介绍（多图警告）</h2><p>之前的工作一直使用的<code>git</code>（至于<code>git</code>的快速实战技能介绍，近期将会写一篇详细的博客）。同为版本管理工具，却还没有使用过<code>svn</code>，因为工作的原因现在要换成<code>svn</code>。查看网上教程，很多没有对于工作快速技能的博客解释，这篇博客就快速教你学会工作中迫切需要会的技能。入门之后，后面的更多功能需要自己慢慢探索，后续有时间我也会新的博客重新编写更加详细的功能。</p><h2>项目初始化</h2><p>这里如何创建一个svn的项目不做解释，不是本片博客介绍的重点： - 拉取代码到本地 - 创建新的分支，修改代码并提交 - 创建冲突情况，合并冲突并提交代码 - 你需要关注的问题</p><h2>● 拉取代码到本地</h2><p>1、我在本地创建了一个项目，项目地址为：file:///E:/002-svn-local/trunk/SvnDemo，trunk目录下展示------- </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-48582aa938890d448096e3d7b4a4c7a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"761\" class=\"origin_image zh-lightbox-thumb\" width=\"1123\" data-original=\"https://pic1.zhimg.com/v2-48582aa938890d448096e3d7b4a4c7a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1123&#39; height=&#39;761&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"761\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1123\" data-original=\"https://pic1.zhimg.com/v2-48582aa938890d448096e3d7b4a4c7a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-48582aa938890d448096e3d7b4a4c7a4_b.jpg\"/></figure><p> 2、把项目拉到本地： 在这里操作，你可以选择使用命令行界面操作，也可以使用idea本身支持的插件进行操作。（我这里还是侧重使用开发工具进行相关的操作，方便截图和展示） </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5171ffe750d448b660e442dcd6906b91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1002\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb\" width=\"1002\" data-original=\"https://pic2.zhimg.com/v2-5171ffe750d448b660e442dcd6906b91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1002&#39; height=&#39;722&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1002\" data-rawheight=\"722\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1002\" data-original=\"https://pic2.zhimg.com/v2-5171ffe750d448b660e442dcd6906b91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5171ffe750d448b660e442dcd6906b91_b.jpg\"/></figure><p> 点击checkout，可以将刚才添加的项目地址检出到本地。具体操作流程的截图可以继续向下看 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f96fd4f99d43237e3b3426229bd8f91d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb\" width=\"813\" data-original=\"https://pic2.zhimg.com/v2-f96fd4f99d43237e3b3426229bd8f91d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;813&#39; height=&#39;534&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"813\" data-rawheight=\"534\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"813\" data-original=\"https://pic2.zhimg.com/v2-f96fd4f99d43237e3b3426229bd8f91d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f96fd4f99d43237e3b3426229bd8f91d_b.jpg\"/></figure><p>  选择检出到本地的项目位置路径信息  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4315adc9261e87e2e4372a8776523962_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb\" width=\"851\" data-original=\"https://pic3.zhimg.com/v2-4315adc9261e87e2e4372a8776523962_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;851&#39; height=&#39;565&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"851\" data-original=\"https://pic3.zhimg.com/v2-4315adc9261e87e2e4372a8776523962_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4315adc9261e87e2e4372a8776523962_b.jpg\"/></figure><p>  拉取项目到本地展示  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cefe270ac8b6e6aa02d541b010ed29f1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1917\" data-rawheight=\"1038\" class=\"origin_image zh-lightbox-thumb\" width=\"1917\" data-original=\"https://pic2.zhimg.com/v2-cefe270ac8b6e6aa02d541b010ed29f1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1917&#39; height=&#39;1038&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1917\" data-rawheight=\"1038\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1917\" data-original=\"https://pic2.zhimg.com/v2-cefe270ac8b6e6aa02d541b010ed29f1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cefe270ac8b6e6aa02d541b010ed29f1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>●创建新的分支，修改代码并提交</h2><ul><li>创建分支的点击 </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-adec24a6878f378795a5595ff22be38c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"1044\" class=\"origin_image zh-lightbox-thumb\" width=\"968\" data-original=\"https://pic1.zhimg.com/v2-adec24a6878f378795a5595ff22be38c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;968&#39; height=&#39;1044&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"1044\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"968\" data-original=\"https://pic1.zhimg.com/v2-adec24a6878f378795a5595ff22be38c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-adec24a6878f378795a5595ff22be38c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>创建分支界面的选择，一般是按照截图中配置，有特殊情况需要按照图中的注解进行修改（请注意如果失败了，和选择Repositories Locations的Revision有关 可以改选Specified）  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-376be3bdd858200ac604ae9c00b3ec21_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1344\" data-rawheight=\"1038\" class=\"origin_image zh-lightbox-thumb\" width=\"1344\" data-original=\"https://pic2.zhimg.com/v2-376be3bdd858200ac604ae9c00b3ec21_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1344&#39; height=&#39;1038&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1344\" data-rawheight=\"1038\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1344\" data-original=\"https://pic2.zhimg.com/v2-376be3bdd858200ac604ae9c00b3ec21_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-376be3bdd858200ac604ae9c00b3ec21_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>切换到刚才创建的分支位置（辗转难眠对于下面的Depth做了研究，新写了一篇博客）  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-788940800d5cae0caf4381bf61092a23_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"821\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic4.zhimg.com/v2-788940800d5cae0caf4381bf61092a23_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;821&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"821\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic4.zhimg.com/v2-788940800d5cae0caf4381bf61092a23_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-788940800d5cae0caf4381bf61092a23_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>添加新文件并提交  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5dd3c235d14bbcb026b34c78dc8c6b1c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic1.zhimg.com/v2-5dd3c235d14bbcb026b34c78dc8c6b1c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic1.zhimg.com/v2-5dd3c235d14bbcb026b34c78dc8c6b1c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5dd3c235d14bbcb026b34c78dc8c6b1c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>代码合并到主分支  首先切换为trunk分支  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-810c10d534028ca89ba1a99ea350cceb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"671\" data-rawheight=\"1043\" class=\"origin_image zh-lightbox-thumb\" width=\"671\" data-original=\"https://pic4.zhimg.com/v2-810c10d534028ca89ba1a99ea350cceb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;671&#39; height=&#39;1043&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"671\" data-rawheight=\"1043\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"671\" data-original=\"https://pic4.zhimg.com/v2-810c10d534028ca89ba1a99ea350cceb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-810c10d534028ca89ba1a99ea350cceb_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-43ef8bab4196cab4dcc1f54794c4be44_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1097\" data-rawheight=\"767\" class=\"origin_image zh-lightbox-thumb\" width=\"1097\" data-original=\"https://pic1.zhimg.com/v2-43ef8bab4196cab4dcc1f54794c4be44_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1097&#39; height=&#39;767&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1097\" data-rawheight=\"767\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1097\" data-original=\"https://pic1.zhimg.com/v2-43ef8bab4196cab4dcc1f54794c4be44_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-43ef8bab4196cab4dcc1f54794c4be44_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-302c33b259987f412851f7fab0c542da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic3.zhimg.com/v2-302c33b259987f412851f7fab0c542da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic3.zhimg.com/v2-302c33b259987f412851f7fab0c542da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-302c33b259987f412851f7fab0c542da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>●创建冲突情况，合并冲突并提交代码</h2><ul><li>trunk分支对READ.md文件进行修改并提交  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0f4895e25eead5639550cebf280aa96f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1923\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb\" width=\"1923\" data-original=\"https://pic4.zhimg.com/v2-0f4895e25eead5639550cebf280aa96f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1923&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1923\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1923\" data-original=\"https://pic4.zhimg.com/v2-0f4895e25eead5639550cebf280aa96f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0f4895e25eead5639550cebf280aa96f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>sakrua_version_1.0修改提交  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4daf289f75b191d4bece257a90bb1297_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1922\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"1922\" data-original=\"https://pic4.zhimg.com/v2-4daf289f75b191d4bece257a90bb1297_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1922&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1922\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1922\" data-original=\"https://pic4.zhimg.com/v2-4daf289f75b191d4bece257a90bb1297_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4daf289f75b191d4bece257a90bb1297_b.jpg\"/></figure><p>  下面介绍冲突合并的重点，可以理解trunk和git中的master一样，因此trunk合并操作之前应该是完全没有冲突的代码：  1、trunk主动合并解决冲突问题  首先sakura分支提交，然后切换到trunk分支进行merge操作  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6e800254cd5476f6875ea2dd09ebc0d6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"709\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb\" width=\"709\" data-original=\"https://pic3.zhimg.com/v2-6e800254cd5476f6875ea2dd09ebc0d6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;709&#39; height=&#39;1002&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"709\" data-rawheight=\"1002\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"709\" data-original=\"https://pic3.zhimg.com/v2-6e800254cd5476f6875ea2dd09ebc0d6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6e800254cd5476f6875ea2dd09ebc0d6_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-455400b2e119a9e10506ceac123f6677_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1391\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb\" width=\"1391\" data-original=\"https://pic4.zhimg.com/v2-455400b2e119a9e10506ceac123f6677_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1391&#39; height=&#39;1042&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1391\" data-rawheight=\"1042\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1391\" data-original=\"https://pic4.zhimg.com/v2-455400b2e119a9e10506ceac123f6677_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-455400b2e119a9e10506ceac123f6677_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9f2d52934aada8fd65222e078c4b897b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-9f2d52934aada8fd65222e078c4b897b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-9f2d52934aada8fd65222e078c4b897b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9f2d52934aada8fd65222e078c4b897b_b.jpg\"/></figure><p>  这里我采用了两个都保存的方式进行冲突解决方案  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-981fe5902cb6046d2cf98cc2d3ba4d69_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb\" width=\"1576\" data-original=\"https://pic2.zhimg.com/v2-981fe5902cb6046d2cf98cc2d3ba4d69_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1576&#39; height=&#39;925&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1576\" data-original=\"https://pic2.zhimg.com/v2-981fe5902cb6046d2cf98cc2d3ba4d69_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-981fe5902cb6046d2cf98cc2d3ba4d69_b.jpg\"/></figure><p>  2、分支解决冲突，请求合并主分支（推荐）  操作解释：这里我就把上面的操作再来展示一次  初始化界面为（sakura 分支）  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-aabb19c9b6fe03b855c7b3ee2147a18f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-aabb19c9b6fe03b855c7b3ee2147a18f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-aabb19c9b6fe03b855c7b3ee2147a18f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-aabb19c9b6fe03b855c7b3ee2147a18f_b.jpg\"/></figure><p> trunk分支进行信息修改 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6b1a9b08a702af95d3f322e2150deb45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1912\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb\" width=\"1912\" data-original=\"https://pic2.zhimg.com/v2-6b1a9b08a702af95d3f322e2150deb45_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1912&#39; height=&#39;418&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1912\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1912\" data-original=\"https://pic2.zhimg.com/v2-6b1a9b08a702af95d3f322e2150deb45_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6b1a9b08a702af95d3f322e2150deb45_b.jpg\"/></figure><p> sakura分支修改后合并冲突 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8f7fec303a861eaab202dae6c3b2a37a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1233\" data-rawheight=\"1043\" class=\"origin_image zh-lightbox-thumb\" width=\"1233\" data-original=\"https://pic3.zhimg.com/v2-8f7fec303a861eaab202dae6c3b2a37a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1233&#39; height=&#39;1043&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1233\" data-rawheight=\"1043\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1233\" data-original=\"https://pic3.zhimg.com/v2-8f7fec303a861eaab202dae6c3b2a37a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8f7fec303a861eaab202dae6c3b2a37a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-855710f01a7d6b7eda47ec485b3c09ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic2.zhimg.com/v2-855710f01a7d6b7eda47ec485b3c09ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic2.zhimg.com/v2-855710f01a7d6b7eda47ec485b3c09ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-855710f01a7d6b7eda47ec485b3c09ed_b.jpg\"/></figure><p> 采用同样的方式进行合并 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3a4efd1a5fbfdf03b534e56b9f333eb3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb\" width=\"1576\" data-original=\"https://pic4.zhimg.com/v2-3a4efd1a5fbfdf03b534e56b9f333eb3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1576&#39; height=&#39;925&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1576\" data-rawheight=\"925\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1576\" data-original=\"https://pic4.zhimg.com/v2-3a4efd1a5fbfdf03b534e56b9f333eb3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3a4efd1a5fbfdf03b534e56b9f333eb3_b.jpg\"/></figure><p> 最后提交代码，这时候如果管理员是trunk分支权限，那么他发起合并sakura请求的时候便是没有冲突的纯净文件，如下： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ece0b20cceef3eb22582aee4a6b8a093_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-ece0b20cceef3eb22582aee4a6b8a093_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1928&#39; height=&#39;1048&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1928\" data-rawheight=\"1048\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1928\" data-original=\"https://pic4.zhimg.com/v2-ece0b20cceef3eb22582aee4a6b8a093_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ece0b20cceef3eb22582aee4a6b8a093_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>你需要关注的问题</h2><ul><li>有关冲突合并，是目标分支发起的主动动作</li><li>trunk或者是sakura合并请求的操作目的都是为了解决冲突</li><li>合并到trunk分支有trunk发起合并最终代码是正确操作，但是sakura修改的代码造成的冲突原则上应该有sakura分支解决，因此推荐使用第二种解决冲突的办法。</li><li>这里只是个人实战开发的问题，还有很多我确定和知识点盲区，如有错误还请联系我。</li></ul>", 
            "topic": [
                {
                    "tag": "SVN(Subversion)", 
                    "tagLink": "https://api.zhihu.com/topics/19607465"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59100329", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 3, 
            "title": "Java引用类型原理剖析", 
            "content": "<p>Java中一共有4种引用类型(其实还有一些其他的引用类型比如FinalReference)：强引用、软引用、弱引用、虚引用。其中强引用就是我们经常使用的 Objecta=newObject(); 这样的形式，在Java中并没有对应的Reference类。</p><p>本篇文章主要是分析软引用、弱引用、虚引用的实现，这三种引用类型都是继承于Reference这个类，主要逻辑也在Reference中。</p><p><b>问题</b></p><p>在分析前，先抛几个问题？</p><p>1.网上大多数文章对于软引用的介绍是：在内存不足的时候才会被回收，那内存不足是怎么定义的？什么才叫内存不足？</p><p>2.网上大多数文章对于虚引用的介绍是：形同虚设，虚引用并不会决定对象的生命周期。主要用来跟踪对象被垃圾回收器回收的活动。真的是这样吗？</p><p>3.虚引用在Jdk中有哪些场景下用到了呢？</p><p>Reference</p><p>我们先看下 Reference.java中的几个字段</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1ca4f39c7b57cad93fb79a2ba62d2f9b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic4.zhimg.com/v2-1ca4f39c7b57cad93fb79a2ba62d2f9b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;349&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic4.zhimg.com/v2-1ca4f39c7b57cad93fb79a2ba62d2f9b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1ca4f39c7b57cad93fb79a2ba62d2f9b_b.jpg\"/></figure><p>一个Reference对象的生命周期如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c9870f69944df02e383c5ab877c36f8d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-c9870f69944df02e383c5ab877c36f8d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;625&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic2.zhimg.com/v2-c9870f69944df02e383c5ab877c36f8d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c9870f69944df02e383c5ab877c36f8d_b.jpg\"/></figure><p>主要分为Native层和Java层两个部分。</p><p>Native层在GC时将需要被回收的Reference对象加入到DiscoveredList中（代码在 referenceProcessor.cpp中 process_discovered_references方法），</p><p>然后将DiscoveredList的元素移动到PendingList中</p><p>（代码在 referenceProcessor.cpp中 enqueue_discovered_ref_helper方法）,</p><p>PendingList的队首就是Reference类中的pending对象。 具体代码就不分析了，有兴趣的同学可以看看这篇文章。</p><blockquote><a href=\"https://link.zhihu.com/?target=http%3A//www.importnew.com/21628.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">importnew.com/21628.htm</span><span class=\"invisible\">l</span><span class=\"ellipsis\"></span></a></blockquote><p>看看Java层的代码</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c2e8db923f3df81d783bff2efad15bb8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"882\" class=\"origin_image zh-lightbox-thumb\" width=\"676\" data-original=\"https://pic1.zhimg.com/v2-c2e8db923f3df81d783bff2efad15bb8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;676&#39; height=&#39;882&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"882\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"676\" data-original=\"https://pic1.zhimg.com/v2-c2e8db923f3df81d783bff2efad15bb8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c2e8db923f3df81d783bff2efad15bb8_b.jpg\"/></figure><p>流程比较简单：就是源源不断的从PendingList中提取出元素，然后将其加入到ReferenceQueue中去，开发者可以通过从ReferenceQueue中poll元素感知到对象被回收的事件。</p><p>另外需要注意的是，对于Cleaner类型（继承自虚引用）的对象会有额外的处理：在其指向的对象被回收时，会调用clean方法，该方法主要是用来做对应的资源回收，在堆外内存DirectByteBuffer中就是用Cleaner进行堆外内存的回收，这也是虚引用在java中的典型应用。</p><p>看完了Reference的实现，再看看几个实现类里，各自有什么不同。</p><p>SoftReference</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9c1df4c2fe465d8a1be9afd41ddcb675_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb\" width=\"673\" data-original=\"https://pic2.zhimg.com/v2-9c1df4c2fe465d8a1be9afd41ddcb675_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;673&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"673\" data-original=\"https://pic2.zhimg.com/v2-9c1df4c2fe465d8a1be9afd41ddcb675_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9c1df4c2fe465d8a1be9afd41ddcb675_b.jpg\"/></figure><p>软引用的实现很简单，就多了两个字段： clock和 timestamp。 clock是个静态变量，每次GC时都会将该字段设置成当前时间。 timestamp字段则会在每次调用get方法时将其赋值为 clock（如果不相等且对象没被回收）。</p><p>那这两个字段的作用是什么呢？这和软引用在内存不够的时候才被回收，又有什么关系呢？</p><p>这些还得看JVM的源码才行，因为决定对象是否需要被回收都是在GC中实现的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-37ac286ea99f6af7e85c6bbbd77b4907_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-37ac286ea99f6af7e85c6bbbd77b4907_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;569&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-37ac286ea99f6af7e85c6bbbd77b4907_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-37ac286ea99f6af7e85c6bbbd77b4907_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-63ced293a2352addb9b73c622962429c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"575\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-63ced293a2352addb9b73c622962429c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;575&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"575\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-63ced293a2352addb9b73c622962429c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-63ced293a2352addb9b73c622962429c_b.jpg\"/></figure><p>refs_lists中存放了本次GC发现的某种引用类型（虚引用、软引用、弱引用等），而 process_discovered_reflist方法的作用就是将不需要被回收的对象从 refs_lists移除掉， refs_lists最后剩下的元素全是需要被回收的元素，最后会将其第一个元素赋值给上文提到过的 Reference.java#pending字段。</p><p>ReferencePolicy一共有4种实现：NeverClearPolicy，AlwaysClearPolicy，LRUCurrentHeapPolicy，LRUMaxHeapPolicy。其中NeverClearPolicy永远返回false，代表永远不回收SoftReference，在JVM中该类没有被使用，AlwaysClearPolicy则永远返回true，在 referenceProcessor.hpp#setup方法中中可以设置policy为AlwaysClearPolicy，至于什么时候会用到AlwaysClearPolicy，大家有兴趣可以自行研究。</p><p>LRUCurrentHeapPolicy和LRUMaxHeapPolicy的shouldclearreference方法则是完全相同：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-90d12fd6a3e28b698f0d847fff7f080b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb\" width=\"674\" data-original=\"https://pic4.zhimg.com/v2-90d12fd6a3e28b698f0d847fff7f080b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;674&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"674\" data-original=\"https://pic4.zhimg.com/v2-90d12fd6a3e28b698f0d847fff7f080b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-90d12fd6a3e28b698f0d847fff7f080b_b.jpg\"/></figure><p>timestmp_clock就是SoftReference的静态字段 clock， java_lang_ref_SoftReference::timestamp(p)对应是字段 timestamp。如果上次GC后有调用 SoftReference#get， interval值为0，否则为若干次GC之间的时间差。</p><p>_max_interval则代表了一个临界值，它的值在LRUCurrentHeapPolicy和LRUMaxHeapPolicy两种策略中有差异。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-aa4130b5364447a61da8f9c31e955623_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"668\" data-original=\"https://pic4.zhimg.com/v2-aa4130b5364447a61da8f9c31e955623_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;668&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"668\" data-original=\"https://pic4.zhimg.com/v2-aa4130b5364447a61da8f9c31e955623_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-aa4130b5364447a61da8f9c31e955623_b.jpg\"/></figure><p>其中 SoftRefLRUPolicyMSPerMB默认为1000，前者的计算方法和上次GC后可用堆大小有关，后者计算方法和（堆大小-上次gc时堆使用大小）有关。</p><p>看到这里你就知道SoftReference到底什么时候被被回收了，它和使用的策略（默认应该是LRUCurrentHeapPolicy），堆可用大小，该SoftReference上一次调用get方法的时间都有关系。</p><p>WeakReference</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f11d82a8e5c3356ba326fe28199be24e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"207\" class=\"origin_image zh-lightbox-thumb\" width=\"675\" data-original=\"https://pic3.zhimg.com/v2-f11d82a8e5c3356ba326fe28199be24e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;675&#39; height=&#39;207&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"207\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"675\" data-original=\"https://pic3.zhimg.com/v2-f11d82a8e5c3356ba326fe28199be24e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f11d82a8e5c3356ba326fe28199be24e_b.jpg\"/></figure><p>可以看到WeakReference在Java层只是继承了Reference，没有做任何的改动。那referent字段是什么时候被置为null的呢？要搞清楚这个问题我们再看下上文提到过的 process_discovered_reflist方法：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e399b6cdd47b687ac4544203e711fdbc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"670\" data-rawheight=\"815\" class=\"origin_image zh-lightbox-thumb\" width=\"670\" data-original=\"https://pic1.zhimg.com/v2-e399b6cdd47b687ac4544203e711fdbc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;670&#39; height=&#39;815&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"670\" data-rawheight=\"815\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"670\" data-original=\"https://pic1.zhimg.com/v2-e399b6cdd47b687ac4544203e711fdbc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e399b6cdd47b687ac4544203e711fdbc_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ebd3e4042b14fce3d30726a530890957_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"798\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-ebd3e4042b14fce3d30726a530890957_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;798&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"798\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-ebd3e4042b14fce3d30726a530890957_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ebd3e4042b14fce3d30726a530890957_b.jpg\"/></figure><p>不管是弱引用还是其他引用类型，将字段referent置null的操作都发生在 process_phase3中，而具体行为是由 clear_referent的值决定的。而 clear_referent的值则和引用类型相关。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8f52cda314eae584dd315325d47bf682_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"954\" class=\"origin_image zh-lightbox-thumb\" width=\"668\" data-original=\"https://pic3.zhimg.com/v2-8f52cda314eae584dd315325d47bf682_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;668&#39; height=&#39;954&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"954\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"668\" data-original=\"https://pic3.zhimg.com/v2-8f52cda314eae584dd315325d47bf682_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8f52cda314eae584dd315325d47bf682_b.jpg\"/></figure><p>可以看到，对于Soft references和Weak references clear_referent字段传入的都是true，这也符合我们的预期：对象不可达后，引用字段就会被置为null，然后对象就会被回收（对于软引用来说，如果内存足够的话，在Phase 1，相关的引用就会从refslist中被移除，到Phase 3时refslist为空集合）。</p><p>但对于Final references和 Phantom references， clear_referent字段传入的是false，也就意味着被这两种引用类型引用的对象，如果没有其他额外处理，只要Reference对象还存活，那引用的对象是不会被回收的。Final references和对象是否重写了finalize方法有关，不在本文分析范围之内，我们接下来看看Phantom references。</p><p>PhantomReference</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6d15fcc3046457032aa38a3809845295_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb\" width=\"673\" data-original=\"https://pic2.zhimg.com/v2-6d15fcc3046457032aa38a3809845295_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;673&#39; height=&#39;206&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"673\" data-original=\"https://pic2.zhimg.com/v2-6d15fcc3046457032aa38a3809845295_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6d15fcc3046457032aa38a3809845295_b.jpg\"/></figure><p>可以看到虚引用的get方法永远返回null，我们看个demo。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a5d89a8fe39d1945487b2df3510c0a2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"664\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"664\" data-original=\"https://pic2.zhimg.com/v2-a5d89a8fe39d1945487b2df3510c0a2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;664&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"664\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"664\" data-original=\"https://pic2.zhimg.com/v2-a5d89a8fe39d1945487b2df3510c0a2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a5d89a8fe39d1945487b2df3510c0a2d_b.jpg\"/></figure><p>从以上代码中可以看到，虚引用能够在指向对象不可达时得到一个&#39;通知&#39;（其实所有继承References的类都有这个功能），需要注意的是GC完成后，phanRef.referent依然指向之前创建Object，也就是说Object对象一直没被回收！</p><p>而造成这一现象的原因在上一小节末尾已经说了： 对于Finalreferences和Phantomreferences，clear_referent 字段传入的时false，也就意味着被这两种引用类型引用的对象，如果没有其他额外处理，在GC中是不会被回收的。</p><p>对于虚引用来说，从 refQueue.remove();得到引用对象后，可以调用 clear方法强行解除引用和对象之间的关系，使得对象下次可以GC时可以被回收掉。</p><h2><b>End</b></h2><p>针对文章开头提出的几个问题，看完分析，我们已经能给出回答：</p><p><b>1.我们经常在网上看到软引用的介绍是：</b>在内存不足的时候才会回收，那内存不足是怎么定义的？为什么才叫内存不足？</p><p>软引用会在内存不足时被回收，内存不足的定义和该引用对象get的时间以及当前堆可用内存大小都有关系，计算公式在上文中也已经给出。</p><p><b>2.网上对于虚引用的介绍是：</b>形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。主要用来跟踪对象被垃圾回收器回收的活动。真的是这样吗？</p><p>严格的说，虚引用是会影响对象生命周期的，如果不做任何处理，只要虚引用不被回收，那其引用的对象永远不会被回收。所以一般来说，从ReferenceQueue中获得PhantomReference对象后，如果PhantomReference对象不会被回收的话（比如被其他GC ROOT可达的对象引用），需要调用 clear方法解除PhantomReference和其引用对象的引用关系。</p><p><b>3.虚引用在Jdk中有哪些场景下用到了呢？</b></p><p>DirectByteBuffer中是用虚引用的子类 Cleaner.java来实现堆外内存回收的，后续会写篇文章来说说堆外内存的里里外外。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59099171", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 10, 
            "title": "java new一个对象的过程中发生了什么", 
            "content": "<p>java在new一个对象的时候，会先查看对象所属的类有没有被加载到内存，如果没有的话，就会先通过类的全限定名来加载。加载并初始化类完成后，再进行对象的创建工作。</p><p>我们先假设是第一次使用该类，这样的话new一个对象就可以分为两个过程：加载并初始化类和创建对象。</p><p><b>一、类加载过程（第一次使用该类）</b></p><p>java是使用双亲委派模型来进行类的加载的，所以在描述类加载过程前，我们先看一下它的工作过程：</p><p>双亲委托模型的工作过程是：如果一个类加载器（ClassLoader）收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，子加载器才会尝试自己去加载</p><p>使用双亲委托机制的好处是：能够有效确保一个类的全局唯一性，当程序中出现多个限定名相同的类时，类加载器在执行加载时，始终只会加载其中的某一个类。</p><p><b>1、加载</b></p><p>由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例</p><p><b>2、验证</b></p><p>格式验证：验证是否符合class文件规范</p><p>语义验证：检查一个被标记为final的类型是否包含子类；检查一个类中的final方法是否被子类进行重写；确保父类和子类之间没有不兼容的一些方法声明（比如方法签名相同，但方法的返回值不同）</p><p>操作验证：在操作数栈中的数据必须进行正确的操作，对常量池中的各种符号引用执行验证（通常在解析阶段执行，检查是否可以通过符号引用中描述的全限定名定位到指定类型上，以及类成员信息的访问修饰符是否允许访问等）</p><p><b>3、准备</b></p><p>为类中的所有静态变量分配内存空间，并为其设置一个初始值（由于还没有产生对象，实例变量不在此操作范围内）</p><p>被final修饰的static变量（常量），会直接赋值；</p><p><b>4、解析</b></p><p>将常量池中的符号引用转为直接引用（得到类或者字段、方法在内存中的指针或者偏移量，以便直接调用该方法），这个可以在初始化之后再执行。</p><p>解析需要静态绑定的内容。  // 所有不会被重写的方法和域都会被静态绑定</p><p>以上2、3、4三个阶段又合称为链接阶段，链接阶段要做的是将加载到JVM中的二进制字节流的类数据信息合并到JVM的运行时状态中。</p><p><b>5、初始化（先父后子）</b></p><p><b>5.1 为静态变量赋值</b></p><p><b>5.2 执行static代码块</b></p><p><b>注意：static代码块只有jvm能够调用</b></p><p>如果是多线程需要同时初始化一个类，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。</p><p>因为子类存在对父类的依赖，所以类的加载顺序是先加载父类后加载子类，初始化也一样。不过，父类初始化时，子类静态变量的值也有有的，是默认值。</p><p>最终，方法区会存储当前类类信息，包括类的静态变量、类初始化代码（定义静态变量时的赋值语句 和 静态初始化代码块）、实例变量定义、实例初始化代码（定义实例变量时的赋值语句实例代码块和构造方法）和实例方法，还有父类的类信息引用。</p><p><b>二、创建对象</b></p><p><b>1、在堆区分配对象需要的内存</b></p><p>分配的内存包括本类和父类的所有实例变量，但不包括任何静态变量</p><p><b>2、对所有实例变量赋默认值</b></p><p>将方法区内对实例变量的定义拷贝一份到堆区，然后赋默认值</p><p><b>3、执行实例初始化代码</b></p><p>初始化顺序是先初始化父类再初始化子类，初始化时先执行实例代码块然后是构造方法</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f091ea31117f2b77921b9c7f772410ec_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"372\" data-rawheight=\"463\" data-thumbnail=\"https://pic1.zhimg.com/v2-f091ea31117f2b77921b9c7f772410ec_b.jpg\" class=\"content_image\" width=\"372\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;372&#39; height=&#39;463&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"372\" data-rawheight=\"463\" data-thumbnail=\"https://pic1.zhimg.com/v2-f091ea31117f2b77921b9c7f772410ec_b.jpg\" class=\"content_image lazy\" width=\"372\" data-actualsrc=\"https://pic1.zhimg.com/v2-f091ea31117f2b77921b9c7f772410ec_b.gif\"/></figure><p>4、如果有类似于Child c = new Child()形式的c引用的话，在栈区定义Child类型引用变量c，然后将堆区对象的地址赋值给它</p><p>需要注意的是，每个子类对象持有父类对象的引用，可在内部通过super关键字来调用父类对象，但在外部不可访问</p><p><b>补充：</b></p><p>通过实例引用调用实例方法的时候，先从方法区中对象的实际类型信息找，找不到的话再去父类类型信息中找。</p><p>如果继承的层次比较深，要调用的方法位于比较上层的父类，则调用的效率是比较低的，因为每次调用都要经过很多次查找。这时候大多系统会采用一种称为虚方法表的方法来优化调用的效率。</p><p>所谓虚方法表，就是在类加载的时候，为每个类创建一个表，这个表包括该类的对象所有动态绑定的方法及其地址，包括父类的方法，但一个方法只有一条记录，子类重写了父类方法后只会保留子类的。当通过对象动态绑定方法的时候，只需要查找这个表就可以了，而不需要挨个查找每个父类。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59098692", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "zookeeper知识点整理", 
            "content": "<h2><b><code>ZooKeeper</code>是什么？</b></h2><p><code>ZooKeeper</code>是一个开放源码的分布式协调服务，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户,因为Google的Chubby的开源实现。</p><h2><b><code>ZooKeeper</code>能干什么？</b></h2><p>分布式应用程序可以基于<code>Zookeeper</code>实现诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知、集群管理、<code>Master</code>选举、分布式锁和分布式队列等功能。</p><h2><b><code>ZooKeeper</code>保证了如下分布式一致性特性</b></h2><ul><li>顺序一致性</li><li>原子性</li><li>单一视图</li><li>可靠性</li><li>实时性（最终一致性）</li></ul><h2><b><code>ZooKeeper</code>四种节点</b></h2><ul><li>PERSISTENT-持久节点除非手动删除，否则节点一直存在于Zookeeper上</li><li>EPHEMERAL-临时节点临时节点的生命周期与客户端会话绑定，一旦客户端会话失效（客户端与zookeeper连接断开不一定会话失效），那么这个客户端创建的所有临时节点都会被移除。</li><li>PERSISTENT_SEQUENTIAL-持久顺序节点基本特性同持久节点，只是增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li><li>EPHEMERAL_SEQUENTIAL-临时顺序节点基本特性同临时节点，增加了顺序属性，节点名后边会追加一个由父节点维护的自增整型数字。</li></ul><h2><b><code>ZooKeeper</code>服务器角色</b></h2><h2><b>Leader</b></h2><ul><li>事务请求的唯一调度和处理者，保证集群事务处理的顺序性</li><li>集群内部各服务的调度者</li></ul><h2><b>Follower</b></h2><ul><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>参与事务请求Proposal的投票</li><li>参与Leader选举投票</li></ul><h2><b>Observer</b></h2><p>3.3.0版本以后引入的一个服务器角色，在不影响集群事务处理能力的基础上提升集群的非事务处理能力</p><ul><li>处理客户端的非事务请求，转发事务请求给Leader服务器</li><li>不参与任何形式的投票</li></ul><h2><b><code>ZooKeeper</code>服务工作状态</b></h2><p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p><ul><li>LOOKING：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</li><li>FOLLOWING：跟随者状态。表明当前服务器角色是Follower。</li><li>LEADING：领导者状态。表明当前服务器角色是Leader。</li><li>OBSERVING：观察者状态。表明当前服务器角色是Observer。</li></ul><h2><b>集群支持动态添加机器吗？</b></h2><p>其实就是水平扩容了，Zookeeper在这方面不太好。两种方式：</p><ul><li>全部重启：关闭所有Zookeeper服务，修改配置之后启动。不影响之前客户端的会话。</li><li>逐个重启：在过半存活即可用的原则下，一台机器重启不影响整个集群对外提供服务。这是比较常用的方式。</li></ul><p>3.5版本开始支持动态扩容。</p><h2><b><code>ZAB</code>和<code>Paxos</code>算法的联系与区别？</b></h2><ul><li>相同点：</li><ul><li>两者都存在一个类似于Leader进程的角色，由其负责协调多个Follower进程的运行</li><li>Leader进程都会等待<b>超过半数</b>的Follower做出正确的反馈后，才会将一个提案进行提交</li><li><code>ZAB</code>协议中，每个<code>Proposal中</code>都包含一个 <code>epoch</code>值来代表当前的<code>Leader</code>周期，<code>Paxos</code>中名字为<code>Ballot</code></li></ul><li>不同点：<code>ZAB</code>用来构建高可用的分布式数据主备系统（<code>Zookeeper</code>），<code>Paxos</code>是用来构建分布式一致性状态机系统。</li></ul><h2><b><code>ZAB</code>协议是什么？</b></h2><p><code>ZAB</code>协议是为分布式协调服务<code>Zookeeper</code>专门设计的一种支持崩溃恢复的原子广播协议。</p><p><code>ZAB</code>协议包括两种基本的模式：崩溃恢复和消息广播。</p><p>当整个<code>zookeeper</code>集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与Leader服务器保持正常通信时，所有进程（服务器）进入崩溃恢复模式，首先选举产生新的Leader服务器，然后集群中Follower服务器开始与新的Leader服务器进行数据同步，当集群中超过半数机器与该Leader服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader服务器开始接收客户端的事务请求生成事物提案来进行事务请求处理。</p><h2><b><code>Zookeeper Watcher</code> 机制 -- 数据变更通知</b></h2><p><code>Zookeeper</code>允许客户端向服务端的某个<code>Znode</code>注册一个<code>Watcher</code>监听，当服务端的一些指定事件触发了这个<code>Watcher</code>，服务端会向指定客户端发送一个事件通知来实现分布式的通知功能，然后客户端根据<code>Watcher</code>通知状态和事件类型做出业务上的改变。</p><p>工作机制：</p><ul><li>客户端注册<code>watcher</code></li><li>服务端处理<code>watcher</code></li><li>客户端回调<code>watcher</code></li></ul><p><code>Watcher</code>特性总结：</p><ol><li>一次性无论是服务端还是客户端，一旦一个<code>Watcher</code>被触发，<code>Zookeeper</code>都会将其从相应的存储中移除。这样的设计有效的减轻了服务端的压力，不然对于更新非常频繁的节点，服务端会不断的向客户端发送事件通知，无论对于网络还是服务端的压力都非常大。</li><li>客户端串行执行客户端<code>Watcher</code>回调的过程是一个串行同步的过程。</li><li>轻量</li></ol><ul><li><code>Watcher</code>通知非常简单，只会告诉客户端发生了事件，而不会说明事件的具体内容。</li><li>客户端向服务端注册<code>Watcher</code>的时候，并不会把客户端真实的<code>Watcher</code>对象实体传递到服务端，仅仅是在客户端请求中使用<code>boolean</code>类型属性进行了标记。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-83145433989c24200e4f96a094eeedd3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"403\" data-rawheight=\"272\" class=\"content_image\" width=\"403\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;403&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"403\" data-rawheight=\"272\" class=\"content_image lazy\" width=\"403\" data-actualsrc=\"https://pic4.zhimg.com/v2-83145433989c24200e4f96a094eeedd3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li><code>watcher event</code>异步发送<code>watcher</code>的通知事件从<code>server</code>发送到<code>client</code>是异步的，这就存在一个问题，不同的客户端和服务器之间通过<code>socket</code>进行通信，由于网络延迟或其他因素导致客户端在不通的时刻监听到事件，由于<code>Zookeeper</code>本身提供了<code>ordering guarantee</code>，即客户端监听事件后，才会感知它所监视<code>znode</code>发生了变化。所以我们使用<code>Zookeeper</code>不能期望能够监控到节点每次的变化。<code>Zookeeper</code>只能保证最终的一致性，而无法保证强一致性。</li><li>注册<code>watcher getData、exists、getChildren</code></li><li>触发<code>watcher create、delete、setData</code></li><li>当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的<code>znode</code>的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。</li></ol><h2><b><code>zookeeper</code>节点宕机如何处理？</b></h2><p><code>zookeeper</code>本身也是集群，推荐配置不少于3个服务器。<code>zookeeper</code>自身也要保证当一个节点宕机时，其他节点会继续提供服务。如果是一个Follower宕机，还有2台服务器提供访问，因为<code>zookeeper</code>上的数据是有多个副本的，数据并不会丢失；如果是一个Leader宕机，<code>zookeeper</code>会选举出新的Leader。<code>zookeeper</code>集群的机制是只要超过半数的节点正常，集群就能正常提供服务。只有在<code>zookeeper</code>节点挂得太多，只剩一半或不到一半节点能工作，集群才失效。所以3个节点的cluster可以挂掉1个节点(leader可以得到2票&gt;1.5),2个节点的cluster就不能挂掉任何1个节点了(leader可以得到1票&lt;=1);</p><h2><b><code>zookeeper</code>是如何选举主leader的？</b></h2><p>当leader崩溃或者leader失去大多数的follower，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。Zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为<b><code>fast paxos</code></b>。<br/>更多...</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-20464b82e6d130919b7b1bcd9902629d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"589\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-20464b82e6d130919b7b1bcd9902629d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;589&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"589\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-20464b82e6d130919b7b1bcd9902629d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-20464b82e6d130919b7b1bcd9902629d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6ad503c632cf400a9527eda772103903_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"238\" data-rawheight=\"268\" class=\"content_image\" width=\"238\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;238&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"238\" data-rawheight=\"268\" class=\"content_image lazy\" width=\"238\" data-actualsrc=\"https://pic4.zhimg.com/v2-6ad503c632cf400a9527eda772103903_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b687be065d4a5c2a90447de490a6b655_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-b687be065d4a5c2a90447de490a6b655_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;528&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-b687be065d4a5c2a90447de490a6b655_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b687be065d4a5c2a90447de490a6b655_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-80dcc84be5852f34a0e84c97930e9ba0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"749\" data-original=\"https://pic1.zhimg.com/v2-80dcc84be5852f34a0e84c97930e9ba0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;749&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"749\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"749\" data-original=\"https://pic1.zhimg.com/v2-80dcc84be5852f34a0e84c97930e9ba0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-80dcc84be5852f34a0e84c97930e9ba0_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "集群", 
                    "tagLink": "https://api.zhihu.com/topics/19596215"
                }, 
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }, 
                {
                    "tag": "dubbo", 
                    "tagLink": "https://api.zhihu.com/topics/20032385"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55210836", 
            "userName": "Brain wang", 
            "userLink": "https://www.zhihu.com/people/9ce1f280caa0cb83a4c032b5e1087ec6", 
            "upvote": 4, 
            "title": "K8S使用就绪和存活探针配置健康检查", 
            "content": "<h2><b>一、 健康检查</b></h2><p><br/>健康检查（Health Check）可用于服务运行的状态监控，比如腾讯旗下的DNSPOD的D监控，要求配置一个访问路径以判断网站是否可以正常访问实际上就是一个健康检查，当发现健康检查失败时会发送一个邮件通知或者短信来告知网站管理员进行维修。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7a4df6cf83f55e4ba90550b8a15d33e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"1134\" class=\"origin_image zh-lightbox-thumb\" width=\"1047\" data-original=\"https://pic1.zhimg.com/v2-7a4df6cf83f55e4ba90550b8a15d33e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1047&#39; height=&#39;1134&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1047\" data-rawheight=\"1134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1047\" data-original=\"https://pic1.zhimg.com/v2-7a4df6cf83f55e4ba90550b8a15d33e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7a4df6cf83f55e4ba90550b8a15d33e4_b.jpg\"/></figure><p>而在现代一些分布式系统中，用户访问不再是单台主机，而是一个由成百上千台实例组成的<b>集群</b>，用户请求通过<b>负载均衡器</b>分发到不同的实例，<b>负载均衡</b>帮助解决单台服务器的访问压力，同时提高了系统的<b>高可用性</b>，而<b>健康检查</b>常常作为当前实例是否“可用”的判断标准。即：<b>当系统发现某台实例健康检查不通过，负载均衡器将不会把流量导向该实例</b>。<br/>现在的云服务厂商比如AWS一般都为负载均衡配备了健康检查，而<b>Kubernetes</b>提供了两种探针来检查容器的状态，Liveliness和Readiness，根据官方文档，Liveliness探针是为了查看容器是否正在运行，翻译为<b>存活探针</b>（livenessProbe），Readiness探针是为了查看容器是否准备好接受HTTP请求，翻译为<b>就绪探针</b>（readinessProbe）。 在Kubernetes中，Pod是Kubernetes创建及管理的最小的可部署的计算单元，一个Pod由一个或者多个容器（Docker，rocket等等）组成，这些容器共享内存，网络以及运行容器的方式。<br/>在Kubernetes上下文中<b>存活探针和就绪探针</b>被称作<b>健康检查</b>。这些容器探针是一些周期性运行的小进程，这些探针返回的结果（成功，失败或者未知）反映了容器在Kubernetes的状态。基于这些结果，Kubernetes会判断如何处理每个容器，以保证弹性，高可用性和更长的正常运行时间。<br/><b>就绪探针</b><br/>就绪探针旨在让Kubernetes知道你的应用<b>是否准备好为请求提供服务</b>。Kubernetes只有在就绪探针通过才会把流量转发到Pod。如果就绪探针检测失败，Kubernetes将停止向该容器发送流量，直到它通过。<br/></p><p><b>存活探针</b></p><p><br/>Liveness探测器是让Kubernetes知道你的<b>应用是否活着</b>。如果你的应用还活着，那么Kubernetes就让它继续存在。如果你的应用程序已经死了，Kubernetes将移除Pod并重新启动一个来替换它。</p><h2><br/><b>二、工作过程</b></h2><p><br/>让我们看看两个场景，来看看就绪探针和存活探针怎样帮助我们构建更高可用的的系统。<br/><b>就绪探针</b><br/>一个应用往往需要一段时间来预热和启动，比如一个后端项目的启动需要连接数据库执行数据库迁移等等，一个Spring项目的启动也需要依赖Java虚拟机。即使该过程已启动，您的服务在启动并运行之前也无法运行。应用在完全就绪之前不应接收流量，但默认情况下，Kubernetes会在容器内的进程启动后立即开始发送流量。通过就绪探针探测，直到应用程序完全启动，然后才允许将流量发送到新副本。<br/></p><figure data-size=\"small\"><noscript><img src=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_b.gif\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1010\" data-rawheight=\"862\" data-thumbnail=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1010\" data-original=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1010&#39; height=&#39;862&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1010\" data-rawheight=\"862\" data-thumbnail=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1010\" data-original=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7dd35978297b4c44a916dac271929872_b.gif\"/></figure><p><b>存活探针</b><br/>让我们想象另一种情况，当我们的应用在成功启动以后因为一些原因“宕机”，或者遇到死锁情况，导致它无法响应用户请求。 在默认情况下，Kubernetes会继续向Pod发送请求，通过使用存活探针来检测，当发现服务不能在限定时间内处理请求（请求错误或者超时），就会重新启动有问题的pod。<br/></p><figure data-size=\"small\"><noscript><img src=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_b.gif\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1010\" data-rawheight=\"862\" data-thumbnail=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1010\" data-original=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1010&#39; height=&#39;862&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1010\" data-rawheight=\"862\" data-thumbnail=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1010\" data-original=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-05ec3fb33fa8412a4ba60a24ea510f6c_b.gif\"/></figure><p><b>探针类型</b><br/>探针类型是指通过何种方式来进行健康检查，K8S有三种类型的探测：HTTP，Command和TCP。</p><p><b>HTTP</b> </p><p>HTTP探测可能是最常见的探针类型。即使应用不是HTTP服务，也可以创建一个轻量级HTTP服务器来响应探测。比如让Kubernetes通过HTTP访问一个URL，如果返回码在200到300范围内，就将应用程序标记为健康状态，否则它被标记为不健康。 更多关于HTTP探测可参考这里。</p><p><br/><b>命令</b></p><p> 对于命令探测，是指Kubernetes在容器内运行命令。如果命令以退出代码0返回，则容器将标记为正常。否则，它被标记为不健康。 更多关于命令探测可参考这里。<br/></p><p><b>TCP</b> </p><p>最后一种类型的探测是TCP探测，Kubernetes尝试在指定端口上建立TCP连接。如果它可以建立连接，容器被认为是健康的; 如果它不能被认为是不健康的。这常用于对gRPC或FTP服务的探测。<br/>更多关于TCP探测可参考这里。</p><p><br/><b>初始探测延迟</b><br/>我们可以配置K8S健康检查运行的频率，检查成功或失败的条件，以及响应的超时时间。可参考有关配置探针的文档。<br/>存活探针探测失败会导致pod重新启动，所以配置初始探测延迟 <code>initialDelaySeconds</code>十分重要，要确保在应用准备之后探针才启动。否则，应用将无限重启！<br/>我建议使用p99启动时间作为initialDelaySeconds，或者取平均启动时间外加一个buffer。同时根据应用程序的启动时间更新这个值。</p><h2><br/><b>三、举例</b></h2><p><br/>以下面的一个K8S的配置代码为例，<br/></p><ul><li>K8S将在Pod开始<b>启动后120s(initialDelaySeconds)后</b>利用HTTP访问8080端口的 <code>/actuator/health</code>，如果<b>超过10s</b>或者返回码不在200~300内，就绪检查就失败</li><li>类似的，在Pod运行过程中，K8S仍然会每隔5s(periodSeconds检测8080端口的 <code>/actuator/health</code> </li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><br/><b>参考资料</b><br/></p><ul><li>【Kubernetes best practices: Setting up health checks with readiness and liveness probes】</li><li>【Kubernetes存活探针和就绪探针的最佳实践】</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>原文链接：<a href=\"https://link.zhihu.com/?target=https%3A//wangbaiyuan.cn/k8s-health-examination-with-ready-survival-probes.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">K8S使用就绪和存活探针配置健康检查 | 王柏元的博客</a></p><p><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-34aee97d90895fa38c31eb5dd0cdf610_b.jpg\" data-size=\"normal\" data-rawwidth=\"344\" data-rawheight=\"344\" class=\"content_image\" width=\"344\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;344&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"344\" data-rawheight=\"344\" class=\"content_image lazy\" width=\"344\" data-actualsrc=\"https://pic1.zhimg.com/v2-34aee97d90895fa38c31eb5dd0cdf610_b.jpg\"/><figcaption>关注《我是极客人》微信公众号</figcaption></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "网站架构", 
                    "tagLink": "https://api.zhihu.com/topics/19557963"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }, 
                {
                    "tag": "Kubernetes", 
                    "tagLink": "https://api.zhihu.com/topics/20018384"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/54157792", 
            "userName": "陈志发", 
            "userLink": "https://www.zhihu.com/people/8a5d03f91d3467064b2c693749cf4569", 
            "upvote": 0, 
            "title": "Chrome 的新 Bug，CPU 使用率飙升至 100%!", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;422&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最近在 Google Chrome 中发现了一个新的 Bug，使用 JavaScript 创建一个循环，最终会导致 Google Chrome 耗尽计算机上的所有 CPU 资源并使浏览器卡死。</p><p>Google Chrome 在错误报告中报告了这个 Bug，该报告指出，一旦用户访问该页面，CPU 利用率很快就会达到 100％。这使得无法关闭 Google Chrome 选项卡、浏览器或使用计算机，直到 Chrome 进程结束。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Google Bug 报告</p><p>访问下列的网址时，您将被带到这个 Bug 的页面，其标题为“Internet Security Alert! Code: 055BCCAC9FEC”。此页伪装成 Windows 错误标题&#34;Internet Security Alert! Code: 055BCCAC9FEC&#34;，表明您的计算机已被感染，您应该拨打列出的电话号码以获取帮助。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此页面包含的 JavaScript 将导致浏览器重复跳转到一个网址，然后 Google Chrome 返回按钮转到浏览器历史记录，然后再转到前进按钮返回原始页面。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Javascript 循环</p><p>此循环让浏览器使用了计算机的所有 CPU 资源，如下面的 Chrome 任务管理器中所示。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;703&#39; height=&#39;367&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>CPU 利用率</b></p><p>如此高的 CPU 利用率最终会导致浏览器冻结，计算机几乎无法使用。此时，关闭浏览器的唯一方法是通过 Windows 任务管理器等工具，关闭 Chrome.exe 进程。</p><p>问题在于，在关闭流程后重新打开 Chrome 后，它会提示你恢复打开之前的页面。这将 Bug 页面重新打开，再次导致浏览器/计算机出现问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>重新打开 Chrome</p><p>因此，当 Bug 影响并终止浏览器进程时，请你不要允许 Chrome 恢复之前打开的页面。</p><p>在 BleepingComputer 的测试中，同样的技术支持骗局不会影响 Firefox。在 Firefox，遇到此 Bug 只需关闭选项卡和浏览器即可。</p>", 
            "topic": [
                {
                    "tag": "CPU 更换", 
                    "tagLink": "https://api.zhihu.com/topics/19650528"
                }, 
                {
                    "tag": "中央处理器 (CPU)", 
                    "tagLink": "https://api.zhihu.com/topics/19553309"
                }, 
                {
                    "tag": "Bug 修复", 
                    "tagLink": "https://api.zhihu.com/topics/19629729"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53502119", 
            "userName": "陈志发", 
            "userLink": "https://www.zhihu.com/people/8a5d03f91d3467064b2c693749cf4569", 
            "upvote": 0, 
            "title": "Chrome 的新 Bug，CPU 使用率飙升至 100%!", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;422&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d3ef7de00b9df541b40c0d1c76bfc59_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最近在 Google Chrome 中发现了一个新的 Bug，使用 JavaScript 创建一个循环，最终会导致 Google Chrome 耗尽计算机上的所有 CPU 资源并使浏览器卡死。</p><p>Google Chrome 在错误报告中报告了这个 Bug，该报告指出，一旦用户访问该页面，CPU 利用率很快就会达到 100％。这使得无法关闭 Google Chrome 选项卡、浏览器或使用计算机，直到 Chrome 进程结束。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-10ec8f5735c2443d6085f14609641e8e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Google Bug 报告</p><p>访问下列的网址时，您将被带到这个 Bug 的页面，其标题为“Internet Security Alert! Code: 055BCCAC9FEC”。此页伪装成 Windows 错误标题&#34;Internet Security Alert! Code: 055BCCAC9FEC&#34;，表明您的计算机已被感染，您应该拨打列出的电话号码以获取帮助。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6a919335fd89b890b67fa4beb818e4a2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此页面包含的 JavaScript 将导致浏览器重复跳转到一个网址，然后 Google Chrome 返回按钮转到浏览器历史记录，然后再转到前进按钮返回原始页面。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;545&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"545\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ccf0e514f0584ac3d71d52f354f98cf1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Javascript 循环</p><p>此循环让浏览器使用了计算机的所有 CPU 资源，如下面的 Chrome 任务管理器中所示。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;703&#39; height=&#39;367&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"703\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"703\" data-original=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-39f542c37c3a2d0e383fa2e47bbcf074_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>CPU 利用率</b></p><p>如此高的 CPU 利用率最终会导致浏览器冻结，计算机几乎无法使用。此时，关闭浏览器的唯一方法是通过 Windows 任务管理器等工具，关闭 Chrome.exe 进程。</p><p>问题在于，在关闭流程后重新打开 Chrome 后，它会提示你恢复打开之前的页面。这将 Bug 页面重新打开，再次导致浏览器/计算机出现问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0abf6513d3f6d1f62ae72fd02ae2ae66_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>重新打开 Chrome</p><p>因此，当 Bug 影响并终止浏览器进程时，请你不要允许 Chrome 恢复之前打开的页面。</p><p>在 BleepingComputer 的测试中，同样的技术支持骗局不会影响 Firefox。在 Firefox，遇到此 Bug 只需关闭选项卡和浏览器即可。</p>", 
            "topic": [
                {
                    "tag": "CPU 指令集", 
                    "tagLink": "https://api.zhihu.com/topics/19823428"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53346916", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 3, 
            "title": "从事IT业内16年的人士告诉你，大学生该不该参加IT培训？", 
            "content": "<p><b>本篇文章来着于我在09年时的培训学校的校长（老师|老大）所发。通读之后，感觉写的非常深刻，可以说非常符合当前的IT公司招人场景，于是拷贝过来，跟大家进行分享：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-55b4bf09b6a2eee2cc4f4ab8c13acfb9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1280\" class=\"origin_image zh-lightbox-thumb\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-55b4bf09b6a2eee2cc4f4ab8c13acfb9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1920&#39; height=&#39;1280&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1280\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1920\" data-original=\"https://pic2.zhimg.com/v2-55b4bf09b6a2eee2cc4f4ab8c13acfb9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-55b4bf09b6a2eee2cc4f4ab8c13acfb9_b.jpg\"/></figure><p>众所周知，妖魔化IT培训机构和IT培训机构培训出来的学生，在程序员聚集的社区，似乎成了一种政治正确。作为一个8年软件公司研发经验、16年IT培训机构从业经验的业内人士，我从自己的角度谈谈对大学生参加IT培训班的看法。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a948cf15c2ae6ef104e8af4a823a8874_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"525\" data-original=\"https://pic1.zhimg.com/v2-a948cf15c2ae6ef104e8af4a823a8874_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;525&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"525\" data-original=\"https://pic1.zhimg.com/v2-a948cf15c2ae6ef104e8af4a823a8874_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a948cf15c2ae6ef104e8af4a823a8874_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>很多人说，大学刚毕业的年轻人想有不错的前途，首先选择<b>就业城市</b>，其次是<b>行业，</b>这个观点很有道理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>年轻时候应该到GDP高的地方去，比如北上广深这样的一线城市。对于四川年轻人来说，“火锅、折耳根、串串”是离不开家乡的一个主要原因，因此成都就是首选了。</p><p><b>成都算是一线半到二线城市，GDP排名全国靠前。</b></p><p>有人说GDP高的地方，房价高，物价高，生存压力太大，很难出头。这里有一个误区，GDP高的地方肯定生存压力大，但是压力会促使你更努力学习、锻炼自己。</p><p>人在年轻的时候精力充沛，可塑性强，潜力无限！如果年轻时在GDP低的地方逍遥放松，二十来岁就处于“退休状态”，能力得不到充分的锻炼，三十而立时，<b>你哪来的竞争力，你何以对家庭负责？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>说到这里，印象最深的是一个早年毕业的学生，毕业后在成都工作四个月不到，去了北京，鬼使神差进了Oracle。几年后，以P7级别进淘宝，几年后晋升P8。现在在腾讯，级别是<b>T4.1</b>。我一直想不明白，一个普通大学毕业的学生，在我们这里学习时也没展现多高天份，怎么就进了Oracle，怎么就到T4.1这级别呢？不可否认，除了个人努力之外，环境也很重要，GDP高的地方对人的锻炼以及机会，是GDP低的地方远不能及的。<br/>我们统计发现，早年去北上广深就业的学生，干了几年后回成都，如今技术能力和眼界比同班级选择在GDP低的高出很多。所以，我在我们学生毕业前，都会鼓励他们去GDP高的城市闯荡几年。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>至于行业，</b>作为一个既不是官二代又不是富二代的普通家庭出身的年轻人，要在成都这座城市生存下去，肯定要选起步收入不错的行业。</p><p>金融行业收入不错，但是门槛高，高学历，专业对口（PS：金融行业不包括到处打电话推销保险和贷款的！）。其次是政府支持、发展迅猛的软件开发行业了。高新区发展那么快，软件园那么大，在四川，你还能找出几个比软件开发行业发展更快的产业么？你还能找出几个软件开发行业收入更高的行业么？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>记得2006年我们创立XX学校时，高新区软件园规模小，软件公司不多。业务稳定了，招生多了，我时常忧虑一年几百人，不到几年软件园被我们学生占领完，就业不好，我们这生意还怎么做下去呢？</p><p><b>但不到两年，IT产业规模越来越大，这种担忧就完全没有了。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-402d45b35d42789982f7a625d647ce9a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb\" width=\"634\" data-original=\"https://pic3.zhimg.com/v2-402d45b35d42789982f7a625d647ce9a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;634&#39; height=&#39;196&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"634\" data-rawheight=\"196\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"634\" data-original=\"https://pic3.zhimg.com/v2-402d45b35d42789982f7a625d647ce9a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-402d45b35d42789982f7a625d647ce9a_b.jpg\"/></figure><p>如今成都IT培训机构扩张到五十几家，丝毫没有影响我们学生的就业。</p><p><b>相反学生就业速度越来越快，两周之内达到100%就业率的班级越来越多。</b>经在读和已就业学生介绍来学习的人数，就是所谓<b>口碑招生</b>，已达到一年三百多人，数据显示，口碑学生多由毕业两三年的学生转介绍。试想一下，一个学生毕业后在软件开发行业不能找到工作，就业两三年后收入不能大幅度的提升，还会介绍朋友、亲戚、家人、同学进这行么？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>曾经的成都，IT行业与一线城市北上广深差距相当大，从业人员收入差距也相当大。十几年过来，成都市政府对IT产业的支持政策陆续出台，从当年支持数字娱乐产业，到支持外包产业，到吸引世界五百强，到支持互联网产业、移动互联网、电子商务、互联网金融...与支持政策配套的成都高新区产业区规模越来越大，<b>从当初只有孵化园和软件园A区、B区，到现在C、D、E、F、G区...。十几年发展，除了本土软件公司和外企以外，华为、蚂蚁金服、腾讯、京东等国内一流公司也纷纷在成都落户，好的公司越来越多</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-59672e42cd423630980b9061fda0c271_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb\" width=\"561\" data-original=\"https://pic2.zhimg.com/v2-59672e42cd423630980b9061fda0c271_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;561&#39; height=&#39;503&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"561\" data-original=\"https://pic2.zhimg.com/v2-59672e42cd423630980b9061fda0c271_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-59672e42cd423630980b9061fda0c271_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如今在成都软件开发行业，拿到二十万、三十万甚至更高的年收入并非难事。公司多了，跳槽选择余地大了，涨薪容易了，拿到高薪的机会更多了，所以才带来我们口碑招生人数的急剧增长。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c6c58f9c4787d8f10a6c7cd49f99d9fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"458\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb\" width=\"458\" data-original=\"https://pic1.zhimg.com/v2-c6c58f9c4787d8f10a6c7cd49f99d9fc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;458&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"458\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"458\" data-original=\"https://pic1.zhimg.com/v2-c6c58f9c4787d8f10a6c7cd49f99d9fc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c6c58f9c4787d8f10a6c7cd49f99d9fc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>前面说了，软件开发这行业不错。但是，很多人还是认为门槛高，甚至业内不少激进人士也持同样观点！</p><p>真有那么高么？在我看来，这纯属危言耸听。一个拥有普通大学学历的年轻人，经过四五个月专业培训就能进入的行业，这能算门槛很高？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>市面上所有软件开发培训机构，除了以招高中生为主的北大青鸟ACCP是一年半以外，全国哪个培训机构教学周期不是四到六个月？整个行业都是这个教学周期，肯定不是偶然。</p><p>从我十几年从业经历来看，四到六个月，是完全可以把一名非计算机专业的大学毕业生带入软件开发行业的。从培训机构毕业的学生，绝大部分人实际项目开发能力远远超出大部分计算机专业刚毕业的本科生，这已经是不争的事实了。也就是说，进入这个行业，不一定需要三四年的计算机专业教育经历，只要有四到六个月的全天专业培训，完全可以从其他专业转到软件开发这个方向。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么会是这样的？道理很简单。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>首先，课时量。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>高校计算机专业本科虽然教学周期有四年（目前大部分高校最后一学期甚至一学年是实习期，实际上是没有教学的），用于就业所需专业知识和技能的课时量少。因为全日制本科教育的核心是通识教育，是培养学生批判性独立思考的能力，并为终身学习打下基础。而专业的知识和技能，是学生们根据自己的意愿，在大学毕业后才需要去学习和掌握的。培训机构四到六个月短期培训，只能重视技能，所有教学时间都投入到就业有关的专业知识和技能上。<br/>按大多数培训机构4个月教学周期、每天8小时、每月22个工作日来算，与就业有关的专业知识和技能培训达到了4x8x22=704个课时之多。虽然就业时综合素质，专业知识和技能同等重要，但对于软件开发公司来说更看重技能，也就是实际项目开发能力。培训机构就业就是生命线，所以会根据软件公司实际技能设置课程体系，教学内容，考核老师。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>其次，课程设置的合理性。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>高校计算机专业，设置了计算机科学基础原理课程，包括模拟电路、数字电路、计算机组成原理、数据库原理、操作系统原理、编译原理等（以川内某本科院校计算机科学与技术专业的课程为例）。不可否认，这些课程至关重要，是计算机科学方向的通识教育。绝大多数IT培训机构，在四到六个月短期技能培训周期内，是不会教授这些课程的，这也是IT培训机构最被人诟病的内容之一。<br/><br/>但是，为什么四到六个月所谓“快速成才”的IT培训机构学生的就业率，并不比四年高校计算机本科专业差，甚至会超过高校计算机本科专业的就业率呢？原因在于，对于初级程序员来说，计算机科学基础原理课程并不重要，实际项目开发所需技能才更为重要。那么，计算机科学基础原理课程对什么重要呢？对初级程序员两三年后能否顺利晋升为中高级程序员是至关重要的。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>除了计算机科学基础原理课程外，大多数高校还开设了C/C++/Java课程。让人觉得不可理喻的是，很多高校大一上C，大二上C++，大三上Java。</p><p>初学阶段，学好一门编程语言则可，需要学其他编程语言，是触类旁通的事情，自学就可以上手。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>为什么要在宝贵的教学时间重复讲授三种风格各异的编程语言？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>一门编程语言学习完后，应该在广度、深度继续加强。为什么总是停留在语言层面上，不继续在应用层面教学呢？而培训机构，4-6个月，都是围绕一门编程语言深入下去。以Java方向为例，学完Java编程语言，会继续教授Java网络编程、Java并发编程、Java Web编程、Java开源框架以及前端、数据库、OOD、OOA等技术，直到具备开发一个Java项目所需的全部能力为止。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>实际上，从教育规律来看，</b>以计算机科学基础原理为主的教学，在应用开发技能没有达到一定程度，学生不知道学了有什么用，能做什么，能用到哪里。而对于初学者来说，计算机科学基础原理课程比应用开发技能的学习难度高很多，容易出现的：<b>学生厌学。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们在教学时，更为强调技能的培训，学生开发出一个接一个实际项目，从而提高学习兴趣，锻炼实际软件项目开发能力。教学中，强调就业后两到三年内必须加强计算机科学基础原理的学习，为顺利晋升中高级程序员做好准备。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>最后，一个最容易被人忽视的问题，学习时间的连续性。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>是在我儿子读大学计算机本科时偶然发现的。我有多年开发和培训经验，深知计算机科学基础原理课程的重要性，所以提醒他在学这些课程时必须全力以赴。同时，我也知道大学阶段在应用技能学习上的不足，专门给他列出了一个学期必须自学完的某个方向的技能。<br/>最后无可奈何地发现，在一个学期甚至一个学年内，要让他完成某个方向从基础到高级全部技能学习，不可能。为什么呢？<br/>他每天的学习，除了包含计算机科学基础原理的专业课程之外，还有英语、数学、语文、思想政治、体育等等。我们都知道，任何一门课程想学好，想通过考试，拿到学位，要花大量的时间。于是，他自学专业技能的时间，被校园课程碎片化了，根本无法保证学习时间的连续性。最后怎么办？只能在最后一学年，抽出几个月的时间到我这里连续学习。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p><b>通过上面的分析，我们大致了解了几点：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote><b>- 大学教育的核心是通识教育，是培养学生批判性独立思考的能力，并为终身学习打下基础。而专业的知识和技能，是学生们根据自己的意愿，在大学毕业后才需要去学习和掌握的。</b><br/><b>- 在计算机科学领域某个方向就业所需的专业技能，通过四到六个月的全天培训就可以掌握。也就是说，进入软件开发行业的门槛并不高。</b><br/><b>- 入了门后能走多远，几年之后收入增长的幅度有多高，取决于对计算机科学原理课程的掌握程度。</b></blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>所以，高校计算机专业课程中的计算机科学基础原理课程，是计算机科学领域的通识教育，也就是说，要在计算机科学领域具备终身学习的能力，基础原理课程是必须掌握的。</p><p>这些课程虽然枯燥无味，或者老师能力所限，不能讲解透彻，但是它们对你以后在计算机科学领域能走多深远是至关重要的。在学习计算机原理课程时，务必全力以赴。就算课堂教学效果不佳，互联网上有大量优秀的计算机科学教材以及世界顶级名校的优质教学视频可以辅助学习。至于编程语言，选一门即可，C、C++、Java、Python都可以。没事就到LeeCode上刷刷题，了解自己对计算机科学原理课程的掌握程度。只有掌握了计算机科学核心原理的核心优势，才有可能顺利通过校招进入名企实习，通过实习掌握软件开发所需的专业知识和技能。如果不能进入名企实习，那就只能自己留出来一段连续的学习时间，<b>将某门编程语言在各个方向上的应用延伸下去，逐步掌握就业所需专业知识和技能。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>对于大学非计算机专业学生来说，</b>如果本专业发展前景和就业薪资不够理想，那完全可以选择进入软件开发行业。这行业的门槛并没有外界所说的那么高。通过一两年的自学或者四到六个月的专门培训，完全可以掌握就业所需的专业知识和技能。在工作以后两三年之内，再逐步加强计算机科学原理课程的学习。<b>而且在实践中逐步学习这些计算机科学原理课程，效果会更好，领悟会更深刻。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>由于涉及到具体的培训学校，由于自身公司背景问题，故而使用XX替代，请理解一下！</b></p>", 
            "topic": [
                {
                    "tag": "培训", 
                    "tagLink": "https://api.zhihu.com/topics/19568266"
                }, 
                {
                    "tag": "教育培训", 
                    "tagLink": "https://api.zhihu.com/topics/19599922"
                }, 
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53343810", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "通过 Docker 启动一个博客网站来开启我们的 Docker 之旅", 
            "content": "<blockquote>这篇文章包含 Docker 的基本概念，以及如何通过创建一个定制的 Dockerfile 来 Docker 化（Dockerize）一个应用。</blockquote><p>Docker 是一个过去两年来从某个 idea 中孕育而生的有趣技术，公司组织们用它在世界上每个角落来部署应用。在今天的文章中，我将讲述如何通过“Docker 化（Dockerize）”一个现有的应用，来开始我们的 Docker 之旅。这里提到的应用指的就是这个博客！</p><h2><b>什么是 Docker？</b></h2><p>当我们开始学习 Docker 基本概念时，让我们先去搞清楚什么是 Docker 以及它为什么这么流行。Docker 是一个操作系统容器管理工具，它通过将应用打包在操作系统容器中，来方便我们管理和部署应用。</p><h2><b>容器 vs. 虚拟机</b></h2><p>容器和虚拟机并不完全相似，它是另外一种提供<b>操作系统虚拟化</b>的方式。它和标准的虚拟机还是有所不同。</p><p>标准的虚拟机一般会包括一个完整的操作系统、操作系统软件包、最后还有一至两个应用。这都得益于为虚拟机提供硬件虚拟化的管理程序。这样一来，一个单一的服务器就可以将许多独立的操作系统作为虚拟客户机运行了。</p><p>容器和虚拟机很相似，它们都支持在单一的服务器上运行多个操作环境，只是，在容器中，这些环境并不是一个个完整的操作系统。容器一般只包含必要的操作系统软件包和一些应用。它们通常不会包含一个完整的操作系统或者硬件的虚拟化。这也意味着容器比传统的虚拟机开销更少。</p><p>容器和虚拟机常被误认为是两种对立的技术。虚拟机采用一个物理服务器来提供全功能的操作环境，该环境会和其余虚拟机一起共享这些物理资源。容器一般用来隔离一个单一主机上运行的应用进程，以保证隔离后的进程之间不能相互影响。事实上，容器和 <b>BSD Jails</b> 以及 <code>chroot</code> 进程的相似度，超过了和完整虚拟机的相似度。</p><h2><b>Docker 在容器之上提供了什么</b></h2><p>Docker 本身不是一个容器运行环境，事实上，只是一个与具体实现无关的容器技术，Docker 正在努力支持 <a href=\"https://link.zhihu.com/?target=https%3A//blog.docker.com/2015/08/docker-oracle-solaris-zones/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Solaris Zones</a> 和 <a href=\"https://link.zhihu.com/?target=https%3A//wiki.freebsd.org/Docker\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BSD Jails</a>。Docker 提供了一种管理、打包和部署容器的方式。虽然一定程度上，虚拟机多多少少拥有这些类似的功能，但虚拟机并没有完整拥有绝大多数的容器功能，即使拥有，这些功能用起来都并没有 Docker 来的方便或那么完整。</p><p>现在，我们应该知道 Docker 是什么了，然后，我们将从安装 Docker，并部署一个公开的预构建好的容器开始，学习 Docker 是如何工作的。</p><h2><b>从安装开始</b></h2><p>默认情况下，Docker 并不会自动被安装在您的计算机中，所以，第一步就是安装 Docker 软件包；我们的教学机器系统是 Ubuntu 14.0.4，所以，我们将使用 Apt 软件包管理器，来执行安装操作。</p><p># apt-get install <a href=\"https://link.zhihu.com/?target=http%3A//docker.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">docker.io</span><span class=\"invisible\"></span></a> Reading package lists... Done Building dependency tree<br/>Reading state information... Done The following extra packages will be installed: aufs-tools cgroup-lite git git-man liberror-perl Suggested packages: btrfs-tools debootstrap lxc rinse git-daemon-run git-daemon-sysvinit git-doc git-el git-email git-gui gitk gitweb git-arch git-bzr git-cvs git-mediawiki git-svn The following NEW packages will be installed: aufs-tools cgroup-lite <a href=\"https://link.zhihu.com/?target=http%3A//docker.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">docker.io</span><span class=\"invisible\"></span></a> git git-man liberror-perl 0 upgraded, 6 newly installed, 0 to remove and 0 not upgraded. Need to get 7,553 kB of archives. After this operation, 46.6 MB of additional disk space will be used. Do you want to continue? [Y/n] y</p><p><b>为了检查当前是否有容器运行，我们可以执行<code>docker</code>命令，加上<code>ps</code>选项</b></p><p># docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</p><p><code>docker</code>命令中的<code>ps</code>功能类似于 Linux 的<code>ps</code>命令。它将显示可找到的 Docker 容器及其状态。由于我们并没有启动任何 Docker 容器，所以命令没有显示任何正在运行的容器。</p><h2><b>部署一个预构建好的 nginx Docker 容器</b></h2><p>我比较喜欢的 Docker 特性之一就是 Docker 部署预先构建好的容器的方式，就像<code>yum</code>和<code>apt-get</code>部署包一样。为了更好地解释，我们来部署一个运行着 nginx web 服务器的预构建容器。我们可以继续使用<code>docker</code>命令，这次选择<code>run</code>选项。</p><p># docker run -d nginx Unable to find image &#39;nginx&#39; locally Pulling repository nginx 5c82215b03d1: Download complete e2a4fb18da48: Download complete 58016a5acc80: Download complete 657abfa43d82: Download complete dcb2fe003d16: Download complete c79a417d7c6f: Download complete abb90243122c: Download complete d6137c9e2964: Download complete 85e566ddc7ef: Download complete 69f100eb42b5: Download complete cd720b803060: Download complete 7cc81e9a118a: Download complete</p><p><code>docker</code>命令的<code>run</code>选项，用来通知 Docker 去寻找一个指定的 Docker 镜像，然后启动运行着该镜像的容器。默认情况下，Docker 容器运行在前台，这意味着当你运行<code>docker run</code>命令的时候，你的 shell 会被绑定到容器的控制台以及运行在容器中的进程。为了能在后台运行该 Docker 容器，我们使用了<code>-d</code> (<b>detach</b>)标志。</p><p>再次运行<code>docker ps</code>命令，可以看到 nginx 容器正在运行。</p><p># docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f6d31ab01fc9 nginx:latest nginx -g &#39;daemon off 4 seconds ago Up 3 seconds 443/tcp, 80/tcp desperate_lalande</p><p>从上面的输出信息中，我们可以看到正在运行的名为<code>desperate_lalande</code>的容器，它是由<code>nginx:latest image</code>（LCTT 译注： nginx 最新版本的镜像）构建而来得。</p><h2><b>Docker 镜像</b></h2><p>镜像是 Docker 的核心特征之一，类似于虚拟机镜像。和虚拟机镜像一样，Docker 镜像是一个被保存并打包的容器。当然，Docker 不只是创建镜像，它还可以通过 Docker 仓库发布这些镜像，Docker 仓库和软件包仓库的概念差不多，它让 Docker 能够模仿<code>yum</code>部署软件包的方式来部署镜像。为了更好地理解这是怎么工作的，我们来回顾<code>docker run</code>执行后的输出。</p><p># docker run -d nginx Unable to find image &#39;nginx&#39; locally</p><p>我们可以看到第一条信息是，Docker 不能在本地找到名叫 nginx 的镜像。这是因为当我们执行<code>docker run</code>命令时，告诉 Docker 运行一个基于 nginx 镜像的容器。既然 Docker 要启动一个基于特定镜像的容器，那么 Docker 首先需要找到那个指定镜像。在检查远程仓库之前，Docker 首先检查本地是否存在指定名称的本地镜像。</p><p>因为系统是崭新的，不存在 nginx 镜像，Docker 将选择从 Docker 仓库下载之。</p><p>Pulling repository nginx 5c82215b03d1: Download complete e2a4fb18da48: Download complete 58016a5acc80: Download complete 657abfa43d82: Download complete dcb2fe003d16: Download complete c79a417d7c6f: Download complete abb90243122c: Download complete d6137c9e2964: Download complete 85e566ddc7ef: Download complete 69f100eb42b5: Download complete cd720b803060: Download complete 7cc81e9a118a: Download complete</p><p>这就是第二部分输出信息显示给我们的内容。默认情况下，Docker 会使用 <a href=\"https://link.zhihu.com/?target=https%3A//hub.docker.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker Hub</a> 仓库，该仓库由 Docker 公司维护。</p><p>和 Github 一样，在 Docker Hub 创建公共仓库是免费的，私人仓库就需要缴纳费用了。当然，部署你自己的 Docker 仓库也是可以的，事实上只需要简单地运行<code>docker run registry</code>命令就行了。但在这篇文章中，我们的重点将不是讲解如何部署一个定制的注册服务。</p><h2><b>关闭并移除容器</b></h2><p>在我们继续构建定制容器之前，我们先清理一下 Docker 环境，我们将关闭先前的容器，并移除它。</p><p>我们利用<code>docker</code>命令和<code>run</code>选项运行一个容器，所以，为了停止同一个容器，我们简单地在执行<code>docker</code>命令时，使用<code>kill</code>选项，并指定容器名。</p><p># docker kill desperate_lalande desperate_lalande</p><p>当我们再次执行<code>docker ps</code>，就不再有容器运行了</p><p># docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</p><p>但是，此时，我们这是停止了容器；虽然它不再运行，但仍然存在。默认情况下，<code>docker ps</code>只会显示正在运行的容器，如果我们附加<code>-a</code> (all) 标识，它会显示所有运行和未运行的容器。</p><p># docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f6d31ab01fc9 5c82215b03d1 nginx -g &#39;daemon off 4 weeks ago Exited (-1) About a minute ago desperate_lalande</p><p>为了能完整地移除容器，我们在用<code>docker</code>命令时，附加<code>rm</code>选项。</p><p># docker rm desperate_lalande desperate_lalande</p><p>虽然容器被移除了；但是我们仍拥有可用的<b>nginx</b>镜像（LCTT 译注：镜像缓存）。如果我们重新运行<code>docker run -d nginx</code>，Docker 就无需再次拉取 nginx 镜像即可启动容器。这是因为我们本地系统中已经保存了一个副本。</p><p>为了列出系统中所有的本地镜像，我们运行<code>docker</code>命令，附加<code>images</code>选项。</p><p># docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE nginx latest 9fab4090484a 5 days ago 132.8 MB</p><h2><b>构建我们自己的镜像</b></h2><p>截至目前，我们已经使用了一些基础的 Docker 命令来启动、停止和移除一个预构建好的普通镜像。为了“Docker 化（Dockerize）”这篇博客，我们需要构建我们自己的镜像，也就是创建一个 <b>Dockerfile</b>。</p><p>在大多数虚拟机环境中，如果你想创建一个机器镜像，首先，你需要建立一个新的虚拟机、安装操作系统、安装应用，最后将其转换为一个模板或者镜像。但在 Docker 中，所有这些步骤都可以通过 Dockerfile 实现全自动。Dockerfile 是向 Docker 提供构建指令去构建定制镜像的方式。在这一章节，我们将编写能用来部署这个博客的定制 Dockerfile。</p><h2><b>理解应用</b></h2><p>我们开始构建 Dockerfile 之前，第一步要搞明白，我们需要哪些东西来部署这个博客。</p><p>这个博客本质上是由一个静态站点生成器生成的静态 HTML 页面，这个生成器是我编写的，名为 <b>hamerkop</b>。这个生成器很简单，它所做的就是生成该博客站点。所有的代码和源文件都被我放在了一个公共的 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/madflojo/blog\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Github 仓库</a>。为了部署这篇博客，我们要先从 Github 仓库把这些内容拉取下来，然后安装 <b>Python</b> 和一些 <b>Python</b> 模块，最后执行<code>hamerkop</code>应用。我们还需要安装 <b>nginx</b>，来运行生成后的内容。</p><p>截止目前，这些还是一个简单的 Dockerfile，但它却给我们展示了相当多的 Dockerfile 语法。我们需要克隆 Github 仓库，然后使用你最喜欢的编辑器编写 Dockerfile，我选择<code>vi</code></p><p># git clone <a href=\"https://link.zhihu.com/?target=https%3A//github.com/madflojo/blog.git\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/madflojo/blo</span><span class=\"invisible\">g.git</span><span class=\"ellipsis\"></span></a> Cloning into &#39;blog&#39;... remote: Counting objects: 622, done. remote: Total 622 (delta 0), reused 0 (delta 0), pack-reused 622 Receiving objects: 100% (622/622), 14.80 MiB | 1.06 MiB/s, done. Resolving deltas: 100% (242/242), done. Checking connectivity... done. # cd blog/ # vi Dockerfile</p><h2><b>FROM - 继承一个 Docker 镜像</b></h2><p>第一条 Dockerfile 指令是<code>FROM</code>指令。这将指定一个现存的镜像作为我们的基础镜像。这也从根本上给我们提供了继承其他 Docker 镜像的途径。在本例中，我们还是从刚刚我们使用的 <b>nginx</b> 开始，如果我们想从头开始，我们可以通过指定<code>ubuntu:latest</code>来使用 <b>Ubuntu</b> Docker 镜像。</p><h2>Dockerfile that generates an instance of <a href=\"https://link.zhihu.com/?target=http%3A//bencane.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://bencane.com</a></h2><p>FROM nginx:latest MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a></p><p>除了<code>FROM</code>指令，我还使用了<code>MAINTAINER</code>，它用来显示 Dockerfile 的作者。</p><p>Docker 支持使用<code>#</code>作为注释，我将经常使用该语法，来解释 Dockerfile 的部分内容。</p><h2><b>运行一次测试构建</b></h2><p>因为我们继承了 <b>nginx</b> Docker镜像，我们现在的 Dockerfile 也就包括了用来构建 <b>nginx</b>镜像的 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/nginxinc/docker-nginx/blob/08eeb0e3f0a5ee40cbc2bc01f0004c2aa5b78c15/Dockerfile\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dockerfile</a> 中所有指令。这意味着，此时我们可以从该 Dockerfile 中构建出一个 Docker 镜像，然后以该镜像运行一个容器。虽然，最终的镜像和 <b>nginx</b> 镜像本质上是一样的，但是我们这次是通过构建 Dockerfile 的形式，然后我们将讲解 Docker 构建镜像的过程。</p><p>想要从 Dockerfile 构建镜像，我们只需要在运行 <code>docker</code> 命令的时候，加上 <code>build</code> 选项。</p><p># docker build -t blog /root/blog Sending build context to Docker daemon 23.6 MB Sending build context to Docker daemon Step 0 : FROM nginx:latest ---&gt; 9fab4090484a Step 1 : MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a> ---&gt; Running in c97f36450343 ---&gt; 60a44f78d194 Removing intermediate container c97f36450343 Successfully built 60a44f78d194</p><p>上面的例子，我们使用了<code>-t</code> (<b>tag</b>)标识给镜像添加“blog”的标签。实质上我们就是在给镜像命名，如果我们不指定标签，就只能通过 Docker 分配的 <b>Image ID</b> 来访问镜像了。本例中，从 Docker 构建成功的信息可以看出，<b>Image ID</b>值为 <code>60a44f78d194</code>。</p><p>除了<code>-t</code>标识外，我还指定了目录<code>/root/blog</code>。该目录被称作“构建目录”，它将包含 Dockerfile，以及其它需要构建该容器的文件。</p><p>现在我们构建成功了，下面我们开始定制该镜像。</p><h2><b>使用 RUN 来执行 apt-get</b></h2><p>用来生成 HTML 页面的静态站点生成器是用 <b>Python</b> 语言编写的，所以，在 Dockerfile 中需要做的第一件定制任务是安装 Python。我们将使用 Apt 软件包管理器来安装 Python 软件包，这意味着在 Dockerfile 中我们要指定运行<code>apt-get update</code>和<code>apt-get install python-dev</code>；为了完成这一点，我们可以使用<code>RUN</code>指令。</p><h2>Dockerfile that generates an instance of <a href=\"https://link.zhihu.com/?target=http%3A//bencane.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://bencane.com</a></h2><p>FROM nginx:latest MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a></p><h2><b>Install python and pip</b></h2><p>RUN apt-get update RUN apt-get install -y python-dev python-pip</p><p>如上所示，我们只是简单地告知 Docker 构建镜像的时候，要去执行指定的<code>apt-get</code>命令。比较有趣的是，这些命令只会在该容器的上下文中执行。这意味着，即使在容器中安装了<code>python-dev</code>和<code>python-pip</code>，但主机本身并没有安装这些。说的更简单点，<code>pip</code>命令将只在容器中执行，出了容器，<code>pip</code>命令不存在。</p><p>还有一点比较重要的是，Docker 构建过程中不接受用户输入。这说明任何被<code>RUN</code>指令执行的命令必须在没有用户输入的时候完成。由于很多应用在安装的过程中需要用户的输入信息，所以这增加了一点难度。不过我们例子中，<code>RUN</code>命令执行的命令都不需要用户输入。</p><h2><b>安装 Python 模块</b></h2><p><b>Python</b> 安装完毕后，我们现在需要安装 Python 模块。如果在 Docker 外做这些事，我们通常使用<code>pip</code>命令，然后参考我的博客 Git 仓库中名叫<code>requirements.txt</code>的文件。在之前的步骤中，我们已经使用<code>git</code>命令成功地将 Github 仓库“克隆”到了<code>/root/blog</code>目录；这个目录碰巧也是我们创建<code>Dockerfile</code>的目录。这很重要，因为这意味着 Docker 在构建过程中可以访问这个 Git 仓库中的内容。</p><p>当我们执行构建后，Docker 将构建的上下文环境设置为指定的“构建目录”。这意味着目录中的所有文件都可以在构建过程中被使用，目录之外的文件（构建环境之外）是不能访问的。</p><p>为了能安装所需的 Python 模块，我们需要将<code>requirements.txt</code>从构建目录拷贝到容器中。我们可以在<code>Dockerfile</code>中使用<code>COPY</code>指令完成这一需求。</p><h2>Dockerfile that generates an instance of <a href=\"https://link.zhihu.com/?target=http%3A//bencane.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://bencane.com</a></h2><p>FROM nginx:latest MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a></p><h2>Install python and pip</h2><p>RUN apt-get update RUN apt-get install -y python-dev python-pip</p><h2>Create a directory for required files</h2><p>RUN mkdir -p /build/</p><h2>Add requirements file and run pip</h2><p>COPY requirements.txt /build/ RUN pip install -r /build/requirements.txt</p><p>在<code>Dockerfile</code>中，我们增加了3条指令。第一条指令使用<code>RUN</code>在容器中创建了<code>/build/</code>目录。该目录用来拷贝生成静态 HTML 页面所需的一切应用文件。第二条指令是<code>COPY</code>指令，它将<code>requirements.txt</code>从“构建目录”(<code>/root/blog</code>)拷贝到容器中的<code>/build/</code>目录。第三条使用<code>RUN</code>指令来执行<code>pip</code>命令；安装<code>requirements.txt</code>文件中指定的所有模块。</p><p>当构建定制镜像时，<code>COPY</code>是条重要的指令。如果在 Dockerfile 中不指定拷贝文件，Docker 镜像将不会包含requirements.txt 这个文件。在 Docker 容器中，所有东西都是隔离的，除非在 Dockerfile 中指定执行，否则容器中不会包括所需的依赖。</p><h2><b>重新运行构建</b></h2><p>现在，我们让 Docker 执行了一些定制任务，现在我们尝试另一次 blog 镜像的构建。</p><p># docker build -t blog /root/blog Sending build context to Docker daemon 19.52 MB Sending build context to Docker daemon Step 0 : FROM nginx:latest ---&gt; 9fab4090484a Step 1 : MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a> ---&gt; Using cache ---&gt; 8e0f1899d1eb Step 2 : RUN apt-get update ---&gt; Using cache ---&gt; 78b36ef1a1a2 Step 3 : RUN apt-get install -y python-dev python-pip ---&gt; Using cache ---&gt; ef4f9382658a Step 4 : RUN mkdir -p /build/ ---&gt; Running in bde05cf1e8fe ---&gt; f4b66e09fa61 Removing intermediate container bde05cf1e8fe Step 5 : COPY requirements.txt /build/ ---&gt; cef11c3fb97c Removing intermediate container 9aa8ff43f4b0 Step 6 : RUN pip install -r /build/requirements.txt ---&gt; Running in c50b15ddd8b1 Downloading/unpacking jinja2 (from -r /build/requirements.txt (line 1)) Downloading/unpacking PyYaml (from -r /build/requirements.txt (line 2))</p><p>&lt;truncated to reduce noise&gt; Successfully installed jinja2 PyYaml mistune markdown MarkupSafe Cleaning up... ---&gt; abab55c20962 Removing intermediate container c50b15ddd8b1 Successfully built abab55c20962</p><p>上述输出所示，我们可以看到构建成功了，我们还可以看到另外一个有趣的信息<code>---&gt; Using cache</code>。这条信息告诉我们，Docker 在构建该镜像时使用了它的构建缓存。</p><h2><b>Docker 构建缓存</b></h2><p>当 Docker 构建镜像时，它不仅仅构建一个单独的镜像；事实上，在构建过程中，它会构建许多镜像。从上面的输出信息可以看出，在每一“步”执行后，Docker 都在创建新的镜像。</p><p>Step 5 : COPY requirements.txt /build/ ---&gt; cef11c3fb97c</p><p>上面片段的最后一行可以看出，Docker 在告诉我们它在创建一个新镜像，因为它打印了<b>Image ID</b> : <code>cef11c3fb97c</code>。这种方式有用之处在于，Docker能在随后构建这个 <b>blog</b> 镜像时将这些镜像作为缓存使用。这很有用处，因为这样， Docker 就能加速同一个容器中新构建任务的构建流程。从上面的例子中，我们可以看出，Docker 没有重新安装<code>python-dev</code>和<code>python-pip</code>包，Docker 则使用了缓存镜像。但是由于 Docker 并没有找到执行<code>mkdir</code>命令的构建缓存，随后的步骤就被一一执行了。</p><p>Docker 构建缓存一定程度上是福音，但有时也是噩梦。这是因为决定使用缓存或者重新运行指令的因素很少。比如，如果<code>requirements.txt</code>文件发生了修改，Docker 会在构建时检测到该变化，然后 Docker 会重新执行该执行那个点往后的所有指令。这得益于 Docker 能查看<code>requirements.txt</code>的文件内容。但是，<code>apt-get</code>命令的执行就是另一回事了。如果提供 Python 软件包的 <b>Apt</b> 仓库包含了一个更新的 python-pip 包；Docker 不会检测到这个变化，转而去使用构建缓存。这会导致之前旧版本的包将被安装。虽然对<code>python-pip</code>来说，这不是主要的问题，但对使用了存在某个致命攻击缺陷的软件包缓存来说，这是个大问题。</p><p>出于这个原因，抛弃 Docker 缓存，定期地重新构建镜像是有好处的。这时，当我们执行 Docker 构建时，我简单地指定<code>--no-cache=True</code>即可。</p><h2><b>部署博客的剩余部分</b></h2><p>Python 软件包和模块安装后，接下来我们将拷贝需要用到的应用文件，然后运行<code>hamerkop</code>应用。我们只需要使用更多的<code>COPY</code> 和 <code>RUN</code>指令就可完成。</p><h2><b>Dockerfile that generates an instance of <a href=\"https://link.zhihu.com/?target=http%3A//bencane.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://bencane.com</a></b></h2><p>FROM nginx:latest MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a></p><h2><b>Install python and pip</b></h2><p>RUN apt-get update RUN apt-get install -y python-dev python-pip</p><h2><b>Create a directory for required files</b></h2><p>RUN mkdir -p /build/</p><h2><b>Add requirements file and run pip</b></h2><p>COPY requirements.txt /build/ RUN pip install -r /build/requirements.txt</p><h2><b>Add blog code nd required files</b></h2><p>COPY static /build/static COPY templates /build/templates COPY hamerkop /build/ COPY config.yml /build/ COPY articles /build/articles</p><h2><b>Run Generator</b></h2><p>RUN /build/hamerkop -c /build/config.yml</p><p>现在我们已经写出了剩余的构建指令，我们再次运行另一次构建，并确保镜像构建成功。</p><p># docker build -t blog /root/blog/ Sending build context to Docker daemon 19.52 MB Sending build context to Docker daemon Step 0 : FROM nginx:latest ---&gt; 9fab4090484a Step 1 : MAINTAINER Benjamin Cane <a href=\"mailto:ben@bencane.com\">ben@bencane.com</a> ---&gt; Using cache ---&gt; 8e0f1899d1eb Step 2 : RUN apt-get update ---&gt; Using cache ---&gt; 78b36ef1a1a2 Step 3 : RUN apt-get install -y python-dev python-pip ---&gt; Using cache ---&gt; ef4f9382658a Step 4 : RUN mkdir -p /build/ ---&gt; Using cache ---&gt; f4b66e09fa61 Step 5 : COPY requirements.txt /build/ ---&gt; Using cache ---&gt; cef11c3fb97c Step 6 : RUN pip install -r /build/requirements.txt ---&gt; Using cache ---&gt; abab55c20962 Step 7 : COPY static /build/static ---&gt; 15cb91531038 Removing intermediate container d478b42b7906 Step 8 : COPY templates /build/templates ---&gt; ecded5d1a52e Removing intermediate container ac2390607e9f Step 9 : COPY hamerkop /build/ ---&gt; 59efd1ca1771 Removing intermediate container b5fbf7e817b7 Step 10 : COPY config.yml /build/ ---&gt; bfa3db6c05b7 Removing intermediate container 1aebef300933 Step 11 : COPY articles /build/articles ---&gt; 6b61cc9dde27 Removing intermediate container be78d0eb1213 Step 12 : RUN /build/hamerkop -c /build/config.yml ---&gt; Running in fbc0b5e574c5 Successfully created file /usr/share/nginx/html//2011/06/25/checking-the-number-of-lwp-threads-in-linux Successfully created file /usr/share/nginx/html//2011/06/checking-the-number-of-lwp-threads-in-linux</p><p>&lt;truncated to reduce noise&gt; Successfully created file /usr/share/nginx/html//archive.html Successfully created file /usr/share/nginx/html//sitemap.xml ---&gt; 3b25263113e1 Removing intermediate container fbc0b5e574c5 Successfully built 3b25263113e1</p><h2><b>运行定制的容器</b></h2><p>成功的一次构建后，我们现在就可以通过运行<code>docker</code>命令和<code>run</code>选项来运行我们定制的容器，和之前我们启动 nginx 容器一样。</p><p># docker run -d -p 80:80 --name=blog blog 5f6c7a2217dcdc0da8af05225c4d1294e3e6bb28a41ea898a1c63fb821989ba1</p><p>我们这次又使用了<code>-d</code> (<b>detach</b>)标识来让Docker在后台运行。但是，我们也可以看到两个新标识。第一个新标识是<code>--name</code>，这用来给容器指定一个用户名称。之前的例子，我们没有指定名称，因为 Docker 随机帮我们生成了一个。第二个新标识是<code>-p</code>，这个标识允许用户从主机映射一个端口到容器中的一个端口。</p><p>之前我们使用的基础 <b>nginx</b> 镜像分配了80端口给 HTTP 服务。默认情况下，容器内的端口通道并没有绑定到主机系统。为了让外部系统能访问容器内部端口，我们必须使用<code>-p</code>标识将主机端口映射到容器内部端口。上面的命令，我们通过<code>-p 8080:80</code>语法将主机80端口映射到容器内部的80端口。</p><p>经过上面的命令，我们的容器看起来成功启动了，我们可以通过执行<code>docker ps</code>核实。</p><p># docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d264c7ef92bd blog:latest nginx -g &#39;daemon off 3 seconds ago Up 3 seconds 443/tcp, 0.0.0.0:80-&gt;80/tcp blog</p><h2><b>总结</b></h2><p>截止目前，我们拥有了一个运行中的定制 Docker 容器。虽然在这篇文章中，我们只接触了一些 Dockerfile 指令用法，但是我们还是要学习所有的指令。我们可以检查 <a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/v1.8/reference/builder/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Docker&#39;s reference page</a> 来获取所有的 Dockerfile 指令用法，那里对指令的用法说明得很详细。</p><p>另一个比较好的资源是 <a href=\"https://link.zhihu.com/?target=https%3A//docs.docker.com/engine/articles/dockerfile_best-practices/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dockerfile Best Practices page</a>，它有许多构建定制 Dockerfile 的最佳练习。有些技巧非常有用，比如战略性地组织好 Dockerfile 中的命令。上面的例子中，我们将<code>articles</code>目录的<code>COPY</code>指令作为 Dockerfile 中最后的<code>COPY</code>指令。这是因为<code>articles</code>目录会经常变动。所以，将那些经常变化的指令尽可能地放在最后面的位置，来最优化那些可以被缓存的步骤。</p><p>通过这篇文章，我们涉及了如何运行一个预构建的容器，以及如何构建，然后部署定制容器。虽然关于 Docker 你还有许多需要继续学习的地方，但我想这篇文章给了你如何继续开始的好建议。当然，如果你认为还有一些需要继续补充的内容，在下面评论即可。</p>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "网站", 
                    "tagLink": "https://api.zhihu.com/topics/19556496"
                }, 
                {
                    "tag": "博客", 
                    "tagLink": "https://api.zhihu.com/topics/19550419"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53078395", 
            "userName": "架构师修炼宝典", 
            "userLink": "https://www.zhihu.com/people/5829f75938f170e5e0e241bb9970a59d", 
            "upvote": 0, 
            "title": "「阿里面试系列」从JVM层面了解线程的启动和停止", 
            "content": "<h2>文章简介</h2><blockquote>这一篇主要围绕线程状态控制相关的操作分析线程的原理，比如线程的中断，线程的通信等，内容比较多，可能会分两篇文章<br/><a href=\"https://zhuanlan.zhihu.com/p/52833842\" class=\"internal\">【阿里面试系列】搞懂并发编程，轻松应对80%的面试场景</a><br/><a href=\"https://zhuanlan.zhihu.com/p/52834556\" class=\"internal\">【阿里面试系列】Java线程的应用及挑战</a> </blockquote><h2>内容导航</h2><ol><li>线程的启动的实现原理</li><li>线程停止的实现原理分析</li><li>为什么中断线程会抛出InterruptedException的</li></ol><h2>线程的启动原理</h2><p>前面我们简单分析过了线程的使用，通过调用线程的启动方法来启动线程，线程启动后会调用运行方法执行业务逻辑，运行方法执行完毕后，线程的生命周期也就终止了。<br/>很多同学最早学习线程的时候会比较疑惑，启动一个线程为什么是调用启动方法，而不是运行方法，这做一个简单的分析，先简单看一下启动方法的定义</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Thread implements Runnable {\n...\npublic synchronized void start() {\n        /**\n         * This method is not invoked for the main method thread or &#34;system&#34;\n         * group threads created/set up by the VM. Any new functionality added\n         * to this method in the future may have to also be added to the VM.\n         *\n         * A zero status value corresponds to state &#34;NEW&#34;.\n         */\n        if (threadStatus != 0)\n            throw new IllegalThreadStateException();\n        /* Notify the group that this thread is about to be started\n         * so that it can be added to the group&#39;s list of threads\n         * and the group&#39;s unstarted count can be decremented. */\n        group.add(this);\n        boolean started = false;\n        try {\n            start0(); //注意这里\n            started = true;\n        } finally {\n            try {\n                if (!started) {\n                    group.threadStartFailed(this);\n                }\n            } catch (Throwable ignore) {\n                /* do nothing. If start0 threw a Throwable then\n                  it will be passed up the call stack */\n            }\n        }\n    }\n    private native void start0();//注意这里\n...</code></pre></div><p>我们看到调用启动方法实际上是调用一个本地方法START0（）来启动一个线程，首先START0（）这个方法是在线程的静态块中来注册的，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Thread implements Runnable {\n    /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */\n    private static native void registerNatives();\n    static {\n        registerNatives();\n    }</code></pre></div><p>这个registerNatives的作用是注册一些本地方法提供给Thread类来使用，比如start0（），isAlive（），currentThread（），sleep（）;这些都是大家很熟悉的方法.registerNatives<br/>的本地方法的定义在文件<a href=\"https://link.zhihu.com/?target=https%3A//github.com/unofficial-openjdk/openjdk/blob/jdk/jdk/src/java.base/share/native/libjava/Thread.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Thread.c</a>，<br/>Thread.c定义了各个操作系统平台要用的关于线程的公共数据和操作，以下是Thread.c的全部内容</p><div class=\"highlight\"><pre><code class=\"language-text\">static JNINativeMethod methods[] = {\n    {&#34;start0&#34;,           &#34;()V&#34;,        (void *)&amp;JVM_StartThread},\n    {&#34;stop0&#34;,            &#34;(&#34; OBJ &#34;)V&#34;, (void *)&amp;JVM_StopThread},\n    {&#34;isAlive&#34;,          &#34;()Z&#34;,        (void *)&amp;JVM_IsThreadAlive},\n    {&#34;suspend0&#34;,         &#34;()V&#34;,        (void *)&amp;JVM_SuspendThread},\n    {&#34;resume0&#34;,          &#34;()V&#34;,        (void *)&amp;JVM_ResumeThread},\n    {&#34;setPriority0&#34;,     &#34;(I)V&#34;,       (void *)&amp;JVM_SetThreadPriority},\n    {&#34;yield&#34;,            &#34;()V&#34;,        (void *)&amp;JVM_Yield},\n    {&#34;sleep&#34;,            &#34;(J)V&#34;,       (void *)&amp;JVM_Sleep},\n    {&#34;currentThread&#34;,    &#34;()&#34; THD,     (void *)&amp;JVM_CurrentThread},\n    {&#34;countStackFrames&#34;, &#34;()I&#34;,        (void *)&amp;JVM_CountStackFrames},\n    {&#34;interrupt0&#34;,       &#34;()V&#34;,        (void *)&amp;JVM_Interrupt},\n    {&#34;isInterrupted&#34;,    &#34;(Z)Z&#34;,       (void *)&amp;JVM_IsInterrupted},\n    {&#34;holdsLock&#34;,        &#34;(&#34; OBJ &#34;)Z&#34;, (void *)&amp;JVM_HoldsLock},\n    {&#34;getThreads&#34;,        &#34;()[&#34; THD,   (void *)&amp;JVM_GetAllThreads},\n    {&#34;dumpThreads&#34;,      &#34;([&#34; THD &#34;)[[&#34; STE, (void *)&amp;JVM_DumpThreads},\n    {&#34;setNativeName&#34;,    &#34;(&#34; STR &#34;)V&#34;, (void *)&amp;JVM_SetNativeThreadName},\n};\n#undef THD\n#undef OBJ\n#undef STE\n#undef STR\nJNIEXPORT void JNICALL\nJava_java_lang_Thread_registerNatives(JNIEnv *env, jclass cls)\n{\n    (*env)-&gt;RegisterNatives(env, cls, methods, ARRAY_LENGTH(methods));\n}</code></pre></div><p>从这段代码可以看出，start0（），实际会执行JVM_StartThread方法，这个方法是干嘛的呢？从名字上来看，似乎是在JVM层面去启动一个线程，如果真的是这样，那么在JVM层面，一定会调用Java中定义的运行方法。那接下来继续去找找答案。我们找到jvm.cpp这个文件;这个文件需要下载hotspot的源码才能找到。</p><div class=\"highlight\"><pre><code class=\"language-text\">JVM_ENTRY(void, JVM_StartThread(JNIEnv* env, jobject jthread))\n  JVMWrapper(&#34;JVM_StartThread&#34;);\n...\nnative_thread = new JavaThread(&amp;thread_entry, sz);\n...</code></pre></div><p>JVM_ENTRY是用来定义JVM_StartThread函数的，在这个函数里面创建了一个真正和平台有关的本地线程。本着打破砂锅查到底的原则，继续看看newJavaThread做了什么事情，继续寻找JavaThread的定义<br/>在hotspot的源码中thread.cpp文件中1558行的位置可以找到如下代码</p><div class=\"highlight\"><pre><code class=\"language-text\">JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :\n  Thread()\n#if INCLUDE_ALL_GCS\n  , _satb_mark_queue(&amp;_satb_mark_queue_set),\n  _dirty_card_queue(&amp;_dirty_card_queue_set)\n#endif // INCLUDE_ALL_GCS\n{\n  if (TraceThreadEvents) {\n    tty-&gt;print_cr(&#34;creating thread %p&#34;, this);\n  }\n  initialize();\n  _jni_attach_state = _not_attaching_via_jni;\n  set_entry_point(entry_point);\n  // Create the native thread itself.\n  // %note runtime_23\n  os::ThreadType thr_type = os::java_thread;\n  thr_type = entry_point == &amp;compiler_thread_entry ? os::compiler_thread :\n                                                     os::java_thread;\n  os::create_thread(this, thr_type, stack_sz);\n  _safepoint_visible = false;\n  // The _osthread may be NULL here because we ran out of memory (too many threads active).\n  // We need to throw and OutOfMemoryError - however we cannot do this here because the caller\n  // may hold a lock and all locks must be unlocked before throwing the exception (throwing\n  // the exception consists of creating the exception object &amp; initializing it, initialization\n  // will leave the VM via a JavaCall and then all locks must be unlocked).\n  //\n  // The thread is still suspended when we reach here. Thread must be explicit started\n  // by creator! Furthermore, the thread must also explicitly be added to the Threads list\n  // by calling Threads:add. The reason why this is not done here, is because the thread\n  // object must be fully initialized (take a look at JVM_Start)\n}</code></pre></div><p>这个方法有两个参数，第一个是函数名称，线程创建成功之后会根据这个函数名称调用对应的函数;第二个是当前进程内已经有的线程数量。最后我们重点关注与一下os :: create_thread，实际就是调用平台创建线程的方法来创建线程。<br/>接下来就是线程的启动，会调用Thread.cpp文件中的Thread :: start（Thread * thread）方法，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">void Thread::start(Thread* thread) {\n  trace(&#34;start&#34;, thread);\n  // Start is different from resume in that its safety is guaranteed by context or\n  // being called from a Java method synchronized on the Thread object.\n  if (!DisableStartThread) {\n    if (thread-&gt;is_Java_thread()) {\n      // Initialize the thread state to RUNNABLE before starting this thread.\n      // Can not set it after the thread started because we do not know the\n      // exact thread state at that time. It could be in MONITOR_WAIT or\n      // in SLEEPING or some other state.\n      java_lang_Thread::set_thread_status(((JavaThread*)thread)-&gt;threadObj(),\n                                          java_lang_Thread::RUNNABLE);\n    }\n    os::start_thread(thread);\n  }\n}</code></pre></div><p>启动方法中有一个函数调用：os :: start_thread（thread）;,调用平台启动线程的方法，最终会调用Thread.cpp文件中的JavaThread :: run（）方法</p><div class=\"highlight\"><pre><code class=\"language-text\">// The first routine called by a new Java thread\nvoid JavaThread::run() {\n  // initialize thread-local alloc buffer related fields\n  this-&gt;initialize_tlab();\n  // used to test validitity of stack trace backs\n  this-&gt;record_base_of_stack_pointer();\n  // Record real stack base and size.\n  this-&gt;record_stack_base_and_size();\n  // Initialize thread local storage; set before calling MutexLocker\n  this-&gt;initialize_thread_local_storage();\n  this-&gt;create_stack_guard_pages();\n  this-&gt;cache_global_variables();\n  // Thread is now sufficient initialized to be handled by the safepoint code as being\n  // in the VM. Change thread state from _thread_new to _thread_in_vm\n  ThreadStateTransition::transition_and_fence(this, _thread_new, _thread_in_vm);\n  assert(JavaThread::current() == this, &#34;sanity check&#34;);\n  assert(!Thread::current()-&gt;owns_locks(), &#34;sanity check&#34;);\n  DTRACE_THREAD_PROBE(start, this);\n  // This operation might block. We call that after all safepoint checks for a new thread has\n  // been completed.\n  this-&gt;set_active_handles(JNIHandleBlock::allocate_block());\n  if (JvmtiExport::should_post_thread_life()) {\n    JvmtiExport::post_thread_start(this);\n  }\n  EventThreadStart event;\n  if (event.should_commit()) {\n     event.set_javalangthread(java_lang_Thread::thread_id(this-&gt;threadObj()));\n     event.commit();\n  }\n  // We call another function to do the rest so we are sure that the stack addresses used\n  // from there will be lower than the stack base just computed\n  thread_main_inner();\n  // Note, thread is no longer valid at this point!\n}</code></pre></div><p>这个方法中主要是做一系列的初始化操作，最后有一个方法thread_main_inner，接下来看看这个方法的逻辑是什么样的</p><div class=\"highlight\"><pre><code class=\"language-text\">void JavaThread::thread_main_inner() {\n  assert(JavaThread::current() == this, &#34;sanity check&#34;);\n  assert(this-&gt;threadObj() != NULL, &#34;just checking&#34;);\n  // Execute thread entry point unless this thread has a pending exception\n  // or has been stopped before starting.\n  // Note: Due to JVM_StopThread we can have pending exceptions already!\n  if (!this-&gt;has_pending_exception() &amp;&amp;\n      !java_lang_Thread::is_stillborn(this-&gt;threadObj())) {\n    {\n      ResourceMark rm(this);\n      this-&gt;set_native_thread_name(this-&gt;get_thread_name());\n    }\n    HandleMark hm(this);\n    this-&gt;entry_point()(this, this);\n  }\n  DTRACE_THREAD_PROBE(stop, this);\n  this-&gt;exit(false);\n  delete this;\n}</code></pre></div><p>和主流程无关的代码咱们先不去看，直接找到最核心的代码块this-&gt; entry_point（）（this，this）;,这个entrypoint应该比较熟悉了，因为我们在前面提到了，在:: JavaThread这个方法中传递的第一个参数，代表函数名称，线程启动的时候会调用这个函数。<br/>如果大家还没有晕车的话，应该记得我们在jvm.cpp文件中看到的代码，在创建native_thread = newJavaThread（ ＆thread_entry，SZ）; 的时候传递了一个threadentry函数，所以我们在jvm.cpp中找到这个函数的定义如下</p><div class=\"highlight\"><pre><code class=\"language-text\">static void thread_entry(JavaThread* thread, TRAPS) {\n{\n  HandleMark hm(THREAD);\n  Handle obj(THREAD, thread-&gt;threadObj());\n  JavaValue result(T_VOID);\n  JavaCalls::call_virtual(&amp;result,\n                          obj,\n                          KlassHandle(THREAD, SystemDictionary::Thread_klass()),\n                          vmSymbols::run_method_name(), //注意这里\n                          vmSymbols::void_method_signature(),\n                          THREAD);\n}</code></pre></div><p>可以看到vmSymbols :: run_method_name（）这个调用，其实就是通过回调方法调用Java线程中定义的运行方法，run_method_name是一个宏定义，在vmSymbols.hpp文件中可以找到如下代码</p><div class=\"highlight\"><pre><code class=\"language-text\">#define VM_SYMBOLS_DO(template, do_alias)    \n...\ntemplate(run_method_name, &#34;run&#34;)  \n...</code></pre></div><blockquote>所以结论就是，Java的里面创建线程之后必须要调用启动方法才能真正的创建一个线程，该方法会调用虚拟机启动一个本地线程，本地线程的创建会调用当前系统创建线程的方法进行创建，并且线程被执行的时候会回调跑方法进行业务逻辑的处理</blockquote><h2>线程的终止方法及原理</h2><p>线程的终止有主动和被动之分，被动表示线程出现异常退出或者运行方法执行完毕，线程会自动终止。主动的方式是Thread.stop（）来实现线程的终止，但是停止（）方法是一个过期的方法，官方是不建议使用，理由很简单，停止（）方法在中介一个线程时不会保证线程的资源正常释放，也就是不会给线程完成资源释放工作的机会，相当于我们在Linux的上通过kill -9强制结束一个进程。</p><blockquote>那么如何安全的终止一个线程呢？</blockquote><p>我们先看一下下面的代码，代码演示了一个正确终止线程的方法，至于它的实现原理，稍后我们再分析</p><div class=\"highlight\"><pre><code class=\"language-text\">public class InterruptedDemo implements Runnable{\n    @Override\n    public void run() {\n        long i=0l;\n        while(!Thread.currentThread().isInterrupted()){//notice here\n            i++;\n        }\n        System.out.println(&#34;result:&#34;+i);\n    }\n    public static void main(String[] args) throws InterruptedException {\n        InterruptedDemo interruptedDemo=new InterruptedDemo();\n        Thread thread=new Thread(interruptedDemo);\n        thread.start();\n        Thread.sleep(1000);//睡眠一秒\n        thread.interrupt();//notice here\n    }\n}</code></pre></div><p>代码中有两处需要注意，在主线程中，调用了线程的interrupt（）方法，在运行方法中，而循环中通过Thread.currentThread（）。isInterrupted（）来判断线程中断的标识。所以我们在这里猜想一下，应该是在线程中维护了一个中断标识，通过thread.interrupt（）方法去改变了中断标识的值使得运行方法中而循环的判断不成立而跳出循环，因此运行方法执行完毕以后线程就终止了。</p><h2>线程中断的原理分析</h2><p>我们来看一下thread.interrupt（）方法做了什么事情</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Thread implements Runnable {\n...\n    public void interrupt() {\n        if (this != Thread.currentThread())\n            checkAccess();\n        synchronized (blockerLock) {\n            Interruptible b = blocker;\n            if (b != null) {\n                interrupt0();           // Just to set the interrupt flag\n                b.interrupt(this);\n                return;\n            }\n        }\n        interrupt0();\n    }\n...</code></pre></div><p>这个方法里面，调用了中断0（），这个方法在前面分析启动方法的时候见过，是一个本机方法，这里就不再重复贴代码了，同样，我们找到jvm.cpp文件，找到JVM_Interrupt的定义</p><div class=\"highlight\"><pre><code class=\"language-text\">JVM_ENTRY(void, JVM_Interrupt(JNIEnv* env, jobject jthread))\n  JVMWrapper(&#34;JVM_Interrupt&#34;);\n  // Ensure that the C++ Thread and OSThread structures aren&#39;t freed before we operate\n  oop java_thread = JNIHandles::resolve_non_null(jthread);\n  MutexLockerEx ml(thread-&gt;threadObj() == java_thread ? NULL : Threads_lock);\n  // We need to re-resolve the java_thread, since a GC might have happened during the\n  // acquire of the lock\n  JavaThread* thr = java_lang_Thread::thread(JNIHandles::resolve_non_null(jthread));\n  if (thr != NULL) {\n    Thread::interrupt(thr);\n  }\nJVM_END</code></pre></div><p>这个方法比较简单，直接调用了Thread :: interrupt（thr）这个方法，这个方法的定义在Thread.cpp文件中，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">void Thread::interrupt(Thread* thread) {\n  trace(&#34;interrupt&#34;, thread);\n  debug_only(check_for_dangling_thread_pointer(thread);)\n  os::interrupt(thread);\n}</code></pre></div><p>Thread :: interrupt方法调用了os :: interrupt方法，这个是调用平台的中断方法，这个方法的实现是在os _ * .cpp文件中，其中星号代表的是不同平台，因为jvm是跨平台的，所以对于不同的操作平台，线程的调度方式都是不一样的。我们以os_linux.cpp文件为例</p><div class=\"highlight\"><pre><code class=\"language-text\">void os::interrupt(Thread* thread) {\n  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),\n    &#34;possibility of dangling Thread pointer&#34;);\n  //获取本地线程对象\n  OSThread* osthread = thread-&gt;osthread();\n  if (!osthread-&gt;interrupted()) {//判断本地线程对象是否为中断\n    osthread-&gt;set_interrupted(true);//设置中断状态为true\n    // More than one thread can get here with the same value of osthread,\n    // resulting in multiple notifications.  We do, however, want the store\n    // to interrupted() to be visible to other threads before we execute unpark().\n    //这里是内存屏障，这块在后续的文章中会剖析；内存屏障的目的是使得interrupted状态对其他线程立即可见\n    OrderAccess::fence();\n    //_SleepEvent相当于Thread.sleep，表示如果线程调用了sleep方法，则通过unpark唤醒\n    ParkEvent * const slp = thread-&gt;_SleepEvent ;\n    if (slp != NULL) slp-&gt;unpark() ;\n  }\n  // For JSR166. Unpark even if interrupt status already was set\n  if (thread-&gt;is_Java_thread())\n    ((JavaThread*)thread)-&gt;parker()-&gt;unpark();\n  //_ParkEvent用于synchronized同步块和Object.wait()，这里相当于也是通过unpark进行唤醒\n  ParkEvent * ev = thread-&gt;_ParkEvent ;\n  if (ev != NULL) ev-&gt;unpark() ;\n}</code></pre></div><p>通过上面的代码分析可以知道，了Thread.interrupt（）方法实际就是设置一个中断状态标识为真，并且通过ParkEvent的取消驻留方法来唤醒线程。</p><ol><li>对于同步阻塞的线程，被唤醒以后会继续尝试获取锁，如果失败仍然可能被公园</li><li>在调用ParkEvent的公园方法之前，会先判断线程的中断状态，如果为真，会清除当前线程的中断标识</li><li>的Object.wait，了Thread.sleep，的Thread.join会抛出InterruptedException的</li></ol><blockquote>这里给大家普及一个知识点，为什么的Object.wait，的Thread.sleep和的Thread.join都会抛出InterruptedException的？首先，这个异常的意思是表示一个阻塞被其他线程中断了。然后，由于线程调用了中断（）中断方法，那么的Object.wait，的Thread.sleep等被阻塞的线程被唤醒以后会通过is_interrupted方法判断中断标识的状态变化，如果发现中断标识为真，则先清除中断标识，然后抛出InterruptedException的</blockquote><p>需要注意的是，InterruptedException的异常的抛出并不意味着线程必须终止，而是提醒当前线程有中断的操作发生，至于接下来怎么处理取决于线程本身，比如</p><ol><li>直接捕获异常不做任何处理</li><li>将异常往外抛出</li><li>停止当前线程，并打印异常信息</li></ol><p><b>为了让大家能够更好的理解上面这段话，我们以了Thread.sleep为例直接从JDK的源码中找到中断标识的清除以及异常抛出的方法代码</b></p><blockquote>找到is_interrupted（）方法，linux平台中的实现在os_linux.cpp文件中，代码如下</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">bool os::is_interrupted(Thread* thread, bool clear_interrupted) {\n  assert(Thread::current() == thread || Threads_lock-&gt;owned_by_self(),\n    &#34;possibility of dangling Thread pointer&#34;);\n  OSThread* osthread = thread-&gt;osthread();\n  bool interrupted = osthread-&gt;interrupted(); //获取线程的中断标识\n  if (interrupted &amp;&amp; clear_interrupted) {//如果中断标识为true\n    osthread-&gt;set_interrupted(false);//设置中断标识为false\n    // consider thread-&gt;_SleepEvent-&gt;reset() ... optional optimization\n  }\n  return interrupted;\n}</code></pre></div><blockquote>找到了Thread.sleep这个操作在JDK中的源码体现，怎么找？相信如果前面大家有认真看的话，应该能很快找到，代码在jvm.cpp文件中</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">JVM_ENTRY(void, JVM_Sleep(JNIEnv* env, jclass threadClass, jlong millis))\n  JVMWrapper(&#34;JVM_Sleep&#34;);\n  if (millis &lt; 0) {\n    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(), &#34;timeout value is negative&#34;);\n  }\n  //判断并清除线程中断状态，如果中断状态为true,抛出中断异常\n  if (Thread::is_interrupted (THREAD, true) &amp;&amp; !HAS_PENDING_EXCEPTION) {\n    THROW_MSG(vmSymbols::java_lang_InterruptedException(), &#34;sleep interrupted&#34;);\n  }\n  // Save current thread state and restore it at the end of this block.\n  // And set new thread state to SLEEPING.\n  JavaThreadSleepState jtss(thread);\n...</code></pre></div><p>注意上面加了中文注释的地方的代码，先判断is_interrupted的状态，然后抛出一个InterruptedException的异常。到此为止，我们就已经分析清楚了中断的整个流程。</p><h2>Java的线程的中断标识判断</h2><p>了解了线程。中断方法的作用以后，再回过头来看Java中Thread.currentThread（）。isInterrupted（）这段代码，就很好理解了。由于前者先设置了一个中断标识为真，所以isInterrupted（ ）这个方法的返回值为真，故而不满足而循环的判断条件导致退出循环。<br/>这里有必要再提一句，就是这个线程中断标识有两种方式复位，第一种是前面提到过的InterruptedException的;另一种是通过Thread.interrupted（）对当前线程的中断标识进行复位。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53078651", 
            "userName": "架构师修炼宝典", 
            "userLink": "https://www.zhihu.com/people/5829f75938f170e5e0e241bb9970a59d", 
            "upvote": 1, 
            "title": "【阿里面试系列】Thread.join的作用", 
            "content": "<h2><b>文章简介</b></h2><p>很多人对Thread.join的作用以及实现了解得很少，毕竟这个api我们很少使用。这篇文章仍然会结合使用及原理进行深度分析</p><p>扩展阅读：</p><p><a href=\"https://zhuanlan.zhihu.com/p/52834556\" class=\"internal\">「阿里面试系列」搞懂并发编程，轻松应对80%的面试场景</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//my.oschina.net/u/3779583/blog/2980911\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【阿里面试系列】Java线程的应用及挑战</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/52833842\" class=\"internal\">「阿里面试系列」面试加分项，从JVM层面了解线程的启动和停止</a></p><h2><b>内容导航</b></h2><ol><li>Thread.join的作用</li><li>Thread.join的实现原理</li><li>什么时候会使用Thread.join</li></ol><h2><b>Thread.join的作用</b></h2><p>之前有人问过我一个这样的面试题</p><blockquote>Java中如何让多线程按照自己指定的顺序执行？</blockquote><p>这个问题最简单的回答是通过Thread.join来实现，久而久之就让很多人误以为Thread.join是用来保证线程的顺序性的。<br/>下面这段代码演示了Thread.join的作用</p><div class=\"highlight\"><pre><code class=\"language-text\">public class JoinDemo extends Thread{\n    int i;\n    Thread previousThread; //上一个线程\n    public JoinDemo(Thread previousThread,int i){\n        this.previousThread=previousThread;\n        this.i=i;\n    }\n    @Override\n    public void run() {\n        try {\n          //调用上一个线程的join方法，大家可以自己演示的时候可以把这行代码注释掉\n            previousThread.join(); \n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(&#34;num:&#34;+i);\n    }\n    public static void main(String[] args) {\n        Thread previousThread=Thread.currentThread();\n        for(int i=0;i&lt;10;i++){\n            JoinDemo joinDemo=new JoinDemo(previousThread,i);\n            joinDemo.start();\n            previousThread=joinDemo;\n        }\n    }\n}</code></pre></div><p>上面的代码，注意 previousThread.join部分，大家可以把这行代码注释以后看看运行效果，在没有加join的时候运行的结果是不确定的。加了join以后，运行结果按照递增的顺序展示出来。</p><blockquote>thread.join的含义是当前线程需要等待previousThread线程终止之后才从thread.join返回。简单来说，就是线程没有执行完之前，会一直阻塞在join方法处。</blockquote><p>下面的图表现了join对于线程的作用</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8ba5846209272282736c464d25f747f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"938\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"938\" data-original=\"https://pic3.zhimg.com/v2-8ba5846209272282736c464d25f747f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;938&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"938\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"938\" data-original=\"https://pic3.zhimg.com/v2-8ba5846209272282736c464d25f747f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8ba5846209272282736c464d25f747f6_b.jpg\"/></figure><h2><b>Thread.join的实现原理</b></h2><blockquote>线程是如何被阻塞的？又是通过什么方法唤醒的呢？先来看看Thread.join方法做了什么事情</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">public class Thread implements Runnable {\n    ...\n    public final void join() throws InterruptedException {\n        join(0);\n    }\n    ...\n    public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis &lt; 0) {\n            throw new IllegalArgumentException(&#34;timeout value is negative&#34;);\n        }\n        if (millis == 0) { //判断是否携带阻塞的超时时间，等于0表示没有设置超时时间\n            while (isAlive()) {//isAlive获取线程状态，无线等待直到previousThread线程结束\n                wait(0); //调用Object中的wait方法实现线程的阻塞\n            }\n        } else { //阻塞直到超时\n            while (isAlive()) { \n                long delay = millis - now;\n                if (delay &lt;= 0) {\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n    ...</code></pre></div><p>从join方法的源码来看，join方法的本质调用的是Object中的wait方法实现线程的阻塞，wait方法的实现原理我们在后续的文章再说详细阐述。<b>但是我们需要知道的是，调用wait方法必须要获取锁</b>，所以join方法是被synchronized修饰的，synchronized修饰在方法层面相当于synchronized(this),this就是previousThread本身的实例。</p><p>有很多人不理解join为什么阻塞的是主线程呢? 不理解的原因是阻塞主线程的方法是放在previousThread这个实例作用，让大家误以为应该阻塞previousThread线程。实际上主线程会持有previousThread这个对象的锁，然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。</p><blockquote>第二个问题，为什么previousThread线程执行完毕就能够唤醒住线程呢？或者说是在什么时候唤醒的？</blockquote><p>要了解这个问题，我们又得翻jdk的源码，但是如果大家对线程有一定的基本了解的话，通过wait方法阻塞的线程，需要通过notify或者notifyall来唤醒。所以在线程执行完毕以后会有一个唤醒的操作，只是我们不需要关心。<br/>接下来在hotspot的源码中找到 thread.cpp，看看线程退出以后有没有做相关的事情来证明我们的猜想.</p><div class=\"highlight\"><pre><code class=\"language-text\">void JavaThread::exit(bool destroy_vm, ExitType exit_type) {\n  assert(this == JavaThread::current(),  &#34;thread consistency check&#34;);\n  ...\n  // Notify waiters on thread object. This has to be done after exit() is called\n  // on the thread (if the thread is the last thread in a daemon ThreadGroup the\n  // group should have the destroyed bit set before waiters are notified).\n  ensure_join(this); \n  assert(!this-&gt;has_pending_exception(), &#34;ensure_join should have cleared&#34;);\n  ...</code></pre></div><p>观察一下 ensure_join(this)这行代码上的注释，唤醒处于等待的线程对象，这个是在线程终止之后做的清理工作，这个方法的定义代码片段如下</p><div class=\"highlight\"><pre><code class=\"language-text\">static void ensure_join(JavaThread* thread) {\n  // We do not need to grap the Threads_lock, since we are operating on ourself.\n  Handle threadObj(thread, thread-&gt;threadObj());\n  assert(threadObj.not_null(), &#34;java thread object must exist&#34;);\n  ObjectLocker lock(threadObj, thread);\n  // Ignore pending exception (ThreadDeath), since we are exiting anyway\n  thread-&gt;clear_pending_exception();\n  // Thread is exiting. So set thread_status field in  java.lang.Thread class to TERMINATED.\n  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);\n  // Clear the native thread instance - this makes isAlive return false and allows the join()\n  // to complete once we&#39;ve done the notify_all below\n  //这里是清除native线程，这个操作会导致isAlive()方法返回false\n  java_lang_Thread::set_thread(threadObj(), NULL);\n  lock.notify_all(thread);//注意这里\n  // Ignore pending exception (ThreadDeath), since we are exiting anyway\n  thread-&gt;clear_pending_exception();\n}</code></pre></div><p>ensure_join方法中，调用 lock.notify_all(thread); 唤醒所有等待thread锁的线程，意味着调用了join方法被阻塞的主线程会被唤醒； 到目前为止，我们基本上对join的原理做了一个比较详细的分析</p><blockquote>总结，Thread.join其实底层是通过wait/notifyall来实现线程的通信达到线程阻塞的目的；当线程执行结束以后，会触发两个事情，第一个是设置native线程对象为null、第二个是通过notifyall方法，让等待在previousThread对象锁上的wait方法被唤醒。</blockquote><h2><b>什么时候会使用Thread.join</b></h2><p>在实际应用开发中，我们很少会使用thread.join。在实际使用过程中，我们可以通过join方法来等待线程执行的结果，其实有点类似future/callable的功能。<br/>我们通过以下伪代码来说明join的使用场景</p><div class=\"highlight\"><pre><code class=\"language-text\">public void joinDemo(){\n   //....\n   Thread t=new Thread(payService);\n   t.start();\n   //.... \n   //其他业务逻辑处理,不需要确定t线程是否执行完\n   insertData();\n   //后续的处理，需要依赖t线程的执行结果，可以在这里调用join方法等待t线程执行结束\n   t.join();\n}</code></pre></div><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53080541", 
            "userName": "架构师修炼宝典", 
            "userLink": "https://www.zhihu.com/people/5829f75938f170e5e0e241bb9970a59d", 
            "upvote": 0, 
            "title": "「阿里面试系列」Synchronized原理分析", 
            "content": "<h2><b>文章简介</b></h2><p>synchronized想必大家都不陌生，用来解决线程安全问题的利器。同时也是Java高级程序员面试比较常见的面试题。这篇文正会带大家彻底了解synchronized的实现。</p><p>扩展阅读：</p><p><a href=\"https://zhuanlan.zhihu.com/p/52833842\" class=\"internal\">「阿里面试系列」搞懂并发编程，轻松应对80%的面试场景</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/52834556\" class=\"internal\">【阿里面试系列】Java线程的应用及挑战</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/53078395\" class=\"internal\">「阿里面试系列」从JVM层面了解线程的启动和停止</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/53078651\" class=\"internal\">【阿里面试系列】Thread.join的作用</a></p><h2><b>内容导航</b></h2><ul><li>什么时候需要用Synchronized</li><li>synchronized的使用</li><li>synchronized的实现原理分析</li></ul><p><b>什么时候需要用Synchronized</b></p><p>想必大家对synchronized都不陌生，主要作用是在多个线程操作共享数据的时候，保证对共享数据访问的线程安全性。</p><p>比如在下面这个图片中，两个线程对于i这个共享变量同时做i++递增操作，那么这个时候对于i这个值来说就存在一个不确定性，也就是说理论上i的值应该是2，但是也可能是1。而导致这个问题的原因是线程并行执行i++操作并不是原子的，存在线程安全问题。所以通常来说解决办法是通过加锁来实现线程的串行执行，而synchronized就是java中锁的实现的关键字。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-50dc16ae85fb1cf2e6040ec197b3eff8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"230\" class=\"content_image\" width=\"327\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;327&#39; height=&#39;230&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"327\" data-rawheight=\"230\" class=\"content_image lazy\" width=\"327\" data-actualsrc=\"https://pic1.zhimg.com/v2-50dc16ae85fb1cf2e6040ec197b3eff8_b.jpg\"/></figure><p>synchronized在并发编程中是一个非常重要的角色，在JDK1.6之前，它是一个重量级锁的角色，但是在JDK1.6之后对synchronized做了优化，优化以后性能有了较大的提升(这块会在后面做详细的分析)。</p><p>先来看一下synchronized的使用</p><h2><b>Synchronized的使用</b></h2><p>synchronized有三种使用方法，这三种使用方法分别对应三种不同的作用域，代码如下</p><p><b>修饰普通同步方法</b></p><p>将synchronized修饰在普通同步方法，那么该锁的作用域是在当前实例对象范围内,也就是说对于 SyncDemosd=newSyncDemo();这一个实例对象sd来说，多个线程访问access方法会有锁的限制。如果access已经有线程持有了锁，那这个线程会独占锁，直到锁释放完毕之前，其他线程都会被阻塞 </p><div class=\"highlight\"><pre><code class=\"language-text\">public SyncDemo{\n   Object lock =new Object();\n    //形式1\n    public synchronized void access(){\n       //\n    }\n    //形式2,作用域等同于形式1\n    public void access1(){\n       synchronized(lock){\n         //\n       }\n    }\n    //形式3，作用域等同于前面两种\n    public void access2(){\n       synchronized(this){\n          //\n       }\n    }\n}</code></pre></div><p><b>修饰静态同步方法</b></p><p>修饰静态同步方法或者静态对象、类，那么这个锁的作用范围是类级别。举个简单的例子，</p><div class=\"highlight\"><pre><code class=\"language-text\">SyncDemo sd=SyncDemo();\nSyncDemo sd2=new SyncDemo();} </code></pre></div><p>两个不同的实例sd和sd2， 如果sd这个实例访问access方法并且成功持有了锁，那么sd2这个对象如果同样来访问access方法，那么它必须要等待sd这个对象的锁释放以后，sd2这个对象的线程才能访问该方法，这就是类锁；也就是说类锁就相当于全局锁的概念，作用范围是类级别。</p><blockquote>这里抛一个小问题，大家看看能不能回答，如果不能也没关系，后面会讲解；问题是如果sd先访问access获得了锁，sd2对象的线程再访问access1方法，那么它会被阻塞吗？</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">public SyncDemo{\n    static Object lock=new Object();\n    //形式1\n    public synchronized static void access(){\n       //\n    }\n    //形式2等同于形式1\n    public void access1(){\n       synchronized(lock){\n          //\n       }\n    }\n    //形式3等同于前面两种\n    public void access2(){\n        synchronzied(SyncDemo.class){\n          //\n        }\n    }\n}</code></pre></div><p><b>步方法块</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public SyncDemo{\n   Object lock=new Object();\n   public void access(){\n       //do something\n       synchronized(lock){\n         //\n       }\n   }\n}</code></pre></div><blockquote>通过演示3种不同锁的使用，让大家对synchronized有了初步的认识。当一个线程视图访问带有synchronized修饰的同步代码块或者方法时，必须要先获得锁。当方法执行完毕退出以后或者出现异常的情况下会自动释放锁。如果大家认真看了上面的三个案例，那么应该知道锁的范围控制是由对象的作用域决定的。对象的作用域越大，那么锁的范围也就越大，因此我们可以得出一个初步的猜想，synchronized和对象有非常大的关系。那么，接下来就去剖析一下锁的原理</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Synchronized的实现原理分析</b></h2><p>当一个线程尝试访问synchronized修饰的代码块时，它首先要获得锁，那么这个锁到底存在哪里呢？</p><p><b>对象在内存中的布局</b></p><p>synchronized实现的锁是存储在Java对象头里，什么是对象头呢？在Hotspot虚拟机中，对象在内存中的存储布局，可以分为三个区域:对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ac08e7682828e73238b751bec0f1bc60_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"209\" class=\"content_image\" width=\"279\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;279&#39; height=&#39;209&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"209\" class=\"content_image lazy\" width=\"279\" data-actualsrc=\"https://pic1.zhimg.com/v2-ac08e7682828e73238b751bec0f1bc60_b.jpg\"/></figure><p>当我们在Java代码中，使用new创建一个对象实例的时候，（hotspot虚拟机）JVM层面实际上会创建一个 instanceOopDesc对象。</p><blockquote>Hotspot虚拟机采用OOP-Klass模型来描述Java对象实例，OOP(Ordinary Object Point)指的是普通对象指针，Klass用来描述对象实例的具体类型。Hotspot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型</blockquote><p>instanceOopDesc的定义在Hotspot源码中的 instanceOop.hpp文件中，另外，arrayOopDesc的定义对应 arrayOop.hpp</p><div class=\"highlight\"><pre><code class=\"language-text\">class instanceOopDesc : public oopDesc {\n public:\n  // aligned header size.\n  static int header_size() { return sizeof(instanceOopDesc)/HeapWordSize; }\n  // If compressed, the offset of the fields of the instance may not be aligned.\n  static int base_offset_in_bytes() {\n    // offset computation code breaks if UseCompressedClassPointers\n    // only is true\n    return (UseCompressedOops &amp;&amp; UseCompressedClassPointers) ?\n             klass_gap_offset_in_bytes() :\n             sizeof(instanceOopDesc);\n  }\n  static bool contains_field_offset(int offset, int nonstatic_field_size) {\n    int base_in_bytes = base_offset_in_bytes();\n    return (offset &gt;= base_in_bytes &amp;&amp;\n            (offset-base_in_bytes) &lt; nonstatic_field_size * heapOopSize);\n  }\n};\n#endif // SHARE_VM_OOPS_INSTANCEOOP_HPP</code></pre></div><p>从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot源码中的 oop.hpp文件中</p><div class=\"highlight\"><pre><code class=\"language-text\">class oopDesc {\n  friend class VMStructs;\n private:\n  volatile markOop  _mark;\n  union _metadata {\n    Klass*      _klass;\n    narrowKlass _compressed_klass;\n  } _metadata;\n  // Fast access to barrier set.  Must be initialized.\n  static BarrierSet* _bs;\n  ...\n}</code></pre></div><p>在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark和 _metadata</p><ul><li>_mark表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息</li><li>_metadata表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示普通指针、 _compressed_klass表示压缩类指针</li></ul><p><b>Mark Word</b></p><p>在前面我们提到过，普通对象的对象头由两部分组成，分别是markOop以及类元信息，markOop官方称为Mark Word</p><p>在Hotspot中，markOop的定义在 markOop.hpp文件中，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">class markOopDesc: public oopDesc {\n private:\n  // Conversion\n  uintptr_t value() const { return (uintptr_t) this; }\n public:\n  // Constants\n  enum { age_bits                 = 4,  //分代年龄\n         lock_bits                = 2, //锁标识\n         biased_lock_bits         = 1, //是否为偏向锁\n         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,\n         hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits, //对象的hashcode\n         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),\n         epoch_bits               = 2 //偏向锁的时间戳\n  };\n...</code></pre></div><p>Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，那么围绕这个锁的一系列操作都和Mark word有关系。Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。</p><p>Mark Word里面存储的数据会随着锁标志位的变化而变化，Mark Word可能变化为存储以下5中情况</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f2e9a0db82c76b862e5786973e7e5eeb_b.jpg\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb\" width=\"968\" data-original=\"https://pic4.zhimg.com/v2-f2e9a0db82c76b862e5786973e7e5eeb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;968&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"968\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"968\" data-original=\"https://pic4.zhimg.com/v2-f2e9a0db82c76b862e5786973e7e5eeb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f2e9a0db82c76b862e5786973e7e5eeb_b.jpg\"/><figcaption>32位虚拟机中的定义</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0b8417293b3bf760f12e11aa43aef3f5_b.jpg\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb\" width=\"874\" data-original=\"https://pic2.zhimg.com/v2-0b8417293b3bf760f12e11aa43aef3f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;874&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"150\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"874\" data-original=\"https://pic2.zhimg.com/v2-0b8417293b3bf760f12e11aa43aef3f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0b8417293b3bf760f12e11aa43aef3f5_b.jpg\"/><figcaption>64位虚拟机中的定义</figcaption></figure><p><b>锁标志位的表示意义</b></p><ol><li>锁标识 lock=00 表示轻量级锁</li><li>锁标识 lock=10 表示重量级锁</li><li>偏向锁标识 biased_lock=1表示偏向锁</li><li>偏向锁标识 biased_lock=0且锁标识=01表示无锁状态</li></ol><p>到目前为止，我们再总结一下前面的内容，synchronized(lock)中的lock可以用Java中任何一个对象来表示，而锁标识的存储实际上就是在lock这个对象中的对象头内。大家懂了吗？</p><blockquote>其实前面只提到了锁标志位的存储，但是为什么任意一个Java对象都能成为锁对象呢？</blockquote><p>首先，Java中的每个对象都派生自Object类，而每个Java Object在JVM内部都有一个native的C++对象 oop/oopDesc进行对应。</p><p>其次，线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor可以认为是一个同步对象，所有的Java对象是天生携带monitor.</p><p>在hotspot源码的 markOop.hpp文件中，可以看到下面这段代码。</p><div class=\"highlight\"><pre><code class=\"language-text\">ObjectMonitor* monitor() const {\n    assert(has_monitor(), &#34;check&#34;);\n    // Use xor instead of &amp;~ to provide one extra tag-bit check.\n    return (ObjectMonitor*) (value() ^ monitor_value);\n  }</code></pre></div><p>多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识,上面的代码中ObjectMonitor这个对象和线程争抢锁的逻辑有密切的关系(后续会详细分析)</p><p><b>锁的升级</b></p><p>前面提到了锁的几个概念，偏向锁、轻量级锁、重量级锁。在JDK1.6之前，synchronized是一个重量级锁，性能比较差。从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，synchronized进行了优化，引入了 偏向锁和 轻量级锁的概念。所以从JDK1.6开始，锁一共会有四种状态，锁的状态根据竞争激烈程度从低到高分别是:无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。这几个状态会随着锁竞争的情况逐步升级。为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。</p><h2><b>下面就详细讲解synchronized的三种锁的状态及升级原理</b></h2><p><b>偏向锁</b></p><p>在大多数的情况下，锁不仅不存在多线程的竞争，而且总是由同一个线程获得。因此为了让线程获得锁的代价更低引入了偏向锁的概念。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。偏向锁可以通过 -XX:+UseBiasedLocking开启或者关闭</p><p><b>偏向锁的获取</b></p><p>偏向锁的获取过程非常简单，当一个线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，表示哪个线程获得了偏向锁，结合前面分析的Mark Word来分析一下偏向锁的获取逻辑</p><p>首先获取目标对象的Mark Word，根据锁的标识为和epoch去判断当前是否处于可偏向的状态</p><p>如果为可偏向状态，则通过CAS操作将自己的线程ID写入到MarkWord，如果CAS操作成功，则表示当前线程成功获取到偏向锁，继续执行同步代码块</p><p>如果是已偏向状态，先检测MarkWord中存储的threadID和当前访问的线程的threadID是否相等，如果相等，表示当前线程已经获得了偏向锁，则不需要再获得锁直接执行同步代码；如果不相等，则证明当前锁偏向于其他线程，需要撤销偏向锁。</p><p>CAS:表示自旋锁，由于线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说性能开销很大。同时，很多对象锁的锁定状态指会持续很短的时间，因此引入了自旋锁，所谓自旋就是一个无意义的死循环，在循环体内不断的重行竞争锁。当然，自旋的次数会有限制，超出指定的限制会升级到阻塞锁。</p><p><b>偏向锁的撤销</b></p><p>当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，撤销偏向锁的过程需要等待一个全局安全点(所有工作线程都停止字节码的执行)。</p><p>首先，暂停拥有偏向锁的线程，然后检查偏向锁的线程是否为存活状态</p><p>如果线程已经死了，直接把对象头设置为无锁状态</p><p>如果还活着，当达到全局安全点时获得偏向锁的线程会被挂起，接着偏向锁升级为轻量级锁，然后唤醒被阻塞在全局安全点的线程继续往下执行同步代码</p><p><b>偏向锁的获取流程图</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-05847811a2d9f2ef438b3d1be9549b95_b.jpg\" data-size=\"normal\" data-rawwidth=\"915\" data-rawheight=\"807\" class=\"origin_image zh-lightbox-thumb\" width=\"915\" data-original=\"https://pic2.zhimg.com/v2-05847811a2d9f2ef438b3d1be9549b95_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;915&#39; height=&#39;807&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"915\" data-rawheight=\"807\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"915\" data-original=\"https://pic2.zhimg.com/v2-05847811a2d9f2ef438b3d1be9549b95_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-05847811a2d9f2ef438b3d1be9549b95_b.jpg\"/><figcaption>偏向锁的获取流程图</figcaption></figure><p><b>轻量级锁</b></p><p>前面我们知道，当存在超过一个线程在竞争同一个同步代码块时，会发生偏向锁的撤销。偏向锁撤销以后对象会可能会处于两种状态</p><ol><li>一种是不可偏向的无锁状态，简单来说就是已经获得偏向锁的线程已经退出了同步代码块，那么这个时候会撤销偏向锁，并升级为轻量级锁</li><li>一种是不可偏向的已锁状态，简单来说就是已经获得偏向锁的线程正在执行同步代码块，那么这个时候会升级到轻量级锁并且被原持有锁的线程获得锁</li></ol><p>那么升级到轻量级锁以后的加锁过程和解锁过程是怎么样的呢?</p><p><b>轻量级锁加锁</b></p><ol><li>JVM会先在当前线程的栈帧中创建用于存储锁记录的空间(LockRecord)</li><li>将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word.</li><li>线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针</li><li>如果替换成功，表示当前线程获得轻量级锁，如果失败，表示存在其他线程竞争锁，那么当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀升级为重量级锁</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-da1ae271708fda12ddecff428af305c0_b.jpg\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb\" width=\"615\" data-original=\"https://pic1.zhimg.com/v2-da1ae271708fda12ddecff428af305c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;615&#39; height=&#39;735&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"735\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"615\" data-original=\"https://pic1.zhimg.com/v2-da1ae271708fda12ddecff428af305c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-da1ae271708fda12ddecff428af305c0_b.jpg\"/><figcaption>轻量级锁加锁</figcaption></figure><p><b>轻量锁解锁</b></p><p>尝试CAS操作将所记录中的Mark Word替换回到对象头中</p><p>如果成功，表示没有竞争发生</p><p>如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁</p><blockquote>一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于重量级锁状态，其他线程尝试获取锁时，都会被阻塞，也就是 BLOCKED状态。当持有锁的线程释放锁之后会唤醒这些现场，被唤醒之后的线程会进行新一轮的竞争</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-850e296e6a4b39d6fa44449f17e52fa0_b.jpg\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"514\" data-original=\"https://pic1.zhimg.com/v2-850e296e6a4b39d6fa44449f17e52fa0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;514&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"514\" data-original=\"https://pic1.zhimg.com/v2-850e296e6a4b39d6fa44449f17e52fa0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-850e296e6a4b39d6fa44449f17e52fa0_b.jpg\"/><figcaption>轻量级锁解锁</figcaption></figure><p><b>重量级锁</b></p><p>重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）</p><p>大家如果对MutexLock有兴趣，可以抽时间去了解，假设Mutex变量的值为1，表示互斥锁空闲，这个时候某个线程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被其他线程获得，其他线程调用lock只能挂起等待</p><blockquote><b>为什么重量级锁的开销比较大呢？</b></blockquote><p>原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的</p><p>总结</p><p>到目前为止，我们分析了synchronized的使用方法、以及锁的存储、对象头、锁升级的原理。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": [
                {
                    "userName": "之乎者也", 
                    "userLink": "https://www.zhihu.com/people/edba0eefa98ee3b45571d3983937df37", 
                    "content": "i++操作怎么不是原子的呢？ 如果换成int k = i; i = k+1;这样才不是原子的吧", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "之乎者也", 
                    "userLink": "https://www.zhihu.com/people/edba0eefa98ee3b45571d3983937df37", 
                    "content": "修饰静态同步方法 中，形式二不对吧", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52397993", 
            "userName": "飘零客", 
            "userLink": "https://www.zhihu.com/people/bab29426419ff1d3e50898f92e40f227", 
            "upvote": 0, 
            "title": "云适配亮相“2018全国勘察设计行业信息化工作交流会”， 助力勘察设计行业数字化智能升级", 
            "content": "<p>近日，由中国勘察设计协会信息化推进工作委员会主办的全国勘察设计行业信息化工作交流会暨中国勘察设计协会信息化推进工作委员会2018年年会在浙江湖州成功召开。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>各地方、各部门勘察设计同业协会，中国人民解放军工程建设协会，各设计院会员单位信息部门领导等出席了此次会议，总结“十三五”中期工程勘察设计行业信息化建设情况，云适配受邀出席交流会，并与众多行业协会及业内人士分享先进企业信息化建设经验，共同探讨新的转型和升级之路。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1a66221fee8b55ab3adb1c234e968cc8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-1a66221fee8b55ab3adb1c234e968cc8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;419&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-1a66221fee8b55ab3adb1c234e968cc8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1a66221fee8b55ab3adb1c234e968cc8_b.jpg\"/></figure><p><b>大会开幕</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在经历了30年的经济高速增长之后，工程勘察设计行业遇到了前所未有的困难和挑战，传统的粗放式发展已经难以为继，而数字化转型升级给企业带来的帮助不言而喻，效率提高、降低成本、优化沟通协作，最终帮助企业提升自身核心竞争力。打造“智慧设计院”正成为设计行业克服挑战，不断创新和蜕变的重要途径。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>会上，<b>云适配东区销售总监朱敏以《三大管家助力设计院信息化升级》为题，着重介绍了“移动管家”、“智能管家”及“安全管家”在企业数字化建设中的作用。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-48bf7fc6b1b94303d5c2b5d4661ccee4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-48bf7fc6b1b94303d5c2b5d4661ccee4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;419&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-48bf7fc6b1b94303d5c2b5d4661ccee4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-48bf7fc6b1b94303d5c2b5d4661ccee4_b.jpg\"/></figure><p><b>云适配东区销售总监朱敏</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>勘察设计行业具有知识密集、移动办公需求大、图纸保密需求高、多方协作多、业务系统复杂等特点，朱敏说道，云适配采用三角架构，通过跨设备的统一安全工作入口、跨设备统一的用户、设备、应用以及策略管控平台，解决“PC+移动+内网+云”办公场景的安全性以及移动化问题，企业不仅可通过“企业办公入口统一管控解决方案 ”实现应用入口、用户信息、用户设备的统一管理，也可选择NO API的移动化解决方案来实现智能适配。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上海城建设计集团技术管理部副主任倪奕在此次会议中就“新一代技术在企业中的应用和实践”作了精彩分享。上海城建院作为国内著名最具产业链优势的工程设计咨询综合服务商，在勘察设计行业中一直是数字息化建设先进单位。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-50d4b482491607a41c9ec22719117308_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"558\" class=\"content_image\" width=\"420\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;420&#39; height=&#39;558&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"558\" class=\"content_image lazy\" width=\"420\" data-actualsrc=\"https://pic1.zhimg.com/v2-50d4b482491607a41c9ec22719117308_b.jpg\"/></figure><p><b>上海城建设计集团技术管理部副主任倪奕</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>眼下，多数企业正处于转型发展的关键时期，而企业数字化建设是一个逐步适应和优化的过程，基于勘察设计行业的实际需求，云适配也将继续以独到的“移动、智能、安全”综合解决方案及优质的服务，助力勘察设计行业数字化转型，打造真正的“智慧设计院”。</p>", 
            "topic": [
                {
                    "tag": "移动化办公", 
                    "tagLink": "https://api.zhihu.com/topics/19683592"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52289704", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 9, 
            "title": "程序员必须要知道的几个网站", 
            "content": "<p>作为程序员，你经常会发现自己是某些网站的永久访问者。它们可以是教程、参考或论坛。因此，在这篇文章中，让我们看看给程序员的最佳网站。</p><h2><b>W3Schools</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.w3schools.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">W3Schools</a> 是为初学者和有经验的 Web 开发人员学习各种编程语言的最佳网站之一。你可以学习 HTML5、CSS3、PHP、 JavaScript、ASP 等。</p><p>更重要的是，该网站为网页开发人员提供了大量资源和参考资料。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7578b7713c5d89b91b876324b3d2ba62_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1345\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb\" width=\"1345\" data-original=\"https://pic3.zhimg.com/v2-7578b7713c5d89b91b876324b3d2ba62_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1345&#39; height=&#39;614&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1345\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1345\" data-original=\"https://pic3.zhimg.com/v2-7578b7713c5d89b91b876324b3d2ba62_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7578b7713c5d89b91b876324b3d2ba62_b.jpg\"/></figure><p>你可以快速浏览各种关键字及其功能。该网站非常具有互动性，它允许你在网站本身的嵌入式编辑器中尝试和练习代码。该网站是你作为网页开发人员少数需要经常访问的网站之一。</p><p>（LCTT 译注：有一个国内网站 <a href=\"https://link.zhihu.com/?target=http%3A//www.w3school.com.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">www.w3school.com.cn</a> 提供类似的中文内容，但二者似无关系。）</p><h2><b>GeeksforGeeks</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.geeksforgeeks.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GeeksforGeeks</a> 是一个主要专注于计算机科学的网站。它有大量的算法，解决方案和编程问题。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4e400e14d0311dfb3a4bc2910d3d3b63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1344\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb\" width=\"1344\" data-original=\"https://pic4.zhimg.com/v2-4e400e14d0311dfb3a4bc2910d3d3b63_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1344&#39; height=&#39;614&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1344\" data-rawheight=\"614\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1344\" data-original=\"https://pic4.zhimg.com/v2-4e400e14d0311dfb3a4bc2910d3d3b63_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4e400e14d0311dfb3a4bc2910d3d3b63_b.jpg\"/></figure><p>该网站也有很多面试中经常问到的问题。由于该网站更多地涉及计算机科学，因此你可以找到很多编程问题在大多数著名语言下的解决方案。</p><h2><b>TutorialsPoint</b></h2><p>一个学习任何东西的地方。<a href=\"https://link.zhihu.com/?target=https%3A//www.tutorialspoint.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TutorialsPoint</a> 有一些又好又简单的教程，它可以教你任何编程语言。我真的很喜欢这个网站，它不仅限于通用编程语言。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fc56107eee9895d217a23a0492c68fb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1357\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"1357\" data-original=\"https://pic2.zhimg.com/v2-fc56107eee9895d217a23a0492c68fb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1357&#39; height=&#39;628&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1357\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1357\" data-original=\"https://pic2.zhimg.com/v2-fc56107eee9895d217a23a0492c68fb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fc56107eee9895d217a23a0492c68fb5_b.jpg\"/></figure><p>你可以在这里上找到几乎所有语言框架的教程。</p><h2><b>StackOverflow</b></h2><p>你可能已经知道 <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">StackOverflow</a> 是遇到程序员的地方。你在代码中遇到问题，只要在 StackOverflow 问一个问题，来自互联网的程序员将会在那里帮助你。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-265b766745ea03975e6b0d07e78fc4c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1347\" data-rawheight=\"624\" class=\"origin_image zh-lightbox-thumb\" width=\"1347\" data-original=\"https://pic2.zhimg.com/v2-265b766745ea03975e6b0d07e78fc4c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1347&#39; height=&#39;624&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1347\" data-rawheight=\"624\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1347\" data-original=\"https://pic2.zhimg.com/v2-265b766745ea03975e6b0d07e78fc4c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-265b766745ea03975e6b0d07e78fc4c1_b.jpg\"/></figure><p>关于 StackOverflow 最好的是几乎所有的问题都得到了答案。你可能会从其他程序员的几个不同观点获得答案。</p><h2><b>HackerRank</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.hackerrank.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HackerRank</a> 是一个你可以参与各种编码竞赛并检测你的竞争能力的网站。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d3539345aaeb5c58d75829e8d25f98c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1352\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb\" width=\"1352\" data-original=\"https://pic2.zhimg.com/v2-d3539345aaeb5c58d75829e8d25f98c1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1352&#39; height=&#39;579&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1352\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1352\" data-original=\"https://pic2.zhimg.com/v2-d3539345aaeb5c58d75829e8d25f98c1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d3539345aaeb5c58d75829e8d25f98c1_b.jpg\"/></figure><p>这里有以各种编程语言举办的各种比赛，赢得比赛将增加你的分数。这个分数可以让你处于最高级别，并增加你获得一些软件公司注意的机会。</p><h2><b>Codebeautify</b></h2><p>由于我们是程序员，所以一般我们不关心代码是否可阅读。很多时候，我们的代码很难被其他人阅读。<a href=\"https://link.zhihu.com/?target=https%3A//codebeautify.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Codebeautify</a> 可以使你的代码易于阅读。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4f3b2903a79bfc2d9fa06812b6f11b06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1353\" data-rawheight=\"629\" class=\"origin_image zh-lightbox-thumb\" width=\"1353\" data-original=\"https://pic3.zhimg.com/v2-4f3b2903a79bfc2d9fa06812b6f11b06_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1353&#39; height=&#39;629&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1353\" data-rawheight=\"629\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1353\" data-original=\"https://pic3.zhimg.com/v2-4f3b2903a79bfc2d9fa06812b6f11b06_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4f3b2903a79bfc2d9fa06812b6f11b06_b.jpg\"/></figure><p>该网站有大多数可以美化的语言。另外，如果你想让你的代码不能被某人读取，你也可以这样做。</p><p>这些是我选择的一些最好的程序员网站。如果你有经常访问的我没有提及的网站，请在下面的评论区让我知道。</p>", 
            "topic": [
                {
                    "tag": "软件开发", 
                    "tagLink": "https://api.zhihu.com/topics/19552332"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": [
                {
                    "userName": "Zenka", 
                    "userLink": "https://www.zhihu.com/people/1b1bb8801b41b183aec16f18da28ff2d", 
                    "content": "<p><a href=\"http://link.zhihu.com/?target=https%3A//m.aliyun.com/act/team1212%3Fparams%3DN.AK7S4cmQZJ\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">双12来了，云产品低至2折！</a></p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Real-529", 
                    "userLink": "https://www.zhihu.com/people/7d95e0a729b032396dc1375113bd2110", 
                    "content": "最好的难道不是官方文档吗？？？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52099878", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "程序员，你应该知道的几个基础 Git 命令", 
            "content": "<p><i>简介：这个快速指南将向你展示所有的基础 Git 命令以及用法。你可以下载这些命令作为快速参考。</i></p><p>我们在早先一篇文章中已经快速介绍过 <a href=\"https://link.zhihu.com/?target=http%3A//itsfoss.com/download-vi-cheat-sheet/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vi 速查表</a>了。在这篇文章里，我们将会介绍开始使用 Git 时所需要的基础命令。</p><h2><b>Git</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//git-scm.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Git</a> 是一个分布式版本控制系统，它被用在大量开源项目中。它是在 2005 年由 Linux 创始人 <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Linus_Torvalds\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Linus Torvalds</a> 写就的。这个程序允许非线性的项目开发，并且能够通过存储在本地服务器高效处理大量数据。在这个教程里，我们将要和 Git 愉快玩耍并学习如何开始使用它。</p><p>我在这个教程里使用 Ubuntu，但你可以使用你选择的任何发行版。除了安装以外，剩下的所有命令在任何 Linux 发行版上都是一样的。</p><h2><b>安装 Git</b></h2><p>要安装 git 执行以下命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo apt-get install git-core</code></pre></div><p>在它完成下载之后，你就安装好了 Git 并且可以使用了。</p><h2><b>设置 Git</b></h2><p>在 Git 安装之后，不论是从 apt-get 还是从源码安装，你需要将你的用户名和邮箱地址复制到 gitconfig 文件。你可以访问 ~/.gitconfig 这个文件。</p><p>全新安装 Git 之后打开它会是完全空白的：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo vim ~/.gitconfig</code></pre></div><p>你也可以使用以下命令添加所需的信息。将‘user’替换成你的用户名，‘<a href=\"mailto:user@example.com\">user@example.com</a>’替换成你的邮箱。</p><div class=\"highlight\"><pre><code class=\"language-text\">git config --global user.name &#34;User&#34;\ngit config --global user.email user@example.com</code></pre></div><p>然后你就完成设置了。现在让我们开始 Git。</p><h2><b>仓库</b></h2><p>创建一个新目录，打开它并运行以下命令：</p><div class=\"highlight\"><pre><code class=\"language-text\">git init</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e6c9dfb4cbef8ca8618e7be12627734_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-6e6c9dfb4cbef8ca8618e7be12627734_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;173&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-6e6c9dfb4cbef8ca8618e7be12627734_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e6c9dfb4cbef8ca8618e7be12627734_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这个命令会创建一个新的 Git 仓库（repository）。你的本地仓库由三个 Git 维护的“树”组成。</p><p>第一个是你的工作目录（Working Directory），保存实际的文件。第二个是索引，实际上扮演的是暂存区（staging area），最后一个是 HEAD，它指向你最后一个 commit 提交。使用 git clone /path/to/repository 签出你的仓库（从你刚创建的仓库或服务器上已存在的仓库）。</p><h2><b>添加文件并提交</b></h2><p>你可以用以下命令添加改动：</p><div class=\"highlight\"><pre><code class=\"language-text\">git add &lt;filename&gt;\n</code></pre></div><p>这会添加一个新文件到暂存区以提交。如果你想添加每个新文件，输入：</p><div class=\"highlight\"><pre><code class=\"language-text\">git add --all\n</code></pre></div><p>添加文件之后可以使用以下命令检查状态：</p><div class=\"highlight\"><pre><code class=\"language-text\">git status</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-79bd8ea7fd5998e5d3fb5c5108f53afe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-79bd8ea7fd5998e5d3fb5c5108f53afe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;219&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-79bd8ea7fd5998e5d3fb5c5108f53afe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-79bd8ea7fd5998e5d3fb5c5108f53afe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>正如你看到的，那里已经有一些变化但还没有提交。现在你需要提交这些变化，使用：</p><div class=\"highlight\"><pre><code class=\"language-text\">git commit -m &#34;提交信息&#34;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-91d4da59d1eb8d8b489c8bc7d130d758_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-91d4da59d1eb8d8b489c8bc7d130d758_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;124&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-91d4da59d1eb8d8b489c8bc7d130d758_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-91d4da59d1eb8d8b489c8bc7d130d758_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>你也可以这么做（首选）：</p><div class=\"highlight\"><pre><code class=\"language-text\">git commit -a</code></pre></div><p>然后写下你的提交信息。现在你的文件提交到了 HEAD，但还不在你的远程仓库中。</p><h2><b>推送你的改动</b></h2><p>你的改动在你本地工作副本的 HEAD 中。如果你还没有从一个已存在的仓库克隆，或想将你的仓库连接到远程服务器，你需要先添加它：</p><div class=\"highlight\"><pre><code class=\"language-text\">git remote add origin &lt;服务器地址&gt;\n</code></pre></div><p>现在你可以将改动推送到指定的远程服务器。要将改动发送到远程服务器，运行：</p><div class=\"highlight\"><pre><code class=\"language-text\">git push -u origin master\n\n</code></pre></div><h2><b>分支</b></h2><p>分支用于开发特性，分支之间是互相独立的。主分支 master 是你创建一个仓库时的“默认”分支。使用其它分支用于开发，在完成时将它合并回主分支。</p><p>创建一个名为“mybranch”的分支并切换到它之上：</p><div class=\"highlight\"><pre><code class=\"language-text\">git checkout -b mybranch</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ef8ef912eeb82ad8ee33b2d7aafb1292_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-ef8ef912eeb82ad8ee33b2d7aafb1292_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;145&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"145\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-ef8ef912eeb82ad8ee33b2d7aafb1292_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ef8ef912eeb82ad8ee33b2d7aafb1292_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>你可以使用这个命令切换回主分支：</p><div class=\"highlight\"><pre><code class=\"language-text\">git checkout master\n\n</code></pre></div><p>如果你想删除这个分支，执行：</p><div class=\"highlight\"><pre><code class=\"language-text\">git branch -d mybranch</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b65f8d959f323aab6bdec53f8d085c8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"181\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-b65f8d959f323aab6bdec53f8d085c8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;181&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"181\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-b65f8d959f323aab6bdec53f8d085c8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b65f8d959f323aab6bdec53f8d085c8e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>除非你将分支推送到远程服务器上，否则该分支对其他人是不可用的，所以只需把它推送上去：</p><div class=\"highlight\"><pre><code class=\"language-text\">git push origin &lt;分支名&gt;</code></pre></div><h2><b>更新和合并</b></h2><p>要将你本地仓库更新到最新的提交上，运行：</p><div class=\"highlight\"><pre><code class=\"language-text\">git pull</code></pre></div><p>在你的工作目录获取并合并远程变动。要合并其它分支到你的活动分支（如 master），使用：</p><div class=\"highlight\"><pre><code class=\"language-text\">git merge &lt;分支&gt;</code></pre></div><p>在这两种情况下，git 会尝试自动合并（auto-merge）改动。不幸的是，这不总是可能的，可能会导致冲突。你需要通过编辑 git 所显示的文件，手动合并那些冲突。改动之后，你需要用以下命令将它们标记为已合并：</p><div class=\"highlight\"><pre><code class=\"language-text\">git add &lt;文件名&gt;\n</code></pre></div><p>在合并改动之前，你也可以使用以下命令预览：</p><div class=\"highlight\"><pre><code class=\"language-text\">git diff &lt;源分支&gt; &lt;目标分支&gt;</code></pre></div><h2><b>Git 日志</b></h2><p>你可以这么查看仓库历史：</p><div class=\"highlight\"><pre><code class=\"language-text\">git log</code></pre></div><p>要以每个提交一行的样式查看日志，你可以用：</p><div class=\"highlight\"><pre><code class=\"language-text\">git log --pretty=oneline</code></pre></div><p>或者也许你想要看一个所有分支的 ASCII 艺术树，带有标签和分支名：</p><div class=\"highlight\"><pre><code class=\"language-text\">git log --graph --oneline --decorate --all</code></pre></div><p>如果你只想看哪些文件改动过：</p><div class=\"highlight\"><pre><code class=\"language-text\">git log --name-status</code></pre></div><p>在这整个过程中如果你需要任何帮助，你可以用 git --help。</p><p>Git 棒不棒？！祝贺你你已经会 Git 基础了。如果你愿意的话，你可以从下面这个链接下载这些基础 Git 命令作为快速参考：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//drive.google.com/open%3Fid%3D0By49_3Av9sT1bXpINjhvU29VNUU\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">下载 Git 速查表</a></li></ul>", 
            "topic": [
                {
                    "tag": "版本控制", 
                    "tagLink": "https://api.zhihu.com/topics/19738222"
                }, 
                {
                    "tag": "版本控制系统", 
                    "tagLink": "https://api.zhihu.com/topics/19551033"
                }, 
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52039894", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "Linux 新手必须知道的 10 条 Linux 基本命令", 
            "content": "<p>Linux 对我们的生活产生了巨大的冲击。至少你的安卓手机使用的就是 Linux 核心。尽管如此，在第一次开始使用 Linux 时你还是会感到难以下手。因为在 Linux 中，通常需要使用终端命令来取代 Windows 系统中的点击启动图标操作。但是不必担心，这里我们会介绍 10 个 Linux 基本命令来帮助你开启 Linux 神秘之旅。</p><h2><b>帮助新手走出第一步的 10 个 Linux 基本命令</b></h2><p>当我们谈论 Linux 命令时，实质上是在谈论 Linux 系统本身。这短短的 10 个 Linux 基本命令不会让你变成天才或者 Linux 专家，但是能帮助你轻松开始 Linux 之旅。使用这些基本命令会帮助新手们完成 Linux 的日常任务，由于它们的使用频率如此至高，所以我更乐意称他们为 Linux 命令之王！</p><p>让我们开始学习这 10 条 Linux 基本命令吧。</p><h2><b>1. sudo</b></h2><p>这条命令的意思是“以超级用户的身份执行”，是 SuperUserDo 的简写，它是新手将要用到的最重要的一条 Linux 命令。当一条单行命令需要 root 权限的时候，<code>sudo</code>命令就派上用场了。你可以在每一条需要 root 权限的命令前都加上<code>sudo</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ sudo su</code></pre></div><h2><b>2. ls (list)</b></h2><p>跟其他人一样，你肯定也经常想看看目录下都有些什么东西。使用列表命令，终端会把当前工作目录下所有的文件以及文件夹展示给你。比如说，我当前处在 /home 文件夹中，我想看看 /home 文件夹中都有哪些文件和目录。</p><div class=\"highlight\"><pre><code class=\"language-text\">/home$ ls</code></pre></div><p>在 /home 中执行<code>ls</code>命令将会返回类似下面的内容：</p><div class=\"highlight\"><pre><code class=\"language-text\">imad lost+found</code></pre></div><h2><b>3. cd</b></h2><p>变更目录命令（cd）是终端中总会被用到的主要命令。它是最常用到的 Linux 基本命令之一。此命令使用非常简单，当你打算从当前目录跳转至某个文件夹时，只需要将文件夹键入此命令之后即可。如果你想跳转至上层目录，只需要在此命令之后键入两个点 (..) 就可以了。 ​ 举个例子，我现在处在 /home 目录中，我想移动到 /home 目录中的 usr 文件夹下，可以通过以下命令来完成操作。</p><div class=\"highlight\"><pre><code class=\"language-text\">/home $ cd usr\n\n/home/usr $</code></pre></div><h2><b>4. mkdir</b></h2><p>只是可以切换目录还是不够完美。有时候你会想要新建一个文件夹或子文件夹。此时可以使用 mkdir 命令来完成操作。使用方法很简单，只需要把新的文件夹名跟在 mkdir 命令之后就好了。</p><div class=\"highlight\"><pre><code class=\"language-text\">~$ mkdir folderName</code></pre></div><h2><b>5. cp</b></h2><p>拷贝-粘贴（copy-and-paste）是我们组织文件需要用到的重要命令。使用 <code>cp</code> 命令可以帮助你在终端当中完成拷贝-粘贴操作。首先确定你想要拷贝的文件，然后键入打算粘贴此文件的目标位置。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ cp src des</code></pre></div><p>注意：如果目标目录对新建文件需要 root 权限时，你可以使用 <code>sudo</code> 命令来完成文件拷贝操作。</p><h2><b>6. rm</b></h2><p>rm 命令可以帮助你移除文件甚至目录。如果不希望每删除一个文件都提示确认一次，可以用<code>-f</code>参数来强制执行。也可以使用 <code>-r</code> 参数来递归的移除文件夹。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ rm myfile.txt</code></pre></div><h2><b>7. apt-get</b></h2><p>这个命令会依据发行版的不同而有所区别。在基于 Debian 的发行版中，我们拥有 Advanced Packaging Tool（APT）包管理工具来安装、移除和升级包。apt-get 命令会帮助你安装需要在 Linux 系统中运行的软件。它是一个功能强大的命令行，可以用来帮助你对软件执行安装、升级和移除操作。</p><p>在其他发行版中，例如 Fedora、Centos，都各自不同的包管理工具。Fedora 之前使用的是 yum，不过现在 dnf 成了它默认的包管理工具。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ sudo apt-get update\n\n$ sudo dnf update</code></pre></div><h2><b>8. grep</b></h2><p>当你需要查找一个文件，但是又忘记了它具体的位置和路径时，<code>grep</code> 命令会帮助你解决这个难题。你可以提供文件的关键字，使用<code>grep</code>命令来查找到它。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ grep user /etc/passwd</code></pre></div><h2><b>9. cat</b></h2><p>作为一个用户，你应该会经常需要浏览脚本内的文本或者代码。<code>cat</code>命令是 Linux 系统的基本命令之一，它的用途就是将文件的内容展示给你。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ cat CMakeLists.txt</code></pre></div><h2><b>10. poweroff</b></h2><p>最后一个命令是 <code>poweroff</code>。有时你需要直接在终端中执行关机操作。此命令可以完成这个任务。由于关机操作需要 root 权限，所以别忘了在此命令之前添加<code>sudo</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">$ sudo poweroff</code></pre></div><h2><b>总结</b></h2><p>如我在文章开始所言，这 10 条命令并不会让你立即成为一个 Linux 大拿，但它们会让你在初期快速上手 Linux。以这些命令为基础，给自己设置一个目标，每天学习一到三条命令，这就是此文的目的所在。在下方评论区分享有趣并且有用的命令。别忘了跟你的朋友分享此文。</p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51996029", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "我们为什么需要性能优化以及关于性能优化的一些建议", 
            "content": "<p>在我们推动网络做更多事情的时候，我们遇到了一个共同的问题：性能。网站和应用程序的功能比以往更丰富。结果，他们对网络和设备资源的要求越来越高。因此，我们现在很难在各种网络条件和设备上实现高水平的性能。</p><p>性能问题是多样的。情况好点的，缓网站和应用程序产生一些微不足道的延迟，这些延迟会给用户一些不好的交互体验。也有及其糟糕的情况，那就是它们完全无法访问，对用户输入没有反应，或两者兼而有之。</p><h2><b>性能是留住用户很重要的一环</b></h2><p>我们希望用户与用Web构建的内容进行有意义的交互。如果是博客，我们希望人们阅读帖子。如果是在线商店，我们希望将潜在的购物者变成买家。如果它是一个社交网络网络应用程序，我们希望访问者写帖子，上传照片，并与其他人互动。</p><p>性能在任何在线企业的成功中起着重要作用，因为高性能的网站比表现不佳的网站更好地吸引和留住用户。以下是有关性能如何影响多个网站的互动和转化的案例研究。</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40Pinterest_Engineering/driving-user-growth-with-performance-improvements-cfc50dafadd7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pinterest重建了他们的页面以实现性能，使感知等待时间减少了40％，从而将搜索引擎流量和注册量提高了15％。</a>.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.nccgroup.trust/uk/about-us/resources/cook-real-user-monitoring-case-study/%3Fstyle%3DWebsite%2BPerformance%26resources%3DCase%2BStudies\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">通过将平均页面加载时间减少850毫秒，COOK发现他们能够将转化率提高7％，将跳出率降低7％，并将每个页面的页面数量增加10％。</a>.</li></ul><p>如果高性能是一种资产，那么表现不佳就是一种负担。以下是一些案例研究，其中表现不佳会对业务目标产生负面影响：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.creativebloq.com/features/how-the-bbc-builds-websites-that-scale\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BBC发现，他们在网站加载的每一秒钟内就会损失10％的用户。</a>.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.doubleclickbygoogle.com/articles/mobile-speed-matters/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DoubleClick by Google发现，如果网页加载时间超过3秒，则会有53％的用户放弃移动网站的访问。</a>.</li></ul><p>由于业务竞争激烈，我们始终认识到竞争对手的行为。在上面引用的同一个<a href=\"https://link.zhihu.com/?target=https%3A//www.doubleclickbygoogle.com/articles/mobile-speed-matters/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DoubleClick by Google</a>调查中，发现在5秒内加载的网站的会话时间延长了70％，跳出率降低了35％，广告可见度也提高了25％，比19秒时间长了近4倍的网站。要大致了解您的网站的性能与竞争对手的比较，<a href=\"https://link.zhihu.com/?target=https%3A//www.thinkwithgoogle.com/feature/mobile/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">请查看速度记分卡工具。</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-abff9cb5e38313e32f9761c95eefe938_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic1.zhimg.com/v2-abff9cb5e38313e32f9761c95eefe938_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic1.zhimg.com/v2-abff9cb5e38313e32f9761c95eefe938_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-abff9cb5e38313e32f9761c95eefe938_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>图 1</b>. Speed Scorecard使用来自美国4G网络用户的Chrome UX报告数据比较四个竞争网站的性能。</p><h2><b>性能是改善转换率至关重要的一环</b></h2><p>留住用户对于改善转化率至关重要。如果您经营在线业务，转换是目标，性能至关重要。缓慢的网站对收入产生负面影响，反之亦然。以下是一些示例，说明性能如何在使企业获利更多（或更少）方面发挥作用：</p><ul><li>对于Mobify，<a href=\"https://link.zhihu.com/?target=http%3A//resources.mobify.com/2016-Q2-mobile-insights-benchmark-report.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">主页加载速度每减少100毫秒，基于会话的转换增加1.11％，平均年收入增加近380,000美元</a>。此外，结账页面加载速度减少100毫秒，基于会话的转换增加了1.55％，从而使年均收入增长近530,000美元。</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.doubleclickbygoogle.com/articles/mobile-speed-matters/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DoubleClick发现在5秒内加载网站的发布商的广告收入是在19秒内加载的网站的两倍。</a>.</li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.digitalcommerce360.com/2010/08/19/web-accelerator-revs-conversion-and-sales-autoanything/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">当AutoAnything将页面加载时间缩短一半时，他们的销售额增长了12-13％。</a></li></ul><p>如果您在网络上经营业务，性能至关重要。如果您网站的能够快速的响应用户输入，则能够为用户带来更多的服务。要了解效果可能会如何影响您的收入，请查看我们的<a href=\"https://link.zhihu.com/?target=https%3A//www.thinkwithgoogle.com/feature/mobile/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">影响力计算器</a>工具。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1e189289e34613ad91898445a18ed76c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"766\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"766\" data-original=\"https://pic1.zhimg.com/v2-1e189289e34613ad91898445a18ed76c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;766&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"766\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"766\" data-original=\"https://pic1.zhimg.com/v2-1e189289e34613ad91898445a18ed76c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1e189289e34613ad91898445a18ed76c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图2.影响计算器通过改善网站性能来估算您可以获得多少收入。</p><h2><b>性能与用户体验有关</b></h2><p>当你点击一个网站的时候，由于条件（例如，连接质量，服务器和前端架构）的不同，您的体验可能与其他用户完全不同。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ccbd545fe03e1227ab506bc146c3677c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1128\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"1128\" data-original=\"https://pic1.zhimg.com/v2-ccbd545fe03e1227ab506bc146c3677c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1128&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1128\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1128\" data-original=\"https://pic1.zhimg.com/v2-ccbd545fe03e1227ab506bc146c3677c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ccbd545fe03e1227ab506bc146c3677c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>图3</b> ：在非常慢的连接（顶部）与更快的连接（底部）上的页面加载的比较。</p><p>当网站开始加载时，用户会等待内容出现一段时间。在此之前，没有任何用户体验可言。但是，在较慢的连接上，用户被迫等待。当最终渲染<i>does</i>在这样的条件下启动时，用户可能会受到CSS，JavaScript和其他页面资源慢慢渗入的进一步问题的困扰，每个都会出现自己独特的性能问题。</p><p>因此，可以认为性能是良好用户体验的基础方面。当网站发布大量代码时，由于浏览器在慢速网络上咀嚼数兆字节，性能仍然不佳。处理能力和内存有限的设备可能无法应对我们认为适量的未经优化的代码。由于性能不佳，应用程序响应能力和可用性会降低。如果您想了解更多有关如何评估网站性能并找到改进机会的信息，请查看我们的指南<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/speed-tools/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何思考速度工具</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3990e591080fcde76c17ff6094a55b78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-3990e591080fcde76c17ff6094a55b78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;398&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-3990e591080fcde76c17ff6094a55b78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3990e591080fcde76c17ff6094a55b78_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图4.在<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/tools/lighthouse/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lighthouse</a>中看到的页面性能概述。</p><h2><b>性能对于用户的意义</b></h2><p>虽然提高性能对于企业的财务至关重要，但重要的是不要忽视人们在浏览网络时面临的潜在挑战。改善性能不应仅仅视为推进自己的一种手段，而应视为道德上负责任的行为。表现不佳的网站和应用程序可能会给使用它们的人带来一些后果和时间成本。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//gs.statcounter.com/platform-market-share/desktop-mobile-tablet\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">随着移动用户继续占全球互联网用户的很大一部分</a>, it&#39;s ，重要的是要记住，其中许多用户通过移动LTE，4G，3G甚至2G网络访问网络。<a href=\"https://link.zhihu.com/?target=https%3A//building.calibreapp.com/beyond-the-bubble-real-world-performance-9c991dcd5342\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">正如Caliber的Ben Schwarz在这项关于现实世界性能的研究中所指出的那样</a>，预付费数据计划的成本正在下降，这反过来又使得在以前没有的地方更容易获得互联网。简而言之，移动设备和互联网接入不再是富裕消费者的奢侈品。它们是在日益互联的世界中导航和运行所必需的常用工具。</p><p><a href=\"https://link.zhihu.com/?target=http%3A//beta.httparchive.org/reports/state-of-the-web%23bytesTotal\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">自2011年以来</a>，总页面大小一直在稳步增长，而且这种趋势似乎还在继续。随着典型页面提供的数据量的增加，计量数据变得不那么经济。</p><p>虽然快速和轻量级的用户体验显示出经济上的考虑，但它们对危机中的用户也很重要。医院，诊所和危机中心等公共资源拥有在线资源，可以传达人们在危机中需要的重要和具体信息。<a href=\"https://link.zhihu.com/?target=https%3A//aneventapart.com/news/post/eric-meyer-designing-for-crisis\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在紧张时刻有效地呈现重要信息至关重要</a>但是不能低估提供这些信息的重要性。</p><h2><b>下一步是什么？</b></h2><p>你现在知道为什么性能很重要，但你可能想知道“下一步是什么？”接下来，我们将介绍三个实用的性能考虑因素，并提供解决每个问题的建议。虽然这些列表可能看起来令人生畏，但要了解您不需要执行所有这些操作来提高站点的性能。它们只是潜在的起点，所以不要感到不知所措！您可以采取的任何措施来提高性能对您的用户有所帮助。</p><h2><b>你发送的资源</b></h2><p>构建高性能应用程序的有效方法是<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/eliminate-downloads\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">审核发送给用户的资源</a>。虽然<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/tools/chrome-devtools/network-performance/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Chrome开发人员工具中的网络面板</a>可以很好地总结给定页面上使用的所有资源，但如果您到目前为止尚未考虑性能，那么知道从哪里开始是很重要的。以下是一些建议：</p><ul><li><b>如果您使用Bootstrap或Foundation来构建UI</b>，请问自己是否有必要。这些资源添加了浏览器必须下载，解析和应用于页面的大量CSS，所有这些都是在特定于站点的CSS进入图片之前。 Flexbox和Grid在使用相对较少的代码创建简单和复杂布局方面非常出色。<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/critical-rendering-path/render-blocking-css\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">由于CSS是一种渲染阻塞资源</a>，因此CSS框架的开销可能会显着延迟渲染。您应该通过消除不必要的开销来加速渲染，尽可能依赖于浏览器中的工具。</li><li><b>JavaScript库很方便，但并不总是必要的</b>。以jQuery为例：由于<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">querySelector</a> 和 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">querySelectorAll</a>等方法，元素选择得到了极大的简化。使用addEventListener可以轻松进行事件绑定。 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">addEventListener</a>. <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Element/classList\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">classList</a>, <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">setAttribute</a>, 和<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">getAttribute</a>提供了使用类和元素属性的简便方法。如果你必须使用图书馆，研究更精简的替代品。例如，<a href=\"https://link.zhihu.com/?target=http%3A//zeptojs.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Zepto</a>是一个较小的jQuery替代品，<a href=\"https://link.zhihu.com/?target=https%3A//preactjs.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Preact</a>是React的一个小得多的替代品。</li><li><b>并非所有网站都需要是单页面应用程序（SPA）</b>，因为它们经常广泛使用JavaScript。 <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/dev-channel/the-cost-of-javascript-84009f51e99e\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JavaScript是我们在字节的web字节上提供的最昂贵的资源</a>，因为它不仅必须下载，还必须解析，编译和执行。例如，具有优化前端架构的新闻和博客站点可以像传统的多页体验一样表现良好。特别是如果正确配置了<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/http-caching\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTTP缓存</a>，并且可选地，如果使用了<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/primers/service-workers/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">service worker</a>。</li></ul><h2><b>你如何发送资源</b></h2><p>当您知道需要为您的应用发送哪些资源以使其成为您想要的美观和功能时，请考虑下一步如何发送它们。如何发送资源对于构建快速用户体验至关重要。</p><ul><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/http2/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">迁移到HTTP / 2</a></b>。 HTTP / 2解决了HTTP / 1.1中固有的许多性能问题，例如并发请求限制和缺少头压缩。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/resource-prioritization\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">使用资源提示加快资源交付</a></b>。 rel = preload是一个这样的资源提示，它允许在浏览器发现它们之前提前获取关键资源。<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/reloading/preload-prefetch-and-priorities-in-chrome-776165961bbf%230106\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这可以对页面呈现产生明显的积极影响</a>，并在明智地使用时降低交互时间。 <a href=\"https://link.zhihu.com/?target=https%3A//www.igvita.com/2015/08/17/eliminating-roundtrips-with-preconnect/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">rel = preconnect是另一个资源提示，可以掩盖为第三方域上托管的资源打开新连接的延迟</a>。</li><li><b>现代网站<a href=\"https://link.zhihu.com/?target=http%3A//httparchive.org/trends.php%23bytesJS%26reqJS\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">平均提供大量JavaScript</a> <a href=\"https://link.zhihu.com/?target=http%3A//httparchive.org/trends.php%23bytesCSS%26reqCSS\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">和 CSS</a></b>。在HTTP / 1环境中将样式和脚本捆绑到大型捆绑包中很常见。这样做是因为大量请求对性能有害。现在不再是HTTP / 2在场的情况，因为多个同时请求更便宜。考虑在<a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/guides/code-splitting/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack中使用代码拆分来限制下载的脚本数量</a>，使其仅限于当前页面或视图所需的内容。将CSS分成较小的模板或特定于组件的文件，并仅包含可能使用它们的资源。</li></ul><h2><b>你发送了多少数据</b></h2><p>有了一些关于哪些资源适合发送的想法以及<i>how</i>你应该发送它们，我们将介绍一些限制你发送的<i>how much</i>数据的建议：</p><ul><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer%23minification_preprocessing_context-specific_optimizations\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">缩小文本资源</a></b>。缩小是在基于文本的资源中删除不必要的空格，注释和其他内容。它可以显着减少您发送给用户的数据量，而不会影响功能。在JavaScript中使用<i><a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/uglifyjs\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">uglification</a></i>以通过缩短变量和方法名称来进一步节省成本。由于SVG是基于文本的图像格式，因此可以使用<a href=\"https://link.zhihu.com/?target=https%3A//github.com/svg/svgo\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SVGO进行优化</a>。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/optimize-encoding-and-transfer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">配置服务器以压缩资源</a></b>。压缩资源会大大减少您发送给用户的数据量，尤其是在涉及文本资产的情况下。 GZIP在这个领域是一种令人尊敬的格式，但<a href=\"https://link.zhihu.com/?target=https%3A//www.smashingmagazine.com/2016/10/next-generation-server-compression-with-brotli/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Brotli</a>.压缩可以更进一步。但是，要理解压缩并不是性能问题的全部：一些隐式压缩的文件格式（例如，JPEG，PNG，GIF，WOFF等）不响应压缩，因为它们已经被压缩。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/automating-image-optimization/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">优化图像</a></b> 以确保您的网站尽可能少地发送图像数据。<a href=\"https://link.zhihu.com/?target=http%3A//httparchive.org/trends.php%23bytesImg%26reqImg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">由于图像构成消耗了大部分的性能</a>，因此图像优化代表了提升性能的独特机会。</li><li>如果您有时间，请考虑提供其他图像格式。 <a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/speed/webp/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">WebP</a>享有相当广泛的<a href=\"https://link.zhihu.com/?target=https%3A//caniuse.com/%23feat%3Dwebp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">浏览器支持</a>，并且可以在保持类似视觉质量的同时削弱文件大小的既定格式。 JPEG XR是IE和Edge支持的另一种<a href=\"https://link.zhihu.com/?target=https%3A//jpeg.org/jpegxr/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">替代格式</a>，可提供类似的节省。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">响应地传送图像</a></b>。各种各样的设备及其屏幕提供了一个巨大的机会，通过发送最适合查看它们的屏幕的图像来提高性能。在最简单的用例中，您可以向元素添加<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/HTML/Element/img%23attr-srcset\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">srcset属性</a> ，以指定浏览器可以选择的图像数组。在更复杂的方面，您可以使用帮助浏览器选择最佳格式（例如，WebP over JPEG或PNG），或者为不同的屏幕尺寸提供不同的图像处理。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">使用视频而不是动画GIF</a></b>。动画GIF非常庞大，但质量相近的视频要小得多，通常大约80％左右。如果您的网站大量使用动画GIF，这可能是您可以做的最有效的事情，以提高加载性能。</li><li><b><a href=\"https://link.zhihu.com/?target=http%3A//httpwg.org/http-extensions/client-hints.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">客户端提示</a></b> 可用于根据当前网络条件和设备特征定制资源交付。 DPR，Width和Viewport-Width标头可以帮助您<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/updates/2015/09/automating-resource-selection-with-client-hints\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">使用服务器端代码为设备提供最佳图像</a>，并提供更少的标记。 <a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/updates/2016/02/save-data\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Save-Data标头可以帮助您为明确要求您的用户提供更轻松的应用程序体验</a>。</li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/NetworkInformation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NetworkInformation API</a></b>公开有关用户网络连接的信息。此信息可用于修改较慢网络上的用户的应用程序体验。</li></ul><p>有关提高性能的更全面的指南，请查看我们关于<a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/rail\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">RAIL性能模型</a>的文章，其重点是改善加载时间和应用程序响应能力 。 <a href=\"https://link.zhihu.com/?target=https%3A//developers.google.cn/web/fundamentals/performance/prpl-pattern/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">我们的PRPL模式指南也是一个很好的资源</a>，用于改善现代单页面应用程序的性能。</p><p>如果您对如何更好地了解性能以及如何加快网站速度感到兴奋，请浏览我们的性能文档，以获取有关各种主题的指南。 我们不断添加新指南并更新现有指南，敬请期待！</p><p>特别感谢Addy Osmani，Jeff Posnick，Matt Gaunt，Philip Walton，Vinamrata Singal，Daniel An和Pete LePage在改进和推出这一资源方面的广泛反馈，以及众成翻译“_小生_”的辛勤付出！</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19633850"
                }, 
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51815058", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "Javascript的对象拷贝", 
            "content": "<p>本篇文章将会说说Javascript中对象拷贝的多种方式，以及探究一下深拷贝和浅拷贝。</p><p>在开始之前，我先提一下一些基础知识：Javascript 的对象只是指向内存中某个位置的指针。这些指针是可变的，也就是说，它们可以重新被赋值。因此，单单复制这个指针的结果是，有两个指针指向内存中的同一块地址。</p><div class=\"highlight\"><pre><code class=\"language-text\">var foo = {\n    a : &#34;abc&#34;\n}\nconsole.log(foo.a);\n// abc\n\nvar bar = foo;\nconsole.log(bar.a);\n// abc\n\nfoo.a = &#34;yo foo&#34;;\nconsole.log(foo.a);\n// yo foo\nconsole.log(bar.a);\n// yo foo\n\nbar.a = &#34;whatup bar?&#34;;\nconsole.log(foo.a);\n// whatup bar?\nconsole.log(bar.a);\n// whatup bar?    </code></pre></div><p>如上面的例子可见，foo和bar对象都能根据对方的变化而变化。因此，在拷贝Javascript中的对象时，我们要根据实际使用情况，而做一些考虑。</p><h2><b>浅拷贝</b></h2><p>如果要操作的对象拥有的属性都是值类型，那么我们可以用扩展语法或者Object.assign(...)</p><div class=\"highlight\"><pre><code class=\"language-text\">var obj = { foo: &#34;foo&#34;, bar: &#34;bar&#34; };\nvar copy = { ...obj };\n// Object { foo: &#34;foo&#34;, bar: &#34;bar&#34; }\nvar obj = { foo: &#34;foo&#34;, bar: &#34;bar&#34; };\nvar copy = Object.assign({}, obj);\n// Object { foo: &#34;foo&#34;, bar: &#34;bar&#34; }</code></pre></div><p>可以看到，上面的两个方法都可以把多个不同来源对象中的属性拷贝到一个目标对象中。</p><div class=\"highlight\"><pre><code class=\"language-text\">var obj1 = { foo: &#34;foo&#34; };\nvar obj2 = { bar: &#34;bar&#34; };\nvar copySpread = { ...obj1, ...obj2 };\n// Object { foo: &#34;foo&#34;, bar: &#34;bar&#34; }\nvar copyAssign = Object.assign({}, obj1, obj2);\n// Object { foo: &#34;foo&#34;, bar: &#34;bar&#34; }</code></pre></div><p>上面方法的问题是，如果对象的属性本身也是对象，那么实际被拷贝的只是那些指针，也就是说，这跟执行 var bar = foo; 的效果是一样的，跟第一段代码的做法一样。</p><div class=\"highlight\"><pre><code class=\"language-text\">var foo = { a: 0 , b: { c: 0 } };\nvar copy = { ...foo };\ncopy.a = 1;\ncopy.b.c = 2;\nconsole.dir(foo);\n// { a: 0, b: { c: 2 } }\nconsole.dir(copy);\n// { a: 1, b: { c: 2 } }</code></pre></div><h2><b>深拷贝（有限制）</b></h2><p>想要深拷贝一个对象，一个可用的解决方法是，先把对象序列化为字符串，然后再把它反序列化回来。</p><div class=\"highlight\"><pre><code class=\"language-text\">var obj = { a: 0, b: { c: 0 } };\nvar copy = JSON.parse(JSON.stringify(obj));</code></pre></div><p>不幸的是，这个方法只在对象包含可序列化值，并且没有循环引用的时候有用。其中一个不可序列化的类型的就是日期对象 - 尽管它显示出来是字符串化的ISO格式，JSON.parse只会把它解析成为一个字符串，而不是日期类型</p><h2><b>深拷贝 (少一点限制)</b></h2><p>对于一些更复杂的情景，我们可以使用HTML5的一个新算法，叫做<a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Notification/Notification\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">结构化克隆</a>。不过，截至本篇文章发表为止，有些内置类型还是无法支持，但相比JSON.parse，它支持的类型要多的多：日期类型，正则表达式，Map，集合，二进制大对象，文件集合，图像数据，sparse函数和数组。 它还维护克隆对象的引用，使得他可以支持循环引用结构的拷贝，而这些在上面的序列化例子中是不支持的。</p><p>目前，没有直接调用结构化克隆的方法，但是有些新的浏览器特性，底层使用了这个算法。因此，深拷贝对象可能需要一系列的环境才能实现。</p><p>通过 MessageChannels: 这样做的原理是，借用通讯的一个特性中使用到的序列化算法。由于那个特性是基于事件的，所以这里的克隆也是一个异步操作。</p><div class=\"highlight\"><pre><code class=\"language-text\">class StructuredCloner {\n  constructor() {\n    this.pendingClones_ = new Map();\nthis.nextKey_ = 0;\nconst channel = new MessageChannel();\nthis.inPort_ = channel.port1;\nthis.outPort_ = channel.port2;\nthis.outPort_.onmessage = ({data: {key, value}}) =&gt; {\n      const resolve = this.pendingClones_.get(key);\nresolve(value);\nthis.pendingClones_.delete(key);\n};\nthis.outPort_.start();\n}\n\n  cloneAsync(value) {\n    return new Promise(resolve =&gt; {\n      const key = this.nextKey_++;\nthis.pendingClones_.set(key, resolve);\nthis.inPort_.postMessage({key, value});\n});\n}\n}\n\nconst structuredCloneAsync = window.structuredCloneAsync =\n    StructuredCloner.prototype.cloneAsync.bind(new StructuredCloner);\nconst main = async () =&gt; {\n  const original = { date: new Date(), number: Math.random() };\noriginal.self = original;\nconst clone = await structuredCloneAsync(original);\n// different objects:\n  console.assert(original !== clone);\nconsole.assert(original.date !== clone.date);\n// cyclical:\n  console.assert(original.self === original);\nconsole.assert(clone.self === clone);\n// equivalent values:\n  console.assert(original.number === clone.number);\nconsole.assert(Number(original.date) === Number(clone.date));\nconsole.log(&#34;Assertions complete.&#34;);\n};\nmain();</code></pre></div><p>通过history对象API：history.pushState() 和history.replaceState() 都会给它们的第一个参数做一个结构化克隆！要注意的是，这个方法是同步的，操作浏览器历史这个操作速度不是非常快，如果频繁调用这个方法，会导致浏览器卡死。</p><div class=\"highlight\"><pre><code class=\"language-text\">const structuredClone = obj =&gt; {\n  const oldState = history.state;\nhistory.replaceState(obj, null);\nconst clonedObj = history.state;\nhistory.replaceState(oldState, null);\nreturn clonedObj;\n};</code></pre></div><p>通过 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/Notification/Notification\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">notification API</a>: 当创建一个notification实例的时候，构造器为它相关的数据做了结构化克隆。需要注意的是，它会尝试向用户展示浏览器通知，但是，除非它接收到用户允许展示通知的请求，否则，它什么也不会做。一旦用户点击同意的话，notification 会立刻被关闭。</p><div class=\"highlight\"><pre><code class=\"language-text\">const structuredClone = obj =&gt; {\n  const n = new Notification(&#34;&#34;, {data: obj, silent: true});\nn.onshow = n.close.bind(n);\nreturn n.data;\n};</code></pre></div><h2>使用Node.js进行深拷贝</h2><p>Node.js的8.0.0版本提供了一个 <a href=\"https://link.zhihu.com/?target=https%3A//nodejs.org/api/v8.html%23v8_serialization_api\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">序列化 api</a> 可以跟结构化克隆媲美. 不过这个API在本文发布的时候，还只是被认为是试验性的:</p><div class=\"highlight\"><pre><code class=\"language-text\">const v8 = require(&#39;v8&#39;);\nconst buf = v8.serialize({a: &#39;foo&#39;, b: new Date()});\nconst cloned = v8.deserialize(buf);\ncloned.b.getMonth();</code></pre></div><p>8.0.0版本以下的话，比较稳定的方法，可以考虑用 lodash的cloneDeep函数，它的思想也多少有点基于结构化克隆算法。</p><h2><b>结论</b></h2><p>总结一下，Javascript 中最好的对象拷贝的算法，很大程度上取决于使用环境，以及你需要拷贝的对象的类型。虽然lodash是最安全的泛型深拷贝函数，但是，如果你自己封装的话，可能可以得到效率更高的实现方法，以下就是一个简单的深拷贝，也同样适用于Date日期对象：</p><div class=\"highlight\"><pre><code class=\"language-text\">function deepClone(obj) {\n  var copy;\n// Handle the 3 simple types, and null or undefined\n  if (null == obj || &#34;object&#34; != typeof obj) return obj;\n// Handle Date\n  if (obj instanceof Date) {\n    copy = new Date();\ncopy.setTime(obj.getTime());\nreturn copy;\n}\n\n  // Handle Array\n  if (obj instanceof Array) {\n    copy = [];\nfor (var i = 0, len = obj.length;\ni &lt; len;\ni++) {\n        copy[i] = deepClone(obj[i]);\n}\n    return copy;\n}\n\n  // Handle Function\n  if (obj instanceof Function) {\n    copy = function() {\n      return obj.apply(this, arguments);\n}\n    return copy;\n}\n\n  // Handle Object\n  if (obj instanceof Object) {\n      copy = {};\nfor (var attr in obj) {\n          if (obj.hasOwnProperty(attr)) copy[attr] = deepClone(obj[attr]);\n}\n      return copy;\n}\n\n  throw new Error(&#34;Unable to copy obj as type isn&#39;t supported &#34; + obj.constructor.name);\n}</code></pre></div><p>就个人来说，我很期待可以随便使用结构克隆的那一天，让对象拷贝不再令人头疼。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>感谢众成翻译的daisygogogo，对这篇文章翻译的辛勤付出！</p>", 
            "topic": [
                {
                    "tag": "ECMAScript", 
                    "tagLink": "https://api.zhihu.com/topics/19600610"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51619113", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "过犹不及，别再在编程中高射炮打蚊子", 
            "content": "<p>在编程的社区中，有些现象令人感到十分困扰。（为了更好地阐述我的观点，）我将以 Vue 作为例子，这样的问题同样也存在于其他编程领域之中。</p><p>首先，我们一起来看看问题的根源。</p><p>在编写代码时，可能会遇到一些问题，自然想（前往社区）寻求帮助。此时，你会迫切地想得到问题的解决方案。然而，我对部分的问题回答者保留意见。他们鼓吹提问者<b>切换工具、类库或者整个框架</b>，而不是根据实际情况提供一个恰到好处的<b>解决方案</b>。</p><p>部分回答者不会尝试去了解你所遇问题的背景。他们会建议你去用<b>高射炮</b>，尽管你只想杀的 bug 是只<b>蚊子</b>。</p><p>这实在是答非所问！比如我在烤一个蛋糕时，问你：</p><blockquote><i><b>我正在烤一个蛋糕，烤箱应该设置多少度呢？</b></i></blockquote><p>我期待的答案是告诉我应该设置什么温度，然而回答却并非如此：</p><blockquote><i><b>别烤蛋糕了，你做过沙拉吗？</b></i></blockquote><p>在社区中类似的场景比较常见。我不是想指责什么，但这并不是一个好现象。我刚接触编程时，也经常犯这个错误。但之后我意识到这并不对。</p><p>我并不是说换一个工具就不能解决问题，我的意思是：<b>需要了解问题的需求与背景</b>。</p><p>与其建议对方<b>用自己正在用的</b>，不如在了解背景之后，<b>提供一个恰到好处的解决方案</b>。不要因为熟悉某项技术，就不断怂恿他人使用。</p><h2><b>那么，Vue 的社区有什么问题呢？</b></h2><p>在 Vue 的社区中，无论是在 Facebook、论坛还是 Discord，只要涉及到处理 state 或者 SEO 的问题，回答者经常在<b>询问提问者项目的规模</b>之前，就给出一样的回答。</p><blockquote><b>- 提问者：</b>我 Vue 的项目中碰到一点 SEO 问题 […] 我该怎么办呢？ <b>- 回答者：</b>你尝试过 nuxt 吗？</blockquote><p>这并不是好的答案？如果提问者的项目中并未使用 nuxt，回答者首先应该根据提问者的项目背景提供解决方案，而不是建议他直接去使用 nuxt。</p><p>不要误会，我喜欢 nuxt，nuxt的作者是法国人。我的观点是：nuxt 并不是在 Vue 项目中解决 SEO 的唯一方案。</p><p>迁移到 nuxt 并不是一件简单的事情，nuxt 有自己的架构，如果和现在的架构不兼容时，迁移的成本并不低。</p><p>因此，告诉提问者：“<b>用 nuxt 就好</b>”，实在不是好的解决方案。这和只建议人们使用 <b>prerender-spa-plugin</b> 或其他工具是一样的。</p><blockquote>- 提问者：有两个组件，我想让他们共享状态，我该怎么做呢？ - 回答者：用 vuex 就好。</blockquote><p>vuex 是两个组件共享状态的唯一方案吗？显然不是！</p><p>我也十分喜欢 vuex，我在项目中经常使用它，但 vuex 在小的项目中，实在是大材小用。先了解背景与需求，再去回答对应的问题！</p><p>在 Vue 中，要共享状态，<b>至少有三种不同的解决方案</b>：共享一个响应式的对象、Event Bus、Vuex。 <a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/guide/state-management.html%23Simple-State-Management-from-Scratch\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/guide/stat</span><span class=\"invisible\">e-management.html#Simple-State-Management-from-Scratch</span><span class=\"ellipsis\"></span></a></p><p><b>除非是提问者要求的</b>，不然在推荐一个新工具之前，应该先去了解问题的背景。</p><p>虽然我十分喜欢 Vue，但如果有人问我：<b>我在登录页中应该使用什么呢？</b>。我不会直接告诉他：<b>使用Vue</b>。我会先询问他，在页面中要实现什么功能。</p><p><b>以上只是冰山一角</b>。</p><p>这只是一点抱怨。我之前也经常这么做，但我觉得这只是<b>将自己喜欢的强加于对方</b>，但并没有解决<b>提问者的问题</b>。</p><p>Have a nice day~编程是一件美好的事情。</p><p><b>最后</b>：不少人在 reddit 上谈论 XY 问题。如果提问者一开始就使用了不合适的工具，那么推荐新的工具并没有任何问题。我指的<b>高射炮爱好者</b>，是那些<b>在不了解背景的情况下就直接推荐</b>的人。</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51583179", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 4, 
            "title": "Vue 2.5中将迎来有关TypeScript的优化！", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fe198c645439322c31065e502bcbfd5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic4.zhimg.com/v2-fe198c645439322c31065e502bcbfd5b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic4.zhimg.com/v2-fe198c645439322c31065e502bcbfd5b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fe198c645439322c31065e502bcbfd5b_b.jpg\"/></figure><h2><b>类型改进</b></h2><p>自Vue2.0发布以来，我们一直在收到更好集成TypeScript的请求。从那时起，我们已经为大多数核心库（<code>vue</code>，<code>vue-router</code>，<code>vuex</code>）加入了官方的TypeScript类型声明。然而，当使用开箱即用的Vue API时，目前的集成还是有所欠缺。例如：TypeScript不能轻易的推断出Vue使用的基于对象的默认API中的<code>this</code>类型。想要使我们的Vue代码与TypeScript更好的运作，我们需要使用<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue-class-component\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue-class-component</a>装饰器，它允许我们使用基于类的语法来写Vue组件。</p><p>对于喜欢基于类的API的用户，这可能就够好了，但是有点糟的是，只是为了类型判断，用户就不得不使用不同的API。这也使得将现有的Vue代码库向TypeScript迁移更具挑战。</p><p>今年的早些时候，TypeScript引入了一些<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Microsoft/TypeScript/pull/14141\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">新特性</a>，能使TypeScript更好的理解基于对象字面量的API，这也使得改进Vue的类型声明更具可能。来自TypeScript团队的<a href=\"https://link.zhihu.com/?target=https%3A//github.com/DanielRosenwasser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Daniel Rosenwasser</a>发起了一个<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/pull/5887\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">雄心勃勃的PR</a>（现在由核心团队成员<a href=\"https://link.zhihu.com/?target=https%3A//github.com/HerringtonDarkholme\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HerringtonDarkholme</a>持有），一旦通过合并，将会提供：</p><ul><li>使用默认的Vue API时对<code>this</code>的正确的类型推断。这也能在单文件组件中很好的运行！</li><li>基于组件的<code>props</code>配置的<code>this</code>的<code>props</code>的类型推断。</li><li>更重要的是，<b>这些改进也会使纯粹的JavaScript用户受益！</b>，如果你正在配合很棒的<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vetur\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vetur</a>扩展使用VSCode，在Vue组件中使用纯粹的JavaScript时，你会感受到关于自动补全提示甚至是类型提示的显著改进！ 这是因为<a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/vue-language-server\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue-language-server</a>，这个分析Vue组件的内部包，可以利用TypeScript编译器来提取关于你代码的更多信息。此外，任何支持语言服务协议的的编辑器都可以利用<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vetur/tree/master/server\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue-language-server</a>来提供类似的功能。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ecf3df2a225ab8e0c2982b831e940105_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1820\" data-rawheight=\"1113\" class=\"origin_image zh-lightbox-thumb\" width=\"1820\" data-original=\"https://pic2.zhimg.com/v2-ecf3df2a225ab8e0c2982b831e940105_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1820&#39; height=&#39;1113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1820\" data-rawheight=\"1113\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1820\" data-original=\"https://pic2.zhimg.com/v2-ecf3df2a225ab8e0c2982b831e940105_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ecf3df2a225ab8e0c2982b831e940105_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>运行中的 VSCode + Vetur + 新类型声明</p><p>感兴趣的话，就克隆<a href=\"https://link.zhihu.com/?target=https%3A//github.com/octref/veturpack/tree/new-types\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这个体验项目</a>（确保是<code>new-types</code>分支）并使用VSCode + Vetur打开它来尝试一下吧。</p><h2><b>TypeScript用户可能需要的操作</b></h2><p>类型改进将在vue 2.5中实装，目前计划在十月初前后发布。我们正在发布一个小版本，因为JavaScript公共API还没有取得突破性改变，但是，升级可能需要现有的Vue+TypeScript用户进行一些操作。这也是我们现在公布改动的原因，便于你有足够的时间来规划升级。</p><ul><li>新的类型需要至少2.4版的TypeScript。建议你随着Vue2.5升级至最新的TypeScript版本。</li><li>之前，我们建议在<code>tsconfig.json</code>中配置<code>&#34;allowSyntheticDefaultImports&#34;: true</code>来使用ES风格的导入语法（<code>import Vue from &#39;vue&#39;</code>）。新的类型将正式转换至ES风格的导入/导出语法，这样上述配置就不需要了，而且用户在所有情况下都要使用ES风格的导入。</li><li>为了配合语法的变化，下述有Vue核心类型依赖的库将会有主版本更新，需要跟随Vue2.5进行升级：<code>vuex</code>, <code>vue-router</code>, <code>vuex-router-sync</code>, <code>vue-class-component</code>。</li><li>现在，当增加自定义模块时，用户需要使用<code>interface VueConstructor</code>来代替<code>namespace Vue</code>(<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vue/pull/6391/files%23diff-1c3e3e4cf681d5fde88941717da1058aL11\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">差异对比</a>)</li><li>如果你使用<code>as ComponentOptions&lt;something&gt;</code>来注释你的组件配置，像<code>computed</code>, <code>watch</code>, <code>render</code>和生命周期钩子这种类型的需要手动进行类型注释。</li></ul><p>我们尽力去减小升级成本，并使这些类型改进与<code>vue-class-component</code>中使用的基于类的API兼容。对于绝大多数用户，只需要升级依赖关系，并切换至ES风格的导入就好。同时我们建议你在准备好升级前，将你的Vue版本锁定在<code>2.4.x</code>。</p><h2><b>蓝图：vue-cli中的TypeScript类型支持</b></h2><p>在2.5版本后，我们计划在下个vue-cli版本中去引入官方TypeScript支持，以便TS+Vue用户能轻松的启动新项目。敬请期待吧！</p><h2><b>对于非TypeScript用户</b></h2><p>这些改动不会对非TypeScript用户产生负面影响；就公共JavaScript API而言，2.5会完全向下兼容，TypeScript CLI集成也可以完全的选择性加入。但是正如刚才所提到的，如果你使用<a href=\"https://link.zhihu.com/?target=https%3A//github.com/vuejs/vetur/tree/master/server\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue-language-server</a>编辑器扩展，你会收到更好的自动补全提示。</p><p>—</p><p>感谢 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/danielrosenwasser\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Daniel Rosenwasser</a>, <a href=\"https://link.zhihu.com/?target=https%3A//github.com/HerringtonDarkholme\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HerringtonDarkholme</a>, <a href=\"https://link.zhihu.com/?target=https%3A//github.com/ktsn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Katashin</a> 与 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/octref\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pine Wu</a> 对这些特性做出的工作和对这篇文章的审核。</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": [
                {
                    "userName": "陈雪冬", 
                    "userLink": "https://www.zhihu.com/people/b047b9e7403480fa4e9937b79ed2feb2", 
                    "content": "有点迟吧……我都用半年了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51580731", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 5, 
            "title": "Hello Vue: Vue快速入门教程", 
            "content": "<p>Vue快速入门教程，此教程包括使用Kendo UI for Vue的组件。希望通过此教程能够成为你学习vue的一个很好的起点。这其中还包含一个可扩展的事例，如果你感兴趣可以深入学习下去。</p><p>本教程针对的是第一次使用Vue资源管理器。我将向您展示如何使用Vue创建一个简单的示例，然后我将添加一些交互性和UI组件，最后添加更多功能和<a href=\"https://link.zhihu.com/?target=https%3A//www.telerik.com/%2520kendo-vue-ui\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Kendo UI</a>组件。虽然本教程演示非常基础，但它概述了使用Vue添加特性和功能的所有关键元素。扩展演示代码并交换更复杂的组件非常容易。我的例子，如Vue本身，是可扩展的。</p><p>ps: 框架的名称在技术上是“Vue.js”，有些地方甚至会修改版本号以获得“Vue.js 2”，但大多数人只是在常用中使用“Vue”。本教程侧重于语言，并未涵盖更重要的Vue-cli等高级主题，但应该在以后会有介绍。</p><p>让我们开始吧!</p><h2>Hello, world!</h2><p>首先，让我们先来了解一下开始使用Vue是多么容易。我们将从流行的“<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/%2522Hello%2C_World%25EF%25BC%2581%25EF%25BC%258522_program\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hello，world</a>”应用程序的Vue实现开始。请注意，我在这里是一个纯粹主义者，我使用原始的Kernighan和Ritchie书中定义的原始拼写“<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/The_C_Programming_Language\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C编程语言</a>”。</p><p>话虽如此，我实际上不会使用“hello，world”这个文字。你以后会明白为什么。而不是一个“你好，世界”的例子，这是一个“你必须让我知道”的例子。我们走了 - 解释如下。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&#34;en&#34;&gt;\n&lt;head&gt;\n  &lt;title&gt;Clash&lt;/title&gt;\n  &lt;!-- the star of the show - the Vue library! --&gt;\n  &lt;script src=&#34;https://unpkg.com/vue/dist/vue.min.js&#34;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // when life is settled, load up the fun stuff\n    document.addEventListener(&#39;DOMContentLoaded&#39;, function () {\n      new Vue({\n        el: &#39;#sg1&#39;,\n        // define data - initial display text\n        data: {\n          m1: &#34;You got to let me know&#34;\n        }\n      })\n    })\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- text --&gt;\n  &lt;div id=&#34;sg1&#34;&gt;\n    &lt;p&gt;{{ m1 }}&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre></div><h2>我们做了什么</h2><p>首先，在文件中，我们给它标题。不是绝对必要的，但是写标题是一个不该被遗忘的好习惯。</p><p>接下来，我们从CDN加载Vue库。当你开始使用时，你可能会切换到npm（这是Vue的[推荐安装方法](<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/guide/installation.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/guide/inst</span><span class=\"invisible\">allation.html</span><span class=\"ellipsis\"></span></a>(），但CDN是最简单和最便携方式。</p><p>首先，让我们跳到文档<code>&lt;body&gt;</code>。这里，我们有一个带有属性的</p><p>`元素，id =“sg1”。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;div id=&#34;sg1&#34;&gt;\n  &lt;p&gt;{{ m1 }}&lt;/p&gt;\n&lt;/div&gt;\n\n</code></pre></div><p>Vue的核心是能够使用简单的模板语法以声明方式将数据呈现给DOM。</p><p>跳回到文档<code>&amp;lt;head&amp;gt;</code>，我们看到一些代码在通过设置事件监听器加载DOM时触发。如果你来自jQuery世界，这就像$（document）.ready（）。</p><p>接下来，我们有我们的Vue代码，这里所做的就是设置“m1”的内容：</p><div class=\"highlight\"><pre><code class=\"language-text\">new Vue({\n  el: &#39;#sg1&#39;,\n  // define data - initial display text\n  data: {\n    m1: &#34;You got to let me know&#34;\n  }\n})</code></pre></div><p>我们从这里开始使用Vue（）函数创建一个新的Vue实例。有了这个，我们传递它配置。在这里，我们只在数据部分设置m1的初始值。（稍后会详细介绍。）我们还告诉它我们想要使用哪个元素，el：&#39;＃sg1&#39;类似于document.getElementById（&#39;＃sg1&#39;）。</p><p>当我们运行它时，我们得到：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a8459bce61fa9f07878bd8d444eacb99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"172\" data-rawheight=\"50\" class=\"content_image\" width=\"172\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;172&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"172\" data-rawheight=\"50\" class=\"content_image lazy\" width=\"172\" data-actualsrc=\"https://pic2.zhimg.com/v2-a8459bce61fa9f07878bd8d444eacb99_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这很简单，但不是很有用。但是，它确实让我们了解如何设置Vue应用程序。到目前为止，它看起来并没有太大的不同。但是这里发生了一些有趣的事情，我们还没有看到。我们将探讨下一个例子中的内容。</p><h2>增加交互性</h2><p>接下来，我们将添加一个按钮：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!DOCTYPE html&gt;\n&lt;html lang=&#34;en&#34;&gt;\n&lt;head&gt;\n  &lt;title&gt;Clash&lt;/title&gt;\n  &lt;!-- the star of the show - the Vue library! --&gt;\n  &lt;script src=&#34;https://unpkg.com/vue/dist/vue.min.js&#34;&gt;&lt;/script&gt;\n  &lt;script&gt;\n    // some data we&#39;ll use\n    var action = [ &#34;Go&#34;, &#34;Stay&#34;];\n    var result = [ &#34;It will be double&#34;, &#34;There will be trouble&#34; ];\n    // when life is settled, load up the fun stuff\n    document.addEventListener(&#39;DOMContentLoaded&#39;, function () {\n      new Vue({\n        el: &#39;#sg1&#39;,\n        // define data - initial display text and set the text on the button\n        data: {\n          m1: &#34;You got to let me know&#34;,\n          btext: action[0]\n        },\n        // define the methods - alternate between the two values\n        methods: {\n          staygo: function () {\n            var sel = ( this.btext == action[0] ) ? sel = 1 : sel = 0;\n            this.m1 = result[sel];\n            this.btext = action[sel];\n          }\n        }\n      })\n    })\n  &lt;/script&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;!-- text and the button --&gt;\n  &lt;div id=&#34;sg1&#34;&gt;\n    &lt;p&gt;{{ m1 }}&lt;/p&gt;\n    &lt;p&gt;&lt;button v-on:click=&#34;staygo&#34;&gt;{{ btext }}&lt;/button&gt;&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n\n</code></pre></div><p>在标记中，我们添加了按钮。这是一个基本按钮，我们通过附加调用staygo（）的侦听器定义了一个单击事件的动作，并且我们为按钮文本设置了一个名为“btext”的占位符。</p><p>回到代码中，我们在配置中添加了一个方法属性。在其中，我们定义了staygo（）以匹配按钮中的那个。这是它变得有趣的地方。</p><div class=\"highlight\"><pre><code class=\"language-text\">methods: {\n  staygo: function () {\n    var sel = ( this.btext == action[0] ) ? sel = 1 : sel = 0;\n    this.m1 = result[sel];\n    this.btext = action[sel];\n  }\n}</code></pre></div><p>我们还在数据区域添加了文本，为按钮提供了初始标签。在该方法中，我们基本上看到按钮上的内容，然后在两行文本中的一行和两个按钮标签之一之间切换。</p><div class=\"highlight\"><pre><code class=\"language-text\">data: {\n  m1: &#34;You got to let me know&#34;,\n  btext: action[0]\n}</code></pre></div><p>这里发生的有趣的事情是我们现在已经链接了数据和DOM，我们的应用程序是被动的。当我们改变m1的值时，显示的文本被改变，当我们改变btext的值时，按钮文本被改变。没有什么需要做的了。这也发生在我们的第一个例子中，但我们没有看到，因为我们只是将文本留下了初始值。</p><p>看起来像：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-12bd137652bed09cb4ced08917a4e1e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"167\" data-rawheight=\"64\" class=\"content_image\" width=\"167\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;167&#39; height=&#39;64&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"167\" data-rawheight=\"64\" class=\"content_image lazy\" width=\"167\" data-actualsrc=\"https://pic1.zhimg.com/v2-12bd137652bed09cb4ced08917a4e1e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们看到文字“你必须告诉我”，按钮标有“go”。正如任何经典朋克的粉丝都知道的那样，如果你去“会有麻烦”并且文字改为此。同时，决定留下来，我们唯一的选择是“停留”，我们将按钮上的标签更改为“停留”。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-034998edd97010344317ab438193dca2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"153\" data-rawheight=\"66\" class=\"content_image\" width=\"153\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;153&#39; height=&#39;66&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"153\" data-rawheight=\"66\" class=\"content_image lazy\" width=\"153\" data-actualsrc=\"https://pic3.zhimg.com/v2-034998edd97010344317ab438193dca2_b.jpg\"/></figure><p>如果您现在单击“停留”，则文本将更改为“它将是双倍”。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a4579ac65f536adb3b66bafe7d52cb8a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"124\" data-rawheight=\"65\" class=\"content_image\" width=\"124\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;124&#39; height=&#39;65&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"124\" data-rawheight=\"65\" class=\"content_image lazy\" width=\"124\" data-actualsrc=\"https://pic3.zhimg.com/v2-a4579ac65f536adb3b66bafe7d52cb8a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>你可以在逗留和去之间来回点击，然后决定你是否要经常遇到麻烦或双重麻烦。</p><h2>添加Kendo UI组件</h2><p>为了简单起见，我在这里使用了一个基本的下拉组件，但如果你想添加一个网格或图表或其他更复杂的组件，那么这个过程就大致相同了。此外，它有点长，所以我将列出下面每个部分的添加内容并列出完整的代码<a href=\"https://link.zhihu.com/?target=https%3A//github.com/JohnWilloughby/HelloVue\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在GitHub上</a>。</p><p>首先，我们在标题中添加了一个部分，以引入Kendo UI样式，基本库和此组件的库：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- load Kendo UI stylesheets --&gt;\n&lt;link rel=&#34;stylesheet&#34; href=&#34;https://kendo.cdn.telerik.com/2017.3.913/styles/kendo.common.min.css&#34;/&gt;\n&lt;link rel=&#34;stylesheet&#34; href=&#34;https://kendo.cdn.telerik.com/2017.3.913/styles/kendo.default.min.css&#34;/&gt;\n&lt;!-- load Kendo UI libraries --&gt;\n&lt;script src=&#34;https://code.jquery.com/jquery-1.12.4.min.js&#34;&gt;&lt;/script&gt;\n&lt;script src=&#34;https://kendo.cdn.telerik.com/2017.3.913/js/kendo.all.min.js&#34;&gt;&lt;/script&gt;\n&lt;script src=&#34;https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.6.15/browser-polyfill.min.js&#34;&gt;&lt;/script&gt;\n&lt;!-- load Kendo UI for Vue --&gt;\n&lt;script src=&#34;https://unpkg.com/@progress/kendo-dropdowns-vue-wrapper/dist/cdn/kendo-dropdowns-vue-wrapper.min.js&#34;&gt;&lt;/script&gt;</code></pre></div><p>这包括组件的一些样式，我们依赖的一些库，以及我们将使用的实际组件的库。</p><p>我们还在<code>&amp;lt;body&amp;gt;</code>部分添加了一个<code>&lt;div&gt;</code>元素。在这里，您会看到一些新文本以及<code>&amp;lt;kendo-dropdownlist&amp;gt;</code>元素：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- second text and the DropDownList component --&gt;\n&lt;div id=&#34;sg2&#34; class=&#34;vue-app&#34;&gt;\n  &lt;p&gt;{{ m2 }}&lt;/p&gt;\n  &lt;h4&gt;Singer:&lt;/h4&gt;\n  &lt;kendo-dropdownlist :data-source=&#34;singerOptions&#34;\n                       :data-text-field=&#34;&#39;text&#39;&#34;\n                       :data-value-field=&#34;&#39;value&#39;&#34;\n                       @change=&#34;onChange&#34;&gt;\n  &lt;/kendo-dropdownlist&gt;\n&lt;/div&gt;\n\n</code></pre></div><p>在这里，您可以看到我们已经指定了实际标签的数据源（文本项数组），调用文本字段的内容，调用返回的值，最后我们告诉它如何处理具体行动。在这种情况下，它是@change，它在选择被更改时触发（不仅仅是选中，而是实际更改为其他选择）并且我们已经定义了onChange（）。您可以触发许多其他事件，还可以设置大量其他参数来控制DropDownList组件的行为。有关这方面的更多信息，请查看<a href=\"https://link.zhihu.com/?target=https%3A//www.telerik.com/kendo-vue-ui/components/dropdowns/dropdownlist/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DropDownList组件</a>的文档 。</p><p>现在，回到脚本，我们为这个新部分添加了新代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">new Vue({\n  el: &#34;#sg2&#34;,\n  // data is the lyric line and the two options for the DropDownList component\n  data: {\n    m2: problem[0],\n    singerOptions: [\n      { text: option[0], value: &#39;0&#39; },\n      { text: option[1], value: &#39;1&#39; }\n    ]\n  },\n  // and the method here just updates the text based on the singer selection\n  methods: {\n    onChange: function(e) {\n      this.m2 = problem[e.sender.value()];\n    }\n  }\n})</code></pre></div><p>我们添加了两（2）个数据项：一个用于文本，“m2”，第二个是实际由DropDownList组件使用的数组。最后，我们有一个方法，在DropDownList组件中更改选择时调用，该方法根据选择设置文本“m2”，该选择与e.sender.value（）一起传递。</p><p>我们的应用现在看起来像这样：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-be63c3a1bd86918719700d4b3fea829e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"246\" data-rawheight=\"222\" class=\"content_image\" width=\"246\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;246&#39; height=&#39;222&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"246\" data-rawheight=\"222\" class=\"content_image lazy\" width=\"246\" data-actualsrc=\"https://pic3.zhimg.com/v2-be63c3a1bd86918719700d4b3fea829e_b.jpg\"/></figure><p>我们仍然有原始的“hello，world”文本和按钮，但现在我们也看到了新的歌词和下拉列表。如果我们点击下拉菜单，我们会得到两个选择：“Mick”或“Joe and Joe”。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5acc138e02451b61efb06a700b7b4a74_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"291\" class=\"content_image\" width=\"221\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;221&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"291\" class=\"content_image lazy\" width=\"221\" data-actualsrc=\"https://pic1.zhimg.com/v2-5acc138e02451b61efb06a700b7b4a74_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果我们选择&#39;Mick&#39;，我们会看到Mick Jones演唱的英文歌词，这就是我们开始使用的歌曲。如果我们选择“Joe and Joe”，我们将获得Joe Strummer和Joe Ely演唱的西班牙语。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4869dd4ef5a6ccc8a3f1ee084f4b56c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"224\" data-rawheight=\"226\" class=\"content_image\" width=\"224\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;224&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"224\" data-rawheight=\"226\" class=\"content_image lazy\" width=\"224\" data-actualsrc=\"https://pic4.zhimg.com/v2-4869dd4ef5a6ccc8a3f1ee084f4b56c3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>下一步</h2><p>现在你已经看到了开始使用Vue是多么容易，下一步是什么？</p><p>在这个小例子之后你可以找到各种各样的方向。但是在这里你有一个实际的工作示例，交互性和所有连接的Kendo UI组件。如果您之前没有使用过Vue，那么这可以超越基本的“hello，world”示例，这些示例基于您具备所有设置和工作的基础知识。从一个复杂的例子开始，从来没有什么帮助，因为当它不起作用时你通常不知道为什么，这就是为什么“你好，世界”的例子如此受欢迎。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>感谢 众成翻译作家“_小生_”的译文，您的翻译让我们可以在8小时之外能学习更多，非常感谢！</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39659524", 
            "userName": "Tmhoney", 
            "userLink": "https://www.zhihu.com/people/f46a38226ef76941c7dde7ea44007873", 
            "upvote": 4, 
            "title": "分形实例-从分形山脉->分形地形山->分形立体山", 
            "content": "<p>  之前看过一些关于分形的资料，有一些感触，它其实是数学里面的分支，他有时候又被称为碎形，当然名字不重要，该怎么做出一种分形才重要，分形界几种常见的分形<a href=\"https://link.zhihu.com/?target=https%3A//baike.sogou.com/lemma/ShowInnerLink.htm%3FlemmaId%3D10931385\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Mandelbrot集合</a>、Julia集合、Burning Ship，数学专业的同学大佬们可以去研究研究，我对这种东西是比较反感的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8a3edc4b1919c13da87221074147076a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"268\" class=\"content_image\" width=\"268\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;268&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"268\" data-rawheight=\"268\" class=\"content_image lazy\" width=\"268\" data-actualsrc=\"https://pic3.zhimg.com/v2-8a3edc4b1919c13da87221074147076a_b.jpg\"/></figure><p>像这种分形，我看见它觉得好恶心啊，就像无数个虫子重叠在一起一样，但是不得不承认他们真的很奇妙，把他们无限放大，可以得到不同的分型集。</p><p>  今天呢，我就不再说这种分形了，因为我喜欢玩一玩吃鸡，我看到吃鸡里面的沙漠地图和一篇博客里面电脑模拟出来的分形山很像，所以自己兴趣也来了，也打算做一个。</p><h2><b><i>分形山脉</i></b></h2><p>  首先呢，我是从最基础的山脉做的，我们可以想象一个简单直线，取其中点进行分形。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0ae7bd51f947e080214874d5bf02732b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"122\" class=\"content_image\" width=\"392\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;392&#39; height=&#39;122&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"122\" class=\"content_image lazy\" width=\"392\" data-actualsrc=\"https://pic4.zhimg.com/v2-0ae7bd51f947e080214874d5bf02732b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7a7012f2d539803cc264baefd8b77958_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"406\" data-rawheight=\"204\" class=\"content_image\" width=\"406\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;406&#39; height=&#39;204&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"406\" data-rawheight=\"204\" class=\"content_image lazy\" width=\"406\" data-actualsrc=\"https://pic1.zhimg.com/v2-7a7012f2d539803cc264baefd8b77958_b.jpg\"/></figure><p>取两个点的中点，可以认为他的x值已经确定，但是y值可以适当的提升或者降低，而这个值是某个范围内的随机值，以便体现山脉的不规则性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a5b53746f929280b8fcf17919f045bf0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"159\" class=\"content_image\" width=\"397\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;397&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"159\" class=\"content_image lazy\" width=\"397\" data-actualsrc=\"https://pic1.zhimg.com/v2-a5b53746f929280b8fcf17919f045bf0_b.jpg\"/></figure><p>把两个点不断地取中点，不断地分配y值，这个过程实际就是一个递归的过程了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a7f804397895dcda10bc6ef4153e1ac4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb\" width=\"846\" data-original=\"https://pic1.zhimg.com/v2-a7f804397895dcda10bc6ef4153e1ac4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;846&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"846\" data-original=\"https://pic1.zhimg.com/v2-a7f804397895dcda10bc6ef4153e1ac4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a7f804397895dcda10bc6ef4153e1ac4_b.jpg\"/></figure><p>代码如上，这是对最初的两个点进行分形递归的过程，xishu是y值改变的幅度系数，yyi是y值改变的幅度大小，这个幅度可以根据自己认为的情况随意设置，并不一定要按我的来模拟。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3c126a7ada35a8638eb93450f70d5e27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb\" width=\"779\" data-original=\"https://pic4.zhimg.com/v2-3c126a7ada35a8638eb93450f70d5e27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;779&#39; height=&#39;334&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"779\" data-original=\"https://pic4.zhimg.com/v2-3c126a7ada35a8638eb93450f70d5e27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3c126a7ada35a8638eb93450f70d5e27_b.jpg\"/></figure><p>这是分形后的样子，当然分形次数越多，就越明显啦。简单的山脉就这样完成了。</p><h2><b><i>分形地形山</i></b></h2><p>分型地形山，这个就比较复杂了。之前的分形山脉是一条直线，这次我们一次性分形三条直线，也就是说一次分形一个三角形，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7415a5edf4c750844b3ce9a8c737972b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"286\" class=\"content_image\" width=\"401\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;401&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"286\" class=\"content_image lazy\" width=\"401\" data-actualsrc=\"https://pic4.zhimg.com/v2-7415a5edf4c750844b3ce9a8c737972b_b.jpg\"/></figure><p>就像这样，然后把三个中点连起来，原来的边去掉，就变成了四个三角形</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10a6fae73fb0e1fb64117b1b6a321659_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"292\" class=\"content_image\" width=\"420\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;420&#39; height=&#39;292&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"292\" class=\"content_image lazy\" width=\"420\" data-actualsrc=\"https://pic2.zhimg.com/v2-10a6fae73fb0e1fb64117b1b6a321659_b.jpg\"/></figure><p>和直线分形一样，也是一个递归的过程，只不过是对三角形分形了，而且你三条边的幅度和之前一样可以随便分配，然后对四个三角形分形，这时候就会面临一个问题</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dcc369021eea96bbe3ac95eaff30f0ca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-dcc369021eea96bbe3ac95eaff30f0ca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;465&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-dcc369021eea96bbe3ac95eaff30f0ca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-dcc369021eea96bbe3ac95eaff30f0ca_b.jpg\"/></figure><p>如果分别对AED，BEF，CDF分形可以知道，DE，DF，EF可以分别产生一个新的中点，</p><p><i><b>小问题：</b></i></p><p>这样如果再对EDF进行分形，就会造成矛盾，当你进行多次分型后，就会产生大量的空白，我就曾经遇到过这样的问题，分形一两次没多大感觉，三次也还过得去，当到了六七次，就是大量的空白了，一点也看不出来是地形山。这时候我们需要创建一个标志，即表示两个点之间是否已经取过了中点，对于取过的中点，没必要重复取了，以免造成没必要的麻烦。这个标志是两个状态了，0或者1，或者其他标志随便设。我把每个带分形的点称作父母，分型得到的点成为儿子，我是针对每个父母点都创建了一个儿子集，在不断分形的过程中一个点会不断地遇到其他点，生出一个儿子，当然这只是一个比喻，现实生活中不存在的，每当对两个点进行分形时，查找这两个点的儿子集，看有没有交配结果，如果有过了，就像计划生育一样，不准这两个点之间产子了。这样就避免了两点之间重复取中点的过程。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void mountains(Point A,Point B,Point C,int count,int range,int t){\n\t\tif (count&lt;=6){\n\t\t\t//找出ABC的儿子是否相同\n\t\t\tint mab=0; int nab=0; int kab=0;\n\t\t\twhile (A.son[mab].x!=0&amp;&amp;kab!=1){\n\t\t\t\tnab=0;\n\t\t\t\twhile(B.son[nab].x!=0){\n\t\t\t\t\tif ((A.son[mab].x==B.son[nab].x)&amp;&amp;(A.son[mab].y==B.son[nab].y)){ kab=1; break;}\t\n\t\t\t\t\tnab++;\n\t\t\t\t}\n\t\t\t\tif(kab==1){break;}\n\t\t\t\tmab++;\n\t\t\t}\n\t\t\tint mac=0; int nac=0; int kac=0;\n\t\t\twhile (A.son[mac].x!=0&amp;&amp;kac!=1){\n\t\t\t\tnac=0;\n\t\t\t\twhile(C.son[nac].x!=0){\n\t\t\t\t\tif ((A.son[mac].x==C.son[nac].x)&amp;&amp;(A.son[mac].y==C.son[nac].y)){ kac=1; break;}\t\n\t\t\t\t\tnac++;\n\t\t\t\t}\n\t\t\t\tif (kac==1){break;}\n\t\t\t\tmac++;\n\t\t\t}\n\t\t\tint mbc=0; int nbc=0; int kbc=0;\n\t\t\twhile (B.son[mbc].x!=0&amp;&amp;kbc!=1){\n\t\t\t\tnbc=0;\n\t\t\t\twhile(C.son[nbc].x!=0){\n\t\t\t\t\tif ((B.son[mbc].x==C.son[nbc].x)&amp;&amp;(B.son[mbc].y==C.son[nbc].y)){ kbc=1; break;}\t\n\t\t\t\t\tnbc++;\n\t\t\t\t}\n\t\t\t\tif (kbc==1){break;}\n\t\t\t\tmbc++;\n\t\t\t}\n\t\t\t\n\t\t\tRandom nns=new Random();\n\t\t\t\n\t\t\t//A，B中点\n\t\t\tif(kab==0){\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=(A.x+B.x)/2;\n\t\t\t\tno.node[count][no.c[count]].y=(A.y+B.y)/2-range/t+nns.nextInt(range);\n\t\t\t\t//记录儿子的坐标\n\t\t\t\tint sa=0; int sb=0;\n\t\t\t\twhile (A.son[sa].x!=0) {sa++;}\n\t\t\t\twhile (B.son[sb].x!=0) {sb++;}\n\t\t\t\tA.son[sa].x=no.node[count][no.c[count]].x;\n\t\t\t\tA.son[sa].y=no.node[count][no.c[count]].y;\n\t\t\t\tB.son[sb].x=no.node[count][no.c[count]].x;\n\t\t\t\tB.son[sb].y=no.node[count][no.c[count]].y;\n\t\t\t}else{\n\t\t\t\t//两点之间已经有儿子。不用再记录儿子\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=A.son[mab].x;\n\t\t\t\tno.node[count][no.c[count]].y=A.son[mab].y;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(kbc==0){\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=(B.x+C.x)/2;\n\t\t\t\tno.node[count][no.c[count]].y=(B.y+C.y)/2-range/t+nns.nextInt(range);\n\t\t\t\t//记录儿子\n\t\t\t\tint sb=0; int sc=0;\n\t\t\t\twhile (B.son[sb].x!=0) {sb++;}\n\t\t\t\twhile (C.son[sc].x!=0) {sc++;}\n\t\t\t\tB.son[sb].x=no.node[count][no.c[count]].x;\n\t\t\t\tB.son[sb].y=no.node[count][no.c[count]].y;\n\t\t\t\tC.son[sc].x=no.node[count][no.c[count]].x;\n\t\t\t\tC.son[sc].y=no.node[count][no.c[count]].y;\n\t\t\t}else{\n\t\t\t\t//两点之间已经有儿子。不用再记录儿子\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=B.son[mbc].x;\n\t\t\t\tno.node[count][no.c[count]].y=B.son[mbc].y;\n\t\t\t}\n\t\t\t\n\t\t\tif(kac==0){\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=(A.x+C.x)/2;\n                                no.node[count][no.c[count]].y=(A.y+C.y)/2-range/t+nns.nextInt(range);\n\t\t\t\t//记录儿子\n\t\t\t\tint sa=0; int sc=0;\n\t\t\t\twhile (A.son[sa].x!=0) {sa++;}\n\t\t\t\twhile (C.son[sc].x!=0) {sc++;}\n\t\t\t\tA.son[sa].x=no.node[count][no.c[count]].x;\n\t\t\t\tA.son[sa].y=no.node[count][no.c[count]].y;\n\t\t\t\tC.son[sc].x=no.node[count][no.c[count]].x;\n\t\t\t\tC.son[sc].y=no.node[count][no.c[count]].y;\n\t\t\t}else{\n\t\t\t\t//两点之间已经有儿子。不用再记录儿子\n\t\t\t\tno.c[count]++;\n\t\t\t\tno.node[count][no.c[count]].x=A.son[mac].x;\n\t\t\t\tno.node[count][no.c[count]].y=A.son[mac].y;\n\t\t\t}\n\t\t\tSystem.out.println(&#34;(&#34;+count+&#34;,&#34;+(no.c[count]-2)+&#34;)=&#34;+no.node[count][no.c[count]-2].x+&#34; &#34;+no.node[count][no.c[count]-2].y);\n\t\t\tSystem.out.println(&#34;(&#34;+count+&#34;,&#34;+(no.c[count]-1)+&#34;)=&#34;+no.node[count][no.c[count]-1].x+&#34; &#34;+no.node[count][no.c[count]-1].y);\n\t\t\tSystem.out.println(&#34;(&#34;+count+&#34;,&#34;+no.c[count]+&#34;)=&#34;+no.node[count][no.c[count]].x+&#34; &#34;+no.node[count][no.c[count]].y);\n\t\t\t\n\t\t\tmountains(A,no.node[count][no.c[count]-2],no.node[count][no.c[count]],count+1,range/t,t);\n\t\t\tmountains(B,no.node[count][no.c[count]-2],no.node[count][no.c[count]-1],count+1,range/t,t);\n\t\t\tmountains(C,no.node[count][no.c[count]-1],no.node[count][no.c[count]],count+1,range/t,t);\n\t\t\tmountains(no.node[count][no.c[count]-2],no.node[count][no.c[count]-1],no.node[count][no.c[count]],count+1,range/t,t);\n\t\t}else {\n\t\t\tg.drawLine(A.x,A.y,B.x,B.y);\n\t\t\tg.drawLine(A.x,A.y,C.x,C.y);\n\t\t\tg.drawLine(B.x,B.y,C.x,C.y);\n\t\t}\n\t\t\n\t\t\n\t}</code></pre></div><p>这是我写的主要代码，但是针对重复取中点的问题，我认为还有其他的方法，大佬们可以想一想其他的方法，或看一看博客。这里推荐两篇博客：</p><a href=\"https://link.zhihu.com/?target=http%3A//blog.sina.com.cn/s/blog_4f2803a50101i721.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">分形的基本原理_独孤剑_新浪博客</a><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/fjsjxy1111/p/5933216.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-ac09dc715bda51dcb444bf16feff3c32_180x120.jpg\" data-image-width=\"789\" data-image-height=\"138\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">分形应用：造山 - 莫小江 - 博客园</a><p>这两篇是我获得启发，大佬们可以自己去看一看。</p><p>对了还有分形地形山的效果图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b705227ca37514d1ed0b37016cef988b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"325\" class=\"content_image\" width=\"287\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;287&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"325\" class=\"content_image lazy\" width=\"287\" data-actualsrc=\"https://pic4.zhimg.com/v2-b705227ca37514d1ed0b37016cef988b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fc1b0b50ba6296487640a61ccfecbc6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"348\" data-rawheight=\"420\" class=\"content_image\" width=\"348\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;348&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"348\" data-rawheight=\"420\" class=\"content_image lazy\" width=\"348\" data-actualsrc=\"https://pic3.zhimg.com/v2-fc1b0b50ba6296487640a61ccfecbc6e_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-56e871e53643ac9a61624c91a7908296_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"319\" data-rawheight=\"452\" class=\"content_image\" width=\"319\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;319&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"319\" data-rawheight=\"452\" class=\"content_image lazy\" width=\"319\" data-actualsrc=\"https://pic3.zhimg.com/v2-56e871e53643ac9a61624c91a7908296_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f7ee10fb71c861223a89c979f2cc2406_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"329\" class=\"content_image\" width=\"242\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;242&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"242\" data-rawheight=\"329\" class=\"content_image lazy\" width=\"242\" data-actualsrc=\"https://pic3.zhimg.com/v2-f7ee10fb71c861223a89c979f2cc2406_b.jpg\"/></figure><h2><b><i>分形立体山</i></b></h2><p>分形立体山我是看过莫小江学姐后的博客收到的启发，当然，我和她的思路不一样，所以只能从我的基础上往他的方法靠。之前我已经基本把分形地形山给画出来了，由于我电脑的原因，我的分形地形山，只能分形几次，效果不是很明显。接下来，就是把地形山抬高了，形成立体山。这个我做了很多次研究，也尝试了好几次不同的代码，但是效果都不明显。看过几篇博客后，我的想法变成了两种，一种是之前分形的分形地形山，从视觉上看出是一种山的曲面，也就是说是山的一面。第二种是完全建立一种三维的立体坐标系，之前的x，y值完全是在一个平面上，采用斜二测画法可以将我们所想要的立体山就可以画出来。但是分形次数要足够多，效果才明显。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4646ed0f81eaecd5edf349586460a3cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-4646ed0f81eaecd5edf349586460a3cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;342&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-4646ed0f81eaecd5edf349586460a3cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4646ed0f81eaecd5edf349586460a3cf_b.jpg\"/></figure><p>实际上在做地形分形时，每个点都对应着三维坐标上的一点，即我们根据视觉上的看到的，是一个三维不规则的分形曲面，它是立体山的分形一面，当然如果想做的更真实，可以用Unity3D去做，那个比较专业化吧，更容易操作。</p><p>我根据自己的想法，设了一个最大陡峭值range，和一个陡峭系数t，没分形一次，陡峭系数就减到range/t，当然不应定是这个数值，可以增加到多少也可以减少到多少，说白了，你要把它看成立体的，无非就是y值得上下抖动，你可以越往中间越高，体现出山峰的感觉，在坐标系上就是y值越低。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a7d41b98b7e518321fe7675124b1c8c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"446\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb\" width=\"446\" data-original=\"https://pic1.zhimg.com/v2-a7d41b98b7e518321fe7675124b1c8c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;446&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"446\" data-rawheight=\"291\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"446\" data-original=\"https://pic1.zhimg.com/v2-a7d41b98b7e518321fe7675124b1c8c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a7d41b98b7e518321fe7675124b1c8c8_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-128507a7ccdcdf5683b49bcd0c7a9a7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"462\" class=\"content_image\" width=\"392\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;392&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"392\" data-rawheight=\"462\" class=\"content_image lazy\" width=\"392\" data-actualsrc=\"https://pic4.zhimg.com/v2-128507a7ccdcdf5683b49bcd0c7a9a7b_b.jpg\"/></figure><p>大家也可以参考其他博客的方法进行试验，总之分形次数越多效果越明显，时间也花费的越长，我的电脑只能分形7次，系统就满足不了我要存储的数据了，主要是分形时儿子集那个东西没有管理好，造成了资源的大量使用，以致栈空间满了，所以大家可以尝试其他的方法来进行试验。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-825a6649feb7c34a9e3d9475ba64b8e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"789\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"789\" data-original=\"https://pic1.zhimg.com/v2-825a6649feb7c34a9e3d9475ba64b8e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;789&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"789\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"789\" data-original=\"https://pic1.zhimg.com/v2-825a6649feb7c34a9e3d9475ba64b8e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-825a6649feb7c34a9e3d9475ba64b8e0_b.jpg\"/></figure><p>这是一张经典的图片，一直到最后一张，效果是非常的逼真了。</p><p>还有一个问题就是颜色填充的问题，我个人觉得如果分形次数足够多了就没必要加颜色，因为到了后面就有很多的线条重复在一起，显得已经填充过一样了。不过，对于初级的分形，还是可以可以填充一下的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8581aaaa04cde00b0fed04e0a8bd42be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"602\" data-original=\"https://pic3.zhimg.com/v2-8581aaaa04cde00b0fed04e0a8bd42be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;602&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"602\" data-original=\"https://pic3.zhimg.com/v2-8581aaaa04cde00b0fed04e0a8bd42be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8581aaaa04cde00b0fed04e0a8bd42be_b.jpg\"/></figure><p>这是填充后的一张简图，我个人觉得效果不是很好。说到这里，有的人会问API里面有颜色填充的可以填矩形，圆之类的，对于三角形，似乎没有这样的方法，在这里，我就简单介绍一下那个填充多边形的方法fillPolygon，这个方法是将多边形的坐标集合写出来以及有几个这样的坐标点个数。</p><div class=\"highlight\"><pre><code class=\"language-text\">                        int px[]={A.x,B.x,C.x,A.x};\n\t\t\tint py[]={A.y,B.y,C.y,A.y};\n\t\t\tint rgb=(A.y+B.y+C.y)/9;                  \n\t\t\tcolor=new Color(80,80,80);\n\t\t\tg.setColor(color);\n\t\t\tg.fillPolygon(px,py, 4);\n\t\t\tg.drawLine(A.x,A.y,B.x,B.y);\n\t\t\tg.drawLine(A.x,A.y,C.x,C.y);\n\t\t\tg.drawLine(B.x,B.y,C.x,C.y);</code></pre></div><p>这是画一个三角形并填充，px和py集合要重复是因为你要首尾相结合，才能闭合起来。</p><p>这就是我简单的从分形山脉到分形地形山到立体山，往后一段时间我会用其他的方法画出更好的立体山，到时候与大家分享一下，如果我有什么不足谢谢大家指点，大家有什么观点也可以和我分享分享。</p>", 
            "topic": [
                {
                    "tag": "自然科学", 
                    "tagLink": "https://api.zhihu.com/topics/19553298"
                }, 
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "分形理论", 
                    "tagLink": "https://api.zhihu.com/topics/19610593"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42818634", 
            "userName": "SevenLin澤耿", 
            "userLink": "https://www.zhihu.com/people/668202aff2aebf102bcc86b2b076c815", 
            "upvote": 5, 
            "title": "使用Bean Validation实现数据校验", 
            "content": "<h2><b>Bean Validation</b></h2><h2><b>简介</b></h2><p>Bean Validation是Java定义的一套基于注解的数据校验规范，目前已经从JSR 303的1.0版本升级到JSR 349的1.1版本，再到JSR 380的2.0版本（2.0完成于2017.08），已经经历了三个版本</p><p>&#34;数据校验&#34;是这个比较常见的工作，在日常的开发中贯穿于代码的各个层次，从上层的View层到下底层的数据层，为了保证程序的正确运行以及数据的正确性，开发者通常会在不同层次间做数据校验而且这些校验通常是重复的，为了实现代码的复用性，通常会把校验的逻辑写在被校验对象上。</p><p>Bean Validation就是为了解决这样的问题，它定义了一套元数据模型和API对JavaBean实现校验，默认是以注解作为元数据，可以通过XML重写或者拓展元数据，通常来说注解的方式可以实现比较简单逻辑的校验，而复杂校验就需要通过XML来描述。可以说Bean Validation是JavaBean的一个拓展，也就是说它布局于哪一层的代码，不局限于Web应用还是端应用。</p><h2><b>Bean Validation 2.0 关注点</b></h2><ul><li>使用Bean Validation的最低Java版本为Java 8</li><li>支持容器的校验，通过<code>TYPE_USE</code>类型的注解实现对容器内容的约束：<code>List&lt;@Email String&gt;</code></li><li>支持日期/时间的校验，@Past和@Future</li><li>拓展元素数据：@Email，@NotEmpty，@NotBlank，@Positive， @PositiveOrZero，@Negative，@NegativeOrZero，@PastOrPresent和@FutureOrPresent</li></ul><h2><b>Bean Validation的实现</b></h2><p>Bean Validation在2.0之前有两个官方认可的实现：<code>Hibernate Validator</code>和<code>Apache BVal</code>，但如果你想用2.0版本的话，基本上只有<code>Hibernate Validator</code>，而这里我使用的是<code>Hibernate Validator</code>，其他实现不做展开。</p><h2><b>使用</b></h2><h2><b>安装依赖</b></h2><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"c\">&lt;!--版本自行控制，这里只是简单举例--&gt;</span>\n<span class=\"nt\">&lt;dependency&gt;</span>\n    <span class=\"nt\">&lt;groupId&gt;</span>javax.validation<span class=\"nt\">&lt;/groupId&gt;</span>\n    <span class=\"nt\">&lt;artifactId&gt;</span>validation-api<span class=\"nt\">&lt;/artifactId&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>2.0.0.Final<span class=\"nt\">&lt;/version&gt;</span>\n<span class=\"nt\">&lt;/dependency&gt;</span>\n<span class=\"nt\">&lt;dependency&gt;</span>\n    <span class=\"nt\">&lt;groupId&gt;</span>org.hibernate<span class=\"nt\">&lt;/groupId&gt;</span>\n    <span class=\"nt\">&lt;artifactId&gt;</span>hibernate-validator<span class=\"nt\">&lt;/artifactId&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>6.0.1.Final<span class=\"nt\">&lt;/version&gt;</span>\n<span class=\"nt\">&lt;/dependency&gt;</span>\n<span class=\"nt\">&lt;dependency&gt;</span>\n    <span class=\"nt\">&lt;groupId&gt;</span>org.glassfish<span class=\"nt\">&lt;/groupId&gt;</span>\n    <span class=\"nt\">&lt;artifactId&gt;</span>javax.el<span class=\"nt\">&lt;/artifactId&gt;</span>\n    <span class=\"nt\">&lt;version&gt;</span>3.0.1-b09<span class=\"nt\">&lt;/version&gt;</span>\n<span class=\"nt\">&lt;/dependency&gt;</span></code></pre></div><h2><b>Demo-直接使用</b></h2><ul><li>一个简单的JavaBean</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">User</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">String</span> <span class=\"n\">gender</span><span class=\"o\">;</span>\n    <span class=\"nd\">@Positive</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">age</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"nd\">@Email</span> <span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">emails</span><span class=\"o\">;</span>\n<span class=\"err\">​</span>\n    <span class=\"c1\">// getter and setter \n</span><span class=\"c1\"></span>    <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><ul><li>使用Validator校验</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">User</span> <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">User</span><span class=\"o\">();</span>\n<span class=\"err\">​</span>\n<span class=\"n\">user</span><span class=\"o\">.</span><span class=\"na\">setName</span><span class=\"o\">(</span><span class=\"s\">&#34;seven&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">user</span><span class=\"o\">.</span><span class=\"na\">setGender</span><span class=\"o\">(</span><span class=\"s\">&#34;man&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">user</span><span class=\"o\">.</span><span class=\"na\">setAge</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"n\">user</span><span class=\"o\">.</span><span class=\"na\">setEmails</span><span class=\"o\">(</span><span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">asList</span><span class=\"o\">(</span><span class=\"s\">&#34;sevenlin@gmail.com&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;sevenlin.com&#34;</span><span class=\"o\">));</span>\n<span class=\"err\">​</span>\n<span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">ConstraintViolation</span><span class=\"o\">&lt;</span><span class=\"n\">User</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">Validation</span><span class=\"o\">.</span><span class=\"na\">buildDefaultValidatorFactory</span><span class=\"o\">().</span><span class=\"na\">getValidator</span><span class=\"o\">().</span><span class=\"na\">validate</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">);</span>\n<span class=\"err\">​</span>\n<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span> <span class=\"n\">message</span>\n    <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"o\">.</span><span class=\"na\">stream</span><span class=\"o\">().</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">-&gt;</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"na\">getPropertyPath</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"na\">getMessage</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"s\">&#34;: &#34;</span> <span class=\"o\">+</span> <span class=\"n\">v</span><span class=\"o\">.</span><span class=\"na\">getInvalidValue</span><span class=\"o\">())</span>\n        <span class=\"o\">.</span><span class=\"na\">collect</span><span class=\"o\">(</span><span class=\"n\">Collectors</span><span class=\"o\">.</span><span class=\"na\">toList</span><span class=\"o\">());</span>\n<span class=\"err\">​</span>\n<span class=\"n\">message</span><span class=\"o\">.</span><span class=\"na\">forEach</span><span class=\"o\">(</span><span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">::</span><span class=\"n\">println</span><span class=\"o\">);</span></code></pre></div><ul><li>校验结果</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">emails[1].&lt;list element&gt; must be a well-formed email address: sevenlin.com\nage must be greater than 0: -1</code></pre></div><h2><b>集成到Spring MVC</b></h2><ul><li>配置</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Configuration</span>\n<span class=\"nd\">@EnableWebMvc</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">WebConfig</span> <span class=\"kd\">implements</span> <span class=\"n\">WebMvcConfigurer</span> <span class=\"o\">{</span>\n<span class=\"err\">​</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Validator</span> <span class=\"nf\">getValidator</span><span class=\"o\">();</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>注意，使用Spring MVC 的时候，Spring会默认注册从<code>classpath</code>下找到的可用Bean Validation，所以如果不需要自定义Validation</p><ul><li>在Controller中校验请求参数 使用注解<code>@Valid</code>和<code>@Validated</code>实现对请求参数的校验</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@PostMapping</span><span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"s\">&#34;/create&#34;</span><span class=\"o\">)</span>\n<span class=\"nd\">@ResponseBody</span>\n<span class=\"kd\">public</span> <span class=\"n\">ResponseEntity</span><span class=\"o\">&lt;</span><span class=\"n\">User</span><span class=\"o\">&gt;</span> <span class=\"nf\">create</span><span class=\"o\">(</span><span class=\"nd\">@RequestBody</span> <span class=\"nd\">@Validated</span> <span class=\"n\">UserForm</span> <span class=\"n\">form</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">User</span> <span class=\"n\">user</span> <span class=\"o\">=</span> <span class=\"n\">userService</span><span class=\"o\">.</span><span class=\"na\">create</span><span class=\"o\">(</span><span class=\"n\">form</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">ResponseEntity</span><span class=\"o\">.</span><span class=\"na\">ok</span><span class=\"o\">().</span><span class=\"na\">body</span><span class=\"o\">(</span><span class=\"n\">user</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>配置统一校验结果处理</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@ControllerAdvice</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ValidationResponseAdvice</span> <span class=\"kd\">extends</span> <span class=\"n\">ResponseEntityExceptionHandler</span> <span class=\"o\">{</span>\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">ResponseEntity</span><span class=\"o\">&lt;</span><span class=\"n\">Object</span><span class=\"o\">&gt;</span> <span class=\"nf\">handleMethodArgumentNotValid</span><span class=\"o\">(</span><span class=\"n\">MethodArgumentNotValidException</span> <span class=\"n\">ex</span><span class=\"o\">,</span> <span class=\"n\">HttpHeaders</span> <span class=\"n\">headers</span><span class=\"o\">,</span> <span class=\"n\">HttpStatus</span> <span class=\"n\">status</span><span class=\"o\">,</span> <span class=\"n\">WebRequest</span> <span class=\"n\">request</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">String</span> <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">ex</span><span class=\"o\">.</span><span class=\"na\">getBindingResult</span><span class=\"o\">().</span><span class=\"na\">getAllErrors</span><span class=\"o\">().</span><span class=\"na\">stream</span><span class=\"o\">().</span><span class=\"na\">map</span><span class=\"o\">(</span><span class=\"nl\">DefaultMessageSourceResolvable:</span><span class=\"o\">:</span><span class=\"n\">getDefaultMessage</span><span class=\"o\">)</span>\n                <span class=\"o\">.</span><span class=\"na\">collect</span><span class=\"o\">(</span><span class=\"n\">Collectors</span><span class=\"o\">.</span><span class=\"na\">joining</span><span class=\"o\">(</span><span class=\"s\">&#34;,&#34;</span><span class=\"o\">));</span>\n        <span class=\"k\">return</span> <span class=\"n\">ResponseEntity</span><span class=\"o\">.</span><span class=\"na\">badRequest</span><span class=\"o\">().</span><span class=\"na\">body</span><span class=\"o\">(</span><span class=\"n\">message</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2><b>常见的元数据</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-754d8a8b3603488efc7ea2600914f18c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"1416\" class=\"origin_image zh-lightbox-thumb\" width=\"1060\" data-original=\"https://pic1.zhimg.com/v2-754d8a8b3603488efc7ea2600914f18c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1060&#39; height=&#39;1416&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1060\" data-rawheight=\"1416\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1060\" data-original=\"https://pic1.zhimg.com/v2-754d8a8b3603488efc7ea2600914f18c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-754d8a8b3603488efc7ea2600914f18c_b.jpg\"/></figure><h2><b>其他</b></h2><h2><b>相关链接</b></h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//jcp.org/en/jsr/detail%3Fid%3D303\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSR 303: Bean Validation 1.0</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//jcp.org/en/jsr/detail%3Fid%3D349\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSR </a>349<a href=\"https://link.zhihu.com/?target=https%3A//jcp.org/en/jsr/detail%3Fid%3D349\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">: Bean Validation 1.1</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//jcp.org/en/jsr/detail%3Fid%3D380\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSR 380: Bean Validation 2.0</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//beanvalidation.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Bean Validation</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//docs.spring.io/spring/docs/current/spring-framework-reference/web.html%23mvc-config-validation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spring MVC</a></li></ul><h2><b>参考</b></h2><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.springboottutorial.com/spring-boot-validation-for-rest-services\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Implementing Validation for RESTful Services with Spring Boot</a> </li></ul><h2><b>原文</b></h2><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/2a495bf5504e\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">使用Bean Validation实现数据校验</a><p></p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "奇诺城堡", 
                    "userLink": "https://www.zhihu.com/people/4b7086f5fe88e6de843ead6d3f62deb9", 
                    "content": "<p>勘误：JSR 380: Bean Validation 1.1 =》JSR 349: Bean Validation 1.1</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "SevenLin澤耿", 
                            "userLink": "https://www.zhihu.com/people/668202aff2aebf102bcc86b2b076c815", 
                            "content": "<p>多谢，已经修改</p>", 
                            "likes": 0, 
                            "replyToAuthor": "奇诺城堡"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42789346", 
            "userName": "X-猪", 
            "userLink": "https://www.zhihu.com/people/21bbead3d41b756dd550cefa992463fc", 
            "upvote": 1, 
            "title": "设计模式深入理解", 
            "content": "<h2>设计模式</h2><p>本文讨论了一些常用的设计模式，重点分析各种模式适用的场景，以及需要注意的地方，<b>理解各种模式的本质</b>含义。 关于各种设计模式的全面介绍文章有很多，本文侧重于分析理解，省略了对各种模式的基本内容的详细介绍。文末有一些参考资料，可以与本文结合起来阅读。</p><h2>1. 单实例（Singleton）</h2><p>单实例是最容易使用，也最常用的设计模式，可谓价格便宜量又足。</p><p>面向对象程序设计，就像规划一个公司，有生产部、研发部、设计部、销售部、财务部等等，每个部门有特定的职责，并且互相协作来完成工作。每次需要其他部门配合时，都需要找到合作部门的接口人。</p><p>从程序设计的角度看，就是每个部门是一个实例化的对象，比如财务部m，所有需要与财务部协作的其它部门（其它对象实例a、b、c等等），都需要保存对财务部实例m的引用（知道对方的接口人是谁）。</p><p>进一步考虑到公司刚创建时，各部门还不一定有构造好（程序启动时就像从零开始创建一个公司，各部门是逐个创建出来的），那么当a想要访问m时，还需要考虑m是否已经就绪，这又额外增加了一些设计上的麻烦。</p><p>单实例模式可以简单明了的解决上述问题。它相当于一个全局的智能构造访问器，当a部门需要找m部门时，如果m部门已经创建好了，就直接把m的地址告诉a，如果m还没有创建好，就创建一个m，然后把这个m的地址告诉a。这样，a既不需要保存m的地址，也不需要关心m是否已经事先创建好。</p><p>单实例的实现方法很简单，不过有一个需要注意的问题，就是<b>多线程访问单实例需要注意线程并发问题</b>，多线程情况下不小心的话可能导致创建出多个实例。保障线程安全的单实例写法建议如下：</p><ol><li>Java5以及之后的版本可以用enum来实现。该方案线程安全，并且是懒加载（Lazy loading）。</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">public enum SingletonEnum {\n    INSTANCE;\n    private int someField;\n    public void doSomething() {\n        // ...\n    }\n}\n\npublic class EnumDemo {\n    public static void main(String[] args) {\n        SingletonEnum singleton = SingletonEnum.INSTANCE;\n        singleton.doSomething();\n    }\n}</code></pre></div><ol><li>采用static实例。同样线程安全，是早加载（Early loading）。</li></ol><div class=\"highlight\"><pre><code class=\"language-text\">public class Foo {\n    private static final Foo INSTANCE = new Foo();\n\n    private Foo() {\n        if (INSTANCE != null) {\n            throw new IllegalStateException(&#34;Already instantiated&#34;);\n        }\n    }\n\n    public static Foo getInstance() {\n        return INSTANCE;\n    }\n}</code></pre></div><p>关于单实例的实现方案的更多分析讨论，参考： <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/70689/what-is-an-efficient-way-to-implement-a-singleton-pattern-in-java%3Fnoredirect%3D1%26lq%3D1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What is an efficient way to implement a singleton pattern in Java?</a></p><h2>2. 工厂（Factory）</h2><p>工厂模式，根据复杂程度的不同，可以有 <b>简单工厂、工厂方法、抽象工厂</b>。</p><ul><li><b>类图</b>（来自 <a href=\"https://link.zhihu.com/?target=https%3A//design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图说设计模式</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9a894593ed680b75f4117b482ef5dd91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb\" width=\"675\" data-original=\"https://pic2.zhimg.com/v2-9a894593ed680b75f4117b482ef5dd91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;675&#39; height=&#39;422&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"675\" data-original=\"https://pic2.zhimg.com/v2-9a894593ed680b75f4117b482ef5dd91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9a894593ed680b75f4117b482ef5dd91_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-492eac1a89f62411a66fb8f5eb7ed1c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"598\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"598\" data-original=\"https://pic1.zhimg.com/v2-492eac1a89f62411a66fb8f5eb7ed1c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;598&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"598\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"598\" data-original=\"https://pic1.zhimg.com/v2-492eac1a89f62411a66fb8f5eb7ed1c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-492eac1a89f62411a66fb8f5eb7ed1c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-16ac926d48bff6f5f77e3517b42312e5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"835\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb\" width=\"835\" data-original=\"https://pic2.zhimg.com/v2-16ac926d48bff6f5f77e3517b42312e5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;835&#39; height=&#39;574&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"835\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"835\" data-original=\"https://pic2.zhimg.com/v2-16ac926d48bff6f5f77e3517b42312e5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-16ac926d48bff6f5f77e3517b42312e5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>产品</b></li></ul><p>工厂模式的要点是，系统需要几种不同的产品，但这些产品有相同的使用方法。所以，可以将几种不同的具体产品提炼为一种<b>抽象的产品</b>，即类图中的 <b>&lt;\\&gt; Product</b>，比如该产品提供 <b>use()</b> 方法，那么不管具体是哪种产品，都会提供 use() 功能，对于<b>使用者</b>来说（图中未画出），不需要知道具体是哪个产品，都是通过use()方法使该产品完成特定的功能。</p><p>举例来说，某种业务处理期间会输出信息，一方面要记录到日志文件，另一方面要传送到客户端，供管理人员监控。这里，一种<b>抽象的输出信息处理工具</b>，就是一个<b>抽象的产品</b>。对于业务处理程序而言，它只需获得一个抽象的输出信息处理工具，并将自己的信息交给该工具去处理。如果实际是一个文件工具，文件工具会将信息记录到日志，如果实际是一个信息传输工具，该工具会将信息发送到客户端去显示。 假如某一天需要将信息记录到数据库，则增加一个数据库处理工具，该工具完成将信息记录到数据库的任务。而对于业务处理程序而言，依然不需要知道到底是哪个工具、以及该工具具体是如何处理信息。</p><ul><li><b>工厂</b></li></ul><p>产品的特性清楚了，那么工厂的意义是什么、以及选用哪种工厂呢？ 工厂的作用在于根据情况创建具体的产品。上面例子中，工厂就是负责创建 文件工具、远程传输工具、数据库工具，并将其中之一交给业务处理程序。 如果这几种工具的创建过程很简单，就可以用<b>简单工厂</b>，在一个类里面搞定。如果比较复杂，就用<b>工厂方法</b>，每种工具有各自的工厂类来创建，当然，这个时候，<b>工厂也是抽象的</b>，也就是说，不同产品的工厂有相同的创建接口，并且都返回相同的产品——即上面所说的<b>抽象的产品</b>。</p><ul><li><b>多产品</b></li></ul><p>如果产品比较复杂，不是单个产品，而是需要<b>多件产品</b>的套件，则使用<b>抽象工厂</b>。看看类图，工厂方法生产一种抽象产品，抽象工厂生产多种抽象产品。比如界面主题，不同的主题可以设置不同的颜色搭配、字体、日期时间格式、文本样式、边框样式、动态背景等等，这样一系列设置项，可以用抽象工厂来创建一套设置工具，分别完成各项目的设置。</p><ul><li><b>生产和使用</b>（与其它模式的关系） 作为创建型模式，工厂的应用很广泛。原则上讲，生产和使用是一个产品生命中的两个阶段，要使用一个产品，必须先生产出来。同时，我们也不会生产没用的产品，浪费资源，所以生产出来的产品都会被使用。<br/> </li><li><b>生产</b> 程序中多数时候直接new一个对象，然后使用该实例。 但如果用到某个<b>使用了Interface的设计模式，很可能就要搭配使用工厂模式</b>了。因为Interface必然有实现者（被某个class implement，在类图中通常命名为ConcreteXYZ，代码比如<code>class ConcreteXYZ implements InterfaceXYZ</code>）。而且不止一个实现者（如果只有一个ConcreteXYZ，就不必要用Interface来提取抽象接口了）。而多个ConcreteXYZ每个都需要被创建出来，创建多个不同类型的ConcreteXYZ，通常就需要采用某种工厂模式。<br/> </li><li><b>使用</b> 工厂虽然创建了一组ConcreteXYZ，但使用者（在类图中通常命名为Client，但有时没有画出来）通常不直接使用这些ConcreteXYZ，而仅使用它们共同的Interface接口中的方法，也就是说，<b>Client不关心也不知道是哪个具体的ConcreteXYZ在执行任务</b>。代码通常是<code>interfaceXYZ.doSomething()</code>，而不是<code>concreteXYZ.doSomething()</code>。<br/> </li><li><b>配置</b> 工厂创建的是一组ConcreteXYZ，Client却要使用interfaceXYZ，但这个interfaceXYZ在被使用时其实是一个ConcreteXYZ，那么Client怎样知道何时使用哪个ConcreteXYZ呢？ 所以程序设计中还需要一段配置逻辑，在不同的情况下将适当的ConcreteXYZ交给Client。如果配置逻辑是固定的，可以直接在代码中实现，比如一串if else，在不同情况下return不同的ConcreteXYZ。如果需要在运行时设定，可以通过界面由用户选择。如果还要动态加载，可以通过配置文件+反射机制，比如框架创建和使用上层业务对象。 <b>配置将生产和使用关联</b>到一起。<br/> </li><li><b>小结</b><br/> </li></ul><p>具有相同接口但不同实现的一组产品，可以用工厂模式来创建，具体采用哪种，要看创建对象的过程是简单还是复杂。工厂模式关注的是产品生命周期中创建阶段，不过程序设计时我们同时要考虑产品的使用和配置。</p><h2>3. 适配器（Adapter）</h2><p>适配器模式，顾名思义，就是适配器的意思。比如出国旅行，不同国家的电源插座是不一样的，我们带一个转换插座，将各种插座统一转换成我们常用的三孔或两孔插座，这个转换插座就是适配器。</p><ul><li><b>类图</b>（来自 <a href=\"https://link.zhihu.com/?target=https%3A//design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图说设计模式</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b959981d58e380165a65d7ef2f518d85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic2.zhimg.com/v2-b959981d58e380165a65d7ef2f518d85_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;313&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic2.zhimg.com/v2-b959981d58e380165a65d7ef2f518d85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b959981d58e380165a65d7ef2f518d85_b.jpg\"/></figure><p> - <b>使用场景</b> <b>1. 不方便修改已有的接口</b> 考虑上面转换插座的例子，因为各国插座的接口已经固定好了，不可能要求别人按照我们的标准更换插座，所以只能自己带转换插座去转接。在程序的角度，比如我们要采用外部第三方的组件，就可能需要在中间加一个适配器。 假如新设计一个程序，需要适配器的可能性较小。就比如假设各国还没有制定插座标准，那么就制定一个统一规范是最简单的。</p><p><b>2. 通常需要适配多个不同的接口，需要搭配工厂模式</b> 假如有一天，你有一家“鸡拱门”公司收购了麦当劳和肯德基，你当然希望为客户提供“巨无霸+全家桶”套餐，但是整合两家店的订餐系统太麻烦了，如果在客户和两个订餐系统之间加一层适配器（具体有2个适配器，一个对接麦当劳，一个对接肯德基）就比较简单。如果是巨无霸，适配器将订单发给麦当劳，如果是全家桶，适配器将订单发给肯德基。</p><p>既然是2个适配器，其实，这就需要一个适配器工厂，也就是说，系统需要知道哪个订单交给哪个适配器去处理。</p><p>假如只收购了麦当劳呢？就一套系统，直接用就可以了哦。</p><h2>4. 外观/门面/助理（Facade）</h2><p>外观模式适用于将复杂的过程总结为一个简单的接口，就像老板助理。老板说，下周我要举办一个晚宴。助理就要安排场所和菜单、确认客人名单和座位、找财务要预算、安排宴会流程等等。老板就是提一个要求，不关心怎样操作，只要最后宴会顺利进行，助理搞定所有具体细节。</p><p>对照下面的类图来看，SystemA、B、C就相当于场所、财务等等，各种具体的细节事物。助理的角色，就是门面Facade，助理是SystemA、B、C的门面，她/他屏蔽了A、B、C的细节，只把结果（门面上展示的产品）呈现给老板。老板是Client，只交代助理要完成某任务，不管其它。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e469bc9b9a6d46278620041a29de9e2f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-e469bc9b9a6d46278620041a29de9e2f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-e469bc9b9a6d46278620041a29de9e2f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e469bc9b9a6d46278620041a29de9e2f_b.jpg\"/></figure><p> - <b>使用场景</b> 老板频繁开宴会，就需要一个专职的宴会助理。在这个意义上，称之为<b>助理模式</b>更贴切一点。 如果只是一次性的操作，比如公司倒闭的时候老板请散伙饭，反正也就一次，助理也懒了，老板只好自己操持各种细节，也是可以的。</p><ul><li><b>小结</b> 外观模式的主要作用就是<b>屏蔽细节</b>。</li></ul><h2>5. 代理（Proxy）</h2><p>买卖房屋通常都通过房产中介来交易，中介就是一种代理。在程序设计中，代理也是用来隔离调用者和被调用者，不过代理模式通常有更具体一些的应用场景。</p><ul><li><b>类图</b>（来自 <a href=\"https://link.zhihu.com/?target=https%3A//design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图说设计模式</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-49158dd20d5cf2f28c91470db840e431_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb\" width=\"658\" data-original=\"https://pic2.zhimg.com/v2-49158dd20d5cf2f28c91470db840e431_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;658&#39; height=&#39;437&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"658\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"658\" data-original=\"https://pic2.zhimg.com/v2-49158dd20d5cf2f28c91470db840e431_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-49158dd20d5cf2f28c91470db840e431_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>使用场景</b></li><li><b>空间代理</b> client不需要了解所操作的对象的实际位置。比如远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。<br/> </li><li><b>时间代理</b> 比如代理先提供一个缩略图，必要时再加载大图。虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。<br/> </li><li><b>缓冲(Cache)代理</b> 为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。<br/> </li><li><b>保护(Protect or Access)代理</b> 控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 防火墙(Firewall)代理：保护目标不让恶意用户接近。<br/> </li><li><b>强化代理</b> 为被代理对象增加一些额外的功能，比如： 同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。 智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。<br/> </li><li><b>对比适配器、外观模式、代理</b> 适配器、外观、代理，可以说都是在client与调用对象之间增加了一层中间层，它们的主要区别在于：<br/> </li><ul><li>适配器侧重于统一不同制式的接口（插座转换器）</li><li>外观侧重于整合复杂的细节（老板助理）</li><li>代理则用于一些特定的情况（上面的举例）</li></ul></ul><h2>6. 组合（Composite）</h2><p>组合模式强调<b>整体和部分</b>具有一些<b>相同</b>的功能。这里有两个要点，一个是具有一些共性，另一个是具有 整体-部分 关系。比如目录下可以放文件，不过都可以进行复制、粘贴。</p><ul><li><b>类图</b>（来自 <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Composite_pattern\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科</a>)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-81ea506f3d0b9c9735ed23d1b97d71d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-81ea506f3d0b9c9735ed23d1b97d71d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-81ea506f3d0b9c9735ed23d1b97d71d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-81ea506f3d0b9c9735ed23d1b97d71d8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>使用场景</b> 常见的组合模式是具有树状结构的数据，比如文件系统中 目录-子目录-文件；公司架构中 公司-部门-子部门。在Java程序中，GUI组件也是一种 组合模式，看下面的类图（来自<a href=\"https://link.zhihu.com/?target=https%3A//gof.quanke.name/%25E6%25A0%2591%25E5%25BD%25A2%25E7%25BB%2593%25E6%259E%2584%25E7%259A%2584%25E5%25A4%2584%25E7%2590%2586%25E2%2580%2594%25E2%2580%2594%25E7%25BB%2584%25E5%2590%2588%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E4%25BA%2594%25EF%25BC%2589.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式</a>)：</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b62b9fa3fc6dd3c94851e5759aa4e916_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic3.zhimg.com/v2-b62b9fa3fc6dd3c94851e5759aa4e916_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;266&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic3.zhimg.com/v2-b62b9fa3fc6dd3c94851e5759aa4e916_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b62b9fa3fc6dd3c94851e5759aa4e916_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们考察一下这个例子为什么适合用组合模式。 1. <b>共性</b> 可以看到，Checkbox、Button、TextComponent等控件都是一个Component，而且Container容器也是一个Component，我们看看Java文档中关于 <a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/api/java/awt/Component.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Component</a> 提供的方法：     - add(PopupMenu popup)     - addMouseListener(MouseListener l)     - getBounds()     - repaint()     - 等等</p><p>这些方法，包括菜单、监听器、边框、绘图等，无论对控件（Button等）还是容器（Container）都是同样有效的，所以它们全都继承自Component。 2. <b>整体-部分</b> 再看 <a href=\"https://link.zhihu.com/?target=https%3A//docs.oracle.com/javase/7/docs/api/java/awt/Container.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Container</a> 的文档，它提供的方法：     - add(Component comp)     - add(Component comp, int index)     - 等等</p><p>容器（Container）需要提供对组件（Component）的管理。    Container 里面可以包含 Component，所以具有 整体(Container) - 部分(Component) 关系。注意，Container自身也是一个Component，所以 Container里面也可以包含其它Container，就像目录下面可以有子目录一样。</p><p>典型的组合模式会有 整体-部分 关系，一个容器包含多个Component，所以容器通常会提供 add/remove/get 等功能。</p><h2>7. 装饰（Decorator）</h2><p>装饰模式用于<b>动态</b>地给一个对象添加一些<b>额外的功能</b>。 比如做一个生日蛋糕，基础部分就是一个蛋糕外面抹奶油。但是可以提供各种额外的<b>装饰</b>，比如写上生日快乐，加蜡烛，添加水果，还可以做多层蛋糕，等等。可以选择采用其中一种或多种装饰依次叠加，得到各式各样的蛋糕。而且以后还可以增加新的装饰种类。当然，不管怎样，原则是最后都要生成一个蛋糕。</p><ul><li><b>类图</b>（在 <a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/god_bless_you/archive/2010/06/10/1755212.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">装饰模式</a> 的基础上修改）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-50431780595efab9c735a9ef726143bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-50431780595efab9c735a9ef726143bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-50431780595efab9c735a9ef726143bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-50431780595efab9c735a9ef726143bb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>链式装饰</b> 使用装饰模式的时候，经常需要一种链式装饰：做一个基础产品-&gt;添加装饰a-&gt;添加装饰b......，用代码写出来通常是这样：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">(蛋糕)基础蛋糕 = new 巧克力蛋糕\n(蛋糕)草莓蛋糕 = new 草莓蛋糕(基础蛋糕)\n(蛋糕)蜡烛草莓蛋糕 = new 蜡烛草莓蛋糕(草莓蛋糕)</code></pre></div><p>每一次装饰都需要在上一个蛋糕之上进行，即需要将上一个对象实例作为参数传递给当前装饰对象。如果装饰层次太多，也会增加系统复杂度。</p><p>当然，好处是可以随意选择不同的装饰，还可以采用不同的顺序。</p><ul><li><b>装饰、组合、代理</b> 对比一下上面组合模式的类图，是不是和装饰模式有相似的感觉。 Decorator继承自Component，同时也包含一个Component变量，这也是一种组合关系，所以类图上看它们之间的关系，与组合模式中Composite与Component的关系是同样的。而且装饰模式中ConcreteComponent也类似于组合模式中的Leaf。</li></ul><p>但是装饰和组合是针对不同的应用场景，我们看<b>组合模式中Composite强调的是对Composite的add/remove/get，装饰模式中强调的是对Composite增加功能addBehavior</b>。组合模式通常容器中包含多个Component，装饰模式中通常装饰者只使用一个被装饰者。</p><p>说到增加功能，上面讲代理的时候，有一种代理的应用场景也是给对象增加一些额外功能的，比如增加引用计数。那么这里装饰模式与代理模式有什么不同呢？最大的区别在于装饰模式更强调<b>动态</b>增加。也就是说，在基础功能之上，今天可能需要加个A功能，明天需要加个B功能，或者运行时根据情况决定添加哪些功能，这时就适合用装饰模式。</p><h2>8. 享元（Flyweight）</h2><p>当系统中存在<b>大量</b>细粒度对象时，如果这些对象具有<b>部分相同的信息</b>，则这些相同的部分内容可以共享，不必每个对象都持有该信息的副本，从而减少内存消耗。</p><p>我们可以将享元理解为一定数量的<b>公共对象池</b>。当需要某个享元对象时，并不是每次直接new一个新对象出来，而是获得公共对象池中自己所需对象的引用。 比如Java字符串String的设计就是一种享元模式，程序中所有String其实都放在一个<b>String对象池</b>中，如果两个String的内容相同，其实是引用同一个对象。</p><div class=\"highlight\"><pre><code class=\"language-text\">String a = &#34;hello&#34;;\nString b = &#34;hello&#34;;\nSystem.out.println(a==b);   // true</code></pre></div><ul><li><b>类图</b>（来自《Design Patterns: Elements of Reusable Object-Oriented Software》）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6382ef09af90e3abafaccdeb5d49fb1b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-6382ef09af90e3abafaccdeb5d49fb1b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-6382ef09af90e3abafaccdeb5d49fb1b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6382ef09af90e3abafaccdeb5d49fb1b_b.jpg\"/></figure><p> 要维护公共对象池，通常可以采用<b>一个单实例的享元工厂</b>，它提供一个静态的工厂方法用于返回享元对象。如果所要求的享元对象已经存在，直接返回其引用，如果不存，则创建一个，并返回其引用。</p><ul><li><b>案例</b></li></ul><p>再看一个例子（参考<a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/sstd521/design/193613\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式之禅（第2版）</a>）。一个考试报名系统，每个考生报名时需要填写报名信息，包括 科目、考点、准考证邮寄地址等。当考生很多时，系统会创建大量的报考信息object，每个考生一个。但实际上只有4个科目，30个考点。所以科目和考点信息（对象实例）是可以共享的，无论有1千考生还是10万考生，都只需要4个科目对象，30个考点对象。</p><h2>9. 桥接/双层抽象（Bridge）</h2><p>桥接模式是软件设计模式中最难以理解的模式之一，它的目的是</p><blockquote> Decouple an abstraction from its implementation so that the two can vary independently.  将一个<b>抽象</b>与它的<b>实现</b>解耦，使它们可以各自独立的变化。<br/> </blockquote><p>这句话里面最让人费解的是<b>抽象</b>和<b>实现</b>，到底是指什么？先看下类图</p><ul><li><b>类图</b>（来自<a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E6%25A9%258B%25E6%258E%25A5%25E6%25A8%25A1%25E5%25BC%258F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科</a>)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fa3adcebad91f5b423739e4dee095b47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-fa3adcebad91f5b423739e4dee095b47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-fa3adcebad91f5b423739e4dee095b47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fa3adcebad91f5b423739e4dee095b47_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>把Client加进去看一下（来自《Design Patterns: Elements of Reusable Object-Oriented Software》）：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-93a5455a743a78b36af13dd0fc7b8f2c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb\" width=\"851\" data-original=\"https://pic1.zhimg.com/v2-93a5455a743a78b36af13dd0fc7b8f2c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;851&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"851\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"851\" data-original=\"https://pic1.zhimg.com/v2-93a5455a743a78b36af13dd0fc7b8f2c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-93a5455a743a78b36af13dd0fc7b8f2c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li><b>双层抽象</b> 从类图可以看出，Client只使用Abstraction，Abstraction保存Implementor并使用它的方法。其实这就是一个<b>双层抽象</b>，GOF将<b>第一层抽象称为Abstraction（抽象）</b>，<b>第二层抽象称为Implementor（实现）</b>。Abstraction持有并使用Implementor，称之为Bridge/桥接。</li></ol><p>引用一下《Design Patterns: Elements of Reusable Object-Oriented Software》中关于Implementor的说明：</p><blockquote><b>Implementor</b>  defines the interface for implementation classes. This interface doesn&#39;t have to correspond exactly to Abstraction&#39;s interface; in fact the two interfaces can be quite different. Typically the <b>Implementor interface provides only primitive operations, and Abstraction defines higher-level operations based on these primitives</b>.  <br/> Implementor是实现类的公共接口，这些接口不需要与Abstraction的接口相同，实际上，这两者的接口经常有很大区别。典型情况下，<b>Implementor接口是比较原始的操作，而Abstraction接口则是比较上层的操作，并且是基于Implementor的原始操作来实现</b>。<br/> </blockquote><ol><li><b>Abstraction具有扩展性</b> 另外需要注意的一点是，Abstraction是可以通过继承来扩展其功能的。在类图上体现的就是Abstraction提供 function() 功能，继承它的 RefinedAbstraction 还提供 refinedFunction() 功能。<br/> </li><li><b>案例</b><br/> </li></ol><p>现在我们看一下书中的例子，来进一步帮助理解 Abstraction（抽象）和 Implementor（实现），以及什么场景下会需要这种桥接结构。(配图及代码来自《Design Patterns: Elements of Reusable Object-Oriented Software》）。</p><p>我们需要设计一个可应用于多种操作系统平台的通用GUI工具包，考虑其中Window类的设计。主要面临的问题是， 1. Window有多种形式，比如常规的window，外面是标题边框，里面显示具体的视图内容；也有图标型的window，它不显示视图内容，而是画出一个图标；等等。 2. 不同操作系统在界面上画出GUI元素的实现方式是不一样的，比如 X Window 操作系统 和 IBM的 PM操作系统（ Presentation Manager），等等。</p><p>如果用通常的继承结构，可能需要有 XNormalWindow, XIconWindow, PMNormalWindow, PMIconWindow，总共需要 [Window类型数 * 支持的OS数] 个class，当Window类型和支持的OS较多时，程序设计和维护都非常困难。</p><p>使用桥接模式，我们可以定义一个高层的Window接口（Abstraction）和一个底层的绘图接口（Implementor）。如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-24f62c82dd5074a1a3866cdec70bdefb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-24f62c82dd5074a1a3866cdec70bdefb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic4.zhimg.com/v2-24f62c82dd5074a1a3866cdec70bdefb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-24f62c82dd5074a1a3866cdec70bdefb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>不同类型的具体的Window基于Window（Abstraction）扩展，不同OS的支持基于WindowImp（Implementor）提供实现。两者可以独立的扩展，互不依赖。 下面摘录书中的部分代码，该案例详细说明和更多代码请参考原书。</p><p>Window会提供比较高层的功能</p><div class=\"highlight\"><pre><code class=\"language-text\">class Window { \npublic: \n    Window(View* contents);\n\n    // requests handled by window \n    virtual void DrawContents();\n\n    virtual void Open(); \n    virtual void Close(); \n    virtual void Iconify(); \n    virtual void Deiconify();\n\n    // requests forwarded to implementation \n    virtual void SetOrigin(const Point&amp; at); \n    virtual void SetExtent(const Point&amp; extent); \n    virtual void Raise(); \n    virtual void Lower();\n\n    virtual void DrawLine(const Point&amp;, const Point&amp;); \n    virtual void DrawRect(const Point&amp;, const Point&amp;); \n    virtual void DrawPolygon(const Point[], int n); \n    virtual void DrawText(const char*, const Point&amp;);\n\nprotected: \n    WindowImp* GetWindowImp(); \n    View* GetView();\n\nprivate: \n    WindowImp* _imp; \n    View* _contents; // the window&#39;s contents \n};</code></pre></div><p>WindowImp需要提供与OS相关的更细节的绘图功能</p><div class=\"highlight\"><pre><code class=\"language-text\">class WindowImp { \npublic: \n    virtual void ImpTop() = 0; \n    virtual void ImpBottom() = 0; \n    virtual void ImpSetExtent(const Point&amp;) = 0; \n    virtual void ImpSetOrigin(const Point&amp;) = 0;\n\n    virtual void DeviceRect(Coord, Coord, Coord, Coord) = 0; \n    virtual void DeviceText(const char*, Coord, Coord) = 0; \n    virtual void DeviceBitmap(const char*, Coord, Coord) = 0; \n    // lots more functions for drawing on windows... \nprotected: \n    WindowImp(); \n};</code></pre></div><p>不同类型的Window有自己独特的实现</p><div class=\"highlight\"><pre><code class=\"language-text\">class IconWindow : public Window { \npublic: \n    // ... \n    virtual void DrawContents(); \nprivate: \n    const char* _bitmapName; \n};\n\nvoid IconWindow::DrawContents() { \n    WindowImp* imp = GetWindowImp(); \n    if (imp != 0) { \n        imp-&gt;DeviceBitmap(_bitmapName, 0.0, 0.0); \n    } \n}</code></pre></div><ul><li><b>结合抽象工厂</b> Window需要一个WindowImp的实例，有时是XWindowImp，有时是PMWindowImp，要看在哪个平台上运行。动态创建实例的场景适合用抽象工厂模式。由一个单实例工厂负责根据所在的操作系统平台来创建和返回相应的WindowImp实例。</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">WindowImp* Window::GetWindowImp () { \n        if (_imp == 0) { \n            _imp = WindowSystemFactory::Instance()-&gt;MakeWindowImp(); \n        } \n        return _imp; \n    }</code></pre></div><ul><li><b>参考</b> 强烈建议阅读原文《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式：可复用面向对象软件的基础》</li></ul><h2>10. 观察者（Observer）</h2><p>当一个对象状态发生改变时，需要了解其状态变化的对象都会得到通知。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。此种模式经常用于实时事件处理系统，比如Java中的GUI控件发布的事件，鼠标/键盘事件等。</p><p>另外比如 生产-消费 模型，多个生产者生产产品，多个消费者消费产品，在多线程设计中可以采用 wait-notify 方式来实现。产品都放在一个队列中，当生产者向队列中增加产品 或 消费者从队列中取出产品时，都会通知（notifyAll）其它正在等候（wait）的生产者和消费者，队列中的产品状态已经改变。被唤醒的的生产者和消费者会竞争同步锁，获得锁以后进行自己的生产或消费活动。</p><ul><li><b>类图</b>（来自<a href=\"https://link.zhihu.com/?target=https%3A//gof.quanke.name/%25E5%25AF%25B9%25E8%25B1%25A1%25E9%2597%25B4%25E7%259A%2584%25E8%2581%2594%25E5%258A%25A8%25E2%2580%2594%25E2%2580%2594%25E8%25A7%2582%25E5%25AF%259F%25E8%2580%2585%25E6%25A8%25A1%25E5%25BC%258F%25EF%25BC%2588%25E4%25BA%258C%25EF%25BC%2589.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>订阅和发布可以是<b>多对多</b>的关系，当然也可以一对多、多对一、一对一。</p><p>状态变化后的处理，如果比较简单快捷，可以<b>同步</b>完成。即状态变化时，状态对象函数直接调用观察者的函数，观察者方法返回后，状态对象的函数才会返回。 如果观察者的处理较为复杂，可以采用<b>异步</b>调用。即观察者在自己的线程中对状态变化的情况进行处理，当然，可以需要增加线程同步和协作的机制。比如上面讲的 生产-消费 模型。</p><p>观察模式可以形成<b>观察链</b>，比如a观察b，b观察c，c观察d，当d变化时通知c，从进而通知b，b再通知a。观察链增加了系统结构的复杂度，最好不要设计太多环节。</p><h2>11. 命令（Command）</h2><p>命令模式将<b>命令</b>本身抽象出来，即类图中的 <b>&lt;\\&gt;Command</b> ，从而我们可以对命令本身进行<b>调度或操作</b>。</p><ul><li><b>类图</b>（来自 <a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E5%2591%25BD%25E4%25BB%25A4%25E6%25A8%25A1%25E5%25BC%258F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-20f0b76ae38f9e58e4d69f27ff9df1fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-20f0b76ae38f9e58e4d69f27ff9df1fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;353&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-20f0b76ae38f9e58e4d69f27ff9df1fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-20f0b76ae38f9e58e4d69f27ff9df1fb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>程序在绝大多数情况下，调用者直接调用执行者的某个方法，传入所需的参数，并获得执行结果。但如果遇到需要将<b>命令</b>这个东西本身抽象出来的情况，就可以采用命令模式。也就是说需要使用<b>Command.execute()</b> 这种间接的方式来调度命令的执行。</p><p>结合类图来看的话，通常 Client 直接调用 <code>receiver.action()</code>。 使用命令模式后，Client 先设置好某个命令由哪个Receiver来执行，并将该命令放置到命令队列中，或者直接关联到某个 Invoker上面，但并不直接执行，而是由Invoker 来调度命令的执行。</p><ul><li><b>案例</b> 你开了一家小吃店，开始只有一个厨师三张桌子，客户下单的时候，你直接往后厨喊一嗓子“红烧肉盖饭”，厨师就直接做出来。程序中绝大多数调用就是这么干的。 因为做得好吃服务也很到位，你的生意越做越大，一不小心变成10个大厨50个菜品的网红餐厅。这时就要为下单的客人打印一张所点的菜品清单，多位客人的点菜清单（命令）依次发给后厨，大厨们选择清单中的菜品进行制作。<br/> </li><li><b>适用场景</b><br/> </li><li><b>线程池</b> 从程序设计的角度来看，这是一个10个线程50种任务的<b>线程池</b>系统。这里很自然需要采用命令模式，下单时服务员（Client）不能直接调用某个厨师（Reveiver）来完成某个菜品，必须将菜品命令（Command）添加到任务队列，由调度系统（Invoker）在根据一定的规则选择厨师（线程）来制作某个菜品（Command）。 进一步考虑，有时客户会修改点单，增加或删除菜品。这时只需要在菜品任务队列中添加或删除相应的菜品就可以了。 所以，用命令模式整个系统架构更加清晰，而且服务员和厨师都是异步执行，效率高。<br/> </li><li><b>撤销和重做</b>（undo/redo） 有些程序需要提供撤销和重做（undo/redo）功能，比如我们常用的WORD，或者PS。这跟上面修改菜品任务队列是类似的（不过undo/redo动作只能在栈顶操作，不能随意调整命令的次序），所以undo/redo也是一种适合采用命令模式的场景。<br/> </li><li><b>GUI命令响应</b> 界面元素，比如按钮、菜单等，当用户点击时会触发一个命令动作。我们可以预先将GUI元素（按钮、菜单等）与对应的命令绑定，一旦用户触发动作，绑定的命令就会执行。重点代码如下（来自 <a href=\"https://link.zhihu.com/?target=https%3A//alvinalexander.com/java/java-action-abstractaction-actionlistener\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">A Java Action, ActionListener, and AbstractAction example</a>，稍做修改）：<br/> </li></ul><div class=\"highlight\"><pre><code class=\"language-text\">/**\n   * Our &#34;Copy&#34; action.\n   */\n  public class CopyAction extends AbstractAction\n  {\n    public CopyAction(String name, ImageIcon icon, String shortDescription, Integer mnemonic)\n    {\n      super(name, icon);\n      putValue(SHORT_DESCRIPTION, shortDescription);\n      putValue(MNEMONIC_KEY, mnemonic);\n    }\n\n    public void actionPerformed(ActionEvent e)\n    {\n      // 假设 docMgr 是一个文档内容管理器，\n      docMgr.instance().doCopy();\n    }\n  }\n\n  // 创建一个命令（copyAction）\n  copyAction = new CopyAction(&#34;Copy&#34;, copyIcon, &#34;Copy stuff to the clipboard&#34;, new Integer(KeyEvent.VK_COPY));\n\n  // 命令绑定到菜单\n  JMenuItem copyMenuItem = new JMenuItem(copyAction);\n  // 同一个命令绑定到按钮\n  JButton copyButton = new JButton(copyAction);</code></pre></div><p>在这个例子中，命令模式的作用不算太重要，其主要用途是，可以用一个命令对象（copyAction）绑定多个界面元素（一个菜单和一个按钮）。 如果不用命令对象，直接在 ActionListener 中调用目标方法也是可以的。虽然需要分别设置ActionListener，但省略了CopyAction类，其实也很简洁。示例代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 按钮事件监听器\n        copyButton.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n               docMgr.instance().doCopy();\n            }\n        });\n\n        // 菜单事件监听器\n        copyMenuItem.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent arg0) {\n               docMgr.instance().doCopy();\n            }\n        });</code></pre></div><ol><li><b>更多应用场景</b> <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Command_pattern\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科 Command pattern</a> <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/1673841/examples-of-gof-design-patterns-in-javas-core-libraries%3Frq%3D1\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Examples of GoF Design Patterns in Java&#39;s core libraries</a><br/> </li><li><b>解疑</b><br/> </li><li><b>Client和Receiver</b> 在基本场景下（程序绝大多数情况下调用方法时），只有Client和Receiver，Client直接调用Receiver的方法并获得返回结果。就像你直接喊厨房做个红烧肉一样。<br/> </li><li><b>Invoker</b><br/> </li></ol><ul><li>在命令模式的场景下，由于某些原因Client不方便直接调用Receiver，所以通过Invoker来调度命令的执行，所以，<b>Invoker是命令的调度者</b>，比如餐厅的例子。</li><li>也有些时候，命令一触发就立即执行，但Invoker会附加一些针对命令本身的操作。这时，<b>Invoker对命令进行额外的操作</b>。比如redo/undo情况下，Invoker需要维护命令队列，以及当前有效命令在队列中的哪个位置，并根据情况要求命令执行redo/undo。</li><li>不管是调度命令，还是进行额外的操作，Invoker既不知道命令的发起者，也不知道命令的执行者，也不关心命令执行的结果，只是单纯的调度或维护命令本身。</li></ul><ol><li><b>Client/Receiver和Invoker</b> 同样，Client和Receiver也不知道命令是如何调度的，或者做了什么其它的事情。Client只关心自己的命令肯定会被执行，并返回结果。也就是说服务员（Client）向厨房（Receiver）下的单肯定都会被完成，虽然不清楚何时、由哪个厨师完成。 看类图上面，Client/Receiver 与 Invoker 之间都没有任何联系。<b>Client/Receiver和Invoker 解耦</b>。<br/> </li><li><b>Client与Receiver解耦了吗？</b> 注意看类图 Client 是明确需要使用 Receiver的，这两者并<b>没有解耦</b>。 客户点餐后，服务员会下单给厨房，客户结账时，服务员会把客户引到收银台，业务不熟的服务员是不行的。<br/> </li><li><b>有时候好像不需要Receiver？</b> 很多时候我们可以直接在 Action 里面执行一系列操作，并不需要专门定义一个 Receiver类，好像 Receiver 被省略掉了。这里，我们应该理解为<b>没有显式的</b>定义一个Receiver，但依然完成了Receiver的功能。即使只是在Action里面System.out.println()，这个System就是Receiver。<br/> </li><li><b>小结</b> 当且仅当我们需要对 <b>命令本身</b> 进行 <b>调度</b>（比如线程池）或 <b>操作</b>（比如redo/undo）时，可以采用命令模式。<br/> </li><li><b>参考</b> <a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Command_pattern\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科 Command pattern</a> <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/32597736/why-should-i-use-the-command-design-pattern-while-i-can-easily-call-required-met\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why should I use the command design pattern while I can easily call required methods?</a> <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/16561473/why-do-we-need-a-receiver-class-in-the-command-design-pattern\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why do we need a “receiver” class in the Command design pattern </a><br/> </li></ol><h2>12. 策略（Strategy）</h2><ul><li><b>类图</b>（来自<a href=\"https://link.zhihu.com/?target=https%3A//design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图说设计模式</a>）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1526d05cce868ef5a78fe96e26da1ebd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb\" width=\"764\" data-original=\"https://pic2.zhimg.com/v2-1526d05cce868ef5a78fe96e26da1ebd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;764&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"764\" data-original=\"https://pic2.zhimg.com/v2-1526d05cce868ef5a78fe96e26da1ebd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1526d05cce868ef5a78fe96e26da1ebd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>某品牌在不同情况下有各种促销活动方案，比如中秋活动、换季折扣、积分抵扣、优惠券、满减、套装等等，而且还可能不断增加新的活动类型。</p><div class=\"highlight\"><pre><code class=\"language-text\">public double calcPrice(int 活动类型) {\n    if(活动类型 == 中秋活动){\n      计算中秋价格;\n    }\n    else if (活动类型 == 换季折扣){\n      计算换季折扣价格;\n    }\n    ......\n}</code></pre></div><p>这样一大堆 if else 会非常繁琐。那么我们采用 策略模式来看看。</p><div class=\"highlight\"><pre><code class=\"language-text\">Interface 策略 {\n    public double caldPrice();\n}\n\nclass 中秋策略 extends 策略{\n    public double caldPrice() {\n        计算中秋价格;\n    }\n}\n\nclass 换季折扣策略 extends 策略{\n    public double caldPrice() {\n        计算换季折扣价格;\n    }\n}\n\nclass 价格管理 {\n    private 当前策略;\n    public void 设置当前策略(策略 oneStrategy) {\n        当前策略 = oneStrategy;\n    }\n\n    // 主流程非常简单明了\n    public double calcPrice() {\n        return 当前策略.caldPrice();\n    }\n}</code></pre></div><p>策略模式简化了主流程，隔离了不同策略的实现。 不过呢，其实我们也并没有完全避开那些 if else，必然在程序中的某个地方（比如对策略的配置管理），需要根据用户的设置来指定 当前采用哪一个具体的策略。</p><ul><li><b>动态策略</b> 如果希望动态加载策略，甚至支持第三方开发的策略，那么策略模式就很有必要了。由于策略被定义为一个抽象的接口，调用者不需要知道具体的策略是哪一种，如果我们采用反射机制，可以完全动态的加载一个第三方策略，使用该策略来计算价格。<br/> </li><li><b>策略与工厂</b> 如果对比一下工厂模式，可以发现策略与工厂的类图长得很像。策略模式是一个抽象的策略接口，然后有几个具体的策略类。工厂模式有一个抽象的产品接口，然后有几个具体的产品类。它们的差异是什么？<br/> </li></ul><p>如果紧扣模式本身的概念来说，工厂是创建模式，策略是行为模式。但进一步想，创建之后不需要行动吗？多种不同的行为难道不是要先创建出来吗？策略模式中的 各种策略，其实也是被工厂生产出来的产品。<b>工厂模式和策略模式，分别强调了一个完整过程中的两个阶段</b>，生产阶段（工厂）和行为阶段（策略），当我们采用其中一个模式时，另一个模式也必然会（显式或隐式）的被使用。</p><ul><li><b>语义</b> 策略模式架构很简单，但还是被单独命名为一个模式，更多的是指出一类应用场景，即与策略、算法等相关的应用。</li></ul><h2>总结</h2><p>设计模式的本质，是希望找到系统中<b>共性</b>的部分和<b>差异</b>的部分，将共性的部分提炼为接口（interface），差异的部分定义成不同的具体的类（class）来实现（implement）那个共同的接口。对于使用者（Client）来说，就可以调用抽象的接口（的实例），而不用关注具体是哪个类的实例在完成工作。 不管哪种设计模式，看到类图的时候最主要的关注点就是<b>Interface</b>部分，它代表了系统中可以被<b>抽象出来的共性</b>。</p><h2>参考</h2><ol><li>《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式：可复用面向对象软件的基础》</li><li><a href=\"https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E8%25AE%25BE%25E8%25AE%25A1%25E6%25A8%25A1%25E5%25BC%258F_%28%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%29\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">维基百科</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//gof.quanke.name/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//design-patterns.readthedocs.io/zh_CN/latest/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">图说设计模式</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.kancloud.cn/sstd521/design/193489\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式之禅（第2版）</a></li></ol>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42002577", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 19, 
            "title": "如何轻松实现10进制与2进制互转", 
            "content": "<h2><b>心血来潮，突然想写写这两者之间的转换，以做记录所用：</b></h2><p>//---------------------10进制转2进制----------------------</p><p><b>1、正整数转二进制</b></p><p>    不断的除2，取余数，反写得到的结果就是该数值的2进制</p><p>\t42 转 2进制</p><p>\t42 / 2 = 21 -------0  （低位）</p><p>\t21 / 2 = 10 -------1</p><p>\t10 / 2 = 5  -------0</p><p>\t5 / 2 = 2   -------1</p><p>        2 / 2 = 1   -------0  （高位）</p><p>        1 / 2 = 0   -------1</p><p>  101010  补齐  0010 1010</p><p>  1个字节是：8位   int类型，4个字节，那么就应该是32位  </p><p><b>2、负整数转二进制</b></p><p>\t先不管符号直接获得二进制，然后取反，再 + 1</p><p>\t42 转 2进制</p><p>\t0010 1010 </p><p>\t取反</p><p>\t1101 0101</p><p>\t再 + 1</p><p>\t1101 0110   = -42</p><p><b>3、小数转二进制</b></p><p>    整数部分依旧遵循上述转换方法，小数部分不断 * 2 取整就是了（反正不是1就是0）</p><p>\t42.125</p><p>\t42转二进制后是：0010 1010</p><p>\t0.125 转2进制</p><p>\t0.125 x 2 = 0.25  -----0</p><p>\t0.25 x 2 = 0.5      -----0</p><p>\t0.5 x 2 = 1.0        -----1</p><p>\t0.125 就该是0.001</p><p>\t合起来0010 1010.0010 0000 就是42.125</p><p>//---------------------2进制转10进制----------------------</p><p><b>4、整数二进制转换为十进制</b> </p><p>   如何区分一个二进制是正数，还是负数，非常简单，看补齐后的首位是0或者1，0就是整数，1就是负数</p><p>   101010 先补齐  0010 1010 </p><p>   然后再每位，乘于2^n ，分别相加就可以了，如：</p><p>   0 * 2^0    = 0</p><p> + 1 * 2^1    = 2</p><p> + 0 * 2^2    = 0</p><p> + 1 * 2^3    = 8</p><p> + 0 * 2^4    = 0</p><p> + 1 * 2^5    = 32</p><p>   得到42</p><p><b>5、负整数二进制转换为十进制\t  </b></p><p>   1101 0110</p><p>   首位是1，说明这是1个负整数，应该先-1，并且取反，再每位，乘于2^n ，分别相加就可以了，如：</p><p>   1101 0110</p><p> - 0000 0001</p><p>= 1101 0101 </p><p>取反：0010 1010  后分别再乘以2的n次方，最后相加</p><p>   0 * 2^0    = 0</p><p> + 1 * 2^1    = 2</p><p> + 0 * 2^2    = 0</p><p> + 1 * 2^3    = 8</p><p> + 0 * 2^4    = 0</p><p> + 1 * 2^5    = 32</p><p> 得到42，再加上符号，为-42</p><p><b>注意：</b>二进制的减法，与十进制的减法一致，不够就去高位借，只不过十进制中，借的1位相当于10，在二进制中，借的1位相当于2 </p><p>如：</p><p>    1100 0011</p><p> -  0010 1101</p><p> = 1001 0110  </p><p>二进制的加法，也与十进制的加法一致，多了就向前进一位   </p><p>如：</p><p>    0000 0111   </p><p>+ 0000 1110</p><p>= 0001 0101\t</p><p><b>6、小数二进制转十进制</b></p><p> 0010 1010.0010 0000 转10进制</p><p> 小数点之前是：</p><p>    0 * 2^0    = 0</p><p> + 1 * 2^1    = 2</p><p> + 0 * 2^2    = 0</p><p> + 1 * 2^3    = 8</p><p> + 0 * 2^4    = 0</p><p> + 1 * 2^5    = 32</p><p> 小数点之后是：</p><p> 0 * 2^-1 = 0</p><p> + 0 * 2^-2 = 0</p><p> + 1 * 2^-3 = 0.125</p><p> 所以加起来就是：0.125  合起来就是：42.125</p>", 
            "topic": [
                {
                    "tag": "进制", 
                    "tagLink": "https://api.zhihu.com/topics/19644925"
                }, 
                {
                    "tag": "十进制", 
                    "tagLink": "https://api.zhihu.com/topics/19573525"
                }, 
                {
                    "tag": "二进制", 
                    "tagLink": "https://api.zhihu.com/topics/19586916"
                }
            ], 
            "comments": [
                {
                    "userName": "无途", 
                    "userLink": "https://www.zhihu.com/people/4f00f32689a7cad4c2b9acfbda6cca7a", 
                    "content": "谢谢大佬", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "深海浅唱", 
                    "userLink": "https://www.zhihu.com/people/78536980fa0911a7fbf888309daa99a9", 
                    "content": "谢谢！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "朴素的少年", 
                    "userLink": "https://www.zhihu.com/people/c8c8b177f7168babd9e7dd1d71650cea", 
                    "content": "那如果十进制小数位是0.7怎么变为二进制", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "沈信得", 
                    "userLink": "https://www.zhihu.com/people/2b217ae69a6b679863b5fa2f8b77cd03", 
                    "content": "倒数第二行有错别字，应该是“+ 1*2^-3=0.125”", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39174808", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 5, 
            "title": "一个工作8年的资深老程序员对“分布式系统”的理解！", 
            "content": "<h2><b>什么是&#34;分布式系统&#34;：</b></h2><p>\t&#34;分布式系统&#34;是指将一个完整的系统，按照一定的规则拆分成很多的子系统（或者叫做组件），子系统之间通过网络传递消息进行通信和动作协调的系统。所以对于一个&#34;分布式系统&#34;而言，它的核心理念就是让多台服务器协同工作，共同完成以前单台服务器无法完成的任务，尤其是一些关于高并发或者大数据量的任务，那么一个&#34;分布式系统&#34;应该具有哪些特征呢？</p><h2><b>&#34;分布式系统&#34;的性能特征：</b></h2><p>     1. 高性能 高性能是我们大家设计分布式系统的最原始的初衷，目的是为了能够让我们的系统能够在单位时间内，支持更高的系统并发，或者是能够处理更多的数据，如果你设计的&#34;分布式系统&#34;最终运行起来像蜗牛一样慢，那么恭喜你，你的分布式系统是失败的。</p><p>\t 2. 服务透明性 分布式系统对于用户来说是完全透明的，因为用户他面对的是一个完整的系统，不是一个又一个拆分的系统，一个分布式系统在用户面前的表现，就应该像一个完整的传统的单处理机分时系统一样，让用户完全不必了解系统的内部结构。</p><p>\t 3. 扩展性 分布式系统的最大特点就是系统的扩展性的提升，<b>对于一个系统提升扩展的手段，无非就是：分块分层，分布式，事件驱动架构， </b>但是可能能直接体现扩展性好处的，应该就是分布式。因为分布式系统，完全能够根据系统需求的增加而扩展新的子系统（组件），并且能够做到不会对原有系统造成任何影响</p><p>\t 4. 伸缩性 分布式系统一般在生产部署时，都需要结合服务器集群来提升系统的高性能，这同时也是它之所以能支持高并发或者大数据量处理能力的保证，它能够根据需求的增加而实现动态的扩展，既可以按照横向添加服务器节点数的方案来实现集群的整体性能得到线性提升，也可以通过纵向提升单台服务器的硬件来提升单台服务器处理能力（但 一般不推荐），使得服务器集群的性能得到提升。</p><p>\t 5. 可靠性  分布式系统一般是不会允许单点失效的问题出现，一般都是一个节点出现异常，其他的服务器节点补上，继续提供服务，保证服务的可靠性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>当然，分布式系统也是有它的弊端，那么主要集中体现在以下几个地方：</b></p><p>\t 1. 由于分布式系统需要结合服务器集群来做到以上的几个特性，这样带来的后果就是服务器节点多了，服务器是需要钱的，服务器与服务器之间通信需要网络传输，那么节点之间的网络通信也是需要花费开销的，而且线程安全的问题也会变得无比复杂，怎么样在保证系统数据完整的同时，又要去保证我们系统整体性能，就是一个我们不断需要考虑的问题</p><p>\t 2. 过于依赖网络传输，网络带宽的大小，网络数据的丢包，或者网络传输的稳定性等等的因素都会不断的困扰着我们。</p><p>\t 3. 潜在的数据安全和网络安全等安全性问题</p><h2><b>&#34;分布式系统&#34;与&#34;集中式系统&#34;的区别：</b></h2><p>        首先，需要我们明白一点，集中系统都是采用串行计算，而分布式系统采用并行计算，这是两者之间的最本质上的区别，集中系统，当然也是最节约公司成本的一种方式，将一个系统的所有功能都集中式的在同一个系统里面，然后在单台服务器上部署运营，但是这种系统往往最大的特点就是：<b>业务简单，并发量低，数据量不大……,</b>此时选择集中式开发模式是最为有利的。</p><p>\t但是一旦业务复杂了，业务量庞大了，而且业务量在分布时并且出现了较大的差异了，数据量也随之增多了，那么就是我们需要考虑分布式的时候到了。分布式系统的整体性价比高，公司一般在部署分布式时，都拒绝购买高昂服务器，高昂软件工具，都是选择成本较低的普通PC服务器，或者免费开源的一些软件开发工具或者技术，<b>其目的很明确，就是为了节约公司成本。</b></p><p>\t所以分布式系统集群中，最节约成本的办法就是使用集中在一起的大量的廉价的服务器，然后将负载通过一些&#34;负载均衡&#34;手段，分散到众多的服务器身上，当单台服务器出现异常，还有其他的服务器能够正常提供服务。并且我们可以根据业务量的变化，动态的向服务器集群中添加服务器节点，最后，从服务器整体性能上来讲，分布式集群系统的计算能力远超过单台服务器。</p>", 
            "topic": [
                {
                    "tag": "软件开发", 
                    "tagLink": "https://api.zhihu.com/topics/19552332"
                }, 
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38510768", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 4, 
            "title": "5分钟图文并茂看懂WEB程序中“会话机制”、“登录机制”", 
            "content": "<p> 最近为了学生扩展，整理“单点登录”的东西，在整理的过程中，发现很多学生依旧对WEB程序的“会话机制”、“登录机制”概念模糊不清，完全不知道什么意思，或者知道浏览器与服务器之间，是采用cookie结合session的方式来完成对“应用状态”的维护，但是不知道是怎么维护的？这就很尴尬……</p><p>今天特意以图形结构的方式，给大家做个详细的介绍：</p><h2><b>WEB程序的“会话机制”：</b></h2><p><b>首先，我们简单回顾一下，WEB程序到底是如何采用cookie加Session来进行“应用状态”维护的：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f9713b11801df390abe4377d976f5ab7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1290\" data-rawheight=\"1065\" class=\"origin_image zh-lightbox-thumb\" width=\"1290\" data-original=\"https://pic4.zhimg.com/v2-f9713b11801df390abe4377d976f5ab7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1290&#39; height=&#39;1065&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1290\" data-rawheight=\"1065\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1290\" data-original=\"https://pic4.zhimg.com/v2-f9713b11801df390abe4377d976f5ab7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f9713b11801df390abe4377d976f5ab7_b.jpg\"/></figure><p>在这张图中，我将一个用户访问系统的过程，详细的进行了阐述，过程我们总结出来，大体可以分为以下几个步骤：</p><p>1、用户使用浏览器， 初次访问系统，比如地址是：<a href=\"https://link.zhihu.com/?target=http%3A//www.lovo.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">lovo.com</span><span class=\"invisible\"></span></a>或者是<a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a></p><p>这个时候，由于用户是初次访问系统，无论浏览器中，还是在后台服务器都没有任何关于“应用状态”的数据</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7b8a108833810efbe93f4f0324f35de8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-7b8a108833810efbe93f4f0324f35de8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-7b8a108833810efbe93f4f0324f35de8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7b8a108833810efbe93f4f0324f35de8_b.jpg\"/></figure><p>2、用户的初次请求，到达后台服务器之后，后台服务器将在WEB容器中，对应的给该用户创建一个会话，我们也称之为session对象，<b>记住：每个用户都有一个独特的session对象，并不是说后台只有一个session</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-516cd728b194295c820276f6d6d74829_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"579\" data-original=\"https://pic2.zhimg.com/v2-516cd728b194295c820276f6d6d74829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;579&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"579\" data-original=\"https://pic2.zhimg.com/v2-516cd728b194295c820276f6d6d74829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-516cd728b194295c820276f6d6d74829_b.jpg\"/></figure><p>3、后台服务器创建好session对象之后，将session对应的JSESSIONID存入到response对象的cookie数组中，然后将JSESSIONID随着response响应对象，回到浏览器。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4、浏览器将JSESSIONID以K-V键值对结构的方式，存储在浏览器的cookie目录中去</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d6bffddff0a3afd97ccb5972359ee619_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"568\" data-original=\"https://pic2.zhimg.com/v2-d6bffddff0a3afd97ccb5972359ee619_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;568&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"568\" data-original=\"https://pic2.zhimg.com/v2-d6bffddff0a3afd97ccb5972359ee619_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d6bffddff0a3afd97ccb5972359ee619_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>5、浏览器再次访问后台服务器时，从此以后就可以从cookie中获取到JSESSIONID了，然后每次请求都将对应的JSESSIONID封装在“请求头”中，向后台进行传输，传输到后台之后，后台需要针对该JSESSIONID进行查找，看是否有该JSESSIONID所对应的session实例存在。</p><p>如果没有，则代表：用户长时间没操作，后台服务器已经将session对象销毁掉了，会话超时，这个时候需要用户做的事情是，重新访问我们的系统，一般都是重新回到登录页面，重新登录。当然，如果JSESSIONID所对应的session实例依旧存在，那么会话继续。</p><p><b>上述，就是浏览器与后台服务器之间，如何采用cookie和session进行“应用状态”的维护。</b></p><h2><b>WEB程序的“登录机制”：</b></h2><p>当然，我们大家在看懂了“会话机制”之后，再来看“登录机制”就很简单了</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10472831dedaa50a29e4cdf908df9c7d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1290\" data-rawheight=\"1263\" class=\"origin_image zh-lightbox-thumb\" width=\"1290\" data-original=\"https://pic2.zhimg.com/v2-10472831dedaa50a29e4cdf908df9c7d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1290&#39; height=&#39;1263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1290\" data-rawheight=\"1263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1290\" data-original=\"https://pic2.zhimg.com/v2-10472831dedaa50a29e4cdf908df9c7d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-10472831dedaa50a29e4cdf908df9c7d_b.jpg\"/></figure><p>同样，我们根据这个图来进行过程讲解，大体可以分为以下几个步骤：</p><p>1、用户初次访问我们系统，并随着后台服务器产生的初次响应得到JSESSIONID，然后用户进入到“登录页面”，并且在登录页面中录入数据（用户名，密码），然后点击登录</p><p><b>注：</b><i>登录请求，往往并非是访问系统的第一个请求，所以JSESSIONID，不一定就是登录请求/响应得到的，所以登录请求中，大家通过F12查看请求，会发现同样携带的有JSESSIONID</i></p><p>2、后台服务器根据得到的数据，查询数据库，校验“用户名”、“密码”的正确性</p><p>3、如果校验成功，那么在登录方法中，一般都需要执行以下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">session.setAttribute(&#34;user&#34;,user)</code></pre></div><p>将用户信息，存放入session对象的作用域中，当然校验失败，一切回顾原点，</p><p><b>注：</b><i>任何请求，一般都需要经过“状态过滤器”，但是在状态过滤器中，一般针对“登录请求”都是直接放行</i></p><p>4、系统服务器返回“登录响应”</p><p>5、用户登录成功之后，会继续访问我们的系统，这样就不可避免的需要产生一系列请求，这些请求在到达后台系统时，除了携带数据以外，还需要携带JSESSIONID</p><p>6、后台系统得到JSESSIONID之后，先去在WEB容器中去校验JSESSIONID对应的session是否存在，如果不存在，则代表：会话超时，需要重新登录</p><p>7、会话校验成功之后，再次对“用户登录状态”进行校验，通常这个工作都是在“状态过滤器”中完成</p><div class=\"highlight\"><pre><code class=\"language-text\">UserInfo user = sesssion.getAttribute(&#34;user&#34;);\nif(user == null)return &#34;&#34;;//重定向到登录页面</code></pre></div><p>8、后台系统经过“用户登录状态”校验之后，调用业务方法，完成业务逻辑，最后返回浏览器响应</p><p>实际上，后续的任何请求，都是遵循5-到-8之间的过程</p><p><b>所以，web服务器维护“应用状态”的手段，真的不复杂，你认为呢？</b></p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "Java EE", 
                    "tagLink": "https://api.zhihu.com/topics/19620553"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38458227", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 6, 
            "title": "生产环境，如何实现Netty框架高性能以及高可用？", 
            "content": "<h2><b>Netty框架实现高性能以及高可用架构图：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed6e88cbc77c1e4277ad82ed5e86b57e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"925\" data-original=\"https://pic3.zhimg.com/v2-ed6e88cbc77c1e4277ad82ed5e86b57e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;925&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"925\" data-original=\"https://pic3.zhimg.com/v2-ed6e88cbc77c1e4277ad82ed5e86b57e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed6e88cbc77c1e4277ad82ed5e86b57e_b.jpg\"/></figure><p>在讲解这张架构图之前，先说明几个概念：</p><p><b>高性能：</b></p><p>很多地方都提到过这个词语，那到底什么是“高性能”呢？通常在现实生活中，比如：我们大家买一台电脑，销售人员都会给我们推荐不同配置下，不同的电脑它们的性能也不同；建筑工地上，一个瘦弱的人，与一个强壮的人，他们同时搬砖，但是强壮的人，一定比瘦弱的人，速度更快，效率更高；那么在我们WEB项目开发中，用于部署我们软件的电脑（服务器），同样也是这样的道理，只不过此时我们更加关注的是这台电脑，能同时或者最大可以处理多少个并发请求。<b>能同时并发处理更多请求的服务器，它的性能一定更高！</b></p><p><b>那是不是要求我们在选择服务器时，就一定要选择配置最好的，价钱最高的呢？</b></p><p><b>答案：</b>绝对不是，软件开发是一个需要成本的事情，不到万不得已的地步，我们一定不会去选择“收费的”技术，“收费的”框架，“价钱特别昂贵的”服务器。其原因可能更多的是为老板或者是甲方，节约成本。毕竟谁也不想，一个价值50万的项目，在产品还未正式上线之前，就消耗100万……</p><p>那怎么办呢？ 业界常流行这样一句话“<b>当1头牛耕不动地的时候，或者耕不完地的时候，我们绝对不会去花费大价钱去购买一头更加强壮的牛，而是去多购买几头廉价的牛，让他们一起耕地</b>”，假设：大家想想一下，1头牛平均每天耕地2亩，那么10头就是20亩，可能买1头强壮的牛，最多也就是耕地5亩 （除非有划时代的产品出现……）</p><p>所以，为了让我们的系统能够在单位时间范围内，支持更多的并发请求，我们更多的选择是去购买或者租赁较为便宜的服务器，让它们构成一个群体，整体去提供服务，当然这个群体，我们常称为“<b>集群</b>”。</p><p><b>高可用：</b></p><p>所谓的高可用，实际上更多的是“集群”或者“冗余”的一种体现，当系统未做集群或者冗余技术之前，很多的情况下，我们很多的软件都会部署到同一台，或者是有限的几台电脑上，但是电脑这个东西，很容易就会出现一些莫名其妙的问题，或者是由于服务器硬件配置导致的各种容量不足等问题。这时，电脑就会经常会出现“死机”“长时间未响应”，以及“关机”等各种可怕的问题，而且还不是大家重启一下电脑，就可以轻松解决的问题。</p><p>当电脑出现这些问题之后，我们的系统在问题解决之前，这段时间都是“不可用的”，这就很可怕了，想想一下“淘宝”，“京东”如果他们的系统长时间未响应，这是一个什么后果……</p><p>当然业界也有评比的标准，就是按照时间来算，全年能有多少时间，系统正常。这个评比一般都是以9为单位进行评比，比如：99%，99.99%……  9越多，代表这个系统在一年的时间范围内，就有更多的时间，系统是能够正常访问的……</p><p><b>常见的实现高可用手段：</b>集群（1头牛病了，还有其他的牛可以正常工作）、冗余（1头牛上班，另外1头休息，当生病等情况出现时，休息的这头牛赶紧顶上，继续工作）</p><blockquote><b>在开发任何系统的时候，我们大家一定要有一个共同的认知，那就是：“我们需要保证，在任何情况下，这个系统都要尽可能的保证它能正常运行，只要它能正常运行，那就是成功的……”</b> </blockquote><hr/><p>当然，我们这里为了保证“netty”框架开发的“数据中心”，能够保证更多的并发请求，能够保证任何情况下，都能正常提供服务，我们也需要使用到“集群”，以及“冗余”方案：</p><p><b>首先，我们需要做的第一件事情是：</b></p><p>在较多的PC服务器，或者是租赁的“云服务器”上，为“数据中心”开发一定的端口，然后在服务器上去部署我们的“数据中心”，并且保证每一个都能正常运行……</p><p>并且，由PC服务器或者租赁的“云服务器”，构成的集群圈，最好是内网环境，大家位于同一个网段。一般我们为了安全性考虑，也不会将系统软件所在的服务器直接暴露在外！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c272ba5fa6b6ef9ea6471cebcbf221a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1207\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"1207\" data-original=\"https://pic2.zhimg.com/v2-c272ba5fa6b6ef9ea6471cebcbf221a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1207&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1207\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1207\" data-original=\"https://pic2.zhimg.com/v2-c272ba5fa6b6ef9ea6471cebcbf221a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c272ba5fa6b6ef9ea6471cebcbf221a5_b.jpg\"/></figure><p><b>第二个步骤，则是采用HAproxy完成负载均衡，以及采用Keepalive完成服务器“冗余”的实现：</b></p><p>完成第一个步骤之后，此时我们的“数据中心”服务器集群中，所有的服务器都可以正常给“客户端”提供服务，但是具体如何提供，还需要一个“负载均衡”服务器来实现。</p><p><b>负载，</b>实际上就是由客户端发送到“数据中心”服务器的连接，当客户端过多以后，连接就会非常多，给服务器造成的压力也就会非常大。</p><p>所谓的“<b>均衡</b>”，就是在采用某种方式（随机、轮询、IP粘贴……），完成负载的一个较为平均的分配。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f34d9892a27af1b8067f9018d237832a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"540\" data-original=\"https://pic3.zhimg.com/v2-f34d9892a27af1b8067f9018d237832a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;540&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"540\" data-original=\"https://pic3.zhimg.com/v2-f34d9892a27af1b8067f9018d237832a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f34d9892a27af1b8067f9018d237832a_b.jpg\"/></figure><p>请求在主服务器接收到以后，采用一些算法，较为平均的将请求，分配到后端的普通PC服务器上。</p><p>但是我们为了保证“<b>主服务器</b>”的可用性，所以我们不可避免的需要给主服务器，要么做集群，要么就需要做“冗余服务器”，所谓的“<b>冗余</b>”，就是指<i>平时我不管你，但你一出问题，我就立马替代你</i>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-004221040e105a1e5652bdc287cc0a14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb\" width=\"869\" data-original=\"https://pic1.zhimg.com/v2-004221040e105a1e5652bdc287cc0a14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;869&#39; height=&#39;406&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"869\" data-rawheight=\"406\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"869\" data-original=\"https://pic1.zhimg.com/v2-004221040e105a1e5652bdc287cc0a14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-004221040e105a1e5652bdc287cc0a14_b.jpg\"/></figure><p>“<b>冗余服务器</b>”，需要采用keepalive技术来实现，keepalive可以在主服务器之外，再去设置一个“备份服务器”，“备份服务器”平时不需要做事情，只需要随时去监管一下“主服务器”是否正常即可。只要“主服务器”失去正常工作的能力之后，keepalive才会激活“备份服务器”，让“备份服务器”代替“主服务器”正常工作（<b>这个过程，也被称之为：失效转移机制</b>）。</p><p>keepalive会在“主服务器”与“备份服务器”之前，虚拟出一个新的服务器，也就是可以虚拟出一个新的IP地址，让我们可以正常使用。所以我们客户端，一般都是连接“虚拟出来的IP地址”，然后与我们的真实服务器进行数据通信。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>整体来说：</b>我们为了实现“数据中心”高性能以及高可用，必须要采用的方案，就是集群以及冗余，当然要考虑这样的方案，还是那句话“具体情况，具体分析”，如果客户端并不多，同时在线的客户端并不多的情况下，我认为还是没什么必要去做这一套东西。</p><p>当然，我这篇文章中，并未告诉大家，如何配置HAProxy，如何配置keepalive，这些网上示例现成，大家可以直接搜索，如果有疑问，也可以留言。但至少给大家提供了一个解决问题的方案，不是？</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "网络编程", 
                    "tagLink": "https://api.zhihu.com/topics/19611616"
                }, 
                {
                    "tag": "Io（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/20087899"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38357640", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 12, 
            "title": "面试经典问题，谈谈你对OOA,OOD,OOP的理解", 
            "content": "<p> OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程），这3个概念，对于我们JAVA程序员来讲，或多或少应该都有所了解，或者说至少都听说过。但是要谈到对其理解，可能对于多数入行不深的从业者来说，确实不是那么容易做到。特别是对于绝大多数的3年以内的低中级软件工程师而言。因为他们的工作更多是需要按照项目经理分配的任务来编写功能代码，很少有多余的时间去阅读或者思考一些概念性的东西。说起这个问题，我也在网络上也搜索过很多的资料，大多摘录至书籍，比较官方化。让初学者无从理解。<br/>为了广大的新从业者或者应聘者，在这里，我们以一种实例的方式来对这3个概念进行重新的阐述：<br/></p><p><b>业务场景：</b><br/>建行卡持有者，张三与李四两人，现在需要张三给李四转账人民币5000元整。按照业务分析后的流程图如下:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d19035ba8046f9ee108002f28343a588_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1043\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb\" width=\"1043\" data-original=\"https://pic1.zhimg.com/v2-d19035ba8046f9ee108002f28343a588_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1043&#39; height=&#39;550&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1043\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1043\" data-original=\"https://pic1.zhimg.com/v2-d19035ba8046f9ee108002f28343a588_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d19035ba8046f9ee108002f28343a588_b.jpg\"/></figure><h2><b>对于分析业务流程，常见的2种：面向过程分析（POA），面向对象分析（OOA）</b></h2><p><b>面向过程分析</b>（Procedure Oriented Analysis）：是一种以过程为中心的编程思想，以数据流向为主要导向。为了解决问题，将解决问题的业务过程，按照一定的顺序划分成为一个又一个的事件，然后再封装成一个又一个的函数，最后由一个函数统一的按照顺序一步一步的调用即可。在面向过程分析中，顺序很重要，要实现功能只需要按照一定的顺序相互调用函数即可。</p><p>上述业务场景按照面向过程分析出来的结果就是：</p><ol><li>程序检查张三卡中余额是否足够5000元人民币（事件1，满足则调用事件2）</li><li>程序从张三卡中扣除5000元人民币（事件2）</li><li>程序向李四卡中加入5000元人民币（事件3）</li><li>程序检测李四卡中是否正常入账（事件4，满足则结束整个业务）</li><li>程序向张三卡中加入5000元人民币（事件5）</li></ol><p>在上述过程中，我们将这个业务过程，分成了5个步骤，也叫做5个事件，那么如果需要在程序中完成该转账业务的话，那么我们只需要按照1-2-3-4-5这样的顺序依次调用函数方法即可。在这个过程中，你会发现我们函数调用的顺序一定是不能变化的，变了就出问题了……</p><p><b>面向对象分析</b>（Object Oriented Analysis）:是一种以对象为中心的编程思想。利用从问题域中的词汇表中找到类与对象。那么说到这里，很多人对问题域又不是很清楚了，问题域：说的简单直接一点，问题域就是客户告诉你的要求，他要干什么。问题域并不特指需求，很多时候，客户所提的需求很多地方都有关联，所以在很多场合，客户所提的需求，还需要需求分析师多角度的帮助客户理清与完善。那么在客户需求范围中，衍生出来的他想要告诉你做的事，就是问题域，包括后期需求发生的变化，同样隶属于问题域的范围。<br/>用一个图来表示：需求分析文档，规格说明文档，以及程序之间的关系：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f64a9e894b4e373f18b249d826151d04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb\" width=\"666\" data-original=\"https://pic1.zhimg.com/v2-f64a9e894b4e373f18b249d826151d04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;666&#39; height=&#39;243&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"666\" data-original=\"https://pic1.zhimg.com/v2-f64a9e894b4e373f18b249d826151d04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f64a9e894b4e373f18b249d826151d04_b.jpg\"/></figure><p>从上述业务场景的分析中，我们可以抽离出的类与对象有：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eebc1963a41d0427aa3697ca83957c3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb\" width=\"433\" data-original=\"https://pic3.zhimg.com/v2-eebc1963a41d0427aa3697ca83957c3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;433&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"433\" data-original=\"https://pic3.zhimg.com/v2-eebc1963a41d0427aa3697ca83957c3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-eebc1963a41d0427aa3697ca83957c3a_b.jpg\"/></figure><p>抽离出来的类型有：汇钱者类，收钱者类，货币类。而张三只能算是汇钱者类中的一个实例，也被称之为汇钱者对象，李四只能算是一个收钱者类中的一个实例，也被称之为收钱者对象。那么额度为5000的人民币也只是货币类的一个具体实例。通常汇钱者类，收钱者类，货币类，我们都统一称之为：领域模型类，张三，李四，5000元人民币我们都统一称之为：领域对象。作为面向对象分析来说，我们最为重要的就是要分析出领域对象的行为。领域对象的行为主要是为后期的<b>面向对象设计</b>（OOD）提供接口依据，而属性作为分析阶段不是我们的重点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8db950bc0be36ecd94a4463ca5f55625_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"861\" data-original=\"https://pic2.zhimg.com/v2-8db950bc0be36ecd94a4463ca5f55625_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;861&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"861\" data-original=\"https://pic2.zhimg.com/v2-8db950bc0be36ecd94a4463ca5f55625_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8db950bc0be36ecd94a4463ca5f55625_b.jpg\"/></figure><p>就上述3种领域对象而言，张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。</p><p>李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中。而5000元人民币只是数据的传输携带者，没有任何行为可言。</p><h2><b>在JAVAEE项目中，组织业务逻辑的方式：事务脚本（面向过程设计 POD）、领域模型（面向对象设计 OOD）</b></h2><p><b>事务脚本（面向过程设计 POD）：</b>它是纯面向过程的一种组织业务逻辑的方式，在JAVAEE项目，是一种非常常见的设计方式，做法很简单，将POA分析后的结果封装成JAVA对应的方法即可，然后在业务层中统一按照顺序调用接口。将领域对象（人民币）去掉行为，只保留属性即可，用于数据传输。以数据流向为主要导向。</p><p>按照上述的业务场景来设计：保留失去行为的领域对象（人民币），同时抽离出一个业务层的接口类，多个持久层的数据访问接口类，在业务层接口中提供一个统一的业务调用方法transferAccount(),在数据库发生关系的持久层，提供一系列事件方法：queryBalance(),reduceBalance(),increaseBalance();使用UML类图表示为：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b30580dda8a342138315340dd34071ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"891\" class=\"origin_image zh-lightbox-thumb\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-b30580dda8a342138315340dd34071ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1200&#39; height=&#39;891&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1200\" data-rawheight=\"891\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1200\" data-original=\"https://pic4.zhimg.com/v2-b30580dda8a342138315340dd34071ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b30580dda8a342138315340dd34071ef_b.jpg\"/></figure><p>当然还有一系列的表示手段，比如：包图，对象图，序列图，用例图…… 这里就不一一设计了。</p><p><b>领域模型（面向对象设计 OOD）</b>（Object Oriented Design）：主要是正确有效的构造出复杂系统的抽象结构，将<b>面向对象分析</b>后的结果，作为面向对象设计的模型，通常用于展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）。将OOA分析的结果作进一步的规范化整理，以便能够被OOP直接接受。</p><p>概念可能比较生硬，那么说的直白点，设计阶段的任务就是：</p><ol><li>按照面向对象的方式将系统分解成不同的模块化，或者系统再次划分为子系统，直到划分到可设计的最小粒度为止【垂直分块，水平分层】。</li><li>使用不同的表示方法来展示被设计系统的逻辑模型（业务逻辑如何设计），物理模型（系统如何划分，层次如何划分，如何部署……），静态模型（组成系统的元素：类，接口）和动态模型（对象的调用……）【常用的表示法手段：UML各种图形】。</li></ol><p><b>需要注意的是：</b>层次结构并非就一定是三层结构，也可以是多层，具体分几层需要根据项目的复杂度来决定，如果没有过多的业务逻辑，只有简单的CRUD的话，那么三层结构足以应付一切。</p><p>按照上述的业务场景来设计：对于领域逻辑来说，三层结构就不能满足其业务逻辑复杂度了，可能这时整个系统可能是四层，五层，或者多层……，我们这个例子，暂时定为四层结构：控制层、业务层、领域逻辑层、数据访问层。在设计领域对象时，保留失去行为的领域对象（人民币），转钱对象，收钱对象，同时抽象出一个业务层的业务接口用于简单的调度业务逻辑，多个持久层的数据访问接口类。</p><p>在OOA阶段，我们分析出张三这个实例，可以查询自己卡中余额，可以从余额中取出5000元，也可以将外来的钱加入到自己的账户中。那么它就应该对应着对应的3种行为方法。<br/>李四这个实例，可以查询自己卡中余额，可以将外来的钱加入到自己的账户中，那么它就应该对应着对应的2种行为方法。而5000元人民币只是数据的传输携带者，没有任何行为可言</p><p>如果采用UML中类图的表示法来看，图形应该如下：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-04dc71cae327acca37b13a490f595f7c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"1239\" class=\"origin_image zh-lightbox-thumb\" width=\"1061\" data-original=\"https://pic1.zhimg.com/v2-04dc71cae327acca37b13a490f595f7c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1061&#39; height=&#39;1239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1061\" data-rawheight=\"1239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1061\" data-original=\"https://pic1.zhimg.com/v2-04dc71cae327acca37b13a490f595f7c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-04dc71cae327acca37b13a490f595f7c_b.jpg\"/></figure><p><br/>（在同一个图中，相同名称的元素代表同一元素）<br/>在这张图中，我们的层次就是4层结构，甚至我们还可以再分为5层，6层等，所以一般领域模型适用于业务需求较为复杂的情况。业务层仅仅是为了梳理业务流程，而真正的业务逻辑则交由领域层的领域对象之间相互调用对方的方法来实现业务逻辑。比如要转钱，就需要转钱者领域对象，减少自己的余额后，调用收钱者领域对象，添加自己的余额。当然真正的银行转钱复杂度，绝对远高于这个场景。 还需要使用到事件驱动模型，以及消息队列等一系列的技术，当然具体情况具体分析。</p><h2><b>面向对象编程（OOP）</b></h2><p>面向对象编程（Object Oriented programming）：将面向对象设计后的抽象，采用面向对象的方式来实现的方法，就叫做面向对象编程。在这种方法中，程序被组织成许多相互协作的对象，每个对象都是一个类的实例。利用对象构成业务逻辑的组成基本元素（组合模式的层次结构），而不是采用算法。组成程序的基本元素是一个又一个的基础组件（类），那么组件就是我们层次结构所对应的接口或接口的实现类，那么程序就是由一个又一个实现类的实例相互协作来完成业务逻辑的实现。</p><p><b>总体来说：</b> 面向对象分析的结果可以作为面向对象设计的模型，而面向对象设计的结果则可以作为面向对象编程的蓝图，应用程序需要由编程才能实现。</p><p></p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38354881", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 2, 
            "title": "Netty框架，实现定长时间无交互，自动断开客户端连接", 
            "content": "<p>在《使用Netty框架，到底选择长连接模式还是短连接模式？》文章中，在写到长连接和短连接选择的过程中，有一种比较特殊的长连接情况需要考虑：</p><p>在一段时间范围内，客户端与“数据中心”的交互非常频繁，而过了这段时间，可能很长一段时间范围内，两者之间都不会有任何交互。那么这种情况下，如果需要仍旧保持连接的通畅，对于“数据中心”来讲，实际上是一种不必要的性能浪费。毕竟“数据中心”对应的服务器需要去维护这些无用的连接。</p><p><b>那么最好的解决方案：</b>就是“数据中心”在一定时间范围内，对于某根连接，监听发现长时间并未有有效数据上传，就主动断开连接，或者客户端主动断开连接    （节约“数据中心”服务器性能消耗）</p><p><b>代码实现如下：</b></p><p>首先定义服务器代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\nimport io.netty.handler.timeout.ReadTimeoutHandler;\n/**\n * 服务端接送类\n * @author Administrator\n *\n */\npublic class Server {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t\n\t\tEventLoopGroup pGroup = new NioEventLoopGroup();\n\t\tEventLoopGroup cGroup = new NioEventLoopGroup();\n\t\t\n\t\tServerBootstrap b = new ServerBootstrap();\n\t\tb.group(pGroup, cGroup)\n\t\t .channel(NioServerSocketChannel.class)\n\t\t .option(ChannelOption.SO_BACKLOG, 1024)\n\t\t //设置日志\n\t\t .handler(new LoggingHandler(LogLevel.INFO))\n\t\t .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\t\n\t\t\t\t//实现5秒钟，如果两端，如果数据读取，直接断开连接\n\t\t\t\tsc.pipeline().addLast(new ReadTimeoutHandler(5));\n\t\t\t\t\n\t\t\t\t//实现5秒钟，如果两端，如果数据写入，直接断开连接\n\t\t\t\t//sc.pipeline().addLast(new WriteTimeoutHandler(5));\n\t\t\t\t\n\t\t\t\tsc.pipeline().addLast(new ServerHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\tChannelFuture cf = b.bind(8765).sync();\n\t\t\n\t\tcf.channel().closeFuture().sync();\n\t\tpGroup.shutdownGracefully();\n\t\tcGroup.shutdownGracefully();\n\t\t\n\t}\n}\n</code></pre></div><p>然后定义服务器信息处理类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n\npublic class ServerHandler extends ChannelHandlerAdapter{\n\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tRequest request = (Request)msg;\n\t\tSystem.out.println(&#34;Server : &#34; + request.getId() + &#34;, &#34; + request.getName() + &#34;, &#34; + request.getRequestMessage());\n\t\tResponse response = new Response();\n\t\tresponse.setId(request.getId());\n\t\tresponse.setName(&#34;response&#34; + request.getId());\n\t\tresponse.setResponseMessage(&#34;响应内容&#34; + request.getId());\n\t\tctx.writeAndFlush(response);//.addListener(ChannelFutureListener.CLOSE);\n\t}\n\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\t\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tctx.close();\n\t}\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>定义客户端信息请求实体类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport java.io.Serializable;\n\npublic class Request implements Serializable{\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 4019165376582639604L;\n\t\n\tprivate String id ;\n\tprivate String name ;\n\tprivate String requestMessage ;\n\t\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getRequestMessage() {\n\t\treturn requestMessage;\n\t}\n\tpublic void setRequestMessage(String requestMessage) {\n\t\tthis.requestMessage = requestMessage;\n\t}\n}\n</code></pre></div><p>定义“数据中心”服务端响应实体类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport java.io.Serializable;\n\npublic class Response implements Serializable{\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate String id;\n\tprivate String name;\n\tprivate String responseMessage;\n\t\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getResponseMessage() {\n\t\treturn responseMessage;\n\t}\n\tpublic void setResponseMessage(String responseMessage) {\n\t\tthis.responseMessage = responseMessage;\n\t}\n}\n</code></pre></div><p>定义JBoss Marshalling解码器代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport io.netty.handler.codec.marshalling.DefaultMarshallerProvider;\nimport io.netty.handler.codec.marshalling.DefaultUnmarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallingDecoder;\nimport io.netty.handler.codec.marshalling.MarshallingEncoder;\nimport io.netty.handler.codec.marshalling.UnmarshallerProvider;\n\nimport org.jboss.marshalling.MarshallerFactory;\nimport org.jboss.marshalling.Marshalling;\nimport org.jboss.marshalling.MarshallingConfiguration;\n\n/**\n * 采用Jboss Marshalling解码器 完成JAVA对象序列化\n * @author Administrator\n *\n */\npublic final class MarshallingCodeCFactory {\n\n    /**\n     * 创建Jboss Marshalling解码器MarshallingDecoder\n     * @return MarshallingDecoder\n     */\n    public static MarshallingDecoder buildMarshallingDecoder() {\n    \t//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\t//创建了MarshallingConfiguration对象，配置了版本号为5 \n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\t//根据marshallerFactory和configuration创建provider\n\t\tUnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度\n\t\tMarshallingDecoder decoder = new MarshallingDecoder(provider, 1024*1024*1);\n\t\treturn decoder;\n    }\n\n    /**\n     * 创建Jboss Marshalling编码器MarshallingEncoder\n     * @return MarshallingEncoder\n     */\n    public static MarshallingEncoder buildMarshallingEncoder() {\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\tMarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组\n\t\tMarshallingEncoder encoder = new MarshallingEncoder(provider);\n\t\treturn encoder;\n    }\n}\n</code></pre></div><p>定义客户端连接类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\n\n/**\n * 客户端连接类\n * @author Administrator\n *\n */\npublic class Client {\n\t\n\tprivate static class SingletonHolder {\n\t\tstatic final Client instance = new Client();\n\t}\n\t\n\tpublic static Client getInstance(){\n\t\treturn SingletonHolder.instance;\n\t}\n\t\n\tprivate EventLoopGroup group;\n\tprivate Bootstrap b;\n\tprivate ChannelFuture cf ;\n\t\n\tprivate Client(){\n\t\t\tgroup = new NioEventLoopGroup();\n\t\t\tb = new Bootstrap();\n\t\t\tb.group(group)\n\t\t\t .channel(NioSocketChannel.class)\n\t\t\t .handler(new LoggingHandler(LogLevel.INFO))\n\t\t\t .handler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t\t\t@Override\n\t\t\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\t\t\t\n\t\t\t\t\t\t//客户端，同样可以做定长时间，自动断开连接操作\n\t\t\t\t\t\t//实现5秒钟，如果两端，如果数据读取，直接断开连接\n\t\t\t\t\t\t//sc.pipeline().addLast(new ReadTimeoutHandler(5));\n\t\t\t\t\t\t//实现5秒钟，如果两端，如果数据写入，直接断开连接\n\t\t\t\t\t\t//sc.pipeline().addLast(new WriteTimeoutHandler(5));\n\t\t\t\t\t\t\n\t\t\t\t\t\tsc.pipeline().addLast(new ClientHandler());\n\t\t\t\t\t}\n\t\t    });\n\t}\n\t\n\tpublic void connect(){\n\t\ttry {\n\t\t\tthis.cf = b.connect(&#34;127.0.0.1&#34;, 8765).sync();\n\t\t\tSystem.out.println(&#34;远程服务器已经连接, 可以进行数据交换..&#34;);\t\t\t\t\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic ChannelFuture getChannelFuture(){\n\t\t\n\t\tif(this.cf == null){\n\t\t\tthis.connect();\n\t\t}\n\t\tif(!this.cf.channel().isActive()){\n\t\t\tthis.connect();\n\t\t}\n\t\t\n\t\treturn this.cf;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tfinal Client c = Client.getInstance();\n\t\t\n\t\tChannelFuture cf = c.getChannelFuture();\n\t\tfor(int i = 1; i &lt;= 3; i++ ){\n\t\t\tRequest request = new Request();\n\t\t\trequest.setId(&#34;&#34; + i);\n\t\t\trequest.setName(&#34;pro&#34; + i);\n\t\t\trequest.setRequestMessage(&#34;数据信息&#34; + i);\n\t\t\tcf.channel().writeAndFlush(request);\n\t\t\tTimeUnit.SECONDS.sleep(4);\n\t\t\tSystem.out.println(new Date());\n\t\t}\n\t\t\n\t\t//再等待2秒钟\n\t\tTimeUnit.SECONDS.sleep(2);\n\t\tRequest request = new Request();\n\t\trequest.setId(&#34;4&#34;);\n\t\trequest.setName(&#34;pro4&#34;);\n\t\trequest.setRequestMessage(&#34;数据信息4&#34;);\n\t\tcf.channel().writeAndFlush(request);\n\t\t\n\t\t\n\t\t//等待关闭连接\n\t\tcf.channel().closeFuture().sync();\n\t\tSystem.out.println(&#34;断开连接,主线程结束..&#34;);\t\n\t}\n}\n</code></pre></div><p>最后定义客户端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.runtime;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.ReferenceCountUtil;\n\npublic class ClientHandler extends ChannelHandlerAdapter{\n\t\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\ttry {\n\t\t\tResponse resp = (Response)msg;\n\t\t\tSystem.out.println(&#34;Client : &#34; + resp.getId() + &#34;, &#34; + resp.getName() + &#34;, &#34; + resp.getResponseMessage());\t\t\t\n\t\t} finally {\n\t\t\tReferenceCountUtil.release(msg);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\t\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tctx.close();\n\t}\t\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>客户端在连接时，在Client中向服务端发送内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-41f33ca5f65f40ea24a8f29f0d161d3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb\" width=\"932\" data-original=\"https://pic3.zhimg.com/v2-41f33ca5f65f40ea24a8f29f0d161d3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;932&#39; height=&#39;409&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"932\" data-original=\"https://pic3.zhimg.com/v2-41f33ca5f65f40ea24a8f29f0d161d3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-41f33ca5f65f40ea24a8f29f0d161d3a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b7a68973f55cdd6755fcf8543aaeee5f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"874\" data-original=\"https://pic4.zhimg.com/v2-b7a68973f55cdd6755fcf8543aaeee5f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;874&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"874\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"874\" data-original=\"https://pic4.zhimg.com/v2-b7a68973f55cdd6755fcf8543aaeee5f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b7a68973f55cdd6755fcf8543aaeee5f_b.jpg\"/></figure><p>服务端在创建通道信息时，添加的业务处理类有：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0a180e7251db8ffe5d350d999905c81f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1180\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"1180\" data-original=\"https://pic4.zhimg.com/v2-0a180e7251db8ffe5d350d999905c81f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1180&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1180\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1180\" data-original=\"https://pic4.zhimg.com/v2-0a180e7251db8ffe5d350d999905c81f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0a180e7251db8ffe5d350d999905c81f_b.jpg\"/></figure><p>当然，这个地方，具体使用5秒钟未读就断开连接，还是使用5秒钟未写就断开连接，或者两者都用，这是各位看官自己的事情，请酌情选择。</p><p>最后，得到的效果就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c7d24005feb89927a79bea572bc7b1a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1192\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb\" width=\"1192\" data-original=\"https://pic3.zhimg.com/v2-c7d24005feb89927a79bea572bc7b1a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1192&#39; height=&#39;528&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1192\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1192\" data-original=\"https://pic3.zhimg.com/v2-c7d24005feb89927a79bea572bc7b1a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c7d24005feb89927a79bea572bc7b1a2_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f59e3afe6714f6863ab50c44efedd999_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1217\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb\" width=\"1217\" data-original=\"https://pic2.zhimg.com/v2-f59e3afe6714f6863ab50c44efedd999_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1217&#39; height=&#39;379&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1217\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1217\" data-original=\"https://pic2.zhimg.com/v2-f59e3afe6714f6863ab50c44efedd999_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f59e3afe6714f6863ab50c44efedd999_b.jpg\"/></figure><p>由于客户端，在多条数据上传的过程中，使用了如下代码，让时间超过了5秒钟，所以“数据中心”服务器主动断开了连接</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8f485ea5c33a94d1d24ef281f9a064e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1254\" data-rawheight=\"572\" class=\"origin_image zh-lightbox-thumb\" width=\"1254\" data-original=\"https://pic2.zhimg.com/v2-8f485ea5c33a94d1d24ef281f9a064e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1254&#39; height=&#39;572&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1254\" data-rawheight=\"572\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1254\" data-original=\"https://pic2.zhimg.com/v2-8f485ea5c33a94d1d24ef281f9a064e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8f485ea5c33a94d1d24ef281f9a064e9_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "网络编程", 
                    "tagLink": "https://api.zhihu.com/topics/19611616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38326429", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "使用Netty框架，到底选择长连接模式还是短连接模式？", 
            "content": "<p>  在实际的项目开发环境中，我们使用netty框架进行“数据中心”的开发时，到底选择“长连接”，“短连接”模式中的哪一种？在创建连接时，到底需要设置哪些参数？我们设置的参数，服务器性能是否能够满足？ 这些问题，都是需要我们根据具体情况，去具体分析的。</p><p><b>那么我个人建议，如果有多台设备需要与“数据中心”进行交互时，需要考虑以下三点内容：</b></p><p><b>第一种情况：</b></p><p>服务器性能比较不错，同时客户端数量比较少的情况下，而且对“报文数据”实时性要求较高的情况下，建议使用“长连接”模式，也就是“数据中心”与设备之间的连接长时间保持开启状态</p><p><b>第二种情况：</b></p><p>对“报文数据”实时性要求不高，而且支持一次性批量提交数据的情况下，也就是比如：我们有些“数据缓冲区”，“数据库表”等等可以放置数据的地方，当数据量达到一定量以后，一次性需要提交到“数据中心”的场景下，又或者采用定时任务轮询提交的场景下，那么建议“数据中心”与设备之间最好保持“短连接”，提交一次断开一次连接，下次需要再提交时，再获取新的连接即可。</p><p><b>第三种情况：</b></p><p>一种比较特殊的长连接模式，在一段时间内，“数据中心”与设备之间数据交互频繁，但是过了这段时间，很长一段时间内，都没有任何数据需要交互的情况下，最好的办法就是：在交互频繁的那段时间，保持长连接 ，一旦过了那段时间，立马断开连接，下次需要交互时，再获取连接即可，这种方式，主要可以为“数据中心”服务器节省资源的浪费。</p><p>第三种情况的使用，需要考虑两个问题：</p><ul><li>如果客户端或者“数据中心”，连接超时，无数据交互后，如何去断开连接？</li><li>客户端主动断开连接，很好办，下次需要再连接即可，那么如果是“数据中心”主动断开连接了，客户端应该如何去与“数据中心”再次建立连接？</li></ul><p><b>长连接模式下，维护连接的方案：</b></p><p>如果是长连接的情况下，一般我们都需要做连接的维护工作，方案主要有以下两种：</p><p>1、客户端间隔5分钟，向服务器发起一次“心跳”报文，如果服务器正常回应，那就无所谓，如果不回应，一般就直接断开“连接”，然后重新向服务器再次申请新的连接即可。</p><p>2、客户端或者服务端开启一个定时任务，间隔5分钟，判断在这5分钟内，是否有向服务器交互数据，如果有交互，那么就继续维护这个连接，如果没有交互，那么就直接断开连接即可，下次再需要交互时，再向服务器申请新的连接即可。这样做的好处，是给服务器减压</p><p>客户端如果主动自己断开，这个一般不需要做特殊处理，直接在下次连接时，申请新的连接即可。</p><p>服务器如果自己因为什么原因，断开了，那么客户端，需要定义一个定时任务，间隔10分钟，或者多少时间，去不断的尝试服务器是否恢复。</p><p></p>", 
            "topic": [
                {
                    "tag": "Netty", 
                    "tagLink": "https://api.zhihu.com/topics/19732975"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "网络编程", 
                    "tagLink": "https://api.zhihu.com/topics/19611616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38320072", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 2, 
            "title": "Netty框架采用定时发送“心跳报文”，解决“心跳检测”问题", 
            "content": "<p>“数据中心”与硬件终端通信过程中，有的时候，建立的“连接”需要保持长时间的连接状态，当然，也有的“连接”不需要保持较长时间的连接状态。</p><p>在需要保持“长连接”的通信中，如何保证连接长时间处于连接状态，那么这个时候，就需要使用到“心跳检测”机制。由客户端，间隔一定时间，不间断的向“数据中心”发送请求，来保持连接的通畅，以及检测连接是否有效。</p><p><b>“心跳检测”的实现原理：</b></p><p>在客户端建立一个线程，间隔一定时间就向连接通道中，向“数据中心”发送 “心跳报文”，然后“数据中心”收到“心跳报文”后，立马向客户端发回响应 &lt;----- 重复</p><hr/><p><b>Netty框架，同样也是采用上述的机制，来实现“心跳检测”：</b></p><p>先定义服务端代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class Server {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t\n\t\tEventLoopGroup pGroup = new NioEventLoopGroup();\n\t\tEventLoopGroup cGroup = new NioEventLoopGroup();\n\t\t\n\t\tServerBootstrap b = new ServerBootstrap();\n\t\tb.group(pGroup, cGroup)\n\t\t .channel(NioServerSocketChannel.class)\n\t\t .option(ChannelOption.SO_BACKLOG, 1024)\n\t\t //设置日志\n\t\t .handler(new LoggingHandler(LogLevel.INFO))\n\t\t .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\tsc.pipeline().addLast(new ServerHeartBeatHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\tChannelFuture cf = b.bind(8765).sync();\n\t\t\n\t\tcf.channel().closeFuture().sync();\n\t\tpGroup.shutdownGracefully();\n\t\tcGroup.shutdownGracefully();\n\t\t\n\t}\n}\n</code></pre></div><p>服务端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport org.framestudy.netty.utils.StringUtils;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n\n/**\n * 服务端心跳维护处理类\n * @author Administrator\n *\n */\npublic class ServerHeartBeatHandler extends ChannelHandlerAdapter {\n\n\tprivate static final String SUCCESS_KEY = &#34;auth&#34;;\n\t/**\n\t * 认证这个地方，请自己按照自己的业务，重新设计\n\t * @param ctx\n\t * @param msg\n\t * @return\n\t * @throws Exception\n\t */\n\tprivate boolean auth(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tString body = (String) msg;\n\t\t//IP地址不为空，既为认证信息\n\t\tif (!StringUtils.isEmpty(body)) {\n\t\t\tctx.writeAndFlush(SUCCESS_KEY);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tif (msg instanceof String) {\n\t\t\tauth(ctx, msg);\n\t\t} else if (msg instanceof HeartInfo) {\n\t\t\t//解析心跳数据\n\t\t\tHeartInfo info = (HeartInfo) msg;\n\t\t\tSystem.out.println(&#34;Server ：&#34; + info);\n\t\t\tctx.writeAndFlush(&#34;Server ：info received!&#34;);\n\t\t}\n\t}\n\n}</code></pre></div><p>字符串工具类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.utils;\n/**\n * String字符串处理工具类\n * @author Administrator\n *\n */\npublic class StringUtils {\n\t/**\n\t * 判断字符串是否为空\n\t * @param string\n\t * @return\n\t */\n\tpublic static boolean isEmpty(String string) {\n\t\tif(string == null || &#34;&#34;.equals(string)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n</code></pre></div><p>定义客户端心跳数据实体对象：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport java.io.Serializable;\n/**\n * 心跳数据\n * @author Administrator\n *\n */\npublic class HeartInfo implements Serializable {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String heartInfo ;\n\t//.. other field\n\tpublic String getHeartInfo() {\n\t\treturn heartInfo;\n\t}\n\tpublic void setHeartInfo(String heartInfo) {\n\t\tthis.heartInfo = heartInfo;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn &#34;RequestInfo [heartInfo=&#34; + heartInfo + &#34;]&#34;;\n\t}\n}\n</code></pre></div><p>客户端发起连接代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class Client {\n\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\t\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\tBootstrap b = new Bootstrap();\n\t\tb.group(group)\n\t\t .channel(NioSocketChannel.class)\n\t\t .handler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t@Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\tsc.pipeline().addLast(new ClienHeartBeatHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\tChannelFuture cf = b.connect(&#34;127.0.0.1&#34;, 8765).sync();\n\t\t\n\t\tcf.channel().closeFuture().sync();\n\t\tgroup.shutdownGracefully();\n\t}\n}\n</code></pre></div><p>客户端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport java.net.InetAddress;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.ScheduledFuture;\nimport java.util.concurrent.TimeUnit;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.ReferenceCountUtil;\n\n/**\n * 客户端心跳维护处理类\n * \n * @author Administrator\n *\n */\npublic class ClienHeartBeatHandler extends ChannelHandlerAdapter {\n\n\tprivate ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n\tprivate ScheduledFuture&lt;?&gt; heartBeat;\n\t// 主动向服务器发送认证信息\n\tprivate InetAddress addr;\n\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\taddr = InetAddress.getLocalHost();\n\t\tString ip = addr.getHostAddress();\n\t\t// 通道建立起来之后，先握手，建立认证体系\n\t\tctx.writeAndFlush(ip);\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\ttry {\n\t\t\tif (msg instanceof String &amp;&amp; &#34;auth&#34;.equals(msg)) {\n\t\t\t\t// 握手成功，主动发送心跳消息（0，代表启动就开始，30代表间隔30秒钟）\n\t\t\t\tthis.heartBeat = this.scheduler.scheduleWithFixedDelay(new HeartBeatTask(ctx), 0, 30, TimeUnit.SECONDS);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(msg);\n\t\t} finally {\n\t\t\tReferenceCountUtil.release(msg);\n\t\t}\n\t}\n\n\t/**\n\t * 定义心跳任务线程\n\t * \n\t * @author Administrator\n\t *\n\t */\n\tprivate class HeartBeatTask implements Runnable {\n\t\tprivate final ChannelHandlerContext ctx;\n\t\t\n\t\tpublic HeartBeatTask(final ChannelHandlerContext ctx) {\n\t\t\tthis.ctx = ctx;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tHeartInfo info = new HeartInfo();\n\t\t\t\t//发送心跳报文\n\t\t\t\tinfo.setHeartInfo(&#34;客户端心跳报文：T0&#34;);\n\t\t\t\tctx.writeAndFlush(info);\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tcause.printStackTrace();\n\t\tif (heartBeat != null) {\n\t\t\theartBeat.cancel(true);\n\t\t\theartBeat = null;\n\t\t}\n\t\tctx.fireExceptionCaught(cause);\n\t}\n}\n</code></pre></div><p>定义 Jboss Marshalling解码器代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.heartbeat;\n\nimport io.netty.handler.codec.marshalling.DefaultMarshallerProvider;\nimport io.netty.handler.codec.marshalling.DefaultUnmarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallingDecoder;\nimport io.netty.handler.codec.marshalling.MarshallingEncoder;\nimport io.netty.handler.codec.marshalling.UnmarshallerProvider;\n\nimport org.jboss.marshalling.MarshallerFactory;\nimport org.jboss.marshalling.Marshalling;\nimport org.jboss.marshalling.MarshallingConfiguration;\n\n/**\n * 采用Jboss Marshalling解码器 完成JAVA对象序列化\n * @author Administrator\n *\n */\npublic final class MarshallingCodeCFactory {\n\n    /**\n     * 创建Jboss Marshalling解码器MarshallingDecoder\n     * @return MarshallingDecoder\n     */\n    public static MarshallingDecoder buildMarshallingDecoder() {\n    \t//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\t//创建了MarshallingConfiguration对象，配置了版本号为5 \n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\t//根据marshallerFactory和configuration创建provider\n\t\tUnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度\n\t\tMarshallingDecoder decoder = new MarshallingDecoder(provider, 1024 * 1024 * 1);\n\t\treturn decoder;\n    }\n\n    /**\n     * 创建Jboss Marshalling编码器MarshallingEncoder\n     * @return MarshallingEncoder\n     */\n    public static MarshallingEncoder buildMarshallingEncoder() {\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\tMarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组\n\t\tMarshallingEncoder encoder = new MarshallingEncoder(provider);\n\t\treturn encoder;\n    }\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>客户端在连接激活时，先向“数据中心”发起认证请求：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-73a0d3241a59d14585b94a49a4c62218_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1184\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb\" width=\"1184\" data-original=\"https://pic1.zhimg.com/v2-73a0d3241a59d14585b94a49a4c62218_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1184&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1184\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1184\" data-original=\"https://pic1.zhimg.com/v2-73a0d3241a59d14585b94a49a4c62218_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-73a0d3241a59d14585b94a49a4c62218_b.jpg\"/></figure><p>“数据中心”在接收到认证请求之后，向客户端发送认证后的结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f50e8d2ca6ebf4b20d35d8da72e0b5f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1182\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb\" width=\"1182\" data-original=\"https://pic1.zhimg.com/v2-f50e8d2ca6ebf4b20d35d8da72e0b5f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1182&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1182\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1182\" data-original=\"https://pic1.zhimg.com/v2-f50e8d2ca6ebf4b20d35d8da72e0b5f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f50e8d2ca6ebf4b20d35d8da72e0b5f0_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2a887f87c7d036bba7b0ec76fb108cdf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1188\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"1188\" data-original=\"https://pic4.zhimg.com/v2-2a887f87c7d036bba7b0ec76fb108cdf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1188&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1188\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1188\" data-original=\"https://pic4.zhimg.com/v2-2a887f87c7d036bba7b0ec76fb108cdf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2a887f87c7d036bba7b0ec76fb108cdf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>认证通过之后，客户端就可以给“数据中心”间隔一定时间发起“心跳报文”：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-96e3e90716214f24ed2c023870b6005a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1204\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"1204\" data-original=\"https://pic3.zhimg.com/v2-96e3e90716214f24ed2c023870b6005a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1204&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1204\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1204\" data-original=\"https://pic3.zhimg.com/v2-96e3e90716214f24ed2c023870b6005a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-96e3e90716214f24ed2c023870b6005a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-318edad0b80d92ffaf7497bdcbb9b04d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1152\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb\" width=\"1152\" data-original=\"https://pic2.zhimg.com/v2-318edad0b80d92ffaf7497bdcbb9b04d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1152&#39; height=&#39;440&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1152\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1152\" data-original=\"https://pic2.zhimg.com/v2-318edad0b80d92ffaf7497bdcbb9b04d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-318edad0b80d92ffaf7497bdcbb9b04d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8fc79bcb7ea5186853c40230492fbda0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"1062\" data-original=\"https://pic1.zhimg.com/v2-8fc79bcb7ea5186853c40230492fbda0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1062&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1062\" data-original=\"https://pic1.zhimg.com/v2-8fc79bcb7ea5186853c40230492fbda0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8fc79bcb7ea5186853c40230492fbda0_b.jpg\"/></figure><p>“数据中心”在收到“心跳报文”后，就可以查看“报文数据”，并响应客户端结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ba7a2e63fc2c5e85eec4e268ae6814f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1173\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb\" width=\"1173\" data-original=\"https://pic1.zhimg.com/v2-ba7a2e63fc2c5e85eec4e268ae6814f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1173&#39; height=&#39;448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1173\" data-rawheight=\"448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1173\" data-original=\"https://pic1.zhimg.com/v2-ba7a2e63fc2c5e85eec4e268ae6814f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ba7a2e63fc2c5e85eec4e268ae6814f0_b.jpg\"/></figure><p>当然，我们在传输过程中，采用的“对象序列化”的方式来完成“报文传输”，所以我们还是需要在客户端，服务端，在创建Channel通道代码时，都定义使用了JBoss Marshalling 解码器：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fddf24216afcd546f8ca4b6136f5670d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1223\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb\" width=\"1223\" data-original=\"https://pic2.zhimg.com/v2-fddf24216afcd546f8ca4b6136f5670d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1223&#39; height=&#39;416&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1223\" data-rawheight=\"416\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1223\" data-original=\"https://pic2.zhimg.com/v2-fddf24216afcd546f8ca4b6136f5670d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fddf24216afcd546f8ca4b6136f5670d_b.jpg\"/></figure><p>所以，最后执行的结果就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b055f7518ab005f67d5dd5b7650a1f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1206\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"1206\" data-original=\"https://pic4.zhimg.com/v2-42b055f7518ab005f67d5dd5b7650a1f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1206&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1206\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1206\" data-original=\"https://pic4.zhimg.com/v2-42b055f7518ab005f67d5dd5b7650a1f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b055f7518ab005f67d5dd5b7650a1f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-31f3e4f4563503540095502fc574b031_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1256\" data-rawheight=\"204\" class=\"origin_image zh-lightbox-thumb\" width=\"1256\" data-original=\"https://pic2.zhimg.com/v2-31f3e4f4563503540095502fc574b031_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1256&#39; height=&#39;204&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1256\" data-rawheight=\"204\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1256\" data-original=\"https://pic2.zhimg.com/v2-31f3e4f4563503540095502fc574b031_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-31f3e4f4563503540095502fc574b031_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>注意：</b>定义心跳报文时，报文内容尽量的少一些，因为我们有时不得不为“流量”考虑。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "Netty", 
                    "tagLink": "https://api.zhihu.com/topics/19732975"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38312792", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "Netty框架使用“对象序列化”来解决“数据粘包”", 
            "content": "<h2><b>Netty处理“数据粘包”的方式三：</b></h2><p>本示例采用“对象序列化”的方式，进行数据拆分！</p><p>先定义服务端代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.logging.LogLevel;\nimport io.netty.handler.logging.LoggingHandler;\n\npublic class Server {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\tChannelFuture cf1 = null;\n\t\t//1 创建线两个程组 \n\t\t//一个是用于处理服务器端接收客户端连接的线程组\n\t\t//一个是进行网络通信的（网络读写的）线程组\n\t\t//实现连接维护，以及业务逻辑处理的分离\n\t\tEventLoopGroup pGroup = null;\n\t\tEventLoopGroup cGroup = null;\n\t\ttry {\n\t\t\tpGroup = new NioEventLoopGroup();\n\t\t\tcGroup = new NioEventLoopGroup();\n\t\t\t\n\t\t\t//2 创建辅助工具类，用于服务器通道的一系列配置\n\t\t\tServerBootstrap b = new ServerBootstrap();\n\t\t\tb.group(pGroup, cGroup)\t\t//绑定俩个线程组\n\t\t\t.channel(NioServerSocketChannel.class)\t\t//指定NIO的模式\n\t\t    .option(ChannelOption.SO_BACKLOG, 1024)\t\t//设置tcp缓冲区\n\t\t\t.handler(new LoggingHandler(LogLevel.INFO))\n\t\t\t\n\t\t\t//SocketChannel 代表的就是每一个独立的Socket连接通道\n\t\t\t.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t\t @Override\n\t\t\t\t protected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t\t\n\t\t\t\t\t//设置Jboss Marshalling的2个编码器，完成二进制与对象之间的序列化操作\n\t\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\t\tsc.pipeline().addLast(new ServerHandler());\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\t//4 进行端口绑定 ，并完成异步阻塞\n\t\t\tcf1 = b.bind(8765).sync();\n\t\t\t\n\t\t\t\n\t\t\tcf1.channel().closeFuture().sync();\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t\te.printStackTrace();\n\t\t}finally {\n\t\t\tpGroup.shutdownGracefully();\n\t\t\tcGroup.shutdownGracefully();\n\t\t}\n\t}\n}\n</code></pre></div><p>服务端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\n\nimport org.framestudy.netty.utils.GzipUtils;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n/**\n * 服务器消息处理类\n * @author Administrator\n *\n */\npublic class ServerHandler extends ChannelHandlerAdapter {\n\t/**\n\t * 通道激活后的方法\n\t */\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34; server channel active... &#34;);\n\t}\n\t/**\n\t * 从通道中读取数据的方法\n\t */\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tReq req = (Req) msg;\n\t\tSystem.out.println(&#34;Server : &#34; + req);\n\t\t\n\t\t//------如果不做附件传输，可以不添加下面这段代码------\n\t\tbyte[] attachment = GzipUtils.ungzip(req.getAttachment());\n\t\tString path = System.getProperty(&#34;user.dir&#34;) + File.separatorChar + &#34;receive&#34; + File.separatorChar + req.getFileName();\n\t\tFileOutputStream fos = new FileOutputStream(path);\n\t\tfos.write(attachment);\n\t\tfos.close();\n\t\t//--------接到客户端消息后，向服务器发送响应---------\n\t\tResp resp = new Resp();\n\t\tresp.setId(req.getId());\n\t\tresp.setName(&#34;resp&#34; + req.getName());\n\t\tresp.setResponseMessage(&#34;响应内容 ：&#34; + req.getRequestMessage());\n\t\tctx.writeAndFlush(resp);\n\t\t\n\t\t//完成短连接与长连接的转换\n\t\t// .addListener(ChannelFutureListener.CLOSE);\n\t}\n\t\n\t/**\n\t * 从通道中将数据读取完毕后的方法\n\t */\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34;server channel readcomplete... &#34;);\n\t}\n\t\n\t/**\n\t * 异常抛出后的方法\n\t */\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\n\t}\n\n}\n</code></pre></div><p>定义客户端请求实体对象：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport java.io.Serializable;\nimport java.util.Arrays;\n/**\n * 定义请求对象\n * @author Administrator\n *\n */\npublic class Req implements Serializable{\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\t/**\n\t * \n\t */\n\tprivate String id ;\n\tprivate String name ;\n\tprivate String requestMessage ;//请求消息\n\tprivate String fileName;\n\tprivate byte[] attachment;//携带的附件，例如：文件……\n\t\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getFileName() {\n\t\treturn fileName;\n\t}\n\tpublic void setFileName(String fileName) {\n\t\tthis.fileName = fileName;\n\t}\n\tpublic String getRequestMessage() {\n\t\treturn requestMessage;\n\t}\n\tpublic void setRequestMessage(String requestMessage) {\n\t\tthis.requestMessage = requestMessage;\n\t}\n\tpublic byte[] getAttachment() {\n\t\treturn attachment;\n\t}\n\tpublic void setAttachment(byte[] attachment) {\n\t\tthis.attachment = attachment;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn &#34;Req [id=&#34; + id + &#34;, name=&#34; + name + &#34;, requestMessage=&#34; + requestMessage + &#34;, attachment=&#34;\n\t\t\t\t+ Arrays.toString(attachment) + &#34;]&#34;;\n\t}\n}\n</code></pre></div><p>定义服务端响应实体对象：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport java.io.Serializable;\n\n/**\n * 定义响应对象\n * @author Administrator\n *\n */\npublic class Resp implements Serializable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate String id;\n\tprivate String name;\n\tprivate String responseMessage;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getResponseMessage() {\n\t\treturn responseMessage;\n\t}\n\n\tpublic void setResponseMessage(String responseMessage) {\n\t\tthis.responseMessage = responseMessage;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn &#34;Resp [id=&#34; + id + &#34;, name=&#34; + name + &#34;, responseMessage=&#34; + responseMessage + &#34;]&#34;;\n\t}\n}</code></pre></div><p>定义GZIP压缩工具类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.utils;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class GzipUtils {\n\t\n\t\n\t/**\n\t * 压缩功能\n\t * @param data\n\t * @return\n\t * @throws Exception\n\t */\n    public static byte[] gzip(byte[] data) throws Exception{\n    \tByteArrayOutputStream bos = new ByteArrayOutputStream();\n    \tGZIPOutputStream gzip = new GZIPOutputStream(bos);\n    \tgzip.write(data);\n    \tgzip.finish();\n    \tgzip.close();\n    \tbyte[] ret = bos.toByteArray();\n    \tbos.close();\n    \treturn ret;\n    }\n    /**\n     * 解压缩功能\n     * @param data\n     * @return\n     * @throws Exception\n     */\n    public static byte[] ungzip(byte[] data) throws Exception{\n    \tByteArrayInputStream bis = new ByteArrayInputStream(data);\n    \tGZIPInputStream gzip = new GZIPInputStream(bis);\n    \tbyte[] buf = new byte[1024];\n    \tint num = -1;\n    \tByteArrayOutputStream bos = new ByteArrayOutputStream();\n    \twhile((num = gzip.read(buf, 0 , buf.length)) != -1 ){\n    \t\tbos.write(buf, 0, num);\n    \t}\n    \tgzip.close();\n    \tbis.close();\n    \tbyte[] ret = bos.toByteArray();\n    \tbos.flush();\n    \tbos.close();\n    \treturn ret;\n    }\n}</code></pre></div><p>客户端连接代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport java.io.File;\nimport java.io.FileInputStream;\n\nimport org.framestudy.netty.utils.GzipUtils;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\n\npublic class Client {\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\t\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\tBootstrap b = new Bootstrap();\n\t\tb.group(group)\n\t\t .channel(NioSocketChannel.class)\n\t\t .handler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t@Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t\n\t\t\t\t//设置Jboss Marshalling的2个编码器，完成二进制与对象之间的序列化操作\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingDecoder());\n\t\t\t\tsc.pipeline().addLast(MarshallingCodeCFactory.buildMarshallingEncoder());\n\t\t\t\tsc.pipeline().addLast(new ClientHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\tChannelFuture cf = b.connect(&#34;127.0.0.1&#34;, 8765).sync();\n\t\t\n\t\tfor(int i = 1; i &lt;= 6; i++ ){\n\t\t\tReq req = new Req();\n\t\t\treq.setId(&#34;&#34; + i);\n\t\t\treq.setName(&#34;pro&#34; + i);\n\t\t\treq.setRequestMessage(&#34;数据信息&#34; + i);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//------如果不做附件传输，可以不添加下面这段代码------\n\t\t\treq.setFileName(&#34;00&#34;+i+&#34;.jpg&#34;);\n\t\t\tString path = System.getProperty(&#34;user.dir&#34;) + File.separatorChar + &#34;sources&#34; +  File.separatorChar + &#34;00&#34;+i+&#34;.jpg&#34;;\n\t\t\tFile file = new File(path);\n\t        FileInputStream in = new FileInputStream(file);  \n\t        byte[] data = new byte[in.available()];  \n\t        in.read(data);  \n\t        in.close(); \n\t\t\treq.setAttachment(GzipUtils.gzip(data));\n\t\t\t\n\t\t\t//-------向服务端发送req序列化对象-------\n\t\t\tcf.channel().writeAndFlush(req);\n\t\t}\n\t\t\n\t\t//等待连接关闭\n\t\tcf.channel().closeFuture().sync();\n\t\tgroup.shutdownGracefully();\n\t}\n}\n</code></pre></div><p>客户端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.ReferenceCountUtil;\n/**\n * 客户端消息处理类\n * @author Administrator\n *\n */\npublic class ClientHandler extends ChannelHandlerAdapter{\n\t/**\n\t * 通道激活后的方法\n\t */\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34; client channel active... &#34;);\n\t}\n\t\n\t/**\n\t * 从通道中读取数据的方法\n\t */\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\ttry {\n\t\t\tResp resp = (Resp)msg;\n\t\t\tSystem.out.println(&#34;Client : &#34; + resp);\t\t\t\n\t\t} finally {\n\t\t\tReferenceCountUtil.release(msg);\n\t\t}\n\t}\n\n\t/**\n\t * 从通道中将数据读取完毕后的方法\n\t */\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\t\n\t}\n\t/**\n\t * 异常抛出后的方法\n\t */\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\n\t}\n\t\n}\n</code></pre></div><p>定义 Jboss Marshalling解码器代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak03;\n\nimport org.jboss.marshalling.MarshallerFactory;\nimport org.jboss.marshalling.Marshalling;\nimport org.jboss.marshalling.MarshallingConfiguration;\n\nimport io.netty.handler.codec.marshalling.DefaultMarshallerProvider;\nimport io.netty.handler.codec.marshalling.DefaultUnmarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallerProvider;\nimport io.netty.handler.codec.marshalling.MarshallingDecoder;\nimport io.netty.handler.codec.marshalling.MarshallingEncoder;\nimport io.netty.handler.codec.marshalling.UnmarshallerProvider;\n\n/**\n * 采用Jboss Marshalling解码器 完成JAVA对象序列化\n * @author Administrator\n *\n */\npublic final class MarshallingCodeCFactory {\n\n    /**\n     * 创建Jboss Marshalling解码器MarshallingDecoder\n     * @return MarshallingDecoder\n     */\n    public static MarshallingDecoder buildMarshallingDecoder() {\n    \t//首先通过Marshalling工具类的精通方法获取Marshalling实例对象 参数serial标识创建的是java序列化工厂对象。\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\t//创建了MarshallingConfiguration对象，配置了版本号为5 \n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\t//根据marshallerFactory和configuration创建provider\n\t\tUnmarshallerProvider provider = new DefaultUnmarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingDecoder对象，俩个参数分别为provider和单个消息序列化后的最大长度，目前是1M\n\t\t//超过1M，将不做序列化\n\t\tMarshallingDecoder decoder = new MarshallingDecoder(provider, 1024 * 1024 * 1);\n\t\treturn decoder;\n    }\n\n    /**\n     * 创建Jboss Marshalling编码器MarshallingEncoder\n     * @return MarshallingEncoder\n     */\n    public static MarshallingEncoder buildMarshallingEncoder() {\n\t\tfinal MarshallerFactory marshallerFactory = Marshalling.getProvidedMarshallerFactory(&#34;serial&#34;);\n\t\tfinal MarshallingConfiguration configuration = new MarshallingConfiguration();\n\t\tconfiguration.setVersion(5);\n\t\tMarshallerProvider provider = new DefaultMarshallerProvider(marshallerFactory, configuration);\n\t\t//构建Netty的MarshallingEncoder对象，MarshallingEncoder用于实现序列化接口的POJO对象序列化为二进制数组\n\t\tMarshallingEncoder encoder = new MarshallingEncoder(provider);\n\t\treturn encoder;\n    }\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>在通过“对象序列号”的方式来解决“数据粘包”，最为重要的就是这个Marshalling解码器的使用，它是由Jboss框架提供，主要可以用来完成“对象与二进制之间进行相互转换”</p><p class=\"ztext-empty-paragraph\"><br/></p><p>客户端在连接时，在Client中向服务端发送内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d616e96c8e986b1c1b0ad2b06381ee9f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1106\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb\" width=\"1106\" data-original=\"https://pic4.zhimg.com/v2-d616e96c8e986b1c1b0ad2b06381ee9f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1106&#39; height=&#39;559&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1106\" data-rawheight=\"559\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1106\" data-original=\"https://pic4.zhimg.com/v2-d616e96c8e986b1c1b0ad2b06381ee9f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d616e96c8e986b1c1b0ad2b06381ee9f_b.jpg\"/></figure><p>服务端在接收到数据时，在ServerHandle中向客户端发送的内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d12dc90433a1c243580851558cf505ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1187\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"1187\" data-original=\"https://pic3.zhimg.com/v2-d12dc90433a1c243580851558cf505ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1187&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1187\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1187\" data-original=\"https://pic3.zhimg.com/v2-d12dc90433a1c243580851558cf505ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d12dc90433a1c243580851558cf505ee_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e84a1165bd10bd5a72bc57b333d6b250_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1113\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"1113\" data-original=\"https://pic1.zhimg.com/v2-e84a1165bd10bd5a72bc57b333d6b250_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1113&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1113\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1113\" data-original=\"https://pic1.zhimg.com/v2-e84a1165bd10bd5a72bc57b333d6b250_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e84a1165bd10bd5a72bc57b333d6b250_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>但是无论是客户端，还是服务端，在创建Channel通道代码时，都定义使用了JBoss Marshalling 解码器：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c2274d0645c5d001bdc694ce310c3a0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1083\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"1083\" data-original=\"https://pic1.zhimg.com/v2-c2274d0645c5d001bdc694ce310c3a0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1083&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1083\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1083\" data-original=\"https://pic1.zhimg.com/v2-c2274d0645c5d001bdc694ce310c3a0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c2274d0645c5d001bdc694ce310c3a0c_b.jpg\"/></figure><p>所以，最后执行的结果就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-410351ee737c604cbee0ce7c8895f527_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1315\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"1315\" data-original=\"https://pic4.zhimg.com/v2-410351ee737c604cbee0ce7c8895f527_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1315&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1315\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1315\" data-original=\"https://pic4.zhimg.com/v2-410351ee737c604cbee0ce7c8895f527_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-410351ee737c604cbee0ce7c8895f527_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bb9f9adeb35b6d4a52d95eb752bd1f75_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1323\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"1323\" data-original=\"https://pic2.zhimg.com/v2-bb9f9adeb35b6d4a52d95eb752bd1f75_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1323&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1323\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1323\" data-original=\"https://pic2.zhimg.com/v2-bb9f9adeb35b6d4a52d95eb752bd1f75_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bb9f9adeb35b6d4a52d95eb752bd1f75_b.jpg\"/></figure><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Socket", 
                    "tagLink": "https://api.zhihu.com/topics/19604051"
                }, 
                {
                    "tag": "Netty", 
                    "tagLink": "https://api.zhihu.com/topics/19732975"
                }, 
                {
                    "tag": "网络编程", 
                    "tagLink": "https://api.zhihu.com/topics/19611616"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38310224", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "Netty框架使用“报文定长”来解决“数据粘包”", 
            "content": "<h2><b>Netty处理“数据粘包”的方式二：</b></h2><p>本示例采用“报文定长”的方式，进行数据拆分！</p><p>先定义服务端代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak02;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.FixedLengthFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\n\npublic class Server {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t//1 创建2个线程，一个是负责接收客户端的连接。一个是负责进行数据传输的\n\t\tEventLoopGroup pGroup = new NioEventLoopGroup();\n\t\tEventLoopGroup cGroup = new NioEventLoopGroup();\n\t\t\n\t\t//2 创建服务器辅助类\n\t\tServerBootstrap b = new ServerBootstrap();\n\t\tb.group(pGroup, cGroup)\n\t\t .channel(NioServerSocketChannel.class)\n\t\t .option(ChannelOption.SO_BACKLOG, 1024)\n\t\t .option(ChannelOption.SO_SNDBUF, 32*1024)\n\t\t .option(ChannelOption.SO_RCVBUF, 32*1024)\n\t\t .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t@Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t//设置报文字符串长度\n\t\t\t\tsc.pipeline().addLast(new FixedLengthFrameDecoder(5));\n\t\t\t\t//设置字符串形式的解码\n\t\t\t\tsc.pipeline().addLast(new StringDecoder());\n\t\t\t\tsc.pipeline().addLast(new ServerHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\t//4 绑定连接\n\t\tChannelFuture cf = b.bind(8765).sync();\n\t\t\n\t\t//等待服务器监听端口关闭\n\t\tcf.channel().closeFuture().sync();\n\t\tpGroup.shutdownGracefully();\n\t\tcGroup.shutdownGracefully();\n\t\t\n\t}\n\t\n}\n</code></pre></div><p>服务端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak02;\n\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n\npublic class ServerHandler extends ChannelHandlerAdapter {\n\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34; server channel active... &#34;);\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tString request = (String)msg;\n\t\tSystem.out.println(&#34;Server :&#34; + msg);\n\t\tString response = request;\n\t\tctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));\n\t}\n\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\t\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {\n\n\t}\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>客户端连接代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak02;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.FixedLengthFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\n\npublic class Client {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\t\n\t\tBootstrap b = new Bootstrap();\n\t\tb.group(group)\n\t\t .channel(NioSocketChannel.class)\n\t\t .handler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t@Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t//设置报文字符串长度\n\t\t\t\tsc.pipeline().addLast(new FixedLengthFrameDecoder(5));\n\t\t\t\t//设置字符串形式的解码\n\t\t\t\tsc.pipeline().addLast(new StringDecoder());\n\t\t\t\tsc.pipeline().addLast(new ClientHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\tChannelFuture cf = b.connect(&#34;127.0.0.1&#34;, 8765).sync();\n\t\t\n\t\tcf.channel().writeAndFlush(Unpooled.wrappedBuffer(&#34;aaaaabbbbb&#34;.getBytes()));\n\t\t//当不够5个位时，可以使用空格补位\n\t\tcf.channel().writeAndFlush(Unpooled.\n\t\t\t\tcopiedBuffer(&#34;ccccccc   &#34;.getBytes()));\n\t\t\n\t\t//等待客户端端口关闭\n\t\tcf.channel().closeFuture().sync();\n\t\tgroup.shutdownGracefully();\n\t\t\n\t}\n}\n</code></pre></div><p>客户端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak02;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n\npublic class ClientHandler extends ChannelHandlerAdapter{\n\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34;client channel active... &#34;);\n\t}\n\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tString response = (String)msg;\n\t\tSystem.out.println(&#34;Client接收到的响应内容: &#34; + response);\n\t}\n\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t}\n\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t}\n\n}\n</code></pre></div><p>客户端在连接时，在Client中向服务端发送内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0726514c2af0413cfcd44f4c1e3c78dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb\" width=\"978\" data-original=\"https://pic1.zhimg.com/v2-0726514c2af0413cfcd44f4c1e3c78dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;978&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"978\" data-original=\"https://pic1.zhimg.com/v2-0726514c2af0413cfcd44f4c1e3c78dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0726514c2af0413cfcd44f4c1e3c78dc_b.jpg\"/></figure><p>服务端在接收到数据时，在ServerHandle中向客户端发送的内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3597c6ba99b51be4d1bacf13bffe0c06_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-3597c6ba99b51be4d1bacf13bffe0c06_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1030&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-3597c6ba99b51be4d1bacf13bffe0c06_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3597c6ba99b51be4d1bacf13bffe0c06_b.jpg\"/></figure><p>但是无论是客户端，还是服务端，在创建Channel通道代码时，都定义了一个定长报文字符分割器：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1712fc829740f0a0db79f766487a3cb2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1183\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"1183\" data-original=\"https://pic3.zhimg.com/v2-1712fc829740f0a0db79f766487a3cb2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1183&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1183\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1183\" data-original=\"https://pic3.zhimg.com/v2-1712fc829740f0a0db79f766487a3cb2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1712fc829740f0a0db79f766487a3cb2_b.jpg\"/></figure><p>所以，最后执行的结果就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-40a91a0cad4c8b53df7b32d7fb07d049_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"913\" data-original=\"https://pic2.zhimg.com/v2-40a91a0cad4c8b53df7b32d7fb07d049_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;913&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"913\" data-original=\"https://pic2.zhimg.com/v2-40a91a0cad4c8b53df7b32d7fb07d049_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-40a91a0cad4c8b53df7b32d7fb07d049_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2700e4994bc3ebf9c3a8a2d796bc5580_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"896\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"896\" data-original=\"https://pic1.zhimg.com/v2-2700e4994bc3ebf9c3a8a2d796bc5580_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;896&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"896\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"896\" data-original=\"https://pic1.zhimg.com/v2-2700e4994bc3ebf9c3a8a2d796bc5580_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2700e4994bc3ebf9c3a8a2d796bc5580_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Netty", 
                    "tagLink": "https://api.zhihu.com/topics/19732975"
                }, 
                {
                    "tag": "Socket", 
                    "tagLink": "https://api.zhihu.com/topics/19604051"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38280496", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "Netty框架使用“特殊字符”来解决“数据粘包”", 
            "content": "<p>在基于“TCP/IP协议”进行数据传输过程中，数据中心在接收到每条数据后，并非是立马进行处理，而是定义一定的“缓冲区”来进行缓存数据，等到达一定量，或者接收完毕后，才进行处理，由于TCP传输的无边界性，那么数据中心，将无法正确的区分“协议”什么时候开始，什么时候结束，所以不可避免的就会出现“数据粘包”!</p><h2><b>Netty处理“数据粘包”的方式一：</b></h2><p>本示例采用“$_”来作为特殊字符，进行数据拆分！</p><p>先定义服务端代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak01;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioServerSocketChannel;\nimport io.netty.handler.codec.DelimiterBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\n\npublic class Server {\n\n\tpublic static void main(String[] args) throws Exception{\n\t\t//创建用于负责接收客户端数据的连接组\n\t\tEventLoopGroup pGroup = new NioEventLoopGroup();\n\t\t//创建用于负责进行数据传输的连接组\n\t\tEventLoopGroup cGroup = new NioEventLoopGroup();\n\t\t\n\t\t//创建服务端辅助类\n\t\tServerBootstrap b = new ServerBootstrap();\n\t\tb.group(pGroup, cGroup)\n\t\t .channel(NioServerSocketChannel.class)//采用NIO方式进行创建服务端程序\n\t\t .option(ChannelOption.SO_BACKLOG, 1024)//定义连接处理缓冲队列\n\t\t .option(ChannelOption.SO_SNDBUF, 32*1024)//定义数据发送缓冲区大小\n\t\t .option(ChannelOption.SO_RCVBUF, 32*1024)//定义数据接收缓冲区大小\n\t\t .option(ChannelOption.SO_KEEPALIVE, true)//保持连接处于激活状态\n\t\t .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t\n\t\t\t @Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t//设置特殊分隔符，并使用工具类，将String类型的$_转成ByeteBuf类型的数据\n\t\t\t\tByteBuf buf = Unpooled.copiedBuffer(&#34;$_&#34;.getBytes());\n\t\t\t\t\n\t\t\t\t/* DelimiterBasedFrameDecoder\n\t\t\t\t * 作用主要是从特殊分隔符处，将报文进行拆分\n\t\t\t\t * 2个参数：\n\t\t\t\t * 第一个参数是指特殊分割符的最大长度\n\t\t\t\t * 第二个参数是指特殊分隔符\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tsc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));\n\t\t\t\t//设置字符串形式的解码，将ByteBuf直接转换成String类型的数据\n\t\t\t\tsc.pipeline().addLast(new StringDecoder());\n\t\t\t\tsc.pipeline().addLast(new ServerHandler());\n\t\t\t}\n\t\t});\n\t\t\n\t\t//4 绑定连接（同时还可以开发多个端口）\n\t\tChannelFuture cf = b.bind(8765).sync();\n\t\t\n\t\t//等待服务器监听端口关闭\n\t\tcf.channel().closeFuture().sync();\n\t\tpGroup.shutdownGracefully();\n\t\tcGroup.shutdownGracefully();\n\t}\n\t\n}\n</code></pre></div><p>服务端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak01;\n\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\n/**\n * 服务器消息处理类\n * @author Administrator\n *\n */\npublic class ServerHandler extends ChannelHandlerAdapter {\n\n\t/**\n\t * 通道激活后的方法\n\t */\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34; server channel active... &#34;);\n\t}\n\t\n\t/**\n\t * 从通道中读取数据的方法\n\t */\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\tString request = (String)msg;\n\t\tSystem.out.println(&#34;Server :&#34; + request);\n\t\tString response = &#34;服务器响应：&#34; + request + &#34;$_&#34;;\n\t\tctx.writeAndFlush(Unpooled.copiedBuffer(response.getBytes()));\n\t\t//完成短连接与长连接的转换\n//\t\t.addListener(ChannelFutureListener.CLOSE);\n\t}\n\t\n\t/**\n\t * 从通道中将数据读取完毕后的方法\n\t */\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t\t\n\t}\n\t\n\t/**\n\t * 异常抛出后的方法\n\t */\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable t) throws Exception {\n\t\tctx.close();\n\t}\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>客户端连接代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak01;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.channel.socket.nio.NioSocketChannel;\nimport io.netty.handler.codec.DelimiterBasedFrameDecoder;\nimport io.netty.handler.codec.string.StringDecoder;\n\npublic class Client {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\t//创建用于负责接收服务端数据的连接组\n\t\tEventLoopGroup group = new NioEventLoopGroup();\n\t\t\n\t\t//创建客户端辅助类\n\t\tBootstrap b = new Bootstrap();\n\t\tb.group(group)\n\t\t .channel(NioSocketChannel.class)\n\t\t .handler(new ChannelInitializer&lt;SocketChannel&gt;() {\n\t\t\t@Override\n\t\t\tprotected void initChannel(SocketChannel sc) throws Exception {\n\t\t\t\t//设置特殊分隔符，并使用工具类，将String类型的$_转成ByeteBuf类型的数据\n\t\t\t\tByteBuf buf = Unpooled.copiedBuffer(&#34;$_&#34;.getBytes());\n\t\t\t\tsc.pipeline().addLast(new DelimiterBasedFrameDecoder(1024, buf));\n\t\t\t\tsc.pipeline().addLast(new StringDecoder());\n\t\t\t\tsc.pipeline().addLast(new ClientHandler());//添加客户端消息处理类\n\t\t\t}\n\t\t});\n\t\t\n\t\t//通过IP与端口连接服务端\n\t\tChannelFuture cf = b.connect(&#34;127.0.0.1&#34;, 8765).sync();\n\t\t\n\t\t//向服务端写入数据\n\t\tcf.channel().writeAndFlush(Unpooled.wrappedBuffer(&#34;bbbb$_&#34;.getBytes()));\n\t\tcf.channel().writeAndFlush(Unpooled.wrappedBuffer(&#34;cccc$_&#34;.getBytes()));\n\t\t\n\t\t//等待客户端端口关闭\n\t\tcf.channel().closeFuture().sync();\n\t\tgroup.shutdownGracefully();\n\t\t\n\t}\n}\n</code></pre></div><p>客户端信息处理类代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">package org.framestudy.netty.agreebreak01;\n\nimport io.netty.channel.ChannelHandlerAdapter;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.util.ReferenceCountUtil;\n/**\n * 客户端消息处理类\n * @author Administrator\n *\n */\npublic class ClientHandler extends ChannelHandlerAdapter{\n\t\n\t/**\n\t * 通道激活后的方法\n\t */\n\t@Override\n\tpublic void channelActive(ChannelHandlerContext ctx) throws Exception {\n\t\tSystem.out.println(&#34;client channel active... &#34;);\n\t}\n\t\n\t/**\n\t * 从通道中读取数据的方法\n\t */\n\t@Override\n\tpublic void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n\t\ttry {\n\t\t\tString response = (String)msg;\n\t\t\tSystem.out.println(&#34;Client: &#34; + response);\n\t\t} finally {\n\t\t\tReferenceCountUtil.release(msg);\n\t\t}\n\t}\n\t\n\t/**\n\t * 从通道中将数据读取完毕后的方法\n\t */\n\t@Override\n\tpublic void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n\t}\n\n\t/**\n\t * 异常抛出后的方法\n\t */\n\t@Override\n\tpublic void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n\t\tctx.close();\n\t}\n\n}\n</code></pre></div><p>客户端在连接时，在Client中向服务端发送内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7e6e73e8eacee218530b34da49b2f89d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb\" width=\"884\" data-original=\"https://pic2.zhimg.com/v2-7e6e73e8eacee218530b34da49b2f89d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;884&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"884\" data-original=\"https://pic2.zhimg.com/v2-7e6e73e8eacee218530b34da49b2f89d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7e6e73e8eacee218530b34da49b2f89d_b.jpg\"/></figure><p>服务端在接收到数据时，在ServerHandle中向客户端发送的内容是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-84a6b6c52da949df6167420674ef3cb9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1116\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb\" width=\"1116\" data-original=\"https://pic2.zhimg.com/v2-84a6b6c52da949df6167420674ef3cb9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1116&#39; height=&#39;276&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1116\" data-rawheight=\"276\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1116\" data-original=\"https://pic2.zhimg.com/v2-84a6b6c52da949df6167420674ef3cb9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-84a6b6c52da949df6167420674ef3cb9_b.jpg\"/></figure><p>但是无论是客户端，还是服务端，在创建Channel通道代码时，都定义了一个特殊字符分割器：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5e9323fca426dba81b2a2a58de8f56a7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"1137\" data-original=\"https://pic4.zhimg.com/v2-5e9323fca426dba81b2a2a58de8f56a7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1137&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1137\" data-original=\"https://pic4.zhimg.com/v2-5e9323fca426dba81b2a2a58de8f56a7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5e9323fca426dba81b2a2a58de8f56a7_b.jpg\"/></figure><p>所以，最后执行的结果就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-384f8fa210861e60e39f254cfff16df7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"712\" data-original=\"https://pic4.zhimg.com/v2-384f8fa210861e60e39f254cfff16df7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;712&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"712\" data-original=\"https://pic4.zhimg.com/v2-384f8fa210861e60e39f254cfff16df7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-384f8fa210861e60e39f254cfff16df7_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-64bdcc129a7b83060a83eceb7f804582_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb\" width=\"762\" data-original=\"https://pic3.zhimg.com/v2-64bdcc129a7b83060a83eceb7f804582_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;762&#39; height=&#39;194&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"194\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"762\" data-original=\"https://pic3.zhimg.com/v2-64bdcc129a7b83060a83eceb7f804582_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-64bdcc129a7b83060a83eceb7f804582_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Netty", 
                    "tagLink": "https://api.zhihu.com/topics/19732975"
                }, 
                {
                    "tag": "Socket", 
                    "tagLink": "https://api.zhihu.com/topics/19604051"
                }
            ], 
            "comments": [
                {
                    "userName": "霜雪明", 
                    "userLink": "https://www.zhihu.com/people/57deeee18708b6e56ee84506a3255dba", 
                    "content": "如果要传输的数据中就是有$_怎么进行转义呢？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38265341", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "5分钟搞清楚IO编程与NIO的区别", 
            "content": "<p>相信很多人，都听过“数据采集中心”的说法，特别是做一些 <b>远程控制硬件终端</b> 的项目，一定都有自己的“数据采集中心”。比如说：远程控制摩拜自动开锁、远程控制小区入户开锁……  做这些系统的开发人员，一定都知道，终端设备与我们的后台WEB服务器之间，需要进行指令的交互，并且通过“远程指令”的交互，来完成对硬件设备的控制。</p><p>比如：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-64765222830eb50ce13035e23da6fc58_b.jpg\" data-rawwidth=\"550\" data-rawheight=\"357\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-64765222830eb50ce13035e23da6fc58_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"550\" data-rawheight=\"357\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-64765222830eb50ce13035e23da6fc58_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-64765222830eb50ce13035e23da6fc58_b.jpg\"/></figure><p>作为数据中心来讲，必不可少就需要考虑如何才能支持更多的终端同时在线，能实现与 硬件终端 进行数据通信的技术有很多，对应技术的框架封装也很多，具体选择哪种，根据具体情况来分析。但目前，使用最多的可能就是IO编程或者是NIO编程实现，所以无论是IO还是NIO技术，它们的目的与作用都是一致的，只是实现方式上有所区别而已。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>那么很多人，就在想，那么什么使用IO，什么时候使用NIO呢？</b></p><p>我个人建议需要综合考虑三点要求：</p><p>1、数据中心的并发要求是否非常高，以及需要考虑在集群的情况下，因为NIO能通过“面向缓冲区”编程的思想，能支持较高的并发量。</p><p>2、由于NIO是面向“缓冲区”编程，所以“缓冲区”的容量需要考虑，这就有一个特点，数据传输的容量不能过大，所以每次终端传输的数据容量，也需要考虑。</p><p>3、团队的技术能力，是否能支持我们使用各种IO或者是NIO的封装框架，以及后续的集群，以及可用性</p><p>其它的，都没啥必要过分考虑，正如我刚提到的，IO或者NIO它们的目的和最终能达到的效果都是一致的。</p><hr/><h2><b>IO与NIO的具体区别在于</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-99b3e8800bb3bffde4f1be1a5208904b_b.jpg\" data-rawwidth=\"437\" data-rawheight=\"386\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"437\" data-original=\"https://pic4.zhimg.com/v2-99b3e8800bb3bffde4f1be1a5208904b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;437&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"437\" data-rawheight=\"386\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"437\" data-original=\"https://pic4.zhimg.com/v2-99b3e8800bb3bffde4f1be1a5208904b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-99b3e8800bb3bffde4f1be1a5208904b_b.jpg\"/></figure><h2><b>传统IO编程的特点：</b></h2><p>1、传统 <b>IO</b> 面向“流”编程，终端一旦与“数据中心”监听的端口，取得联系（搭建Socket管道）后，终端将向“数据中心”上传数据，“数据中心”从连接池中抓取连接出来，根据IO流去“定长”的去读取终端上传的数据。读完再读，直到将该终端上传的数据读完为止。</p><div class=\"highlight\"><pre><code class=\"language-text\">byte[] data = new byte[1024];</code></pre></div><p>2、传输 <b>IO</b> 采用线程阻塞方式编程，“数据中心”从连接池中抓取连接出来后，这根连接就一直跟Socket管道绑定了，一直需要阻塞式的运行，不能参与到其他的工作中去。当连接中的IO数据读取完毕后，连接也不能释放，需要阻塞式的等待，直到终端上传新的数据，连接又开启一次新的读取……</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1c4b9fbfde21a5ff50e4fbf846c17882_b.jpg\" data-rawwidth=\"765\" data-rawheight=\"338\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-1c4b9fbfde21a5ff50e4fbf846c17882_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;765&#39; height=&#39;338&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"765\" data-rawheight=\"338\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-1c4b9fbfde21a5ff50e4fbf846c17882_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1c4b9fbfde21a5ff50e4fbf846c17882_b.jpg\"/></figure><p>餐厅中，每张桌子一个“服务员”，在桌子上有人吃饭时，那么这个“服务员”就不能离开，必须要一直待到旁边，不管“客人”是否需要它，one2one的服务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d01b83f2807d32657afc0b41f36015e8_b.jpg\" data-rawwidth=\"421\" data-rawheight=\"324\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"421\" data-original=\"https://pic1.zhimg.com/v2-d01b83f2807d32657afc0b41f36015e8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;421&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"421\" data-rawheight=\"324\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"421\" data-original=\"https://pic1.zhimg.com/v2-d01b83f2807d32657afc0b41f36015e8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d01b83f2807d32657afc0b41f36015e8_b.jpg\"/></figure><h2><b>New IO编程的特点：</b></h2><p>1、NIO采用&#34;面向缓冲区编程&#34;，所谓的“缓冲区”，大家可以理解为就是在内存中，申请了一片区域，这片区域主要用于“缓冲数据”，一个数据的“缓存”地点。 </p><p>终端与“数据中心”取得联系后，建立起来的Socket通道，在NIO中被称之为Channel通道，</p><p>Channel通道，同样主要用于传输数据，“数据中心”会从连接池中，抓取连接出来读取数据，连接先去检查终端对应的“缓冲区”中，是否还有空间可以去“缓冲数据”，有，就直接存储。如果没有空间可以“缓冲数据”，将等待其它连接池中的连接去处理“缓冲区”的数据，将“缓冲区”数据清空，“缓冲区”空了之后，用于读取数据的连接就可以向其中去“缓冲数据”，数据读取完毕之后，连接回到连接池中，或者去监听其它Channel通道是否有“数据”需要读取到对应的“缓冲区”。</p><p>“缓冲区”的数据，不是说立马就需要去处理，而是要看是否有空闲的用于业务处理的连接可以去处理。</p><p>2、NIO采用“非阻塞式方式”来完成数据的读写，“数据中心”从连接池中，抓取出来的连接从Channel通道中，向“缓冲区”中读取数据之后，不需要阻塞等待新的数据，而是回到连接池或者去监听其他Channel通道是否有数据需要读取到对应的“缓冲区”。</p><p>在NIO编程中，一般用于读写数据的连接，和处理业务逻辑的连接是 <b>分离</b> 开的，不是同一批连接。</p><p><b>所谓的非阻塞式：</b>餐厅改变服务方式，“客人”通过大门进入餐厅后，服务员安排他们到对应的桌子，然后就离开，客人自己通过“点餐”设备向餐厅下单，下单完毕之后，服务员检查订单处，是否已有订单，服务员接单之后，又离开去为其他“客人”服务</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>非阻塞式，提高了连接的复用率，让每一根连接都能不间断的提供服务 ，而不是处于阻塞状态。</b>任何一个物理服务器，都会因为各种影响（内存，CPU……）导致能够为“数据中心”提供的连接数不多（我们之前做过实验，一台比较理想的服务器，在windows server操作系统下，能提供的连接是2W左右），那么如何尽可能的合理利用这些连接，就是我们需要考虑的问题。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-81ca971e5c7efc57bc15e61fddc88498_b.jpg\" data-rawwidth=\"500\" data-rawheight=\"275\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-81ca971e5c7efc57bc15e61fddc88498_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"500\" data-rawheight=\"275\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-81ca971e5c7efc57bc15e61fddc88498_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-81ca971e5c7efc57bc15e61fddc88498_b.jpg\"/></figure><p>3、NIO允许我们采用选择器<b>Selectors，</b>来实现单一连接监听多个Channel通道，在NIO编程时，我们可以定义一个选择器，然后在选择器中去注册多个Channel通道，这样就可以实现， 连接去监听多个Channel通道，实现连接的尽可能高复用。很多NIO框架，都采用了这一思想，比如：netty</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2bfa061afdfea33d5684d999bfc4a15e_b.jpg\" data-rawwidth=\"293\" data-rawheight=\"252\" data-caption=\"\" data-size=\"normal\" class=\"content_image\" width=\"293\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;293&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"293\" data-rawheight=\"252\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" width=\"293\" data-actualsrc=\"https://pic3.zhimg.com/v2-2bfa061afdfea33d5684d999bfc4a15e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>综合：NIO可以让你尽可能的实现连接的高复用性，但是也需要付出一定的代价，代价就是连接需要不断的切换，以及需要考虑不同的数据解析问题。但绝对适合于高并发，但数据量较小的“数据中心”来采用。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数据采集", 
                    "tagLink": "https://api.zhihu.com/topics/19574843"
                }, 
                {
                    "tag": "Io（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/20087899"
                }, 
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38264728", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 2, 
            "title": "Lock接口,比Synchronized更强大的锁", 
            "content": "<h2><b>Lock接口,比Synchronized更强大的锁</b></h2><h2><b>什么是并发问题？</b></h2><p>当多个进程或线程同时访问同一资源时会产生<b>并发</b>问题。</p><p><b>例如：</b></p><p><b>当多个卖票窗口同时出售同一航空公司的机票.</b></p><p>当窗口A,窗口B,窗口C同时出售机票时，可能就会导致同一张机票会被多次卖出。</p><p>—- 示例代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">//出售机票类\npublic class SellTicket implements Runnable {\n    //剩余机票数量\n    private int  ticketNum = 100;\n    @Override\n    public void run() {\n        //出售机票\n        while(true){\n            try {\n                //让线程休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            //当剩余大于0时，才能出售机票\n            if(ticketNum&gt;0){\n                System.out.println(Thread.currentThread().getName()+\n\t\t\t &#34;正在售出剩余的第&#34;+(ticketNum--)+&#34;张票。&#34;);\n\t   }else{\n\t       break;\n\t   }\n\t}\n    }\n}</code></pre></div><p>—- 测试代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n    public static void main(String[] args) {\n        SellTicket st = new SellTicket();\n        Thread t1 = new Thread(st,&#34;窗口A&#34;);\n        Thread t2 = new Thread(st,&#34;窗口B&#34;);\n        Thread t3 = new Thread(st,&#34;窗口C&#34;);\n        \n        t1.start();\n        t2.start();\n        t3.start();\n    }\n}</code></pre></div><p>—- 显示结果</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-788a22f9d265625e2e24b5eadb9620b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-788a22f9d265625e2e24b5eadb9620b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;460&#39; height=&#39;594&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"460\" data-original=\"https://pic1.zhimg.com/v2-788a22f9d265625e2e24b5eadb9620b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-788a22f9d265625e2e24b5eadb9620b4_b.jpg\"/></figure><p>这就是<b><i>典型的并发问题</i></b>。如何解决？可以用<b><i>锁</i></b></p><h2><b><i>锁</i></b> <b>是线程控制的重要途径。</b></h2><p>Java为此也提供了2种锁机制，synchronized 和 Lock.</p><h2><b>关键字 synchronized</b></h2><p>synchronized是java中的一个<b><i>关键字</i></b>，也就是Java语言内置的特性。</p><p>synchronized(隐式锁)，在需要同步的对象中加入此控制，synchronized 可以加在<b><i>方法上</i></b>，也可以加在<b><i>特定代码块中</i></b>，括号中表示需要锁的对象。</p><p><b>1. synchronized 在方法上</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n    public synchronized void method(int num){\n        //需要同步的代码\n        .......\n    }\n}</code></pre></div><p><b>2. synchronized 在特定的代码块</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n    public  void method(int num){\n        //括号中表示需要锁的对象\n        synchronized (this) {\n            //需要同步的代码\n            ......\n        }\n    }\n}</code></pre></div><p><b>使用synchronized解决并发问题</b></p><p>修改代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class SellTicket implements Runnable {\n    //剩余机票数量\n    private int  ticketNum =100;\n    \n    @Override\n    public  void run() {\n        //出售机票\n        while(true){\n            try {\n            //让线程休眠100毫秒\n            Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            //加上同步锁\n            synchronized (this) {\n                if(ticketNum&gt;0){\n                    System.out.println(Thread.currentThread().getName()+\n                    &#34;正在售出剩余的第&#34;+(ticketNum--)+&#34;张票。&#34;);\n                }else{\n                    break;\n                }\n            }\n        }\n    }\n}</code></pre></div><h2><b>既然可以通过synchronized来实现同步访问，那么java为什么还需要提供Lock？</b></h2><h2><b>synchronized的缺陷</b></h2><p>我们了解到如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：</p><ol><li>获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</li><li>线程执行发生异常，此时JVM(java虚拟机)会让线程自动释放锁。</li></ol><p>如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep方法）被阻塞了，但是又没有释放锁，那么其他线程也就只能一直无期限地等待下去，这多么影响程序的执行效率.</p><p><b>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过Lock就可以办到。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>从java 5之后，在java.util.concurrent.locks包下提供了另外一种方式来实现同步访问，那就是Lock。</b></p><p>Lock提供了比synchronized更多的功能。但是要注意以下几点:</p><ol><li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个接口，通过它的实现类可以实现同步访问；</li><li>Lock和synchronized有一点非常大的不同，采用<b><i>synchronized不需要用户手动的释放锁</i></b>，当synchronized方法或者synchronized代码块执行完之后，<b><i>系统会自动</i></b>让线程释放对锁的占用；而Lock则必须要用户<b><i>手动释放锁</i></b>，如果没有主动释放锁，就有可能导致出现 <b><i>死锁</i></b> 现象。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Lock</b></h2><p>Lock（显示锁）：需要显示指定起始位置和终止位置。</p><p>一般使用ReentrantLock类做为锁，多个线程中必须要使用一个ReentrantLock类做为对象才能保证锁的生效。且在<b>加锁和解锁处需要通过</b> <b>lock( ) 和 unlock( )</b> <b>显示指出</b>。所以一般会在finally块中写unlock( )以防死锁。</p><p>– 先看Api</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c98317a0687cbec005b574d253c02051_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1542\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb\" width=\"1542\" data-original=\"https://pic2.zhimg.com/v2-c98317a0687cbec005b574d253c02051_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1542&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1542\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1542\" data-original=\"https://pic2.zhimg.com/v2-c98317a0687cbec005b574d253c02051_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c98317a0687cbec005b574d253c02051_b.jpg\"/></figure><p>Lock 是一个接口.</p><p>Lock 实现提供了比使用 synchronized 方法和语句可获得的更广泛的锁定操作,此实现允许更灵活的结构.</p><p>它提供了 6 个 方法 如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2559e9eb852630bf3f4f4b8af33b2f98_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1994\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb\" width=\"1994\" data-original=\"https://pic1.zhimg.com/v2-2559e9eb852630bf3f4f4b8af33b2f98_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1994&#39; height=&#39;768&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1994\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1994\" data-original=\"https://pic1.zhimg.com/v2-2559e9eb852630bf3f4f4b8af33b2f98_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2559e9eb852630bf3f4f4b8af33b2f98_b.jpg\"/></figure><p>其中获取锁的方法有 4 个：</p><h2><b>lock( )方法</b></h2><p>是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。<br/>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用Lock必须在try{ }catch{ }块中进行，并且将释放锁的操作放在finally块中进行，以保证锁一定被被释放，防止死锁的发生。</p><h2><b>tryLock( ) 方法</b></h2><p>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</p><h2><b>tryLock(long time, TimeUnit unit)方法</b></h2><p>方法和tryLock()方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</p><h2><b>lockInterruptibly( ) 方法</b></h2><p>此方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过lock.lockInterruptibly()想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用threadB.interrupt()方法能够中断线程B的等待过程</p><p>以上是获取锁的4个方法。</p><hr/><h2><b>newCondition( )</b></h2><p>此方法暂且不在此讲述</p><h2><b>unLock( )方法</b></h2><p>方法是用来释放锁的</p><h2><b>ReentrantLock 类</b></h2><p>ReentrantLock 意思是“可重入锁”.</p><p>ReentrantLock是实现了Lock接口的类，并且ReentrantLock提供了更多的方法。</p><p>下面通过一些实例具体看一下如何使用ReentrantLock</p><h2><b>使用 Lock 解决并发问题</b></h2><p>修改后的出售机票类代码为：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class SellTicket implements Runnable {\n    //剩余机票数量\n    private int  ticketNum =100;\n    //创建锁\n    private Lock lock = new ReentrantLock(); // 注意这里的 创建了一把锁\n    @Override\n    public  void run() {\n        //出售机票\n        while(true){\n            try {\n                //让线程休眠100毫秒\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n            //使用Lock 解决并发\n            //获得锁\n            lock.lock(); //上锁\n            try {\n                if(ticketNum&gt;0){\n                    System.out.println(Thread.currentThread().getName()+\n                    &#34;正在售出剩余的第&#34;+(ticketNum--)+&#34;张票。&#34;);\n                }else{\n                    break;\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }finally{\n                //使用lock时,一定记住在finally块中释放锁防止死锁的发生。\n                lock.unlock(); //释放锁\n            }\n        }\n    }\n}</code></pre></div><h2><b>与锁相关的几个概念</b></h2><h2><b>1.可重入锁</b></h2><p>如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。</p><p>举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>如果两个方法method1和method2都用synchronized修饰了，假如某一时刻，线程A执行到了method1，此时线程A获取了这个对象的锁，而由于method2也是synchronized方法，假如synchronized不具备可重入性，此时线程A需要重新申请锁。但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。</p><p>由于synchronized和Lock都具备可重入性，所以不会发生上述现象.</p><h2><b>2. 可中断锁</b></h2><p>可中断锁：顾名思义，就是可以相应中断的锁。<br/>在Java中，synchronized就不是可中断锁，而Lock是可中断锁。</p><p>例如：</p><p>如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><h2><b>3.公平锁</b></h2><p>公平锁即尽量以请求锁的顺序来获取锁。</p><p>比如同时有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该锁，这种就是公平锁。</p><p>非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。</p><p>在Java中，synchronized就是<b><i>非公平锁</i></b>，它无法保证等待的线程获取锁的顺序。</p><p>而对于ReentrantLock，它<b><i>默认情况下是非公平锁，但是可以设置为公平锁</i></b>。</p><p>从ReentrantLock类的构造方法中可以看出</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b5db4e573749e6a82cf9e48b1b0523c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2016\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb\" width=\"2016\" data-original=\"https://pic2.zhimg.com/v2-b5db4e573749e6a82cf9e48b1b0523c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2016&#39; height=&#39;348&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2016\" data-rawheight=\"348\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2016\" data-original=\"https://pic2.zhimg.com/v2-b5db4e573749e6a82cf9e48b1b0523c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b5db4e573749e6a82cf9e48b1b0523c5_b.jpg\"/></figure><h2><b>4. 读写锁</b></h2><p>读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。</p><p>正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。</p><h2><b>关于面试题</b></h2><p>1 .简述synchronized和java.util.concurrent.locks.Lock的异同 ？</p><p>Lock和synchronized有以下几点不同：</p><p>　　1）Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</p><p>　　2）synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</p><p>　　3）Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</p><p>　　4）通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</p><p>　　5）Lock可以提高多个线程进行读操作的效率。</p><p>　　在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized。所以说，在具体使用时要根据适当情况选择。</p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "交互设计", 
                    "tagLink": "https://api.zhihu.com/topics/19556231"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38264099", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "5分钟搞定数据类型和变量的关系", 
            "content": "<p>计算机的内存类似于人的大脑，计算机使用内存来记忆大量运算时要使用数据。内存是一个物理设备，如何来存储一个数据呢？很简单，把内存想象成一间旅馆，要存储的数据就好比要住宿的客人。</p><h2><b>变量和数据类型的关系</b></h2><p>在现实中，旅店的服务人员会询问要住什么样的房间，如：单人间、双人间、总统套间；然后，根据选择的房间类型，服务员会安排合适的房间。<b>先开房间，后入住 其实就描述了数据存入内存的过程。</b></p><p>首先，根据数据类型的类型为它在内存中分配一块空间（即找一个合适的房间），然后数据就可以放进这个空间（即入住）。</p><p>那么为什么对存储空间有要求呢？试想有3个客人，服务员就安排了一个人单人间，这能入住吗？分配的空间过小，会导致数据无法存储。</p><p>数据被存储在内存中，目的是便于在需要时取出来使用，或者如果这个数据被改变了，内存中存储的值也会随之相应的更新，以便下次使用新的数据。</p><p><b>变量与房间的对应关系</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-391431d2c3a08e0ee129ebdbd7dc73a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-391431d2c3a08e0ee129ebdbd7dc73a9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"190\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-391431d2c3a08e0ee129ebdbd7dc73a9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-391431d2c3a08e0ee129ebdbd7dc73a9_b.jpg\"/></figure><p><b>通过变量名可以简单快速的找到存储数据。将指定给变量，就是将数据存储到以别名为变量名的那个房间；调用变量，就是将那个房间中的数据取出来。可见，变量是存储数据的一个基本单元，不同的变量相互独立。</b></p><h2><b>变量的声明和使用</b></h2><p>1）声明变量，即“根据数据类型在内存重申请一块空间”，这里需要给变量名</p><p><b>语法： 数据类型 变量名</b></p><div class=\"highlight\"><pre><code class=\"language-text\">double money;\nint age;\nboolean sex;\nfloat score;</code></pre></div><p>2）给变量赋值，即“将数据存储至对应的内存空间”</p><p><b>语法： 变量名 值</b></p><div class=\"highlight\"><pre><code class=\"language-text\">money = 20.5;\nage = 18;\nsex = true;\nscore = 80.8F;</code></pre></div><p>这样的分解步骤有点繁琐，也可以将步骤（1）（2）合二为一，在声明一个变量的同时给变量赋值。</p><p><b>语法： 数据类型 变量名 = 值</b></p><div class=\"highlight\"><pre><code class=\"language-text\">double money = 20.5;\nint age = 18;\nboolean sex = true;\nfloat score = 80.8F;</code></pre></div><p>3）调用变量。使用存储的变量，我们称之为“调用变量”。</p><div class=\"highlight\"><pre><code class=\"language-text\">//从控制台输出变量的值\nSystem.out.println(money);\nSystem.out.println(age);\nSystem.out.println(sex);\nSystem.out.println(score);</code></pre></div><p>另外,需要注意的是:<b>变量都必须声明和赋值之后才能使用</b>。</p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38239786", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 6, 
            "title": "还不知道线程同步？请进！", 
            "content": "<p><b>还不知道线程同步？ 来来来….</b></p><h2><b>什么叫同步？</b></h2><p>同步（英语：Synchronization）：指对在一个系统中所发生的事件之间进行协调，在时间上出现一致性与统一化的现象。</p><h2><b>为什么要线程同步？</b></h2><p>当多个线程<b><i>同时读写同一份共享资源的时候</i></b>，可能会引起冲突。这时候，我们需要引入线程“同步”机制，即各个线程之间要有先来后到，不能一窝蜂同时挤上去抢作一团。</p><p>线程同步其实就是相对于现实中的“排队”,几个线程之间要排队，一个一个对共享资源进行操作，而不是同时进行操作。</p><p><b>线程同步是为了防止多个线程同时访问同一个数据对象时，对数据造成破坏。</b></p><p><b>线程的同步是保证多线程安全访问资源的一种手段。</b></p><p><b>示例</b></p><p>例如： 这里模仿有<b>6个人同时对同一个银行账户进行存款操作</b></p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n    * \n    * 银行账户类\n    *\n    */\n   public class BankCount {\n   \t//账户名称\n   \tprivate  String  username;\n   \t//账户余额\n   \tprivate int   countcash;\n   \t\n   \t\n   \tpublic BankCount(String username, int countcash) {\n\tsuper();\n\tthis.username = username;\n\tthis.countcash = countcash;\n}\n   \n   \tpublic String getUsername() {\n   \t\treturn username;\n   \t}\n   \n   \tpublic void setUsername(String username) {\n   \t\tthis.username = username;\n   \t}\n   \n   \tpublic int getCountcash() {\n   \t\treturn countcash;\n   \t}\n   \n   \tpublic void setCountcash(int countcash) {\n   \t\tthis.countcash = countcash;\n   \t}\n   \t\n   \t/**\n   \t * 存钱方法\n   \t * @param num 存款金额\n   \t */\n   \tpublic void  save(int num){\n   \t\ttry {\n   \t\t\t//模拟操作的时间\n   \t\t\tThread.sleep(1000);\n   \t\t   //改变账户余额\n   \t\t\tthis.countcash+=num;\n         System.out.println(Thread.currentThread().getName()+&#34;===&gt;&gt;存入&#34;\n         +num+&#34;,当前余额为&#34;+this.countcash);\n   \t\t} catch (InterruptedException e) {\n   \t\t\t// TODO Auto-generated catch block\n   \t\t\te.printStackTrace();\n   \t\t}\n   \t\n   \t}\n   }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * \n * 存款的线程\n *\n */\npublic class SaveThread implements Runnable {\n    //银行账户\n\tprivate BankCount bankCount;\n\t//存款金额\n\tprivate int num;\n\t\n\tpublic SaveThread(BankCount bankCount,int num) {\n\t\tthis.bankCount=bankCount;\n\t\tthis.num=num;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\t//执行存款操作\n\t\tbankCount.save(this.num);\n    }\n}</code></pre></div><p><b>测试代码</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Test {\n    \t\n    \t public static void main(String[] args) {\n    \t\t\n    \t\t\t  BankCount bankCount = new BankCount(&#34;张三&#34;,1000);\n    \t\t\t  Thread t1 = new Thread(new SaveThread(bankCount, 100),&#34;线程1&#34;);\n    \t\t\t  Thread t2 = new Thread(new SaveThread(bankCount, 600),&#34;线程2&#34;);\n    \t\t\t  Thread t3 = new Thread(new SaveThread(bankCount, 500),&#34;线程3&#34;);\n    \t\t\t  Thread t4 = new Thread(new SaveThread(bankCount, 100),&#34;线程4&#34;);\n    \t\t\t  Thread t5 = new Thread(new SaveThread(bankCount, 1000),&#34;线程5&#34;);\n    \t\t\t  Thread t6 = new Thread(new SaveThread(bankCount, 600),&#34;线程6&#34;);\n    \t\t\t  t1.start();\n    \t\t\t  t2.start();\n    \t\t\t  t3.start();\n    \t\t\t  t4.start();\n    \t\t\t  t5.start();\n    \t\t\t  t6.start();\n    \t }\n    \n   }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>运行结果</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eea1e2299b6c516cd41c4e3590fe7b1e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic3.zhimg.com/v2-eea1e2299b6c516cd41c4e3590fe7b1e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic3.zhimg.com/v2-eea1e2299b6c516cd41c4e3590fe7b1e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-eea1e2299b6c516cd41c4e3590fe7b1e_b.jpg\"/></figure><p>很显然，上面的结果是错误的，导致错误的原因就是 多个线程 并发 访问了同一个竞争资源而引起的</p><h2><b>如何解决并发问题？</b></h2><p><b>同步和锁</b></p><p>Java为此也提供了2种锁机制，synchronized 和 Lock.</p><p><b>关键字： synchronized</b></p><p>Java中每一个对象都有一个内置锁。</p><p>当程序运行到synchronized同步代码块时，自动获得锁定对象的锁。</p><p>一个对象只有一个锁。</p><p>所以，如果一个线程获得该锁，就没有其他线程可以获得锁，直到第一个线程释放锁。<br/>这也意味着任何其他线程都不能进入synchronized方法或代码块，直到该锁被释放。</p><p>释放锁是指持锁线程退出了synchronized同步方法或代码块。</p><p>Synchronized是Java中解决并发问题的一种最常用的方法，也是最简单的一种方法。</p><p>Synchronized的作用主要有三个：</p><p>（1）确保线程互斥的访问同步代码<br/>（2）保证共享变量的修改能够及时可见<br/>（3）有效解决重排序问题。</p><p>从语法上讲，Synchronized总共有三种用法：</p><p>（1）修饰普通方法</p><p>（2）修饰静态方法</p><p>（3）修饰代码块</p><p>Java编程语言对 synchronized 提供了两种基本的同步用法： 同步方法 和 同步语句。</p><h2><b>—— synchronized 同步方法</b></h2><p>Synchronized 修饰一个方法很简单，就是在方法的前面加synchronized 关键字即可</p><p>synchronized关键字 放在 修饰符（如：public 等）之后,返回类型声明(如：void等)之前.</p><p>使用synchronized的方法（同步方法),即一次只能有一个线程进入该方法,其他线程要想在此时调用该方法,只能排队等候, 当前线程(就是在synchronized方法内部的线程)执行完该方法后,别的线程才能进入.</p><p>（一） 修饰普通方法</p><h2><b>—示例代码（例如：修改之前账户类的存款方法）</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * 存钱方法 (同步方法)\n * @param num 存款金额\n */\npublic synchronized void  save(int num){\n\ttry {\n\t\t//Thread.sleep(1000);\n\t   //改变账户余额\n\t\tthis.countcash+=num;\n\t\tSystem.out.println(Thread.currentThread().getName()+&#34;===&gt;&gt;存入&#34;+num+&#34;,当前余额为&#34;+this.countcash);\n\t} catch (Exception e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t}\n}</code></pre></div><p>——- 测试结果 ————————</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c583009b2bb289a84fb0141d3eb06d70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"576\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"576\" data-original=\"https://pic1.zhimg.com/v2-c583009b2bb289a84fb0141d3eb06d70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;576&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"576\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"576\" data-original=\"https://pic1.zhimg.com/v2-c583009b2bb289a84fb0141d3eb06d70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c583009b2bb289a84fb0141d3eb06d70_b.jpg\"/></figure><p><b>使用线程同步以后，操作数据就正确了</b>。</p><p>（ 二 ） 修饰静态方法</p><h2><b>示例代码如下</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">public class StaticSynchronizedMethod {\n\t\n\tpublic  synchronized static void testMethod(String threadName){\n\t\t\n\t    System.out.println(threadName+&#34;---调用testMethod方法开始执行.......&#34;);\n\t    \n\t    try {\n\t\t\tThread.sleep(2000);\n\t\t\tSystem.out.println(threadName+&#34;正在执行。。。。&#34;);\n\t\t} catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t    \n\t    System.out.println(threadName+&#34;---testMethod方法完毕。。。。。。&#34;);\n\t} \n}</code></pre></div><p><b>测试代码</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class TestStaticSynchronized {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tfinal StaticSynchronizedMethod   oneObj = new StaticSynchronizedMethod();\n\t\tfinal StaticSynchronizedMethod   twoObj = new  StaticSynchronizedMethod();\n\t\t\n\t\t//开启第一个线程\n\t\tnew Thread(new Runnable() {\n\t\t\t\n\t\t\tpublic void run() {\n\t\t\t\t//调用 testMethod 方法\n\t\t\t\toneObj.testMethod(Thread.currentThread().getName());\n\t\t\t}\n\t\t},&#34;线程1&#34;).start();\n\t\t\n\t\t//开启第二个线程\n\t\t\t\tnew Thread(new Runnable() {\n\t\t\t\t\tpublic void run() {\n\t\t\t\t\t\t//调用 testMethod 方法\n\t\t\t\t\t\ttwoObj.testMethod(Thread.currentThread().getName());\n\t\t\t\t\t}\n\t\t\t\t},&#34;线程2&#34;).start();\n\t\t\n\t}\n}</code></pre></div><p>——- 测试结果 ————————</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-997600ad1ff1220b21fa5eba2cccdcb1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"805\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"805\" data-original=\"https://pic2.zhimg.com/v2-997600ad1ff1220b21fa5eba2cccdcb1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;805&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"805\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"805\" data-original=\"https://pic2.zhimg.com/v2-997600ad1ff1220b21fa5eba2cccdcb1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-997600ad1ff1220b21fa5eba2cccdcb1_b.jpg\"/></figure><h2><b>注意</b></h2><p>对静态方法的同步本质上是对类的同步（静态方法本质上是属于类的方法，而不是对象上的方法），所以即使 oneObj 和 twoObj 属于不同的对象，但是它们都属于StaticSynchronizedMethod 类的实例，所以也只能顺序的执行testMethod方法，不能并发执行。</p><h2><b>Synchronized 关键字 修饰普通方法 与 修饰静态方法 的区别</b></h2><ol><li>synchronized 修饰静态方法是同步某个类的范围。</li></ol><p>如 : synchronized static void testMethod()方法是防止多个线程中多个实例同时访问这个类中的synchronized static 方法。它可以对类的所有对象实例起作用。</p><p>2. synchronized 修饰普通方法是同步某个实例的范围。</p><p>如：public synchronized void save()方法( –存钱的方法–),防止多个线程中 对 同一个实例 同时访问这个对象的 synchronized 方法。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>—— synchronized 同步块</b></h2><p>通过 synchronized 关键字来声明 synchronized 块。语法如下</p><div class=\"highlight\"><pre><code class=\"language-text\"> //syncObject: 同步对象（ 可以是类的实例 或 类 ）\n  synchronized (syncObject) {\n\t\t //允许被同步的代码\n\t\t  \n}</code></pre></div><p><b>示例代码</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class SynchronizedBlock{\n\t\n\t  public  void method(){\n\t\t  //同步执行代码块\n\t\t  // SynchronizedBlock.class  获得SynchronizedBlock的类的锁\n\t\t  // 类\n\t\t /* synchronized (SynchronizedBlock.class) {\n\t\t\t  System.out.println(Thread.currentThread().getName()+&#34;---开始调用---&#34;);\n\t\t\ttry {\n\t\t\t\tThread.sleep(2000);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&#34;--正在执行&#34;);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t System.out.println(Thread.currentThread().getName()+&#34;---调用完毕---&#34;);\n\t\t  }*/\n\t\t  \n\t\t  // 类的实例\n\t\t  synchronized (this) {\n\t\t\t  System.out.println(Thread.currentThread().getName()+&#34;---开始调用---&#34;);\n\t\t\ttry {\n\t\t\t\tThread.sleep(2000);\n\t\t\t\tSystem.out.println(Thread.currentThread().getName()+&#34;--正在执行&#34;);\n\t\t\t} catch (InterruptedException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\t System.out.println(Thread.currentThread().getName()+&#34;---调用完毕---&#34;);\n\t\t  }\n\t  }\n}</code></pre></div><p><b>测试代码</b></p><div class=\"highlight\"><pre><code class=\"language-text\">public class TestSynchronizedBlock {\n\tpublic static void main(String[] args) {\n\t\t//创建一个对象实例\n\t\tfinal SynchronizedBlock obj = new SynchronizedBlock();\n\t\t//启动线程一\n\t\tnew\tThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t   obj.method();\n\t\t\t}\n\t\t},&#34;线程1&#34;).start();\n\t\t\n\t\t//启动线程二\n\t\tnew\tThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t   obj.method();\n\t\t\t}\n\t\t},&#34;线程2&#34;).start();\n\t\t\n\t\t//启动线程三\n\t\tnew\tThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t   obj.method();\n\t\t\t}\n\t\t},&#34;线程3&#34;).start();\n\t\t\n\t\t//启动线程四\n\t\tnew\tThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t   obj.method();\n\t\t\t}\n\t\t},&#34;线程4&#34;).start();\n\t}\n}</code></pre></div><p>——- 测试结果 ————————</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4e83aaf66ba9399bcefea8d588fd2c92_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb\" width=\"904\" data-original=\"https://pic3.zhimg.com/v2-4e83aaf66ba9399bcefea8d588fd2c92_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;904&#39; height=&#39;530&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"904\" data-rawheight=\"530\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"904\" data-original=\"https://pic3.zhimg.com/v2-4e83aaf66ba9399bcefea8d588fd2c92_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4e83aaf66ba9399bcefea8d588fd2c92_b.jpg\"/></figure><h2><b>synchronized 方法 与 synchronized 代码块的区别</b></h2><p>synchronized 方法 与synchronized 代码块 之间 没有什么区别,只是 synchronized 方法便于阅读理解，而synchronized 代码块 可以更精确的控制冲突限制访问区域，有时候表现更高效率。</p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38224192", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 6, 
            "title": "JavaDoc注释与帮助说明文档", 
            "content": "<p>我们知道在java中注释有三种，第一种，单行注释 //注释的内容，第二种，多行注释 /*…注释的内容…*/，第三种 文档注释 /**..注释的内容….*/。不难发现，第三种注释方式和第二种方式很相似，那它出现的目的是什么呢？就是为了便于javadoc程序自动生成文档。接下来咱们聊一聊这个文档注释⋯⋯</p><h2><b>添加注释的原则</b></h2><p>代码注释是架起程序设计者与程序阅读者之间的通信桥梁，最大限度的提高团队开发合作效率，也是程序代码可维护性的重要环节之一。所以看起来非常简单的注释也是有些原则需要遵守：</p><p><b>注释形式统一</b></p><p>在整个应用程序中，使用具有一致的标点和结构的样式来构造注释。如果在其它项目中发现它们的注释规范与这份文档不同，按照这份规范写代码，不要试图在既成的规范系统中引入新的规范。</p><p><b>注释内容准确简洁</b></p><p>内容要简单、明了、含义准确，防止注释的多义性，错误的注释不但无益反而有害。</p><h2><b>注释可以添加的位置</b></h2><p>作为注释，语法上当然是可以添加在程序的任意位置啦！但是我们在添加时候还是要添加在合适的位置，一般添加在类和方法上。如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1fc5d8eead3e4d15c1586c712e9053bf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"575\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb\" width=\"575\" data-original=\"https://pic4.zhimg.com/v2-1fc5d8eead3e4d15c1586c712e9053bf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;575&#39; height=&#39;588&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"575\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"575\" data-original=\"https://pic4.zhimg.com/v2-1fc5d8eead3e4d15c1586c712e9053bf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1fc5d8eead3e4d15c1586c712e9053bf_b.jpg\"/></figure><p>大家仔细看，可以发现注释中有这些东西@author，@version，@see，@param ⋯⋯，这些都是什么含义呢？<br/>这些都称之为java doc标记，含义如下：<br/>@author 标明开发该类模块的作者<br/>@version 标明该类模块的版本<br/>@see 参考转向，也就是相关主题<br/>@param 对方法中某参数的说明<br/>@return 对方法返回值的说明<br/>@exception 对方法可能抛出的异常进行说明</p><p>其中，@author 可以多次使用，以指明多个作者，生成的文档中每个作者之间使用逗号 (,) 隔开。@version 也可以使用多次，只有第一次有效。@param、@return 和 @exception 这三个标记都是只用于方法的。</p><h2><b>把注释生成文档的方式</b></h2><p>通常在编写程序时我们会用IDE工具，比如eclipse，咱们来看看怎么用eclipse生成文档。如下图：</p><p>第一步：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-538c1b8c99d2a757fb7b4c7cf92834c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"906\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb\" width=\"906\" data-original=\"https://pic4.zhimg.com/v2-538c1b8c99d2a757fb7b4c7cf92834c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;906&#39; height=&#39;442&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"906\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"906\" data-original=\"https://pic4.zhimg.com/v2-538c1b8c99d2a757fb7b4c7cf92834c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-538c1b8c99d2a757fb7b4c7cf92834c3_b.jpg\"/></figure><p>下一步：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-22cd279fff47a3e145a0d11f3fec11ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb\" width=\"525\" data-original=\"https://pic3.zhimg.com/v2-22cd279fff47a3e145a0d11f3fec11ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;525&#39; height=&#39;550&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"550\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"525\" data-original=\"https://pic3.zhimg.com/v2-22cd279fff47a3e145a0d11f3fec11ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-22cd279fff47a3e145a0d11f3fec11ee_b.jpg\"/></figure><p>下一步：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f3bdd926687ba2728d639da8daa571ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"660\" class=\"origin_image zh-lightbox-thumb\" width=\"525\" data-original=\"https://pic4.zhimg.com/v2-f3bdd926687ba2728d639da8daa571ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;525&#39; height=&#39;660&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"525\" data-rawheight=\"660\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"525\" data-original=\"https://pic4.zhimg.com/v2-f3bdd926687ba2728d639da8daa571ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f3bdd926687ba2728d639da8daa571ab_b.jpg\"/></figure><p>接着点finish就好啦，可能在点finish的时候弹出一个框，直接选择”yes to all”就好了！找到我的E：\\myapi文件夹，会发现生成了很多文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1ec4ddf81a0a944b776a2f5d23b32257_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-1ec4ddf81a0a944b776a2f5d23b32257_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;619&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"384\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-1ec4ddf81a0a944b776a2f5d23b32257_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1ec4ddf81a0a944b776a2f5d23b32257_b.jpg\"/></figure><p>用浏览器打开你就看到自己想要的东西了！</p><p>说完这个，咱们再说说如何用doc生成文档：</p><p>看图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dc3165cdc391c14b4f9ccc7761e7c96a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"777\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb\" width=\"777\" data-original=\"https://pic3.zhimg.com/v2-dc3165cdc391c14b4f9ccc7761e7c96a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;777&#39; height=&#39;675&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"777\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"777\" data-original=\"https://pic3.zhimg.com/v2-dc3165cdc391c14b4f9ccc7761e7c96a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-dc3165cdc391c14b4f9ccc7761e7c96a_b.jpg\"/></figure><p>参数说明</p><p>-public 仅为public访问级别的类及类的成员生成javaDoc文档</p><p>-proteceted 仅为public和protected访问级别的类及类的成员生成javadoc文档.</p><p>(默认选项)</p><p>-d 指定API文档的输出目录，默认是当前目录。建议总是指定该参数。</p><p>然后找到E:\\mydosapi文件夹，打开index.html就看到文档已经生成好了⋯⋯</p><p>好了，java文档注释就说到这里，如果还有不明白的，那就自行体会，哈哈⋯⋯</p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "文档", 
                    "tagLink": "https://api.zhihu.com/topics/19566746"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38222764", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "程序猿居家旅游必备技能-如何画UML类图", 
            "content": "<p>在系统的逻辑视图中，类图用于表示类和它们之间的关系， 单张类图表示了系统类结构的一个视图。在分析时，我们采用类图来说明实体共同的角色和责任，这些实体提供了系统的行为。在设计时，我们采用类图来记录类的结构，这些类构成了系统的架构。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>类图中的两个基本元素：类和它们的基本关系。</p><h2><b>基本概念：类表示法</b></h2><p>类图标由三部分组成：第一部分用于放置类名，第二部分用于放置属性，第三部分用于放置操作（行为）。</p><p>如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-665eda716b98d7418a8f23de4cac6651_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"466\" data-original=\"https://pic2.zhimg.com/v2-665eda716b98d7418a8f23de4cac6651_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;466&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"466\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"466\" data-original=\"https://pic2.zhimg.com/v2-665eda716b98d7418a8f23de4cac6651_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-665eda716b98d7418a8f23de4cac6651_b.jpg\"/></figure><p>每个类都需要一个名称，而且此名称必须在它的命名空间中是唯一的。并且，按照命名规范，类的名称以大写字母开头，省略多个单词之间的空格。属性和操作的名称以小写字母开头，后续单词的首字母大写，并且像类名一样省略空格。类是它的属性和操作的命名空间，属性名称与操作名称在类的范围内必须无二义。</p><p>属性规格说明格式：<br/>可见性 属性名称：类型【多重性】=默认值 {特性字符串}</p><p>操作规格说明格式：<br/>可见性 操作名称（参数名称：类型）返回值 {特性字符串}</p><p>对于特定的类图，显示一个类的某些属性和操作是有用的。对于凡是具有一点重要性的类，在一张类图中显示它的所有属性既不方便，也不必要。一般只显示重要的属性和行为。</p><p>抽象类是不能创建实例的类，但是这种类对于构建良好的类层次结构非常重要，所以提供了一种特殊的方式来表示抽象类。具体来说，用斜体来显示其类名，表明只能为它的子类创建实例。当然，为了表明一个操作是抽象的，同样采用斜体来显示操作名称。意味着这个操作可以在它的子类中以不同的方式实现。如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-371471cb4fc14aa2c39969a46e003046_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"240\" class=\"content_image\" width=\"408\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;408&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"240\" class=\"content_image lazy\" width=\"408\" data-actualsrc=\"https://pic3.zhimg.com/v2-371471cb4fc14aa2c39969a46e003046_b.jpg\"/></figure><h2><b>基本概念：类关系</b></h2><p>在UML类图中，常见的类关系有：泛化（Generalization），实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency)。</p><p><b>泛化（Generalization）：</b></p><p>【泛化关系】：是一种继承关系，是”是一种”关系的体现 ，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性</p><p>【箭头指向】 ：带三角箭头的实线，箭头指向父类，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-35acd7a37834c04a129dc7385da6a173_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"175\" data-rawheight=\"306\" class=\"content_image\" width=\"175\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;175&#39; height=&#39;306&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"175\" data-rawheight=\"306\" class=\"content_image lazy\" width=\"175\" data-actualsrc=\"https://pic4.zhimg.com/v2-35acd7a37834c04a129dc7385da6a173_b.jpg\"/></figure><p><b>实现（Realization）：</b></p><p>【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现。<br/>【箭头指向】：带三角箭头的虚线，箭头指向接口，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2936000951d9fc64396c8bd3adcca011_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"262\" class=\"content_image\" width=\"180\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;180&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"262\" class=\"content_image lazy\" width=\"180\" data-actualsrc=\"https://pic2.zhimg.com/v2-2936000951d9fc64396c8bd3adcca011_b.jpg\"/></figure><p><b>关联（Association)：</b></p><p>【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。<br/>【代码体现】：成员变量<br/>【箭头及指向】：带普通箭头的实心线，指向被拥有者，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bc9c9b8f281b20bac8cade386042939e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-bc9c9b8f281b20bac8cade386042939e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;112&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"112\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-bc9c9b8f281b20bac8cade386042939e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bc9c9b8f281b20bac8cade386042939e_b.jpg\"/></figure><p>上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西它不拥有学生。</p><p>下图为自身关联：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-45fe9a167535798fb0f85244639b9228_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"259\" data-rawheight=\"164\" class=\"content_image\" width=\"259\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;259&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"259\" data-rawheight=\"164\" class=\"content_image lazy\" width=\"259\" data-actualsrc=\"https://pic1.zhimg.com/v2-45fe9a167535798fb0f85244639b9228_b.jpg\"/></figure><p><b>聚合（Aggregation）：</b></p><p>【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。</p><p>聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。<br/>【代码体现】：成员变量<br/>【箭头及指向】：带空心菱形的实心线，菱形指向整体，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-83760f135a0f8e5b8827d41bcabc0826_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"410\" data-rawheight=\"296\" class=\"content_image\" width=\"410\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;410&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"410\" data-rawheight=\"296\" class=\"content_image lazy\" width=\"410\" data-actualsrc=\"https://pic3.zhimg.com/v2-83760f135a0f8e5b8827d41bcabc0826_b.jpg\"/></figure><p><b>组合(Composition)：</b></p><p>【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。</p><p>组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。选择聚合通常是分析或架构设计时的决定，选择组合（物理包容）通常是具体的、战术的问题。区分物理包容是有必要的，因为在构建和销毁聚合体的部分时，它的语义会起作用。</p><p>【代码体现】：成员变量</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-621ece8b07eafdc274d8788d939f2aa0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"301\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;301&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"301\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic1.zhimg.com/v2-621ece8b07eafdc274d8788d939f2aa0_b.jpg\"/></figure><p>【箭头及指向】：带实心菱形的实线，菱形指向整体</p><p><b>依赖(Dependency)：</b></p><p>【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖。<br/>【代码表现】：局部变量、方法的参数或者对静态方法的调用<br/>【箭头及指向】：带箭头的虚线，指向被使用者，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f777bc26982a7430c191c44b4a1312a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"263\" class=\"content_image\" width=\"221\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;221&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"221\" data-rawheight=\"263\" class=\"content_image lazy\" width=\"221\" data-actualsrc=\"https://pic3.zhimg.com/v2-f777bc26982a7430c191c44b4a1312a2_b.jpg\"/></figure><p>各种关系的强弱顺序：</p><p>泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖</p><p>下面这张UML图，比较形象地展示了各种类图关系：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0d7366b41b60889cd34f345a59a89b3f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic4.zhimg.com/v2-0d7366b41b60889cd34f345a59a89b3f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic4.zhimg.com/v2-0d7366b41b60889cd34f345a59a89b3f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0d7366b41b60889cd34f345a59a89b3f_b.jpg\"/></figure><p>在类图上，大家可能看到1或者n的字样，实际上这是“多重性”的体现，多重性就是是否存在多个的体现。多应用于关联的目标端，说明源类和目标类实例的连接个数。通常最好显示多重性，避免造成误解。</p><p></p>", 
            "topic": [
                {
                    "tag": "企业级应用", 
                    "tagLink": "https://api.zhihu.com/topics/20046628"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38221431", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "事务，程序猿不知道会出大事的", 
            "content": "<p>事务管理是应用程序中不可缺少的一部分，合理应用事务管理对于整个应用系统来说至关重要。事务是为了解决数据安全操作而提出的，通过事务可以控制用户对数据的安全访问。那么，事务是怎么产生的？如何实现事务管理？如果不使用事务管理会发生什么问题？我们今天就来了解一下。</p><h2><b>事务产生的背景</b></h2><p>我们先来看一个例子：银行中提供了转帐业务，现在A帐户要转帐2000元给B帐户。在这个转帐业务中，需要进行两次数据库更新操作。A帐户首先要减去2000元，然后B帐户要增加2000元。如果这时网络出现了故障，A帐户减去2000元成功，但B帐户由于网络故障，并没有增加2000元。那么这时，问题就大了。A帐户认为钱已经给B帐户了，因为A帐户的钱减少了。B帐户认为A帐户没有转帐，因为B帐户的钱没有增加。</p><p>我们再来看一个例子：用户去购物网站购物，当用户买了一大堆的商品后，提交订单。对服务器而言，在订单中，应该记录用户的姓名、电话、送货地址等等信息。除此之外，还应该记录该订单中用户买了哪些商品，每种商品购买的数量等信息。如果这时，订单信息记录成功，但服务器忽然死机。这样，就会导致订单信息记录成功。但是，用户购买的商品信息并没有记录。</p><p>从上面的示例可以看出，在一个业务中，如果有多次数据库更新操作时，这些操作可能会因为某些问题（比如，网络故障，停电，死机等等），而导致部分操作成功，部分操作失败的情况。如果不解决这个问题，会造成数据库数据的混乱，给用户造成巨大的损失。</p><p>从第一个示例可以看出，A帐户钱减少了2000元，B帐户的钱没有增加。这样，会导致A帐户白白损失2000元。如果数据安全问题不解决，一旦转帐金额巨大，客户会损失很多钱。</p><p>从第二个示例可以看出，当商家看到订单时，无法确认用户在该订单中买了哪些商品，也就无法发货。用户也无法收到自己购买的商品。</p><p>那么，如何解决这些问题呢？于是，在业务层架构模式中，人们提出事务脚本的概念。</p><h2><b>事务脚本</b></h2><p>那么什么是事务脚本呢？首先，我们来看一下脚本。脚本也就是方法，在很多时候，一个业务中，可能需要进行很多的操作，比如：查询、更新、数据处理等操作。按照迪米特法则，软件实体之间应该尽量减少交互。所以，我们应该把这些属于一个业务的操作封装成一个方法，这就是所谓的脚本。事实上，我们将转帐业务中的，A帐户减钱，B帐户加钱的这些操作，封装成转帐方法；以及将订单信息的添加，和该订单购物明细添加的这些操作，封装成提交订单方法；都称之为脚本。</p><p>但是，在脚本中，很可能有多次数据库更新操作。这些操作可能会部分成功，部分失败。这样，会导致数据库数据的混乱。那么如何防止这一点呢？这就需要进行事务管理。</p><p>事务是用户定义的一个操作序列。事务认为，这些操作序列是一个不可分割的工作单位。事务有四个特点：原子性、一致性、隔离性和持久性。</p><p>事务的原子性，表示事务执行过程中，用户定义的操作序列要么全部执行成功，要么全部执行失败。</p><p>事务的一致性，表示当事务执行失败时，所有被该事务影响的数据都应该恢复到事务执行前的状态，这称为事务回滚。</p><p>事务的隔离性，表示在事务执行过程中对数据的修改，在事务提交之前对其他事务不可见。</p><p>事务的持久性，表示事务完成之后，对系统的影响是永久性的。如果已提交的数据在事务执行失败时，数据的状态都应该正确。</p><p>从事务的特点可以看出，通过事务，数据库能将逻辑相关的一组操作绑定在一起，以便数据库保持数据的完整性。当一个操作序列中，多个操作进行的时候，某个操作执行失败。为了保持数据的完整性，需要使用事务回滚。让该事务影响的数据恢复到事务执行前的状态，从而保证数据的完整性和安全性，防止出现数据混乱。</p><p>综上所述，事务脚本的含义是，将一个业务中所有的操作封装成一个方法。保证方法中，所有数据库更新操作（查询操作中，数据库数据没有发生变化，所以不纳入事务范围），要么同时成功，要么同时失败。不允许部分成功，部分失败这样引起数据混乱的操作。</p><h2><b>如何实现事务管理？</b></h2><p>那么，如何实现事务管理呢？如何在一系列操作时，有一个操作失败时，回滚到事务执行前的状态呢？</p><p>在java中，数据库操作都是使用JDBC完成的。在事务的控制上，可以使用Connection对象来完成。JDBC Connection接口提供了两种事务模式：自动提交和手工提交。默认情况下，采用自动提交方式。也就是在</p><div class=\"highlight\"><pre><code class=\"language-text\">PreparedStatement.executeUpdate();</code></pre></div><p>方法执行后，马上更新数据库中的数据。那么，很明显，如果采用自动提交方式，无法实现对事务的管理。</p><p>在JDBC中，要实现对事务的控制，需要有两个条件：</p><p>a、在事务中所有的数据更新操作，必须使用同一个连接对象。</p><p>b、将事务提交方式设置为手工提交。在所有操作都成功以后，再手工提交事务，更新数据库数据。如果操作失败，一般都会有异常发生。那么，应该在catch块中，进行事务回滚操作。</p><p>在Connection接口中，提供了</p><div class=\"highlight\"><pre><code class=\"language-text\">public void setAutoCommit(boolean autoCommit);</code></pre></div><p>方法，设置提交的方式。当boolean值设置为true时，表示自动提交，这也是默认的方式。如果设置为false，表示手工提交。</p><p>在手工提交方式下，即使PreparedStatement.executeUpdate()方法执行以后，也不会对数据库数据进行更新。只有在调用了Connection的</p><div class=\"highlight\"><pre><code class=\"language-text\">public void commit();</code></pre></div><p>方法以后，数据库数据才会进行更新。</p><p>那么，在某一个操作出现异常后，如何进行事务回滚呢？在Connection接口中，提供了</p><div class=\"highlight\"><pre><code class=\"language-text\">public void rollback();</code></pre></div><p>方法，可以让该事务影响的数据恢复到事务执行前的状态。</p><p>现在，以添加订单和订单明细为例，我们来看一下，如何在业务层中实现事务管理。首先，新建连接对象。</p><div class=\"highlight\"><pre><code class=\"language-text\">public static Connection getConnection(){\n\t\ttry{\n\t\t\tClass.forName(&#34;com.mysql.jdbc.Driver&#34;);\n\t\t\tConnection con = DriverManager.getConnection(&#34;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&#34;,&#34;root&#34;,&#34;123&#34;);\n\t\t\t//设置提交方式为手工提交\n\t\t\tcon.setAutoCommit(false);\n\t\t\treturn con;\n\t\t}catch(Exception e){\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n   }</code></pre></div><p>其次，在业务方法中，调用持久操作时，让每个DAO使用同一个连接对象。</p><p>OrderDao代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class OrderDaoImpl implements IOrderDao{\n\t\tprivate Connection con;\n\t\tpublic void setConnection(Connection con){\n\t\t\tthis.con = con;\n\t\t}\n\t\t\n\t\tpublic int addOrder(OrderBean bean){\n\t\t\tPreparedStatement ps = con.prepareStatement(&#34;……&#34;);\n\t\t\t……//执行添加方法\n\t\t\tps.executeUpdate();\n\t\t}\n   }</code></pre></div><p>OrderInfoDao代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class OrderInfoDao implements IOrderInfoDao{\n\t\tprivate Connection con;\n\t\tpublic void setConnection(Connection con){\n\t\t\tthis.con = con;\n\t\t}\n\t\t\n\t\tpublic int addOrderInfo(OrderInfoBean bean){\n\t\t\tPreparedStatement ps = con.prepareStatement(&#34;……&#34;);\n\t\t\t……//执行添加方法\n\t\t\tps.executeUpdate();\n\t\t}\n   }</code></pre></div><p>业务方法代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public class OrderService{\n\t\tprivate IOrderDao orderDao = new OrderDaoImpl();\n\t\tprivate IOrderInfoDao orderInfoDao = new OrderInfoDaoImpl();\n\t\t\n\t\tpublic void addOrder(OrderBean bean,List&lt;OrderInfoBean&gt; orderInfoList){\n\t\t\t//得到连接对象\n\t\t\tConnection con = DBUtil.getConnection();\n\t\t\ttry{\n\t\t\t\n\t\t\t\t//设置每个DAO的连接对象。保证每个DAO操作数据时，使用同一个连接对象\n\t\t\t\torderDao.setConnection(con);\n\t\t\t\torderInfoDao.setConnection(con);\n\t\t\t\t\n\t\t\t\t……//执行业务操作\n\t\t\t\t\n\t\t\t\t//操作全部成功，提交事务\n\t\t\t\tcon.commit();\n\t\t\t}catch(Exception e){\n\t\t\t\te.printStackTrace();\n\t\t\t\t//在try块中出现异常，则回滚事务，回到事务执行前的状态\n\t\t\t\tcon.rollback();\n\t\t\t}finally{\n\t\t\t\t……//关闭连接\n\t\t\t}\n\t\t}\n   }</code></pre></div><p>当然，在业务层中不应该出现Connection之类的持久层组件。不过，我们可以通过代理模式，将事务管理从实际业务中分离出来，让业务层只关注业务操作，而不用关心事务的管理。</p><h2><b>总结</b></h2><ol><li>事务管理对于整个应用系统来说至关重要，通过事务可以控制用户对数据的安全访问。</li><li>事务是用户定义的一个操作序列，这些操作序列是一个不可分割的工作单位。事务有四个特点：原子性、一致性、隔离性和持久性。</li><li>事务脚本的含义是，将一个业务中所有的操作封装成一个方法。保证方法中，所有数据库更新操作，要么同时成功，要么同时失败。不允许部分成功，部分失败这样引起数据混乱的操作。</li><li>在JDBC中，要实现对事务的控制，需要有两个条件：<br/>a. 在事务中所有的数据更新操作，必须使用同一个连接对象。<br/>b. 将事务提交方式设置为手工提交，在所有操作都成功以后，再手工提交事务，更新数据库数据。如果操作失败，一般都会有异常发生，那么应该在catch块中，进行事务回滚操作。</li><li>Connection的setAutoCommit(false)可以实现手工提交，通过commit()方法才能真正更新数据库。通过rollback()方法可以在发生异常时回滚事务。</li></ol><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "软件工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19558713"
                }, 
                {
                    "tag": "女程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19601346"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38123828", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 2, 
            "title": "web工程的运作原理简单解析", 
            "content": "<h2><b>引子</b></h2><p>在java web的学习中,JSP具有承上启下的作用。基本上包含了前面我们学习的所有内容,所以也是学习的难点。在JSP的学习中，我们还用到了一个新的软件应用服务器Tomcat,但是在教学过程中发现,很多同学基本就不是太理解Tomcat的基本原理,就只是在学习的过程中机械的把myeclipse里面的内容导入到Tomcat中,再输入网址运行。甚至有些同学把myeclipse换成eclipse就不知道如何去建工程写程序了。出现这个问题的原因还是同学们把知识学的太死,平时只是按照老师写的程序依葫芦画瓢,不知道程序或者软件底层的一些意义,所以今天这篇文章主要是探讨一下Tomcat的一些基本的运作原理。</p><h2><b>web运行原理</b></h2><p>要理解Tomcat其实首先就是要理解Web的运行原理,基本上每个同学都上网,但是既然我们自己在学习在做动态网页，有没有真正考虑过我们在浏览网页时底层的一些基本运行原理。<br/>当我们输入一个网址,如<a href=\"https://link.zhihu.com/?target=HTTP%3A//www.lovo.com/JAVA/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">HTTP://www.</span><span class=\"visible\">lovo.com/JAVA/index.htm</span><span class=\"invisible\">l</span><span class=\"ellipsis\"></span></a><br/>这中间其实是你的客户端浏览器与服务器端的通信过程,具体如下：</p><ol><li>浏览器与网络上的域名为<a href=\"https://link.zhihu.com/?target=http%3A//www.lovo.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">lovo.com</span><span class=\"invisible\"></span></a> 的 Web服务器建立TCP连接</li><li>浏览器发出要求访问JAVA/index.html的HTTP请求</li><li>Web服务器在接收到HTTP请求后，解析HTTP请求，然后发回包含index.html文件数据的HTTP响应</li><li>浏览器接受到HTTP响应后，解析HTTP响应，并在其窗口中展示index.html文件</li><li>浏览器与Web服务器之间的TCP连接关闭</li></ol><p>就是这样的一个简单过程,有些同学可能会说,这个过程书上也有,还有图。但是，就是这个样子的一个过程，中间就有很多值得探讨的地方。</p><p>我们来解析一下,从上面这个过程中分析出</p><p><b>浏览器应该有一下的功能</b>：</p><ol><li>请求与Web服务器建立TCP连接</li><li>创建并发送HTTP请求</li><li>接受并解析HTTP响应</li><li>展示html文档</li></ol><p><b>Web服务器应该具有的功能</b>：</p><ol><li>接受来自浏览器的TCP的请求</li><li>接收并解析HTTP请求</li><li>创建并发送HTTP响应</li></ol><p>HTTP客户程序(浏览器)和HTTP服务器分别由不同的软件开发商提供,目前<br/>最流行的浏览器IE，Firefox，Google Chrome，Apple Safari等等，最常用的Web服务器有IIS，Tomcat，Weblogic，jboss等。不同的浏览器和Web服务器都是不同的编程语言编写的，那么用C++编写的HTTP客户端浏览器能否与用JAVA编写的Web服务进行通信呢？允许在苹果系统上的Safari浏览器能否与运行在Windows或者Linux平台上的Web服务器进行通信呢？</p><p>前面说了这么多，就是引出这一句话。</p><p>为什么不同语言编写，不同平台运行的软件双方能够看懂对方的数据呢？</p><p><b>这主要归功于HTTP协议</b>：</p><p>HTTP协议严格规定了HTTP请求和HTTP响应的数据格式，只要Web服务器与客户端浏览器之间的交换数据都遵守HTTP协议，双方就能看懂对方发送的数据从而进行交流。</p><hr/><h2><b>HTTP请求格式</b></h2><p>HTTP协议规定，HTTP请求由三部分组成</p><ol><li>请求方法，URI和HTTP协议的版本</li><li>请求头(Request Header)</li><li>请求正文(Request Content)</li></ol><p>看一个<b>HTTP请求</b>的列子:</p><div class=\"highlight\"><pre><code class=\"language-text\">//请求方法,URI和HTTP协议的版本\nPOST /servlet/default.JSP HTTP/1.1\n//========请求头==================//\nAccept: text/html,application/xml;q=0.9,application/xhtml+xml,image/png,\n    image/jpeg,image/gif,image/x-xbitmap,*/*;q=0.1 \nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8 \nAccept-Charset: iso-8859-1, utf-8, utf-16, *;q=0.1 \nAccept-Encoding: deflate, gzip, x-gzip, identity, *;q=0 \nConnection: Keep-Alive \nHost: localhost \nReferer: HTTP://localhost/ch8/SendDetails.htm \nUser-Agent: Mozilla/4.0 (compatible; MSIE 4.01; Windows 98) \nContent-Length: 33 \nContent-Type: application/x-www-form-urlencoded  \n//========请求头==================//\n//请求正文\nLastName=Franks&amp;FirstName=Michael</code></pre></div><p><b>请求方法，URI和HTTP协议版本</b></p><p>这三个都在HTTP请求的第一行，以空格分开，以上代码中”post”为请求方式，”/servlet/default.JSP”为URI， ”HTTP/1.1”为HTTP协议版本</p><p><b>请求头</b></p><p>请求头包含许多有关客户端环境和请求正文的有用信息。比如包含浏览器类型，所用语言，请求正文类型以及请求正文长度等。</p><p><b>请求正文</b></p><p>HTTP协议规定，请求头和请求正文之间必须以空行分割(\\r\\n),这个空行很重要，它表示请求头已经结束，接下来是请求正文。在请求正文中可以包含客户以Post方式提交的数据表单<br/>LastName=Franks&amp;FirstName=Michael</p><h2><b>HTTP响应格式</b></h2><p>和请求相似，HTTP响应也是由3部分组成</p><ol><li>HTTP协议的版本，状态代码和描述</li><li>响应头(Response Header)</li><li>响应正文(Response Content)</li></ol><p>看一个HTTP响应列子:</p><div class=\"highlight\"><pre><code class=\"language-text\">HTTP/1.1 200 OK \nDate: Tues, 07 May 2013 14:16:18 GMT \nServer: Apache/1.3.31 (Unix) mod_throttle/3.1.2 \nLast-Modified: Tues, 07 May 2013 14:16:18 \nETag: &#34;dd7b6e-d29-39cb69b2&#34; \nAccept-Ranges: bytes \nContent-Length: 3369 \nConnection: close \nContent-Type: text/html\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;hello&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;hello&lt;/h1&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p><b>HTTP协议版本,状态代码和描述</b></p><p>HTTP响应第一行也是3个内容，同样以空格分隔，依次是HTTP协议版本，状态代码以及对状态代码的描述。状态代码200表示服务器已经成功处理了客户端发送的请求。状态代码是三位整数，以1，2，3，4，5开头，具体有哪些常见的状态代码这里不再多做描述。</p><p><b>响应头</b></p><p>响应头主要是一些描述信息，如服务器类型，正文类型和正文长度等</p><p><b>响应正文</b></p><p>响应正文就是服务器返回的具体数据，它是浏览器真正请求访问的信息，最常见的当然就是HTML。同样，响应正文和响应头同样需要以空行分割</p><h2><b>分析</b></h2><p>前面说了这么多，描述的HTTP请求和响应的内容，主要是引出下面的内容，既然Tomcat可以作为Web服务器，那么我们自己能不能根据HTTP请求和响应搭建一个自己简单的Web服务器呢？</p><p>我们在启动好Tomcat后，访问的地址如<a href=\"https://link.zhihu.com/?target=HTTP%3A//127.0.0.1%3A8080/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">HTTP://</span><span class=\"visible\">127.0.0.1:8080/index.ht</span><span class=\"invisible\">ml</span><span class=\"ellipsis\"></span></a>, 经过分析，前面的127.0.0.1无非就是主机IP，而8080就是Tomcat监听端口， index.html是我们需要访问的网址，其实也就是Tomcat帮我们读取之后，响应给我们的内容，这是在Tomcat上存在的一个网页。</p><p>根据上面的分析，我们自己要建一个简单的Web服务器，那就简单了，就是自己写一段JAVA代码，代替Tomcat监听在8080端口，然后打开网页输入8080端口后进入自己的代码程序，解析HTTP请求，然后在服务器本地读取html文档，最后再响应回去不就行了么？</p><h2><b>用JAVA套接字创建HTTP服务器程序</b></h2><p>首先做好准备工作，注意整个测试工程的路径是下面这样子的，如图:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3ae85b58706ceb0760ea741a6fadb9c7_b.jpg\" data-rawwidth=\"524\" data-rawheight=\"212\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"524\" data-original=\"https://pic4.zhimg.com/v2-3ae85b58706ceb0760ea741a6fadb9c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;524&#39; height=&#39;212&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"524\" data-rawheight=\"212\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"524\" data-original=\"https://pic4.zhimg.com/v2-3ae85b58706ceb0760ea741a6fadb9c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3ae85b58706ceb0760ea741a6fadb9c7_b.jpg\"/></figure><p>这个html文件在工程中我放在了test文件夹下面，接下来上代码</p><p>html中的代码很简单<br/><b>index.html</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;meta charset=&#34;UTF-8&#34;&gt;\n&lt;title&gt;Test&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\nHello!!\n&lt;/body&gt;\n&lt;/html&gt;</code></pre></div><p><b>HTTPServer.java</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.ying.http;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\npublic class HTTPServer {\n    public static void main(String[] args) {\n        int port;\n        ServerSocket serverSocket;\n        try {\n            serverSocket = new ServerSocket(8080);\n            System.out.println(&#34;服务器正在监听:&#34; + \n                serverSocket.getLocalPort());\n            while(true){\n                try {\n                    Socket socket = serverSocket.accept();\n                    System.out.println(&#34;服务器与一个客户端建立了新的连接,&#34; + \n                        &#34;该客户端的地址为:&#34; +\n                        socket.getInetAddress() + &#34;:&#34; + \n                        socket.getPort());\n                        service(socket);\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\t\n\tpublic static void service(Socket socket) throws Exception{\n\t\tInputStream socketIn = socket.getInputStream();\n\t\tThread.sleep(500);\n\t\tint size = socketIn.available();\n\t\tbyte[] buffer = new byte[size];\n\t\tsocketIn.read(buffer);\n\t\tString request = new String(buffer);\n\t\tif(request.equals(&#34;&#34;)) return;\n\t\tSystem.out.println(request);\n\t\t\n\t\tint l = request.indexOf(&#34;\\r\\n&#34;);\n\t\tString firstLineRequest = request.substring(0, l);\n\t\tString [] parts = firstLineRequest.split(&#34; &#34;);\n\t\tString uri = parts[1];\n\t\t\n\t\t//HTTP响应正文类型\n\t\tString contentType;\n\t\tif(uri.indexOf(&#34;html&#34;) != -1 || \n\t\t  uri.indexOf(&#34;html&#34;) != -1){\n\t\t\tcontentType = &#34;text/html&#34;;\n\t\t}else if(uri.indexOf(&#34;jpg&#34;) != -1 || \n\t\t  uri.indexOf(&#34;jpeg&#34;) != -1){\n\t\t\tcontentType = &#34;image/jpeg&#34;;\n\t\t}else if(uri.indexOf(&#34;gif&#34;) != -1){\n\t\t\tcontentType = &#34;image/gif&#34;;\n\t\t}else\n\t\t\tcontentType = &#34;application/octet-stream&#34;;\n\t\t\n\t\t/*创建HTTP响应结果*/\n\t\tString responseFirstLine = &#34;HTTP/1.1 200 OK\\r\\n&#34;;\n\t\tString responseHeader = &#34;Content-Tyep:&#34; + contentType + \n\t\t  &#34;\\r\\n\\r\\n&#34;;\n\t\tInputStream in = \n\t\t  HTTPServer.class.getResourceAsStream(&#34;test/&#34; + uri);\n\t\t\n\t\tOutputStream socketOut = socket.getOutputStream();\n\t\tsocketOut.write(responseFirstLine.getBytes());\n\t\tsocketOut.write(responseHeader.getBytes());\n\t\t\n\t\tint len = 0;\n\t\tbuffer = new byte[128];\n\t\twhile((len=in.read(buffer)) != -1){\n\t\t\tsocketOut.write(buffer,0,len);\n\t\t}\n\t\tThread.sleep(1000);\n\t\tsocket.close();\n\t}\n}</code></pre></div><p>大家可以看到上面的代码其实就是操作了一些HTTP请求与响应的协议字符串而已。写好上面的代码后，我们启动浏览器，输入<a href=\"https://link.zhihu.com/?target=HTTP%3A//127.0.0.1%3A8080/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">HTTP://</span><span class=\"visible\">127.0.0.1:8080/index.ht</span><span class=\"invisible\">ml</span><span class=\"ellipsis\"></span></a> 大家会看到下面的效果:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-abc73314e915a261706ed1dcf6d9c8b8_b.jpg\" data-rawwidth=\"1010\" data-rawheight=\"240\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"1010\" data-original=\"https://pic1.zhimg.com/v2-abc73314e915a261706ed1dcf6d9c8b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1010&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1010\" data-rawheight=\"240\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1010\" data-original=\"https://pic1.zhimg.com/v2-abc73314e915a261706ed1dcf6d9c8b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-abc73314e915a261706ed1dcf6d9c8b8_b.jpg\"/></figure><p>浏览器自动帮我们输出了index.html下面的文字，</p><div class=\"highlight\"><pre><code class=\"language-text\">服务器与一个客户端建立了新的连接,该客户端的地址为:/127.0.0.1:57891\nGET /index.html HTTP/1.1\nHost: 127.0.0.1:8080\nConnection: keep-alive\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nAccept-Encoding: gzip, deflate, sdch, br\nAccept-Language: en-US,en;q=0.8,zh-CN;q=0.6,zh;q=0.4</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>这其实就是一个简单自制的HTTP远程访问，但是上面的代码就只是能根据原始的html返回内容，不能和客户端发生交互，那么现在做一个<b>简单交互</b>。</p><h2><b>和服务器进行交互</b></h2><p>比如我们输入如下网址:</p><p><a href=\"https://link.zhihu.com/?target=HTTP%3A//127.0.0.1%3A8080/servlet/HelloServlet%3FuserName%3Dyingside\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">HTTP://</span><span class=\"visible\">127.0.0.1:8080/servlet/</span><span class=\"invisible\">HelloServlet?userName=yingside</span><span class=\"ellipsis\"></span></a></p><p>那么就应该能出现下面这样的效果</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f8a3444310a7cb9d174dfb014728c55c_b.jpg\" data-rawwidth=\"1102\" data-rawheight=\"284\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"1102\" data-original=\"https://pic1.zhimg.com/v2-f8a3444310a7cb9d174dfb014728c55c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1102&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1102\" data-rawheight=\"284\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1102\" data-original=\"https://pic1.zhimg.com/v2-f8a3444310a7cb9d174dfb014728c55c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f8a3444310a7cb9d174dfb014728c55c_b.jpg\"/></figure><p>输入:</p><p><a href=\"https://link.zhihu.com/?target=HTTP%3A//127.0.0.1%3A8080/servlet/HelloServlet%3FuserName%3Dlovo\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">HTTP://</span><span class=\"visible\">127.0.0.1:8080/servlet/</span><span class=\"invisible\">HelloServlet?userName=lovo</span><span class=\"ellipsis\"></span></a></p><p>就会是这样的效果:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-08204db3de18c3e8fbbfd40ee31cf007_b.jpg\" data-rawwidth=\"988\" data-rawheight=\"260\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"988\" data-original=\"https://pic4.zhimg.com/v2-08204db3de18c3e8fbbfd40ee31cf007_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;988&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"988\" data-rawheight=\"260\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"988\" data-original=\"https://pic4.zhimg.com/v2-08204db3de18c3e8fbbfd40ee31cf007_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-08204db3de18c3e8fbbfd40ee31cf007_b.jpg\"/></figure><p>其实这里我们只要对之前的代码做一下简单的修改，让代码能够分析出后面的值就行了。</p><p>首先,先来看一下,我们修改之后工程的路径,因为代码中一些路径都是写死了的,为了避免出错,大家先按照我工程的路径搭建就行了.</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c44ba3574f58abbde2d540b045ccfbdf_b.jpg\" data-rawwidth=\"520\" data-rawheight=\"344\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-c44ba3574f58abbde2d540b045ccfbdf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;520&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"520\" data-rawheight=\"344\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"520\" data-original=\"https://pic4.zhimg.com/v2-c44ba3574f58abbde2d540b045ccfbdf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c44ba3574f58abbde2d540b045ccfbdf_b.jpg\"/></figure><p>这里把分析后面参数值的内容专门放在了一个类中，为了让这个类具有通用性，定义了一个接口 <b>Servlet.java</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.ying.http;\nimport java.io.OutputStream;\npublic interface Servlet {\n\tvoid init() throws Exception;\n\tvoid service(byte[] requestBuffer,OutputStream out) \n\t   throws Exception;\n}</code></pre></div><p><b>init()方法</b>:为初始化方法，当HTTPServer创建了实现该接口的类的一个实例后,就会立即调用该实例的init()方法</p><p><b>service()方法</b>:用于响应HTTP请求，产生具体的HTTP响应结果。</p><p><b>HelloServlet.java</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.ying.http;\nimport java.io.OutputStream;\npublic class HelloServlet implements Servlet {\n  public void init() throws Exception {\n     System.out.println(&#34;Hello Servlet is inited&#34;);\n  }\n  @Override\n  public void service(byte[] requestBuffer, OutputStream out) \n      throws Exception {\n    String request = new String(requestBuffer);\n    //获得请求的第一行\n    String firstLineRequest=request.substring(0, request.indexOf(&#34;\\r\\n&#34;));\n    String [] parts = firstLineRequest.split(&#34; &#34;);\n    String method = parts[0];//获得HTTP请求中的请求方式\n    String uri = parts[1];//获得uri\n    \n    String userName = null;\n    //如果请求方式为&#34;GET&#34;,则请求参数紧跟在HTTP请求的第一行uri的后面\n    if(method.equalsIgnoreCase(&#34;get&#34;)&amp;&amp;uri.indexOf(&#34;userName&#34;) != -1){\n    /*假定uri=&#34;servlet/HelloServlet?userName=chenjie&amp;password=accp&#34;*/\n    /*那么参数=&#34;userName=chenjie&amp;password=accp&#34;,所以这里截取参数字符串*/\n    String parameters = uri.substring(uri.indexOf(&#34;?&#34;), uri.length());\n    //通过&#34;&amp;&#34;符号截取字符串\n    //parts={&#34;userName=chenjie&#34;,&#34;password=accp&#34;}\n    parts = parameters.split(&#34;&amp;&#34;);\n    //如果想截取出userName的值,再通过&#34;=&#34;截取字符串\n    parts = parts[0].split(&#34;=&#34;);\n    userName = parts[1];\n  }\n    //如果请求方式为&#34;post&#34;,则请求参数在HTTP请求的正文中\n    //由于请求头和正文有两行空行,所以截取出两行空行,就能截取出正文\n    if(method.equalsIgnoreCase(&#34;post&#34;)){\n      int location = request.indexOf(&#34;\\r\\n\\r\\n&#34;);//提取出两行空行的位置\n      String content = request.substring(location+4, request.length());\n      //&#34;post&#34;提交正文里面只有参数,所以只需要\n      //和&#34;get&#34;方式一样,分割字符串,提取出userName的值\n      if(content.indexOf(&#34;userName&#34;) != -1){\n        parts = content.split(&#34;&amp;&#34;);\n        parts = parts[0].split(&#34;=&#34;);\n        userName = parts[1];\n      }\n  }\n\t\t\n  /*创建并发送HTTP响应*/\n  //发送HTTP响应第一行\n  out.write(&#34;HTTP/1.1 200 OK\\r\\n&#34;.getBytes());\n  //发送响应头\n  out.write(&#34;Content-Type:text/html\\r\\n\\r\\n&#34;.getBytes());\n  //发送HTTP响应正文\n  out.write(&#34;&lt;html&gt;&lt;head&gt;&lt;title&gt;HelloWord&lt;/title&gt;&lt;/head&gt;&#34;.getBytes());\n  out.write(new String(&#34;&lt;body&gt;&lt;h1&gt;hello:&#34;+userName+&#34;&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#34;).getBytes());\n  }\n}</code></pre></div><p>说的简单点，其实就是把解析HTTP请求和响应协议字符串放在了这个HelloServlet.JAVA的类里面。最后把HTTPServer做一下修改,干脆重新新建一个类<b>HTTPServerParam</b>.java,大家可以下去自行比较一下两个的区别</p><p><b>HTTPServerParam.java</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.ying.http;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.HashMap;\nimport java.util.Map;\npublic class HTTPServerParam {\n  // 存放servlet实例的map缓存\n  private static Map servletCache = new HashMap();\n  \n  public static void main(String[] args) {\n    int port;\n    ServerSocket serverSocket;\n    try {\n      serverSocket = new ServerSocket(8080);\n      System.out.println(&#34;服务器正在监听:&#34; + serverSocket.getLocalPort());\n      while (true) {\n        try {\n          Socket socket = serverSocket.accept();\n          System.out.println(&#34;服务器与一个客户端建立了新的连接,该客户端的地址为:&#34; \n            + socket.getInetAddress() + &#34;:&#34; + socket.getPort());\n          service(socket);\n        } catch (Exception e) {\n          e.printStackTrace();\n        }\n      }\n    } catch (IOException e) {\n      e.printStackTrace();\n    }\n  }\n  public static void service(Socket socket) throws Exception {\n    InputStream socketIn = socket.getInputStream();\n    Thread.sleep(500);\n    int size = socketIn.available();\n    byte[] requestBuffer = new byte[size];\n    socketIn.read(requestBuffer);\n    String request = new String(requestBuffer);\n    if (request.equals(&#34;&#34;))\n      return;\n    System.out.println(request);\n    /* 解析HTTP请求 */\n    // 获得HTTP请求的第一行\n    int l = request.indexOf(&#34;\\r\\n&#34;);\n    String firstLineRequest = request.substring(0, l);\n    // 解析HTTP请求的第一行，通过空格截取字符串数组\n    String[] parts = firstLineRequest.split(&#34; &#34;);\n    String uri = parts[1];\n    /* 判断如果访问的是Servlet,则动态的调用Servlet对象的service()方法 */\n    if (uri.indexOf(&#34;servlet&#34;) != -1) {\n      String servletName = null;\n      if (uri.indexOf(&#34;?&#34;) != -1)\n        servletName = uri.substring(uri.indexOf(&#34;servlet/&#34;) + 8, \n          uri.indexOf(&#34;?&#34;));\n      else\n        servletName = uri.substring(uri.indexOf(&#34;servlet/&#34;) + 8,\n          uri.length());\n      // 首先从map里面获取有没有该Servlet\n      Servlet servlet = (Servlet) servletCache.get(servletName);\n      // 如果Servlet缓存中不存在Servlet对象,就创建它,并把它存到map缓存中\n      if (servlet == null) {\n        servlet = (Servlet) Class.forName(&#34;com.ying.http.&#34; + \n          servletName).newInstance();\n        servlet.init();\n        servletCache.put(servletName, servlet);\n      }\n      // 调用Servlet的service()方法\n      servlet.service(requestBuffer, socket.getOutputStream());\n      Thread.sleep(1000);\n      socket.close();\n      return;\n    }\n    // HTTP响应正文类型\n    String contentType;\n    if (uri.indexOf(&#34;html&#34;) != -1 || uri.indexOf(&#34;html&#34;) != -1) {\n      contentType = &#34;text/html&#34;;\n    } else if (uri.indexOf(&#34;jpg&#34;) != -1 || uri.indexOf(&#34;jpeg&#34;) != -1) {\n      contentType = &#34;image/jpeg&#34;;\n    } else if (uri.indexOf(&#34;gif&#34;) != -1) {\n      contentType = &#34;image/gif&#34;;\n    } else\n      contentType = &#34;application/octet-stream&#34;;\n    /* 创建HTTP响应结果 */\n    String responseFirstLine = &#34;HTTP/1.1 200 OK\\r\\n&#34;;\n    String responseHeader = &#34;Content-Tyep:&#34; + contentType + &#34;\\r\\n\\r\\n&#34;;\n    InputStream in = HTTPServerParam.class.getResourceAsStream(&#34;test/&#34; +\n           uri);\n    OutputStream socketOut = socket.getOutputStream();\n    socketOut.write(responseFirstLine.getBytes());\n    socketOut.write(responseHeader.getBytes());\n    int len = 0;\n    requestBuffer = new byte[128];\n    while ((len = in.read(requestBuffer)) != -1) {\n      socketOut.write(requestBuffer, 0, len);\n    }\n    Thread.sleep(1000);\n    socket.close();\n  }\n}</code></pre></div><p>修改之后的HelloServerParam的基本逻辑就是如果客户端请求的URI位于servlet子目录下，就按照Serlvet来处理，否则就按照普通的静态文件来处理。当客户端请求访问特定的Servlet时，服务器端代码先从自己的servletCache缓存中寻找特定的Servlet实例，如果存在就调用它的service()方法；否则就先创建Servlet实例，把它放入servletCache缓存中，再调用它的service()方法。</p><p>如果学习过servlet的同学就会发现，这其实就是实现了一个j2ee的servlet,现在相当于我们就自己建立一个非常简单的Tomcat服务器…当然这里只能说是一个转换器而已…不过基本的Tomcat基本的原理就是这些,希望能够帮助大家理解.</p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>想问一下index.html应该放哪儿？我用的idea，服务器有显示，但是浏览器没有文字显示。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38121478", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "SQL注入攻击，吓死本宝宝了", 
            "content": "<p>SQL注入攻击，是黑客对数据库进行攻击的常用手段之一。那么，什么是SQL注入？SQL注入是怎么发生的？如何防止SQL注入？我们今天就来了解一下。</p><h2><b>SQL注入产生的背景</b></h2><p>在企业级应用中，存储数据主要是使用数据库来实现。数据库有着强大的数据存储能力和数据处理性能。</p><p>对于开发者而言，完成数据库的数据存储和数据处理，主要是利用SQL语句来实现的。不过，SQL语句中的数据是由用户在客户端通过文本框进行数据录入，然后，通过表单提交的方式请求服务器。开发者为了将客户端提交的数据和数据库进行数据的交互。就需要将客户端提交的数据和SQL语句的进行拼接，形成一条完整的能够执行的SQL语句。然后，交给DBMS执行，完成数据的存储以及数据处理。</p><p>举个添加的例子，SQL语句应该书写如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">insert into t_user(user_name,sex) values(&#39;tom&#39;,&#39;男&#39;);</code></pre></div><p>这条SQL语句执行完成后，可以向数据库添加用户名为”tom”，性别为”男”的记录。但是，在实际应用中，用户名和性别应该是由客户端提供的。这时，开发者应该先得到从客户端提交数据，然后拼接成添加SQL语句，交由DBMS执行。</p><div class=\"highlight\"><pre><code class=\"language-text\">String name = request.getParameter(&#34;userName&#34;);\nString sex = request.getParameter(&#34;sex&#34;);\nString sql=&#34;insert into t_user(user_name,sex)values(&#39;&#34;+name+&#34;&#39;,&#39;&#34;+sex+&#34;&#39;)&#34;;</code></pre></div><p>这时，如果客户端提交的name值为”john”，性别为”男”。那么拼接后的SQL语句就应该是：</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;insert into t_user(userName,sex) values(&#39;john&#39;,&#39;男&#39;)&#34;;</code></pre></div><p>这样，DBMS在执行SQL语句后，就会将”john”和”男”添加进数据库。</p><p>不过，在这个过程中，存在一些漏洞可以被黑客所攻击。如果客户端提交的数据存在一些非法字符或数据库关键字时，可能会造成SQL语句发生错误，或执行结果不正确的情况。</p><p>在上面的示例中，如果客户端提交的name值为”jo’hn”。性别为”男”。那么拼接后的SQL语句就应该是：</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;insert into t_user(userName,sex) values(&#39;jo&#39;hn&#39;,&#39;男&#39;)&#34;;</code></pre></div><p>很明显，这条SQL语句不满足添加语句的语法。DBMS在执行时会报SQL语句语法错误。</p><p>再来看一个登陆的例子，sql语句应该书写如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">String name = request.getParameter(&#34;userName&#34;);\nString password = request.getParameter(&#34;password&#34;);\nString sql = &#34;select * from  t_user where userName=&#39;&#34; + name + \n    &#34;&#39; and  password=&#39;&#34;+password+&#34;&#39;&#34;;</code></pre></div><p>这条SQL语句的本意是，查询用户名和密码同时相等的记录。如果客户端提交的userName值为”tom”，密码为”123”。那么拼接后的SQL语句就应该是：</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;select * from  t_user where userName=&#39;tom&#39; and &#34; \n    + &#34;password=&#39;123&#39;&#34;;</code></pre></div><p>但是，如果客户端提交的userName值为”aaa”。密码为”bbb’ or ‘1’=’1”。那么拼接后的SQL语句就应该是：</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;select * from  t_user where userName=&#39;aaa&#39; and &#34;\n     + &#34;password=&#39;bbb&#39; or &#39;1&#39;=&#39;1&#39;&#34;;</code></pre></div><p>由于’1’=’1’固定为true，所以，这条SQL语句的查询结果，是t_user表中所有记录。这样的话，无论用户名和密码输什么值，都可以有结果返回。从而，开发者会得到”登陆成功”的错误结论。</p><p>有些黑客也利用，在数据中加入”--“的方式，注释掉SQL语句中的条件。比如，客户端提交的userName值为”aaa’ or 1=1 -- “。密码为”bbb”。那么拼接后的SQL语句就应该是：</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;select * from  t_user where userName=&#39;aaa&#39; or 1=1 -- &#39;&#34; \n    + &#34; and password=&#39;bbb&#39;&#34;;</code></pre></div><p>这样，1=1固定为true，而以后的SQL语句会因为注释不会执行。</p><p>如果黑客再坏一点，在数据中加入DDL操作，比如：在密码中填入”bbb’;drop table t_user;”，那么SQL语句就变成：</p><div class=\"highlight\"><pre><code class=\"language-text\">tring sql = &#34;select * from  t_user where userName=&#39;aaa&#39; and  &#34; \n    + &#34;password=&#39;bbb&#39;;drop table t_user&#34;;</code></pre></div><p>执行SQL语句后，表都没了。</p><hr/><h2><b>什么是SQL注入？</b></h2><p>所谓SQL注入，是将客户机提交或Web表单递交的数据，拼接成SQL语句字符串时。如果客户端提交的数据有非法字符或SQL语句关键字时，会造成执行的SQL语句语法错误，或执行结果不正确的情况。通过SQL注入，黑客可以最终达到欺骗服务器，执行恶意的SQL语句，甚至破坏数据库结构的目的。</p><p>SQL注入攻击大多是利用设计上的漏洞，在目标服务器上运行Sql语句的攻击方式。开发者在动态生成Sql语句时，没有对用户输入的数据进行验证，是Sql注入攻击得逞的主要原因。</p><h2><b>如何防止SQL注入？</b></h2><p>在java中，是使用JDBC和数据库建立连接，并执行SQL语句，和数据库进行数据交互的。</p><p>JDBC在执行SQL语句操作时，提供了Statement、PreparedStatement和CallableStatement三种方式来执行SQL语句。其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程。<br/>在三个接口中，Statement是PreparedStatement和CallableStatement的父接口。Statement在执行SQL语句时，对于客户端提交的数据只支持拼接SQL语句的方式。</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;select * from  t_user where userName=&#39;&#34; + name + \n    &#34;&#39; and  password=&#39;&#34; + password + &#34;&#39;&#34;; </code></pre></div><p>所以，使用Statement在执行SQL语句，容易引起SQL注入。PreparedStatement在执行参数化查询时，支持占位符方式。</p><div class=\"highlight\"><pre><code class=\"language-text\">String sql = &#34;select * from  t_user where userName=? and password=?&#34;;\nPreparedStatement ps = conn.prepareStatement(sql);\nps.setString(1,name);\nps.setString(2,password);</code></pre></div><p>在使用参数化查询的情况下，数据库系统不会将参数的内容，视为SQL指令的一部分来处理。而是在数据库完成SQL指令的编译后，才套用参数运行。因此，就算参数中含有破坏性的指令，也不会被数据库所运行。所以，使用PreparedStatement的参数化查询可以有效的阻止SQL注入。</p><p>另外，PreparedStatement相比Statement还有以下几个优势<br/>1、可以预编译SQL语句，多次查询时速度快。<br/>2、防止数据库缓冲区溢出<br/>3、代码的可读性可维护性好</p><p>由于有以上优点，所以，在开发JDBC时，PreparedStatement成为访问数据库的语句对象的首选。</p><h2><b>总结：</b></h2><ol><li>所谓SQL注入，是将客户机提交或Web表单递交的数据，拼接成SQL语句字符串时。如果客户端提交的数据有非法字符或SQL语句关键字时，会造成执行的SQL语句语法错误，或执行结果不正确的情况。通过SQL注入，黑客可以最终达到欺骗服务器，执行恶意的SQL语句，甚至破坏数据库结构的目的。</li><li>在JDBC中使用PreparedStatement的参数化查询，数据库系统不会将参数的内容，视为SQL指令的一部分来处理。可以有效防止SQL注入。</li><li>开发JDBC时，尽量采用 PreparedStatement执行SQL语句，相比Statement有以下优势:<br/>a、可以防止SQL注入<br/>b、可以预编译SQL语句，多次查询时速度快<br/>c、防止数据库缓冲区溢出<br/>d、代码的可读性可维护性好</li></ol>", 
            "topic": [
                {
                    "tag": "SQL 注入", 
                    "tagLink": "https://api.zhihu.com/topics/19678733"
                }, 
                {
                    "tag": "黑客 (Hacker)", 
                    "tagLink": "https://api.zhihu.com/topics/19558642"
                }, 
                {
                    "tag": "计算机科学", 
                    "tagLink": "https://api.zhihu.com/topics/19580349"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38121019", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "this和super，我和我爸？", 
            "content": "<p>相信大家已经对Java基础内容有所了解了，本篇博客为大家讲解在编程过程中两个重要的关键字<b>this</b>和<b>super</b>，不管是已经有所了解，还是晕晕乎乎，亦或是学得不错，希望看完这篇博客后，都对你能所有帮助。</p><p>接下来进入我们的正文内容：this与super。</p><h2><b>this与super</b></h2><p><b>this关键字</b></p><p><b>this</b>在Java中指代<b>当前对象</b>。</p><p>this关键字的主要使用方式有两种：</p><p><b>1.使用this指代当前对象，并调用属性和方法</b></p><p><b>2.使用this()来指代本类构造器</b></p><h2><b>使用方式一：在方法中操作当前对象属性和方法</b></h2><p>当我们需要在方法中使用当前对象的属性和行为时，我们使用this来指代调用方法的对象本身。并用this.属性或this.方法名()的方式来调用属性和行为。</p><p>例如：在Test类中具有两个属性</p><div class=\"highlight\"><pre><code class=\"language-text\">public String name;\npublic int age;</code></pre></div><p>name和age是Test类的属性，该类有一个自我介绍的方法selfIntroduction()，那我们如何在该方法中使用当前对象的属性值呢？</p><p>selfIntroduction()方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">public void selfIntroduction() {\n    System.out.println(&#34;我叫&#34;+this.name+&#34;今年&#34;+this.age);\n}</code></pre></div><p>在测试类中</p><div class=\"highlight\"><pre><code class=\"language-text\">public static void main(String[] args) {\n    Test t1 = new Test();\n    t1.name = &#34;小明&#34;;\n    t1.age = 19;\n    t1.selfIntroduction();\n}</code></pre></div><p>执行结果为：输出了“我叫小明今年19”。</p><p>从上述代码中可以看出，我们使用this.name的方式调用到了当前对象的name值，同样，我们也调用到了当前对象的age值</p><p>不难发现，使用this.name的方式，获得了调用selfIntroduction()方法的当前对象的name属性值，也就是说，这个时候this对象指代的是此时调用该方法的当前对象。</p><p>这样我们就可以理解，为什么使用this.name和使用this.age可以得到”小明”和19这两个值了。</p><p>那既然this可以指代当前对象，可以使用this来调用方法吗？</p><div class=\"highlight\"><pre><code class=\"language-text\">//在Test类中的设置姓名的方法\npublic void setName(String name) {\n    this.name = name;\n}\npublic void selfIntroduction() {\n    this.setName(&#34;小红&#34;);\n    System.out.println(&#34;我叫&#34;+this.name+&#34;今年&#34;+this.age);\n}</code></pre></div><p>上述代码中，在selfIntroduction()方法第一行使用this.setName(“小红”)调用了当前对象的setName(String name)方法，并传入”小红”字符串；在setName(String name)方法中使用this.name来完成当前对象name属性值的赋值。</p><p>完成上述操作后，再次输出，结果为：“我叫小红今年19”。</p><p>这就是this指代当前对象，调用属性和行为的操作。</p><p>当然，有时this是可以省略的。</p><p>例如上述：</p><div class=\"highlight\"><pre><code class=\"language-text\">public void selfIntroduction() {\n    System.out.println(&#34;我叫&#34;+name+&#34;今年&#34;+age);\n}</code></pre></div><p>这样书写同样可以得到效果。</p><p><b>但是</b>:一定注意，省略this是有要求的，要求是在该方法中没有局部变量和该属性名称一致。</p><p>例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">//在Test类中的设置姓名的方法\npublic void setName(String name) {\n    name = name;\n}</code></pre></div><p>如果写成这样，程序执行时，会把传入的name值赋值给了传入的name值，并不会给属性name赋值，这种操作是无意义的。</p><p>为了给属性name赋值正确的写法：</p><div class=\"highlight\"><pre><code class=\"language-text\">//在Test类中的设置姓名的方法\npublic void setName(String name) {\n    this.name = name;\n}</code></pre></div><p><b>使用this.name代表对象的name属性，而name则代表传入的name局部变量。</b></p><p><b>注意</b>：this只能被使用在不被static修饰的非静态方法的方法体中。</p><p>当然，this也经常被使用在构造器，进行属性的赋值，例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">public Test(String name,int age){\n    this.name = name;\n    this.age = age;\n}</code></pre></div><p>利用这种方式就可以给当前对象进行属性的赋值。</p><h2><b>使用方式二：代表当前类中的构造器</b></h2><p>除了上述代表当前对象并调用属性和行为以外，this()可以代表本类构造器。</p><p>例：在Test类中有一个无参构造</p><div class=\"highlight\"><pre><code class=\"language-text\">public Test() {\n    System.out.println(&#34;无参构造&#34;);\n}\n</code></pre></div><p>如果想在有参构造中调用无参构造，这时就可以使用this()的方式来代表本类无参构造。</p><div class=\"highlight\"><pre><code class=\"language-text\">public Test(String name) {\n    this();\n    this.name = name;\n}</code></pre></div><p>当使用上述有参构造时，就会在第一行处调用无参构造，并执行无参构造的内容。</p><p>同样如果想调用上述的有参构造，也可以使用this(name)来代表有参构造。</p><p>例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">public Test(String name,int age) {\n    this(name);\n    this.age = age;\n}</code></pre></div><p>这样的话，就可以进行构造方法的调用了。</p><p><b>当然，在使用this()代表构造器时，一定要将其放在构造方法的第一行，否则会报错。</b></p><p>this关键字的用法先介绍到这儿，接下来看看我们了解的super。</p><h2><b>super关键字</b></h2><p><b>super</b>：在Java继承内容中，指代子类从父类中继承的内容。</p><p>不能操作子类的内容，能操作到父类中访问修饰符允许的属性和方法，其使用方式和this有相似之处。</p><h2><b>使用方式一：指代继承父类中的属性和行为</b></h2><p>相信同学们在继承中已经了解到，子类对象中不仅仅有子类独有的内容，更有从父类中继承而来的内容。</p><p>那我们如何区分是父类中继承而来的内容还是子类中独有的内容呢？</p><p>例：</p><p>父类：</p><div class=\"highlight\"><pre><code class=\"language-text\">//父类\npublic class Father {\n    public String name;\n    public int age;\n    public void sleep() {\n        System.out.println(&#34;睡觉打鼾&#34;);\n    }\n}</code></pre></div><p>子类：</p><div class=\"highlight\"><pre><code class=\"language-text\">//子类\npublic class Son extends Father{\n    public void sleep() {\n        System.out.println(&#34;儿子睡觉流口水&#34;);\n    }\n    //子类独有的方法\n    public void playGame() {\n        System.out.println(&#34;喜欢打游戏&#34;);\n    }\n}</code></pre></div><p>在上述代码中子类Son继承父类Father，并重写了父类的sleep方法</p><p>如果我们要使用到父类的属性和行为</p><p>将子类改为：</p><div class=\"highlight\"><pre><code class=\"language-text\">//子类\npublic class Son extends Father{\n    public void sleep() {\n        super.sleep();\n        System.out.println(&#34;儿子睡觉流口水&#34;);\n    }\n    //子类独有的方法\n    public void playGame() {\n        System.out.println(super.name+&#34;喜欢打游戏&#34;);\n    }\n}</code></pre></div><p>上述代码中，使用super.sleep()的方式在子类中调用了父类中的方法，和this一样，需要写在方法中。</p><p>同样，我们也可以在方法中调用从父类中继承而来的属性name，使用super.name获得name值。</p><p><b>但是</b>：有同学会发现，在playGame()方法中使用this.name和super.name效果是一样的，这是为什么呢？</p><p>原因是因为这时，子类的属性都是从父类中继承而来的，使用this和super调用属性的效果都是一样的。</p><p><b>注意：</b>但如果子类发生了变化，在子类中加上一个name属性，并赋值为”小明”：</p><div class=\"highlight\"><pre><code class=\"language-text\">public String name = &#34;小明&#34;;</code></pre></div><p>由于这时父类中有一个属性名称为name,而子类中也有一个属性名称为name，这时，super.name是父类继承来的name，而this.name是子类中属性，值就不一样的。</p><p><b>所以</b>：不要一味的觉得super.name和this.name相同，也不要觉得它们一定不同，得具体情况具体分析。</p><h2><b>使用方式二：代表父类中的构造器</b></h2><p>这一点是super关键字的重要作用。</p><p>和this一样，在构造器中可以使用super()代表调用了父类的无参构造。</p><p>例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">//父类无参构造\npublic Father(){}\n\n//子类无参构造\npublic Son(){\n    super();\n}</code></pre></div><p>当然，也可以使用super(参数)带参的构造器，来表示调用父类有参构造。</p><p><b>注意事项</b>：如果子类没有调用父类构造器，父类也没有无参构造，子类会报错。</p><p>例：</p><p>父类：</p><div class=\"highlight\"><pre><code class=\"language-text\">//父类\npublic class Father {\n    public String name;\n    public int age;\n    \n    public Father(String name) {\n        this.name = name;\n    }\n    \n    public void sleep() {\n        System.out.println(&#34;父亲睡觉打鼾&#34;);\n    }\n}</code></pre></div><p>子类：</p><div class=\"highlight\"><pre><code class=\"language-text\">//子类\npublic class Son extends Father{\n    public Son() {}\n    \n    public void sleep() {\n        super.sleep();\n        System.out.println(&#34;儿子睡觉流口水&#34;);\n    }\n    //子类独有的方法\n    public void playGame() {\n        System.out.println(super.name+&#34;喜欢打游戏&#34;);\n    }\n}</code></pre></div><p>为什么子类报错了呢？一番询问后才知道，原来子类的构造器中没有指定调用其它构造器，则会默认的去调用父类构造器，并且会调用父类的无参构造。</p><p>所以在上面的代码中，由于子类无参构造没有调用指定的其它构造器，那么会去默认调用父类无参构造，结果父类中有一个有参构造，就不会自动生成无参构造，找不到父类无参构造器，导致子类出错了。</p><p>在子类构造器中实现上是：</p><div class=\"highlight\"><pre><code class=\"language-text\">public Son() {\n    super();\n}</code></pre></div><p>当调用super()父类无参构造时可以省略不用书写。</p><p>当然有人会说，<b>难道我子类构造器就一定得调用父类无参构造？不能调用父类其它构造器或者不调用父类构造器吗？</b></p><p><b>首选</b>，不调用父类构造器，在内存中是加载不了父类内容的，那子类就完成不了对象的创建，所以必须调用父类构造器；</p><p><b>其次</b>，并不是一定要调用父类无参构造，也可以调用父类其它构造器，但由于默认会调用到父类无参构造，为了书写规范，应该给父类加上无参构造和相应的有参构造。</p><p><b>注意</b>：不光是this()指代的构造器要求写在第一行，super()指代的构造器也只能写在构造器语句的第一行哟！</p><hr/><h2><b>归纳总结</b></h2><h2><b>指代对象时</b></h2><p>一：this和super关键字都只能使用在不被static修饰的非静态方法方法体中。</p><p>二：this指代当前对象，可以在代码中调用当前对象的属性和行为。</p><p>三：super代表继承父类的内容，在子类中可以调用父类继承而来的属性和行为。</p><h2><b>指代构造器时</b></h2><p>一：this()指代本类无参构造，而super()代表父类无参构造。</p><p>二：this()与super()不能共存，两者只能使用一个，因为在构造器中第一行只能写一个语句。</p><p>三：子类必须调用父类构造器来加载父类内容完成继承，就算不去主动调用父类构造器，子类构造器也会默认的调用父类无参构造。所以为了格式规范，应该给父类加上无参构造。</p><p>四：调用父类无参构造super()可以不写，默认调用。</p><p>内容结束了，希望能够帮助大家对this和super有更深入的了解。</p><p></p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38120703", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "装神必备：数据库设计的范式", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0abb3bdc30798277e5744e144c6edac0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-0abb3bdc30798277e5744e144c6edac0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-0abb3bdc30798277e5744e144c6edac0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0abb3bdc30798277e5744e144c6edac0_b.jpg\"/></figure><p>为了建立数据冗余较小、结构合理的数据库，设计数据库时必须遵循一定的规则。在关系型数据库中这种规则就称为<b>范式</b>。范式是符合某一种设计要求的总结。要想设计一个结构合理的关系型数据库，必须满足一定的范式。</p><p>听你这么一说，范式好像蛮重要的样子，那为何我不懂什么范式，照样把数据库建立起来了，照样可以存储数据？</p><p>如果设计数据库不遵守范式，后果就是你设计的数据库虽然可以存储数据，但是数据冗余大，结构不合理，扩展性和维护性差。总之，一个字很垃圾：）</p><p>Dr E.F.codd最初定义了三个级别的范式，分别命名为第一范式、第二范式和第三范式。而这三个范式合在一起就是著名的<b>数据库设计三大范式</b>。</p><p>下面跟我一起，一探究竟吧！</p><hr/><h2><b>第一范式(1st NF －First Normal Fromate)</b></h2><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</p><p>第一范式的合理遵循需要根据系统的实际需求来定。</p><p>比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-13356f8fa6a983bea30aa8b515a32c8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-13356f8fa6a983bea30aa8b515a32c8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-13356f8fa6a983bea30aa8b515a32c8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-13356f8fa6a983bea30aa8b515a32c8f_b.jpg\"/></figure><p>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><h2><b>第二范式(2nd NF－Second Normal Fromate)</b></h2><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，如下表所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-61898cd41bd875add2084775d0519f3c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-61898cd41bd875add2084775d0519f3c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-61898cd41bd875add2084775d0519f3c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-61898cd41bd875add2084775d0519f3c_b.jpg\"/></figure><p>这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。</p><p>而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了。如下所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9cc9fba388d5482b7471e74e9eb1a58c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-9cc9fba388d5482b7471e74e9eb1a58c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-9cc9fba388d5482b7471e74e9eb1a58c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9cc9fba388d5482b7471e74e9eb1a58c_b.jpg\"/></figure><p>这样设计，在很大程度上减小了数据库的冗余。如果要获取订单的商品信息，使用商品编号到商品信息表中查询即可。</p><h2><b>第三范式(3rd NF－ Third Normal Fromate)</b></h2><p>第三范式在第二范式的基础之上更进一层。第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-feb21093993f4ab92615e0f9f40336b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-feb21093993f4ab92615e0f9f40336b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic1.zhimg.com/v2-feb21093993f4ab92615e0f9f40336b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-feb21093993f4ab92615e0f9f40336b8_b.jpg\"/></figure><p>这样在查询订单信息的时候，就可以使用客户编号来引用客户信息表中的记录，也不必在订单信息表中多次输入客户信息的内容，减小了数据冗余。</p><hr/><h2><b>总结</b></h2><ol><li><b>第一范式：确保表中每列保持原子性</b></li><li><b>第二范式：确保表中每列都与主键相关</b></li><li><b>第三范式：确保表中每列都和主键列直接相关,而不是间接相关</b></li></ol><p>掌握了数据库设计三大范式这一技能，就可以帮助设计出合理的数据库；也可以利用三大范式检验其他人数据库设计是否合理。</p><p>看来数据库设计三大范式，当之无愧是程序员装神必备技能之一。</p><p>注：还存在更高级的范式，但关系模型不需要（甚至提及）它们，它们只用在某些需要避免冗余的情况下。简单的说，它们是Boyce-Codd范式、第四范式、第五范式…</p><p></p>", 
            "topic": [
                {
                    "tag": "SQL", 
                    "tagLink": "https://api.zhihu.com/topics/19553557"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38120321", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "URL与URI，有联系有区别？", 
            "content": "<p>当我们在学习web知识时，通常会听到两个专业术语，URL 和 URI ,那么它们到底是什么？它们有什么联系？ 又有什么区别？</p><h2><b>URL</b></h2><p>URL：（全称：Uniform Resource Locator）统一资源定位符。</p><p>它是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。</p><p>URL 的常见定义格式为：</p><p>scheme://host[:port#]/path/…/[;url-params][?query-string][#anchor]</p><div class=\"highlight\"><pre><code class=\"language-text\">scheme //有我们很熟悉的http、https、ftp以及著名的ed2k，迅雷的thunder等。\nhost   //HTTP服务器的IP地址或者域名\nport#  //HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，\n例如tomcat的默认端口是8080  http://localhost:8080/\npath   //访问资源的路径\nurl-params  //所带参数 \nquery-string    //发送给http服务器的数据\nanchor //锚点定位</code></pre></div><p>URL的格式一般由下列三部分组成：</p><ol><li>协议(或称为服务方式);</li><li>存有该资源所在的服务器的名称或IP地址(包括端口号);</li><li>主机资源的具体地址。</li></ol><p>一个简单的url :例如：</p><p>1 — 协议</p><p>常见的协议</p><div class=\"highlight\"><pre><code class=\"language-text\"> http     超文本传输协议资源\n https    用安全套接字层传送的超文本传输协议\n ftp      文件传输协议\nmailto   电子邮件地址</code></pre></div><p>2 — 存有该资源所在的服务器的名称或IP地址(包括端口号)</p><p>端口:相当于一种数据的传输通道。用于接受某些数据，然后传输给相应的服务，而电脑将这些数据处理后，再将相应的回复通过开启的端口传给对方。</p><p>端口的作用：因为 IP 地址与网络服务的关系是一对多的关系。所以实际上因特网上是通过 IP 地址加上端口号来区分不同的服务的。</p><p>端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。</p><div class=\"highlight\"><pre><code class=\"language-text\">例如： 127.0.0.1:8080  表示 本机地址 端口号为 8080   </code></pre></div><p>3 — 主机资源的具体地址</p><div class=\"highlight\"><pre><code class=\"language-text\">例如：  /webProject/index.html </code></pre></div><p>一般的URL为：</p><div class=\"highlight\"><pre><code class=\"language-text\">URL:  http://127.0.0.1:8080/webProject/index.html </code></pre></div><h2><b>URI</b></h2><p>URI：（全称：Uniform Resource Identifier）统一资源标识符，它是一个字符串<b>用来标示抽象或物理资源。</b></p><p>Web上可用的每种资源（ HTML文档、图像、音频、视频片段、程序等）都由一个通用资源标识符（Uniform Resource Identifier, 简称”URI”）进行定位。</p><p>URI的格式也由三部分组成：</p><ol><li>访问资源的命名机制。</li><li>存放资源的主机名。</li><li>资源自身的名称，由路径表示。</li></ol><h2><b>联系与区别</b></h2><p>URI ：Uniform Resource Identifier，统一资源标识符；</p><p>URL：Uniform Resource Locator，统一资源定位符；</p><p>URN：Uniform Resource Name，统一资源名称。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e0b1b7ec4bfa5eef306911e1532d00ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-e0b1b7ec4bfa5eef306911e1532d00ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-e0b1b7ec4bfa5eef306911e1532d00ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e0b1b7ec4bfa5eef306911e1532d00ad_b.jpg\"/></figure><p>URI 属于 URL 更高层次的抽象，一种字符串文本标准。</p><p>就是说，URI 属于父类，而 URL 属于 URI 的子类。URL 是 URI 的一个子集</p><p>URI 表示请求服务器的路径，定义这么一个资源。而 URL 同时说明要如何访问这个资源（<a href=\"https://link.zhihu.com/?target=http%3A//%2529./\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://）。</a></p><p>URI可以分为URL,URN，或同时具备locators 和names特性的一个东西。URN作用就好像一个人的名字，URL就像一个人的地址。换句话说：URN确定了东西的身份，URL提供了找到它的方式。”</p><h2><b>总结</b></h2><p>URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><p>URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位。</p><p>URI：统一资源标识<br/>URL：统一资源定位<br/>URN：统一资源名称</p><p>例如：<br/><a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com</span><span class=\"invisible\"></span></a>是URL.<br/><a href=\"https://link.zhihu.com/?target=http%3A//www.baidu.com/index.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">baidu.com/index.html</span><span class=\"invisible\"></span></a> 是URL 同时也是URI。<br/>所以，URL 就是 URI 的 定位。</p><p>但 URI 不一定是 URL。<br/>因为 URI有一类子集是 URN，它是命名资源 但不指定如何定位资源。<br/>如： mailto 需要 加上 相应的结构参数，才能进行 统一资源定位。<br/>如： mailto: xxxxx@qq.com</p><p>因此，三者之间的关系是：<br/>URI 一定是 URL<br/>URN + URL 就是 URI</p>", 
            "topic": [
                {
                    "tag": "企业级应用", 
                    "tagLink": "https://api.zhihu.com/topics/20046628"
                }, 
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37763432", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "mysql数据库主从复制的核心原理？", 
            "content": "<p>在讲解原理之前，先请大家看一张图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e210674aa5819cb008d956ee333e9e92_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-e210674aa5819cb008d956ee333e9e92_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;731&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-e210674aa5819cb008d956ee333e9e92_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e210674aa5819cb008d956ee333e9e92_b.jpg\"/></figure><h2><b>通过这张图，我简单的描述一下，主从集群的实现原理</b></h2><p>     mysql数据库，主从集群的实现原理，非常的简单，我们先来描述一下他们实现的步骤：</p><ul><li>     首先，我们通过应用程序，对主库进行写数据的操作。</li><li>     主库，会将本库的变化（CUD），记录到本库的（二进制日志）中去。二进制日志，一般并未开启，需要使用log-bin = mysql-bin的方式来完成开启。</li><li>     从库，开启2根不同的线程，1个叫I/O线程，另1个叫SQL线程。I/O线程，主要干1件事情，与主库建立连接，然后读取主库（二进制日志）的变化。并且将变化，读取回到从库，然后记录到（中继日志）中去。中继日志，大家可以把它想象成就是一个文件内容的中转站。</li><li>     从库SQL线程，不断的读取“中继日志”中间的变化。然后向从库中，执行相同的SQL语句，有些地方，把这个过程，称之为：“重演”</li></ul><h2><b>从上述的步骤分析中，我们可以总结出来：</b></h2><ol><li>    数据库的主从，是从库去异步读取主库的变化。而并非是主库向从库主从推送。所以主库压力不大。</li><li>    如果主库，不去开启“二进制日志”，一切都将成为泡影，所以主库的“二进制日志”。是全局的重点。</li><li>    从库是间隔一段时间，不断的去读取主库的变化，所以在一定的时间范围内，可能出现主从数据库之间数据不一致，但是能保证数据最终一致性。所以，如果对实时性要求较高的时间，请直接查询主库。</li><li>     主库不会同步从库的数据，甚至主库对于从库是未知的。所以我们操作从库，对于主库没有任何影响，我们可以去在从库中，做数据“冷备”了，反正他们最终一定会一样的。</li><li>     既然从库去异步读主库，那么1主1从可以做，那么同理，1主多从也就可以做了，原理一样。</li><li>     主从之间，不断的在同步数据，那么如果数据库中的数据，相当于实时在做多个备份，数据库的可用性得到了极大的提升。</li></ol>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37767805", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "springmvc解决页面数据无法转换成Date类型的问题？", 
            "content": "<p>首先，大家应该都知道，页面数据到达后台服务器之前，所有从表单中提交的输入框中的数据，都是字符串。有时候，刚好比如需要输入“birthday”这种日期数据。日期的格式非常的多：比如yyyy-MM-dd，也有MM/dd/yyyy，也有一些其他的……</p><p>       正因为，它的日期格式太多，所以spring框架，在写关于日期的类型转换器时，压根就不知道应该去兼容哪些格式类型。</p><p>       所以，很尴尬，它不能自动完成yyyy-MM-dd，yyyy-MM-dd hh:mm:ss这种格式的类型</p><h2><b>解决方法有3种：</b></h2><p>        第一种：在实体类的日期属性上方，使用@DateTimeFormat注解</p><div class=\"highlight\"><pre><code class=\"language-text\">@DateTimeFormat(pattern = &#34;yyyy-MM-dd&#34;)  \nprivate Date birthday; </code></pre></div><p>         第二种：在对应的控制器中，使用属性绑定注解，需要前端人员配合，传输的格式，固定为：yyyy-MM-dd或者yyyy-MM-dd hh:mm:ss</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.framestudy.springmvcanno.usermag.controller;\n\nimport java.util.Date;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\nimport com.framestudy.springmvcanno.beans.RegisterBean;\nimport com.framestudy.springmvcanno.converters.UtilDateEditor;\n\n@RequestMapping(&#34;/registers&#34;)\n@Controller\npublic class RegisterController {\n\t\n\t\n\n\t//定义一个属性编辑器\n\t@InitBinder\n\tprotected void dateTypeConverter(WebDataBinder binder) {\n\t\tbinder.registerCustomEditor(Date.class, new UtilDateEditor());\n\t}\n\t\n\t\n\t\n\t/**\n\t * 注册\n\t * @param register\n\t * @return\n\t */\n\t@RequestMapping(&#34;/add&#34;)\n\tpublic String regist(RegisterBean register) {\n\t\tSystem.out.println(register);\n\t\t\n\t\treturn &#34;index&#34;;\n\t}\n}</code></pre></div><p>属性编辑器为：</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.framestudy.springmvcanno.converters;\n\nimport java.beans.PropertyEditorSupport;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.springframework.util.StringUtils;\n\npublic class UtilDateEditor extends PropertyEditorSupport {\n\t/**\n\t * text 来至于页面的数据\n\t */\n\t@Override\n\tpublic void setAsText(String text) throws IllegalArgumentException {\n\t\t// TODO Auto-generated method stub\n\t\t// yyyy-MM-dd yyyy-MM-dd HH:mm:ss\n\t\tDate date = null;\n\t\tif (StringUtils.hasLength(text)) {\n\t\t\tint lenth = text.length();\n\t\t\ttry {\n\t\t\t\tif (lenth == 10) {\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy-MM-dd&#34;);\n\t\t\t\t\tdate = sdf.parse(text);\n\t\t\t\t} else {\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy-MM-dd hh:mm:ss&#34;);\n\t\t\t\t\tdate = sdf.parse(text);\n\t\t\t\t}\n\t\t\t} catch (ParseException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\tthis.setValue(date);\n\t}\n}\n</code></pre></div><p>    第3种，使用全局类型转换器，同样需要前端人员配合，传输的格式，固定为：yyyy-MM-dd或者yyyy-MM-dd hh:mm:ss</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.framestudy.ssh.converters;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\nimport org.springframework.core.convert.converter.Converter;\nimport org.springframework.util.StringUtils;\n\npublic class DateTypeConverter implements Converter&lt;String, Date&gt; {\n\n\t@Override\n\tpublic Date convert(String text) {\n\t\t// TODO Auto-generated method stub\n\t\tDate date = null;\n\t\tif (StringUtils.hasLength(text)) {\n\t\t\tint lenth = text.length();\n\t\t\ttry {\n\t\t\t\tif (lenth == 10) {\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy-MM-dd&#34;);\n\t\t\t\t\tdate = sdf.parse(text);\n\t\t\t\t} else {\n\t\t\t\t\tSimpleDateFormat sdf = new SimpleDateFormat(&#34;yyyy-MM-dd hh:mm:ss&#34;);\n\t\t\t\t\tdate = sdf.parse(text);\n\t\t\t\t}\n\t\t\t} catch (ParseException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn date;\n\t}\n\n}\n</code></pre></div><p>    然后修改spring-servlet.xml配置文件,代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 开启springmvc注解支持，并且让springmvc框架使用spring提供的转换规则 --&gt;\n\t&lt;mvc:annotation-driven conversion-service=&#34;conversionService&#34;&gt;&lt;/mvc:annotation-driven&gt;</code></pre></div><p>并且配置spring的转换规则：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 声明类型转换工厂，并向其中注册“我们自己的转换器” --&gt;\n\t&lt;bean id=&#34;conversionService&#34;\n\t\tclass=&#34;org.springframework.context.support.ConversionServiceFactoryBean&#34;&gt;\n\t\t&lt;property name=&#34;converters&#34;&gt;\n\t\t\t&lt;set&gt;\n\t\t\t\t&lt;bean class=&#34;com.framestudy.ssh.converters.DateTypeConverter&#34; /&gt;\n\t\t\t&lt;/set&gt;\n\t\t&lt;/property&gt;\n\t&lt;/bean&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>上述3种方式，都可以使用，第1种最为简单；第2种较为复杂，并且只针对当前控制器有效，其他控制器直接没任何效果；第3种最为复杂，但是它可以针对所有控制器都有效，1次配置，多次使用， 并且我们代码中，不需要去编写@DateTimeFormat注解</p>", 
            "topic": [
                {
                    "tag": "Spring MVC", 
                    "tagLink": "https://api.zhihu.com/topics/20033636"
                }
            ], 
            "comments": [
                {
                    "userName": "旅途丶", 
                    "userLink": "https://www.zhihu.com/people/08fd02e4d3fdd1723a0e27a5a13b88aa", 
                    "content": "你好，请问一下，注解的方式不生效能知道是什么问题吗", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37769239", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 1, 
            "title": "如何在WEB工程中，不在乎Http提交方式，都能实现中文不乱码？", 
            "content": "<p>       Post乱码，我们可以采用spring容器提供在spring-web.jar包中的CharacterEncodingFilter过滤器来处理，但是Get乱码就很难处理了。</p><p>       首先，我们先明确Get是tomcat容器，在解析Get请求时，采用ISO-8859-1的字符集方式造成的，所以很多人说，那么我们可以去修改tomcat的配置文件，将URIEncoding=utf-8配置在server.xml中，但是，我们需要想到的是：服务器不一定在本地，服务器一旦做成集群后，将会有很多的server.xml都需要修改。所以这种方法不合适！</p><p>      还有一种方式，就是我们先在控制器中拿到数据，然后使用如下代码去转：</p><div class=\"highlight\"><pre><code class=\"language-text\">userName = new String(userName .getBytes(&#34;ISO-8859-1&#34;),&#34;utf-8&#34;);</code></pre></div><p>       但是，可以想象一下，我们将会在代码中，写很多的这样的代码，也不合适。</p><p>     所以最好的办法，则是自己写一个过滤器来实现这个问题，过滤器代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.framestudy.ssh.filters;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class CharacterEncodingFilter implements Filter {\n\n\tprivate String encoding;\n\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\n\t}\n\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n\t\t\tthrows IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpServletRequest req = (HttpServletRequest) request;\n\t\tHttpServletResponse res = (HttpServletResponse) response;\n\t\tString httpMethod = req.getMethod();// 得到请求的提交方式\n\t\tif (&#34;GET&#34;.equals(httpMethod)) {\n\t\t\tEncodingHttpServletRequest httpRequest = new EncodingHttpServletRequest(req, encoding);\n\t\t\tchain.doFilter(httpRequest, res);\n\t\t} else {\n\t\t\trequest.setCharacterEncoding(encoding);\n\t\t\tresponse.setCharacterEncoding(encoding);\n\t\t\tchain.doFilter(request, response);\n\t\t}\n\t}\n\n\tpublic void init(FilterConfig filterConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tencoding = filterConfig.getInitParameter(&#34;encoding&#34;);\n\t}\n\n\tprivate static class EncodingHttpServletRequest extends HttpServletRequestWrapper {\n\n\t\tprivate HttpServletRequest request;\n\t\tprivate String encoding;\n\n\t\tpublic EncodingHttpServletRequest(HttpServletRequest request) {\n\t\t\tsuper(request);\n\t\t\t// TODO Auto-generated constructor stub\n\t\t\tthis.request = request;\n\t\t}\n\n\t\tpublic EncodingHttpServletRequest(HttpServletRequest request, String encoding) {\n\t\t\tsuper(request);\n\t\t\t// TODO Auto-generated constructor stub\n\t\t\tthis.request = request;\n\t\t\tthis.encoding = encoding;\n\t\t}\n\n\t\t@Override\n\t\tpublic Map&lt;String, String[]&gt; getParameterMap() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tString content = getQueryString();\n\t\t\tMap&lt;String, String[]&gt; params = new HashMap&lt;String, String[]&gt;();\n\t\t\t// 处理多值的情况\n\t\t\tMap&lt;String, List&lt;String&gt;&gt; multiValues = new HashMap&lt;String, List&lt;String&gt;&gt;();\n\t\t\tif (content != null) {\n\t\t\t\tString[] tem = content.split(&#34;&amp;&#34;);\n\t\t\t\tfor (String str : tem) {\n\t\t\t\t\tString[] kvs = str.split(&#34;=&#34;);// userName=撒旦法\n\t\t\t\t\t// 需要处理一个提交项有多个值的情况发生\n\t\t\t\t\tif (params.containsKey(kvs[0])) {\n\t\t\t\t\t\t// 需要处理checkbox的多值情况，例如：ck=111&amp;ck=222&amp;ck=333\n\t\t\t\t\t\tList&lt;String&gt; valuesList;\n\t\t\t\t\t\tif (multiValues.containsKey(kvs[0])) {// 如果多值集合中已经包含某个键\n\t\t\t\t\t\t\tvaluesList = multiValues.get(kvs[0]);\n\t\t\t\t\t\t\tif (kvs.length &gt;= 2) {// ck=111\n\t\t\t\t\t\t\t\tvaluesList.add(kvs[1]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvaluesList.add(&#34;&#34;);// ck=\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {// 如果多值集合中尚未包含某个键\n\t\t\t\t\t\t\tvaluesList = new ArrayList&lt;String&gt;();\n\t\t\t\t\t\t\tvaluesList.add(params.get(kvs[0])[0]);// 初始加入\n\t\t\t\t\t\t\tif (kvs.length &gt;= 2) {// ck=111\n\t\t\t\t\t\t\t\tvaluesList.add(kvs[1]);\n\t\t\t\t\t\t\t} else {// ck=\n\t\t\t\t\t\t\t\tvaluesList.add(&#34;&#34;);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmultiValues.put(kvs[0], valuesList);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (kvs.length &gt;= 2) {// userName=撒旦法\n\t\t\t\t\t\t\tparams.put(kvs[0], new String[] { kvs[1] });\n\t\t\t\t\t\t} else {// userName=\n\t\t\t\t\t\t\tparams.put(kvs[0], new String[] { &#34;&#34; });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // for循环结束\n\n\t\t\t\t// --------------将多值情况，同样添加到params集合中去-------------\n\t\t\t\tif (multiValues != null &amp;&amp; !multiValues.isEmpty()) {\n\t\t\t\t\tIterator&lt;String&gt; its = multiValues.keySet().iterator();\n\t\t\t\t\twhile (its.hasNext()) {\n\t\t\t\t\t\tString key = (String) its.next();\n\t\t\t\t\t\tList&lt;String&gt; strs = multiValues.get(key);\n\t\t\t\t\t\tint size = strs.size();// 获得值的个数\n\t\t\t\t\t\tString[] arrays = new String[size];\n\t\t\t\t\t\tfor (int i = 0; i &lt; size; i++) {\n\t\t\t\t\t\t\tarrays[i] = strs.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams.put(key, arrays);// 将多值的情况也处理到Map集合中去\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn params;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getQueryString() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tString content = request.getQueryString();\n\t\t\tif (content != null) {\n\t\t\t\ttry {\n\t\t\t\t\tcontent = URLDecoder.decode(content, encoding);\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn content;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getParameter(String name) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tMap&lt;String, String[]&gt; params = getParameterMap();\n\t\t\tString val = &#34;&#34;;\n\t\t\tif (params != null &amp;&amp; params.containsKey(name)) {\n\t\t\t\tval = params.get(name)[0];\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\n\t\t@Override\n\t\tpublic Enumeration&lt;String&gt; getParameterNames() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn Collections.enumeration(getParameterMap().keySet());\n\t\t}\n\n\t\t@Override\n\t\tpublic String[] getParameterValues(String name) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn (String[]) getParameterMap().get(name);\n\t\t}\n\n\t}\n\n}\n</code></pre></div><p>当然，如果需要过滤器生效，需要在web.xml中配置一下：</p><div class=\"highlight\"><pre><code class=\"language-text\">  &lt;!-- 配置字符集处理过滤器 --&gt;\n\t&lt;filter&gt;\n\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n\t\t&lt;filter-class&gt;com.framestudy.ssh.filters.CharacterEncodingFilter&lt;/filter-class&gt;\n\t\t&lt;init-param&gt;\n\t\t\t&lt;param-name&gt;encoding&lt;/param-name&gt;\n\t\t\t&lt;param-value&gt;utf-8&lt;/param-value&gt;\n\t\t&lt;/init-param&gt;\n\t&lt;/filter&gt;\n\n        &lt;filter-mapping&gt;\n\t\t&lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;\n\t\t&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;\n\t&lt;/filter-mapping&gt;</code></pre></div>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37977968", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 0, 
            "title": "如何解决PUT或DELETE提交中，路径中文乱码的问题？", 
            "content": "<p>        随着restful架构风格的兴起，使用“http的四种标准提交方式+uri（统一资源描述）”，向后台服务器发起请求的方式就不可避免。</p><p>        uri（统一资源修饰符），使用名词来对资源进行统一，并唯一的描述。如果需要对资源进行查询，可以使用GET提交；对资源进行修改，可以使用PUT提交；对资源进行新增，可以使用POST提交，而如果需要对资源进行删除，可以使用DELETE提交。</p><p>        restful架构中，在要求对资源进行修饰时，需要尽可能的详细，这就不可避免的，有时会出现一个情况，在路径中包含“中文”，但是中文传递到后台通过以下代码，却无法实现乱码的转换：</p><div class=\"highlight\"><pre><code class=\"language-text\">String encoding = &#34;utf-8&#34;;\nrequest.setCharacterEncoding(encoding);\nresponse.setCharacterEncoding(encoding);</code></pre></div><p>       那么原因是什么呢？</p><p>       经过分析，PUT或者DELETE请求，他们的参数都是经过路径向后台进行传递，而不是类似POST中，采用消息体，向后台传递。反而它们跟GET请求差不多，都是通过路径进行传递，但是GET还有不同，GET是将参数封装到“查询参数”中了。</p><p>       无论是哪一种请求提交，那么路径这块，统一都采用的是GET请求处理，（我们在学习servlet时，应该知道，我们页面发起的每个请求，在真正处理该请求时，都会在这个请求之前，发起一次路径的GET请求，用于校验“页面控制器”是否存在）。</p><p>      所以PUT或者DELETE请求，同样也遵循，路径采用GET请求提交方式，但是大家应该都知道，tomcat容器在做处理GET请求时，是采用的ISO-8859-1，而并非是UTF-8</p><p>      所以，如果我们需要解决这个问题，那么我们就需要自己定义一个自己的过滤器，或者修改tomcat的配置文件，但是我还是推荐自己写过滤器：</p><div class=\"highlight\"><pre><code class=\"language-text\">package com.framestudy.ssh.filters;\n\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\n\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport javax.servlet.http.HttpServletResponse;\n/**\n * 当Rest提供时，中文路径乱码，可以使用此过滤器，解决\n * @author pu\n *\n */\npublic class HttpUrlEncodingHandleFilter implements Filter {\n\n    public HttpUrlEncodingHandleFilter() {\n        // TODO Auto-generated constructor stub\n    }\n\n\tpublic void destroy() {\n\t\t// TODO Auto-generated method stub\n\t}\n\n\tpublic void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n\t\t// TODO Auto-generated method stub\n\t\tHttpServletRequest req = (HttpServletRequest) request;\n\t\tHttpServletResponse res = (HttpServletResponse) response;\n\t\tEncodingHttpServletRequest wapper = new EncodingHttpServletRequest(req);\n\t\tchain.doFilter(wapper, res);\n\t}\n\tpublic void init(FilterConfig fConfig) throws ServletException {\n\t\t// TODO Auto-generated method stub\n\t}\n\t\n\tprivate static class EncodingHttpServletRequest extends HttpServletRequestWrapper{\n\n\t\tprivate HttpServletRequest request;\n\t\t\n\t\tpublic EncodingHttpServletRequest(HttpServletRequest request) {\n\t\t\tsuper(request);\n\t\t\t// TODO Auto-generated constructor stub\n\t\t\tthis.request = request;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic String getServletPath() {\n\t\t\t// TODO Auto-generated method stub\n\t\t\tString servletPath = request.getServletPath();\n\t\t\ttry {\n\t\t\t\tservletPath =new String(servletPath.getBytes(&#34;ISO-8859-1&#34;),&#34;utf-8&#34;);\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn servletPath;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\n}\n</code></pre></div><p>配合web.xml，进行过滤器配置：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 配置Restful Uri路径传值中文乱码，解决过滤器 --&gt;\n\t&lt;filter&gt;\n\t\t&lt;filter-name&gt;httpUrlEncodingHandleFilter&lt;/filter-name&gt;\n\t\t&lt;filter-class&gt;com.framestudy.ssh.filters.HttpUrlEncodingHandleFilter&lt;/filter-class&gt;\n\t&lt;/filter&gt;\n        &lt;filter-mapping&gt;\n\t\t&lt;filter-name&gt;httpUrlEncodingHandleFilter&lt;/filter-name&gt;\n\t\t&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;\n         &lt;/filter-mapping&gt;</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "中文乱码", 
                    "tagLink": "https://api.zhihu.com/topics/19682686"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37719484", 
            "userName": "格智教学部", 
            "userLink": "https://www.zhihu.com/people/f0795423d922479012d5dbf0ad10e06d", 
            "upvote": 2, 
            "title": "mysql数据库为啥要做主从复制？", 
            "content": "<h2><b>1、单数据库，有什么问题？</b></h2><ul><li><b>      数据的“备份”，只能采用“冷备”的方式。一旦遇到数据库发生重要异常，只能恢复成上次“冷备”的数据。</b></li></ul><p>      “冷备”：间隔1周，或者半个月，使用数据库连接工具，对整个数据库的“结构和数据”做一次sql导出。</p><p>        而且备份期间，数据库自动加“读锁”，导致我们无法向数据库中，去写入数据。</p><ul><li><b>单台“数据库”服务器，如果发生“断电”，“网线异常”，“系统异常”等等情况下，数据库将无法正常提供数据访问服务。</b></li></ul><p>       “断电”、“网线异常”、“操作系统异常”等等的情况，太过于常见，一旦发生这类似的情况，数据库在到恢复之前，系统都无法正常访问到它。整个系统的“可用行”极差。</p><ul><li><b>    单台“数据库”可提供的连接数有限，很容易就达到极限值</b></li></ul><p>默认情况下，mysql数据库最大连接数是100，我们可以通过修改my.ini配置文件中的max_connections属性进行配置，一般生产环境下，我们修改成200。一个数据库能够具体提供多高的连接数量，受到很多因素的影响，比如：服务器硬件，操作系统，数据库版本……</p><p>       建议通过“测试工具，编写脚本”去对数据库进行压力测试，根据服务器的质量，连接数量也是有高有低，此处不做明确的指标。200的标准，至少可以保证，目前来说，任何的电脑，都是能够正常提供的，不会因为连接过多，而导致系统奔溃，或者反应缓慢。但是无论多少，单台的量，一定很容易就能达到，除非你的系统，访问人群不多，在线量不大！</p><ul><li><b>      当连接大量用于“查询”时，甚至影响到“写”的效率时，单库无法解决</b></li></ul><p>绝大多的系统，都有这么一个特征，就是“用户的操作，如果按照读：写比例的方式来进行分析的化，会出现这么一个情况，80%的操作都是在对数据库进行查询，只有20%在对数据库是进行修改”，“80%的查询，都是集中在20%的核心表，以及核心数据上”。</p><p>      这时，就有可能遇到一个问题就是，当大量的连接用于查询，而只有少量，甚至没有连接可以提供给用户进行“写数据”时，单库就处理不了。</p><h2><b>2、什么情况下，需要主从复制？</b></h2><ul><li><b>对系统的整体可用性，要求较高时，比如要求：全年99.9%的时间，系统都要保证可以正常使用的情况下。</b></li><li><b>需要对数据库进行“数据”实时备份时，如果进行“冷备”时，不得影响系统对数据库进行操作的情况下。</b></li><li><b>当单台“数据库”无法应付越来越多的访问时，也就是“连接”快达到或者已经达到峰值时，业务量还在不断“增加”的情况下。 </b></li><li><b>分析业务量，“当用户的操作比例中，连接，读写比例严重失衡”的情况下，用于读的连接已经影响到用于写的情况下。</b></li></ul>", 
            "topic": [
                {
                    "tag": "SQL", 
                    "tagLink": "https://api.zhihu.com/topics/19553557"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_201901433"
}
