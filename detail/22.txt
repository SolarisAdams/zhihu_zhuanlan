{
    "title": "故原苒苒", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/CodeInception", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/castzhong", 
        "https://www.zhihu.com/people/lao-cheng-35", 
        "https://www.zhihu.com/people/karminski"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/29433875", 
            "userName": "binggg", 
            "userLink": "https://www.zhihu.com/people/cb3bb49977e986142c9e390e16604c15", 
            "upvote": 102, 
            "title": "性能优化之组件懒加载: Vue Lazy Component 介绍", 
            "content": "<p>这篇文章分享了从遇到前端业务<b>性能问题</b>，到<b>分析、解决</b>并且<b>梳理</b>出<b>通用的Vue 2.x 组件级懒加载解决方案</b>（Vue Lazy Component ）的过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>初始加载资源过多</h2><p>问题起源于我们的一个页面，下面是这个页面的截图和初次请求的瀑布图。<br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-25b115b8306ed8e7ec9381d462b9d3bd_b.png\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb\" width=\"1169\" data-original=\"https://pic2.zhimg.com/v2-25b115b8306ed8e7ec9381d462b9d3bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1169&#39; height=&#39;664&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1169\" data-original=\"https://pic2.zhimg.com/v2-25b115b8306ed8e7ec9381d462b9d3bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-25b115b8306ed8e7ec9381d462b9d3bd_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>初始加载的时候，一共请求了155个资源，请求的瀑布图就快要和页面一样长了?</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-e0fd2476a950d166e1c08ed46c67202b_b.png\" data-rawwidth=\"1079\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb\" width=\"1079\" data-original=\"https://pic4.zhimg.com/v2-e0fd2476a950d166e1c08ed46c67202b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1079&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1079\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1079\" data-original=\"https://pic4.zhimg.com/v2-e0fd2476a950d166e1c08ed46c67202b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e0fd2476a950d166e1c08ed46c67202b_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>初始加载的资源过多导致在 domInteractive 之后，页面花费了大量时间加载子资源，导致页面的 load 时长被严重拖长，达到了 5.6s 。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-e4f1a76d58c1fcad8bf67f98cfdfa9c0_b.png\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb\" width=\"1169\" data-original=\"https://pic1.zhimg.com/v2-e4f1a76d58c1fcad8bf67f98cfdfa9c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1169&#39; height=&#39;664&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1169\" data-original=\"https://pic1.zhimg.com/v2-e4f1a76d58c1fcad8bf67f98cfdfa9c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e4f1a76d58c1fcad8bf67f98cfdfa9c0_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>来看看这些子资源都是什么，根据请求资源的类型，我们找到了最多的类型是图片，这是显而易见的，页面上到处都是大图片，其次是 js 文件，由第三方的业务插件和一些 JSONP 的接口组成。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-6c3d7464e2c18732314f562e42a64603_b.png\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb\" width=\"1169\" data-original=\"https://pic4.zhimg.com/v2-6c3d7464e2c18732314f562e42a64603_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1169&#39; height=&#39;664&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1169\" data-rawheight=\"664\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1169\" data-original=\"https://pic4.zhimg.com/v2-6c3d7464e2c18732314f562e42a64603_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6c3d7464e2c18732314f562e42a64603_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>问题分析</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-125c348c8182bd169b492754d91b4bfd_b.png\" data-rawwidth=\"584\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb\" width=\"584\" data-original=\"https://pic2.zhimg.com/v2-125c348c8182bd169b492754d91b4bfd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;584&#39; height=&#39;465&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"584\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"584\" data-original=\"https://pic2.zhimg.com/v2-125c348c8182bd169b492754d91b4bfd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-125c348c8182bd169b492754d91b4bfd_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>再回到最初的这个页面，结合上面的数据情况我们得出了这个页面的问题总结结论：</p><ul><li>页面由大量模块组成</li><li>每个模块部分由首页自主维护，部分由业务方通过插件维护</li><li>所有模块是同时进行加载</li><li>模块中图片内容较多</li><li>每个模块的依赖资源较多（包括js文件、接口文件、css文件等）</li></ul><h2>解决思路</h2><p>我们提出了下面两个主要的解决思路：</p><h2>组件化分治思想</h2><p>为了方便后续的优化，我们必须要求每个模块之间降低耦合，将相关的逻辑（比如请求接口、请求相关的依赖资源）都封装在内部，在 Vue 里落实成组件的形式。</p><ul><li>将各模块拆分为组件粒度</li><li>将组件依赖的资源全部封装在组件内部进行调用</li></ul><h2>加载优先级</h2><p>在完成了组件化的拆分，确保模块之间不会互相影响和产生耦合之后，我们可以方面地调整加载策略。加载的策略是根据可见性来处理优先级问题。</p><ul><li>优先加载首屏可见模块</li><li>其余不可见模块懒加载，待可见或即将可见时加载</li></ul><p>有了上面的解决思路，我们开始思考具体的实现：</p><h2>如何解决判断可见性问题？</h2><p>从前我们都是通过监听滚动事件、resize 事件来判断模块是否可见，代码不仅繁琐，而且一不小心没有函数去抖就又可能导致严重的性能问题。</p><p>现在我们有了更好的选择—— IntersectionObserver API ，IntersectionObserver 允许你配置一个回调函数，每当 target ，元素和设备视口或者其他指定元素发生交集的时候该回调函数将会被执行。这个 API 的设计是异步的，而且保证你的回调执行次数是非常有限的，而且回调是会在主线程空闲时才执行，在性能方面表现更优，使用起来也更简单。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-ef8d79b1cca75c66b5380bfce4a5ae32_b.png\" data-rawwidth=\"1173\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb\" width=\"1173\" data-original=\"https://pic3.zhimg.com/v2-ef8d79b1cca75c66b5380bfce4a5ae32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1173&#39; height=&#39;686&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1173\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1173\" data-original=\"https://pic3.zhimg.com/v2-ef8d79b1cca75c66b5380bfce4a5ae32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ef8d79b1cca75c66b5380bfce4a5ae32_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>目前是现代浏览器支持，低版本浏览器可以通过 polyfill 兼容。</p><h2>如何尽可能懒的条件渲染？</h2><p>在解决了加载条件的判断之后，我们需要解决加载条件为假的情况下不去渲染、加载条件为真的时候才渲染的问题，这里的答案非常简单：使用 Vue.js 提供的 v-if 指令，就可以做到真正的惰性渲染。</p><h2>如果可见后进行初始渲染，可见前如何显示？</h2><p>如果在判断加载条件为假的时候，什么都不渲染，就会带来一系列问题：</p><ul><li>用户体验比较差，最开始是白屏，然后突然又渲染出现内容。</li><li>最致命的是我们判断可见性是需要一个目标来观察的，如果什么不都渲染，我们就无从观察。</li></ul><p>这里引入一个骨架屏的概念，我们为真实的组件做一个在尺寸、样式上非常接近真实组件的组件，叫做骨架屏。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-75afd23106521e3f37c48f3575b12154_b.png\" data-rawwidth=\"378\" data-rawheight=\"382\" class=\"content_image\" width=\"378\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;378&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"378\" data-rawheight=\"382\" class=\"content_image lazy\" width=\"378\" data-actualsrc=\"https://pic1.zhimg.com/v2-75afd23106521e3f37c48f3575b12154_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>骨架屏的作用有：</p><ul><li>提升用户感知体验</li><li>保证切换的一致性</li><li>提供可见性观察的目标对象</li></ul><h2>如何提升切换时的体验？</h2><p>在真实组件开始渲染的时候，需要一定的时间和空间，时间指的是真实组件从创建到渲染的时间，包括请求接口、请求资源和渲染的时间，空间指的是页面布局中需要给真实组件留出刚好的位置，避免产生抖动。</p><p>这里我们可以使用 Vue.js 内置的 transition 组件自定义骨架组件和真实组件的进入和离开效果，通过合理的布局和定位，减少切换时的抖动，<br/>通过设置过渡效果给真实组件留出一定的加载时间。</p><p>上面的问题都有了答案之后，我们很容易就可以实现一个通用的方案，来解决组件的懒加载问题。</p><h2>Vue组件懒加载方案介绍</h2><p>项目Github地址： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/xunleif2e/vu</span><span class=\"invisible\">e-lazy-component</span><span class=\"ellipsis\"></span></a></p><p>这个是我们基于上面的思考做的一个通用的解决方案，下面简单介绍一下特性、使用以及 API 方面的知识，后面结合 5 个具体的 DEMO 来讲解更高级的用法。</p><h2>特性</h2><ul><li>支持 组件可见或即将可见时懒加载</li><li>支持 组件延时加载</li><li>支持 加载组件前展示组件骨架，提高用户体验</li><li>支持 懒加载组件分包异步加载</li></ul><h2>安装和使用</h2><div class=\"highlight\"><pre><code class=\"language-text\">npm i @xunlei/vue-lazy-component</code></pre></div><ul><li>方式1 利用插件方式全局注册</li><li>方式2 局部注册</li><li>方式3 独立版本引入，自动全局注册</li></ul><h2>用法</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-b9a0540e8014281cb7bfe73bd1c345b4_b.png\" data-rawwidth=\"1240\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-b9a0540e8014281cb7bfe73bd1c345b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1240\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-b9a0540e8014281cb7bfe73bd1c345b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b9a0540e8014281cb7bfe73bd1c345b4_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Props</h2><figure><noscript><img src=\"https://pic3.zhimg.com/v2-01fc384d2419c77d5f2c1d4ab3db29de_b.png\" data-rawwidth=\"1131\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb\" width=\"1131\" data-original=\"https://pic3.zhimg.com/v2-01fc384d2419c77d5f2c1d4ab3db29de_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1131&#39; height=&#39;483&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1131\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1131\" data-original=\"https://pic3.zhimg.com/v2-01fc384d2419c77d5f2c1d4ab3db29de_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-01fc384d2419c77d5f2c1d4ab3db29de_b.png\"/></figure><h2>Events</h2><figure><noscript><img src=\"https://pic3.zhimg.com/v2-7cce6b90b3db25ca4c3534a05f72855a_b.png\" data-rawwidth=\"1128\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb\" width=\"1128\" data-original=\"https://pic3.zhimg.com/v2-7cce6b90b3db25ca4c3534a05f72855a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1128&#39; height=&#39;464&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1128\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1128\" data-original=\"https://pic3.zhimg.com/v2-7cce6b90b3db25ca4c3534a05f72855a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7cce6b90b3db25ca4c3534a05f72855a_b.png\"/></figure><h2>DEMO 1 超长页面懒加载</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-lazy-component/demo/dist/index.html%23/large-page\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-lazy-component/demo/dist/index.html#/large-page</span><span class=\"ellipsis\"></span></a></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;vue-lazy-component&gt;\n    &lt;st-series-sohu/&gt;\n    &lt;st-series-sohu-skeleton slot=&#34;skeleton&#34;/&gt;\n&lt;/vue-lazy-component&gt;</code></pre></div><p>通过上面这种简单的使用方式就可以实现组件即将可见时自动加载。</p><h2>DEMO 2 延时加载</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-lazy-component/demo/dist/index.html%23/timeout\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-lazy-component/demo/dist/index.html#/timeout</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-2efab0d1424bfda296bfd34e54e1eff7_b.png\" data-rawwidth=\"1023\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic4.zhimg.com/v2-2efab0d1424bfda296bfd34e54e1eff7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;433&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1023\" data-rawheight=\"433\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic4.zhimg.com/v2-2efab0d1424bfda296bfd34e54e1eff7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2efab0d1424bfda296bfd34e54e1eff7_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;vue-lazy-component :timeout=&#34;1000&#34;&gt;\n    &lt;st-series-sohu/&gt;\n    &lt;st-series-sohu-skeleton slot=&#34;skeleton&#34;/&gt;\n&lt;/vue-lazy-component&gt;\n`</code></pre></div><p>如果有时候仅仅是希望某些组件稍后渲染，而不一定要等到可见时，可以通过这种方式。</p><p>比如我们业务中可能会有些运营性质的挂件，就可以采取延时加载的方式。</p><h2>DEMO 3 自定义过渡效果</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-lazy-component/demo/dist/index.html%23/custom-transition\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-lazy-component/demo/dist/index.html#/custom-transition</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d488d6304263900e9e4162e43d8a8df9_b.png\" data-rawwidth=\"948\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb\" width=\"948\" data-original=\"https://pic2.zhimg.com/v2-d488d6304263900e9e4162e43d8a8df9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;948&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"948\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"948\" data-original=\"https://pic2.zhimg.com/v2-d488d6304263900e9e4162e43d8a8df9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d488d6304263900e9e4162e43d8a8df9_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果觉得 Vue Lazy Component 自带的淡入淡出的过渡效果太丑，或者需要调整淡入淡出效果的时长，就可以通过自定义样式来改变过渡效果。这个例子演示了另外一种过渡效果，transition 的生命周期可以参考 Vue.js 的 transition 组件的文档。</p><h2>DEMO 4 webpack 分包</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-lazy-component/demo/dist/index.html%23/large-page-chunks\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-lazy-component/demo/dist/index.html#/large-page-chunks</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-b9009c5e27d1e13622abaef36838e9f2_b.png\" data-rawwidth=\"494\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"494\" data-original=\"https://pic3.zhimg.com/v2-b9009c5e27d1e13622abaef36838e9f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;494&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"494\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"494\" data-original=\"https://pic3.zhimg.com/v2-b9009c5e27d1e13622abaef36838e9f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b9009c5e27d1e13622abaef36838e9f2_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>DEMO1 演示了如何懒加载模块，但其实只是推迟了模块的渲染和模块内的资源的加载，如果我们需要更进一步，连模块本身的代码也是懒加载，就像 AMD 那样异步按需加载，这个也是可以做到的。</p><p>这里可以利用Vue.js的异步组件，将每个真实组件都注册成异步组件，在异步组件的工厂函数里使用 Webpack 的 AMD 版本的 require ，就可以实现真实组件可以分成独立的 bundle 加载，脱离页面 js 的bundle。</p><p>但是这里会有个问题，就算模块是可见时才渲染，在打开页面的时候会发现模块不可见之前它的 bundle 已经加载了，这并没有实现按需加载。</p><p>这个例子演示了一种做法，Vue Lazy Component 可以在即将切换真实组件前通过 Scoped Slots 传递一个 loading 属性给真实组件，真实组件只要是根据这个 loading 来条件渲染就可以避免非按需加载，这个和 Vue.js 对组件的解析机制有关，例子里有相应的的代码，有兴趣的同学可以深入研究下。</p><h2>DEMO 5 特定视口内懒加载</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-lazy-component/demo/dist/index.html%23/specific-viewport\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-lazy-component/demo/dist/index.html#/specific-viewport</span><span class=\"ellipsis\"></span></a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-1ae4fb999424e14682f66917e5b7d5af_b.png\" data-rawwidth=\"717\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb\" width=\"717\" data-original=\"https://pic4.zhimg.com/v2-1ae4fb999424e14682f66917e5b7d5af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;717&#39; height=&#39;459&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"717\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"717\" data-original=\"https://pic4.zhimg.com/v2-1ae4fb999424e14682f66917e5b7d5af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1ae4fb999424e14682f66917e5b7d5af_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在某些场景下，我们要解决滚动容器内的组件懒加载，这个时候可见性是相对与这个视口来的，这个例子演示了如何指定聊天窗口作为观察的视口。</p><p>这里吐槽下Vue.js的 $parent 、$refs 的设计，它们都不是响应式的，如果需要动态获取这些组件引用上的 $el ，必须要等到 mounted 事件发生之后，所以例子的代码稍微有一点繁琐。</p><h2>应用效果</h2><p>首先 Vue Lazy Component 的设计虽然是说组件级的，其实它的粒度可大可小，大的比如页面不同的区域，小的就像 DEMO5 里的只是一个用户头像，所以适用性非常强，只要有懒加载需求的场景基本都可以采用。</p><p>另外，在终端方面，不仅可以兼容PC端的项目，在移动端也是可以使用的，当然，需要解决 IntersectionObserver API 的兼容性问题，在项目 Readme 里提到了 w3c 的 polyfill 的地址。</p><h2>应用业务</h2><p>我们目前应用在迅雷的两个项目中，一个是 PC 迅雷的首页项目，一个是 PC 迅雷的组队加速项目，后期预计会推广到更多的业务中去。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-43f27aa72d01cbc2976ba3535bfbd9d1_b.png\" data-rawwidth=\"781\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb\" width=\"781\" data-original=\"https://pic2.zhimg.com/v2-43f27aa72d01cbc2976ba3535bfbd9d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;781&#39; height=&#39;213&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"781\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"781\" data-original=\"https://pic2.zhimg.com/v2-43f27aa72d01cbc2976ba3535bfbd9d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-43f27aa72d01cbc2976ba3535bfbd9d1_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>优化后请求瀑布图</h2><p>我们再来看看开始那个页面的情况，在使用了 组件懒加载技术后，请求数变成了只有 31 个，瀑布图变得比较短了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-fff0c73c6a01469bc54dbe3053eb808c_b.png\" data-rawwidth=\"678\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic1.zhimg.com/v2-fff0c73c6a01469bc54dbe3053eb808c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;377&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"678\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic1.zhimg.com/v2-fff0c73c6a01469bc54dbe3053eb808c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fff0c73c6a01469bc54dbe3053eb808c_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>数据对比</h2><p>我们把前后的数据进行一个对比：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-2c5eb523dd71c5e3e542f01361f9134f_b.png\" data-rawwidth=\"828\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"828\" data-original=\"https://pic4.zhimg.com/v2-2c5eb523dd71c5e3e542f01361f9134f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;828&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"828\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"828\" data-original=\"https://pic4.zhimg.com/v2-2c5eb523dd71c5e3e542f01361f9134f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2c5eb523dd71c5e3e542f01361f9134f_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>请求数变成之前的 1 / 5，优化效果比较明显</li><li>请求大小相比之前降低不太明显</li><li>load 时长也同样不太明显</li></ul><p>分析主要是有较多图片未按照使用尺寸裁剪和压缩，导致请求大小较大，同时造成了 load 时长的拖长。</p><h2>后续性能优化方向</h2><p>后续我们会继续来优化这个页面，主要的方向有两个：</p><h2>图片尺寸适配和压缩</h2><p>通过图片的裁剪和压缩，解决请求资源大小较大子资源加载时间较长导致 load 时间拖长的问题</p><h2>预渲染</h2><p>采用预渲染插件将页面的主要 css 、js 进行内联，将骨架架屏通过预渲染生成出来，这样可以避免 SPA 首屏可见关键路径较长的问题，在页面解析完 dom 树以后即可保证首屏可见。</p><h2>懒加载方案 ROADMAP</h2><p>Vue Lazy Component 懒加载方案还有些地方做得还不够好，计划在后期的几个小版本里支持以下的特性：</p><ul><li>SSR 支持 v1.1.0</li><li>UI单元测试 v1.2.0</li><li>减少性能开销 v1.3.0</li><ul><li>重绘</li><li>FPS</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>后记</h2><p>这篇文章分享了从遇到业务实际性能问题，到分析、解决并梳理出通用的解决方案的过程，重点其实不是最终的实现代码实现，而是解决问题的角度和过程。</p><p>最后欢迎大家通过提交 issue 或者 PR 的方式参与贡献，项目 Github 地址： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-lazy-component\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/xunleif2e/vu</span><span class=\"invisible\">e-lazy-component</span><span class=\"ellipsis\"></span></a> 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><div class=\"highlight\"><pre><code class=\"language-html\">                     微信搜索 蜂鸟前端 关注迅雷前端公众号</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "前端性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19583739"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": [
                {
                    "userName": "廖伟强", 
                    "userLink": "https://www.zhihu.com/people/ae066e38f1d560a9b73d8ce139913e9c", 
                    "content": "<p>迅雷前端实践经验，来感受下。</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "世家", 
                    "userLink": "https://www.zhihu.com/people/34a5ada1c2c892a6fbfbd92d0395f882", 
                    "content": "不错的文章，还有自己的轮子，棒棒哒。不过我倒是觉得，针对文章中的场景，用图片懒加载搭配预加载就可以了吧。毕竟绝大部分是图片", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "binggg", 
                            "userLink": "https://www.zhihu.com/people/cb3bb49977e986142c9e390e16604c15", 
                            "content": "<p>是的，在大部分是图片的情况下图片懒加载可以起到很好的效果，不过我们的场景有点特殊，部分内容并非我们自己开发维护的，不是很好约束开发者的代码，组件层面的懒加载对我们来说比较方便实行</p>", 
                            "likes": 0, 
                            "replyToAuthor": "世家"
                        }
                    ]
                }, 
                {
                    "userName": "江月何年初照人", 
                    "userLink": "https://www.zhihu.com/people/9b5fe9a3c78ac2f7148feecbd7aa97a5", 
                    "content": "<p>如梦初醒，好诗好诗</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "[已重置]", 
                    "userLink": "https://www.zhihu.com/people/9d205838fda230276a7cd7b2221178a9", 
                    "content": "<p>感谢分享！已推荐到《开发者头条》：<a href=\"http://link.zhihu.com/?target=https%3A//toutiao.io/posts/7agmbh\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">性能优化之组件懒加载：Vue Lazy Component 介绍</a> 欢迎点赞支持！</p><p>欢迎订阅《技术分享小站》<a href=\"http://link.zhihu.com/?target=https%3A//toutiao.io/subjects/12684\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">热门分享 - 技术分享小站</a></p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>学习了，感谢！</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "有理想", 
                    "userLink": "https://www.zhihu.com/people/bceb0b9d318407796080f1e0449bcd21", 
                    "content": "<p>你好，看完你们的文章受益匪浅。不过我有两个问题，还望不吝赐教。</p><p>1. IntersectionObserver 只有线程空闲下来，才会执行观察器。这意味着，这个观察器的优先级非常低，只在其他任务执行完，浏览器有了空闲才会执行。这样会导致刚一打开页面，用户快速下拉滚动条，此时如果接口也比较慢，就会加长用户的等待时间。</p><p>2. 骨架屏这个概念就类似于在数据获取之前放一个loading图，放loading图的话更加简单，请问你们为啥要舍弃这种方式而用骨架屏？</p><p>大神如果看到了，请解答下，谢谢谢谢大神</p><p><br></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Peter Cheng", 
                            "userLink": "https://www.zhihu.com/people/564abf3ad7a477b3b910e733a7d37c34", 
                            "content": "1，intersectionObserver只放在每一帧空闲时渲染，有一个最大执行时间，100ms。2，骨架图能让用户优先知道呈现内容分布，比如标题和作者，这是loading不具备的。", 
                            "likes": 0, 
                            "replyToAuthor": "有理想"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36369422", 
            "userName": "binggg", 
            "userLink": "https://www.zhihu.com/people/cb3bb49977e986142c9e390e16604c15", 
            "upvote": 6, 
            "title": "致敬 React: 为 Vue 引入容器组件和展示组件", 
            "content": "<p>如果你使用过 Redux 开发 React，你一定听过 容器组件（Smart/Container Components） 或 展示组件（Dumb/Presentational Components），这样划分有什么样的好处，我们能否能借鉴这种划分方式来编写 Vue 代码呢？这篇文章会演示为什么我们应该采取这种模式，以及如何在 Vue 中编写这两种组件。</p><h2>为什么要使用容器组件?</h2><p>假如我们要写一个组件来展示评论，在没听过容器组件之前，我们的代码一般都是这样写的：</p><h2>components/CommentList.vue</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e7991771b7c00dda9ddd6bb4cee6bda2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"1242\" class=\"origin_image zh-lightbox-thumb\" width=\"908\" data-original=\"https://pic3.zhimg.com/v2-e7991771b7c00dda9ddd6bb4cee6bda2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;908&#39; height=&#39;1242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"1242\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"908\" data-original=\"https://pic3.zhimg.com/v2-e7991771b7c00dda9ddd6bb4cee6bda2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e7991771b7c00dda9ddd6bb4cee6bda2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>store/index.js</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8a92668c7c83835b2478b04e8d0c0193_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"788\" data-rawheight=\"1602\" class=\"origin_image zh-lightbox-thumb\" width=\"788\" data-original=\"https://pic4.zhimg.com/v2-8a92668c7c83835b2478b04e8d0c0193_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;788&#39; height=&#39;1602&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"788\" data-rawheight=\"1602\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"788\" data-original=\"https://pic4.zhimg.com/v2-8a92668c7c83835b2478b04e8d0c0193_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8a92668c7c83835b2478b04e8d0c0193_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这样写看起来理所当然，有没有什么问题，或者可以优化的地方呢？</p><p>有一个很显而易见的问题，由于 CommentList.vue 与 项目的 Vuex store 产生了耦合，导致脱离当前的项目很难复用。</p><p>有没有更好的组件的组织方式，可以解决这个问题呢？是时候了解下 React 社区的容器组件的概念了。</p><h2>什么是容器组件</h2><p>在 React.js Conf 2015 ，有一个 <a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DKYzlpRvWZ6c%26t%3D1351\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Making your app fast with high-performance components</a> 的主题介绍了容器组件。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-da2d7b1de0ce398f10b3f1ac8ddf6f14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb\" width=\"1046\" data-original=\"https://pic1.zhimg.com/v2-da2d7b1de0ce398f10b3f1ac8ddf6f14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1046&#39; height=&#39;544&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1046\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1046\" data-original=\"https://pic1.zhimg.com/v2-da2d7b1de0ce398f10b3f1ac8ddf6f14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-da2d7b1de0ce398f10b3f1ac8ddf6f14_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>容器组件专门负责和 store 通信，把数据通过 props 传递给普通的展示组件，展示组件如果想发起数据的更新，也是通过容器组件通过 props 传递的回调函数来告诉 store。</p><p>由于展示组件不再直接和 store 耦合，而是通过 props 接口来定义自己所需的数据和方法，使得展示组件的可复用性会更高。</p><h2>容器组件 和 展示组件 的区别</h2><p><b>展示组件容器组件</b>作用描述如何展现（骨架、样式）描述如何运行（数据获取、状态更新）直接使用 store否是数据来源props监听 store state数据修改从 props 调用回调函数向 store 派发 actions</p><blockquote>来自 Redux 文档 <a href=\"https://link.zhihu.com/?target=https%3A//user-gold-cdn.xitu.io/2018/5/2/1631f590aa5512b7\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">user-gold-cdn.xitu.io/2</span><span class=\"invisible\">018/5/2/1631f590aa5512b7</span><span class=\"ellipsis\"></span></a></blockquote><h2>用 容器组件/展示组件 模式改造上面的例子</h2><p>针对最初的例子，如何快速按照这种模式来划分组件呢？我们主要针对 CommentList.vue 进行拆分,首先是基本的概要设计：</p><h2>概要设计</h2><h2>展示组件</h2><ul><li><b><code>components/CommentListNew.vue</code></b> 这是一个新的评论展示组件，用于展示评论</li><li><code>comments:Array</code> prop 接收以 <code>{id,author,body}</code> 形式显示的 comment 项数组。</li><li><code>fetch()</code> 接收更新评论数据的方法</li></ul><p>展示组件只定义外观并不关心数据来源和如何改变。传入什么就渲染什么。</p><p>comments、fetch 等这些 props 并不关心背后是否是由 Vuex 提供的，你可以使用 Vuex，或者其他状态管理库，甚至是一个 EventBus，都可以复用这些展示组件。</p><p>同时，可以利用 props 的类型和验证来约束传入的内容，比如验证传入的 comments 是否是一个含有指定字段的对象，这在之前混合组件的情况是下是没有的，提高了代码的健壮性。</p><h2>容器组件</h2><ul><li><b><code>containers/CommentListContainer.vue</code></b> 将 CommentListNew 组件连接到 store</li></ul><p>容器组件可以将 store 对应的 state 或者 action 等封装传入展示组件。</p><h2>编码实现</h2><blockquote>Talk is cheap, show me the code!</blockquote><h2>components/CommentListNew.vue</h2><p>这个文件不再依赖 store，改为从 props 传递。</p><p>值得注意的是 comments 和 fetch 分别定义了 type 、default 和 validator，用以定义和验证 props。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-679525324c15bbf54883b47fbaed97ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"1746\" class=\"origin_image zh-lightbox-thumb\" width=\"908\" data-original=\"https://pic4.zhimg.com/v2-679525324c15bbf54883b47fbaed97ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;908&#39; height=&#39;1746&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"1746\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"908\" data-original=\"https://pic4.zhimg.com/v2-679525324c15bbf54883b47fbaed97ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-679525324c15bbf54883b47fbaed97ff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>containers/CommentListContainer.vue</h2><p>容器组件的职责</p><ul><li>通过 computed 来获取到状态更新，传递给展示组件</li><li>通过 methods 定义回调函数，回调函数内部调用 store 的 dispatch 方法，传递给展示组件</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3f88169e7f2f7ca1ccb02a437bbfffb0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1108\" data-rawheight=\"1458\" class=\"origin_image zh-lightbox-thumb\" width=\"1108\" data-original=\"https://pic1.zhimg.com/v2-3f88169e7f2f7ca1ccb02a437bbfffb0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1108&#39; height=&#39;1458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1108\" data-rawheight=\"1458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1108\" data-original=\"https://pic1.zhimg.com/v2-3f88169e7f2f7ca1ccb02a437bbfffb0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3f88169e7f2f7ca1ccb02a437bbfffb0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>使用 @xunlei/vuex-connector 实现容器组件</h2><p>上面演示的容器组件的代码非常简单，实际上如果直接投入生产环境，会产生一些问题。</p><h2>手动实现容器组件存在的不足</h2><h2>代码比较繁琐</h2><p>在上面的例子中，每次传递一个 state 都要定义一个 computed，每传递一个 mutation 或者 action 都需要定义一个方法，而且还要注意这个方法的参数要透传过去，同时还要处理返回值，比如异步的 action 需要返回 promise 的时候，定义的这个 method 也得把 action 的返回值返回出去。</p><h2>无法透传其他 props 给展示组件</h2><p>比如展示组件新增了一个 prop 叫做 type，可以传递一个评论的类型，用来区分是热门还是最新，如果用上面的容器实现方式，首先需要在容器组件这层新增一个 prop 叫做 type 接受外部传来的参数，然后在展示组件内部同样定义一个 叫做 type 的 prop，然后才能传递下去。</p><p>需要透传的 props 必须定义两遍，增加了维护的成本。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-991134f9d191a2aaa4cce2a0eec2667a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1164\" data-rawheight=\"378\" class=\"origin_image zh-lightbox-thumb\" width=\"1164\" data-original=\"https://pic3.zhimg.com/v2-991134f9d191a2aaa4cce2a0eec2667a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1164&#39; height=&#39;378&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1164\" data-rawheight=\"378\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1164\" data-original=\"https://pic3.zhimg.com/v2-991134f9d191a2aaa4cce2a0eec2667a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-991134f9d191a2aaa4cce2a0eec2667a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6a477fc937b1ca05aafb69592fbc7955_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"620\" data-original=\"https://pic2.zhimg.com/v2-6a477fc937b1ca05aafb69592fbc7955_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;620&#39; height=&#39;522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"620\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"620\" data-original=\"https://pic2.zhimg.com/v2-6a477fc937b1ca05aafb69592fbc7955_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6a477fc937b1ca05aafb69592fbc7955_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>容器组件无法统一进行优化</h2><p>每一个手动实现的容器组件实质上代码逻辑非常近似，但是没有经过同一层封装，如果目前实现的容器组件存在一些性能优化的地方，需要每个容器组件都进行统一的修改。</p><h2>无法控制展示组件不去获取 store</h2><p>因为容器组件是通过 this.$store 获取 store 的，展示组件内部实质上也可以直接跟 store 通信，如果没有约束，很难统一要求展示组件不得直接和 store 通信。</p><h2>使用 @xunlei/vuex-connector</h2><p>@xunlei/vuex-connector 借鉴了 react redux 的 connect 方法，在 vuex 基础上进行的开发。</p><p>有以下几个特点：</p><h2>代码非常简洁</h2><p>下面是上面例子中手动实现的容器组件的改造版本：</p><h2>comonents/ConnectCommentListContainer.vue</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b657d45b4853f66f6ebe353522e0ed49_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1160\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb\" width=\"1160\" data-original=\"https://pic2.zhimg.com/v2-b657d45b4853f66f6ebe353522e0ed49_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1160&#39; height=&#39;810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1160\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1160\" data-original=\"https://pic2.zhimg.com/v2-b657d45b4853f66f6ebe353522e0ed49_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b657d45b4853f66f6ebe353522e0ed49_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>通过 connector 的 connnect 方法，传入要映射的配置，支持 mapStateToProps, mapGettersToProps, mapDispatchToProps, mapCommitToProps 这四种，每一种都是只要配置一个简单的 map 函数，或者字符串即可。</p><p>然后在返回的函数中传入要连接的展示组件，是不是非常的简洁，同时借鉴了 redux 优雅的函数式风格。</p><h2>问题来了，connector 是什么？</h2><p>connector 实际上是一个能获取到 store 实例的连接器，可以在初始化 vuex store 的时候进行初始化。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c0c95e6721f0818f19ec8917c423882_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1076\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb\" width=\"1076\" data-original=\"https://pic3.zhimg.com/v2-4c0c95e6721f0818f19ec8917c423882_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1076&#39; height=&#39;810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1076\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1076\" data-original=\"https://pic3.zhimg.com/v2-4c0c95e6721f0818f19ec8917c423882_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c0c95e6721f0818f19ec8917c423882_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一个 Vue 程序实际上只需要初始化一次即可。</p><h2>支持透传其他 props 给展示组件</h2><p>VuexConnector 实现的时候采用了函数式组件( <code>functional:true</code> )</p><p>函数式组件是无状态 (没有响应式数据)，无实例 (没有 this 上下文)。</p><p>在作为包装组件时函数式组件非常有用，比如，当你需要做这些时：</p><ul><li>程序化地在多个组件中选择一个</li><li>在将 children, props, data 传递给子组件之前操作它们。</li></ul><p>另外，函数式组件只是一个函数，所以渲染开销也低很多。然而，对持久化实例的缺乏也意味着函数式组件不会出现在 Vue devtools 的组件树里。</p><p>因此需要透传的 props 可以直接透传，需要通过 map 方式从 store 里进行获取的 props 直接会根据配置生成。</p><h2>统一封装方便后续统一优化</h2><p>VuexConnector.connect 方法将本来需要重复做的事情进行了抽象，也带来了后期进行统一优化和升级的便利。</p><h2>可以控制展示组件无法直接与 store 通信</h2><p>VuexConnector 不依赖 this.$store，而是依赖初始化传入的 store 实例，容器组件可以用 connect 将展示组件与 store 进行连接。</p><p>由于不依赖 this.$store，我们在程序入口 new Vue 的时候，就不需要传入 store 实例了。</p><p>比如，之前我们是通过下面的方式进行初始化：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ba411ded7dd501ec76d81427979d7a37_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"702\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-ba411ded7dd501ec76d81427979d7a37_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;702&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"702\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-ba411ded7dd501ec76d81427979d7a37_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ba411ded7dd501ec76d81427979d7a37_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用了 VuexConnector 之后，在最初 new Vue 的时候就不需要也最好不要传递 store 了，这样就避免了 this.$store 泛滥导致代码耦合的问题。</p><h2>引入容器组件/展示组件模式带来的好处</h2><h2>可复用性</h2><p>容器组件/展示组件的划分，采用了单一职责原则的设计模式，容器组件专门负责和 store 通信，展示组件只负责展示，解除了组件的耦合，可以带来更好的可复用性。</p><h2>健壮性</h2><p>由于展示组件和容器组件是通过 props 这种接口来连接，可以利用 props 的校验来增强代码的可靠性，混合的组件就没有这种好处。</p><p>另外对 props 的校验可以采取一下几种方式：</p><h2>Vue 组件 props 验证</h2><p>可以验证 props 的类型，默认可以校验是否是以下类型：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Function</li><li>Object</li><li>Array</li><li>Symbol</li></ul><p>如果你的 props 是类的一个实例，type 也可以是一个自定义构造器函数，使用 instanceof 检测。</p><p>如果还是不满足需求，可以自定义验证函数：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6fdde71f03672eb747a45a247e01b600_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"558\" class=\"origin_image zh-lightbox-thumb\" width=\"740\" data-original=\"https://pic1.zhimg.com/v2-6fdde71f03672eb747a45a247e01b600_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;740&#39; height=&#39;558&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"558\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"740\" data-original=\"https://pic1.zhimg.com/v2-6fdde71f03672eb747a45a247e01b600_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6fdde71f03672eb747a45a247e01b600_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>TypeScript 类型系统</h2><p>Vue 组件 props 验证对于对象或者其他复杂的类型校验还是不太友好，所以很多人也推荐大家的 props 尽量采取简单类型，不过如果你有在用 TypeScript 开发 Vue 应用，可以利用 TypeScript 静态类型检查来声明你的 props 。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-873d6aaa7d8ae4eeda9bce82a8da06e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1052\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"1052\" data-original=\"https://pic2.zhimg.com/v2-873d6aaa7d8ae4eeda9bce82a8da06e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1052&#39; height=&#39;522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1052\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1052\" data-original=\"https://pic2.zhimg.com/v2-873d6aaa7d8ae4eeda9bce82a8da06e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-873d6aaa7d8ae4eeda9bce82a8da06e9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>可测试性</h2><p>由于组件做的事情更少了，使得测试也会变得容易。</p><p>容器组件不用关心 UI 的展示，只关心数据和更新。</p><p>展示组件只是呈现传入的 props ，写单元测试的时候也非常容易 mock 数据层。</p><h2>引入容器组件/展示组件模式带来的限制</h2><h2>学习和开发成本</h2><p>因为容器组件/展示组件的拆分，初期会增加一些学习成本，不过当你看完这篇文章，基本上也就入门了。</p><p>在开发的时候，由于需要封装一个容器，包装一些数据和接口给展示组件，会增加一些工作量， @xunlei/vuex-connector 通过配置的方式可以减轻不少你的工作量。</p><p>另外，在展示组件内对 props 的声明也会带来少量的工作。</p><p><b>总体来说，引入容器组件/展示组件模式投入产出比还是比较值得的。</b></p><h2>延伸阅读</h2><ul><li>Redux 文档 <a href=\"https://link.zhihu.com/?target=https%3A//user-gold-cdn.xitu.io/2018/5/2/1631f590aa5512b7\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">user-gold-cdn.xitu.io/2</span><span class=\"invisible\">018/5/2/1631f590aa5512b7</span><span class=\"ellipsis\"></span></a></li><li>Making your app fast with high-performance components <a href=\"https://link.zhihu.com/?target=https%3A//www.youtube.com/watch%3Fv%3DKYzlpRvWZ6c%26t%3D1351\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">youtube.com/watch?</span><span class=\"invisible\">v=KYzlpRvWZ6c&amp;t=1351</span><span class=\"ellipsis\"></span></a></li></ul><h2>代码示例</h2><h2>Vue Vuex 容器-展示组件模式 Demo</h2><h2>Demo 在线地址:</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//xunleif2e.github.io/vue-vuex-container-component/dist/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">xunleif2e.github.io/vue</span><span class=\"invisible\">-vuex-container-component/dist/</span><span class=\"ellipsis\"></span></a></p><h2>Demo 源码：</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vue-vuex-container-component\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/xunleif2e/vu</span><span class=\"invisible\">e-vuex-container-component</span><span class=\"ellipsis\"></span></a></p><h2>@xunlei/vuex-connector</h2><p>基于 Vue 生态实现的Vuex store Connector</p><h2>@xunlei/vuex-connector 源码:</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/xunleif2e/vuex-connector\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/xunleif2e/vu</span><span class=\"invisible\">ex-connector</span><span class=\"ellipsis\"></span></a></p><p>欢迎 Star</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">作者：binggg\n校对：珈蓝</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">微信搜索 蜂鸟前端 关注迅雷前端公众号</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "Redux", 
                    "tagLink": "https://api.zhihu.com/topics/20030680"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87181015", 
            "userName": "binggg", 
            "userLink": "https://www.zhihu.com/people/cb3bb49977e986142c9e390e16604c15", 
            "upvote": 7, 
            "title": "Nuxt 自适应 SSR 方案: SEO 和首屏最小化优化", 
            "content": "<p>之前的项目采用 Nuxt SSR 来完成服务端渲染 ，为满足 SEO 需求，将非首屏内容也进行了请求和服务端直出，导致首屏时间变长（非首屏的资源请求和组件的渲染都会带来额外开销）。对于海量的用户来说，少量的爬虫访问需求反而影响了正常用户的访问，导致 SEO 和用户体验提升存在很大的矛盾。</p><p>为了解决这个问题，我们设计和实践了自适应 SSR 方案，来同时满足这两种场景的需求。今天会分享这个方案的技术细节、设计思路以及在实施该方案过程中遇到的一些相关的子问题的实践踩坑经验，欢迎大家一起交流。</p><h2>分享大纲</h2><ul><li>问题来源和背景</li><li>问题解决思路</li><li>自适应 SSR 方案介绍</li><li>采用自适应 SSR 优化前后数据</li><li>Vue SSR client side hydration 踩坑实践</li><li>使用 SVG 生成骨架屏踩坑实践</li></ul><h2>问题来源和背景</h2><p>目前项目采用 Nuxt SSR 来完成服务端渲染，为满足 SEO 需求，将非首屏资源也进行了请求和服务端直出，导致首屏时间变长（非首屏的资源请求和组件的渲染都会带来额外开销）</p><h3>优化前的加载流程图</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-18502cd99d249bcd2a01a74e57076730_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2321\" data-rawheight=\"1047\" class=\"origin_image zh-lightbox-thumb\" width=\"2321\" data-original=\"https://pic1.zhimg.com/v2-18502cd99d249bcd2a01a74e57076730_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2321&#39; height=&#39;1047&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2321\" data-rawheight=\"1047\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2321\" data-original=\"https://pic1.zhimg.com/v2-18502cd99d249bcd2a01a74e57076730_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-18502cd99d249bcd2a01a74e57076730_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>目前我们的 Nuxt 项目采用 fetch 来实现 SSR 数据预取，fetch 中会处理所有关键和非关键请求</p><h3>Nuxt 生命周期图</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-042f38716dab613e1dd189111a611c5e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"1298\" class=\"origin_image zh-lightbox-thumb\" width=\"940\" data-original=\"https://pic3.zhimg.com/v2-042f38716dab613e1dd189111a611c5e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;940&#39; height=&#39;1298&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"1298\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"940\" data-original=\"https://pic3.zhimg.com/v2-042f38716dab613e1dd189111a611c5e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-042f38716dab613e1dd189111a611c5e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于海量的用户来说，少量的爬虫访问需求反而影响了正常用户的访问，导致 SEO 和用户体验提升存在很大的矛盾。</p><p>为了解决这个问题，我们希望能区分不同的场景进行不同的直出，SEO 场景全部直出，其他场景只直出最小化的首屏，非关键请求放在前端异步拉取</p><h2>解决思路</h2><p>计划通过统一的方式来控制数据加载，将数据加载由专门的插件来控制，插件会根据条件来选择性的加载数据，同时懒加载一部分数据</p><ul><li>判断是 SEO 情况，fetch 阶段执行所有的数据加载逻辑</li><li>非 SEO 场景，fetch 阶段只执行最小的数据加载逻辑，等到页面首屏直出后，通过一些方式来懒加载另一部分数据</li></ul><h3>优化后的项目影评页加载流程图</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4cb35b949abc5af711cfcb4997a2b28f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2546\" data-rawheight=\"1044\" class=\"origin_image zh-lightbox-thumb\" width=\"2546\" data-original=\"https://pic4.zhimg.com/v2-4cb35b949abc5af711cfcb4997a2b28f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2546&#39; height=&#39;1044&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2546\" data-rawheight=\"1044\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2546\" data-original=\"https://pic4.zhimg.com/v2-4cb35b949abc5af711cfcb4997a2b28f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4cb35b949abc5af711cfcb4997a2b28f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>自适应 SSR 方案介绍</h2><h3>Gitlab CI Pipeline</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b2fff4b50e6a0a90f3f71e54c2329453_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"910\" data-original=\"https://pic4.zhimg.com/v2-b2fff4b50e6a0a90f3f71e54c2329453_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;910&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"910\" data-original=\"https://pic4.zhimg.com/v2-b2fff4b50e6a0a90f3f71e54c2329453_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b2fff4b50e6a0a90f3f71e54c2329453_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>自研 Nuxt Fetch Pipeline</h3><p>借鉴 Gitlab CI 持续集成的概念和流程，将数据请求设计为不同的阶段 （Stage ），每个阶段执行不同的异步任务（Job），所有的阶段组成了数据请求的管线（Pipeline）</p><h3>预置的 Stage</h3><ul><li>seoFetch ： 面向 SEO 渲染需要的 job 集合，一般要求是全部数据请求都需要，尽可能多的服务端渲染内容</li><li>minFetch：首屏渲染需要的最小的 job 集合</li><li>mounted： 首屏加载完之后，在 mounted 阶段异步执行的 job 集合</li><li>idle： 空闲时刻才执行的 job 集合</li></ul><p>每一个页面的都有一个 Nuxt Fetch Pipeline 的实例来控制，Nuxt Fetch Pipeline 需要配置相应的 job 和 stage，然后会自适应判断请求的类型，针对性的处理异步数据拉取：</p><ul><li>如果是 SEO 场景，则只会执行 seoFetch 这个 stage 的 job 集合</li><li>如果是真实用户访问，则会在服务端先执行 minFetch 这个 stage 的 job 集合，然后立即返回，客户端可以看到首屏内容及骨架屏，然后在首屏加载完之后，会在 mounted 阶段异步执行 mounted stage 的 job 集合，另外一些优先级更低的 job，则会在 idle stage 也就是空闲的时候才执行。</li></ul><h3>Nuxt Fetch Pipeline 使用示例</h3><p>page 页面 index.vue</p><div class=\"highlight\"><pre><code class=\"language-text\">import NuxtFetchPipeline, {\n  pipelineMixin,\n  adaptiveFetch,\n} from &#39;@/utils/nuxt-fetch-pipeline&#39;;\nimport pipelineConfig from &#39;./index.pipeline.config&#39;;\n\nconst nuxtFetchPipeline = new NuxtFetchPipeline(pipelineConfig);\n\nexport default {\n  mixins: [pipelineMixin(nuxtFetchPipeline)],\n\n  fetch(context) {\n    return adaptiveFetch(nuxtFetchPipeline, context);\n  },\n};</code></pre></div><p>配置文件 index.pipeline.config.js</p><div class=\"highlight\"><pre><code class=\"language-text\">export default {\n  stages: {\n    // 面向SEO渲染需要的 job 集合，一般要求是全部\n    seoFetch: {\n      type: &#39;parallel&#39;,\n      jobs: [\n        &#39;task1&#39;\n      ]\n    },\n    // 首屏渲染需要的最小的 job 集合\n    minFetch: {\n      type: &#39;parallel&#39;,\n      jobs: [\n      ]\n    },\n    // 首屏加载完之后，在 mounted 阶段异步执行的 job 集合\n    mounted: {\n      type: &#39;parallel&#39;,\n      jobs: [\n      ]\n    },\n    // 空闲时刻才执行的 job 集合\n    idle: {\n      type: &#39;serial&#39;,\n      jobs: [\n      ]\n    }\n  },\n  pipelines: {\n    // 任务1\n    task1: {\n      task: ({ store, params, query, error, redirect, app, route }) =&amp;gt {\n        return store.dispatch(&#39;action&#39;, {})\n      }\n    }\n  }\n}</code></pre></div><h3>并发控制</h3><p>Stage 执行 Job 支持并行和串行 Stage 配置 type 为 parallel 时为并行处理，会同时开始每一个 job 等待所有的 job 完成后，这个 stage 才完成 Stage 配置 type 为 serial 时为串行处理，会依次开始每一个 job，前一个 job 完成后，后面的 job 才开始，最后一个 job 完成后，这个 stage 才完成</p><h3>Job 嵌套</h3><p>可以将一些可以复用的 job 定义为自定义的 stage，然后，在其他的 Stage 里按照如下的方式来引用，减少编码的成本</p><div class=\"highlight\"><pre><code class=\"language-text\">{\n  seoFetch: {\n    type: &#39;serial&#39;,\n    jobs:\n    [\n      &#39;getVideo&#39;,\n      { jobType: &#39;stage&#39;, name: &#39;postGetVideo&#39; }\n    ]\n  },\n  postGetVideo: {\n    type: &#39;parallel&#39;,\n    jobs: [\n      &#39;anyjob&#39;,\n      &#39;anyjob2&#39;\n    ]\n  }\n}</code></pre></div><h3>Job 的执行上下文</h3><p>为了方便编码，以及减少改动成本，每一个 job 执行上下文和 Nuxt fetch 类似，而是通过一个 context 参数来访问一些状态，由于 fetch 阶段还没有组件实例，为了保持统一，都不可以通过 this 访问实例</p><p>目前支持的 nuxt context 有</p><ul><li>app</li><li>route</li><li>store</li><li>params</li><li>query</li><li>error</li><li>redirect</li></ul><h3>Stage 的划分思路</h3><p>Stage适合的 Job是否并行seoFetch全部，SEO 场景追求越多越好最好并行minFetch关键的，比如首屏内容、核心流程需要的数据，页面的主要核心内容（例如影评页面是影评的正文，短视频页面是短视频信息，帖子页面是帖子正文）的数据最好并行mounted次关键内容的数据，例如侧边栏，第二屏等根据优先成都考虑是否并行idle最次要的内容的数据，例如页面底部，标签页被隐藏的部分尽量分批进行，不影响用户的交互</p><h2>使用 SVG 生成骨架屏踩坑实践</h2><p>由于服务端只拉取了关键数据，部分页面部分存在没有数据的情况，因此需要骨架屏来提升体验</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5d17e796ad160e9fdc926e752ab7fc33_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1920\" data-original=\"https://pic4.zhimg.com/v2-5d17e796ad160e9fdc926e752ab7fc33_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1920&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1920\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1920\" data-original=\"https://pic4.zhimg.com/v2-5d17e796ad160e9fdc926e752ab7fc33_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5d17e796ad160e9fdc926e752ab7fc33_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>Vue Content Loading 使用及原理</h3><h3>例子</h3><div class=\"highlight\"><pre><code class=\"language-text\">&lt;script&gt;\n  import VueContentLoading from &#39;vue-content-loading&#39;;\n\n  export default {\n    components: {\n      VueContentLoading,\n    },\n  };\n&lt;/script&gt;\n\n&lt;template&gt;\n  &lt;vue-content-loading :width=&#34;300&#34; :height=&#34;100&#34;&gt;\n    &lt;circle cx=&#34;30&#34; cy=&#34;30&#34; r=&#34;30&#34; /&gt;\n    &lt;rect x=&#34;75&#34; y=&#34;13&#34; rx=&#34;4&#34; ry=&#34;4&#34; width=&#34;100&#34; height=&#34;15&#34; /&gt;\n    &lt;rect x=&#34;75&#34; y=&#34;37&#34; rx=&#34;4&#34; ry=&#34;4&#34; width=&#34;50&#34; height=&#34;10&#34; /&gt;\n  &lt;/vue-content-loading&gt;\n&lt;/template&gt;</code></pre></div><h3>Vue Content Loading 核心代码</h3><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n  &lt;svg :viewBox=&#34;viewbox&#34; :style=&#34;svg&#34; preserveAspectRatio=&#34;xMidYMid meet&#34;&gt;\n    &lt;rect\n      :style=&#34;rect.style&#34;\n      :clip-path=&#34;rect.clipPath&#34;\n      x=&#34;0&#34;\n      y=&#34;0&#34;\n      :width=&#34;width&#34;\n      :height=&#34;height&#34;\n    /&gt;\n\n    &lt;defs&gt;\n      &lt;clipPath :id=&#34;clipPathId&#34;&gt;\n        &lt;slot&gt;\n          &lt;rect x=&#34;0&#34; y=&#34;0&#34; rx=&#34;5&#34; ry=&#34;5&#34; width=&#34;70&#34; height=&#34;70&#34; /&gt;\n          &lt;rect x=&#34;80&#34; y=&#34;17&#34; rx=&#34;4&#34; ry=&#34;4&#34; width=&#34;300&#34; height=&#34;13&#34; /&gt;\n          &lt;rect x=&#34;80&#34; y=&#34;40&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;250&#34; height=&#34;10&#34; /&gt;\n          &lt;rect x=&#34;0&#34; y=&#34;80&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;350&#34; height=&#34;10&#34; /&gt;\n          &lt;rect x=&#34;0&#34; y=&#34;100&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;400&#34; height=&#34;10&#34; /&gt;\n          &lt;rect x=&#34;0&#34; y=&#34;120&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;360&#34; height=&#34;10&#34; /&gt;\n        &lt;/slot&gt;\n      &lt;/clipPath&gt;\n\n      &lt;linearGradient :id=&#34;gradientId&#34;&gt;\n        &lt;stop offset=&#34;0%&#34; :stop-color=&#34;primary&#34;&gt;\n          &lt;animate\n            attributeName=&#34;offset&#34;\n            values=&#34;-2; 1&#34;\n            :dur=&#34;formatedSpeed&#34;\n            repeatCount=&#34;indefinite&#34;\n          /&gt;\n        &lt;/stop&gt;\n\n        &lt;stop offset=&#34;50%&#34; :stop-color=&#34;secondary&#34;&gt;\n          &lt;animate\n            attributeName=&#34;offset&#34;\n            values=&#34;-1.5; 1.5&#34;\n            :dur=&#34;formatedSpeed&#34;\n            repeatCount=&#34;indefinite&#34;\n          /&gt;\n        &lt;/stop&gt;\n\n        &lt;stop offset=&#34;100%&#34; :stop-color=&#34;primary&#34;&gt;\n          &lt;animate\n            attributeName=&#34;offset&#34;\n            values=&#34;-1; 2&#34;\n            :dur=&#34;formatedSpeed&#34;\n            repeatCount=&#34;indefinite&#34;\n          /&gt;\n        &lt;/stop&gt;\n      &lt;/linearGradient&gt;\n    &lt;/defs&gt;\n  &lt;/svg&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  const validateColor = color =&gt;\n    /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/.test(color);\n  export default {\n    name: &#39;VueContentLoading&#39;,\n    props: {\n      rtl: {\n        default: false,\n        type: Boolean,\n      },\n      speed: {\n        default: 2,\n        type: Number,\n      },\n      width: {\n        default: 400,\n        type: Number,\n      },\n      height: {\n        default: 130,\n        type: Number,\n      },\n      primary: {\n        type: String,\n        default: &#39;#f0f0f0&#39;,\n        validator: validateColor,\n      },\n      secondary: {\n        type: String,\n        default: &#39;#e0e0e0&#39;,\n        validator: validateColor,\n      },\n    },\n    computed: {\n      viewbox() {\n        return `0 0 ${this.width} ${this.height}`;\n      },\n      formatedSpeed() {\n        return `${this.speed}s`;\n      },\n      gradientId() {\n        return `gradient-${this.uid}`;\n      },\n      clipPathId() {\n        return `clipPath-${this.uid}`;\n      },\n      svg() {\n        if (this.rtl) {\n          return {\n            transform: &#39;rotateY(180deg)&#39;,\n          };\n        }\n      },\n      rect() {\n        return {\n          style: {\n            fill: &#39;url(#&#39; + this.gradientId + &#39;)&#39;,\n          },\n          clipPath: &#39;url(#&#39; + this.clipPathId + &#39;)&#39;,\n        };\n      },\n    },\n    data: () =&gt; ({\n      uid: null,\n    }),\n    created() {\n      this.uid = this._uid;\n    },\n  };\n&lt;/script&gt;</code></pre></div><h3>SVG 动画卡顿</h3><p>使用了 Vue content loading 做骨架屏之后，发现在 js 加载并执行的时候动画会卡住，而 CSS 动画大部分情况下可以脱离主线程执行，可以避免卡顿</p><blockquote>CSS animations are the better choice. But how? The key is that as long as the properties we want to animate do not trigger reflow/repaint (read CSS triggers for more information), we can move those sampling operations out of the main thread. The most common property is the CSS transform. If an element is promoted as a layer, animating transform properties can be done in the GPU, meaning better performance/efficiency, especially on mobile. Find out more details in OffMainThreadCompositing. <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/Performance/CSS_JavaScript_animation_performance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">developer.mozilla.org/e</span><span class=\"invisible\">n-US/docs/Web/Performance/CSS_JavaScript_animation_performance</span><span class=\"ellipsis\"></span></a></blockquote><p>测试 Demo 地址</p><p><a href=\"https://link.zhihu.com/?target=https%3A//jsbin.com/wodenoxaku/1/edit%3Fhtml%2Ccss%2Coutput\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">jsbin.com/wodenoxaku/1/</span><span class=\"invisible\">edit?html,css,output</span><span class=\"ellipsis\"></span></a></p><p>看起来浏览器并没有对 SVG 动画做这方面的优化，最终，我们修改了 Vue content loading 的实现，改为了使用 CSS 动画来实现闪烁的加载效果</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n  &lt;div :style=&#34;style&#34;&gt;\n    &lt;svg :viewBox=&#34;viewbox&#34; preserveAspectRatio=&#34;xMidYMid meet&#34;&gt;\n      &lt;defs :key=&#34;uid&#34;&gt;\n        &lt;clipPath :id=&#34;clipPathId&#34; :key=&#34;clipPathId&#34;&gt;\n          &lt;slot&gt;\n            &lt;rect x=&#34;0&#34; y=&#34;0&#34; rx=&#34;5&#34; ry=&#34;5&#34; width=&#34;70&#34; height=&#34;70&#34; /&gt;\n            &lt;rect x=&#34;80&#34; y=&#34;17&#34; rx=&#34;4&#34; ry=&#34;4&#34; width=&#34;300&#34; height=&#34;13&#34; /&gt;\n            &lt;rect x=&#34;80&#34; y=&#34;40&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;250&#34; height=&#34;10&#34; /&gt;\n            &lt;rect x=&#34;0&#34; y=&#34;80&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;350&#34; height=&#34;10&#34; /&gt;\n            &lt;rect x=&#34;0&#34; y=&#34;100&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;400&#34; height=&#34;10&#34; /&gt;\n            &lt;rect x=&#34;0&#34; y=&#34;120&#34; rx=&#34;3&#34; ry=&#34;3&#34; width=&#34;360&#34; height=&#34;10&#34; /&gt;\n          &lt;/slot&gt;\n        &lt;/clipPath&gt;\n      &lt;/defs&gt;\n    &lt;/svg&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n  const validateColor = color =&gt;\n    /^#([A-Fa-f0-9]{3}|[A-Fa-f0-9]{6})$/.test(color);\n\n  export default {\n    name: &#39;VueContentLoading&#39;,\n    props: {\n      rtl: {\n        default: false,\n        type: Boolean,\n      },\n      speed: {\n        default: 2,\n        type: Number,\n      },\n      width: {\n        default: 400,\n        type: Number,\n      },\n      height: {\n        default: 130,\n        type: Number,\n      },\n      primary: {\n        type: String,\n        default: &#39;#F0F0F0&#39;,\n        validator: validateColor,\n      },\n      secondary: {\n        type: String,\n        default: &#39;#E0E0E0&#39;,\n        validator: validateColor,\n      },\n      uid: {\n        type: String,\n        required: true,\n      },\n    },\n    computed: {\n      viewbox() {\n        return `0 0 ${this.width} ${this.height}`;\n      },\n      formatedSpeed() {\n        return `${this.speed}s`;\n      },\n      clipPathId() {\n        return `clipPath-${this.uid || this._uid}`;\n      },\n      style() {\n        return {\n          width: `${this.width}px`,\n          height: `${this.height}px`,\n          backgroundSize: &#39;200%&#39;,\n          backgroundImage: `linear-gradient(-90deg, ${this.primary} 0, ${this.secondary} 20%, ${this.primary} 50%,  ${this.secondary} 75%,  ${this.primary})`,\n          clipPath: &#39;url(#&#39; + this.clipPathId + &#39;)&#39;,\n          animation: `backgroundAnimation ${this.formatedSpeed} infinite linear`,\n          transform: this.rtl ? &#39;rotateY(180deg)&#39; : &#39;none&#39;,\n        };\n      },\n    },\n  };\n&lt;/script&gt;\n\n&lt;style lang=&#34;scss&#34;&gt;\n  @keyframes backgroundAnimation {\n    0% {\n      background-position-x: 100%;\n    }\n\n    50% {\n      background-position-x: 0;\n    }\n\n    100% {\n      background-position-x: -100%;\n    }\n  }\n&lt;/style&gt;</code></pre></div><h2>Vue SSR client side hydration 踩坑实践</h2><h3>一个例子</h3><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n  &lt;div :id=&#34;id&#34;&gt; text: {{ id }}&lt;/div&gt;\n&lt;/template&gt;\n&lt;script&gt;\n  export default {\n    data () {\n       return {\n         id: Math.random()\n       }\n    }\n  }\n&lt;/script&gt;</code></pre></div><p>client side hydration 的结果会是如何呢？</p><ul><li>A. id 是 client 端随机数， text 是 client 端随机数</li><li>B. id 是 client 端随机数， text 是 server 端随机数</li><li>C. id 是 server 端随机数， text 是 client 端随机数</li><li>D. id 是 server 端随机数， text 是 server 端随机数</li></ul><h3>为什么要问这个问题 ？</h3><p>Vue content loading 内部依赖了 this._uid 来作为 svg defs 里的 clippath 的 id，然而 this._uid 在客户端和服务端并不一样，实际跟上面随机数的例子差不多。</p><p>client side hydration 的结果是 C</p><p>也就是说 id 并没有改变，导致的现象在我们这个场景就是骨架屏闪了一下就没了</p><h3>为什么会出现这个情况？</h3><p>初始化 Vue 到最终渲染的整个过程</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d0bd628c2b6bfcd8a09a6957be0f9b52_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb\" width=\"732\" data-original=\"https://pic3.zhimg.com/v2-d0bd628c2b6bfcd8a09a6957be0f9b52_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;732&#39; height=&#39;351&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"351\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"732\" data-original=\"https://pic3.zhimg.com/v2-d0bd628c2b6bfcd8a09a6957be0f9b52_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d0bd628c2b6bfcd8a09a6957be0f9b52_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>来源：<a href=\"https://link.zhihu.com/?target=https%3A//ustbhuangyi.github.io/vue-analysis/data-driven/update.html%23%25E6%2580%25BB%25E7%25BB%2593\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">ustbhuangyi.github.io/v</span><span class=\"invisible\">ue-analysis/data-driven/update.html#%E6%80%BB%E7%BB%93</span><span class=\"ellipsis\"></span></a></p><p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p><p>在 entry-client.js 中，我们用下面这行挂载(mount)应用程序：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 这里假定 App.vue template 根元素的 `id=&#34;app&#34;`\napp.$mount(&#39;#app&#39;);</code></pre></div><p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要&#34;激活&#34;这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p><p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;div id=&#34;app&#34; data-server-rendered=&#34;true&#34;&gt;&lt;/div&gt;</code></pre></div><p>data-server-rendered 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 id=&#34;app&#34;，而是添加 data-server-rendered 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。</p><p>注意，在没有 data-server-rendered 属性的元素上，还可以向 \\$mount 函数的 hydrating 参数位置传入 true，来强制使用激活模式(hydration)：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 强制使用应用程序的激活模式\napp.$mount(&#39;#app&#39;, true);</code></pre></div><p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。在生产模式下，此检测会被跳过，以避免性能损耗。</p><p>vue 对于 attrs,class,staticClass,staticStyle,key 这些是不处理的</p><p>list of modules that can skip create hook during hydration because they are already rendered on the client or has no need</p><h3>uid 解决方案</h3><h3>根据组件生成唯一 UUID</h3><ul><li>props 和 slot 转换为字符串</li><li>hash 算法</li></ul><p>太重了，放弃</p><h3>最终解决方案</h3><p>干脆让用户自己传 ID</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;vue-content-loading\n  uid=&#34;circlesMediaSkeleton&#34;\n  v-bind=&#34;$attrs&#34;\n  :width=&#34;186&#34;\n  :height=&#34;height&#34;\n&gt;\n  &lt;template v-for=&#34;i in rows&#34;&gt;\n    &lt;rect\n      :key=&#34;i + &#39;_r&#39;&#34;\n      x=&#34;4&#34;\n      :y=&#34;getYPos(i, 4)&#34;\n      rx=&#34;2&#34;\n      ry=&#34;2&#34;\n      width=&#34;24&#34;\n      height=&#34;24&#34;\n    /&gt;\n    &lt;rect\n      :key=&#34;i + &#39;_r&#39;&#34;\n      x=&#34;36&#34;\n      :y=&#34;getYPos(i, 6)&#34;\n      rx=&#34;3&#34;\n      ry=&#34;3&#34;\n      width=&#34;200&#34;\n      height=&#34;18&#34;\n    /&gt;\n  &lt;/template&gt;\n&lt;/vue-content-loading&gt;</code></pre></div><h2>优化效果</h2><ul><li>通过减少 fetch 阶段的数据拉取的任务，减少了数据拉取时间</li><li>同时减少了服务端渲染的组件数和开销，缩短了首字节时间</li><li>首屏大小变小也缩短了下载首屏所需的时间</li></ul><p>综合起来，首字节、首屏时间都将提前，可交互时间也会提前</p><h3>本地数据</h3><p>类型服务响应时间首页大小 未 Gzip首页修改前0.88s561 KB首页（最小化 fetch 请求）0.58s217 KB</p><p>在本地测试，服务端渲染首页只请求关键等服务器接口请求时，服务响应时间<b>缩短 0.30s</b>，<b>降低 34%</b>，首页 html 文本大小<b>降低 344 KB</b>,<b>减少 60%</b></p><h3>线上数据</h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ea42296fe794a443086e4aa97332793d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-ea42296fe794a443086e4aa97332793d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-ea42296fe794a443086e4aa97332793d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ea42296fe794a443086e4aa97332793d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>首页的首屏可见时间中位数从 2-3s 降低到了 1.1s 左右，加载速度提升 100%+</p><h2>总结</h2><p>本文分享了如何解决 SEO 和用户体验提升之间存在矛盾的问题，介绍了我们如何借鉴 Gitlab CI 的 pipeline 的概念，在服务端渲染时兼顾首屏最小化和 SEO，分享了自适应 SSR 的技术细节、设计思路以及在实施该方案过程中遇到的一些相关的子问题的实践踩坑经验，希望对大家有所启发和帮助。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>关于我</h2><div class=\"highlight\"><pre><code class=\"language-text\">binggg(Booker Zhao) @腾讯\n\n- 先后就职于迅雷、腾讯等，个人开源项目有 mrn.js 等\n- 创办了迅雷内部组件仓库 XNPM ，参与几个迅雷前端开源项目的开发\n- 热衷于优化和提效，是一个奉行“懒惰使人进步”的懒人工程师\n</code></pre></div><h3>社交资料</h3><ul><li>🐙 GitHub: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fgithub.com%252Fbinggg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://github.com/binggg</a></li><li>📕 简书: <a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/60f22559b79f\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/u/60f22559b</span><span class=\"invisible\">79f</span><span class=\"ellipsis\"></span></a></li><li>📒 掘金: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fjuejin.im%252Fuser%252F58d31f130ce4630057edb3ba\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://juejin.im/user/58d31f130ce4630057edb3ba</a></li><li>👁️‍🗨️ 微博: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fweibo.com%252Fbeing99\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://weibo.com/being99</a></li><li>📗 思否: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fsegmentfault.com%252Fu%252Fbinggg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://segmentfault.com/u/binggg</a></li><li>📚 博客园: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fwww.cnblogs.com%252Fbinggg%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.cnblogs.com/binggg/</a></li><li>📖 开源中国: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fmy.oschina.net%252Fu%252F4217267\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://my.oschina.net/u/4217267</a></li><li>💻 极术社区: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Faijishu.com%252Fu%252Fbinggg\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://aijishu.com/u/binggg</a></li><li>📰 今日头条: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fwww.toutiao.com%252Fc%252Fuser%252F102306299647\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.toutiao.com/c/user/102306299647</a></li><li>📝CSDN: <a href=\"https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Fblog.csdn.net%252Fweixin_42541867\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://blog.csdn.net/weixin_42541867</a></li></ul><p>微信公众号 <code>binggg_net</code>, 欢迎关注</p>", 
            "topic": [
                {
                    "tag": " SEO ", 
                    "tagLink": "https://api.zhihu.com/topics/20671741"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85812564", 
            "userName": "wayne", 
            "userLink": "https://www.zhihu.com/people/a234874d34c22c107ac89cacfbdb34a5", 
            "upvote": 0, 
            "title": "5分钟简单了解React-Hooks", 
            "content": "<p>首先附上官网正文😀：[React Hooks]([<a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/docs/hooks-intro.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Introducing Hooks – React</a>](<a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/docs/hooks-intro.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Introducing Hooks – React</a>)</p><p>)</p><blockquote>Hooks are a new addition in React 16.8. They let you use state and other React features without writing a class.</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>简单讲就是说，Hooks是在React 16.8版本中新增加的特性。可以让你通过不谢一个类class,就可以使用State和其他React特性。</p><p>另外使用ReactNative开发的小伙伴需要注意一下，就是在ReactNative 0.59正式版才开始支持Hooks.</p><blockquote>React 16.8.0 is the first release to support Hooks. When upgrading, don’t forget to update all packages, including React DOM. React Native supports Hooks since [the 0.59 release of React Native](<a href=\"https://link.zhihu.com/?target=https%3A//facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Releasing React Native 0.59 · React Native</a>).</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>现在通过写一个简单的案例来说明一下，下面代码中useState方法就是React已经内部实现的hook,是一个状态钩子。</p><p>1.使用class的方式,通过一个按钮点击改变文字</p><div class=\"highlight\"><pre><code class=\"language-text\">import React, {Component} from &#39;react&#39;\nimport {\n    Text,\n    View,\n    TouchableOpacity\n} from &#39;react-native&#39;\n\nexport default class demo_class extends Component {\n    constructor(props) {\n        super(props)\n        this.state = {\n            text: &#39;this is class demo&#39;\n        }\n    }\n\n    componentDidMount() {\n\n    }\n\n    _changeTheDefaultText = () =&gt; {\n        this.setState({\n            text: &#39;this is the new text&#39;\n        })\n    }\n\n    render() {\n        const {text} = this.state\n        return (\n            &lt;View&gt;\n                &lt;Text style={{fontSize: 20, color: &#39;red&#39;}}&gt;{text}&lt;/Text&gt;\n                &lt;TouchableOpacity onPress={this._changeTheDefaultText}&gt;\n                    &lt;Text style={{fontSize: 20, color: &#39;red&#39;}}&gt;改变文字&lt;/Text&gt;\n                &lt;/TouchableOpacity&gt;\n            &lt;/View&gt;\n        )\n    }\n}</code></pre></div><p>2.同样的方式，使用hook来实现</p><div class=\"highlight\"><pre><code class=\"language-text\">import React, {useState} from &#39;react&#39;\nimport {\n    Text,\n    View,\n    TouchableOpacity\n} from &#39;react-native&#39;\n\nconst demoHooks = () =&gt; {\n    // 初始值\n    const [text, setText] = useState(&#39;this is hook demo&#39;)\n    // 方法\n    _changeTheDefaultText = () =&gt; {\n        return setText(&#39;this is the new text&#39;)\n    }\n\n    return (\n        &lt;View&gt;\n            &lt;Text style={{fontSize: 20, color: &#39;red&#39;}}&gt;{text}&lt;/Text&gt;\n            &lt;TouchableOpacity onPress={this._changeTheDefaultText}&gt;\n                &lt;Text style={{fontSize: 20, color: &#39;red&#39;}}&gt;改变文字&lt;/Text&gt;\n            &lt;/TouchableOpacity&gt;\n        &lt;/View&gt;\n    )\n}\n\nexport default demoHooks</code></pre></div><p>通过上面两个简单的例子，直观看使用hook后的代码数明显比使用class完成的少，但实现的是同样的功能。是不是很欣喜呢？</p><blockquote> useState()这个函数接受一个初始值作为参数，和class中this.state设置的值一样。返回一个数组，数组的第一个成员是我们自定义的变量，就是状态的当前值，比如，例子中text;第二个成员是一个函数，用来修改state,通常约定set前缀加上自定义状态的变量名，比如例子中的setText</blockquote><p>3.新增加的这个hooks特性，没有突破性的改变</p><ul><li>- 是一个可选项。你完全可以尝试使用Hooks重写任何已有代码</li><li>- 100%向后兼容。Hooks并没有带来任何突破性的改变。</li><li>- hooks只是提供了一个多选项，一个more API,来优化你的代码， react 官方也没有打算要完全移除类class</li></ul>", 
            "topic": [
                {
                    "tag": "React Native", 
                    "tagLink": "https://api.zhihu.com/topics/20025477"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85475668", 
            "userName": "九思", 
            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
            "upvote": 0, 
            "title": "一个展示文本差异的react组件", 
            "content": "<blockquote>此组件基于一些现有的工具开发</blockquote><h3>react-text-diff</h3><p>可以diff文本，代码等。缺点是无法做滚动现实，适合少量内容的diff。</p><h3>安装</h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">npm</span> <span class=\"nx\">install</span> <span class=\"nx\">react</span><span class=\"o\">-</span><span class=\"nx\">text</span><span class=\"o\">-</span><span class=\"nx\">diff</span>\n</code></pre></div><h3>使用</h3><div class=\"highlight\"><pre><code class=\"language-mathematica\"><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"n\">Component</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"n\">react</span><span class=\"err\">&#39;</span><span class=\"p\">;</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"n\">import</span><span class=\"w\"> </span><span class=\"n\">ReactTextDiff</span><span class=\"w\"> </span><span class=\"n\">from</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"n\">react</span><span class=\"o\">-</span><span class=\"n\">text</span><span class=\"o\">-</span><span class=\"n\">diff</span><span class=\"err\">&#39;</span><span class=\"p\">;</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"n\">class</span><span class=\"w\"> </span><span class=\"n\">Demo</span><span class=\"w\"> </span><span class=\"n\">extends</span><span class=\"w\"> </span><span class=\"n\">Component</span><span class=\"p\">{</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">constructor</span><span class=\"p\">(</span><span class=\"n\">props</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n</span><span class=\"w\">        </span><span class=\"n\">super</span><span class=\"p\">(</span><span class=\"n\">props</span><span class=\"p\">);</span><span class=\"w\">\n</span><span class=\"w\">        </span><span class=\"n\">this</span><span class=\"err\">.</span><span class=\"n\">state</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"n\">oldStr</span><span class=\"err\">:</span><span class=\"w\"> </span><span class=\"n\">oldStr</span><span class=\"p\">,</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"n\">newStr</span><span class=\"err\">:</span><span class=\"w\"> </span><span class=\"n\">newStr</span><span class=\"p\">,</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"n\">context</span><span class=\"err\">:</span><span class=\"w\"> </span><span class=\"mi\">100000</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"o\">//</span><span class=\"w\"> </span><span class=\"n\">max</span><span class=\"w\"> </span><span class=\"mi\">100000</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"n\">outputFormat</span><span class=\"err\">:</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"n\">side</span><span class=\"o\">-</span><span class=\"n\">by</span><span class=\"o\">-</span><span class=\"n\">side</span><span class=\"err\">&#39;</span><span class=\"w\"> </span><span class=\"o\">//</span><span class=\"err\">&#39;</span><span class=\"n\">line</span><span class=\"o\">-</span><span class=\"n\">by</span><span class=\"o\">-</span><span class=\"n\">line</span><span class=\"err\">&#39;</span><span class=\"w\"> </span><span class=\"n\">or</span><span class=\"w\"> </span><span class=\"err\">&#39;</span><span class=\"n\">side</span><span class=\"o\">-</span><span class=\"n\">by</span><span class=\"o\">-</span><span class=\"n\">side</span><span class=\"err\">&#39;</span><span class=\"w\">\n</span><span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"n\">render</span><span class=\"p\">(){</span><span class=\"w\">\n</span><span class=\"w\">        </span><span class=\"n\">return</span><span class=\"w\"> </span><span class=\"p\">(</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"o\">&lt;</span><span class=\"n\">div</span><span class=\"o\">&gt;</span><span class=\"w\">\n</span><span class=\"w\">                </span><span class=\"o\">&lt;</span><span class=\"n\">ReactTextDiff</span><span class=\"w\"> </span><span class=\"n\">oldStr</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">oldStr</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">newStr</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">newStr</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">context</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">context</span><span class=\"p\">}</span><span class=\"w\"> </span><span class=\"n\">outputFormat</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"n\">outputFormat</span><span class=\"p\">}</span><span class=\"o\">/&gt;</span><span class=\"p\">;</span><span class=\"w\">\n</span><span class=\"w\">            </span><span class=\"o\">&lt;/</span><span class=\"n\">div</span><span class=\"o\">&gt;</span><span class=\"w\">\n</span><span class=\"w\">        </span><span class=\"p\">)</span><span class=\"w\">\n</span><span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"p\">}</span><span class=\"w\">\n</span><span class=\"w\">\n</span><span class=\"w\"></span><span class=\"n\">export</span><span class=\"w\"> </span><span class=\"n\">default</span><span class=\"w\"> </span><span class=\"n\">Demo</span><span class=\"p\">;</span></code></pre></div><h3>样例</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2b9e747aabd0b3020d6bee0fb6775346_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2868\" data-rawheight=\"1024\" class=\"origin_image zh-lightbox-thumb\" width=\"2868\" data-original=\"https://pic3.zhimg.com/v2-2b9e747aabd0b3020d6bee0fb6775346_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2868&#39; height=&#39;1024&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2868\" data-rawheight=\"1024\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2868\" data-original=\"https://pic3.zhimg.com/v2-2b9e747aabd0b3020d6bee0fb6775346_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2b9e747aabd0b3020d6bee0fb6775346_b.jpg\"/></figure><h3>github上可以查看demo运行方式：</h3><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/react-text-diff\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-e95ee1809ed8591c398b39fb014cc873_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Stevenzwzhai/react-text-diff</a><h3>react-diff-code</h3><p>可以方便的diff文本、代码，可以滚动显示内容。</p><h3>安装</h3><div class=\"highlight\"><pre><code class=\"language-text\">npm install react-diff-code</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h3>使用</h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"p\">{</span><span class=\"nx\">Component</span><span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;react&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">ReactDiffCode</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;react-diff-code&#39;</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span> <span class=\"nx\">Demo</span> <span class=\"k\">extends</span> <span class=\"nx\">Component</span><span class=\"p\">{</span>\n    <span class=\"nx\">constructor</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">super</span><span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"nx\">render</span><span class=\"p\">(){</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span>\n            <span class=\"o\">&lt;</span><span class=\"nx\">div</span><span class=\"o\">&gt;</span>\n                <span class=\"o\">&lt;</span><span class=\"nx\">ReactDiffCode</span> <span class=\"nx\">oldStr</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">oldStr</span><span class=\"p\">}</span> <span class=\"nx\">newStr</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">newStr</span><span class=\"p\">}</span> <span class=\"nx\">leftTitle</span><span class=\"o\">=</span><span class=\"s2\">&#34;当前数据&#34;</span> <span class=\"nx\">rightTitle</span><span class=\"o\">=</span><span class=\"s2\">&#34;旧数据&#34;</span><span class=\"o\">/&gt;</span>\n            <span class=\"o\">&lt;</span><span class=\"err\">/div&gt;</span>\n        <span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Demo</span><span class=\"p\">;</span>\n</code></pre></div><h3>样例</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f2e5faadac23e164978446178fbf5f8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4186\" data-rawheight=\"1506\" class=\"origin_image zh-lightbox-thumb\" width=\"4186\" data-original=\"https://pic3.zhimg.com/v2-f2e5faadac23e164978446178fbf5f8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;4186&#39; height=&#39;1506&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"4186\" data-rawheight=\"1506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"4186\" data-original=\"https://pic3.zhimg.com/v2-f2e5faadac23e164978446178fbf5f8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f2e5faadac23e164978446178fbf5f8e_b.jpg\"/></figure><h3>github上可以查看demo运行方式</h3><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/react-diff-code\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-e95ee1809ed8591c398b39fb014cc873_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Stevenzwzhai/react-diff-code</a><p>大家可以试用，有问题issue!</p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75586650", 
            "userName": "九思", 
            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
            "upvote": 0, 
            "title": "如何提高你的项目质量", 
            "content": "<blockquote>每个程序员对自己的代码都有天然的自信，尤其是改动一点点东西的时候，极大的情景是：从来不验证就发布了，然后就被bug分分钟打脸！</blockquote><h3>你的代码是不是有bug？</h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2bb9455d4e4cb5348de7d4fbf53e064a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb\" width=\"440\" data-original=\"https://pic3.zhimg.com/v2-2bb9455d4e4cb5348de7d4fbf53e064a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;440&#39; height=&#39;202&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"440\" data-original=\"https://pic3.zhimg.com/v2-2bb9455d4e4cb5348de7d4fbf53e064a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2bb9455d4e4cb5348de7d4fbf53e064a_b.jpg\"/></figure><h3>你可能遇到的场景</h3><ul><li>给某个对象加个字段</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;project&#39;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">=&gt;</span>\n<span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;project&#39;</span>\n    <span class=\"nx\">age</span><span class=\"o\">:</span> <span class=\"mi\">12</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>操作很简单，当然错误也很简单，少了个逗号。那么如何避免呢？</p><p>多数人想到的是我们规定每个对象的字段最后一个都要添加逗号，这样写不会报错，但其实有些不美观，而且无法保证人人都能遵守。</p><ul><li>switch问题</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">switch(type) {\n  case 1: return 1;\n  case 2: return 2;\n}</code></pre></div><p>偶然遇到一个同事项目突然运行失败，然而报错信息提示的是redux处理action的时候action为空，最后查明是因为这位同事在写action的时候使用了switch来返回，然后他没写default，导致switch匹配失败的时候action处理失败。</p><ul><li>jsx一个常见的写法</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">export default class DefaultComponent extends Components {\n    handleClick = (name) =&gt; {\n        // code\n        console.log(name)\n    }\n    render() {\n        return (&lt;div onClick={() =&gt; this.handleClick(name)}&gt;click&lt;/div&gt;);\n    }\n}</code></pre></div><p>当大家在写jsx处理事件要传递参数的时候，一般会选择使用箭头函数（当然之前也可能会使用bind），但其实这种写法会导致组件二次渲染。</p><ul><li>不忍直视的代码</li></ul><ol><li>一行代码写的特别长</li><li>定义了一堆无用的变量</li><li>缩进不一致</li><li>各种空行</li><li>使用来ts却不写接口、变量类型</li><li>...</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51ca53424eb68389638ecfb069fa10c1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"350\" class=\"content_image\" width=\"350\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;350&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"350\" class=\"content_image lazy\" width=\"350\" data-actualsrc=\"https://pic2.zhimg.com/v2-51ca53424eb68389638ecfb069fa10c1_b.jpg\"/></figure><h3>如何改善这种现状</h3><ul><li>整理一套代码规范</li><li>辅以工具检测</li></ul><p>我们首先会想到各种lint工具比如eslint、stylelint、tslint，有这些工具我们可以很方便的管理代码质量。基于完善的文档和各种实践文章，大家可以快速接入到项目中，然而你还是太天真了。</p><p>你能想到一个老项目使用eslint检查后要改多少地方么？基本上是满屏红。此时如果再有人让你接eslint甚至是stylelint、tslint等，或许辞职的心都有了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b21a9462eb4c6f26cbf6413974dd55d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"300\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"300\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic1.zhimg.com/v2-b21a9462eb4c6f26cbf6413974dd55d8_b.jpg\"/></figure><p>对于新项目，从一开始就按照规范来，一切都很美好，对于老项目如何改造呢？</p><h3>渐进式接入lint检查工具</h3><p>鉴于老项目修改点较多，我们采用增量检查的方案，也就是有变动的js文件再去检查，这样对于老项目就可以渐进式的接入。文件改动基本是以下四种，而对于删除的文件是没必要检查的。</p><p>A：新增</p><p>C：拷贝</p><p>M：修改</p><p>D：删除</p><p>对于项目的变动文件，在开发中大体分两种情况：第一是未commit；第二种是已经commit。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-26bf8ad9357bb69d14a9794406e1090f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1074\" data-rawheight=\"958\" class=\"origin_image zh-lightbox-thumb\" width=\"1074\" data-original=\"https://pic4.zhimg.com/v2-26bf8ad9357bb69d14a9794406e1090f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1074&#39; height=&#39;958&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1074\" data-rawheight=\"958\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1074\" data-original=\"https://pic4.zhimg.com/v2-26bf8ad9357bb69d14a9794406e1090f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-26bf8ad9357bb69d14a9794406e1090f_b.jpg\"/></figure><p>对于未commit的文件，只检测暂存区域的文件（git add 之后的文件）。对于已经commit的代码，则通过对比commit记录，获取最后一次提交的文件（对于只有一次提交记录的进行全量检查），大大降低了老项目的接入成本。</p><ul><li>commit检查</li></ul><p>在commit的时候通过设置lint-stage来进行第一次检查</p><div class=\"highlight\"><pre><code class=\"language-text\">&#34;scripts&#34;: {\n  &#34;precommit&#34;: &#34;lint-staged&#34;\n},\n&#34;lint-staged&#34;: {\n  &#34;*.js&#34;: [\n    &#34;eslint&#34;,\n    &#34;git add&#34;\n  ]\n}</code></pre></div><ul><li>构建检查</li></ul><p>这里可以使用个人写的一个检查工具[linters](<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/linter/blob/master/README.md\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/Stevenzwzhai</span><span class=\"invisible\">/linter/blob/master/README.md</span><span class=\"ellipsis\"></span></a>)来作为构建流程，极大的避免某些同学使用`--no-verify`绕过代码检查。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-68c8dfa3e9aa156c4e4415b057eb9eb2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb\" width=\"1490\" data-original=\"https://pic3.zhimg.com/v2-68c8dfa3e9aa156c4e4415b057eb9eb2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1490&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1490\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1490\" data-original=\"https://pic3.zhimg.com/v2-68c8dfa3e9aa156c4e4415b057eb9eb2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-68c8dfa3e9aa156c4e4415b057eb9eb2_b.jpg\"/></figure><p>本地检查+CI构建检查双重保证代码质量。</p><h3>这些为我们带来来什么</h3><ul><li>代码规范统一，便于多人协作开发、项目交接，提升项目的可维护性</li><li>减少一些不必要的代码错误，避免低级错误导致的现网bug</li><li>高质量的代码可以减小读代码的难度，提升我们的开发效率</li></ul><p>作为一名合格的程序员，我们有必要规范自己的代码，同样有义务带给自己的团队！</p><p>ps:对于本人写的代码检查辅助工具[linters](<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/linter/blob/master/README.md\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/Stevenzwzhai</span><span class=\"invisible\">/linter/blob/master/README.md</span><span class=\"ellipsis\"></span></a>)，目的不是为了造轮子，只是更加方便大家接入，有不足之处大家可以提issue！</p>", 
            "topic": [
                {
                    "tag": "代码质量", 
                    "tagLink": "https://api.zhihu.com/topics/19585332"
                }, 
                {
                    "tag": "ESLint", 
                    "tagLink": "https://api.zhihu.com/topics/20035615"
                }, 
                {
                    "tag": "TypeScript", 
                    "tagLink": "https://api.zhihu.com/topics/19766226"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67322195", 
            "userName": "九思", 
            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
            "upvote": 5, 
            "title": "你需要掌握的http知识", 
            "content": "<h3>零、为什么要学</h3><p>回答这个问题很简单，因为面试官会问，而且还问的不少！相信经历过面试的同学基本都被问过http缓存，并由此展开一些列问答。当然学习好http还可以 帮你快速排查一些问题，比如安全问题。本文将罗列一系列知识点，尽量覆盖各个方面，对每个点不会详细讲解，但是会提供一些优秀的文章链接供大家深入学习。此外大家可以查看[http技能图谱](<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/study-source/blob/master/skill-map/http%25E5%259B%25BE%25E8%25B0%25B1.png\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/Stevenzwzhai</span><span class=\"invisible\">/study-source/blob/master/skill-map/http%E5%9B%BE%E8%B0%B1.png</span><span class=\"ellipsis\"></span></a> )来更直观的查看相关知识点。</p><h3>一、基础知识</h3><p>与http相关的TCP、IP、DNS、url、uri</p><h3>1.IP</h3><p>IP地址是我们很熟悉的东西，最常见的的就是127.0.0.1。我们都知道连接网络后，每台机器都会有不同的IP地址，也有自己的mac地址（这个地址是硬件写死的），那么我们传输信息的时候只要知道对方的IP地址，然后再和mac地址配对就基本可以确定接受信息方；而传输过程中我们肯定是希望信息高效传递过去，那么传输方式以及传输路径就要找到最好的方式。IP协议就是做这些事情的，IP是指IP协议而不是我们常常说的IP地址，它位于网络层，所要做的事情主要是以下三点：</p><p>    1）寻址和路由；</p><p>    2）传递服务；</p><p>    3）数据包的分片和重组；</p><h3>2.TCP</h3><p>首先按照分层，TCP位于传输层，提供字节流服务。那么什么是字节流呢？网络传输数据就像汽车运输货物一样，比如我们运输的是信号塔，这么大不可能一下子运到目的地，这时候就需要一部分一部分运过去，再组装起来。而TCP确保数据能到达目的地。运输货物我们打个就可以通知是否送到了，TCP要用什么方式呢？看图说话</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c38b4ac5cdb8bb6b61064f2ac42d64a4_b.jpg\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-c38b4ac5cdb8bb6b61064f2ac42d64a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;411&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"411\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-c38b4ac5cdb8bb6b61064f2ac42d64a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c38b4ac5cdb8bb6b61064f2ac42d64a4_b.jpg\"/><figcaption>tcp三次握手</figcaption></figure><p>还有四次挥手</p><h3>3.DNS</h3><p>我们要访问一台服务器的东西，需要知道它的地址，IP地址可以作为一个标识，但是四个数字是很不好记的，因此诞生了域名这个东西，<a href=\"https://link.zhihu.com/?target=http%3A//xn--www-eo8er22f.qq.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">比如www.qq.com</a>，我们可以访问到腾讯主页，但这个是怎么找到对应到腾讯的服务器呢？DNS服务就是干这个的，它处于应用层，当然它也可以通过IP来查找对应的域名。</p><h3>4.URL和URI</h3><p>URL: 统一资源定位符</p><p>URI: 统计资源标识符</p><p>URI用来标识某个互联网资源，而URL是资源的位置，所以URL是URI的子集。这里知道简单区别即可。</p><h3>二、http报文</h3><p>http报文分为请求报文和响应报文，HTTP请求报文：一个HTTP请求报文由请求行、请求头部、空行和请求数据4部分组成。HTTP响应报文：由三部分组成：状态行、消息报头、响应正文。综合两种报文，我们把报文分为一下结构</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f03bbe63342ed54bd38be50d58b35684_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f03bbe63342ed54bd38be50d58b35684_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-f03bbe63342ed54bd38be50d58b35684_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f03bbe63342ed54bd38be50d58b35684_b.jpg\"/></figure><h3>1.请求行</h3><p>主要呈现请求的基本信息，包括请求的目标，协议版本，以及请求方法。目标就是一个url，比如我们要请求的网址或者跟后端协定好的接口地址。协议版本指http1.0、http1.1等。请求方法最常见的GET、POST，在http1.1总共有八种，这里不再一一阐述，最常见的GET、POST区别可以参考 [这篇文章](<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI3NzIzMzg3Mw%3D%3D%26mid%3D100000054%26idx%3D1%26sn%3D71f6c214f3833d9ca20b9f7dcd9d33e4%23rd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">mp.weixin.qq.com/s?</span><span class=\"invisible\">__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd</span><span class=\"ellipsis\"></span></a>)</p><h3>2.状态行</h3><p>状态行就主要表示请求结果了，这里主要涉及状态码后面第三部分会说到</p><h3>3.首部字段</h3><p>这里首部字段就有通用首部字段、请求首部字段以及响应首部字段三种。</p><p>常用的首部字段比如Date(日期)，Pragma、cache-control(缓存相关)，Upgrade(协议升级，比如使用websocket)等。</p><p>请求首部字段比如Accept-*系列(表示优先级的，Charset字符集，Encoding编码，Language语言等)，缓存类的(Etag和modified相关)，referer(请求方)等。</p><p>相应首部字段比如缓存相关(Etag和modified相关)，服务器信息(Server)，重定向(Location)等。</p><h3>4.其他</h3><p>http中未定义的一些字段，比如cookie</p><h3>5.报文主体</h3><p>请求报文主要是请求信息，query、body参数等。响应报文主要是服务器返回的信息。</p><h3>三、状态码</h3><h3>1xx: </h3><p>信息类型，表示在处理了。</p><h3>2xx：</h3><p>成功类型。比如常见的200，服务器处理成功但是不返回实体信息的204等。</p><h3>3xx：</h3><p>需要附加操作的，比如重定向（301永久重定向，302临时重定向）和使用缓存（304，这里结合几个首部字段使用，具体可以参考[http缓存](<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/2d5bf49fa142\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http缓存</a>)）</p><h3>4xx：</h3><p>客户端错误，比如参数错误(400)，认证失败(401)，没有访问权限(403)，资源不存在(404)等</p><h3>5xx：</h3><p>服务器错误，比如服务端执行错误或者故障(500)，服务器暂时无法处理(503)，超时(504)，协议有问题(505)等</p><h3>三、身份认证</h3><p>身份认证主要有以下五种方式</p><p>1.承载用户身份信息的HTTP首部（比如referer）</p><p>2.客户端IP地址跟踪，通过用户的IP地址对其进行识别</p><p>3.用户登录，用认证方式来识别用户(这里需要了解token机制)</p><p>4.胖URL，一种在URL中嵌入识别信息的技术</p><p>5.cookie，一种功能强大且高效的持久身份识别技术</p><p>[详细了解](<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wyq_tc25/article/details/51794262\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/wyq_tc25/</span><span class=\"invisible\">article/details/51794262</span><span class=\"ellipsis\"></span></a>)</p><h3>四、安全</h3><h3>1.请求头中的安全机制</h3><p>CSP策略</p><p>可以采用请求头设置方式</p><p>Content-Security-Policy: policy</p><p>Content-Security-Policy: default-src &#39;self&#39;（自定义）</p><p>当然也可以在meta标签中设置，比如&lt;meta http-equiv=&#34;Content-Security-Policy&#34; content=&#34;default-src &#39;self&#39;; img-src https://*; child-src &#39;none&#39;;&#34;&gt;（来自mdn）。</p><p>X-Frame-Options</p><p>防止点击劫持</p><p>X-XSS-Protection</p><p>控制浏览器XSS防止的开关</p><h3>2.cookie安全</h3><p>比如cookie加密，设置HttpOnly和secure</p><h3>五、其他</h3><p>https:四次握手，ssl/tls协议，加密等。</p><p>http2:优势，多路复用、头部压缩、流的优先级等。[详细](<a href=\"https://zhuanlan.zhihu.com/p/26559480\" class=\"internal\">又拍云：一文读懂 HTTP/2 特性</a>)</p><p>http3: 可以了解下。[详细](<a href=\"https://link.zhihu.com/?target=https%3A//www.infoq.cn/article/IgME_4ebP3d46m3tHbaT\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一文看完HTTP3的演化历程 - InfoQ</a>)</p><h3>六、总结</h3><p>这里只针对http我们需要掌握的基本信息做一个大概的总结，具体的某方面知识建议查看书籍去了解，虽然我们在编写代码（写bug中）过程中几乎不会用到http，但是我们的项目运行却是离不开它，因此掌握基本的http对性能优化，安全等都是很有帮助的。有书写错误或者解释错误的欢迎指出！</p><p></p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57041230", 
            "userName": "九思", 
            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
            "upvote": 1, 
            "title": "监控页面的资源请求", 
            "content": "<h2>前言</h2><p>加载一个web页面，可能会请求各种静态资源，比如图片，js，css等，但是很有可能加载了一些意料之外的东西，比如一段恶意脚本，或者一个广告等等。尤其是你的页面依赖第三方的东西的时候变得更加不可控。</p><h2>常见的意外</h2><ul><li>看个小说吧<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-36eacc322e84b626b147324b2b7ac4d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"412\" class=\"content_image\" width=\"240\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;240&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"412\" class=\"content_image lazy\" width=\"240\" data-actualsrc=\"https://pic2.zhimg.com/v2-36eacc322e84b626b147324b2b7ac4d5_b.jpg\"/></figure><p>卧槽，这咋还有棋牌，很多时候就一不小心点进去了，而且还很可能自动开始下载。</p><ul><li>刷个微博</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-520d4d998acb309ac6524b1cde468555_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"386\" class=\"content_image\" width=\"240\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;240&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"386\" class=\"content_image lazy\" width=\"240\" data-actualsrc=\"https://pic2.zhimg.com/v2-520d4d998acb309ac6524b1cde468555_b.jpg\"/></figure><p>诶，还有诱人小广告（你动心了吗）。</p><ul><li>随便看点啥吧</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1db695c9756cc0fc7ce1df9cbff09763_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-1db695c9756cc0fc7ce1df9cbff09763_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-1db695c9756cc0fc7ce1df9cbff09763_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1db695c9756cc0fc7ce1df9cbff09763_b.jpg\"/></figure><p>还是悄悄地出现了，并且引起了我的注意。</p><blockquote>广告有些是网站自己有广告位的，这些是正常的，但是总有些是意外的产出，比如运营商劫持，使用https势在必行，它可以帮我们解决掉大多数的问题。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2>https全搞定？</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5f031bd62879e0e1fff05b18b3c54cbe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"242\" class=\"content_image\" width=\"240\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;240&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"242\" class=\"content_image lazy\" width=\"240\" data-actualsrc=\"https://pic3.zhimg.com/v2-5f031bd62879e0e1fff05b18b3c54cbe_b.jpg\"/></figure><p>前一段时间event-stream 事件引起了广大猿人的注意，event-stream被很多的前端流行框架和库使用，每月有几千万的下载量。不怕贼偷就怕贼惦记啊！</p><p>最简单写一个：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0aba64fd1c68057ba70800203b74ada7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"115\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic4.zhimg.com/v2-0aba64fd1c68057ba70800203b74ada7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;115&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"115\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic4.zhimg.com/v2-0aba64fd1c68057ba70800203b74ada7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0aba64fd1c68057ba70800203b74ada7_b.jpg\"/></figure><blockquote>对于一些“意外”的资源请求多数都是用户反馈我们才得知，但是具体情况一概不知。如何监听甚至是解决呢？</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2>监控dom的一举一动</h2><p>MutationObserver这个东西大家或许听过，它提供了监控dom的能力，举个例子：</p><ul><li>首先我们把监控代码写好，当页面有增加script 标签，并且有src属性的时候打log。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d470e5aae46a7e3ee3b8d6255043eb6a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-d470e5aae46a7e3ee3b8d6255043eb6a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-d470e5aae46a7e3ee3b8d6255043eb6a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d470e5aae46a7e3ee3b8d6255043eb6a_b.jpg\"/></figure><ul><li>打开浏览器运行一下</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d1e986507c1c6871a041a1c84db6a204_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-d1e986507c1c6871a041a1c84db6a204_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic1.zhimg.com/v2-d1e986507c1c6871a041a1c84db6a204_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d1e986507c1c6871a041a1c84db6a204_b.jpg\"/></figure><p>可以看到控制台输出了我们想要的东西，此处我们就可以做一些常规上报了。</p><h2>除此之外我们还可以做一些其他东西，比如：</h2><ol><li>异常的a标签链接</li></ol><p>当我们监测到异常的a标签可以及时删除掉。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-def4473db33523862348d2f24cd5ff16_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-def4473db33523862348d2f24cd5ff16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-def4473db33523862348d2f24cd5ff16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-def4473db33523862348d2f24cd5ff16_b.jpg\"/></figure><p>2. 异常的iframe插入 </p><p>3. 元素显示内容变化记录</p><blockquote>注意：这里MutationObserver只兼容到IE11，对于低版本的可以使用Mutation events，但是这个事件性能不是很好，这里就不在详细介绍。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b3bd871ab70ce285c01931cc4926dd0b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"229\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-b3bd871ab70ce285c01931cc4926dd0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"229\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-b3bd871ab70ce285c01931cc4926dd0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b3bd871ab70ce285c01931cc4926dd0b_b.jpg\"/></figure><p>虽然我们监控到了有异常资源，但是依然发出了请求，还有什么办法吗？</p><h2>防守大闸-CSP</h2><p>CSP策略，全称[Content Security Policy](<a href=\"https://link.zhihu.com/?target=https%3A//wiki.mozilla.org/Security/CSP/Specification\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Security/CSP/Specification - MozillaWiki</a>)，很多人把它喻为XSS攻击的终结者，因为这种策略不再像传统只靠各种正则和特征匹配来识别跨站攻击Payload，而是直接从协议层把一些存在安全隐患的用法默认干掉，把同源同域更发挥到了极致。</p><p>比如你的站点js文件请求域名都是<a href=\"https://link.zhihu.com/?target=http%3A//xn--jsa-vu9dxsr8tu7gwrdl52bdpb574a5gbo27agxtk1omt8dz3r.cdn.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">a.cdn.cn</a>，那么添加csp策略之后，所以其他域名的js请求全都会被拦截。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-330e8b87e22cf88d1627e632fdebf3e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"498\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-330e8b87e22cf88d1627e632fdebf3e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;498&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"498\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-330e8b87e22cf88d1627e632fdebf3e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-330e8b87e22cf88d1627e632fdebf3e4_b.jpg\"/></figure><p> 直接拦截掉，异常js请求</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3d23d6bade39c6376759fe19f15f761b_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"33\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-3d23d6bade39c6376759fe19f15f761b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;33&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"33\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-3d23d6bade39c6376759fe19f15f761b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3d23d6bade39c6376759fe19f15f761b_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-192d011f4238db46ded887bb0b620ff4_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-192d011f4238db46ded887bb0b620ff4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-192d011f4238db46ded887bb0b620ff4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-192d011f4238db46ded887bb0b620ff4_b.png\"/></figure><p>添加方式：</p><p>1. meta标签</p><p>2. 在返回头信息中添加content-security-policy字段</p><p>第一种方式我写了个简单的webpack插件，[CSPPlugin](<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Stevenzwzhai/CSPPlugin\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Stevenzwzhai/CSPPlugin</a>)，可以拿来直接使用。目前来说貌似只有知乎和github使用了这种策略，因为它实在是太严格了。</p><h2>小结</h2><p>网页千万个，安全第一位。</p><p>平时不注意，后果很严重。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c57a78b90010ead54959c2ba35e0d662_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"244\" class=\"content_image\" width=\"240\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;240&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"240\" data-rawheight=\"244\" class=\"content_image lazy\" width=\"240\" data-actualsrc=\"https://pic3.zhimg.com/v2-c57a78b90010ead54959c2ba35e0d662_b.jpg\"/></figure><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "网络安全", 
                    "tagLink": "https://api.zhihu.com/topics/19554927"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55938308", 
            "userName": "九思", 
            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
            "upvote": 0, 
            "title": "前端工程化，你做了多少？", 
            "content": "<blockquote>前端工程化是近几年比较热门的一个东西，大大小小的团队也在朝着这一方向发展，那么你的团队做了多少呢？</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><h2>前端发展简史</h2><ul><li>石期时代</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>最初的前端页面都是一些静态页面，人们看到的网页就像报纸一样。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>青铜时代</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>后端为主的时代，往往页面都是后端利用一些模版引擎来完成页面；对于有大量页面的项目，前端在写页面需要构造一定的环境，比如jsp，php等。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>铁器时代</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>随着ajax的诞生，浏览器可以主动从服务端拉取数据，前后端分离的时代到来，SPA应运而生，前端可以处理一些复杂的交互、业务逻辑。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>工业时代</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>随着前端扮演的角色越来越重要，各种SPA框架层出不穷；nodejs的活跃也为前端带来了更有利开发方式以及更多的发展方向。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>前端工程化需要做哪些？</h2><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>代码管理工具</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>目前来看大多数都是git/svn，当然还是推荐使用git，好处自然不用说。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>项目创建、开发、发布</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>项目创建包含了技术选型，目录结构设计，模块化等。开发中可能会遇到页面适配、样式预处理以及开发便捷性。发布涉及到了代码打包、发布到服务器，你可能还会做一些打包优化等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>前端自动化工具</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>对于前端工具这个就很繁杂了，比如图片压缩、开启本地服务代理等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>当然前端工程化远不止于此，还有单元测试、规范制定等，本文主要梳理开发中最常见的几个环节，看看大家目前的状态是什么样子的？有哪些可以做改进。毕竟茹毛饮血不是我们想要的！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>在前端开发中“你”是怎么做的？</h2><ul><li>项目创建</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>  开发一个项目，首先要创建项目，大概收集了几种方式</p><p>  1. copy后修改一下。</p><p>  2. git clone -&gt; npm install -&gt; npm start（克隆自己的空项目开发）。</p><p>  3. 使用框架官方脚手架（vue-cli， Angular-cli，create-react-app），然后再改改。</p><p>  4. 有自己的脚手架构建器，统一管理（一般是有大牛发力）。</p><p>对于前端项目，我们需要做的有很多，比如要适配各种移动端机型，要兼容低版本，想用sass/less，还想用es6甚至是ts，对自己严格要求加个eslint等等，如果你还处于1，2，3情况，那么这些东西每次开发新项目都要重新来一遍，如果你很熟练，可能个把小时就弄好了，否则可能创建项目就要半天。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>项目构建</li></ul><p>  项目构建目前来说基本都是使用webpack，但是其复杂的配置、版本迭代速度让很多开发望而生畏，甚至诞生处理webpack配置工程师（有这个的真牛批😂）。</p><p>但是我们依然需要开发构建和打包构建能提供一些能里，比如开发热更新，各种预处理，结合性能优化所需要的一些配置（雪碧图，代码分割，压缩，cdn），多页配置，当项目很大的时候我们还需要优化构建速度。突然发现开发完业务功能还有一堆的事情要做，如果没有相关经验积累真是头大。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>前端工具</li></ul><p>nodejs的盛行给前端开发带来了更多的便捷，各种npm包，node工具。对于工具这一块TJ大神写的 [commander.js](<a href=\"https://link.zhihu.com/?target=https%3A//github.com/tj/commander.js\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/tj/commander</span><span class=\"invisible\">.js</span><span class=\"ellipsis\"></span></a>)让我们更加便捷的开发命令式工具，常见的脚手架初始化、代码转化等，真的算是一个神器了。</p><p>但是，不得不说，开发还是有一定的技术要求的，注册命令就要写一堆东西，还有参数解析；而且如果我们有多个工具，直接这么来写是很不方便管理的，比如我想查看有哪些是我们自己开发的命令。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>适合自己的工作流</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>上面仅仅是介绍了关于项目开发中的问题，随着前端重要性越来越大，工作量也是与日俱增，而前端工程化正是帮助我们优化流程、减少工作量，因此拥有自己的前端工作流势在必行。</p><p>讲了这么多，给大家推荐一个不错的前端工作流工具[feflow](<a href=\"https://link.zhihu.com/?target=https%3A//www.feflowjs.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://www.feflowjs.org</a>)，利用这个工具，从创建项目到业务开发，再到打包发布，涵盖了整个完整的工作流程。</p><ul><li>脚手架和构建器</li></ul><p>官方有给出react+redux的脚手架以及基于webpack4的构建器，而且还可以根据官方文档自定义自己的脚手架和构建器，对于不同的框架和业务都可以完美的接入。</p><ul><li>插件体系</li></ul><p>此外feflow还提供了丰富的插件体系，你可以自定义各种插件，通过feflow 命令来调用：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">feflow</span><span class=\"p\">.</span><span class=\"nx\">cmd</span><span class=\"p\">.</span><span class=\"nx\">register</span><span class=\"p\">(</span><span class=\"s1\">&#39;add&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;加法运算器&#39;</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">add</span><span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">_</span><span class=\"p\">);</span>\n<span class=\"p\">});</span>\n<span class=\"kd\">function</span> <span class=\"nx\">add</span> <span class=\"p\">(</span><span class=\"nx\">args</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">sum</span> <span class=\"o\">=</span> <span class=\"nx\">args</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">((</span><span class=\"nx\">sum</span><span class=\"p\">,</span> <span class=\"nx\">item</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nx\">sum</span> <span class=\"o\">+</span> <span class=\"nx\">item</span>\n    <span class=\"p\">},</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">sum</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"nx\">sum</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"c1\"># 调用</span>\nfeflow add <span class=\"m\">1</span> <span class=\"m\">2</span> <span class=\"m\">3</span>\n<span class=\"c1\"># 输出</span>\n <span class=\"m\">6</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是很简单，并且命令都是可控的（feflow 控制下）。</p><h2>结语</h2><p>不管用什么工具方法，目的都是为了优化工作流程，让我们轻松高效的完成工作。最后附上feflow官网<a href=\"https://link.zhihu.com/?target=http%3A//www.feflowjs.org/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">feflowjs.org/</span><span class=\"invisible\"></span></a>。</p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "开发工具", 
                    "tagLink": "https://api.zhihu.com/topics/19564417"
                }
            ], 
            "comments": [
                {
                    "userName": "烂笔头", 
                    "userLink": "https://www.zhihu.com/people/9b493d29c70583b3835c5d8d50f3c2ac", 
                    "content": "<p>md没转换过来 看的有点难受</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "九思", 
                            "userLink": "https://www.zhihu.com/people/0f3bb3d784fb3120607d7a18967784d4", 
                            "content": "<p>哈哈，已经转了哈</p>", 
                            "likes": 1, 
                            "replyToAuthor": "烂笔头"
                        }
                    ]
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1073579069320384512"
}
