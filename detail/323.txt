{
    "title": "LeetCode刷题篇", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/wang-xiao-han-36-65", 
        "https://www.zhihu.com/people/ling-du-88-94", 
        "https://www.zhihu.com/people/xiao-min-72-71", 
        "https://www.zhihu.com/people/wang-zhen-78", 
        "https://www.zhihu.com/people/li-man-11-15", 
        "https://www.zhihu.com/people/gui-shao-pan", 
        "https://www.zhihu.com/people/fantuan123", 
        "https://www.zhihu.com/people/yu-nuo-41-57", 
        "https://www.zhihu.com/people/ang-gao", 
        "https://www.zhihu.com/people/12306-10", 
        "https://www.zhihu.com/people/jie-ge-zhu-14", 
        "https://www.zhihu.com/people/da-yan-jing-xiao-yan-jing-94", 
        "https://www.zhihu.com/people/helloworld-ma", 
        "https://www.zhihu.com/people/xiao-jia-17-63", 
        "https://www.zhihu.com/people/lu-guan-43", 
        "https://www.zhihu.com/people/ling-yidao", 
        "https://www.zhihu.com/people/ma-le-28-27", 
        "https://www.zhihu.com/people/chen-xiao-shuai-bu-shuai", 
        "https://www.zhihu.com/people/bai-san-88-21", 
        "https://www.zhihu.com/people/spx-26", 
        "https://www.zhihu.com/people/mujin-50", 
        "https://www.zhihu.com/people/chen-qi-14-72", 
        "https://www.zhihu.com/people/li-joye", 
        "https://www.zhihu.com/people/curry-27", 
        "https://www.zhihu.com/people/wang-ze-an-23", 
        "https://www.zhihu.com/people/shen-ye-xing-nan", 
        "https://www.zhihu.com/people/long-jian-1", 
        "https://www.zhihu.com/people/zhong-lin-sun", 
        "https://www.zhihu.com/people/xy-li-2", 
        "https://www.zhihu.com/people/yi-ming-17-78", 
        "https://www.zhihu.com/people/song-xiang-hao-17", 
        "https://www.zhihu.com/people/15835036272", 
        "https://www.zhihu.com/people/yang-xiao-yuan-25-46", 
        "https://www.zhihu.com/people/Micro-Kun", 
        "https://www.zhihu.com/people/wang-rui-36-5-90", 
        "https://www.zhihu.com/people/raphael-36-87", 
        "https://www.zhihu.com/people/e-yun-30", 
        "https://www.zhihu.com/people/zhan-zhan-de-melody", 
        "https://www.zhihu.com/people/redsold", 
        "https://www.zhihu.com/people/zhi-wu-zhi-8", 
        "https://www.zhihu.com/people/h-h-39-60", 
        "https://www.zhihu.com/people/zhou-sheng-long-55", 
        "https://www.zhihu.com/people/rock-97-71", 
        "https://www.zhihu.com/people/ceng-jian-lin-63", 
        "https://www.zhihu.com/people/li-jing-7-8", 
        "https://www.zhihu.com/people/guo-kai-27-62", 
        "https://www.zhihu.com/people/hzgzh", 
        "https://www.zhihu.com/people/da-bing-rui-en-71", 
        "https://www.zhihu.com/people/qilewuqiongdexmg", 
        "https://www.zhihu.com/people/url_", 
        "https://www.zhihu.com/people/san-mu-jun-50", 
        "https://www.zhihu.com/people/liao-chen-60-59", 
        "https://www.zhihu.com/people/guan-xu-yuan-36", 
        "https://www.zhihu.com/people/wang-kui-10", 
        "https://www.zhihu.com/people/ha-ha-mo-mo-32", 
        "https://www.zhihu.com/people/easycn", 
        "https://www.zhihu.com/people/zai-duo-yidian", 
        "https://www.zhihu.com/people/denom", 
        "https://www.zhihu.com/people/fang-jie-78-51", 
        "https://www.zhihu.com/people/ben-xiao-hai-80-92", 
        "https://www.zhihu.com/people/yu-hai-long-22", 
        "https://www.zhihu.com/people/0x8badf00d", 
        "https://www.zhihu.com/people/tian-chen-xd", 
        "https://www.zhihu.com/people/mi-gao-86-24", 
        "https://www.zhihu.com/people/liu-yi-25-9", 
        "https://www.zhihu.com/people/bai-ren-19-65", 
        "https://www.zhihu.com/people/bu-yu-53", 
        "https://www.zhihu.com/people/lu-zhang-hao-67", 
        "https://www.zhihu.com/people/he-jia-wei-19", 
        "https://www.zhihu.com/people/yi-er-san-84-97", 
        "https://www.zhihu.com/people/nian-nian-yy", 
        "https://www.zhihu.com/people/huang-li-an", 
        "https://www.zhihu.com/people/jiang-qing-86", 
        "https://www.zhihu.com/people/bao-da-xiao-hua-fu", 
        "https://www.zhihu.com/people/wang-li-fu-65", 
        "https://www.zhihu.com/people/cao-pei-en", 
        "https://www.zhihu.com/people/who-lee", 
        "https://www.zhihu.com/people/zang-ying-ying-60", 
        "https://www.zhihu.com/people/zhi-zhang-de-gong-ke-nan", 
        "https://www.zhihu.com/people/xu-lei-hui-shou-ni-xin-ma", 
        "https://www.zhihu.com/people/liu-hai-67-13", 
        "https://www.zhihu.com/people/du-du-47-61", 
        "https://www.zhihu.com/people/yu-xia-99-37", 
        "https://www.zhihu.com/people/xiong-mo-63", 
        "https://www.zhihu.com/people/zhao-qing-5-36", 
        "https://www.zhihu.com/people/jun-liu-11", 
        "https://www.zhihu.com/people/ceng-yu-95-5", 
        "https://www.zhihu.com/people/lrjxaint", 
        "https://www.zhihu.com/people/en-yang-89", 
        "https://www.zhihu.com/people/zheng-chi-yin", 
        "https://www.zhihu.com/people/wang-jian-64-41-76", 
        "https://www.zhihu.com/people/wei-sui-chi-han-pro", 
        "https://www.zhihu.com/people/tao-qi-ge-da-66", 
        "https://www.zhihu.com/people/tai-bai-80", 
        "https://www.zhihu.com/people/tangquanliang", 
        "https://www.zhihu.com/people/kang-kang-34-74-18", 
        "https://www.zhihu.com/people/liu-qi-91-99", 
        "https://www.zhihu.com/people/living-45-55", 
        "https://www.zhihu.com/people/mail-hotstuff", 
        "https://www.zhihu.com/people/hahatwz", 
        "https://www.zhihu.com/people/hongyu-liu", 
        "https://www.zhihu.com/people/mu-feng-ru-yu", 
        "https://www.zhihu.com/people/uglymonkey", 
        "https://www.zhihu.com/people/lixaing", 
        "https://www.zhihu.com/people/lin-jian-ming-19", 
        "https://www.zhihu.com/people/xu-liu-kai-7", 
        "https://www.zhihu.com/people/wu-xd", 
        "https://www.zhihu.com/people/wangliangsz", 
        "https://www.zhihu.com/people/zhou-fei-31-82", 
        "https://www.zhihu.com/people/aaron-yu-79-88", 
        "https://www.zhihu.com/people/wo-lai-la-56", 
        "https://www.zhihu.com/people/gu-shu-hao-40", 
        "https://www.zhihu.com/people/yyy-6", 
        "https://www.zhihu.com/people/SampanLee", 
        "https://www.zhihu.com/people/rey-32-94", 
        "https://www.zhihu.com/people/wang-liao-52", 
        "https://www.zhihu.com/people/tang-shi-jie-31", 
        "https://www.zhihu.com/people/dan-zhi-chang-lao"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/90149911", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "第六十天——第六十题（缺失数字）", 
            "content": "<p>昨天好好翻译了一下六级的问题，翻译虽然提升空间大，但真正能提升多少呢，比得上听力最后是个一个选择14.2分吗，所以翻译要练习，听力部分也不能放弃，还有一个月多一点的时间，一切还来得及。</p><h2><b>第六十天——第六十题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/missing-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">缺失数字</a><b>）</b></h2><p>给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [3,0,1]\n输出: 2</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [9,6,4,2,3,5,7,0,1]\n输出: 8</code></pre></div><h2>python解答之一：</h2><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def missingNumber(self, nums):\n        nums.sort()\n        if nums[-1] != len(nums):\n            return len(nums)\n\n        elif nums[0] != 0:\n            return 0\n        for i in range(1, len(nums)):\n            expected_num = nums[i-1] + 1\n            if nums[i] != expected_num:\n                return expected_num</code></pre></div><p><b>代码解释：</b></p><p>1.先将列表排序，再判断最后一位数和第一位数是否存在，存在正常，不存在返回不存在的值</p><p>2.判断列表中前一个数与后一个数相差是否为1，相差大于1，则表明两数之间有缺失，返回缺失值。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "听力多看一些技巧吧，感觉真正听懂还是挺难的，然后就是阅读作文翻译（分先后顺序）", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>阅读问题不大，作为翻译不要写错位置，字迹不要太乱，作文不要跑题分数不会拉分，六级听力真正能听懂确实很难，主要是能不能抓到关键点，对自己的要求就是不要让听力拉分就行</p><p></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "路在脚下", 
                            "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                            "content": "你是刷分还是", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }, 
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>还没过...命运多舛</p><p></p>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89995484", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "第五十九天——第五十九题（丑数）", 
            "content": "<p>说说我六级的血泪史吧，最近又双叒在准备六级，说来惭愧啊，考研英语79分，然而考上研后考了两次六级了次次扎心。最薄弱的是听力，不过个人感觉听力收效很小，所以这次重点放在翻译和作文上，阅读没有太大问题，最近一直在写翻译的同时练一练衡水体，希望书写上先开门红吧。</p><h2><b>第五十九天——第五十九题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/ugly-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">丑数</a><b>）</b></h2><p><b>看题目！</b></p><p>编写一个程序判断给定的数是否为丑数。</p><p>丑数就是只包含质因数 2, 3, 5 的正整数。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 6\n输出: true\n解释: 6 = 2 × 3</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 8\n输出: true\n解释: 8 = 2 × 2 × 2</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 14\n输出: false \n解释: 14 不是丑数，因为它包含了另外一个质因数 7。</code></pre></div><h2>python解答之一：</h2><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isUgly(self, num: int) -&gt; bool:\n        if num &lt;= 0:  ## 如果num非正，就不是丑数\n            return False\n        while True:\n            last = num\n            if not num % 2:  ## 如果2整除num，就除以2\n                num &gt;&gt;= 1\n            if not num % 3:  ## 如果3整除num，就除以3\n                num //= 3\n            if not num % 5:  ## 如果5整除num，就除以5\n                num //= 5\n            if num == 1:  ## 如果若干次操作后，num变成1，说明num的因数只有2、3、5，是丑数\n                return True\n            if last == num:  ## 如果1轮操作后，num没变，说明num不是丑数\n                return False</code></pre></div><p>参考题解中<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/u/erik_chen/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Erik_Chen</a>网友的解答，解释的很清楚啦~漂亮！</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89581199", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "第五十八天——第五十八题（各位相加）", 
            "content": "<p>11月1号，2019年的最后来个月正式开始，今天对我影响最大的一件事就是，流量不限速了，哈哈。</p><h2><b>第五十八天——第五十八题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/add-digits/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 各位相加</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。</p><p>示例:</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 38\n输出: 2 \n解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">addDigits</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">num</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">int</span><span class=\"p\">:</span>\n        <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"mi\">1</span><span class=\"p\">):</span>\n            <span class=\"n\">tmp</span><span class=\"o\">=</span><span class=\"mi\">0</span>\n            <span class=\"k\">for</span> <span class=\"n\">a</span> <span class=\"ow\">in</span> <span class=\"n\">num</span><span class=\"p\">:</span>\n                <span class=\"n\">tmp</span><span class=\"o\">+=</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">)</span>\n            <span class=\"n\">tmp</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">)</span>\n            <span class=\"n\">num</span><span class=\"o\">=</span><span class=\"n\">tmp</span>\n        <span class=\"k\">return</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span></code></pre></div><p><b>代码解释：</b></p><p>1.将数字转为字符串，当字符串长度大于1时即可进行循环。</p><p>2.在循环中，定义一个临时变量，遍历这个字符串，tmp则成为它每个数位上数字相加的和</p><p>3.将tmp这个数字转为字符串后再赋值给num,循环判断num的长度是否大于1，直到num长度小于1结束循环，返回结果。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89409602", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "第五十七天——第五十七题（二叉树的所有路径）", 
            "content": "<p>十月的最后一天，明天进入2019年的最后两个月，2020年马上到来，我们将引来全面建成小康社会的历史性的一年。</p><h2><b>第五十七天——第五十七题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-paths/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二叉树的所有路径</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: \n   1 \n /   \\\n2     3\n \\\n  5</code></pre></div><p>输出: [&#34;1-&gt;2-&gt;5&#34;, &#34;1-&gt;3&#34;]</p><p>python解答之一：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def binaryTreePaths(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: List[str]\n        &#34;&#34;&#34;\n        def construct_paths(root, path):\n            if root:\n                path += str(root.val)\n                if not root.left and not root.right:  # 当前节点是叶子节点\n                    paths.append(path)  # 把路径加入到答案中\n                else:\n                    path += &#39;-&gt;&#39;  # 当前节点不是叶子节点，继续递归遍历\n                    construct_paths(root.left, path)\n                    construct_paths(root.right, path)\n\n        paths = []\n        construct_paths(root, &#39;&#39;)\n        return paths</code></pre></div><p><b>代码解释：</b></p><p>这个解答是官方给出的python版用递归的方式解答，做这个题很自然的可以想到是递归解答更好一点。</p><p>1.在函数里再定义一个函数:construct_paths()</p><p>2.判断如果root不为空root值加到path中</p><p>3.判断root下的左右节点是否存在，如果不存在，则当前节点为叶子节点，把路径加到答案中。</p><p>4.如果root不是叶子节点，进入递归操作</p><p>5在construct_paths()外定义一下paths列表，再调用一下construct_paths()输入参数root，就开始执行<i>construct</i>_paths下的语句了，最后返回答案即可。</p><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "二叉树", 
                    "tagLink": "https://api.zhihu.com/topics/19698867"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/89192499", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "第五十六天——第五十六题（有效的字母异位词）", 
            "content": "<p>今天是10月30日星期三，一个月前我给哥们儿介绍了一个对象，现在他们在一起感情稳定，你侬我侬的，昨天晚上回去说每当他感到幸福的时候就特别感谢我，我听了还挺高兴，哈哈</p><h2><b>第五十六天——第五十六题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/delete-node-in-a-linked-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">有效的字母异位词</a>）</b></h2><p><b>看题目！</b></p><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: s = &#34;anagram&#34;, t = &#34;nagaram&#34;\n输出: true</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">输入</span><span class=\"p\">:</span> <span class=\"n\">s</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;rat&#34;</span><span class=\"p\">,</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;car&#34;</span>\n<span class=\"n\">输出</span><span class=\"p\">:</span> <span class=\"n\">false</span></code></pre></div><p><b>说明:</b></p><p>你可以假设字符串只包含小写字母。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isAnagram(self, s: str, t: str) -&gt; bool:\n        return collections.Counter(s)==collections.Counter(t)</code></pre></div><p><b>代码解释：</b></p><p><b>字母异位词：</b>字符串长度相等，所含字母及同一字母出现的次数相同。</p><p>collections是python中的一个模块，利用collections中的Counter即可计算字符串中每个字母出现的次数。</p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "我想做你哥们哈哈", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>哈哈</p>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88970164", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第五十五天（删除链表中的节点）", 
            "content": "<p>今天是10月29日，天气越来越凉，要多加几层被子了，距离供暖还有17天。</p><h2><b>第五十五天——第五十五题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/delete-node-in-a-linked-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除链表中的节点</a>）</b></h2><p><b>看题目！</b></p><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>现有一个链表 -- head = [4,5,1,9]，它可以表示为:</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: head = [4,5,1,9], node = 5\n输出: [4,1,9]\n解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: head = [4,5,1,9], node = 1\n输出: [4,5,9]\n解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">deleteNode</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">):</span>\n        <span class=\"s2\">&#34;&#34;&#34;\n</span><span class=\"s2\">        :type node: ListNode\n</span><span class=\"s2\">        :rtype: void Do not return anything, modify node in-place instead.\n</span><span class=\"s2\">        &#34;&#34;&#34;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"nb\">next</span><span class=\"o\">.</span><span class=\"n\">val</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"nb\">next</span><span class=\"o\">.</span><span class=\"nb\">next</span></code></pre></div><p><b>代码解释：</b></p><p>每次遇到纳闷的地方怀疑题目有问题，答案都会给我给我一巴掌。我心想着输入也没有整个链表，这想删也没处删呀！然后看了答案：</p><p>就是说没有链表的话就针对输入的节点做文章，用node.next.val的值代替它的位置，它的下一个位置就用node.next.next这段链表代替，就把这个node删除了。</p>", 
            "topic": [
                {
                    "tag": "链表", 
                    "tagLink": "https://api.zhihu.com/topics/19649942"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88788228", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第五十四天（二叉搜索树的最近公共祖先）", 
            "content": "<p>新的一周又要开始了，大家加油！</p><h2><b>第五十四天——第五十四题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 二叉搜索树的最近公共祖先</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p>例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-acc30b9a8993f50acdffc6ae60d406d3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"190\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;190&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"190\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-acc30b9a8993f50acdffc6ae60d406d3_b.jpg\"/></figure><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\n输出: 6 \n解释: 节点 2 和节点 8 的最近公共祖先是 6。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\n输出: 2\n解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。</code></pre></div><p><b>说明：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉搜索树中。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">lowestCommonAncestor</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">:</span> <span class=\"s1\">&#39;TreeNode&#39;</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">:</span> <span class=\"s1\">&#39;TreeNode&#39;</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">:</span> <span class=\"s1\">&#39;TreeNode&#39;</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"s1\">&#39;TreeNode&#39;</span><span class=\"p\">:</span>\n        <span class=\"c1\"># Value of current node or parent node.</span>\n        <span class=\"n\">parent_val</span> <span class=\"o\">=</span> <span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">val</span>\n\n        <span class=\"c1\"># Value of p</span>\n        <span class=\"n\">p_val</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"n\">val</span>\n\n        <span class=\"c1\"># Value of q</span>\n        <span class=\"n\">q_val</span> <span class=\"o\">=</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"n\">val</span>\n\n        <span class=\"c1\"># If both p and q are greater than parent</span>\n        <span class=\"k\">if</span> <span class=\"n\">p_val</span> <span class=\"o\">&gt;</span> <span class=\"n\">parent_val</span> <span class=\"ow\">and</span> <span class=\"n\">q_val</span> <span class=\"o\">&gt;</span> <span class=\"n\">parent_val</span><span class=\"p\">:</span>    \n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lowestCommonAncestor</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n        <span class=\"c1\"># If both p and q are lesser than parent</span>\n        <span class=\"k\">elif</span> <span class=\"n\">p_val</span> <span class=\"o\">&lt;</span> <span class=\"n\">parent_val</span> <span class=\"ow\">and</span> <span class=\"n\">q_val</span> <span class=\"o\">&lt;</span> <span class=\"n\">parent_val</span><span class=\"p\">:</span>    \n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">lowestCommonAncestor</span><span class=\"p\">(</span><span class=\"n\">root</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">q</span><span class=\"p\">)</span>\n        <span class=\"c1\"># We have found the split point, i.e. the LCA node.</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"n\">root</span></code></pre></div><p><b>代码解释：</b></p><p>看了解答才觉得很简单系列！自己想到了递归，不过对二叉树的性质还是没有掌握好忘记了它有一个很重要的性质：</p><p>1.节点 N<i>N</i> 左子树上的所有节点的值都小于等于节点 N<i>N</i> 的值</p><p>2.节点 N<i>N</i> 右子树上的所有节点的值都大于等于节点 N<i>N</i> 的值</p><p>3.左子树和右子树也都是 BST</p><p><b>官方题解如下：</b></p><p><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian--2/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二叉搜索树的最近公共祖先</a></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88568217", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第五十三天（2的幂）", 
            "content": "<p>亲爱的老铁们，大家周末好，今天上午闲来无事，来做一道——回文链表</p><h2><b>第五十三天——第五十三题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/palindrome-linked-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">回文链表</a>）</b></h2><p><b>看题目！</b></p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;2\n输出: false</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;2-&gt;2-&gt;1\n输出: true</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isPalindrome(self, head: ListNode) -&gt; bool:\n        tmp = []\n        while head:\n            tmp.append(head.val)\n            head = head.next\n        l = 0\n        r = len(tmp)-1\n        while l&lt;r:\n            if tmp[l] != tmp[r]:\n                return False\n            l += 1\n            r -= 1\n        return True</code></pre></div><p><b>python解答之一：</b></p><p>1.那道题首先有个不确定的地方就是回文数的位数是奇数还是偶数，后来特地又看了一下就是反着念顺着念都是一样的数。</p><p>2.那这段代码就很简单了，把链表放到列表里，然后前后元素对比是否一样，即可判断。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88396739", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第五十二天（2的幂）", 
            "content": "<p>今天出门虽然阳光明媚，但是温度却异常的低，寒风扑面，瑟瑟发抖，冬天真的要来了，是时候拿出我心爱的手套这样骑车也不会太冷~</p><h2><b>第五十二天——第五十二题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/power-of-two/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">2的幂</a>）</b></h2><p><b>看题目！</b></p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1\n输出: true\n解释: 2**0 = 1</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 16\n输出: true\n解释: 2**4 = 16</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 218\n输出: false</code></pre></div><p><b>pyhton解答法一：</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">isPowerOfTwo</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">n</span><span class=\"p\">:</span> <span class=\"nb\">int</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"nb\">bool</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">False</span>\n        <span class=\"k\">while</span> <span class=\"n\">n</span><span class=\"o\">%</span><span class=\"mi\">2</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"n\">n</span><span class=\"o\">//=</span><span class=\"mi\">2</span>\n        <span class=\"k\">if</span> <span class=\"n\">n</span><span class=\"o\">==</span><span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">True</span>\n        <span class=\"k\">return</span> <span class=\"kc\">False</span></code></pre></div><p><b>python解答法二：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPowerOfTwo(self, n):\n        return n and n &amp; (n-1) == 0</code></pre></div><p><b>代码解释：</b></p><p>1.方法一不用多说一直能整除的就是了，方法二则是因为发现了一个规律而得出的：</p><p>2.如果输入数字n是2的幂，那么n的二进制形态上只有最高位是“1”，其他位均为“0”，而n-1的二次幂最高位变成了“0”：，而其他位均为“1”，因此我们把n的二进制与n-1的二进制按位相与得到的结果一定是零。</p><p>（作者：玖月晴 链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/8005103cd158\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/8005103cd</span><span class=\"invisible\">158</span><span class=\"ellipsis\"></span></a> 来源：简书 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。）</p><p>3.我专门试了试几个数，比如：</p><p>8的二进制是1000,7的二进制就是0111；</p><p>16的二进制是10000，15的二进制就是1111;</p><p>32的二进制是100000，31的二进制就是11111；</p><p>所以他们的二进制按位相与必为零，由此条件也就可以判断输入n是否为2的幂。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88241227", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第五十一天（翻转二叉树）", 
            "content": "<p>每当自己精神懈怠的时候就会拿出迈克尔杰克逊的歌听个遍，虽然自己听不懂，但旋律还是很好听的，也因为他一生的事迹让每首歌的背后都有了不一样的故事关于爱与和平，反抗斗阵...心情就会很舒畅，感觉到了世界，大海，和森林...</p><h2><b>第五十一天——第五十一题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/invert-binary-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">翻转二叉树</a><b>）</b></h2><p><b>看题目！</b></p><p>翻转一棵二叉树。</p><p><b>示例：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入：\n\n     4\n   /   \\\n  2     7\n / \\   / \\\n1   3 6   9\n\n输出：  \n  4\n   /   \\\n  7     2\n / \\   / \\\n9   6 3   1</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">invertTree</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">root</span><span class=\"p\">:</span> <span class=\"n\">TreeNode</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">TreeNode</span><span class=\"p\">:</span>\n         <span class=\"k\">if</span> <span class=\"n\">root</span> <span class=\"o\">!=</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">root</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">invertTree</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">right</span><span class=\"p\">),</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">invertTree</span><span class=\"p\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"n\">left</span><span class=\"p\">)</span>\n         <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"k\">return</span> <span class=\"kc\">None</span>\n\n         <span class=\"k\">return</span> <span class=\"n\">node</span></code></pre></div><p><b>代码解释：</b></p><p>这道题大部分同学都用的是递归方法，形式略有不同但大家表达的都是一个意思。</p><p>这里也刚好可以回顾一下二叉树！</p><p>1.root根节点，root.left     root.right,这里和链表很像，一个根节点包含了下边的所有子节点</p><p>2.若根节点不为空将其赋值给node，然后进行递归操作，返回翻转后的二叉树。</p>", 
            "topic": [
                {
                    "tag": "二叉树", 
                    "tagLink": "https://api.zhihu.com/topics/19698867"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88006542", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第五十天（存在重复元素）", 
            "content": "<p>今天的题目有点过于简单~今天已经第五十天了，估计等到一百天还得至少俩月，哈哈，进度够慢的。</p><p>个人觉得刷题重要的是看到题目想答案的过程，你会把相关的知识都回顾一遍；同时在分析题解时也会发现大神们提供的多种方法，这两个过程是最容易收获的地方。加油！</p><h2><b>第五十天——第五十题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/contains-duplicate/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">存在重复元素</a><b>）</b></h2><p><b>看题目</b></p><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3,1]\n输出: true</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3,4]\n输出: false</code></pre></div><p><b>python解答一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        a=len(nums)\n        b=len(set(nums))\n        if a==b:\n            return False\n        else:\n            return True</code></pre></div><p><b>python解答二：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def containsDuplicate(self, nums: List[int]) -&gt; bool:\n        for i in range(len(nums)):\n            for j in range(i + 1, len(nums)):\n                if nums[i] == nums[j]:\n                    return True\n        return False</code></pre></div><p>逻辑很简单就不再解释了哈~</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "考试", 
                    "tagLink": "https://api.zhihu.com/topics/19556327"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87840424", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第四十九天（反转链表）", 
            "content": "<p>最近师兄师姐开始找工作了，明年就轮到我们了，可到现在还拿不准是去一线城市还是回家乡发展，所以暂定为到时候看找工作的情况而定吧，哪里有更加合适的工作去哪里~</p><h2><b>第四十九天——第四十九题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-linked-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">反转链表</a><b>）</b></h2><p><b>看题目！</b></p><p>反转一个单链表。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL\n输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def reverseList(self, head: ListNode) -&gt; ListNode:\n        new_head = None\n        \n        while head :     \n            tmp = head.next      # 备份原来head节点的next地址\n            head.next = new_head\n            new_head = head\n            head = tmp\n        \n        return new_head</code></pre></div><p><b>代码解释：</b></p><p>我发现自己越来越怕递归了，递归感觉很难看懂，这个解答是迭代。</p><p>1.我用了例子自己走了一遍确实可以翻转，可怜的是看明白都费劲，做出来还得好好修炼呢。</p><p>2.新建一个空链表，然后在while循环里完成翻转操作。</p><p>3.假设链表是5-&gt;4-&gt;3-&gt;2-&gt;1，while链表存在时，如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-769d312201255fbc25079b78fd6b75b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1440\" data-rawheight=\"729\" class=\"origin_image zh-lightbox-thumb\" width=\"1440\" data-original=\"https://pic3.zhimg.com/v2-769d312201255fbc25079b78fd6b75b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1440&#39; height=&#39;729&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1440\" data-rawheight=\"729\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1440\" data-original=\"https://pic3.zhimg.com/v2-769d312201255fbc25079b78fd6b75b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-769d312201255fbc25079b78fd6b75b2_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "最近才开始找工作嘛", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>对，找一些国企</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "路在脚下", 
                            "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                            "content": "哦哦", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }, 
                        {
                            "userName": "天涯过客", 
                            "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                            "content": "找哪个方向的，转行的啥也不懂[大哭]", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87212310", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第四十八天（同构字符串）", 
            "content": "<p>本来都提交了，因为把群二维码贴上来了，立马就给我封了，还得重新写一遍~</p><h2><b>第四十八天——第四十八题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/isomorphic-strings/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">同构字符串</a><b>）</b></h2><p><b>看题目！</b></p><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: s = &#34;egg&#34;, t = &#34;add&#34;\n输出: true205. 同构字符串 - 力扣（LeetCode）输入: s = &#34;egg&#34;, t = &#34;add&#34;\n输出: true</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: s = &#34;foo&#34;, t = &#34;bar&#34;\n输出: false</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: s = &#34;paper&#34;, t = &#34;title&#34;\n输出: true</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isIsomorphic(self, s: str, t: str) -&gt; bool:\n        return [*map(s.index, s)] == [*map(t.index, t)]</code></pre></div><p><b>代码解释：</b></p><p>做的时候就觉得这种题目有点想脑筋急转弯，一定有规律，但是这个规律不容易想到，所以我想了半天还是看了题解，一句话：<b>同构代表两个字符串中每个位置上字符在自身第一次出现的索引相同</b></p><p>1.首先要清楚Map()函数的用法，举个例子：</p><p>&gt;&gt;&gt; map(square, [1,2,3,4,5])# 计算列表各个元素的平方&gt;&gt;&gt;[1, 4, 9, 16, 25]</p><p>2.再举个例子s=&#34;app&#34;,t=“add”,</p><p>        *map(s.index, s)输出：[0,1,1]                   *map(t.index, t)输出：[0,1,1]</p><p>这么一比较就知道他们是不是同构字符串了吧！有趣！</p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": [
                {
                    "userName": "天涯过客", 
                    "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                    "content": "，哈哈，感觉您进度有点慢，emmmm,作者你好，你觉得java与golang二选一，哪个好，😁😁", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "是啊，之前坚持一天一题，后来就成了有时间了就写，我的阅历还不足以去评论这两个语言的优劣，但就我个人选的话，我会先学java，这个看你以后要做什么了吧", 
                            "likes": 0, 
                            "replyToAuthor": "天涯过客"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87101590", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第四十七天（计数质数）", 
            "content": "<p>今天这个题目感觉有点难办啊~先写出来再仔细看看！</p><h2><b>第四十七天——第四十七题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/count-primes/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">计数质数</a>）</b></h2><p><b>看题目！</b></p><p>统计所有小于非负整数 <i>n </i>的质数的数量。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 10\n输出: 4\n解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def countPrimes(self, n: int) -&gt; int:\n        count = 0\n        sign = [1] * n\n        for i in range(2, n, 1):\n            if int(sign[i]):\n                count += 1\n                for j in range(2 * i, n, i):\n                    sign[j] = 0\n        return count</code></pre></div><p><b>代码解释</b>：</p><p>这个是<a href=\"https://link.zhihu.com/?target=http%3A//zh.wikipedia.org/wiki/%25E5%259F%2583%25E6%258B%2589%25E6%2589%2598%25E6%2596%25AF%25E7%2589%25B9%25E5%25B0%25BC%25E7%25AD%259B%25E6%25B3%2595\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">厄拉多塞筛法</a>，不了解，特地去查了一下，感兴趣的可以点连接去看看。</p><p>恕吾愚钝，这段代码我看了很久，虽然厄拉多塞筛法看明白了，但是这段代码还是很迷。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>希望大神可以在评论区解释一下这段代码~感谢！</h2><p></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86721488", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第四十六天（移除链表元素）", 
            "content": "<p>昨天的微博爆炸新闻是——雪梨确认死亡，抑郁症真的是很可怕的病，他们平时看上去和我们一样的生活，但内心却十分煎熬，所以要照顾好自己的同时，也要多多关注一下身边的朋友，也许你的一句话就可以挽救一个人的生命。</p><h2><b>第四十六天——第四十六题（移除链表元素）</b></h2><p><b>看题目！</b></p><p>删除链表中等于给定值 <b><i>val </i></b>的所有节点。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6\n输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def removeElements(self, head: ListNode, val: int) -&gt; ListNode:\n        ans = head\n        while head != None:\n            if head.val == val:\n                head = head.next\n                ans = head\n                continue\n            if head.next != None and head.next.val == val:\n                head.next = head.next.next\n            else:\n                head = head.next\n        return ans</code></pre></div><p><b>代码解释：</b></p><p>1.记录头结点到ans</p><p>2.遍历结点，如果当前结点的值需要被删除，则将头结点舍弃，也就是head = <a href=\"https://link.zhihu.com/?target=http%3A//head.next\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">head.next</a>，并更新ans</p><p>3.判断当前结点的next是否需要被删除，如果需要删除，<a href=\"https://link.zhihu.com/?target=http%3A//%25E5%2588%25A0%25E9%2599%25A4%25E6%2596%25B9%25E6%25B3%2595%25E6%2598%25AFhead.next\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除方法是head.next</a> = <a href=\"https://link.zhihu.com/?target=http%3A//head.next.next\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">head.next.next</a>；如果不需要删除，继续检查下一个结点</p><p>此解释来自LeetCode大神<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/u/wkxjc/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wkxjc</a>发布的题解，相较其他题解来说更容易理解。</p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "天涯过客", 
                    "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                    "content": "提个小小建议，可以把专栏文章归类", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>链表在一起，数组在一起，用递归的在一起，动态规划的在一起是这样吗</p>", 
                            "likes": 0, 
                            "replyToAuthor": "天涯过客"
                        }, 
                        {
                            "userName": "天涯过客", 
                            "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                            "content": "不用归类了，才50道左右，多了再归类，哈哈，感觉您进度有点慢，emmmm,作者你好，你觉得java与golang二选一，哪个好，😁😁", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86331523", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第四十五天（快乐数）", 
            "content": "<p>快乐数一点也不快乐，自己磨磨唧唧写了半天，最后显示超出时间限制。</p><h2><b>第四十五天——第四十五题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/happy-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">快乐数</a><b>）</b></h2><p><b>看题目！</b></p><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><div class=\"highlight\"><pre><code class=\"language-text\">示例: \n\n输入: 19\n输出: true\n解释: \n12 + 92 = 82\n82 + 22 = 68\n62 + 82 = 100\n12 + 02 + 02 = 1</code></pre></div><p><b>Python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isHappy(self, n: int) -&gt; bool:\n        while True:\n            n = sum([int(i)**2 for i in str(n)])\n            if n == 4:\n                return False\n            if n == 1:\n                return True</code></pre></div><p><b>代码解释：</b></p><p>1.快乐数 最终会收敛到1， 如果不是快乐书 最终会出现4 16 37 58 89 145 42 20循环，所以n==4的时候说明就不是，n==1的时候就是了。这个方法一点都不友好，有几个人会发现这种规律。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isHappy(self, n: int) -&gt; bool:\n        n = str(n)\n        visited = set()\n        while 1:\n            n = str(sum(int(i) ** 2 for i in n))\n            if n == &#34;1&#34;:\n                return True\n            if n in visited:\n                return False\n            visited.add(n)</code></pre></div><p>相比较而言我自己墨迹想了半天，方法和这个类似！</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/86003379", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第四十四天（打家劫舍）", 
            "content": "<p>今天的题目有点意思，感觉像在教我们怎么盗窃，哈哈</p><h2><b>第四十四天——第四十四题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/house-robber/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">打家劫舍</a>）</b></h2><p><b>看题目！</b></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</p><p>示例 1:</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3,1]\n输出: 4\n解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。\n     偷窃到的最高金额 = 1 + 3 = 4 。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def rob(self, nums: List[int]) -&gt; int:\n        if not nums: \n            return 0\n        if len(nums) &lt;= 2: \n            return max(nums)\n        dp = [[None]*2 for _ in nums] \n        dp[0][0] = 0 \n        dp[0][1] = nums[0] \n        for i in range(1, len(nums)): # 从第二天开始择优\n            dp[i][0] = max(dp[i-1][0], dp[i-1][1])\n            dp[i][1] = dp[i-1][0] + nums[i]\n        n = len(nums) - 1\n        return max(dp[n][0], dp[n][1]) # 从最后一天选择出 抢了最后一天 和 没抢最后一天 最大的</code></pre></div><p><b>代码解释：</b></p><p>1.将输入为空时，输入长度小于等于2时这两种情况考虑在内。</p><p>2.解决这个题目用了动态规划寻求最优解，和之前买股票的那个题很相似。</p><p>3.初始化一个数组，大概长这样：[[None, None], [None, None], [None, None]]这是有三个房子时的初始化数组</p><p>4.dp[0][0]=0是第一个屋子没有被盗，dp[0][1] = nums[0]是第一个屋子被盗了，并拿到了钱</p><p>5.从第二个屋子开始进行动态规划，寻求最优解</p><p>6.第i间屋子没被盗，i-1间屋子有两种情况，可能被盗也可能没有被盗，选择拿钱最多的情况</p><p>7.第i间屋子被盗了，i-1间屋子肯定没有被盗，再加上第i间屋子的钱，就是偷盗总额。</p><p>8.最后一间屋子被盗了或者没被盗，两种情况取利益最大的一种情况即可获得最后偷盗总额。</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85825125", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第四十三天（位1的个数）", 
            "content": "<p>舍友最近在追火影疾风传谈论起这部动漫，这部动漫虽然没有像七龙珠那样贯穿我成长的始终，但鸣人他们还是在2016年带给了我一个夏天的感动。火影完结后我便开始了从火影的第50集开始看，看了一个夏天看完了整部剧，太多情节让我感动到哭啊，今天又回头听了听其中的BGM，还是那么的有感触。这是一部更新了15年的热血动漫！</p><h2><b>第四十三天——第四十三题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/number-of-1-bits/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">位1的个数</a>）</b></h2><p><b>看题目！</b></p><p>编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为<a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E6%25B1%2589%25E6%2598%258E%25E9%2587%258D%25E9%2587%258F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">汉明重量</a>）。</p><p><b>示例 1：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入：00000000000000000000000000001011\n输出：3\n解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def hammingWeight(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        num=bin(n)[2:]\n        count=0\n        for i in num:\n            if i==&#34;1&#34;:\n                count+=1    \n        return count</code></pre></div><p><b>代码解释：</b></p><p>再没有比今天的还简单的题目了，或者直接调用函数count(“1”)也行。</p><p><b>今天要特地说说我的导师，半个月前我老师左眼不舒服，跟我们说你们抓紧写论文我眼睛过几天就好了，到时候给你们看看。不料病情加重就医，诊断为视网膜脱落后住院治疗后需要在家静养至少一个月方可痊愈。</b></p><p><b>结果今天我和我的导师一起上的电梯，他这是生病以后第一次来学校，虽然眼睛还未痊愈，身体还未完全恢复，来的时候左眼还不能完全睁开，但他还是依然过来看我们，担心我们的进度，来了以后让我们分别去他办公室说说了最近的进展后，中午坐校车走了。</b></p><p><b>来的时候其他老师建议我们老师在家电话遥控就好了，不要硬撑着呀，我们老师说，本科生倒无所谓后期可以补课，研究生不能不管啊。</b></p><p><b>在我求学路上这么敬业的老师真的不多见，对我们也很好，比我爸爸大一岁，希望他们都健健康康的，很幸运选择了我的导师。</b></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "天涯过客", 
                    "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                    "content": "java学不会，转行学python,你的这个栏目写的真好", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>谢谢，我也是在学着写，参考大神的比较多</p>", 
                            "likes": 0, 
                            "replyToAuthor": "天涯过客"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85647685", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第四十二天（颠倒二进制位）", 
            "content": "<p>最近身体状况很差，希望大家保护好自己的身体，一旦生了病会发现健康比什么都重要!</p><p><b>第四十二天——第四十二题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/reverse-bits/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">颠倒二进制位</a>）</b></p><p><b>看题目！</b></p><p>颠倒给定的 32 位无符号整数的二进制位。</p><p><b>示例 1：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 00000010100101000001111010011100\n输出: 00111001011110000010100101000000\n解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，\n      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。python</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    # @param n, an integer\n    # @return an integer\n    def reverseBits(self, n):\n        return int(bin(n)[2:].zfill(32)[::-1], base=2)</code></pre></div><p><b>代码解释：</b></p><p><b>1.bin(n)将输入的整数转换为二进制数，[2:]是将二进数前的0b去掉。</b></p><p><b>2.输出为32位的二进制数，str.zfill(width)是返回指定长度的字符串，原字符串右对齐，前面填充0。</b></p><p><b>3.[::-1]然后反转，base=2是说这里的数转为二进制的整数，int()默认为十进制。</b></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "没事吧兄弟", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>问题不大，但需要时间恢复，谢谢</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-6eeb544aa5ce6be1e6a6add75e436746.gif\" data-width=\"\" data-height=\"\">[哈哈]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }
                    ]
                }, 
                {
                    "userName": "天涯过客", 
                    "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                    "content": "老哥研究生？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>研二</p>", 
                            "likes": 0, 
                            "replyToAuthor": "天涯过客"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83413155", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第四十一天（旋转数组）", 
            "content": "<h2><b>第四十一天——第四十一题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/rotate-array/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">旋转数组</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><p>示例 1:</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3,4,5,6,7] 和 k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右旋转 1 步: [7,1,2,3,4,5,6]\n向右旋转 2 步: [6,7,1,2,3,4,5]\n向右旋转 3 步: [5,6,7,1,2,3,4]</code></pre></div><p>示例 2:</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [-1,-100,3,99] 和 k = 2\n输出: [3,99,-1,-100]\n解释: \n向右旋转 1 步: [99,-1,-100,3]\n向右旋转 2 步: [3,99,-1,-100]</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def rotate(self, nums, k):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type k: int\n        :rtype: None Do not return anything, modify nums in-place instead.\n        &#34;&#34;&#34;\n        n = len(nums)\n        k %= n\n        for _ in range(k):\n            nums.insert(0, nums.pop())</code></pre></div><p><b>代码解释：</b></p><p><b>这个解答的方式很多，我就找了一个最简单的做。</b></p><p><b>1.得到列表长度后，k%=n这步操作是为了适用当k小于n和k大于n两种情况，比如：若k取值永远是小于n的，也就是小于列表长度，那k%=n这步就可以省略了，它让我们移动多少我们就移动多少。</b></p><p><b>2.但是题目并没有说k永远小于n,当k大于n时，比如长度为5的列表，k=6，那我们是不是就要乖乖的移动6次呢，其实不然，因为移动5次的时候相当于没有移动，所以k=6的时候我们只要移动1次就可以了。</b></p><p><b>3.而k%=n这步取余的操作，完全满足了上述两种情况，最后for循环，将列表最后一个数删除并插入到列表的第一个位置（即零索引处），这样就完成了旋转数组。</b></p><h2><b>祝大家周末愉快哟~</b></h2>", 
            "topic": [
                {
                    "tag": "数组", 
                    "tagLink": "https://api.zhihu.com/topics/19725906"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83225953", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第四十天（阶乘后的零）", 
            "content": "<p>话不多说，直接开始——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/factorial-trailing-zeroes/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">阶乘后的零</a></p><p><b>第四十天——第四十题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">阶乘</a>后的零<b>）</b></p><p><b>看题目 !</b></p><p>给定一个整数 n，返回 n! 结果尾数中零的数量。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 3\n输出: 0\n解释: 3! = 6, 尾数中没有零。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 5\n输出: 1\n解释: 5! = 120, 尾数中有 1 个零.</code></pre></div><p>说明: 你算法的时间复杂度应为 O(log n) 。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def trailingZeroes(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: int\n        &#34;&#34;&#34;\n        res = 0\n        while n &gt; 0:\n            n //= 5\n            res += n\n       return res</code></pre></div><p><b>自己写的代码：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">def jiechen(n):\n    mid=1\n    for i in range(n):\n        mid *= (i + 1)\n    a=list(str(mid))\n    for index,j in enumerate(a[::-1]):\n        if j!=&#34;0&#34;:\n            return index,a[::-1]\n</code></pre></div><p><b>代码解释：</b></p><p>好不容易自己写出了一个，结果说超出时间限制。先说正确答案吧！</p><p><i><b>大神的方法：</b></i></p><p>1.大概意思就是阶乘的时候但凡是末尾有零的必定跟5有关，而这种关系是看输入n中有5可以除。</p><p>2.【5//5=1】【10//5=2】【15//5=3】【20//5=4】【25//5=5，5//5=1】.....</p><p>只要知道n里能除几个5就可以啦！</p><p><i><b>我的方法：</b></i></p><p>1.先求出n的阶乘的值为多少，再将其值转换为字符串再转成列表（为了分析每一位数上的数是多少）</p><p>2.将分解后的值反转后遍历：比如5的阶乘是120，我反转后就是[&#39;0&#39;, &#39;2&#39;, &#39;1&#39;]，然后我遍历它知道j不为零的时候返回其索引值刚好就是它含零的个数。</p><p>3.结果是正确的，就是不能当做答案。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83073261", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十九天（Excel表列序号）", 
            "content": "<p>今天是9月18日，自8月9日停更已经过去了整整40天，这四十天将实验和论文大体完成等待老师的审核建议，所以接下来的一段时间里相对自由，今天重启刷题计划——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Excel表列序号</a></p><h2><b>第三十九天——第三十九题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Excel表列序号</a><b>）</b></h2><p><b>看题目</b></p><p>给定一个Excel表格中的列名称，返回其相应的列序号。</p><p>例如，</p><div class=\"highlight\"><pre><code class=\"language-text\"> A -&gt; 1\n    B -&gt; 2\n    C -&gt; 3\n    ...\n    Z -&gt; 26\n    AA -&gt; 27\n    AB -&gt; 28 \n    ...\n</code></pre></div><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;A&#34;\n输出: 1</code></pre></div><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;AB&#34;\n输出: 28</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;ZY&#34;\n输出: 701</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def titleToNumber(self, s: str) -&gt; int:\n        res = 0\n        bit = 1\n        for a in s[::-1]:\n            res += (ord(a) - 64) * bit\n            bit *= 26\n        return res\n</code></pre></div><p><b>代码解释：</b></p><p>这个题理解起来总有一种小学附加题的感觉，我没想太多直接下手写，因为没有完整的思路，所以就先把len(s)==1,2,3时的三种情况先写出来，然后从中找找规律（比较笨的方法啦）。</p><p>找到规律以后就开始想办法把这些规律用一段代码写出来同时适用于任何长度的输入值s。</p><p>1.res设为零为后续做准备，bit是每进一位就扩大到原来的26倍，就好比是个位1和十位上的1比较，十位上是个位上的10倍，而我们这个题的数位间差26倍。</p><p>2.s[::-1]是将输入的字符串反转：“ABCD&#34;变成了“DCBA”这样我们在for循环的时候就可以从个位开始了。</p><p>3.其中的64是因为“A”对应的ASCII码为65，减去64就可以让A-Z==1-26了。</p><p>4.个位计算完了bit*26，每进一位就在原来的基础上*26</p><p>5.循环结束，返回res。game over</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "失踪人口回归", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>哈哈，要走的路还很长</p>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }, 
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>哈哈，要走的路还很长</p>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78519370", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "暂停更新几天哟", 
            "content": "<p>这两天一直在赶着在开学前把实验结果做出来，忙完这段时间再重新回归刷题吧~</p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77402254", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十八天（求众数）", 
            "content": "<p>外边突然下大雨了，话说现在已是秋天了，秋高气爽，落叶漫天呢，一年又一年，自己也从孩子变成了大人了——<b>求众数</b></p><h2><b>第三十八天——第三十八题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/majority-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">求众数</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个大小为 <i>n</i> 的数组，找到其中的众数。众数是指在数组中出现次数<b>大于</b> <code>⌊ n/2 ⌋</code> 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [3,2,3]\n输出: 3</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [2,2,1,1,1,2,2]\n输出: 2</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def majorityElement(self, nums):\n        count = 0\n        candidate = None\n\n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n\n        return candidate\n</code></pre></div><p><b>代码解释：</b></p><p>1.这个题目的解答方法官方给出了很多不同的方法去解答，建议大家去看一下官方的解答<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/majority-element/solution/qiu-zhong-shu-by-leetcode-2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方题解：求众数 - 力扣（LeetCode）</a></p><p>2.这个是其中说的投票法，就是此消彼长的一个形式，如果一个元素连续重复的出现，count值就会不停的加一，如果遇到另外一个数count就减一，另外一个数连续重复出现的次数比前一个数还多那就会把count减回到0，这个时候candidate就会被第二个数赋值。</p><p>3.最后返回那个出现更多的元素即可。</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "不止一次机会", 
                    "userLink": "https://www.zhihu.com/people/5370e106d637db54ff4a2f6928be5e35", 
                    "content": "那这样只能用来只有两个元素得数组？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77380778", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十七天（Excel表列名称）", 
            "content": "<p>最近喜欢上了在微信小程序上玩五子棋，可能是因为百战百胜的原因吧，从小就喜欢玩五子棋，个人感觉五子棋的技术占80%，运气占20%——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-title/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Excel表列名称</a></p><h2><b>第三十七天——第三十七题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/excel-sheet-column-title/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Excel表列名称</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个正整数，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">   1 -&gt; A\n    2 -&gt; B\n    3 -&gt; C\n    ...\n    26 -&gt; Z\n    27 -&gt; AA\n    28 -&gt; AB \n    ...</code></pre></div><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1\n输出: &#34;A&#34;</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 28\n输出: &#34;AB&#34;</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 701\n输出: &#34;ZY&#34;</code></pre></div><p><b>Python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def convertToTitle(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: str\n        &#34;&#34;&#34;\n        res = &#34;&#34;\n        while n:\n            n, y = divmod(n, 26) \n            if y == 0:\n                n -= 1\n                y = 26\n            res = chr(y + 64) + res\n        return res\n</code></pre></div><p><b>代码解释：</b></p><p>1.这个题目有点费解，理解题中所给的逻辑就用了一会儿工夫。</p><p>2.大致意思就是让十进制转26进制</p><p>3.首先定义一个空的字符串，当n为真，也就是n&gt;0的时候进入while循环。</p><p>4.例如：4,0 = divmod（8,2），3,1 =divmod(7,2)这个函数就是干这个的。返回商和余数。</p><p>5.如果输入的n可以整除26时，余数特别为0，进入if语句后，n减1，y=26,res=chr(26+64)+res,此时res=&#34;z&#34;,因为n&gt;0，继续循环知道n=0,返回res</p><p>6.特别说明chr(65)=&#34;A&#34;，chr(90)=&#34;Z&#34;。可以去看看chr（）码值对应列表。</p><h2>不得不说这种代码能想出来不简单，还需要和人家多学习学习。</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/77378146", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十六天（两数之和 II - 输入有序数组）", 
            "content": "<p>今天是8月9号，这几天被实验整的很苦恼没有刷题，虽然仍在苦恼中，索性拿出一下午的时间来这里放松一下吧——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">两数之和 II - 输入有序数组</a></p><p><b>第三十六天——第三十六题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">两数之和 II - 输入有序数组</a><b>）</b></p><p><b>看题目!</b></p><p>给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。<br/>函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。<br/>说明:<br/>返回的下标值（index1 和 index2）不是从零开始的。<br/>你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: numbers = [2, 7, 11, 15], target = 9 输出: [1,2] \n解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</code></pre></div><p><b>python 解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def twoSum(self, numbers, target):\n        &#34;&#34;&#34;\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        &#34;&#34;&#34;\n        size = len(numbers)\n        left = 0\n        right = size - 1\n        while left &lt; right:\n            if numbers[left] + numbers[right] &gt; target:\n                right -= 1\n            elif numbers[left] + numbers[right] &lt; target:\n                left += 1\n            else:\n                return [left + 1, right + 1]\n</code></pre></div><p><b>代码解释：</b></p><p>1.双指针真的是个好东西呀，一旦学会灵活应用双指针，必定能称霸一方。</p><p>2.这个答案就是利用了双指针，利用了题目中提到的元素升序排列的这一性质。</p><p>3.首先要定义两个指针，左右两个哟，左边是从零开始的，又边必定要减一，不然就会多出一个索引咯。</p><p>4.while循环的条件就是在这两个指针没有相遇的时候，就不停止循环。</p><p>5.当左边（值较小的元素）+右边（值比较大的元素）比target还要大的时候，那问题肯定出现在右边（右边这个元素太大了），那就让右指针向元素值小的方向移动一下，再次循环。</p><p>6.同理，小于target时就让左边的指针向右边移动，再循环。</p><p>7.循环到，左边指针&lt;右边指针，同时左右两值不大于target,也不小于target，那就是相当呗，直接把其索引+1返回位置即可（+1是题目中要求的哟） 。</p><h2>不多说了，还有几篇要更啦~出来混总是要还的~</h2><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76927464", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十五天（相交链表）", 
            "content": "<p>最近看老版的三国演义,感叹人生短暂,再厉害的人也抵不住时间的消逝——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/intersection-of-two-linked-lists/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">相交链表</a></p><h2><b>第三十五天——第三十五题（相交链表）</b></h2><p><b>看题目！</b></p><p>编写一个程序，找到两个单链表相交的起始节点。如下面的两个链表<b>：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-95a3c91db0fb864c861cd7ed25c5597e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-95a3c91db0fb864c861cd7ed25c5597e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-95a3c91db0fb864c861cd7ed25c5597e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-95a3c91db0fb864c861cd7ed25c5597e_b.jpg\"/></figure><p>在节点 c1 开始相交。</p><h2><b>示例 1：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-56e3e30afc374302939e2c0e5aeb699d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic2.zhimg.com/v2-56e3e30afc374302939e2c0e5aeb699d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic2.zhimg.com/v2-56e3e30afc374302939e2c0e5aeb699d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-56e3e30afc374302939e2c0e5aeb699d_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\n输出：Reference of the node with value = 8\n输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。</code></pre></div><h2><b>示例 2：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-98f9515091e037aa9641a76c27d27390_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"622\" data-original=\"https://pic1.zhimg.com/v2-98f9515091e037aa9641a76c27d27390_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;622&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"622\" data-original=\"https://pic1.zhimg.com/v2-98f9515091e037aa9641a76c27d27390_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-98f9515091e037aa9641a76c27d27390_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Reference of the node with value = 2\n输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</code></pre></div><h2><b>示例 3：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6d485a139fcd39b6496d1a8cb3b900a9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"382\" data-rawheight=\"241\" class=\"content_image\" width=\"382\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;382&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"382\" data-rawheight=\"241\" class=\"content_image lazy\" width=\"382\" data-actualsrc=\"https://pic2.zhimg.com/v2-6d485a139fcd39b6496d1a8cb3b900a9_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：null\n输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n解释：这两个链表不相交，因此返回 null。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        p,q = headA,headB\n        while p!=q:\n            p = p.next if p else headB\n            q = q.next if q else headA\n        return p</code></pre></div><p><b>代码解释：</b></p><p><b>同时时遍历链表1和链表2，到达末尾时，再指向另一个链表。则当两链表走到相等的位置时，即p=q,则返回p.</b></p><p><b>没交点则y=0, 结尾都指向None,返回空。</b></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76684068", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第三十四天（环形链表）", 
            "content": "<p>今天是8月5日星期一，距离四六级成绩公布还有二十天——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/linked-list-cycle/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">环形链表</a></p><h2><b>第三十四天——第三十四题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/linked-list-cycle/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">环形链表</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><b>示例 1：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ac4a1d75327d42fac10beebd9363656d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"531\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb\" width=\"531\" data-original=\"https://pic2.zhimg.com/v2-ac4a1d75327d42fac10beebd9363656d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;531&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"531\" data-rawheight=\"171\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"531\" data-original=\"https://pic2.zhimg.com/v2-ac4a1d75327d42fac10beebd9363656d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ac4a1d75327d42fac10beebd9363656d_b.jpg\"/></figure><p><b>python 解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def hasCycle(self, head):\n        &#34;&#34;&#34;\n        :type head: ListNode\n        :rtype: bool\n        &#34;&#34;&#34;\n        if not head or not head.next :\n            return False\n        slow = head\n        fast = head.next\n        while slow != fast:\n            if not fast or not fast.next:\n                return False\n            slow = slow.next\n            fast = fast.next.next\n        else:\n            return True</code></pre></div><p><b>代码解释：</b></p><p>1.首先判断输入是否为空。</p><p>2.利用双指针的方法，定义一个快指针和一个满指针。</p><p>3.将链表比作跑道，指针比作运动员，直线跑道快者先至终点，此时满足：if not fast or not fast.next:                 return False。故可判定非环形赛道。</p><p>4.若为环形赛道，快者每次循环都先慢者一步，必有超慢者一圈的时候。当快者再与慢者相遇即为二者相等之时，即可执行 else:             return True。故可判定此链表为环形链表。</p><p><b>马上就要入秋了，时间过得真快，夏天刚来就要走了，窗外阴雨绵绵，这两天格外凉爽，等待开学！</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76541376", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十三天（只出现一次的数字）", 
            "content": "<p>今天不知道说点啥，只出现过一次的数字不是很难我们直接看题目吧！</p><h2><b>第三十三天——第三十三题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/single-number/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">只出现一次的数字</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个<b>非空</b>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p><b>说明：</b></p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [2,2,1]\n输出: 1</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [4,1,2,1,2]\n输出: 4</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def singleNumber(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        if nums is None:\n            return None\n        y=[]\n        for i in nums:\n            if i not in y:\n                y.append(i)\n            else:\n                y.remove(i)\n        return y.pop()</code></pre></div><p><b>代码解释：</b></p><p>1.定义一个空的列表，遍历数组中的每一个元素，如果该元素不在列表中，则将其添加进去。</p><p>2.如果遍历的元素已存在列表中，则将列表中的该元素移除。</p><p>3.最后返回列表中的元素，即为只出现过一次的元素。</p><p><b>大家晚安！</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76420415", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十二天（验证回文串）", 
            "content": "<p>今天上午出门感觉雨不大，于是骑着我刚修好自行车去学校了，结果在路上越下越大最后到学校都成落汤鸡了，只好拿出抽屉里的雨衣又回家换了身衣服——验证回文串</p><h2><b>第三十二天——第三十二题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-palindrome/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">验证回文串</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><b>说明：</b>本题中，我们将空字符串定义为有效的回文串。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;A man, a plan, a canal: Panama&#34;\n输出: true</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;race a car&#34;\n输出: false</code></pre></div><p><b>python解答之一：</b></p><p><b>回文数和回文串就是：从左往右读==从右往左读，类似121——aba等等。</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPalindrome(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: bool\n        &#34;&#34;&#34;\n        tmp = re.sub(r&#34;[^A-Za-z0-9]&#34;,&#34;&#34;, s).lower()\n        return tmp == tmp[::-1]</code></pre></div><p><b>代码解释：</b></p><p>1.两行代码结束战斗。</p><p>2.re是正则表达式，是python中一个功能非常强大的模块好久没用，细节的知识也记不清了。</p><p>3.<b>re</b>:regular expression的缩写,表示正则表达式</p><p><b>   sub</b>:substitude的缩写，表示替换。</p><p>4.将字符串中的子母和数字提取出来然后将字字母都变成小写，只需比较反转前后是否一样即可，相同返回True,否则返回False。</p><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>[^A-Za-z0-9]，^==不是，这段代码就是说不是字母和数字的字符串根据第二个参数的内容进行替换，这里第二个参数是“”，所以就是把非字母和数字的字符串删除就好了，最后就只剩下字母和数字了，方便比较。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76255013", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第三十一天（买卖股票的最佳时机）", 
            "content": "<p>今天是8月1日建军节，转眼就又到了八月份了，从小到大8月总是悲喜交加，小时候进入八月心想还有一个月才开学呢时间还早，八月底却又因为赶不完暑假作业而痛苦不堪。中学时期的8月往往在补课中度过，炎热的夏天和一群刚刚熟悉起来的朋友转眼就要说再见。上大学后的8月总是在打工中度过。现在的8月，可以说是近些年最特殊的8月，没有补习班，没有实习，只是留在学校，做着自己的事情，这样也挺好——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">买卖股票的最佳时机 II</a></p><h2><b>第三十一天——第三十一题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">买卖股票的最佳时机 II</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。</p><p>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [7,1,5,3,6,4]\n输出: 7\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3,4,5]\n输出: 4\n解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。\n     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。\n     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxProfit(self, prices):\n        &#34;&#34;&#34;\n        :type prices: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        if (len(prices)&lt;=1):\n            return 0\n        buy=-prices[0]\n        sell=0\n        for i in range(len(prices)):\n            buy= max(buy,sell-prices[i])\n            sell= max(sell,prices[i]+buy)\n        return sell</code></pre></div><p><b>代码解答：</b></p><p>1.这道题目和昨天的题目很相似，区别在于昨天是一锤子买卖，买入和卖出行为分别只发生一次。</p><p>2.今天的买入和卖出可以发生多次，但是来回就是这一笔生意的买入卖出。</p><p>3.所以只需要在 buy= max(buy,sell-prices[i]），当天【买入股票】这件事情上加上sell的值就可以了，意味着第二次买入股票的时候可以用上第一次挣的那点钱。</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/76246745", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第三十天（买卖股票的最佳时机）", 
            "content": "<p>看完侄子回来了，小家伙这两天做了一个不大不小的手术，现在又活蹦乱跳的了，小孩子真是好有个玩具就可以开心玩上一天，小时候我也喜欢变形金刚和遥控赛车，虽然也都玩过，只是没有那么容易得到吧——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">买卖股票的最佳时机</a></p><h2><b>第三十天——第三十题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">买卖股票的最佳时机</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [7,1,5,3,6,4]\n输出: 5\n解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [7,6,4,3,1]\n输出: 0\n解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</code></pre></div><p><b>python 解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxProfit(self, prices):\n        &#34;&#34;&#34;\n        :type prices: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        if (len(prices)&lt;=1):\n            return 0\n        buy=-prices[0]\n        sell=0\n        for i in range(len(prices)):\n            buy= max(buy,-prices[i])\n            sell= max(sell,prices[i]+buy)\n        return sell</code></pre></div><p><b>代码解答：</b></p><p>1.先考虑输入只有1个元素的时候，返回为0即可。</p><p>2.输入不为0的时候，定义buy和sell，分别代表【买入股票】和【卖出股票】，之所以让【买入股票】为-prices[0]是将买入股票这个行为看作是【钱】损失了prices[0]，毕竟最后我们要让手头上的钱达到最大。</p><p>3.sell开始定义为0，开始for循环，for循环语句中的内容就是追求两个最大化：当天买和之前买哪个收益更高，当天卖和之前卖哪个收益更高。</p><p>4.max(buy,-prices[i])代表【之前买】和【当天买】比较选择大的</p><p>sell= max(sell,prices[i]+buy)代表【之前卖】和【当天卖】比较选择大的</p><p>5.最后返回sell即可。</p><h2>这道题目参考了@和程序员小吴一起学算法的文章，内容中详细介绍了动态规划及股票购买中各个步骤的意义。</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75895656", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十九天（杨辉三角II）", 
            "content": "<p>昨天一直在想为什么今天30号了，而我这里是第29天做题，往前翻了翻发现有两天标题都是第21天，所以才会比日历晚一天，明天回家看小侄子，后更新两篇就可以恢复正常啦——<b>杨辉三角II</b></p><h2><b>第二十九天——第二十九题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/pascals-triangle-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">杨辉三角 II</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个非负索引 <i>k</i>，其中<i>k</i> ≤ 33，返回杨辉三角的第<i>k</i>行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image\" width=\"260\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;260&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image lazy\" width=\"260\" data-actualsrc=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\"/></figure><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><b>示例:</b></p><p><b>输入:</b> 3<br/><b>输出:</b> [1,3,3,1]</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">def getRow(self, rowIndex: int) -&gt; List[int]:\n        tmp = []\n        for i in range(rowIndex + 1):\n            tmp.insert(0, 1)\n            for i in range(1, len(tmp) - 1):\n                tmp[i] = tmp[i] + tmp[i+1]\n        return tmp\n\n作者：powcai\n链接：https://leetcode-cn.com/problems/two-sum/solution/mo-ni-guo-cheng-by-powcai-5/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><p><b>代码解释：</b></p><p>这段代码运行没问题，但是我还是顺不下来~</p><p>1.定义一个空列表。</p><p>2.假设rowIndex=3，意味着输出第4行的值，所以需要遍历4次，(for循环中：第0次，第1次，第2次，第3次）</p><p>3.关键就是我在第0次进入循环后就出不来，哈哈</p><p>4.第一个for循环后将tmp的0索引赋予1值，此时tmp=[1],进入第二个for循环，此时range(1,len(tmp)-1)==range(1,0)——这样的写法好奇怪。继续往下...</p><p><b>5.i=1时，tmp[1]=tmp[1]+tmp[2]，这个位置着实不明白，此时tmp只有0索引上有值啊。</b></p><p>6.接下来就进行不下去了。。。待在下弄明白后写在评论区，见谅！</p><h2>明天早上六点起床，回家看望小侄子~今天留下好多疑问，希望忙完明天了赶紧解决！</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75690066", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第二十八天（杨辉三角）", 
            "content": "<p>昨晚上的大暴雨真是很刺激呀！狂风暴雨，电闪雷鸣，因为是半夜起来关窗户的时候看到的，所以脑子里也没有留下很多画面，只记得关完窗户后，躺在床上，感觉外边的世界要崩塌了一样。想想有多少流浪的人在这样的天气，只能蜷缩在城市的某个角落里等待天晴，就略有心酸，可能是我最近看抖音上那些关爱孤寡老人的视频看多了，就总往这方面想——<b>杨辉三角</b></p><h2><b>第二十八天——第二十八题（</b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/pascals-triangle/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">杨辉三角</a><b>）</b></h2><p><b>看题目！</b></p><p>给定一个非负整数 <i>numRows，</i>生成杨辉三角的前 <i>numRows </i>行。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image\" width=\"260\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;260&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"240\" data-thumbnail=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.jpg\" class=\"content_image lazy\" width=\"260\" data-actualsrc=\"https://pic3.zhimg.com/v2-99fd119be3ca7616ae635b28e7181f7e_b.gif\"/></figure><p>在杨辉三角中，每个数是它左上方和右上方的数的和</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 5\n输出:\n[\n     [1],\n    [1,1],\n   [1,2,1],\n  [1,3,3,1],\n [1,4,6,4,1]\n]</code></pre></div><p><b>python 解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def generate(self, numRows):\n        &#34;&#34;&#34;\n        :type numRows: int\n        :rtype: List[List[int]]\n        &#34;&#34;&#34;\n        triangle = []\n        for row_num in range(numRows):\n            row = [None for i in range(row_num+1)]\n            row[0], row[-1] = 1, 1\n            for j in range(1, len(row)-1):\n                row[j] = triangle[row_num-1][j-1] + triangle[row_num-1][j]\n            triangle.append(row)\n        return triangle</code></pre></div><p><b>代码解释：</b></p><p>1.通过观察杨辉三角的数字规律可以确定一些位置的值，每一行的首位和末尾都是1。</p><p>2.首先定义一个目标数组（最后返回的结果），之前也做过一个将临时数组添加到目标数组的题目（可以看一下第二十三天的内容）。</p><p>3.开始循环，在循环中定义了一个数组row，这个row在第一次for循环时，row=[None]，然后row[0]=1改变了row=[None]，进入第二个for循环，这个j代表的索引就是row数组中非1的那些位置（除首末以外的中间位置）。</p><p>4.这个时候找到当前行的前一行数组再找到该数组j索引的前一个索引上的值（也就是每个数的左上方的值），同理找到这个元素右上方的值，两个值之和赋值给row的j索引，主要操作就完成了。</p><p>5.row放入triangle中，进行下一次循环操作，循环完毕后，返回triangle数组，就可以得到杨辉三角啦。</p><p>6.对于这句的理解：row = [None for i in range(row_num+1)]，就是直接把row上所有的位置都变成None,然后在下一句：row[0], row[-1] = 1, 1将首末位变成已知的值1。之后在下边的操作计算中间的值。</p><h2>小生不才，自带啰嗦体质，望各位见谅~</h2><p>读完一遍发现我解释了那么多，好像第6步解释就可以说明问题了哈哈~</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "Knights", 
                    "userLink": "https://www.zhihu.com/people/fe2ea0ddcf1f60e85b6f06a32df271ea", 
                    "content": "<p>这个对打印格式有要求吗</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>没有要求但是最后输出应该是杨辉三角才对</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75512413", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第二十七天（路径总和）", 
            "content": "<p>今天的实验室只有自己一个人，于是就打开我的歌单，一首《可不可以》还是挺有感觉的：我可以接受你的所有，所有小脾气，我可以带你去吃，吃好多东西。。。。。。</p><p>虎哥说车：许多网友想做——<b>路径总和</b>，今天它来啦~（自带bgm）</p><p><b>第二十七天——第二十七题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/path-sum/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">路径总和</a>）</b></p><p><b>看题目！</b></p><p>给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p><p><b>说明:</b> 叶子节点是指没有子节点的节点。</p><p><b>示例:</b></p><p>给定如下二叉树，以及目标和<code>sum = 22</code>，</p><div class=\"highlight\"><pre><code class=\"language-text\">              5\n             / \\\n            4   8\n           /   / \\\n          11  13  4\n         /  \\      \\\n        7    2      1\n\n来源：力扣（LeetCode）</code></pre></div><p>返回<code>true</code>, 因为存在目标和为 22 的根节点到叶子节点的路径<code>5-&gt;4-&gt;11-&gt;2</code>。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def hasPathSum(self, root, sum):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :type sum: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        if not root:\n            return False\n\n        sum -= root.val\n        if not root.left and not root.right:  # if reach a leaf\n            return sum == 0\n        return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)</code></pre></div><p><b>代码解释：</b></p><p>1.惯例，考虑输入为空的情况</p><p>2.拿出我们的目标值来去减掉根节点的值（因为用了递归，所以只有第一次这个root是真正的根节点，接下来的root就是root.left，root.left.left等等）</p><p>3.如果递归到了这个节点不存在子节点的时候，这个时候就返回sum==0,这个==有两种情况，要是真正的如愿以偿sum==0则返回True,如果费了半天劲,返回的时候发现sum不等于0那就只能输出False啦。</p><p>4.如果人家递归到的这个节点存在子节点的时候，那就继续上述操作，直到没有子节点的时候，进入3.中返回结果即可。</p><p><b>祝大家周末愉快哟~</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75454475", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十六天（二叉树的最小深度）", 
            "content": "<p>下雨了，不过我知道马上就会停了，真是伤心耶。不过感觉没那么热了——今天的这个小悟空有点不太像哈，《七龙珠》在我心里的地位就像周杰伦在我心里的地位一样，同样是童年回忆，青年的激励——<b>二叉树的最小深度</b></p><h2>第二十六天——第二十六题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/minimum-depth-of-binary-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二叉树的最小深度</a>）</h2><p><b>看题目!</b></p><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p><b>说明:</b> 叶子节点是指没有子节点的节点</p><p><b>示例:</b></p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><div class=\"highlight\"><pre><code class=\"language-text\">   3\n   / \\\n  9  20\n    /  \\\n   15   7</code></pre></div><p>返回它的最小深度  2.</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def minDepth(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: int\n        &#34;&#34;&#34;\n        if not root: \n            return 0 \n        \n        children = [root.left, root.right]\n        # if we&#39;re at leaf node\n        if not any(children):\n            return 1\n        \n        min_depth = float(&#39;inf&#39;)\n        for c in children:\n            if c:\n                min_depth = min(self.minDepth(c), min_depth)\n        return min_depth + 1 </code></pre></div><p><b>代码解释：</b></p><p>1.习惯性考虑输入为空的情况，返回零。</p><p>2.将左节点和有节点放入数组中，定义为children。</p><p>3.如果二叉树除了root外，没有任何子节点，那么返回1（这个if not any()挺好用哈）</p><p>4.重点来了，min_depth = float(&#39;inf&#39;)这一句将正无穷赋值给最小深度，也就是定义一个min_depth它的值必须是正数（我是这样理解的哈）</p><p>5.去遍历children（它已经是一个包含左右子节点的数组了），当遍历出的C值为真时，也就是说children中是有值的时候，这个有值可能是只有左边子节点的值或者只有右边子节点的值，再或者两边都有值，这三种情况都包括了。</p><p>6.利用递归的方式求每个子节点的深度，返回值+1即为所求。</p><h2>疑问：有一点不太理解的地方时，那个正无穷的赋值和min()中的min_depth的存在，作用是什么呢？</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>说说我对上述疑问的理解：min_depth只在第一次的遍历中发挥正无穷的作用，第二次中它被重新赋值以后就要和之前的子节点的深度进行比较如果第二次的，也就是右边的子节点拥有更小的深度，那么min()就输出min_depth的值。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "美利坚搅拌机", 
                            "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                            "content": "<p>你说的没错，min_depth用于保存当前最小的深度，每次如果有更小的就更新，初始状态需要设为正无穷，因为只要这棵树不为空，那深度一定比正无穷小，自然就会更新min_depth</p>", 
                            "likes": 1, 
                            "replyToAuthor": "微雨点点点"
                        }, 
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>很多时候，困扰自己的问题突然就解决了</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" data-width=\"\" data-height=\"\">[干杯]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "美利坚搅拌机"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75398046", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十五天（平衡二叉树）", 
            "content": "<p>       这段时间跟二叉树杠上了，接下来还有许多二叉树的题目，虽然已经做了不少了，大多题目都涉及到了递归，也挺好，刚好有机会练习一下递归，但是遇到新的题目还是有点力不从心，还需要看参考答案，真希望有一天像汤神一样：<b>这道题我拿到手上就会做！</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dcad9db1f9c67920dc982cca8b7636f5_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"180\" class=\"content_image\" width=\"180\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;180&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"180\" class=\"content_image lazy\" width=\"180\" data-actualsrc=\"https://pic2.zhimg.com/v2-dcad9db1f9c67920dc982cca8b7636f5_b.png\"/></figure><h2>第二十五天——第二十五题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/balanced-binary-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">平衡二叉树</a>）</h2><p><b>看题目！</b></p><p>给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>本题中，一棵高度平衡二叉树定义为：</p><p>一个二叉树<i>每个节点 </i>的左右两个子树的高度差的绝对值不超过1。</p><p><b>示例 1:</b></p><p>给定二叉树<code>[3,9,20,null,null,15,7]</code> </p><div class=\"highlight\"><pre><code class=\"language-text\">   3\n   / \\\n  9  20\n    /  \\\n   15   7</code></pre></div><p>返回<code>true</code>。</p><p><b>示例 2:</b></p><p>给定二叉树<code>[1,2,2,3,3,null,null,4,4]</code></p><div class=\"highlight\"><pre><code class=\"language-text\">       1\n      / \\\n     2   2\n    / \\\n   3   3\n  / \\\n 4   4\n </code></pre></div><p>返回 <code>false</code></p><p><b>python解答之一： </b></p><div class=\"highlight\"><pre><code class=\"language-text\"># Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution(object):\n    def isBalanced(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: bool\n        &#34;&#34;&#34;\n        if not root:\n            return True\n        return abs(self.height(root.right)-self.height(root.left))&lt;2 and self.isBalanced(root.left) and self.isBalanced(root.right)\n\t# 求高度\n    def height(self, node):\n        if not node:\n            return 0\n        return 1+max(self.height(node.right),self.height(node.left))\n       </code></pre></div><p><b>代码解释：</b></p><p>1.首先判断根节点为空时的情况（这一步已经习以为常了）</p><p>2.不为空则根据输入是否满足return后的条件来决定返回True或者False。</p><p>3.return后的条件为：</p><p>条件1：左右两侧的高度差小于2（也就是说高度差是1或者0都是可以的）</p><p>条件2：利用递归，去判断根节点左右两边的叶子结点他们的子节点是否满足条件1，以此往树下走，直到走到头。</p><p>4.条件1中用到了求二叉树高度的函数，所以在最后另外在定义一下height函数即可。</p><h2>有时候风扇比空调更适合你哟~</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "双子的沉默", 
                    "userLink": "https://www.zhihu.com/people/522a5a55122ee4f48045b8cd17ff370f", 
                    "content": "你好 机器学习方向也需要刷leetcode吗", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>就是为了练习一下代码，见多识广，熟能生巧，做实验啥的免不了自己写代码</p>", 
                            "likes": 0, 
                            "replyToAuthor": "双子的沉默"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75116267", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十四天（将有序数组转换为二叉搜索树）", 
            "content": "<p>今天导师来实验室转了一圈，说起我的研究生导师，真的是非常负责人的一位老教授，即便是暑假一周也会来好多次，就是希望在自己不太忙的时候可以多指导指导我们的论文进度。想想当初自己选导师，真是慧眼识英才呀——<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">将有序数组转换为二叉搜索树</a></b></p><h2>第二十四天——第二十四题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">leetcode-cn.com/problem</span><span class=\"invisible\">s/binary-tree-level-order-traversal-ii/</span><span class=\"ellipsis\"></span></a><b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">将有序数组转换为二叉搜索树</a></b>）</h2><p><b>看题目：如果题目读不懂可以看下边CSDN上的链接。</b></p><p>将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。</p><p>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p><p><b>示例:</b></p><p>给定有序数组: [-10,-3,0,5,9],</p><p>一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树：</p><div class=\"highlight\"><pre><code class=\"language-text\">      0\n     / \\\n   -3   9\n   /   /\n -10  5</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def sortedArrayToBST(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: TreeNode\n        &#34;&#34;&#34;\n        if len(nums)==0:\n            return\n        # 取nums列表的中间下标值\n        mid_index = len(nums)//2\n        pNode = TreeNode(nums[mid_index])\n        pNode.left = self.sortedArrayToBST(nums[:mid_index])\n        pNode.right = self.sortedArrayToBST(nums[mid_index+1:])\n        return pNode</code></pre></div><p><b>代码解释：</b></p><p><b>首先：</b><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/xiaohui987987/article/details/81347463\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/xiaohui98</span><span class=\"invisible\">7987/article/details/81347463</span><span class=\"ellipsis\"></span></a></p><p><b><i>要理解题目的意思，还需要把上边的链接点开，了解一下什么是平衡二叉树，什么是二叉排序树</i></b>。</p><p>1.习惯性判断当输入为空的情况该如何处置。</p><p>2.正常情况下取数组的中间数作为根节点，然后用递归的方式，定义左侧节点（左侧节点值都要小于根节点的值）和右侧节点（右侧节点的值都要大于根节点的值），于是左侧取数组中间数的左边，右侧取数组中间数的右边，最后返回二叉树即可。</p><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75095764", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十三天（二叉树的层次遍历 II）", 
            "content": "<p>最近外边的温度一度达到了39摄氏度，持续的高温让人不想出门，但是越是懈怠就越是懈怠，还是要走出舒适区，进入人群中，投入到工作和学习中，才会获得快乐——二叉树的层次遍历II</p><h2>第二十三天——第二十三题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 二叉树的层次遍历 II</a>）</h2><p><b>看题目！</b></p><p>给定一个二叉树，返回其节点值自底向上的层次遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><p><b>例如：</b></p><p>给定二叉树 [3,9,20,null,null,15,7],</p><div class=\"highlight\"><pre><code class=\"language-text\">    3\n   / \\\n  9  20\n    /  \\\n   15   7</code></pre></div><p>返回其自底向上的层次遍历为：</p><div class=\"highlight\"><pre><code class=\"language-text\">[\n  [15,7],\n  [9,20],\n  [3]\n]</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def levelOrderBottom(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        &#34;&#34;&#34;\n        if not root:\n            return []\n        ans = [root]\n        target = []\n        while ans:\n            tmp,n = [],len(ans)\n            for i in range(n):\n                r = ans.pop(0)\n                tmp.append(r.val)\n                if r.left:\n                    ans.append(r.left)\n                if r.right:\n                    ans.append(r.right)\n            target.append(tmp)\n        return target[::-1]</code></pre></div><p><b>代码解释：</b></p><p>1.如果二叉树为空，返回空数组。</p><p>2.把二叉树转成数组。定义一个目标数组，他将是最后返回的结果。</p><p>3.进入while循环，当ans数组不为空时：定义一个临时的数组和ans的长度。</p><p>4.进入For循环，第一层只能循环一次，取ans索引为零的数值，拿出来赋值给r。</p><p>5.把r所表示的值添加到临时数组tmp中，如果此值也就是此节点有左子节点或者有右子节点，要将其添加到ans数组中。</p><p>6.把刚刚得到的tmp放入target中，完成，第一层的遍历。</p><p>7.同理往复，最后倒序输出target。</p><h2>期待一场持续的降雨~</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74864104", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十二天（二叉树的最大深度）", 
            "content": "<p>这几天知乎又被杰伦刷屏了，想想自己喜欢周杰伦也快20年了，虽然我才25岁，哈哈</p><p>小时候比我大七岁的哥哥特别喜欢周杰伦，耳濡目染就成为了一名杰迷，周杰伦三个字成为我成长道路上一个非常重要的积极因素。来看看今天的题目——<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二叉树的最大深度</a></b></p><h2>第二十二天——第二十二题（<b><a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/maximum-depth-of-binary-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二叉树的最大深度</a></b>）</h2><p><b>看题目！</b></p><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>说明: 叶子节点是指没有子节点的节点。</p><p><b>示例：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">给定二叉树 [3,9,20,null,null,15,7]，\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\n返回它的最大深度 3 。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def maxDepth(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: int\n        &#34;&#34;&#34;\n        if not root:\n            return 0\n        if root.left==root.right==0:\n            return 1\n        else:\n            left=self.maxDepth(root.left)\n            right=self.maxDepth(root.right)\n        return max(left+1,right+1)\n            </code></pre></div><p><b>代码解释：</b></p><p>1.先处理输入为空，和输入只有根节点的情况。</p><p>2.再进入正常的语句，利用递归得出二叉树左侧和右侧的深度，加1即为所求二叉树最大深度。</p><p><b>今晚是红烧鸡翅，回家吃饭啦</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "路在脚下", 
                    "userLink": "https://www.zhihu.com/people/fddb0ec5bef32ca1767f798b9c075f50", 
                    "content": "周杰伦！", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>Jay</p>", 
                            "likes": 0, 
                            "replyToAuthor": "路在脚下"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74701450", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 3, 
            "title": "LeetCode刷题——第二十一天（对称二叉树）", 
            "content": "<p>今天的壁纸很帅气呀，已经把他设置成桌面了，这个风格的绿巨人还是头一次见到——对称二叉树</p><h2>第二十一天——第二十一题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/symmetric-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">对称二叉树</a>）</h2><p><b>看题目！</b></p><p>给定一个二叉树，检查它是否是镜像对称的。</p><p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p><div class=\"highlight\"><pre><code class=\"language-text\">    1\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3</code></pre></div><p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p><div class=\"highlight\"><pre><code class=\"language-text\">    1\n   / \\\n  2   2\n   \\   \\\n   3    3</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/symmetric-tree\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">对称二叉树 - 力扣（LeetCode）</a></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> class Solution(object):\n    def isSymmetric(self, root):\n        &#34;&#34;&#34;\n        :type root: TreeNode\n        :rtype: bool\n        &#34;&#34;&#34;      \n        if not root:                                 # 先判断根节点是否为空\n            return True\n        return self.isMirror(root.left, root.right)  # 分成左子树和右子树判断\n\n    def isMirror(self, p, q):                        # 判断两棵树是否是镜像树\n        if not p and not q:                          # 根节点都为空，是\n            return True\n        if not p or not q:                           # 其中有一棵为空，不是\n            return False\n        l = self.isMirror(p.left, q.right)           # p的左子树和q的右子树是否相同\n        r = self.isMirror(p.right, q.left)           # p的右子树和q的左子树是否相同\n        return p.val == q.val and l and r  \n\n作者：yi-xi-4\n链接：https://leetcode-cn.com/problems/two-sum/solution/pythondi-gui-he-dui-lie-shi-xian-dui-cheng-er-ch-2/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><p><b>今天这位大佬的代码解释的很详细，剩下的是需要我去思考的，去理解这段代码的思路。</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74612421", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 3, 
            "title": "LeetCode刷题——第二十一天（python）", 
            "content": "<p>早上来了听着Micheal的经典曲目，好久没听了，还是很好听，所以就找了一张他的壁纸。</p><p>对于二叉树，听着熟悉，但是做起来却不知道从何下手——<b>相同的树</b></p><h2>第二十天——第二十题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/same-tree/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">相同的树</a>）</h2><p><b>看题目！</b></p><p>给定两个二叉树，编写一个函数来检验它们是否相同。</p><p>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入:       1         1\n          / \\       / \\\n         2   3     2   3\n        [1,2,3],   [1,2,3]\n输出: true</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入:      1          1\n          /           \\\n         2             2\n        [1,2],     [1,null,2]\n输出: false</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入:       1         1\n          / \\       / \\\n         2   1     1   2\n        [1,2,1],   [1,1,2]\n输出: false</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:\n        def preorder(root):\n            if not root:\n                return [None]\n            else:\n                return [root.val] +preorder(root.left)+preorder(root.right)\n        return preorder(p)==preorder(q)\n\n作者：pandawakaka\n链接：https://leetcode-cn.com/problems/two-sum/solution/xiang-tong-de-shu-python3xian-xu-bian-li-by-pandaw/\n来源：力扣（LeetCode）</code></pre></div><p><b>代码解释：</b></p><p><b>这位大哥的代码写的好呀，简单明了，思路清晰，佩服，佩服。</b></p><p>1.先判断输入为空的情况，若根节点为空，则直接返回None.</p><p>2.当输入不为空时，将二叉树返回为：数组，也就是根节点+左侧子节点+右侧子节点。</p><p>3.最后将两个二叉树导入到定义好的preorder函数中，比较两个二叉树形成的数组是否相等，相等返回True,不等返回：False</p><p><b>新的一周，新的任务，加油</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74533404", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第二十天（python）", 
            "content": "<p>今天是补发啦，一到周末的就偷懒，不过今天的题目十分简单，也算是小题怡情吧——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-sorted-array/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">合并两个有序数组</a></p><h2>第二十天——第二十题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除排序链表中的重复元素</a>）</h2><p><b>看题目！</b></p><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p>说明:</p><p>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</p><p>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入:\nnums1 = [1,2,3,0,0,0], m = 3\nnums2 = [2,5,6],       n = 3\n\n输出: [1,2,2,3,5,6]</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        &#34;&#34;&#34;\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        &#34;&#34;&#34;\n        nums1[:] = sorted(nums1[:m] + nums2)</code></pre></div><p><b>代码解释：</b></p><p><b>nums2合并到nums1之前，将nums1中的元素（有m个元素），加nums2后再排序即可得到结果。</b></p><p><b>周末愉快哟~</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74359921", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十九天（python）", 
            "content": "<p>今天再一次遇到链表了——删除排序链表的重复值</p><h2>第十九天——第十九题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除排序链表中的重复元素</a>）</h2><p>给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;1-&gt;2\n输出: 1-&gt;2</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3\n输出: 1-&gt;2-&gt;3</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def deleteDuplicates(self, head):\n        &#34;&#34;&#34;\n        :type head: ListNode\n        :rtype: ListNode\n        &#34;&#34;&#34;\n        if head == None or head.next== None:\n            return head        \n        p = head\n        target = p.val\n        while True:\n                \n            if p.next.val == target:\n                p.next = p.next.next                \n            else:\n                target =p.next.val\n                p = p.next\n                \n            if p.next is None:\n                break\n                \n        return head</code></pre></div><p><b>代码解释：</b></p><p>1.在链表的下一个值不为空时，正常进行循环中的语句，当链表下一个值为空时，跳出循环，返回结果。</p><p>其他的地方还有好多不明白，为什么while中的对象是p,最后循环完了以后也没有重新把p赋值给head,就可以输出结果，这道题超出了在下的能力范围，看了好久还是不太明白，希望有缘人可以拿一个示例进行讲解一下~</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "美利坚搅拌机", 
                    "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                    "content": "输出的结果是链表的头head，而执行完代码后p的位置在链表的尾部，如果你输出的是p的话，通过p你无法找到前驱，因为单链表只有一个next指针", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>就是说只要返回了表头，就像牵住了牛的鼻环儿，后边的值也就都能指出来了，所以才叫链表，对吧</p>", 
                            "likes": 0, 
                            "replyToAuthor": "美利坚搅拌机"
                        }, 
                        {
                            "userName": "美利坚搅拌机", 
                            "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                            "content": "对的，就是因为这样，才导致了链表的查找比数组慢，因为每次只能从头部往尾部去查找", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>确实输出p就是最后一个数，看来我得特地的再了解一下链表的具体内容了，谢谢</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74203024", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十八天（python）", 
            "content": "<p>今天要——爬楼梯了，也是第一次了解了——动态规划是干什么的！</p><h2>十八天——第十八题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/climbing-stairs/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 爬楼梯</a>）</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1e62c05da1943af778626fab3fdeb94b_b.jpg\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb\" width=\"821\" data-original=\"https://pic4.zhimg.com/v2-1e62c05da1943af778626fab3fdeb94b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;821&#39; height=&#39;216&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"216\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"821\" data-original=\"https://pic4.zhimg.com/v2-1e62c05da1943af778626fab3fdeb94b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1e62c05da1943af778626fab3fdeb94b_b.jpg\"/><figcaption>图片来源于——百度百科</figcaption></figure><p><b>看题目！</b></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><p><b>示例 1：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶</code></pre></div><p><b>示例 2：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/climbing-stairs\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">爬楼梯 - 力扣（LeetCode）</a></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> class Solution:\n    # dp[i] = dp[i-1]+dp[i-2]\n    def climbStairs(self, n: int) -&gt; int:\n        dp = []\n        dp.append(1) # 初始状态，只有1阶的时候有一种走法\n        dp.append(2) # 有2阶的时候有两种走法\n        if n==1:\n            return 1\n        if n==2:\n            return 2\n        for i in range(2,n):\n            dp.append(dp[i-1]+dp[i-2])\n            \n        return dp[-1]</code></pre></div><p><b>代码解释：</b></p><p>1.动态规划的核心思路就是由子任务推出最后的结果，这段代码首先得到n=1,2时每种情况有多少中方法，然后在此基础上计算n&gt;=3时对应的值。</p><p>2.定义了列表dp=[]，将n=1,2对应的值放入列表中，再往下计算，最后结果输出列表的最后一个值<b>（值的意思就是多少种走法）</b>即为所求值。</p><p>3.可以举例尝试一下：n=3时需要，n=1和n=2时的值，n=4时，需要n=3和n=2时的值，</p><p>也就是说知道n的前两个数对应的值，他们之和就是当前n的值。</p><h2>还有一点疑问就是：dp[i] = dp[i-1]+dp[i-2]，这样的等式时属于大家都知道的规律性等式呢，还是人家自己想的思路，然后写出来的。</h2>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74046625", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十七天（python）", 
            "content": "<p>今天的题目是——求x的平方根，我越来越发现好多看似题目简单的，做起来往往比较复杂~</p><h2>十七天——第十七题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/sqrtx/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> x 的平方根</a>）</h2><p><b>看题目！</b></p><p>实现 int sqrt(int x) 函数。</p><p>计算并返回 x 的平方根，其中 x 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 4\n输出: 2</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 8\n输出: 2</code></pre></div><p>说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def mySqrt(self, x):\n        &#34;&#34;&#34;\n        :type x: int\n        :rtype: int\n        &#34;&#34;&#34;\n         # 为了照顾到 0 把左边界设置为 0\n        left = 0\n        # 为了照顾到 1 把右边界设置为 x // 2 + 1\n        right = x // 2+1 \n        while left &lt; right:\n            # 注意：这里一定取右中位数，如果取左中位数，代码可能会进入死循环\n            # mid = left + (right - left + 1) // 2\n            mid = (left + right + 1) &gt;&gt; 1\n            square = mid * mid\n\n            if square &gt; x:\n                right = mid - 1\n            else:\n                left = mid\n        # 因为一定存在，因此无需后处理\n        return left</code></pre></div><p><b>代码疑问：</b></p><p>很多时候我希望为大家解释代码，但往往会遇到许多有疑问的地方，这个题目的难点在于对开根号原理的理解，这个代码的思路真的是我难以匹及的高度，没有看之前是我怎么都想不到的，所以经历了以后希望自己能掌握，也算是一种成长。</p><p>1..先定义了左右两个界限：left = 0,right = x // 2+1 ,结果出自这个范围中。</p><p>2.题目中说为了照顾1，把right = x // 2，写成了right = x // 2+1，这样x=1时，输出结果就不会是0，而是1了。</p><p>3.开始进入循环，求出两个边界的右中位数来，求中位数的平方，</p><p><b>4.只要平方值不大于输入值，中位数就为所求值，如果大于输入值，中位数-1赋值给右边再一次进行循环，如果不满足循环条件了，输出最后一次的left值。</b></p><p><b>代码谁都能看懂，但是自己能不能想清楚就是关键了，就第四点这一块儿，他的依据是什么，就是说人家怎么想到这么写的，我就很好奇。</b></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "美利坚搅拌机", 
                    "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                    "content": "判断的时候最好写成 mid &lt; x / mid， 如果使用mid * mid碰到大数会overflow（尽管python会自动变成long不会溢出），算是个好习惯吧～", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>好的，谢谢指导</p><a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-ba306425d0a7aee2c7260381f1bf7b97.gif\" data-width=\"\" data-height=\"\">[欢呼]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "美利坚搅拌机"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73904393", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十六天（python）", 
            "content": "<p>今天的题目是一个——<b>二进制求和</b>，好熟悉的字眼，这道题可以用内置函数解决，简单明了，快捷方便，也可以手动进行。</p><h2>十六天——第十六题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/add-binary/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二进制求和</a>）</h2><p><b>看题目！</b></p><p>给定两个二进制字符串，返回他们的和（用二进制表示）。</p><p>输入为<b>非空</b>字符串且只包含数字 <code>1</code> 和 <code>0</code>。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: a = &#34;11&#34;, b = &#34;1&#34;\n输出: &#34;100&#34;</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: a = &#34;1010&#34;, b = &#34;1011&#34;\n输出: &#34;10101&#34;</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def addBinary(self, a, b):\n        &#34;&#34;&#34;\n        :type a: str\n        :type b: str\n        :rtype: str\n        &#34;&#34;&#34;\n        return bin(int(a, 2) + int(b, 2))[2:]</code></pre></div><p><b>代码解答：</b>就这一句： return bin(int(a, 2) + int(b, 2))[2:]，利用int将二进制数转成整型</p><p>相加后利用bin表达为二进制数，bin表达出时是ob100，所以要从[2:]的位置开始显示结果。</p><p><b>非内置函数如下：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def addBinary(self, a: str, b: str) -&gt; str:\n        r, p = &#39;&#39;, 0\n        d = len(b) - len(a)\n        a = &#39;0&#39; * d + a\n        b = &#39;0&#39; * -d + b\n        for i, j in zip(a[::-1], b[::-1]):\n            s = int(i) + int(j) + p\n            r = str(s % 2) + r\n            p = s // 2\n        return &#39;1&#39; + r if p else r\n\n作者：QQqun902025048\n链接：https://leetcode-cn.com/problems/two-sum/solution/python-1xing-nei-zhi-han-shu-fei-nei-zhi-jie-fa-by/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre></div><p>这段代码是看一位大佬写的，鄙人还有点看不太懂，明天再好好瞅瞅~</p><p>两句废话：不是自己的电脑，今天上的壁纸和以往的风格不一样哈，哈哈</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73734751", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第十五天（python）", 
            "content": "<p>今天是周一，时刻提醒自己今天是工作日，作为一个学生，虽然已经放假了但是年纪已经不允许我再放纵了，同意的同学可以——<b>加一</b></p><h2>第十五天——第十五题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/plus-one/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 加一</a>）</h2><p><b>看题目！</b></p><p>给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储一个数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,2,3]\n输出: [1,2,4]\n解释: 输入数组表示数字 123。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [4,3,2,1]\n输出: [4,3,2,2]\n解释: 输入数组表示数字 4321。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def plusOne(self, digits):\n        &#34;&#34;&#34;\n        :type digits: List[int]\n        :rtype: List[int]\n        &#34;&#34;&#34;\n        for i in range(len(digits)):\n            if digits[-1 - i] == 9:\n                digits[-1 - i] = 0\n                if -1-i == -len(digits):\n                    digits[-1 - i] = 1\n                    digits.append(0)\n                    return digits\n            else:\n                digits[-1 - i] += 1\n                return digits\n</code></pre></div><p><b>代码解释：</b></p><p>1.倒序遍历，如果9在列表的最后一位，就把9变成1，同时还要在列表中加个0.</p><p>我理解的就是在原列表的基础上再加一个0，意味着列表的长度[1,2,3,4,5,6,7,8,9]就变成了[1,2,3,4,5,6,7,9,0],<b>这个位置我就不明白了，为什么不是加个零呢？</b></p><p>2.如果列表中不存在9的话，那就直接在最后一位值的基础上加1就可以了。<b>那他为什么不写成digits[len(digits)-1]+=1?</b></p><p>脑子有点乱，可能又把题理解错了，明天再看看吧！</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": [
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "又看了看，还是没有仔细读懂题目，以为是个单纯的数组，懵懵懂懂的就下手了，仔细看题目，就是一个数，用数组的每个元素代表这个数的每个数位上的值。该加一加一，该进一进一。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "彻底明白了！", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }, 
                {
                    "userName": "美利坚搅拌机", 
                    "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                    "content": "个人觉得同类型的题放在一起刷会比较有助于加深理解", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>我是按照LeetCode题库中简单程度的题一个一个刷的</p><a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-ba306425d0a7aee2c7260381f1bf7b97.gif\" data-width=\"\" data-height=\"\">[欢呼]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "美利坚搅拌机"
                        }
                    ]
                }, 
                {
                    "userName": "杨刚", 
                    "userLink": "https://www.zhihu.com/people/397a107f069e0269eb9b15006a173a56", 
                    "content": "<p>你可以把一个列表的数字变成Int,然后加1，然后再转成列表</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>这个是比较简单粗暴的，哈哈</p>", 
                            "likes": 0, 
                            "replyToAuthor": "杨刚"
                        }, 
                        {
                            "userName": "修行生", 
                            "userLink": "https://www.zhihu.com/people/62f115fb9a738adf7df3ccb7ed8f1f46", 
                            "content": "数组长度可能会大于int甚至long的储存位数吧，会不会无法转化，Java的BigInteger倒是可以，Python我不是很清楚", 
                            "likes": 0, 
                            "replyToAuthor": "杨刚"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73632165", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十四天（python）", 
            "content": "<p>如今已经进入假期，但是这一年又是没有假期，2017年考研的那个暑假也是在学校学习，转眼间已经两年了，昨天是周日，在家里待着待着就忘了更新了今天补上一个——<b>最后一个单词的长度</b></p><h2>第十四天——第十四题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/length-of-last-word/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">最后一个单词的长度</a>）</h2><p><b>看题目！</b></p><p>给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串，返回其最后一个单词的长度。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指由字母组成，但不包含任何空格的字符串。</p><p><b>示例:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;Hello World&#34;\n输出: 5</code></pre></div><p>来源：力扣（LeetCode）</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def lengthOfLastWord(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: int\n        &#34;&#34;&#34;\n        if s==&#39;&#39;:\n            ans=0\n        elif s.isspace():\n            ans=0\n        else:\n            s=s.split()\n            ans=len(s[-1])\n        return ans</code></pre></div><p><b>代码解释：</b></p><p>1.先考虑了当输入为空字符串或者是只包含空格，结果为0.（isspace()的意思就是判断字符串中是否是只由空格组成，是！返回True,不是！返回False）</p><p>2.如果以上两种情况都不是，则将字符串根据空格的位置，分割字符串形成新的列表(split的功能），然后输出列表的最后一个值的长度就可以了。</p><p>3.最后返回结果</p><p><b>今天是2019年7月15日，去年的暑假去实习是在5月21日开始的，算起来都实习了一个多月了这个时间。而今年的这个日子是暑假开始的第一天吧。</b></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73475462", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 4, 
            "title": "LeetCode刷题——第十三天（python）", 
            "content": "<p>今天读的这个题干真是有点费劲，也是厉害了，总觉得这种题是非正常人的思路才会出的题，真的想清楚就得一会儿，一看题目——报数，还以为挺简单的。</p><h2>第十三天——第十三题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/count-and-say/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">报数</a>）</h2><p><b>看题目!</b></p><p>报数序列是一个整数序列，按照其中的整数的顺序进行报数，得到下一个数。其前五项如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">1.     1\n2.     11\n3.     21\n4.     1211\n5.     111221</code></pre></div><p>_____</p><div class=\"highlight\"><pre><code class=\"language-text\">1 被读作  &#34;one 1&#34;  (&#34;一个一&#34;) , 即 11。\n11 被读作 &#34;two 1s&#34; (&#34;两个一&#34;）, 即 21。\n21 被读作 &#34;one 2&#34;,  &#34;one 1&#34; （&#34;一个二&#34; ,  &#34;一个一&#34;) , 即 1211。\n给定一个正整数 n（1 ≤ n ≤ 30），输出报数序列的第 n 项。\n注意：整数顺序将表示为一个字符串。</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def countAndSay(self, n):\n        &#34;&#34;&#34;\n        :type n: int\n        :rtype: str\n        &#34;&#34;&#34;\n        def next_num(tmp):\n            res = &#34;&#34;\n            i = 0\n            tmp_n = len(tmp)\n            while i &lt; tmp_n:\n                count = 1\n                while i &lt; tmp_n - 1 and tmp[i] == tmp[i+1]:\n                    count += 1\n                    i += 1\n                res += (str(count) + tmp[i])\n                i += 1\n            return res\n        res = &#34;1&#34;\n        for i in range(1, n):\n            res = next_num(res)\n        return res\n</code></pre></div><p><b>代码疑问：</b></p><p>1.今天这个题好挫败，代码好几处带看不太懂，关键是人家的思路是什么样的还是不太明白。</p><p>2.res就是最后要返回的结果，也就是这个字符串类型的数字，tmp是什么，我不太肯定，应该就是下一个数的内容吧，这一个希望大家可以说一下。</p><p>3.然后就是下边这些代码，都是迷迷糊糊的，还得花时间好好琢磨一下。</p><p><b>今天抱歉了，没整明白~祝大家晚安</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73373977", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第十二天（python）", 
            "content": "<p>今天很不幸的被锁在了实验室外边，电脑也没拿出来，只能借朋友的电脑来写了~壁纸为：彼得兔，很适合和小朋友或者女朋友一起看。</p><h2>第十二天——第十二题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/search-insert-position/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> 搜索插入位置</a>）</h2><p>看题目！</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,3,5,6], 5\n输出: 2</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,3,5,6], 2\n输出: 1</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [1,3,5,6], 7\n输出: 4</code></pre></div><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution:\n    def searchInsert(self, nums: List[int], target: int) -&gt; int:\n        for i in range(len(nums)):\n            if nums[i] &gt;= target:\n                return i\n        return i + 1\n</code></pre></div><p><b>代码解答：</b></p><p>1.用列表中的元素和目标元素逐个比较，大于或者等于的时候就返回当前索引，即输出。</p><p>2.如果列表中的所有元素都小于目标元素，就把目标元素放到列表的最后一个位置还往后一个位置。意思是举例：本来列表有0，1，2，3，四个索引，那么这个目标元素就要放在第4个索引上，因为列表中没有索引4.所以就要i+1,即 return i+1。</p><p><b>祝大家周末愉快~</b></p><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73205393", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十一天（python）", 
            "content": "<p>今天的这个题可以调用库，然后就成了，不过我们还是厚道点，用一个手动的方式去实现——strStr()</p><h2>第十一天——第十一题（实现 <a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/strstr/811469\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">strStr()</a> 函数）</h2><p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: haystack = &#34;hello&#34;, needle = &#34;ll&#34;\n输出: 2</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: haystack = &#34;aaaaa&#34;, needle = &#34;bba&#34;\n输出: -1</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/implement-strstr\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">实现strStr() - 力扣（LeetCode）</a></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def strStr(self, haystack, needle):\n        &#34;&#34;&#34;\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        &#34;&#34;&#34;\n        for i in range(0, len(haystack) - len(needle) + 1):\n \t        if haystack[i:i+len(needle)] == needle:\n \t            return i\n     \treturn -1</code></pre></div><p><b>代码解释：</b></p><p>1.这个代码的思路好清晰呀，遍历的范围是（0, len(haystack) - len(needle) + 1），这个范围可以这样想——列如：&#34;hello&#34;这个单词，有5个字母，&#34;ll&#34;有两个字母，如果有一个指针从0索引的位置以两个字母为步长往右移动，需要移动4次。</p><p>2.如果是“HelloWord”是10个字母，“llo”是3个字母，意味着从0索引开始以三个字母为步长往右移动，需要移动8次。</p><p>3.if语句便是在每一次移动的时候都要和目标字符串进行对比，如果匹配就可以输出结果了，不匹配就返回-1.</p><p>4.没了</p><p><b>今天想说，刚刚补了牙，感觉好别扭呀~平时还是要好好刷牙，保护好自己的牙齿~</b></p><p></p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "自学编程", 
                    "tagLink": "https://api.zhihu.com/topics/19642932"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73048719", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第十天（python）", 
            "content": "<p>今天又遇到了一个和昨天差不多的题——移动元素，看着挺简单的，题干说的也很清楚，但真正做起来就没那么简单了~</p><h2>第十天——第十题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-element/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">移除元素</a>）</h2><p><b>看题目！</b></p><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">给定 nums = [3,2,2,3], val = 3,\n函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。\n你不需要考虑数组中超出新长度后面的元素。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">给定 nums = [0,1,2,2,3,0,4,2], val = 2,\n函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。\n注意这五个元素可为任意顺序。\n你不需要考虑数组中超出新长度后面的元素。</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-element\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">移除元素 - 力扣（LeetCode）</a></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def removeElement(self, nums, val):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :type val: int\n        :rtype: int\n        &#34;&#34;&#34;\n        idx = 0\n        for i in range(len(nums)):\n            if nums[i] != val:\n                nums[idx] = nums[i]\n                idx += 1\n        return idx</code></pre></div><p><b>代码疑问：</b></p><p><b>1.这个代码还是没看懂。。。</b></p><p><b>2.为什么只考虑了不等于的情况，那等于的情况怎么说。</b></p><p><b>3.昨天题干上就有一个“说明”，今天又有，昨天没注意，今天发现真是返回了：idx,但输出的却是一个列表，虽然说明了，但是感觉还是有点蒙。</b></p><h2>说明:</h2><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。\nfor (int i = 0; i &lt; len; i++) {\n    print(nums[i]);\n}</code></pre></div><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": [
                {
                    "userName": "小兔子", 
                    "userLink": "https://www.zhihu.com/people/4cb7cc45be788edd3948e7a062415817", 
                    "content": "双指针，把i,和idx想像成指针，当不等于val时，都移动一个位置，当等于val时，idx不移动。这样这样val+1的值就是不等于val值的个数。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>哦哦，最终得到个数就行了是吧，这个val+1，应该是idx+1吧</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72893600", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 4, 
            "title": "LeetCode刷题——第九天（python）", 
            "content": "<p>今天的题很小个，一段代码就能解决了，不过这一段代码也提供了一个很厉害的思路，我觉得以后肯定还会经常遇到，那就是——<b>逆序遍历</b></p><h2>第九天——第九题（<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除排序数组中的重复项</a>）</h2><p><b>看题目！</b></p><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">给定数组 nums = [1,1,2], \n函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 \n你不需要考虑数组中超出新长度后面的元素。</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">给定 nums = [0,0,1,1,1,2,2,3,3,4],\n函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。\n你不需要考虑数组中超出新长度后面的元素。</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/remove-duplicates-from-sorted-array\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">删除排序数组中的重复项 - 力扣（LeetCode）</a></p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def removeDuplicates(self, nums):\n        &#34;&#34;&#34;\n        :type nums: List[int]\n        :rtype: int\n        &#34;&#34;&#34;\n        for i in range(len(nums)-1, 0, -1):\n            if nums[i] == nums[i-1]: nums.pop(i)\n        return len(nums)</code></pre></div><p><b>代码解释：</b></p><p>1.本人开始用的是正序遍历结果是索引超出范围。然后-了题解，看了好多答案，上边的这个答案看起来更简单一些。</p><p>2.利用逆序遍历的方式，避免了索引超出范围的情况发生。</p><p>3.顺便说一下range（len(nums)-1,0,-1)这个是怎么回事，既然大家都是小白，我觉得还是讲一下比较友好。</p><p>假设len(nums)=10,上边range()就是<b>range（9,0，-1）</b>，<b>简单点说：前两个参数是从几到几，第三个参数就是步长。</b>步长的位置是<b>-1</b>代表着需要<b>逆序输出</b>，对于下边这个for循环——</p><div class=\"highlight\"><pre><code class=\"language-text\">for i in range(len(nums)-1, 0, -1):</code></pre></div><p>把遍历的i放在列表里就是[9, 8, 7, 6, 5, 4, 3, 2, 1]，为什么不是从9到0而是到1呢，因为range不包含end,就是最后一个值。就是这样就避免了索引超范围的情况。</p><p>4.然后就执行：</p><div class=\"highlight\"><pre><code class=\"language-text\">if nums[i] == nums[i-1]: nums.pop(i)</code></pre></div><p>这个没啥说的，nums.pop()中的pop()默认是删除列表中的最后一个元素，这里也可以指定要删除元素的索引。所以这段代码就是从列表的最后一个值往第一个值的方向遍历，如果遇到相邻的两个元素相等就删除靠后的一个，等i=1时，也就没有可以遍历的了，因为最后一个i就是1，一看代码nums[i-1]，恰巧nums[0]参与了比较了，这样就大家好才是真的好，最后返回长度，Over~</p><p><b>闲话：</b>大神看了我这段清新脱俗的讲解可能会有一丝无奈，在下愚钝，现在就是抽时间一点点进步吧，还请各位多多指教，还有就是我这个人有些啰唆，以后在写文章的时候肯定会尽力的简介一点，哈哈</p><p>喜欢壁纸的朋友可以私信我哟，之前下载的，所以也没有链接，回头再下载就保存链接，直接放上来更方便~晚安</p>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": [
                {
                    "userName": "阿方", 
                    "userLink": "https://www.zhihu.com/people/81895385a3a71cddc4db81429d426f8a", 
                    "content": "你这是O(n^2)吧...", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>不太懂</p>", 
                            "likes": 0, 
                            "replyToAuthor": "阿方"
                        }, 
                        {
                            "userName": "鹏之肥", 
                            "userLink": "https://www.zhihu.com/people/2d1be3d1a0596bcecce433df4251f058", 
                            "content": "循环n，循环里pop是n，然后n^2没问题", 
                            "likes": 1, 
                            "replyToAuthor": "阿方"
                        }
                    ]
                }, 
                {
                    "userName": "wjwABCDEFG", 
                    "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                    "content": "很经典的算法题，用异或可以解决乱序的情况<a href=\"https://www.zhihu.com/question/38206659/answer/713199930\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/question/3820</span><span class=\"invisible\">6659/answer/713199930</span><span class=\"ellipsis\"></span></a>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>谢谢赐教</p>", 
                            "likes": 0, 
                            "replyToAuthor": "wjwABCDEFG"
                        }
                    ]
                }, 
                {
                    "userName": "西瓜吃完了", 
                    "userLink": "https://www.zhihu.com/people/2734be10b186202f89d801a5de4a19e2", 
                    "content": "two-pointer technique", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>双指针了解一下</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>嗯呢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "破忆断回", 
                    "userLink": "https://www.zhihu.com/people/78e98867f1e07f44d05af5ea41f2cae6", 
                    "content": "[捂脸]我都是直接上map解决", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72694697", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第8天（python）", 
            "content": "<p>今天有点挫败，这个递归就是函数中自己调用自己，感觉跟循环那么像但是又想不明白，难受。</p><h2>第八天——第八题（合并两个有序列表）</h2><p><b>看题目：</b></p><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><p>示例：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4\n输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/merge-two-sorted-lists\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">合并两个有序链表 - 力扣（LeetCode）</a></p><p><b>python解答之一（LeetCode官方解答）：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def mergeTwoLists(self, l1, l2):\n        &#34;&#34;&#34;\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        &#34;&#34;&#34;\n        if l1 is None:\n            return l2\n        elif l2 is None:\n            return l1\n        elif l1.val &lt; l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2</code></pre></div><p><b>代码解释：</b></p><p>1.先判断两种情况，l1,l2为空的情况。</p><p>2.如果都不为空，表头小的那个链表的第一个值与剩下的值做合并操作。</p><p>3.返回结果。</p><p>顺便说一下：l1.val指的是链表第一个值，l1.next指的是链表下一个值</p><p><b>疑问：</b></p><p>这个代码解释很敷衍，恕吾愚钝，这个递归是怎么递归的看了半天也没太懂，我再去看看相关的解释吧，哎，伤心......</p><p><b>附上递归的定义：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">递归的含义\n递归，就是一个函数直接或者间接调用自身的过程。如果函数A在其函数体内直接调用其自身，则称为直接递归，\n如果函数A调用函数B，而函数B又调用了函数A（或者函数B再调用其他函数，而其他函数调用函数A），则称为间接递归。\n不过，函数如果无条件的调用自身，这是没有意义的，最终也会导致超过最大递归深度而产生错误。\n因此，我们必须能够找出，让递归终止的条件。\n递归，我们可以分为递推与回归。所谓递推，就是解决问题，逐层的进行推理，得出递归的终止点。\n而回归，则是利用刚才递推取得终止点的条件，再一层层返回，最终取得答案的过程。</code></pre></div><p>希望有大神可以把这个地方的递归可以讲一讲，我看了一些递归的教程，说这个部分不能细想，容易把自己绕进去。。。我就绕进行了~</p>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": [
                {
                    "userName": "wjwABCDEFG", 
                    "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                    "content": "学到了", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72589417", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 2, 
            "title": "LeetCode刷题——第七天（python）", 
            "content": "<p>感觉自己还没怎么刷这都第七天了，确实一天一道题很少，但是从目前的情况来看，一道题自己得看好久，看好几个答案，然后不会的再查，才能弄明白，伤心~</p><h2>第七天——第七题（有效的括号）</h2><p>看题目！</p><p>给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有效字符串需满足：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>左括号必须用相同类型的右括号闭合。</p><p>左括号必须以正确的顺序闭合。</p><p>注意空字符串可被认为是有效字符串。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;()&#34;\n输出: true\n</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;()[]{}&#34;\n输出: true\n</code></pre></div><p><b>示例 3:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;(]&#34;\n输出: false</code></pre></div><p>python 解答之一（LeetCode官方解答）：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isValid(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: bool\n        &#34;&#34;&#34;          \n        stack = []\n        mapping = {&#34;)&#34;: &#34;(&#34;, &#34;}&#34;: &#34;{&#34;, &#34;]&#34;: &#34;[&#34;}\n        for char in s:\n            if char in mapping:\n                top_element = stack.pop() if stack else &#39;#&#39;\n                if mapping[char] != top_element:\n                    return False\n            else:\n                 stack.append(char)\n        return not stack</code></pre></div><p>难得LeetCode出python的官方答案，一般官方都是用java解答的，今天看了看人家的解释还是很详细的。</p><p><b>代码解释：</b></p><p>1.相比之前，现在看见题不至于一点思路都没有了，至少今天这道题我知道肯定得用到字典。</p><p>2.官方解释中用到了栈的概念，更详细的解释可以到<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/valid-parentheses/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">有效的括号 - 力扣（LeetCode）</a>这个网页的题解部分看一看。</p><p>3.代码的大致意思就是，先设定一个空的列表，然后将不同开括号和闭括号的对应关系定义出来，说到一一对应的关系，自然想到了用字典来实现。</p><p>4.遍历给定的字符串S，如果char在字典中，这个部分我不明白是说char与字典中的Key相同时算是包含关系呢，还是与values相同算是包含关系，后来我去pycharm试了试，结果是第一种，即char与key相同即包含。</p><p>5.如果包含说明此时的char是闭括号（看字典就知道了，因为所有的key都是开括号）</p><p>6.如果定义的stack列表不是空的，那么就将他最后的那个元素赋值给top_<i>element,如果是空的</i>就给top_element赋值一个“#”（这个应该就是随便赋值个符号都行）。</p><p>7.如果这个char，就是此时的闭括号对应的开括号与top_element不同，返回False.</p><p>8.另一种情况的话（也就是char是开括号，就是说char不在字典中时），就把这个char添加到这个stack列表中。</p><p>9.函数最后看如果stack为空，则返回Ture,不为空则返回False.</p><p>10.结束</p><p><b>疑惑的地方：</b></p><p><b>1.if stack else &#34;#&#34;,官方解释这段代码的时候是说，如果stack不为空则将最后一个元素（官方叫栈顶）赋值给top_element,我就奇怪为什么这里只写个stack就能表达他不为空了呢？</b></p><p><b>2.另外的就是最后的return not stack，虽然查了一下return not，但是给出的解释并不多，我理解的就是根据stack的状态返回布尔类型，即返回true or false。</b></p><h2><b>一转眼都七天了，下一个星期继续！</b></h2><p></p>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": [
                {
                    "userName": "NBplus", 
                    "userLink": "https://www.zhihu.com/people/2ddede18aea2476b82239428c59e28cb", 
                    "content": "加油，算法功底有待提高[飙泪笑]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "谢谢，实不相瞒我是周杰伦十几年的粉丝", 
                            "likes": 0, 
                            "replyToAuthor": "NBplus"
                        }, 
                        {
                            "userName": "wjwABCDEFG", 
                            "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                            "content": "实不相瞒周杰伦湛江演唱会我已经买好门票[赞同]", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72525048", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 3, 
            "title": "LeetCode刷题——第六天（python）", 
            "content": "<p>今天是周六，真是罪恶的一天，没在学校，一下子就把这码事儿忘了，还好今天还没结束，看看今天的题吧。</p><h2>第六天——第六题（最长公共前缀）</h2><p><b>看题目！</b></p><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&#34;&#34;</code>。</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [&#34;flower&#34;,&#34;flow&#34;,&#34;flight&#34;]\n输出: &#34;fl&#34;</code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: [&#34;dog&#34;,&#34;racecar&#34;,&#34;car&#34;]\n输出: &#34;&#34;\n解释: 输入不存在公共前缀。</code></pre></div><p><b>说明:</b></p><p>所有输入只包含小写字母 <code>a-z</code> 。</p><p><b>python解答之一：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def longestCommonPrefix(self, strs):\n        &#34;&#34;&#34;\n        :type strs: List[str]\n        :rtype: str\n        &#34;&#34;&#34;\n        res = &#34;&#34;\n        for tmp in zip(*strs):\n            tmp_set = set(tmp)\n            if len(tmp_set) == 1:\n                res += tmp[0]\n            else:\n                break\n        return res</code></pre></div><p>代码解答：</p><p>1.取每一个单词的同一位置的字母，看是否相同。</p><p>今天的代码主要的点就在<b>zip(*strs)</b>这个位置，上边的方法是在解答区看到一个大佬用多种思路解答中的第一种思路，自己看了看没太看明白，因为<b>zip(*strs)</b>我去查了一下，还是没太明白，时间不早了，明天再把这个部分好好看看。</p><p>我就喜欢每天有这种之前没怎么见过的方法，通过做这道题最后明白了<b>zip(*strs)</b>，收获也是很大的，毕竟万事都抵不过日积月累嘛。今天太罪恶了，差一点就忘记了。。。还算幸运。。。</p><h2>祝大家晚安~</h2>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72390235", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题——第五天（python）", 
            "content": "<p>今天的题目是：罗马数字转整数，一眼看下去没太多思路。</p><h2>第五天——第五题（罗马数字转整数）</h2><p>看题目！</p><p>罗马数字包含以下七种字符: <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><div class=\"highlight\"><pre><code class=\"language-text\">字符          数值\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/roman-to-integer</code></pre></div><p>————</p><div class=\"highlight\"><pre><code class=\"language-text\">例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。\n\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，\n例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。\n同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。</code></pre></div><p>示例1：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;III&#34;\n输出: 3</code></pre></div><p>示例2：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;IV&#34;\n输出: 4</code></pre></div><p>示例3：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: &#34;IX&#34;\n输出: 9</code></pre></div><p>python解答之一（超级佩服的一个解答）：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def romanToInt(self, s):\n        &#34;&#34;&#34;\n        :type s: str\n        :rtype: int\n        &#34;&#34;&#34;\n        d = {&#39;I&#39;:1, &#39;IV&#39;:3, &#39;V&#39;:5, &#39;IX&#39;:8, &#39;X&#39;:10, &#39;XL&#39;:30, &#39;L&#39;:50, &#39;XC&#39;:80, &#39;C&#39;:100, &#39;CD&#39;:300, &#39;D&#39;:500, &#39;CM&#39;:800, &#39;M&#39;:1000}\n        return sum(d.get(s[max(i-1, 0):i+1], d[n]) for i, n in enumerate(s))</code></pre></div><p>我自己在pycharm上墨迹了半天，这种尝试写的长长的但还是运行不出来，去解答区逛了逛看到这这位大哥的操作。</p><p>两行代码直截了当，真是“指如疾风，势如闪电”，不禁让我想起了葵花点穴手，在传说中的盗圣面前，我就是莫小贝。。。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9ec041e3e41ae3ebb6488e1217b9ba32_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb\" width=\"644\" data-original=\"https://pic3.zhimg.com/v2-9ec041e3e41ae3ebb6488e1217b9ba32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;644&#39; height=&#39;565&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"644\" data-original=\"https://pic3.zhimg.com/v2-9ec041e3e41ae3ebb6488e1217b9ba32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9ec041e3e41ae3ebb6488e1217b9ba32_b.jpg\"/></figure><p>代码解答：</p><p>1.首先这位大哥想到用字典用将每个罗马符号与整数对应起来，这一步虽然简单而且在很多让眼里看来是自然而然的，但是对于小白的我来说，还是让我有一种恍然大悟的感觉，因为我一开始是一个一个的赋值，有点沙雕。</p><p>2.然后又用了一个列表推导式直接得出结果，我觉得挺强的，能用这两行代码就实现了。</p><p>3.但是第二行代码看着费劲，看了好一会儿才整明白。还得消化一下。</p><h2>今天晚上雷阵雨，爽歪歪~</h2>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": [
                {
                    "userName": "小狗", 
                    "userLink": "https://www.zhihu.com/people/e02aa6aa5ca88c20f2e247c97698f264", 
                    "content": "刷力扣在一遍遍错错错后进步的确还挺大的", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "主要是对于小白水平的我能找到可以上手的题", 
                            "likes": 0, 
                            "replyToAuthor": "小狗"
                        }
                    ]
                }, 
                {
                    "userName": "天涯过客", 
                    "userLink": "https://www.zhihu.com/people/3f81c75bf36843efc89eaa2550f7f54c", 
                    "content": "写错了，iv是4", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>大意了啦</p>", 
                            "likes": 0, 
                            "replyToAuthor": "天涯过客"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72207951", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 4, 
            "title": "LeetCode刷题——第四天（python）", 
            "content": "<p>每天选壁纸做封面这个环节是我最喜欢的，今天的题目是比较经典又十分简单的一道题。</p><h2>第四天——第四题（回文数）</h2><p>请看题：判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><p>示例1：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 121\n输出: true</code></pre></div><p>示例2：</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: -121\n输出: false\n解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</code></pre></div><p>示例3</p><div class=\"highlight\"><pre><code class=\"language-text\">输入: 10\n输出: false\n解释: 从右向左读, 为 01 。因此它不是一个回文数。</code></pre></div><p>python解答之一：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def isPalindrome(self, x):\n        &#34;&#34;&#34;\n        :type x: int\n        :rtype: bool\n        &#34;&#34;&#34;\n        if x&lt;0:\n            return False\n        if x&gt;=0:\n            str_x=str(x)\n            if  str_x[::]==str_x[::-1]:\n                return True\n            else:\n                return False</code></pre></div><p>解题思路：</p><p><i>1.首先判断数字的正负，因为题里边说了带负号的话就不是回文数了，所以首先排除带负号的数字。</i></p><p><i>2.然后按照昨天题目的思路，先将整数类型的数据转换成字符串类型的数据。</i></p><p><i>3.如果反转之前的数字（字符串类型）和反转之后的数字（字符串类型）相同，则返回为True,否则则为False。</i></p><p>今天的题真的很友好，值得高兴的是自己写了一下，一次过，很成功。</p><p>看来多少还有点收获，每天花上15分钟写一下这个来督促自己，比较有这么多大佬看着呢，还请大家多多指教。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": [
                {
                    "userName": "李叶", 
                    "userLink": "https://www.zhihu.com/people/482e97e729f4f6dd59074af2e80b2ddf", 
                    "content": "<p>            if  str_x[::]==str_x[::-1]:<br>                return True<br>            else:<br>                return False</p><p>这一段直接 return str_x[::]==str_x[::-1]就行了😂</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>我去试试</p>", 
                            "likes": 0, 
                            "replyToAuthor": "李叶"
                        }
                    ]
                }, 
                {
                    "userName": "wjwABCDEFG", 
                    "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                    "content": "我最近也开始做，目前做了10道，请问答主每天都有更新吗？可以一起学吗？<a href=\"https://pic4.zhimg.com/v2-db92f653a2ec17ea3ff309d6d56e8507.gif\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"980770591112015872\">[吃瓜]</a>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>每天都会更新，一起学习，自己还是小白，希望以后可以互相学习呢</p><a class=\"comment_sticker\" href=\"https://pic3.zhimg.com/v2-cb8443f07a41298e45191cef11b90fd2.gif\" data-width=\"\" data-height=\"\">[干杯]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "wjwABCDEFG"
                        }, 
                        {
                            "userName": "wjwABCDEFG", 
                            "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                            "content": "<p>晚了一天 没看到私信 我私信你了</p><p>附上int类型解法（应该是题目想让我们做的解法）</p><p>// java </p><p>class Solution {<br>    public boolean isPalindrome(int x) {<br>        if(x == 0) return true;<br>        if(x &lt; 0 || x % 10 == 0) return false;<br>        int yu = 0, zheng = x, new_x = 0;<br>        while(zheng != 0)<br>        {<br>            yu = zheng % 10;<br>            zheng = zheng / 10;<br>            new_x = new_x * 10 + yu;<br>        }<br>        return new_x == x;<br>    }<br>}</p><p><br></p><p>顺便改成了python</p><p>class Solution:<br>    def isPalindrome(self, x: int) -&gt; bool:<br>        if(x == 0):<br>            return True;<br>        if(x &lt; 0 or x % 10 == 0):<br>            return False;<br>        yu = 0<br>        zheng = x<br>        new_x = 0<br>        while(zheng != 0):<br>            yu = zheng % 10<br>            zheng = zheng // 10<br>            new_x = new_x * 10 + yu<br>        return new_x == x;</p>", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }, 
                {
                    "userName": "凌少琨", 
                    "userLink": "https://www.zhihu.com/people/af30b5f2ef09b482077e9668586a458c", 
                    "content": "能分享一下封面吗[可怜]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "董大佬", 
                    "userLink": "https://www.zhihu.com/people/633196694d08e89faa817a94e0e1cdd3", 
                    "content": "来来来加好友。一起学习", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>好，或者建一个微信群今天我把二维码放在今天的更新里</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "董大佬", 
                            "userLink": "https://www.zhihu.com/people/633196694d08e89faa817a94e0e1cdd3", 
                            "content": "没看到私信啊，你建个微信群吧<br>我微信号：961006487", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }, 
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>OK</p><p></p>", 
                            "likes": 0, 
                            "replyToAuthor": "董大佬"
                        }
                    ]
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>私信给你了哦</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>主要是python，这个我还得好好看看，周末自己都懈怠了，哈哈</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72088609", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 1, 
            "title": "LeetCode刷题——第一天（python）", 
            "content": "<p>今天是7月1日的晚上，作为研一小白，接下来的一段时间里希望自己每天都可以在LeetCode上刷几道题，这个平台也是我寻寻觅觅多个刷题平台后，相比较下来更适合我的一个编程实践平台。题量多，题目简单，阶梯训练，相信我坚持刷下去，编程能力多少会有所提高。</p><p>今天只做了一道题，因为外边快要下雨了，抓紧时间写一下就准备回家。。。。。。</p><h2>第一天——第一题（两数之和）</h2><p>题目：给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素</p><p>示例:</p><div class=\"highlight\"><pre><code class=\"language-text\">给定 nums = [2, 7, 11, 15], target = 9\n\n因为 nums[0] + nums[1] = 2 + 7 = 9\n\n所以返回 [0, 1</code></pre></div><p>来源：力扣（LeetCode）</p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/two-sum\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">两数之和 - 力扣（LeetCode）</a></p><p>正确解答之一（python）：</p><div class=\"highlight\"><pre><code class=\"language-text\">def day1(nums, target):\n        size = len(nums)\n        for i, m in enumerate(nums):\n            j = i + 1\n            while j &lt; size:\n                if target == (m + nums[j]):\n                    return [i, j]\n                else:\n                    j += 1</code></pre></div><p>这个代码是自己写了半天都不对，然后在题解里找到的，相对来说比较简单的一个，看着很简单，但是思路没跟上也是写不出来的，所以以后还是要多练习培养编程思想。</p><p>仔细想想这个代码的内容，就是遍历的第一个m与m之后的元素逐个相加，知道输出目标值。</p><p>万事开头难，今天第一天刷题，第一次写知乎，以后慢慢来，送自己一句话吧！</p><h2>不积跬步，无以至千里；不积小流，无以成江海！</h2>", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": [
                {
                    "userName": "阿方", 
                    "userLink": "https://www.zhihu.com/people/81895385a3a71cddc4db81429d426f8a", 
                    "content": "写这个答案这道题相当于白做了", 
                    "likes": 2, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "<p>还请大佬多多指教</p>", 
                            "likes": 0, 
                            "replyToAuthor": "阿方"
                        }, 
                        {
                            "userName": "阿方", 
                            "userLink": "https://www.zhihu.com/people/81895385a3a71cddc4db81429d426f8a", 
                            "content": "看讨论区吧", 
                            "likes": 0, 
                            "replyToAuthor": "微雨点点点"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72086046", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 4, 
            "title": "LeetCode刷题——第三天（python）", 
            "content": "<p>昨天的那道题难度上是中等的，但是对于菜鸟的我来说已经超出能力范围，今天回到了简单程度的题——【整数反转】</p><p><b>看题目！</b></p><p>###给出一个 <b>32 位的有符号整数</b>，你需要将这个整数中每位上的数字进行反转###</p><p><b>示例 1:</b></p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"n\">输入</span><span class=\"p\">:</span> <span class=\"mi\">123</span>\n<span class=\"n\">输出</span><span class=\"p\">:</span> <span class=\"mi\">321</span></code></pre></div><p><b>示例 2:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入: -123\n输出: -321</code></pre></div><p>python解答方法之一：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Solution(object):\n    def reverse(self, x):\n        &#34;&#34;&#34;\n        :type x: int\n        :rtype: int\n        &#34;&#34;&#34;\n        flag=1 if x&gt;=0 else -1\n        abs_x=abs(x)\n        str_x=str(abs_x)\n        reverse_x=str_x[::-1]\n        result_x=int(reverse_x)*flag\n        if -2 ** 31 &lt;= result_x&lt;= 2**31 - 1:\n            return result_x\n        else:\n            return 0\n        </code></pre></div><p>这道题简单点说就是反一串数字保持符号不变，但是一看到“32 位的有符号整数”，这题干着实让我一慌，赶紧去百度了一下“32 位的有符号整数”是个啥，说实话，看了几篇博客，现在对这个“32位的有符号整数”还是似懂非懂的，大家如果有知道的不妨在评论区讲一讲。</p><p>抛去这个“32 位的有符号整数”，直接说反转数字保持符号不变，相比之下这个题看起来就简单了许多。</p><p>代码的思路就是：</p><p><i>1.先把符号取出来</i></p><p><i>2.求整数的绝对值</i></p><p><i>3.整数的绝对值变成字符串</i></p><p><i>4.字符串反转</i></p><p><i>5.字符串反转后转成整数</i></p><p><i>6.变换后的整数*flag   保证符号不变</i></p><p><i>7.判断是否溢出</i></p><p><i>8.没有溢出则输出结果</i></p><p>今天还是一道题，这个代码也是参考了大神的以后完善的，相对来说比较简单好理解。</p><h2>菜是确实菜，但是我相信每天进步一点点，总会有进步的。</h2><p>最后想说：以后我都会将自己喜欢的壁纸放在封面上和大家分享一下，与君共勉</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }
            ], 
            "comments": [
                {
                    "userName": "美利坚搅拌机", 
                    "userLink": "https://www.zhihu.com/people/ea4ae23277d5052f8fdac5285d894b96", 
                    "content": "加油💪", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "微雨点点点", 
                            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                            "content": "共同进步", 
                            "likes": 0, 
                            "replyToAuthor": "美利坚搅拌机"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71938132", 
            "userName": "微雨点点点", 
            "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
            "upvote": 0, 
            "title": "LeetCode刷题--第二天(两数相加)", 
            "content": "<p>本来今天应该多做几道题的，无奈突然不能上网了，暂时还没有解决，恐怖如斯…</p><p>题目：给出两个 <b>非空</b> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <b>逆序</b> 的方式存储的，并且它们的每个节点只能存储 <b>一位</b> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><b>示例：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)\n输出：7 -&gt; 0 -&gt; 8\n原因：342 + 465 = 807</code></pre></div><p>python解答之一：</p><p>2. 两数相加</p><h1>LeetCode 两数相加 Python3解答</h1><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"k\">class</span> <span class=\"nc\">Solution</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"nf\">addTwoNumbers</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">l1</span><span class=\"p\">:</span> <span class=\"n\">ListNode</span><span class=\"p\">,</span> <span class=\"n\">l2</span><span class=\"p\">:</span> <span class=\"n\">ListNode</span><span class=\"p\">)</span> <span class=\"o\">-&gt;</span> <span class=\"n\">ListNode</span><span class=\"p\">:</span>\n        <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n        <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">ListNode</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"k\">while</span> <span class=\"n\">l1</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span> <span class=\"ow\">and</span> <span class=\"n\">l2</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">l1</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">+</span> <span class=\"n\">l2</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">+</span> <span class=\"n\">flag</span>\n            <span class=\"k\">if</span> <span class=\"n\">temp</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span> <span class=\"o\">-</span> <span class=\"mi\">10</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span>\n            <span class=\"n\">l1</span> <span class=\"o\">=</span> <span class=\"n\">l1</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n            <span class=\"n\">l2</span> <span class=\"o\">=</span> <span class=\"n\">l2</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n            <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"n\">ListNode</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n        <span class=\"k\">while</span> <span class=\"n\">l1</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">l1</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">+</span> <span class=\"n\">flag</span>\n            <span class=\"k\">if</span> <span class=\"n\">temp</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span> <span class=\"o\">-</span> <span class=\"mi\">10</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span>\n            <span class=\"n\">l1</span> <span class=\"o\">=</span> <span class=\"n\">l1</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n            <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"n\">ListNode</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n        <span class=\"k\">while</span> <span class=\"n\">l2</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"n\">l2</span><span class=\"o\">.</span><span class=\"n\">val</span> <span class=\"o\">+</span> <span class=\"n\">flag</span>\n            <span class=\"k\">if</span> <span class=\"n\">temp</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">10</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span> <span class=\"o\">-</span> <span class=\"mi\">10</span>\n            <span class=\"k\">else</span><span class=\"p\">:</span>\n                <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">temp</span>\n            <span class=\"n\">l2</span> <span class=\"o\">=</span> <span class=\"n\">l2</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n            <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"n\">ListNode</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n        <span class=\"k\">if</span> <span class=\"n\">flag</span><span class=\"p\">:</span>\n            <span class=\"n\">r</span><span class=\"o\">.</span><span class=\"nb\">next</span> <span class=\"o\">=</span> <span class=\"n\">ListNode</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"n\">out</span> <span class=\"o\">=</span> <span class=\"n\">out</span><span class=\"o\">.</span><span class=\"nb\">next</span>\n        <span class=\"k\">return</span> <span class=\"n\">out</span></code></pre></div><p>今天的内容没有太仔细的看，伤心T_T，我去修电脑了…</p>", 
            "topic": [], 
            "comments": [
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>昨天晚上是整个实验室都没网，只有一个小伙伴跟我在一个屋，奇怪他的电脑可以正常上网，我就以为我的电脑坏了，郁闷了一晚上，今天仔细看了看这道题，难度是中等，但是已经超出本人目前的能力范围，哈哈</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "wjwABCDEFG", 
                    "userLink": "https://www.zhihu.com/people/96421c45a3a4d364e9d444f26545e339", 
                    "content": "补个java的，思路和答主的类似，不过答主的边界条件处理的比较好，我在l1l2长度不等情况下边界值那里疯狂报错调了好久<br>class Solution {<br>    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {<br>        ListNode a = l1, b = l2;<br>        ListNode c = new ListNode(0);<br>        ListNode head = c;    //头指针防丢<br>        int x = a.val;    //当前值<br>        int y = b.val;<br>        int cout = 0;   //进位<br>        int sum;    //本位和<br><br>        while(a != null || b != null)<br>        {<br>            sum = x + y + cout;<br>            c.next = new ListNode(sum % 10);<br>            cout = sum / 10;<br>            a = (a == null || a.next == null) ? null : a.next;<br>            b = (b == null || b.next == null) ? null : b.next;<br>            x = (a == null) ? 0 : a.val;<br>            y = (b == null) ? 0 : b.val;<br>            c = c.next;<br>        }<br>        if(cout == 1)<br>        {<br>            c.next = new ListNode(cout);<br>        }<br>        return head.next;<br>    }<br>}<a href=\"https://pic3.zhimg.com/v2-c2ca56571fa76c73619f980f31dbeeb2.webp\" class=\"comment_sticker\" data-width=\"0\" data-height=\"0\" data-sticker-id=\"1029329540195229696\">[瑟瑟发抖]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "微雨点点点", 
                    "userLink": "https://www.zhihu.com/people/e93b8c52938d5e32a5f2282244240679", 
                    "content": "<p>专业！</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1129436381788897280"
}
