{
    "title": "童话说", 
    "description": "专注大前端领域原创技术分享", 
    "followers": [
        "https://www.zhihu.com/people/qing-yi-zhan-jiu-8", 
        "https://www.zhihu.com/people/cubesugarZhang", 
        "https://www.zhihu.com/people/feed-12", 
        "https://www.zhihu.com/people/neihan", 
        "https://www.zhihu.com/people/yu-hhha", 
        "https://www.zhihu.com/people/zhang-lei-96-68", 
        "https://www.zhihu.com/people/ppp-57-64", 
        "https://www.zhihu.com/people/macdfree", 
        "https://www.zhihu.com/people/loveyunk", 
        "https://www.zhihu.com/people/liu-tao-37-92-74", 
        "https://www.zhihu.com/people/gkrxqn", 
        "https://www.zhihu.com/people/leon82", 
        "https://www.zhihu.com/people/yue-yu-nan-nan", 
        "https://www.zhihu.com/people/liyannan99", 
        "https://www.zhihu.com/people/panovr", 
        "https://www.zhihu.com/people/cosmtrek", 
        "https://www.zhihu.com/people/slogeor", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/igeek", 
        "https://www.zhihu.com/people/abnerzq", 
        "https://www.zhihu.com/people/sepiggy", 
        "https://www.zhihu.com/people/wen-zhi-hong", 
        "https://www.zhihu.com/people/zhi-ao-yan-leng", 
        "https://www.zhihu.com/people/wang-jia-jia-94-44", 
        "https://www.zhihu.com/people/xiao-wen-55-60", 
        "https://www.zhihu.com/people/Voyager_VI", 
        "https://www.zhihu.com/people/justinhuang", 
        "https://www.zhihu.com/people/zhang-kefer", 
        "https://www.zhihu.com/people/rong-wo-ci-sheng-wen-qing", 
        "https://www.zhihu.com/people/apeng-chen", 
        "https://www.zhihu.com/people/ceng-yun-chun", 
        "https://www.zhihu.com/people/ying-zi-ren-sheng", 
        "https://www.zhihu.com/people/ju-da-ren", 
        "https://www.zhihu.com/people/wei-sheng-79", 
        "https://www.zhihu.com/people/a-zi-mao-54", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/xiao-ming-7-76-73", 
        "https://www.zhihu.com/people/wu-yi-38-95-49", 
        "https://www.zhihu.com/people/zhang-zhe-lun", 
        "https://www.zhihu.com/people/fuxiaoabc", 
        "https://www.zhihu.com/people/jianchun-he", 
        "https://www.zhihu.com/people/hei-tou-fa-de-xiao-qiang", 
        "https://www.zhihu.com/people/guo-fan-70", 
        "https://www.zhihu.com/people/riskers", 
        "https://www.zhihu.com/people/phoenix-czg", 
        "https://www.zhihu.com/people/cheng-xian-sheng-27-40", 
        "https://www.zhihu.com/people/vanillangelia", 
        "https://www.zhihu.com/people/yh-ding", 
        "https://www.zhihu.com/people/ju-shang-38", 
        "https://www.zhihu.com/people/ATXON", 
        "https://www.zhihu.com/people/wemlion", 
        "https://www.zhihu.com/people/deng-lei-87", 
        "https://www.zhihu.com/people/lifeigump", 
        "https://www.zhihu.com/people/julytian", 
        "https://www.zhihu.com/people/xiang-rong-64-40", 
        "https://www.zhihu.com/people/efanchy", 
        "https://www.zhihu.com/people/chensuiyi", 
        "https://www.zhihu.com/people/ru-ru-bu-dong-86-96", 
        "https://www.zhihu.com/people/zhu-yong-chun-46-1", 
        "https://www.zhihu.com/people/huang-he-47-48", 
        "https://www.zhihu.com/people/xue-yuan-10-50", 
        "https://www.zhihu.com/people/spacerover", 
        "https://www.zhihu.com/people/li-qiang-20", 
        "https://www.zhihu.com/people/ren-jian-hua-34", 
        "https://www.zhihu.com/people/curarchy", 
        "https://www.zhihu.com/people/mnizm", 
        "https://www.zhihu.com/people/shit-yang", 
        "https://www.zhihu.com/people/ou-fen-hai", 
        "https://www.zhihu.com/people/san-you-jia-mu-22", 
        "https://www.zhihu.com/people/john-91-74", 
        "https://www.zhihu.com/people/yao-hao-23", 
        "https://www.zhihu.com/people/forevercc-42", 
        "https://www.zhihu.com/people/kyuubi", 
        "https://www.zhihu.com/people/zhou-yu-lai-18", 
        "https://www.zhihu.com/people/tian-tian-jin-bu-88", 
        "https://www.zhihu.com/people/tinythytigerdaddy", 
        "https://www.zhihu.com/people/he-shi-yun", 
        "https://www.zhihu.com/people/xpal7512", 
        "https://www.zhihu.com/people/RocKim", 
        "https://www.zhihu.com/people/littlelane", 
        "https://www.zhihu.com/people/shangwfa", 
        "https://www.zhihu.com/people/cheng-xin-xin-27", 
        "https://www.zhihu.com/people/ybtk", 
        "https://www.zhihu.com/people/wang-xiao-feng-6-67", 
        "https://www.zhihu.com/people/mu-ne-25", 
        "https://www.zhihu.com/people/bing-xin-22", 
        "https://www.zhihu.com/people/gu-wei-81", 
        "https://www.zhihu.com/people/ling1983613", 
        "https://www.zhihu.com/people/qqmm2016", 
        "https://www.zhihu.com/people/dq-xia", 
        "https://www.zhihu.com/people/codearvin", 
        "https://www.zhihu.com/people/jp928-67", 
        "https://www.zhihu.com/people/kate-49-40", 
        "https://www.zhihu.com/people/kaka-9527", 
        "https://www.zhihu.com/people/fluency03", 
        "https://www.zhihu.com/people/li-zi-an-72", 
        "https://www.zhihu.com/people/liu-xian-sen-29-79", 
        "https://www.zhihu.com/people/wang-xiang-zhong-5", 
        "https://www.zhihu.com/people/lei40251", 
        "https://www.zhihu.com/people/ceng-tan-2", 
        "https://www.zhihu.com/people/zhang-liang-31-8", 
        "https://www.zhihu.com/people/yinyun957", 
        "https://www.zhihu.com/people/Inspector", 
        "https://www.zhihu.com/people/li-ji-hang-23", 
        "https://www.zhihu.com/people/mao-quan", 
        "https://www.zhihu.com/people/yun-zai-qing-tian-dk", 
        "https://www.zhihu.com/people/fantasticsoul", 
        "https://www.zhihu.com/people/wangningkai", 
        "https://www.zhihu.com/people/zhao-da-cheng-75-3", 
        "https://www.zhihu.com/people/wang-liao-52", 
        "https://www.zhihu.com/people/face-yzz", 
        "https://www.zhihu.com/people/xu-yi-hang", 
        "https://www.zhihu.com/people/lijiadeyu", 
        "https://www.zhihu.com/people/ycjcl", 
        "https://www.zhihu.com/people/knowledge-seeking", 
        "https://www.zhihu.com/people/liu-kan-shui-91", 
        "https://www.zhihu.com/people/cute_pow", 
        "https://www.zhihu.com/people/li-zheng-cao-94", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/du-xing-xia-41-57", 
        "https://www.zhihu.com/people/rollforward", 
        "https://www.zhihu.com/people/zhengzigege", 
        "https://www.zhihu.com/people/yi-ran-yi-xi-mie", 
        "https://www.zhihu.com/people/liu-bin-43-97", 
        "https://www.zhihu.com/people/immkoala", 
        "https://www.zhihu.com/people/wang-yi-liang-86", 
        "https://www.zhihu.com/people/feixiaxia", 
        "https://www.zhihu.com/people/wei-yue-xin", 
        "https://www.zhihu.com/people/hunter-gu-94", 
        "https://www.zhihu.com/people/hong-lin-song-40", 
        "https://www.zhihu.com/people/qiu-bo-8-56", 
        "https://www.zhihu.com/people/gou-bu-li-si-ji", 
        "https://www.zhihu.com/people/obovgood", 
        "https://www.zhihu.com/people/onefanta"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/85857004", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 72, 
            "title": "TypeScript：又一个终将逝去的青春", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/blog/2019/10/10/typescript-another-fading-youth\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-b7b7642447ca6a5b28abf9f90bf06ef8_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TypeScript：又一个终将逝去的青春 | 博客</a><p><b>硬币的另一面</b></p><p>TypeScript 真的是太火了，伴随着 Vue 3 的登场，三大框架全面支持 TypeScript，全民学习 TypeScript 迎来新一波热潮，娱乐圈正式进入 TypeScript 新时代。</p><p>回头一看，娱乐圈像这样的头条还真不在少数，Flutter、微信小程序、ES6 …… 再往前就不说了，太多了。每一个都曾引起过一阵全民学习的狂潮，感觉学了就能走向巅峰，不学就完了。</p><p>关注新技术的诞生，是每个有追求的开发者应该做的。但这一篇，我却想谈谈硬币的另一面。</p><h2>英雄末路</h2><p>在人家最火的时候，来这么一下，难不成是在故意唱反调，博眼球吗？</p><p>作为 TypeScript 早期实践者中的一员，浪潮初到时我也曾为之激动过，也正因为如此，当后浪来临时，我反而非常淡定，开始看向新的远方。</p><p>优胜劣汰，物竞天择，大自然的法则谁也逃不过。有诞生，就有毁灭，再火热的技术，也终将退休。</p><p>上一个因为退休而被热议的技术，应该是 jQuery 了吧。jQuery 年轻时有多火不用多说，如今廉颇老矣，虽尚能饭，但世人却依然给了它一个大大的「否」字。不是 jQuery 不行了，只是行业发展了，不再需要它了。</p><p>回顾历史，这样的故事，其实一直在上演。</p><h2>历史总是惊人的相似</h2><p>人们想要一致的 API 来操作 DOM，于是创造出了 jQuery。后来 DOM API 越发标准，jQuery 也就逐渐淡出了人们的视野。</p><p>人们想要好用的语法特性，于是创造出了 CoffeeScript。后来 ES 2015 标准发布，CoffeeScript 的存在感一天不如一天。</p><p>人们想要在客户端也能有良好的模块化支持，于是创造出了 AMD/CMD/UMD 等方案。后来 ESM 成为了主流，就没人再谈这些了。</p><p>现在，人们想要类型推断了 ……</p><h2>命中注定是个备胎</h2><p>昔日英雄，都不过是备胎罢了，需要时发展一个，用不着了就丢掉，标准才是永远的正宫。听上去很惋惜，但这都是大自然的常规操作。</p><p>行业需要什么，从业者就会去创造什么，行业从中受益得到发展。行业发展了，曾经的创造不再被需要，日渐被遗忘，最后彻底退出。</p><p>【假装我是删除线】即便是 React、Vue、Angular 也是一样，三大技术栈现在大方向都是奔着 Web Components 去，等哪一天 Web Components 支持度足够了，或许就又到新一轮更新换代了。【假装我是删除线】</p><blockquote>看了尤老师的评论，我又重新去认识了一下 Web Components。上面这段，大家就假装没看到吧。（知乎不提供删除线……）</blockquote><h2>35 岁这个哏</h2><p>每年，都有一批 35 岁左右的互联网从业者光荣退休。有人抱怨企业过河拆桥，但毕竟资本是嗜血的，企业是以赚钱为目的的，大家只是利益驱使下的雇佣关系，而已。一方需要能力，一方提供能力，一纸合同，开干。</p><p>从这一点看，人和技术都是一样的。行业的走向、企业的需求、开发者的年龄，开发者的能力，这些都是变量。前面 3 种变化都是被动的，不管我们接不接受，该变的都会变，唯有技能，是我们可以控制的。当我们的能力，能够顺应行业的走向，能够满足企业的需求，年龄就成了无关变量，否则，它就可能成为一个「温柔的借口」。</p><h2>终将逝去的青春</h2><p>现在整个前端圈都已经接受了「静态类型系统」这么个东西，一个库如果无法提供良好的类型定义甚至会因此被嫌弃。当一项非标准的技术成为了事实上的标准，那么它距离成为真正的标准也就不远了。剩下的，或许只是时间的问题。</p><p>届时，TypeScript 或许也会逐渐消失，成为一代人的记忆，被后世所遗忘。</p><p>青春终将逝去，技术也是一样。来时，我们为之狂热，去时，我们为之惋惜。</p><p>若干年后，当后辈们再次踏上这条征途，他们的起点，或许就已经不同以往：</p><p>「JavaScript —— 一门静态类型语言」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5d72d1593ee3afddd7f4bf450848c4e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-5d72d1593ee3afddd7f4bf450848c4e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-5d72d1593ee3afddd7f4bf450848c4e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5d72d1593ee3afddd7f4bf450848c4e7_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "TypeScript", 
                    "tagLink": "https://api.zhihu.com/topics/19766226"
                }, 
                {
                    "tag": "ECMAScript", 
                    "tagLink": "https://api.zhihu.com/topics/19600610"
                }
            ], 
            "comments": [
                {
                    "userName": "尤雨溪", 
                    "userLink": "https://www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f", 
                    "content": "<p>ES2015 发布，Babel 也没有退出历史舞台。ESM 成为了主流，然而在 Node 中的原生支持依然迟迟没有落地，在客户端打包工具也依然不可或缺。标准化的进程和落地是一个极其复杂的过程，仅仅是一些作用域很窄的特性，也会要经过长期的讨论和利益博弈（比如 ESM，class fields）。而类型系统的水可以说深得超过 JavaScript 语言本身，还涉及配套的工具链，将这一整套系统标准化，以 TC39 现在的扯皮效率，保守估计需要十年。</p>", 
                    "likes": 86, 
                    "childComments": []
                }, 
                {
                    "userName": "风声太大", 
                    "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                    "content": "要根据实际需要去学习一项技术，而不是什么火就学什么", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "风声太大", 
                            "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                            "content": "要不要学？有没有前景？这些就都不是问题了，当下确实需要，那就去学它！用它！一项技术在未来会被淘汰这太正常不过了。", 
                            "likes": 0, 
                            "replyToAuthor": "风声太大"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "35岁退休？", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "程序猿的自黑哏", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "晨曦时梦见兮", 
                            "userLink": "https://www.zhihu.com/people/b3b784827032ece644e97673df3fc4d1", 
                            "content": "<p>到底是自黑 还是真的确有其事呢 不好说...</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "范海宁", 
                    "userLink": "https://www.zhihu.com/people/4938aebc1712561a9d16b6529374ad94", 
                    "content": "js不会成为静态类型，历史包袱太重了", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "走走停停", 
                            "userLink": "https://www.zhihu.com/people/34a362ab0540e7d0ea55ec8074a19449", 
                            "content": "可以看下 python 的类型标注", 
                            "likes": 2, 
                            "replyToAuthor": "范海宁"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "历史包袱，终究会被时间冲洗掉，无非是多久的问题", 
                            "likes": 0, 
                            "replyToAuthor": "范海宁"
                        }
                    ]
                }, 
                {
                    "userName": "打字慢怎么coding", 
                    "userLink": "https://www.zhihu.com/people/c6f018bfba6c7848cf66f8d994902c04", 
                    "content": "<p>人类都是逐利的嘛，不存在，在当下好好学习，拥抱新技术才对，而不总是想一劳永逸</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "风声太大", 
                            "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                            "content": "对啊，一项技术末路这个问题，其实无所谓的，有某个需求，当下的解决方案是什么，那就去用，以后有新的解决方案了再用新的解决方案就行了。", 
                            "likes": 0, 
                            "replyToAuthor": "打字慢怎么coding"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>在人家最火的时候，来这么一下，发生什么事情了，没有上下文让读者去理解什么东西？</p>", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "意思是，TS现在正火着，我却在思考它的末路，有心之人会误会我在唱衰TS。", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我以为ts核心成员离开了呢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>那还不是js当初设计的太简陋，不适合当前需要才出现的Typescript吗？如果哪一天js进化到不需要ts的辅助了，那么Ts也到了功成身退的时候了。</p>", 
                    "likes": 2, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "就是这么个意思，不过现在看来的简陋，在当时也已经够用了，这事儿不可同日而语", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "haroel", 
                    "userLink": "https://www.zhihu.com/people/92c3e7514fb0a5a71c4d23432fe321af", 
                    "content": "<p>感慨太多了吧，ts只是一门语言</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "其他的不说，web compoment和三大框架比起来就是玩具，何来未来方向之说。<br><br>连方向都看不清，还是不要预测啥了吧……", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "你可能对 web componemts 有什么误会", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "……又不是没写过……还能有啥误会的。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "李小志", 
                    "userLink": "https://www.zhihu.com/people/e31119836b33876b011a571a631a0d97", 
                    "content": "现在js有静态类型的提案了吗，如果原生支持，自然更喜欢原生，哈哈", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "目前还没", 
                            "likes": 0, 
                            "replyToAuthor": "李小志"
                        }
                    ]
                }, 
                {
                    "userName": "Rwing", 
                    "userLink": "https://www.zhihu.com/people/58a357e7d8cf3d8a4128d0770e338bc9", 
                    "content": "<p>难道不是webassembly吗？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "那是另一话了", 
                            "likes": 0, 
                            "replyToAuthor": "Rwing"
                        }
                    ]
                }, 
                {
                    "userName": "justjavac", 
                    "userLink": "https://www.zhihu.com/people/ced30ef2e460b4febfd77ef3038167ce", 
                    "content": "静态类型 js？这不就是胎死腹中的 es4 嘛", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "三十年河东，三十年河西，谁知道呢", 
                            "likes": 0, 
                            "replyToAuthor": "justjavac"
                        }, 
                        {
                            "userName": "justjavac", 
                            "userLink": "https://www.zhihu.com/people/ced30ef2e460b4febfd77ef3038167ce", 
                            "content": "<p>也许 es14 又回来了呢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>读史可以知兴替</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "尤雨溪", 
                    "userLink": "https://www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f", 
                    "content": "<p>ES2015 发布，Babel 也没有退出历史舞台。ESM 成为了主流，然而在 Node 中的原生支持依然迟迟没有落地，在客户端打包工具也依然不可或缺。标准化的进程和落地是一个极其复杂的过程，仅仅是一些作用域很窄的特性，也会要经过长期的讨论和利益博弈（比如 ESM，class fields）。而类型系统的水可以说深得超过 JavaScript 语言本身，还涉及配套的工具链，将这一整套系统标准化，以 TC39 现在的扯皮效率，保守估计需要十年。</p>", 
                    "likes": 86, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "babel 保留到现在，最初是因为浏览器不支持新语法，后来是出于语言自身的发展需要。Node 中的 ESM 是底层技术问题，大方向上人们还是希望能够统一的。当然，技术的更替都是需要过程的，绝非前脚新技术刚出，后脚老技术就被彻底淘汰。我从不认为标准化是拍脑袋就能做的决定，这个领域您比我懂。以我目前的水平，不敢妄加推测这个需要多久，但既然那么多人想要，这个趋势应该是跑不了，或许最终的妥协就是可选的语法。", 
                            "likes": 1, 
                            "replyToAuthor": "尤雨溪"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>proposal-class-fielda似乎争议很大，尤大怎么看👀？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "尤雨溪"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>高维度打击！</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "吕嘉轩", 
                    "userLink": "https://www.zhihu.com/people/1ccfb627854eaba96775f3fadf0af241", 
                    "content": "最后一句，全文升华", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "木易几", 
                    "userLink": "https://www.zhihu.com/people/7579f8ecfc6424a490b320ecf6e6ca66", 
                    "content": "引用说的挺好的，就是套在ts上有点别扭", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "AlexanderChiuMungZit", 
                    "userLink": "https://www.zhihu.com/people/188f6a61891d24f0b620c63999993e41", 
                    "content": "<p>和玩游戏是一个道理。JS天赋全点的敏捷（动态、灵活），TS转职天赋点了耐力（静态，严谨）。看什么怪上什么人吧。</p>", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "顺陌先生", 
                    "userLink": "https://www.zhihu.com/people/23794671f75ffb1f0ef327e723f5d92a", 
                    "content": "不会的 js残疾地方太多了", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Acurse", 
                    "userLink": "https://www.zhihu.com/people/0f381629330e10899da5077e40490a17", 
                    "content": "<p>“娱乐圈”“35岁”“web component”以及方兴未艾的TS，我觉得你就是在博眼球。</p>", 
                    "likes": 3, 
                    "childComments": []
                }, 
                {
                    "userName": "尤雨溪", 
                    "userLink": "https://www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f", 
                    "content": "<p>ES2015 发布，Babel 也没有退出历史舞台。ESM 成为了主流，然而在 Node 中的原生支持依然迟迟没有落地，在客户端打包工具也依然不可或缺。标准化的进程和落地是一个极其复杂的过程，仅仅是一些作用域很窄的特性，也会要经过长期的讨论和利益博弈（比如 ESM，class fields）。而类型系统的水可以说深得超过 JavaScript 语言本身，还涉及配套的工具链，将这一整套系统标准化，以 TC39 现在的扯皮效率，保守估计需要十年。</p>", 
                    "likes": 86, 
                    "childComments": []
                }, 
                {
                    "userName": "风声太大", 
                    "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                    "content": "要根据实际需要去学习一项技术，而不是什么火就学什么", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "风声太大", 
                            "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                            "content": "要不要学？有没有前景？这些就都不是问题了，当下确实需要，那就去学它！用它！一项技术在未来会被淘汰这太正常不过了。", 
                            "likes": 0, 
                            "replyToAuthor": "风声太大"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "35岁退休？", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "程序猿的自黑哏", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "晨曦时梦见兮", 
                            "userLink": "https://www.zhihu.com/people/b3b784827032ece644e97673df3fc4d1", 
                            "content": "<p>到底是自黑 还是真的确有其事呢 不好说...</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "范海宁", 
                    "userLink": "https://www.zhihu.com/people/4938aebc1712561a9d16b6529374ad94", 
                    "content": "js不会成为静态类型，历史包袱太重了", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "走走停停", 
                            "userLink": "https://www.zhihu.com/people/34a362ab0540e7d0ea55ec8074a19449", 
                            "content": "可以看下 python 的类型标注", 
                            "likes": 2, 
                            "replyToAuthor": "范海宁"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "历史包袱，终究会被时间冲洗掉，无非是多久的问题", 
                            "likes": 0, 
                            "replyToAuthor": "范海宁"
                        }
                    ]
                }, 
                {
                    "userName": "打字慢怎么coding", 
                    "userLink": "https://www.zhihu.com/people/c6f018bfba6c7848cf66f8d994902c04", 
                    "content": "<p>人类都是逐利的嘛，不存在，在当下好好学习，拥抱新技术才对，而不总是想一劳永逸</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "风声太大", 
                            "userLink": "https://www.zhihu.com/people/5751636b8159ee95242e0c32c4bd38fa", 
                            "content": "对啊，一项技术末路这个问题，其实无所谓的，有某个需求，当下的解决方案是什么，那就去用，以后有新的解决方案了再用新的解决方案就行了。", 
                            "likes": 0, 
                            "replyToAuthor": "打字慢怎么coding"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>在人家最火的时候，来这么一下，发生什么事情了，没有上下文让读者去理解什么东西？</p>", 
                    "likes": 5, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "意思是，TS现在正火着，我却在思考它的末路，有心之人会误会我在唱衰TS。", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我以为ts核心成员离开了呢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>那还不是js当初设计的太简陋，不适合当前需要才出现的Typescript吗？如果哪一天js进化到不需要ts的辅助了，那么Ts也到了功成身退的时候了。</p>", 
                    "likes": 2, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "就是这么个意思，不过现在看来的简陋，在当时也已经够用了，这事儿不可同日而语", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "haroel", 
                    "userLink": "https://www.zhihu.com/people/92c3e7514fb0a5a71c4d23432fe321af", 
                    "content": "<p>感慨太多了吧，ts只是一门语言</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "其他的不说，web compoment和三大框架比起来就是玩具，何来未来方向之说。<br><br>连方向都看不清，还是不要预测啥了吧……", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "你可能对 web componemts 有什么误会", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "……又不是没写过……还能有啥误会的。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "李小志", 
                    "userLink": "https://www.zhihu.com/people/e31119836b33876b011a571a631a0d97", 
                    "content": "现在js有静态类型的提案了吗，如果原生支持，自然更喜欢原生，哈哈", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "目前还没", 
                            "likes": 0, 
                            "replyToAuthor": "李小志"
                        }
                    ]
                }, 
                {
                    "userName": "Rwing", 
                    "userLink": "https://www.zhihu.com/people/58a357e7d8cf3d8a4128d0770e338bc9", 
                    "content": "<p>难道不是webassembly吗？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "那是另一话了", 
                            "likes": 0, 
                            "replyToAuthor": "Rwing"
                        }
                    ]
                }, 
                {
                    "userName": "justjavac", 
                    "userLink": "https://www.zhihu.com/people/ced30ef2e460b4febfd77ef3038167ce", 
                    "content": "静态类型 js？这不就是胎死腹中的 es4 嘛", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "三十年河东，三十年河西，谁知道呢", 
                            "likes": 0, 
                            "replyToAuthor": "justjavac"
                        }, 
                        {
                            "userName": "justjavac", 
                            "userLink": "https://www.zhihu.com/people/ced30ef2e460b4febfd77ef3038167ce", 
                            "content": "<p>也许 es14 又回来了呢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>读史可以知兴替</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "尤雨溪", 
                    "userLink": "https://www.zhihu.com/people/cfdec6226ece879d2571fbc274372e9f", 
                    "content": "<p>ES2015 发布，Babel 也没有退出历史舞台。ESM 成为了主流，然而在 Node 中的原生支持依然迟迟没有落地，在客户端打包工具也依然不可或缺。标准化的进程和落地是一个极其复杂的过程，仅仅是一些作用域很窄的特性，也会要经过长期的讨论和利益博弈（比如 ESM，class fields）。而类型系统的水可以说深得超过 JavaScript 语言本身，还涉及配套的工具链，将这一整套系统标准化，以 TC39 现在的扯皮效率，保守估计需要十年。</p>", 
                    "likes": 86, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "babel 保留到现在，最初是因为浏览器不支持新语法，后来是出于语言自身的发展需要。Node 中的 ESM 是底层技术问题，大方向上人们还是希望能够统一的。当然，技术的更替都是需要过程的，绝非前脚新技术刚出，后脚老技术就被彻底淘汰。我从不认为标准化是拍脑袋就能做的决定，这个领域您比我懂。以我目前的水平，不敢妄加推测这个需要多久，但既然那么多人想要，这个趋势应该是跑不了，或许最终的妥协就是可选的语法。", 
                            "likes": 1, 
                            "replyToAuthor": "尤雨溪"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>proposal-class-fielda似乎争议很大，尤大怎么看👀？</p>", 
                            "likes": 0, 
                            "replyToAuthor": "尤雨溪"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>高维度打击！</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "吕嘉轩", 
                    "userLink": "https://www.zhihu.com/people/1ccfb627854eaba96775f3fadf0af241", 
                    "content": "最后一句，全文升华", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "木易几", 
                    "userLink": "https://www.zhihu.com/people/7579f8ecfc6424a490b320ecf6e6ca66", 
                    "content": "引用说的挺好的，就是套在ts上有点别扭", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "AlexanderChiuMungZit", 
                    "userLink": "https://www.zhihu.com/people/188f6a61891d24f0b620c63999993e41", 
                    "content": "<p>和玩游戏是一个道理。JS天赋全点的敏捷（动态、灵活），TS转职天赋点了耐力（静态，严谨）。看什么怪上什么人吧。</p>", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "顺陌先生", 
                    "userLink": "https://www.zhihu.com/people/23794671f75ffb1f0ef327e723f5d92a", 
                    "content": "不会的 js残疾地方太多了", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Acurse", 
                    "userLink": "https://www.zhihu.com/people/0f381629330e10899da5077e40490a17", 
                    "content": "<p>“娱乐圈”“35岁”“web component”以及方兴未艾的TS，我觉得你就是在博眼球。</p>", 
                    "likes": 3, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/75906177", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 38, 
            "title": "TypeScript 次日指南", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/blog/2019/07/28/typescript-the-second-day\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8239307adc5ccdfc32320e1bcadb6300_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">TypeScript 次日指南 | 博客</a><h2><b>杂谈</b></h2><p>不知道是就我这样，还是大家也是，最近的内容圈子里关于 TypeScript 的文章满天飞，各种 TypeScript 有多好、多受欢迎，要不就是 TypeScript 的教程、实践。偏偏我在这时候有了写这篇文章的想法，搞得很有跟风蹭热度的嫌疑。</p><p>作为一名坚持原创的作者，我并不想把市面上随手可得的东西，换一种方式再讲给大家听，这样不仅是在浪费大家的时间，也是在浪费我自己的时间。我所理解的为社区做贡献，应该是能够填补当前环境下的一些空白，去做一些真正有意义的事，而不是摆出一副资深的样子，去转发或是创造一些重复的内容。</p><p>今天这篇文章，虽然有跟风的嫌疑，但我向你保证，内容依然是绝对的原创。如有巧合，那么英雄所见略同。</p><h2>为什么是次日？</h2><p>上手 TypeScript 并不难，有 JavaScript 基础的同学，花个一天时间过一遍文档，基本就都清楚了。如果你刚好还有 Java、C# 等后端语言的基础，那么其中关于 OOP 的一些概念相信你一定会觉得非常眼熟。</p><p>如果你刚看完文档就开始准备把 TypeScript 用到项目中去，那么恭喜你，你很快就会遇到各种坑，而且你无法直接从文档中寻找到对应的解决方案。这篇文章的存在，就是希望能够填补这中间的空白，帮助各位顺利的把 TypeScript 落地到项目中。</p><p>这便是标题中「次日」的由来。如果你还没有看过 TypeScript 的文档，那么这篇文章现在还不适合你，建议先收藏起来，等看完了文档再回来。</p><p>如果你已经准备好了，那我们开始吧。</p><h2>你或许并不需要 TypeScript</h2><p>每个人接触 TypeScript 的原因不同，有的是被人安利，有的是因为团队在用，有的是因为用了 Angular。但不管因为什么入了这个坑，我们都需要明白：TypeScript 并非必须。</p><p>TypeScript 适合大型项目，小型项目最好还是继续用 JavaScript。这已经是业内的一个共识。</p><p>TypeScript 可以简单理解为 JavaScript + Types。从工程效率的角度上讲，Types 的部分属于额外的工作量，如果不能给项目带来足够的收益，去平衡掉其引入的成本，那么这项投入就不是很值得。</p><p>如果只是官网之类的小型项目，类型不类型的并不重要，没必要为了用 TypeScript 而用 TypeScript。但随着项目的规模和复杂度的增加，代码质量、沟通成本等问题开始浮现，而这恰恰是类型系统能够解决的问题。通过类型检测，我们可以更早的发现潜在的类型错误，进行主动防御，进而提高代码质量；通过类型定义，我们可以更加直观的描述我们的数据结构，降低团队作业中的沟通成本。</p><p>因此，要不要用 TypeScript，取决于你项目的类型以及规模，不要盲目跟风。</p><h2>别忘了 jsDoc</h2><p>很多人对 TypeScript 有一个误解，觉得有了静态类型的代码已经足够「自解释」，就不需要 jsDoc 一类的注释了。</p><p>静态类型描述的是数据的结构，而注释描述的是数据的作用，两者解决的是不同的问题，彼此之间并不冲突。</p><p>比如下面这段 JavaScript 代码：</p><div class=\"highlight\"><pre><code class=\"language-ts\"><span class=\"kd\">function</span> <span class=\"nx\">convert</span> <span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">,</span> <span class=\"nx\">config</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// some code\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><p>不难看出这是一个转换函数，接收一个待转换的值，以及一个配置对象，但我们并不知道这个函数用来转换什么，配置对象又有哪些参数。</p><p>现在我们用 TypeScript 来重写一下，补充一些类型定义。</p><div class=\"highlight\"><pre><code class=\"language-ts\"><span class=\"kd\">function</span> <span class=\"nx\">convert</span> <span class=\"p\">(</span><span class=\"nx\">val</span>: <span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">config</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">x</span>: <span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">y?</span> :<span class=\"kt\">boolean</span><span class=\"p\">})</span><span class=\"o\">:</span> <span class=\"kt\">string</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// some code\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><p>现在我们知道了这是一个用于处理字符串的转换函数，配置对象有两个参数，一个是必选的字符串，一个是可选的布尔值，最后返回的也是一个字符串。但具体到业务中，这个函数用来转换什么样的字符串，我们还是不太清楚。</p><div class=\"highlight\"><pre><code class=\"language-ts\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * @description 对手机号进行编码，隐藏其中一部分，如：13812345678 -&gt; 138****5678\n</span><span class=\"cm\"> * @param val 待编码的手机号\n</span><span class=\"cm\"> * @param config 配置选项\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">function</span> <span class=\"nx\">convert</span> <span class=\"p\">(</span><span class=\"nx\">val</span>: <span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">config</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">x</span>: <span class=\"kt\">string</span><span class=\"p\">,</span> <span class=\"nx\">y?</span> :<span class=\"kt\">boolean</span><span class=\"p\">})</span><span class=\"o\">:</span> <span class=\"kt\">string</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// some code\n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><p>加上注释之后，一切就都清楚了：这是一个对手机号进行编码，将其中一部分替换成其他字符，以保护用户隐私的函数。</p><p>所以你看，TypeScript 并不能完全替代 jsDoc 的作用，该写的注释还是得写。</p><p>当然对于上面的例子，如果是一个单纯的工具函数，我们完全可以使用更加直观的命名，比如 <code>encodeMobile (mobile, config)</code>，但如果这是某个类中的成员函数，那么可能就不可避免地会出现示例中的写法。总之，你明白我的意思就好，就不要钻牛角尖了。</p><p>对了，得益于 TypeScript 的类型系统，<code>@param</code> 不需要再指定数据类型了，只要对变量的用途进行描述就好了。如果你配置了 Lint 工具，它也会提醒你优先使用 TypeScript 来定义类型，不要重复定义。</p><h2>TSX 和 JSX</h2><p>之前我们在用 JavaScript 写 React 时，对文件的扩展名没有什么特别的要求，<code>*.js</code> 或者 <code>*.jsx</code> 都行。</p><p>但在 TypeScript 中，如果你要使用 JSX 语法，就不能使用 <code>*.ts</code>，必须使用 <code>*.tsx</code>。如果你不知道，或者忘了这么做，那么你会在使用了 JSX 代码的地方收到类型报错，但代码本身怎么看都没有问题。这也是刚上手 TypeScript + React 时几乎每个人都会遇到的坑。</p><p>关于这一点，TypeScript 只是在官方教程的示例代码中直接用了 <code>*.tsx</code>，但并没有明确说明这一问题。</p><p>React 则在它的官方文档中说明了这一规则：</p><blockquote> In React, you most likely write your components in a <code>.js</code> file. In TypeScript we have 2 file extensions:<br/> <code>.ts</code> is the default file extension while <code>.tsx</code> is a special extension used for files which contain JSX.<br/> 在使用 React 时，我们通常会把组件写在一个 <code>.*js</code> 文件里。在 TypeScript 中我们有两种文件扩展名：<br/> <code>.ts</code> 是默认的文件扩展名，而 <code>.tsx</code> 是用于包含了 JSX 的文件的特殊扩展名。<br/> </blockquote><p>其实上面这段话也没有明说在 <code>*.ts</code> 中使用 JSX 会报错，所以即便有人看到了这段话，可能也以为只是像 <code>*.jsx</code> 一样多了一种选择，并没有太当回事……直到遇到问题。</p><h2>变量的 Type 怎么找</h2><p>上手 TypeScript 之后很快我们就发现，即便是原生的 DOM、或是 React 的 API，也经常会要我们手动指定类型。但这些结构并不是简单的 JavaScript 原始类型，在使用 JavaScript 编写相关代码时候由于没有这种需要，我们也没关心过这些东西的类型，突然问起来，还真不知道这些类型叫什么名字。</p><p>不光是这些标准类型，同样的问题在很多第三方的库中也会遇到，比如一些组件库会检查你传入的 Props。</p><p>在我看来，这中间其实缺少了一部分的文档，来指导新用户如何找到所需要的类型。既然社区没有提供，那就我来吧。</p><p>当然，让每个开发者都熟记所有的类型肯定是不现实的，总不能每接触一个新的库，就要去记一堆类型吧。放心，世界还是美好的，这种事情，当然是有方法的。</p><p>最直白的方法就是去看库的 Types Definition，也就是那些 <code>*.d.ts</code> 文件。如果你刚好有在用 VS Code 的话，有一个非常方便的操作：把鼠标移动到你想知道它类型的代码上（比如某个变量、某个函数调用，或是某个 JSX 标签、某个组件的 props），右键选择「Go to Definition」（或者光标选中后按 F12），就可以跳转到它的类型定义文件了。</p><p>如果你更习惯使用 VS Code 之外的编辑器，我相信时至今日，它们应该也都早就对 TypeScript 提供了支持。具体操作我不太熟悉，你可以自己探索下（我一直用 VS Code，其它的不太熟）。</p><p>一般来说，这个操作可以直接把你带到你想要的地方，但考虑到类型是可以继承的，有时候一次跳转可能不太够，遇到这种情况，那就需要你随机应变一下，沿着继承关系多跳几次，直到找到你想要的内容。</p><p>对于不熟悉的类型，可以通过这个方法去寻找，慢慢熟悉以后，你会发现，一些常见的类型还是很好找的，稍微联想一下英文的表达方式，配合自动补全的提示，一般都不难找到。</p><p>为了方便初学者，我们还是稍微列举一些常见的类型，找找感觉：</p><h3>常见 Types 之 DOM</h3><p>TypeScript 自带了一些基本的类型定义，包括 ECMAScript 和 DOM 的类型定义，所有你需要的类型都可以从这里找到。如果你想做一些「纯 TypeScript 开发」的话，有这些就够了。</p><p>比如下面这张截图，就是对 <code>&lt;div&gt;</code> 标签的类型定义。我们可以看到，它继承了更加通用的 <code>HTMLElement</code> 类型，并且扩展了一个即将被废弃的 <code>align</code> 属性，以及两组 <code>addEventListener</code> 和 <code>removeEventListener</code>，注意这里使用了重载。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eb9fc6a85e4e54e27e336dc7f92fed47_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"777\" class=\"origin_image zh-lightbox-thumb\" width=\"1127\" data-original=\"https://pic4.zhimg.com/v2-eb9fc6a85e4e54e27e336dc7f92fed47_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1127&#39; height=&#39;777&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1127\" data-rawheight=\"777\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1127\" data-original=\"https://pic4.zhimg.com/v2-eb9fc6a85e4e54e27e336dc7f92fed47_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eb9fc6a85e4e54e27e336dc7f92fed47_b.jpg\"/></figure><p>这里的命名也不是随便起的，都是在 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/en-US/docs/Web/API/HTMLDivElement\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MDN</a> 上可以查到的。</p><p>还是以 <code>&lt;div&gt;</code> 为例，我们已经知道它继承自 <code>HTMLElement</code>，其实再往上，<code>HTMLElement</code> 继承自 <code>Element</code>，<code>Element</code> 又继承自 <code>Node</code>，顺着这条路，你可以挖掘出所有 HTML 标签的类型。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ee4b30b40251609d0119621208e4c42f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1213\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"1213\" data-original=\"https://pic4.zhimg.com/v2-ee4b30b40251609d0119621208e4c42f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1213&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1213\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1213\" data-original=\"https://pic4.zhimg.com/v2-ee4b30b40251609d0119621208e4c42f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ee4b30b40251609d0119621208e4c42f_b.jpg\"/></figure><p>对于一些 DOM 相关的属性，比如 <code>onclick</code>、<code>onchange</code> 等，你都可以如法炮制，找到它们的定义。</p><h3>常见 Types 之 React</h3><p>关于 TypeScript 的问题，有不少其实是在使用第三方库的时候遇到的，React 就是其中比较典型的一个。</p><p>其实方法都一样，只不过相关的类型定义不在 TypeScript 中，而是在 <code>@types/react</code> 中。</p><p>React 的类型定义的名称其实也很直观，比如我们常见的 <code>React.Component</code>，在定义 Class 组件时，我们需要对 Props 和 State 预先进行类型定义，为什么呢？答案就在它的类型定义中。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1affc8e8174fb04cda4ecdf0d6266e0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1106\" data-rawheight=\"1228\" class=\"origin_image zh-lightbox-thumb\" width=\"1106\" data-original=\"https://pic1.zhimg.com/v2-1affc8e8174fb04cda4ecdf0d6266e0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1106&#39; height=&#39;1228&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1106\" data-rawheight=\"1228\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1106\" data-original=\"https://pic1.zhimg.com/v2-1affc8e8174fb04cda4ecdf0d6266e0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1affc8e8174fb04cda4ecdf0d6266e0c_b.jpg\"/></figure><p>再比如，当我们在写一些组件时，我们可能会需要向下传递 <code>this.props.children</code>，但 <code>children</code> 并没有被设为默认值，需要我们自己定义到 props 上，那么它的类型应该是什么呢？</p><p>到类型定义中搜一下关键字 children，很快我们就找到了下面的定义：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6882b5bdca0070a8e5248110a267776b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1093\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb\" width=\"1093\" data-original=\"https://pic4.zhimg.com/v2-6882b5bdca0070a8e5248110a267776b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1093&#39; height=&#39;641&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1093\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1093\" data-original=\"https://pic4.zhimg.com/v2-6882b5bdca0070a8e5248110a267776b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6882b5bdca0070a8e5248110a267776b_b.jpg\"/></figure><p>所有 React 中 JSX 所代表的内容，无论是 <code>render()</code> 的返回，还是 <code>children</code>，我们都可以定义为一个 <code>ReactNode</code>。那这个 <code>ReactNode</code> 长什么样呢？我们通过右键继续寻找：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b5b12874598f590ed04575d55ef3afed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1089\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb\" width=\"1089\" data-original=\"https://pic2.zhimg.com/v2-b5b12874598f590ed04575d55ef3afed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1089&#39; height=&#39;518&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1089\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1089\" data-original=\"https://pic2.zhimg.com/v2-b5b12874598f590ed04575d55ef3afed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b5b12874598f590ed04575d55ef3afed_b.jpg\"/></figure><p>看到这里，我们不光找到了我们想要的类型，还顺带明白了为什么 <code>render()</code> 可以返回 boolean、null、undefined 表示不渲染任何内容。</p><p>那么事件呢？当我们给组件定义事件处理函数的时候，也经常会被要求指定类型。还是老办法，找不到咱就搜，比如 <code>onClick</code> 不清楚，那我们就以它为关键字去搜：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4f5054a84bc7a46acf170256a8d939aa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"903\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-4f5054a84bc7a46acf170256a8d939aa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;903&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"903\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-4f5054a84bc7a46acf170256a8d939aa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4f5054a84bc7a46acf170256a8d939aa_b.jpg\"/></figure><p>据此我们找到一个叫 <code>MouseEventHandler</code> 的定义，这名字，够直白吧。</p><p>好了，我们找到想要的了。不过既然来了，不如继续看一下，看看还能发现什么。我们右键 MouseEventHandler 继续往下看：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8fd6b9945c155874535f22f163f4672f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1016\" data-rawheight=\"896\" class=\"origin_image zh-lightbox-thumb\" width=\"1016\" data-original=\"https://pic4.zhimg.com/v2-8fd6b9945c155874535f22f163f4672f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1016&#39; height=&#39;896&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1016\" data-rawheight=\"896\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1016\" data-original=\"https://pic4.zhimg.com/v2-8fd6b9945c155874535f22f163f4672f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8fd6b9945c155874535f22f163f4672f_b.jpg\"/></figure><p>看到了吗，所有的事件处理函数都有对应的定义，每个都需要一个泛型参数，传递了事件的类型，名称也挺直白的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-168c05ca3cfef0f61979b4b96a4f7600_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"906\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic1.zhimg.com/v2-168c05ca3cfef0f61979b4b96a4f7600_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;906&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"906\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic1.zhimg.com/v2-168c05ca3cfef0f61979b4b96a4f7600_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-168c05ca3cfef0f61979b4b96a4f7600_b.jpg\"/></figure><p>Ok，事件的类型也被我们挖出来了，以后如果需要单独定义一个事件相关的类型，就可以直接用了。</p><p>以此类推，不管是什么东西的类型，都可以去它们对应的 <code>@types/xxx</code> 里，按关键字搜，只要你的英语别太差，很容易就能找到。</p><h2>多重 extends</h2><p>我们知道 Interface 是可以多继承的，extends 后面可以跟多个其它 Interface，我们不能保证被继承的多个 Interface 一定没有重复的属性，那么当属性重复，但类型定义不同时，最终的结果会怎么样呢？</p><p>在 TypeScript 中，Interface 会按照从右往左的顺序去合并多个被继承的 Interface，也就是说，同名属性，左边的会覆盖右边的。</p><div class=\"highlight\"><pre><code class=\"language-text\">interface A {\n  value?: string\n}\n\ninterface B {\n  value: string\n}\n\ninterface C {\n  value: number\n}\n\ninterface D extends A, B {}\n// value?: string\n\ninterface E extends B, C {}\n// value: string</code></pre></div><h2><code>obj[prop]</code> 无法访问怎么办</h2><p>有时候我们会定义一些集合型的数据，例如对象、枚举等，但在调用的时候，我们未必会直接通过 <code>obj.prop</code> 的形式去调用，可能会是以 <code>obj[prop]</code> 这种动态索引的形式去访问，但通过动态索引的方式就无法确定最终访问的元素是否存在，因此在 TypeScript 中，默认是不允许这种操作的。</p><p>但这又是个非常合理，而且非常常见的场景，怎么办呢？TypeScript 允许为类型添加索引，以实现这一点。</p><div class=\"highlight\"><pre><code class=\"language-text\">interface Foo {\n  x: string,\n  y: number\n  [index: string]: string | number\n}</code></pre></div><p>这个方法虽然有效，但每次都要手动为类型加索引，重复多了也挺心累的。包括在一些「配置对象」中，我们甚至无法确定有哪些类型，有没有一种更加通用、更加一劳永逸的方法。</p><p>当然有。</p><p>其实在 TypeScript 的官方文档中就有提到这个方案，官方管它叫 OptionBag，大概就是指 config、option 等用于提供配置信息的这么一类参数。我不是很确定这到底是个常规的英文单词，还是 TypeScript 中特定的术语（个人感觉是前者），反正就这么个意思吧。</p><p>简单说来，我们可以定义下面这样一个类型：</p><div class=\"highlight\"><pre><code class=\"language-text\">interface OptionBag {\n  [index: string]: any\n}</code></pre></div><p>这是一个非常通用的结构，以字符串为键，值可以是任何类型，并且支持索引 —— 这不就是 Object 么。</p><p>之后所有需要动态索引的结构，或是作为配置对象的结构，都可以直接指定为，或是继承 <code>OptionBag</code>。这个方案以牺牲一定的类型检查为代价，换取了操作上的便利。</p><p>理论上讲，<code>OptionBag</code> 可以适用于所有类似对象这样的结构，但不建议各位真就这么做。这个方案只能是用在一些对类型要求不那么严格，或是无法预知类型的场景中，能够确定的类型还是尽可能地写一下，否则就失去了使用 TypeScript 意义了。</p><h2>小结</h2><p>TypeScript 确实是个好东西，但世上没有绝对完美的东西，实践过程中总会有那么些阻碍完我们前进的坑。但是掉坑里并不可怕，只要有办法能爬出来，那就都不叫事儿。</p><p>原创不易，坚持原创更是，希望这篇文章多少能给大家带来一些收获吧。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "TypeScript", 
                    "tagLink": "https://api.zhihu.com/topics/19766226"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "要是我当初刚上手时能看到这文章就好了[飙泪笑]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "fhfuih", 
                    "userLink": "https://www.zhihu.com/people/c0e399b35474e84b6d636cc5e331b9e2", 
                    "content": "写的很好！正好这两天刚刚接触ts代码，有很多一般别人讲不到的细节都在这里解答了！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "佘玉非", 
                    "userLink": "https://www.zhihu.com/people/0fee029ddb80365f994a2ea6ff47de17", 
                    "content": "React部分写的好。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "私觉得例子中的 convert 函数不能自解释的原因只是名字起的太烂 [微笑]  applyStarMask 多好", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我在文中特意解释了一遍，结果你还是钻了这个牛角尖，哈哈哈</p><a class=\"comment_sticker\" href=\"https://pic2.zhimg.com/v2-e213ddb29e5a2adb54d6343d5dea27d1.gif\" data-width=\"\" data-height=\"\">[摊手]</a>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "那真的举得出这样的例子吗？类成员和类名本身形成的语义为什么会差呢？说实话，这一点真的太弱，在我看来，TypeScript下好的起名下不仅少了太多 jsDoc的需要，注释的量都会大大减少。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "刘津玮", 
                    "userLink": "https://www.zhihu.com/people/b939059cecfb337f68aea732d7f446a5", 
                    "content": "我觉得ts不是不适合小项目，而是不适合临时项目，哪怕是公司官网这种规模不大的项目，只要它需要被长期维护，那么用ts就是非常值得的。不值得用ts的是类似电商活动页面这种上线几天就下而且以后再也不会维护的页面。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>项目周期也可以算一个考量的角度，「需要长期维护」可以理解为「复杂度持续上升」，累积到一定程度就会形成规模上的提升。终究还是成本上的考量。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "刘津玮"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67183229", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 37, 
            "title": "重新 Think in Hooks", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/blog/2019/05/27/rethink-in-hooks\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-f9fcd719dcab55af4a1ad3d3cfbe0585_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">重新 Think in Hooks | 博客</a><h2>为什么要重新来过？</h2><p>我之前写过 <a href=\"https://zhuanlan.zhihu.com/blog/2019/02/15/how-to-think-in-hooks\" class=\"internal\">一篇博客</a>，介绍了 Class 组件的各个生命周期钩子函数在 Hooks 中对应的方案。那时 Hooks 刚刚发布，开发者最关心的莫过于代码的迁移问题，也就是怎么把现有的 Class 组件改造成 Hooks 的方式。</p><p>尽管这种方式非常的直观有效，但很快我们就发现，事情似乎没那么简单。单纯用这个思维来考虑问题，并不能很好地解释 Hooks 的一些行为，比如 <code>useEffect</code> 中的变量有时候无法获取最新的值、命令式的回调函数也不总是按照我们的预期工作，<code>useEffect</code> 的依赖数组好像总是缺点什么。</p><p>在亲自踩了 2 个多月的坑，参与了一些 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/reactjs/zh-hans.reactjs.org/pull/121\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">React 官网的翻译工作</a>，拜读了 <a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/a-complete-guide-to-useeffect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">几篇</a> <a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/react-as-a-ui-runtime\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">非常好的</a> <a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/making-setinterval-declarative-with-react-hooks\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">博客</a> 之后，我对「如何 Think in Hooks」有了新的认识。</p><p>因此这篇博客，我们来「重新 Think in Hooks」。</p><h2>当我们讨论 Hooks 时，我们到底在讨论什么？</h2><p>要理解 Hooks，我们得先回到 Hooks 的本质 —— 一种逻辑复用的方式。</p><p>Hooks 并不是新的组件类型，当我们讨论 Hooks 时，我们讨论的其实是函数组件 —— 就是那种只是根据 props 返回相应的 JSX 的渲染函数。Hooks 的出现让函数组件可以和 Class 组件一样可以拥有 state（是可以，不是必须）。因此确切的说，我们是在讨论使用了 Hooks 的函数组件。</p><p>但是「使用了 Hooks 的函数组件」这个词太长了，而下文我又将经常提到这个词，所以在后面的文字中，我将简单用 Hooks 来表示这个概念。</p><h2>忘掉你所学</h2><p>当我们在使用 Class 组件时，每当 props 或 state 有更新，所有的修改都发生在 React 组件实例上，就像修改一个对象的属性一样。这个逻辑放到 Hooks 里是行不通的，函数组件的渲染只是简单的函数调用，不加 <code>new</code> 的函数调用是不存在所谓生成实例的。这也是很多问题产生的根源。</p><p>所以要想真正 Think in Hooks，首先你得忘记如何 Think in Class，改为 Think in Functions。</p><h2>为什么我的 state 不更新？</h2><p>Hooks 的本质是一个渲染函数，就像是把 Class 组件的 <code>render()</code> 函数单独提取出来一样。</p><p><code>render()</code> 函数在运行时会根据那一次的 props 和 state 去渲染。如果在 <code>render()</code> 函数运行期间 props 或是 state 再次发生变化，并不会影响这一次的执行，而是会触发新一轮的渲染，<code>render()</code> 再一次被调用，并且这一次传入的是变化后的 props 和 state。</p><p>到这里我们得出结论：</p><blockquote><code>render()</code> 函数中用到的 props 和 state 在函数执行的一开始就已经被确定了。<br/> </blockquote><p>好了，理论说得够多了，我们来看代码吧。假设我们有这样一个组件：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Counter</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">count</span><span class=\"p\">,</span> <span class=\"nx\">setCount</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n  <span class=\"kd\">function</span> <span class=\"nx\">onClick</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">setCount</span><span class=\"p\">(</span><span class=\"nx\">count</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">onClick</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"nx\">You</span> <span class=\"nx\">clicked</span> <span class=\"p\">{</span><span class=\"nx\">count</span><span class=\"p\">}</span> <span class=\"nx\">times</span><span class=\"o\">&lt;</span><span class=\"err\">/p&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>等价的 Class 组件实现可以是下面这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Counter</span> <span class=\"k\">extends</span> <span class=\"nx\">Component</span> <span class=\"p\">{</span>\n  <span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">count</span><span class=\"o\">:</span> <span class=\"mi\">0</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"nx\">onClick</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setState</span><span class=\"p\">({</span>\n        <span class=\"nx\">count</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">count</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n      <span class=\"p\">})</span>\n    <span class=\"p\">},</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"nx\">render</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">onClick</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"nx\">You</span> <span class=\"nx\">clicked</span> <span class=\"p\">{</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">count</span><span class=\"p\">}</span> <span class=\"nx\">times</span><span class=\"o\">&lt;</span><span class=\"err\">/p&gt;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>对比一下两段函数，如果把 Class 的语法中的所有东西全部塞到 <code>render()</code> 函数里，然后把 <code>render()</code> 函数单独拎出来，给变量和函数换个名字 —— 恭喜你，你得到了一个等效的 Hooks ！</p><p>开玩笑的，但这真的很像对不对。</p><p>现在考虑一个问题：如果我在 2 秒内点击组件 3 次，那么到第 5 秒的时候，组件会显示什么？</p><p>在类组件的实现中，结果是 3，因为触发了 3 次更新，每次都在原有的基础上加 1。</p><p>但在 Hooks 的实现中，结果意外地变成了 1。很奇怪对不对，明明是一样的逻辑，为什么结果不一样？（我向你保证这跟闭包没有关系）</p><p>如果你在 <code>onClick</code> 函数中 <code>console.log</code> 一下，你会发现点击事件确实被触发了 3 次，但是 3 次 <code>count</code> 的值是一样的。</p><p>这是为什么？</p><p>还记得我们前面的结论吗？「<code>render()</code> 函数中用到的 props 和 state 在函数执行的一开始就已经被确定了」。为了简化问题，我们可以把 Hooks 的代码中所有用到的 props 和 state 直接替换成那一次的取值：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 第一次渲染\n</span><span class=\"c1\"></span><span class=\"kd\">function</span> <span class=\"nx\">Counter</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 这里是对 useState 的等价替换\n</span><span class=\"c1\"></span>  <span class=\"k\">const</span> <span class=\"nx\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"c1\">// highlight-line\n</span><span class=\"c1\"></span>  <span class=\"k\">const</span> <span class=\"nx\">setCount</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">val</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span> <span class=\"p\">...</span> <span class=\"p\">}</span>\n\n  <span class=\"kd\">function</span> <span class=\"nx\">onClick</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">setCount</span><span class=\"p\">(</span><span class=\"mi\">0</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// highlight-line\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">onClick</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"nx\">You</span> <span class=\"nx\">clicked</span> <span class=\"mi\">0</span> <span class=\"nx\">times</span><span class=\"o\">&lt;</span><span class=\"sr\">/p&gt; /</span><span class=\"o\">/</span> <span class=\"nx\">highlight</span><span class=\"o\">-</span><span class=\"nx\">line</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>注意到第 9 行的变化了么？这就是为什么。在这 2 秒钟之内，无论点击多少次，我们都是在给组件下达同样的指令：2 秒钟后把 <code>count</code> 设置为 1。2 秒之后组件或许会被更新多次，但结果都是一样的。<code>onClick</code> 函数中 <code>count</code> 的值在一开始就已经被确定了。</p><p>那如果我想实现 Class 版本的那种效果要怎么办？可以通过给 <code>setCount()</code> 传入一个回调函数来解决（如果可以的话，我推荐在更新 state 时尽量采用这种写法，原因后面会讲到）：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Counter</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">count</span><span class=\"p\">,</span> <span class=\"nx\">setCount</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n  <span class=\"kd\">function</span> <span class=\"nx\">onClick</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">setCount</span><span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">c</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// highlight-line\n</span><span class=\"c1\"></span>    <span class=\"p\">},</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">onClick</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"nx\">You</span> <span class=\"nx\">clicked</span> <span class=\"p\">{</span><span class=\"nx\">count</span><span class=\"p\">}</span> <span class=\"nx\">times</span><span class=\"o\">&lt;</span><span class=\"err\">/p&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里表示不管 count 现在的值是多少，往上加一就好了。Class 组件中的 <code>setState()</code> 函数也有同样的写法，虽然它俩的目的并不相同。</p><h2>useEffect 的依赖数组到底应该怎么用</h2><p>这可能是刚接触 Hooks 时最让人头疼的一个问题，相信每个人都对「依赖数组里的内容会决定 Effect 是否会重新执行」这一点印象深刻，给人感觉这就是 <code>componentDidUpdate()</code> 的等效实现，按照我们对 Class 组件的认知，只要依赖数组里的内容不变，Effect 就不会重新执行；如果某个变量不参与比对的过程，就不需要出现在依赖数组中。然而依赖数组并没有我们想象的这么简单。</p><p>依赖数组真正的含义，是「这个 Effect 引用了哪些外部变量」。不管它是否参与比对的过程，只要 Effect 中引用了（也就是 Effect 依赖了这个变量），就必须出现在依赖数组中。举个例子：</p><p>在下面的代码中，我们想要实现：<code>foo</code> 或 <code>bar</code> 在被点击时自身加一，其中任何一个的变化都会触发 <code>total</code> 也加一，同时有一个 Effect 在每秒打印 <code>total</code> 的值。由于我们只需要在组件挂载时启用一下计时器就好，因此我们把依赖数组留空。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">App</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">props</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">total</span><span class=\"p\">,</span> <span class=\"nx\">setTotal</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">foo</span><span class=\"p\">,</span> <span class=\"nx\">setFoo</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">bar</span><span class=\"p\">,</span> <span class=\"nx\">setBar</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n  <span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">total</span><span class=\"p\">)</span>\n    <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"p\">[])</span>\n    \n  <span class=\"kd\">function</span> <span class=\"nx\">updateTotal</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setTotal</span><span class=\"p\">(</span><span class=\"nx\">t</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">t</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n   \n  <span class=\"kd\">function</span> <span class=\"nx\">addFoo</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setFoo</span><span class=\"p\">(</span><span class=\"nx\">f</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">f</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"nx\">updateTotal</span><span class=\"p\">()</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kd\">function</span> <span class=\"nx\">addBar</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setBar</span><span class=\"p\">(</span><span class=\"nx\">b</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">b</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"nx\">updateTotal</span><span class=\"p\">()</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"o\">&lt;&gt;</span>\n    <span class=\"o\">&lt;</span><span class=\"nx\">button</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">addFoo</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"nx\">foo</span><span class=\"p\">}</span><span class=\"o\">&lt;</span><span class=\"err\">/button&gt;</span>\n    <span class=\"o\">+</span>\n    <span class=\"o\">&lt;</span><span class=\"nx\">button</span> <span class=\"nx\">onClick</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"nx\">addBar</span><span class=\"p\">}</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"nx\">bar</span><span class=\"p\">}</span><span class=\"o\">&lt;</span><span class=\"err\">/button&gt;</span>\n    <span class=\"o\">=</span>\n    <span class=\"o\">&lt;</span><span class=\"nx\">span</span><span class=\"o\">&gt;</span><span class=\"p\">{</span><span class=\"nx\">total</span><span class=\"p\">}</span><span class=\"o\">&lt;</span><span class=\"err\">/span&gt;</span>\n  <span class=\"o\">&lt;</span><span class=\"err\">/&gt;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><br/>这个 Effect 引用了 <code>total</code> 这个变量，但是 <code>total</code> 并没有参与「是否要执行这个 Effect」的决策。按照我们之前对于 Class 组件的理解，<code>total</code> 不需要出现在依赖数组中。那么我们来执行一下这段代码。</p><p> 点击按钮，<code>foo</code> 和 <code>bar</code> 如我们预期的那样自增了，页面上 <code>total</code> 也显示了最新的值。然而控制台打印出来的 <code>total</code> 却始终为 0。</p><p> 为什么会这样？</p><p> 如我们上一节所说的，「<code>render()</code> 函数中用到的 props 和 state 在函数执行的一开始就已经被确定了」，Effect 也是 render 函数的一部分，因此同样适用这条规则，那么我们带入变量值看一下：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 初始化时\n</span><span class=\"c1\"></span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"p\">},</span> <span class=\"p\">[])</span>\n\n<span class=\"c1\">// 点击 foo\n</span><span class=\"c1\"></span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"p\">},</span> <span class=\"p\">[])</span>\n\n<span class=\"c1\">// 再点击 bar\n</span><span class=\"c1\"></span><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"p\">},</span> <span class=\"p\">[])</span> \n</code></pre></div><p>由于 <code>total</code> 并没有在依赖数组中申明，因此 <code>total</code> 的更新不会触发 Effect 重新执行，也就不会去获取它的最新值，每次执行都引用了第一次执行时候的值。</p><p> 要解决这个问题，我们可以把 <code>total</code> 加入依赖数组，告诉 Effect 当 <code>total</code> 更新时重新执行 Effect，这样依赖 Effect 就能在重新执行时获取到 <code>total</code> 的最新值了。同时注意，由于每次 <code>total</code> 改变会引起 Effect 的重新执行，因此 <code>setInterval()</code> 也会重复执行，创建多个计时器，要解决这个问题，只要让 Effect 返回一个清理函数，结束掉上一个计时器即可：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">id</span> <span class=\"o\">=</span> <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">total</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n  <span class=\"k\">return</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">clearInterval</span><span class=\"p\">(</span><span class=\"nx\">id</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">total</span><span class=\"p\">])</span> \n</code></pre></div><p>这么一来，程序就正常了。<br/><br/>现在新版的 React 已经自带了对 Hooks 规则的一些检查，当它发现一些不合规的写法（比如 Effect 中引用了外部变量，但没有在依赖数组中进行申明），就会给出提示。只要保持使用最新版的 React，理论上就可以避免这一类的错误。如果你出于某些原因不方便升级，也可以手动安装 <a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/eslint-plugin-react-hooks\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">eslint-plugin-react-hooks</a> 来进行检查。</p><p>总的来说，对于 <code>useEffect()</code> 的依赖数组，一定要牢记：</p><blockquote> 只要是 <code>useEffect()</code> 中用到的，都要在依赖数组中申明。<br/> </blockquote><p>那如果 <code>useEffect()</code> 中引用了一些不参与「是否执行 Effect」的决策的变量，我们要怎么处理这些尴尬的变量呢？别担心，方法有很多：</p><ol><li>用回调函数的方式来设置 state，以解除对某些 state 变量的引用。</li><li>如果组件内部的函数仅用于某个 Effect，可以把这个函数的定义移到 <code>useEffect()</code> 内部，以解除对某些函数的引用。</li><li>如果一些变量的存在是为了决定另一些变量（比如 url 查询参数），可以把相关逻辑抽取为独立的函数，用 <code>useCallback()</code> 进行优化，然后我们就可以把这部分变量提取到 Effect 之外去，以精简依赖数组。</li><li>实在没法优化了，还有个最简单粗暴的方法。在 <code>useEffect()</code> 中对所有参与决策的变量进行比对，判断是否发生变化，以决定是继续执行还是就此返回。</li></ol><h2>不要担心重复定义函数</h2><p>从工程学的角度，我们习惯通过缓存来避免频繁的销毁和重建同样的内容。在 Class 组件中，通过函数绑定，我们可以很轻易的做到这一点。但在 Hooks 中，我们或许需要改变一下习惯，试着接受这一类的开销。</p><p>由于函数组件的特性，它不像类组件的实例那样，存在生命周期的概念。函数组件的核心就只有一个渲染函数，即便 Hooks 引入了 state，函数组件的更新也还是重新执行整个函数，而不是在某个实例上小修小改。这样的特定就决定了函数组件内定义的函数，会在组件每次重新渲染时被销毁然后重建，即便函数本身并没有改变，只是传入的参数发生了改变。</p><p>好在，只要不是非常高频的更新，这种程度的开销并不会对我们的应用造成明显的负面影响。因此我们可以允许这种反模式的存在。</p><h2>如何在 Hooks 中发起 HTTP 请求</h2><p>在 Class 组件中，我们常见的做法是定义一个获取数据的函数，在其中读取 props 和 state，拼接出要传递的参数，好一点的做法或许还要判断一下 loading 状态以避免重复操作和异步冲突，然后发起其请求，等 Promise 被 resolve 后，处理返回的结果，更新一些 state。</p><p>但当我们尝试在 Hooks 中重现这一套路时，我们遇到了问题。要想读取最新的 props 和 state，我们就必须把发起请求的函数写到一个 Effect 中，并且所有引用到的变量都必须放进依赖数组中。这就导致我们必须非常小心地处理每一个依赖的变化，一不小心就会陷入死循环。</p><p>具体的操作，展开来篇幅太长了，这里就不展开了，推荐一篇非常全面的<a href=\"https://link.zhihu.com/?target=https%3A//www.robinwieruch.de/react-hooks-fetch-data/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">文章</a>，需要的可以看一下。这篇文章国内有不少人做了翻译，<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c98fb35518825157172acc6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这篇</a>是一个不错的译本，英文有压力的同学可以看看。</p><h2>如何使用 <code>setInterval()</code></h2><p>还有一个非常常见的命令式操作，就是设置定时器。</p><p>比如一个短信验证码的倒计时，在 Class 组件中，我们通常会这么做：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">state</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">countdown</span><span class=\"o\">:</span> <span class=\"mi\">0</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">timer</span> <span class=\"o\">=</span> <span class=\"kc\">null</span>\n\n<span class=\"nx\">startCountdown</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">duration</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setState</span><span class=\"p\">({</span> <span class=\"nx\">countdown</span><span class=\"o\">:</span> <span class=\"nx\">duration</span> <span class=\"p\">},</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">timer</span> <span class=\"o\">=</span> <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">setState</span><span class=\"p\">({</span> <span class=\"nx\">countdown</span><span class=\"o\">:</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">countdown</span> <span class=\"o\">-</span> <span class=\"mi\">1</span> <span class=\"p\">},</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">countdown</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n          <span class=\"nx\">clearInterval</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">timer</span><span class=\"p\">)</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">})</span>\n    <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n  <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>现在我们尝试改用 Hooks 来实现。</p><p>设置一个 state 用于存储当前剩余秒数，然后在 <code>setInterval()</code> 的回调函数中更新这个值（通过回调函数的写法，我们不需要引用这个 state 也能正确更新它）。很好，倒计时开始了，页面上也能获取到更新了，目前为止一切顺利。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">countdown</span><span class=\"p\">,</span> <span class=\"nx\">setCountdown</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n<span class=\"k\">const</span> <span class=\"nx\">timer</span> <span class=\"o\">=</span> <span class=\"nx\">useRef</span><span class=\"p\">()</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">startCountdown</span> <span class=\"p\">(</span><span class=\"nx\">duration</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">setCountdown</span><span class=\"p\">(</span><span class=\"nx\">duration</span><span class=\"p\">)</span>\n  <span class=\"nx\">timer</span> <span class=\"o\">=</span> <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setCountdown</span><span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">c</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>3、2、1、0、-1？问题出现了。我们希望数到 0 的时候结束倒计时，为此我们需要判断 countdown 是否为 0 以决定是否要 <code>clearInterval()</code>，然而现在我们无法直接读取 countdown 的最新值。为了能读到 countdown 的最新值，我们需要把这个逻辑放到一个 Effect 里，并把 countdown 放进依赖数组中。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"p\">[</span><span class=\"nx\">countdown</span><span class=\"p\">,</span> <span class=\"nx\">setCountdown</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nx\">useState</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">startCountdown</span> <span class=\"p\">(</span><span class=\"nx\">duration</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">setCountdown</span><span class=\"p\">(</span><span class=\"nx\">duration</span><span class=\"p\">)</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">useEffect</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">countdown</span><span class=\"p\">)</span> <span class=\"k\">return</span>\n  <span class=\"nx\">timer</span> <span class=\"o\">=</span> <span class=\"nx\">setInterval</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">setCountdown</span><span class=\"p\">(</span><span class=\"nx\">c</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">c</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nx\">countdown</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">clearInterval</span><span class=\"p\">(</span><span class=\"nx\">timer</span><span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">},</span> <span class=\"mi\">1000</span><span class=\"p\">)</span>\n<span class=\"p\">},</span> <span class=\"p\">[</span><span class=\"nx\">countdown</span><span class=\"p\">])</span>\n</code></pre></div><p>然而事情还没有结束，仔细看一下代码，不难发现每次 countdown 更新都会触发一次新的 <code>setInterval()</code>，这并不是我们想要的。并且我们没法提前结束这个计时器。</p><p>哎~明明在 Class 组件中很简单的事情，怎么到了 Hooks 中这么复杂。</p><p>解决方案看<a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/zh-hans/making-setinterval-declarative-with-react-hooks/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这里</a>，你会惊讶的。</p><h2>小结</h2><p>第一次看到官方文档中的「It takes a bit of a mindshift to start “thinking in Hooks”」这句话的时候，我并没有太当回事，觉得无非就是有一样新东西要学而已。时隔几个月再看，这句话分量还是挺重的。从 Class 到 Hooks 的变化真的很大，很多思维模式都变了，我们甚至需要接受一些曾经极力避免的反模式。</p><p>React 从一开始就推崇声明式的设计，万物皆组件，最大的感受就是路由的设计。Hooks 相比 Class 更加符合声明式的设计，从此 React 进入「万物皆函数」的时代。</p><p>如果你觉得 Hooks 是一颗重磅炸弹，我建议你了解一下 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/blog/2018/11/27/react-16-roadmap.html%23react-16x-q2-2019-the-one-with-concurrent-mode\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Concurrent Mode</a>。然后你会发现，Hooks 只是一道前菜，是为后面真正的主菜做铺垫用的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>感觉更根本的原因是因为 useState 返回的数组，第一个值永远是一个新值，而我们在使用这个值的时候，访问到的其实是老值，所以我们当然获取不到更新后的值。解决办法有两个，一个是保持我们使用的这个值不变，比如使用 useRef 来保存值；另一个就是保证我们更新值后这个值所在的函数能够重新创建，这样获取的就是更新后的变量了。比如下面改写文章中第一个 Counter 的例子中，把 count 值挂在永远不会变的 setCount 上，每次获取到的就都是最新值了</p><p><a href=\"http://link.zhihu.com/?target=https%3A//codesandbox.io/s/patient-pine-vmv7k\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">codesandbox.io/s/patien</span><span class=\"invisible\">t-pine-vmv7k</span><span class=\"ellipsis\"></span></a></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>用 ref 是一种办法，不过一般用来记录上一轮的取值，以便作对比。后面的方法属于奇技淫巧，不是很推荐。设计合理的话，是不需要这么麻烦的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "秋风", 
                            "userLink": "https://www.zhihu.com/people/b15d53a0a373975f6ad21cd5b5c86f0e", 
                            "content": "<p>我觉得你这个想法，和以前的面向对象思想就一样了。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64445722", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 4, 
            "title": "探索 React 组件之间的生命周期", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=http%3A//tonghuashuo.github.io/blog/2019/05/02/react-lifecycle\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-0edf69056144aaf512a28d0670b53b57_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">探索 React 组件之间的生命周期 | 博客</a><h2>0）写在前面</h2><p>React 组件的生命周期，相信大家都非常熟悉了，无非那么几个函数，官方文档已经写得非常清楚了。（那还有什么好说的？浪费感情！合上！）</p><p>一般我们所讨论的，都是单个组件的生命周期。如果是多个组件之间呢？比如父子组件？兄弟组件？各个周期又是什么样的？异步路由的情况呢？前阵子新出的 Hooks 呢？有几个人敢站出来说我全知道的？（反正我是不敢）</p><p>刚好也是最近遇到一些关于生命周期的问题，项目中涉及到大量的异步操作，需要清楚地知道各部分的执行顺序，借此机会整理一下。</p><h2>1）在你继续之前</h2><p>这篇文章并不是入门教学，如果你对 React 一点不了解的话，或许这篇文章并不适合你。</p><p>我假定你已经掌握 React 的基本知识，例如：组件的生命周期、Hooks 的基本概念、类组件和函数组件的区别 等，并用 React 开发过有一定复杂度的应用。</p><p>这里我们不讨论 <code>shouldComponentUpdate()</code>、<code>React.memo()</code> 等优化手段，只考虑最原始的情况。</p><p>本文以浏览器作为目标环境，React Native 和 Electron 在基本概念上是一样的，细节上的不同不作为本文的讨论重点，</p><h2>2）关于 Hooks 的生命周期</h2><p>确切地说，Hooks 并不是一种新的组件类型，它只是一种代码复用的方式，并且总是伴随着函数组件一起出现。</p><p>在 Hooks 之前，函数组件是没有 state 的概念的，因而也就不存在生命周期一说，就只是一个 render 函数。Hooks 的出现，让函数组件也可以拥有 state，相应的也就引入了生命周期的概念，具体来说也就是 <code>useEffect()</code> 和 <code>useLayoutEffect()</code> 具体何时执行的问题。</p><p>函数组件的本质是函数，而函数本身是没有生命周期的，Hooks 的出现也没有改变这一点。这里我们讨论的对象是「组件」，组件是可以有生命周期的。因此当我在后面的文字中提到 Hooks 时，我其实是在表示「使用了 Hooks 的函数组件」（虽然这个说法不是很严谨，但是这不重要，你懂我意思就好）。</p><h2>3）那么我们就来做个实验吧</h2><p>为了一探究竟，我写了一个 <a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/react-lifecycle\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Demo</a> 来模拟一些常见的用例：父子组件、兄弟组件、同步/异步路由、类组件和 Hooks、组件初始化时的异步操作（如访问 API）等。</p><p>如果你有遇到 Demo 没覆盖到的使用场景，欢迎提 Issue。</p><h3>3.1）TL,DR;</h3><p>我知道大家的时间都很宝贵，赶时间的朋友可以直接看结论；时间宽裕的朋友，我们从下一节开始细聊：</p><ol><li>同步路由，父组件在 <code>render</code> 阶段创建子组件。</li><li>异步路由，父组件在自身挂载完成之后才开始创建子组件。</li><li>挂载完成之后，在更新时，同步组件和异步组件是一样的。</li><li>无论是挂载还是更新，以 <code>render</code> 完成为界，之前父组件先执行，之后子组件先执行。</li><li>兄弟组件大体上按照在父组件中的出场顺序执行。</li><li><code>useEffect</code> 会在挂载/更新完成之后，延迟执行。</li><li>异步请求（如访问 API）何时得到响应与组件的生命周期无关，即父组件中发起的异步请求不保证在子组件挂载完成前得到响应。</li></ol><h3>3.2）挂载过程</h3><p>父子组件的挂载分为三个阶段。</p><p>第一阶段，父组件执行到自身的 <code>render</code>，解析其下有哪些子组件需要渲染，并对其中同步的子组件进行创建，挨个执行各组件到 <code>render</code>，生成到目前为止的 Virtual DOM 树，并 commit 到 DOM。</p><p>第二阶段，此时 DOM 节点已经生成完毕，组件挂载完成，开始后续流程。先依次触发同步子组件各自的 <code>componentDidMount</code> / <code>useLayoutEffect</code>，最后触发父组件的。</p><p>第三阶段，如果组件使用了 <code>useEffect</code>，则会在第二阶段之后触发 <code>useEffect</code>。如果父子组件都使用了 <code>useEffect</code>，那么子组件先触发，然后是父组件。</p><p>如果父组件中包含异步子组件，则会在父组件挂载完成后被创建。</p><p>对于兄弟组件，如果是同步路由，它们的创建顺序和在父组件中定义的出场顺序是一致的。</p><blockquote> 对于「异步的兄弟组件」，最终的加载顺序是按照 JSX 中定义的顺序，还是按照 js 文件下载完成的顺序，我暂时还不能确定。<br/> 按照我对“异步”的理解，我更倾向于认为是按照下载完成的顺序，这更符合“按需加载”的概念。<br/> 之所以会造成困扰，是因为据我目前所观察到的情况，两种顺序是一致的，我还没有遇到过后定义但先加载的情况。<br/> 大部分时候我们会以页面为单位去划分异步组件，单个页面需要加载多个异步组件的场景比较少；即便在这些少数场景中，单次需要请求的文件数量也不会很多，不至于超过浏览器的并发上限；即便超过，也会按照在父组件中定义的出场顺序去分批发起请求。考虑到单个异步组件的文件尺寸通常都很小，加载速度非常快，同一批发起的请求基本上也都是同时到达，因此大部分时候下载完成的顺序和定义的顺序是一致的。<br/> 但没遇到不代表不存在，该问题我会进一步验证，已经有结果的小伙伴也可以分享一下。<br/> </blockquote><p>如果组件的初始化过程包含异步操作（通常在 <code>componentDidMount()</code> 和 <code>useEffect(fn, [])</code> 中进行），这些操作何时得到响应与组件的生命周期无关，完全看异步操作本身花了多少时间。</p><h3>3.3）更新过程</h3><p>React 的设计遵循单向数据流模型，兄弟节点之间的通信也会经过父组件（Redux 和 Context 也是通过改变父组件传递下来的 <code>props</code> 实现的），因此任何两个组件之间的通信，本质上都可以归结为父组件更新导致子组件更新的情况。</p><p>父子组件的更新同样分为三个阶段。</p><p>第一、三阶段，和挂载过程基本一样，无非是第一阶段多了一个 Reconciliation 的过程，第三阶段需要先执行 <code>useEffect</code> 的 Cleanup 函数。</p><p>第二阶段，和挂载过程也很类似，都是子组件先于父组件，但更新比挂载涉及的函数要多一些：</p><ol><li><code>getSnapshotBeforeUpdate()</code></li><li><code>useLayoutEffect() 的 Cleanup</code></li><li><code>useLayoutEffect()</code> / <code>componentDidUpdate()</code></li></ol><p>React 会按照上面的顺序依次执行这些函数，每个函数都是各个子组件的先执行，然后才是父组件的执行。具体说来，就是先执行各个子组件的 <code>getSnapshotBeforeUpdate()</code>，然后是父组件的 <code>getSnapshotBeforeUpdate()</code>，再然后是各个子组件的 <code>componentDidUpdate()</code>，父组件的 <code>componentDidUpdate()</code>，以此类推。</p><p>这里我们把类组件和 Hooks 的生命周期函数放在了一起，因为父子组件可以是这两种组件类型的任意排列组合。实际渲染时不一定每一个函数都有用到，只会调用组件实际拥有的函数。</p><h3>3.4）卸载过程</h3><p>卸载过程涉及到 <code>componentWillUnmount()</code>、<code>useEffect()</code> 的 Cleanup、<code>useLayoutEffect()</code> 的 Cleanup 这三种函数，顺序固定为父组件的先执行，子组件按照在 JSX 中定义的顺序依次执行各自的方法。</p><p>注意，此时的 Cleanup 函数会按照在代码中定义的顺序先后执行，与函数本身的特性无关。</p><p>如果卸载旧组件的同时伴随有新组件的创建，新组件会先被创建并执行完 <code>render</code>，然后卸载不需要的旧组件，最后新组件执行挂载完成的回调。</p><h2>4）Hooks 的特别之处</h2><p>根据 React 的官方文档，<code>useEffect()</code> 和 <code>useLayoutEffect()</code> 都是等效于 <code>componentDidUpdate()</code> / <code>componentDidMount()</code> 的存在，但实际上两者在一些细节上还是有所不同：</p><h3>4.1）先来未必先走</h3><p><code>useLayoutEffect()</code> 永远比 <code>useEffect()</code> 先执行，即便在你的代码中 <code>useEffect()</code> 是写在前面的。所以 <code>useLayoutEffect()</code> 才是事实上和 <code>componentDidUpdate()</code> / <code>componentDidMount()</code> 平起平坐的存在。</p><p><code>useEffect()</code> 会在父子组件的 <code>componentDidUpdate()</code> / <code>componentDidMount()</code> 都触发之后才被触发。当父子组件都用到 <code>useEffect()</code> 时，子组件中的会比父组件中的先触发。</p><h3>4.2）不团结的 Cleanup</h3><p>同样都拥有 Cleanup 函数，<code>useLayoutEffect()</code> 和它的 Cleanup 未必是挨着的。</p><p>当父组件是 Hooks、子组件是 Class 时，能够很明显看出，<code>useLayoutEffect()</code> 的 Cleanup 会在 <code>getSnapshotBeforeUpdate()</code> 和 <code>componentDidUpdate()</code> 之间被调用，而 <code>useLayoutEffect()</code> 则是和 <code>componentDidUpdate()</code> 同级，按照更新过程的顺序被调用。</p><p>Hooks 作为子组件时也是这么个过程，只是没有了子组件，看上去不那么明显罢了。</p><p>而 <code>useEffect()</code> 就不一样，它和它的 Cleanup 紧密团结在一起，每次执行都是前后脚一起的，从不分离。</p><h2>5）小结</h2><p>无论是类组件还是 Hooks，单拎出来大家肯定都很熟悉它们的生命周期，但当把它们混在一起，就没那么简单了。撰写这篇博客的过程，帮助我理清了这通乱麻，但愿也能够帮到坚持看到这里的你。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e2512d6fb3bbfb5d563a92e7b471d96f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57376166", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 2, 
            "title": "如何 Think in Hooks", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=http%3A//tonghuashuo.github.io/blog/2019/02/15/how-to-think-in-hooks\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-26d13ef2591ee05a3c4bba7fc34daa88_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何 Think in Hooks | 博客</a><h2>喜迎 Hooks</h2><p>正当中国人民还沉浸在过年的忙碌中，在世界的另一头，React 团队的小伙伴们一点也没闲着，他们写了 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/blog/2019/02/06/react-v16.8.0.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一篇博客</a> ，并借此正式发布了 Hooks —— 一个官方宣传了好久、开发者们也期待了好久的新特性。</p><p>Hooks 正式发布于 v16.8.0，但由于官方团队的 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/blog/2018/12/19/react-v-16-7.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">一点点小失误</a>，在 v16.7.0-alpha.1 中就已经包含了 Hooks 的部分代码。好在 Dan Abramov 之前在 React Conf 上一再强调这还只是实验特性，API 随时有可能会改，欢迎早期反馈，但不建议用于生产环境；官方在事后也及时发文说明了原委，并表示“以后注意”。算是一个小插曲吧，无伤大雅。</p><h2>稳住，别急</h2><p>最近把 Hooks 部分的文档通读了一遍，加上去年 React Conf 上几个关于 Hooks 的演讲，对 Hooks 的概念及用法有了基本的了解。</p><p>作为可能是 React 继 Fiber 之后最大的改变，官方团队真的是慎之又慎。下面这些话摘自 React 官方文档中关于 Hooks 的部分：</p><blockquote>You don’t have to learn Hooks right now.<br/>你不必现在就学习 Hooks。<br/>There is no rush to migrate to Hooks. It takes a bit of a mindshift to start “thinking in Hooks”.<br/>不用着急马上迁移到 Hooks，开始“以 Hooks 的方式思考”需要一点点思维上的转变。<br/>It is an early time for Hooks, and some third-party libraries might not be compatible with Hooks at the moment.<br/>Hooks 目前尚处于早期阶段，一些第三方库目前可能还不兼容 Hooks。<br/>We intend for Hooks to cover all existing use cases for classes, but we will keep supporting class components for the foreseeable future.<br/>我们计划让 Hooks 覆盖 class 的所有现有使用场景，但在可见的未来里我们还是会继续支持 class 组件。<br/>There are no plans to remove classes from React.<br/>我们不打算把 class 从 React 中移除。<br/>Conceptually, React components have always been closer to functions.<br/>从概念上讲，React 组件一直以来都更接近函数。</blockquote><p>类似的表述在官方文档中随处可见。可以看出，官方对 Hooks 的态度非常明确：<b><i>未来是属于 Hooks 的</i></b>。</p><p>但路得一步一步走，官方对开发者也是一再表示：</p><ol><li>Hooks 是可选的，老代码不用改。</li><li>Hooks 的概念很新，别着急用。</li><li>放心，Class 还在。（至少短期内）</li></ol><h2>迁移到 Hooks</h2><p>相信大部分人在学习 Hooks 时都想过：我已经有一个函数组件 / class 组件了，要怎么把它改造成用 Hooks 实现呢？这个弯要是转不过来，后面的事情就很难办了。</p><p>Hooks 的方案，可以简单理解为把 class 独有的东西全都整合到函数组件中去，最终让所有组件变成函数，主要涉及几个方面：</p><h2>1. state</h2><p>定义一个组件时，到底应该用函数还是用 Class，这是过去大家一直非常关心的问题，最核心的一点就是：组件是否包含 state。</p><p>Hooks 通过 <code>useState()</code> 把 state 引进了函数，并且相比在 Class 中的语法还更加简洁。</p><h2>2. 生命周期</h2><p>使用 Class 的另一个原因就是生命周期函数，Hooks 去掉了生命周期函数，改为用 <code>useEffect()</code> 等方法实现。因此如果我们能够给每个生命周期函数都找到对应的解决办法，问题不就解决了嘛。让我们按照这个思路来试一下：</p><blockquote>这里我们只讨论 React 16 开始的新的生命周期方法，<code>UNSAFE_</code> 开头的方法由于要被废除了，就不再讨论了。</blockquote><h2>2.1. <code>componentDidUpdate()</code></h2><p>Hooks 使用 <code>useEffect(callback[, depends])</code> 替代 <code>componentDidUpdate()</code> 来处理“副作用（Side Effect，简称 Effect）”。</p><p>Effect 会在每次 render 完成之后被执行，刚好就是 <code>componentDidUpdate()</code> 触发的时机。可以在 callback 中通过条件判断来决定具体要执行哪些逻辑，也可以通过 <code>useEffect()</code> 的第二个参数，传入一个数组，数组中放入需要检查的属性，只有当数组里的属性和上一次不同时，callback 才会被执行。</p><p>Hooks 的设计目的之一，就是让相关的逻辑靠得更近，让不相关的逻辑独立开来，因此如果组件中包含有多种不同的副作用，最好交给不同的 <code>useEffect()</code> 去处理。</p><h2>2.2. <code>componentDidMount()</code></h2><p><code>componentDidMount()</code> 同样也用于处理副作用，因此也是通过 <code>useEffect()</code> 实现。</p><p><code>componentDidMount()</code> 和 <code>componentDidUpdate()</code> 都是在 render 之后被触发，最大的不同在于前者仅在第一次触发，后者从第二次开始往后都会触发。因此只要能够区分触发的时机，就能够用同样的函数来完成两个阶段的任务。</p><blockquote>Instead of thinking in terms of “mounting” and “updating”, you might find it easier to think that effects happen “after render”.<br/>不用纠结“挂载”还是“更新”，你只需要简单认为“副作用发生在 render 之后”就好了。</blockquote><p>只需要在第二个参数位置传入一个空数组，告知该 Effect 不依赖任何属性的变化，即可将其和 <code>componentDidUpdate()</code> 区分开来。</p><p>同样的，不同的副作用应该交给不同的 <code>useEffect()</code> 去处理。</p><h2>2.3. <code>componentWillUnmount()</code></h2><p><code>useEffect()</code> 默认不需要返回任何东西，但如果你希望某个副作用在下一次执行之前先做点什么（比如清理一些旧数据），可以在 <code>useEffect()</code> 的 callback 中返回一个 cleanup 函数，在这个函数中定义的内容会在 Effect 下一次被调用之前执行。</p><p>如果此时 <code>useEffect()</code> 的第二个参数刚好是个空数组，那么就只会在组件销毁时被触发，起到 <code>componentWillUnMount()</code> 的作用，否则就相当于是 <code>componentDidUpdate()</code> 的一部分。</p><h2>2.4. <code>getDerivedStateFromProps()</code></h2><p>在 Hooks 的设计中，是没有这个环节的，相关逻辑全部通过用 <code>useEffect()</code> 触发 update 来实现。</p><h2>2.5. <code>shouldComponentUpdate()</code></h2><p>函数式组件可以使用 <code>React.memo(renderFn, areEqualFn)</code> 来进行性能优化。</p><p><code>React.memo()</code> 默认相当于 <code>React.PureComponent</code>，通过对 props 进行浅比较来决定是否要更新。但我们可以通过其中的 <code>areEqualFn</code> 来自定义判断的方式，起到 <code>shouldComponentUpdate()</code> 的作用。</p><p>需要注意的是， <code>areEqualFn</code> 如果返回 true 表示两次的 props 相同，不更新，这一点和 <code>shouldComponentUpdate()</code> 刚好相反。从函数命名上也能看出来。</p><p>另外，由于 <code>React.memo()</code> 仅适用于函数式组件，因此只比较 props，不比较 state。</p><h2>2.6. <code>getSnapshotBeforeUpdate()</code>、<code>componentDidCatch()</code></h2><p>目前还没有针对这两个生命周期函数的替代方案，但官方表示未来会有的。</p><p>前者用的比较少，影响不大；后者意味着 Error Boundary 在 Hooks 中暂时还用不了，不过如果组件设计的合理的话，不用也没问题。</p><h2>2.7. <code>forceUpdate()</code></h2><p>严格说来，这个函数不属于生命周期，但是因为和生命周期息息相关，所以放了进来。</p><p>React 保留了这个函数，用于在实在没办法的情况下强制触发一次 update。注意使用时候前面不用加 <code>this.</code>，直接调用即可。</p><h2>Thinking in Hooks</h2><p>除了语法上的变化，Hooks 在代码设计思想上也有不小的变化。如果你已经决定要开始使用 Hooks，那么有些观念需要转变一下：</p><h2>1. 用自定义 Hook 代替 Render Props 和 HOC</h2><p>在 Hooks 出现之前，想要在组件之间复用一段逻辑通常会使用 Render Props 和 High-Order Component 来解决。</p><p>在 React “一切皆组件”的思想下，我们早已习惯了这样的思维模式。与此同时，我们也习惯了另一件事：包裹器地狱（wrapper hell），组件层层嵌套，子子孙孙无穷无尽。</p><p>Hooks 通过自定义 Hook 把可复用的逻辑抽取出来，成为一个普通函数。组件间复用逻辑就像复用一个工具函数一样。</p><h2>2. 按业务逻辑拆分代码，而不是生命周期</h2><p>在 Class 中，我们按生命周期来拆分代码，这就导致一些紧密相关的业务被拆分到不同函数中，同一函数中可能包含了多个不相关的业务。</p><p>从计算机的角度，生命周期固然非常重要，必须熟练掌握；但从写代码的目的来看，业务逻辑才是我们关心的重点。</p><p>Hooks 把代码按照业务逻辑的相关性进行拆分，把同一业务的代码集中在一起，不同的业务的代码独立开来，维护起来就清楚很多。</p><h2>最后</h2><p>Hooks 从设计思路上讲，确实会比 Class 更符合直觉一点。具体在使用上还会不会有别的坑，等大家再使用一段时间看看吧。</p><p>Happy Hooking !</p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "呆毛王的亲卫兵", 
                    "userLink": "https://www.zhihu.com/people/6e457d30248cb24aca979620650510ee", 
                    "content": "<p>useEffect的第二个参数为[]的时候，并不能算作彻底区分componentDidUpdated和componentDidMounted，useEffect第二个参数为空的时候，每次（包括第一次）都会被调用，而componentDidUpdated在第一次挂载时是不会被调用的。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57376013", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 5, 
            "title": "你可能已经知道的 ES 2018 和 2019", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=http%3A//tonghuashuo.github.io/blog/2019/02/11/es2018-and-es2019\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-5646b4878e533cd7c725ce4c17984071_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">你可能已经知道的 ES 2018 和 2019 | 博客</a><h2>标准这事儿吧……</h2><p>ES 2019（ES 10）标准于年前正式发布，借此机会，我们来看看都有哪些特性有幸转正吧。顺带把 ES 2018 的内容也补一下。</p><p>ECMAScript 标准的制定过程，自 2015 年大改，至今已经是第 5 个年头了，想必大家都心里有数了。与 Java 等语言不同，JS 并非先制定标准再开始使用，恰恰相反，是大家先用着，觉得合适的，才收录进标准。标准的存在更像是一个“年度优秀特性合集”。对绝大部分开发者来说，一项特性进没进标准不重要，Babel 支不支持才重要。标准你随便写，不用 Babel 算我输。</p><p>那么接下来，我们就来看看 2018 和 2019 两个年度的大合集都有些啥吧。</p><h2>ES2018（ES9）</h2><h2>1）异步迭代器（Asynchronous Iteration）</h2><p>总有那么些时候，我们会想要同步执行一些异步的操作，比如下面这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">actions</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span>\n  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">),</span>\n  <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n<span class=\"p\">]</span>\n</code></pre></div><p>利用 <code>async / await</code> 语法，我们可以很轻松的做到这点。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">process</span> <span class=\"p\">(</span><span class=\"nx\">actions</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"nx\">action</span> <span class=\"k\">of</span> <span class=\"nx\">actions</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kr\">await</span> <span class=\"nx\">asyncFunc</span><span class=\"p\">(</span><span class=\"nx\">action</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上面的写法，会按顺序执行 <code>asyncFunc</code>，上一个结束之后才会开始下一个，每次得到的 <code>action</code> 都是一个异步操作本身（比如这里是一个 Promise 对象）。</p><p>ES 2018 为我们提供了一种新的方式，在前面代码的基础之上，让每次得到的 <code>action</code> 直接是异步操作完成之后的结果（比如这里是 Promise 被 resolve 之后的结果）。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kr\">async</span> <span class=\"kd\">function</span> <span class=\"nx\">process</span> <span class=\"p\">(</span><span class=\"nx\">actions</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">for</span> <span class=\"kr\">await</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"nx\">action</span> <span class=\"k\">of</span> <span class=\"nx\">actions</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">asyncFunc</span><span class=\"p\">(</span><span class=\"nx\">action</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>2）Rest/Spread Properties 开始适用于对象</h2><p>这是一个从 ES 2015 开始就被广泛使用的特性，只不过 ES 2015 的标准只支持用于数组，从 ES 2018 开始也支持对象了。</p><p>事实上 Map、Set、String 同样支持 <code>...</code>，但具体是哪个版本引入的我还真没数。（反正我已经用了很久了，不管了）</p><h2>3）Promise.finally</h2><p>正如它的名字，finally。这也是个用了好久终于进标准的特性。</p><p>在处理 Promise 的返回时，我们经常会遇到这样的情况：无论结果状态是 resolved 还是 rejected，都执行一样的逻辑。</p><p>早先遇到这种情况，我们不得不在 <code>then()</code> 和 <code>catch()</code> 里都写一遍，现在可以一次性写在 <code>finally()</code> 里。一个 <code>finally()</code> 就等价于一组回调函数相同的 <code>then()</code> 和 <code>catch()</code>。</p><p>虽然名字叫“最终”，但并不代表这是 Promise 执行的终点。<code>finally()</code> 后面还可以继续跟 <code>then()</code> 和 <code>catch()</code>，无限跟。</p><h2>4）移除对“在‘带标签的模版字面量’中使用非法转义序列”的限制</h2><p>从这里开始的内容比较高阶，一般用不到，赶时间的话你可以跳过，直接去看 ES 2019。</p><p>这一节的标题有点绕，我们拆开来讲。首先是“带标签的模版字面量”。</p><p>ES 2015 引入了“模板字面量”的特性，相信大家都很熟悉了，长这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;John&#39;</span>\n<span class=\"k\">const</span> <span class=\"nx\">greetings</span> <span class=\"o\">=</span> <span class=\"sb\">`Hi, </span><span class=\"si\">${</span><span class=\"nx\">name</span><span class=\"si\">}</span><span class=\"sb\">`</span> <span class=\"c1\">// &#39;Hi, John&#39;\n</span></code></pre></div><p>这个特性有一个生僻用法，它允许我们自定义一个字符串模板函数，比如下面这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">myTag</span><span class=\"p\">(</span><span class=\"nx\">strings</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// strings: [&#39;that &#39;, &#39; is a &#39;, &#39;&#39;]\n</span><span class=\"c1\"></span>\n  <span class=\"k\">const</span> <span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"nx\">params</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n  <span class=\"k\">const</span> <span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"nx\">params</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n  <span class=\"k\">const</span> <span class=\"nx\">title</span> <span class=\"o\">=</span> <span class=\"nx\">age</span> <span class=\"o\">&gt;</span> <span class=\"mi\">99</span> <span class=\"o\">?</span> <span class=\"s1\">&#39;centenarian&#39;</span> <span class=\"o\">:</span> <span class=\"s1\">&#39;youngster&#39;</span>\n\n  <span class=\"k\">return</span> <span class=\"nx\">strings</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nx\">name</span> <span class=\"o\">+</span> <span class=\"nx\">strings</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"nx\">title</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">person</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Mike&#39;</span>\n<span class=\"k\">const</span> <span class=\"nx\">age</span> <span class=\"o\">=</span> <span class=\"mi\">28</span>\n<span class=\"k\">const</span> <span class=\"nx\">output</span> <span class=\"o\">=</span> <span class=\"nx\">myTag</span><span class=\"sb\">`that </span><span class=\"si\">${</span> <span class=\"nx\">person</span> <span class=\"si\">}</span><span class=\"sb\"> is a </span><span class=\"si\">${</span> <span class=\"nx\">age</span> <span class=\"si\">}</span><span class=\"sb\">`</span>\n<span class=\"c1\">// that Mike is a youngster\n</span></code></pre></div><p>这就是“带标签的模版字面量”。尽管我严重怀疑这个用法的实用性（或许是觉得这样更加语义化？普通函数语义也不差啊？），但 ES 2018 还是选择了对这个特性进行完善。</p><p>ES 2016 为这个特性加入了对转义序列的支持，比如八进制（\\ 开头）、十六进制（\\x 开头）、Unicode 字符（\\u 开头），但前提必须是一个有效的转义序列。如果是无效的序列，会报错。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">latex</span><span class=\"sb\">`</span><span class=\"err\">\\</span><span class=\"sb\">u00A9`</span>   <span class=\"c1\">// 合法，表示“版权符号”\n</span><span class=\"c1\"></span><span class=\"nx\">latex</span><span class=\"sb\">`</span><span class=\"err\">\\</span><span class=\"sb\">unicode`</span> <span class=\"c1\">// 不合法，报错\n</span></code></pre></div><p>ES 2018 去掉了这个限制，主要是考虑到对一些领域特定语言的支持，比如 <a href=\"https://link.zhihu.com/?target=https%3A//www.latex-project.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LaTeX</a>。（学术界一种常用的标记型语言，类似 HTML，其语法会用到大量形如转义序列的指令，如<code>\\section</code>、<code>\\frac</code>、<code>\\sum</code> 等）</p><p>但去掉限制只是说不报错了，模板中的无效转义序列会被替换为 undefined。比如下面这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">myTag</span> <span class=\"p\">(</span><span class=\"nx\">template</span><span class=\"p\">,</span> <span class=\"p\">...</span><span class=\"nx\">params</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">({</span> <span class=\"nx\">template</span><span class=\"p\">,</span> <span class=\"nx\">params</span> <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">const</span> <span class=\"nx\">foo</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;foo&#39;</span>\n<span class=\"k\">const</span> <span class=\"nx\">bar</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;bar&#39;</span>\n<span class=\"nx\">myTag</span><span class=\"sb\">`aaa</span><span class=\"si\">${</span><span class=\"nx\">foo</span><span class=\"si\">}</span><span class=\"err\">\\</span><span class=\"sb\">unicode</span><span class=\"si\">${</span><span class=\"nx\">bar</span><span class=\"si\">}</span><span class=\"sb\">bbb`</span>\n<span class=\"cm\">/* {\n</span><span class=\"cm\">  template: [&#39;aaa&#39;, undefined, &#39;bbb&#39;, raw: [&#39;aaa&#39;, &#39;\\unicode&#39;, &#39;bbb]],\n</span><span class=\"cm\">  params: [&#39;foo&#39;, &#39;bar&#39;]\n</span><span class=\"cm\">} */</span>\n</code></pre></div><p>上面的代码里，<code>template</code> 是模板部分被 <code>${foo}</code> 等变量分割形成的数组；<code>params</code> 就是 <code>${foo}</code> 等变量组成的数组。可以看到，<code>\\unicode</code> 由于是无效的转义序列，被替换为 <code>undefined</code>，但在 <code>template.raw</code> 里得以保留。</p><p><code>template.raw</code> 是“带标签的模版字面量”中 <code>template</code> 参数特有的一个属性，保存了未被替换的原始字符串。</p><p>这样一来，既避免了报错，又保留了开发者自行处理这些转义序列的能力。</p><h2>5）关于正则表达式的一些改进</h2><h2>5.1）<code>s</code> 标志（dotAll 模式）</h2><p>在正则表达式中，点号 <code>.</code> 表示匹配任一单个字符，但这不包含换行符（如：<code>\\n</code>、<code>\\r</code>、<code>\\f</code> 等）。</p><p>现在可以通过在尾部增加 <code>s</code> 标志的方式，让它匹配了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"o\">/</span><span class=\"nx\">hello</span><span class=\"p\">.</span><span class=\"nx\">world</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"nx\">test</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello\\nworld&#39;</span><span class=\"p\">)</span>  <span class=\"c1\">// false\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">hello</span><span class=\"p\">.</span><span class=\"nx\">world</span><span class=\"o\">/</span><span class=\"nx\">s</span><span class=\"p\">.</span><span class=\"nx\">test</span><span class=\"p\">(</span><span class=\"s1\">&#39;hello\\nworld&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// true\n</span></code></pre></div><h2>5.2）扩展 Unicode 匹配范围</h2><p>一直以来，要编写正则表达式来匹配各种 Unicode 字符并不容易，像 <code>\\w</code>、<code>\\W</code>、<code>\\d</code> 等都只能匹配英文字符和数字，对于除此之外的字符就很难匹配了，例如非英语的文字。</p><p>幸运的是，Unicode 为每个符号添加了元数据属性，并使用它来对各种符号进行分组和描述。例如，Unicode 数据库给所有印地语字符（हिन्दी）设置了 Script 属性，取值为 Devanagari（梵文），还设置了一个 Script_Extensions 属性，同样取值为 Devanagari。我们可以通过搜索 Script=Devanagari 来得到所有印地文字符。</p><p>ES 2018 允许正则表达式通过 <code>\\p{...}</code> 来扩展 Unicode 符号的匹配范围。例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 扩展匹配范围，允许匹配希腊字符\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">reGreekSymbol</span> <span class=\"o\">=</span> <span class=\"sr\">/\\p{Script=Greek}/u</span>\n<span class=\"nx\">reGreekSymbol</span><span class=\"p\">.</span><span class=\"nx\">test</span><span class=\"p\">(</span><span class=\"s1\">&#39;π&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// true\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 扩展匹配范围，允许匹配 Emoji\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">reEmoji</span> <span class=\"o\">=</span> <span class=\"sr\">/\\p{Emoji}\\p{Emoji_Modifier}/u</span>\n<span class=\"nx\">reEmoji</span><span class=\"p\">.</span><span class=\"nx\">test</span><span class=\"p\">(</span><span class=\"s1\">&#39;✌🏽&#39;</span><span class=\"p\">)</span> <span class=\"c1\">//true\n</span></code></pre></div><p>我们还可以通过 <code>\\P{...}</code>（注意，大写 P）来去反，缩小匹配范围。</p><h2>5.3）正则表达式命名捕获组</h2><p>正则表达式支持通过括号在一个表达式中指定多个捕获组，就像下面这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span>\n  <span class=\"nx\">reDate</span> <span class=\"o\">=</span> <span class=\"sr\">/([0-9]{4})-([0-9]{2})-([0-9]{2})/</span><span class=\"p\">,</span>\n  <span class=\"nx\">match</span>  <span class=\"o\">=</span> <span class=\"nx\">reDate</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;2019-02-11&#39;</span><span class=\"p\">),</span>\n  <span class=\"nx\">year</span>   <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"c1\">// 2019\n</span><span class=\"c1\"></span>  <span class=\"nx\">month</span>  <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">],</span> <span class=\"c1\">// 02\n</span><span class=\"c1\"></span>  <span class=\"nx\">day</span>    <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">];</span> <span class=\"c1\">// 11\n</span></code></pre></div><p>这样的代码虽然可以跑通，但阅读起来比较难懂，而且修改正则有可能会影响到匹配内容的索引。</p><p>ES 2018 允许在 <code>(</code> 后立即使用符号 <code>?&lt;name&gt;</code> 对捕获组进行命名，匹配失败的会返回 <code>undefined</code>，就像下面这样：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span>\n  <span class=\"nx\">reDate</span> <span class=\"o\">=</span> <span class=\"sr\">/(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/</span><span class=\"p\">,</span>\n  <span class=\"nx\">match</span>  <span class=\"o\">=</span> <span class=\"nx\">reDate</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;2019-02-11&#39;</span><span class=\"p\">),</span>\n  <span class=\"nx\">year</span>   <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">.</span><span class=\"nx\">groups</span><span class=\"p\">.</span><span class=\"nx\">year</span><span class=\"p\">,</span>  <span class=\"c1\">// 2019\n</span><span class=\"c1\"></span>  <span class=\"nx\">month</span>  <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">.</span><span class=\"nx\">groups</span><span class=\"p\">.</span><span class=\"nx\">month</span><span class=\"p\">,</span> <span class=\"c1\">// 02\n</span><span class=\"c1\"></span>  <span class=\"nx\">day</span>    <span class=\"o\">=</span> <span class=\"nx\">match</span><span class=\"p\">.</span><span class=\"nx\">groups</span><span class=\"p\">.</span><span class=\"nx\">day</span>   <span class=\"c1\">// 11\n</span></code></pre></div><p>命名捕获组也可以用在 <code>replace()</code> 中，用 <code>$&lt;name&gt;</code> 进行引用（注意，虽然这里的语法和模板字面量很像，但并不是）。例如改变日期格式的顺序：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span>\n  <span class=\"nx\">reDate</span> <span class=\"o\">=</span> <span class=\"sr\">/(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-9]{2})-(?&lt;day&gt;[0-9]{2})/</span><span class=\"p\">,</span>\n  <span class=\"nx\">d</span>      <span class=\"o\">=</span> <span class=\"s1\">&#39;2019-02-11&#39;</span><span class=\"p\">,</span>\n  <span class=\"nx\">usDate</span> <span class=\"o\">=</span> <span class=\"nx\">d</span><span class=\"p\">.</span><span class=\"nx\">replace</span><span class=\"p\">(</span><span class=\"nx\">reDate</span><span class=\"p\">,</span> <span class=\"s1\">&#39;$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// 02-11-2019\n</span></code></pre></div><h2>5.4）正则表达式的反向断言（lookbehind）</h2><p>正则表达式支持正向断言（lookahead），例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 正向肯定查找\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">x</span><span class=\"p\">(</span><span class=\"o\">?=</span><span class=\"nx\">y</span><span class=\"p\">)</span><span class=\"o\">/</span> <span class=\"c1\">// 匹配 x，但仅当 x 后面紧跟着 y 时\n</span><span class=\"c1\"></span><span class=\"sr\">/Jack(?=Sprat)/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;JackSprat&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// &#39;Jack&#39;\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">Jack</span><span class=\"p\">(</span><span class=\"o\">?=</span><span class=\"nx\">Sprat</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;JackFrost&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// null\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">Jack</span><span class=\"p\">(</span><span class=\"o\">?=</span><span class=\"nx\">Sprat</span><span class=\"o\">|</span><span class=\"nx\">Frost</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;JackFrost&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// &#39;Jack&#39;\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 正向否定查找\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">x</span><span class=\"p\">(</span><span class=\"o\">?!</span><span class=\"nx\">y</span><span class=\"p\">)</span><span class=\"o\">/</span> <span class=\"c1\">// 匹配 x，但仅当 x 后面不紧跟着 y 时\n</span><span class=\"c1\"></span><span class=\"sr\">/Jack(?!Sprat)/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;JackSprat&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// null\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"nx\">Jack</span><span class=\"p\">(</span><span class=\"o\">?!</span><span class=\"nx\">Sprat</span><span class=\"p\">)</span><span class=\"o\">/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;Jack Sprat&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// &#39;Jack&#39;\n</span></code></pre></div><p>ES 2018 引入了工作方式相同，但是方向相反的反向断言（lookbehind），语法上的差别就在于 <code>?</code> 变成了 <code>?&lt;</code>，例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 反向肯定断言\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"o\">?&lt;</span><span class=\"nx\">x</span><span class=\"p\">)</span><span class=\"nx\">y</span><span class=\"o\">/</span> <span class=\"c1\">// 匹配 y，但仅当它紧跟在 x 后面时\n</span><span class=\"c1\"></span><span class=\"sr\">/(?&lt;=\\D)\\d+/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;$123.89&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\">// 123.89\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 反向否定断言\n</span><span class=\"c1\"></span><span class=\"o\">/</span><span class=\"p\">(</span><span class=\"o\">?&lt;!</span><span class=\"nx\">x</span><span class=\"p\">)</span><span class=\"nx\">y</span><span class=\"o\">/</span> <span class=\"c1\">// 匹配 y，但仅当它紧跟在 x 后面时\n</span><span class=\"c1\"></span><span class=\"sr\">/(?&lt;!\\D)\\d+/</span><span class=\"p\">.</span><span class=\"nx\">exec</span><span class=\"p\">(</span><span class=\"s1\">&#39;$123.89&#39;</span><span class=\"p\">)[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"c1\">// null\n</span></code></pre></div><h2>ES 2019（ES 10）</h2><h2>1）JSON 成为 ECMAScript 的完全子集</h2><p>从学习 JSON 的第一课起，我们就被告知 JSON 应该是专为 JavaScript 而存在的，因此 JSON 是 JavaScript 的子集这一点应该毫无争议啊，这算什么新特性！？</p><p>然而细心的开发者却发现，有两个符号是例外：行分隔符（U + 2028）和段分隔符（U + 2029）。在 <code>JSON.parse()</code> 中使用这两个会报语法错误。</p><p>ES 2019 把这两个也收入囊中，从今往后，JSON 真正成为 ECMAScript 的完全子集，一个都不少。</p><h2>2）更友好的 <code>JSON.stringify()</code></h2><p>过去，对于一些超出 Unicode 范围的转义序列，<code>JSON.stringify()</code> 会输出未知字符。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"s1\">&#39;\\uDF06\\uD834&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// &#39;&#34;��&#34;&#39;\n</span><span class=\"c1\"></span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"s1\">&#39;\\uDEAD&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// &#39;&#34;�&#34;&#39;\n</span></code></pre></div><p>现在，<code>JSON.stringify()</code> 会为其重新转义，显示为有效的 Unicode 序列。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"s1\">&#39;\\uDF06\\uD834&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// &#39;&#34;\\\\udf06\\\\ud834&#34;&#39;\n</span><span class=\"c1\"></span><span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"s1\">&#39;\\uDEAD&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// &#39;&#34;\\\\udead&#34;&#39;\n</span></code></pre></div><p>这和 ES 2018 中对“带标签的模板字面量”的修正，似乎有些许联系。结合历代 ECMAScript 标准，ECMAScript 在处理 Unicode 的问题上着实下了不少功夫。</p><h2>3）<code>Function.prototpye.toString()</code> 显示更加完善</h2><p>对一个函数使用 <code>toString()</code> 会返回函数定义的内容。</p><p>过去，返回的内容中 <code>function</code> 关键字和函数名之间的注释，以及函数名和参数列表左括号之间的空格，是不会被打出来的。ES 2019 现在回精确返回这些内容，函数怎么定义的，这就就怎么显示。</p><h2>4）<code>Array.prorptype.flat()</code> 和 <code>Array.prorptype.flatMap()</code></h2><p>ES 2019 为数组新增两个函数。</p><p><code>flat()</code> 用于对数组进行降维，它可以接收一个参数，用于指定降多少维，默认为 1。降维最多降到一维。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">array</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]]]</span>\n<span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">flat</span><span class=\"p\">()</span> <span class=\"c1\">// [1, 2, [3]]\n</span><span class=\"c1\"></span><span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">flat</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"c1\">// [1, 2, [3]]，默认降 1 维\n</span><span class=\"c1\"></span><span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">flat</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"c1\">// [1, 2, 3]\n</span><span class=\"c1\"></span><span class=\"nx\">array</span><span class=\"p\">.</span><span class=\"nx\">flat</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\">// [1, 2, 3]，最多降到一维\n</span></code></pre></div><p><code>flatMap()</code> 允许在对数组进行降维之前，先进行一轮映射，用法和 <code>map()</code> 一样。然后再将映射的结果降低一个维度。可以说 <code>arr.flatMap(fn)</code> 等效于 <code>arr.map(fn).flat(1)</code>。（但是根据 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MDN</a>，<code>flatMap()</code> 在效率上略胜一筹）</p><p><code>flatMap()</code> 也可以等效为 <code>reduce()</code> 和 <code>concat()</code> 的组合，下面这个案例来自 <a href=\"https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap%23%25E7%25AD%2589%25E4%25BB%25B7%25E6%2593%258D%25E4%25BD%259C\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MDN</a>，但是……这不是一个 <code>map</code> 就能搞定的事么？</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">arr1</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">];</span>\n\n<span class=\"nx\">arr1</span><span class=\"p\">.</span><span class=\"nx\">flatMap</span><span class=\"p\">(</span><span class=\"nx\">x</span> <span class=\"p\">=&gt;</span> <span class=\"p\">[</span><span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">]);</span>\n<span class=\"c1\">// 等价于\n</span><span class=\"c1\"></span><span class=\"nx\">arr1</span><span class=\"p\">.</span><span class=\"nx\">reduce</span><span class=\"p\">((</span><span class=\"nx\">acc</span><span class=\"p\">,</span> <span class=\"nx\">x</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">acc</span><span class=\"p\">.</span><span class=\"nx\">concat</span><span class=\"p\">([</span><span class=\"nx\">x</span> <span class=\"o\">*</span> <span class=\"mi\">2</span><span class=\"p\">]),</span> <span class=\"p\">[]);</span>\n<span class=\"c1\">// [2, 4, 6, 8]\n</span></code></pre></div><p><code>flat()</code> 和 <code>flatMap()</code> 都是返回新的数组，原数组不变。</p><h2>5）<code>String.prototype.trimStart()</code> 和 <code>String.prototype.trimEnd()</code></h2><p>ES 2019 为字符串也新增了两个函数：<code>trimStart()</code> 和 <code>trimEnd()</code>。用过 <code>trim()</code> 的朋友都知道了，这两个函数各自负责只去掉单边的多余空格。<code>trim()</code> 是两边都去。</p><h2>6）<code>Object.fromEntries()</code></h2><p>从名字就能看出来，这是 <code>Object.entries()</code> 的逆过程。</p><h2>7）<code>Symbol.prototype.description</code></h2><p>Symbol 是 ES 2015 引入的新的原始类型，通常在创建 Symbol 时我们会附加一段描述。过去，只有把这个 Symbol 转成 String 才能看到这段描述，而且外层还套了个 &#39;Symbol()&#39; 字样。ES 2019 为 Symbol 新增了 <code>description</code> 属性，专门用于查看这段描述。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">sym</span> <span class=\"o\">=</span> <span class=\"nx\">Symbol</span><span class=\"p\">(</span><span class=\"s1\">&#39;The description&#39;</span><span class=\"p\">);</span>\n<span class=\"nb\">String</span><span class=\"p\">(</span><span class=\"nx\">sym</span><span class=\"p\">)</span> <span class=\"c1\">// &#39;Symbol(The description)&#39;\n</span><span class=\"c1\"></span><span class=\"nx\">sym</span><span class=\"p\">.</span><span class=\"nx\">description</span> <span class=\"c1\">// &#39;The description&#39;\n</span></code></pre></div><h2>8）可选的 <code>catch</code> 绑定</h2><p><code>try...catch</code> 的语法大家都很熟悉了，过去，<code>catch</code> 后面必须有一组括号，里面用一个变量（通常叫 <code>e</code> 或者 <code>err</code>）代表错误信息对象。现在这部分是可选的了，如果异常处理部分不需要错误信息，我们可以把它省略，像写 <code>if...else</code> 一样写 <code>try...catch</code>。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">try</span> <span class=\"p\">{</span>\n  <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nb\">Error</span><span class=\"p\">(</span><span class=\"s1\">&#39;Some Error&#39;</span><span class=\"p\">)</span>\n<span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">{</span>\n  <span class=\"nx\">handleError</span><span class=\"p\">()</span> <span class=\"c1\">// 这里没有用到错误信息，可以省略 catch 后面的 (e)。\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h2>遗憾</h2><p>ES 2019 收录了非常多好用的特性，但还是有很多我们非常熟悉，甚至已经用了好久的特性没能进入标准，比如：</p><ul><li>Stage 3（明年见？）</li><ul><li>Dynamic Import</li><li>私有属性</li></ul><li>Stage 2（加油？）</li><ul><li>装饰器</li></ul><li>Stage 1（你们慢慢讨论，我们先用为敬）</li><ul><li>Observable</li><li>Promise.try</li><li>String.prototype.replaceAll</li><li>do</li></ul></ul><p>不过这不重要，标准只是官宣，只要 Babel 支持就好，哈哈哈哈哈哈。</p>", 
            "topic": [
                {
                    "tag": "ECMAScript", 
                    "tagLink": "https://api.zhihu.com/topics/19600610"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "simon3000", 
                    "userLink": "https://www.zhihu.com/people/56f3795b634a0e8123c1f87469ded13a", 
                    "content": "<p>replaceAll还没好2333</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我之前一直以为这应该是原生的语法，结果并不是。但可以通过正则加 g 标识来实现。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "simon3000"
                        }, 
                        {
                            "userName": "simon3000", 
                            "userLink": "https://www.zhihu.com/people/56f3795b634a0e8123c1f87469ded13a", 
                            "content": "<p>嗯，我几个小时前就写了一个正则加g...</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "杨树", 
                    "userLink": "https://www.zhihu.com/people/81320240e25f6efa8c253db88163d315", 
                    "content": "私有属性、装饰器，要把JavaScript变成JavaPlus", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57375824", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 172, 
            "title": "除了 SSR，就没有别的办法了吗？", 
            "content": "<p>本文首发于我的博客：</p><a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/blog/2019/02/07/explore-static-site-generation\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-c2ac5cf49eafd77a1b2ce1fab7f53515_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"675\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">除了 SSR，就没有别的办法了吗 | 博客</a><h2>SSR 出啥事了</h2><p>放心，SSR 没出事。</p><p>写这篇博客并不是想说 SSR 有什么不好，而是因为一些别的原因。</p><h2>想象一个这样的场景</h2><p>作为有追求的开发者，我们都希望自己能够负责一些比较有技术难度的项目。但作为公司业务来说，总会有一些比较简单的需求，需要做几个静态页，比如产品官网、活动页之类的。这些需求虽然没什么挑战性，但总得有人来做。</p><h2>没有什么是 jQuery 一把梭搞不定的</h2><p>一般接到这类“简单”的需求，相信绝大部分人的第一反应肯定是 jQuery，尽管它早已落入前端鄙视链的最底层，但依然魅力不减，宝刀未老。配合 BootStrap 又是一把梭，分分钟搞定。</p><p>时至今日，这套方案依然可行，很好的满足了业务的需求，对开发者的技术要求也不高，可以说是非常稳了。</p><p>那不就行了，你还担心啥？</p><h2>教练，我想打篮球</h2><p>这是一个属于 MVVM 的时代，即便是刚入行的新人也都知道：jQuery 不是终点。</p><p>Angular、React、Vue，不管谁是你的本命，一旦入坑，就再也回不去了。即便不为框架故，ES 2015+ 了解一下？LESS、SCSS 了解一下？Pug、EJS 了解一下？用了这些那肯定逃不开 Babel、Gulp、Webpack 了吧？</p><p>See？不是 jQuery 不行了，而是行业的发展，让开发者更倾向于（至少已经习惯于）用 MVVM 来开发。</p><h2>老生常谈 SEO</h2><p>MVVM 的开发体验是不错，极大的解放了前端开发者的生产力。但和 MVVM 经常一起出现的还有另一个让人又爱又恨的东西，叫 SPA。</p><p>SPA 的体验非常好，页面切换非常自然。但 SPA 最大的问题，就是缺少对 SEO 的支持。</p><p>为了解决这个问题，主流 MVVM 技术栈都提供了对应的 SSR 的方案。</p><p>SSR 从根本上解决了 SEO 的问题，但是实践起来比较麻烦。一方面上手难度较高：必须使用 Node.js、业务代码要进行同构化改造、Webpack 需要多一套配置、第三方库需要审查是否支持 SSR；另一方面 SSR 使得前端的工作需要在浏览器和服务器之间来回切换，相比单纯的客户端开发，或是服务端开发，工作内容要更杂。</p><p>所以尽管 SSR 很强大，但杀鸡焉用牛刀。</p><h2>回到未来</h2><p>SSR 其实并不是什么新鲜玩意儿，早在 SPA 占领世界之前，动态页面本就是由服务端输出的，前端不过是后端代码中的一个视图而已。</p><p>我们现在所谈的 SSR 方案，主要得归功于 Node.js。作为一个运行环境，它使得 JS 成为一门全端语言，前端现在所有的繁荣昌盛和麻烦事儿，都源自 Node.js 的诞生。</p><p>相比于传统的后端渲染方案，SSR 最大的好处，是兼顾了前端的组件化，和后端输出的效率。顺带地，由于前后端使用了同一门语言，大量代码得以复用。</p><p>尽管前端现在开发手段花里胡哨，但网页最终的样子始终没变。</p><p>因此总的来说，我们的诉求就是：开发阶段用 MVVM，构建阶段利用工具生成静态页面。</p><h2>“预渲染”了解一下</h2><p>显然，我肯定不是第一个提出这个诉求的人，在 SSR 方案出来没多久，就有人开始研究另一种方案 —— 预渲染。</p><p>大家都觉得，这事儿不一定非得放到服务器去做，Node.js 只是一个运行环境，不用非把它当做服务器来看。如果能在构建阶段直接把渲染好的 HTML 打出来，问题不就解决了。</p><p>于是有人开发出来这样一个 Webpack 插件 —— <a href=\"https://link.zhihu.com/?target=https%3A//github.com/chrisvfritz/prerender-spa-plugin\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PrerenderSPAPlugin</a>。</p><p>这是一个很厉害的插件，不挑技术栈，无论你是 Angular、React、Vue 中谁的粉，只需要简单设定一下路由，就可以在构建阶段直接输出渲染好的静态页面。背后的原理主要是利用 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/GoogleChrome/puppeteer\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Puppeteer</a> 加载页面，并把加载完成后的内容保存下来。</p><p>PrerenderSPAPlugin 的好处是改造成本低，如果你有一个现有的系统，需要进行预渲染改造，那么你只需要调整一下 Webpack 的配置即可，业务代码不用动。</p><p>但这个方案只能处理静态的路由，对于动态路由，这个插件暂时还没有很好的办法来解决。</p><h2>了不起的盖茨比</h2><p>开发者大多有自己的博客，博客是一种典型的静态站点，过去有 WordPress、JekyII、Hexo 等大名鼎鼎的 CMS，都能生成静态站点。但这些工具目的性都太强，明白儿地告诉你：我就是个博客。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.gatsbyjs.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Gatsby</a> 是最近流行起来的一种新型方案，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/gatsbyjs/gatsby/commits/master%3Fafter%3D2032147f23d40fe8d986fd33996a8c5362e6c75d%2B7960\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">项目始于 2015 年</a>，原本只是个副业，开发了一年之后，发现反响不错，于是 <a href=\"https://link.zhihu.com/?target=https%3A//www.bricolage.io/gatsby-open-source-work/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">创始人开始全职投入 Gatsby 的开发工作</a>。</p><p>区别于其它方案，Gatsby 并没有死盯着 CMS 这一个领域，它定位于一种使用 React 技术栈开发站点的方式。不光可以用于开发静态站点，动态站点也完全不在话下。</p><p>Gatsby 的页面就是 React 组件，你之前积累的所有 React 知识到这里都可以继续用，可定制性非常高。</p><p>Gatsby 不光支持 Markdown 转 HTML 的方式来生成内容，同时还支持从 WordPress 等主流 CMS 导入数据，或通过外部 API 获取数据来动态生成页面，方便迁移。</p><p>Gatsby 支持自定义路由，静态动态均可，没有任何固定的路由套路。</p><p>Gatsby 支持部署到 Github Page、Now.sh、Surge.sh 等各大主流托管平台。如果你有自己的服务器，你当然也可以自由发挥。</p><p>事实上，这篇博客发布之时，我刚刚把整个博客用 Gatsby 彻底改造了一遍，大家可以感受一下。</p><h2>想得远一点</h2><p>既然 Gatsby 这么强大，那么我们可不可以用 Gastby 来替代 SSR 呢？在一定条件下是可以的，但目前有几个问题还没能得到很好的处理：</p><h2>1）动态路由（/user/:id）</h2><p>对于博客这种内容已经确定的，可以在构建期就确定有哪些路由，但如果需要通过外部 API 来获取，就需要 API 支持 GraphQL，否则目前还无法实现。</p><p>当然这种情况我们可以换种思路来考虑，使用固定的子路由，通过改变查询参数，在页面载入之后再动态获取内容。这种方法虽然 URL 看上去不那么完美，但解决问题还是可以的。</p><h2>2）React-Router</h2><p>一般我们在使用 React 时都会配合 React-Router 来管理路由，然而 Gatsby 并非使用 React-Router，它的路由有两种，一个是 <code>src/pages</code> 目录下按照目录和文件的名称来定义路由，另一个是通过 <code>onCreateNode</code> 生命周期手动创建 slug 来扩展路由。React 的 SSR 框架 Next.js 也是采用的类似的方式。这点在迁移老系统时需要重新设计一下。</p><h2>别急</h2><p>尽管还有一些问题，但 Gatsby 可以说是目前创建静态站点最完善的方案，既满足了一个静态网站所需要的一切，又提供给了开发者非常现代化的开发方式。</p><p>项目现在更新很频繁，包括核心库在内，每天都有大量的 commit。我这次改造大概花了一周时间，期间执行过几次 <code>yarn outdated</code>，每次都有一堆的可更新项目，全都是 <code>gatsby-</code> 开头。</p><p>频繁更新的背后，是一整个团队不屑的努力。截至发文当时，Gatsby 最新版本是 <code>2.0.117</code>。</p><h2>小结</h2><p>总的看来，Gatsby 虽然需要投入一些额外的学习成本，但回报率还是比较高的。</p><h2>题外话：简单谈一谈 Imgcook</h2><p>前阵子阿里爸爸放又出来一个大杀器 —— <a href=\"https://link.zhihu.com/?target=https%3A//imgcook.taobao.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Imgcook</a>，可以把设计稿一键生成可读性很高的代码，让一批前端从业者背后又一凉。</p><p>为什么是“又”？</p><p>一方面，人们研究设计稿自动转 HTML 的技术也不是一两天了。前有 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/tonybeltramelli/pix2code\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Pixel2Code</a> 一文惊天下，后有 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/Microsoft/ailab/tree/master/Sketch2Code\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">微软</a>、<a href=\"https://link.zhihu.com/?target=https%3A//airbnb.design/sketching-interfaces/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Airbnb</a> 等大厂发力相关技术。另一方面，阿里爸爸在过去一年先后推出过好多这一类自动化的项目：<a href=\"https://link.zhihu.com/?target=https%3A//luban.aliyun.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">鹿班</a>、<a href=\"https://link.zhihu.com/?target=https%3A//alibaba.github.io/ice/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">飞冰</a>、<a href=\"https://link.zhihu.com/?target=https%3A//fusion.design/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Fusion Design</a>。</p><p>其实这没什么新鲜，Word、Photoshop、Sketch 导出成 HTML 早就已经是存在了很久的功能了。</p><p>每次 AI 出点什么新闻，都会让一批人背后一凉，担心什么时候自己就失业了。但在我看来，AI 再厉害不过是个熟练工。如果一件事情只要重复次数多了谁都能来，那它就有可能被 AI 做到，否则，那就不用担心。不管是设计，还是开发，都属于创造型工作，从创意到实现的过程或许能被 AI 代替，但形成创意的过程，再强大的电脑也算不过来。</p>", 
            "topic": [
                {
                    "tag": "Gatsby", 
                    "tagLink": "https://api.zhihu.com/topics/20172777"
                }, 
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "Chino", 
                    "userLink": "https://www.zhihu.com/people/6b079a9a7b100d7bfd7db55f0e089445", 
                    "content": "<p>想歪了，想歪了</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                    "likes": 113, 
                    "childComments": []
                }, 
                {
                    "userName": "Hun Soul", 
                    "userLink": "https://www.zhihu.com/people/494716de5484e86020fb1aad6c1c6737", 
                    "content": "写的很不错，SPA的动态路由可以用无头浏览器去做渲染，然后获取其html返回，也有相关的框架，", 
                    "likes": 4, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>问题不在于实现，而在于动态的内容数量无法确定，而且大概率会是海量的数据。像个人博客这种少量且有限的可以预先生成好，如果是资讯、电商类的平台，就只能通过 SSR + 缓存了。</p>", 
                            "likes": 1, 
                            "replyToAuthor": "Hun Soul"
                        }, 
                        {
                            "userName": "Hun Soul", 
                            "userLink": "https://www.zhihu.com/people/494716de5484e86020fb1aad6c1c6737", 
                            "content": "不是我的意思是 后端Nginx检测到UA是来自搜索引擎的 则把请求转发到无头浏览器去，无头浏览器会打开浏览器访问当前的url然后渲染完毕后拿到其html返回过去，", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Destiny", 
                    "userLink": "https://www.zhihu.com/people/0ce9fda06d49d1db5c6ac5b05f4b05a2", 
                    "content": "之前看到有个程序，如果是爬虫的话返回渲染完的html，其他的不用管", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>能做到这一步的，直接部署 SSR 就好了啊，不用区分是不是爬虫</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Destiny"
                        }, 
                        {
                            "userName": "safa", 
                            "userLink": "https://www.zhihu.com/people/e594cabbdb3ef61f38e183441e35e117", 
                            "content": "但是有可能ssr的方案会让服务器很吃力，所以尽量避免ssr", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Chino", 
                    "userLink": "https://www.zhihu.com/people/6b079a9a7b100d7bfd7db55f0e089445", 
                    "content": "<p>想歪了，想歪了</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                    "likes": 113, 
                    "childComments": [
                        {
                            "userName": "瓜子魔术新传人", 
                            "userLink": "https://www.zhihu.com/people/19c34e441ceb6f446acc6eba5b198fb8", 
                            "content": "哈哈", 
                            "likes": 0, 
                            "replyToAuthor": "Chino"
                        }, 
                        {
                            "userName": "可乐呢o3o", 
                            "userLink": "https://www.zhihu.com/people/505d08fa273f27d986c3a335b8637111", 
                            "content": "想歪了，第一反应是梯子，后来看到一半。。。。面壁去了", 
                            "likes": 14, 
                            "replyToAuthor": "瓜子魔术新传人"
                        }
                    ]
                }, 
                {
                    "userName": "tauCross", 
                    "userLink": "https://www.zhihu.com/people/c77580b2c3e9e989fc8c59d9cab52e77", 
                    "content": "看到标题我还以为是要介绍梯子呢…[捂脸]", 
                    "likes": 49, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我也是</p>", 
                            "likes": 0, 
                            "replyToAuthor": "tauCross"
                        }, 
                        {
                            "userName": "有木桑", 
                            "userLink": "https://www.zhihu.com/people/4d64fe840012903ee8b3f9b3d4e3b668", 
                            "content": "<p>我也是</p>", 
                            "likes": 0, 
                            "replyToAuthor": "tauCross"
                        }
                    ]
                }, 
                {
                    "userName": "周大汤", 
                    "userLink": "https://www.zhihu.com/people/14738c04d0418f3100a0d11361e8f285", 
                    "content": "我还以为是科学上网的那个", 
                    "likes": 13, 
                    "childComments": []
                }, 
                {
                    "userName": "俊Jack", 
                    "userLink": "https://www.zhihu.com/people/0f26865a7df5a25261f6d0b68f665d6a", 
                    "content": "问一下ssr是什么", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "服务端渲染", 
                            "likes": 0, 
                            "replyToAuthor": "俊Jack"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "asp net core MVC  加 vue", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Yehowah", 
                    "userLink": "https://www.zhihu.com/people/82a23e7b08f969bae82f60c7332b60cf", 
                    "content": "诶，不是那个ssr啊", 
                    "likes": 9, 
                    "childComments": []
                }, 
                {
                    "userName": "某泽西", 
                    "userLink": "https://www.zhihu.com/people/18c2acb045a2a71dfd90f8690e8fc274", 
                    "content": "<p>还以为是酸酸乳。。</p>", 
                    "likes": 14, 
                    "childComments": []
                }, 
                {
                    "userName": "渐渐", 
                    "userLink": "https://www.zhihu.com/people/3d1d9c0669e36eae18d48e35dcd60d2b", 
                    "content": "我一个玩阴阳师的点进来干嘛", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "尘埃眠于光年", 
                    "userLink": "https://www.zhihu.com/people/d02837fbf4659b342de40e0b63d488a1", 
                    "content": "隔行如隔山啊[捂脸]大佬说话一个字都看不懂", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "途中", 
                    "userLink": "https://www.zhihu.com/people/fdceeb69de68873f457b69bfaa8b3867", 
                    "content": "不是纸飞机？？", 
                    "likes": 3, 
                    "childComments": []
                }, 
                {
                    "userName": "罗辑", 
                    "userLink": "https://www.zhihu.com/people/2a9c5649509c6811635053f9f30096f6", 
                    "content": "酸…酸酸乳", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "沙雕网友", 
                    "userLink": "https://www.zhihu.com/people/2355d833773da2fbfc230724a7f2a311", 
                    "content": "我以为是科学上网的更优解决方案。。", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "我要写bug", 
                    "userLink": "https://www.zhihu.com/people/1295bda3e6f3333abcb3ce7ddcf8a3ba", 
                    "content": "我以为科学上网呢", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>抱歉，想歪了，我说谁敢公开讨论酸酸乳呢</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "kill4peace", 
                    "userLink": "https://www.zhihu.com/people/4488b3b07dc4602f73d97c6be742c504", 
                    "content": "看不懂，还以为是另外一个ssr", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "此SSR非彼ssr", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "陈洲", 
                    "userLink": "https://www.zhihu.com/people/88e69a674fa5fb7126bbdc4192f12f8e", 
                    "content": "吓我一大跳，原来我们想的不一样", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Chino", 
                    "userLink": "https://www.zhihu.com/people/6b079a9a7b100d7bfd7db55f0e089445", 
                    "content": "<p>想歪了，想歪了</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                    "likes": 113, 
                    "childComments": []
                }, 
                {
                    "userName": "Hun Soul", 
                    "userLink": "https://www.zhihu.com/people/494716de5484e86020fb1aad6c1c6737", 
                    "content": "写的很不错，SPA的动态路由可以用无头浏览器去做渲染，然后获取其html返回，也有相关的框架，", 
                    "likes": 4, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>问题不在于实现，而在于动态的内容数量无法确定，而且大概率会是海量的数据。像个人博客这种少量且有限的可以预先生成好，如果是资讯、电商类的平台，就只能通过 SSR + 缓存了。</p>", 
                            "likes": 1, 
                            "replyToAuthor": "Hun Soul"
                        }, 
                        {
                            "userName": "Hun Soul", 
                            "userLink": "https://www.zhihu.com/people/494716de5484e86020fb1aad6c1c6737", 
                            "content": "不是我的意思是 后端Nginx检测到UA是来自搜索引擎的 则把请求转发到无头浏览器去，无头浏览器会打开浏览器访问当前的url然后渲染完毕后拿到其html返回过去，", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Destiny", 
                    "userLink": "https://www.zhihu.com/people/0ce9fda06d49d1db5c6ac5b05f4b05a2", 
                    "content": "之前看到有个程序，如果是爬虫的话返回渲染完的html，其他的不用管", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>能做到这一步的，直接部署 SSR 就好了啊，不用区分是不是爬虫</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Destiny"
                        }, 
                        {
                            "userName": "safa", 
                            "userLink": "https://www.zhihu.com/people/e594cabbdb3ef61f38e183441e35e117", 
                            "content": "但是有可能ssr的方案会让服务器很吃力，所以尽量避免ssr", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Chino", 
                    "userLink": "https://www.zhihu.com/people/6b079a9a7b100d7bfd7db55f0e089445", 
                    "content": "<p>想歪了，想歪了</p><a class=\"comment_sticker\" href=\"https://pic1.zhimg.com/v2-12562ad40366818a1ea39bcecb2599a0.gif\" data-width=\"\" data-height=\"\">[害羞]</a>", 
                    "likes": 113, 
                    "childComments": [
                        {
                            "userName": "瓜子魔术新传人", 
                            "userLink": "https://www.zhihu.com/people/19c34e441ceb6f446acc6eba5b198fb8", 
                            "content": "哈哈", 
                            "likes": 0, 
                            "replyToAuthor": "Chino"
                        }, 
                        {
                            "userName": "可乐呢o3o", 
                            "userLink": "https://www.zhihu.com/people/505d08fa273f27d986c3a335b8637111", 
                            "content": "想歪了，第一反应是梯子，后来看到一半。。。。面壁去了", 
                            "likes": 14, 
                            "replyToAuthor": "瓜子魔术新传人"
                        }
                    ]
                }, 
                {
                    "userName": "tauCross", 
                    "userLink": "https://www.zhihu.com/people/c77580b2c3e9e989fc8c59d9cab52e77", 
                    "content": "看到标题我还以为是要介绍梯子呢…[捂脸]", 
                    "likes": 49, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>我也是</p>", 
                            "likes": 0, 
                            "replyToAuthor": "tauCross"
                        }, 
                        {
                            "userName": "有木桑", 
                            "userLink": "https://www.zhihu.com/people/4d64fe840012903ee8b3f9b3d4e3b668", 
                            "content": "<p>我也是</p>", 
                            "likes": 0, 
                            "replyToAuthor": "tauCross"
                        }
                    ]
                }, 
                {
                    "userName": "周大汤", 
                    "userLink": "https://www.zhihu.com/people/14738c04d0418f3100a0d11361e8f285", 
                    "content": "我还以为是科学上网的那个", 
                    "likes": 13, 
                    "childComments": []
                }, 
                {
                    "userName": "俊Jack", 
                    "userLink": "https://www.zhihu.com/people/0f26865a7df5a25261f6d0b68f665d6a", 
                    "content": "问一下ssr是什么", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "服务端渲染", 
                            "likes": 0, 
                            "replyToAuthor": "俊Jack"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "asp net core MVC  加 vue", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Yehowah", 
                    "userLink": "https://www.zhihu.com/people/82a23e7b08f969bae82f60c7332b60cf", 
                    "content": "诶，不是那个ssr啊", 
                    "likes": 9, 
                    "childComments": []
                }, 
                {
                    "userName": "某泽西", 
                    "userLink": "https://www.zhihu.com/people/18c2acb045a2a71dfd90f8690e8fc274", 
                    "content": "<p>还以为是酸酸乳。。</p>", 
                    "likes": 14, 
                    "childComments": []
                }, 
                {
                    "userName": "渐渐", 
                    "userLink": "https://www.zhihu.com/people/3d1d9c0669e36eae18d48e35dcd60d2b", 
                    "content": "我一个玩阴阳师的点进来干嘛", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "尘埃眠于光年", 
                    "userLink": "https://www.zhihu.com/people/d02837fbf4659b342de40e0b63d488a1", 
                    "content": "隔行如隔山啊[捂脸]大佬说话一个字都看不懂", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "途中", 
                    "userLink": "https://www.zhihu.com/people/fdceeb69de68873f457b69bfaa8b3867", 
                    "content": "不是纸飞机？？", 
                    "likes": 3, 
                    "childComments": []
                }, 
                {
                    "userName": "罗辑", 
                    "userLink": "https://www.zhihu.com/people/2a9c5649509c6811635053f9f30096f6", 
                    "content": "酸…酸酸乳", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "沙雕网友", 
                    "userLink": "https://www.zhihu.com/people/2355d833773da2fbfc230724a7f2a311", 
                    "content": "我以为是科学上网的更优解决方案。。", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "我要写bug", 
                    "userLink": "https://www.zhihu.com/people/1295bda3e6f3333abcb3ce7ddcf8a3ba", 
                    "content": "我以为科学上网呢", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>抱歉，想歪了，我说谁敢公开讨论酸酸乳呢</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "kill4peace", 
                    "userLink": "https://www.zhihu.com/people/4488b3b07dc4602f73d97c6be742c504", 
                    "content": "看不懂，还以为是另外一个ssr", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "此SSR非彼ssr", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "陈洲", 
                    "userLink": "https://www.zhihu.com/people/88e69a674fa5fb7126bbdc4192f12f8e", 
                    "content": "吓我一大跳，原来我们想的不一样", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57375349", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 39, 
            "title": "【译】React 是如何区分 Class 和 Function 的 ?", 
            "content": "<blockquote>原文地址：<a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/how-does-react-tell-a-class-from-a-function/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">How Does React Tell a Class from a Function?</a><br/>原文作者：<a href=\"https://link.zhihu.com/?target=https%3A//mobile.twitter.com/dan_abramov\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dan Abramov</a><br/>译者：<a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Washington Hua</a></blockquote><h2>让我们来看一下这个以函数形式定义的 <code>Greeting</code> 组件：</h2><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">Greeting</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span><span class=\"o\">&gt;</span><span class=\"nx\">Hello</span><span class=\"o\">&lt;</span><span class=\"err\">/p&gt;;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>React 也支持将他定义成一个类：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">class</span> <span class=\"nx\">Greeting</span> <span class=\"k\">extends</span> <span class=\"nx\">React</span><span class=\"p\">.</span><span class=\"nx\">Component</span> <span class=\"p\">{</span>\n  <span class=\"nx\">render</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"o\">&lt;</span><span class=\"nx\">p</span><span class=\"o\">&gt;</span><span class=\"nx\">Hello</span><span class=\"o\">&lt;</span><span class=\"err\">/p&gt;;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>（直到 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/docs/hooks-intro.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">最近</a>，这是使用 state 特性的唯一方式）</p><p>当你要渲染一个 <code>&lt;Greeting /&gt;</code> 组件时，你并不需要关心它是如何定义的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 是类还是函数 —— 无所谓\n</span><span class=\"c1\"></span><span class=\"o\">&lt;</span><span class=\"nx\">Greeting</span> <span class=\"o\">/&gt;</span>\n</code></pre></div><p>但 <b>React 本身</b>在意其中的差别！</p><p>如果 <code>Greeting</code> 是一个函数，React 需要调用它。</p><div class=\"highlight\"><pre><code class=\"language-text\">// 你的代码\nfunction Greeting() {\n  return &lt;p&gt;Hello&lt;/p&gt;;\n}\n\n// React 内部\nconst result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt;</code></pre></div><p>但如果 <code>Greeting</code> 是一个类，React 需要先用 <code>new</code> 操作符将其实例化，<b>然后</b> 调用刚才生成实例的 <code>render</code> 方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 你的代码\nclass Greeting extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\n// React 内部\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt;</code></pre></div><p>无论哪种情况 React 的目标都是去获取渲染后的节点（在这个案例中，<code>&lt;p&gt;Hello&lt;/p&gt;</code>）。但具体的步骤取决于 <code>Greeting</code> 是如何定义的。</p><p><b>所以 React 是怎么知道某样东西是 class 还是 function 的呢？</b></p><p>就像我 <a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/why-do-we-write-super-props/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">上一篇博客</a> 中提到的，<b>你并不需要知道这个才能高效使用 React。</b> 我几年来都不知道这个。请不要把这变成一道面试题。事实上，这篇博客更多的是关于 JavaScript 而不是 React。</p><p>这篇博客是写给那些对 React 具体是 <b>如何</b> 工作的表示好奇的读者的。你是那样的人吗？那我们一起深入探讨一下吧。</p><p><b>这将是一段漫长的旅程，系好安全带。这篇文章并没有多少关于 React 本身的信息，但我们会涉及到</b> <b><code>new</code>、<code>this</code>、<code>class</code>、箭头函数、<code>prototype</code>、<code>__proto__</code>、<code>instanceof</code></b> <b>等方面，以及这些东西是如何在 JavaScript 中一起工作的。幸运的是，你并不需要在使用 React 时一直想着这些，除非你正在实现 React...</b></p><p>（如果你真的很想知道答案，直接翻到最下面。）</p><hr/><p>首先，我们需要理解为什么把函数和类分开处理很重要。注意看我们是怎么使用 <code>new</code> 操作符来调用一个类的：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 如果 Greeting 是一个函数\nconst result = Greeting(props); // &lt;p&gt;Hello&lt;/p&gt;\n\n// 如果 Greeting 是一个类\nconst instance = new Greeting(props); // Greeting {}\nconst result = instance.render(); // &lt;p&gt;Hello&lt;/p&gt;</code></pre></div><p>我们来简单看一下 <code>new</code> 在 JavaScript 是干什么的。</p><hr/><p>在过去，JavaScript 还没有类。但是，你可以使用普通函数来模拟。<b>具体来讲，只要在函数调用前加上</b> <b><code>new</code></b> <b>操作符，你就可以把任何函数当做一个类的构造函数来用：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// 只是一个函数\nfunction Person(name) {\n  this.name = name;\n}\n\nvar fred = new Person(&#39;Fred&#39;); // ✅ Person {name: &#39;Fred&#39;}\nvar george = Person(&#39;George&#39;); // 🔴 没用的</code></pre></div><p>现在你依然可以这样写！在 DevTools 里试试吧。</p><p>如果你调用 <code>Person(&#39;Fred&#39;)</code> 时 <b>没有</b> 加 <code>new</code>，其中的 <code>this</code> 会指向某个全局且无用的东西（比如，<code>window</code> 或者 <code>undefined</code>），因此我们的代码会崩溃，或者做一些像设置 <code>window.name</code> 之类的傻事。</p><p>通过在调用前增加 <code>new</code>，我们说：“嘿 JavaScript，我知道 <code>Person</code> 只是个函数，但让我们假装它是个构造函数吧。<b>创建一个</b> <code><b>{}</b></code> <b>对象并把</b> <code><b>Person</b></code> <b>中的</b> <code><b>this</b></code> <b>指向那个对象，以便我可以通过类似</b> <code><b>this.name</b></code> <b>的形式去设置一些东西，然后把这个对象返回给我。</b>”</p><p>这就是 <code>new</code> 操作符所做的事。</p><div class=\"highlight\"><pre><code class=\"language-text\">var fred = new Person(&#39;Fred&#39;); // 和 `Person` 中的 `this` 等效的对象</code></pre></div><p><code>new</code> 操作符同时也把我们放在 <code>Person.prototype</code> 上的东西放到了 <code>fred</code> 对象上：</p><div class=\"highlight\"><pre><code class=\"language-text\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHi = function() {  alert(&#39;Hi, I am &#39; + this.name);}\nvar fred = new Person(&#39;Fred&#39;);\nfred.sayHi();</code></pre></div><p>这就是在 JavaScript 直接支持类之前，人们模拟类的方式。</p><hr/><p><code>new</code> 在 JavaScript 中已经存在了好久了，然而类还只是最近的事，它的出现让我们能够重构我们前面的代码以使它更符合我们的本意：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Person {\n  constructor(name) {\n    this.name = name;\n  }\n  sayHi() {\n    alert(&#39;Hi, I am &#39; + this.name);\n  }\n}\n\nlet fred = new Person(&#39;Fred&#39;);\nfred.sayHi();</code></pre></div><p><b>捕捉开发者的本意</b> 是语言和 API 设计中非常重要的一点。</p><p>如果你写了一个函数，JavaScript 没办法判断它应该像 <code>alert()</code> 一样被调用，还是应该被视作像 <code>new Person()</code> 一样的构造函数。忘记给像 <code>Person</code> 这样的函数指定 <code>new</code> 会导致令人费解的行为。</p><p><b>类语法允许我们说：“这不仅仅是个函数 —— 这是个类并且它有构造函数”。</b> 如果你在调用它时忘了加 <code>new</code>，JavaScript 会报错：</p><div class=\"highlight\"><pre><code class=\"language-text\">let fred = new Person(&#39;Fred&#39;);\n// ✅  如果 Person 是个函数：有效\n// ✅  如果 Person 是个类：依然有效\n\nlet george = Person(&#39;George&#39;); // 我们忘记使用 `new`\n// 😳 如果 Person 是个长得像构造函数的方法：令人困惑的行为br/&gt;// 🔴 如果 Person 是个类：立即失败</code></pre></div><p>这可以帮助我们在早期捕捉错误，而不会遇到类似 <code>this.name</code> 被当成 <code>window.name</code> 对待而不是 <code>george.name</code> 的隐晦错误。</p><p>然而，这意味着 React 需要在调用所有类之前加上 <code>new</code>，而不能把它直接当做一个常规的函数去调用，因为 JavaScript 会把它当做一个错误对待！</p><div class=\"highlight\"><pre><code class=\"language-text\">class Counter extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\n// 🔴 React 不能简单这么做：\nconst instance = Counter(props);</code></pre></div><p>这意味着麻烦。</p><hr/><p>在我们看到 React 如何处理这个问题之前，很重要的一点就是要记得大部分 React 的用户会使用 Babel 等编译器来编译类等现代化的特性以便能在老旧的浏览器上运行。因此我们需要在我们的设计中考虑编译器。</p><p>在 Babel 的早期版本中，类不加 <code>new</code> 也可以被调用。但这个问题已经被修复了 —— 通过生成额外的代码的方式。</p><div class=\"highlight\"><pre><code class=\"language-text\">function Person(name) {\n  // 稍微简化了一下 Babel 的输出：\n  if (!(this instanceof Person)) {\n    throw new TypeError(&#34;Cannot call a class as a function&#34;);\n  }\n  // 我们的代码:\n  this.name = name;\n}\n\nnew Person(&#39;Fred&#39;); // ✅ OK\nPerson(&#39;George&#39;);   // 🔴 无法把类当做函数来调用</code></pre></div><p>你或许已经在你构建出来的包中见过类似的代码，这就是那些 <code>_classCallCheck</code> 函数做的事。（你可以通过启用“loose mode”来关闭检查以减小构建包的尺寸，但这或许会使你最终转向真正的原生类时变得复杂）</p><hr/><p>至此，你应该已经大致理解了调用时加不加 <code>new</code> 的差别：</p><p>译者注：知乎不支持表格，无奈只能当代码处理了</p><div class=\"highlight\"><pre><code class=\"language-text\">|          | new Person()                 | Person()                       |\n| -------- | ---------------------------- | ------------------------------ | \n| class    | ✅ this 是一个 Person 实例     | 🔴 TypeError                  | \n| function | ✅ this 是一个 Person 实例     | 😳 this 是 window 或 undefined |</code></pre></div><p>这就是 React 正确调用你的组件很重要的原因。 <b>如果你的组件被定义为一个类，React 需要使用</b> <b><code>new</code></b> <b>来调用它</b></p><p>所以 React 能检查出某样东西是否是类吗？</p><p>没那么容易！即便我们能够 <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/29093396/how-do-you-check-the-difference-between-an-ecmascript-6-class-and-function\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在 JavaScript 中区分类和函数</a>，面对被 Babel 等工具处理过的类这还是没用。对浏览器而言，它们只是不同的函数。这是 React 的不幸。</p><hr/><p>好，那 React 可以直接在每次调用时都加上 <code>new</code> 吗？很遗憾，这种方法并不总是有用。</p><p>对于常规函数，用 <code>new</code> 调用会给它们一个 <code>this</code> 作为对象实例。对于用作构造函数的函数（比如我们前面提到的 <code>Person</code>）是可取的，但对函数组件这或许就比较令人困惑了：</p><div class=\"highlight\"><pre><code class=\"language-text\">function Greeting() {\n  // 我们并不期望 `this` 在这里表示任何类型的实例\n  return &lt;p&gt;Hello&lt;/p&gt;;\n}</code></pre></div><p>这暂且还能忍，还有两个 <b>其他</b> 理由会扼杀这个想法。</p><hr/><p>关于为什么总是使用 <code>new</code> 是没用的的第一个理由是，对于原生的箭头函数（不是那些被 Babel 编译过的），用 <code>new</code> 调用会抛出一个错误：</p><div class=\"highlight\"><pre><code class=\"language-text\">const Greeting = () =&gt; &lt;p&gt;Hello&lt;/p&gt;;\nnew Greeting(); // 🔴 Greeting 不是一个构造函数</code></pre></div><p>这个行为是遵循箭头函数的设计而刻意为之的。箭头函数的一个附带作用是它 <b>没有</b> 自己的 <code>this</code> 值 —— <code>this</code> 解析自离得最近的常规函数：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Friends extends React.Component {\n  render() {\n    const friends = this.props.friends;\n    return friends.map(friend =&gt;\n      &lt;Friend\n        // `this` 解析自 `render` 方法\n        size={this.props.size}\n        name={friend.name}\n        key={friend.id}\n      /&gt;\n    );\n  }\n}</code></pre></div><p>OK，所以 <b>箭头函数没有自己的</b> <b><code>this</code>。</b>但这意味着它作为构造函数是完全无用的！</p><div class=\"highlight\"><pre><code class=\"language-text\">const Person = (name) =&gt; {\n  // 🔴 这么写是没有意义的！\n  this.name = name;\n}</code></pre></div><p>因此，<b>JavaScript 不允许用</b> <b><code>new</code></b> <b>调用箭头函数。</b> 如果你这么做，你或许已经犯了错，最好早点告诉你。这和 JavaScript 不让你 <b>不加</b> <code>new</code> 去调用一个类是类似的。</p><p>这样很不错，但这也让我们的计划受阻。React 不能简单对所有东西都使用 <code>new</code>，因为会破坏箭头函数！我们可以利用箭头函数没有 <code>prototype</code> 的特点来检测箭头函数，不对它们使用 <code>new</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">(() =&gt; {}).prototype // undefined\n(function() {}).prototype // {constructor: f}</code></pre></div><p>但这对于被 Babel 编译过的函数是 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/issues/4599%23issuecomment-136562930\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">没用</a> 的。这或许没什么大不了，但还有另一个原因使得这条路不会有结果。</p><hr/><p>另一个我们不能总是使用 <code>new</code> 的原因是它会妨碍 React 支持返回字符串或其它原始类型的组件。</p><div class=\"highlight\"><pre><code class=\"language-text\">function Greeting() {\n  return &#39;Hello&#39;;\n}\n\nGreeting(); // ✅ &#39;Hello&#39;\nnew Greeting(); // 😳 Greeting {}</code></pre></div><p>这，再一次，和 <code>href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new&#34;&gt;new 操作符 的怪异设计有关。如我们之前所看到的，new 告诉 JavaScript 引擎去创建一个对象，让这个对象成为函数内部的 this，然后把这个对象作为 new 的结果给我们。</code></p><p>然而，JavaScript 也允许一个使用 <code>new</code> 调用的函数返回另一个对象以 <b>覆盖</b> <code>new</code> 的返回值。或许，这在我们利用诸如“对象池模式”来对组件进行复用时是被认为有用的：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 创建了一个懒变量 zeroVector = null;\nfunction Vector(x, y) {\n  if (x === 0 &amp;&amp; y === 0) {\n    if (zeroVector !== null) {\n      // 复用同一个实例\n      return zeroVector;\n    }\n    zeroVector = this;\n  }\n  this.x = x;\n  this.y = y;\n}\n\nvar a = new Vector(1, 1);\nvar b = new Vector(0, 0);\nvar c = new Vector(0, 0); // 😲 b === c</code></pre></div><p>然而，如果一个函数的返回值 <b>不是</b> 一个对象，它会被 <code>new</code> <b>完全忽略</b>。如果你返回了一个字符串或数字，就好像完全没有 <code>return</code> 一样。</p><div class=\"highlight\"><pre><code class=\"language-text\">function Answer() {\n  return 42;\n}\n\nAnswer(); // ✅ 42\nnew Answer(); // 😳 Answer {}</code></pre></div><p>当使用 <code>new</code> 调用函数时，是没办法读取原始类型（例如一个数字或字符串）的返回值的。因此如果 React 总是使用 <code>new</code>，就没办法增加对返回字符串的组件的支持！</p><p>这是不可接受的，因此我们必须妥协。</p><hr/><p>至此我们学到了什么？React 在调用类（包括 Babel 输出的）时 <b>需要用</b> <code>new</code>，但在调用常规函数或箭头函数时（包括 Babel 输出的）<b>不需要用</b> <code>new</code>，并且没有可靠的方法来区分这些情况。</p><p><b>如果我们没法解决一个笼统的问题，我们能解决一个具体的吗？</b></p><p>当你把一个组件定义为类，你很可能会想要扩展 <code>React.Component</code> 以便获取内置的方法，比如 <code>this.setState()</code>。 <b>与其试图检测所有的类，我们能否只检测</b> <code><b>React.Component</b></code> <b>的后代呢？</b></p><p>剧透：React 就是这么干的。</p><hr/><p>或许，检查 <code>Greeting</code> 是否是一个 React 组件类的最符合语言习惯的方式是测试 <code>Greeting.prototype instanceof React.Component</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">class A {}\nclass B extends A {}\n\nconsole.log(B.prototype instanceof A); // true</code></pre></div><p>我知道你在想什么，刚才发生了什么？！为了回答这个问题，我们需要理解 JavaScript 原型。</p><p>你或许对“原型链”很熟悉。JavaScript 中的每一个对象都有一个“原型”。当我们写 <code>fred.sayHi()</code> 但 <code>fred</code> 对象没有 <code>sayHi</code> 属性，我们尝试到 <code>fred</code> 的原型上去找 <code>sayHi</code> 属性。要是我们在这儿找不到，就去找原型链的下一个原型 —— <code>fred</code> 的原型的原型，以此类推。</p><p><b>费解的是，一个类或函数的</b> <b><code>prototype</code></b> <b>属性</b> <b><i>并不</i></b> <b>指向那个值的原型。</b> 我没开玩笑。</p><div class=\"highlight\"><pre><code class=\"language-text\">function Person() {}\n\nconsole.log(Person.prototype); // 🤪 不是 Person 的原型\nconsole.log(Person.__proto__); // 😳 Person 的原型</code></pre></div><p>因此“原型链”更像是 <code>__proto__.__proto__.__proto__</code> 而不是 <code>prototype.prototype.prototype</code>，我花了好几年才搞懂这一点。</p><p>那么函数和类的 <code>prototype</code> 属性又是什么？<b>是用</b> <code><b>new</b></code> <b>调用那个类或函数生成的所有对象的</b> <code><b>__proto__</b></code> <b>！</b></p><div class=\"highlight\"><pre><code class=\"language-text\">function Person(name) {\n  this.name = name;\n}\nPerson.prototype.sayHi = function() {\n  alert(&#39;Hi, I am &#39; + this.name);\n}\n\nvar fred = new Person(&#39;Fred&#39;); // 设置 `fred.__proto__` 为 `Person.prototype`</code></pre></div><p>那个 <code>__proto__</code> 链才是 JavaScript 用来查找属性的：</p><div class=\"highlight\"><pre><code class=\"language-text\">fred.sayHi();\n// 1. fred 有 sayHi 属性吗？不。\n// 2. fred.__proto__ 有 sayHi 属性吗？是的，调用它！\n\nfred.toString();\n// 1. fred 有 toString 属性吗？不。\n// 2. fred.__proto__ 有 toString 属性吗？不。\n// 3. fred.__proto__.__proto__ 有 toString 属性吗？是的，调用它！</code></pre></div><p>在实战中，你应该几乎永远不需要直接在代码里动到 <code>__proto__</code> 除非你在调试和原型链相关的问题。如果你想让某样东西在 <code>fred.__proto__</code> 上可用，你应该把它放在 <code>Person.prototype</code>，至少它最初是这么设计的。</p><p><code>__proto__</code> 属性甚至一开始就不应该被浏览器暴露出来，因为原型链应该被视为一个内部概念，然而某些浏览器增加了 <code>__proto__</code> 并最终勉强被标准化（但已被废弃并推荐使用 <code>Object.getPrototypeOf()</code>）。</p><p><b>然而一个名叫“原型”的属性却给不了我一个值的“原型”这一点还是很让我困惑</b>（例如，<code>fred.prototype</code> 是未定义的，因为 <code>fred</code> 不是一个函数）。个人观点，我觉得这是即便有经验的开发者也容易误解 JavaScript 原型链的最大原因。</p><hr/><p>这篇博客很长，是吧？已经到 80% 了，坚持住。</p><p>我们知道当说 <code>obj.foo</code> 的时候，JavaScript 事实上会沿着 <code>obj</code>, <code>obj.__proto__</code>, <code>obj.__proto__.__proto__</code> 等等一路寻找 <code>foo</code>。</p><p>在使用类时，你并非直接面对这一机制，但 <code>extends</code> 的原理依然是基于这项老旧但有效的原型链机制。这也是的我们的 React 类实例能够访问如 <code>setState</code> 这样方法的原因：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Greeting extends React.Component {\n  render() {\n    return &lt;p&gt;Hello&lt;/p&gt;;\n  }\n}\n\nlet c = new Greeting();\nconsole.log(c.__proto__); // Greeting.prototype\nconsole.log(c.__proto__.__proto__); // React.Component.prototype\nconsole.log(c.__proto__.__proto__.__proto__); // Object.prototype\n\nc.render();      // 在 c.__proto__ (Greeting.prototype) 上找到\nc.setState();    // 在 c.__proto__.__proto__ (React.Component.prototype) 上找到\nc.toString();    // 在 c.__proto__.__proto__.__proto__ (Object.prototype) 上找到</code></pre></div><p>换句话说，<b>当你在使用类的时候，实例的</b> <b><code>__proto__</code></b> <b>链“镜像”了类的层级结构：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">// `extends` 链\nGreeting\n  → React.Component\n    → Object (间接的)\n\n// `__proto__` 链\nnew Greeting()\n  → Greeting.prototype\n    → React.Component.prototype\n      → Object.prototype</code></pre></div><p>2 条链。</p><hr/><p>既然 <code>__proto__</code> 链镜像了类的层级结构，我们可以检查一个 <code>Greeting</code> 是否扩展了 <code>React.Component</code>，我们从 <code>Greeting.prototype</code> 开始，一路沿着 <code>__proto__</code> 链：</p><div class=\"highlight\"><pre><code class=\"language-text\">// `__proto__` chain\nnew Greeting()\n  → Greeting.prototype // 🕵️ 我们从这儿开始\n    → React.Component.prototype // ✅ 找到了！\n      → Object.prototype</code></pre></div><p>方便的是，<code>x instanceof Y</code> 做的就是这类搜索。它沿着 <code>x.__proto__</code> 链寻找 <code>Y.prototype</code> 是否在那儿。</p><p>通常，这被用来判断某样东西是否是一个类的实例：</p><div class=\"highlight\"><pre><code class=\"language-text\">let greeting = new Greeting();\n\nconsole.log(greeting instanceof Greeting); // true\n// greeting (🕵️‍ 我们从这儿开始)br/&gt;//   .__proto__ → Greeting.prototype (✅ 找到了！)br/&gt;//     .__proto__ → React.Component.prototypebr/&gt;//       .__proto__ → Object.prototype\n\nconsole.log(greeting instanceof React.Component); // truebr/&gt;// greeting (🕵️‍ 我们从这儿开始)br/&gt;//   .__proto__ → Greeting.prototypebr/&gt;//     .__proto__ → React.Component.prototype (✅ 找到了！)br/&gt;//       .__proto__ → Object.prototype\n\nconsole.log(greeting instanceof Object); // truebr/&gt;// greeting (🕵️‍ 我们从这儿开始)br/&gt;//   .__proto__ → Greeting.prototypebr/&gt;//     .__proto__ → React.Component.prototypebr/&gt;//       .__proto__ → Object.prototype (✅ 找到了！)\n\nconsole.log(greeting instanceof Banana); // falsebr/&gt;// greeting (🕵️‍ 我们从这儿开始)br/&gt;//   .__proto__ → Greeting.prototypebr/&gt;//     .__proto__ → React.Component.prototypebr/&gt;//       .__proto__ → Object.prototype (🙅‍ 没找到！)</code></pre></div><p>但这用来判断一个类是否扩展了另一个类还是有效的</p><div class=\"highlight\"><pre><code class=\"language-text\">console.log(Greeting.prototype instanceof React.Component);\n// greeting\n//   .__proto__ → Greeting.prototype (🕵️‍ 我们从这儿开始)br/&gt;//     .__proto__ → React.Component.prototype (✅ 找到了！)br/&gt;//       .__proto__ → Object.prototype</code></pre></div><p>这种检查方式就是我们判断某样东西是一个 React 组件类还是一个常规函数的方式。</p><hr/><p>然而 React 并不是这么做的 😳</p><p>关于 <code>instanceof</code> 解决方案有一点附加说明，当页面上有多个 React 副本，并且我们要检查的组件继承自 <b>另一个</b> React 副本的 <code>React.Component</code> 时，这种方法是无效的。在一个项目里混合多个 React 副本是不好的，原因有很多，但站在历史角度来看，我们试图尽可能避免问题。（有了 Hooks，我们 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/issues/13991\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">或许得</a> 强制避免重复）</p><p>另一点启发可以是去检查原型链上的 <code>render</code> 方法。然而，当时还 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/issues/4599%23issuecomment-129714112\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">不确定</a> 组件的 API 会如何演化。每一次检查都有成本，所以我们不想再多加了。如果 <code>render</code> 被定义为一个实例方法，例如使用类属性语法，这个方法也会失效。</p><p>因此, React 为基类 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/pull/4663\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">增加了</a> 一个特别的标记。React 检查是否有这个标记，以此知道某样东西是否是一个 React 组件类。</p><p>最初这个标记是在 <code>React.Component</code> 这个基类自己身上：</p><div class=\"highlight\"><pre><code class=\"language-text\">// React 内部\nclass Component {}\nComponent.isReactClass = {};\n\n// 我们可以像这样检查它\nclass Greeting extends Component {}\nconsole.log(Greeting.isReactClass); // ✅ 是的</code></pre></div><p>然而，有些我们希望作为目标的类实现 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/scala-js/scala-js/issues/1900\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">并没有</a> 复制静态属性（或设置非标准的 <code>__proto__</code>），标记也因此丢失。</p><p>这也是为什么 React 把这个标记 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/pull/5021\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">移动到了</a> <code>React.Component.prototype</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">// React 内部\nclass Component {}\nComponent.prototype.isReactComponent = {};\n\n// 我们可以像这样检查它\nclass Greeting extends Component {}\nconsole.log(Greeting.prototype.isReactComponent); // ✅ 是的</code></pre></div><p><b>说真的这就是全部了。</b></p><p>你或许奇怪为什么是一个对象而不是一个布尔值。实战中这并不重要，但早期版本的 Jest（在 Jest 商品化之前）是默认开始自动模拟功能的，生成的模拟数据省略掉了原始类型属性，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/pull/4663%23issuecomment-136533373\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">破坏了检查</a>。谢了，Jest。</p><p>一直到今天，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/blob/769b1f270e1251d9dbdce0fcbd9e92e502d059b8/packages/react-reconciler/src/ReactFiber.js%23L297-L300\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">React 都在用</a> <code>isReactComponent</code> 进行检查。</p><p>如果你不扩展 <code>React.Component</code>，React 不会在原型上找到 <code>isReactComponent</code>，因此就不会把组件当做类处理。现在你知道为什么解决 <code>Cannot call a class as a function</code> 错误的 <a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/a/42680526/458193\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">得票数最高的答案</a> 是增加 <code>extends React.Component</code>。最后，我们还 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/pull/11168\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">增加了一项警告</a>，当 <code>prototype.render</code> 存在但 <code>prototype.isReactComponent</code> 不存在时会发出警告。</p><hr/><p>你或许会觉得这个故事有一点“标题党”。 <b>实际的解决方案其实真的很简单，但我花了大量的篇幅在转折上来解释为什么 React 最终选择了这套方案，以及还有哪些候选方案。</b></p><p>以我的经验来看，设计一个库的 API 也经常会遇到这种情况。为了一个 API 能够简单易用，你经常需要考虑语义化（可能的话，为多种语言考虑，包括未来的发展方向）、运行时性能、有或没有编译时步骤的工程效能、生态的状态以及打包方案、早期的警告，以及很多其它问题。最终的结果未必总是最优雅的，但必须要是可用的。</p><p><b>如果最终的 API 成功的话,</b> <b><i>它的用户</i></b> <b>永远不必思考这一过程</b>。他们只需要专心创建应用就好了。</p><p>但如果你同时也很好奇...知道它是怎么工作的也是极好的。</p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>你就不能一开始说答案吗？答案就是检测 Greeting.prototype.isReactComponent</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "这你得问 Dan [摊手]", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Sean", 
                    "userLink": "https://www.zhihu.com/people/24b76c1d7aeeaf595f10790aa3ec801a", 
                    "content": "這機翻的麼…<br><br>（直到 最近，这是使用 state 特性的唯一方式）<br><br>原文大概使用 until 吧，意思是在 hook 特性出來之前，使用 class 創建 react 組件是能夠傳遞 state 的唯一方式。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "不用大概，原文有链接，您可以直接查看。如果有更好的译本，欢迎留言，共同改进", 
                            "likes": 0, 
                            "replyToAuthor": "Sean"
                        }, 
                        {
                            "userName": "Sean", 
                            "userLink": "https://www.zhihu.com/people/24b76c1d7aeeaf595f10790aa3ec801a", 
                            "content": "就那段可能稍微改一下會比較貼近中文的語序", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57372137", 
            "userName": "Washington Hua", 
            "userLink": "https://www.zhihu.com/people/8c05fd9fe17e0d8a38e42ea7d6760242", 
            "upvote": 18, 
            "title": "【译】我们为什么要写 super(props)?", 
            "content": "<blockquote>原文地址：<a href=\"https://link.zhihu.com/?target=https%3A//overreacted.io/why-do-we-write-super-props/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Why Do We Write super(props) ?</a><br/>原文作者：<a href=\"https://link.zhihu.com/?target=https%3A//twitter.com/dan_abramov\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Dan Abramov</a><br/>译者：<a href=\"https://link.zhihu.com/?target=https%3A//tonghuashuo.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Washington Hua</a></blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>我听说 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/docs/hooks-intro.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hooks</a> 最近很火。讽刺的是，我想以一些关于 class 组件的有趣故事来开始这个博客。怎样！（皮一下很开心）</p><p>这些小坑并不会影响你高效的使用 React，但如果你愿意深入了解下背后的工作原理，你会发现它们非常有意思。</p><p>这是第一个。</p><hr/><p>我这辈子写过的 <code>super(props)</code> 比我想象的要多得多</p><div class=\"highlight\"><pre><code class=\"language-text\">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}</code></pre></div><p>当然，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/tc39/proposal-class-fields\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">class fields proposal</a> 允许我们跳过这个仪式。</p><div class=\"highlight\"><pre><code class=\"language-text\">class Checkbox extends React.Component {\n  state = { isOn: true };\n  // ...\n}</code></pre></div><p>这样的语法是在 2015 年 React 0.13 增加对纯 Class 的支持的时候加入 <a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html%23es7-property-initializers\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">计划</a> 的. 定义 <code>constructor</code> 和调用 <code>super(props)</code> 一直都只是 class fiels 出现之前的临时解决方案。</p><p>然而，让我们只用 ES2015 的特性来回顾一下这个例子。</p><div class=\"highlight\"><pre><code class=\"language-text\">class Checkbox extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { isOn: true };\n  }\n  // ...\n}</code></pre></div><p><b>我们为什么要调用<code>super</code>？能不能不调用它？如果非要调用，如果不传</b> <b><code>props</code></b> <b>会怎样？还有其它参数吗？</b>让我们来看一下。</p><p>在 JavaScript 中，<code>super</code> 指代父类的构造函数。（在我们的案例中，它指向 <code>React.Component</code> 这个实现）</p><p>重点在于，在你调用父类构造函数之前，你无法在构造函数中使用 <code>this</code>。JavaScript 不会允许你这么做。</p><div class=\"highlight\"><pre><code class=\"language-text\">class Checkbox extends React.Component {\n  constructor(props) {\n    // 🔴 这时候还不能使用 `this`\n    super(props);\n    // ✅ 现在开始可以了\n    this.state = { isOn: true };\n  }\n  // ...\n}</code></pre></div><p>JavaScript 强制你在使用 <code>this</code> 前运行父类构造函数有一个很好的理由。考虑这样一个类结构：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Person {\n  constructor(name) {\n    this.name = name;\n  }\n}\n\nclass PolitePerson extends Person {\n  constructor(name) {\n    this.greetColleagues(); // 🔴 这是不允许的，下面会解释原因\n    super(name);\n  }\n  greetColleagues() {\n    alert(&#39;Good morning folks!&#39;);\n  }\n}</code></pre></div><p>想象一下如果在调用 <code>super</code> 前使用 <code>this</code> 是被允许的。一个月之后。我们或许会改变 <code>greetColleagues</code> 把 person 的 name 加到消息中。</p><div class=\"highlight\"><pre><code class=\"language-text\">greetColleagues() {\n  alert(&#39;Good morning folks!&#39;);\n  alert(&#39;My name is &#39; + this.name + &#39;, nice to meet you!&#39;);\n}</code></pre></div><p>但我们忘了 <code>this.greetColleagues()</code> 是在 <code>super()</code> 有机会设置 <code>this.name</code> 之前被调用的。<code>this.name</code> 甚至还没被定义！如你所见，像这样的代码理解起来会很困难。</p><p>为了避免这样的陷阱，<b>JavaScript 强制规定，如果你想在构造函数中只用<code>this</code>，就必须先调用</b> <b><code>super</code></b>。让父类做它该做的事！这一限制也适用于定义成类的 React 组件。</p><div class=\"highlight\"><pre><code class=\"language-text\">constructor(props) {\n  super(props);\n  // ✅ 现在可以使用 `this` 了\n  this.state = { isOn: true };\n}</code></pre></div><p>这给我们留下了另一个问题：为什么要传 <code>props</code>？</p><hr/><p>你或许觉得把 <code>props</code> 传进 <code>super</code> 是必要的，这使得基类 <code>React.Component</code> 可以初始化 <code>this.props</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">// React 内部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}</code></pre></div><p>很接近了——事实上，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/facebook/react/blob/1d25aa5787d4e19704c049c3cfa985d3b5190e0d/packages/react/src/ReactBaseClasses.js%23L22\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">它就是这么做的</a>。</p><p>然而，即便在调用 <code>super()</code> 时没有传入 <code>props</code> 参数，你依然能够在 <code>render</code> 和其它方法中访问 <code>this.props</code>。（你要是不相信我，可以自己试一试）</p><p>这是什么原理？其实 <b>React 在调用你的构造函数之后，马上又给实例设置了一遍</b> <b><code>props</code></b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">// React 内部\nconst instance = new YourComponent(props);\ninstance.props = props;</code></pre></div><p>因此，即便你忘了把 <code>props</code> 传入 <code>super()</code>，React 依然会在事后设置它们。这是有理由的。</p><p>当 React 添加对 Class 的支持时，它并不是只添加了对 ES6 的支持，而是希望能够支持尽可能广泛的 class 抽象。由于<a href=\"https://link.zhihu.com/?target=https%3A//reactjs.org/blog/2015/01/27/react-v0.13.0-beta-1.html%23other-languages\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">不是很确定</a> ClojureScript、CoffeeScript、ES6、Fable、Scala.js、TypeScript 或其他解决方案谁更适合用来定义组件，React 对于是否有必要调用 <code>super()</code> 刻意不表态。</p><p>那么这是否意味着你可以只写 <code>super()</code> 而不用 <code>super(props)</code>？</p><p><b>或许并非如此，因为这依然让人困扰</b>。诚然，React 会在你的构造函数运行之后设置 <code>this.props</code>。但在 <code>super</code> 调用一直到构造函数结束之前，<code>this.props</code> 依然是未定义的。</p><div class=\"highlight\"><pre><code class=\"language-text\">// React 内部\nclass Component {\n  constructor(props) {\n    this.props = props;\n    // ...\n  }\n}\n\n// 你的代码\nclass Button extends React.Component {\n  constructor(props) {\n    super(); // 😬 我们忘了传入 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // 😬 undefined \n  }\n  // ...\n}</code></pre></div><p>如果这发生在某些从构造函数中调用的函数，调试起来会更加麻烦。<b>这也是为什么我推荐总是使用</b> <b><code>super(props)</code></b> <b>的写法，即便这是非必要的</b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">class Button extends React.Component {\n  constructor(props) {\n    super(props); // ✅ 我们传了 props\n    console.log(props);      // ✅ {}\n    console.log(this.props); // ✅ {}\n  }\n  // ...\n}</code></pre></div><p>这样的写法确保了 <code>this.props</code>即便在构造函数返回之前就被设置好了。</p><hr/><p>最后还有一点是 React 的长期用户或许会好奇的。</p><p>你或许已经注意到，当你在 Class 中使用 Context API 时（无论是旧版的语法还是 React 16.6 中新增的现代化语法），context 是被作为构造函数的第二个参数传入的。</p><p>那么我们为什么不写 <code>super(props, context)</code> 呢？当然我们可以这么做，但 context 的使用频率没那么高，所以这个陷阱影响还没那么大。</p><p><b>伴随着 class fields proposal 的发布，这个问题也就不复存在了。</b>即便不显式调用构造函数，所有参数也会自动传入。这就允许像 <code>state = {}</code> 这样的表达式在必要时可以直接引用 <code>this.props.</code> 或 <code>this.context</code>。</p><p>在 Hooks 中，我们甚至都没有 <code>super</code> 或 <code>this</code>。这个话题我们择日再说。</p>", 
            "topic": [
                {
                    "tag": "React", 
                    "tagLink": "https://api.zhihu.com/topics/20013159"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/tonghuashuo"
}
