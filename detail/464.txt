{
    "title": "啊哈！编程", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/xing-wei-45-1", 
        "https://www.zhihu.com/people/liang-zhong-hua-49", 
        "https://www.zhihu.com/people/thinkinnight", 
        "https://www.zhihu.com/people/chun-tian-hua-hui-kai-99-18", 
        "https://www.zhihu.com/people/zeng-zhi-an", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/jing-yu-bao-bao-85-92"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/53771523", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 2, 
            "title": "Android——LruCache源码解析", 
            "content": "<p>以下针对 Android API 26 版本的源码进行分析。 在了解<code>LruCache</code>之前，最好对<code>LinkedHashMap</code>有初步的了解，<code>LruCache</code>的实现主要借助<code>LinkedHashMap</code>。<code>LinkedHashMap</code>的源码解析，可阅读<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ZhaoxiCheung/p/Java-LinkedHashMap-Source-Analysis.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java——LinkedHashMap源码解析</a></p><h2>概述</h2><p><code>LruCahce</code>其 Lru 是 Least Recently Used 的缩写，即最近最少使用，是包含对有限数量值的强引用的缓存。每当一个值被访问，它将被移到队尾。当缓存达到指定的数量时，位于队头的值将被移除，并且可能被 GC 回收。如果缓存的值包含需要显式释放的资源，那么需要重写<code>entryRemoved</code>方法。如果 key 对应的缓存未命中，通过重写<code>create</code>方法创建对应的 value。这可以简化代码调用：即使存在缓存未命中，也允许假设始终返回一个值。   默认情况下，缓存大小以条目数量度量。在不同缓存对象下，通过重写<code>sizeOf</code>方法测量 key-value 缓存的大小。例如如下的例子，这个缓存限制了 4MiB 大小的位图：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">cacheSize</span> <span class=\"o\">=</span> <span class=\"n\">4</span> <span class=\"o\">*</span> <span class=\"n\">1024</span> <span class=\"o\">*</span> <span class=\"n\">1024</span><span class=\"o\">;</span> <span class=\"c1\">// 4MiB\n</span><span class=\"c1\"></span><span class=\"n\">LruCache</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Bitmap</span><span class=\"o\">&gt;</span> <span class=\"n\">bitmapCache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LruCache</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">,</span> <span class=\"n\">Bitmap</span><span class=\"o\">&gt;(</span><span class=\"n\">cacheSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"nf\">sizeOf</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Bitmap</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"o\">.</span><span class=\"na\">getByteCount</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>  这个类是线程安全的，通过在缓存上执行同步操作来以原子方式执行多个缓存操作：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">cache</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>  这个类不允许空值作为 key 或者 value，对于<code>get</code>、<code>put</code>、<code>remove</code>方法返回<code>null</code>值是明确的行为：缓存中不存在这个键。</p><h2>源码分析</h2><h2>主要字段</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//LruCache 主要借助 LinkedHashMap 按元素访问顺序的迭代顺序（此时 accessOrder = true）来实现\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">map</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 不同 key-value 条目下缓存的大小，不一定是 key-value 条目的数量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n    <span class=\"c1\">//缓存大小的最大值\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">//存储的 key-value 条目的个数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">putCount</span><span class=\"o\">;</span>\n    <span class=\"c1\">//创建 key 对应的 value 的次数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">createCount</span><span class=\"o\">;</span>\n    <span class=\"c1\">//缓存移除的次数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">evictionCount</span><span class=\"o\">;</span>\n    <span class=\"c1\">//缓存命中的次数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">hitCount</span><span class=\"o\">;</span>\n    <span class=\"c1\">//缓存未命中的次数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">missCount</span><span class=\"o\">;</span></code></pre></div><h2>构造函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * maxSize 对于缓存没有重写 sizeOf 方法的时候，这个数值指定了缓存中可以容纳的最大条目的数量；\n</span><span class=\"cm\"> * 对于其他缓存，这是缓存中条目大小的最大总和。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LruCache</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">maxSize</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;maxSize &lt;= 0&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">maxSize</span> <span class=\"o\">=</span> <span class=\"n\">maxSize</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">//指定了哈希表初始容量为0，负载因子为0.75，迭代顺序为按照条目访问顺序\n</span><span class=\"c1\"></span>    <span class=\"c1\">//因此在有对条目进行访问的操作的时候，条目都会被放置到队尾，具体细节详看 LinkedHashMap 的解析\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">75f</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>Size操作</h2><p><code>LruCache</code>在默认情况下，<u>size</u> 指的是 key-value 条目的个数，当重写<code>sizeOf</code>函数时，可以自定义 key-value 条目的单位大小，如<a href=\"https://zhuanlan.zhihu.com/write#%E6%A6%82%E8%BF%B0\" class=\"internal\">概述</a>中位图的例子，其通过重写<code>sizeOf</code>函数，返回的大小值并非是 1，而是不同<code>Bitmap</code>对象的字节大小。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 以用户定义的单位返回 key-value 条目的大小\n</span><span class=\"cm\"> * 默认实现返回1，因此 size 是条目数，max size是最大条目数\n</span><span class=\"cm\"> * 条目的大小在缓存中时不得更改\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"nf\">sizeOf</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">sizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">result</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalStateException</span><span class=\"o\">(</span><span class=\"s\">&#34;Negative size: &#34;</span> <span class=\"o\">+</span> <span class=\"n\">key</span> <span class=\"o\">+</span> <span class=\"s\">&#34;=&#34;</span> <span class=\"o\">+</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除最旧的条目，直到剩余条目总数小于等于指定的大小。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">trimToSize</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n        <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">size</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalStateException</span><span class=\"o\">(</span><span class=\"n\">getClass</span><span class=\"o\">().</span><span class=\"na\">getName</span><span class=\"o\">()</span>\n                        <span class=\"o\">+</span> <span class=\"s\">&#34;.sizeOf() is reporting inconsistent results!&#34;</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">//哈希表中条目的大小小于指定的大小即终止\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">&lt;=</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">//获取哈希表中最旧的条目\n</span><span class=\"c1\"></span>            <span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">toEvict</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">eldest</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">//哈希表为空，终止\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">toEvict</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">toEvict</span><span class=\"o\">.</span><span class=\"na\">getKey</span><span class=\"o\">();</span>\n            <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">toEvict</span><span class=\"o\">.</span><span class=\"na\">getValue</span><span class=\"o\">();</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n            <span class=\"n\">size</span> <span class=\"o\">-=</span> <span class=\"n\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">//移除元素的次数\n</span><span class=\"c1\"></span>            <span class=\"n\">evictionCount</span><span class=\"o\">++;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">//此处 evicted 为 true，表明是为了腾出空间而进行的删除条目操作\n</span><span class=\"c1\"></span>        <span class=\"n\">entryRemoved</span><span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 调整缓存的大小\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">resize</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">maxSize</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;maxSize &lt;= 0&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">maxSize</span> <span class=\"o\">=</span> <span class=\"n\">maxSize</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">trimToSize</span><span class=\"o\">(</span><span class=\"n\">maxSize</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>查询</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 指定 key 对应的 value 值存在时返回，否则通过 create 方法创建相应的 key-value 对。\n</span><span class=\"cm\"> * 如果对应的 value 值被返回，那么这个 key-value 对将被移到队尾。\n</span><span class=\"cm\"> * 当返回 null 时，表明没有对应的 value 值并且也无法被创建\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">//缓存不允许 key 值为 null，因此对于查询 null 的键可直接抛出异常\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">(</span><span class=\"s\">&#34;key == null&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">V</span> <span class=\"n\">mapValue</span><span class=\"o\">;</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">mapValue</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"c1\">//缓存命中\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mapValue</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">hitCount</span><span class=\"o\">++;</span>\n            <span class=\"k\">return</span> <span class=\"n\">mapValue</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">//缓存未命中\n</span><span class=\"c1\"></span>        <span class=\"n\">missCount</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/*\n</span><span class=\"cm\">     * 尝试创建一个 value 值，这可能需要花费较长的时间完成，当 create 返回时，哈希表可能变得不同\n</span><span class=\"cm\">     * 如果在 create 工作时向哈希表添加了一个冲突的值（key 已经有对应的 value 值，但 create 方法返回了一个不同的 value 值）\n</span><span class=\"cm\">     * 那么将该值保留在哈希表中并释放创建的值。\n</span><span class=\"cm\">     */</span>\n    <span class=\"n\">V</span> <span class=\"n\">createdValue</span> <span class=\"o\">=</span> <span class=\"n\">create</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">createdValue</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//缓存创建的次数\n</span><span class=\"c1\"></span>        <span class=\"n\">createCount</span><span class=\"o\">++;</span>\n        <span class=\"n\">mapValue</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">createdValue</span><span class=\"o\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mapValue</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// mapValue 不为 null，说明存在一个冲突值，保留之前的 value 值\n</span><span class=\"c1\"></span>            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">mapValue</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">size</span> <span class=\"o\">+=</span> <span class=\"n\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">createdValue</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">mapValue</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">entryRemoved</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">createdValue</span><span class=\"o\">,</span> <span class=\"n\">mapValue</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">mapValue</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">trimToSize</span><span class=\"o\">(</span><span class=\"n\">maxSize</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">createdValue</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 在缓存未命中之后调用以计算相应 key 的 value。\n</span><span class=\"cm\"> * 当能计算 key 对应的 value 时，返回 value，否则返回 null。默认实现一律返回 null 值。\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 这个方法在被调用的时候没有添加额外的同步操作，因此其他线程可能在这个方法执行时访问缓存\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 如果 key 对应的 value 存储在缓存中，那么通过 create 创建的 value 将通过 entryRemoved 方法释放。\n</span><span class=\"cm\"> * 这种情况主要发生在：当多个线程同时请求相同的 key （导致创建多个值）时，或者当一个线程调用 put 而另一个线程为其创建值时\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">protected</span> <span class=\"n\">V</span> <span class=\"nf\">create</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>存储</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 对于 key，缓存其相应的 value，key-value 条目放置于队尾\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @return 返回先前 key 对应的 value 值\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">value</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">(</span><span class=\"s\">&#34;key == null || value == null&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">V</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">putCount</span><span class=\"o\">++;</span>\n        <span class=\"n\">size</span> <span class=\"o\">+=</span> <span class=\"n\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n        <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">previous</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">size</span> <span class=\"o\">-=</span> <span class=\"n\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">previous</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">previous</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//evicted 为 true，表明不是为了腾出空间而进行的删除操作\n</span><span class=\"c1\"></span>        <span class=\"n\">entryRemoved</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">previous</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">trimToSize</span><span class=\"o\">(</span><span class=\"n\">maxSize</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>删除</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除 key 对应的条目\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 返回 key 对应的 value值\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">remove</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">(</span><span class=\"s\">&#34;key == null&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">V</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">previous</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">size</span> <span class=\"o\">-=</span> <span class=\"n\">safeSizeOf</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">previous</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">previous</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">entryRemoved</span><span class=\"o\">(</span><span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">previous</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">previous</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 当条目需要被移除或删除时调用\n</span><span class=\"cm\"> * 当一个值被移除以腾出空间，通过调用 remove 删除，或者被 put 调用替换值时，会调用此方法。默认实现什么也不做\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 这个方法在被调用的时候没有添加额外的同步操作，因此其他线程可能在这个方法执行时访问缓存\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @param evicted true 表明条目正在被删除以腾出空间，false 表明删除是由 put 或 remove 引起的（并非是为了腾出空间）\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @param newValue key 的新值。如果非 null，则此删除是由 put 引起的。否则它是由 remove引起的\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">entryRemoved</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">evicted</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">oldValue</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">newValue</span><span class=\"o\">)</span> <span class=\"o\">{}</span></code></pre></div>", 
            "topic": [
                {
                    "tag": "Android", 
                    "tagLink": "https://api.zhihu.com/topics/19603145"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52471143", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 2, 
            "title": "-----------------", 
            "content": "<p>-==============================</p>", 
            "topic": [
                {
                    "tag": "力扣（LeetCode）", 
                    "tagLink": "https://api.zhihu.com/topics/19925162"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52231686", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 0, 
            "title": "Java——LinkedHashMap源码解析", 
            "content": "<p>以下针对JDK 1.8版本中的<b>LinkedHashMap</b>进行分析。 对于<code>HashMap</code>的源码解析，可阅读<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ZhaoxiCheung/p/Java-HashMap-Source-Analysis.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java——HashMap源码解析</a></p><h2>概述</h2><p>  哈希表和链表基于<code>Map</code>接口的实现，其具有可预测的迭代顺序。此实现与<code>HashMap</code>的不同之处在于它维护了一个包括所有条目（Entry）的双向链表。相比于无序的<code>HashMap</code>，<code>LinkedHashMap</code>迭代顺序支持按插入条目顺序或者按访问条目顺序，默认迭代顺序为按插入顺序。对于相同 <u>key</u> 的重复插入，其不会改变插入顺序。    此实现可以让客户端免受由<code>HashMap</code>（和<code>Hashtable</code>）提供的未指定的，通常是混乱的排序，而对于与<code>TreeMap</code>提供的默认根据键排序的功能相比，其性能成本会更小。使用它可以生成一个与原来顺序相同的映射副本，而与原映射的实现无关：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">void</span> <span class=\"nf\">foo</span><span class=\"o\">(</span><span class=\"n\">Map</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Map</span> <span class=\"n\">copy</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">);</span>\n    <span class=\"o\">...</span>\n<span class=\"o\">}</span></code></pre></div><p>如果模块通过输入得到一个映射，复制这个映射，然后返回由此副本确定其顺序的结果，这种情况下这项技术特别有用（客户端通常期望返回的内容与其出现的顺序相同）。</p><p><code>LinkedHashMap</code>提供一种特殊的构造方法来创建哈希表，其迭代顺序根据条目的访问顺序排序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射的迭代顺序很适合构建 <u>LRU Cache</u>。调用<code>put</code>、<code>putIfPresent</code>、<code>get</code>、<code>getOrDefault</code>、<code>compute</code>、<code>computeIfAbsent</code>、<code>computerIfPresent</code>或者<code>merge</code>方法都算是对相应条目的访问（假定调用完成后它还存在）。<code>replace()</code>方法只有在值被替换的情况下，才算是对条目的访问。<code>putAll</code>方法以指定映射的条目集迭代器提供的键-值映射关系的顺序，为指定映射的每个映射关系生成一个条目访问。任何其他方法均不生成条目访问。特别是，collection 视图上的操作不 影响底层映射的迭代顺序。</p><p>  可以重写<code>removeEldestEntry(Map.Entry)</code>方法来实施策略，以便在将新的条目添加到哈希表时，如果超过指定容量，自动移除旧的条目，这在实现 <u>LRU Cahce</u>的时候将非常有用。</p><p>  这个类提供了所有可选的<code>Map</code>的操作，并且允许<code>null</code>元素。和<code>HashMap</code>一样，假定哈希函数将元素均匀分布到各个桶中，对于基本操作如<code>add</code>、<code>contains</code>和<code>remove</code>，其提供了常数时间的性能。由于增加了维护链表的开支，其性能很可能比<code>HashMap</code>稍逊一筹，不过有一点是例外的：<code>LinkedHashMap</code>的 collection 视图迭代所需时间与映射的大小（<u>size</u>）成比例，而与容量（<u>capacity</u>）无关；<code>HashMap</code>迭代时间很可能开支较大，因为它所需要的时间与其容量（<u>capacity</u>）成比例。</p><p><code>LinkedHashMap</code>有两个因子影响着其性能：<b>初始容量</b>和<b>负载因子</b>。它们的定义与<code>HashMap</code>完全相同。要注意，为初始容量选择非常高的值对此类的影响比对<code>HashMap</code>要小，因为此类的迭代时间不受容量的影响。</p><p><b>值得注意的是，这个类对于<code>Map</code>接口都不是同步的。</b>如果多个线程并发的访问一个哈希表，并且至少有一个线程对这个哈希表进行结构性更改，那么必须增添额外的同步操作。这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用<code>Collections.synchronizedMap</code>方法来“包装”该哈希表。最好在创建时完成这一操作，以防止对哈希表的意外的非同步访问：<code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p><p>  对于结构性更改指任何添加或者删除一个或者多个条目，或者在按访问顺序的哈希表中影响迭代顺序的任何操作。在按插入顺序的哈希表中，仅更改已存在的 key 对应的 value 值不是结构性修改。在按访问顺序的哈希表中，仅利用<code>get</code>查询不是结构性修改。）</p><p>  Collection（由此类的所有 collection 视图方法所返回）的 iterator 方法返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的<code>remove</code>方法，其他任何时间任何方式的修改，迭代器都将抛出<code>ConcurrentModificationException</code>。因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来不确定的时间发生任意不确定行为的风险。</p><p>  注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p><h2>源码分析</h2><h2>构造函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据指定的初始容量和负载因子，初始化一个空的按照插入顺序排序的 LinkedHashMap 的实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LinkedHashMap</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">,</span> <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">initialCapacity</span><span class=\"o\">,</span> <span class=\"n\">loadFactor</span><span class=\"o\">);</span>\n    <span class=\"n\">accessOrder</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据指定的容量和默认的负载因子（0.75），初始化一个空的按照插入顺序排序的 LinkedHashMap 的实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LinkedHashMap</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">initialCapacity</span><span class=\"o\">);</span>\n    <span class=\"n\">accessOrder</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据默认的容量（16）和负载因子（0.75），初始化一个空的按照插入顺序排序的 LinkedHashMap 实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LinkedHashMap</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">();</span>\n    <span class=\"n\">accessOrder</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 初始化一个根据传入的映射关系并且按照插入顺序排序的 LinkedHashMap 的实例\n</span><span class=\"cm\"> * 这个 LinkedHashMap 实例的负载因子为0.75，容量不小于指定的映射关系的数量的最小2次幂\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LinkedHashMap</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">?</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">();</span>\n    <span class=\"n\">accessOrder</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"n\">putMapEntries</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据指定的容量、负载因子、排序模式来初始化一个空的 LinkedHashMap 的实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">LinkedHashMap</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">,</span>\n                     <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">,</span>\n                     <span class=\"kt\">boolean</span> <span class=\"n\">accessOrder</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">initialCapacity</span><span class=\"o\">,</span> <span class=\"n\">loadFactor</span><span class=\"o\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">accessOrder</span> <span class=\"o\">=</span> <span class=\"n\">accessOrder</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>  从上面的构造函数可以看出来：<code>accessOrder = false</code>，如果没有特别指定排序模式，那么其将按照插入顺序来作为迭代顺序。</p><h2>三个重要的回调函数</h2><p>在<code>HashMap</code>源码中，预留了三个回调函数，来让<code>LinkedHashMap</code>进行后期操作：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// Callbacks to allow LinkedHashMap post-actions\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"o\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">afterNodeInsertion</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">evict</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"o\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">afterNodeRemoval</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"o\">}</span></code></pre></div><p>在<code>LinkedHashMap</code>中，这三个函数实现如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//移除节点的时候会触发回调，将节点从双向链表中删除，在调用 removeNode 函数时候会执行\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">afterNodeRemoval</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// unlink\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span>\n        <span class=\"o\">(</span><span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">;</span>\n    <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">//新节点插入时会触发回调，根据条件判断是否移除最老的条目，在调用 compute computeIfAbsent merge putVal 函数时候会实行\n</span><span class=\"c1\">//实现 LruCache 的时候会用到这个函数\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">afterNodeInsertion</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">evict</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// possibly remove eldest\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">evict</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"n\">K</span> <span class=\"n\">key</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">;</span>\n        <span class=\"n\">removeNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">//将节点放置链表尾，在调用 putVal 函数时会执行，保证最近访问节点在链表尾部\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// move node to last\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n    <span class=\"c1\">//accessOrder为 true表示按照访问顺序排序，并且此时的键值对不在链表尾部\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">accessOrder</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span>\n            <span class=\"o\">(</span><span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">e</span><span class=\"o\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span><span class=\"o\">,</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">;</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">b</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">b</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n            <span class=\"n\">last</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"o\">++</span><span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>从上面三个回调函数可以看出，其主要是在对条目进行操作的时候触发来维护双向链表。另外值得一提的是<code>afterNodeInsertion</code>和<code>removeEldestEntry</code>函数，在构建 <u>LruCache</u> 时将非常有用。对于<code>removeEldestEntry</code>，其默认返回<code>false</code>，因此默认情况下不会删除最旧的元素：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * @param    eldest 哈希表中最近插入的条目，或者如果迭代顺序是按照访问顺序排序，则是最近最少访问的条目。\n</span><span class=\"cm\"> *                  如果这个方法返回 true，则这是将被删除的条目。如果在 put 或 putAll 调用之前哈希表为空时，触发此调用，\n</span><span class=\"cm\"> *                  则这将是刚插入的条目;换句话说，如果哈希表包含单个条目，则最老的条目也是最新的。\n</span><span class=\"cm\"> * @return   返回 true 表明将删除最老的条目\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">eldest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>如果需要删除最旧条目，则返回true。在将新条目插入后，<code>put</code>和<code>putAll</code>将调用此方法。它为实现者提供了在每次添加新条目时删除最旧条目的机会。如果用来实现缓存，则此选项非常有用：它允许哈希表通过删除过时条目来减少内存消耗。 示例使用：重写这个函数实现，以下例子将允许在增长到100个条目时，然后在每次添加新条目时删除最旧的条目，保持100个条目的稳定状态。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAX_ENTRIES</span> <span class=\"o\">=</span> <span class=\"n\">100</span><span class=\"o\">;</span>\n<span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span> <span class=\"n\">eldest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n   <span class=\"k\">return</span> <span class=\"n\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">MAX_ENTRIES</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>此方法通常不通过重写来修改哈希表，而是通过返回值来判断是否对哈希表进行修改。当然，此方法允许直接修改哈希表，但如果它这样做，则必须返回false（表示哈希表不应尝试任何进一步的修改）。如果在此方法中修改哈希表后返回 true，那么对于结果是未指定。</p><h2>存储</h2><p><code>LinkedHashMap</code>直接使用了<code>HashMap</code>的<code>put</code>函数，但重写了<code>newNode</code>、<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"nf\">newNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span> <span class=\"o\">=</span>\n        <span class=\"k\">new</span> <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">);</span>\n    <span class=\"c1\">//将节点放置链表尾部\n</span><span class=\"c1\"></span>    <span class=\"n\">linkNodeLast</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">// 将新增节点放置链表尾部\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">linkNodeLast</span><span class=\"o\">(</span><span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">last</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n    <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">last</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n    <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">before</span> <span class=\"o\">=</span> <span class=\"n\">last</span><span class=\"o\">;</span>\n        <span class=\"n\">last</span><span class=\"o\">.</span><span class=\"na\">after</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>删除</h2><p>  同样的，<code>LinkedHashMap</code>仍然直接使用了<code>HashMap</code>的<code>remove</code>函数，只是对<code>afterNodeRemoval</code>回调函数进行了重写。对于<code>afterNodeRemoval</code>函数上面已经分析过了。</p><h2>查询</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 返回指定 key 所对应的 value 值，当不存在指定的 key 时，返回 null。\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 当返回 null 的时候并不表明哈希表中不存在这种关系的映射，有可能对于指定的 key，其对应的值就是 null。\n</span><span class=\"cm\"> * 因此可以通过 containsKey 来区分这两种情况。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">getNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">accessOrder</span><span class=\"o\">)</span>\n        <span class=\"n\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>  与<code>HashMap</code>相比，其多了一步对 <u>accessOrder</u> 的判断来维护链表，当指定迭代顺序按照访问顺序排序时，<code>get</code>操作表明对指定的条目进行了一次访问，那么此条目应该移到链表尾部。对于<code>afterNodeAccess</code>在上面已经分析过了，值得注意的是，在调用<code>afterNodeAccess</code>时，会修改 <u>modeCount</u>，所以当你正在<code>accessOrder = true</code>的模式下迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，会导致 <u>fail-fast</u>，因为迭代的顺序已经变了。</p><h2>其他</h2><p>  对于<code>LinkedHashMap</code>其与<code>HashMap</code>还有一些不同，由于<code>LinkedHashMap</code>维护一个双向链表，因此在判断哈希表中是否存储着某个键值对的时候，不需要在整个数组桶中查找，而只需要对链表遍历即可，这也是<code>LinkedHashMap</code>的其中一处优化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">containsValue</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">LinkedHashMap</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span> <span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">after</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">V</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">==</span> <span class=\"n\">value</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">value</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">)))</span>\n            <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>实现 LruCache</h2><p>在 LeetCode 有一道题——<a href=\"https://link.zhihu.com/?target=https%3A//leetcode.com/problems/lru-cache/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Lru Cache</a>：设计和实现一个  LRU (最近最少使用) 缓存机制，那么就可以利用<code>LinkedHashMap</code>可选的迭代顺序——按访问顺序的模式来进行实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">LRUCache</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">cache</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">LRUCache</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">capacity</span> <span class=\"o\">=</span> <span class=\"n\">capacity</span><span class=\"o\">;</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">cache</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">LinkedHashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"o\">(</span><span class=\"n\">capacity</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">75f</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">removeEldestEntry</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">eldest</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">size</span><span class=\"o\">()</span> <span class=\"o\">&gt;</span> <span class=\"n\">capacity</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span>\n            <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">cache</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Your LRUCache object will be instantiated and called as such:\n</span><span class=\"cm\"> * LRUCache obj = new LRUCache(capacity);\n</span><span class=\"cm\"> * int param_1 = obj.get(key);\n</span><span class=\"cm\"> * obj.put(key,value);\n</span><span class=\"cm\"> */</span></code></pre></div><p>当然，如果觉得直接使用<code>LinkedHashMap</code>的方式太过取巧，我们仍可以借鉴<code>LinkedHashMap</code>的思想来进行实现——使用 <u>HashMap 和 双向链表</u> 的组合来实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">LRUCache</span> <span class=\"o\">{</span>\n    <span class=\"kd\">class</span> <span class=\"nc\">Node</span><span class=\"o\">{</span>\n        <span class=\"n\">Integer</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n        <span class=\"n\">Integer</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"n\">Node</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n        <span class=\"n\">Node</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n\n        <span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"n\">Integer</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Integer</span> <span class=\"n\">value</span><span class=\"o\">){</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">key</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">private</span> <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Node</span><span class=\"o\">&gt;</span><span class=\"n\">map</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"nf\">LRUCache</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">capacity</span><span class=\"o\">;</span>\n        <span class=\"n\">map</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">capacity</span><span class=\"o\">);</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n        <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"kc\">null</span> <span class=\"o\">!=</span> <span class=\"n\">node</span><span class=\"o\">){</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">);</span>\n\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">;</span>\n\n            <span class=\"n\">appendTail</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"kc\">null</span> <span class=\"o\">==</span> <span class=\"n\">node</span> <span class=\"o\">?</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"kc\">null</span> <span class=\"o\">!=</span> <span class=\"n\">node</span><span class=\"o\">){</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">);</span>\n\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">;</span>\n\n            <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span><span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">size</span><span class=\"o\">){</span>\n            <span class=\"n\">Node</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">tmp</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">);</span>\n\n            <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"n\">tmp</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n\n            <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"kc\">null</span> <span class=\"o\">==</span> <span class=\"n\">node</span><span class=\"o\">)</span>   <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n        <span class=\"n\">appendTail</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n        <span class=\"n\">map</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">node</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">appendTail</span><span class=\"o\">(</span><span class=\"n\">Node</span> <span class=\"n\">node</span><span class=\"o\">){</span>\n        <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">prev</span><span class=\"o\">;</span>\n        <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">tail</span><span class=\"o\">;</span>\n        <span class=\"n\">tail</span><span class=\"o\">.</span><span class=\"na\">prev</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Your LRUCache object will be instantiated and called as such:\n</span><span class=\"cm\"> * LRUCache obj = new LRUCache(capacity);\n</span><span class=\"cm\"> * int param_1 = obj.get(key);\n</span><span class=\"cm\"> * obj.put(key,value);\n</span><span class=\"cm\"> */</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52231615", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 2, 
            "title": "Java——HashMap源码解析", 
            "content": "<p>以下针对JDK 1.8版本中的<b>HashMap</b>进行分析。</p><h2>概述</h2><p>    哈希表基于<code>Map</code>接口的实现。此实现提供了所有可选的映射操作，并且允许键为<code>null</code>，值也为<code>null</code>。HashMap 除了不支持同步操作以及支持<code>null</code>的键值外，其功能大致等同于 Hashtable。这个类不保证元素的顺序，并且也不保证随着时间的推移，元素的顺序不会改变。      假设散列函数使得元素在哈希桶中分布均匀，那么这个实现对于 <b>put</b> 和 <b>get</b> 等操作提供了常数时间的性能。</p><p>    对于一个 HashMap 的实例，有两个因子影响着其性能：<b>初始容量</b>和<b>负载因子</b>。容量就是哈希表中哈希桶的个数，初始容量就是哈希表被初次创建时的容量大小。负载因子是在进行自动扩容之前衡量哈希表存储键值对的一个指标。当哈希表中的键值对超过<code>capacity * loadfactor</code>时，就会进行 resize 的操作。</p><p>    作为一般规则，默认负载因子（0.75）在时间和空间成本之间提供了良好的折衷。负载因子越大，空间开销越小，但是查找的开销变大了。</p><p>    注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p><h2>源码分析</h2><h2>主要字段</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 初始容量大小 —— 必须是2的幂次方\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">DEFAULT_INITIAL_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">4</span><span class=\"o\">;</span> <span class=\"c1\">// aka 16\n</span><span class=\"c1\"></span>\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 最大容量\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">30</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 默认负载因子\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">float</span> <span class=\"n\">DEFAULT_LOAD_FACTOR</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">75f</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 当链表长度超过这个值时转换为红黑树\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">TREEIFY_THRESHOLD</span> <span class=\"o\">=</span> <span class=\"n\">8</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * The bin count threshold for untreeifying a (split) bin during a\n</span><span class=\"cm\"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at\n</span><span class=\"cm\"> * most 6 to mesh with shrinkage detection under removal.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">UNTREEIFY_THRESHOLD</span> <span class=\"o\">=</span> <span class=\"n\">6</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * The smallest table capacity for which bins may be treeified.\n</span><span class=\"cm\"> * (Otherwise the table is resized if too many nodes in a bin.)\n</span><span class=\"cm\"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts\n</span><span class=\"cm\"> * between resizing and treeification thresholds.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MIN_TREEIFY_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">64</span><span class=\"o\">;</span>\n\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * table 在第一次使用时进行初始化并在需要的时候重新调整自身大小。对于 table 的大小必须是2的幂次方。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Holds cached entrySet(). Note that AbstractMap fields are used\n</span><span class=\"cm\"> * for keySet() and values().\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"n\">Set</span><span class=\"o\">&lt;</span><span class=\"n\">Map</span><span class=\"o\">.</span><span class=\"na\">Entry</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;&gt;</span> <span class=\"n\">entrySet</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 键值对的个数\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * HashMap 进行结构性调整的次数。结构性调整指的是增加或者删除键值对等操作，注意对于更新某个键的值不是结构特性调整。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"kt\">int</span> <span class=\"n\">modCount</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 所能容纳的 key-value 对的极限（表的大小 capacity * load factor），达到这个容量时进行扩容操作。\n</span><span class=\"cm\"> */</span>\n<span class=\"kt\">int</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 负载因子，默认值为 0.75\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">final</span> <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">;</span></code></pre></div><p>    从上面我们可以得知，HashMap中指定的哈希桶数组<u>table.length</u>必须是2的幂次方，这与常规性的把哈希桶数组设计为素数不一样。指定为2的幂次方主要是在两方面做优化： - 扩容：扩容的时候，哈希桶扩大为当前的两倍，因此只需要进行左移操作 - 取模：由于哈希桶的个数为2的幂次，因此可以用<b>&amp;</b>操作来替代耗时的模运算， <code>n % table.length -&gt; n &amp; (table.length - 1)</code></p><h2>哈希函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 哈希函数\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">hash</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">h</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">())</span> <span class=\"o\">^</span> <span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">16</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>    key 的哈希值通过它自身<b>hashCode</b>的高十六位与低十六位进行亦或得到。这么做得原因是因为，由于哈希表的大小固定为 2 的幂次方，那么某个 key 的 hashCode 值大于 table.length，其高位就不会参与到 hash 的计算（对于某个 key 其所在的桶的位置的计算为 <code>hash &amp; (table.length - 1)</code>）。因此通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，保证了高位 Bits 也能参与到 Hash 的计算。</p><h2>tableSizeFor函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 返回大于等于capacity的最小2的整数次幂\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">tableSizeFor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">cap</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">cap</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">4</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">8</span><span class=\"o\">;</span>\n    <span class=\"n\">n</span> <span class=\"o\">|=</span> <span class=\"n\">n</span> <span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">16</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;=</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">:</span> <span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>    根据注释可以知道，这个函数返回大于或等于<b>cap</b>的最小二的整数次幂的值。比如对于3，返回4；对于10，返回16。详解如下： 假设对于<b>n</b>（32位数）其二进制为 01xx...xx， n &gt;&gt;&gt; 1，进行无符号右移一位， 001xx..xx，位或得 011xx..xx n &gt;&gt;&gt; 2，进行无符号右移两位， 00011xx..xx，位或得 01111xx..xx 依此类推，无符号右移四位再进行位或将得到8个1，无符号右移八位再进行位或将得到16个1，无符号右移十六位再进行位或将得到32个1。根据这个我们可以知道进行这么多次无符号右移及位或操作，那么可让数<b>n</b>的二进制位最高位为1的后面的二进制位全部变成1。此时进行 +1 操作，即可得到最小二的整数次幂的值。（《高效程序的奥秘》第3章——2的幂界方 有对此进行进一步讨论，可自行查看） 回到上面的程序，之所以在开头先进行一次 -1 操作，是为了防止传入的<b>cap</b>本身就是二的幂次方，此时得到的就是下一个二的幂次方了，比如传入4，那么在不进行 -1 的情况下，将得到8。</p><h2>构造函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 传入指定的初始容量和负载因子\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">HashMap</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">,</span> <span class=\"kt\">float</span> <span class=\"n\">loadFactor</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">initialCapacity</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;Illegal initial capacity: &#34;</span> <span class=\"o\">+</span>\n                                           <span class=\"n\">initialCapacity</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">initialCapacity</span> <span class=\"o\">&gt;</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">)</span>\n        <span class=\"n\">initialCapacity</span> <span class=\"o\">=</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">loadFactor</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span> <span class=\"o\">||</span> <span class=\"n\">Float</span><span class=\"o\">.</span><span class=\"na\">isNaN</span><span class=\"o\">(</span><span class=\"n\">loadFactor</span><span class=\"o\">))</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;Illegal load factor: &#34;</span> <span class=\"o\">+</span>\n                                           <span class=\"n\">loadFactor</span><span class=\"o\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">loadFactor</span> <span class=\"o\">=</span> <span class=\"n\">loadFactor</span><span class=\"o\">;</span>\n    <span class=\"c1\">//返回2的幂次方\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">tableSizeFor</span><span class=\"o\">(</span><span class=\"n\">initialCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>    对于上面的构造器，我们需要注意的是<code>this.threshold = tableSizeFor(initialCapacity);</code>这边的 threshold 为 2的幂次方，而不是<code>capacity * load factor</code>，当然此处并非是错误，因为此时 table 并没有真正的被初始化，初始化动作被延迟到了<code>putVal()</code>当中，所以 threshold 会被重新计算。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据指定的容量以及默认负载因子（0.75）初始化一个空的 HashMap 实例\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 如果 initCapacity是负数，那么将抛出 IllegalArgumentException\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">HashMap</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">initialCapacity</span><span class=\"o\">,</span> <span class=\"n\">DEFAULT_LOAD_FACTOR</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据默认的容量和负载因子初始化一个空的 HashMap 实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">HashMap</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">loadFactor</span> <span class=\"o\">=</span> <span class=\"n\">DEFAULT_LOAD_FACTOR</span><span class=\"o\">;</span> <span class=\"c1\">// all other fields defaulted\n</span><span class=\"c1\"></span><span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the\n</span><span class=\"cm\"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with\n</span><span class=\"cm\"> * default load factor (0.75) and an initial capacity sufficient to\n</span><span class=\"cm\"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @param   m the map whose mappings are to be placed in this map\n</span><span class=\"cm\"> * @throws  NullPointerException if the specified map is null\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">HashMap</span><span class=\"o\">(</span><span class=\"n\">Map</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"n\">K</span><span class=\"o\">,</span> <span class=\"o\">?</span> <span class=\"kd\">extends</span> <span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">loadFactor</span> <span class=\"o\">=</span> <span class=\"n\">DEFAULT_LOAD_FACTOR</span><span class=\"o\">;</span>\n    <span class=\"n\">putMapEntries</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>查询</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 返回指定 key 所对应的 value 值，当不存在指定的 key 时，返回 null。\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 当返回 null 的时候并不表明哈希表中不存在这种关系的映射，有可能对于指定的 key，其对应的值就是 null。\n</span><span class=\"cm\"> * 因此可以通过 containsKey 来区分这两种情况。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">getNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"kc\">null</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 1.首先通过 key 的哈希值找到其所在的哈希桶\n</span><span class=\"cm\"> * 2.对于 key 所在的哈希桶只有一个元素，此时就是 key 对应的节点，\n</span><span class=\"cm\"> * 3.对于 key 所在的哈希桶超过一个节点，此时分两种情况：\n</span><span class=\"cm\"> *     如果这是一个 TreeNode，表明通过红黑树存储，在红黑树中查找\n</span><span class=\"cm\"> *     如果不是一个 TreeNode，表明通过链表存储（链地址法），在链表中查找\n</span><span class=\"cm\"> * 4.查找不到相应的 key，返回 null\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">final</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"nf\">getNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">tab</span><span class=\"o\">;</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">first</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">;</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">;</span> <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span>\n        <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">[(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">hash</span><span class=\"o\">])</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">first</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span> <span class=\"c1\">// always check first node\n</span><span class=\"c1\"></span>            <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span>\n            <span class=\"k\">return</span> <span class=\"n\">first</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">first</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">first</span> <span class=\"k\">instanceof</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"o\">((</span><span class=\"n\">TreeNode</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">first</span><span class=\"o\">).</span><span class=\"na\">getTreeNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n            <span class=\"k\">do</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span>\n                    <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span>\n                    <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>存储</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 在映射中，将指定的键与指定的值相关联。如果映射关系之前已经有指定的键，那么旧值就会被替换\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">putVal</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * * @param onlyIfAbsent if true, don&#39;t change existing value\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 1.判断哈希表 table 是否为空，是的话进行扩容操作\n</span><span class=\"cm\"> * 2.根据键 key 计算得到的 哈希桶数组索引，如果 table[i] 为空，那么直接新建节点\n</span><span class=\"cm\"> * 3.判断 table[i] 的首个元素是否等于 key，如果是的话就更新旧的 value 值\n</span><span class=\"cm\"> * 4.判断 table[i] 是否为 TreeNode，是的话即为红黑树，直接在树中进行插入\n</span><span class=\"cm\"> * 5.遍历 table[i]，遍历过程发现 key 已经存在，更新旧的 value 值，否则进行插入操作，插入后发现链表长度大于8，则将链表转换为红黑树\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">final</span> <span class=\"n\">V</span> <span class=\"nf\">putVal</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">K</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">V</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">onlyIfAbsent</span><span class=\"o\">,</span>\n               <span class=\"kt\">boolean</span> <span class=\"n\">evict</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">tab</span><span class=\"o\">;</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">;</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n    <span class=\"c1\">//哈希表 table 为空，进行扩容操作\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">resize</span><span class=\"o\">()).</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"c1\">// tab[i] 为空，直接新建节点\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">[</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">hash</span><span class=\"o\">])</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"n\">tab</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">newNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n    <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">;</span> <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">;</span>\n        <span class=\"c1\">//tab[i] 首个元素即为 key，更新旧值\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span>\n            <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span>\n            <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"c1\">//当前节点为 TreeNode，在红黑树中进行插入\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"k\">instanceof</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span>\n            <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"n\">TreeNode</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">p</span><span class=\"o\">).</span><span class=\"na\">putTreeVal</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">tab</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"c1\">//遍历 tab[i]，key 已经存在，更新旧的 value 值，否则进心插入操作，插入后链表长度大于8，将链表转换为红黑树\n</span><span class=\"c1\"></span>            <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">binCount</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">binCount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">newNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">value</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n                    <span class=\"c1\">//链表长度大于8\n</span><span class=\"c1\"></span>                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">binCount</span> <span class=\"o\">&gt;=</span> <span class=\"n\">TREEIFY_THRESHOLD</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"c1\">// -1 for 1st\n</span><span class=\"c1\"></span>                        <span class=\"n\">treeifyBin</span><span class=\"o\">(</span><span class=\"n\">tab</span><span class=\"o\">,</span> <span class=\"n\">hash</span><span class=\"o\">);</span>\n                    <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"c1\">// key 已经存在\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span>\n                    <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span>\n                    <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">//key 已经存在，更新旧值\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span> <span class=\"c1\">// existing mapping for key\n</span><span class=\"c1\"></span>            <span class=\"n\">V</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">onlyIfAbsent</span> <span class=\"o\">||</span> <span class=\"n\">oldValue</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n            <span class=\"n\">afterNodeAccess</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">//HashMap插入元素表明进行了结构性调整\n</span><span class=\"c1\"></span>    <span class=\"o\">++</span><span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"c1\">//实际键值对数量超过 threshold，进行扩容操作\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"n\">threshold</span><span class=\"o\">)</span>\n        <span class=\"n\">resize</span><span class=\"o\">();</span>\n    <span class=\"n\">afterNodeInsertion</span><span class=\"o\">(</span><span class=\"n\">evict</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>扩容</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 初始化或者对哈希表进行扩容操作。如果当前哈希表为空，则根据字段阈值中的初始容量进行分配。\n</span><span class=\"cm\"> * 否则，因为我们扩容两倍，那么对于桶中的元素要么在原位置，要么在原位置再移动2次幂的位置。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">final</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"nf\">resize</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">oldTab</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">oldCap</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">oldTab</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"n\">oldTab</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">oldThr</span> <span class=\"o\">=</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">newCap</span><span class=\"o\">,</span> <span class=\"n\">newThr</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">oldCap</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//超过最大容量，不再进行扩容\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">oldCap</span> <span class=\"o\">&gt;=</span> <span class=\"n\">MAXIMUM_CAPACITY</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">;</span>\n            <span class=\"k\">return</span> <span class=\"n\">oldTab</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"c1\">//容量没有超过最大值，容量变为原来两倍\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">newCap</span> <span class=\"o\">=</span> <span class=\"n\">oldCap</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">&amp;&amp;</span>\n                 <span class=\"n\">oldCap</span> <span class=\"o\">&gt;=</span> <span class=\"n\">DEFAULT_INITIAL_CAPACITY</span><span class=\"o\">)</span>\n            <span class=\"c1\">//阈值变为原来两倍\n</span><span class=\"c1\"></span>            <span class=\"n\">newThr</span> <span class=\"o\">=</span> <span class=\"n\">oldThr</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// double threshold\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">oldThr</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"c1\">// initial capacity was placed in threshold\n</span><span class=\"c1\"></span>        <span class=\"c1\">//调用了HashMap的带参构造器，初始容量用threshold替换，\n</span><span class=\"c1\"></span>        <span class=\"c1\">//在带参构造器中，threshold的值为 tableSizeFor() 的返回值，也就是2的幂次方，而不是 capacity * load factor\n</span><span class=\"c1\"></span>        <span class=\"n\">newCap</span> <span class=\"o\">=</span> <span class=\"n\">oldThr</span><span class=\"o\">;</span>\n    <span class=\"k\">else</span> <span class=\"o\">{</span>               <span class=\"c1\">// zero initial threshold signifies using defaults\n</span><span class=\"c1\"></span>        <span class=\"c1\">//初次初始化，容量和阈值使用默认值\n</span><span class=\"c1\"></span>        <span class=\"n\">newCap</span> <span class=\"o\">=</span> <span class=\"n\">DEFAULT_INITIAL_CAPACITY</span><span class=\"o\">;</span>\n        <span class=\"n\">newThr</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)(</span><span class=\"n\">DEFAULT_LOAD_FACTOR</span> <span class=\"o\">*</span> <span class=\"n\">DEFAULT_INITIAL_CAPACITY</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newThr</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">//计算新的阈值\n</span><span class=\"c1\"></span>        <span class=\"kt\">float</span> <span class=\"n\">ft</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">float</span><span class=\"o\">)</span><span class=\"n\">newCap</span> <span class=\"o\">*</span> <span class=\"n\">loadFactor</span><span class=\"o\">;</span>\n        <span class=\"n\">newThr</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">newCap</span> <span class=\"o\">&lt;</span> <span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">ft</span> <span class=\"o\">&lt;</span> <span class=\"o\">(</span><span class=\"kt\">float</span><span class=\"o\">)</span><span class=\"n\">MAXIMUM_CAPACITY</span> <span class=\"o\">?</span>\n                  <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span><span class=\"n\">ft</span> <span class=\"o\">:</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">newThr</span><span class=\"o\">;</span>\n    <span class=\"nd\">@SuppressWarnings</span><span class=\"o\">({</span><span class=\"s\">&#34;rawtypes&#34;</span><span class=\"o\">,</span><span class=\"s\">&#34;unchecked&#34;</span><span class=\"o\">})</span>\n    <span class=\"c1\">//以下为扩容过程的重点\n</span><span class=\"c1\"></span>        <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">newTab</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[])</span><span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">[</span><span class=\"n\">newCap</span><span class=\"o\">];</span>\n    <span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"n\">newTab</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">oldTab</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">oldCap</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">oldTab</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">])</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">//将原哈希桶置空，以便GC\n</span><span class=\"c1\"></span>                <span class=\"n\">oldTab</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                <span class=\"c1\">//当前节点不是以链表形式存在，直接计算其应放置的新位置\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                    <span class=\"n\">newTab</span><span class=\"o\">[</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">&amp;</span> <span class=\"o\">(</span><span class=\"n\">newCap</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                <span class=\"c1\">//当前节点是TreeNode\n</span><span class=\"c1\"></span>                <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"k\">instanceof</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span>\n                    <span class=\"o\">((</span><span class=\"n\">TreeNode</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">e</span><span class=\"o\">).</span><span class=\"na\">split</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">newTab</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">oldCap</span><span class=\"o\">);</span>\n                <span class=\"k\">else</span> <span class=\"o\">{</span> <span class=\"c1\">// preserve order\n</span><span class=\"c1\"></span>                    <span class=\"c1\">//节点以链表形式存储\n</span><span class=\"c1\"></span>                    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">loHead</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">loTail</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">hiHead</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">hiTail</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n                    <span class=\"k\">do</span> <span class=\"o\">{</span>\n                        <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n                        <span class=\"c1\">//原索引\n</span><span class=\"c1\"></span>                        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">&amp;</span> <span class=\"n\">oldCap</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">loTail</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                                <span class=\"n\">loHead</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                            <span class=\"k\">else</span>\n                                <span class=\"n\">loTail</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                            <span class=\"n\">loTail</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                        <span class=\"o\">}</span>\n                        <span class=\"c1\">//原索引 + oldCap\n</span><span class=\"c1\"></span>                        <span class=\"k\">else</span> <span class=\"o\">{</span>\n                            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">hiTail</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                                <span class=\"n\">hiHead</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                            <span class=\"k\">else</span>\n                                <span class=\"n\">hiTail</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                            <span class=\"n\">hiTail</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                        <span class=\"o\">}</span>\n                    <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">loTail</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">loTail</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                        <span class=\"n\">newTab</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">loHead</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">hiTail</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">hiTail</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                        <span class=\"n\">newTab</span><span class=\"o\">[</span><span class=\"n\">j</span> <span class=\"o\">+</span> <span class=\"n\">oldCap</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">hiHead</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">newTab</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>    因为哈希表使用2次幂的拓展（指长度拓展为原来的2倍），所以在扩容的时候，元素的位置要么在原位置，要么在原位置再移动2次幂的位置。为什么是这么一个规律呢？我们假设 n 为 table 的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1bac6d2076e388a76d841b0f93bd65bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-1bac6d2076e388a76d841b0f93bd65bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1632&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1632\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1632\" data-original=\"https://pic4.zhimg.com/v2-1bac6d2076e388a76d841b0f93bd65bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1bac6d2076e388a76d841b0f93bd65bb_b.jpg\"/></figure><p> 元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f34ef09c43c974fdcab4b38ff5435063_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic4.zhimg.com/v2-f34ef09c43c974fdcab4b38ff5435063_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1064&#39; height=&#39;202&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"202\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic4.zhimg.com/v2-f34ef09c43c974fdcab4b38ff5435063_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f34ef09c43c974fdcab4b38ff5435063_b.jpg\"/></figure><p> 因此，我们在扩容的时候，只需要看看原来的hash值新增的那个 bit 是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0b5c0e5c0049af633ebe5ca23eea218b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb\" width=\"1268\" data-original=\"https://pic4.zhimg.com/v2-0b5c0e5c0049af633ebe5ca23eea218b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1268&#39; height=&#39;730&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1268\" data-rawheight=\"730\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1268\" data-original=\"https://pic4.zhimg.com/v2-0b5c0e5c0049af633ebe5ca23eea218b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0b5c0e5c0049af633ebe5ca23eea218b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>删除</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除指定的 key 的映射关系\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"n\">V</span> <span class=\"nf\">remove</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">removeNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">),</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">))</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span>\n        <span class=\"kc\">null</span> <span class=\"o\">:</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**Java\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * 1.根据 key 的哈希值在哈希桶中查找是否存在这个包含有这个 key 的节点\n</span><span class=\"cm\"> *      链表头节点是要查找的节点\n</span><span class=\"cm\"> *      节点是TreeNode，在红黑树中查找\n</span><span class=\"cm\"> *      在链表中进行查找\n</span><span class=\"cm\"> * 2.如果查找到对应的节点，进行删除操作\n</span><span class=\"cm\"> *      从红黑树中删除\n</span><span class=\"cm\"> *      将链表头节点删除\n</span><span class=\"cm\"> *      在链表中删除\n</span><span class=\"cm\"> *\n</span><span class=\"cm\"> * @param hash key 的 hash 值\n</span><span class=\"cm\"> * @param key 指定的 key\n</span><span class=\"cm\"> * @param value 当 matchhValue 为真时，则要匹配这个 value\n</span><span class=\"cm\"> * @param matchValue 为真并且与 value 相等时进行删除\n</span><span class=\"cm\"> * @param movable if false do not move other nodes while removing\n</span><span class=\"cm\"> * @return the node, or null if none\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">final</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"nf\">removeNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">Object</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Object</span> <span class=\"n\">value</span><span class=\"o\">,</span>\n                           <span class=\"kt\">boolean</span> <span class=\"n\">matchValue</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">movable</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">tab</span><span class=\"o\">;</span> <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">p</span><span class=\"o\">;</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span>\n        <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tab</span><span class=\"o\">[</span><span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">&amp;</span> <span class=\"n\">hash</span><span class=\"o\">])</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">e</span><span class=\"o\">;</span> <span class=\"n\">K</span> <span class=\"n\">k</span><span class=\"o\">;</span> <span class=\"n\">V</span> <span class=\"n\">v</span><span class=\"o\">;</span>\n        <span class=\"c1\">//链表头即为要删除的节点\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span>\n            <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span>\n            <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">//节点为TreeNode，在红黑树中查找是否存在指定的key\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span> <span class=\"k\">instanceof</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span>\n                <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"o\">((</span><span class=\"n\">TreeNode</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">p</span><span class=\"o\">).</span><span class=\"na\">getTreeNode</span><span class=\"o\">(</span><span class=\"n\">hash</span><span class=\"o\">,</span> <span class=\"n\">key</span><span class=\"o\">);</span>\n            <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"c1\">//在链表中查找是否存在指定的key\n</span><span class=\"c1\"></span>                <span class=\"k\">do</span> <span class=\"o\">{</span>\n                    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">hash</span> <span class=\"o\">==</span> <span class=\"n\">hash</span> <span class=\"o\">&amp;&amp;</span>\n                        <span class=\"o\">((</span><span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">key</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">key</span> <span class=\"o\">||</span>\n                         <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">k</span><span class=\"o\">))))</span> <span class=\"o\">{</span>\n                        <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                        <span class=\"k\">break</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                    <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">while</span> <span class=\"o\">((</span><span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">);</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(!</span><span class=\"n\">matchValue</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">value</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">value</span> <span class=\"o\">||</span>\n                             <span class=\"o\">(</span><span class=\"n\">value</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">value</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">))))</span> <span class=\"o\">{</span>\n            <span class=\"c1\">//从红黑树中删除\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"k\">instanceof</span> <span class=\"n\">TreeNode</span><span class=\"o\">)</span>\n                <span class=\"o\">((</span><span class=\"n\">TreeNode</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;)</span><span class=\"n\">node</span><span class=\"o\">).</span><span class=\"na\">removeTreeNode</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">,</span> <span class=\"n\">tab</span><span class=\"o\">,</span> <span class=\"n\">movable</span><span class=\"o\">);</span>\n            <span class=\"c1\">//链表头删除\n</span><span class=\"c1\"></span>            <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">node</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"o\">)</span>\n                <span class=\"n\">tab</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"c1\">//链表中的元素删除\n</span><span class=\"c1\"></span>            <span class=\"k\">else</span>\n                <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n            <span class=\"c1\">//进行结构特性调整\n</span><span class=\"c1\"></span>            <span class=\"o\">++</span><span class=\"n\">modCount</span><span class=\"o\">;</span>\n            <span class=\"o\">--</span><span class=\"n\">size</span><span class=\"o\">;</span>\n            <span class=\"n\">afterNodeRemoval</span><span class=\"o\">(</span><span class=\"n\">node</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除所有的映射关系\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">clear</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">K</span><span class=\"o\">,</span><span class=\"n\">V</span><span class=\"o\">&gt;[]</span> <span class=\"n\">tab</span><span class=\"o\">;</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">tab</span> <span class=\"o\">=</span> <span class=\"n\">table</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">tab</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span>\n            <span class=\"c1\">//置 null 以便 GC\n</span><span class=\"c1\"></span>            <span class=\"n\">tab</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>问题</h2><ul><li>对于<code>new HashMap(18)</code>，那么哈希桶数组的大小是多少</li><li>HashMap 要求哈希桶数组的长度是2的幂次方，这么设计的目的是为什么</li><li>HashMap 何时对哈希桶数组开辟内存</li><li>哈希函数是如何设计的，这么设计的意图是什么</li><li>HashMap 扩容的过程，扩容时候对 rehash 进行了什么优化</li></ul><h2>参考资料</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//tech.meituan.com/java_hashmap.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java 8系列之重新认识HashMap</a></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52231480", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 2, 
            "title": "Java——ArrayList源码解析", 
            "content": "<p>以下针对JDK 1.8版本中的<b>ArrayList</b>进行分析。</p><h2>概述</h2><p><code>ArrayList</code>基于<code>List</code>接口实现的大小可变的数组。其实现了所有可选的<code>List</code>操作，并且元素允许为任意类型，包括<code>null</code>元素。除了实现<code>List</code>接口，此类还提供了操作内部用于存储列表数组大小的方法（这个类除了没有实现同步外，功能基本与<code>Vector</code>一致）。      每个<code>ArrayList</code>实例都有一个容量。容量是用于存储列表中元素的数组的大小。它始终至少与列表大小一样大。随着元素添加到<code>ArrayList</code>，其容量会自动增加。除了添加元素具有恒定的摊销时间成本这一事实之外，增长策略并没有详细指出。</p><p>    我们在添加大容量数据的时候可以使用<code>ensureCapacity</code>方法来主动扩容，这可以减少自动扩容的次数。</p><p>    值得注意的是，这些实现都不是同步的。因此，当多个线程并发访问一个<code>ArrayList</code>实例并且至少有一个线程对这个实例进行结构性调整的时候，必须在外部额外实现同步（对于结构性调整，主要指增加或删除一个或多个元素，更精确的说，就是对这个列表的大小进行了调整，对于更改元素的数值并非是结构性调整）。这通常通过在自然封装列表的某个对象上进行同步来完成。如果不存在此类对象，则应使用<code>Collections.synchronizedList</code>方法“包装”该列表。这最好在创建时完成，以防止意外地不同步访问列表：<code>List list = Collections.synchronizedList(new ArrayList(...));</code></p><p>    注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出<code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p><h2>源码分析</h2><h2>主要字段</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 默认初始容量\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">DEFAULT_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 用于ArrayList空实例的共享空数组实例\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">EMPTY_ELEMENTDATA</span> <span class=\"o\">=</span> <span class=\"o\">{};</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 用于默认大小空实例的共享空数组实例。我们将this（DEFAULTCAPACITY_EMPTY_ELEMENTDATA）\n</span><span class=\"cm\"> * 和EMPTY_ELEMENTDATA区别开来，以便在添加第一个元素时知道数组大小要扩容为多少多少。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class=\"o\">=</span> <span class=\"o\">{};</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 存储 ArrayList 元素的数组缓冲区。ArrayList 的容量是此数组缓冲区的长度。\n</span><span class=\"cm\"> * 当第一个元素添加进空数组时候 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 将会被扩容至 DEFAULT_CAPACITY\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">transient</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">elementData</span><span class=\"o\">;</span> <span class=\"c1\">// non-private to simplify nested class access\n</span><span class=\"c1\"></span>\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * ArrayList的数组大小（ArrayList包含的元素个数\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"o\">;</span></code></pre></div><p>    注意此处的<code>elementData</code>字段是用的<code>transient</code>修饰的以及对于空实例有<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>两个共享空数组实例，下面会对提到的这些注意点进行分析。</p><h2>构造函数</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 根据指定的容量初始化空的列表，注意当容量为 0 时，使用的是 EMPTY_ELEMENTDATA\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">ArrayList</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">initialCapacity</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">elementData</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">initialCapacity</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">initialCapacity</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">EMPTY_ELEMENTDATA</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;Illegal Capacity: &#34;</span><span class=\"o\">+</span>\n                                           <span class=\"n\">initialCapacity</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 初始化容量为 10 的空列表\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">ArrayList</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * Constructs a list containing the elements of the specified\n</span><span class=\"cm\"> * collection, in the order they are returned by the collection&#39;s\n</span><span class=\"cm\"> * iterator.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"nf\">ArrayList</span><span class=\"o\">(</span><span class=\"n\">Collection</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// c.toArray might (incorrectly) not return Object[] (see 6260652)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">getClass</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">Object</span><span class=\"o\">[].</span><span class=\"na\">class</span><span class=\"o\">)</span>\n            <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOf</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">size</span><span class=\"o\">,</span> <span class=\"n\">Object</span><span class=\"o\">[].</span><span class=\"na\">class</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// replace with empty array.\n</span><span class=\"c1\"></span>        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">EMPTY_ELEMENTDATA</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>    注意到对于无参构造器使用的是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，而对于带参构造器，当 <u>initialCapacity</u> 为0时，使用的是<code>EMPTY_ELEMENTDATA</code>；另外，在无参构造器中的注释——“初始化容量为10的空列表”，我们不禁有以下疑惑： - <code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>都是空的对象数组，为什么在构造器中要对其进行区分 - 无参构造器中，只是把空的对象数组赋值给了<code>elementData</code>，为什么注释称声明了长度为10的空数组</p><p>对于以上问题，将在<b>存储和扩容</b>部分进行讲解。</p><h2>存储和扩容</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 增加 ArrayList 实例的容量，确保 ArrayList 实例能存储 minCapacity 个元素\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">ensureCapacity</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">minExpand</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">elementData</span> <span class=\"o\">!=</span> <span class=\"n\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"o\">)</span>\n        <span class=\"c1\">// any size if not default element table\n</span><span class=\"c1\"></span>        <span class=\"o\">?</span> <span class=\"n\">0</span>\n        <span class=\"c1\">// larger than default for default empty table. It&#39;s already\n</span><span class=\"c1\"></span>        <span class=\"c1\">// supposed to be at default size.\n</span><span class=\"c1\"></span>        <span class=\"o\">:</span> <span class=\"n\">DEFAULT_CAPACITY</span><span class=\"o\">;</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">minCapacity</span> <span class=\"o\">&gt;</span> <span class=\"n\">minExpand</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">ensureExplicitCapacity</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>    当ArrayList实例是个空列表并且 <code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>时，<u>minExpand</u> 设置为<code>DEFAULT_CAPACITY</code>(10)，此时如果 <u>minCapacity</u> 小于 <u>minExpand</u>，那么不马上进行扩容操作，在进行<code>add</code>操作时候，会初始化一个容量为 10 的空列表，这样不仅符合无参构造器中的注释，并且保证了 ArrayList 实例能够存储 <u>minCapacity</u> 个元素。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">elementData</span> <span class=\"o\">==</span> <span class=\"n\">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">minCapacity</span> <span class=\"o\">=</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">DEFAULT_CAPACITY</span><span class=\"o\">,</span> <span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">ensureExplicitCapacity</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>    在<code>add</code>操作内部，会调用这个<b>私有</b>方法来确保有足够的容量来放置元素。注意，这个函数一开始就对 <u>elementData</u> 进行判断是否为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，如果是的话，证明是无参构造器初始化的实例，在下一步会初始化一个容量为 10 的空列表，符合无参构造器中的注释，其实就是一个延迟初始化的技巧。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">ensureExplicitCapacity</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n\n    <span class=\"c1\">// 扩容操作\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">minCapacity</span> <span class=\"o\">-</span> <span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">grow</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 允许分配的最大数组大小\n</span><span class=\"cm\"> *一些 VM 会在数组头部储存头数据，试图尝试创建一个比 Integer.MAX_VALUE - 8 大的数组可能会产生 OOM 异常。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAX_ARRAY_SIZE</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span> <span class=\"o\">-</span> <span class=\"n\">8</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 增加 ArrayList 实例的容量，确保 ArrayList 实例能存储 minCapacity 个元素\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">grow</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// overflow-conscious code\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">oldCapacity</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"c1\">//扩容为当前容量的 1.5 倍\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">oldCapacity</span> <span class=\"o\">+</span> <span class=\"o\">(</span><span class=\"n\">oldCapacity</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newCapacity</span> <span class=\"o\">-</span> <span class=\"n\">minCapacity</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">minCapacity</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">newCapacity</span> <span class=\"o\">-</span> <span class=\"n\">MAX_ARRAY_SIZE</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">newCapacity</span> <span class=\"o\">=</span> <span class=\"n\">hugeCapacity</span><span class=\"o\">(</span><span class=\"n\">minCapacity</span><span class=\"o\">);</span>\n    <span class=\"c1\">// minCapacity is usually close to size, so this is a win:\n</span><span class=\"c1\"></span>    <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">copyOf</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">newCapacity</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">hugeCapacity</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">minCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">minCapacity</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"c1\">// overflow\n</span><span class=\"c1\"></span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">OutOfMemoryError</span><span class=\"o\">();</span>\n    <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">minCapacity</span> <span class=\"o\">&gt;</span> <span class=\"n\">MAX_ARRAY_SIZE</span><span class=\"o\">)</span> <span class=\"o\">?</span>\n        <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span> <span class=\"o\">:</span>\n        <span class=\"n\">MAX_ARRAY_SIZE</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 将指定的元素追加到此列表的末尾\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"n\">E</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>  <span class=\"c1\">// Increments modCount!!\n</span><span class=\"c1\"></span>    <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">size</span><span class=\"o\">++]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 在列表中将指定元素插入到指定位置，将其后元素都向右移动一个位置\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">add</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">E</span> <span class=\"n\">element</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">//检查 index 是否越界\n</span><span class=\"c1\"></span>    <span class=\"n\">rangeCheckForAdd</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">//确保有足够的容量能够添加元素\n</span><span class=\"c1\"></span>    <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">);</span>  <span class=\"c1\">// Increments modCount!!\n</span><span class=\"c1\"></span>    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">,</span>\n                     <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">index</span><span class=\"o\">);</span>\n    <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">element</span><span class=\"o\">;</span>\n    <span class=\"n\">size</span><span class=\"o\">++;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 将指定集合中的全部元素添加到列表尾端\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">addAll</span><span class=\"o\">(</span><span class=\"n\">Collection</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numNew</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">numNew</span><span class=\"o\">);</span>  <span class=\"c1\">// Increments modCount\n</span><span class=\"c1\"></span>    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">size</span><span class=\"o\">,</span> <span class=\"n\">numNew</span><span class=\"o\">);</span>\n    <span class=\"n\">size</span> <span class=\"o\">+=</span> <span class=\"n\">numNew</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">numNew</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 将指定集合中的全部元素插入到列表指定的位置后面\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">addAll</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">Collection</span><span class=\"o\">&lt;?</span> <span class=\"kd\">extends</span> <span class=\"n\">E</span><span class=\"o\">&gt;</span> <span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">rangeCheckForAdd</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n\n    <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">toArray</span><span class=\"o\">();</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numNew</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n    <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">numNew</span><span class=\"o\">);</span>  <span class=\"c1\">// Increments modCount\n</span><span class=\"c1\"></span>\n    <span class=\"kt\">int</span> <span class=\"n\">numMoved</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">index</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">numMoved</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span> <span class=\"o\">+</span> <span class=\"n\">numNew</span><span class=\"o\">,</span>\n                         <span class=\"n\">numMoved</span><span class=\"o\">);</span>\n\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span> <span class=\"n\">numNew</span><span class=\"o\">);</span>\n    <span class=\"n\">size</span> <span class=\"o\">+=</span> <span class=\"n\">numNew</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">numNew</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>    因此对于无参构造器的注释的疑问，到达这里就可以解答了，它确确实实初始化了一个大小为 10 的空列表，只是不是一开始就初始化，而是使用了延迟初始化的方式，在<code>add</code>的时候才进行初始化。     对于另一个问题，无参构造器使用<code>DEFAULTCAPACITY_EMPTY_ELEMENTDAT</code>，对于<code>new ArrayList(0);</code>使用的是<code>EMPTY_ELEMENTDATA</code>，前者是不知道需要的容量大小，后者预估元素较少。因此<code>ArrayList</code>对此做了区别，通过引用判断来区别用户行为，使用不同的扩容算法（扩容速度：无参：10-&gt;15-&gt;22...，有参且参数为0 ：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;6-&gt;9...)。另外，在 JDK 1.7 中，没有通过两个空数组来对用户行为进行区分，因此容量为 0 的话，会创建很多空数组<code>new Object[0]</code>，因此上述方式也对这种情况进行了优化。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//JDK 1.7\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"nf\">ArrayList</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">initialCapacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">();</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">initialCapacity</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;Illegal Capacity: &#34;</span><span class=\"o\">+</span>\n                                           <span class=\"n\">initialCapacity</span><span class=\"o\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">elementData</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">initialCapacity</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n\n\n<span class=\"kd\">public</span> <span class=\"nf\">ArrayList</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">this</span><span class=\"o\">(</span><span class=\"n\">10</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h2>删除</h2><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 从列表中删除指定位置的元素，并将其后位置的元素向左移动\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"n\">E</span> <span class=\"nf\">remove</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">//检查是否超过数组越界\n</span><span class=\"c1\"></span>    <span class=\"n\">rangeCheck</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"n\">E</span> <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">numMoved</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">index</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">numMoved</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span>\n                         <span class=\"n\">numMoved</span><span class=\"o\">);</span>\n    <span class=\"c1\">//置null，让 GC 可以工作\n</span><span class=\"c1\"></span>    <span class=\"n\">elementData</span><span class=\"o\">[--</span><span class=\"n\">size</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除列表中首次出现的指定的元素，若列表不存在相应元素，则不做改变\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">remove</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">o</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">//若指定元素为 null，因其为空，没有 equals 方法，因此这两个地方做一个区分\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">index</span><span class=\"o\">++)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">fastRemove</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">index</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">index</span><span class=\"o\">++)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">o</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">index</span><span class=\"o\">]))</span> <span class=\"o\">{</span>\n                <span class=\"n\">fastRemove</span><span class=\"o\">(</span><span class=\"n\">index</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/*\n</span><span class=\"cm\"> * Private remove method that skips bounds checking and does not\n</span><span class=\"cm\"> * return the value removed.\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">fastRemove</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">index</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numMoved</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">index</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">numMoved</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">index</span><span class=\"o\">,</span>\n                         <span class=\"n\">numMoved</span><span class=\"o\">);</span>\n    <span class=\"n\">elementData</span><span class=\"o\">[--</span><span class=\"n\">size</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"c1\">// clear to let GC do its work\n</span><span class=\"c1\"></span><span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 删除列表中所有的元素\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">clear</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n\n    <span class=\"c1\">// 置 null 以便让 GC 回收\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n        <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n    <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 从列表中删除 fromIndex &lt;= pos &lt; toIndex 的元素\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">removeRange</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">fromIndex</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">toIndex</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">modCount</span><span class=\"o\">++;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numMoved</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"n\">toIndex</span><span class=\"o\">;</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">arraycopy</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">toIndex</span><span class=\"o\">,</span> <span class=\"n\">elementData</span><span class=\"o\">,</span> <span class=\"n\">fromIndex</span><span class=\"o\">,</span>\n                     <span class=\"n\">numMoved</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">// clear to let GC do its work\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">newSize</span> <span class=\"o\">=</span> <span class=\"n\">size</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"n\">toIndex</span><span class=\"o\">-</span><span class=\"n\">fromIndex</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">newSize</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">newSize</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>ArrayList的序列化</h2><p>在 <a href=\"https://zhuanlan.zhihu.com/write#%E4%B8%BB%E8%A6%81%E5%AD%97%E6%AE%B5\" class=\"internal\">主要字段</a> 部分我们可以看到，<u>elementData</u> 是通过<code>transient</code>修饰的（<u>transient</u>具体用法可参看<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ZhaoxiCheung/p/Java-Serializable.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java对象序列化</a>一文），通过<code>transient</code>声明，因此其无法通过序列化技术保存下来，但仔细阅读源码发现其内部实现了序列化和反序列化函数：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 保存 ArrayList 中实例的状态到序列中\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">writeObject</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">ObjectOutputStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">{</span>\n    <span class=\"c1\">// Write out element count, and any hidden stuff\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">expectedModCount</span> <span class=\"o\">=</span> <span class=\"n\">modCount</span><span class=\"o\">;</span>\n    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">defaultWriteObject</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// Write out size as capacity for behavioural compatibility with clone()\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeInt</span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">// Write out all elements in the proper order.\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">modCount</span> <span class=\"o\">!=</span> <span class=\"n\">expectedModCount</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">ConcurrentModificationException</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 从序列中恢复 ArrayList 中实例的状态\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">readObject</span><span class=\"o\">(</span><span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">ObjectInputStream</span> <span class=\"n\">s</span><span class=\"o\">)</span>\n    <span class=\"kd\">throws</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">,</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n    <span class=\"n\">elementData</span> <span class=\"o\">=</span> <span class=\"n\">EMPTY_ELEMENTDATA</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// Read in size, and any hidden stuff\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">defaultReadObject</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// Read in capacity\n</span><span class=\"c1\"></span>    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">readInt</span><span class=\"o\">();</span> <span class=\"c1\">// ignored\n</span><span class=\"c1\"></span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">size</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// be like clone(), allocate array based upon size not capacity\n</span><span class=\"c1\"></span>        <span class=\"n\">ensureCapacityInternal</span><span class=\"o\">(</span><span class=\"n\">size</span><span class=\"o\">);</span>\n\n        <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">elementData</span><span class=\"o\">;</span>\n        <span class=\"c1\">// Read in all elements in the proper order.\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">readObject</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>通过一个例子验证其序列化和反序列化过程：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">test</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.io.*</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.ArrayList</span><span class=\"o\">;</span>\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.List</span><span class=\"o\">;</span>\n\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ListDemo</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">IOException</span><span class=\"o\">,</span> <span class=\"n\">ClassNotFoundException</span> <span class=\"o\">{</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span><span class=\"n\">list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;();</span>\n        <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;hello&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"s\">&#34;world&#34;</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">//write Obj to File\n</span><span class=\"c1\"></span>        <span class=\"n\">ObjectOutputStream</span> <span class=\"n\">oos</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjectOutputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">FileOutputStream</span><span class=\"o\">(</span><span class=\"s\">&#34;file&#34;</span><span class=\"o\">));</span>\n        <span class=\"n\">oos</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">list</span><span class=\"o\">);</span>\n        <span class=\"n\">oos</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">//read Obj from File\n</span><span class=\"c1\"></span>        <span class=\"n\">File</span> <span class=\"n\">file</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">File</span><span class=\"o\">(</span><span class=\"s\">&#34;file&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">ObjectInputStream</span> <span class=\"n\">ois</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjectInputStream</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">FileInputStream</span><span class=\"o\">(</span><span class=\"n\">file</span><span class=\"o\">));</span>\n        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;</span><span class=\"n\">newList</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">String</span><span class=\"o\">&gt;)</span> <span class=\"n\">ois</span><span class=\"o\">.</span><span class=\"na\">readObject</span><span class=\"o\">();</span>\n        <span class=\"n\">ois</span><span class=\"o\">.</span><span class=\"na\">close</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">newList</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"cm\">/*\n</span><span class=\"cm\">[hello, world]\n</span><span class=\"cm\"> */</span></code></pre></div><p>可以得出结论：ArrayList支持进行序列化操作，此时不禁会思考既然要将 ArrayList 的字段序列化（即将 elementData 序列化），那为什么又要用 transient 修饰 elementData 呢？实际上，ArrayList 通过动态数组的技术，当数组放满后，自动扩容，但是扩容后的容量往往都是大于或者等于 ArrayList 所存元素的个数。如果直接序列化 elementData 数组，那么就会序列化一大部分没有元素的数组，导致浪费空间，为了保证在序列化的时候不会将这么大部分没有元素的数组进行序列化，因此设置为 transient。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// Write out all elements in the proper order.\n</span><span class=\"c1\"></span><span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">=</span><span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">writeObject</span><span class=\"o\">(</span><span class=\"n\">elementData</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]);</span>\n<span class=\"o\">}</span></code></pre></div><p>从源码中，可以观察到循环时是使用<code>i &lt; size</code>而不是<code>i&lt;elementData.length</code>，说明序列化时，只需实际存储的那些元素，而不是整个数组。</p><h2>问题</h2><ul><li><code>List&lt;Integer&gt;list = new ArrayList&lt;&gt;(10); out.println(list.get(1));</code>是否会抛出异常</li><li>ArrayList 支持序列化，为什么 <u>elementData</u> 要设置为<code>transient</code></li><li>对于空实例数组，为什么要区分<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code> </li></ul>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52150962", 
            "userName": "Zyoung", 
            "userLink": "https://www.zhihu.com/people/05cb417aa13f8759cbe3b293287e8367", 
            "upvote": 1, 
            "title": "链表专题——面试中常见的链表问题", 
            "content": "<p><b>声明：</b> 链表定义如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//Java:\n</span><span class=\"c1\"></span><span class=\"kd\">class</span> <span class=\"nc\">ListNode</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n    <span class=\"n\">ListNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">//C++:\n</span><span class=\"c1\"></span><span class=\"n\">typedef</span> <span class=\"n\">struct</span> <span class=\"n\">ListNode</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n    <span class=\"n\">struct</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n        <span class=\"n\">val</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">),</span> <span class=\"n\">next</span><span class=\"o\">(</span><span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span><span class=\"n\">ListNode</span><span class=\"o\">;</span></code></pre></div><h2>从无头单链表中删除节点</h2><p><b>详情：</b>给定一个没有头指针的单链表，一个指针指向此单链表中间的一个节点（不是第一个，也不是最后一个节点），请将该节点从单链表中删除。 <b>题解：</b> 解法一：由于单链表并没有给出头指针，因此我们无法通过遍历链表的方式找到该节点的前一个节点来改变其 next 指向去指向该节点的 next 节点。换一种思路，我们可以将该节点的元素值全部替换成其 next 节点，然后删除 next 节点，这样就相当于把该节点删除了。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//Java\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">deleteRandomNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">currentNode</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">nextNode</span> <span class=\"o\">=</span> <span class=\"n\">currentNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nextNode</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">currentNode</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">nextNode</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">;</span>\n        <span class=\"n\">currentNode</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">nextNode</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">nextNode</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">deleteRandomNode</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">current</span><span class=\"o\">){</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">){</span>\n        <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span><span class=\"o\">;</span>\n        <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">delete</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>反转链表</h2><p><b>详情：</b>给定一个链表的头指针，要求只遍历一次，将单链表中的元素顺序反转过来。 <b>题解：</b> 解法一：题目较为简单，每次反转的时候记录下一个节点的指针</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//Java\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">ReverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">head</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">head</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n        <span class=\"n\">pre</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">pre</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">ReverseList</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">NULL</span><span class=\"o\">,</span> <span class=\"o\">*</span><span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">NULL</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pHead</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n        <span class=\"n\">pHead</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">prev</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">current</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>两个链表的第一个公共节点</h2><p><b>详情：</b>输入两个链表，找出它们的第一个公共节点 <b>题解：</b> 解法一：为了找到两个链表的公共节点，那么我们可以从尾往头遍历查找，但是只给了我们头节点，因此类似于栈的先进后出，因此我们可以用两个栈来保存节点，然后从栈中取出节点进行比较。 解法二：统计两个链表的长度 len1 和 len2，让较长的链表先走<code>abs(len1 - len2)</code>长度，之后二者同时继续往下遍历，查找第一个公共节点。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"nf\">FindFirstCommonNode</span><span class=\"p\">(</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead1</span><span class=\"p\">,</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">len1</span> <span class=\"o\">=</span> <span class=\"n\">SizeLinkedList</span><span class=\"p\">(</span><span class=\"n\">pHead1</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">len2</span> <span class=\"o\">=</span> <span class=\"n\">SizeLinkedList</span><span class=\"p\">(</span><span class=\"n\">pHead2</span><span class=\"p\">);</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">len1</span> <span class=\"o\">&gt;</span> <span class=\"n\">len2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">pHead1</span> <span class=\"o\">=</span> <span class=\"n\">walker</span><span class=\"p\">(</span><span class=\"n\">pHead1</span><span class=\"p\">,</span> <span class=\"n\">len1</span> <span class=\"o\">-</span> <span class=\"n\">len2</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">pHead2</span> <span class=\"o\">=</span> <span class=\"n\">walker</span><span class=\"p\">(</span><span class=\"n\">pHead2</span><span class=\"p\">,</span> <span class=\"n\">len2</span> <span class=\"o\">-</span> <span class=\"n\">len1</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">!=</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">pHead1</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"n\">pHead2</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">pHead1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">SizeLinkedList</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">head</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>   <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">current</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">size</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">current</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">size</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"nf\">walker</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">cnt</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">cnt</span><span class=\"o\">--</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>判断给定链表是否存在环</h2><p><b>详情：</b>给定一个链表，判断这个链表是否存在环 <b>题解：</b> 解法一：<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ZhaoxiCheung/p/7355369.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Floyd判圈算法</a></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"kt\">bool</span> <span class=\"nf\">hasRing</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead</span><span class=\"p\">){</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">hasRing</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">fast</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">){</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">fast</span> <span class=\"o\">==</span> <span class=\"n\">slow</span><span class=\"p\">)</span>   <span class=\"n\">hasRing</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">hasRing</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>链表中环的入口节点</h2><p><b>详情：</b>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 <b>题解：</b> 解法一：<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/ZhaoxiCheung/p/7355369.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Floyd判圈算法</a></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//Java\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">EntryNodeOfLoop</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">,</span> <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">==</span> <span class=\"n\">slow</span><span class=\"o\">)</span>   <span class=\"k\">break</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>  <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">!=</span> <span class=\"n\">slow</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">fast</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">EntryNodeOfLoop</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">,</span> <span class=\"o\">*</span><span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">==</span> <span class=\"n\">slow</span><span class=\"o\">)</span>   <span class=\"k\">break</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span> <span class=\"o\">||</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span>   <span class=\"k\">return</span> <span class=\"n\">NULL</span><span class=\"o\">;</span>\n    <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">pHead</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">fast</span> <span class=\"o\">!=</span> <span class=\"n\">slow</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">fast</span> <span class=\"o\">=</span> <span class=\"n\">fast</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"n\">slow</span> <span class=\"o\">=</span> <span class=\"n\">slow</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">fast</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><h2>判断两个链表是否相交</h2><p><b>详情：</b>给定两个单链表的头指针，判断这两个链表是否相交。 <b>题解：</b> 解法一：若两个链表相交，则链表的最后一个节点一定是公共的，因此可以利用这个性质求解。</p><div class=\"highlight\"><pre><code class=\"language-text\">//C++\nbool isIntersect(ListNode *pHead1, ListNode *pHead2){\n    if (pHead1 == NULL || pHead2 == NULL)   return false;\n    while (pHead1-&gt;next != NULL)    pHead1 = pHead1-&gt;next;\n    while (pHead2-&gt;next != NULL)    pHead2 = pHead2-&gt;next;\n    if (pHead1 == pHead2)   return true;\n    return false;\n}</code></pre></div><p>解法二：由于都是单项链表，也就是都没有环，那么我们可以把第一个链表链接到第二个链表后面，如果新的链表有环，证明了有公共节点。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"kt\">bool</span> <span class=\"nf\">isIntersect</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead1</span><span class=\"p\">,</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead2</span><span class=\"p\">){</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">pHead1</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span> <span class=\"o\">||</span> <span class=\"n\">pHead2</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>   <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">hasRing</span><span class=\"p\">(</span><span class=\"n\">pHead1</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>判断两个链表是否相交<b>变形</b></h2><p><b>详情：</b>给定两个<b>有环</b>链表的头指针，判断这两个链表是否相交。 <b>题解：</b> 解法一：对于有环链表，如果相交，存在以下几种情况： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-274beb77f3875aca533f076763fbc872_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb\" width=\"611\" data-original=\"https://pic3.zhimg.com/v2-274beb77f3875aca533f076763fbc872_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;611&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"611\" data-original=\"https://pic3.zhimg.com/v2-274beb77f3875aca533f076763fbc872_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-274beb77f3875aca533f076763fbc872_b.jpg\"/></figure><p> 因此，找到链表的入口节点，判断是否相等，对应情形一和二，对于三，我们可以固定一个节点，然后遍历链表来判断是否存在相交。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"kt\">bool</span> <span class=\"nf\">isIntersect</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead1</span><span class=\"p\">,</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead2</span><span class=\"p\">){</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">pHead1</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span> <span class=\"o\">||</span> <span class=\"n\">pHead2</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>   <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">entry1</span> <span class=\"o\">=</span> <span class=\"n\">EntryNodeOfLoop</span><span class=\"p\">(</span><span class=\"n\">pHead1</span><span class=\"p\">);</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">entry2</span> <span class=\"o\">=</span> <span class=\"n\">EntryNodeOfLoop</span><span class=\"p\">(</span><span class=\"n\">pHead2</span><span class=\"p\">);</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">entry1</span> <span class=\"o\">==</span> <span class=\"n\">entry2</span><span class=\"p\">)</span>   <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span><span class=\"p\">{</span>\n        <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">backup</span> <span class=\"o\">=</span> <span class=\"n\">entry2</span><span class=\"p\">;</span>\n        <span class=\"k\">do</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">entry2</span> <span class=\"o\">=</span> <span class=\"n\">entry2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span><span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">entry2</span> <span class=\"o\">!=</span> <span class=\"n\">entry1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">entry2</span> <span class=\"o\">!=</span> <span class=\"n\">backup</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">entry2</span> <span class=\"o\">!=</span> <span class=\"n\">backup</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>合并两个排序的链表</h2><p><b>详情：</b>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 <b>题解：</b> 解法一：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//Java\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"n\">ListNode</span> <span class=\"nf\">Merge</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"n\">list1</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"n\">list2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"n\">ListNode</span> <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">?</span> <span class=\"n\">list1</span> <span class=\"o\">:</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">list2</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">list1</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">list2</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">list1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">;</span>\n        <span class=\"n\">list1</span> <span class=\"o\">=</span> <span class=\"n\">list1</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">list2</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">prev</span><span class=\"o\">.</span><span class=\"na\">next</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">;</span>\n        <span class=\"n\">list2</span> <span class=\"o\">=</span> <span class=\"n\">list2</span><span class=\"o\">.</span><span class=\"na\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"c1\">//C++\n</span><span class=\"c1\"></span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">Merge</span><span class=\"o\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead1</span><span class=\"o\">,</span> <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">pHead2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead1</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead2</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">NULL</span><span class=\"o\">;</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">root</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">?</span> <span class=\"n\">pHead1</span> <span class=\"o\">:</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pHead1</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">pHead2</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span> <span class=\"o\">&lt;</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">pHead1</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">prev</span> <span class=\"o\">==</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n                <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n                <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n            <span class=\"n\">pHead2</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pHead1</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">;</span>\n        <span class=\"n\">pHead1</span> <span class=\"o\">=</span> <span class=\"n\">pHead1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">pHead2</span> <span class=\"o\">!=</span> <span class=\"n\">NULL</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n        <span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">;</span>\n        <span class=\"n\">pHead2</span> <span class=\"o\">=</span> <span class=\"n\">pHead2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">root</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "链表", 
                    "tagLink": "https://api.zhihu.com/topics/19649942"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1050743817447337984"
}
