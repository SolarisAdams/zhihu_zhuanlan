{
    "title": "促膝笔谈", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/hyzok", 
        "https://www.zhihu.com/people/fang-ni-96-8", 
        "https://www.zhihu.com/people/ta-tu-35-66", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/lxfeng", 
        "https://www.zhihu.com/people/viggoxia", 
        "https://www.zhihu.com/people/zhang-liang-7-1-36", 
        "https://www.zhihu.com/people/xu-ming-ming-78-15", 
        "https://www.zhihu.com/people/huanyu-chen", 
        "https://www.zhihu.com/people/1024-75-51", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/kerryliang-11", 
        "https://www.zhihu.com/people/xu-ze-fan-37", 
        "https://www.zhihu.com/people/kai-en-56", 
        "https://www.zhihu.com/people/yu-tie-niu", 
        "https://www.zhihu.com/people/zhang-tian-44-23", 
        "https://www.zhihu.com/people/jin-liang-21-65", 
        "https://www.zhihu.com/people/zhou-shuai-chao", 
        "https://www.zhihu.com/people/sTank", 
        "https://www.zhihu.com/people/spring-star", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/dplord", 
        "https://www.zhihu.com/people/koo-jj", 
        "https://www.zhihu.com/people/lei-zi-hai", 
        "https://www.zhihu.com/people/xie-zi-82-82", 
        "https://www.zhihu.com/people/nan-gong-ran-69", 
        "https://www.zhihu.com/people/bai-shi-jie", 
        "https://www.zhihu.com/people/zhi-hu-zhe-ye-70-52-30", 
        "https://www.zhihu.com/people/jiao-luo-70-45", 
        "https://www.zhihu.com/people/pan-peter-71-62", 
        "https://www.zhihu.com/people/hijackjave", 
        "https://www.zhihu.com/people/openthedoors", 
        "https://www.zhihu.com/people/he-ping-33-22", 
        "https://www.zhihu.com/people/yy158125", 
        "https://www.zhihu.com/people/huang-han-tao-54", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/joseph295"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/60996977", 
            "userName": "不去彼岸", 
            "userLink": "https://www.zhihu.com/people/133519f8dc6923280761214073ec2a06", 
            "upvote": 24, 
            "title": "多线程redis的设计思路，与实践笔记", 
            "content": "<p></p><h3>由来</h3><p>  Redis以其极高的性能以及支持丰富的数据结构而著称，在互联网行业应用广泛，尤其是KV缓存，以及类似索引的zset有序集合。然而随着服务器CPU核数的增加，Redis单线程的设计也被大家所诟病。因此也萌生了自己实现一个多线程版redis的想法，不过感觉工作量不少，所以一直没有动手<br/>   其实在去年就用go实现过一个类似redis的nosql数据库，支持了主要的几种数据结构。不过完成度还不高，还没有主从与集群功能。  </p><p>  前几个星期在知乎看到阿里云的多线程版Redis实现,感觉是个不错的简化方案，而且之前实践过自己的gedis项目，积累了一定的经验，所以就决定自己也薅一个多线程redis出来</p><p>有兴趣可以移步github看具体的项目： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/wosiwo/redis-multithreading\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">redis-multithreading</a></p><h3>Redis内部实现</h3><blockquote> 工欲善其事必先利其器，动手改造之前先要梳理好redis本身的设计思路<br/> </blockquote><h3>Redis的各个逻辑链</h3><p>  一直觉得接触一个大项目需要抓好切入点(一个是提高效率，一个是容易建立正反馈)，虽然代码可读性一直都是大家的追求，不过程序语言到底还是处在人的语言和机器语言中间，通读代码来理出逻辑肯定不是一个高效的办法。<br/>   基于之前的实践，感觉从逻辑链入手，是一个比较好的办法，一开始不要把自己困在一个个逻辑实现的细节总，人大脑的并行能力其实很有限，不同层次的逻辑混在一起看，难度就大了很多  </p><div class=\"highlight\"><pre><code class=\"language-as3\"><span class=\"c1\">//一次Redis请求的执行流程\n</span><span class=\"c1\"></span><span class=\"n\">main</span><span class=\"o\">();</span>                                    <span class=\"c1\">//入口函数\n</span><span class=\"c1\"></span><span class=\"n\">listenToPort</span><span class=\"o\">();</span>                           <span class=\"c1\">//端口监听\n</span><span class=\"c1\"></span><span class=\"n\">aeCreateFileEvent</span><span class=\"o\">();</span>                        <span class=\"c1\">//事件触发绑定\n</span><span class=\"c1\"></span><span class=\"n\">aeMain</span><span class=\"o\">();</span>                                   <span class=\"c1\">//主事件循环\n</span><span class=\"c1\"></span><span class=\"n\">acceptTcpHandler</span><span class=\"o\">();</span><span class=\"n\">acceptUnixHandler</span><span class=\"o\">();</span>     <span class=\"c1\">//创建tcp/本地 连接\n</span><span class=\"c1\"></span><span class=\"n\">createClient</span><span class=\"o\">();</span>                           <span class=\"c1\">//创建一个新客户端\n</span><span class=\"c1\"></span><span class=\"n\">readQueryFromClient</span><span class=\"o\">();</span>                    <span class=\"c1\">//读取客户端的查询缓冲区内容\n</span><span class=\"c1\"></span><span class=\"n\">processInputBuffer</span><span class=\"o\">();</span>                        <span class=\"c1\">//处理客户端输入的命令内容\n</span><span class=\"c1\"></span><span class=\"n\">processCommand</span><span class=\"o\">();</span>                         <span class=\"c1\">//执行命令\n</span><span class=\"c1\"></span><span class=\"n\">addReply</span><span class=\"o\">();</span>                               <span class=\"c1\">//将客户端连接描述符的写事件，绑定到指定的事件循环中\n</span><span class=\"c1\"></span><span class=\"n\">sendReplyToClient</span><span class=\"o\">();</span>                      <span class=\"sr\">//</span><span class=\"n\">reactor线程中将内容输出给客户端</span></code></pre></div><p>更详细的调用链梳理：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wosiwo/redis-multithreading/blob/master/CallChain.md\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CallChain.md</a></p><h3>几种多线程模型的对比</h3><blockquote> 了解了Redis本身的逻辑链，下面就可以思考应该应用那种多线程模型  <br/> </blockquote><ul><li> 首先是阿里云Redis采用的简化方案，增加多个reactor线程(IO线程)和一个worker线程  </li></ul><blockquote>这个方案采取了折中的方式，只有一个worker线程负责所有的对数据库的读写操作， 这个就避免了很多并行操作数据库的多线程安全问题<br/> </blockquote><ul><li> 第二个方案是多个reactor线程,多个worker线程  </li></ul><blockquote>后面实验性版本，对GET命令做了压测，性能虽然对比第一个方案有一定的提升， 不过对数据库的并行操作如何保障线程安全，又是需要好好考虑的问题了， 而且这样reactor线程+worker线程不能明显超过CPU核心数(或者说线程数)，CPU频繁的切换线程， 还是会带来可观的性能损耗的，所以说不如第三个方案<br/> </blockquote><ul><li> 第三个方案就是多线程不区分IO线程和工作线程，从IO到命令执行都在同一个线程  (开了实验性的分支，只支持对GET命令的压测)</li></ul><blockquote>这个方案的最后的压测效果最好，不过通样也是有并发操作数据库的线程安全问题，对数据库的并行操作， 很显然是没法彻底避免使用锁的，下面会有专门的锻炼来尝试设计一个尽量减少互斥的数据库并行操作的方案<br/> </blockquote><ul><li> 第四个方案是综合了第一第三个方案，多个reactor线程，一个worker线程，不过只有写入操作会分配个worker线程，读取命令由reactor线程直接执行</li></ul><blockquote>这个方案实现起来会相对简单一些(这个方案还处于TODO状态，不过大体上应该能猜的出， 读取性能指标接近第三个方案，写入的性能接近第一个方案)<br/> </blockquote><ul><li> 在开工实现第一个方案的时候还意外发现了唯品会实现的多线程版redis：vire</li></ul><blockquote> vire的多线程模型类似于方案3，对数据库的并行操作同个一个比较粗粒度的锁来保证线程安全， (不过vire这个就是一个按照redis思路的一个全新实现了)<br/> </blockquote><h3>多reactor单worker线程模型</h3><blockquote> 目前实现的是第一个方案，这里做一个详细的介绍,先借用阿里云Redis的模型图 </blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b40cfe0a0d70260b656815da5b9b216f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-b40cfe0a0d70260b656815da5b9b216f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;682&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-b40cfe0a0d70260b656815da5b9b216f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b40cfe0a0d70260b656815da5b9b216f_b.jpg\"/></figure><ul><li>主线程监听端口，当有请求到来时从accepted队列从取出已经就绪的连接描述符，将之加入到某个reactor线程的事件循环中，并指定可读时触发事件，与回调函数</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">dispatch2Reactor</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">connfd</span><span class=\"p\">,</span><span class=\"n\">redisClient</span> <span class=\"o\">*</span><span class=\"n\">c</span><span class=\"p\">){</span>\n    <span class=\"kt\">int</span> <span class=\"n\">reactor_id</span> <span class=\"o\">=</span> <span class=\"n\">connfd</span><span class=\"o\">%</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactorNum</span><span class=\"p\">;</span> <span class=\"c1\">//连接fd对REACTOR_NUM取余，决定抛给哪个reactor线程\n</span><span class=\"c1\"></span>    <span class=\"c1\">//将connfd加入到指定reactor线程的事件循环中\n</span><span class=\"c1\"></span>    <span class=\"c1\">//reactor线程的事件驱动器被触发后，AE_READABLE类型的事件会被分发到reactorReadHandle函数\n</span><span class=\"c1\"></span>    <span class=\"n\">aeCreateFileEvent</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactors</span><span class=\"p\">[</span><span class=\"n\">reactor_id</span><span class=\"p\">].</span><span class=\"n\">el</span><span class=\"p\">,</span><span class=\"n\">connfd</span><span class=\"p\">,</span><span class=\"n\">AE_READABLE</span><span class=\"p\">,</span><span class=\"n\">reactorReadHandle</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"p\">);</span>\n<span class=\"p\">}</span></code></pre></div><ul><li>有多个reactor线程，里面都有各自的事件循环，从主线程绑定过来的连接描述符connfd可读时，会执行绑定的回调函数，在回调函数里读取数据，写入到c-&gt;querybuf中，并将连接对象添加到线程的无锁队列中，然后使用管道(socketpair)通知worker线程</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">reactorReadHandle</span><span class=\"p\">(</span><span class=\"n\">aeEventLoop</span> <span class=\"o\">*</span><span class=\"n\">el</span><span class=\"p\">,</span><span class=\"kt\">int</span> <span class=\"n\">connfd</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">privdata</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">mask</span><span class=\"p\">){</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">readQueryFromClient</span><span class=\"p\">(</span><span class=\"n\">el</span><span class=\"p\">,</span> <span class=\"n\">connfd</span><span class=\"p\">,</span> <span class=\"n\">privdata</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"p\">);</span>\n    <span class=\"c1\">//通过管道通知worker线程\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">pipeWriteFd</span> <span class=\"o\">=</span> <span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">worker</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">pipMasterFd</span><span class=\"p\">;</span>\n     <span class=\"c1\">//将客户端信息添加到当前reactor线程的队列中\n</span><span class=\"c1\"></span>    <span class=\"n\">atomListAddNodeTail</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactors</span><span class=\"p\">[</span><span class=\"n\">c</span><span class=\"o\">-&gt;</span><span class=\"n\">reactor_id</span><span class=\"p\">].</span><span class=\"n\">clients</span><span class=\"p\">,</span><span class=\"n\">c</span><span class=\"p\">);</span>\n    <span class=\"c1\">//worker线程循环读取队列，可以判断worker线程状态来决定是否通过管道通知worker线程\n</span><span class=\"c1\"></span>    <span class=\"c1\">//避免大量的管道读写带来的开销\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"o\">==</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">worker</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">loopStatus</span><span class=\"p\">){</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">pipeWriteFd</span><span class=\"p\">,</span> <span class=\"n\">str</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">);</span>\n        <span class=\"n\">redisLog</span><span class=\"p\">(</span><span class=\"n\">REDIS_NOTICE</span><span class=\"p\">,</span><span class=\"s\">&#34;reactorReadHandle reactor_id %s write %d connfd %d&#34;</span><span class=\"p\">,</span><span class=\"n\">str</span><span class=\"p\">,</span><span class=\"n\">ret</span><span class=\"p\">,</span><span class=\"n\">connfd</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><ul><li>一个worker线程，也带有事件循环，绑定管道的可读事件，当reactor线程写管道时，会触发可读事件绑定的回调函数，回调函数中，从无锁队列中取出redisclient *c 对象，执行c-&gt;querybuf中的请求，将结果写入c-&gt;buf，最后将连接connfd再以可写触发类型绑定到reactor线程，由reactor将结果write(connfd)输出给客户端</li><li>考虑到管道读写的开销，worker线程会循环的拉取队列内容，直到所有线程的队列都为空，同时worker线程会标记自己的运行状态，尽量避免不必要的管道通信</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">workerPipeReadHandle</span><span class=\"p\">(</span><span class=\"n\">aeEventLoop</span> <span class=\"o\">*</span><span class=\"n\">el</span><span class=\"p\">,</span><span class=\"kt\">int</span> <span class=\"n\">pipfd</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">privdata</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">mask</span><span class=\"p\">){</span>\n      <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">node</span><span class=\"p\">;</span><span class=\"kt\">int</span> <span class=\"n\">nullNodes</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"k\">do</span><span class=\"p\">{</span>     <span class=\"c1\">//轮询各个线程的队列，循环弹出所有节点\n</span><span class=\"c1\"></span>          <span class=\"n\">reactor_id</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactorNum</span><span class=\"p\">);</span>\n          <span class=\"c1\">//从无锁队列从取出client信息\n</span><span class=\"c1\"></span>          <span class=\"n\">redisClient</span> <span class=\"o\">*</span><span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">atomListPop</span><span class=\"p\">(</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactors</span><span class=\"p\">[</span><span class=\"n\">reactor_id</span><span class=\"p\">].</span><span class=\"n\">clients</span><span class=\"p\">);</span>\n          <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"o\">==</span><span class=\"n\">node</span><span class=\"p\">)</span> <span class=\"n\">nullNodes</span><span class=\"o\">++</span><span class=\"p\">;</span>\n\n          <span class=\"n\">processInputBuffer</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>  <span class=\"c1\">//执行客户端操作命令\n</span><span class=\"c1\"></span>      <span class=\"p\">}</span><span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">nullNodes</span><span class=\"o\">&lt;</span><span class=\"n\">server</span><span class=\"p\">.</span><span class=\"n\">reactorNum</span><span class=\"p\">);</span> <span class=\"c1\">//循环取队列     \n</span><span class=\"c1\"></span><span class=\"p\">}</span></code></pre></div><h3>Redis拆分多线程后线程安全问题梳理</h3><blockquote> 先就第一个方案来梳理拆分后遇到的线程安全问题<br/> </blockquote><h3>客户端对象</h3><p>redisClient *c ,在主线程，reactor线程，woker线程都有可能被操作</p><ul><li>主线程里面负责创建这个结构体，还有有定时任务会清理所有客户端的c-&gt;querybuf空闲空间，以及关闭超时连接</li><ul><li>缩小客户端查询缓冲区的大小</li><ul><li>查询缓冲区的大小大于 BIG_ARG 以及 querybuf_peak</li><li>客户端不活跃，并且缓冲区大于 1k</li><li>这里定时任务的缩小缓存区的操作有可能触发线程安全问题 </li></ul></ul><li>reactor线程负责从连接描述符connfd中读取请求内容到c-&gt;querybuf</li><li>每个reactor线程有一个无锁队列，在reactor中将 redisClient *c添加到队列中，在worker线程中取出</li><li>worker线程会从c-&gt;querybuf读取请求命令并执行</li><li>最后会由reactor线程将c-&gt;buf或c-&gt;reply中的内容输出给客户端</li><li>同一个连接，上一次请求没处理完，下一次请求又到来的话，会操作同一个redisClient *c结构体(主从同步的时候会碰到这种情况)</li></ul><h3>字典扩容</h3><p>在数据库字典dict满的时候，会对字典进行扩容，这个时候会有线程安全问题</p><h3>频道订阅</h3><p>对channel订阅，与取消订阅的操作，需要改造为无锁队列(pubsubUnsubscribeChannel())</p><h3>server 全局变量</h3><ul><li>关闭连接时，从server.clients删除连接信息 ln = listSearchKey(server.clients,c);</li><li>关闭连接时 删除客户端的阻塞信息 ln = listSearchKey(server.unblocked_clients,c);</li><li>命令执行次数计数server.stat_numcommands</li><li>server.clients 的处理</li><ul><li>创建客户端对象 c时，添加到链表尾部 listAddNodeTail(server.clients,c);            </li><li>连接关闭时，从链表删除 freeClient(redisClient *c)</li><li>即使单线程情况下，定时任务也有可能会清理掉执行完，而未输出给客户端的连接信息，---因为单线程下，从读取connfd内容，写入querybuf到命令执行完毕都是连续的，命令执行完后，c-&gt;querybuf就可以回收了</li></ul></ul><h3>事务</h3><p>TODO 验证多线程对事务是否有影响</p><h3>集群</h3><p>多线程下的集群 也是TODO状态  </p><h3>性能优化措施</h3><blockquote> 对线程模型进行优化，以充分利用多核，以及尽可能减少线程间的互斥<br/> </blockquote><ul><li>无锁队列<br/>    先对无锁队列做一个梳理<br/>    进队列操作</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">EnQueue</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">,</span><span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"c1\">//进队列改良版\n</span><span class=\"c1\"></span><span class=\"p\">{</span>\n    <span class=\"n\">node</span> <span class=\"o\">=</span> <span class=\"n\">new</span> <span class=\"n\">record</span><span class=\"p\">();</span>\n    <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"n\">node</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n\n    <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span><span class=\"p\">;</span>\n    <span class=\"n\">oldp</span> <span class=\"o\">=</span> <span class=\"n\">p</span>\n\n    <span class=\"c1\">//判断是否空表\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">CAS</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nb\">true</span><span class=\"p\">){</span> <span class=\"c1\">//表尾指针为空\n</span><span class=\"c1\"></span>        <span class=\"c1\">//这里有个需要特别注意的地方，不能直接把node节点赋值给list-&gt;head\n</span><span class=\"c1\"></span>        <span class=\"c1\">//因为当出队速度快于入队速速，是会把队列取空的，一旦队列取空，是无法原子的同时吧list-&gt;head和list-&gt;tail原子的置空的\n</span><span class=\"c1\"></span>        <span class=\"c1\">//所以就需要给原队列留下一个种子，保证队列不会完全被置空\n</span><span class=\"c1\"></span>        <span class=\"c1\">//无锁队列的设计很巧妙的通过使用哨兵节点，在初始化队列时，给head指针赋值一个空节点，这个空节点的next指针再指向真正的当前节点\n</span><span class=\"c1\"></span>        <span class=\"c1\">//这样即使在取空队列的时候，仍然会有一个节点被留下来\n</span><span class=\"c1\"></span>        <span class=\"n\">headNode</span> <span class=\"o\">=</span> <span class=\"n\">new</span> <span class=\"n\">record</span><span class=\"p\">();</span>\n        <span class=\"n\">headNode</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"n\">headNode</span><span class=\"o\">-&gt;</span><span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">headNode</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">CAS</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">head</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">)</span><span class=\"o\">!=</span><span class=\"nb\">true</span><span class=\"p\">){</span>\n            <span class=\"c1\">//printf(&#34;list-&gt;head shoud be null except\\n&#34;);\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n    <span class=\"p\">}</span><span class=\"k\">else</span><span class=\"p\">{</span>\n      <span class=\"k\">do</span> <span class=\"p\">{</span>\n          <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"c1\">//加这个while循环是因为tail节点是不能保证一定指向最后一个节点的\n</span><span class=\"c1\"></span>              <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span> <span class=\"k\">while</span><span class=\"p\">(</span> <span class=\"n\">CAS</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">TRUE</span><span class=\"p\">);</span> <span class=\"c1\">//如果没有把结点链在尾上，再试\n</span><span class=\"c1\"></span>      <span class=\"c1\">//p.next==NULL 表示当前节点已经是事实上的最后一个节点\n</span><span class=\"c1\"></span>\n      <span class=\"n\">CAS</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span><span class=\"p\">,</span> <span class=\"n\">oldp</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">);</span> <span class=\"c1\">//置尾结点\n</span><span class=\"c1\"></span>      <span class=\"c1\">//如果tail指针指向的仍然是循环之前的节点，则将其指向新加入的节点\n</span><span class=\"c1\"></span>      <span class=\"c1\">//tail指针没有变化，说明这中间没有其他线程对链表进行入队操作\n</span><span class=\"c1\"></span>      <span class=\"c1\">//不论是否发生了变化，其实都不能保证tail指针指向的是最后的节点，只是能够在执行这段代码时没有其他线程插入的情况下将tail指针更新到较新的节点\n</span><span class=\"c1\"></span>\n    <span class=\"p\">}</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>出队列操作 </p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">DeQueue</span><span class=\"p\">(</span><span class=\"n\">list</span><span class=\"p\">)</span> <span class=\"c1\">//出队列\n</span><span class=\"c1\"></span>  <span class=\"p\">{</span>\n      <span class=\"k\">do</span><span class=\"p\">{</span>\n          <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">head</span><span class=\"p\">;</span>\n          <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">){</span>\n              <span class=\"k\">return</span> <span class=\"n\">ERR_EMPTY_QUEUE</span><span class=\"p\">;</span>\n          <span class=\"p\">}</span>\n      <span class=\"k\">while</span><span class=\"p\">(</span> <span class=\"n\">CAS</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">list</span><span class=\"o\">-&gt;</span><span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">TRUE</span> <span class=\"p\">);</span>\n      <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">value</span><span class=\"p\">;</span>  <span class=\"c1\">//返回的是下一个节点的内容\n</span><span class=\"c1\"></span>      <span class=\"c1\">// TODO 需要避免head指针跑到tail指针后面\n</span><span class=\"c1\"></span>  <span class=\"p\">}</span></code></pre></div><ul><li>每个reactor线程维持一个无锁队列，worker线程循环读取各个队列，取空才退出等待下一次通信，大大减少了同个管道进行通信的次数</li><li>TODO：线程模型的优化： 也就是前面提到的线程模型方案三，方案四</li><li>TODO:  数据库并行操作的方案  ：使用原子操作来使得多线程支持SET</li><li>TODO：其他复杂数据结构的并行操作(集合，列表，有续集)</li></ul><h3>压测对比</h3><blockquote> 对各种线程模型的压测对比(后面的两种方案只是实验性质的拉了分支，并没有处理线程安全问题，所以只能对get命令压测)<br/> </blockquote><p>机器环境</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a0f80b28c50ed4ed636ade7a82fab80d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1446\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb\" width=\"1446\" data-original=\"https://pic2.zhimg.com/v2-a0f80b28c50ed4ed636ade7a82fab80d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1446&#39; height=&#39;186&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1446\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1446\" data-original=\"https://pic2.zhimg.com/v2-a0f80b28c50ed4ed636ade7a82fab80d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a0f80b28c50ed4ed636ade7a82fab80d_b.jpg\"/></figure><p>压测结果</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cf97c8a659c783481ed16d3b94a2ec60_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1450\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb\" width=\"1450\" data-original=\"https://pic1.zhimg.com/v2-cf97c8a659c783481ed16d3b94a2ec60_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1450&#39; height=&#39;540&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1450\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1450\" data-original=\"https://pic1.zhimg.com/v2-cf97c8a659c783481ed16d3b94a2ec60_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cf97c8a659c783481ed16d3b94a2ec60_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-bash\">//这里直接使用了vire的多线程压测客户端\n//e.g get命令的压测  -T 表示压测程序开启的线程数\n./tests/vire-benchmark -p <span class=\"m\">6381</span> -c <span class=\"m\">600</span> -T <span class=\"m\">12</span> -t get -n <span class=\"m\">1000000</span>\nGET命令的压测会有两个值，斜杆<span class=\"s2\">&#34;/&#34;</span>前是直接对空数据库的GET请求，另一个是有数据情况下的GET请求</code></pre></div><p>  从压测对比上看，目前实现的多reactor单worker线程模型(虽然只在空数据集的情况下进行压测)，在大部分命令中性能大概是原版redis是两倍，不过还是直接多个工作线程的方案三性能最好   </p><h3>TODO</h3><ul><li>多线程下的集群</li><li>内存满的时候将淘汰的key落地</li><li>压测，找出瓶颈，向C10M方向优化</li><li>加上磁盘搜索功能，让redis不再局限与一个内存数据库(待定)</li></ul><h3>参考</h3><p><a href=\"https://link.zhihu.com/?target=https%3A//coolshell.cn/articles/8239.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">coolshell.cn/articles/8</span><span class=\"invisible\">239.html</span><span class=\"ellipsis\"></span></a></p><p><a href=\"https://zhuanlan.zhihu.com/p/43422624\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/43</span><span class=\"invisible\">422624</span><span class=\"ellipsis\"></span></a></p><p></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "C（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19561633"
                }
            ], 
            "comments": [
                {
                    "userName": "小渣渣", 
                    "userLink": "https://www.zhihu.com/people/251abdd68735f10d937036713a2273c3", 
                    "content": "请问有没有实现特别简单的redis的教程诶", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小渣渣", 
                    "userLink": "https://www.zhihu.com/people/251abdd68735f10d937036713a2273c3", 
                    "content": "我现在数据结构这一块都会写", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小渣渣", 
                    "userLink": "https://www.zhihu.com/people/251abdd68735f10d937036713a2273c3", 
                    "content": "就是网络啥的不太会呢", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>可以单独了解下C语言的网络编程，主要是理解epoll这样的异步事件驱动的编程模型</p>", 
                            "likes": 0, 
                            "replyToAuthor": "小渣渣"
                        }, 
                        {
                            "userName": "鱼坚强", 
                            "userLink": "https://www.zhihu.com/people/e70082c501aceee12e0026e4d6efe929", 
                            "content": "感觉这种redis的难点还是在数据并发控制，网络层面其实还好", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "冒泡", 
                    "userLink": "https://www.zhihu.com/people/421ae9014cf4b66993c52d390e505440", 
                    "content": "<p>vire的作者当年好像还找我讨论过一些思路</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>厉害了~</p>", 
                            "likes": 0, 
                            "replyToAuthor": "冒泡"
                        }
                    ]
                }, 
                {
                    "userName": "白馨", 
                    "userLink": "https://www.zhihu.com/people/f3c0870440cedd8a3f803b771dea0ab0", 
                    "content": "第四种方案也需要读写锁吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>确实没法完全避免，只能尽量做优化，一个hashmap本身要支持并发读写，然后对value的修改要么做到原子操作，要么就要在key这一层加锁了</p>", 
                            "likes": 0, 
                            "replyToAuthor": "白馨"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58623565", 
            "userName": "不去彼岸", 
            "userLink": "https://www.zhihu.com/people/133519f8dc6923280761214073ec2a06", 
            "upvote": 0, 
            "title": "Python语言特性的梳理", 
            "content": "<p>对python的语言特性，多线程机制，以及性能局限的梳理 </p><h2>运行环境</h2><p>由于Python不同版本，尤其是Python2与Pyhton3之间差异明显，所以运行不同项目时往往需要不同版本的运行环境，这种情况下，就需要能快速切换版本的运行环境 <br/>现在存在着virtualenv pyenv conda anaconda等虚拟环境 <br/><br/>Anaconda 一个科学计算环境，Python的发行版本 ：包括了Conda  <br/>Conda --包和虚拟环境管理工具  <br/>virtualenv 轻量级第三方虚拟环境管理工具,没有Anaconda好用  <br/>pyenv 　　python版本管理工具</p><h2>Pythonic</h2><blockquote> Pythonic就是以Python的方式写出简洁优美的代码<br/> </blockquote><h2>上下文管理器</h2><p>上下文管理器就算在想要执行的目标代码前做一些预处理工作，然后再目标代码执行后，做一些后续扫尾工作  在上下文管理协议中，有两个方法<b>enter</b>和<b>exit</b>，分别实现上述两个功能。  使用with语句，以及一个支持上下文协议的对象，就可以使用上下文管理器</p><blockquote> 装饰器contextmanager 将一个函数中yield语句之前的代码当做<b>enter</b>方法执行，yield语句之后的代码当做<b>exit</b>方法执行。同时yield返回值赋值给as后的变量。 <br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"nd\">@contextlib</span><span class=\"o\">.</span><span class=\"n\">contextmanager</span>\n<span class=\"k\">def</span> <span class=\"nf\">open_func</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">):</span>\n    <span class=\"c1\"># __enter__方法</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;open file:&#39;</span><span class=\"p\">,</span> <span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"s1\">&#39;in __enter__&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">file_handler</span> <span class=\"o\">=</span> <span class=\"nb\">open</span><span class=\"p\">(</span><span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"s1\">&#39;r&#39;</span><span class=\"p\">)</span>\n\n    <span class=\"k\">yield</span> <span class=\"n\">file_handler</span>\n\n    <span class=\"c1\"># __exit__方法</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;close file:&#39;</span><span class=\"p\">,</span> <span class=\"n\">file_name</span><span class=\"p\">,</span> <span class=\"s1\">&#39;in __exit__&#39;</span><span class=\"p\">)</span>\n    <span class=\"n\">file_handler</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n    <span class=\"k\">return</span>\n\n<span class=\"k\">with</span> <span class=\"n\">open_func</span><span class=\"p\">(</span><span class=\"s1\">&#39;python_base.py&#39;</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">file_in</span><span class=\"p\">:</span>\n    <span class=\"k\">for</span> <span class=\"n\">line</span> <span class=\"ow\">in</span> <span class=\"n\">file_in</span><span class=\"p\">:</span>\n        <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span></code></pre></div><h2>装饰器</h2><p>装饰器实际上就是给其他函数和类附加额外功能 值得注意的是使用装饰器后代码的执行顺序</p><blockquote> 装饰器的逻辑是，将被装饰的函数传入装饰器，返回一个装饰器的函数对象。在这个对象里面猜实际执行被装饰的方法<br/> </blockquote><p>下面的例子，把foo函数传入的装饰器函数中去，装饰器函数返回一个可执行的wrapper函数，wrapper函数里面再执行foo函数</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">logging</span>\n\n<span class=\"k\">def</span> <span class=\"nf\">use_logging</span><span class=\"p\">(</span><span class=\"n\">func</span><span class=\"p\">):</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">wrapper</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">):</span>\n        <span class=\"n\">logging</span><span class=\"o\">.</span><span class=\"n\">warn</span><span class=\"p\">(</span><span class=\"s2\">&#34;</span><span class=\"si\">%s</span><span class=\"s2\"> is running&#34;</span> <span class=\"o\">%</span> <span class=\"n\">func</span><span class=\"o\">.</span><span class=\"vm\">__name__</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">func</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">args</span><span class=\"p\">,</span> <span class=\"o\">**</span><span class=\"n\">kwargs</span><span class=\"p\">)</span>   <span class=\"c1\"># 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span>\n    <span class=\"k\">return</span> <span class=\"n\">wrapper</span>\n\n<span class=\"nd\">@use_logging</span>    <span class=\"c1\"># 装饰器的逻辑是，把foo函数传入的装饰器函数中去，装饰器函数返回一个可执行的wrapper函数，wrapper函数里面再执行foo函数</span>\n<span class=\"k\">def</span> <span class=\"nf\">foo</span><span class=\"p\">():</span>\n    <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"s2\">&#34;i am foo&#34;</span><span class=\"p\">)</span>\n\n\n<span class=\"n\">foo</span><span class=\"p\">()</span></code></pre></div><h2>生成器</h2><p>生成器与列表推导有点类似，区别在于，列表推导一开始就执行完计算，返回的就是一个列表，而生成器返回的是一个生成器对象，里面保存的是生产数据的算法，可以步进的执行里面的逻辑</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)]</span>   <span class=\"c1\"># 列表</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">L</span>\n<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"mi\">25</span><span class=\"p\">,</span> <span class=\"mi\">36</span><span class=\"p\">,</span> <span class=\"mi\">49</span><span class=\"p\">,</span> <span class=\"mi\">64</span><span class=\"p\">,</span> <span class=\"mi\">81</span><span class=\"p\">]</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>  <span class=\"c1\"># 生成器对象</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span>\n<span class=\"o\">&lt;</span><span class=\"n\">generator</span> <span class=\"nb\">object</span> <span class=\"o\">&lt;</span><span class=\"n\">genexpr</span><span class=\"o\">&gt;</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fbea411e9a8</span><span class=\"o\">&gt;</span></code></pre></div><p>可以用next(g)来获得生成器的下一次结果，但一般使用迭代,generator也是可迭代对象</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">g</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">))</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">for</span> <span class=\"n\">n</span> <span class=\"ow\">in</span> <span class=\"n\">g</span><span class=\"p\">:</span>\n<span class=\"o\">...</span>     <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">)</span>\n<span class=\"o\">...</span> \n<span class=\"mi\">0</span>\n<span class=\"mi\">1</span>\n<span class=\"mi\">4</span>\n<span class=\"o\">...</span></code></pre></div><p>可以使用yield将函数变成生成器</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">def</span> <span class=\"nf\">fib</span><span class=\"p\">(</span><span class=\"nb\">max</span><span class=\"p\">):</span>\n    <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span>\n    <span class=\"k\">while</span> <span class=\"n\">n</span> <span class=\"o\">&lt;</span> <span class=\"nb\">max</span><span class=\"p\">:</span>\n        <span class=\"k\">yield</span> <span class=\"n\">b</span>\n        <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">b</span><span class=\"p\">,</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"n\">b</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span>\n    <span class=\"k\">return</span> <span class=\"s1\">&#39;done&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">fib</span><span class=\"p\">(</span><span class=\"mi\">6</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">f</span>\n<span class=\"o\">&lt;</span><span class=\"n\">generator</span> <span class=\"nb\">object</span> <span class=\"n\">fib</span> <span class=\"n\">at</span> <span class=\"mh\">0x7fbea411ea20</span><span class=\"o\">&gt;</span></code></pre></div><h2>描述符</h2><blockquote> 使用描述符的类中，多次实例化描述，不同变量保存的描述符是独立的，但是类被多次实例化的话，不同实例的同名描述符变量之间是共享实例的 下面的例子说明，对描述符变量的读写都会被转接到对象内部的<b>get</b>与<b>set</b>方法<br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">from</span> <span class=\"nn\">weakref</span> <span class=\"k\">import</span> <span class=\"n\">WeakKeyDictionary</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">NonNegative</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">default</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">default</span> <span class=\"o\">=</span> <span class=\"n\">default</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">WeakKeyDictionary</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">default</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__get__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">owner</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">default</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__set__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">instance</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"n\">value</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n            <span class=\"k\">raise</span> <span class=\"ne\">ValueError</span><span class=\"p\">(</span><span class=\"s2\">&#34;Negative value not allowed: </span><span class=\"si\">%s</span><span class=\"s2\">&#34;</span> <span class=\"o\">%</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">data</span><span class=\"p\">[</span><span class=\"n\">instance</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">value</span>\n\n\n<span class=\"k\">class</span> <span class=\"nc\">Movie</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"n\">View</span> <span class=\"o\">=</span> <span class=\"n\">NonNegative</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">View</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">View</span> <span class=\"o\">=</span> <span class=\"n\">View</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">profit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">View</span> <span class=\"o\">+</span><span class=\"mi\">1</span>\n\n<span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">Movie</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># </span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">View</span><span class=\"p\">)</span>  <span class=\"c1\"># calls Movie.View.__get__(m, Movie)</span>\n<span class=\"n\">m</span><span class=\"o\">.</span><span class=\"n\">View</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>  <span class=\"c1\"># calls Movie.View.__set__(m, 100)</span></code></pre></div><h2>元类</h2><p>python中类不但可以创建对象，而且本身就是一个对象 (python这种类的实现方式，感觉有点想javascirpt)</p><ul><li>可以像操作普通对象一样操作类对象</li></ul><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">class</span> <span class=\"nc\">ObjectCreator</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"o\">...</span>     <span class=\"k\">pass</span>\n<span class=\"o\">...</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">ObjectCreator</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span> <span class=\"err\">&#39;</span><span class=\"nc\">__main__</span><span class=\"o\">.</span><span class=\"n\">ObjectCreator</span><span class=\"s1\">&#39;&gt;</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; ObjectCreator.new_attribute = &#39;</span><span class=\"n\">foo</span><span class=\"s1\">&#39;  # 添加属性</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; print(ObjectCreator.new_attribute)</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">foo</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; ObjectCreatorMirror = ObjectCreator  # 赋值给其他变量</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; print(ObjectCreatorMirror)</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&lt;class &#39;</span><span class=\"n\">__main__</span><span class=\"o\">.</span><span class=\"n\">ObjectCreator</span><span class=\"s1\">&#39;&gt;</span></code></pre></div><ul><li>动态地创建类 type有一种完全不同的能力，它也能动态的创建类。type可以接受一个类的描述作为参数，然后返回一个类<br/> <br/> </li></ul><div class=\"highlight\"><pre><code class=\"language-text\"># 使用方式\ntype(类名, 父类的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</code></pre></div><p>例如这样的类定义</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"k\">class</span> <span class=\"nc\">MyShinyClass</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n<span class=\"err\">…</span>       <span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></code></pre></div><p>可以用type来实现,type 接受一个字典来为类定义属性</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">MyShinyClass</span> <span class=\"o\">=</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"s1\">&#39;MyShinyClass&#39;</span><span class=\"p\">,</span> <span class=\"p\">(),</span> <span class=\"p\">{</span><span class=\"s1\">&#39;bar&#39;</span><span class=\"p\">:</span><span class=\"kc\">True</span><span class=\"p\">})</span>  <span class=\"c1\"># 返回一个类对象</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"nb\">print</span> <span class=\"n\">MyShinyClass</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span> <span class=\"err\">&#39;</span><span class=\"nc\">__main__</span><span class=\"o\">.</span><span class=\"n\">MyShinyClass</span><span class=\"s1\">&#39;&gt;</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; print MyShinyClass()  #  创建一个该类的实例</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&lt;__main__.MyShinyClass object at 0x8997cec&gt;</span></code></pre></div><blockquote> 元类可以理解为创建类的类,主要目的是为了当创建类时能够自动地改变类。 <br/> </blockquote><p>Python中所有的东西都是对象。包括整数、字符串、函数以及类。而且它们都是从元类type衍生而来</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">language</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Python&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">language</span><span class=\"o\">.</span><span class=\"vm\">__class__</span>\n<span class=\"o\">&lt;</span><span class=\"k\">class</span> <span class=\"err\">&#39;</span><span class=\"nc\">str</span><span class=\"s1\">&#39;&gt;</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&gt;&gt;&gt; language.__class__.__class__</span><span class=\"err\">\n</span><span class=\"err\"></span><span class=\"s1\">&lt;class &#39;</span><span class=\"nb\">type</span><span class=\"s1\">&#39;&gt;</span></code></pre></div><ul><li>元类的实际应用 <b>metaclass</b>属性 <b>metaclass</b>属性 可以指定使用什么元类来创建当前类对象，它可以设置在类中，也可以在设置在模块这一层级上</li></ul><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"k\">class</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"n\">__metaclass__</span> <span class=\"o\">=</span> <span class=\"n\">something</span><span class=\"err\">…</span></code></pre></div><ul><li>自定义元类</li></ul><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"c1\"># 元类会自动将你通常传给‘type’的参数作为自己的参数传入</span>\n<span class=\"k\">def</span> <span class=\"nf\">upper_attr</span><span class=\"p\">(</span><span class=\"n\">future_class_name</span><span class=\"p\">,</span> <span class=\"n\">future_class_parents</span><span class=\"p\">,</span> <span class=\"n\">future_class_attr</span><span class=\"p\">):</span>\n    <span class=\"s1\">&#39;&#39;&#39;返回一个类对象，将属性都转为大写形式&#39;&#39;&#39;</span>\n    <span class=\"c1\">#  选择所有不以&#39;__&#39;开头的属性</span>\n    <span class=\"n\">attrs</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">future_class_attr</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">()</span> <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">name</span><span class=\"o\">.</span><span class=\"n\">startswith</span><span class=\"p\">(</span><span class=\"s1\">&#39;__&#39;</span><span class=\"p\">))</span>\n\n    <span class=\"c1\"># 将它们转为大写形式</span>\n    <span class=\"n\">uppercase_attr</span> <span class=\"o\">=</span> <span class=\"nb\">dict</span><span class=\"p\">((</span><span class=\"n\">name</span><span class=\"o\">.</span><span class=\"n\">upper</span><span class=\"p\">(),</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"k\">for</span> <span class=\"n\">name</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> <span class=\"n\">attrs</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># 通过&#39;type&#39;来做类对象的创建</span>\n    <span class=\"k\">return</span> <span class=\"nb\">type</span><span class=\"p\">(</span><span class=\"n\">future_class_name</span><span class=\"p\">,</span> <span class=\"n\">future_class_parents</span><span class=\"p\">,</span> <span class=\"n\">uppercase_attr</span><span class=\"p\">)</span>\n\n<span class=\"n\">__metaclass__</span> <span class=\"o\">=</span> <span class=\"n\">upper_attr</span>  <span class=\"c1\">#  这会作用到这个模块中的所有类</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Foo</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"c1\"># 我们也可以只在这里定义__metaclass__，这样就只会作用于这个类中</span>\n    <span class=\"n\">bar</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;bip&#39;</span>\n\n<span class=\"nb\">print</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">,</span> <span class=\"s1\">&#39;bar&#39;</span><span class=\"p\">)</span>\n<span class=\"c1\"># 输出: False</span>\n<span class=\"nb\">print</span> <span class=\"nb\">hasattr</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"p\">,</span> <span class=\"s1\">&#39;BAR&#39;</span><span class=\"p\">)</span>\n<span class=\"c1\"># 输出:True</span>\n\n<span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Foo</span><span class=\"p\">()</span>\n<span class=\"nb\">print</span> <span class=\"n\">f</span><span class=\"o\">.</span><span class=\"n\">BAR</span>\n<span class=\"c1\"># 输出:&#39;bip&#39;</span></code></pre></div><h2>其他</h2><ul><li>python的特殊语法：变量交换</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">a, b = b, a   # 快速交换变量值</code></pre></div><ul><li>列表推导  这个其实类似于生成器了，只是会直接进行计算，返回计算结果</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">[ i*i for i in range(30, 41) if i% 2 == 0 ]</code></pre></div><h2>代码组织与包管理机制</h2><p>Python工程目录结构</p><blockquote> <a href=\"https://zhuanlan.zhihu.com/p/36221226\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/36</span><span class=\"invisible\">221226</span><span class=\"ellipsis\"></span></a> 模块与包的引入与管理<br/> </blockquote><ul><li>python 引入模块要注意避免循环引用</li><li>包 ：只要一个文件夹下面有个 <b>init</b>.py 文件，那么这个文件夹就可以看做是一个包</li><li>python使用pip进行包管理，包下载后，当前版本的执行环境下都可以进行引用，这区别与php comporsor 将包引入项目内部</li></ul><blockquote> TODO 与go,php composor的包管理机制的对比<br/> </blockquote><h2>数据结构</h2><p>python中的元组 tuple，可以认为是一种特殊的列表，只是一经创建，内容不可修改</p><div class=\"highlight\"><pre><code class=\"language-text\">tup1 = (&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000)</code></pre></div><p>不过对于tuple中的引用类型数据(借用静态语言的概念)，在不修改引用本身的情况下，是可以对这个引用内部的数据进行修改的 tuple中相当于保存的是指针，无需改变指针，就可以对指向的数据进行修改</p><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">t</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;A&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;B&#39;</span><span class=\"p\">])</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">t</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;X&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">t</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;Y&#39;</span>\n<span class=\"o\">&gt;&gt;&gt;</span> <span class=\"n\">t</span>\n<span class=\"p\">(</span><span class=\"s1\">&#39;a&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;b&#39;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"s1\">&#39;X&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Y&#39;</span><span class=\"p\">])</span></code></pre></div><h2>多线程编程</h2><p>python的多线程编程会用到一些内置特性来进行线程间通信，与并发安全控制(虽然默认的CPython不会真正的并行，但是在多个线程间切换执行，仍绕会面临并发安全问题) <i> 线程间通信      event与queue，锁 </i> 线程安全 -锁机制 </p><ul><li> 子线程启动后，   </li><li>  有join,主线程阻塞在join的位置     </li><li> 没有join,主线程与子线程并发执行，主线程执行完所有逻辑后，子线程仍然能继续执行(主线程执行完退出) 下面的例子，在多个线程操作同一变量时使用锁来保证线程安全</li></ul><div class=\"highlight\"><pre><code class=\"language-python3\"><span class=\"kn\">import</span> <span class=\"nn\">time</span><span class=\"o\">,</span> <span class=\"nn\">threading</span>\n<span class=\"kn\">from</span> <span class=\"nn\">threading</span> <span class=\"k\">import</span> <span class=\"n\">Thread</span>\n\n<span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n<span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"n\">threading</span><span class=\"o\">.</span><span class=\"n\">Lock</span><span class=\"p\">()</span> <span class=\"c1\">#使用锁来协调线程的并发执行</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">tWork</span><span class=\"p\">(</span><span class=\"n\">Thread</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"n\">step</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">):</span>\n        <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span> <span class=\"o\">=</span> <span class=\"n\">step</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">global</span> <span class=\"n\">num</span>\n        <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">):</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">acquire</span><span class=\"p\">()</span> <span class=\"c1\"># 先要获取锁:</span>\n\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;+&#39;</span><span class=\"o\">+</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">))</span>\n            <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"o\">+</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span>\n            <span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"n\">num</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"s1\">&#39;-&#39;</span> <span class=\"o\">+</span> <span class=\"nb\">str</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span><span class=\"p\">))</span>\n            <span class=\"n\">num</span> <span class=\"o\">=</span> <span class=\"n\">num</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">step</span>\n\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"n\">release</span><span class=\"p\">()</span>\n\n<span class=\"n\">threadSer</span> <span class=\"o\">=</span> <span class=\"n\">tWork</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span>\n<span class=\"n\">threadSer2</span> <span class=\"o\">=</span> <span class=\"n\">tWork</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">)</span>\n\n<span class=\"n\">threadSer</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span>\n<span class=\"n\">threadSer2</span><span class=\"o\">.</span><span class=\"n\">start</span><span class=\"p\">()</span></code></pre></div><h2>解释器,多线程GIL 与性能优化</h2><p>python的性能一直挺受诟病，一个是默认的cpyton解释器的执行效率确实不高，另外一个就是鼎鼎大名的GIL全局锁导致python的多线程直接是互斥执行的，同一时间只会有一个线程在执行</p><ul><li>解释器慢的问题，有 Pypy, Jython等第三方解释器 其中pypy的性能优化做的挺不错，使用了JIT，我的实测对比，pypy的速度大致是cpython的5倍，另外由于使用了JIT,对一个变量不停的追加内容，会导致明显的性能下降 Jython则是在jvm中执行python，看到一些测评，性能并不如意</li><li>CPython 使用带condition的互斥锁来实现GIL，并且在线程执行碰到阻塞时，会释放锁，交给其他线程继续支持</li><li>针对CPython解释器GIL的问题  Jython与IronPython中实现了真正的多线程并发，PyPy也有独立的分支版本PyPy-stm来支持多线程 从单核性能来看，首选pypy来执行，考虑多线程的时候，可以使用PyPy-stm<br/> <br/> </li></ul><blockquote> 更多实例代码可以我的github项目 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/wosiwo/pythonic\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wosiwo/pythonic</a> <br/> </blockquote><h2>参考</h2><p><a href=\"https://www.zhihu.com/question/21408921\" class=\"internal\">怎样才能写出 Pythonic 的代码？</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24709718\" class=\"internal\">笑虎：Python进阶：With语句和上下文管理器ContextManager</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//python.jobbole.com/81899/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">解密 Python 的描述符（descriptor） - Python - 伯乐在线</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/21351/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">深刻理解Python中的元类(metaclass) - 文章 - 伯乐在线</a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.newsmth.net/nForum/%23%21article/Programming/118874\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">水木社区-源于清华的高知社群</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//cyrusin.github.io/2016/04/27/python-gil-implementaion/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GIL的实现细节</a></p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Pythonic", 
                    "tagLink": "https://api.zhihu.com/topics/19727016"
                }, 
                {
                    "tag": "python多线程", 
                    "tagLink": "https://api.zhihu.com/topics/20215014"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58165332", 
            "userName": "不去彼岸", 
            "userLink": "https://www.zhihu.com/people/133519f8dc6923280761214073ec2a06", 
            "upvote": 10, 
            "title": "对PHP变量的实现方式以及内存管理的梳理", 
            "content": "<blockquote> 对PHP变量的实现方式以及内存管理的梳理 <br/> </blockquote><h2>变量</h2><ul><li> 局部变量     PHP中局部变量分配在zend_execute_data结构上，每次执行zend_op_array都会生成一个新的zend_execute_data     局部变量通过编译时确定的编号进行读写操作<br/> </li></ul><p> 静态变量     静态变量只会在编译时初始化，保存在zend_op_array-&gt;static_variables 这个哈希表中     静态变量通过哈希表保存，这就使得能像普通变量那样有一个固定的编号     编译时先判断zend_op_array-&gt;static_variables 是否已创建，然后将静态变量插入哈希表     <br/></p><div class=\"highlight\"><pre><code class=\"language-c\">    <span class=\"c1\">//zend_compile_static_var_common():\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">CG</span><span class=\"p\">(</span><span class=\"n\">active_op_array</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">static_variables</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ALLOC_HASHTABLE</span><span class=\"p\">(</span><span class=\"n\">CG</span><span class=\"p\">(</span><span class=\"n\">active_op_array</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">static_variables</span><span class=\"p\">);</span>\n    <span class=\"n\">zend_hash_init</span><span class=\"p\">(</span><span class=\"n\">CG</span><span class=\"p\">(</span><span class=\"n\">active_op_array</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">static_variables</span><span class=\"p\">,</span> <span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"n\">ZVAL_P</span>\n    <span class=\"n\">TR_DTOR</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">//插入静态变量\n</span><span class=\"c1\"></span>    <span class=\"n\">zend_hash_update</span><span class=\"p\">(</span><span class=\"n\">CG</span><span class=\"p\">(</span><span class=\"n\">active_op_array</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">static_variables</span><span class=\"p\">,</span> <span class=\"n\">Z_STR</span><span class=\"p\">(</span><span class=\"n\">var_node</span><span class=\"p\">.</span><span class=\"n\">u</span><span class=\"p\">.</span>\n    <span class=\"n\">constant</span><span class=\"p\">),</span> <span class=\"n\">value</span><span class=\"p\">);</span></code></pre></div><p><br/><br/>例如$count与         static_variables[&#34;count&#34;]间的关系如图所示         </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;496&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_b.jpg\"/></figure><p><br/> </p><ul><li> 全局变量 PHP中在函数、类之外直接定义的变量可以在函数、类成员方法中通过global关键词引入使 用，这些变量称为：全局变量<br/> </li></ul><p>全局变量在整个请求执行期间始终存在，它们保存在 EG(symbol_table) 中，也就是全局 变量符号表，与静态变量的存储一样，这也是一个哈希表，主脚本(或include、require)在 zend_execute_ex 执行开始之前会把当前作用域下的所有局部变量添加到 EG(symbol_table) 中</p><p>与静态变量的访问一样，全局变量也是将原来的值转换为引用，然后在global导入的作用域 内创建一个局部变量指向该引用</p><ul><li>超全局变量   超全局变量实际是PHP内核定义的一些全局变量：$GLOBALS、$_SERVER、$_REQUEST、 $_POST、$_GET、$_FILES、$_ENV、$_COOKIE、$_SESSION、argv、argc</li><li>常量  在内核中常量存储在 EG(zend_constant) 哈希表  常量的数据结构<br/></li></ul><div class=\"highlight\"><pre><code class=\"language-c\"> <span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">_zend_constant</span> <span class=\"p\">{</span>\n            <span class=\"n\">zval</span> <span class=\"n\">value</span><span class=\"p\">;</span> <span class=\"c1\">//常量值\n</span><span class=\"c1\"></span>            <span class=\"n\">zend_string</span> <span class=\"o\">*</span><span class=\"n\">name</span><span class=\"p\">;</span> <span class=\"c1\">//常量名\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">flags</span><span class=\"p\">;</span> <span class=\"c1\">//常量标识位\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">module_number</span><span class=\"p\">;</span> <span class=\"c1\">//所属扩展、模块\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span> <span class=\"n\">zend_constant</span><span class=\"p\">;</span></code></pre></div><ul><li><br/>这里主要介绍下flags，它的值可以是以下三个中任意组合：</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#define CONST_CS (1&lt;&lt;0) </span><span class=\"c1\">//大小写敏感\n</span><span class=\"c1\"></span><span class=\"cp\">#define CONST_PERSISTENT (1&lt;&lt;1) </span><span class=\"c1\">//持久化的\n</span><span class=\"c1\"></span><span class=\"cp\">#define CONST_CT_SUBST (1&lt;&lt;2)</span></code></pre></div><p>介绍下三种flag代表的含义：    </p><ul><ul><li><b>CONST_CS:</b> 大小写敏感，默认是开启的，用户通过define()定义的始终是区分大小 写的，通过扩展定义的可以自由选择    </li><li><b>CONST_PERSISTENT:</b> 持久化的，只有通过扩展、内核定义的才支持，这种常量不 会在request结束时清理掉     </li><li>CONST_CT_SUBST: 允许编译时替换，编译时如果发现有地方在读取常量的值，那么编 译器会尝试直接替换为常量值，而不是在执行时再去读取，目前这个flag只有TRUE、 FALSE、NULL三个常量在使用</li></ul></ul><p>这里需要特别注意的一个是,__CONST_PERSISTENT这个持久化状态，持久化常量是在 php_module_shutdown() 阶段销毁的</p><ul><li> 资源型变量 在实际使用PHP中，开启对mysql，redis的长连接是很常见的优化措施， 之前也思考过每次请求结束都会进行gc销毁变量的php-fpm是如何维持跨请求的长连接的， 这里就要另外介绍php内核对资源型数据的存储<br/> </li><ul><li>非持久化的资源型变量保存在EG(regular_list) </li><li>持久化的资源型变量保存在EG(persistent_list)中</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li> php数组的实现<br/> </li></ul><p>普通的hashtable是无序的，而php实现的数组功能却是有序的(插入php数组的顺序)，这是因为php内核在实现数组功能时，根据key计算的哈希值索引定位到的是一个中间散列表，而不是直接定位到数组元素组成的数组中</p><p>向数组添加元素的时候，会先顺序的吧新元素加入到数组中，而根据key进行寻址查找元素时，则是先定位到中间散列表的某个下标值，而这个值就是元素在数组中的下标</p><h2>内存管理</h2><p>zend 对内存的操作做了一层封装，提供的emalloc、efree、estrdup的操作就是在zend的内存池上，而不是直接操作内存</p><ul><li>内存池是内核中最底层的内存操作，定义了三种粒度的内存块：chunk、page、slot，每个 chunk的大小为2M，page大小为4KB，一个chunk被切割为512个page，而一个或若干个 page被切割为多个slot，所以申请内存时按照不同的申请大小决定具体的分配策略：</li><li>内存池在php_module_startup阶段初始化，start_memory_manager</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">ZEND_API</span> <span class=\"kt\">void</span> <span class=\"nf\">start_memory_manager</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"cp\">#ifdef ZTS\n</span><span class=\"cp\"></span><span class=\"n\">ts_allocate_id</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">alloc_globals_id</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">zend_alloc_globals</span><span class=\"p\">),</span> <span class=\"p\">(</span><span class=\"n\">ts_all</span>\n<span class=\"n\">ocate_ctor</span><span class=\"p\">)</span> <span class=\"n\">alloc_globals_ctor</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"n\">ts_allocate_dtor</span><span class=\"p\">)</span> <span class=\"n\">alloc_globals_dtor</span><span class=\"p\">);</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span><span class=\"n\">alloc_globals_ctor</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">alloc_globals</span><span class=\"p\">);</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span><span class=\"p\">}</span>\n<span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">alloc_globals_ctor</span><span class=\"p\">(</span><span class=\"n\">zend_alloc_globals</span> <span class=\"o\">*</span><span class=\"n\">alloc_globals</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"cp\">#ifdef MAP_HUGETLB\n</span><span class=\"cp\"></span><span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">getenv</span><span class=\"p\">(</span><span class=\"s\">&#34;USE_ZEND_ALLOC_HUGE_PAGES&#34;</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tmp</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">zend_atoi</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n<span class=\"n\">zend_mm_use_huge_pages</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"cp\">#endif\n</span><span class=\"cp\"></span><span class=\"n\">ZEND_TSRMLS_CACHE_UPDATE</span><span class=\"p\">();</span>\n<span class=\"n\">alloc_globals</span><span class=\"o\">-&gt;</span><span class=\"n\">mm_heap</span> <span class=\"o\">=</span> <span class=\"n\">zend_mm_init</span><span class=\"p\">();</span>\n<span class=\"p\">}</span></code></pre></div><p><b>alloc_globals 是一个全局变量，即 AG宏</b> ，它只有一个成员:mm_heap，保存着整个内 存池的信息，所有内存的分配都是基于这个值，多线程模式下(ZTS)会有多个heap，也就是 说每个线程都有一个独立的内存池，(php多线程的线程安全实现，就是简单粗暴的复制出独立内存池)</p><ul><li> 内存的分配  </li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;496&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f0d4c67f2ec0ac4be4d095fcf8000015_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li> 垃圾回收   一个是引用计数这个早期就有的基本机制，refcount减到0时，释放变量   这里同时也介绍下一个比较通用的写时复制机制，   </li></ul><div class=\"highlight\"><pre><code class=\"language-php\"> $a = 1;     \n $b = $a;     // 这里变量$a 与变量$b 持有的是同一个zend_val    \n $a = 2;     // 这个时候变量$a的值发生了改变，而显然，让$b的值也发生同样的改变是不符合预期的  所以这个时候就会发生zend_val的复制\n //另外一种情况 \n $a = 1; \n $b = <span class=\"ni\">&amp;$a;</span> //当$b只有的是对$a的引用时，这两个变量始终共用同一个zend_val \n $a = 2; //这时$b的值也为2   \n </code></pre></div><ul><ul><li>循环引用  <br/>引用计数机制有一个缺陷，就是碰到循环引用时，refcount无法减到0，导致变量无法释放，具体来说就是变量内部的成员引用了变量本身，比如数组中的某个元素指向了数组     </li></ul></ul><div class=\"highlight\"><pre><code class=\"language-php\"> $a = [1];     \n $a[] = <span class=\"ni\">&amp;$a;</span>    \n unset($a);     </code></pre></div><p>      针对这种情况，php引入了垃圾回收器来处理     变量是否加入垃圾检查buffer并不是根据zval的类型判断的，而是与前面介绍的是否用到引用计数一样通过 zval.u1.type_flag 记录的，只有包含 IS_TYPE_COLLECTABLE 的变量才会被GC收集</p><blockquote>目前垃圾只会出现在array、object两种类型中,只有这两种类型的变量会出现成员引用自身的情况<br/>如果当变量的refcount减少后大于0，PHP并不会立即进行对这个变量进行垃圾鉴定，而是放入一个缓冲buffer中，等这个buffer满了以后(10000个值)再统一进行处理，加入buffer的是 变量zend_value的 zend_refcounted_h<br/><br/>一个变量只能加入一次buffer，为了防止重复加入，变量加入后会把<br/>zend_refcounted_h.gc_info 置为 GC_PURPLE ，即标为紫色，下次refcount减少时<br/>如果发现已经加入过了则不再重复插入。</blockquote><p><br/>    垃圾缓存区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓存区，再对当前变量的所有成员进行遍历，然后把成员的refcount减1(如果成员还包含子成员则也进行递归遍历，其实就是深度优先的遍历)<br/>    最后再检查当前变量的引用，如果减为了0则为垃圾<br/>    这个算法的原理很简单，垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，结果如果发现变量本身refcount变为了0则就表明其引用全部来自自身成员。</p><h2>PHP对象在内存堆栈中的分配</h2><p>对象在PHP里面和整型、浮点型一样，也是一种数据类，都是存储不同类型数据用的， 在运行的时候都要加载到内存中去用，那么对象在内存里面是怎么体现的呢？内存从逻辑上说大体上是分为4段，栈空间段、堆空间段、代码段、初始化静态段，程序里面不同的声明放在不同的内存段里面。</p><p>数据段（data segment）通常是指用来存放程序中已初始化且不为0的全局变量如：静态变量和常量</p><p>代码段（code segment / text segment）通常是指用来存放程序执行代码的一块内存区域，比如函数和方法</p><p>栈空间段是存储占用相同空间长度并且占用空间小的数据类型的地方，比如说整型1，10，100，1000，10000，100000 等等，在内存里面占用空间是等长的，都是64 位4 个字节。</p><p>（heap）数据长度不定长，而且占有空间很大的数据类型的数据放在堆内存里面的。</p><p>栈内存是可以直接存取的，而堆内存是 不可以直接存取的内存。对于我们的对象来数就是一种大的数据类型而且是占用空间不定长的类型，所以说对象是放在堆里面的，但对象名称是放在栈里面的，这样通过对象名称就可 以使用对象了。</p><ul><li>PHP脚本运行的时候,那些变量被放到了栈内存,那些被保存到了堆内存?</li></ul><p>在PHP5的Zend Engine的实现中,所有的值都是在堆上分配空间,并且通过引用计数和垃圾收集来管理. PHP5的Zend Engine主要使用指向zval结构的指针来操作值,在很多地方甚至通过zval的二级指针来操作.</p><p>而在PHP7的Zend Engine实现中,值是通过zval结构本身来操作(非指针). 新的zval结构直接被存放在VM[虚拟机?]的栈上,HashTable的桶里,以及属性槽里. 这样大大减少了在堆上分配和释放内存的操作,还避免了对简单值的引用计数和垃圾收集.</p><p>引用： </p><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/web21/p/6197980.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PHP对象在内存堆栈中的分配 - web21 - 博客园</a></p><p>《PHP7内核剖析》</p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "PHP扩展", 
                    "tagLink": "https://api.zhihu.com/topics/19679214"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56937715", 
            "userName": "不去彼岸", 
            "userLink": "https://www.zhihu.com/people/133519f8dc6923280761214073ec2a06", 
            "upvote": 2, 
            "title": "对redis cluster的实现原理的理解，以及与codis,corvus的对比", 
            "content": "<blockquote>Redis Cluster是一个分布式系统。由多个Redis实例组成的整体，数据按照Slot存储分布在多个Redis实例上，通过Gossip协议来进行节点之间通信。<br/></blockquote><h2>整理理解</h2><ul><li>redis cluster整体上还是一个哈希分布的方案，与twemproxy，codis没有本质区别，不同的地方在于，客户请求不在通过代理节点转发，而是直接与对应槽位的节点处理</li><li>通过gossip来使得集群中的节点互相了解其他节点的状况，(节点的存活情况，所持有的槽位情况等)</li></ul><h2>哈希方案：slot(槽位)</h2><p>Redis Cluster中有一个16384长度的槽的概念，每个key都会通过公式CRC16(key)% 16384来计算键key属于哪个槽，槽位是虚拟的，可以在不同节点之前迁移</p><p>客户端对key做哈希，得到槽位，并到本地路由缓存查找槽位对应的服务器节点，其中会有一些特殊情况要处理</p><ul><li>访问到了错误的节点，该节点会返回正确的节点地址，让客户端重新访问</li><li>访问到正在迁移的节点，分好几种情况</li><ul><li>访问的key还存储在旧的节点，直接操作</li><li>访问的key已经迁移到新的节点了，但是整个槽位还没有完成迁移，返回一个一次性的ask 指令，让客户端尝试去新的节点查找这个key，但是不更新这个槽位在本地的路由缓存</li><li>访问的key已经迁移，且整个槽位已经完成迁移，返回move指令，告诉客户端以后这个槽位都访问指定的新节点，客户端收到指令后会更新本地的路由缓存</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>集群通信</h2><p>cluster服务端节点直接使用gossip协议进行节点间通信(redis cluster这种单纯的哈希分布的方案下，好像除了交换节点存活情况和槽位信息，服务端节点之间的数据交互需求并不高，感觉不如谷歌大数据老三篇论文里面的弱master节点的设计，能节省很多不必要的节点通信)</p><ul><li>主要使用 cluster meet ,ping ,pong 三个命令来完成</li><li>通信由meet或ping命令发起</li><li>meet命令主要用于节点间的初次通信(?待确认)</li><li>节点间的握手，类似于tcp的三次握手，都会确保对方知道自己已经收到消息</li><li>定时任务clusterCron会向随机节点发其ping 通信（标记下线，疑似下线，即获知其他节点的存活情况）</li><li>在定时心跳通信时，会附带上随机两个节点的信息，包括ip,端口，以及节点所包含的槽位信息</li><ul><li>收到心跳信息的节点，会判断附加的节点信息是否在本地记录中，</li><ul><li>本地无记录，会发其meet通信(握手)</li><li>本地有记录，会进行更新(判断epoch)</li></ul></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>数据结构</li><ul><li>使用bitmap来表示一个节点持有的槽位信息</li><li>集群消息处理函数 clusterProcessPacket</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>slot槽位的迁移</h2><ul><li>A节点的一个slot需要迁移到B节点，节点A 设置migrating flag, B 设置importing flag</li><li>将该slot的key逐步迁移到节点B中</li><li>迁移完毕使用cluster setslot node来消除importing和migrating flag</li><li>这个时候节点B会bump epoch，更新专辑的epoch编号，来提高优先级，使得节点的槽位信息传播出去后能覆盖旧的版本</li><li>节点槽位信息的更新：slot从A节点迁移到B节点后，信息同步到其他节点C，C节点会比较本地缓存的A节点的epoch与同步过来的B节点的epoch，B的epoch大，才对这个slot的信息进行更新</li></ul><h2>几种方案的对比</h2><ul><li>twemproxy 应该是最早开源的集群方案了，不过功能太过简单了，尽管使用了一致性哈希，但是集群中节点有增加时，还是会产生部分数据的丢失，而且不支持数据分片迁移，另外是单线程了，不过单线程的问题有唯品会twemproxies分支解决了</li><li>codis 的功能相对比较完整，支持新增节点，支持数据迁移，使用go语言开发，而go的协程非常适合这种并发请求的场景，也能轻松实现对多核CPU的利用，不过codis感觉最大的问题还是所有请求都需要结果代理转发，另外就是这个项目现在官方团队已经不再维护了(搞TiDB去了~)</li><li>redis cluster 这个redis官方的集群方案，优势和缺点也都很明显，与codis的预哈希方案类似，key哈希到某个slot(槽位)而不再是具体的节点，使得集群可以比较平滑的伸缩，另外一个优势就是客户端与node节点直连，省去了代理的开销，不过cluster的问题也同样明显，使用gossip这种无中心p2p的协议，导致所有节点都要频繁的与其他节点交换信息，另外一个问题就是使用redis cluster需要升级客户端，这对很多存量业务是很大的成本</li><li>corvus是饿了么开发的，加载redis cluster前面的一个客户端代理，主要作用是在不侵入代码的情况下使用redis cluster，业务代理里面对redis的使用与原来单点的实例没有区别</li><li>另外还有SSDB/ledisdb/redisdb/tidis 等实现redis协议的第三方实现</li></ul><h2>总结</h2><ul><li>在对redis的各种集群化方案比较思考之后，感觉加入一个弱的中心节点可能会是一个可以考虑的优化方向，redis cluster的p2p方式确实增加了通信成本，而且难以获知集群的当前状态，运维上也是一个问题，后续找时间需要研究下能否在codis方案下做一些调整(避免使用代理转发，保证主节点高可用，主节点失效时，通过选举产生新的主节点等)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>参考: </p><p><a href=\"https://link.zhihu.com/?target=https%3A//studygolang.com/articles/3126\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Codis 的设计与实现 Part 1</a></p><p><a href=\"https://link.zhihu.com/?target=https%3A//xiking.win/2018/07/17/tidis-distributed-transactional-redis-protocol-disk-storage/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tidis - 基于tikv实现兼容redis协议分布式事务存储</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/25060071\" class=\"internal\">黄光星：Redis Cluster 原理与管理</a></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "Redis Cluster", 
                    "tagLink": "https://api.zhihu.com/topics/20173110"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53704513", 
            "userName": "不去彼岸", 
            "userLink": "https://www.zhihu.com/people/133519f8dc6923280761214073ec2a06", 
            "upvote": 1, 
            "title": "redis,gedis性能瓶颈探索", 
            "content": "<blockquote>最近对自己写的nosql数据<a href=\"https://link.zhihu.com/?target=https%3A//github.com/wosiwo/gedis\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gedis</a>和redis做了性能对比压测，碰到一些问题，做了一些思考和尝试，这里做个记录<br/><br/><a href=\"https://link.zhihu.com/?target=https%3A//github.com/wosiwo/gedis\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/wosiwo/gedis</span><span class=\"invisible\"></span></a></blockquote><h2>长连接</h2><ul><li>使用长连接能显著提升性能</li></ul><p><b>unix socket</b></p><ul><li>使用 unixsocket qps对比长连接模式提升超过50%</li><li>mac系统下 从37446.17qps 到58360.08</li></ul><h2>本地循环地址 127.0.0.1</h2><ul><li>不走网卡</li><li>本机的报文的路径是这样的：</li><li>应用层-&gt; socket接口 -&gt; 传输层（tcp/udp报文） -&gt; 网络层 -&gt; back to 传输层 -&gt; backto socket接口 -.&gt; 传回应用程序</li></ul><h2>redis-benchmark</h2><ul><li>仅使用多连接，没有使用多线程</li><li>mac系统测试，考虑到cpu为双核四线程，选择同时打开4个redis-benchmark 使用unix socket </li><li>gedis的 qps分别为16052.65,15807.78,16217.97,16990.91 合计65069.31的qps,单个benchmark下为43658.59</li><ul><li>redis 单个压测的qps为56085.25</li><li>四个并行压测的qps为,11913.98,13163.96,12466.50,12496.10 合计为50040.54</li><li>可见客户端单线程的情况下即使使用了IO多路复用模型，仍然无法得出并发运行的服务端的性能瓶颈，客户端的命令归根结底是串行发出的，由于nosql本身的执行速度极快，在下一个命令到来前就已经执行完毕，所以可以大致认为单线程的客户端只能压出单核的性能瓶颈</li><li>go的单线程性能稍弱与c，但是能够方便的利用多核，在高并发场景下还是有自己的优势的</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>优化TCP/IP 栈</h2><p>在局域网环境下只要传输的包不超过一个 MTU （以太网下大约 1500 bytes），那么对于 10、100、1000 bytes 不同包大小的处理吞吐能力实际结果差不多</p><ul><li>局域网内启用巨帧 MTU 包可以对性能有很大的提升</li><ul><li>测试下来对本机无命中的get压测影响不大</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>TODO 其他内核参数的调优ifconfig ${Interface} mtu ${SIZE} up ifconfig eth1 mtu 9000 up</li></ul><p><a href=\"https://link.zhihu.com/?target=https%3A//www.ibm.com/developerworks/cn/linux/l-hisock.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">ibm.com/developerworks/</span><span class=\"invisible\">cn/linux/l-hisock.html</span><span class=\"ellipsis\"></span></a></p><h2>修改go 的net包，支持多实例监听同个端口</h2><h2>对比单个和多个端口监听实例</h2><ul><li>redis 只有主线程监听端口</li><li>gedis 5个端口监听实例</li><li>最后的实践与思考发现，当前压测的redis始终高于gedis的原因在于redis-benchmark是单线程，无法充分测试并发服务端的性能瓶颈</li><li>多个监听实例在长连接场景下的价值有限</li><li>TODO 后面继续测试多个监听实例对大量短连接的意义</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">diff --git a/src/pkg/net/sockopt_linux.go b/src/pkg/net/sockopt_linux.go\n--- a/src/pkg/net/sockopt_linux.go\n+++ b/src/pkg/net/sockopt_linux.go\n@@ -9,6 +9,10 @@\n     &#34;syscall&#34;\n )\n\n+const SO_REUSEPORT = 15\n+\n+var USE_SO_REUSEPORT bool\n+\n func setDefaultSockopts(s, family, sotype int, ipv6only bool) error {\n     if family == syscall.AF_INET6 &amp;&amp; sotype != syscall.SOCK_RAW {\n         // Allow both IP versions even if the OS default\n@@ -21,6 +25,11 @@\n }\n\n func setDefaultListenerSockopts(s int) error {\n+    if USE_SO_REUSEPORT {\n+        if err := syscall.SetsockoptInt(s, syscall.SOL_SOCKET, SO_REUSEPORT, 1); err != nil {\n+            return os.NewSyscallError(&#34;setsockopt&#34;, err)\n+        }\n+    }\n     // Allow reuse of recently-used addresses.\n     return os.NewSyscallError(&#34;setsockopt&#34;, syscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1))\n }</code></pre></div><h2>后续计划</h2><ul><li>尝试linux下的异步io</li></ul>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "性能测试", 
                    "tagLink": "https://api.zhihu.com/topics/19618663"
                }, 
                {
                    "tag": "Go 语言", 
                    "tagLink": "https://api.zhihu.com/topics/19625982"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1064154989135437824"
}
