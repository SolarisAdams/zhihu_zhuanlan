{
    "title": "不止思考", 
    "description": "互联网、思考、认知。微信公众号「 不止思考 」", 
    "followers": [
        "https://www.zhihu.com/people/xie-yu-kun-20", 
        "https://www.zhihu.com/people/zhang-zhao-qiang-74-68", 
        "https://www.zhihu.com/people/jian-dan-ru-yu-qi", 
        "https://www.zhihu.com/people/daixf9", 
        "https://www.zhihu.com/people/sunway-d-b", 
        "https://www.zhihu.com/people/aouone-lee-25", 
        "https://www.zhihu.com/people/Micro-Kun", 
        "https://www.zhihu.com/people/lan-shang-31", 
        "https://www.zhihu.com/people/liu-fu-hong-36-8", 
        "https://www.zhihu.com/people/hai-yang-xun-shou-shi", 
        "https://www.zhihu.com/people/liu-fang-wai", 
        "https://www.zhihu.com/people/jia-fei-mao-61-25", 
        "https://www.zhihu.com/people/huang-guang-le", 
        "https://www.zhihu.com/people/wei-yang-6-88", 
        "https://www.zhihu.com/people/mmp-233", 
        "https://www.zhihu.com/people/wo-yong-yuan-xi-huan-qi-e", 
        "https://www.zhihu.com/people/ding-jian-2-22", 
        "https://www.zhihu.com/people/zui-hurricane", 
        "https://www.zhihu.com/people/evbg-he-zhi-xing", 
        "https://www.zhihu.com/people/zzz-59-93-33", 
        "https://www.zhihu.com/people/li-zhi-yong-32-61", 
        "https://www.zhihu.com/people/xiao-xiao-xiao-4-49", 
        "https://www.zhihu.com/people/li-xiao-long-de-li", 
        "https://www.zhihu.com/people/eva-43-49", 
        "https://www.zhihu.com/people/wang-ming-66-71", 
        "https://www.zhihu.com/people/liyizhe", 
        "https://www.zhihu.com/people/lml233", 
        "https://www.zhihu.com/people/baird-4", 
        "https://www.zhihu.com/people/kkshuang-kong-11", 
        "https://www.zhihu.com/people/gu-du-huan-zhe-98-57-80", 
        "https://www.zhihu.com/people/xiao-zu-ji-qi-ren", 
        "https://www.zhihu.com/people/jia-sen-96-94", 
        "https://www.zhihu.com/people/nono-62-86-43", 
        "https://www.zhihu.com/people/bill011", 
        "https://www.zhihu.com/people/noblesse-51", 
        "https://www.zhihu.com/people/shen-shi-10-64", 
        "https://www.zhihu.com/people/wen-ping-69-83", 
        "https://www.zhihu.com/people/ma-shao-guang", 
        "https://www.zhihu.com/people/yuan-lei-30-75", 
        "https://www.zhihu.com/people/huayaoyue6", 
        "https://www.zhihu.com/people/mr-wrong-46", 
        "https://www.zhihu.com/people/zhou-rui-feng", 
        "https://www.zhihu.com/people/fu-feng-ge-50-51", 
        "https://www.zhihu.com/people/wangyileichn", 
        "https://www.zhihu.com/people/lazychia", 
        "https://www.zhihu.com/people/robin0908", 
        "https://www.zhihu.com/people/li-jun-feng-16-41", 
        "https://www.zhihu.com/people/yimi-ba-de-xiao-qiang", 
        "https://www.zhihu.com/people/xiao-ba-sen", 
        "https://www.zhihu.com/people/p1uto-2", 
        "https://www.zhihu.com/people/he-zheng-e", 
        "https://www.zhihu.com/people/tan-xiao-yang-95", 
        "https://www.zhihu.com/people/xiao-mi-jiang-4", 
        "https://www.zhihu.com/people/qcc-93", 
        "https://www.zhihu.com/people/firstfu", 
        "https://www.zhihu.com/people/chauncey-13", 
        "https://www.zhihu.com/people/sosla", 
        "https://www.zhihu.com/people/bei-cheng-yi-bei-33", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/wang-qiang-96-2-15", 
        "https://www.zhihu.com/people/chang-an-2-87-44", 
        "https://www.zhihu.com/people/xu-dong-29-23", 
        "https://www.zhihu.com/people/li-xiao-tian-58-29", 
        "https://www.zhihu.com/people/smalldongdong", 
        "https://www.zhihu.com/people/litefeel", 
        "https://www.zhihu.com/people/feng-liu-ren-wu-10", 
        "https://www.zhihu.com/people/jun-wang-73", 
        "https://www.zhihu.com/people/zhi-dao-12-49-74", 
        "https://www.zhihu.com/people/yuan-yuan-5-83-12", 
        "https://www.zhihu.com/people/a-wang-shuang-yan", 
        "https://www.zhihu.com/people/wangzl_lan", 
        "https://www.zhihu.com/people/szj-ws", 
        "https://www.zhihu.com/people/tang-yue-38-48", 
        "https://www.zhihu.com/people/xiao-bai-yao-fen-dou-13", 
        "https://www.zhihu.com/people/tang-qin-rui-44", 
        "https://www.zhihu.com/people/you-qing-ti-xing-39", 
        "https://www.zhihu.com/people/stanley-wong", 
        "https://www.zhihu.com/people/tu-miao-14", 
        "https://www.zhihu.com/people/xiao-ming-67-68", 
        "https://www.zhihu.com/people/justsoso-74", 
        "https://www.zhihu.com/people/yang-zhao-lao-hu-de-xiao-mao-mi", 
        "https://www.zhihu.com/people/lucy-49-92", 
        "https://www.zhihu.com/people/dfgdfgfdg", 
        "https://www.zhihu.com/people/erchoc", 
        "https://www.zhihu.com/people/zhou-lao-ge", 
        "https://www.zhihu.com/people/zwein-teng", 
        "https://www.zhihu.com/people/lao-bi-jiu-shi-wo", 
        "https://www.zhihu.com/people/brian-wang-75", 
        "https://www.zhihu.com/people/da-mi-li", 
        "https://www.zhihu.com/people/yang-guang-hua-er", 
        "https://www.zhihu.com/people/cui-si-tan-52", 
        "https://www.zhihu.com/people/steven-21-7-25", 
        "https://www.zhihu.com/people/ha-lou-52-99", 
        "https://www.zhihu.com/people/wanglar-47", 
        "https://www.zhihu.com/people/TedHacker", 
        "https://www.zhihu.com/people/lina-7-16-28", 
        "https://www.zhihu.com/people/tian-yu-qing-20", 
        "https://www.zhihu.com/people/liu-fang-88-94", 
        "https://www.zhihu.com/people/joejoe-93", 
        "https://www.zhihu.com/people/spark-63-72", 
        "https://www.zhihu.com/people/wei-ge-14-50", 
        "https://www.zhihu.com/people/uou123", 
        "https://www.zhihu.com/people/wo-mei-26", 
        "https://www.zhihu.com/people/kome", 
        "https://www.zhihu.com/people/kong-meng-64", 
        "https://www.zhihu.com/people/arthurkin", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/zhang-hong-chuan-88", 
        "https://www.zhihu.com/people/wang-da-wei-68-57", 
        "https://www.zhihu.com/people/taoonehacker", 
        "https://www.zhihu.com/people/mou-zi-50", 
        "https://www.zhihu.com/people/wu-chen-hui-83-51", 
        "https://www.zhihu.com/people/lu-lei-99-58", 
        "https://www.zhihu.com/people/yu-chen-75-27-86", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/qin-jy-6", 
        "https://www.zhihu.com/people/zhou-jing-42-44", 
        "https://www.zhihu.com/people/henryge-21", 
        "https://www.zhihu.com/people/chenwenlongzf", 
        "https://www.zhihu.com/people/yangmengli", 
        "https://www.zhihu.com/people/jiang-jing-ping-42", 
        "https://www.zhihu.com/people/xy-yao", 
        "https://www.zhihu.com/people/lai-ge-tu-zi", 
        "https://www.zhihu.com/people/liu-gang-38-21-15", 
        "https://www.zhihu.com/people/xiao-long-64-13-43", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/LicLee", 
        "https://www.zhihu.com/people/ke-le-wa-wa-85", 
        "https://www.zhihu.com/people/ywang67", 
        "https://www.zhihu.com/people/leonliuxu", 
        "https://www.zhihu.com/people/hum-75", 
        "https://www.zhihu.com/people/deweing", 
        "https://www.zhihu.com/people/fan-fan-fan-81-17-51", 
        "https://www.zhihu.com/people/xin-gai-nian-kai-fa", 
        "https://www.zhihu.com/people/heier2013", 
        "https://www.zhihu.com/people/DONUTY", 
        "https://www.zhihu.com/people/wangyts", 
        "https://www.zhihu.com/people/wang-xiang-zhong-5", 
        "https://www.zhihu.com/people/si-san-er-yi-10-44", 
        "https://www.zhihu.com/people/fu-sheng-ruo-meng-65-43-73", 
        "https://www.zhihu.com/people/yang-zh-91", 
        "https://www.zhihu.com/people/MikePeng", 
        "https://www.zhihu.com/people/hu-zi-87-53", 
        "https://www.zhihu.com/people/liu-jia-63", 
        "https://www.zhihu.com/people/zhu-yong-chun-46-1", 
        "https://www.zhihu.com/people/alanzeng-69", 
        "https://www.zhihu.com/people/jianchun-96", 
        "https://www.zhihu.com/people/sun-zheng-bin", 
        "https://www.zhihu.com/people/XiaMin1314", 
        "https://www.zhihu.com/people/xiao-fan-25-98-14", 
        "https://www.zhihu.com/people/barefootcoder", 
        "https://www.zhihu.com/people/ge-lai-lai-64", 
        "https://www.zhihu.com/people/dufei-lee", 
        "https://www.zhihu.com/people/ling-yi-ge-zhang-zhi-ming", 
        "https://www.zhihu.com/people/riverhohai", 
        "https://www.zhihu.com/people/datacracker", 
        "https://www.zhihu.com/people/hu-zhi-hong-43", 
        "https://www.zhihu.com/people/simon-44", 
        "https://www.zhihu.com/people/qiaoliangxiang", 
        "https://www.zhihu.com/people/alex-96-32-29", 
        "https://www.zhihu.com/people/tou-wong-64", 
        "https://www.zhihu.com/people/yiwa", 
        "https://www.zhihu.com/people/leo-25-6-83", 
        "https://www.zhihu.com/people/alexzhang2015", 
        "https://www.zhihu.com/people/ozil11-30", 
        "https://www.zhihu.com/people/shoutleaf", 
        "https://www.zhihu.com/people/ieason92", 
        "https://www.zhihu.com/people/babyfamily", 
        "https://www.zhihu.com/people/scue", 
        "https://www.zhihu.com/people/xiaowei-zhang-70", 
        "https://www.zhihu.com/people/iceyang1989", 
        "https://www.zhihu.com/people/ken-wang-86", 
        "https://www.zhihu.com/people/tian-xuan-yi-feng", 
        "https://www.zhihu.com/people/kemin-cheng", 
        "https://www.zhihu.com/people/eagleliwx", 
        "https://www.zhihu.com/people/luo-ji-yin-85", 
        "https://www.zhihu.com/people/sunicdavy", 
        "https://www.zhihu.com/people/gomars", 
        "https://www.zhihu.com/people/zhangdongfang", 
        "https://www.zhihu.com/people/jasonlee-41-3", 
        "https://www.zhihu.com/people/tian-tian-zao-qi-hai-ren", 
        "https://www.zhihu.com/people/yubo-dou", 
        "https://www.zhihu.com/people/zhang-yan-15-25-75", 
        "https://www.zhihu.com/people/KingJeason", 
        "https://www.zhihu.com/people/60sky", 
        "https://www.zhihu.com/people/SakuB", 
        "https://www.zhihu.com/people/wei-yin-shi-tai-ge", 
        "https://www.zhihu.com/people/okcokc", 
        "https://www.zhihu.com/people/hai-lan-65-39", 
        "https://www.zhihu.com/people/fei007", 
        "https://www.zhihu.com/people/zhang-ye-jiang-66", 
        "https://www.zhihu.com/people/wang-peng-ju-84", 
        "https://www.zhihu.com/people/lee8790", 
        "https://www.zhihu.com/people/li-lin-77-78", 
        "https://www.zhihu.com/people/xxt-44", 
        "https://www.zhihu.com/people/qi-feng-96", 
        "https://www.zhihu.com/people/viggo-97", 
        "https://www.zhihu.com/people/dian-jie-42-91", 
        "https://www.zhihu.com/people/patrick-simon-78", 
        "https://www.zhihu.com/people/hu-tao-ye-shi-tao", 
        "https://www.zhihu.com/people/xiao-kai-bu-pa-bu-pa-89", 
        "https://www.zhihu.com/people/biuabiu", 
        "https://www.zhihu.com/people/zhanci", 
        "https://www.zhihu.com/people/liu-chao-51-93", 
        "https://www.zhihu.com/people/jzx-94-55", 
        "https://www.zhihu.com/people/yiye-chun-feng-55", 
        "https://www.zhihu.com/people/wu-kui-yang-41", 
        "https://www.zhihu.com/people/shuidf", 
        "https://www.zhihu.com/people/gong-he-jian", 
        "https://www.zhihu.com/people/du-xin-shao-nian", 
        "https://www.zhihu.com/people/kuang-jia-wei-57", 
        "https://www.zhihu.com/people/tiao-wu-de-hou-zi-20", 
        "https://www.zhihu.com/people/peng-jin-yi", 
        "https://www.zhihu.com/people/xie-xiao-rong-23", 
        "https://www.zhihu.com/people/maodun9", 
        "https://www.zhihu.com/people/khan-60-14", 
        "https://www.zhihu.com/people/chen-chong-001", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/xu-bin-2-24", 
        "https://www.zhihu.com/people/abee-71", 
        "https://www.zhihu.com/people/noeltoby", 
        "https://www.zhihu.com/people/yan-yi-82", 
        "https://www.zhihu.com/people/albert6378", 
        "https://www.zhihu.com/people/rocky-hu-23", 
        "https://www.zhihu.com/people/shang-rui-69", 
        "https://www.zhihu.com/people/ling-ling-89-54", 
        "https://www.zhihu.com/people/inextime", 
        "https://www.zhihu.com/people/you-meng-xiang-de-ren-83", 
        "https://www.zhihu.com/people/-.-Luffy", 
        "https://www.zhihu.com/people/ggff-ss", 
        "https://www.zhihu.com/people/buzoumei", 
        "https://www.zhihu.com/people/zhujunpeng", 
        "https://www.zhihu.com/people/fan-qi-neng", 
        "https://www.zhihu.com/people/ACWei", 
        "https://www.zhihu.com/people/jimmy.li", 
        "https://www.zhihu.com/people/chen-hao-nan-42", 
        "https://www.zhihu.com/people/bluseli-86", 
        "https://www.zhihu.com/people/rao-zhe-heng", 
        "https://www.zhihu.com/people/ding-qiang-23-22", 
        "https://www.zhihu.com/people/na-na-9-85", 
        "https://www.zhihu.com/people/cpm-81", 
        "https://www.zhihu.com/people/zy-xu-37", 
        "https://www.zhihu.com/people/kingchin-wong", 
        "https://www.zhihu.com/people/xiaokaibupabupa", 
        "https://www.zhihu.com/people/yu-qian-28-20", 
        "https://www.zhihu.com/people/bao-zhi-wen-8", 
        "https://www.zhihu.com/people/liu-yang-78-47", 
        "https://www.zhihu.com/people/ashi-tao", 
        "https://www.zhihu.com/people/mingzai624", 
        "https://www.zhihu.com/people/ljg1189", 
        "https://www.zhihu.com/people/zhu-jun-98-96", 
        "https://www.zhihu.com/people/raynor-ren", 
        "https://www.zhihu.com/people/zhu-ming-yue-5255", 
        "https://www.zhihu.com/people/cheng-hua-51-77", 
        "https://www.zhihu.com/people/--help", 
        "https://www.zhihu.com/people/kevin-hill", 
        "https://www.zhihu.com/people/zhong-da-fei", 
        "https://www.zhihu.com/people/yuan-jian-57", 
        "https://www.zhihu.com/people/zhang-shao-peng-78", 
        "https://www.zhihu.com/people/kang-hong-lun", 
        "https://www.zhihu.com/people/lijianjun1984", 
        "https://www.zhihu.com/people/zealoussnow", 
        "https://www.zhihu.com/people/123mu-tou-ren-4-15", 
        "https://www.zhihu.com/people/damieng", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/zheng-chu-hai", 
        "https://www.zhihu.com/people/code-art", 
        "https://www.zhihu.com/people/xyp-88", 
        "https://www.zhihu.com/people/zhupan", 
        "https://www.zhihu.com/people/liu-hai-67-13", 
        "https://www.zhihu.com/people/TtForward", 
        "https://www.zhihu.com/people/wu-di-da-shi-19-76"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88097166", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 2, 
            "title": "要不要赶个时髦，去建设一个「 中台 」？", 
            "content": "<p>很多技术人总是抱怨 新技术/新框架/新概念 太多了，总是学不完，抱怨实在是学不动了。哈哈，这不，最近「 中台 」这么火热，要不要停止抱怨，再咬咬牙学一波？<br/><br/>“很多人都担心被技术新潮流所抛弃，所以当遇见不断涌现的新技术时，总是慌忙的去学习。可是其中到底有多少是真正有用的？又有多少是昙花一现的技术呢？当你无法分辨的时候，其实不必慌张，当一项新技术/概念刚出现的时候，你不必匆忙的去学习，更不必担心自己会错过它，如果它是一个真正有价值的东西，是一个真正经受得住考验得技术，它迟早会再次出现在你面前”<br/>这是我很喜欢的一段话，对技术浪潮的见识太到位了。不过很惭愧，我不记得是哪位大神说的了。<br/>回到「 中台 」这个话题，其实中台已经不算新潮流了，并且它还是被很多企业成功验证过的模式了。那么，既然这么靠谱，咱们是否应该赶个时髦，搞一个？<br/>在回答这个问题之前，咱们先缕一缕啥是中台吧。<br/><b>中台</b> 这个理念在国内最早是由阿里巴巴带起来的，后来国内一些互联网大厂（滴滴、京东等）也开始在内部推行，加上今年腾讯在“全球数字生态大会”上再度提起中台架构，引起了大家一波又一波的追捧。不过这个架构理念也不是由阿里巴巴提出的，而是马云带着阿里团队拜访 Supercell 公司学习来的。Supercell 是芬兰一家著名的移动游戏公司 ，我说几个他们开发的游戏大家就能明白了这家不到两百人的公司有多牛逼了，比如著名的《部落冲突》《卡通农场》《皇室战争》。<br/>Supercell公司公司人员人少，采用的就是“小前台”+“部落”的模式。就是有多个“前台”小组，这些小组就是专门用来快速研发游戏的，每个小组虽然人员不多但它包含了开发一款游戏所需的各种角色人员。这些“前台”小组只关注在业务侧，也就是游戏业务研发和创新上。而对于游戏的底层基础设施：游戏引擎、开发工具、服务器后台等这些都东西，前台小组不用去关心，这些基础功能交由一个称为“部落”的组织独立去负责。这种模式就像是战斗小组专门去负责打仗，后勤弹药又由另外的小组去搞定，分工明确，业务也能快速试错、快速创新。<br/>根据这次拜访学习，阿里巴巴随后宣布组织架构全面升级，启动中台战略，构建“大中台、小前台”的组织机制和业务机制。<br/>在2017、2018、2019年很多互联网大厂都对外分享了自己的中台实践成果，包括阿里、腾讯、京东等都为中台战略做出组织架构的调整。<br/>在互联网大厂的领头、产业互联网的风口，传统企业的转型契机下，「 中台 」不火都不行啊。<br/>对于<b>中台</b>的了解，网上资料简直多的不要不要的，但体系化的学习，我推荐看看<b>云徙科技</b>的几位大佬新出的**《中台战略》<b>这本书，以及极客时间的</b>《说透中台》**专栏，这两个资料算是对中台介绍的比较全面的。本文的部分观点也是吸取了这些内容后的收获，建议找来一读。<br/><b>一、「 中台 」到底是什么？</b><br/>想了很久，想用一句简洁清晰的语句给 <b>中台</b> 下个定义，还是有点难度（嗯，没错，还是我的认知太浅了，哈哈）。<br/><b>中台</b> 就是一个架构理念，它是介于前台与后台之间的（这句好像是废话），它是希望将一些可复用的“能力”统一起来，采用共享的方式去建设，用来解决各个业务团队重复开发、数据分散、试错成本高等问题，中台的核心就是**“对能力的共享”<b>、</b>“对能力的复用”**，它应该是公司内部的统一协同平台。<br/>另外再给个参考，在《说透中台》专栏中王健老师将中台定义为：<br/>企业级的能力复用平台<br/>我觉得这个定义相当准确且简洁。受不了我上面一大段啰嗦定义的同学，可以按照这个简洁的定义去理解中台。<br/>上面讲完了中台的定义，我们再来看看 前台、中台、后台 的区别吧。<br/>「前台」是直接服务客户、触达用户的平台，能够洞察用户需求，进行产品创新、提升用户价值，保持精简和足够敏捷度的平台。比如阿里的 淘宝、天猫、聚划算等。<br/>「中台」前面已经定义过了。它通过组件化的形式输出通用能力，为所有「前台」的业务运营和创新，提供专业能力的共享平台。中台部门提炼各业务线的共性需求，将各种资源转化为方便「前台」使用的能力，最大程度避免重复“造轮子”。<br/>「后台」的职能是提供基础设施建设、服务支持，为「前台」和「中台」提供基础保障。后台会比中台更底层、更通用。「中台」有的时候会更关注在某一行业/领域内的，而「后台」应该是行业/领域通用的。<br/>要注意的是，中台并不是专指技术，相反主流的中台更侧重于业务。<br/>上面提到的 前台、中台、后台 全部都是从用户和职能角度出发的，很多开发同学一听前后台就理解成了技术架构了，技术架构中的前端展示层、技术中间层、后端数据层，与这里的前中后台完全不是一个概念。<br/>阿里的中台战略是以业务中台和数据中台相结合，这也是目前市面上主流的中台架构。<br/><b>业务中台</b>是提供可复用的业务服务，包括如用户中心、会员中心、订单中心、支付中心等，既可拆箱即用，又可复用的业务能力。说白了，各个不同的业务线/业务部门其实有很多类似、共通的业务组件，大家就不要各自搞各自的了（传说中的烟囱式、单体式项目架构），既浪费资源，也不利于协同。干脆大家把这些共性的可复用的业务组件从<b>前台</b>里提炼出来，下沉到中台，一起建设一起用，你好我好大家好。<br/><b>数据中台</b>是基于技术和大数据能力为业务提供可复用的数据服务，将业务中产生出来的数据进行二次加工，将加工的结果再服务于业务，为业务赋能。但要注意的是，大家在理解上不能将数据中台与传统的数仓、大数据平台划等号。数据中台与它们的区别是，数据中台更贴近业务，数据中台不只关心技术层面，不只提供分析功能，更多关心数据资产化、关心数据对业务的运用，为业务提供服务。<br/>业务中台与数据中台相辅相成、互相支撑。所以现在大家也很流行的说法就是：数据业务化、业务数据化嘛。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a658caf40a7ef49e7f6dde8d48f89ca1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1055\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb\" width=\"1055\" data-original=\"https://pic2.zhimg.com/v2-a658caf40a7ef49e7f6dde8d48f89ca1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1055&#39; height=&#39;655&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1055\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1055\" data-original=\"https://pic2.zhimg.com/v2-a658caf40a7ef49e7f6dde8d48f89ca1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a658caf40a7ef49e7f6dde8d48f89ca1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-dd02a1cec30a31a35a16e4e748a2c3f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"613\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-dd02a1cec30a31a35a16e4e748a2c3f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;613&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"613\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-dd02a1cec30a31a35a16e4e748a2c3f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-dd02a1cec30a31a35a16e4e748a2c3f0_b.jpg\"/></figure><p>（图片来源云栖社区）<br/>除此之外，在实际应用中，也衍生出了很多其它的中台概念，如：<b>移动中台</b>、<b>算法中台</b>、<b>技术中台</b>、<b>研发中台</b>、<b>运营中台</b>、<b>组织中台</b> 等等。下面挑选几个简单解释一下：<br/><b>技术中台</b>：提供通用的技术设施能力、技术中间件能力，过滤掉技术细节，像各个前台应用提供统一的易用的技术服务，避免重复造轮子（也有人认为技术中台不具备业务属性，属于技术中间件平台，不能归属中台）。<br/><b>研发中台</b>：研发中台是关注开发效率的平台，将公司的开发流程、最佳实践沉淀为可重用的能力，为应用的开发提供了流程、质量管控和持续交付的能力。<br/><b>移动中台</b>：将移动APP开发中的通用技术、框架、业务组件等进行封装，沉淀到移动中台，提高移动开发组件的可复用性，方便快速构建新的APP开发（有些人对移动中台的争议与技术中台类似）。<br/>为什么会出现这么多的让人眼花缭乱的中台呢？根本原因是每个人自己的职业不同，所以看待的角度不同，出发点不同，并且每个公司的业务性质、形态也不相同。比如 电商团队、AI团队、运营团队、研发团队，他们眼中的中台肯定都是不一样的，但初衷是一样的：<b>资源的复用</b>。<br/>另外，这里还得再啰嗦一句：“<b>平台不是中台</b>”。什么意思呢？<br/>有的互联网企业在对公司内的模块进行定义和表述中，并不常用“后台”的概念，反而用“平台”比较多。比如 大数据平台、运维自动化平台、财务平台等等。这些“平台”与我们今天描述的“中台”并不是一回事。平台比中台更底层一些，更基础一些。平台一般是不带业务属性的，而中台，确必须是具备业务属性的，因为中台是直接为前台业务所服务的，是一个提炼业务能力共性的组织，在这一点上就与平台区别的很明显了。<br/><b>二、我们要不要去建设「 中台 」？</b><br/>「中台」这么火，大小企业都蠢蠢欲动，各种靠谱不靠谱的平台都往中台的概念上靠，要干的劲头挡不住啊。行吧，既然要干，咱们至少得先看看问题吧，把明显不适合搞中台的基本条件弄清楚嘛。<br/></p><ol><li><b>公司得核心业务不成熟 或 公司业务线很少</b><br/>如果企业属于创业公司，主业务模式都不明朗，这种情况就真的不建议搞什么中台的。中台是讲究多业务服务用的，咱就一个业务，这个业务还在探索，搞啥子中台嘛，把技术平台搞好点就可以了。</li><li><b>公司里没有相类似的业务</b><br/>即使不是创业公司，是一个中型甚至是大型公司了，但如果公司里虽然业务多，但是每个业务线做的领域都区别很大，比如业务线1做面向C端的电商，业务线2做游戏，业务线3做面向B端企业级产品。这种情况，很难沉淀共性的业务服务，也做不了中台，还是拉一个团队继续做基础平台给各个业务服务吧。</li><li><b>公司没有足够的人力</b><br/>人力是硬指标，即使上面说的问题都没有，完全符合做中台，那也得考虑考虑人员安排。毕竟中台的建设是需要由独立的团队去完成，并且还应该是一个高效率的团队（不然前台业务会抱怨中台响应不及时），公司是否有这部分的人力预算去建设中台，人员从哪儿来，这个硬性条件必须提前考虑。</li></ol><p>这篇文章阐述了 啥是中台、要不要建中台，但貌似缺一个“怎么建中台”了，这个以后聊。<br/>另外，还有很多人担心「 中台 」会不会是昙花一现的新概念，我觉得纠结这个完全没必要。当咱们充分理解了中台，学到了其中的理念之后，它是不是昙花一现并不是很重要嘛。因为我们已经获得了成长，获得了视野和思维的提升，足以。您觉得呢？<br/>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。</p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "敏捷开发", 
                    "tagLink": "https://api.zhihu.com/topics/19564208"
                }, 
                {
                    "tag": "第四次工业革命", 
                    "tagLink": "https://api.zhihu.com/topics/20011245"
                }, 
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }
            ], 
            "comments": [
                {
                    "userName": "kiki", 
                    "userLink": "https://www.zhihu.com/people/368c1e6a61badbedc1bc9570f9f95c30", 
                    "content": "中台 英文怎么说比较贴切呢？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88097061", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "AI的时代，你的职业还在吗？", 
            "content": "<p>目前人工智能（Artificial Intelligence，简称AI）的技术到底发展到啥情况了？<br/></p><p>如果未来AI在我们社会上全面应用之后，会对咱们的生活会带来多大的帮助？</p><p>AI的应用又会对目前社会上的工作岗位有多少影响呢？你目前所从事的职业未来会被AI替代吗？</p><p>嗯，好问题，但我是一个都没法回答，我也不知道。但据科技大佬们说：</p><p>AI技术早已经在我们身边越来越多的普及了，虽然我们还未完全觉察，但这项技术已经在悄然的改变我们的生活、改变我们的职业了。</p><p>吴军老师认为，这AI的到来是一次智能革命，并且这次智能革命与以往历次的技术革命一样，摆在我们每个人面前的只有两条路，要么加入技术浪潮成为前2%的人，要么观望徘徊被淘汰。</p><p>嗯，听起来有点唬人，但是又好像有些道理。</p><p>为了不被他这一两句话唬住，我决定找点书研究一下，比如李开复的《AI未来》和吴军《智能时代》，毕竟他们的书简单易懂（其实是太高深的我也看不懂），并且他们不仅曾经是人工智能领域的研究先驱，也是这个领域的投资者、推动者，是真正的大佬级别的人物。</p><p>嗯，看他们的书准没错，那就看看大佬们是怎么讲的：</p><h3><b>1、AI时代，你的职业还在不在？</b></h3><p>李开复老师在《AI未来》中预测美国有40%-50%的工作岗位是能够被人工智能技术取代的，中国的情况可能比美国好一点，但也好不了多少。吴军老师甚至认为全球只有2%的人是人工智能的革命的掌握者和直接受益者，其他人都或多或少的受到影响。</p><ul><li>医生：<br/>未来有了人工智能，它可以分析和对比无数的病例和诊断材料，它可以在医生看病的时候，起到辅助治疗提供诊断建议的作用。在做医学影像分析的时候，人工智能比人类更精准。甚至是在做心脏大脑等精细手术的时候，人工智能还能替代人类医生的手去做手术，更稳。<br/>人工智能还能缓解医疗紧缺的问题，现在好的医生和治疗方案只有大医院能提供，未来人工智能可以辅助中等水平的医生做出高水平的医疗方案。人工智能还能推进新药的研发效率。<br/>在短时间内人工智能可能无法完全替代人类医生，它更可能会以医生助手的形式存在，但经过时间的积累，人工智能很有可能比人类医生更出色。</li><li>制造业：<br/>人工智能在这个行业的优势其实很容易理解，前段时间很火的《美国工厂》的最后一个片段里工厂的管理者就在向“玻璃大王”介绍着将要用机器人替代人工岗位，因为工人们太慢了。<br/>目前特斯拉汽车的工厂其实已经在尝试全部由机器人来装配汽车。未来会有大量的做着重复劳动的普通制造业工人失业，人工智能的发展对于经济和企业家来说是利好，但对于那些工人来说却相反。</li><li>记者、编辑 和 金融业：<br/>不要以为人工智能只会影响实体业，相反，人工智能对白领的影响更是首当其冲。人工智能的优势就是算法，这些算法随时能替代脑力劳动者，比起制造业的机器人，人工智能还需要配合机器人的生产、组装和维护调试，但对于脑力劳动，人工智能太容易了，起码现阶段的人工智能还是“思想上的巨人、行动上的矮子”。<br/>人工智能可以很容易的写出一篇报道稿，来替代记者和编辑。在金融业，人工智能早已经采用智能风控算法和大数据去替代风控人员了。</li></ul><p>还有很多行业就不一一列举了，李开复老师认为人工智能革命会分为四波浪潮袭来：</p><p>第一波互联网智能化，第二波商业智能化，第三实体世界智能化，第四波自主智能化。前两波已经出现在了我们身边，后面两波正在跃跃欲试中。</p><h3><b>2、曾经历史上的技术革命是怎样消化掉负面影响的？</b></h3><p>我们先看一下这个世界之前发生的几次技术革命：</p><ul><li>18世纪末始于英国的工业革命<br/>这是以蒸汽机为代表的时代，回头来看，这次技术革命将人均GDP增长了几十倍，全球财富、人类寿命都获得了大幅的提高。但在当时，技术革命的初级阶段只有发明家和工厂主受益，普通民众不仅没有受益，反而破产失业，第二阶段才是英国普通民众受益，第三阶段才是全世界受益。在发展的过程中，它给社会带来的巨大负面影响，导致大量工匠的失业，社会矛盾重重，当时诅咒它的人可比欢呼拥抱它的人更多，英国人花了两代人的时间来消耗工业革命带来负面影响，这个阵痛的时间对于每一个个人和家庭来说可不短。</li><li>19世纪末始于美国德国的第二次工业革命<br/>第二次工业革命是以电力为核心的时代，它带来了生产效率的进一步提高，并且催生了很多新产业。但它在当时也同样带来了社会的阵痛，美国贫富分化程度到达了最高，爆发了工人运动，传统工业被彻底碾碎。也是经过长达半个世纪的时间才消化掉这些阵痛。</li><li>“二战”后以摩尔定律为标准的信息革命<br/>这是以计算机为核心的信息时代，其实这次信息革命还未消化完。中国由于一些特殊原因在这次信息革命中感受到的负面影响较少，更多的是享受到了信息革命带来的财富增长。但对于大部分欧洲国家、南美洲，它们自由的旧的经济结构已经落伍，甚至被摧毁，而在新的经济结构中虽享受到了信息产品，却没有享受信息革命带来的经济增长。</li></ul><p>可以看出，每次重大的技术革命都是靠很长很长的时间来消化掉它所带来的负面影响，因为技术革命会使很多旧产业消失，旧产业的从业人员需要重新寻找出路。根据历史来看，这些时间至少需要一代人。</p><p>而即将到来的智能革命对社会的冲击很有可能会远远超过过去的那几次技术革命。</p><h3><b>3、机器智能是怎样发展过来的？</b></h3><p>人工智能（或者叫机器智能）其实起源很早，从1950年图灵发表的《计算的机器和智能》论文中提出了一种验证机器有无智能的判别方法时起（后来被成为 图灵测试），科学家们就开始用各种方式去探索机器智能了。</p><p>只不过最开始大家都是沿着“机器要像人一样思考才能获得智能”，模拟人的思维的方式去研究机器智能。吴军老师在《智能时代》书中提到这种方法叫做“飞鸟派”，就像人类在飞上天空之前，看到鸟儿会飞翔，就觉得人类想上天空也必须学习鸟儿（仿生学），因此一直研究的方向都是模拟鸟儿的扇动翅膀的飞翔方法去造飞机，后来我们知道这种方式是行不通的，人类是靠研究了空气动力学才造成飞机的。同样，机器智能一直采用模拟人类思维的方式去研究也一直没有取得很大的成果，太难了。</p><p>后来有一波科学家们开始另辟蹊径，找到了采用数据驱动和超级计算的方式去尝试研究，然后随着摩尔定律的发展，计算硬件越来越便宜，并且互联网与移动互联网的兴起，大数据也出现了，数据也越来越多、越来越丰富，加上技术上的突破（深度学习技术被提出）这才促使机器智能再次有爆发的机会，应用才越来越明朗。</p><h3><b>4、人工智能的机遇？</b></h3><p>李开复在《AI未来》中强调，目前人工智能已经从“发明的年代”转变为“实干的年代”了。今天的人工智能创业者开始运用深度学习来落实各种创新的应用。人工智能的许多研究工作大都已完成，现在是创业者们加油干，把深度学习算法转化为持续经营事业的时候了。</p><p>所以对于我们普通人而言，不要觉得人工智能的技术太深奥离我们很远，事实上人工智能的技术服务必然会有一批平台型公司来提供，就像第二次工业革命的电力一样。我们需要的做的就是去使用“电”，基于“电”去改造现有产业，去做创新的应用。</p><p>成功的人工智能应用需要三个基本条件：大数据、算力、算法工程师。算力其实已经不是问题，甚至google专门推出了TPU处理器来支持这类运算，算法工程师其实要求也没有想象的那么高，当我们处于应用阶段而非发明阶段时，并非需要顶尖的算法工程师。这里面，最最重要的还是大数据，当我们想要基于人工智能在某个行业/领域去应用/改造的时候，首先要去思考的时候这个行业是否积累了大数据。</p><p>以上，就是对最近读的《智能时代》和《AI未来》的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。 </blockquote><p><br/> </p>", 
            "topic": [
                {
                    "tag": "AI技术", 
                    "tagLink": "https://api.zhihu.com/topics/20106982"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "人工智能AI酱", 
                    "tagLink": "https://api.zhihu.com/topics/20082756"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88096943", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "算法一看就懂之「 冒泡排序 」", 
            "content": "<p>上一篇文章「 排序算法 」已经整体的把排序算法的分类和评估方法介绍了一下，今天起咱们就开始依次介绍一下各种排序算法的原理和特性。咱们就从最容易理解的「 冒泡排序 」开始吧。<br/><br/><b>一、「 冒泡排序 」是什么？</b><br/><b>冒泡排序</b>是一种交换排序，它的思路就是在待排序的数据中，两两比较相邻元素的大小，看是否满足大小顺序的要求，如果满足则不动，如果不满足则让它们互换。然后继续与下一个相邻元素的比较，一直到一次遍历完成。一次遍历的过程就被成为一次冒泡，一次冒泡的结束至少会让一个元素移动到了正确的位置。所以要想让所有元素都排序好，一次冒泡还不行，我们得重复N次去冒泡，这样最终就完成了N个数据的排序过程。<br/>通过上面的描述，可以看出来冒泡排序在代码实现层面不就是两层循环嘛，哈哈。<br/>下面举例：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f47a0bc40ea4129dc82bc554598359bf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"919\" data-rawheight=\"526\" class=\"origin_image zh-lightbox-thumb\" width=\"919\" data-original=\"https://pic4.zhimg.com/v2-f47a0bc40ea4129dc82bc554598359bf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;919&#39; height=&#39;526&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"919\" data-rawheight=\"526\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"919\" data-original=\"https://pic4.zhimg.com/v2-f47a0bc40ea4129dc82bc554598359bf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f47a0bc40ea4129dc82bc554598359bf_b.jpg\"/></figure><p>如图，这是针对数组：5，1，4，2，8 采用冒泡排序进行从小到大的排列，上图中分别进行了三次冒泡后完成了整个排序过程。<br/>先看第一次冒泡：<br/></p><ol><li>从数组的第0位开始，比较5和1，发现5&gt;1，交换位置，交换后数组为：1，5，4，2，8</li><li>继续下一个元素的比较，比较5和4，发现5&gt;4，交换位置，交换后数组为：1，4，5，2，8</li><li>继续下一个元素的比较，比较5和2，发现5&gt;2，交换位置，交换后数组为：1，4，2，5，8</li><li>继续下一个元素的比较，比较5和8，发现5&lt;8，不用交换，数组保持不变：1，4，2，5，8</li><li>继续下一个元素的比较，发现没有元素了，不用比较了，数组在第一轮冒泡排序后的最终状态就是：1，4，2，5，8 了，此时 元素 8 已经到了正确的位置，其它元素位置还是不对，需要循环进行下一轮冒泡。</li></ol><p>第二次冒泡和第三次冒泡的原理与第一次冒泡一样，这里就不描述了，直接看上图，图中有清晰的流程标注。<br/>我们在写冒泡排序的时候，有两个事项需要注意：<br/></p><ul><li><b>冒泡的次数可以减少：</b><br/>理论上如果数组有N个元素，且这N个元素完全是倒序的话，我们需要进行N次冒泡才可以完成排序工作，但是通过上面的示例可以发现，上述数组有5位，但是我们只进行了三次冒泡就完成了，原因就是因为数组中有些元素之前就已经是有序的了。那我们怎么判断该用几次冒泡操作呢？<br/><b>冒泡停止的条件就是：当某次冒泡操作全程都无需进行元素交换，就说明此时这个数组已经达到了完全有序状态了，无需再进行下一次冒泡了。</b><br/>上图中的第三次冒泡过程中，没有一次需要元素交换的，因此就不需要进行第四次冒泡了。<br/>在写代码的时候，需要使用一个变量来做好标记，下面我们来写一个冒泡代码：<br/>算法题：对数组arr进行从小到大的排序，假设数组arr不为空，arr的长度为n<br/>思路：有两种方式都可以，一个是从数组前往后冒泡，将最大的元素移动到最后面，另一种方式是从数组的后面往前冒泡，将最小的元素移动到最前面。<br/><br/>public class BubbleSort {<br/><br/> /**<br/>   *  从前往后冒泡<br/>   *  上面的图片就是采用这种方式<br/>   */<br/> public void bubbleSort1(int[] arr, int n) { <code>for (int i = 0; i &amp;lt; n; i++) {</code><br/> <code>// flag是用来标记本次冒泡中是否有元素交换，用来决定冒泡停止条件的</code><br/> <code>boolean flag = false;</code><br/> <code>for (int j = 0; j &amp;lt; n-i-1; j++) {</code><br/> <code>// 从第一个开始，相邻元素两两比较，如果前一个比后一个大则交换</code><br/> <code>if (arr[j] &amp;gt; arr[j+1]) { </code><br/> <code>int temp = arr[j];</code><br/><code>              arr[j] = arr[j+1];</code><br/><code>              arr[j+1] = temp;</code><br/><code>              flag = true; // 如果有元素交换了，就设置为true</code><br/><code>          }</code><br/><code>      }</code><br/> <code>// 一次冒泡下来没有元素交换，就提前退出</code><br/> <code>if (!flag) break; </code><br/><code>  }</code><br/><br/>  }<br/><br/> /**<br/>   *  从后往前冒泡<br/>   */<br/> public void bubbleSort2(int[] arr, int n) { <code>for (int i = 0; i &amp;lt; n; i++) {</code><br/> <code>// flag是用来标记本次冒泡中是否有元素交换，用来决定冒泡停止条件的</code><br/> <code>boolean flag = false;</code><br/> <code>for (int j = n-i-1; j &amp;gt; i; j--) {</code><br/> <code>// 从第最后一个开始，相邻元素两两比较，如果前一个比后一个大则交换</code><br/> <code>if (arr[j-1] &amp;gt; arr[j]) { </code><br/> <code>int temp = arr[j-1];</code><br/><code>              arr[j-1] = arr[j];</code><br/><code>              arr[j] = temp;</code><br/><code>              flag = true; // 如果有元素交换了，就设置为true</code><br/><code>          }</code><br/><code>      }</code><br/> <code>// 一次冒泡下来没有元素交换，就提前退出</code><br/> <code>if (!flag) break; </code><br/><code>  }</code><br/><br/>  }<br/><br/>}<br/></li><li><b>冒泡一定是对比相邻元素：</b><br/>冒泡排序的原则很简单，就是相邻的两两对比然后判断是否交换。但其中有个新人很容易疏忽的就是“相邻”这个词，我们在循环中对比的元素一定是要相邻的，不能拿着某个元素依次对比数组中的所有元素（比如先拿数组0位元素依次对比其它元素，将最小的置换到第0位，然后再拿数组1位元素依次对比剩下所有元素，将剩下元素最小的置换到第1位，依次循环），虽然这种方式也能最后排序也能完成，但是效率非常的低。为什么这种方式效率低呢？<br/>因为这种方式每一次元素交换，虽然都将当前最小的元素移动到了正确的位置，但是对于其它元素的位置没有半点改进，甚至会由于交换导致其它比较小的元素这次遍历中移动到后面。<br/>而采用“相邻元素两两对比”的方式，每次冒泡不仅能将一个元素移动到正确的位置，还能附带着对其它元素的位置有改进。</li></ul><p><b>二、「 冒泡排序 」的性能怎么样？</b><br/>我们按照前一篇文章讲到的排序算法评估方法来对「 冒泡排序 」进行一下评估：<br/></p><ul><li><b>时间复杂度：</b><br/>冒泡排序原理就是在两层循环里进行两两对比嘛，所以简单去思考的话，一般情况下的时间复杂度就是O(n*n)了。但是实际还是得看数据情况，如果待排序的数据本身就是有序的，其实我们只需要做依次冒泡就完成了（也就是一次循环），那么此时就是最好时间复杂度：O(n)，如果待排序的数据全部都是逆序的，那我们需要做 n(n-1)/2 次循环，最坏时间复杂度就是：O(n*n)了。</li><li><b>空间复杂度：</b><br/>通过我们对冒泡排序原理的了解，知道冒泡排序在排序的过程中，不需要占用很多额外的空间（就是在交换元素的时候需要临时变量存一存，这里需要的额外空间开销是常量级的），因此冒泡排序的空间复杂度为O(1)了。</li><li><b>排序稳定性：</b><br/>上一篇介绍过了排序算法稳定性的定义，这里不重复介绍了。对于冒泡排序而言，在做元素对比的时候，如果大小顺序不满足要求，则将它们进行交换，如果满足要求，或者元素相等，则啥都不做。可知，在元素相当的情况下，位置没有发生变化，因此它是排序稳定的。</li><li><b>算法复杂性：</b><br/>冒泡排序的算法无论是其设计思路上，还是代码的编写上都不复杂，因此冒泡排序算法复杂性是比较简单的。</li></ul><p>以上，就是对数据结构中「 冒泡排序 」的一些思考，您有什么疑问吗？<br/>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }, 
                {
                    "tag": "算法设计", 
                    "tagLink": "https://api.zhihu.com/topics/19615875"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/88096780", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "算法一看就懂之「 排序算法 」", 
            "content": "<p>之前的文章咱们已经聊过了<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502470%26idx%3D1%26sn%3D55ce43a4d37e55f0e5f3db709ff48324%26chksm%3Df250984cc527115afce1c763e5efc9418ba5b4a356129d491d971fc00a0b2f409288580fac85%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 数组和链表 」</a>、<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502477%26idx%3D1%26sn%3D644bb54cfc4977b6fb16a7e1eb64f14e%26chksm%3Df2509847c5271151a71b55c8fe3590aa7e51fec5d8633884f8c4e8b32284d3d3a87e23a666fa%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 堆栈 」</a>、<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502499%26idx%3D1%26sn%3D7b3d0a61e9b034a1b55d8f8d59ed4afe%26chksm%3Df2509869c527117f573fd867f61b0fdf25b5e959dafc771465b4374a92231a2f4c99477ec216%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 队列 」</a>和<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502516%26idx%3D1%26sn%3D17ac71388fdc283a732a2cf28a830ae8%26chksm%3Df250987ec52711683b665b89de3e451f870061c0acdf535be02f1df307c59fcc7387e4da445d%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 递归 」</a>，这些要么是基础的数据结构，要么就是巧妙的编程方法。从今天起咱们来进入真正的算法阶段，看一看“排序算法”。排序算法有很多，如：「冒泡排序」、「插入排序」、「选择排序」、「希尔排序」、「堆排序」、「归并排序」、「快速排序」、「桶排序」、「计数排序」、「基数排序」等等。</p><p>下图是常用排序算法的时间空间复杂度：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8a6e1a5a639b030e20d0c459ec035c40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"556\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8a6e1a5a639b030e20d0c459ec035c40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;556&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"556\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8a6e1a5a639b030e20d0c459ec035c40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8a6e1a5a639b030e20d0c459ec035c40_b.jpg\"/></figure><p>排序算法这么多，这里先将排序算法做个简单分类：</p><ol><li><b>可以根据待排序的数据量规模分类：</b></li></ol><ul><li>内部排序：在排序过程中，待排序的数据能够被全部加载进内存中</li><li>外部排序：待排序的数据太大，不能全部同时放入内存，排序过程中需要内存与外部存储交换数据</li></ul><ol><li><b>可以根据排序的稳定性进行分类</b>：</li></ol><ul><li>稳定性排序：冒泡排序、插入排序、归并排序</li><li>不稳定排序：快速排序、选择排序、希尔排序、堆排序</li></ul><ol><li><b>可以根据排序时间复杂度分类：</b></li></ol><ul><li>O(N)：桶排序、计数排序、基数排序</li><li>O(NlogN)：快速排序、希尔排序、归并排序、堆排序</li><li>O(N*N)：冒泡排序、插入排序、选择排序</li></ul><ol><li><b>基于算法思想分类：</b></li></ol><ul><li>基于分治：快速排序、归并排序</li><li>基于插入：希尔排序、插入排序</li><li>基于选择：堆排序、选择排序</li><li>基于交换：冒泡排序、快速排序</li></ul><p>这些分类其实并没有那么严格，大多都是根据排序算法的特性总结的，不需要记住，搞懂了各种排序的特点之后也就自然而然的理解了。</p><p>这么多排序算法，我们应该怎么去评估它们呢？</p><p>一般而言，评估一个排序算法的质量主要从以下几个角度去看：</p><ul><li><b>时间复杂度：</b><br/>这是衡量算法性能的常规方法，对于排序算法当然也不例外，这也是衡量排序算法最重要的一个指标。在排序算法中常用的操作就是“比较”和“移动”元素，因此我们想优化某个排序算法的时间复杂度就是要减少去“比较”和“移动”元素的次数。<br/>同时，由于需排序的数据不同会导致即使同一个算法也有着完全不同的时间消耗，因此我们还应该进一步分析排序算法的 最好时间复杂度、最坏时间复杂度，以及平均时间复杂度，以做到对排序算法特性的充分了解。</li><li><b>空间复杂度：</b><br/>这个也是评价算法的另一个常规指标。需要分析执行算法所需要的辅助存储空间（原有数据已占用的空间不算）。如果空间复杂度为O(1)则说明执行算法的辅助存储空间为常量级别，很优秀。<br/>对于「冒泡排序」、「插入排序」、「选择排序」等排序算法的空间复杂度都是O(1)。</li><li><b>排序的稳定性：</b><br/>排序的稳定性是一个新的指标，对于排序算法来说非常的重要。<br/>通俗的来讲就是：假如在待排序的数组中有相等的元素，则经过排序之后，这些相等的元素之间的原有顺序不被改变。<br/>例如：待排序数组：1，3，6，5，6，2，9，经过从小到大的排序之后为：1，2，3，5，6，6，9<br/>在原数组里面有2个6，分别位于数组的第二个位置和第四个位置（数组从第0位开始数），在排序后这2个6分为位于数组的第四个位置和第五个位置。注意重点来了，稳定性要求就是指原来那个第二位置的6是在第四个位置的6的前面的，所以排序完成之后，这两个6的相对向后顺序不能有变，因此位于新数组第四个位置的6必须是原来旧数组的第二个位置的那个6，新数组第五个位置的6必须是旧数组时第四个位置的那个6，虽然值一样，但是还是有区别的。你要说有啥区别？那再举个例子吧：<br/>幼儿园一群小孩排队去领零食，刚开始是杂乱无章的排队的，后来老师说按照年龄大小排队，年龄小的排到前面去，这个时候就可以运用排序算法进行年龄的排序了。可是队伍中有2个同学小张和小赵年龄一样的，本来旧队伍的时候小张是排在小赵前面的，但是如果经过排序算法之后，把小张弄到了小赵的后面，这就不合理了，毕竟他们年龄一样，肯定是刚开始谁在前面就保持原样最好了，这就是体现出算法的稳定性的地方了。<br/>对排序的稳定性要求是在实际应用中非常常见。</li><li><b>算法的复杂性：</b><br/>算法本身的复杂度也会影响算法的性能（这里不是指的时间空间复杂度），这里指的算法设计思想的复杂度，后面我们在学习各种算法的时候就很清楚的看得到有的算法非常简单，有的算法设计的就比较复杂了。像「冒泡排序」、「插入排序」、「选择排序」这类都属于简单排序的算法。</li></ul><p>以上，就是对数据结构中「 排序算法 」的一些思考，下一篇就从「冒泡排序」开始聊起。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote>", 
            "topic": [
                {
                    "tag": "推荐算法", 
                    "tagLink": "https://api.zhihu.com/topics/19580544"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81952290", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "算法一看就懂之「 递归 」", 
            "content": "<p>之前的文章咱们已经聊过了<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502470%26idx%3D1%26sn%3D55ce43a4d37e55f0e5f3db709ff48324%26chksm%3Df250984cc527115afce1c763e5efc9418ba5b4a356129d491d971fc00a0b2f409288580fac85%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 数组和链表 」</a>、<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502477%26idx%3D1%26sn%3D644bb54cfc4977b6fb16a7e1eb64f14e%26chksm%3Df2509847c5271151a71b55c8fe3590aa7e51fec5d8633884f8c4e8b32284d3d3a87e23a666fa%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 堆栈 」</a>和<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502499%26idx%3D1%26sn%3D7b3d0a61e9b034a1b55d8f8d59ed4afe%26chksm%3Df2509869c527117f573fd867f61b0fdf25b5e959dafc771465b4374a92231a2f4c99477ec216%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 队列 」</a>，今天咱们来看看「 递归 」，当然「 递归 」并不是一种数据结构，它是很多算法都使用的一种编程方法。它太普遍了，并且用它来解决问题非常的优雅，但它又不是那么容易弄懂，所以我特意用一篇文章来介绍它。<br/><br/><b>一、「 递归 」是什么？</b><br/><b>递归</b> 就是指函数直接或间接的调用自己，递归是基于栈来实现的。递归的经典例子就是 <b>斐波拉契数列（Fibonacci）</b>。一般如果能用递归来实现的程序，那它也能用循环来实现。用递归来实现的话，代码看起来更清晰一些，但递归的性能并不占优势，时间复杂度甚至也会更大一些。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a90934ac1b6859cb7d115ad57afd7699_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-a90934ac1b6859cb7d115ad57afd7699_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;462&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-a90934ac1b6859cb7d115ad57afd7699_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a90934ac1b6859cb7d115ad57afd7699_b.jpg\"/></figure><p>上图为 斐波拉契数列 图例。<br/>要实现递归，必须满足2个条件：<br/></p><ol><li><b>可调用自己</b><br/>就是我们要解决的这个问题，可以通过函数调用自己的方式来解决，即可以通过将大问题分解为子问题，然后子问题再可以分解为子子问题，这样不停的分解。并且大问题与子问题/子子问题的解决思路是完全一样的，只不过数据不一样。因此这些问题都是通过某一个函数去解决的，最终我们看到的就是不停得函数调用自己，然后就把问题化解了。<br/>如果这个问题不能分解为子问题，或子问题的解决方法与大问题不一样，那就无法通过递归调用来解决。</li><li><b>可停止调用自己</b><br/>停止调用的条件非常关键，就是大问题不停的一层层分解为小问题后，最终必须有一个条件是来终止这种分解动作的（也就是停止调用自己），做递归运算一定要有这个终止条件，否则就会陷入无限循环。</li></ol><p>下面还是以 <b>斐波拉契数列（Fibonacci）</b>为例，我们来理解一下递归：<br/>斐波拉契数列就是由数字 1，1，2，3，5，8，13…… 组成的这么一组序列，特点是每位数字都是前面相邻两项之和。如果我们希望得出第N位的数字是多少？<br/></p><ol><li>可以使用<b>循环</b>的方式求解：<br/>这里就不列代码了，思路是：我们知道最基本的情况是 f(0)=0，f(1)=1，因此我们可以设置一个一个循环，循环从i=2开始，循环N-1次，在循环体内 f(i)=f(i-1)+f(i-2)，直到i=N-1，这样循环结束的时候就求出了f(N)的值了。</li><li>更优雅的方式是使用<b>递归</b>的方式求解：<br/>我们知道斐波拉契数列的逻辑就是：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33394f1147ba8f5b9427f674924067b7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"144\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;144&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"144\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic4.zhimg.com/v2-33394f1147ba8f5b9427f674924067b7_b.jpg\"/></figure><p>可以看出，这个逻辑是满足上面2个基本条件，假如求解 f(3)，那 f(3)=f(2)+f(1)，因此我们得继续去求解f(2)，而 f(2)=f(1)+f(0)，因此整个求解过程其实就在不断的分解问题的过程，将大问题f(3)，分解为f(2)和f(1)的问题，以此类推。既然可以分解成子问题，并且子问题的解决方法与大问题一致，因此这个问题是满足“可调用自己”的递归要求。<br/>同时，我们也知道应该在何时停止调用自己，即当子问题变成了f(0)和f(1)时，就不再需要往下分解了，因此也满足递归中“可停止调用自己”的这个要求。<br/>所以，斐波拉契数列问题可以采用递归的方式去编写代码，先看图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c2e98b481047ff90a89f8d733d087d99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb\" width=\"577\" data-original=\"https://pic2.zhimg.com/v2-c2e98b481047ff90a89f8d733d087d99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;577&#39; height=&#39;323&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"577\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"577\" data-original=\"https://pic2.zhimg.com/v2-c2e98b481047ff90a89f8d733d087d99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c2e98b481047ff90a89f8d733d087d99_b.jpg\"/></figure><p>我们将代码写出来：<br/>int Fb(int n){<br/> if(n&lt;=1) return n==0?0:1；<br/> return Fb(n-1)+Fb(n-2); //这里就是函数自己调用自己<br/>}<br/><br/>从上面的例子可以看出，我们写递归代码最重要的就是写2点：</p><ol><li><b>递推公式</b><br/>上面代码中，递推公式就是 Fb(n)=Fb(n-1)+Fb(n-2)，正是这个公式，才可以一步步递推下去，这也是函数自己调用自己的关键点。因此我们在写递归代码的时候最首先要做的就是思考整个逻辑中的递推公式。</li><li><b>递归停止条件</b><br/>上面代码中的停止条件很明显就是：if(n&lt;=1) return n==0?0:1；这就是递归的出口，想出了递推公司之后，就要考虑递归停止条件是啥，没有停止条件就会无限循环了，通常递归的停止条件是程序的边界值。<br/>我们对比实现斐波拉契数列问题的2种方式，可以看出递归的方式比循环的方式在程序结构上更简洁清晰，代码也更易读。但递归调用的过程中会建立函数副本，创建大量的调用栈，如果递归的数据量很大，调用层次很多，就会导致消耗大量的时间和空间，不仅性能较低，甚至会出现<b>堆栈溢出</b>的情况。<br/>我们在写递归的时候，一定要注意递归深度的问题，随时做好判断，防止出现堆栈溢出。<br/>另外，我们在思考递归逻辑的时候，没必要在大脑中将整个递推逻辑一层层的想透彻，一般人都会绕晕的。大脑很辛苦的，我们应该对它好一点。我们只需要关注当前这一层是否成立即可，至于下一层不用去关注，当前这一层逻辑成立了，下一层肯定也会成立的，最后只需要拿张纸和笔，模拟一些简单数据代入到公式中去校验一下递推公式对不对即可。</li></ol><p><b>二、「 递归 」的算法实践？</b><br/>我们看看经常涉及到 <b>递归</b> 的 <b>算法题（来源leetcode）</b>：<br/>算法题：实现 pow(x, n) ，即计算 x 的 n 次幂函数。<br/><br/>说明:<br/>    -100.0 &lt; x &lt; 100.0<br/>    n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1]<br/><br/>示例:<br/>输入: 2.00000, 10<br/>输出: 1024.00000<br/><br/>解题思路：<br/><br/>方法一：<br/>暴力解法，直接写一个循环让n个x相乘嘛，当然了这种方式就没啥技术含量了，时间复杂度O(1)，代码省略了。<br/><br/>方法二：<br/>基于递归原理，很容易就找出递推公式 f(n)=x*f(n-1)，再找出递归停止条件即n==0或1的情况就可以了。不过稍微需要注意的是，因为n的取值可以是负数，所以当n小于0的时候，就要取倒数计算。代码如下：<br/>class Solution {<br/> public double myPow(double x, int n) {<br/> if(n==0) return 1;<br/> if(n==1) return x;<br/> if(n&lt;0) return 1/(x*myPow(x,Math.abs(n)-1));<br/> return x*myPow(x,n-1);<br/>    }<br/>}<br/>这个方法其实也有问题，当n的数值过大时，会堆栈溢出的，看来也是不最佳解，继续往下看。<br/><br/>方法三：<br/>利用分治的思路，将n个x先分成左右两组，分别求每一组的值，然后再将两组的值相乘就是总值了。即 x的n次方 等于 x的n/2次方 乘以 x的n/2次方。以此类推，左右两组其实还可以分别各自继续往下分组，就是一个递推思想了。但是这里需要考虑一下当n是奇数的情况，做一个特殊处理即可，代码如下：<br/>class Solution {<br/> public double myPow(double x, int n) {<br/> //如果n是负数，则改为正数，但把x取倒数<br/> if(n&lt;0) {<br/>            n = -n;<br/>            x = 1/x;<br/>        }<br/> return pow(x,n);<br/><br/>    }<br/><br/> private double pow(double x, int n) {<br/> if(n==0) return 1;<br/> if(n==1) return x;<br/> double half = pow(x,n/2);<br/> //偶数个<br/> if(n%2==0) {<br/> return half*half;<br/>        }<br/> //奇数个<br/> return half*half*x;<br/>    }<br/>}<br/>这种方法的时间复杂度就是O(logN)了。<br/><br/>以上，就是对数据结构中「 递归 」的一些思考。</p><p><br/>码字不易啊，喜欢的话不妨转发朋友吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "Mentos", 
                    "userLink": "https://www.zhihu.com/people/402d28f1f867d049124fb6938ed2d82a", 
                    "content": "幂函数方法一时间复杂度O(1)???", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81443091", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "读「 人生护城河 」", 
            "content": "<p>如果把人看成一家公司，把人的一生看作这家公司的经营的过程。那么，你选好了你这家“公司”的商业模式了吗？你这家“公司”是否具有自己的独特优势？“公司”的商业护城河又是什么呢。<br/></p><p><b>张辉</b> 的这本<b>《人生护城河》</b>一书，买来有一段时间了，一直没时间读。上周末抽了2个小时快速读了一遍，挺有意思的，我把书中对我比较有启发的几点与大家分享一下。</p><h3><b>1、人生商业模式有哪些？</b></h3><p>如果把自己视为一家公司，那么作为公司，理论上我们就应该 有愿景、有战略、有商业模式。我们先来看看 商业模式，人生的商业模式主要分为四种，我们可以对照一下，看一下自己靠近哪一种：</p><ul><li><b>无杠杆卖时间：</b><br/>就是没有杠杆的出售自己的时间去换取金钱嘛，我们大多数人都是这种。比如公司的上班族啊，自己开的夫妻小店啊。必须要全勤的投入在里面，一份时间换取一份报酬，一旦停止自己在时间上的投入，就不会有收益了。</li><li><b>有杠杆卖时间：</b><br/>基于杠杆卖时间其实就是指将自己的一份时间出售多次。比如明星、网红、作家啊，自己录像一次、出唱片一次、写书一本，然后有很多人持续的付费（当然前提是要有人认可你的作品）。录制电影、写本书的时间其实是固定的，时间花一次就可以了，但是后续每一个去看的观众都会持续不断的进行付费。相当于一份时间卖给了很多人卖了很多份。</li><li><b>花钱买时间：</b><br/>有些人只卖自己的时间还觉得不过瘾，还会去花钱买别人的时间然后出售出去。比如 企业家，他们请雇员给他们打工，雇员给他们创造利润，这不就相当于购买了雇员的时间然后再出售了么。</li><li><b>花钱买“厉害的人”的时间：</b><br/>这种人生的商业模式就更厉害了，他们不是像上面这类雇请员工，他们是把时间和金钱投入到更厉害的人身上，让这些厉害群体去帮他赚钱。比如 风投、价值投资者。</li></ul><p>通过上面几种分类，可以看出，我们应该做一份时间能够被多次利用的事情，应该做时间边际成本递减的事情。尽量不要拿自己固定的时间去换固定的钱，这个从长远上看是不划算的。</p><h3><b>2、关注自己的成长</b></h3><p>我们在关注自己的成长方面，更应该关注自己的长处而不是短板，我们小时候经常受到“木桶原理”的教育，就是说要让我们关注自己的短板，一定要把自己的短板提高，才能容纳下更多的水。但是在现在社会，这个理论早已经行不通了，每个人都有自己的长处和短处，这个短处也必然是自己不擅长或不喜欢的地方，甚至可能是天赋决定，因此用再多的精力的去补短板也很难赶上那些本身就在这方面有优势的人，并且这种补短板效率也不高。</p><p>我们更应该关注自己的长处，应该扬长避短，尽可能的发挥自己的优势领域，而去避开那些突显自己短板的领域。自己的优势越来越明显，才会给自己越来越大的信心，才更有机会做成事。</p><p>我们在各种名人的传记中其实也可以看到，很多牛人都有自己短板的一面，只不过他们发挥的自己的长处，大家也记住了他们的优势而已。</p><p>另外，虽然大部分人努力工作、发展事业是为了收入，但是有的时候却很奇怪，你很关注收入，反正不容易赚到钱，等你把精力关注到与收入相关的其它东西上了，钱反而自然而然就来了。</p><p>所以我们衡量终身成长的维度应该可以更丰富一些：<b>见识</b>、<b>能力</b>、<b>收入</b></p><p>我们重视的优先级应该是：见识 &gt; 能力 &gt; 收入</p><p>很多例子告诉我们，先增长见识，其次能力跟上，最后收入就能在某个时刻体现出来。最怕的就是收入看起来是在涨，但见识和能力停滞，这是平庸的根本，这也是不可持续的。</p><h3><b>3、三种收入</b></h3><p>《人生护城河》一书中建议每个人都去尝试建立三种收入体系：</p><ul><li><b>本职工作收入</b><br/>这个不用多解释了，每个人的本职工作，这是大家的生存之本，这个一定要做好，如果连这个都做不好的人，其实也没必要谈其它收入了，那就是应该多考虑如何提升能力的问题了。<br/>所以本职工作一定要放在第一位，这也是我们应该花最多精力的地方，在本职工作获得成绩的情况下，再谈其它。</li><li><b>第二收入（兴趣收入）</b><br/>这个就是指自己因兴趣产生的收入。如果你的本职工作恰好也是你的兴趣所在，那就太完美了，不要再折腾别的了，努力在本职工作一项开辟出自己的事业巅峰吧。<br/>但是还是有很多人兴趣其实与本职工作不相符的，对于这类人可以在空闲时间去多培养和锻炼自己的兴趣，比如 摄影、舞蹈 等等，不要放弃，慢慢的也能从这些方面找到机会获得兴趣收入。<br/>但是很重要的一点是，第二收入在利益和时间上绝对不能与本职工作有冲突。比如做销售的自己外面再开一个小公司倒腾公司的客户，或者设计师在外面接设计项目影响自身工作时间等等，这些都是不可取的。</li><li><b>投资收入</b><br/>投资尤其是价值投资，也是每个人都应该重点关注的。不过我们应该用长期的眼光去看投资，不要看着别人炒股赚了就赶紧加入，那些注定都是被割的韭菜。找到一个有长期价值的公司，体验他们的产品，然后可以从股票市场上长期的持有他们，最终会有回报的。看看苹果公司近十年的投资回报率吧，千万不要盯着短期。炒股的“炒”和投资的“投”其实已经天然的划分了界限。</li></ul><p>以上，就是读《人生护城河》的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或关注微信公众号「 不止思考 」吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。</blockquote><p><br/> </p>", 
            "topic": [
                {
                    "tag": "人生规划", 
                    "tagLink": "https://api.zhihu.com/topics/19564504"
                }, 
                {
                    "tag": "职业规划", 
                    "tagLink": "https://api.zhihu.com/topics/19560641"
                }, 
                {
                    "tag": "程序员修养", 
                    "tagLink": "https://api.zhihu.com/topics/19573884"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81018602", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "算法一看就懂之「 队列 」", 
            "content": "<p>算法的系列文章中，之前咱们已经聊过了<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502470%26idx%3D1%26sn%3D55ce43a4d37e55f0e5f3db709ff48324%26chksm%3Df250984cc527115afce1c763e5efc9418ba5b4a356129d491d971fc00a0b2f409288580fac85%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 数组和链表 」</a>、<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502477%26idx%3D1%26sn%3D644bb54cfc4977b6fb16a7e1eb64f14e%26chksm%3Df2509847c5271151a71b55c8fe3590aa7e51fec5d8633884f8c4e8b32284d3d3a87e23a666fa%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">「 堆栈 」</a>，今天咱们再来继续看看「 队列 」这种数据结构。「 队列 」和「 堆栈 」比较类似，都属于线性表数据结构，并且都在操作上受到一定规则约束，都是非常常用的数据类型，咱们掌握得再熟练也不为过。<br/><br/><b>一、「 队列 」是什么？</b> <br/><b>队列（queue）</b>是一种先进先出的、操作受限的线性表。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-06d8b217c43f00477d95b4e1b976de20_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"166\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic1.zhimg.com/v2-06d8b217c43f00477d95b4e1b976de20_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;166&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"166\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic1.zhimg.com/v2-06d8b217c43f00477d95b4e1b976de20_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-06d8b217c43f00477d95b4e1b976de20_b.jpg\"/></figure><p>队列这种数据结构非常容易理解，就像我们平时去超市买东西，在收银台结账的时候需要排队，先去排队的就先结账出去，排在后面的就后结账，有其他人再要过来结账，必须排在队尾不能在队中间插队。<br/>「 队列 」数据结构就是这样的，先进入队列的先出去，后进入队列的后出去。<b>必须从队尾插入新元素，队列中的元素只能从队首出</b>，这也就是「 队列 」操作受限制的地方了。<br/>与堆栈类似，队列既可以用 「 数组 」 来实现，也可以用 「 链表 」 来实现。<br/>下面主要介绍一下目前用的比较多的几种「 队列 」类型：<br/></p><ul><li><b>顺序队列</b></li><li><b>链式队列</b></li><li><b>循环队列</b></li><li><b>优先队列</b></li></ul><p>下面来依次了解一下：<br/></p><ol><li>用数组实现的队列，叫做 <b>顺序队列</b>：<br/>用数组实现的思路是这样的：初始化一个长度为n的数组，创建2个变量指针front和rear，front用来标识队头的下标，而rear用来标识队尾的下标。因为队列总是从对头取元素，从队尾插入数据。因此我们在操作这个队列的时候通过移动front和rear这两个指针的指向即可。初始化的时候front和rear都指向第0个位置。<br/>当有元素需要入队的时候，首先判断一下队列是否已经满了，通过rear与n的大小比较可以进行判断，如果相等则说明队列已满（队尾没有空间了），不能再插入了。如果不相等则允许插入，将新元素赋值到数组中rear指向的位置，然后rear指针递增加一（即向后移动了一位），不停的往队列中插入元素，rear不停的移动，如图：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-05b38a395ce550102034710b5b053105_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"179\" class=\"origin_image zh-lightbox-thumb\" width=\"514\" data-original=\"https://pic2.zhimg.com/v2-05b38a395ce550102034710b5b053105_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;514&#39; height=&#39;179&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"179\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"514\" data-original=\"https://pic2.zhimg.com/v2-05b38a395ce550102034710b5b053105_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-05b38a395ce550102034710b5b053105_b.jpg\"/></figure><p>当队列装满的时候，则是如下情况：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e48c449df79a75bde07e3e9307faaaaf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"162\" class=\"origin_image zh-lightbox-thumb\" width=\"463\" data-original=\"https://pic4.zhimg.com/v2-e48c449df79a75bde07e3e9307faaaaf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;463&#39; height=&#39;162&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"162\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"463\" data-original=\"https://pic4.zhimg.com/v2-e48c449df79a75bde07e3e9307faaaaf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e48c449df79a75bde07e3e9307faaaaf_b.jpg\"/></figure><p>当需要做出队操作时，首先要判断队列是否为空，如果front指针和rear指针指向同一个位置（即front==rear）则说明队列是空的，无法做出队操作。如果队列不为空，则可以进行出队操作，将front指针所指向的元素出队，然后front指针递增加一（即向后移动了一位），加入上图的队列出队了2个元素：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-71dd4f498ff8a929cf11356f452d164f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"448\" data-rawheight=\"125\" class=\"origin_image zh-lightbox-thumb\" width=\"448\" data-original=\"https://pic4.zhimg.com/v2-71dd4f498ff8a929cf11356f452d164f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;448&#39; height=&#39;125&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"448\" data-rawheight=\"125\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"448\" data-original=\"https://pic4.zhimg.com/v2-71dd4f498ff8a929cf11356f452d164f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-71dd4f498ff8a929cf11356f452d164f_b.jpg\"/></figure><p>所以对于数组实现的队列而言，需要用2个指针来控制（front和rear），并且无论是做入队操作还是出队操作，front或rear都是往后移动，并不会往前移动。入队的时候是rear往后移动，出队的时候是front往后移动。出队和入队的时间复杂度都是O(1)的。</p><ol><li>用链表实现的队列，叫做 <b>链式队列</b>：<br/>用链表来实现也比较简单，与数组实现类似，也是需要2个指针来控制（front和rear），如图：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8dfd8a1a292072254abbec42e96f2852_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic3.zhimg.com/v2-8dfd8a1a292072254abbec42e96f2852_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic3.zhimg.com/v2-8dfd8a1a292072254abbec42e96f2852_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8dfd8a1a292072254abbec42e96f2852_b.jpg\"/></figure><p>当进行入队操作时，让新节点的Next指向rear的Next，再让rear的Next指向新节点，最后让rear指针向后移动一位（即rear指针指向新节点），如上图右边部分。<br/>当进行出队操作时，直接将front指针指向的元素出队，同时让front指向下一个节点（即将front的Next赋值给front指针），如上图左边部分。</p><ol><li><b>循环队列</b><br/>循环队列是指队列是前后连成一个圆圈，它以循环的方式去存储元素，但还是会按照队列的先进先出的原则去操作。循环队列是基于数组实现的队列，但它比普通数据实现的队列带来的好处是显而易见的，它能更有效率的利用数组空间，且不需要移动数据。<br/>普通的数组队列在经过了一段时间的入队和出队以后，尾指针rear就指向了数组的最后位置了，没法再往队列里插入数据了，但是数组的前面部分（front的前面）由于旧的数据曾经出队了，所以会空出来一些空间，这些空间就没法利用起来，如图：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p>当然可以在数组尾部已满的这种情况下，去移动数据，把数据所有的元素都往前移动以填满前面的空间，释放出尾部的空间，以便尾部还可以继续插入新元素。但是这个移动也是消耗时间复杂度的。<br/>而<b>循环队列</b>就可以天然的解决这个问题，下面是循环队列的示意图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e2d4f516d7d536a3dedb86397e28b43_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"219\" data-rawheight=\"192\" class=\"content_image\" width=\"219\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;219&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"219\" data-rawheight=\"192\" class=\"content_image lazy\" width=\"219\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e2d4f516d7d536a3dedb86397e28b43_b.jpg\"/></figure><p>循环队列也是一种线性数据结构，只不过它的最后一个位置并不是结束位。对于循环队列，头指针front始终指向队列的前面，尾指针rear始终指向队列的末尾。在最初阶段，头部和尾部的指针都是指向的相同的位置，此时队列是空的，如图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-448abbce07a0f01663da508f3934118e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"214\" data-rawheight=\"229\" class=\"content_image\" width=\"214\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;214&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"214\" data-rawheight=\"229\" class=\"content_image lazy\" width=\"214\" data-actualsrc=\"https://pic3.zhimg.com/v2-448abbce07a0f01663da508f3934118e_b.jpg\"/></figure><p>当有新元素要插入到这个循环队列的时候（入队），新元素就会被添加到队尾指针rear指向的位置（rear和tail这两个英文单词都是表示队尾指针的，不同人喜欢的叫法不一样），并且队尾指针就会递增加一，指向下一个位置，如图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-327d3c51ac9d1a9d5650a4b293a4f315_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-327d3c51ac9d1a9d5650a4b293a4f315_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;228&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"228\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-327d3c51ac9d1a9d5650a4b293a4f315_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-327d3c51ac9d1a9d5650a4b293a4f315_b.jpg\"/></figure><p>当需要做出队操作时，直接将头部指针front指向的元素进行出队（我们常用 front 或 head 英文单词来表示头部指针，凭个人喜好），并且头部指针递增加一，指向下一个位置，如图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-49a1ec24910664342527a879d4beb71b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"430\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb\" width=\"430\" data-original=\"https://pic4.zhimg.com/v2-49a1ec24910664342527a879d4beb71b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;430&#39; height=&#39;317&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"430\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"430\" data-original=\"https://pic4.zhimg.com/v2-49a1ec24910664342527a879d4beb71b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-49a1ec24910664342527a879d4beb71b_b.jpg\"/></figure><p>上图中，D1元素被出队列了，头指针head也指向了D2，不过D1元素的实际数据并没有被删除，但即使没有删除，D1元素也不属于队列中的一部分了，队列只承认队头和队尾之间的数据，其它数据并不属于队列的一部分。<br/>当继续再往队列中插入元素，当tail到达队列的尾部的时候：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-018a5cfa6d0c6fedb7793e2eaeca336d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"255\" class=\"content_image\" width=\"377\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;377&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"255\" class=\"content_image lazy\" width=\"377\" data-actualsrc=\"https://pic2.zhimg.com/v2-018a5cfa6d0c6fedb7793e2eaeca336d_b.jpg\"/></figure><p>tail的下标就有重新变成了0，此时队列已经真的满了。<br/>不过此处有个知识点需要注意，在上述队列满的情况下，其实还是有一个空间是没有存储数据的，这是循环队列的特性，只要队列不为空，那么就必须让head和tail之间至少间隔一个空闲单元，相当于浪费了一个空间吧。<br/>假如此时我们将队列中的D2、D3、D4、D5都出队，那队列就又有空间了，我们又可以继续入队，我们将D9、D10入队，状态如下：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-75907440a1dbe7a893b1ec894d127efb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"207\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;207&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"207\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic4.zhimg.com/v2-75907440a1dbe7a893b1ec894d127efb_b.jpg\"/></figure><p>此时，头指针的下标已经大于尾指针的下标了，这也是正式循环队列的特性导致的。<br/>所以可以看到，整个队列的入队和出队的过程，就是头指针head和尾指针tail互相追赶的过程，如果tail追赶上了head就说明队满了（前提是相隔一个空闲单元），如果head追赶上了tail就说明队列空了。<br/>因此循环队列中，<b>判断队列为空的条件是：head==tail</b>。<br/>判断队列为满的情况就是：tail+1=head（即tail的下一个是head，因为前面说了不为空的情况下两者之间需相隔一个单元），不过如果tail与head正好一个在队头一个在队尾（即tail=7，head=0）的时候，队列也是满的，但上述公式就不成立了，因此正确<b>判断队满的公式应该是：(tail+1)%n=head</b></p><ol><li><b>优先队列</b><br/>优先队列（priority Queue）是一种特殊的队列，它不遵守先进先出的原则，它是按照优先级出队列的。分为<b>最大优先队列</b>（是指最大的元素优先出队）和<b>最小优先队列</b>（是指最小的元素优先出队）。<br/>一般用<b>堆</b>来实现优先队列，在后面讲<b>堆</b>的文章里我会详细再讲，这里了解一下即可。</li></ol><p><b>二、「 队列 」的算法实践？</b> <br/>我们看看经常涉及到 <b>队列</b> 的 <b>算法题（来源leetcode）</b>：<br/>算法题1：使用栈实现队列的下列操作：<br/>    push(x) -- 将一个元素放入队列的尾部。<br/>    pop() -- 从队列首部移除元素。<br/>    peek() -- 返回队列首部的元素。<br/>    empty() -- 返回队列是否为空。<br/><br/>解题思路：堆栈是FILO先进后出，队列是FIFO先进先出，要使用堆栈来实现队列的功能，可以采用2个堆栈的方式。堆栈A和堆栈B，当有元素要插入的时候，就往堆栈A里插入。当要移除元素的时候，先将堆栈A里的元素依次出栈放入到堆栈B中，再从堆栈B的顶部出数据。如此便基于2个堆栈实现了先进先出的原则了。<br/><br/>class MyQueue {<br/><br/> private Stack&lt;Integer&gt; s1 = new Stack&lt;&gt;();<br/> private Stack&lt;Integer&gt; s2 = new Stack&lt;&gt;();<br/> private int fornt;<br/><br/><br/> /** Initialize your data structure here. */<br/> public MyQueue() {<br/><br/>    }<br/><br/> /** Push element x to the back of queue. */<br/> public void push(int x) {<br/> if(s1.empty()) fornt = x;<br/>        s1.push(x);<br/>    }<br/><br/> /** Removes the element from in front of queue and returns that element. */<br/> public int pop() {<br/> if(s2.empty()){<br/> while(!s1.empty()){<br/>                s2.push(s1.pop());<br/>            }<br/>        }<br/> return s2.pop();<br/>    }<br/><br/> /** Get the front element. */<br/> public int peek() {<br/> if(s2.empty()){<br/> return fornt;<br/>        }<br/> return s2.peek();<br/>    }<br/><br/> /** Returns whether the queue is empty. */<br/> public boolean empty() {<br/> return s1.empty()&amp;&amp;s2.empty();<br/>    }<br/>}   <br/><br/>入栈的时间复杂度为O(1),出栈的时间复杂度为O(1)<br/><br/><br/>算法题2：使用队列来实现堆栈的下列操作：<br/>    push(x) -- 元素 x 入栈<br/>    pop() -- 移除栈顶元素<br/>    top() -- 获取栈顶元素<br/>    empty() -- 返回栈是否为空<br/><br/>解题思路：由于需要使用FIFO的队列模拟出FILO的堆栈效果，因此需要使用2个队列来完成，队列A和队列B，当需要进行入栈操作的时候，直接往队列A中插入元素。当需要进行出栈操作的时候，先将队列A中的前n-1个元素依次出队移动到队列B中，这样队列A中剩下的最后一个元素其实就是我们所需要出栈的元素了，将这个元素出队即可。<br/><br/>class MyStack {<br/><br/> private Queue&lt;Integer&gt; q1 = new LinkedList&lt;&gt;();<br/> private Queue&lt;Integer&gt; q2 = new LinkedList&lt;&gt;();<br/> int front;<br/><br/> /** Initialize your data structure here. */<br/> public MyStack() {<br/><br/>    }<br/><br/> /** Push element x onto stack. */<br/> public void push(int x) {<br/>        q1.add(x);<br/>        front = x;<br/>    }<br/><br/> /** Removes the element on top of the stack and returns that element. */<br/> public int pop() {<br/> while(q1.size()&gt;1){<br/>            front = q1.remove();<br/>            q2.add(front);<br/>        }<br/> int val = q1.remove();<br/>        Queue&lt;Integer&gt; temp = q2;<br/>        q2 = q1;<br/>        q1 = temp;<br/> return val;<br/>    }<br/><br/> /** Get the top element. */<br/> public int top() {<br/> return front;<br/>    }<br/><br/> /** Returns whether the stack is empty. */<br/> public boolean empty() {<br/> return q1.size()==0;<br/>    }<br/>}<br/><br/>入栈的时间复杂度为O(1)，出栈的时间复杂度为O(n)<br/><br/>这道题其实还有另一个解法，只需要一个队列就可以做到模拟出堆栈，思路就是：当需要进行入栈操作的时候，先将新元素插入到队列的队尾中，再将这个队列中的其它元素依次出队，队列的特性当然是从队头出队了，但是出来的元素再让它们从队尾入队，这样依次进行，留下刚才插入的新元素不动，这个时候，这个新元素其实就被顶到了队头了，新元素入栈的动作就完成了。当需要进行出栈操作的时候，就直接将队列队头元素出队即是了。<br/>思路已经写出来了，代码的话就留给大家练习了哦。<br/><br/>以上，就是对数据结构「 队列 」的一些思考。<br/>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79435086", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 5, 
            "title": "算法一看就懂之「 堆栈 」", 
            "content": "<p>上一篇咱们聊完了数据结构中最基础的「 数组 」和「 链表 」，今天咱们再来继续看看「 堆栈 」吧，我写技术文章很少 show code，所以经常有人吐槽。好吧，这个算法系列的文章我打算每一篇的结尾处都找一道算法题写出代码示例，这总可以了吧。</p><h3><b>一、「 堆栈 」是什么？</b> </h3><p><b>堆栈（stack）</b>是一种先进后出的、操作受限的线性表，也可以直接称为 <b>栈</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f201d55c5cb3fc925ecb72ac7038d249_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"273\" class=\"content_image\" width=\"332\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;332&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"332\" data-rawheight=\"273\" class=\"content_image lazy\" width=\"332\" data-actualsrc=\"https://pic2.zhimg.com/v2-f201d55c5cb3fc925ecb72ac7038d249_b.jpg\"/></figure><p>可以把栈想象成一个桶一样，往这个桶里面一层一层的放东西，先放进去的在里面，后放进去的东西依次在外面。但取东西的时候就是先取靠近外面的，再依次一层层取里面的。这就是 后进先出（ Last In-First Out ）的原则。</p><p>因此「 栈 」虽然是线性的，有2个端：顶端和底端，但它只允许从一端进行插入和删除数据，这就是为啥前面说「 栈 」是操作受限的了。</p><p><b>栈</b>只有两种操作：Push 和 Pop 。我们用Push（压入）来表示往栈中插入数据，也叫入栈，用Pop（弹出）来表示从栈中删除数据，也叫出栈。我们可以既可以用 「 数组 」 来实现一个栈，也可以用 「 链表 」 来实现一个栈。</p><ul><li>用数组实现的栈，叫做 <b>顺序栈</b>：<br/> 顺序栈的实现非常简单，这里就不写代码了，写一下思路。先初始化一个数组，然后再用一个变量给这个数组里的元素进行计数，当有新元素需要入栈的时候，将这个新元素写入到数组的最后一个元素的后面，然后计数器加一。当需要做出栈操作时，将数组中最后一个元素返回，计数器减一。<br/> 当然在入栈前需要判断数组是否已经满了，如果数组大小等于计数器大小，则表明数组是满的。<br/> 出栈的时候也需要判断数组是不是空数组，如果计数器是0，则表明数组是空的。<br/> 从上面的实现流程可以看出，通过数组实现的栈，其入栈和出栈都是对单个元素进行操作，因此其入栈和出栈的时间复杂度都是O(1)，并且其入栈和出栈操作并没有额外开销更多空间，因此其空间复杂度也是O(1)的。</li><li>用链表实现的栈，叫做 <b>链式栈</b>：<br/> 实现思路是先定义一个链表节点的类，基于这个类去定义一个头节点Head。当有新元素需要入栈的时候，将这个新元素的Next指针指向头结点Head的Next节点，然后再将Head的Next指向这个新节点。当需要做出栈操作时，直接将Head所指向的节点返回，同时让Head指向下一个节点。<br/> 当然，在入栈和出栈时都需要判断链表是否为空的情况。<br/> 链式栈的入栈和出栈都是在处理头部节点，所以操作很简单，其时间和空间复杂度均为O(1)。</li></ul><h3><b>二、「 堆栈 」的算法实践？</b> </h3><p>我们来看一个基于用 <b>栈</b> 来完成的 <b>算法题（来源leetcode）</b>：</p><div class=\"highlight\"><pre><code class=\"language-text\">算法题：给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&#39; 的字符串，判断字符串是否有效。\n有效字符串需满足：\n    左括号必须用相同类型的右括号闭合。\n    左括号必须以正确的顺序闭合。\n\n举例：字符串 &#34;()&#34;有效、&#34;()[]{}&#34;有效、&#34;(]&#34;无效、&#34;([)]&#34;无效、&#34;{[]}&#34;有效。\n\n解题思路：\n使用1个堆栈即可解决，依次遍历这个字符串，如果遇到是左括号就入栈到堆栈中，如果遇到的是右括号，则从堆栈中取出栈顶的第一个左括号，比对一下这个左括号和当前遇到的右括号是否匹配，如果不匹配这认为这整个字符串无效。如果能匹配，则OK，删除这个左括号和右括号，继续往后走，继续遍历字符串中剩下的字符，只要遇到左括号就入栈，只要遇到右括号就与将栈顶的左括号出栈与之比较。一直走到字符串结束，再来检查堆栈中是否还有元素，如果还有元素，则这个字符串同样无效，如果堆栈为空，则字符串有效。\n\n就以这个思路实现一个初版代码：\nclass Solution {\n    public boolean isValid(String s) {\n        Stack&lt;Character&gt; satck = new Stack&lt;Character&gt;();\n        for(int i=0; i&lt;s.length();i++){\n            char c = s.charAt(i);\n            if(c==&#39;(&#39; || c==&#39;{&#39; || c==&#39;[&#39;){\n                satck.push(c);\n            }else{\n                if(satck.isEmpty()) return false;\n                char temp = satck.pop();\n                if( (temp==&#39;(&#39;&amp;&amp;c==&#39;)&#39;) || (temp==&#39;{&#39;&amp;&amp;c==&#39;}&#39;)  || (temp==&#39;[&#39;&amp;&amp;c==&#39;]&#39;) ){\n                    continue;\n                }else{\n                    return false;\n                }\n            }\n        }\n        return satck.isEmpty();\n    }\n}\n这个代码的时间复杂度o(n),空间复杂度o(n)搞定。\n\n但是想了想，好像代码不是很优雅，写了一个优化版，提前将左右括号放入到MAP中，这个方法的时间和空间复杂度跟上面的一样。\nclass Solution {\n    public boolean isValid(String s) {\n      Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();\n      HashMap&lt;Character,Character&gt; map = new HashMap&lt;Character,Character&gt;();\n      map.put(&#39;(&#39;, &#39;)&#39;);\n      map.put(&#39;{&#39;,&#39;}&#39; );\n      map.put(&#39;[&#39;, &#39;]&#39;);\n\n      for(int i=0;i&lt;s.length();i++){\n        char c = s.charAt(i);\n        if(map.containsKey(c)){\n          stack.push(c);\n        }else{\n          if(stack.isEmpty()) return false;\n          char temp = stack.pop();\n          if(map.get(temp)!=c) return false;\n        }\n      } \n      return stack.isEmpty();\n    }\n}\n\n继续思考有没有更简洁的方法，竟然在leetcode上找到了一个：\n但是这个方法并没有用到堆栈哦，它的思路是不断的遍历这个字符串，将字符串中的(){}[]全部调换成空字符串，如果最后全部替换完成了，并且字符串为空了，就说明字符串是有效的，否者就是无效的字符串。\nclass Solution {\n    public boolean isValid(String s) {\n      int length = s.length();\n      do{\n        length = s.length();\n        s = s.replaceAll(&#34;\\\\(\\\\)&#34;,&#34;&#34;).replaceAll(&#34;\\\\{\\\\}&#34;,&#34;&#34;).replaceAll(&#34;\\\\[\\\\]&#34;,&#34;&#34;);\n      }while(s.length()!=length);\n      return s.length()==0;\n    }\n}\n不过这个方法的时间复杂度要高一些。\n</code></pre></div><p>以上，就是对数据结构中「 堆栈 」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote> 本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "栈（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20183311"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78094287", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 7, 
            "title": "算法一看就懂之「 数组与链表 」", 
            "content": "<p>数据结构是我们软件开发中最基础的部分了，它体现着我们编程的内功。大多数人在正儿八经学习数据结构的时候估计是在大学计算机课上，而在实际项目开发中，反而感觉到用得不多。<br/><br/>其实也不是真的用得少，只不过我们在使用的时候被很多高级语言和框架组件封装好了，真正需要自己去实现的地方比较少而已。但别人封装好了不代表我们就可以不关注了，数据结构作为程序员的内功心法，是非常值得我们多花时间去研究的，我这就翻开书复习复习：<br/>本文就先从大家最经常使用的「 数组 」和「 链表 」聊起。不过在聊数组和链表之前，咱们先看一下数据的逻辑结构分类。通俗的讲，数据的逻辑结构主要分为两种：<br/></p><ul><li><b>线性的：</b>就是连成一条线的结构，本文要讲的数组和链表就属于这一类，另外还有 队列、栈 等</li><li><b>非线性的：</b>顾名思义，数据之间的关系是非线性的，比如 堆、树、图 等</li></ul><p>知道了分类，下面我们来详细看一下「 数组 」和「 链表 」的原理。<br/><b>一、「 数组 」是什么？</b><br/><b>数组</b>是一个有限的、类型相同的数据的集合，在内存中是一段连续的内存区域。<br/>如下图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cf71741f672150857da2f622ffa4f121_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"711\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb\" width=\"711\" data-original=\"https://pic2.zhimg.com/v2-cf71741f672150857da2f622ffa4f121_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;711&#39; height=&#39;432&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"711\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"711\" data-original=\"https://pic2.zhimg.com/v2-cf71741f672150857da2f622ffa4f121_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cf71741f672150857da2f622ffa4f121_b.jpg\"/></figure><p>数组的下标是从0开始的，上图数组中有6个元素，对应着下标依次是0、1、2、3、4、5，同时，数组里面存的数据的类型必须是一致的，比如上图中存的都是数字类型。数组中的全部元素是“连续”的存储在一块内存空间中的，如上图右边部分，元素与元素之间是不会有别的存储隔离的。另外，也是因为数组需要连续的内存空间，所以数组在定义的时候就需要提前指定固定大小，不能改变。<br/></p><ul><li><b>数组的访问：</b><br/>数组在访问操作方面有着独特的性能优势，因为<b>数组是支持随机访问的</b>，也就是说我们可以通过下标随机访问数组中任何一个元素，其原理是因为数组元素的存储是连续的，所以我们可以通过数组内存空间的首地址加上元素的偏移量计算出某一个元素的内存地址，如下：<br/>array[n]的地址 =  array数组内存空间的首地址 + 每个元素大小*n<br/><br/>通过上述公式可知：数组中通过下标去访问数据时并不需要遍历整个数组，因此<b>数组的访问时间复杂度是 O(1)</b>，当然这里需要注意，如果不是通过下标去访问，而是通过内容去查找数组中的元素，则时间复杂度不是O(1)，极端的情况下需要遍历整个数组的元素，时间复杂度可能是O(n)，当然通过不同的查找算法所需的时间复杂度是不一样的。</li><li><b>数组的插入与删除：</b><br/>同样是因为数组元素的连续性要求，所以导致数组在插入和删除元素的时候效率比较低。<br/>如果要在数组中间插入一个新元素，就必须要将要相邻的后面的元素全部往后移动一个位置，留出空位给这个新元素。还是拿上面那图举例，如果需要在下标为2的地方插入一个新元素11，那就需要将原有的2、3、4、5几个下标的元素依次往后移动一位，新元素再插入下标为2的位置，最后形成新的数组是：<br/>23、4、11、6、15、5、7<br/><br/>如果新元素是插入在数组的最开头位置，那整个原始数组都需要向后移动一位，此时的时间复杂度为最坏情况即O(n)，如果新元素要插入的位置是最末尾，则无需其它元素移动，则此时时间复杂度为最好情况即O(1)，所以平均而言<b>数组插入的时间复杂度是O(n)</b><br/>数组的删除与数组的插入是类似的。</li></ul><p>所以整体而言，数组的访问效率高，插入与删除效率低。不过想改善数组的插入与删除效率也是有办法的，来来来，下面的「 链表 」了解一下。<br/><b>二、「 链表 」是什么？</b><br/><b>链表</b>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，一般用于插入与删除较为频繁的场景。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-558a1a1aae217f77e9499e7874a9e0f2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb\" width=\"721\" data-original=\"https://pic3.zhimg.com/v2-558a1a1aae217f77e9499e7874a9e0f2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;721&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"148\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"721\" data-original=\"https://pic3.zhimg.com/v2-558a1a1aae217f77e9499e7874a9e0f2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-558a1a1aae217f77e9499e7874a9e0f2_b.jpg\"/></figure><p>上图是“单链表”示例，链表并不需要数组那样的连续空间，它只需要一个个零散的内存空间即可，因此对内存空间的要求也比数组低。<br/>链表的每一个节点通过“指针”链接起来，每一个节点有2部分组成，一部分是数据（上图中的Data），另一部分是后继指针（用来存储后一个节点的地址），在这条链中，最开始的节点称为Head，最末尾节点的指针指向NULL。<br/>「 链表 」也分为好几种，上图是最简单的一种，它的每一个节点只有一个指针（后继指针）指向后面一个节点，这个链表称为：<b>单向链表</b>，除此之外还有 双向链表、循环链表 等。<br/><b>双向链表：</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8836bfa977916a3fa28b8cc06ad6b0d2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb\" width=\"628\" data-original=\"https://pic3.zhimg.com/v2-8836bfa977916a3fa28b8cc06ad6b0d2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;628&#39; height=&#39;140&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"140\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"628\" data-original=\"https://pic3.zhimg.com/v2-8836bfa977916a3fa28b8cc06ad6b0d2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8836bfa977916a3fa28b8cc06ad6b0d2_b.jpg\"/></figure><p>双向链表与单向链表的区别是前者是2个方向都有指针，后者只有1个方向的指针。双向链表的每一个节点都有2个指针，一个指向前节点，一个指向后节点。双向链表在操作的时候比单向链表的效率要高很多，但是由于多一个指针空间，所以占用内存也会多一点。<br/><b>循环链表：</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7baeafce887780e5cbeee83234808630_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"487\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb\" width=\"487\" data-original=\"https://pic1.zhimg.com/v2-7baeafce887780e5cbeee83234808630_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;487&#39; height=&#39;114&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"487\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"487\" data-original=\"https://pic1.zhimg.com/v2-7baeafce887780e5cbeee83234808630_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7baeafce887780e5cbeee83234808630_b.jpg\"/></figure><p>其实循环链表就是一种特殊的单向链表，只不过在单向链表的基础上，将尾节点的指针指向了Head节点，使之首尾相连。<br/></p><ul><li><b>链表的访问</b><br/>链表的优势并不在与访问，因为链表无法通过首地址和下标去计算出某一个节点的地址，所以链表中如果要查找某个节点，则需要一个节点一个节点的遍历，因此<b>链表的访问时间复杂度为O(n)</b></li><li><b>链表的插入与删除</b><br/>也正式因为链表内存空间是非连续的，所以它对元素的插入和删除时，并不需要像数组那样移动其它元素，只需要修改指针的指向即可。<br/>例如：删除一个元素E：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0df6f1a5fd408ef8a2ba2f9daba63c88_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-0df6f1a5fd408ef8a2ba2f9daba63c88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-0df6f1a5fd408ef8a2ba2f9daba63c88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0df6f1a5fd408ef8a2ba2f9daba63c88_b.jpg\"/></figure><p>例如：插入一个元素：<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0a3a3a95277914e3f55cb6886f0dedd1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic2.zhimg.com/v2-0a3a3a95277914e3f55cb6886f0dedd1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;173&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic2.zhimg.com/v2-0a3a3a95277914e3f55cb6886f0dedd1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0a3a3a95277914e3f55cb6886f0dedd1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>既然插入与删除元素只需要改动指针，无需移动数据，那么<b>链表的时间插入删除的时间复杂度为O(1)</b>不过这里指的是找到节点之后纯粹的插入或删除动作所需的时间复杂度。<br/>如果当前还未定位到指定的节点，只是拿到链表的Head，这个时候要去删除此链表中某个固定内容的节点，则需要先查找到那个节点，这个查找的动作又是一个遍历动作了，这个遍历查找的时间复杂度却是O(n)，两者加起来总的时间复杂度其实是O(n)的。<br/>其实就算是已经定位到了某个要删除的节点了，删除逻辑也不简单。以“删除上图的E节点”为例，假如当前链表指针已经定位到了E节点，删除的时候，需要将这个E节点的前面一个节点H的后继指针改为指向A节点，那么E节点就会自动脱落了，但是当前链表指针是定位在E节点上，如何去改变H节点的后续指针呢，对于“单向链表”而言，这个时候需要从头遍历一遍整个链表，找到H节点去修改其后继指针的内容，所以时间复杂度是O(n)，但如果当前是“双向链表”，则不需要遍历，直接通过前继指针即可找到H节点，时间复杂度是O(1)，这里就是“双向链表”相当于“单向链表”的优势所在。<br/><b>三、「 数组和链表 」的算法实战？</b><br/>通过上面的介绍我们可以看到「 数组 」和「 链表 」各有优势，并且时间复杂度在不同的操作情况下也不相同，不能简单一句O(1)或O(n)。所以下面我们找了个常用的算法题来练习练习。<br/>算法题：反转一个单链表<br/>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br/>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL<br/><br/>/**<br/> * Definition for singly-linked list.<br/> * public class ListNode {<br/> *     int val;<br/> *     ListNode next;<br/> *     ListNode(int x) { val = x; }<br/> * }<br/> */<br/>class Solution {<br/> public ListNode reverseList(ListNode head) {<br/> //定义一个前置节点变量，默认是null，因为对于第一个节点而言没有前置节点<br/>        ListNode pre = null;<br/> //定义一个当前节点变量，首先将头节点赋值给它<br/>        ListNode curr = head;<br/> //遍历整个链表，直到当前指向的节点为空，也就是最后一个节点了<br/> while(curr != null){<br/> //在循环体里会去改变当前节点的指针方向，本来当前节点的指针是指向的下一个节点，现在需要改为指向前一个节点，但是如果直接就这么修改了，那链条就断了，再也找不到后面的节点了，所以首先需要将下一个节点先临时保存起来，赋值到temp中，以备后续使用<br/>            ListNode temp = curr.next;<br/> //开始处理当前节点，将当前节点的指针指向前面一个节点<br/>            curr.next = pre;<br/> //将当前节点赋值给变量pre，也就是让pre移动一步，pre指向了当前节点<br/>            pre = curr;<br/> //将之前保存的临时节点（后面一个节点）赋值给当前节点变量<br/>            curr = temp;<br/> //循环体执行链表状态变更情况：<br/> //NULL&lt;-1  2-&gt;3-&gt;4-&gt;5-&gt;NULL<br/> //NULL&lt;-1&lt;-2  3-&gt;4-&gt;5-&gt;NULL<br/> //NULL&lt;-1&lt;-2&lt;-3  4-&gt;5-&gt;NULL<br/> //NULL&lt;-1&lt;-2&lt;-3&lt;-4  5-&gt;NULL<br/> //NULL&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5<br/> //循环体遍历完之后，pre指向5的节点<br/>        }<br/> //完成，时间复杂度为O(n)<br/> return pre;<br/>    }<br/>}<br/><br/>以上，就是对「 数组与链表 」的一些思考。<br/>码字不易啊，喜欢的话不妨转发朋友吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78028215", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "「 牛逼的程序员 」+「 会写作 」= ？", 
            "content": "<p>一个代码敲得很6的程序员，再加上「 会写作 」，会产生什么效果？<br/><br/>我在之前的文章中分享过一个观点，咱们程序员除了代码之外，还必须得会营销自己，建立个人的影响力。</p><p><br/>但是说归说，道理很容易理解，可是并非每个人都擅长营销啊（包括我自己）。作为码农的天性，我就喜欢与计算机对话，习惯于对着显示器码代码。如果让我到处找人吹嘘侃大山营销自己，内心是抗拒的啊。</p><p><br/>那怎么办？还有没有别的办法可以帮助咱们码农建立影响力、形成个人品牌呢？<br/>有，那就是「 写作 」。</p><p><br/>最近看到大V <b>粥左罗</b> 出了本新书<b>《学会写作》</b>，我赶紧买来研读了一番，结论是：非常受益，更坚定了我写作的信心。因此，我决定跟大家分享一下对本书学习的体会，看看咱们程序员如何借助写作实现自我进阶。</p><p><br/><b>一、程序员去写作有哪些好处？</b><br/>我们先来看看作为程序员，写作有哪些好处：<br/></p><ul><li><b>可以通过写作倒逼自己去学习</b></li><li><b>可以通过写作训练自己的沟通表达能力</b></li><li><b>可以通过写作展示技能/建立影响力</b></li></ul><p>下面来分别解释一下：<br/></p><ol><li><b>可以通过写作倒逼自己去学习</b><br/>「 写作 」这件事的首要条件就是你自己得有货。无论你是写技术文章、还是写职业经验，不管什么内容，你都得自己先搞懂了，才能写出来告诉别人。<br/>如果仅是写一两篇文章，其实还好，凭着自己过去的经验和积累，相信都能写出来。但是如果是打算长期持续的写，那仅凭过去的积累肯定不行，就必须得持续的去学习，学习新的东西，弄懂搞透彻之后，再结合自己的思考，以写作的形式分享给大家。<br/>也就是说，得有持续的输入才会持续的输出。输入就是自己去学习新的知识，输出就是写文章。<br/>并且写作会逼着在咱们去深度的思考、吸收和输出知识，可以极大的提高咱们的学习效果。<br/>因此，写作 是一种倒逼自己去学习的极佳方法。</li><li><b>可以通过写作训练自己的沟通表达能力</b><br/>作为程序员，由于平时主要是与计算机打交道，所以很多人在沟通表达方面就会有所欠缺。<br/>而写作其实就是一种沟通，通过写作可以锻炼我们的文字表达能力。现在现代社交中，大家经常需要写邮件汇报工作、写PPT展示成果、在微信上发消息去交流，这些都离不开文字表达，此时的文字表达能力也就体现了咱们的沟通能力。<br/>公开写作就相当于面向所有人去表达自己的思想，有些人还会进行评论互动，通过这种方式持续的去训练，自己的表达能力也会越来越进步。</li><li><b>可以通过写作展示技能/建立影响力</b><br/>「 你的代码写的很6 」和「 别人都知道你的代码写的很6 」这完全是两码事。作为程序员，很多人都有自己特别擅长或具有优势的技术方向，那么我们就应该让大家都知道咱们具有这个能力。<br/>我们可以把技术知识、研究成果 或者 开发思路 通过文字的形式记录下来，与大家分享、交流。<br/>这样，就相当于通过写作把自己的技术优势充分的展示出来了，这也是程序员建立个人品牌的最佳方法。</li></ol><p><b>二、程序员应该如何去写作？</b><br/>作为程序员，咱们应该怎么样去写作呢，<b>《学会写作》</b>一书中讲到了几点非常好，可以借鉴一下：</p><ol><li><b>不要在意写得好不好，重点是立即动手写</b><br/>很多人认可了写作这件事，但是却迟迟不肯动手，总担心自己写不好，总希望准备充分了再开始写。<br/>其实一开始写，写不好是正常现象，写得好才奇怪了。不要在意别人的眼光，现代社会大家都很忙，没时间笑话你。<br/>对于写作，最重要的就是立马动手写，文章总是从第一行开始的，写了一行就能写一段，写了一段就能写一篇。不要有完美主义，好文笔是练出来的，好文章是修改出来的。</li><li><b>找出写作内容的定位</b><br/>不过在开始写作之前，咱们得给自己的文章确定一个定位，是打算写技术方向呢，还是写职场方向，甚至是写自己的业余爱好都可以，但是最好有一个明确的方向，这样你的受众也才集中。不然方向太分散，每个方向都写一点，最终不仅不容写好，而且读者也看得很懵。</li><li><b>输入、思考、输出</b><br/>前面提到了，咱们必须有输入（获取知识），然后才会有输出（写作）。这里不仅需要我们经常去读书、学习，其中还有一个非常关键的环节就是要「 思考 」。要对输入的东西有自己的思考，经过消化之后，有自己的观点，再把观点输出出来。输入是前提，思考是本质，输出是结果，这样的内容对读者才是有价值的。</li><li><b>公开写作，借助外部激励，驱动自己坚持下去</b><br/>咱们写作必须要公开，而不是私密的。人都是有惰性的，如果写的东西仅自己可以看，可能就会写的很随意。如果一旦写的东西是要公开的，就会有社交压力，写的东西就会比较注意一些了。所以我们需要借助外部的压力，来提高自己的写作标准。<br/>同时，因为是公开的，所以别人看到可能会点评，因此我们也可以从反馈中知道自己写的好不好，应该如何改进。如果有人称赞，对我们来说也是一种激励，可以驱动着自己长期坚持写下去。</li><li><b>要写对读者有价值的内容</b><br/>咱们写的东西不能只顾着自己写的开心，更重要的是内容得具备价值，对读者有真正的帮助。所以写作的内容要么是教会别人一项技术点、要么能够提供新的知识，要么能够产出新的视角。因为咱们写作的每一篇文章都必须是有目的的，咱们的目的就是让读者有收获，让读者认可我们的观点，最终才能帮助我们建立起个人影响力。</li><li><b>让写作成为习惯</b><br/>写作必须是持续，不能三天打鱼两天晒网，当然我们可以给自己定一个规律，每周写一篇或者几篇，让写作成为我们生活的一个好习惯。</li></ol><p>所以，这里，可以回答最开始的提问了，「 牛逼的程序员 」+「 会写作 」=「 有影响力的技术大神 」。<br/>以上，就是读《学会写作》的一些思考。看完之后，你觉得程序员写作有意义吗？<br/>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊<br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。 </p><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "写作", 
                    "tagLink": "https://api.zhihu.com/topics/19552516"
                }
            ], 
            "comments": [
                {
                    "userName": "胡博", 
                    "userLink": "https://www.zhihu.com/people/6cca2a0e50c1a2289023f7f46982a706", 
                    "content": "等着最后卖课广告，居然没有。良心赞", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "黑客与作家", 
                    "userLink": "https://www.zhihu.com/people/6f438ac62a03ac7a2e461f066da82d56", 
                    "content": "<p>哈哈，我的追求，黑客与作家</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73127004", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 8, 
            "title": "微服务架构之「 容器技术 」", 
            "content": "<p>现在一聊到容器技术，大家就默认是指 Docker 了。但事实上，在 Docker 出现之前，PaaS社区早就有容器技术了，以 Cloud Foundry、OpenShift 为代表的就是当时的主流。<br/></p><p>那为啥最终还是 Docker  火起来了呢？</p><p>因为传统的PaaS技术虽然也可以一键将本地应用部署到云上，并且也是采用隔离环境（容器）的形式去部署，但是其兼容性非常的不好。因为其主要原理就是将本地应用程序和启停脚本一同打包，然后上传到云服务器上，然后再在云服务器里通过脚本启动这个应用程序。</p><p>这样的做法，看起来很理想。但是在实际情况下，由于本地与云端的环境差异，导致上传到云端的应用经常各种报错、运行不起来，需要各种修改配置和参数来做兼容。甚至在项目迭代过程中不同的版本代码都需要重新去做适配，非常耗费精力。</p><p>然而 Docker  却通过一个小创新完美的解决了这个问题。在 Docker 的方案中，它不仅打包了本地应用程序，而且还将本地环境（操作系统的一部分）也打包了，组成一个叫做「 Docker镜像 」的文件包。所以这个「 Docker镜像 」就包含了应用运行所需的全部依赖，我们可以直接基于这个「 Docker镜像 」在本地进行开发与测试，完成之后，再直接将这个「 Docker镜像 」一键上传到云端运行即可。</p><p>Docker 实现了本地与云端的环境完全一致，做到了真正的一次开发随处运行。</p><h3><b>一、容器到底是什么？</b></h3><p>容器到底是什么呢？也许对于容器不太了解，但我们对虚拟机熟悉啊，那么我们就先来看一下容器与虚拟机的对比区别：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ea5a8348d2999beefe40613f6fd06c4b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-ea5a8348d2999beefe40613f6fd06c4b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;960&#39; height=&#39;592&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"960\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"960\" data-original=\"https://pic4.zhimg.com/v2-ea5a8348d2999beefe40613f6fd06c4b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ea5a8348d2999beefe40613f6fd06c4b_b.jpg\"/></figure><p>上图的左侧是虚拟机的原理，右侧是Docker容器的原理。</p><p>虚拟机是在宿主机上基于 Hypervisor 软件虚拟出一套操作系统所需的硬件设备，再在这些虚拟硬件上安装操作系统 Guest OS，然后不同的应用程序就可以运行在不同的 Guest OS 上，应用之间也就相互独立、资源隔离了，但是由于需要 Hypervisor 来创建虚拟机，且每个虚拟机里需要完整的运行一套操作系统 Guest OS，因此这个方式会带来很多额外资源的开销。</p><p>而 Docker容器 中却没有 Hypervisor 这一层，虽然它需要在宿主机中运行 Docker Engine，但它的原理却完全不同于 Hypervisor，它并没有虚拟出硬件设备，更没有独立部署全套的操作系统 Guest OS。</p><p>Docker容器没有那么复杂的实现原理，它其实就是一个普通进程而已，只不过它是一种经过特殊处理过的普通进程。</p><p>我们启动容器的时候（docker run …），Docker Engine 只不过是启动了一个进程，这个进程就运行着我们容器里的应用。但 Docker Engine 对这个进程做了一些特殊处理，通过这些特殊处理之后，这个进程所看到的外部环境就不再是宿主机的那个环境了（它看不到宿主机中的其它进程了，以为自己是当前操作系统唯一一个进程），并且 Docker Engine 还对这个进程所使用得资源进行了限制，防止它对宿主机资源的无限使用。</p><p>那 Docker Engine 具体是做了哪些特殊处理才有这么神奇的效果呢？</p><h3><b>二、容器是如何做到资源隔离和限制的？</b></h3><p>Docker容器对这个进程的隔离主要采用2个技术点：</p><ul><li><b>Namespace 技术</b></li><li><b>Cgroups 技术</b></li></ul><p>弄清楚了这两个技术点对理解容器的原理非常重要，它们是容器技术的核心。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dcb010eb17676773b17fda4294f060d3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"547\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-dcb010eb17676773b17fda4294f060d3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;547&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"547\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-dcb010eb17676773b17fda4294f060d3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-dcb010eb17676773b17fda4294f060d3_b.jpg\"/></figure><p>下面来详细解释一下：</p><ol><li><b>Namespace 技术</b><br/>Namespace 并不是一个什么新技术，它是Linux操作系统默认提供的API，包括 PID Namespace、Mount Namespace、IPC Namespace、Network Namespace等等。<br/>以 PID Namespace 举例，它的功能是可以让我们在创建进程的时候，告诉Linux系统，我们要创建的进程需要一个新的独立的进程空间，并且这个进程在这个新的进程空间里的PID=1，也就是说这个进程只看得到这个新进程空间里的东西，看不到外面宿主机环境里的东西，也看不到其它进程（不过这只是一个虚拟空间，事实上这个进程在宿主机里PID该是啥还是啥，没有变化，只不过在这个进程空间里，该进程以为自己的PID=1）。<br/>打个比方，就像是一个班级，每个人在这个班里都有一个编号，班里有90人，然后来了一位新同学，那他在班里的编号就是91，可是老师为了给这位同学特别照顾，所以在班里开辟了一块独立的看不到外面的小隔间，并告诉这个同学他的编号是1，由于这位同学在这个小空间里隔离着，所以他真的以为自己就是班上的第一位同学且编号为1，当然了，事实上这位同学在班上的编号依然是91。<br/>另外，Network Namespace 的技术原理也是类似的，让这个进程只能看到当前Namespace空间里的网络设备，看不到宿主机真实情况。同理，其它 Mount、IPC等 Namespace 也是这样。<br/>Namespace 技术其实就是修改了应用进程的视觉范围，但应用进程的本质却没有变化。<br/>不过，Docker容器里虽然带有一部分操作系统（文件系统相关），但它并没有内核，因此多个容器之间是共用宿主机的操作系统内核的。这一点与虚拟机的原理是完全不一样的。</li><li><b>Cgroups 技术</b><br/>Cgroup 全称是 Control Group，其功能就是限制进程组所使用的最大资源（这些资源可以是 CPU、内存、磁盘等等）。<br/>既然 Namespace 技术 只能改变一下进程组的视觉范围，并不能真实的对资源做出限制。那么为了防止容器（进程）之间互相抢资源，甚至某个容器把宿主机资源全部用完导致其它容器也宕掉的情况发生。因此，必须采用 Cgroup 技术对容器的资源进行限制。<br/>Cgroup 技术也是Linux默认提供的功能，在Linux系统的 /sys/fs/cgroup 下面有一些子目录 cpu、memory等，Cgroup技术提供的功能就是可以基于这些目录实现对这些资源进行限制。<br/>例如：在 /sys/fs/cgroup/cpu 下面创建一个 dockerContainer 子目录，系统就会自动在这个新建的目录下面生成一些配置文件，这些配置文件就是用来控制资源使用量的。例如可以在这些配置文件里面设置某个进程ID对CPU的最大使用率。<br/>Cgroup 对其它内存、磁盘等资源也是采用同样原理做限制。</li></ol><h3><b>三、容器的镜像是什么？</b></h3><p>一个基础的容器镜像其实就是一个 rootfs，它包含操作系统的文件系统（文件和目录），但并不包含操作系统的内核。</p><p>rootfs 是在容器里根目录上挂载的一个全新的文件系统，此文件系统与宿主机的文件系统无关，是一个完全独立的，用于给容器进行提供环境的文件系统。</p><p>对于一个Docker容器而言，需要基于 pivot_root 指令，将容器内的系统根目录切换到rootfs上，这样，有了这个 rootfs，容器就能够为进程构建出一个完整的文件系统，且实现了与宿主机的环境隔离，也正是有了rootfs，才能实现基于容器的本地应用与云端应用运行环境的一致。</p><p>另外，为了方便镜像的复用，Docker 在镜像中引入了层（Layer）的概念，可以将不同的镜像一层一层的迭在一起。这样，如果我们要做一个新的镜像，就可以基于之前已经做好的某个镜像的基础上继续做。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fc52df1f7ed77d4a3f1022d39d3873a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"681\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb\" width=\"681\" data-original=\"https://pic4.zhimg.com/v2-fc52df1f7ed77d4a3f1022d39d3873a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;681&#39; height=&#39;538&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"681\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"681\" data-original=\"https://pic4.zhimg.com/v2-fc52df1f7ed77d4a3f1022d39d3873a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fc52df1f7ed77d4a3f1022d39d3873a3_b.jpg\"/></figure><p>如上图，这个例子中最底层是操作系统引导，往上一层就是基础镜像层（Linux的文件系统），再往上就是我们需要的各种应用镜像，Docker 会把这些镜像联合挂载在一个挂载点上，这些镜像层都是只读的。只有最上面的容器层是可读可写的。</p><p>这种分层的方案其实是基于 联合文件系统UnionFS（Union File System）的技术实现的。它可以将不同的目录全部挂载在同一个目录下。举个例子，假如有文件夹 test1 和 test2 ，这两个文件夹里面的文件 有相同的，也有不同的。然后我们可以采用联合挂载的方式，将这两个文件夹挂载到 test3 上，那么 test3 目录里就有了 test1 和 test2 的所有文件（相同的文件有去重，不同的文件都保留）。</p><p>这个原理应用在Docker镜像中，比如有2个同学，同学A已经做好了一个基于Linux的Java环境的镜像，同学S想搭建一个Java Web环境，那么他就不必再去做Java环境的镜像了，可以直接基于同学A的镜像在上面增加Tomcat后生成新镜像即可。</p><p>以上，就是对微服务架构之「 容器技术 」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 <br/> </blockquote>", 
            "topic": [
                {
                    "tag": "Docker", 
                    "tagLink": "https://api.zhihu.com/topics/19950993"
                }, 
                {
                    "tag": "容器虚拟化", 
                    "tagLink": "https://api.zhihu.com/topics/20046238"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72971321", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "Facebook也炒币吗？Libra币是什么？", 
            "content": "<p>Facebook 在上周发布了加密数字货币，称为 Libra币。<br/></p><p>太火爆了，很多人都在关注和讨论，包括一些科技大佬们都很积极的讨论（当然，这里指的是真正的科技大佬，比如 马化腾、王兴等，而不是指哪些割韭菜的币圈大佬）。</p><p>我也熬夜凑个热闹，给好奇的小白们聊一聊（虽然我也不是专业班子，但好歹我之前也写过区块链文章啊，哈哈，得继续假装很了解）。</p><h3><b>1. Libra 是什么？</b></h3><p>Libra 是由 Facebook 发起的一种 加密数字货币。<br/></p><h3><b>2. 除了 Libra 外，还有别的什么数字货币吗？</b></h3><p>有，最出名的数字货币就是 比特币 了，它可称之为数字货币的鼻祖。</p><h3><b>3. 数字货币是基于什么技术实现的？</b></h3><p>目前的数字货币（比特币、以太坊、Libra等）都是基于 区块链技术，但各自实现方式又有很大不同。</p><p>目前Libra算是联盟链，未来可能发展成公共链。</p><h3><b>4. 区块链有什么特点？</b></h3><p>去中心化、共识机制、防纂改</p><h3><b>5. Facebook 为啥要发起 Libra？</b></h3><p>希望能能创造一种新型的全球化货币，用来解决在 经济全球化 的大背景下，传统货币的流通问题。</p><p>各个国家之间的法币（法定货币），在国与国之间流通极为不方便，并且汇率成本高。</p><p>因此，Facebook 想通过 Libra 打造一个“货币互联网”，实现真正无国界的交易。</p><h3><b>6. 为什么还要创造一个Libra，比特币难道不可以实现这个功能吗？</b></h3><p>比特币 不满足这个功能。</p><p>因为 比特币，确认一笔交易耗时太长，性能差，吞吐量低，满足不了大并发情况下的交易场景。同时 比特币 的价格波动太大了，无法满足全球化货币的稳定性要求。</p><h3><b>7. Facebook 推广 Libra币 之后，是不是自己就可以无限发币了？</b></h3><p>不是。</p><p>Libra币 并不由 Facebook 发行。基于区块链的数字化货币，决定了它是一个没有“央行”的统一发币机构。</p><p>Facebook 只是这个项目的发起人，这是一个开放的框架，最终 Facebook  也许会从注册入口（发卡）角度获益。</p><h3><b>8.  如果 Libra 成功了，意味着什么？</b></h3><p>意味着某种程度上的全球货币统一了。会影响各个国家的法币政策（当然有的国家欢迎，有的国家排斥）。</p><h3><b>9. Libra 会成功吗？</b></h3><p>不知道。</p><p>但这是一个必然的大趋势，即使 Facebook 的 Libra 不成功，还会有别的“Libra”的，最终会成功的。</p><h3><b>10. Facebook 发起 Libra 是可以割韭菜的吗？</b></h3><p>不能。</p><p>Libra币 理论上是一个100%备付金的货币。也就是说产生多少 Libra币，就必须有多少稳定的等价资产进行兑换储备。</p><h3><b>11. Libra 与 腾讯Q币 啥区别？</b></h3><p>没有一点可比性。</p><p>Q币是一种虚拟货币，腾讯可以自主发行，可以用法币购买。但反过来，通过Q币不能兑换为法币，否者腾讯就可以自己无限造钱了。</p><p>Libra币 是一个可以与 可信的等价值物/稳定的法币 互换的 数字货币。</p><h3><b>12. Libra币由谁来发行？</b></h3><p>Libra协会</p><h3><b>13. Libra币 如何发行？</b></h3><p>如果要发行新的 Libra币，则需要用保值的资产作为抵押（称为Libra储备）。</p><h3><b>14.哪些资产可以被 Libra协会 认可（可以成为 Libra储备 的）？</b></h3><p>稳定的、有信誉度的央行发行的货币、证券等。</p><h3><b>15. Libra协议成员有哪些？</b></h3><p>初始协会成员有28家，未来会完善到100家。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-00e93e812b2236c3e2cb9cea4a5dc8e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"583\" class=\"origin_image zh-lightbox-thumb\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-00e93e812b2236c3e2cb9cea4a5dc8e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;662&#39; height=&#39;583&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"583\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-00e93e812b2236c3e2cb9cea4a5dc8e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-00e93e812b2236c3e2cb9cea4a5dc8e1_b.jpg\"/></figure><h3><b>16.国内大佬们如何评价 Libra？</b></h3><p>美团的王兴说，Libra确实是天才的设计。如果把中本聪（比特币创始人）比作马克斯，那么小札（Facebook创始人）就相当于列宁。</p><p>以上，就是对Facebook推出Libra币的一些思考，你怎么看待Libra币呢？</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、技术架构、Web技术 等。 <br/></blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a4ce2f429c95468cda66184d7d49fc1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a4ce2f429c95468cda66184d7d49fc1_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Libra", 
                    "tagLink": "https://api.zhihu.com/topics/20765478"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70846667", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 13, 
            "title": "微服务架构之「 下一代微服务 Service Mesh 」", 
            "content": "<p>Service Mesh 被大家称为下一代的微服务，是微服务领域的一颗新星，被大家讨论的非常多。<br/></p><p>我在大家的讨论中，还看到有人说 “目前的微服务架构我都没学会呢，现在又来一个下一代微服务，真学不动了”。</p><p>哈哈，没办法，互联网技术就是发展得这么快，这些技术其实也都是由于大家所在的公司业务规模和复杂度变大以后所推动出来的。</p><p>最开始 Service Mesh 的概念是由Buoyant公司在2016年提出。然后在随后几年，业内就围绕着 Service Mesh 思想探索出了各种实现，其中包括以 Linkerd 为代表的第一代 Service Mesh，随后又有以 Istio 为代表的第二代 Service Mesh。</p><p>在国内的一些大厂里，例如 阿里、新浪 等，也都有基于Service Mesh思想的自研实现。既然 Service Mesh 这么火，那它到底是什么呢？又该如何去应用呢？</p><h3><b>一、什么是「 Service Mesh 」？</b></h3><p>Service Mesh 中文称为 服务网格，为啥，因为它的部署图看起来就像一个网格，如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-941ed320d8f08f0b185654416df03bb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"432\" data-original=\"https://pic2.zhimg.com/v2-941ed320d8f08f0b185654416df03bb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;432&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"432\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"432\" data-original=\"https://pic2.zhimg.com/v2-941ed320d8f08f0b185654416df03bb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-941ed320d8f08f0b185654416df03bb5_b.jpg\"/></figure><p>Service Mesh 就是一个基础设施层，它是用于处理微服务中，服务与服务之间通信的一种技术。在 Service Mesh 的实践方案中，它是由一系列轻量级的网络代理组成的，并且这些网络代理会与咱们的应用部署在一起，特别适用于云原生应用，因为 Service Mesh 可以做到应用是无感知的。</p><p>（上图的绿色小块可以理解成是咱们微服务的应用，蓝色小块可以理解成 Service Mesh 的轻量级网络代理）</p><p>有了 Service Mesh 之后，微服务中，服务与服务之间的通信就是靠这些 网络代理模块 来保障。</p><p>那我们为啥需要采用 Service Mesh 呢，Service Mesh 帮我们解决了目前微服务之间调用的啥痛点了吗？</p><h3><b>二、为什么需要「 Service Mesh 」？</b></h3><p>在传统微服务架构中，随着业务越来越大，拆分的服务实例也越来越多，那么各个服务之间的依赖就变成了非常复杂的网络拓扑结构，可能就类似于这样了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b9580cc64c6f26aaa999c453cbeeb395_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic2.zhimg.com/v2-b9580cc64c6f26aaa999c453cbeeb395_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic2.zhimg.com/v2-b9580cc64c6f26aaa999c453cbeeb395_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b9580cc64c6f26aaa999c453cbeeb395_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>哈哈，晕图了、晕图了！<br/></p><p>在如此复杂的分布式部署结构下，咱们微服务中服务依赖调用和数据传输所面临的问题也成倍增加，极大的提高了服务治理的难度。</p><p>同时，由于 容器化技术 的成熟和规模化，微服务都会采用容器化，并朝着 云原生应用 的方向发展。而传统的微服务架构中，虽然也有服务治理的组件，但是这些组件大多需要在应用代码里进行集成，这是不符合 云原生应用 的思想的。因此，大家急需一个标准化，能高效部署和运维的微服务体系方案。</p><p>因此，Service Mesh 就出现了，Service Mesh 就是用来解决这些痛点的，设计的目的就是用来解决微服务架构中 服务间可靠调用、服务治理 等问题。</p><p>下面就拿第一代 Service Mesh 产品 Linkerd 举例说明：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-038e677aca7e1fa96b87c3a6ce378c63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1004\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb\" width=\"1004\" data-original=\"https://pic4.zhimg.com/v2-038e677aca7e1fa96b87c3a6ce378c63_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1004&#39; height=&#39;561&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1004\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1004\" data-original=\"https://pic4.zhimg.com/v2-038e677aca7e1fa96b87c3a6ce378c63_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-038e677aca7e1fa96b87c3a6ce378c63_b.jpg\"/></figure><p>图中可以看到，每一个服务实例（Service）的部署都会同时部署一个 Linkerd 实例，并且服务之间的调用并不是直接进行的，而是先经过 Linkerd 模块去代理转发完成的。</p><p>例如：Service A 需要调用 Service B 的时候，Service A 是把请求发给与它一起部署的 Linkerd-1 的，然后这个 Linkerd-1 将请求发给 Service B 所部署模块的 Linkerd-2，然后  Linkerd-2 再将请求内容转发给 Service B 处理。因此，在整个流程中，Service A  和 Service B 只需要关注自己的业务逻辑即可，无需关注任何服务框架的功能，这些服务框架的功能都是由Linkerd 去实现，Linkerd 要做 负载均衡、熔断、限流、监控等等。</p><p>下面我们具体来看看 Service Mesh 的原理。</p><h3><b>三、「 Service Mesh 」的原理与应用？</b></h3><p>Service Mesh 的核心其实就2个模块：SideCar 与  Control Plane，如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1342b3465b81e92a38e1e8f803fdc54c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic1.zhimg.com/v2-1342b3465b81e92a38e1e8f803fdc54c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;413&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"413\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic1.zhimg.com/v2-1342b3465b81e92a38e1e8f803fdc54c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1342b3465b81e92a38e1e8f803fdc54c_b.jpg\"/></figure><p>搞懂了 SideCar 与  Control Plane 也就对 Service Mesh 的基础思想原理明白了。</p><ol><li><b>SideCar：</b><br/>上面说到的与服务部署在一起的轻量级网络代理也就是指SideCar，它的作用就是实现服务框架的各项功能，这样，就可以让服务（Service A 或 Service B）回归业务本质。<br/>传统的微服务架构中，各种服务框架的功能（例如：服务发现、负载均衡、限流熔断等）都代码逻辑或多或少的都需要耦合到服务实例的代码里，给服务实例增加了很多无关业务的代码，也带来了复杂度。<br/>有了SideCar之后，服务节点只做业务逻辑自身的功能，服务之间的调用交给了SideCar，由SideCar去注册服务、去做服务发现、去做请求路由、去实现熔断限流、去做日志统计。<br/>那么在这种新的微服务架构中，所有的 SideCar 组成在一起，其实就是一个服务网格了。那么这个大型的服务网格并不是完全自治的，它还需要一个统一的控制节点，也就是 Control Plane。</li><li><b>Control Plane：</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a98c48a8850f772944091ab3b2f6934f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"332\" class=\"content_image\" width=\"398\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;398&#39; height=&#39;332&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"332\" class=\"content_image lazy\" width=\"398\" data-actualsrc=\"https://pic4.zhimg.com/v2-a98c48a8850f772944091ab3b2f6934f_b.jpg\"/></figure><p><br/>Control Plane 是用来从全局的角度上控制 SideCar 的。比如 它负责所有 SideCar 的注册，它存储一个统一的路由表，帮助各个 SideCar 进行负载均衡和请求调度。它收集所有 SideCar 的监控信息和日志数据。它就相当于 Service Mesh架构 的大脑。Control Plane 控制着 SideCar 来实现服务治理的各项功能。</p><p>在文章的最开始提到过，以 Linkerd 为代表的被称为第一代 Service Mesh，而以 Istio 为代表的称为了第二代 Service Mesh。主要的不同就是 Istio 引入了 Control Plane 的概念，可以通过  Control Plane 来对服务进行一些精细化控制，所以 Istio 也被称为是实际上的 Service Mesh 标准产品。</p><p>以上，就是我对微服务架构中「 Service Mesh」的一些思考，你是怎么看的呢？</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、Web技术 等。 </blockquote><p><br/> </p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "服务网格（Service Mesh）", 
                    "tagLink": "https://api.zhihu.com/topics/20190714"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69623899", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 2, 
            "title": "咱们码农可以从曾国藩身上学到点什么呢", 
            "content": "<p>曾国藩，这位晚清的四大名臣之首，应该不需要过多介绍。他创立湘军，平定太平天国、也是洋务运动发起人，同时是著名的战略家、理学家、文学家。<br/></p><p>我一直一来就对曾国藩很好奇，这样一个神一般的人物，到底是怎么成长起来的？</p><p>我最不喜欢研究就是什么从小天资聪慧，什么几岁就知道天文地理的神童经历，因为那跟我没啥关系啊，我又没有这么高的智商，这类大神的经历看了也白看。</p><p>但是我发现曾国藩不同，他可是考秀才，连考6年不中，被同乡耻笑为笨蛋的家伙啊，这样的才智水平都能在日后有如此大的作为，肯定有绝招。所以我决定找出《曾国藩传》好好研读一下，看看有没有哪些地方也是值得我们码农去学习学习的，说不定有助于我们早日当上CEO迎娶白富美呢。</p><p>下面我们就来看看曾国藩有哪些点值得咱们学习学习：</p><h3><b>1. 曾国藩的「 不走捷径 」</b></h3><p>史书上记载的曾国藩确实不聪明，秀才考了6次不中，而同乡很多人却早早的就中了秀才。6次不中秀才也就不说了，竟然还在第6次考试的时候，还被“悬牌批责”，意思就是考官把他的文章当做反面典型教材来公示，说他的文章文理不通。不过曾国藩正是受到这次“悬牌批责”的刺激后，他才慢慢改变了学习方法，终于在第7次考试的时候中了，虽然位于榜单的尾部。</p><p>但是有了这么一次成功的经历之后，让曾国藩觉得虽然自己比较笨，但也能走通百分之九十的人都走不通的科举之路。他从此认为，只要努力就没有干不成的事情。他甚至还有点崇尚笨拙，认为世上的人都喜欢取巧走捷径，从而不择手段，反而不容易成功。</p><p>他认为笨拙胜过机巧，笨拙的人由于没有智力资本所以更虚心、肯付出。笨拙的人总是失败，所以心理承受能力强。笨拙的人不走捷径，遇到问题肯钻研，基础打得扎实。所以曾国藩的人生哲学就是“尚拙”，后来与太平军对战时采用的“结硬寨、打呆仗”就是源于他的这个时候养成的性格。</p><p>我觉得曾国藩的这种「 不走捷径 」，踏踏实实的干好手上的每一件事的这种精神，是非常值得我们学习的。不管我们认为自己是多么聪明或者多么笨，但是只要肯付出、踏实的去干，就没有做不成的事情。</p><p>每个人都有不足的地方，比如我自己其实就不擅长于在人前演讲，或者在公共场合下输出自己的观点。但是作为一名技术管理者可能会经常遇到这样的场景啊，那么我就在每次需要讲话之前就充分的准备、在心里或者直接拿出纸笔做好要讲话的草稿，遇到重要的场合我还会像写文章一样去写稿子，就这样，因为我有在私底下下了功夫，做了充分的准备，所以也有慢慢越来越有自信，应对这类场景也越来越游润有余了。「 不走捷径 」就是告诉我们要踏实的一步一个脚印，代码要一行一行仔细敲，事情要一个一个认真的做，没有完不成的目标。</p><h3><b>2. 曾国藩的「 目标设定 」</b></h3><p>曾国藩后来高中进士之后，在京城翰林院任职。由于曾国藩并非什么书香门第，读书也主要是为了应对考试所需而读，课外书籍几乎没读过。因此他到北京任职，与同僚共事交流后，发现自己见识狭隘、观念鄙俗、性格上也有很多缺点，跟别人一比，很自卑。</p><p>所以在翰林院，他开始如饥似渴的阅览群书，慢慢视野和见识也与以前又很大不同。在三十岁这一年，他给自己设定了第一个人生目标「 做圣人 」。</p><p>在没有目标之前其实曾国藩是不知道人生追求的，只知道跟大家所有人一样追求升官发财。但有了目标之后，他似乎有了方向，就有了斗志，也就激发了他的巨大潜力。为了实现目标，他给自己制定了12条自我管理的军规，并且督促自己严格执行。</p><p>曾国藩自我管理的12条军规很有意思，下面摘其中几条，翻译成通俗语句理解就是：</p><ul><li><b>早起：</b>每天要早起，不能懒床。</li><li><b>静坐：</b>每天要静坐四刻钟，也就是一个小时。也就是现代人的静心冥想。</li><li><b>读书不二：</b>一本书没读完不看其它的书。</li><li><b>读史：</b>每天读十页史书。</li><li><b>谨言：</b>不乱说话。</li><li><b>保身：</b>要控制自己的欲望。</li><li><b>作字：</b>每天练字。</li><li><b>夜不出门：</b>晚上不出去瞎逛。</li></ul><p>我觉得这些用在现代人作为自我管理，也是非常有意义的啊。</p><p>我们在工作生活中，也应该给自己设定目标，没有目标就没有方向，再怎么努力也只会原地打转，甚至迷茫。有了目标之后，还可以将大的目标拆分为小的阶段性目标，以便可以分步去实现。</p><p>曾国藩对目标的设定，不仅体现在做「 做圣人 」上，后来曾国藩创立湘军的时候，也给自己设定了目标：“一定要挽救朝廷、再造国家”。同时，为了实现这个大的目标，他又拆解了一个小的目标，就是：“首战一定要胜利，不真正练好军队，决不出兵”。</p><p>正是因为有了这个目标，所以后来即使是咸丰皇帝多次发旨意给他，要求他出兵，曾国藩在军队没有练好的情况下，也是多次抗命、拒不出兵。甚至是在自己的好友、亲家陷入危险境地时，他依然忍痛不出兵。为的就是“准备充分、首战必胜”的小目标，以及“挽救朝廷”的大目标。</p><p>可见，一旦有了目标，对人的驱动作用有多大。</p><p>限于篇幅，今天就分享这两点，曾国藩身上有太多值得我们学习的地方，后面找时间再继续聊。</p><p>以上，就是读《曾国藩传》的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。 </blockquote><p><br/> </p>", 
            "topic": [
                {
                    "tag": "曾国藩", 
                    "tagLink": "https://api.zhihu.com/topics/19608133"
                }, 
                {
                    "tag": "曾国藩（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20116809"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68967618", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "微服务架构之「 访问安全 」", 
            "content": "<p>应用程序的访问安全又是我们每一个研发团队都必须关注的重点问题。尤其是在我们采用了微服务架构之后，项目的复杂度提升了N个级别，相应的，微服务的安全工作也就更难更复杂了。并且我们以往擅长的单体应用的安全方案对于微服务来说已经不再适用了。我们必须有一套新的方案来保障微服务架构的安全。<br/></p><p>在探索微服务访问安全之前，我们还是先来回顾一下单体应用的安全是如何实现的。</p><h3><b>一、传统单体应用如何实现「访问安全」？</b></h3><p>下图就是一个传统单体应用的访问示意图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ac5581e7603b09f32246293277788e24_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic1.zhimg.com/v2-ac5581e7603b09f32246293277788e24_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic1.zhimg.com/v2-ac5581e7603b09f32246293277788e24_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ac5581e7603b09f32246293277788e24_b.jpg\"/></figure><p>（图片来自WillTran在slideshare分享）</p><p>在应用服务器里面，我们有一个auth模块（一般采用过滤来实现），当有客户端请求进来时，所有的请求都必须首先经过这个auth来做身份验证，验证通过后，才将请求发到后面的业务逻辑。</p><p>通常客户端在第一次请求的时候会带上身份校验信息（用户名和密码），auth模块在验证信息无误后，就会返回Cookie存到客户端，之后每次客户端只需要在请求中携带Cookie来访问，而auth模块也只需要校验Cookie的合法性后决定是否放行。</p><p>可见，在传统单体应用中的安全架构还是蛮简单的，对外也只有一个入口，通过auth校验后，内部的用户信息都是内存/线程传递，逻辑并不是复杂，所以风险也在可控范围内。</p><p>那么，当我们的项目改为微服务之后，「访问安全」又该怎么做呢。</p><h3><b>二、微服务如何实现「访问安全」？</b></h3><p>在微服务架构下，有以下三种方案可以选择，当然，用的最多的肯定还是OAuth模式。</p><ul><li><b>网关鉴权模式（API Gateway）</b></li><li><b>服务自主鉴权模式</b></li><li><b>API Token模式（OAuth2.0）</b></li></ul><p>下面分别来讲一下这三种模式：</p><ol><li><b>网关鉴权模式（API Gateway）</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2ec26b590cfa8c60e2e3928d8c2fea8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-2ec26b590cfa8c60e2e3928d8c2fea8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;483&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-2ec26b590cfa8c60e2e3928d8c2fea8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2ec26b590cfa8c60e2e3928d8c2fea8e_b.jpg\"/></figure><p>（图片来自WillTran在slideshare分享）<br/>通过上图可见，因为在微服务的最前端一般会有一个API网关模块（API Gateway），所有的外部请求访问微服务集群时，都会首先通过这个API Gateway，所以我们可以在这个模块里部署auth逻辑，实现统一集中鉴权，鉴权通过后，再把请求转发给后端各个服务。<br/>这种模式的优点就是，由API Gateway集中处理了鉴权的逻辑，使得后端各微服务节点自身逻辑就简单了，只需要关注业务逻辑，无需关注安全性事宜。<br/>这个模式的问题就是，API Gateway适用于身份验证和简单的路径授权（基于URL的），对于复杂数据/角色的授权访问权限，通过API Gateway很难去灵活的控制，毕竟这些逻辑都是存在后端服务上的，并非存储在API Gateway里。</p><ol><li><b>服务自主鉴权模式</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cf5c1fe3cd4ce683ec641c944e1ae26f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-cf5c1fe3cd4ce683ec641c944e1ae26f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-cf5c1fe3cd4ce683ec641c944e1ae26f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cf5c1fe3cd4ce683ec641c944e1ae26f_b.jpg\"/></figure><p>（图片来自WillTran在slideshare分享）<br/>服务自主鉴权就是指不通过前端的API Gateway来控制，而是由后端的每一个微服务节点自己去鉴权。<br/>它的优点就是可以由更为灵活的访问授权策略，并且相当于微服务节点完全无状态化了。同时还可以避免API Gateway 中 auth 模块的性能瓶颈。<br/>缺点就是由于每一个微服务都自主鉴权，当一个请求要经过多个微服务节点时，会进行重复鉴权，增加了很多额外的性能开销。</p><ol><li><b>API Token模式（OAuth2.0）</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4bb169496b812fb8acb785d6fcc339b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-4bb169496b812fb8acb785d6fcc339b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;483&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"483\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-4bb169496b812fb8acb785d6fcc339b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4bb169496b812fb8acb785d6fcc339b4_b.jpg\"/></figure><p>（图片来自网络）<br/>如图，这是一种采用基于令牌Token的授权方式。在这个模式下，是由授权服务器（图中Authorization Server）、API网关（图中API Gateway）、内部的微服务节点几个模块组成。<br/>流程如下：<br/>第一步：客户端应用首先使用账号密码或者其它身份信息去访问授权服务器（Authorization Server）获取 访问令牌（Access Token）。<br/>第二步：拿到访问令牌（Access Token）后带着它再去访问API网关（图中API Gateway），API Gateway自己是无法判断这个Access Token是否合法的，所以走第三步。<br/>第三步：API Gateway去调用Authorization Server校验一下Access Token的合法性。<br/>第四步：如果验证完Access Token是合法的，那API Gateway就将Access Token换成JWT令牌返回。<br/>（注意：此处也可以不换成JWT而是直接返回原Access Token。但是换成JWT更好，因为Access Token是一串不可读无意义的字符串，每次验证Access Token是否合法都需要去访问Authorization Server才知道。但是JWT令牌是一个包含JOSN对象，有用户信息和其它数据的一个字符串，后面微服务节点拿到JWT之后，自己就可以做校验，减少了交互次数）。<br/>第五步：API Gateway有了JWT之后，就将请求向后端微服务节点进行转发，同时会带上这个JWT。<br/>第六步：微服务节点收到请求后，读取里面的JWT，然后通过加密算法验证这个JWT，验证通过后，就处理请求逻辑。<br/>这里面就使用到了OAuth2.0的原理，不过这只是OAuth2.0各类模式中的一种。</p><p>由于OAuth2.0目前最为常用，所以接下来我再来详细讲解一下OAuth2.0的原理和各类用法。</p><h3><b>三、详解 OAuth2.0 的「 访问安全 」？</b></h3><p>OAuth2.0是一种访问授权协议框架。它是基于Token令牌的授权方式，在不暴露用户密码的情况下，使 应用方 能够获取到用户数据的访问权限。</p><p>例如：你开发了一个视频网站，可以采用第三方微信登陆，那么只要用户在微信上对这个网站授权了，那这个网站就可以在无需用户密码的情况下获取用户在微信上的头像。</p><p>OAuth2.0 的流程如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cc446d586974e1503938d4d5003d9e96_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"397\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic3.zhimg.com/v2-cc446d586974e1503938d4d5003d9e96_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;397&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"397\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic3.zhimg.com/v2-cc446d586974e1503938d4d5003d9e96_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cc446d586974e1503938d4d5003d9e96_b.jpg\"/></figure><p>OAuth2.0 里的主要名词有：</p><ul><li><b>资源服务器：</b>用户数据/资源存放的地方，在微服务架构中，服务就是资源服务器。在上面的例子中，微信头像存放的服务就是资源服务器。</li><li><b>资源拥有者：</b>是指用户，资源的拥有人。在上面的例子中某个微信头像的用户就是资源拥有者。</li><li><b>授权服务器：</b>是一个用来验证用户身份并颁发令牌的服务器。</li><li><b>客户端应用：</b>想要访问用户受保护资源的客户端/Web应用。在上面的例子中的视频网站就是客户端应用。</li><li><b>访问令牌：</b>Access Token，授予对资源服务器的访问权限额度令牌。</li><li><b>刷新令牌：</b>客户端应用用于获取新的 Access Token 的一种令牌。</li><li><b>客户凭证：</b>用户的账号密码，用于在 授权服务器 进行验证用户身份的凭证。</li></ul><p>OAuth2.0有四种授权模式，也就是四种获取令牌的方式：授权码、简化式、用户名密码、客户端凭证。</p><p>下面来分别讲解一下：</p><ol><li><b>授权码（Authorization Code）</b><br/>授权码模式是指：客户端应用先去申请一个授权码，然后再拿着这个授权码去获取令牌的模式。这也是目前最为常用的一种模式，安全性比较高，适用于我们常用的前后端分离项目。通过前端跳转的方式去访问 授权服务器 获取授权码，然后后端再用这个授权码访问 授权服务器 以获取 访问令牌。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-875477cc1fe4d260b26ce24b6ed9f653_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb\" width=\"717\" data-original=\"https://pic4.zhimg.com/v2-875477cc1fe4d260b26ce24b6ed9f653_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;717&#39; height=&#39;511&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"717\" data-original=\"https://pic4.zhimg.com/v2-875477cc1fe4d260b26ce24b6ed9f653_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-875477cc1fe4d260b26ce24b6ed9f653_b.jpg\"/></figure><p>流程如上图。<br/>第一步，客户端的前端页面(图中UserAgent)将用户跳转到 授权服务器(Authorization Server)里进行授权，授权完成后，返回 授权码(Authorization Code)<br/>第二步，客户端的后端服务(图中Client)携带授权码(Authorization Code)去访问 授权服务器，然后获得正式的 访问令牌(Access Token)<br/>页面的前端和后端分别做不同的逻辑，前端接触不到Access Token，保证了Access Token的安全性。</p><ol><li><b>简化式（Implicit）</b><br/>简化模式是在项目是一个纯前端应用，在没有后端的情况下，采用的一种模式。<br/>因为这种方式令牌是直接存在前端的，所以非常不安全，因此令牌的有限期设置就不能太长。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-751073c0b92412c63fa47661b88e6cac_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"840\" data-original=\"https://pic1.zhimg.com/v2-751073c0b92412c63fa47661b88e6cac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;840&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"840\" data-original=\"https://pic1.zhimg.com/v2-751073c0b92412c63fa47661b88e6cac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-751073c0b92412c63fa47661b88e6cac_b.jpg\"/></figure><p>其流程就是：<br/>第一步：应用（纯前端的应用）将用户跳转到 授权服务器(Authorization Server)里进行授权，授权完成后，授权服务器 直接将 Access Token 返回给 前端应用，令牌存储在前端页面。<br/>第二步：应用（纯前端的应用）携带 访问令牌(Access Token) 去访问资源，获取资源。<br/>在整个过程中，虽然令牌是在前端URL中直接传递，但注意，令牌在HTTP协议中不是放在URL参数字段中的，而是放在URL锚点里。因为锚点数据不会被浏览器发到服务器，因此有一定的安全保障。</p><ol><li><b>用户名密码（Resource Owner Credentials）</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e6afec30b9185add6312d28cae92f80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-6e6afec30b9185add6312d28cae92f80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;873&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-6e6afec30b9185add6312d28cae92f80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e6afec30b9185add6312d28cae92f80_b.jpg\"/></figure><p>这种方式最容易理解了，直接使用用户的用户名/密码作为授权方式去访问 授权服务器，从而获取Access Token，这个方式因为需要用户给出自己的密码，所以非常的不安全性。一般仅在客户端应用与授权服务器、资源服务器是归属统一公司/团队，互相非常信任的情况下采用。</p><ol><li><b>客户端凭证（Client Credentials）</b><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-72fdceb51b707bfb3999c3e1c651211d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"927\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb\" width=\"927\" data-original=\"https://pic2.zhimg.com/v2-72fdceb51b707bfb3999c3e1c651211d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;927&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"927\" data-rawheight=\"241\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"927\" data-original=\"https://pic2.zhimg.com/v2-72fdceb51b707bfb3999c3e1c651211d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-72fdceb51b707bfb3999c3e1c651211d_b.jpg\"/></figure><p>这是适用于服务器间通信的场景。客户端应用拿一个用户凭证去找授权服务器获取Access Token。</p><p>以上，就是对微服务架构中「访问安全」的一些思考。</p><p>在微服务架构的系列文章中，前面已经通过文章介绍过了「服务注册 」、「服务网关 」、「配置中心 」、「 监控系统 」、「调用链监控」、「容错隔离」，大家可以翻阅历史文章查看。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote><p><br/> </p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "微服务设计（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20128680"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68035063", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 12, 
            "title": "微服务架构之「 容错隔离 」", 
            "content": "<p>我们知道，在单体应用的架构下一旦程序发生了故障，那么整个应用可能就没法使用了，所以我们要把单体应用拆分成具有多个服务的微服务架构，来减少故障的影响范围。但是在微服务架构下，有一个新的问题就是，由于服务数变多了，假设单个服务的故障率是不变的，那么整体微服务系统的故障率其实是提高了的。<br/></p><p>比如：假设单个服务的故障率是0.01%，也就是可用性是99.99%，如果我们总共有10个微服务，那么我们整体的可用性就是99.99%的十次方，得到的就是99.90%的可用性（也就是故障率为0.1%）。可见，相对于之前的单体应用，整个系统可能发生故障的风险大幅提升。</p><p>那么在这种情况下，我们应该怎么去保证微服务架构的可用性呢？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ec58b0f43b18e430664ebb6cfa22174e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-ec58b0f43b18e430664ebb6cfa22174e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-ec58b0f43b18e430664ebb6cfa22174e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ec58b0f43b18e430664ebb6cfa22174e_b.jpg\"/></figure><p>其实我们参考造船行业对船舱进水风险的隔离方法，如上图。</p><p>造船行业有一个专业术语叫做「舱壁隔离」，利用舱壁将不同的船舱隔离起来，如果某一个船舱进了水，那么就可以立即封闭舱门，形成舱壁隔离，只损失那一个船舱，其他船舱不受影响，整个船只还是可以正常航行。</p><p>对应到微服务架构中，我们要做的就是最大限度的隔离单个服务的风险，也就是「 容错隔离 」的方法。</p><h3><b>一、微服务架构中可用性风险有哪些？</b></h3><p>在聊「容错隔离」方法之前，我们先来看一下微服务架构中，常见的可用性风险到底有哪些吧，知道了有哪些风险我们才知道该如何去规避、去隔离风险。</p><p>我们可以从项目部署规模的角度去分析风险：</p><ol><li><b>单机可用性风险：</b><br/>这个很好理解，就是微服务部署所在的某一台机器出现了故障，造成的可用性风险。这种风险发生率很高，因为单机器在运维中本身就容易发生各种故障，例如 硬盘坏了、机器电源故障等等，这些都是时有发生的事情。不过虽然这种风险发生率高，但危害有限，因为我们大多数服务并不只部署在一台机器上，可能多台都有，因此只需要做好监控，发现故障之后，及时的将这台故障机器从服务集群中剔除即可，等修复了再重新上线到集群里。</li><li><b>单机房可用性风险：</b><br/>这种风险的概率比单机器的要低很多，但是也不是完全不可能发生，在实际情况中，还是有一定概率的。比如最为常见的就是通往机房的光纤被挖断了，前段时间支付宝所在机房不是就发生过光纤被挖么。<br/>咱们全国大小城市都在疯狂的进行基建，修桥修路修房子，GDP就这么搞起来了，地下的光纤挖断几根不是再正常不过的事情了么，哈哈。<br/>如果我们的服务全部都部署在单个机房，而机房又出故障了，那就没辙了。好在，现在大多数中大型项目都会采用多机房部署的方案，比如同城双活、异地多活等。一旦某个机房出现了故障不可用了，咱们立即采用切换路由的方式，把这个机房的流量切到其它机房里。</li><li><b>跨机房集群可用性风险：</b><br/>既然都跨机房集群了，可用性理论上应该没啥问题啊。但要知道这是在物理层面没有问题了，如果咱们的代码有坑，或者因为特殊原因用户流量激增，导致我们的服务扛不住了，那在跨机房集群的情况下一样会不可用。但如果我们提前做好了「容错隔离」的一些方案，比如 限流、熔断 等等，用上这些方法还是可以保证一部分服务或者一部分用户的访问是正常。</li></ol><h3><b>二、「 容错隔离 」的方法有哪些？</b></h3><p>好了，上面讲了微服务架构中可能遇到这么多的可用性风险，并且也知道了「容错隔离」的重要性，下面我们再来看看常见的「容错隔离」方法有哪些：</p><ol><li><b>超时：</b><br/>这也是简单的容错方式。就是指在服务之间调用时，设置一个 主动超时时间，超过了这个时间阈值后，如果“被依赖的服务”还没有返回数据的话，“调用者”就主动放弃，防止因“被依赖的服务”的故障所影响。</li><li><b>限流</b><br/>顾名思义，就是限制最大流量。系统能提供的最大并发有限，同时来的请求又太多，服务不过来啊，就只好排队限流了，就跟去景点排队买票、去商场吃饭排队等号的道理一样一样儿的。</li><li><b>降级</b><br/>这个与限流类似，一样是流量太多，系统服务不过来。这个时候可以可将不是那么重要的功能模块进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。同时还可以对用户分层处理，优先处理重要用户的请求，比如VIP收费用户等。</li><li><b>延迟处理</b><br/>这个方式是指设置一个流量缓冲池，所有的请求先进入这个缓冲池等待处理，真正的服务处理方按顺序从这个缓冲池中取出请求依次处理，这种方式可以减轻后端服务的压力，但是对用户来说体验上有延迟。</li><li><b>熔断</b><br/>可以理解成就像电闸的保险丝一样，当流量过大或者错误率过大的时候，保险丝就熔断了，链路就断开了，不提供服务了。当流量恢复正常，或者后端服务稳定了，保险丝会自动街上（熔断闭合），服务又可以正常提供了。这是一种很好的保护后端微服务的一种方式。<br/>熔断技术中有个很重要的概念就是：断路器，可以参考下图：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ae6e2aab864aa407322277140114ec85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-ae6e2aab864aa407322277140114ec85_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-ae6e2aab864aa407322277140114ec85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ae6e2aab864aa407322277140114ec85_b.jpg\"/></figure><p>断路器其实就是一个状态机原理，有三种状态：Closed（闭合状态，也就是正常状态）、Open（开启状态，也就是当后端服务出故障后链路断开，不提供服务的状态）、Half-Open(半闭合状态，就是允许一小部分流量进行尝试，尝试后发现服务正常就转为Closed状态，服务依旧不正常就转为Open状态)。</p><h3><b>三、「 容错隔离 」的应用？</b></h3><p>在容错隔离或者说熔断技术方面做得最出名的框架就是 <b>Hystrix</b> 了。Hystrix是由Netflix开源，在业内应用非常广泛。</p><p>下面是Hystrix的原理流程图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-983c18f4e3a408718f1b04691fb81e09_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-983c18f4e3a408718f1b04691fb81e09_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;513&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-983c18f4e3a408718f1b04691fb81e09_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-983c18f4e3a408718f1b04691fb81e09_b.jpg\"/></figure><p>这是新版流程，比之前旧版本又复杂很多，如果不讲解一下，估计很多人都不容易看懂。</p><p>图中标注了数字1-9，可以按照这个数字顺序去理解这个流程。</p><p>当我们使用了Hystrix之后，请求会被封装到HystrixCommand中，这也就是第一步。然后第二步就是开始执行请求，Hystrix支持同步执行(图中.execute方法)、异步执行(图中.queue方法)和响应式执行(图中.observer)。然后第三步判断缓存，如果存在与缓存中，则直接返回缓存结果。如果不在缓存中，则走第四步，判断 断路器 的状态是否是开启的，如果是开启状态，也就是短路了，那就进行失败返回，跳到第八步，第八步需要对失败返回的处理也需要再做一次判断，要么正常失败返回，返回相应信息，要么根本没有实现失败返回的处理逻辑，就直接报错。如果 断路器 不是开启状态，那请求就继续走，进行第五步，判断线程/队列是否满了，如果满了，那么同样跳到第八步，如果线程没满，则走到第六步，执行远程调用逻辑，然后判断远程调用是否成功，调用发生异常了就挑到第八步，调用正常就挑到第九步正常返回信息。</p><p>图中的第七步，非常牛逼的一个模块，是来收集Hystrix流程中的各种信息来对系统做监控判断的。</p><p>另外，Hystrix的断路器实现原理也很关键，下面就是Hystrix断路器的原理图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b322465f52bc27161941cde948a65db4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"873\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-b322465f52bc27161941cde948a65db4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;873&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"873\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-b322465f52bc27161941cde948a65db4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b322465f52bc27161941cde948a65db4_b.jpg\"/></figure><p>Hystrix通过滑动时间窗口算法来实现断路器的，是以秒为单位的滑桶式统计，它总共包含10个桶，每秒钟一个生成一个新的桶，往前推移，旧的桶就废弃掉。</p><p>每一个桶中记录了所有服务调用的状态，调用次数、是否成功等信息，断路器的开关就是把这10个桶进行聚合计算后，来判断当前是应该开启还是闭合的。</p><p>以上，就是对微服务架构中「容错隔离」的一些思考。</p><p>在微服务架构的系列文章中，前面已经通过文章介绍过了「服务注册 」、「服务网关 」、「配置中心 」、「 监控系统 」、「调用链监控」，大家可以翻阅历史文章查看。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67621152", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "吴军博士眼中的五级软件工程师", 
            "content": "<p>有没有适用于咱们软件工程师的等级评价体系呢？<br/></p><p>世界上有一套针对专业人士的评价体系，它的发明人是苏联著名物理学家 列夫·达维多维奇·朗道。朗道（1908-1968），号称是“世界上最后一个全能的物理学家”，他不仅获得过诺贝尔物理学奖，而且还提出一种按照水平和贡献划分物理学家的方法，被称为物理学家的等级，也就是前面提到的专业人士的评价体系。</p><p>其实，咱们 程序员/软件工程师 也是属于专业人士范畴的，那有没有适用于咱们的等级评价体系呢？</p><p>有，吴军博士在得到《硅谷来信》中就提出了他眼中的五级工程师的要求，虽然不是什么标准化的东西，但是我觉得非常有参考价值，我读完之后简直是醍醐灌顶，不仅可以对照自己所处的位置，更重要的是能指引我们对自己职业发展方向的思考。</p><p>其实我在之前写过一篇文章「如何从程序员到架构师」，在里面我也提到了对程序员的分级，那是根据我自己的认知，以及我这些年工作经验的角度出发，我眼中看到的业内互联网公司技术团队里对程序员/软件工程师这一职业的等级划分。即：初级工程师、中级工程师、高级工程师、资深工程师/架构师、技术专家/首席技术官。并且我也浅显的聊了聊对这每一个级别工程师所应具备素质要求的看法。</p><p>但是对比 吴军 的这个五级软件工程师等级，我那个还是太浅显，视野太窄了。所以这篇文章我就想把吴军的这个划分跟大家聊一聊。</p><h3><b>1. 吴军的五级工程师划分？</b></h3><p>吴军老师在《硅谷来信》中也参考 物理学家朗道 对工程师划分为为了五个等级：</p><p>第一级最高，第五级最低，级和级之间的差别不应该是一点点，而是数量级的差别。</p><ul><li><b>第五级：</b><br/>能独立解决问题，完成工程工作</li><li><b>第四级：</b><br/>能指导和带领其他人，一同完成更有影响力的工作</li><li><b>第三级：</b><br/>能独立设计和实现产品，并在市场上获得成功</li><li><b>第二级：</b><br/>能设计和实现别人不能做出的产品（他的作用很难替代）</li><li><b>第一级：</b><br/>开创一个产业</li></ul><h3><b>2. 对于软件工程师而言，每一级意味着什么？</b></h3><p>将吴军老师的五级工程师，对应到软件具体工作中，可以这么理解：</p><ol><li><b>第五级 工程师：</b><br/>一名合格的五级软件工程师，首先应该是一个技术熟手，在工作中经历过了一定的历练，所以可以在不需要别人的指导下，就能独立完成安排的工作任务。<br/>比如上级/需求方给他安排了一个功能需求，他能够充分的理解这个需求背景和目的、以及能给出实现方案，并知道找公司的哪些人提供相应的资源和支持，然后能主动的推动资源来协助自己完成这个需求，最后实现成功上线。</li><li><b>第四级 工程师：</b><br/>四级工程师，在互联网企业里更具体而言，需要有一定的领导能力，能领导和负责一个项目。能设定目标并找出实现的道路，能正确的识别问题、并找出最合适的解决方案（不仅限于技术方案），带领团队把大问题化解为小问题，最终完成项目。</li><li><b>第三级 工程师：</b><br/>三级工程师，就需要能够独立带领团队为公司做出一个能赚钱的产品了。很明显，这一层级，就需要有商业思维、市场判断能力、营销能力了。<br/>我觉得国内的大多数软件工程师由于编码的固定思维，容易觉得自己技术牛就可以了，其它的事情关注度不高，所以真正能走到这一步的工程师很少了。</li><li><b>第二级 工程师：</b><br/>这一级就更牛了，要能带领团队做出先前没有的产品，或者别人想做但暂时还未成功的产品。能到这一级别也就真正的业内大牛了。比如阿里云的创始人王坚这类，有多难就不说了，另外还得看行业机会。</li><li><b>第一级 工程师：</b><br/>一级是指开创一个产业的人，这个吴军老师没有多谈，估计是觉得离我们实在是太远了，哈哈。</li></ol><p>吴军老师的这五个工程师等级划分，可以看出来与我们在公司的职位/职级完全不相关，也并非与纯技术考量相关，它完全是从整体能力、产出贡献的角度去描述。看完他这个，再想想我们平时对程序员、对架构师等的要求和评估依据明显弱爆了。</p><p>我觉得完全可以依据这五级工程师标准，来看看自己在哪个等级，然后接下来的努力方向在哪儿，相信大家职业生涯也就不迷茫 。对了，吴军老师对自己的评定是在2.5级。</p><p>以上，就是对软件工程师的等级评价体系的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67285937", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 5, 
            "title": "微服务架构之「 调用链监控 」", 
            "content": "<p>「 调用链监控 」是在微服务兴起后才有的一种新流行的监控模式。因为在我们传统单体应用的项目中，不存在服务链/调用链的概念，所以也就根本没有调用链监控的需求了。<br/></p><p>当我们开始微服务架构之后，我们的很多服务变成分布式的了，并且我们对服务进行了拆分，拆分之后，用户的一个请求进来，会依次经过不同的服务节点进行处理，处理完成后再返回结果给用户。那么在整个处理的链条中，如果有任何一个节点出现了延迟或者问题，都有可能导致最终的结果出现异常，有的时候不同的服务节点甚至是由不同的团队开发的、部署在不同的服务器上，那么在这么错综复杂的环境下，我们想要排查出是链条中的具体哪个服务节点出了问题，其实并不容易。</p><p>因此大家就想到了一个办法，将这个请求经过的每一个节点都记录下来，形成一个完整的调用链监控系统，那么一旦发生请求调用异常的情况，只需要去排查这个调用链日志就能很清楚看到出错的环节在哪儿。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;657&#39; height=&#39;595&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\"/></figure><h3><b>一、为什么需要「 调用链监控 」？</b></h3><p>「调用链监控」是在微服务架构中非常重要的一环。它除了能帮助我们定位问题以外，还能帮助项目成员清晰的去了解项目部署结构，毕竟一个几十上百的微服务，相信在运行时间久了之后，项目的结构很可能就是下面图片这样了，在这种情况下，团队开发者甚至是架构师都不一定能对项目的网络结构有很清晰的了解，那就更别谈系统优化了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_b.jpg\"/></figure><p>好了，说了这么多，咱们下面就来具体看一下「调用链监控」的作用有哪些：</p><ol><li><b>项目网络拓扑图：</b><br/>我们可以根据「调用链监控」中记录的链路信息，给项目生成一张网络调用的拓扑图。通过这张图，我们就可以知道系统中的各个服务之间的调用关系是怎样的，以及系统依赖了哪些服务。并且还可以起到监控全局服务的作用，便于架构师掌握系统的状态。</li><li><b>快速定位问题：</b><br/>这个作用前面一直在讲，微服务架构下，问题定位就变得非常复杂了，一个请求可能会经过多个服务节点，那么有这么一套调用链监控系统就能让开发人员快速的定位到问题和相应模块。</li><li><b>优化系统：</b><br/>优化系统也是「调用链监控」很重要的一个功能。因为我们记录了请求在调用链上每一个环节的信息，我们就可以通过这个来找出系统的瓶颈，做出针对性的优化。还可以分析这个调用路径是否合理，是否调用了不必要的服务节点，是否有更近、响应更快的服务节点。通过对调用链路的分析，我们就可以找出最优质的调用路径，从而提高系统的性能。</li><li><b>提高团队成员自律：</b><br/>上面都是系统层面的作用。但如果有了「调用链监控」之后，对团队开发人员的帮助也是非常大的。因为团队所有成员都可以通过这个调用链监控系统看到系统各个模块的状态，相当于给了开发同学一个放大镜，以前开发同学完成项目交付后，只要没有出现问题，可能不太关心系统的优化，但是有这个调用链监控系统之后，哪个模块性能高，哪个模块问题大，一眼就能分辨，通过这么一个看板，开发同学慢慢的也会对自己负责的模块有更多的责任感，也会很自觉的去优化自己的模块。这种习惯的养成，对研发团队而言，非常的重要。</li></ol><h3><b>二、「 调用链监控」的原理？</b></h3><p>在调用链监控系统中，有几个核心概念需要了解：</p><ul><li><b>Trace</b>:<br/>Trace是指一次请求调用的链路过程，trace id 是指这次请求调用的ID。在一次请求中，会在网络的最开始生成一个全局唯一的用于标识此次请求的trace id，这个trace id在这次请求调用过程中无论经过多少个节点都会保持不变，并且在随着每一层的调用不停的传递。最终，可以通过trace id将这一次用户请求在系统中的路径全部串起来。</li><li><b>Span</b>:<br/>Span是指一个模块的调用过程，一般用span id来标识。在一次请求的过程中会调用不同的节点/模块/服务，每一次调用都会生成一个新的span id来记录。这样，就可以通过span id来定位当前请求在整个系统调用链中所处的位置，以及它的上下游节点分别是什么。</li><li><b>Annotation</b>:<br/>是指附属信息，可以用于附属在每一个Span上自定义的数据。</li></ul><p>具体参考下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3cf73e83f782109bd723ad064c9e0faf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"238\" class=\"origin_image zh-lightbox-thumb\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-3cf73e83f782109bd723ad064c9e0faf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;619&#39; height=&#39;238&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"619\" data-rawheight=\"238\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"619\" data-original=\"https://pic4.zhimg.com/v2-3cf73e83f782109bd723ad064c9e0faf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3cf73e83f782109bd723ad064c9e0faf_b.jpg\"/></figure><p>从图中可见，一次请求只有一个唯一的trace id=12345，在请求过程中的任何环节都不会改变。在这个请求的调用链中，SpanA调用了SpanB，然后SpanB又调用了SpanC和SpanD，每一次Span调用都会生成一个自己的span id，并且还会记录自己的上级span id是谁。通过这些id，整个链路基本上就都能标识出来了。</p><p>好了，了解了核心概念之后，我们再来看一下它具体是如何工作的，下面选取Twitter开源的Zipkin原理图作为参考：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1d4e5e306d7b13c15920d5b2268532bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-1d4e5e306d7b13c15920d5b2268532bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic1.zhimg.com/v2-1d4e5e306d7b13c15920d5b2268532bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1d4e5e306d7b13c15920d5b2268532bc_b.jpg\"/></figure><p>所有的调用链监控系统都由 数据埋点采集、数据存储处理、数据分析展示 几大部分组成，Zipkin也不例外。</p><p>图中左上角Reporter部分集成到应用程序中采集数据，并将数据上报，由Collector进行收集，然后通过Storage模块负责存储，落地到存储系统中（Zipkin用的是Cassandra）。而API模块是可以将处理后的数据提供对外服务的，UI模块就是数据统计展示层了。</p><h3><b>三、「 调用链监控」的应用？</b></h3><p>了解了调用链监控的原理之后，我们再看看目前业内有哪些主流的开源调用链监控系统：</p><ul><li><b>CAT</b><br/>CAT是由大众点评开源的一款调用链监控系统，基于JAVA开发的。有很多互联网企业在使用，热度非常高。它有一个非常强大和丰富的可视化报表界面，这一点其实对于一款调用链监控系统而来非常的重要。在CAT提供的报表界面中有非常多的功能，几乎能看到你想要的任何维度的报表数据。<br/>CAT有个很大的优势就是处理的实时性，CAT里大部分系统是分钟级统计。<br/>CAT主要提供的报表有：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ca0209dd0347bf3ae90e6f98c0127795_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"189\" class=\"content_image\" width=\"355\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;355&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"355\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"355\" data-actualsrc=\"https://pic2.zhimg.com/v2-ca0209dd0347bf3ae90e6f98c0127795_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>Transaction报表：<br/>主要是监控一段代码运行情况，如：运行次数、QPS、错误次数、失败率、响应时间等。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b4e03f3f97014c4e8b59d1b2995bbf48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"318\" class=\"origin_image zh-lightbox-thumb\" width=\"726\" data-original=\"https://pic1.zhimg.com/v2-b4e03f3f97014c4e8b59d1b2995bbf48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;726&#39; height=&#39;318&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"318\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"726\" data-original=\"https://pic1.zhimg.com/v2-b4e03f3f97014c4e8b59d1b2995bbf48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b4e03f3f97014c4e8b59d1b2995bbf48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>Event报表：<br/>主要是监控一行代码/一个事件运行次数，如：程序中某个事件运行了多少次、错误了多少次等。Event报表的整体结构与Transaction报表几乎一样，只缺少响应时间的统计。</li><li>Problem报表：<br/>主要是统计项目在运行过程中出现的问题，根据Transaction与Event的数据分析出来系统可能出现的异常，比如访问较慢等。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-61af16d4400db89c3beaa9177cdfc954_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-61af16d4400db89c3beaa9177cdfc954_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-61af16d4400db89c3beaa9177cdfc954_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-61af16d4400db89c3beaa9177cdfc954_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>Heartbeat报表：<br/>以一分钟为周期，定期向服务端汇报当前运行的一些状态，如：JVM状态、Memory、Thread等。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0178f04b632d5fccac8d692e42245907_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"731\" data-original=\"https://pic4.zhimg.com/v2-0178f04b632d5fccac8d692e42245907_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;731&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"731\" data-original=\"https://pic4.zhimg.com/v2-0178f04b632d5fccac8d692e42245907_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0178f04b632d5fccac8d692e42245907_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>Business报表：<br/>业务监控报表，如订单指标、支付数据等业务指标。</li></ol><ul><li><b>Open Zipkin</b><br/>Zipkin由Twitter开源，支持的语言非常多，基于 Google Dapper 的论文设计而来，国内外很多公司都在用，文档资料也很丰富。在上面讲原理的环节已经介绍过了Zipkin，这里就不赘述了，下面是示例图：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a91778b0570bb4a1b3624e569eea1f2f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"727\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb\" width=\"727\" data-original=\"https://pic4.zhimg.com/v2-a91778b0570bb4a1b3624e569eea1f2f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;727&#39; height=&#39;377&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"727\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"727\" data-original=\"https://pic4.zhimg.com/v2-a91778b0570bb4a1b3624e569eea1f2f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a91778b0570bb4a1b3624e569eea1f2f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>Naver Pinpoint</b><br/>Pinpoint中的服务关系依赖图做得非常棒，超出市面上任何一款产品。另外，Pinpoint因为采用字节码增强方式去埋点，所以在埋点的时候是不需要修改业务代码的，非侵入式的，非常适合项目已经完成之后再增加调用链监控的时候去使用的方案。但是也是由于采用字节码增强的方式，所以它目前仅支持JAVA语言。<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-566b9906c7b01332b72f1278246eb960_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"879\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"879\" data-original=\"https://pic1.zhimg.com/v2-566b9906c7b01332b72f1278246eb960_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;879&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"879\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"879\" data-original=\"https://pic1.zhimg.com/v2-566b9906c7b01332b72f1278246eb960_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-566b9906c7b01332b72f1278246eb960_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以上，就是对微服务架构中「 调用链监控」的一些思考。</p><p>在微服务架构的系列文章中，前面已经通过文章介绍过了「服务注册 」、「服务网关 」、「配置中心 」、「 监控系统 」，大家可以翻阅历史文章查看。</p><p>另外，为了方便小伙伴们交流微服务架构相关的技术，我创建了一个「 聊聊架构与微服务 」的交流群。</p><p>添加微信后拉你进群：WH-IT-er，加微信时备注：微服务加群。<br/></p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66707770", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "「码农读书」：我们并没有自己想象的那么理性", 
            "content": "<p>作为码农/程序员，我们经常认为自己是非常理性的。其实不仅是我们自己这么认为，甚至我们身边的朋友们在谈到对我们的评价时，在聊到对程序员这个职业的印象时，都会普遍的认为这是一个非常理性、思维逻辑非常清晰的群体。但事实真的是这样吗？<br/></p><p>我曾经也非常自信于自己的理性。但最近看了一本大块头书《思考，快与慢》后，完全颠覆了我的认知。其实我们并没有自己想象的那么理性。很多时候，我们被自己的大脑欺骗了。</p><p>我们以为自己做出的每一个决策都是理性的、正确的、符合规律的，但有的时候它只是我们凭直觉所作出的判断而已，偏见是人类与生俱来的缺陷。</p><p>在《思考，快与慢》中把人的思维分成了「快思考」与「慢思考」两个系统，简单来说，一个是无意识的直觉系统，另一个是需要我们消耗脑力的复杂系统。我们在需要处理日常生活事情的时候，大脑会不自主的优先使用直觉系统来处理，而我们的直觉系统往往容易产生非理性的结果，所以这也是导致我们经常做出非理性的决策的原因。</p><p>这也就是为什么，我们在主观上以为自己是由理性掌控着自己的决策，但事实上我们的很多决策是由「快思考」的“直觉”给出的，在无意中完成的，而这些决策也并不真的如自己想象的那么靠谱。</p><p>那么，如果才能让自己更为理性呢？在回答这个问题之前，我们先来深刻理解一下大脑中的「快思考」与「慢思考」这两个系统。</p><h3><b>1. 什么是 「快思考」/「慢思考」？</b></h3><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ebd2a3208b673fc930f0aede36ddd49a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"347\" class=\"origin_image zh-lightbox-thumb\" width=\"625\" data-original=\"https://pic3.zhimg.com/v2-ebd2a3208b673fc930f0aede36ddd49a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;625&#39; height=&#39;347&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"347\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"625\" data-original=\"https://pic3.zhimg.com/v2-ebd2a3208b673fc930f0aede36ddd49a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ebd2a3208b673fc930f0aede36ddd49a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图，我们可以把大脑想象成有2个系统在一起协同，左边是慢思考系统，右边是快思考系统。当然这只是一种假设，为了方便理解所杜撰出来的2个角色。这两个系统在大脑中并不是真实存在的实体，只是2种不同的思考模式。<br/></p><ul><li><b>快思考 系统</b><br/>快思考系统的运行是 无意识的、快速的、不怎么耗费脑力的、没有感觉的、完全处于自主控制的。<br/>从上图右边可以看到，「快思考」主要用来处理那些不需要思考计算的问题，例如：“在空旷的地方开车”、“听音乐”、“在对话中明白对方的语气”、“一眼就能识别对方的表情”、“不需要计算就能给出1+1等于多少”、“读广告牌的文字”、“野外看到野兽知道立马就跑”、“确定两个物品的远近”等等。<br/>这些都是自然而然发生的，毫不费力，不需要我们仔细的去计算、去思索就能给出的反应。</li><li><b>慢思考 系统</b><br/>慢思考系统的运行是需要 耗费大量脑力的、消耗注意力的、有意识的、需要主动控制的。<br/>从上图左边可以看到，「慢思考」主要用来处理复杂的事情，一些「快思考」所处理不了的事情。例如：“做一个复杂的计算 28乘以12等于多少”、“开车在一个拥挤的车道上转弯”、“做一个复杂的化学实验”、“决定买哪一只股票”、“做工作计划”、“思考一个旅游攻略”等等。<br/>这些都不是凭第一反应和直觉就能给出的答案，是需要大脑更慢、更严谨、需要保持更多的专注、投入更多脑力去思考或者去计算的。</li></ul><p>理论上这两个系统在我们的大脑中是一起协同工作的，帮助我们做判断和决策。</p><p>「快思考系统」是我们直觉和历史经验的结果，它会不断的给「慢思考系统」提供经验、数据、信息，以便「慢思考系统」以后在做出复杂决策时拥有信息依据。</p><p>一般普通的决策并不需要「慢思考」去做判断，大多是由「快思考」凭直觉就迅速给出了判断，如“计算1+1等于多少？”。只有当「快思考」无法迅速给出结果时，如“计算 28乘以12等于多少”，这个时候大脑就会慢下来，由「慢思考」介入，经过心算后再给出结果。</p><p>事实上，我们大脑中的这2个系统并不都是这么完美合作的，由于「快思考」不怎么消耗脑力，而人类大脑又是有惰性的，所以大多数情况中，「快思考」占据了优先、主导的处理权。这样的结果就是，我们响应事情会非常的快，很有效率，但问题就是由于「快思考」是凭直觉的，容易导致偏见，所以经常给出非理性的结果。</p><h3><b>2. 为什么说「快思考」会带来「非理性」决策呢？</b></h3><p>上面我们知道了大脑的思维模式主要由「快思考」所主导。但是为什么说「快思考」给出的决策大多都是非理性的、有偏见的呢？毕竟我们生活中也经常发现通过“直觉”来做出的判断也挺准的呀。</p><p>为了解释这个问题，书中列举了一些我们认知中的一些常见的判断偏差的规律：</p><ul><li><b>大数法则与小数法则</b>：<br/>大数法则，简单讲是指随机事件在大量重复中往往呈现必然的规律。小数法则是指一种心理偏差，人们在思考时候往往容易忽视大数法则的规律反而过于关注典型事件的概率。<br/>举个例子：在一次飞机事故后，大家在各类新闻中就能看到飞机事故的大量报道，如果恰好你也即将要飞机出行，你就会觉得非常的恐慌。因为大家看到新闻后，潜意识的认为飞机事故是一件非常频繁的事情。但是事实上，飞机是所有交通工具中事故率最低的一种，只不过平时的汽车事故太过于频繁，新闻都懒得报道而已。但是在电视机前的你却没有意识到这个大数法则，你关注到了眼前的典型事件，从而容易导致做出错误的判断：把行程中的飞机改为了火车或汽车。</li><li><b>锚定效应</b>：<br/>人们对一项未知量进行评估时，往往容易受到锚定值的影响，从而影响自己的判断。<br/>比如：拿一个盒子放到你手上，让你猜猜多重。没有任何其它信息的情况下，你可能就凭经验猜测了。但是如果在问你盒子多重的时候，多说一句“另外一个盒子的重量是2斤”，那么这个时候你就会下意识的参考另外一个盒子的重量，在那个范围上下给出答案。这就是锚定值对你决策的影响。如果另外一个盒子的重量是骗你的，你很可能对手这个盒子的判断就失误了。</li><li><b>光环效应</b>：<br/>人们很容易先入为主，所以先接触的信息会影响你对事情的判断，并且这个信息和印象会一直影响你长期对这件事的判断。<br/>比如，你要汇报一件事情，“先汇报好的一面，再汇报坏的一面” 要好过 “先汇报坏的一面，再汇报好的一面”。这是人们认知中先入为主的偏差思维导致。</li><li><b>厌恶损失</b>：<br/>人们天生是厌恶损失的，同样是100块钱，得到100块钱的快乐，是无法弥补丢失100块钱的忧伤的。同样是100块钱，在损失的时候，会更为在意。</li><li><b>峰终效应</b>：<br/>这是一个诺贝尔奖得主研究出的定律，指的是一个人对一件事情在深刻记忆由两个因素决定：高峰时、结束时的感觉。也就是说，对一项事物体验以后，所能记住的就只是在峰与终时的体验，而过程中的体验与时长都影响不大。<br/>大家回忆一下自己印象深刻的事情就能理解了，比如高考。</li><li><b>禀赋效应</b>：<br/>人们会对自己拥有的东西越来越喜欢，也就是说一个人一旦拥有了某件物品就会高估这个物品（比拥有前要评估高）。<br/>举例：以房子为例，在你买之前一般都会对优缺点有比较正常的认知。但是一旦你已经买下了那套房子，即使它再小再偏僻，你对它的评估也会高于购买之前，它在你的心里的价位也一定是高于你购买之前的。这就是禀赋效应的认知偏差。</li></ul><p>在这些规律的效应下，我们「快思考」的直觉判断就非常容易失误，非常的不准了，所以会导致我们经常给出非理性的有偏见的结果。</p><h3><b>3. 如何才能避免「非理性」决策呢？</b></h3><p>既然我们知道了采用「快思考」去做决策，容易受到上面这些规律的误导，从而导致我们做出错误的判断。那么我们有没有办法可以减少这些错误的判断，提高决策的质量呢？</p><p>其实很简单，既然大脑中的「快思考系统」不靠谱，那么我们就应该多用用「慢思考系统」。</p><p>当然 了，上面我们提到了咱们的大脑是有惰性的，它并不是非常乐于经常使用「慢思考系统」的，这个时候就需要我们在遇到需要决策的时候，能够主动的慢下来，主动的去思考，甚至是让外部环境多影响自己，让自己多听听别人的建议后再做决策。</p><p>以上，就是对《思考，快与慢》的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "思考", 
                    "tagLink": "https://api.zhihu.com/topics/19551409"
                }, 
                {
                    "tag": "思考，快与慢（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20127515"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66487165", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 6, 
            "title": "微服务架构之「 监控系统 」", 
            "content": "<p>在微服务架构的系列文章中，前面已经通过文章分别介绍过了微服务的「服务注册 」、「服务网关 」、「配置中心 」，今天这篇文章我们继续来聊一聊另外一个重要模块：「 监控系统 」。<br/></p><p>因为在微服务的架构下，我们对服务进行了拆分，所以用户的每次请求不再是由某一个服务独立完成了，而是变成了多个服务一起配合完成。这种情况下，一旦请求出现异常，我们必须得知道是在哪个服务环节出了故障，就需要对每一个服务，以及各个指标都进行全面的监控。</p><h3><b>一、什么是「 监控系统 」？</b></h3><p>在微服务架构中，监控系统按照原理和作用大致可以分为三类（并非严格分类，仅从日常使用角度来看）：</p><ul><li><b>日志类（Log）</b></li><li><b>调用链类（Tracing）</b></li><li><b>度量类（Metrics）</b></li></ul><p>下面来分别对这三种常见的监控模式进行说明：</p><ol><li><b>日志类（Log）</b><br/>日志类比较常见，我们的框架代码、系统环境、以及业务逻辑中一般都会产出一些日志，这些日志我们通常把它记录后统一收集起来，方便在需要的时候进行查询。<br/>日志类记录的信息一般是一些事件、非结构化的一些文本内容。日志的输出和处理的解决方案比较多，大家熟知的有 <b>ELK Stack</b> 方案（Elasticseach + Logstash + Kibana），如图：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8eb864621dbcf1466f19c5df6ad0cb5b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-8eb864621dbcf1466f19c5df6ad0cb5b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"290\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-8eb864621dbcf1466f19c5df6ad0cb5b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8eb864621dbcf1466f19c5df6ad0cb5b_b.jpg\"/></figure><p>使用Beats（可选）在每台服务器上安装后，作为日志客户端收集器，然后通过Logstash进行统一的日志收集、解析、过滤等处理，再将数据发送给Elasticsearch中进行存储分析，最后使用Kibana来进行数据的展示。<br/>当然还可以升级方案为：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-646dc54d9cd81355c22f542df51f90c9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic2.zhimg.com/v2-646dc54d9cd81355c22f542df51f90c9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;206&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic2.zhimg.com/v2-646dc54d9cd81355c22f542df51f90c9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-646dc54d9cd81355c22f542df51f90c9_b.jpg\"/></figure><p>这些方案都比较成熟，搭建起来也比较简单，除了用作监控系统以外，还可以作为日志查询系统使用，非常适用于做分析、以及问题调试使用。</p><ol><li><b>调用链类（Tracing）</b><br/>调用链类监控主要是指记录一个请求的全部流程。一个请求从开始进入，在微服务中调用不同的服务节点后，再返回给客户端，在这个过程中通过调用链参数来追寻全链路行为。通过这个方式可以很方便的知道请求在哪个环节出了故障，系统的瓶颈在哪儿。<br/>这一类的监控一般采用 <b>CAT</b> 工具 来完成，一般在大中型项目较多用到，因为搭建起来有一定的成本。后面会有单独文章来讲解这个调用链监控系统。</li><li><b>度量类（Metrics）</b><br/>度量类主要采用 <b>时序数据库</b> 的解决方案。它是以事件发生时间以及当前数值的角度来记录的监控信息，是可以聚合运算的，用于查看一些指标数据和指标趋势。所以这类监控主要不是用来查问题的，主要是用来看趋势的。<br/>Metrics一般有5种基本的度量类型：Gauges（度量）、Counters（计数器）、 Histograms（直方图）、 Meters（TPS计算器）、Timers（计时器）。<br/>基于时间序列数据库的监控系统是非常适合做监控告警使用的，所以现在也比较流行这个方案，如果我们要搭建一套新的监控系统，我也建议参考这类方案进行。<br/>因此本文接下来也会重点以时间序列数据库的监控系统为主角来描述。</li></ol><h3><b>二、「 监控系统 」关注的对象和指标都是什么？</b></h3><p>一般我们做「监控系统」都是需要做分层式监控的，也就是说将我们要监控的对象进行分层，一般主要分为：</p><ol><li><b>系统层：</b>系统层主要是指CPU、磁盘、内存、网络等服务器层面的监控，这些一般也是运维同学比较关注的对象。</li><li><b>应用层：</b>应用层指的是服务角度的监控，比如接口、框架、某个服务的健康状态等，一般是服务开发或框架开发人员关注的对象。</li><li><b>用户层：</b>这一层主要是与用户、与业务相关的一些监控，属于功能层面的，大多数是项目经理或产品经理会比较关注的对象。</li></ol><p>知道了监控的分层后，我们再来看一下监控的指标一般有哪些：</p><ol><li><b>延迟时间：</b>主要是响应一个请求所消耗的延迟，比如某接口的HTTP请求平均响应时间为100ms。</li><li><b>请求量：</b>是指系统的容量吞吐能力，例如每秒处理多少次请求（QPS）作为指标。</li><li><b>错误率：</b>主要是用来监控错误发生的比例，比如将某接口一段时间内调用时失败的比例作为指标。</li></ol><h3><b>三、基于时序数据库的「 监控系统 」有哪些？</b></h3><p>下面介绍几款目前业内比较流行的基于时间序列数据库的开源监控方案：</p><ul><li><b>Prometheus</b><br/>Promethes是一款2012年开源的监控框架，其本质是时间序列数据库，由Google前员工所开发。<br/>Promethes采用拉的模式（Pull）从应用中拉取数据，并还支持 Alert 模块可以实现监控预警。它的性能非常强劲，单机可以消费百万级时间序列。<br/>架构如下：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-099c071b79eeecf06cd7731c36c0d2cd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"645\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-099c071b79eeecf06cd7731c36c0d2cd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;645&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"645\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-099c071b79eeecf06cd7731c36c0d2cd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-099c071b79eeecf06cd7731c36c0d2cd_b.jpg\"/></figure><p>从看图的左下角可以看到，Prometheus 可以通过在应用里进行埋点后Pull到 Prometheus Server里，如果应用不支持埋点，也可以采用exporter方式进行数据采集。<br/>从图的左上角可以看到，对于一些定时任务模块，因为是周期性运行的，所以采用拉的方式无法获取数据，那么Prometheus 也提供了一种推数据的方式，但是并不是推送到Prometheus Server中，而是中间搭建一个 Pushgateway，定时任务模块将metrics信息推送到这个Pushgateway中，然后Prometheus Server再依然采用拉的方式从Pushgateway中获取数据。<br/>需要拉取的数据既可以采用静态方式配置在Prometheus Server中，也可以采用服务发现的方式（即图的中间上面的Service discovery所示）。<br/>PromQL：是Prometheus自带的查询语法，通过编写PromQL语句可以查询Prometheus里面的数据。<br/>Alertmanager：是用于数据的预警模块，支持通过多种方式去发送预警。<br/>WebUI：是用来展示数据和图形的，但是一般大多数是与Grafana结合，采用Grafana来展示。</p><ul><li><b>OpenTSDB</b><br/>OpenTSDB是在2010年开源的一款分布式时序数据库，当然其主要用于监控方案中。<br/>OpenTSDB采用的是Hbase的分布式存储，它获取数据的模式与Prometheus不同，它采用的是推模式（Push）。<br/>在展示层，OpenTSDB自带有WebUI视图，也可以与Grafana很好的集成，提供丰富的展示界面。<br/>但OpenTSDB并没有自带预警模块，需要自己去开发或者与第三方组件结合使用。<br/>可以通过下图来了解一下OpenTSDB的架构：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-06bcc8e0c9fa33919226227dcef750b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb\" width=\"494\" data-original=\"https://pic1.zhimg.com/v2-06bcc8e0c9fa33919226227dcef750b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;494&#39; height=&#39;317&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"317\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"494\" data-original=\"https://pic1.zhimg.com/v2-06bcc8e0c9fa33919226227dcef750b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-06bcc8e0c9fa33919226227dcef750b4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>InfluxDB</b><br/>InfluxDB是在2013年开源的一款时序数据库，在这里我们主要还是用于做监控系统方案。它收集数据也是采用推模式（Push）。在展示层，InfluxDB也是自带WebUI，也可以与Grafana集成。<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a262fea72e33f8f0c85a6d78e436af6b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic4.zhimg.com/v2-a262fea72e33f8f0c85a6d78e436af6b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic4.zhimg.com/v2-a262fea72e33f8f0c85a6d78e436af6b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a262fea72e33f8f0c85a6d78e436af6b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以上，就是对微服务架构中「 监控系统」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "Java微服务（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20134412"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66097586", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "微服务架构之「 配置中心 」", 
            "content": "<p>在微服务架构的系列文章中，前面已经通过文章《微服务架构之「服务网关 」》介绍过了在微服务中服务网关的原理和应用，今天这篇文章我们继续来聊一聊微服务中另外一个重要模块：「 配置中心 」。后面还会继续介绍 服务框架、服务监控、服务治理等。还是那句话，只有将这些基础设施弄清楚了，微服务实践的道路才能走的稳、走的远。<br/></p><p>「配置中心」，顾名思义，就是用来统一管理项目中所有配置的系统。虽然听起来很简单，但也不要小瞧了这个模块。如果一个中型互联网项目，不采用配置中心的模式，一大堆的各类配置项，各种不定时的修改需求，一定会让开发同学非常头疼且管理十分混乱。我认为甚至可以直接用 “一个项目中是否有无采用「配置中心」” 这一粗略的条件，来判断一个互联网研发团队是否规范和成熟。</p><h3><b>一、为什么需要「配置中心」？</b></h3><p>我们先来看看在没有「配置中心」的传统项目中，我们是怎么处理各类配置参数问题的：</p><ol><li>一般是静态化配置。大多数在项目中单独写一个配置文件，例如 &#34;config.conf&#34;，然后将各类 参数配置、应用配置、环境配置、安全配置、业务配置 都写到这个文件里。当项目代码逻辑中需要使用配置的时候，就从这个配置文件中读取。这种做法虽然简单，但如果参数需要修改，就非常的不灵活，甚至需要重启运行中的项目才能生效。相信大多数开发同学都深有体会。</li><li>配置文件无法区分环境。由于配置文件是放在项目中的，但是我们项目可能会有多个环境，例如：测试环境、预发布环境、生产环境。每一个环境所使用的配置参数理论上都是不同的，所以我们在配置文件中根据不同环境配置不同的参数，这些都是手动维护，在项目发布的时候，极其容易因开发人员的失误导致出错。</li><li>配置文件过于分散。如果一个项目中存在多个逻辑模块独立部署，每个模块所使用的配置内容又不相同，传统的做法是会在每一个模块中都放一个配置文件，甚至不同模块的配置文件格式还不一样。那么长期的结果就是配置文件过于分散混乱，难以管理。</li><li>配置修改无法追溯。因为采用的静态配置文件方式，所以当配置进行修改之后，不容易形成记录，更无法追溯是谁修改的、修改时间是什么、修改前是什么内容。既然无法追溯，那么当配置出错时，更没办法回滚配置了。</li></ol><p>上面只是拿配置文件的形式来举例，有的项目会采用数据库配置，虽然灵活一点，但是依旧不能完全解决上述问题。既然传统的项目配置有这么多弊端，那我们看看「配置中心」的方案是如何解决这些痛点的：</p><p>「配置中心」的思路就是把项目中各种配置、各种参数、各种开关，全部都放到一个集中的地方进行统一管理，并提供一套标准的接口。当各个服务需要获取配置的时候，就来「配置中心」的接口拉取。当「配置中心」中的各种参数有更新的时候，也能通知到各个服务实时的过来同步最新的信息，使之动态更新。</p><p>那么，按照上述思路，我们理想中的「配置中心」应该具备如下特点：</p><ul><li>配置集中管理、统一标准</li><li>配置与应用分离</li><li>实时更新</li><li>高可用</li></ul><p>具有上述特性的「配置中心」是如何解决上面传统配置所面临的问题的呢？</p><ol><li>采用“配置集中管理”，可以很好的解决传统的“配置文件过于分散”的问题。所有的配置都集中在配置中心这一个地方管理，不需要每一个项目都自带一个，这样极大的减轻了开发成本。</li><li>采用“配置与应用分离”，可以很好的解决传统的“配置文件无法区分环境”的问题，配置并不跟着环境走，当不同环境有不同需求的时候，就到配置中心获取即可，极大的减轻了运维部署成本。</li><li>具备“实时更新”的功能，就是用来解决传统的“静态化配置”的问题。线上系统需要调整参数的时候，只需要在配置中心动态修改即可。</li><li>既然配置都统一管理了，那配置中心在整个系统中的地位就非常重要了，一旦配置中心不能正常提供服务，就可能会导致项目整体故障，因此“高可用”就是配置中心又一个很关键的指标了。</li></ol><h3><b>二、「配置中心」的原理与应用？</b></h3><p>通过上面的介绍，其实就可以了解到「 配置中心 」的原理不是很复杂。其核心功能也不多，主要是：</p><ol><li>实现配置的记录</li><li>实现配置的读取、更新、取消</li><li>实现配置的查看</li></ol><p>但是围绕着这几个核心功能，我们还需要保障高可行、要实现实时更新、要能方便的使用，还希望有权限管理的功能、操作审计的功能等等，加上这些周边辅助功能之后，一个完善的「 配置中心 也就不那么简单了。</p><p>我们再来看一下在实际项目中如何去选型和应用：</p><p>虽然配置中心的核心原理并不复杂，我们可以根据原理自己去实现一个配置中心，但是如果没有特殊需求，还是不建议重复造轮子了，毕竟业内已经有很多成熟的开源方案可以直接选用了。下面就列举几个比较热门的配置中心开源组件给大家参考：</p><ul><li><b>Apollo</b><br/>Apollo是由携程开源的分布式配置中心。<br/>Apollo的特点有很多，比如：配置更新之后可以实时生效，还可以支持灰度发布功能。并且能对所有的配置进行版本管理、操作审计等功能，提供开放平台API。另外由于Apollo使用的人很多，所以网上的资料也非常的丰富，并且github上资料也写的很详细。<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1f41e2c608fea1cc82428d5eea2cc74f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"710\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"710\" data-original=\"https://pic4.zhimg.com/v2-1f41e2c608fea1cc82428d5eea2cc74f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;710&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"710\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"710\" data-original=\"https://pic4.zhimg.com/v2-1f41e2c608fea1cc82428d5eea2cc74f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1f41e2c608fea1cc82428d5eea2cc74f_b.jpg\"/></figure><p>上面即是Apollo的基础模型，看结构很简单。但是其功能很多，之前说过配置中心对高可用的要求很高。下面可以继续看一下Apollo的架构：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b351e6ba0eb984faaf9fbc3b1674ea92_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"699\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb\" width=\"699\" data-original=\"https://pic3.zhimg.com/v2-b351e6ba0eb984faaf9fbc3b1674ea92_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;699&#39; height=&#39;603&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"699\" data-rawheight=\"603\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"699\" data-original=\"https://pic3.zhimg.com/v2-b351e6ba0eb984faaf9fbc3b1674ea92_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b351e6ba0eb984faaf9fbc3b1674ea92_b.jpg\"/></figure><p>更多的Apollo资料可以直接去github上查看，可以说官方文档是非常体贴的。</p><ul><li><b>Spring Cloud Config</b><br/>看名字就知道，这是Spring Cloud中带的配置中心组件。也正是这个原因，所以它和Spring是无缝集成，使用起来非常方便。并且它的配置存储支持Git，不过它没有可视化的操作界面，配置的生效也不是实时的，需要重启或去刷新。所以比较适用于小型项目快速上手。<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-81c25761570023bfe37d67a17efa8332_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"327\" class=\"content_image\" width=\"399\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;399&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"327\" class=\"content_image lazy\" width=\"399\" data-actualsrc=\"https://pic3.zhimg.com/v2-81c25761570023bfe37d67a17efa8332_b.jpg\"/></figure><p>Spring Cloud Config包含了Config Client和Config Server两部分，Config Server 实现配置文件的存储，对外以接口的形式提供获取配置文件，然后Config  Client通过这些接口获取数据。</p><ul><li><b>Disconf</b><br/>Disconf是由百度开源的分布式配置中心。其实很多一线大厂都有开源自己的配置中心组件，这里挑出百度的Disconf也是因为网上比较火热，易用性也还不错，项目也是托管在github上很容易找到。它是基于Zookeeper来实现配置变更后实时通知和生效的。<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-125d299302015741de9813063f9550e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-125d299302015741de9813063f9550e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;553&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"553\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"553\" data-original=\"https://pic1.zhimg.com/v2-125d299302015741de9813063f9550e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-125d299302015741de9813063f9550e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以上，就是对微服务架构中「 配置中心」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65751703", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 12, 
            "title": "与技术无关，但却值得码农们好好读一读的怪书：禅与摩托车维修艺术", 
            "content": "<p>最近在读《禅与摩托车维修艺术》这本书，说它很奇怪，其实是因为觉得书名很有意思。看书名，很容易被误解成是一本教人修摩托车的教程，事实上它是一本非常经典的哲学书籍，很多大牛都有推介过这本书。<br/></p><p>著名的物理学家 霍金 曾这样评价这本书：</p><p>“我因为写了一部人们把它和《禅与摩托车维修艺术》相比较的书而感到甚受恭维，我希望拙作（《时间简史》）和《禅与摩托车维修艺术》一样使人们觉得他们不必自处于伟大的智慧及哲学的问题之外”</p><p>其实不单单是霍金，乔布斯也曾经极力的推崇过这本书。</p><p>大家如果留心就会注意到很多程序员大牛也在自己的一些技术著作或者书单中提到过这本书，我当时看到这个书名就很奇怪，修个摩托车跟程序员有啥关系，为啥这么多大牛都这么崇拜呢。哈哈，现在看过之后，才发现真的是一本很有意思的哲学小说。</p><h3><b>1.</b></h3><p>其实这并不是一本非常容易理解的书，尤其是在看第一遍的时候。</p><p>虽然这是一本“游记”，讲述的是作者带着儿子的一次摩托车旅行经历，但在游记中穿插了很多作者对自己内心思想的描述，对追求「 良质 」的思考。</p><p>「 良质 」是这本书的重点，一种说不清道不明，不能用言语文字表达的东西，但又是我们每个人在生活工作中所应追求的境界。</p><h3><b>2.</b></h3><p>虽然书名叫做《禅与摩托车维修艺术》，但本书并不讲“禅”。况且如果是一位外国人来讲“禅学”，咱们也不信啊。那作者为什么要取这么个书名呢？</p><p>“禅”是一个哲学概念，表现的大家对内心朴质的探索。而“摩托车维修”又是一门科学知识。作者其实是想在旅行中探索这种内心的主观追求与现实的客观世界之间寻求一种平衡的境界。</p><h3><b>3.</b></h3><p>作者希望大家能看到不一样景，能思考着不一样的问题，能悟到不一样的东西。</p><p>例如在讲骑摩托车旅行的感受时描述到：</p><blockquote>骑摩托车旅游和其他的方式完全不同。坐在汽车里，你只是局限在一个小空间之内，因为已经习惯了，你意识不到从车窗向外看风景和看电视差不多。你只是个被动的观众，景物只能呆板地从窗外飞驰而过。骑摩托车可就不同了。它没有什么车窗玻璃在面前阻挡你的视野，你会感到自己和大自然紧密地结合在了一起。你就处在景致之中，而不再是观众，你能感受到那种身临其境的震撼。</blockquote><h3><b>4.</b></h3><blockquote>我并不想仓促行事，因为仓促本身就是 20 世纪最要不得的态度，当你做某件事的时候，一旦想要求快，就表示你再也不关心它，而想去做别的事。</blockquote><p>这段话简直道出了真谛。如果我们在做一件自己真正关心、真正喜欢、真正享受的事情，我们的内心不会去追求快，我们反而会希望慢起来，享受这个过程，用心的去做。如果我们在仓促行事，说明我们手里虽然在做，但是心里想着别的事情，想赶紧把手头的事情赶紧仓促完成。如果是这样，那何不干脆一开始就不做呢。</p><p>举一个生活中例子，有的朋友会炫耀自己每个月读了多少多少书，看了多少多少文章，为这些数字所自豪。但是那些书是他们用心去看完的吗，还是仓促的翻完的。看书的终极目的到底是在于享受知识获取的过程，还是在于炫耀读过的数量呢。</p><h3><b>5.</b></h3><p>「 良质 」到底是什么呢？</p><p>内心的宁静、全心投入当下、感受幸福。</p><p>「 良质 」是一种境界，需要大家自己去悟。</p><p>作者在书中反复思量、反复论证、反复比喻，但终无法用一段文字去定义。不可说，不是不想说，是无法用文字语言去描述，强行去描述，其实也就不是那个东西了。虽然不可说，但又可以用行动去“证”、去“悟”。全情投入到一件事情中，到达禅宗讲到的“物我两忘”的境界，在境界里所产生的那种愉悦感，那种感受也许就是「 良质 」，王阳明也称之为「 致良知 」。</p><h3><b>6.</b></h3><p>书中以维修摩托车为题材，认为大多数人对待手头上做的事情是不关心的、浮躁的，所以很麻木、按部就班的按照说明书在进行，也非常容易遇到卡壳儿的问题，卡住了之后，更是不知道如何进入下一步。但具有「 良质 」的境界却是这样：</p><blockquote>一个人在维修摩托车的时候，对车子的了解分分秒秒都在改变，因而得到了全新认识，其中蕴含了更多的良质。维修的人不会受限于传统的做法，因为他有足够理性的基础拒绝这些思想。真实不再是静态的，它不是让你决定是要去奋战还是打退堂鼓的思想，它们是会跟着你成长的思想。所以具有良质的真实，它的本质不再是静态的，而具有爆炸性的威力，一旦你了解了这一点，就永远不会被卡住了。它虽然有形式，但是这种形式可以改变。</blockquote><p>如果换做程序员的角度，其实我们写程序跟维修摩托车难道有很大不同吗，如果程序员只是为了完成任务，并不是真心关心自己在写的东西，一样会枯燥、一样会乏味。如果我们是用心，用一种具有「 良质 」的境界去对待这份事情，结果可能就会大不一样。</p><p>作者认为：如果一个人在工作的时候，能够看到良质，而且感觉到它的存在，那么他就是一个懂得关心的人。如果一个人对自己所看到的和手中所做的都细致入微地关心，那么他一定有某些良质的特性。</p><h3><b>7.</b></h3><blockquote>在所有关乎技艺方面的工作背后，都有一个“道”或类似于“禅”的东西，一通百通。有时，你就得放弃已有的工匠情结，更多地要把自己的理念，思想都糅合在一个物件上，这时技术只是一个副产品罢了。</blockquote><p>作者虽然讲的是维修摩托车，但这一段似乎更像是程序员的编程。</p><p>我们不能沉迷与编程技术的表面，我们应该去看到代码的背后，用心的去对待这件事情，把自己的思想融入进去，投入你的热忱到编程这件事上，让自己接近「 良质 」，也许这就是为什么无论哪行哪业做到最顶峰的时候都呈现出一副艺术家的气息，不要小瞧编程这件事，码农艺术家多着呢。</p><h3><b>8.</b></h3><p>作者把看世界的角度分为2个认知，一个是「 古典的认知 」、另一个是「 浪漫的认知 」。</p><blockquote>古典的认知认为这个世界是由一些基本形式组成的，而浪漫的认知则是从它的表象来观察。如果你拿一部发动机或是机械图，或是电子仪表给浪漫的人看，他一定不感兴趣，因为他所看到的只是表象，枯燥无味，只是列出一大堆复杂的专有名词、线条和数字，没有让他觉得有趣的事。但是如果你把这些东西拿给一个偏向古典思想的人看，他会仔细地观察，然后就会着迷，因为他看到在这些线条和符号之后是丰富的基本形式。</blockquote><p>作者的这个思想，跟一个我之前看过的叫做「 二元论 」思想很类似。百度百科上是这么解释「 二元论 」：</p><p>「 二元论 」认为世界是存在2个实体的，一个是只有广延而不能思维的“物质实体”，另一个是只能思维而不具广延的“精神实体”，二者性质完全不同，各自独立存在和发展，谁也不影响和决定谁。</p><p>但是本书的作者明显是反对这种二分法的，他认为这两种认知是可以融合的，并且他认为「 良质 」就是这两种认知的结合体，甚至认为「 良质 」就是「 古典的认知 」与「 浪漫的认知 」的发源地。</p><h3><b>9.</b></h3><p>阅读这类哲学书籍，其实难度挺大的，我自己理解的很浅显。</p><p>如果在读书的时候，是一颗浮躁的心，就更难融入进去，很难理解到书中的思想。但哲学其实存在于每个人的心中，在思考问题和解决问题的时候，大家都会不自主的使用到哲学的理论。所以这本书值得每年翻开读一遍。</p><p>以上，就是对《禅与摩托车维修艺术》这本书的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提高 认知、成长、大数据、架构、Web技术 等。</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "禅与摩托车维修艺术（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/19753007"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63713593", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 21, 
            "title": "微服务架构之「 API网关 」", 
            "content": "<p>在微服务架构的系列文章中，前面已经通过文章<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502281%26idx%3D1%26sn%3D62f7c7c50a1a2465772bf84a3b69aafc%26chksm%3Df2509983c5271095c6dca5bc7d52ec5feb84de8301b7d2e8cb9510c205dce62d3be601652245%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《架构设计之「服务注册 」》</a>介绍过了服务注册的原理和应用，今天这篇文章我们来聊一聊「 API网关 」。<br/></p><p>「 API网关 」是任何微服务架构的重要组成部分。有了它我们可以在一个独立的模块上方便的处理一些非业务逻辑，可以让微服务本身专注在自身特定的功能上，使得每个微服务的开发更容易和更快速。</p><p>后面还会有文章继续介绍 配置中心、服务框架、服务监控、服务追踪、服务治理等。还是那句话，只有将这些基础设施弄清楚了，微服务实践的道路才能走的稳、走的远。</p><h3><b>一、为什么需要「 API网关 」？</b></h3><p>为什么做微服务的需要「 API网关 」呢？「 API网关 」到底有些啥功能呢？我们以前项目结构比较简单的时候有用到过「 API网关 」概念的模块吗？</p><p>其实在我们的项目曾经还是单体应用的时候，虽然没有「 API网关 」的概念，但是一般在项目中都会用到filter/过滤器之类的东西，filter的作用就是把项目中的一些非业务逻辑的功能抽离出来独立处理，避免与业务逻辑混在一起增加代码复杂度。比如 鉴权认证功能、Session处理、安全检查、日志处理等等。</p><p>现在我们采用微服务架构了，在一个项目中微服务节点很多，如果让每一个节点都去处理上面这些 “鉴权认证功能、Session处理、安全检查、日志处理等” 会多出很多冗余的代码，也会给增加业务代码的复杂度，因此我们就需要有一个「 API网关 」把这些公共的功能独立出来成为一个服务来统一的处理这些事情。</p><p>我们看一下下面这个微服务架构示意图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3ddc1a3914a610052382c55f8e87e464_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb\" width=\"568\" data-original=\"https://pic1.zhimg.com/v2-3ddc1a3914a610052382c55f8e87e464_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;568&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"477\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"568\" data-original=\"https://pic1.zhimg.com/v2-3ddc1a3914a610052382c55f8e87e464_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3ddc1a3914a610052382c55f8e87e464_b.jpg\"/></figure><p>「 API网关 」就像是微服务的大门守卫一样，是连通外部客户端与内部微服务之间的一个桥梁。</p><p>其主要功能有：</p><ul><li><b>路由转发</b><br/>之前说了「API网关」是内部微服务的对外唯一入口，所以外面全部的请求都会先发到这个「API网关」上，然后由「API网关」来根据不同的请求去路由到不同的微服务节点上。例如可以 根据路径 来转发、也可以 根据参数 来转发。<br/>并且由于内部微服务实例也会随着业务调整不停的变更，增加或者删除节点，「API网关」可以与「服务注册」模块进行协同工作，保证将外部请求转发到最合适的微服务实例上面去。</li><li><b>负载均衡</b><br/>既然「API网关」是内部微服务的单一入口，所以「API网关」在收到外部请求之后，还可以根据内部微服务每个实例的负荷情况进行动态的负载均衡调节。一旦内部的某个微服务实例负载很高，甚至是不能及时响应，则「API网关」就通过负载均衡策略减少或停止向这个实例转发请求。当所有的内部微服务实例都处理不过来的时候，「API网关」还可以采用限流或熔断的形式阻止外部请求，以保障整个系统的可用性。</li><li><b>安全认证</b><br/>「API网关」就像是微服务的大门守卫，每一个请求进来之后，都必须先在「API网关」上进行身份验证，身份验证通过后才转发给后面的服务，转发的时候一般也会带上身份信息。<br/>同时「API网关」也需要对每一个请求进行安全性检查，例如参数的安全性、传输的安全性等等。</li><li><b>日志记录</b><br/>既然所有的请求都需要走「API网关」，那么我们就可以在「API网关」上统一集中的记录下这些行为日志。这些日志既可以作为我们后续事件查询使用，也可以作为系统的性能监控使用。</li><li><b>数据转换</b><br/>因为「API网关」对外是面向多种不同的客户端，不同的客户端所传输的数据类型可能是不一样的。因此「API网关」还需要具备数据转换的功能，将不同客户端传输进来的数据转换成同一种类型再转发给内部微服务上，这样，兼容了这些请求的多样性，保证了微服务的灵活性。</li></ul><h3><b>二、「 API网关 」原理与应用？</b></h3><p>上面聊完了「为什么需要API网关」，我们再来看一下在实际项目中应该如何去应用。虽然我们可以自己去开发一套「API网关」，但是如果没有特殊需求，还是不建议重复造轮子了，市面上有很多成熟的方案可以直接使用，下面简单介绍一下 Zuul、Tyk、Kong三个比较热门的开源组件。</p><ul><li><b>Zuul</b><br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7a634838140b175aab7612f71a4545c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"346\" data-rawheight=\"205\" class=\"content_image\" width=\"346\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;346&#39; height=&#39;205&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"346\" data-rawheight=\"205\" class=\"content_image lazy\" width=\"346\" data-actualsrc=\"https://pic2.zhimg.com/v2-7a634838140b175aab7612f71a4545c5_b.jpg\"/></figure><p><br/>Zuul 是由 Netflix 所开源的组件，基于JAVA技术栈开发的。<br/>Zuul网关的使用热度非常高，并且也集成到了 Spring Cloud 全家桶中了，使用起来非常方便。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eeb2bd3078bf4d79e9a8fc6ea422659a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"707\" data-original=\"https://pic3.zhimg.com/v2-eeb2bd3078bf4d79e9a8fc6ea422659a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;707&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"707\" data-original=\"https://pic3.zhimg.com/v2-eeb2bd3078bf4d79e9a8fc6ea422659a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-eeb2bd3078bf4d79e9a8fc6ea422659a_b.jpg\"/></figure><p>上图可以看到Zuul的一个简化结构，过滤器filter是整个Zuul的核心，分为前置过滤器（pre filter）、路由过滤器（routing filter）、后置过滤器（post filter）以及 错误过滤器（error filter）。<br/>一个请求过来，会先执行所有的 pre filter，然后再通过 routing filter 将请求转发给后端服务，后端服务进行结果响应之后，再执行 post filter，最后再响应给客户端。在不同的filter里面可以执行不同的逻辑，比如安全检查、日志记录等等。</p><ul><li><b>Tyk</b><br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8156db68be578811918ca2ab758eb41a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"441\" data-rawheight=\"162\" class=\"origin_image zh-lightbox-thumb\" width=\"441\" data-original=\"https://pic3.zhimg.com/v2-8156db68be578811918ca2ab758eb41a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;441&#39; height=&#39;162&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"441\" data-rawheight=\"162\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"441\" data-original=\"https://pic3.zhimg.com/v2-8156db68be578811918ca2ab758eb41a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8156db68be578811918ca2ab758eb41a_b.jpg\"/></figure><p><br/>Tyk是一个基于GO编写的，轻量级、快速可伸缩的开源的API网关。<br/>可以通过下图简单了解一下Tyk的流程原理。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ba74b76489cc9d3c554ae4de4294d897_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-ba74b76489cc9d3c554ae4de4294d897_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-ba74b76489cc9d3c554ae4de4294d897_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ba74b76489cc9d3c554ae4de4294d897_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>Kong</b><br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cd48982d56b7fd1bb0f2cd2e11f69c8e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb\" width=\"517\" data-original=\"https://pic3.zhimg.com/v2-cd48982d56b7fd1bb0f2cd2e11f69c8e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;517&#39; height=&#39;169&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"517\" data-original=\"https://pic3.zhimg.com/v2-cd48982d56b7fd1bb0f2cd2e11f69c8e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cd48982d56b7fd1bb0f2cd2e11f69c8e_b.jpg\"/></figure><p>Kong是基于OpenResty技术栈的开源网关服务，因此其也是基于Nginx实现的。<br/>Kong可以做到高性能、插件自定义、集群以及易于使用的Restful API管理。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5ff1c411063f30a737aedfe97de4f0e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic3.zhimg.com/v2-5ff1c411063f30a737aedfe97de4f0e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;542&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"542\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic3.zhimg.com/v2-5ff1c411063f30a737aedfe97de4f0e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5ff1c411063f30a737aedfe97de4f0e6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以上，就是对微服务架构中「 服务网关」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "微服务设计（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20128680"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60777641", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 8, 
            "title": "微服务架构之「 服务注册 」", 
            "content": "<p>微服务架构是一个庞大复杂的工程，为什么说它庞大复杂呢？因为想要做好微服务，就必须先要建设好微服务所需的一系列基础设施和组件。我在前面的文章<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650502269%26idx%3D1%26sn%3D40d7f1c18d3dec82686b4ffc4ad5f935%26chksm%3Df2509977c5271061a7130c75251f16f6579a8b4ae9b7b9650e509700696e112cb0ede3c49dc8%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《架构设计之「 微服务入门 」》</a>中已经初步介绍过了这些组件，包括：服务注册、服务网关、配置中心、服务框架、服务监控、服务追踪、服务治理等。<br/></p><p>只有将这些基础设施搭建完善了，微服务实践的道路才能走的稳、走的远。后面的文章中会依次把每一个基础组件都详细分析一下。今天我们就先挑选「 服务注册 」聊一聊。</p><h3><b>一、为什么需要「 服务注册 」？</b></h3><p>我们先来举一个生活中的例子：在以前互联网还不够发达的时候，“114号码百事通”大家应该很熟悉，有啥需求就会去打个电话查询一下。比如想知道附近电影院电话是多少，就会先去打114问一下。那114为啥知道这么多信息呢，还不是因为各类服务者（商店、机构等）都已经在114上登记了嘛。所以这里的“114百事通”就相当于一个服务注册中心了，这里的各类商店机构就相当于可以提供不同服务的服务者了，而打电话的我们就是去寻找这些服务的消费者了。</p><p>我们再来回到微服务架构中，一般集群都会部署很多个微服务节点。这些节点一般也具备这2种角色，称为：“服务的提供者” 和 “服务的消费者”。</p><p>“服务消费者”需要调用“服务提供者”的API来获得服务。当“服务提供者”的节点有增加或减少的时候，也得让调用者（“服务消费者”）及时的知晓。而在大规模集群中，一般节点数目都很多，节点变化频繁，通过手动去维护这些节点的状态是不现实的，因此需要一个叫做“服务注册中心”的组件来实现。</p><p>“服务提供者”将自己的服务地址等信息登记到“服务注册中心”中，调用者（“服务消费者”）需要的时候，每次都先去“服务注册中心”查询即可。既解决了人工维护微服务节点状态的问题，也能解决多节点间负载均衡的问题。</p><h3><b>二、「 服务注册 」的实现原理是什么？</b></h3><p>在分析其原理之前，我们先来看一下这里包含的一些角色，有三类：“服务提供者”、“服务消费者”、“服务注册中心”。</p><p>其中“服务提供者”需要将自己的服务信息注册到“服务注册中心”里面。而“服务消费者”需要到“服务注册中心”里面去查询有哪些服务可以调用。因此，我们可以分为两个视角去分析原理：</p><ul><li><b>从“服务提供者”的视角， “服务提供者”向“服务注册中心”进行注册：</b><br/>登记注册具体的也有为两种方式，一种是 <b>自己注册</b>，另一种是 <b>第三方注册</b>。</li></ul><ol><li>自己注册：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5ecf7d9ac6c55dc2cafe2ce3e6c4fe93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-5ecf7d9ac6c55dc2cafe2ce3e6c4fe93_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-5ecf7d9ac6c55dc2cafe2ce3e6c4fe93_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5ecf7d9ac6c55dc2cafe2ce3e6c4fe93_b.jpg\"/></figure><p><br/>如图，自己注册就是指微服务节点在启动的时候，自己去服务注册中心登记注册了，把自己的信息和状态传过去。这种方式整体结构比较简单，对于注册中心而言也比较省事，但是对于微服务节点而言，每个微服务都得包含这么一段注册的逻辑代码，架构上看起来不是很优美。<br/>再拿114百事通的例子解释一遍，自己注册就表示这是商家开店之后自己跑去告诉114电话台，说自己商店开业了，目前在经营着哪些服务，请求114登记下来。</p><ol><li>第三方注册：<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-047115e6f362e1cee8fb8d42712cbc02_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-047115e6f362e1cee8fb8d42712cbc02_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-047115e6f362e1cee8fb8d42712cbc02_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-047115e6f362e1cee8fb8d42712cbc02_b.jpg\"/></figure><p><br/>如图，第三方注册就是指有一个“服务管理器”（图中的Service Manager），这个“服务管理器”会去管理所有的微服务和进程，以轮询或其它方式去检查有哪些微服务实例正在运行，会将这些微服务实例自动更新到服务注册中心。这是目前比较常用的方式，例如Eureka就是采用这个模式。<br/>如果再拿114百事通的例子来讲，就相当于114中心安排了一个管理员，这个管理员会定期的到街上去看一看有哪些新开的商店就把它登记下来，有哪些关闭了的商店就从注册中心删除掉。</p><ul><li><b>从“服务消费者”的视角，“服务消费者”向“服务注册中心”查询和调用服务：</b><br/>对于服务的查询和调用，也分为两种模式：<b>客户端模式</b> 和 <b>代理模式</b>。</li></ul><ol><li>客户端模式<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fed3d066e41cfd68b3d659390ca1d544_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"653\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb\" width=\"653\" data-original=\"https://pic1.zhimg.com/v2-fed3d066e41cfd68b3d659390ca1d544_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;653&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"653\" data-rawheight=\"435\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"653\" data-original=\"https://pic1.zhimg.com/v2-fed3d066e41cfd68b3d659390ca1d544_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fed3d066e41cfd68b3d659390ca1d544_b.jpg\"/></figure><p><br/>在客户端模式下，“服务消费者”（图中的Client）在向“服务注册中心”查询到自己需要调用的“服务提供者”的地址之后，“服务消费者”（客户端）就会自己根据地址去访问微服务（图中的第3步 API Gateway是可选项，有API Gateway的情况下，API Gateway起到负载均衡作用，没有第3步的话，那就是Client直接调用Microservice，需要Client自己写负载均衡逻辑）。<br/>客户端模式在实现上比较简单。</p><ol><li>代理模式<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-963ce8e78cfcbeccfd74503e55915526_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-963ce8e78cfcbeccfd74503e55915526_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;313&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"313\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-963ce8e78cfcbeccfd74503e55915526_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-963ce8e78cfcbeccfd74503e55915526_b.jpg\"/></figure><p><br/>在代理模式下，“服务消费者”（图中的Client）与 微服务、“服务注册中心”中间有一个 API Gateway组件相隔着。“服务消费者”只管去找API Gateway访问即可。至于去注册中心查询服务地址，以及访问服务地址的动作都由API Gateway效劳了，最后API Gateway在把结果返回给“服务消费者”即可。<br/>这种模式，看起来“服务消费者”省事了，但是API Gateway模块却复杂了，因为API Gateway就是整个系统的一个非常核心关键节点了，不仅需要保障自己的稳定性和性能，而且还需要处理一些负载均衡的逻辑。在大型架构中，这种模式用的还比较多。</p><h3><b>三、「 服务注册 」如何实践？</b></h3><p>讲完了服务注册中心的必要性和原理，我们再来看一下在实际应用中应该如何去应用。虽然我们可以根据原理自己去开发一套服务注册中心，但是如果没有特殊需求，还是不建议重复造轮子了，市面上有很多成熟的方案可以直接使用。</p><ul><li><b>Eureka</b><br/>Eureka是由Netflix开源，其架构如下图：<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8dd143597c4697bb2ae788239ad9a4f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"687\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb\" width=\"687\" data-original=\"https://pic4.zhimg.com/v2-8dd143597c4697bb2ae788239ad9a4f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;687&#39; height=&#39;388&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"687\" data-rawheight=\"388\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"687\" data-original=\"https://pic4.zhimg.com/v2-8dd143597c4697bb2ae788239ad9a4f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8dd143597c4697bb2ae788239ad9a4f3_b.jpg\"/></figure><p><br/>从图中可以看到，我们的服务（图中Application Clinet与Application Service）要使用Eureka就需要集成它的SDK（图中Eureka Client）。图中的Eureka部署在了三个异地机房，也就是说Eureka是支持多中心部署的。<br/>服务提供者（Application Service）通过Eureka Client实现服务的注册、更新和注销等。服务消费者（Application Clinet）通过Eureka Client实现服务的查询和调用。<br/>Eureka支持了与Spring Cloud的集成，所以使用起来也非常方便，目前属于比较流行的方案。</p><ul><li><b>Consul</b><br/>Consul是另外一个非常流行的开源组件，如下图:<br/></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-22296d1caa494eba6aceef9b37a0eed5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"432\" class=\"content_image\" width=\"418\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;418&#39; height=&#39;432&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"432\" class=\"content_image lazy\" width=\"418\" data-actualsrc=\"https://pic2.zhimg.com/v2-22296d1caa494eba6aceef9b37a0eed5_b.jpg\"/></figure><p><br/>Consul是在服务外进行完成一系列动作的，也就是说并不需要服务节点去依赖它的SDK，没有侵入性，所以跨语言的解决能力更强一些。它一般是在服务节点外通过一些探针的方法去检查应用是否存活，是否需要注册或注销。<br/>Consul也支持Spring Cloud集成，所以使用起来也很方便，也属于比较流行的方案。</p><ul><li><b>Etcd、Zookeeper</b><br/>这两个也有一些公司基于它们来实现服务注册，也集成了Spring Cloud，不过不算非常广泛。</li></ul><p>以上，就是对微服务架构中「 服务注册 」的一些思考。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、架构、大数据、Web技术 等。 </blockquote>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60659022", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 8, 
            "title": "别被「 稀缺心态 」控制了你的人生", 
            "content": "<p>先来解释一下「 稀缺 」这个概念。<br/></p><p>「 稀缺 」是指当你对某个资源的“拥有”程度少于你对它的“需要”程度时，你所产生的感觉，大白说就是说“欲望大于现实”，哈哈，当然这个也被称为「 稀缺心态 」。</p><p>其实真正的资源匮乏并不可怕，可怕的就是由于资源匮乏之后导致你产生了这种稀缺心态。</p><p>这也是最近在读《稀缺》这本书后所了解到的，以前还不觉得，但是搞懂了「 稀缺 」这个概念之后，对生活中以前很多不理解的现象都也有略有些明白了，比如为什么富人越来越富，有时间的人越来越有时间。就是因为这些人能更好避免陷入「 稀缺心态 」的陷阱，避免被「 稀缺心态 」控制自己的行为。</p><h3><b>一、「 稀缺 」是什么？</b></h3><p>「 稀缺 」不单单是指物质上的，它其实指代各类资源。包括 金钱、时间 都可以用是否稀缺来衡量。举个例子，如果你正在写一本书，跟出版社约好了本周末交稿，但是到了周三你还只写了一半，这个时候你肯定就觉得剩下的时间非常紧急了，就会火急火燎的去写，会全神贯注的去写，那么这个时候你就进入了一种「 稀缺 」的状态。</p><p>从上面的例子来看，稀缺状态是一件好事情，可以让人们的注意力集中在如何最有效的去完成目前的任务。</p><p>这种针对稀缺带来的好处，我们称之为「 专注红利 」，也就是说无论是工作还是娱乐，只要时间有限，我们都会尽量将其利用得淋漓尽致，这是稀缺心态带来的正面积极成果。</p><p>但事实上，「 稀缺心态 」除了带来了这么一点好处之外，还随之附带很多问题：由于稀缺俘获了我们的注意力，带来专注的好处使我们在应对紧迫需求时能做得更好。但从长远来看，我们损失了其它东西，因为我们在专注某一件事情的同时，思想总是围绕着稀缺在打转，会忽视其他很多也需要关注的事项，导致在生活的其他方面难以有精力投入，变得难以有成效。</p><p>下面就会来详细解释一下这一现象。</p><h3><b>二、「 稀缺 」带来的问题？</b></h3><p>一旦陷入「 稀缺心态 」，带来的主要问题有如下几点：</p><ol><li><b>让人产生“管窥”效应</b><br/>管窥效应是什么意思呢，就像是我们通过一根管子去看外面的世界一样，虽然很聚焦，但是只能看到管子那么大的一片儿，这种现象也叫作“隧道视野”。<br/>上面讲了“专注”是有积极意义的。但是这个“管窥效应”则是消极的，稀缺导致我们有了管窥之见，让我们忽略了其他可能更重要的事情。<br/>就算我们想要试着做点别的事情，稀缺的“管子”还是会将我们的目光吸引进来，稀缺心态意味着我们在人生的另一个角度上，我们的注意力更少，投入的心思也更少。<br/>《稀缺》一书中举了一个美国消防员的例子，可能大部分想到消防员的牺牲都是在救火场上，但是事实上，他们大多数牺牲在了去救火路上的交通事故上，主要原因就是没有系安全带。可是消防员每周接受的培训都是安全教育，系安全带是最基础的内容了，为什么在现实情况下却一而再的被消防员忽略呢。调查发现，消防员在接到火警后，必须在60秒内穿好消防服、准备好设备上车，并且在车上就要开始规划救援方案，在这种紧急的情况下，会让消防员产生对时间的稀缺心态，虽然让消防员很专注在当前的救援工作上，但是由于“管窥效应”也导致了消防员们忽略了自身的安全，导致大量消防员忘记了系安全带。</li><li><b>会产生“借用”现象</b><br/>当人们面临资源稀缺的时候，常常通过“借用”的方式去应对突发事件。从长远来看，“借用”会进一步加剧稀缺。<br/>这里的“借用”，不单单是指金额，还有 时间 也是一样会产生借用。比如上面的例子，由于你要赶着这周末写书交稿，所以这周的全部时间都可能被你拿去“借用”了，那么这周原计划的其它事情，比如健身、学习、陪家人 等事情的时间就被你借用出去了，而这个借用还会导致雪崩效应，进一步加剧你时间的稀缺。</li><li><b>会导致没有“余闲”</b><br/>“余闲”是指多出来的资源，比如金钱、时间等。<br/>既然资源都稀缺匮乏了，那肯定也不会有“余闲”了。但是没有余闲就无法应对突发事件，比如，如果你没有金钱的余闲，那你就没办法应对突发的用钱需求。如果你没有时间的余闲，那你就没有没法应对突发的时间耽搁问题。余闲是应对突发事件的缓冲机制。<br/>任何一点小小的不稳定都会威胁到处于稀缺边缘的人们，因为他们没有足够的余闲去吸收这些不稳定因素。稀缺会导致没有余闲，而没有余闲又会进一步加剧稀缺。</li><li><b>会引起“心智带宽”的负担</b><br/>“心智带宽”是指一个人心智的容量，它包括两种能力，认知能力和执行控制力。“心智带宽”是有限的，稀缺会不断的让大脑处理“管窥”里的内容，那就会减少他能处理别的事情的精力。稀缺会降低一个人所有这些带宽的容量，导致他缺乏洞察力和前瞻性，还会减弱他的执行控制力。</li></ol><p>在稀缺状态下，我们会产生管窥心态。当稀缺成为带宽负担时，我们会对当下更加关注，从而导致我们产生借用行为。而当我们借用时，就是给自己的将来挖下了更深的坑。今天的稀缺，将造成明天更大的稀缺。</p><h3><b>三、如何解决「 稀缺心态 」？</b></h3><p>要想避免或者解决「 稀缺心态 」问题，必须要能做到“节省心智带宽”和“留有余闲”。</p><p>“节省心智带宽”就要我们减少处理日常琐事的精力，把心智带宽留给值得真正关注的事情上面。有效利用好心智带宽是避免稀缺的重要方法。</p><p>“留有余闲”就是尽量的不要借用、不要透支，在生活中要养成在金钱和时间方面留出充裕的余闲可支配。</p><p>「 稀缺 」就是一种心态，调整好自己的心态，就能更好的驾驭自己的人生。</p><p>以上，就是对稀缺心态这一现象的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p>", 
            "topic": [
                {
                    "tag": "稀缺：我们是如何陷入贫穷与忙碌的（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20129571"
                }, 
                {
                    "tag": "心态", 
                    "tagLink": "https://api.zhihu.com/topics/19569950"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60658848", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 6, 
            "title": "架构设计之「 微服务入门 」", 
            "content": "<p>微服务这几年不可谓不火，很多技术团队都开始在自己的项目上引入了微服务。一方面这些团队确实很好的推动了微服务的应用和发展，另一方面也可以看到一些盲目追技术热点的行为所带来的危害，比如很多中小团队对微服务的基础知识只是做了很浅显的了解就开始盲目的推动微服务的实施，最后导致了项目的失败。<br/></p><p>微服务要想做好是一个非常复杂的架构，今天就先只聊一聊微服务的一些基础架构，算是入门篇。</p><h3><b>一、什么是「 微服务 」？</b></h3><p>「 微服务 」由 Martin Fowler 提出，它是指一种软件架构风格。一个大型的系统可以由多个微服务组成，每个微服务是被独立部署，独立完成自己的任务单元，微服务之间是通过API方式进行通信调用，是松耦合的。</p><p>这个模式听着是不是很熟悉的感觉？</p><p>因为在提出「 微服务 」概念之前，很多互联网公司的中大型项目早就是按照将业务拆分成独立单元的形式在部署和架构的，这与微服务的思路是一脉相通的，只不过实现方式没有现在这么规范与体系。</p><p>那「 微服务 」到底是怎么演变过来的呢？</p><p>在做一个新项目的时候，一开始项目大多数都很小，都是「 单体应用 」，这是很常见的做法。在项目规模小的时候，这种方式开发效率和运维效率都最高，符合互联网公司快速响应的要求。</p><p>但是随着业务量越来越大，项目也越来越复杂，开发团队人员也越来越多。这个时候还采用单体应用，问题就会很明显了。下面挑选两个最为常见的问题来举例：</p><ul><li><b>协同问题：</b>多个人同时开发一份代码，在工作协同上就会经常遇到代码冲突问题。</li><li><b>可用性问题：</b>因为是单体应用，即使改个最小的功能，也需要整体发布，不仅直接影响了线上可用性，还可能会对正常功能带来风险。</li></ul><p>为了解决这些问题，大家就开始考虑将「 单体应用 」进行拆分，进行服务化部署。然后又随着 Martin Fowler对「 微服务 」概念的提出，加上 DevOps 的流行，进一步促进了微服务的火热发展。</p><p>「 微服务 」的理念提倡每个服务都是单一职责，且每一个服务都能实现自治，因此可以带来一些明显好处：</p><ul><li><b>部署简单：</b>每个微服务都可以独立去部署，方便快捷。</li><li><b>逻辑清晰：</b>将一个独立功能逻辑封装在单一微服务里面，实现整体项目的逻辑清晰。</li><li><b>可扩展：</b>因为可以随时增加和减少微服务，可以很方便的扩展功能。</li><li><b>可靠性高：</b>某一个功能的异常可以隔离在单一微服务里面，可以提高整体可靠性。</li></ul><h3><b>二、「 微服务 」的架构是什么样？</b></h3><p>我们先来看一下「 微服务 」的架构图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;657&#39; height=&#39;595&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\"/></figure><p>（图片来源网络，粉丝太少就懒得画图了，大家发挥一下想象力将就的看看，哈哈）</p><p>看起来挺复杂对不对，事实上也确实很复杂。</p><p>所以微服务并不是适用于所有项目、所有团队的。在应用之前一定要搞清楚是否适合自己。</p><p>要保证这么一套微服务架构能成功运行起来，我们起码需要以下这些 <b>微服务的基础组件</b>：</p><ul><li><b>服务注册</b><br/>部署了一个微服务节点，得让调用者知道啊，当微服务节点有增加或减少的时候，也得让调用者及时知晓啊。这些问题都是通过“服务注册”组件来实现的，服务提供者将自己的服务地址等信息登记到“服务注册”组件中，调用者需要的时候，每次都先去查询“服务注册”即可。免去人工维护微服务节点的信息同步问题。</li><li><b>服务网关</b><br/>是指提供给外部系统调用的是统一网关。主要做安全和权限控制等。</li><li><b>配置中心</b><br/>微服务的配置中心是用来统一管理所有微服务节点的配置信息的。因为同一个程序可能要适用于多个环境，所以在微服务实践中要尽量做到程序与配置分离，将配置进行集中管理。包括微服务节点信息、程序运行时配置、变量配置、数据源配置、日志配置、版本配置等。</li><li><b>服务框架</b><br/>是指用来规范各个微服务节点之间通信标准的。服务间通信采用什么协议、数据是如何传输的、数据格式是什么样的。有了这个统一的“服务框架”就能保证各个微服务节点之间高效率的协同。</li><li><b>服务监控</b><br/>微服务运行起来之后，为了能够监控节点的健康情况，保障节点的高可行，需要对各个服务节点进行收集数据指标、然后对数据进行实时处理和分析，形成监控报表和预警。</li><li><b>服务追踪</b><br/>一旦使用了微服务架构，那么当有请求过来时，就会经过多个微服务节点的处理，形成了一个调用链。为了进行问题追踪和故障的定位，需要对请求的完整调用链进行记录。<br/>这里的服务追踪与上面的服务监控是不同维度的，一个是全局的，一个是微观的，发挥的作用也不一样。</li><li><b>服务治理</b><br/>就是指需要通过准备一些策略和方案，来保障整个微服务架构在生产环境遇到极端情况下也能正常提供服务的措施。比如 熔断、限流、隔离等等。</li></ul><p>当然，上述只是一个微服务架构最为核心的基础组件，一旦微服务体系过大，例如有几十上百个微服务节点，那么开发、维护、测试的成本就会非常大。因此一般还会引入 自动化部署 和 自动化测试 来提高协同效率。</p><h3><b>三、「 微服务 」入门如何避免踩坑？</b></h3><p>你以为微服务架构都是下面这样的吗？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;657&#39; height=&#39;595&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"595\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"657\" data-original=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5ffdc9c51d3d0713cab7ea01cf92ca76_b.jpg\"/></figure><p>事实上，更能是下面这样的，哈哈。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0bdfa686ba3420e9514ed51615e4354b_b.jpg\"/></figure><p>（图片来源网络）</p><p>大家都在宣扬「 微服务 」多么多么的好，例如：易扩展、松耦合、服务简单、独立开发、易维护、轻量级等等。虽然这些优势也是事实，但是「 微服务 」带来的问题也很多，尤其是对于刚入门的团队而言，应用微服务后，趟坑真的可以趟到你崩溃。下面就普及一些常见的问题来给大家打个预防针：</p><ul><li><b>不是所有项目都适用微服务</b><br/>有些项目规模还比较小，或者项目才刚立项启动，也只有三四个人负责开发维护，这时候是不建议一上来就搞微服务架构的。这种情况下搞微服务，不仅是“杀鸡用牛刀”，而且还无谓的增加了项目的复杂度，本身一个单体结构就可以搞定的事情，非得拆分N多节点，人员又不足以支撑这么多节点的开发维护，这完全是自找苦吃。反而是等项目成熟了、规模大了之后，再开始慢慢将原有结构拆为微服务才是正确的做法。</li><li><b>不要拆分过多过细的服务</b><br/>即使项目经过评估后适合拆为微服务架构，但也不要过度拆解。有的团队喜欢将项目拆成很细很细的颗粒，最后把项目搞的特别复杂，整个团队都陷进去了。<br/>拆分服务的颗粒度应该根据业务发展和团队现状综合去考虑。这里可以参考一个很火的理论<b>「 康威定律 」</b>。什么样的团队，就产生什么样的架构，微服务拆分的颗粒度是需要和团队结构相匹配的。当你着手拆微服务的时候，得先评估一下团队人员和素质，一般在开发期，2-3个人开发一个服务是合理的，在维护期，1个人维护2-3个服务也是合理的。<br/>如果拆分过细，开发人员跟不上，会严重降低大家的工作效率。并且过细的服务，会导致一个请求的调用链条很长，不仅会影响请求的响应时间，也会对线上问题排查带来增加难度。</li><li><b>没有DevOps就不要急于微服务</b><br/>一个稳定的微服务架构，是需要 持续集成、自动化部署、自动化测试、健全的监控体系来保障的。如果团队还不具备DevOps，这些基础的建设都没有做好，一上来就搞微服务的话，就会导致实施过程中问题百出，微服务的优势不能发挥。</li></ul><p>以上，就是对架构设计中「 微服务基础 」的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p>", 
            "topic": [
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59799739", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 5, 
            "title": "大多数人的努力程度都远远不够，远没有到拼运气的地步", 
            "content": "<p>看过了太多的鸡汤文章，导致我们常常以为只要通过个人努力就能获得成功，但事实上却并非如此简单。<br/></p><p>先抛出两个真相：</p><ul><li><b>成功之路除了需要勤奋努力以外，还需要一点运气</b></li><li><b>大多数人的努力程度都远远不够，远没有到拼运气的地步</b></li></ul><p>最近看了一本书《异类》，据说是很多大佬都有推荐，连微信之父的张小龙都推荐过。</p><p>记得在很早之前罗永浩也推荐过这本书，当时还不太理解，现在看到锤子手机的商业局面，才大概明白他的用意，估计罗胖在推荐《异类》的时候就是想要告诉大家「 时运 」对于创业来说真的太重要了。</p><h2><b>一、想要获得成功，人人都离不开10000小时的刻意练习</b></h2><p>一项研究结果发现，任何一个领域的世界级水平都需要起码10000小时的训练。无论是 钢琴家、歌手、运动选手、棋手，要想进入领域内金字塔的顶端，都离不开10000小时的练习，这就是著名的「 一万小时理论 」。</p><p>为什么是一万小时？而不是一千小时、一百小时。因为一个人在学习过程中，如果要完美的掌握某项复杂的技能，就需要一遍一遍的苦练，当这个练习时间达到了一个临界值的时候，会发现其技艺有了明显的飞跃。研究者们通过对各个领域专家们的长期跟踪，发现这个临界值就是一万小时。</p><p>所以，任何人想要在专业领域内获得成功，都必须先做到这10000小时的努力。</p><p>不信？我们来举2个名人的例子：</p><ul><li><b>Sun公司的天才创始人 比尔乔伊的10000小时</b><br/>乔伊在1971年进入密歇根大学，从大二起正式学编程，因为大学计算机中心漏洞导致可以24小时开放，从那时起，计算机中心就成了乔伊生活的全部，他利用一切可以用的时间去编程，他每天编程十几个小时，在加上每年的暑假，几乎没日没夜的编程。后来乔伊在1975年转如加州大学伯克利分校后，第一年又是日日夜夜的编程，晚上两三点才睡觉，经常直接就趴在键盘上睡着了。后来有人对乔伊进行采访，他回忆后说道，那段时间大概编程时间不少于10000小时吧。</li><li><b>微软的创始人 比尔盖茨的10000小时</b><br/>比尔盖茨的成长经历一直都被人津津乐道，数学天才爱上计算机编程，从哈佛辍学，创业微软。人们只知道这其中的传奇色彩，但是却不知道这背后比尔盖茨付出的练习的努力。<br/>从1968年上八年级的别尔盖茨就在学校接触到了分时电脑去学习编程，到后来1971年比尔盖茨为ISI公司免费编写程序以换取电脑上机时间，在ISI公司每周7天，每天8个小时，长达7个月里共编程了一千多小时，为了有更多的编程时间，后来每天凌晨3-6点偷偷溜出家门去学校医学中心使用电脑，再后来利用整整一个春季在TRW公司的时间去编程，前前后后编程时间是不少于10000小时练习的。</li></ul><p>当然，这里只是挑选了程序员们熟知的名人的作为例子，实际上生活中的各个领域都是类似。</p><p>不过需要特别注意的是，这里的10000小时绝对不单单付出时间去重复就够了，还得必须是刻意练习。也就是说要在训练中去不停的改进、去积累、去学习，以取得进步，不停的向更高难度去挑战的训练方式。</p><p>程序员圈子也流传着一个玩笑：一名程序员去面试，写了十年代码，但是面试官却说他只有一年的工作经验，为什么呢？因为他的其它9年都是在复制粘贴之前的代码，没有任何的改进，这不是真正的刻意练习。</p><h2><b>二、你以为只努力就够了吗？还要看你是否有这个命运</b></h2><p>上面虽然讲了成功需要大家努力的刻意练习，但是你以为单单这样就够了吗？下面给你举几个例子：</p><ul><li><b>加拿大的明星冰球队</b><br/>一项对加拿大的顶级冰球队成员年纪的研究发现，绝大部分球员都是出生在1-3月份，这难道是巧合吗？后来研究组又陆陆续续对其它类型的运动顶级团队做了同样的研究，发现规律都非常相似。<br/>难道在一年中头三个月出生的小孩运气更好？体能更好？<br/>其实这三个月并有什么特殊的魔力，真正的原因是因为加拿大冰球队每年在选拔的时候会按照年纪分组，且分组的分界线是1月1日，即从1月1日到当年12月31日之间出生的球员会被分到同一个组进行比赛选拔。那么这也就意味着1月1日出生的选手是在跟许多年纪比他小的队友在争夺晋级权。要知道对于十来岁的小孩而言，相差一年或几个月年纪在生理成熟度上可是会有巨大的差异。<br/>加拿大每年对十来岁小孩就开始选拔优秀选手组成“巡回赛小组”，对于未被选入的选手只能进入“基础组”。“巡回赛小组”有更优秀的教练、更好的设备、更长时间的训练。<br/>出生在前三个月的小孩，在一开始因为年纪上几个月的优势，所以选入了“巡回赛小组”，然后又因为获得了更好的训练，所以进一步变得更好更出色了，最后也会更容易进入顶级的职业青年队。<br/><b>这就是命运，除了努力之外的命运。</b><br/>因为一开始的微小优势，慢慢扩大了他和那些队友之间的差距，随后差距与机会交替发挥作用，微小额度差距被越拉越大。</li><li><b>中产家庭的教育与文化</b><br/>《异类》书中还举了一个中产家庭的例子，由于中产家庭更注重“协同教育”，而普通家庭更多是“随意教育”，导致小孩从小时候就面临不同的境遇，不同的成长环境，微小的优势也会被慢慢放大，从而改变人生的轨迹。</li></ul><p>这种现象也叫做「 马太效应 」：<b>“凡是有的，还有加给他，叫他更多；没有的，连他所有的，也要夺过来。”</b></p><p>成功者，往往就是获得了这些特殊命运眷顾的人，他们因此最终取得了更大的进步。富有者因取得了更多的减税优惠从而变得更富有。成绩优异的学生因获得了更优秀的老师的指导，更多的关注，从而取得更好的成绩。</p><h2><b>三、你以为加上出身就够了吗？还要看你是否有后天的机遇</b></h2><p>上面知道了要努力，也知道了需要几分天出身命运因素，那有了这些就足够了吗？还不是。</p><p>还要看你是否有后天的造化，也就是机遇，要想取得大成，要看时代给不给你机会，要跟着趋势走。</p><ul><li><b>比尔盖茨的运气</b><br/>如果比尔盖茨只靠自己10000小时的努力，靠自己出身的中产家庭的条件和文化的话，相信足以让他成为一个混得不错的人，也能有所小成就。但要达到他今天这般非凡企业家的成就，单单这些可不行。还需要一个时代给予他的趋势与机遇。<br/>1975年1月是个人电脑时代的起点，是人类历史上在个人电脑上的技术突破。在那之前计算机还是一个巨大的昂贵的放在实验室的玩意儿。既然1975年1月是个人电脑时代的黎明，那谁将是占据最有利的位置去享受黎明第一线曙光的人呢？<br/>如果在1975年，你的年纪太大。那个时候你可能已经毕业，有能力和才华的人已经在IBM等大公司上班，这种微型电脑小玩意儿在你眼中就是小打小闹无暇顾及，甚至你已经有家庭有小孩也不可能投入整么一个新的产业里去冒险。如果在1975年，你的年纪太小。可能你还在上高中，即便想进入这一行当，也相当困难。<br/>所以你的年龄必须不大也不小，正好赶上了个人电脑的革命，就像1955年出生的比尔盖茨。这是时代给你的机遇，这个可不容易创造，这是抓紧趋势的机会。</li><li><b>大韩航空的文化影响</b><br/>《异类》一书中还讲到另一个大韩航空801航班事故的例子。空难是由于一系列错误后才最终导致发生的，但其中有很重要一点必须引起人们注意的就是“文化的影响”。<br/>研究发现，在这些国家的航空公司里，由于文化的原因，虽然一架飞机配备了机长和副机长，但机长是具有绝对权威的，常常在飞机发生异常的时候，即使副机长发现了问题，但往往副机长不能勇敢的、直接的表达出自己的观点，更不敢直接夺取飞机控制权（虽然 飞行手册上是允许的），最终导致了事故的发生。<br/>这种因为“权利距离”因素导致的空难在某些有特定文化的国家里一而再的发生，而并非某个机长能力好就能避免的。也可以看到，一个机长的最终成功与否也同样受到文化的影响，这是后天影响，非个人努力所能决定。</li></ul><p>大多数人以为成功完全是个人努力的结果。但是所有的有关成功人士的历史都说明，事情并非那么简单。历史恰恰说明，那些获得特殊机遇眷顾的人们总能努力工作，与机遇相伴的人总能取得非常的成就。他们的成功并不仅仅是自己努力的成果，更是独特成长环境促成的结果。</p><p>所有成功人士都是幸运的，外部因素的影响大于个人努力，但个人努力是不可或缺的基础。如果你连努力都没有，机遇你也是永远抓不住的。</p><p>还有个事实就是，大多数人的努力程度都远远不够，远没有到拼运气的地步。在想获得大成功之前，先靠个人的努力去取得小成功吧。</p><p>以上，就是对个人努力与成功的一些思考。</p><p>码字不易啊，喜欢的话不妨转发朋友，或点击文章右下角的“在看”吧。😊</p><blockquote>本文发布公众号「 不止思考 」，欢迎关注。涉及 思维认知、个人成长、技术架构、大数据、后端技术等。 </blockquote><p></p><p></p>", 
            "topic": [
                {
                    "tag": "个人努力", 
                    "tagLink": "https://api.zhihu.com/topics/19939343"
                }, 
                {
                    "tag": "成功", 
                    "tagLink": "https://api.zhihu.com/topics/19551436"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59327194", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 14, 
            "title": "架构设计之「 CAP 定理 」", 
            "content": "<p>在计算机领域，如果是初入行就算了，如果是多年的老码农还不懂 CAP 定理，那就真的说不过去了。CAP可是每一名技术架构师都必须掌握的基础原则啊。<br/><br/>现在只要是稍微大一点的互联网项目都是采用 分布式 结构了，一个系统可能有多个节点组成，每个节点都可能需要维护一份数据。那么如何维护各个节点之间的状态，如何保障各个节点之间数据的同步问题就是大家急需关注的事情了。<br/>CAP定理是分布式系统中最基础的原则。所以理解和掌握了CAP，对系统架构的设计至关重要。</p><p><br/><b>一、什么是 CAP？</b><br/>「 CAP定理 」又被称为 布鲁尔定理，它提出对于一个分布式系统而言，不能同时满足以下三点：<br/></p><ul><li><b>Consisteny（一致性）</b></li><li><b>Availability（可用性）</b></li><li><b>Partition tolerance（分区容错性）</b></li></ul><p>也就是说CAP定理指明了，任何分布式系统只能同时满足这三项中的两项。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_b.jpg\"/></figure><p>如上图，如果是最多同时满足两项，那我们可以有三个组合：CA、CP、AP。在聊这三个组合之前，我们先分别看一下 Consisteny（一致性）、Availability（可用性）、Partition tolerance（分区容错性）的含义。<br/>假设某个系统当前有两个节点A和B，两个节点分别可以由Actor进行读写，两个节点之间的数据会自动完成同步。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;611&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_b.jpg\"/></figure><ol><li><b>Consisteny（一致性）</b><br/>一致性的要求是指，对于任何客户端（上图Actor）来说，每次的读操作，都能获得最新的数据。即，当有客户端向A节点写入了新数据之后，其它客户端从B节点中进行读操作所获得的数据必须也是最新的，是与A节点数据保持一致的。</li><li><b>Availability（可用性）</b><br/>可用性的要求是指，每个请求都能在合理的时间内获得符合预期的响应（不保证获取的结果是最新的数据）。<br/>按照上图来看就是，客户端只要向A节点或B节点发起请求后，只要这两个节点收到了请求，就必须响应给客户端，但不需要保证响应的值是否正确。</li><li><b>Partition tolerance（分区容错性）</b><br/>分区容错性是指，当节点之间的网络出现问题之后，系统依然能正常提供服务。</li></ol><p>讲完了C、A、P的含义和要求，我们继续来看看它们之间如何组合使用。<br/><b>二、CAP 怎么应用？</b><br/>先把视野回到这张图上：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-72a7673f42985100a0b0a5f4a314d94b_b.jpg\"/></figure><p>虽然我们知道有 CA、CP、AP 三种组合方式，但是在分布式系统的结构下，网络是不可能做到100%可靠的。既然网络不能保证绝对可靠，那 P（分区容错性）就是一个必选项了。原因如下：<br/>如果选择 CA组合，放弃 P（分区容错性）。还是以最上面的图中A和B节点来举例，当发生节点间网络故障时，为了保证 C（一致性），那么就必须将系统锁住，不允许任何写入操作，否者就会出现节点之间数据不一致了。但是锁住了系统，就意味着当有写请求进来的时候，系统是不可用的，这一点又违背了 A（可用性）原则。<br/>因此分布式系统理论上是不可能有CA组合的，所以我们只能选择 CP 和 AP组合架构。<br/>下面我们来详细看一下  CP架构 和 AP架构的特点：<br/></p><ol><li><b>CP 架构</b><br/>CP架构即 Consisteny（一致性）与 Partition tolerance（分区容错性）的组合。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-57cd2ace74d83a1f441f32d49a561dae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"596\" data-original=\"https://pic3.zhimg.com/v2-57cd2ace74d83a1f441f32d49a561dae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;596&#39; height=&#39;414&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"596\" data-original=\"https://pic3.zhimg.com/v2-57cd2ace74d83a1f441f32d49a561dae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-57cd2ace74d83a1f441f32d49a561dae_b.jpg\"/></figure><p><br/>如上图，由于网络问题，节点A和节点B之前不能互相通讯。当有客户端（上图Actor）向节点A进行写入请求时（准备写入Message 2），节点A会不接收写入操作，导致写入失败，这样就保证了节点A和节点B的数据一致性，即保证了Consisteny（一致性）。<br/>然后，如果有另一个客户端（上图另一个Actor）向B节点进行读请求的时候，B请求返回的是网络故障之前所保存的信息（Message 1），并且这个信息是与节点A一致的，是整个系统最后一次成功写入的信息，是能正常提供服务的，即保证了Partition tolerance（分区容错性）。<br/>上述情况就是保障了CP架构，但放弃了Availability（可用性）的方案。</p><ol><li><b>AP 架构</b><br/>AP架构即 Availability（可用性）与 Partition tolerance（分区容错性）的组合架构。<br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;611&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"611\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"611\" data-original=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bed76ce8670b9086d9132766fbd94841_b.jpg\"/></figure><p><br/>如上图，由于网络问题，节点A和节点B之前不能互相通讯。当有客户端（上图Actor）向节点A进行写入请求时（准备写入Message 2），节点A允许写入，请求操作成功。但此时，由于A和B节点之前无法通讯，所以B节点的数据还是旧的（Message 1）。当有客户端向B节点发起读请求时候，读到的数据是旧数据，与在A节点读到的数据不一致。但由于系统能照常提供服务，所以满足了Availability（可用性）要求。<br/>因此，这种情况下，就是保障了AP架构，但其放弃了 Consisteny（一致性）。</p><p><b>三、CAP 注意事项？</b><br/>了解了CAP定理后，对于开发者而言，当我们构建服务的时候，就需要根据业务特性作出权衡考虑，哪些点是当前系统可以取舍的，哪些是应该重点保障的。<br/>即使是在同一个系统中，不同模块的数据可能应用的CAP架构都是不同的。举个例子，在某个电商系统中，属于用户模块的数据（账密、钱包余额等）对一致性的要求很高，就可以采用CP架构。而对于一些商品信息方面的数据对一致性要求没那么高，但为了照顾用户体验，所以对可用性要求更高一些，那么这个模块的数据就可以采用AP架构。<br/>另外，虽然上面第二节讲到过我们只能选择CP和AP，无法选择CA。但这句话成立的前提条件是在系统发生了网络故障的情况下。然而，网络故障的概率在系统的整个生命周期中占比是很小的，因此我们在设计的时候，虽然要考虑网络问题下的方案，但也要考虑网络正常情况下的方案，即在网络正常情况下，CA是可以实现的，我们也需要去保证在绝大多数时间下的CA架构。<br/>再者，即使我们按照CAP定理，三个中只能取其二，但不代表我们只需要保障其中的两点，而完全的放弃第三点，我们应该为不能保障的第三点也做一些防备措施或者冗余方案，来使系统更加的完善健全。</p><p><br/>以上，就是对CAP定理的一些思考。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，一起提升 认知、工作成长、大数据、架构、Web等技术。<br/></p><p>码字不易啊，喜欢的话各位看官不妨转发朋友吧。</p><p></p>", 
            "topic": [
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58998672", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "真的可以「 人人都是产品经理 」吗", 
            "content": "<p>现在互联网上各种媒体、各种课程 都在宣扬着「 人人都是产品经理 」的理念。虽然初衷是好的，是希望大家都能基于产品思维去思考问题和把握项目方向，但真正能做到的却寥寥无几。<br/><br/>因为一名合格的产品经理需具备的素质和要求其实是非常高的。产品经理往往是大多数项目成功如否的关键因素之一， 产品经理必须要能探索出有价值的产品，还需要评估出产品的可用性、可行性，并最终按预期交付给用户。<br/>在这个号称「 人人都是产品经理 」的时代，一名真正优秀的产品经理就显得格外紧俏了。<br/>最近看了《启示录》这本书，虽然主要讲的是如何打造用户喜爱的产品，但其中产品经理的部分也梳理的很透彻，很有学习的价值。今天我就结合在《启示录》中理解到的内容，一起来聊一聊，什么是一名优秀的产品经理，应该如何去做。</p><p><br/><b>一、产品经理的职责？</b><br/>产品经理要做的工作有很多，但是梳理其核心职责，主要为两点：</p><ul><li><b>探索有价值的产品机会</b></li><li><b>确定产品的解决方案</b></li></ul><p>下面来分析一下这两个职责。</p><ol><li><b>探索有价值的产品机会</b><br/>产品经理不一定是需求方，不一定是 idea 的发起人，但他必须得是 idea 的评估人。有时候 idea 的来源有很多，可能是 公司老板、领导、也可能是用户/客户、还有可能是同事、朋友。但无论是谁提出的 idea，最终都需要由产品经理去负责审核这些点子，去调研和判断当前 idea 有没有价值，是否可行，避免给公司浪费时间和资源。<br/>评估的方法有很多，这属于产品经理的通用技能。但思路上可以围绕着以下几个问题去透视：<br/>（1）产品的价值：这个产品要解决什么问题<br/>（2）目标市场：这个产品是为谁解决问题的<br/>（3）市场情况：这个产品能做多大，成功机会有多大，时机对不对<br/>（4）度量指标：用什么指标去判断这个产品是否成功<br/>（5）竞品格局：市面上有哪些同类产品，我们的优势是什么，成功的条件是什么<br/>（6）推广策略：产品推广营销的方式是什么</li><li><b>确定产品的解决方案</b><br/>当产品经理已经完成上面第一步，探索出了一个有价值且符合公司发展方向的产品机会（idea）后，就应该开始第二项工作：确定这个产品的解决方案了。<br/>确定产品的解决方案主要是指：要明确这个产品的 基本功能、特征、用户体验、边界、核心亮点 以及 发布标准 等。<br/>这一步需要与各方沟通，例如 市场、设计、研发、测试 等可能影响产品最终构成了各个方向人员进行充分的沟通和探讨，最后敲定的产品方案可以通过 PRD（产品需求文档）和 原型 来作为交付物。</li></ol><p><b>二、产品经理的协作？</b><br/>在项目中，产品经理应该是一个需要与不同职能方向的人员打交道最多的人。他除了需要深入产品，也需要深入熟悉与自己协作的团队，这样才能保障最终产出的产品符合当初的计划。</p><ul><li><b>产品经理与项目经理</b><br/>首要要明白，产品经理不是项目经理，虽然很多公司把产品经理当做项目经理在用，但随着产品功能越来越多，产品发布流程越来越复杂，产品经理是没有精力去兼职项目经理工作的，必须有单独的项目管理岗位出来对项目推进负责。<br/>产品经理的职责是探索有价值的、可行的产品。而项目经理则关注如何执行计划以便按期交付产品。</li><li><b>产品经理与设计师</b><br/>一个好的产品必须具备好的用户体验，甚至有的时候用户体验就是产品的生命。产品经理应该与交互设计师、视觉设计师 密切的配合，设计出良好的用户体验，打造出好用的产品。</li><li><b>产品经理与程序员</b><br/>产品经理与程序员的协作非常关键，因为程序员就是那个最终将产品idea实现出来的人。有的公司里面产品经理的地位似乎比程序员要高一些，因为看起来产品经理就是那个决定开发什么功能的角色。<br/>但《启示录》中建议，产品经理要想与程序员完美协作的话，很重要的一点就是要双方承认彼此平等，即任何一方不从属另一方，一个提需求，一个负责实现，双方互相依赖。</li></ul><p>除了上述以外，在产品经理的协作要点中，一定要记住「留空间 」，什么意思呢？<br/>业务方/市场方 在给产品经理提想法/提需求的时候，一定要给产品经理留出自主空间。<br/>产品经理 在给 设计师、程序员 提想法/需求的时候，也一定要给他们留出足够的自由发挥空间。</p><p><br/>乔治史密斯巴顿有一句名言：<br/><b>「永远不要告诉别人怎么做。告诉他们做什么，他们自然会发挥天赋，给你惊喜 」</b></p><p><br/><b>三、如何打造富有创意的产品？</b><br/>虽然在《启示录》中提到了打造富有创意的产品十大要点，但我觉得并不全适用于现在很多互联网场景。因此我结合自身经验，总结了以下几点与大家分享：</p><ul><li><b>最好的创意来自于普通员工</b><br/>虽然大多数产品创意是来自于公司领导或业务市场部门，大家都认为优秀的产品是战略规划的结果，不可否认，有这个因素。但还有很多来自于身边普通员工的idea也很有价值，尤其是公司在尝试创新项目的时候，多去问问最了解那一块的同事与朋友，一定会有很大的收获。<br/>Google公司就是一个典型，它允许员工每周拿出20%的时间去尝试自己得想法，开发自己感兴趣的项目，无论这个项目与平时的工作相不相关，通过这个方式去发挥员工的主管能动性，鼓励大家创新。事实上从Google的产品上也可以证明这个方法是有效的，Google很多伟大产品都是由员工自主创新的，比如 Gmail、Goole News、AdSense等。</li><li><b>产品评审团</b><br/>一个 idea 要不要被执行，必须得有人拿出决定，敲定出产品决策，单单产品经理可不行。为了保证这种产品决策的效率，就可以引入一种「 产品评审团 」的方式。<br/>采用产品评审团，是一个可以让公司相关人员及时作出明智的产品决策的有效方法。目的是通过评审的方式来制定公司产品的战略方向，监督公司产品的研发流程、有效的配置公司资源。具体方式如下：</li></ul><ol><li>第一步，列出待评估的产品idea，让相应的产品经理进行说明和评估</li><li>第二步，对选出的已评估完有价值的产品idea去确定产品解决方案</li><li>第三步，评审产品原型、成本、收益预期等，以决定是否开发此产品</li><li>第四步，评审最终的产品，涉及 功能、品质，影响等，以决定是否发布此产品<br/>四个步骤分别在产品的不同时期进行会议评估，需要公司各部门的关键人员参与决策。</li></ol><ul><li><b>提早试用</b><br/>尽早的给未来的用户试用。在产品还未开发出来之前，就应该拿出 高保真的产品原型图 给用户去试用，收集改进建议。在产品完成但未发布之前，就应该选出部分的种子用户去试用产品，收集优化建议。<br/>越早试用，让产品越早面对真实用户，就能越早避免问题。</li><li><b>最小产品</b><br/>这一点有些类似于产品MVP原则，MVP也叫最小化可行产品。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4dee9369097c75647e3a874be6343910_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"505\" data-original=\"https://pic1.zhimg.com/v2-4dee9369097c75647e3a874be6343910_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;505&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"505\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"505\" data-original=\"https://pic1.zhimg.com/v2-4dee9369097c75647e3a874be6343910_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4dee9369097c75647e3a874be6343910_b.jpg\"/></figure><p>如图，以交付交通工具为例，不是让先造一个轮子，再造一个壳子。而是可以先造一个滑板车，再升级为自行车，最终升级为汽车。因为最终的需求是制造出快速的交通工具交付用户。通过MVP的方式可以提前测试用户的需求是否真实，是否成立。</p><ul><li><b>懂用户情感需求</b><br/>一个优秀的产品经理，必须得懂得用户的情感诉求。<br/>就连咱们的微信之父 张小龙 都说过：产品经理要懂得抓住用户的贪嗔痴。<br/>其实这就是只要懂用户的情感诉求，产品经理要去深入的了解用户的想法和感受，抓住用户的情感需求，尤其是 非理性用户的情感需求，因为这类需求更为典型，属于放大后的情感需求。先理解了 非理性用户，再去理解 理性用户和观望者用户就容易了。</li></ul><p>以上，就是对优秀产品经理的一些思考。码字不易，喜欢的话分享给朋友吧。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作成长、大数据、架构、Web等技术。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "产品经理", 
                    "tagLink": "https://api.zhihu.com/topics/19551325"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58557972", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "如何从程序员到架构师？", 
            "content": "<p>作为程序员，我们应该如何去规划好自己的职业道路？<br/></p><p>作为程序员群体的一员，我发现身边很多同学都非常的踏实，虽然这是一个很好的素质，但我们除了踏实做事以外，也需要多抬头看看路。才能让自己在职业道路上走的更稳更长久。</p><p>身边很多同学都知道去追求升职加薪，但却很少去考虑一个完整的职业规划，很少去考虑自己的职业目标。对于以后自己是去做 技术管理？还是做 技术架构？又或者是干脆转行？很少去思考。</p><p>因此，今天我就来跟大家简单聊一聊程序员的职业发展路径。</p><h2><b>一、先看看各技术层级的要求？</b></h2><p>在聊程序员的发展之前，我们先看一下常见的互联网公司技术团队里，程序员这职业的等级是怎么划分的？</p><p>一般分为以下几个级别，再往上可能就是技术专家或者首席技术官了。</p><ul><li><b>初级工程师</b></li><li><b>中级工程师</b></li><li><b>高级工程师</b></li><li><b>资深工程师/架构师</b></li></ul><p>下面继续看一下每个级别的素质要求是什么？</p><ol><li><b>初级工程师</b><br/>初级工程师主要是指刚毕业的，职场上的技术新人。通常这类人会有一定的专业理论知识，所以也能够比较快的学习公司的常用框架、工具和开发技术。能够在上级/导师的指导下，理解相关的业务知识。<br/>能够按照研发需求完成部分模块和功能的开发，能够在别人的指导下解决研发中遇到的问题。</li><li><b>中级工程师</b><br/>中级工程师是大多数三到五年程序员所处的水平。中级工程师必须要能够独立承担开发任务，并且能够独立负责某个模块或小系统。<br/>能够根据自己的历史经验和学习能力，独立解决日常工作中遇到的技术问题。</li><li><b>高级工程师</b><br/>高级工程师，一般是混迹多年，且有一定技术积累的程序员，有一套自己的开发方法。对于高级工程师要求能快速的理解业务、够独立负责一个中大型系统，且在工作中需具备指导他人的能力，属于团队骨干，在团队中有一定的技术影响力。</li><li><b>资深工程师/架构师</b><br/>程序员到了资深的级别之后，其实在职业上可以分为两个发展方向。<br/>一个是继续往技术深度上钻研，在某个技术领域内有一定的深度和影响力，我们称为资深工程师。<br/>还有另一个方向就是往技术的广度上发展，除自身技术线以外，对周边相关技术也有一定的研究和理解，能够站在更高的维度上去俯视项目里的技术结构，业务理解能力也很强，根据不同业务，设计出不同的技术方案，这一类我们称为架构师。</li></ol><p>上面虽然从企业的用人视角来列举了不同技术层级应具备的要求，但还是不够具体，不太方便量化和评估，因此，我们可以根据上面的要求，总结出一套对程序员的评估方法，主要分为三个方面：</p><ol><li><b>通用素质：</b><br/>用来评估程序员的通用素质水平。比如 系统思维能力、沟通表达能力、经验开放意识、严谨性、组织能力、影响力等。</li><li><b>知识技能：</b><br/>用来评估程序员的知识和技术水平。比如 编程语言、安全、框架应用、系统设计等能力。</li><li><b>业务能力：</b><br/>这个主要用来评估程序员的业务理解能力、业务建模能力等。</li></ol><h2><b>二、有哪些基础技能是都必须具备的？</b></h2><p>在知道了程序员各不同层级的能力模型后，我们再来看一下有哪些基础的技术能力是不同层级都应该具备的，是程序员技术水平的基石：</p><ol><li><b>数据结构</b><br/>数据结构是基础中的基础。有些人觉得数据结构的知识貌似在实际工作中用到很少，反而在面试中问的多，所以就认为这个东西不实用。殊不知数据结构是我们编码的根本。只不过我们平时用的框架工具多了，很多都被封装好了，大家直接调用即可，导致大家对这一块儿渐渐忽略了。但是只有真正理解了数据结构，我们才能写出有质量的代码。<br/>常用的数据结构有：数组、链表、堆栈、队列、树、二叉树、图等。</li><li><b>常用算法</b><br/>算法是每一个程序员都绕不开的话题。但算法跟数据结构一样也是编程的灵魂，是真正区别出不同程序员编程水平的地方，每个技术人都应该学好。</li><li><b>数据存储</b><br/>存储是每个项目的必须环节。以数据库举例，有关系型的数据库，还有NoSQL数据库等，另外还有文件存储系统。这些在做项目中都可能遇到，所以需要熟练掌握其原理和用法。</li><li><b>编程规范</b><br/>编程规范这个自然不必多说，也是最容易看出程序员水平的地方。虽然很多不规范的代码也能运行，但是作为一个有追求的程序员，理应按照一定的编程规范去管理好自己的代码。优秀的程序员始终要有个理念记在心中：代码的第一作用是给人读的，第二作用才是给机器使用。</li><li><b>开发平台</b><br/>这里指的是程序员常用的编程语言、以及语言所在的生态和框架。以Java程序员举例，必须得深入了解Java的语言特性，以及Java这个语言平台的生态体系，同时熟练掌握Java的常用框架和主流方案，每一个语言都有这样的平台与生态。</li><li><b>安全</b><br/>粗略可分为代码安全和运维安全。<br/>代码安全指的是程序员在开发项目的时候，编写出来的代码应具备一定的安全性，例如 防止XSS跨站攻击、防止SQL注入等等。这些除了写代码的时候要注意，后期也可以通过单元测试、代码评审来发现风险。<br/>运维安全是项目在生产环境下，部署的环境安全、资源隔离、运维操作规范、漏洞扫描等方面的安全工作。</li></ol><h2><b>三、如何打造属于自己的技术体系？</b></h2><p>技术的成长是靠一步一步走出来的，不可能一口吃个胖子。既然上面聊了程序员在这条职业道路上应该具备的一些技能和素质。那这里就再补充一下如何去提高这些技能，如何去一步一步走出自己的技术体系。</p><p>这个部分也是学习了「 程序员进阶攻略 」后的深刻体会。这里我就借鉴《极客时间》中「 程序员进阶攻略 」专栏作者胡峰老师提出的“点-线-面”的成长原则，结合自己的思路跟大家聊一聊：</p><ul><li><b>点</b><br/>我们可以把学到的任何一个知识/技能都当做一个「 点 」。比如 我们刚接触计算机编程的时候学习了 数据结构、后来又学习了 Java基础，然后在工作中又学习了 框架Spring，然后根据项目需要又学习了 Linux、学习了 Hadoop、学习了 JavaScript，等等等等。<br/>我们在初级阶段的时候，是在不断的学习各种知识技能，这些就像是天上的星星一样，一个一个的零散的知识点，它是不成体系的，我们需要用到什么就去学习什么。这些不成体系的知识点帮助我们完成了工作，但是它们又很容易被忘记，且一般都不够深入。</li><li><b>线</b><br/>随着我们学到的「 点 」越来越多之后，就会发现里面有些「 点 」是有关联的，甚至是触类旁通的。那么这些「 点 」在我们的脑海中就可以慢慢的形成「 线 」被串起来。它是一个随着累积之后，自然而然的过程，当然也需要我们不断的去总结知识。<br/>而有一部分知识点可能随着技术的变迁，没有合适的「 线 」去串联，也就慢慢的被我们所放弃。<br/>「 线 」是由「 点 」汇聚而成。因此要想知识能够形成「 线 」，我们除了不断学习以外，还需要不断的找出知识技能的共性和规律。</li><li><b>面</b><br/>「 面 」又是由「 线 」交织而成。这个时候我们对技能的认知就从一维上升到了二维。这个「 面 」就像一张技能地图一样，所有的知识技能都能在这张地图里面找到位置和关系。我们再学习新的知识的时候，也只不过是往这张地图里面添加一些锚点，每次添加，都会让这个知识更为牢固和深刻。这就是我们追求的每个人自己的技术体系图了。</li></ul><p>以上，就是对从程序员到架构师成长之路的一些想法，欢迎大家留言交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作成长、大数据、架构、Web等技术。 </blockquote><p></p><p></p>", 
            "topic": [
                {
                    "tag": "软件架构师", 
                    "tagLink": "https://api.zhihu.com/topics/19674281"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "职业发展", 
                    "tagLink": "https://api.zhihu.com/topics/19554825"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57713143", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "除代码之外，程序员还有哪些能力也非常的关键？", 
            "content": "<p>程序员不应该只会写代码。</p><p>我觉得在程序员群体中，很多人有个误区，就是觉得作为码农，每天安安静静的敲代码、默默的做好技术就可以了，其他的事情都不用去思考，以为一切都会水到渠成。但是还没等到水到渠成，却先等来了中年焦虑。慢慢的等到自己到了三十多岁的时候，发现公司里年轻且更能加班码农越来越多，带来了职业发展上的焦虑，同时上有老下有小且薪资也慢慢遇到职业瓶颈，又加重了生活财务的焦虑。</p><p>最近又翻了翻之前看过的一本书《软技能-代码之外的生存指南》，再次来读，又有一番新的理解。</p><p>作为一名程序员，我们的职业与生活中，不能仅仅只关注代码和技术。</p><p>一名真正优秀的程序员，不应该只是技术大牛，应该能超越编码本身，应该是能够把控自己的职业生涯、能够达成自己的人生目标、应该是一个能够享受生活的人。</p><h2><b>一、如何把控自己的职业生涯？</b> </h2><ul><li><b>把自己当做一个企业去经营</b><br/> 想要把控自己的职业生涯，首先要改变自己的工作心态。<br/> 千万不要把自己当做一名技术打工者，只知道按照公司的需求去完成指定的技术工作。有些鸡汤文章讲到要拥有老板/创业者的心态去对待工作，虽然有些过于鸡汤了，但是道理很对。<br/> 我们真正应该怎么做呢？<br/> 其实只需要认认真真的对自己负责就好了，对自己负责了就相当于对工作、对企业负责了。<br/> 怎么做到认认真真的对自己负责呢？把自己当做一个企业去经营。<br/> 你可以这么去假象一下，自己就是一个「 小企业 」，你现在所在的公司不是在雇佣你，而是在跟你这个「 小企业 」进行着合作，它是甲方，你这个小企业是乙方，甲方付钱给你，需求是让你这个小企业提供软件开发服务。<br/> 在这种假设的前提下，你应该怎么去经营好自己这家「 小企业 」呢，肯定首先打铁还需自身硬，技术能力上得过关。你得扎扎实实的完成好每一个需求，甚至做的比需求所要求的更好。<br/> 但单单有技术能力，恐怕不一定能完成好这份商业合同呢。你还需要不段的提升自己的技术能力以获取更多的认可，你还应该做好宣传和营销自己，得把自己能力很强这件事告诉大家才行。比如多写博客、多做演讲、对外培训之类的。<br/> 同时，你这个小企业最好是有某项专长的，或者你有别的「 小企业 」没有的东西。比如你更专注于电商领域，那么你就更容易拿下电商公司的合同（offer）。<br/> 也只要你把自己当做一家企业去经营的时候，你对待工作的心态就会完全不一样了，你获得的成长和回报也将更多。</li><li><b>走出去，多做一点社交</b><br/> 程序员一般都不太喜欢社交，只喜欢“做一名安安静静码代码的美男子”。<br/> 其实这是程序员职业发展的大忌，大多数程序员由于长期跟计算机打交道，所以变得只太不喜欢跟人打交道了，或者不善于跟人打交道了，因为计算机很直接嘛，非0即1，与人打交道则还需要很多社交技巧。<br/> 但正是因为这个原因，所以我们更需要补齐自己的短板，毕竟我们是群居动物，做任何事情都离不开与人之间的交往，尤其在职场上，需要大量的配合与协同才能把活儿干好，把「 小企业 」经营好。<br/> 还有一个很重要的原因是，如果大家都不擅长，而你擅长了，这恰恰就是你的优势所在，前面讲到要把自己当做企业来经营，企业必须得有自己的优势，企业也需要不停的走出去，跟外面世界多接触多社交才能做得好。</li><li><b>营销自己</b><br/> 这一点其实与上面两点是紧密相连的。作为程序员，我们太不擅长宣传自己、营销自己了。都是默默的干活。但是如果我们太过于低调，从不宣传自己，那自己的才华和能力就不容易被人所知。一名真正的优秀的程序员是应该具备营销自己的能力的。就像作为一个企业，如果不宣传自己的产品，营销自己的产品，别人怎么会知道它的产品好呢。虽说酒香不怕巷子深，但是做一个酒香巷子浅的程序员不是更好么。<br/> 那作为程序员应该如何营销自己呢？<br/> 程序员主要提供的服务就是技术开发服务，程序员的自我营销就是对自己技术开发服务能力的营销。起码有几种思路是可以考虑的，比如：在博客上写技术文章、做公开的技术演讲、做内部或外部的技术培训。这几种方式都可以增加程序员的知名度和影响力，也相当于给自己做营销了。</li><li><b>设定自己的职业目标</b><br/> 大家还有一个经常犯的问题就是没有职业目标。项目代码敲完一个又一个，却很少规划自己的职业目标，以后的发展道路是想做 技术管理者呢？还是计划做 技术架构师？又或者做 技术顾问？<br/> 反正很少去思考，很少去设定这样的职业目标。<br/> 如果没有三五年后的职业大目标，那就不会有近期的职业小目标，一个人如果没有目标，那就像一辆没有目的地的小汽车，要么疲惫的停掉，要么到处乱撞而不得成就。</li></ul><h2><b>二、如何超越编码本身，实现人生目标与享受生活？</b> </h2><ul><li><b>培养第二兴趣</b><br/> 程序员一定要有第二兴趣，除编码之外的第二兴趣。这个第二兴趣最好还是以后可以发展成第二职业，或者是第二收入的。<br/> 大家都在讲「 睡后收入 」，就是指除上班八小时之外，通过其它方式产生的收入，并且这个收入还并不与时间投入成比例。<br/> 我们平时工作多长时间就拿多少钱，这种收入其实是与时间投入成正比的，一点停止了时间投入，收入就停止了。<br/> 但是「 睡后收入 」要求的是，投入了某件事情之后，这个事情自己会持续不断的产生收入，即使是我们睡觉的时候也会产生收入，并不与我们投入的时间成正比。<br/> 比如很多程序员靠写专栏、写书，如果写得好，很多人去看文章打赏、去买他的书。他写文章花的时间是固定的，一次性投入，但是文章和书籍产生的收入可以是持续的、源源不断的，只要持续有人看、有人买。<br/> 因此，提倡程序员去寻找自己的第二兴趣，并且最好能通过第二兴趣产生「 睡后收入 」。</li><li><b>投资理财</b><br/> 投资理财也属于「 睡后收入 」，程序员是属于高收入人群。但是并不是大家都善于理财。<br/> 钱就是这样，你不理财，财不理你。<br/> 所以，强烈建议程序员群体都去学习投资理财的知识，让自己的收入能帮我们赚钱，实现「 睡后收入 」，实现财富自由。</li><li><b>健身</b><br/> 程序员群体由于长期加班，996也是家常便饭。所以很多人的身体健康情况并不理想。<br/> 提倡大家多运动多健身，身体是革命的本钱。</li><li><b>微习惯</b><br/> 微习惯很重要，这也是我最近才学习到的一个词，很受益。<br/> 很多人无论是运动健身还是学英语之类的，都要立一个很大的目标、下一个很大的决心，然后企图抽出很大部分时间去做。但是事实上发现，很难坚持。<br/> 其实有一个更为简单且容易坚持的方法，就是微习惯，无论是想学英语还是想健身，只要每天花10-15分钟，背几个单词，做几个俯卧撑。长期下来就会有非常大的效果。<br/> 大家不要以为每天花的时间短就会觉得没效果，要相信时间的力量，时间会带来改变的，并且这种微习惯因为耗费的时间短，所以一般都很容易坚持下来，大家可以试试。</li></ul><p>以上，就是对程序员在代码之外还应去重视的一些事情的想法，欢迎大家留言交流，多多点击文章右下角的“好看”。</p><blockquote> 本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、架构、Web等技术。 <br/> </blockquote>", 
            "topic": [
                {
                    "tag": "职业发展", 
                    "tagLink": "https://api.zhihu.com/topics/19554825"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57105519", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "从大数据技术变迁猜一猜AI人工智能的发展", 
            "content": "<p>目前大数据已经成为了各家互联网公司的核心资产和竞争力了，其实不仅是互联网公司，包括传统企业也拥有大量的数据，也想把这些数据发挥出作用。在这种环境下，大数据技术的重要性和火爆程度相信没有人去怀疑。<br/><br/>而AI人工智能又是基于大数据技术基础上发展起来的，大数据技术已经很清晰了，但是AI目前还未成熟啊，所以本文就天马行空一下，从大数据的技术变迁历史中来找出一些端倪，猜一猜AI人工智能未来的发展。</p><p><br/>最近断断续续的在看《极客时间》中「 从0开始学大数据 」专栏的文章，受益匪浅，学到了很多。尤其是非常喜欢作者李智慧讲的那句话“学习大数据最好的时间是十年前，其次就是现在”，把这句话改到AI也适用，“学习AI最好的时间是十年前，其次就是现在”，任何知识都是这样。下面我们就来详细聊一聊。</p><p><br/><b>一、先聊一聊大数据技术发展史？</b><br/>我们使用的各种大数据技术，最早起源于Google当年公布的三篇论文，Google FS（2003年）、MapReduce（2004年）、BigTable（2006年），其实Google当时并没有公布其源码，但是已经把这三个项目的原理和实现方式在公布的论文中详细的描述了，这几篇论文面世后，就引爆了行业的大数据学习和研究的浪潮。</p><p><br/>随后一个叫 Doug Cutting 的技术大牛（也就是写 Lucene 的那位，做JAVA的同学应该都很熟悉）就开始根据Google公布的论文去开发相关系统，后来慢慢发展成了现在的 Hadoop，包括 MapReduce 和 HDFS。</p><p><br/>但是在当时，使用 MapReduce 进行数据分析和应用还是有很大门槛的，毕竟要编写 Map 和 Reduce 程序。只能大数据工程师上马，普通BI分析师还是一脸懵逼。所以那个时候都是些大公司在玩。</p><p><br/>既然有这么大门槛，就会有人勇于站出来去解决门槛，比如 Yahoo，他们开发一个叫做 Pig 的东西，Pig是一个脚本语言，按照Pig的语法写出来的脚本可以编译成 MapReduce 程序，然后直接在 Hadoop 上运行了。</p><p><br/>这个时候，大数据开发的门槛确实降了一点。</p><p><br/>不过，Pig大法虽好，但还是需要编写脚本啊，这还是码农的活儿啊。人们就在想，有没有不用写代码的方法就能做大数据计算呢，还真有，这个世界的进步就是由一群善于思考的“懒人”推动的。</p><p><br/>于是，Facebook公司的一群高智商家伙发布了一个叫做 Hive 的东西，这个 Hive 可以支持使用 SQL 语法直接进行大数据计算。原理其实就是，你只需要写一个查询的 SQL，然后 Hive 会自动解析 SQL 的语法，将这个SQL 语句转化成 MapReduce 程序去执行。</p><p><br/>这下子就简单了，SQL 是BI/数据分析师们最为常用的工具了，从此他们可以无视码农，开开心心的独立去写Hive，去做大数据分析工作了。Hive从此就火爆了，一般公司的大多数大数据作业都是由Hive完成的，只有极少数较为复杂的需求才需要数据开发工程师去编写代码，这个时候，大数据的门槛才真真的降低了，大数据应用也才真正普及，大大小小的公司都开始在自己的业务上使用了。</p><p><br/>但是，人们的追求不止如此，虽然数据分析便利了，但是大家又发现 MapReduce 程序执行效率不够高啊，其中有多种原因，但有一条很关键，就是 MapReduce 主要是以磁盘作为存储介质，磁盘的性能极大的限制了计算的效率。</p><p><br/>在这个时候，Spark 出现了，Spark 在运行机制上、存储机制上都要优于 MapReduce ，因此大数据计算的性能上也远远超过了 MapReduce 程序，很多企业又开始慢慢采用 Spark 来替代 MapReduce 做数据计算。</p><p><br/>至此，MapReduce 和 Spark 都已成型，这类计算框架一般都是按“天”为单位进行数据计算的，因此我们称它们为“大数据离线计算”。既然有“离线计算”，那就必然也会有非离线计算了，也就是现在称为的“大数据实时计算”。</p><p><br/>因为在数据实际的应用场景中，以“天”为颗粒出结果还是太慢了，只适合非常大量的数据和全局的分析，但还有很多业务数据，数据量不一定非常庞大，但它却需要实时的去分析和监控，这个时候就需要“大数据实时计算”框架发挥作用了，这类的代表有：Storm、Spark Streaming、Flink 为主流，也被称为 流式计算，因为它的数据源像水流一样一点点的流入追加的。</p><p><br/>当然，除了上面介绍的那些技术，大数据还需要一些相关底层和周边技术来一起支撑的，比如 HDFS 就是分布式文件系统，用于负责存储数据的，HBase 是基于HDFS的NoSQL系统、与 HBase类似的还有 Cassandra也都很热门。</p><p><br/><b>二、再看一看大数据技术架构？</b><br/>了解大数据相关技术可以先看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b011d44964503d72c44fb3438519d461_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"613\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"613\" data-original=\"https://pic2.zhimg.com/v2-b011d44964503d72c44fb3438519d461_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;613&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"613\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"613\" data-original=\"https://pic2.zhimg.com/v2-b011d44964503d72c44fb3438519d461_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b011d44964503d72c44fb3438519d461_b.jpg\"/></figure><p>（图片来源网络）</p><p><br/>这图基本上很全面的展示了大数据的技术栈，下面将其主要的部分罗列一下，以便有个清晰的认知：</p><p><br/><b>大数据平台基础：</b></p><ul><li>MapReduce，分布式离线计算框架</li><li>Spark，分布式离线计算框架</li><li>Storm，流式实时计算框架</li><li>Spark Streaming，流式实时计算框架</li><li>Flink，流式实时计算框架</li><li>Yarn，分布式集群资源调度框架</li><li>Oozie，大数据调度系统</li></ul><p><b>分布式文件系统：</b></p><ul><li>HDFS，分布式文件系统</li><li>GFS，分布式文件系统</li></ul><p><b>SQL引擎：</b></p><ul><li>Spark SQL （Shark），将SQL语句解析成Spark的执行计划在Spark上执行</li><li>Pig，Yahoo的发布的脚本语言，编译后会生成MapReduce程序</li><li>Hive，是Hadoop大数据仓库工具，支持SQL语法来进行大数据计算，把SQL转化MapReduce程序</li><li>Impala，Cloudera发布的运行在HDFS上的SQL引擎</li></ul><p><b>数据导入导出：</b></p><ul><li>Sqoop，专门用将关系数据库中的数据 批量 导入导出到Hadoop</li><li>Canal，可以 实时 将关系数据库的数据导入到Hadoop</li></ul><p><b>日志收集：</b></p><ul><li>Flume，大规模日志分布式收集</li></ul><p><b>大数据挖掘与机器学习：</b></p><ul><li>Mahout，Hadoop机器学习算法库</li><li>Spark MLlib，Spark机器学习算法库</li><li>TensorFlow，开源的机器学习系统</li></ul><p><b>三、猜一猜AI人工智能的发展？</b><br/>通过上面的回顾，我们知道了，因为大量数据的产生导致大数据计算技术 MapReduce 的出现，又因为 MapReduce 的参与门槛问题，导致了 Pig、Hive的出现，正是因为这类上手容易的工具的出现，才导致大量的非专业化人员也能参与到大数据这个体系，因此导致了大数据相关技术的飞速发展和应用，又从而进一步推动了机器学习技术的出现，有了现在的AI人工智能的发展。</p><p><br/>但目前人工智能技术的门槛还比较高，并不是任何企业都能入场的，需要非常专业化的高端技术人才去参与，普通人员只能望而却步，因此AI技术的应用受到了极大的限制，所以也不断的有人提出对人工智能提出质疑。</p><p><br/>讲到这里，有没有发现点什么问题？</p><p><br/>历史的规律总是那么相似。可以猜测一下，人工智能的门槛有一天也会像 MapReduce 的开发门槛一样被打破，一旦人工智能的参与门槛降低了，各类大小企业都能结合自己的业务场景进入AI领域发挥优势了，那AI就真的进入高速发展的通道了，AI相关实际应用的普及就指日可待了。</p><p><br/>恩，一定是这样的，哈哈，现在就可以等着大牛们将AI的基础平台建设好，然后降低参与门槛，进一步就迎来了AI的一片光明，大家从此就可以过上AI服务人类的美好生活了（畅想中…）。</p><p><br/>以上，就是从大数据技术变迁想到AI人工智能发展的一些想法，欢迎大家留言交流，多多点击文章右下角的“好看”。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、架构、Web等技术。 </p><p></p>", 
            "topic": [
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }, 
                {
                    "tag": "AI技术", 
                    "tagLink": "https://api.zhihu.com/topics/20106982"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56669410", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "产品研发团队如何融合OKR与Scrum敏捷开发？", 
            "content": "<p>「 OKR 」现在非常的火爆，很多公司都在使用，不仅国外的 Google、英特尔等大公司在用，国内的一线知名互联网企业今日头条和一些创业团队也都在使用。<br/></p><p>那为什么「 OKR 」这么受欢迎呢，因为把它可以帮助团队 达成共识、加深信任、加强协同。</p><p>并且「 OKR 」这套方法，不仅可以帮助我们开展工作，还可以用它来管理个人生活。例如互联网大牛 吴军 就是固定使用「 OKR 」来管理他个人年度目标和计划的。</p><p>乘着假期，我也仔细读了两本关于「 OKR 」的书籍，《OKR工作法》、《这就是OKR》，好书，确实收益良多，方法很简单，但是确实很实用。所以接下来我也打算把「 OKR 」方法实践在我们的研发团队目标管理和我个人的年度计划中。</p><p>说了这么多「 OKR 」的好，那接下来就该详细的介绍一下它了。</p><p>本文在第三节还会重点讲一下，我们作为产品研发团队，应该怎么将「 OKR 」与「 Scrum 」进行深度结合，打造最完美的团队与项目。</p><h2><b>一、什么是 OKR？</b></h2><p>「 OKR 」是一个标准化的目标管理的方法，其中 O 是指 Objectives 目标，KR 是指 Key Results 关键结果，即 目标与关键结果法，它是一套明确和跟踪目标以及其完成情况的管理方法，最初由英特尔公司发明，然后由Google公司发扬光大。</p><p>我们在公司或团队中，经常会制定目标，俗称 KPI ，它是一个自上而下安排的量化指标，它往往是一个从上层往下层责任摊派的过程，并不是由大家自发的去制定去挑战的目标。这种情况会带来什么问题呢，大家对这个KPI虽然压力很大，但是每日里做的工作并不一定是与之高度关联的，甚至很多人不知道自己近期工作的重点，并不清楚自己所做的工作对整体目标的帮助，而且往往对其他人的工作也不甚了解，还不利于团队协同。</p><p>因此，我们需要一个能实现 <b>聚焦</b>、<b>透明</b> 的目标管理方法，这就是「 OKR 」，它能将每个人、每个团队、以及公司的使命关联起来，它是实现协同的首选工具，既能实现“上下同欲”的纵向协同，也能实现“跨职能”的横向协同。</p><p>在工作中， 「 OKR 」明确了大家的预期（需要尽快做什么）、以及具体由谁来执行，能够在不同部门员工之间建立联系，能够让员工的行动与整体的目标保持一致。</p><p><b>「 OKR 」有四个关键作用：</b></p><ul><li>对优先事项能聚焦（明确每季度、每周内的重点事项，大家朝着一个共同的目标）</li><li>有利于人员协作（透明的OKR让大家协同一致，充分实现纵向和横向的协作）</li><li>更有效的责任追踪（每周关注进展、随时调整、每季度回顾评分）</li><li>更能激励大家的自主性（每个人知道自己所做的部分对全局目标的贡献，激发自主性和成就感）</li></ul><h2><b>二、如何使用 OKR？</b></h2><p>使用OKR没有固定模式，可以根据原则和实际情况自行调整，参考流程如下：</p><ol><li>在公司的关键人员讨论下，制定出公司整体的年度 O（目标）和 KR（关键结果）</li><li>根据年度OKR，确定出下一季度的OKR</li><li>基于公司顶层的OKR，各部门/团队的关键人员进行讨论后，确定出部门/团队的季度OKR</li><li>给团队宣讲整体OKR，然后每个员工根据团队的OKR，制定且分享自己的OKR，并与主管确认</li><li>在季度末，员工对各自的OKR进行自我评估</li><li>每周一团队进行周计划，确定本周的工作任务，需要与OKR对齐</li><li>每周五团队进行周庆祝，回顾上周周报、明确进展、发现问题，同样需要检查与OKR是否对齐</li></ol><p><b>在使用「 OKR 」的时候，有几个原则：</b></p><ul><li>目标 必须要能鼓舞人心且与长远的计划有关</li><li>目标 要有时间期限，比如 年度、季度 还是 月度</li><li>目标 要由独立团队来承担，相互依赖的关系比较吃力</li><li>关键结果 需要更接地气且是可量化可衡量的指标</li></ul><p>比如，我们要给一个学习英文的APP设定OKR，一般人可能会想到的目标可能是这类的：</p><p>“在第一季度实现安装量100w”</p><p>“在第一季度实现日活跃用户30w”</p><p>……</p><p>但是上述这些并不符合OKR方法中对目标的描述，它们反而符合OKR中的关键结果。因为它们不够激励人心，没有鼓舞性，在OKR方法中，上面APP产品正确的设定目标的描述方式可以是：</p><p>“在英语学习群体里展示出APP的优秀口碑”</p><p>最好是用“拿下”、“搞定”、“展示出”等能激励人兴奋的词汇，很明显这个目标非常不符合 smart 原则，既没有时间点，也没有可衡量的数值。但是没关系，只要它能鼓舞人就可以了。</p><p>而我们在设定 KR关键结果 的时候，最开始的那些描述“在第一季度实现安装量100w”又正好适用了，我们可以把这个作为关键结果，也就是说，如果要实现“在英语学习群体里展示出APP的优秀口碑”这个具有挑战性的目标的话，我们给自己设定的两项关键结果：“在第一季度实现安装量100w”、“在第一季度实现日活跃用户30w”，我们认为这两项关键结果一旦实现了，上述目标也自然而然就搞定了，是一个顺理成章的事情。</p><p><b>第一次实践 OKR 的时候，有几个小技巧：</b></p><ul><li>如果是第一次实践可以全公司/团队只设置一个OKR，这样更容易接受和落实</li><li>可以先只选一个团队去实践</li><li>可以尝试用OKR来做项目管理，让员工能快速理解这个方法</li></ul><p><b>在OKR实践中，影响目标达成的因素一般有：</b></p><ul><li>没有给目标设定优先级</li><li>缺乏充分的承诺与沟通</li><li>没有做好充分的计划</li><li>轻易的放弃</li></ul><p><b>使用OKR的注意事项：</b></p><ul><li>尽量设置少的OKR，最好是一个</li><li>每周盘点的时候先从公司OKR开始、然后沟通部门的、团队的</li><li>个人的OKR只需要一对一沟通</li><li>OKR不是你唯一一件要做的事情，而是你必须要做的一件事</li><li>OKR要公开、要透明</li></ul><h2><b>三、如何将 OKR 与 Scrum 结合？</b></h2><p>OKR很强大，可以应用的点比较多，甚至还可以直接用作项目管理使用，例如《OKR工作法》一书中提到的OKR四象限方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-182b2498f27201a28b8206b65f2f5098_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"627\" class=\"origin_image zh-lightbox-thumb\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-182b2498f27201a28b8206b65f2f5098_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;850&#39; height=&#39;627&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"850\" data-rawheight=\"627\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"850\" data-original=\"https://pic1.zhimg.com/v2-182b2498f27201a28b8206b65f2f5098_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-182b2498f27201a28b8206b65f2f5098_b.jpg\"/></figure><p>（图片来源《OKR工作法》）</p><p>书中提到的四象限方法，右上角的第一象限可以列出当前OKR以及其进展，左上角的第二象限列出本周重点关注的任务，左下角额度第三象限列出未来四周的计划，右下角的第四象限列出除当前OKR以外产品和团队中的其他状态指标。</p><p>每周通过对这个图进行一次讨论和回顾，基本上就可以当做项目管理来使用了，简洁好用。</p><p>但是OKR毕竟不是一个专业的项目管理工具，它的核心目的不在于做项目管理，尤其是对我们产品研发团队而言，平常用的更多的项目开发管理方法一般是 「 Scrum 」敏捷开发方法。</p><p>「 Scrum 」敏捷开发方法可以让项目成员明确阶段性的目标与任务、明确团队分工协作、明确每周应该完成那些任务、明确下周的计划是什么、清楚目前项目研发中的问题和解决办法。因此作为研发的同学们可能更适应这套工作方法。没关系，其实「 OKR 」与「 Scrum 」不仅不冲突，而且还有很多共同点，因此在产品项目中可以将它们组合在一起，用OKR去设定目标，用Scrum去实现目标，结合起来使用会更加有效。</p><p>OKR 其实更多的是从大局角度，目标角度出发去激励团队，它负责的是指导团队朝着什么方向去做、做到什么程度。而Scrum更多的是从任务维度出发去管理团队，它指导着团队具体怎么做。</p><p><b>「 OKR 」与「 Scrum 」在工作中具体该怎么结合呢？</b></p><p>公司或者团队可以先找OKR的流程去创建年度/季度的目标和关键结果。然后将团队当前季度的KR拆分成Scrum中的Sprint计划，然后再细分任务，每天的站会让团队成员对着看板沟通任务情况，每周的Scrum回顾会议中我们需要更新OKR的进度，每季度进行OKR回顾评分。</p><p>正是因为OKR与Scrum中有些流程和会议是类似的，咱们可以合并进行，最终实现OKR来管理目标和方向，Scrum管理任务计划推进。在实际应用中，不同团队可以根据自身实际情况灵活的应用。</p><p><br/>以上，就是对OKR的基本介绍以及与Scrum结合的一些想法，欢迎大家留言交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、架构、Web等技术。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "OKRs", 
                    "tagLink": "https://api.zhihu.com/topics/19954875"
                }, 
                {
                    "tag": "Scrum", 
                    "tagLink": "https://api.zhihu.com/topics/19567775"
                }, 
                {
                    "tag": "OKR工作法（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20134602"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51126728", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "RAID磁盘阵列是什么（一看就懂）", 
            "content": "<p>在单机时代，采用单块磁盘进行数据存储和读写的方式，由于寻址和读写的时间消耗，导致I/O性能非常低，且存储容量还会受到限制。另外，单块磁盘极其容易出现物理故障，经常导致数据的丢失。因此大家就在想，有没有一种办法将多块独立的磁盘结合在一起组成一个技术方案，来提高数据的可靠性和I/O性能呢。<br/></p><p>在这种情况下，RAID技术就应运而生了。</p><h2><b>一、RAID 是什么？</b></h2><p>RAID （ Redundant Array of Independent Disks ）即独立磁盘冗余阵列，简称为「磁盘阵列」，其实就是用多个独立的磁盘组成在一起形成一个大的磁盘系统，从而实现比单块磁盘更好的存储性能和更高的可靠性。</p><h2><b>二、RAID 有哪些？</b></h2><p>RAID方案常见的可以分为：</p><ul><li><b>RAID0</b></li><li><b>RAID1</b></li><li><b>RAID5</b></li><li><b>RAID6</b></li><li><b>RAID10</b></li></ul><p>下面来分别介绍一下。</p><ol><li><b>RAID0</b></li></ol><p>RAID0 是一种非常简单的的方式，它将多块磁盘组合在一起形成一个大容量的存储。当我们要写数据的时候，会将数据分为N份，以独立的方式实现N块磁盘的读写，那么这N份数据会同时并发的写到磁盘中，因此执行性能非常的高。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f651b9392e881f5870c2a3d2ffaada24_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"451\" class=\"origin_image zh-lightbox-thumb\" width=\"532\" data-original=\"https://pic1.zhimg.com/v2-f651b9392e881f5870c2a3d2ffaada24_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;532&#39; height=&#39;451&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"532\" data-rawheight=\"451\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"532\" data-original=\"https://pic1.zhimg.com/v2-f651b9392e881f5870c2a3d2ffaada24_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f651b9392e881f5870c2a3d2ffaada24_b.jpg\"/></figure><p>RAID0 的读写性能理论上是单块磁盘的N倍（仅限理论，因为实际中磁盘的寻址时间也是性能占用的大头）</p><p>但RAID0的问题是，它并不提供数据校验或冗余备份，因此一旦某块磁盘损坏了，数据就直接丢失，无法恢复了。因此RAID0就不可能用于高要求的业务中，但可以用在对可靠性要求不高，对读写性能要求高的场景中。</p><p>那有没有可以让存储可靠性变高的方案呢？<br/>有的，下面的RAID1就是。</p><ol><li><b>RAID1</b></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0aa0491990e7fff92f6c76d51ec5d9e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-0aa0491990e7fff92f6c76d51ec5d9e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;515&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-0aa0491990e7fff92f6c76d51ec5d9e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0aa0491990e7fff92f6c76d51ec5d9e6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如图，</p><p>RAID1 是磁盘阵列中单位成本最高的一种方式。因为它的原理是在往磁盘写数据的时候，将同一份数据无差别的写两份到磁盘，分别写到工作磁盘和镜像磁盘，那么它的实际空间使用率只有50%了，两块磁盘当做一块用，这是一种比较昂贵的方案。</p><p>RAID1其实与RAID0效果刚好相反。RAID1 这种写双份的做法，就给数据做了一个冗余备份。这样的话，任何一块磁盘损坏了，都可以再基于另外一块磁盘去恢复数据，数据的可靠性非常强，但性能就没那么好了。</p><p>了解了RAID0和RAID1之后，我们发现这两个方案都不完美啊。<br/>这时候就该 性能又好、可靠性也高 的方案 RAID5 登场了。</p><ol><li><b>RAID5</b></li></ol><p>这是目前用的最多的一种方式。<br/>因为 RAID5 是一种将 存储性能、数据安全、存储成本 兼顾的一种方案。</p><p>在了解RAID5之前，我们可以先简单看一下RAID3，虽然RAID3用的很少，但弄清楚了RAID3就很容易明白RAID5的思路。</p><p>RAID3的方式是：将数据按照RAID0的形式，分成多份同时写入多块磁盘，但是还会另外再留出一块磁盘用于写「奇偶校验码」。例如总共有N块磁盘，那么就会让其中额度N-1块用来并发的写数据，第N块磁盘用记录校验码数据。一旦某一块磁盘坏掉了，就可以利用其它的N-1块磁盘去恢复数据。</p><p>但是由于第N块磁盘是校验码磁盘，因此有任何数据的写入都会要去更新这块磁盘，导致这块磁盘的读写是最频繁的，也就非常的容易损坏。</p><p>RAID5的方式可以说是对RAID3进行了改进。</p><p>RAID5模式中，不再需要用单独的磁盘写校验码了。它把校验码信息分布到各个磁盘上。例如，总共有N块磁盘，那么会将要写入的数据分成N份，并发的写入到N块磁盘中，同时还将数据的校验码信息也写入到这N块磁盘中（数据与对应的校验码信息必须得分开存储在不同的磁盘上）。一旦某一块磁盘损坏了，就可以用剩下的数据和对应的奇偶校验码信息去恢复损坏的数据。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0fdbf77f54817cea8e04990e0fbbbb6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"568\" data-original=\"https://pic3.zhimg.com/v2-0fdbf77f54817cea8e04990e0fbbbb6e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;568&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"568\" data-original=\"https://pic3.zhimg.com/v2-0fdbf77f54817cea8e04990e0fbbbb6e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0fdbf77f54817cea8e04990e0fbbbb6e_b.jpg\"/></figure><p>RAID5校验位算法原理：P = D1 xor D2 xor D3 … xor Dn （D1,D2,D3 … Dn为数据块，P为校验，xor为异或运算）</p><p>RAID5的方式，最少需要三块磁盘来组建磁盘阵列，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</p><ol><li><b>RAID6</b></li></ol><p>为了进一步提高存储的高可用，聪明的人们又提出了RAID6方案，可以在有两块磁盘同时损坏的情况下，也能保障数据可恢复。</p><p>为什么RAID6这么牛呢，因为RAID6在RAID5的基础上再次改进，引入了双重校验的概念。</p><p>RAID6除了每块磁盘上都有同级数据XOR校验区以外，还有针对每个数据块的XOR校验区，这样的话，相当于每个数据块有两个校验保护措施，因此数据的冗余性更高了。</p><p>但是RAID6的这种设计也带来了很高的复杂度，虽然数据冗余性好，读取的效率也比较高，但是写数据的性能就很差。因此RAID6在实际环境中应用的比较少。</p><ol><li><b>RAID10</b></li></ol><p>RAID10其实就是RAID1与RAID0的一个合体。</p><p>我们看图就明白了：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2863c36e248cc4b48de927c6095ae57c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"607\" data-original=\"https://pic1.zhimg.com/v2-2863c36e248cc4b48de927c6095ae57c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;607&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"607\" data-original=\"https://pic1.zhimg.com/v2-2863c36e248cc4b48de927c6095ae57c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2863c36e248cc4b48de927c6095ae57c_b.jpg\"/></figure><p>RAID10兼备了RAID1和RAID0的有优点。首先基于RAID1模式将磁盘分为2份，当要写入数据的时候，将所有的数据在两份磁盘上同时写入，相当于写了双份数据，起到了数据保障的作用。且在每一份磁盘上又会基于RAID0技术讲数据分为N份并发的读写，这样也保障了数据的效率。</p><p>但也可以看出RAID10模式是有一半的磁盘空间用于存储冗余数据的，浪费的很严重，因此用的也不是很多。</p><p><b>整体对比一下</b> RAID0、RAID1、RAID5、RAID6、RAID10 的几个特征：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-56e0e1c0c9df23885cfdcaeeca8a1aa4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1007\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"1007\" data-original=\"https://pic1.zhimg.com/v2-56e0e1c0c9df23885cfdcaeeca8a1aa4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1007&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1007\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1007\" data-original=\"https://pic1.zhimg.com/v2-56e0e1c0c9df23885cfdcaeeca8a1aa4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-56e0e1c0c9df23885cfdcaeeca8a1aa4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、Web、区块链技术。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "硬盘", 
                    "tagLink": "https://api.zhihu.com/topics/19570139"
                }, 
                {
                    "tag": "磁盘阵列", 
                    "tagLink": "https://api.zhihu.com/topics/19744182"
                }, 
                {
                    "tag": "RAID", 
                    "tagLink": "https://api.zhihu.com/topics/19631084"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50479555", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 171, 
            "title": "算法的时间与空间复杂度（一看就懂）", 
            "content": "<p>算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。<br/></p><p>那么我们应该如何去衡量不同算法之间的优劣呢？</p><p>主要还是从算法所占用的「时间」和「空间」两个维度去考量。</p><ul><li>时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。</li><li>空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。</li></ul><p>因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。</p><p>下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。</p><h2><b>一、时间复杂度</b></h2><p>我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。</p><p>这种方式可以吗？当然可以，不过它也有很多弊端。<br/>这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。</p><p>因此，另一种更为通用的方法就出来了：「 <b>大O符号表示法</b> 」，即 T(n) = O(f(n))</p><p>我们先来看个例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">for(i=1; i&lt;=n; ++i)\n{\n   j = i;\n   j++;\n}\n</code></pre></div><p>通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?</p><p>在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：<b>算法的渐进时间复杂度</b>。</p><p>我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) =  (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) =  O(n)</p><p>为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。</p><p>所以上面的例子中，如果n无限大的时候，T(n) =  time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) =  O(n) 就可以了。</p><p>常见的时间复杂度量级有：</p><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li></ul><p>上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。</p><p>下面选取一些较为常用的来讲解一下（没有严格按照顺序）：</p><ol><li><b>常数阶O(1)</b></li></ol><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：</p><div class=\"highlight\"><pre><code class=\"language-text\">int i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n</code></pre></div><p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p><ol><li><b>线性阶O(n)</b></li></ol><p>这个在最开始的代码示例中就讲解过了，如：</p><div class=\"highlight\"><pre><code class=\"language-text\">for(i=1; i&lt;=n; ++i)\n{\n   j = i;\n   j++;\n}\n</code></pre></div><p>这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。</p><ol><li><b>对数阶O(logN)</b></li></ol><p>还是先来看代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">int i = 1;\nwhile(i&lt;n)\n{\n    i = i * 2;\n}\n</code></pre></div><p>从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n<br/>也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：<b>O(logn)</b></p><ol><li><b>线性对数阶O(nlogN)</b></li></ol><p>线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。</p><p>就拿上面的代码加一点修改来举例：</p><div class=\"highlight\"><pre><code class=\"language-text\">for(m=1; m&lt;n; m++)\n{\n    i = 1;\n    while(i&lt;n)\n    {\n        i = i * 2;\n    }\n}\n</code></pre></div><ol><li><b>平方阶O(n²)</b></li></ol><p>平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。<br/>举例：</p><div class=\"highlight\"><pre><code class=\"language-text\">for(x=1; i&lt;=n; x++)\n{\n   for(i=1; i&lt;=n; i++)\n    {\n       j = i;\n       j++;\n    }\n}\n</code></pre></div><p>这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即  O(n²) <br/>如果将其中一层循环的n改成m，即：</p><div class=\"highlight\"><pre><code class=\"language-text\">for(x=1; i&lt;=m; x++)\n{\n   for(i=1; i&lt;=n; i++)\n    {\n       j = i;\n       j++;\n    }\n}\n</code></pre></div><p>那它的时间复杂度就变成了 O(m*n)</p><ol><li><b>立方阶O(n³)</b>、<b>K次方阶O(n^k)</b></li></ol><p>参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。</p><p>除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。</p><h2><b>二、空间复杂度</b></h2><p>既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。</p><p>空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。</p><p>空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：</p><ol><li><b>空间复杂度 O(1)</b></li></ol><p>如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)<br/>举例：</p><div class=\"highlight\"><pre><code class=\"language-text\">int i = 1;\nint j = 2;\n++i;\nj++;\nint m = i + j;\n</code></pre></div><p>代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)</p><ol><li><b>空间复杂度 O(n)</b></li></ol><p>我们先看一个代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">int[] m = new int[n]\nfor(i=1; i&lt;=n; ++i)\n{\n   j = i;\n   j++;\n}\n</code></pre></div><p>这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)</p><p>以上，就是对算法的时间复杂度与空间复杂度基础的分析，欢迎大家一起交流。</p><p>欢迎继续看 算法之</p><a href=\"https://zhuanlan.zhihu.com/p/78094287\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-61e3a3939c2f93f30ac21419625c9a4f_180x120.jpg\" data-image-width=\"1920\" data-image-height=\"1280\" class=\"internal\">不止思考(奎哥)：算法一看就懂之「 数组与链表 」</a><p>和</p><a href=\"https://zhuanlan.zhihu.com/p/79435086\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-88c1df32a67e1446609bb557b682f775_180x120.jpg\" data-image-width=\"1920\" data-image-height=\"1280\" class=\"internal\">不止思考(奎哥)：算法一看就懂之「 堆栈 」</a><p>和</p><a href=\"https://zhuanlan.zhihu.com/p/81018602\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-65ba7ad46439ade76d7c0dd365cdc7ff_180x120.jpg\" data-image-width=\"1920\" data-image-height=\"1080\" class=\"internal\">不止思考(奎哥)：算法一看就懂之「 队列 」</a><p>，以及</p><a href=\"https://zhuanlan.zhihu.com/p/81952290\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-f70ec20156ed88b071b5b80e69024952_180x120.jpg\" data-image-width=\"1920\" data-image-height=\"1200\" class=\"internal\">不止思考(奎哥)：算法一看就懂之「 递归 」</a><p>算法与数据结构相关文章会持续更新，欢迎关注。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。 </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "你瞒我瞒", 
                    "userLink": "https://www.zhihu.com/people/250cdf25f596d5aba71f2ff487775e19", 
                    "content": "可以讲的很清楚感谢", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "Zachary", 
                    "userLink": "https://www.zhihu.com/people/38fc4575e26fc56c69d1d5b2a3d93444", 
                    "content": "<p>假设循环x次之后，i 就大于 “n” 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n</p>", 
                    "likes": 6, 
                    "childComments": [
                        {
                            "userName": "Arain", 
                            "userLink": "https://www.zhihu.com/people/0f423146c5200d53389f1015526c817b", 
                            "content": "这个是不是写错了，公式应该是x=log2（n），2是底数", 
                            "likes": 0, 
                            "replyToAuthor": "Zachary"
                        }, 
                        {
                            "userName": "HowKing", 
                            "userLink": "https://www.zhihu.com/people/ad1a388eb1647ffcffc4e88ecf8d5a6d", 
                            "content": "底数无关紧要 可以省略 如果是5也一样 时间复杂度只是描述算法耗时的程度而已 不是计算具体时间", 
                            "likes": 1, 
                            "replyToAuthor": "Arain"
                        }
                    ]
                }, 
                {
                    "userName": "竟然重名", 
                    "userLink": "https://www.zhihu.com/people/b7f8201d844e887c00287dfd3f36a71c", 
                    "content": "简洁易懂，鼓掌", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "大宝剑之力", 
                    "userLink": "https://www.zhihu.com/people/6c92589c12b019b8a1d2a1bc8c01b513", 
                    "content": "<p>我看了java数据结构，上面写了，空间复杂度是以时间复杂度为上限的，这是不是某种情况来说，空间复杂度是等于时间复杂度的？</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "周大侠Jay", 
                    "userLink": "https://www.zhihu.com/people/e86f55146a299af3d92ecde91f0df006", 
                    "content": "我可以转到我的公众号里吗😄", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "可以", 
                            "likes": 0, 
                            "replyToAuthor": "周大侠Jay"
                        }
                    ]
                }, 
                {
                    "userName": "wenxin667", 
                    "userLink": "https://www.zhihu.com/people/5b4b2e686903d9f71973ba20d8f304b2", 
                    "content": "<p>大致上是明白了，不过这段话是不是有误啊【假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间】   无论第几行 都应该是 1个颗粒时间啊    一共n行，就是n个颗粒时间 不该是 1+2n啊？</p>", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "修心", 
                    "userLink": "https://www.zhihu.com/people/3f9d9505c9b8a3b61db3cd648c3f8275", 
                    "content": "我记得以前调试for循环的时候，会调到for，for的一行应该不是一个颗粒时间吧？", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "2sheep2simple", 
                    "userLink": "https://www.zhihu.com/people/4a32e09b5a493efa41de8312b59e16d5", 
                    "content": "<p>for 循环里的i 不需要声明吗？</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "玉米片", 
                    "userLink": "https://www.zhihu.com/people/1ab8c2398c05b8109314dcfbca8a7c38", 
                    "content": "<p>我一直以为，一看就懂的后面还有一句话</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Brizer", 
                    "userLink": "https://www.zhihu.com/people/3bdff78d8524332a3df02b59d6e0e818", 
                    "content": "<p>通俗易懂，非常优秀</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "靠脸吃饭的我好饿", 
                    "userLink": "https://www.zhihu.com/people/d8f70c865c0052b2e491c9e98cb5811d", 
                    "content": "幡然醒悟，谢谢大佬", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "鱼黄", 
                    "userLink": "https://www.zhihu.com/people/4291c9079ef10b5f7d83d88e26ae70ce", 
                    "content": "。。。我想问为什么第一个循环是1颗粒，这个循环不也要执行n次吗？我是小白，刚开始学[捂脸]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "李小龙的李", 
                    "userLink": "https://www.zhihu.com/people/01c14b76ee730ee41a09e0e5e4cc579b", 
                    "content": "通俗易懂，感谢！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "熊阿福", 
                    "userLink": "https://www.zhihu.com/people/2caa63363e45382f9cb6d9da0a23a246", 
                    "content": "<p>已收藏，谢谢大佬</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48584104", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "技术人更应该学会即兴表达", 
            "content": "<p>最近特别忙，忙里偷闲还是抽空把网易云课堂大白老师的《即兴讲话，也能套公式》快速的学习了一遍，收获很大。<br/></p><p>作为一名程序员，为啥要去学习这种教我们怎么讲话的课呢？就做一名安静的美男子好好敲代码难道不好吗！</p><p>这就是我今天想要跟大家聊的重点。</p><p>大家对我们程序员群体的普遍印象就是：「 内向」、「 呆板」、「 不喜沟通」、「 不善表达」、「 熬夜敲代码」。虽然确实有些程序员或多或少有上述特征，但这并不能代表我们整体啊，要知道，还有很多的程序员是很外向的，是非常喜欢去交流和表达的。</p><p>不过，「 喜欢」 并不代表 「擅长」，所以我就把我对《即兴讲话，也能套公式》中印象比较深刻的几个技巧，形成读书笔记跟大家分享一下，也算为改变程序员群体形象做出点贡献。</p><h2><b>一、技术人为啥要学会即兴表达？</b></h2><p>由于程序员长期对着电脑编程，习惯了机器般的0和1的交互方式，因此在沟通表达方面确实是大部分技术人的短板。但是在现实生活中，即兴讲话、沟通汇报 又是我们工作中不可缺少的部分，尤其是在程序员与产品经理互怼的关键时候，即兴表达能力差了那可不行。</p><h2><b>二、即兴表达的几个方法</b></h2><p>大白老师在课程中把即兴讲话的要点和技巧都形成了公式，让大家直接套公式就可以很有条理的说话了。哈哈，是不是听起来很神奇。</p><ul><li><b>三点公式</b></li></ul><p>当我们和别人聊一个话题的时候，可能会在头脑中一下子冒出很多思绪，就像一个毛毛球一样，不知道该从哪儿讲起。那么这个时候，我们可以把自己想说的内容先在大脑中概括总结成「 三个点」，然后就依次来讲这三个点：「 第一… ，第二… ，第三… 」，这样就会显得很有条理。</p><p>即使一时间有点紧张，不能将全部想说的内容快速概括完，那也可以挑自己认为最重要的三个点，实在不行也可以是大脑中最先冒出的那三个观点也可以，这三个点之间甚至不需要有什么关联性。</p><p>举个例子，如果一个人来问你 「 程序员要不要学习即兴讲话？」，你可以快速的思索一下，将大脑中的观点列出三点来回答，比如：「 肯定要啊，第一，学会了即兴讲话有利于程序员在工作中怼产品经理啊，第二，学会了即兴讲话有利于程序员升职到技术管理岗位啊，第三，最重要的是学会了即兴讲话有利于程序员找女朋友，哈哈」</p><p>我觉得三点公式，对于初学者来说最实用了。很多人讲话讲了一堆，但别人根本不知道他在说什么。如果按照这个公式归纳成几个点分别去讲，听的人就很容易抓到重点，讲的人时候也不容易断片，更重要的是，按照「 1、2、3」这么说话，显得特别的条理清晰。</p><p>还有一个有趣的现象是，喜欢看《奇葩说》节目的人可以留心注意一下，里面的很多选手在辩论的时候也是采用这种方式去阐述自己的论点的哦。</p><ul><li><b>时间公式</b></li></ul><p>我们在讨论一个问题的时候，如果一开始，思路还没有打开，想法是疏疏点点的，这个时候可以考虑使用「 时间公式」的方法，采用 时间维度 来梳理自己的思路，将要描述的这件事情，按照时间的顺序去表达、去串联。</p><p>举个例子，如果一个人来问你 「 你觉得大数据是未来的趋势吗？ 」<br/>这个时候你大脑中可能一下子蹦出了很多零散的点想回答，但是不知道怎么组织起来，那么就可以采用时间线来描述，比如按照 大数据从几年前的市场需求、到现在的市场需求、到未来的需求预测，依次去讲一讲，这样就可以从市场的变化趋势来回答大数据未来的趋势。</p><ul><li><b>空间公式</b></li></ul><p>空间公式其实与上面的时间公式比较类似，只是维度不同。这里指的是当我们要即兴的表达某个观点的时候，如果还没有找到合适的思路，我们可以尝试找到空间（地点）为路径去论述我们的观点。</p><p>比如，产品经理问你「为什么产品功能还没有开发完，是不是偷懒了？」，<br/>你可以用空间位置的方式去回答他：「 冤枉啊，我几乎从未歇息啊，白天在公司敲代码，下班后在家里敲代码，周末陪女朋友的时候在电影院敲代码，一刻都没有停息啊！」<br/>这里的「公司」、「家里」、「电影院」就是你串联内容的空间维度。</p><ul><li><b>人物公式</b></li></ul><p>时间、地点、人物，一般都是标准的三要素，既然有「时间公式」、「空间公式」，那么必然就也会有「人物公式」了。<br/>「人物公式」也很好理解，就是以人物的方式去串联我们想表达的内容。</p><p>假如，作为程序员的你，想劝产品经理放弃产品上的一个留言板功能，你就可以这么跟她讲：<br/>「留言板这个功能不应该被开发，我调研了我们产品的部分终端用户，他们对这个功能需求度不高，因为这个功能并非是产品的核心功能，使用的频次非常低；我也去问了相关开发同学，开发这个功能需要的时间周期很长，耗费的人力成本太高；我也去找领导咨询了一下，他们的观点是无论怎么样产品的发布时间是固定的，绝对不能延后；因此为了用户体验、投入产出比，以及保障产品按时发布，我不建议开发这个功能」</p><p>只要你说完上面这段话后，产品经理不打你，我觉得这套「人物公式」就算运用的很完美了。</p><ul><li><b>3W公式</b></li></ul><p>3W思维其实是我们日常生活中经常用到的一种方法，不仅限于用在即兴讲话中。<br/>3W = What（是什么） + Why（为什么） + How（怎么做）<br/>通过3W的方式将你的内容连接起来就是一个完整的观点输出了，What、Why、How三者之间没有严格的顺序要求。</p><p>举个例子，假如你们公司会议室很紧缺，然后你开发了一个预定会议室的APP给公司内部使用，你现在需要给大家去宣讲，去说服大家使用。你可以使用3W的方式去表达：<br/>「（首先是Why）现在我们公司员工很多，而且还在不断的增加中，但是会议室的个数是固定的，就那么几个，发现最近大家开会经常要去抢会议室，非常耽误事情。（What）因此我们就给大家开发了一个可以预定会议室的APP。（How）大家根据自己开会时间的需求，提前在APP里面填写时间和占用的会议室名称进行预定，就不会产生冲突了，而且还可以实时看到会议室的排班情况。」</p><p>基本上讲完3个W后，整个事情也就阐述清楚了。</p><p>以上部分内容源自学习大白老师《即兴讲话，也能套公式》后的读书心得，其实还有很多技巧我没有记住，有兴趣的同学可以自行去学习了解，我觉得还是非常有意思的。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流Java、Web、架构、大数据、职业发展、技术管理。  </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "技术", 
                    "tagLink": "https://api.zhihu.com/topics/19550912"
                }, 
                {
                    "tag": "讲话技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19765557"
                }, 
                {
                    "tag": "当众讲话", 
                    "tagLink": "https://api.zhihu.com/topics/19880292"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45719354", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "架构设计之「数据库集群方案」", 
            "content": "<p>在之前的文章中，我们知道数据库服务可能已经成为了很多系统的性能关键点，甚至是瓶颈了。也给大家介绍了数据库服务器从主备架构、到主从架构、再到主主架构的基础方案。但如果单台机器已经不能满足完整业务数据存储的时候，我们就需要考虑采用多机甚至多中心的部署方案了。<br/></p><p>今天我们就再来聊一聊，在多机环境下，数据库集群的架构方案。</p><p>同样，这里先不看细节，不管底层数据源是什么数据库，我们先谈架构方案。因为无论底层是 Mysql 还是 Redis、MongoDB，我们在架构设计上都是相通的。</p><p>针对多机的架构，常见有如下做法：</p><ul><li><b>单中心数据集群</b></li><li><b>多中心数据分区</b></li></ul><p>下面我们来具体看看：</p><h2><b>一、单中心的数据集群架构（单中心多机）</b></h2><p>单数据中心多机器的集群又可以分为：</p><ul><li>数据集中模式</li><li>数据分散模式</li></ul><p>这两种的主要区别在于集群中的完整业务数据是全部集中在一台机器上，但是分散在多台机器上。</p><ol><li>数据集中模式</li></ol><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6eaead145d03fa9ea67d57805086fca3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"285\" data-rawheight=\"289\" class=\"content_image\" width=\"285\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;285&#39; height=&#39;289&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"285\" data-rawheight=\"289\" class=\"content_image lazy\" width=\"285\" data-actualsrc=\"https://pic4.zhimg.com/v2-6eaead145d03fa9ea67d57805086fca3_b.jpg\"/></figure><p>这种模式与「一主一从式」（主从式）比较类似，完整的业务数据还是存储在一台主机的上，主机承担读服务和写服务，从机只承担读服务。但是从机有多台机器，从机实时的从主机同步数据。所以这种模式，也可以理解为「一主多从」式。</p><p>因为有多个从机，那么也给这种架构带来了一些额外需要处理问题，比如：<br/>1.1，主机需要实时的将数据同步到多台从机上，涉及到主机的处理压力问题。<br/>1.2，需要保障多台从机之间的数据一致性的问题，如果出现数据不一致，如何处理。<br/>1.3，多台从机是如何检测主机状态的，因为从机在关键时刻是要替换主机的，那么如果多台从机监测到的主机状态不一致，那又可能会带来其它问题。<br/>1.4，从机切换为主机的时候，选择哪一台从机来切换呢，这涉及到多台从机之间如何进行选举的问题。</p><p>这些问题，在我们进行架构设计的时候，必须提前考虑。不过市面上也有一些工具可以辅助实现，例如 ZooKeeper等。</p><p>另外，由于数据集中模式的所有写操作都只到一台主机上，而读操作可以到N台从机上。因此这种模式比较适用于业务数据量不大、读操作远远大于写操作、集群规模较小的业务场景。</p><ol><li>数据分散模式</li></ol><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-73a4808859cd4360b807bd5f3103c335_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-73a4808859cd4360b807bd5f3103c335_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;462&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-73a4808859cd4360b807bd5f3103c335_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-73a4808859cd4360b807bd5f3103c335_b.jpg\"/></figure><p>数据分散模式是指，完整的业务数据并非是全部存储在一台主机上的，而是由多台主机共同分担，分散存储。因此这种模式适用于大数据量、集群规模较大的场景。</p><p>使用这种模式，也有几点需要特别注意的：<br/>1.1，尽量将数据均衡的分散的各个机上，这样才能保证资源的均衡使用和性能的最佳。<br/>1.2，多台机器上的数据虽然不同，但是也需要互相进行数据的备份。<br/>1.3，要能动态的增加和删除节点，这样可以便于随时扩展，通常采用一致性HASH的方法。</p><p>聊完了单数据中心的集群架构，我们再来看看多数据中心的数据分区架构。</p><h2><b>二、多中心的数据分区架构（多中心多机）</b></h2><p>出于容灾的考虑，通常会在多个不同地区部署多套的数据集群。毕竟在国内运营商网络故障、光纤被山东蓝翔技工铲断等事件还是不少的。轻则一个机房出问题，重则一个城市一个省份都可能故障。</p><p>如果我们数据存储服务只部署在一个机房，那如果这个机房出现了故障，很有可能导致不能服务甚至是无法恢复业务了。因此我们就需要考虑多中心的数据分区架构，将数据按照一定的规则进行分区，部署在不同机房/城市里，且每一个分区都存储一部分数据，通过这种方式来保障数据和服务的可用性。</p><p>在多中心的数据分区模式下，我们需要提前规划 “分区规则” 。毕竟将数据在地理位置上分区，在网络通讯方面是有时延的，所以必须要考虑好我们是要以区域、还是以城市、还是省份来分节点部署。</p><p>除了 “分区规则” ，我们还需要考虑 “备份规则” 。<br/>因为分区之后，各区都只存储一部分数据，并不是完整数据。如果其中一个区出故障了，虽然不会影响全局，但是也会带来一定损失。因此我们需要考虑将每个区里的数据备份起来，备份有几种方式：</p><ul><li>集中备份式</li><li>独立备份式</li><li>相互备份式</li></ul><p>下面将这三种备份方式解释一下：</p><ol><li>集中备份式</li></ol><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-258ba7d25275a10b62f6affaef1ec1d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"433\" data-original=\"https://pic1.zhimg.com/v2-258ba7d25275a10b62f6affaef1ec1d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;433&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"433\" data-original=\"https://pic1.zhimg.com/v2-258ba7d25275a10b62f6affaef1ec1d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-258ba7d25275a10b62f6affaef1ec1d4_b.jpg\"/></figure><p>（参考图片）</p><p>集中备份式是指建立一个独立的数据备份中心，将各分区（节点）的数据都定期同步到这个备份中心，以保障数据的安全性。这种备份方式可以随意的扩展分区（节点），不受分区的个数限制，并且结构很简单。但是</p><p>这种备份方式的缺点就是，投入成本有点高，因为需要额外建立这么一个备份数据中心，平时也是闲置的，有点浪费资源。另外，备份中心自身也可能会有单点的故障，且备份中心中需存储多个分区的数据，还可能会互相受到影响。</p><ol><li>独立备份式</li></ol><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ba6554dc1a77bd97a789eb83193f588c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"318\" data-rawheight=\"160\" class=\"content_image\" width=\"318\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;318&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"318\" data-rawheight=\"160\" class=\"content_image lazy\" width=\"318\" data-actualsrc=\"https://pic1.zhimg.com/v2-ba6554dc1a77bd97a789eb83193f588c_b.jpg\"/></figure><p>独立备份式就是给每一个数据分区（节点）都建立一个额外的备份节点，这个备份节点部署在不同的地域/城市，这样才能起到容灾的作用。</p><p>这种备份方式相比较于 集中备份式 ，建设成本就更大一些了，毕竟每一个分区都需要额外建立一个备份节点。但是结构更清晰简单了，而且各个分区的数据之间还可以做到互不影响，完全是独立的。后续扩展分区（节点）的时候，对前面的备份节点也没有影响，扩展性好。</p><ol><li>相互备份式</li></ol><p>这个暂时没有找到合适的图。</p><p>相互备份式其实是结合了上面两种特性在一起的模式。上面的方式不是成本大么，那么这种方式就不额外建立备份中心了，让各个分区（节点）互相备份数据。比如 分区A 将自身数据同步一份给 分区B备份着，分区B 将自己的数据同步一份给 分区A 备份着，如果是三个以上分区，还可以做到循环备份。</p><p>这种备份方式，设计稍微复杂一些，扩展性也弱一些，但是可以节约资源。</p><p>无论采用哪种方式，都需要结合实际的业务场景来决定。</p><p>以上，就是对数据库在多机集群模式下的技术架构的分享，欢迎大家一起交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，交流Java、Web、架构、大数据、职业发展、技术管理，欢迎关注。  </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "集群", 
                    "tagLink": "https://api.zhihu.com/topics/19596215"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45508400", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "架构设计之「数据库从主备到主主的高可用方案」", 
            "content": "<p>在互联网项目中，当业务规模越来越大，数据越来越多，随之而来的就是数据库压力会越来越大。慢慢就会发现，数据库层可能已经成为了整个系统的关键点和性能瓶颈了，因此实现数据层的高可用就成为了我们项目中经常要解决的问题。<br/></p><p>本文我们就来聊一聊如何实现数据存储层的高可用方案。在保障数据层的高性能与高稳定方面，最容易想到的方式就是对数据进行分片、多份、冗余等，很多架构的本质其实也是基于这几点来实现的。</p><p>这里先不看细节，即先不管底层数据源是什么数据库，我们先只聊架构方案，因为无论底层是关系型数据库，还是NoSQL数据库，无论是 Mysql 还是 Redis、MongoDB，我们在架构设计上都是相通的。</p><p>大体上，单中心双机的常见方案有以下这些：</p><ul><li><b>一主一备的架构（主备式）</b></li><li><b>一主一从的架构（主从式）</b></li><li><b>互为主从的架构（主主式）</b></li></ul><p>以上方案从上至下，依次是从简单到复杂，从基础到丰富。下面我们来具体看看：</p><h2><b>一、一主一备的架构（主备式）</b></h2><p>主备式架构是双机部署中最简单的一种架构了，几乎市面上所有的数据库系统都会自带这个主备功能。</p><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b68e9d9405f9f998e2aa468e85fd7275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-b68e9d9405f9f998e2aa468e85fd7275_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;496&#39; height=&#39;267&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"496\" data-rawheight=\"267\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"496\" data-original=\"https://pic2.zhimg.com/v2-b68e9d9405f9f998e2aa468e85fd7275_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b68e9d9405f9f998e2aa468e85fd7275_b.jpg\"/></figure><p>其思路也特别的简单：将数据库部署到两台机器，其中一台机器（代号A）作为日常提供数据读写服务的机器，称为「主机」。另外一台机器（代号B）并不提供线上服务，但会实时的将「主机」的数据同步过来，称为「备机」。一旦「主机」出了故障，通过人工的方式，手动的将「主机」踢下线，将「备机」改为「主机」来继续提供服务。</p><p>这个架构的优缺点都很明显，优点就是几乎不需要做什么开发改造，各类数据库就支持这种模式，部署维护起来也简单，并没有引入额外的系统复杂度和瓶颈。</p><p>但是缺点呢，就是当「主机」出现故障的时候，需要人工去干预啊，运维同学很辛苦的，而且处理还不一定及时。再还有一个缺点就是，主备架构会造成严重浪费资源，毕竟需要一台与「主机」同等配置的「备机」长期备着，但又不作为线上服务来使用，你说浪费不浪费。</p><p>为了解决这个资源浪费问题，我们就得想一个把「备机」也用起来的方案：主从式架构。</p><h2><b>二、一主一从的架构（主从式）</b></h2><p>主从式架构大体上与上述的主备式架构差不多。区别就是主备式的「备机」平时是不干活的的，主要起到备份的作用。而主从式的「备机」改为了「从机」，平时也要提供服务，跟「主机」一样随时随刻的在干活的。</p><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-00d5bcdce0a01c5de1f19d2085fb6b73_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-00d5bcdce0a01c5de1f19d2085fb6b73_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;614&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"614\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"614\" data-original=\"https://pic4.zhimg.com/v2-00d5bcdce0a01c5de1f19d2085fb6b73_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-00d5bcdce0a01c5de1f19d2085fb6b73_b.jpg\"/></figure><p>主从式架构中的「从机」虽然也在随时随刻提供服务，但是它只提供「读」服务，并不提供「写」服务。「主机」会实时的将线上数据同步到「从机」，以保证「从机」能够正常的提供读操作。</p><p>这种架构相比较主备式，对资源是一种节约，毕竟「从机」也在提供服务，没有白白的浪费。并且在「主机」出现故障时，在人工介入之前，好歹「从机」也是能够提供数据的「读」操作的，毕竟大多数业务都是「读」多「写」少，因此对稳定性又提高了一个层次。</p><p>缺点就是架构稍微复杂了一点，毕竟「主机」和「从机」都有「读」服务，那么前端业务系统就需要用一定策略去判断该路由到哪一台去读取数据。还有就是，延迟问题，「主机」的数据同步到「从机」难免会有一定程度的延迟，这个延迟可能会对数据实时性要求较高的业务有一定影响。</p><p>通过上面内容可以看到，虽然这个架构一定程度解决了资源浪费，但是并没有解决人工干预的问题，当出现了故障后还是需要人工去处理。<br/>如果想让架构更智能一点，那么我们就需要引入「主从双机自动切换」的功能。</p><p><b>主从双机自动切换</b>：是指当主机出现故障后，从机能够自动检测发现。同时从机将自己迅速切换为主机，将原来的主机立即下线服务，或转换为从机状态。</p><p>要实现「主从双机自动切换」，有几个关键点需要考虑：</p><ol><li>主机与从机之间的状态如何判断？ <br/>必须有一个机制能监测两台机器的运行状态，以此来决定是否应该切换。<br/>我们比较常用的状态传递方式有两种：</li></ol><ul><li>「双机互连模式」</li><li>「第三方中介模式」</li></ul><p>「双机互连模式」：是指在主机和从机之间建立一条用于状态通讯的通道。通过这个通道，主机和从机之间可以共享服务状态，一旦发现对方宕机或者停止服务了，就可以立即将自己切换为主服务。不过这种方式需要关注通道的健壮性，一旦通道自身不稳定了，可能会导致假消息出现，比如主机并没有宕机，但是通道坏了，导致从机以为出现了异常，就将自己切换为了主机，那就出现了2个主机了，因此通道本身也是一个可能的故障点。</p><p>「第三方中介模式」：是指在主机和从机之外，再建立一个中介机器，这个中介机器专门用来维护各节点（主机/从机）状态的，主机/从机实时的将自身状态上报给中介机器，中介机器来决定是否应该切换、何时切换。MongoDB的Replica Set就是采用的这种模式。</p><ol><li>除了状态判断，还需要考虑切换的策略是什么？ 也就是说发生异常几次/多久后开始切换，是否有一个缓冲机制等。另外切换完成后，当原主机又恢复正常之后是否需要自动再切换回来等策略。</li><li>另外就是需要注意在切换过程中双机数据如果发生冲突时，以哪个为准？处理机制是什么。</li></ol><p>这些细节都是在设计主从自动切换架构时候，要提前规划的。</p><h2><b>三、互为主从的架构（主主式）</b></h2><p>互为主从的架构是指两台机器自己都是主机，并且也都是作为对方的从机。两台机器都提供完整的读写服务，因此无需切换，客户机在调用的时候随机挑选一台即可，当其中一台宕机了，另外一台还可以继续服务。</p><p>如图，<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b4f01f9387e8d5791d03417e96266c4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"741\" data-rawheight=\"581\" class=\"origin_image zh-lightbox-thumb\" width=\"741\" data-original=\"https://pic3.zhimg.com/v2-b4f01f9387e8d5791d03417e96266c4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;741&#39; height=&#39;581&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"741\" data-rawheight=\"581\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"741\" data-original=\"https://pic3.zhimg.com/v2-b4f01f9387e8d5791d03417e96266c4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b4f01f9387e8d5791d03417e96266c4e_b.jpg\"/></figure><p>采用 互为主从架构 有个复杂点就是，因为两台主机都接受写数据，那就需要将写的最新数据实时的同步给对方，需要将数据进行两台主机的双向复制。而双向复制不可避免的会在一定程度上带来数据延迟、极端情况下甚至有数据丢失等问题。在实际业务中，有些业务数据对一致性要求是非常高的，并不能接受数据的延迟、丢失，因此这类业务也不适合互为主从的模式，比如金融业务。但是我们互联网业务中大多数场景还是没有这么高要求的，所以这种模式对于一般场景还是用的蛮多。</p><p>以上，就是对数据库从主备架构、到主从架构、再到主主架构的高可用方案基本讲解了，接下来会继续分享数据库在多机集群模式下的技术架构，欢迎大家关注交流。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 不止思考 」，交流Java、Web、架构、大数据、职业发展、技术管理，欢迎关注。  </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }, 
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": [
                {
                    "userName": "二月鸟", 
                    "userLink": "https://www.zhihu.com/people/3ecd0a19978a54a76cb861e200afb360", 
                    "content": "<p>分析的好清楚，受教。</p><p>主备的图有点问题，</p><p>改一下，备不会提供read</p><p></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>谢谢。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "二月鸟"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45062599", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 7, 
            "title": "网络中的「动态路由算法」，你了解吗？", 
            "content": "<p>在计算机网络中，路由器的一个很重要责任就是要在端对端的节点中找出一条最佳路径出来，通过自己与相邻节点之间的信息，来计算出从自己位置到目的节点之间的最佳线路，这种算法我们可以理解为路由算法。</p><p>路由的模式又主要分为「静态路由」和「动态路由」。静态路由协议是由网络管理员手动输入配置的，适用于小型的不太复杂的网络环境中，或者有特定需求的网络场景中。而动态路由协议是现代计算机网络中最为常用的一种方式。动态路由算法能够根据网络拓扑结构去适应流量的变化。</p><p>本文主要聊的就是「动态路由算法」，你知道动态路由算法有哪些吗？</p><p>动态路由算法大致可以分为两类：</p><ul><li><b>距离矢量路由算法</b></li><li><b>链路状态路由算法</b></li></ul><p>下面我们来看一下这两类算法的特点：</p><h2><b>一、距离矢量路由算法</b></h2><p><b>距离矢量路由算法</b>（Distance Vector Routing），它是网络上最早使用的动态路由算法，也称为Bellman-Ford或者Ford-Fulkerson算法。基于这类算法实现的协议有：RIP、BGP等。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d31f5f8cd0cd46cea50e3cf1bf629c9d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"449\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"449\" data-original=\"https://pic2.zhimg.com/v2-d31f5f8cd0cd46cea50e3cf1bf629c9d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;449&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"449\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"449\" data-original=\"https://pic2.zhimg.com/v2-d31f5f8cd0cd46cea50e3cf1bf629c9d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d31f5f8cd0cd46cea50e3cf1bf629c9d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如图，</p><p>这类算法的基本思路是：网络中每一个路由器都要维护一张 矢量表 ，这个 矢量表 中的每一行都记录了从当前位置能到达的目标路由器的最佳出口（接口）和距离（跳数）。</p><p>每隔一段时间当前路由器会向所有的邻居节点发送自己的这个表，同时它也会接收每个邻居发来的它们的表。并会将邻居的表和自己的表做一个对比更新。<br/>比如当前 路由器X 离 邻居Y路由器 的距离是m，此时收到 邻居Y 发来的表中写到了“ 邻居Y离路由器Z的距离是n ”，那 当前路由器X 就知道它离 路由器Z 的距离可能就是 m+n 了，如图：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-86d58dc058f19ff013b8de575167efa4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"86\" class=\"origin_image zh-lightbox-thumb\" width=\"518\" data-original=\"https://pic1.zhimg.com/v2-86d58dc058f19ff013b8de575167efa4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;518&#39; height=&#39;86&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"86\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"518\" data-original=\"https://pic1.zhimg.com/v2-86d58dc058f19ff013b8de575167efa4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-86d58dc058f19ff013b8de575167efa4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>就这样继续类推，要不了多久，每个路由器就可以将网络中所有路由节点和子网线路都汇聚起来了。这样的话，每个路由器只需要查找自己的表就可以很容易的知道到达目的地的最佳出口（接口）是哪个了。</p><p>当然，当网络结构发生变化的时候，各个路由器中的矢量表也会随之动态更新。</p><p>好了，讲到这里，基本上对「距离矢量路由算法」大概原理有个认识了，现在我们再来仔细分析分析这个算法的名字，可以发现，它的名字取的还是蛮有意思的，非常贴切。“距离”这个词就基本表明了这个算法是通过 距离（跳数/时间）来度量2个路由网络之间的线路的，而“矢量”这个词，可以看出线路是有方向性的，且路由表中只记录了数据包去往目的地应该走哪个出口方向，并不会记录到达目的地的整条路径。</p><p>「距离矢量路由算法」的优点很明显：非常简单清晰，且任何加入到网络中的新节点都能很快的与其它节点建立起联系获得补充信息。</p><p>缺点呢，首先就是每次发送信息的时候，要发送整个全局路由表，太大了，因为每个路由器需要在矢量表中记录下整个网络的信息，导致需要较大存储、CPU、网络开销，对资源的要求越来越高。还有一个问题就是收敛时间太慢，也就是路由器共享路由信息并使各台路由器掌握的网络情况达到一致所需的时间比较久，收敛速度慢会导致有些路由器的表更新慢，从而造成路由环路的问题。</p><h2><b>二、链路状态路由算法</b></h2><p><b>链路状态路由算法</b>（Link State Routing ），基于Dijkstra算法，它是以图论作为理论基础，用图来表示网络拓扑结构，用图论中的最短路径算法来计算网络间的最佳路由。基于这类算法实现的协议有：OSPF 等。<br/>如图，<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-78d93805a285dcaab29e0b5fe2e6cf30_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic1.zhimg.com/v2-78d93805a285dcaab29e0b5fe2e6cf30_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"565\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic1.zhimg.com/v2-78d93805a285dcaab29e0b5fe2e6cf30_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-78d93805a285dcaab29e0b5fe2e6cf30_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这类算法的基本思路是：采用的是不停的拼接地图的方式。每一个路由器首先都会发现自己身边的邻居节点，然后将自己与邻居节点之间的链路状态包广播出去，发送到整个网络。这样，当某个路由器收到从网络中其它路由器广播来的路由信息包（链路状态包）之后，会将这个包中的信息与自己路由器上的信息进行拼装，最终形成一个全网的拓扑视图。</p><p>当路由器中形成了全网的拓扑视图后，它就可以通过最短路径算法来计算当前节点到其它路由器之间的最短路径了。当某台路由器的链路状态发生变化时，路由器采用洪泛法向所有路由器发送此信息，其它路由器使用收到的信息重新计算最佳路径，重新生成路由表（拓扑图）。</p><p>这里可以做一个类比，有一个路人甲人去问路，然后本地人A只知道A自己生活方圆5公里的地图，本地人B只知道B自己生活的方圆5公里的地图，但是路人甲要去的地方需要穿过A和B所在区域，那么就把A和B的2份地图拿来拼装在一起，然后去往目的地的完整路线就可以查出来了。</p><p>链路状态路由算法简单而言就是五个步骤：</p><ol><li>发现邻居节点，并了解邻居网络地址</li><li>测量到邻居节点的距离或成本度量值</li><li>构建一个包含自己所拥有信息的链路状态包</li><li>将这个包广播到网络中，并接收其它路由器的链路状态包</li><li>计算出当前节点到其它节点之间的最短路径（基于Dijkstra算法）</li></ol><p>链路状态路由算法 不会像 距离矢量路由算法 那样发送整个路由表，链路状态路由协议只会广播更新的或者改变了的网络拓扑，这样传播的信息量会少很多，同时对带宽和CPU资源也是一种节省。</p><p>「链路状态路由算法」具有很好的扩展能力，也具有更快的收敛速度，能够快速的适应网络变化，且由于一个路由器的链路状态只涉及与其相邻的路由器的联通状态，因而与整个互联网的规模并无直接关系，因此链路状态路由算法可以用于大型的或者路由信息变化剧烈的互联网环境。</p><p>将上述两种算法做一个简单的对比：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bdc5bae26d967db3fad9ba6c66593759_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-bdc5bae26d967db3fad9ba6c66593759_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;185&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"185\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic2.zhimg.com/v2-bdc5bae26d967db3fad9ba6c66593759_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bdc5bae26d967db3fad9ba6c66593759_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图片来源网络，经供参考。</p><p>以上，就是对计算机网络中的动态路由算法的基本讲解了，欢迎大家一起交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流Java、Web、架构、大数据、职业发展、技术管理。  </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "路由器", 
                    "tagLink": "https://api.zhihu.com/topics/19561099"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44984302", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 13, 
            "title": "武汉互联网从业者最新购房指南", 
            "content": "<p>01</p><p><b>2018年是否适合买房</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2018年这个时间点到底适不适合买房呢，让我们先来回顾一下房价上涨的趋势。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>房价的上涨，跟国家政策的变化有一定的关系。从2015年，营业税免征条件（<b>满5年改为满2年</b>）的变化，深圳房价开始上涨，带动整个一线城市（北京、上海、深圳）上涨。</p><p>到2016年契税优惠（根据房产面积不同享受不同的优惠政策）后，二线四小龙城市（南京、苏州、合肥、厦门）房价的上涨，涨幅较猛。</p><p>再到后来二线热门城市的上涨（福州、杭州、武汉、天津等）。<br/></p><p><br/>目前这个时间点看，一线城市已经暴涨过一轮，二线四小龙城市及二线热门城市也已经经历了一个较猛的涨幅。那么下一个较猛的涨幅会出现在哪里呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>个人觉得，房价的上涨趋势，从一线蔓延到二线，从二线四小龙蔓延到一些二线热门城市，再慢慢的蔓延到一些不那么热门的城市。但是归根结底，涨幅比较好的一些城市，应该具备以下特质：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、城市应该是一些可以吸引到大量的人才和外来人口的有潜力的一些城市；</b><br/><b>2、这些城市的房价虽然出现了一定的涨幅，但还没出现暴涨或暂未完成暴涨。</b>典型的，包括广州、福州、杭州、武汉、天津等这些比较热门的省会城市。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>▶ 如果目前在京沪深这样的一线城市</b></p><p>虽然存在短期下调的风险，但从长线看，未来价值还是会有所提升，个人看来，还是可以考虑入手的 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>▶ 如果目前在二线四小龙城市</b></p><p>由于这些城市，目前已经经历了一轮暴涨（跟一线城市相比，长线价值的提升稍弱），建议在挑选的时候，<b>尽量谨慎入手</b>，<b>更多的考虑房子本身的价值（包括 房子的位置、周边措施、是否为学区房等等</b>） 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>▶ 如果，目前在二线热门城市，或者是目前正在一线城市从业</b></p><p>正考虑在二线城市买房（<b>将来可能回二线城市发展</b>），现在买房仍然是一个比较好的时期，这些城市在过去一年多，有一个比较明显的涨幅，随着政府的一些调控，涨幅有一定的控制，但是明显还没有涨到高位盘，<b>依然存在很大的升值空间</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>02</p><p><b>武汉城市发展是否适合买房</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>武汉作为华中大区的中心与核心城市</b>，集中了中部地区最好的教育、医疗、交通等公共资源，拥有很好的地理、经济、人口与教育优势，<b>是中部地区最具竞争力与辐射力的城市</b>。且具有一定的吸附力，除了会吸引大量外来人口来此发展外，同时会吸引资金流入武汉。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>武汉从房地产的投资与商品房销售额来看，在中部城市中规模也位于领先位置。 以下从武汉的地理、经济、教育等方面来让大家对武汉有个更好了解： </p><p><br/><b>1、地理优势：</b>相对于其他中部中心城市，武汉是京广深港线、沪汉蓉线这两条最长的中国经济重要通道的中点和交点,且处于京广线与长江的交汇处，其区位优势无可比拟。</p><p><br/><b>2、经济优势：</b>从经济总量上看，武汉是中部唯一一个进入万亿俱乐部的城市，从产业来看，上市公司是衡量一个城市产业竞争力的重要指标，A股上市公司方面，武汉为50家，位居中部第一。</p><p><br/><b>3、人口与教育优势：</b>武汉人口规模突出，远超城市群其他城市，人口流入量较大，常住人口达1077万（数据取自网络）。另外，武汉是教育大省，高校数量及高等教育人才可观。高校资源所具有的研发能力，可以促进产业升级；同时，这些资源会为城市输送更多高端人才，加上武汉政府的百万大学生留汉计划，带来了旺盛的住房需求。 </p><p><br/><b>综上，武汉是一个非常具有潜力的城市</b>，且随着城际铁路与城市地铁的全面建设，光谷区域的大力发展，以及各大商户在各个区域的入住（例如：永旺、宜家等），武汉同时会成为一个越来越适宜居住的城市，因此，<b>从武汉的城市发展来看，可以考虑在武汉买房。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>03</p><p><b>武汉互联网人最佳买房点及房价行情</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们在这里先简短的介绍一下武汉三镇及买房片区：武汉三镇位于中国的长江、汉江交汇处，为武昌（今武昌区，青山区，洪山区）、汉口（今江汉区，江岸区，硚口区）、汉阳（今汉阳区）三座城镇的合称，范围即是今日武汉市的七个中心城区。三城镇同位于长江和汉水交汇处，隔江鼎立，故称“武汉三镇”。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而这里将房子按片区区分，大概分为：<b>汉口片、武昌片、光谷片以及汉阳片</b>，具体请看下图： </p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-265fdf8842532814b0deb57dcbe52232_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"691\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-265fdf8842532814b0deb57dcbe52232_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;691&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"691\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-265fdf8842532814b0deb57dcbe52232_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-265fdf8842532814b0deb57dcbe52232_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>那么武汉哪儿最适合互联网从业人员买房呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们先来看下，<b>武汉有哪些不错的互联网公司，以及这些企业的分布：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f47f06f1c8b8a7e891b832c09127cb86_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"1448\" class=\"origin_image zh-lightbox-thumb\" width=\"750\" data-original=\"https://pic3.zhimg.com/v2-f47f06f1c8b8a7e891b832c09127cb86_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;750&#39; height=&#39;1448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"750\" data-rawheight=\"1448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"750\" data-original=\"https://pic3.zhimg.com/v2-f47f06f1c8b8a7e891b832c09127cb86_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f47f06f1c8b8a7e891b832c09127cb86_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>本土互联网企业</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要包括 </p><p>斗鱼（光谷软件园）</p><p>盛天网络（光谷金融港）</p><p>极验科技（武大园四路）</p><p>木仓科技（光谷软件园）</p><p>悦然心动（关山大道K11新世界）</p><p>优品财富（光谷金融港）</p><p>微派网络（洪山区关山大道）<br/>石墨文档（光谷软件园）</p><p>灯塔财经（光谷大道光谷世贸中心）</p><p>安天（武汉软件新城）等</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>第二总部或武汉研发中心</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要包括</p><p> 腾讯武汉研发中心（江夏区腾讯大道）</p><p>小红书（已搬至关山大道保利时代）</p><p>尚德机构(当代光谷梦工厂)</p><p>青藤云安全（光谷软件园）</p><p>航班管家（中北路知音大厦）</p><p>京东武汉（光谷智慧园）</p><p>宝宝树（光谷智慧园）</p><p>小米（光谷金融港）</p><p>金山WPS（光谷金融港）</p><p>360企业安全(当代光谷梦工厂)</p><p>今日头条（关山大道保利时代）</p><p>西山居（光谷金融港）</p><p>ThoughtWorks（关山大道保利时代）</p><p>青云（关山大道保利时代）</p><p>科大讯飞（关山大道K11新世界）</p><p>出门问问（关山大道保利时代）</p><p>旷视Face++（武汉软件新城）等 </p><p><br/>武汉互联网企业主要分布<b>在光谷片区（光谷东、光谷南、江夏等地），包括光谷软件园、光谷金融港、光谷当代梦工厂以及关山大道、花山等地带。</b></p><p><br/>武汉目前房价市场行情：<b>内环30000-50000元/平米，二环25000-30000元/平米 ，三环13000-20000元/平米，四环8000-13000元/平米</b>，当然武汉的真实情况是不能以环线论价格的，毕竟光谷的三环外价格比汉阳的二环价格可能还贵，此处用环线只是为了区分大致区域。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>临近这些互联网企业的热门楼盘主要包括：</b></p><p><b>☛ 关山大道：</b>泛悦城、泷悦华府、华润琨瑜府、世界城、正荣紫阙台、清江山水、中建大公馆。</p><p><b>☛ 光谷南：</b>当代国际城二期。</p><p><b>☛ 光谷东：</b>中建光谷之星、国采光立方、绿地国际理想城、朗诗里程、光谷188、北辰优+、光谷悦城、联投驿园、北大资源山水年华。</p><p><b>☛ 江夏：</b>金地湖山境、保利清能西海岸。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>此外，考虑到房子的性价比及距离，也有很多互联网从业者考虑在<b>汉阳片区</b>买房，在这里罗列一下汉阳片区的一些楼盘信息，也可以关注一下： </p><p>☛ <b>汉阳：</b>保利香颂、万科新世纪翡翠滨江、中国铁建国际花园、世茂锦绣长江五期、人信汇、钰龙旭辉半岛。<br/>☛ <b>四新：</b>恒大翡翠华庭、武汉国博新城、新力琥珀园、光明上海府邸、广电兰亭时代、华发未来荟、正荣府、中核时代广场。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>04</p><p><b>外地人在武汉买房的条件及限购情况</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先，我们先来看下武汉最新的限购政策：2017年10月3日，武汉出台新的限购限贷条例，对武汉户籍购买主城区购买<b>第二套房首付50%，购买第三套房限购。</b>非武汉户籍购买首套房首付四成，购买第二套房限贷，购买第三套房限购，且需提供2年及以上的社保或个税缴纳证明才可在主城区购房，且对于补缴的不予认定（如果你断交了社保，那么之前的便不作数了）。 <br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、外地人在武汉买房条件有： </b></p><p>a、根据武汉限购令，暂定对已拥有1套住房的本市户籍居民家庭(包括夫妻双方及未成年子女，下同)、能够提供本市1年纳税证明或社会保险缴纳证明的非本市户籍居民家庭，限购1套住房(含新建商品住房和二手住房，下同)；</p><p><br/>b、对已拥有2套住房及以上住房的本市户籍居民家庭、拥有1套及以上住房的非本市户籍居民家庭，无法提供1年本市纳税证明或社会保障缴纳证明的非本市户籍居民家庭，暂停在本市行政区域内向其出售住房；对违反规定购房的，不予办理房地产相关登记手续。</p><p><br/><b>2、外地人在武汉买房需要具备基本要求有：</b></p><p>a、借款人必须是<b>18-65</b>周岁有民事行为能力人的当地居民或外地购房者(外地购房者须提供本地经营1年以上纳税证明或社会保险缴纳证明)；</p><p>b、首套房贷首付比例<b>40%</b>，二套房贷<b>60%</b>，三套房贷及以上银行政策不予以购房客户受理； </p><p>c、负债比率(按揭贷款月还款额+其它贷款)&lt;=夫妻双方月收入的50%； </p><p>d、信用报告显示连续逾期3次，累计6次原则上不予以贷款。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、外地人员在武汉市购买商品住宅办理常住户口的基本条件是：</b></p><p>凡户籍不在武汉市核心城区(含江岸区、江汉区、桥口区、汉阳区、武昌区、青山区、洪山区等七个核心城区及武汉经济技术开发区、东湖新技术开发区、东湖生态旅游风景区)具备合法身份证明的中国公民，在我市核心城区购买住房面积在<b>100平方米</b>(含100平方米)和总价超过<b>50万</b>元(含50万元)，可在住房地申办武汉市非农业户口；</p><p><br/>凡户籍不在本市和本市核心城区以及远城区农业户口人员在远城区购买住房面积超过90平方米(含90平方米)和总价超过30万元(含30万元)的，可在住房地申办武汉市非农业户口。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>4、办理落户手续时，需要提供的资料：</b></p><p>需要提供《房屋所有权证》和《土地使用证》，以及物业管理部门出具的实际入住证明、原户籍地派出所户籍证明、购房合同及全额发票、身份证和婚姻证明等，直接到武汉市公安局户政处签证窗口申请办理户口。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>5、限购情况：</b></p><p><b>a、限购区域：</b><br/>☛ 江岸区、江汉区、硚口区、汉阳区、武昌区、青山区、洪山区以及武汉东湖新技术开发区、武汉经济技术开发区(不含汉南)、东湖生态旅游风景区，以及东西湖区、江夏区、黄陂区的部分区域，具体区域，请看下图。<br/>☛ 长江新城起步区内（东至武湖泵站河，南至长江北岸，西至滠水河、府河，北至江北铁路）限购限售。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f1e2c4b69d3a0fff3899e3f866815456_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb\" width=\"674\" data-original=\"https://pic3.zhimg.com/v2-f1e2c4b69d3a0fff3899e3f866815456_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;674&#39; height=&#39;375&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"674\" data-original=\"https://pic3.zhimg.com/v2-f1e2c4b69d3a0fff3899e3f866815456_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f1e2c4b69d3a0fff3899e3f866815456_b.jpg\"/></figure><p>（红色区域为武汉市限购区域）</p><p><br/><b>b、武汉市户籍</b><br/>☛ 首套房：在武汉无房无贷，则在限购区域购房，首付比例不低于<b>30%</b>。<br/>☛ 二套房：在武汉市拥有1套住房（无论贷款结清与否），在限购区域买房，首付比例不低于<b>50%</b>。<br/>☛ 二套房及以上：在武汉市拥有2套及以上住房，则不得在限购区域内购房。</p><p><br/><b>c、非武汉市户籍</b><br/>☛ 买房条件：提供自购房之日起连续2年(含2年)在武汉市缴纳社会保险或者个人所得税证明。<br/>☛ 首套房：在武汉无房无贷，在限购区域购房，首付比例不低于30%。<br/>☛ 二套房：在武汉市已经拥有1套及以上住房，则不得在限购区域内购房。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d96842c216bbadb3784bc0c011695400_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb\" width=\"568\" data-original=\"https://pic1.zhimg.com/v2-d96842c216bbadb3784bc0c011695400_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;568&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"387\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"568\" data-original=\"https://pic1.zhimg.com/v2-d96842c216bbadb3784bc0c011695400_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d96842c216bbadb3784bc0c011695400_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>6、异地购房成本</b></p><p><b>a、公积金异地转入：</b><br/>☛ <b>从2017年7月1日起，公积金可办理异地转移接续了。</b>武汉市住房公积金管理中心已出台具体操作细则，异地转入公积金时，武汉及转出地两地公积金部门申请、审核、信息传递及资金转入等全部流程，须在11个工作日内办结。</p><p><br/>☛ 按照住建部统一要求，7月1日起，全国住房公积金异地转移接续平台将上线，实现“账随人走、钱随账走”，即公积金账户等相关信息将在该平台上实现网上转移，今后广大职工异地转移公积金时，只需到转入地公积金中心办理即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>b、公积金贷款额度：</b><br/>☛ 武汉将实行首套房与二套房差别化的基准贷款额度，自<b>2018年5月1日</b>起武汉住房公积金首套房的最高贷款额度提高至<b>70万</b>元，二套房的最高贷款额度为<b>50万元</b>，一共可贷款<b>120万</b>。</p><p><br/>☛ 公积金中心表示，该执行基准并非一成不变，会随着购房者在公积金“总池”的系数进行调整。我市首套房、二套房可贷款额度根据贷款率浮动，首套房最高可贷款至<b>84万</b>元，最低<b>56万</b>元；二套房最高可贷款<b>60万</b>元，最低<b>40万</b>元。</p><p><br/>☛ 取消公积金个人住房贷款“扣减”规定，即职工家庭再次申请公积金贷款时，不再扣减首次已使用过的公积金贷款额度。</p><p><br/>☛ 此前已经受理的公积金个人住房贷款仍然按原政策执行，5月1日起受理的公积金个人贷款(以录入武汉住房公积金管理信息系统为准)按新政策执行。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>c、办理贷款需要携带资料如下：</b><br/>贷款人申请异地贷款时可向武汉公积金中心和受托银行咨询异地贷款的有关政策及办理程序，并携带以下资料向受托银行提交贷款申请： <br/>☛《住房公积金异地贷款申请表》、《异地贷款职工住房公积金缴存使用证明》及近半年缴存明细；<br/>☛ 借款人及配偶身份证及户口簿的原件及复印件； <br/>☛ 借款人婚姻关系或婚姻状况证明(结婚证、离婚证等)，未婚的需填写未婚声明；<br/>☛ 购房合同原件及复印件及购房收据； <br/>☛ 房管部门出具预告登记证； </p><p>☛ 借款人夫妻双方收入证明(银行制式)，未婚情况提供借款人及共同申请人收入证明(银行制式)；<br/>☛ 借款人夫妻双方资金收入账户近12个月流水，未婚情况提供借款人及共同申请人资金收入账户近12个月流水；<br/>☛ 本市住房公积金个人住房贷款需提交的其他资料。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>05</p><p><b>各楼盘分析及点评</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、光谷目前有哪些热门片区及各个片区优劣势分析</b></p><p>光谷目前的热门片区主要有：<b>光谷东、光谷南、关山大道以及江夏片区。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>▶ 关山大道（北起珞喻路华中科技大学正门、南接武汉中环线（三环线））</b></p><p>其<b>优势</b>在于，所在的关山片区被光谷商圈、众多企业和高校环抱，区域内交通条件、周边环境和配套设施飞速发展和完善；</p><p>且离软件园与光谷金融港都比较近，有很多是不错的学区房，以及房源在三环内；</p><p>交通方面有公交、地铁与有轨电车，交通方便；</p><p>商业配套方面，关山大道的商业相对成熟，相比于其他几个区域的<b>劣势</b>，价格较贵。</p><p><br/><b>▶ 光谷东（光谷东区域范围大致西起三环东至左岭，北起九峰，南到武黄高速）</b></p><p><b>优势</b>是规划定位好，将来会成为新城。根据《武汉东湖国家自主创新示范区总体规划（2016-2030年）》，位于光谷东核心区域的光谷中心城定位高科技商务中心，是真正的光谷主中心，鲁巷定位是商业为主的副中心）。</p><p>且规划中，光谷宜家+奥山滑雪场+首创奥特莱斯都会落在光谷东区域，未来升值空间大。离未来科技城较近，若在未来科技城上班，建议优选光谷东；</p><p><b>劣势</b>是目前生活配套还没起来，看起来各个楼配套相当数量的商业，但是目前光谷东没有什么开发商有比较好的商业运营能力，目前靠谱一点的是武汉天地的开发商。</p><p>另外位置偏远，离金融港、软件园等互联网聚集地，并且绝对位置远，离三环线5公里以上、离光谷广场10公里以上、离武昌核心20公里左右、离汉口核心30公里左右；</p><p><br/><b>▶ 江夏区（位于武汉三环外）</b></p><p>相对于光谷东与关山大道，要稍偏僻一些，且户口上学等都属于江夏，不属于东湖高新（光谷核心区域），交通方面离地铁会稍微远一点，但是胜在价格相比其他区域会低一些；</p><p><br/><b>▶ 光谷南（光谷大道向南，从三环线到江夏藏龙岛）</b></p><p><b>优势</b>在于离金融港与软件园都不远，位置较好，价格稳固上升；</p><p>交通便利，有地铁、有轨电车及快速公交等；</p><p>商业配套方面比关山大道弱，但比目前的光谷东与江夏要好一些；</p><p>教育方面，多所名校扎堆 教育资源丰富（光谷二小、光谷实验中学，华一寄宿学校、武汉外国语学校美加分校，武汉海淀外国语学校、武汉枫叶学校、华师一附中等均坐落于光谷南片区，教育资源丰富。虽然多为贵族学校，学费高昂，不过有总比没有强。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>主要的<b>劣势</b>是目前剩下的新房楼盘较少，经常停水停电，基础配套相对较差，尤其是庙山、藏龙岛片区。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2、光谷或周边片区内的高端盘、性价比盘、学区盘分布</b></p><p>▶ 关山大道目前的楼盘为：泛悦城、泷悦华府、华润琨瑜府、世界城、正荣紫阙台、清江山水、中建大公馆<br/></p><p><b>品质：</b>从品质上讲，推荐华润与正荣；<br/></p><p><b>学区盘：</b>从学区来看，中建大公馆对口武汉小学分校，好于其他盘；</p><p><b>从交通来看</b>，优选泛悦城、泷悦，它们靠地铁最近；</p><p><b>从商业配套来讲</b>，中建大公馆与泛悦城会相对于其他盘会好一些。</p><p><br/>▶ 光谷东目前的楼盘为：光谷国际188、光谷创新天地、奥山澎湃城项目、当代云谷、碧桂园项目（今年刚拿到地）、和昌光谷未来城，</p><p><b>综合排序：</b>光谷国际188、光谷创新天地&gt;奥山澎湃城项目&gt;和昌光谷未来城&gt;当代云谷，从居住品质与交通来看，光谷国际188、光谷创新天地要好于奥山澎湃城项目、当代云谷；</p><p class=\"ztext-empty-paragraph\"><br/></p><p>▶ 江夏区目前的楼盘为：雅居乐花园、招商东城华府、江南新天地、枫泽星都汇、拾光里</p><p><br/>▶ 光谷南：目前这个片区没有新房在卖，当代国际城目前在卖商业，住宅只有二手房，需要的可以关注下</p><p class=\"ztext-empty-paragraph\"><br/></p><p>▶ 其他：另外还有 花山区域的联投花山郡、光谷一路上的中建东湖锦城 都还不错</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、对光谷或周边热门楼盘点评</b></p><p><b>关山大道片区：</b></p><p><b>☛ 中建大公馆：</b><br/>靠光谷软件园，也就是在斗鱼办公地的楼下，他家配建了武汉小学分校，自住和出租两相宜。当然，除了这两个优点，我觉得他家其他的都一般。</p><p><br/><b>☛ 泛悦城：</b><br/>他家能最能拿出来说的就是位置了，华科正门口靠地铁。论品质，不如华润。当然，很多时候，地段比什么都强，依然值得关注。</p><p><br/><b>☛  华润琨瑜府：</b><br/>关山大道品质最好的楼盘，并且坚持卖毛坯，光谷改善需求最好选择，无他，就是品质好。他家要下半年开盘，并且买的人多。<br/><br/></p><p><b>☛ 泷悦华府：</b><br/>紧靠着泛悦和华润，是这一地块中位置最差的，品质不如华润，位置不如泛悦城，但是户型多样性是优点。</p><p><br/><b>☛ 世界城香榭丽舍：</b></p><p> 光谷步行街是光谷的魂，这个大家都知道。这个项目是世界城法国风情街的第六期，东临关山大道。这个项目规划了四栋住宅，有底商和一个四层的商业，户型从70多到120多的都有，精装。房子无特点，没有小区，临街，商业上盖，就是卖位置。优点是户型小，购房门槛相对低。</p><p><br/><b>☛ 清江山水：</b> </p><p>这个是光谷一个神盘了，从当年维权不断的盘，现今成为软件园旁最火的盘，不能不说是抱上了软件园这个大腿。今年，这个楼盘还有不少新房源要出来。客观来说，清江做的楼盘，品质都一般。这个楼盘的最大价值就在于与软件园一路之隔，太方便了。自住或者投资，我觉得都是不错的。</p><p><br/><b>☛ 正荣紫阙台：</b> </p><p>就在清江山水旁边。这个楼盘，品质肯定要比清江山水高一个档次，比中建大公馆也要强，应该和华润琨瑜府差不多档次的，这就值得改善人群关注了。当然，价格估计要贵一些。另外，他家小区很特别，是个狭长型的小区，有的人觉得可以，有的人不喜欢。 </p><p><br/><b>☛ 关山大道沿线学区房（包括二手房）：</b><br/>对口光谷一小的，光谷新世界、丽岛曼城、保利时代、金地太阳城、青年城、关山春晓、蓝晶国际</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>光谷东片区：</b></p><p><b>☛ 光谷国际188、光谷创新天地：</b> 周边生活配套完善，靠近地跌。项目西侧为光谷东商业中心，包括绿地、龙湖和瑞安开发的商业中心和商业街区。北面高新大道上有中法医院在建，东侧是光谷中心城一小（在建）和已开学的光谷外校。</p><p><br/><b>光谷国际188</b>在光谷东在售楼盘中算自住舒适度最高之一，平均容积率2.4，楼间距开阔。</p><p><br/><b>光谷创新天地</b>是武汉天地开发商瑞安开发的，被给予在光谷东再造一个武汉天地的厚望。居住舒适度被认为是光谷东最佳。平均容积率2.5，楼栋分布从低至高，由高层、小高层、洋房组成的围合式布局，通透和视野有保障。最大亮点是项目西侧是新月溪公园，生态环境好。离地铁11号线光谷六路站约800米，走路约15分钟，离有轨电车T2号线更近。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>☛ 光谷澎湃城奥山府： </b><br/>光谷澎湃城奥山府位于光谷东偏南区域，距离光谷网球中心、首创奥特莱斯较近。</p><p><br/>奥山府容积率2.3，产品类型有高层、双拼别墅、合院别墅等，小区内部南低北高，中间低两边高设计，风格偏中式，从现场看小区景观设计不错。 高层住宅共37栋，面积段为95㎡—225㎡，别墅面积集中在250㎡—310㎡。 </p><p><br/>缺点是</p><p>1.远离住宅区，最近的住宅项目是东北面的绿地国际理想城，因此，项目“蹭”周边小区生活配套的可能性较小。离地铁站也略远，超过2公里。 </p><p>2.装修水平缩水，交付标准去掉中央空调等配置。</p><p><br/><b>☛ 当代云谷： </b></p><p>当代云谷距离住宅区更远，在一片工业用地中间，东侧就是葛洲坝太阳城工业园。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>☛和昌光谷未来城:</b><br/></p><p>学校配套还不错：博苑双语幼儿园，二师附小、光谷八小、光谷二初中、关山中学。周围商业配套不算远，近一点的有奥特莱斯、宜家等。医疗配套，附近有湖北省中医院、武汉市第三医院光谷关山院区等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>江夏片区：</b><br/></p><p><b>☛ 雅居乐花园(庙山)：</b> </p><p>虽然位置较偏僻。但还是建议买不起关山大道、光谷东的，去看看这个楼盘。这个开发商是第一次进武汉，名气不大，但是在广东却是个大开发商，房子也做的非常好。这个楼盘在庙山，地块比较大，容易做出品质出来，体量大，配套也容易做起来。</p><p><br/><b>☛ 招商东城华府（佛祖岭）：</b><br/>在中海附近。中海喜欢说自己是光谷南，其实正儿八经是个江夏的楼盘，招商也是，属地绝对是江夏，不是光谷，所以户口、上学等都是江夏，不是东湖高新。招商的房子其实做得不错的，但是他家和中海都有个难题，从拿地那一刻，就决定了售价在片区偏高，很多购房者比较犹豫。所以他家很可能和中海一样，不会出现日光。 </p><p><br/><b>☛ 长投绿城蘭园（藏龙岛）：</b><br/>环境不错，就是到光谷来堵，房子还不错；</p><p><br/><b>☛ 江南新天地：</b><br/>算是文化大道上，性价比超高的楼盘了，有地铁，配套还可以。<br/>枫泽星都汇：<br/>配套一般，不是很全，附件有地铁，交通还算便利，在文化大道上，口碑还算不错，性价比不错。</p><p><br/><b>☛ 其他： </b><br/>1、中建东湖锦城：靠地铁口，价格比关山大道便宜一些。<br/>2、联投花山郡：在花山区，位置稍微有点偏，自然环境还不错，配套的小学还不错是华师一附中， 缺点据传离化工区有点近。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>汉阳区：</b></p><p><b>☛ 万科金域国际（五里墩）</b><br/>地铁盘，位置挺好的，去哪都方便，可以蹭华润的商业配套。</p><p><br/><b>☛ 华润万象汇润府（五里墩）</b><br/>和万科要打擂台，差不多的位置，品质与万科相当，自己还配套商业。</p><p><br/><b>☛ 招商樾望（四新）</b><br/>位于四新北路与芳草路交汇处（汉阳麦德龙旁），招商的房子是不错的，物业也好。还靠麦德龙和方岛，自住应该是不错的，就是住宅户型偏大。另外，所谓的“商墅”想清楚了买，其产权性质其实和公寓、LOFT一样的。</p><p><br/><b>☛ 保利星河九州</b><br/>保利的品质一向比较稳定，刚需和刚改自己住都不错。特别提醒，买他家别冲动，一定要深入了解其所处的位置，一定要查清楚周边情况，再决定是否买</p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上便是互联网从业者在武汉定居买房的一个方向参考，部分资料来源网络，欢迎大家加歪特君微信<b>WH-IT-er</b>进群讨论指正。</p><p>本文由公众号 <b>不止思考</b> 作者投稿，作者为资深互联网技术从业者，12年回汉发展。公众号关注 Java、Web、架构、大数据、区块链、技术管理、职业发展 等方面的思考与心得，传送门：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "武汉互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19576547"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }, 
                {
                    "tag": "武汉楼市", 
                    "tagLink": "https://api.zhihu.com/topics/19868334"
                }
            ], 
            "comments": [
                {
                    "userName": "小鹿", 
                    "userLink": "https://www.zhihu.com/people/4dda6da895450b6d234ca5cad844cb6d", 
                    "content": "给小编点赞", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "妖精的尾巴", 
                    "userLink": "https://www.zhihu.com/people/5356dd7940fc8fb5f2bb7c268360a885", 
                    "content": "<p>感谢</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知而行", 
                    "userLink": "https://www.zhihu.com/people/833d2e94d418c790146745c288caccfc", 
                    "content": "庙山当代云城怎么样？有点后悔买了。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44443115", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "当你「ping 一下」的时候，你知道它背后的逻辑吗？", 
            "content": "<p>我们在遇到网络不通的情况，大家都知道去 ping 一下，看一下网络状况。<br/>那你知道「ping」命令后背的逻辑是什么吗？知道它是如何实现的吗？</p><h2><b>一、「ping」命令的作用和原理？</b></h2><p>简单来说，「ping」是用来探测本机与网络中另一主机之间是否可达的命令，如果两台主机之间ping不通，则表明这两台主机不能建立起连接。ping是定位网络通不通的一个重要手段。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ping 命令是基于 ICMP 协议来工作的，「 ICMP 」全称为 Internet 控制报文协议（ Internet Control Message Protocol）。ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为ICMP协议会要求目标主机在收到消息之后，必须返回ICMP应答消息给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举一个例子来描述「ping」命令的工作过程：</p><ol><li>假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2</li><li>此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。</li><li>IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包。</li><li>IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去。</li><li>当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A</li><li>在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。</li></ol><p>通过ping的流程可以发现，ICMP协议是这个过程的基础，是非常重要的，因此下面就把ICMP协议再详细解释一下。</p><h2><b>二、什么是「 ICMP 」？</b></h2><p>我们知道，ping命令是基于ICMP协议来实现的。那么我们再来看下图，就明白了ICMP协议又是通过IP协议来发送的，即ICMP报文是封装在IP包中。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7a93952c3b57668a367725192d4c9de8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"299\" data-rawheight=\"90\" class=\"content_image\" width=\"299\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;299&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"299\" data-rawheight=\"90\" class=\"content_image lazy\" width=\"299\" data-actualsrc=\"https://pic1.zhimg.com/v2-7a93952c3b57668a367725192d4c9de8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>IP协议是一种无连接的，不可靠的数据包协议，它并不能保证数据一定被送达，那么我们要保证数据送到就需要通过其它模块来协助实现，这里就引入的是ICMP协议。</p><p>当传送的IP数据包发送异常的时候，ICMP就会将异常信息封装在包内，然后回传给源主机。</p><p>将上图再细拆一下可见：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d637a69f77ac5ec36702fe76c347cc4f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"80\" class=\"content_image\" width=\"397\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;397&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"397\" data-actualsrc=\"https://pic4.zhimg.com/v2-d637a69f77ac5ec36702fe76c347cc4f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>继续将ICMP协议模块细拆:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-874923550306f43441a42e5b58915275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-874923550306f43441a42e5b58915275_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;151&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"151\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic2.zhimg.com/v2-874923550306f43441a42e5b58915275_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-874923550306f43441a42e5b58915275_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由图可知，ICMP数据包由8bit的类型字段和8bit的代码字段以及16bit的校验字段再加上选项数据组成。</p><p>ICMP协议大致可分为两类：</p><ul><li><b>查询报文类型</b></li><li><b>差错报文类型</b></li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-448439bb584874c0198e1e86c89bfc72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"427\" class=\"content_image\" width=\"420\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;420&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"420\" data-rawheight=\"427\" class=\"content_image lazy\" width=\"420\" data-actualsrc=\"https://pic3.zhimg.com/v2-448439bb584874c0198e1e86c89bfc72_b.jpg\"/></figure><ol><li><b>查询报文类型</b>：</li></ol><p>查询报文主要应用于：ping查询、子网掩码查询、时间戳查询等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面讲到的ping命令的流程其实就对应ICMP协议查询报文类型的一种使用。在主机A构建ICMP请求数据包的时候，其ICMP的类型字段中使用的是 8 （回送请求），当主机B构建ICMP应答包的时候，其ICMP类型字段就使用的是 0 （回送应答），更多类型值参考上表。</p><p>对 查询报文类型 的理解可参考一下文章最开始讲的ping流程，这里就不做赘述。</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li><b>差错报文类型</b>：</li></ol><p>差错报文主要产生于当数据传送发送错误的时候。<br/>它包括：目标不可达（网络不可达、主机不可达、协议不可达、端口不可达、禁止分片等）、超时、参数问题、重定向（网络重定向、主机重定向等）等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>差错报文通常包含了引起错误的IP数据包的第一个分片的IP首部，加上该分片数据部分的前8个字节。</p><p><br/>当传送IP数据包发生错误的时候（例如 主机不可达），ICMP协议就会把错误信息封包，然后传送回源主机，那么源主机就知道该怎么处理了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那是不是只有遇到错误的时候才能使用 差错报文类型 呢？也不一定。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Traceroute 就是一个例外，Traceroute是用来侦测源主机到目标主机之间所经过路由情况的常用工具。Traceroute 的原理就是利用ICMP的规则，制造一些错误的事件出来，然后根据错误的事件来评估网络路由情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体做法就是：</p><p>Traceroute会设置特殊的TTL值，来追踪源主机和目标主机之间的路由数。首先它给目标主机发送一个 TTL=1 的UDP数据包，那么这个数据包一旦在路上遇到一个路由器，TTL就变成了0（TTL规则是每经过一个路由器都会减1），因为TTL=0了，所以路由器就会把这个数据包丢掉，然后产生一个错误类型（超时）的ICMP数据包回发给源主机，也就是差错包。这个时候源主机就拿到了第一个路由节点的IP和相关信息了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接着，源主机再给目标主机发一个 TTL=2 的UDP数据包，依旧上述流程走一遍，就知道第二个路由节点的IP和耗时情况等信息了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如此反复进行，Traceroute就可以拿到从主机A到主机B之间所有路由器的信息了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是有个问题是，如果数据包到达了目标主机的话，即使目标主机接收到TTL值为1的IP数据包，它也是不会丢弃该数据包的，也不会产生一份超时的ICMP回发数据包的，因为数据包已经达到了目的地嘛。那我们应该怎么认定数据包是否达到了目标主机呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Traceroute的方法是在源主机发送UDP数据包给目标主机的时候，会设置一个不可能达到的目标端口号（例如大于30000的端口号），那么当这个数据包真的到达目标主机的时候，目标主机发现没有对应的端口号，因此会产生一份“端口不可达”的错误ICMP报文返回给源主机。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>可见Traceroute的原理确实很取巧，很有趣。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上，就是对ping的基本原理以及ICMP协议的基本讲解了，欢迎大家一起交流。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流Java、Web、架构、大数据、职业发展、技术管理。  </blockquote><p></p>", 
            "topic": [
                {
                    "tag": "ICMP", 
                    "tagLink": "https://api.zhihu.com/topics/20021763"
                }, 
                {
                    "tag": "Ping", 
                    "tagLink": "https://api.zhihu.com/topics/19565676"
                }, 
                {
                    "tag": "traceroute", 
                    "tagLink": "https://api.zhihu.com/topics/20042264"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43887799", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "不懂高性能的负载均衡设计？没关系，架构师带你飞", 
            "content": "<p>在软件系统的架构设计中，对集群的负载均衡设计是作为高性能系统优化环节中必不可少的方案。负载均衡本质上是用于将用户流量进行均衡减压的，因此在互联网的大流量项目中，其重要性不言而喻。<br/></p><h2><b>一、什么是负载均衡？</b></h2><p>早期的互联网应用，由于用户流量比较小，业务逻辑也比较简单，往往一个单服务器就能满足负载需求。随着现在互联网的流量越来越大，稍微好一点的系统，访问量就非常大了，并且系统功能也越来越复杂，那么单台服务器就算将性能优化得再好，也不能支撑这么大用户量的访问压力了，这个时候就需要使用多台机器，设计高性能的集群来应对。</p><p>那么，多台服务器是如何去均衡流量、如何组成高性能的集群的呢？</p><p>此时就需要请出 「负载均衡器」 入场了。</p><p>负载均衡（Load Balancer）是指把用户访问的流量，通过「负载均衡器」，根据某种转发的策略，均匀的分发到后端多台服务器上，后端的服务器可以独立的响应和处理请求，从而实现分散负载的效果。负载均衡技术提高了系统的服务能力，增强了应用的可用性。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cbab668d7f684f71811c9c261f9ea640_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-cbab668d7f684f71811c9c261f9ea640_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;635&#39; height=&#39;392&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"392\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-cbab668d7f684f71811c9c261f9ea640_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cbab668d7f684f71811c9c261f9ea640_b.jpg\"/></figure><p>（可以按照图中去理解，图片来源网络）</p><h2><b>二、负载均衡方案有几种？</b></h2><p>目前市面上最常见的负载均衡技术方案主要有三种：</p><ul><li><b>基于DNS负载均衡</b></li><li><b>基于硬件负载均衡</b></li><li><b>基于软件负载均衡</b></li></ul><p>三种方案各有优劣，DNS负载均衡可以实现在地域上的流量均衡，硬件负载均衡主要用于大型服务器集群中的负载需求，而软件负载均衡大多是基于机器层面的流量均衡。在实际场景中，这三种是可以组合在一起使用。下面来详细讲讲：</p><ol><li><b>基于DNS负载均衡</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1e2aba1578e919d87b4d879856ee050b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"671\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"671\" data-original=\"https://pic4.zhimg.com/v2-1e2aba1578e919d87b4d879856ee050b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;671&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"671\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"671\" data-original=\"https://pic4.zhimg.com/v2-1e2aba1578e919d87b4d879856ee050b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1e2aba1578e919d87b4d879856ee050b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>基于DNS来做负载均衡其实是一种最简单的实现方案，通过在DNS服务器上做一个简单配置即可。<br/>其原理就是当用户访问域名的时候，会先向DNS服务器去解析域名对应的IP地址，这个时候我们可以让DNS服务器根据不同地理位置的用户返回不同的IP。比如南方的用户就返回我们在广州业务服务器的IP，北方的用户来访问的话，我就返回北京业务服务器所在的IP。</p><p>在这个模式下，用户就相当于实现了按照「就近原则」将请求分流了，既减轻了单个集群的负载压力，也提升了用户的访问速度。</p><p>使用DNS做负载均衡的方案，天然的优势就是配置简单，实现成本非常低，无需额外的开发和维护工作。<br/>但是也有一个明显的缺点是：当配置修改后，生效不及时。这个是由于DNS的特性导致的，DNS一般会有多级缓存，所以当我们修改了DNS配置之后，由于缓存的原因，会导致IP变更不及时，从而影响负载均衡的效果。</p><p>另外，使用DNS做负载均衡的话，大多是基于地域或者干脆直接做IP轮询，没有更高级的路由策略，所以这也是DNS方案的局限所在。</p><ol><li><b>基于硬件负载均衡</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bc7ecb2d650266300f275dd6efe434f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"453\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"453\" data-original=\"https://pic2.zhimg.com/v2-bc7ecb2d650266300f275dd6efe434f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;453&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"453\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"453\" data-original=\"https://pic2.zhimg.com/v2-bc7ecb2d650266300f275dd6efe434f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bc7ecb2d650266300f275dd6efe434f9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>硬件的负载均衡那就比较牛逼了，比如大名鼎鼎的 <b>F5 Network Big-IP</b>，也就是我们常说的 <b>F5</b>，它是一个网络设备，你可以简单的理解成类似于网络交换机的东西，完全通过硬件来抗压力，性能是非常的好，每秒能处理的请求数达到百万级，即 几百万/秒 的负载，当然价格也就非常非常贵了，十几万到上百万人民币都有。</p><p>因为这类设备一般用在大型互联网公司的流量入口最前端，以及政府、国企等不缺钱企业会去使用。一般的中小公司是不舍得用的。</p><p>采用 <b>F5</b> 这类硬件做负载均衡的话，主要就是省心省事，买一台就搞定，性能强大，一般的业务不在话下。而且在负载均衡的算法方面还支持很多灵活的策略，同时还具有一些防火墙等安全功能。但是缺点也很明显，一个字：贵。</p><ol><li><b>基于软件负载均衡</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-64f9b0b3b81ceeb4b4d9d0eae011799c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"733\" data-original=\"https://pic1.zhimg.com/v2-64f9b0b3b81ceeb4b4d9d0eae011799c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;733&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"733\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"733\" data-original=\"https://pic1.zhimg.com/v2-64f9b0b3b81ceeb4b4d9d0eae011799c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-64f9b0b3b81ceeb4b4d9d0eae011799c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>软件负载均衡是指使用软件的方式来分发和均衡流量。软件负载均衡，分为7层协议 和 4层协议。<br/>网络协议有七层，基于第四层传输层来做流量分发的方案称为4层负载均衡，例如 <b>LVS</b>，而基于第七层应用层来做流量分发的称为7层负载均衡，例如 <b>Nginx</b>。这两种在性能和灵活性上是有些区别的。</p><p>基于4层的负载均衡性能要高一些，一般能达到 几十万/秒 的处理量，而基于7层的负载均衡处理量一般只在 几万/秒 。</p><p>基于软件的负载均衡的特点也很明显，便宜。在正常的服务器上部署即可，无需额外采购，就是投入一点技术去优化优化即可，因此这种方式是互联网公司中用得最多的一种方式。</p><h2><b>三、常用的均衡算法有哪些？</b></h2><p>上面讲完了常见的负载均衡技术方案，那么接下来咱们看一下，在实际方案应用中，一般可以使用哪些均衡算法？</p><ul><li><b>轮询策略</b></li><li><b>负载度策略</b></li><li><b>响应策略</b></li><li><b>哈希策略</b></li></ul><p>下面来分别介绍一下这几种均衡算法/策略的特点：</p><ol><li><b>轮询策略</b></li></ol><p>轮询策略其实很好理解，就是当用户请求来了之后，「负载均衡器」将请求轮流的转发到后端不同的业务服务器上。这个策略在DNS方案中用的比较多，无需关注后端服务的状态，只药有请求，就往后端轮流转发，非常的简单、实用。</p><p>在实际应用中，轮询也会有多种方式，有按顺序轮询的、有随机轮询的、还有按照权重来轮询的。前两种比较好理解，第三种按照权重来轮询，是指给每台后端服务设定一个权重值，比如性能高的服务器权重高一些，性能低的服务器给的权重低一些，这样设置的话，分配流量的时候，给权重高的更多流量，可以充分的发挥出后端机器的性能。</p><ol><li><b>负载度策略</b></li></ol><p>负载度策略是指当「负载均衡器」往后端转发流量的时候，会先去评估后端每台服务器的负载压力情况，对于压力比较大的后端服务器转发的请求就少一些，对于压力比较小的后端服务器可以多转发一些请求给它。</p><p>这种方式就充分的结合了后端服务器的运行状态，来动态的分配流量了，比轮询的方式更为科学一些。</p><p>但是这种方式也带来了一些弊端，因为需要动态的评估后端服务器的负载压力，那这个「负载均衡器」除了转发请求以外，还要做很多额外的工作，比如采集 连接数、请求数、CPU负载指标、IO负载指标等等，通过对这些指标进行计算和对比，判断出哪一台后端服务器的负载压力较大。</p><p>因此这种方式带来了效果优势的同时，也增加了「负载均衡器」的实现难度和维护成本。</p><ol><li><b>响应策略</b></li></ol><p>响应策略是指，当用户请求过来的时候，「负载均衡器」会优先将请求转发给当前时刻响应最快的后端服务器。<br/>也就是说，不管后端服务器负载高不高，也不管配置如何，只要觉得这个服务器在当前时刻能最快的响应用户的请求，那么就优先把请求转发给它，这样的话，对于用户而言，体验也最好。</p><p>那「负载均衡器」是怎么知道哪一台后端服务在当前时刻响应能力最佳呢？<br/>这就需要「负载均衡器」不停的去统计每一台后端服务器对请求的处理速度了，比如一分钟统计一次，生成一个后端服务器处理速度的排行榜。然后「负载均衡器」根据这个排行榜去转发服务。</p><p>那么这里的问题就是统计的成本了，不停的做这些统计运算本身也会消耗一些性能，同时也会增加「负载均衡器」的实现难度和维护成本。</p><ol><li><b>哈希策略</b></li></ol><p>Hash策略也比较好理解，就是将请求中的某个信息进行hash计算，然后根据后端服务器台数取模，得到一个值，算出相同值的请求就被转发到同一台后端服务器中。</p><p>常见的用法是对用户的IP或者ID进行这个策略，然后「负载均衡器」就能保证同一个IP来源或者同一个用户永远会被送到同一个后端服务器上了，一般用于处理缓存、会话等功能的时候特别好用。</p><p>以上，就是实现高性能负载均衡的常见技术方案和策略了，欢迎大家一起交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "架构师", 
                    "tagLink": "https://api.zhihu.com/topics/19557488"
                }, 
                {
                    "tag": "负载均衡", 
                    "tagLink": "https://api.zhihu.com/topics/19596611"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43372200", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 2, 
            "title": "从程序员的防猝死，思考码农身后的家庭保障", 
            "content": "<p>刚刚，据说又有一名程序员在工作中由于过劳倒下了，这是在8月份发生的事情：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ac1c532780b0d1849c2dd7b3a314e10e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic3.zhimg.com/v2-ac1c532780b0d1849c2dd7b3a314e10e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic3.zhimg.com/v2-ac1c532780b0d1849c2dd7b3a314e10e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ac1c532780b0d1849c2dd7b3a314e10e_b.jpg\"/></figure><p>视频地址：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//tb-video.bdstatic.com/tieba-smallvideo-transcode/3062574_f3f4c62bf9fafcc04d9b6ee91bb54d05_0.mp4\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">tb-video.bdstatic.com/t</span><span class=\"invisible\">ieba-smallvideo-transcode/3062574_f3f4c62bf9fafcc04d9b6ee91bb54d05_0.mp4</span><span class=\"ellipsis\"></span></a></p><p><br/>事件发生之后，这个视频在技术圈经过一轮疯转，然后紧接着又开始了一波重视程序员健康问题的大讨论。虽然这类问题被讨论过无数次，也有无数个教训摆在程序员的面前，但估计等话题热度一过，大家又回归原来的生活状态，该加班加班，该透支身体的透支身体。</p><p><br/>毕竟，在大家传统意识中，「 长期加班 」、「 996 」、「 通宵熬夜 」都已经成为程序员的标配了。</p><p><br/>鉴于已经有很多文章在讲程序员应该如何防猝死，如何注意健康问题，那我这里就不赘述了。 <br/>我这里换一个角度，来跟大家聊一聊我们程序员群体们过劳的问题：</p><p><br/><b>「 作为程序员的你， 有没有考虑过，当你出现意外时，谁来负担自己的医疗？谁来负担你的老婆孩子与父母？」</b></p><p><br/>这句话听起来很无情，但却是一个非常现实的问题。</p><p><br/>这也是本文的目的，我们确实要优先预防健康问题，但我们也不能无视风险，一旦风险发生，希望大家该有的保障都有。</p><p><br/>怎么才能有保障呢？这就是下面即将要聊到的「 保险 」的作用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bb7966f3786a4ba565e3a62ed3ef200a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"861\" data-original=\"https://pic3.zhimg.com/v2-bb7966f3786a4ba565e3a62ed3ef200a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;861&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"861\" data-original=\"https://pic3.zhimg.com/v2-bb7966f3786a4ba565e3a62ed3ef200a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bb7966f3786a4ba565e3a62ed3ef200a_b.jpg\"/></figure><p><b>一、程序员才是最应该购买保险的群体</b></p><p><br/>对于程序员而言，保险是一件非常重要的事情，为啥？</p><p><br/>因为程序员苦逼啊、加班多啊，健康透支严重啊，更重要的是，大多数程序员还是家庭主要经济支柱，一个程序员倒下了，可能背后就是一个家庭倒下了，你说，程序员是不是最需要保障的群体。</p><p><br/>有一句保险宣传语非常有意思：</p><p><b>「 站着是一台印钞机、倒下了是一堆人民币 」</b></p><p>这句话用来形容购买了保险的程序员再合适不过了。</p><p><br/>程序员在大家的眼中就是高智商、高收入人群，那么在高强度的工作下，万一出现了意外，谁来负担自己的医疗？谁来负担身后的家庭呢？</p><p><br/>保险本质上是一种风险转移工具，能将你承受不起的风险转移给保险公司。就是用少量的钱买一份心安，但我们希望保险永远都用不上。</p><p><br/>在发达的国家，保险是一件非常普及的事情，但是在中国，由于各种原因，保险并没有被大众普遍接受。大多数人对保险的认知，还处于非常原始的状态，或者干脆将保险误解成是骗人的东西。 </p><p><br/>如果你对保险的认知，还是处于这种层次，那么你就真的应该花点时间，发挥一下程序员的钻研精神，去好好的研究一下保险知识了。</p><p><br/>不过要注意的是，这里说的保险，并非是指 理财类保险，而是指健康类的：医疗险、意外险、重疾险、寿险 等。</p><p><br/>理财保险只是具有一个长期理财的功能特殊险种，并不能对人身健康起到保障作用，并不推荐程序员配置。</p><p><br/>好了，讲完了程序员为什么要买保险，接下来我们来聊一下程序员的家庭应该如何去配置一份合理的保险。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二、程序员应该如何购买保险</b></p><p><br/>其实很多人对保险的了解，都是从有了小孩之后才开始的，并非出于对自己健康的考虑，身边的很多同事朋友都是这样。 </p><p><br/>但我想告诉大家的是，一个正确的配置保险的顺序应该是：先大人，后小孩，优先考虑家庭经济支柱，再考虑其他成员。</p><p><br/>很多人喜欢先给孩子买，殊不知，其实父母才是孩子最大的保障，优先考虑保障家庭经济支柱，万一发生意外，也能最大程度缓解家庭状况，维持正常生活。当然，有条件的，建议全部家庭成员都进行保险保障。</p><p><br/>保险按类别看，主要分为</p><ul><li>社保保险</li><li>商业保险</li></ul><p><b>社保保险</b>：是每一个参加工作的人都缴纳的保险保障，是国家要求的，也是一种最基础的保障制度。非常重要，但它并不全面，比如自费药/进口药不报销，有比例有限额等等。因此，就有了商业保险的诞生。</p><p><br/><b>商业保险</b>：是一种对社会保险的补充。健康商业保险大概又分为：<br/></p><ul><li><b>意外险</b></li><li><b>医疗险</b></li><li><b>重疾险</b></li><li><b>寿险</b></li></ul><p>当然，还有其它的一些健康类保险，由于不是特别主流，所以这里就不做介绍。 <br/>下面就详细说一下上面几种健康类保险的特点：<br/></p><ol><li><b>意外险</b></li></ol><p>意外险，一般是保障 意外身故、意外伤残、意外医疗的。 </p><p><br/>如果发生意外导致身故、伤残了，就会按照伤残等级，进行一次性赔付保额，也就是你当初保的多少钱，就一次性赔付给你。有的意外险还会附加医疗责任，就是如果因为意外事件导致的治疗，可以按照治疗费用进行报销。每款险种都会有一些细节上的差异，有的意外险还可以保障猝死，也就是当上面发生的那种程序员过劳猝死的话，保险公司也会按照保额进行赔付。<br/>意外险都比较便宜，所以意外险真的是杠杆最高的一种保险了。所谓杠杆，是指保额与保费的比例，高杠杆就是指用极少的钱获得了极高金额的保障。</p><p><br/>但是这里得说明一下「意外」的定义，它需要满足：外来的、突发的、非本意的、非疾病的客观事件。 </p><p><br/>也就是说因疾病导致的，不算意外。常见的意外如：交通事故、运动、摔倒、烧伤、烫伤等等，只是举例，不仅限如此。</p><p><br/>推荐配置消费型意外险，不要购买返还型的，返回型的不划算。几乎每家保险公司都有类似产品，名称不同，可以仔细对比。消费型意外险100万保额一年大概只需要三四百块钱即可，应该是年轻人最先考虑购买的保险。</p><p><br/>这里推荐几个热门意外险产品：「 安心财险-百万成人意外险 」、「 众安保险-个人综合意外险 」、「 小米综合意外险」，这些保险在官网都可以买到，几百块钱保障几十万到上百万。<br/></p><ol><li><b>医疗险</b></li></ol><p>医疗险，顾名思义，就是用于报销医疗费用的保险。 </p><p><br/>它与意外险的最大的区别就是，意外险是赔付型的，而医疗险是报销型的，用多少报销多少，且医疗险面积要广很多，无论是疾病还是意外受伤，只要治疗了，都可以报销。</p><p><br/>就拿 住院医疗保险 举例，只要是投保人生病入院了，并且符合保险中的一些规定，出院后就可以拿着发票找保险公司去报销。不同险种的规定都不同，比如有的要求医院等级达到什么要求、有的有用药范围（是否包括进口药）的要求等等。</p><p><br/>医疗险有专门只针对住院进行报销的，也有针对门诊医疗进行报销的。有大额度的，也有小额度的，价钱不一样。</p><p><br/>这里给程序员们推荐一种非常火爆的医疗保险，一般称为「 百万医疗险 」。</p><p><br/>很多保险公司都有这类保险，各家的名字可能不一样，年轻人投保很便宜，几百块钱。不过由于定价这么便宜，所以一般都有免赔额，比如住院医疗1万元以内不予报销，超过部分可以全部报销等限制，大家可以去搜索看看。</p><p><br/>这里推荐几个热门的医疗险产品：「 众安保险-尊享e生 」、「 支付宝-长期医疗险」。这些保险在官网都可以买到，几百块钱保障一百万医疗费用。<br/></p><ol><li><b>重疾险</b></li></ol><p>重疾险，就是在被保险人发生“重大疾病”时，保险公司一次性赔付一定的进行金额。<br/>哪些疾病属于「 重大疾病」？ </p><p><br/>「 重大疾病」的范畴，在保险行业中是有明确的规定的，一般这类疾病的治疗费用非常高，对家庭的影响也是最大的，因此这个险种稍微贵一点，但是也是最应该配置的保险之一。</p><p><br/>同样推荐配置消费型的重疾险，不要购买返还型，返还型的不划算。一般30岁左右男性，购买50万额度的消费型重疾险，保障到终生，如果交纳30年的话，大概每年需要交纳六七千块钱。每个保险公司的产品不同，价格也就不同。</p><p><br/>这里推荐几个热门重疾险产品：「 弘康保险-康乐一生 」、「 百年人寿-康惠保 」、「瑞泰人寿-瑞泰人寿瑞盈 」。这些保险在官网都可以买到，都属于互联网线上保险。<br/></p><ol><li><b>寿险</b></li></ol><p>寿险是保障身故的，被保险人如果身故，保险公司就会赔付一定额度保险金，其实是给被保险人家人的。 </p><p><br/>很多程序员是家庭的主要经济支柱，可以考虑补充这种保险。</p><p><br/>同样推荐配置消费型寿险，一般30岁左右男性，购买50万额度的寿险，保障到终生的话，大概需要四五千块钱一年。每个保险公司的产品不同价格也不同。</p><p><br/>这里推荐几个热门寿险产品：「 百年人寿-定惠保 」、「 瑞泰人寿-瑞和定寿 」。这些保险在官网都可以买到，都非常划算。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f8017110bca7857c8c5efec43641ff16_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"658\" class=\"origin_image zh-lightbox-thumb\" width=\"737\" data-original=\"https://pic3.zhimg.com/v2-f8017110bca7857c8c5efec43641ff16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;737&#39; height=&#39;658&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"737\" data-rawheight=\"658\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"737\" data-original=\"https://pic3.zhimg.com/v2-f8017110bca7857c8c5efec43641ff16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f8017110bca7857c8c5efec43641ff16_b.jpg\"/></figure><p><br/>另外，上面多次提到「消费型 」和「 返还型 」，这里讲一下有什么区别： </p><p><br/>商业保险有 消费型 和 返还型 两种，消费型的一般便宜一些，纯保障，返还型的在一定的年限后还会把当初交的保费还给客户，所以就会贵一些，其实就是多交一些钱让保险公司去投资去了，但是很多人看到钱还可以返还，心里就很舒服，如果仔细算一笔账就会发现，还不与自己去投资，所以更多的推荐大家配置便宜的消费型保险。</p><p><br/>再者，很多人买保险一定要买大公司的，其实真的没有必要，任何一个保险公司的产品都是经过严格审批才能上市的，并且保险公司背后还有再保险以及保监会去兜底，安全性根本无需担心，还是要把考察的重点放在产品特性上。</p><p><br/>无论是哪个险种，一般在投保之前，保险公司都要求投保人是健康体，也就是在投保之前要向保险公司告知自己的身体健康情况，满足保险公司的健康要求才能投保，所以保险购买越早越好。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注交流 互联网认知、工作管理、大数据、Web、区块链技术。</p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "猝死", 
                    "tagLink": "https://api.zhihu.com/topics/19579429"
                }, 
                {
                    "tag": "IT 行业", 
                    "tagLink": "https://api.zhihu.com/topics/19587634"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42847972", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "架构师带你玩转分布式锁", 
            "content": "<p>大多数互联网系统都是分布式部署的，分布式部署确实能带来性能和效率上的提升，但为此，我们就需要多解决一个分布式环境下，数据一致性的问题。<br/>当某个资源在多系统之间，具有共享性的时候，为了保证大家访问这个资源数据是一致的，那么就必须要求在同一时刻只能被一个客户端处理，不能并发的执行，否者就会出现同一时刻有人写有人读，大家访问到的数据就不一致了。</p><p><b>一、我们为什么需要分布式锁？</b><br/>在单机时代，虽然不需要分布式锁，但也面临过类似的问题，只不过在单机的情况下，如果有多个线程要同时访问某个共享资源的时候，我们可以采用线程间加锁的机制，即当某个线程获取到这个资源后，就立即对这个资源进行加锁，当使用完资源之后，再解锁，其它线程就可以接着使用了。例如，在JAVA中，甚至专门提供了一些处理锁机制的一些API（synchronize/Lock等）。</p><p><br/>但是到了分布式系统的时代，这种线程之间的锁机制，就没作用了，系统可能会有多份并且部署在不同的机器上，这些资源已经不是在线程之间共享了，而是属于进程之间共享的资源。<br/>因此，为了解决这个问题，我们就必须引入「分布式锁」。<br/>分布式锁，是指在分布式的部署环境下，通过锁机制来让多客户端互斥的对共享资源进行访问。</p><p><br/>分布式锁要满足哪些要求呢？<br/></p><ul><li>排他性：在同一时间只会有一个客户端能获取到锁，其它客户端无法同时获取</li><li>避免死锁：这把锁在一段有限的时间之后，一定会被释放（正常释放或异常释放）</li><li>高可用：获取或释放锁的机制必须高可用且性能佳</li></ul><p>讲完了背景和理论，那我们接下来再看一下分布式锁的具体分类和实际运用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二、分布式锁的实现方式有哪些？</b></p><p><br/>目前主流的有三种，从实现的复杂度上来看，从上往下难度依次增加：<br/></p><ul><li><b>基于数据库实现</b></li><li><b>基于Redis实现</b></li><li><b>基于ZooKeeper实现</b></li></ul><p>无论哪种方式，其实都不完美，依旧要根据咱们业务的实际场景来选择。<br/></p><ol><li><b>基于数据库实现：</b> <br/>基于数据库来做分布式锁的话，通常有两种做法： </li></ol><ul><li>基于数据库的乐观锁</li><li>基于数据库的悲观锁</li></ul><p><b>我们先来看一下如何基于「乐观锁」来实现：</b></p><p><br/>乐观锁机制其实就是在数据库表中引入一个版本号（version）字段来实现的。 <br/>当我们要从数据库中读取数据的时候，同时把这个version字段也读出来，如果要对读出来的数据进行更新后写回数据库，则需要将version加1，同时将新的数据与新的version更新到数据表中，且必须在更新的时候同时检查目前数据库里version值是不是之前的那个version，如果是，则正常更新。如果不是，则更新失败，说明在这个过程中有其它的进程去更新过数据了。</p><p><br/>下面找图举例，</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ee5993b9ea81b0a3811825474632081b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"617\" class=\"origin_image zh-lightbox-thumb\" width=\"855\" data-original=\"https://pic4.zhimg.com/v2-ee5993b9ea81b0a3811825474632081b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;855&#39; height=&#39;617&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"617\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"855\" data-original=\"https://pic4.zhimg.com/v2-ee5993b9ea81b0a3811825474632081b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ee5993b9ea81b0a3811825474632081b_b.jpg\"/></figure><p><br/>（图片来源网络）</p><p><br/>如图，假设同一个账户，用户A和用户B都要去进行取款操作，账户的原始余额是2000，用户A要去取1500，用户B要去取1000，如果没有锁机制的话，在并发的情况下，可能会出现余额同时被扣1500和1000，导致最终余额的不正确甚至是负数。但如果这里用到乐观锁机制，当两个用户去数据库中读取余额的时候，除了读取到2000余额以外，还读取了当前的版本号version=1，等用户A或用户B去修改数据库余额的时候，无论谁先操作，都会将版本号加1，即version=2，那么另外一个用户去更新的时候就发现版本号不对，已经变成2了，不是当初读出来时候的1，那么本次更新失败，就得重新去读取最新的数据库余额。</p><p><br/>通过上面这个例子可以看出来，使用「乐观锁」机制，必须得满足： </p><p><br/>（1）锁服务要有递增的版本号version <br/>（2）每次更新数据的时候都必须先判断版本号对不对，然后再写入新的版本号</p><p><br/><b>我们再来看一下如何基于「悲观锁」来实现：</b></p><p><br/>悲观锁也叫作排它锁，在Mysql中是基于 for update 来实现加锁的，例如：</p><p>//锁定的方法-伪代码 <br/>public boolean lock(){ <br/>    connection.setAutoCommit(false) <br/> for(){ <br/>        result = select * from user where id = 100 for update; <br/> if(result){ <br/> //结果不为空，则说明获取到了锁 <br/> return true; <br/>        } <br/> //没有获取到锁，继续获取 <br/>        sleep(1000); <br/>    } <br/> return false; <br/>} <br/> <br/>//释放锁-伪代码 <br/>connection.commit(); </p><p><br/>上面的示例中，user表中，id是主键，通过 for update 操作，数据库在查询的时候就会给这条记录加上排它锁。 <br/>（需要注意的是，在InnoDB中只有字段加了索引的，才会是行级锁，否者是表级锁，所以这个id字段要加索引）</p><p><br/>当这条记录加上排它锁之后，其它线程是无法操作这条记录的。</p><p><br/>那么，这样的话，我们就可以认为获得了排它锁的这个线程是拥有了分布式锁，然后就可以执行我们想要做的业务逻辑，当逻辑完成之后，再调用上述释放锁的语句即可。<br/></p><ol><li><b>基于Redis实现</b></li></ol><p>基于Redis实现的锁机制，主要是依赖redis自身的原子操作，例如：</p><p>SET user_key user_value NX PX 10000 </p><p><br/>redis从2.6.12版本开始，SET命令才支持这些参数： <br/>NX：只在在键不存在时，才对键进行设置操作，SET key value NX 效果等同于 SETNX key value <br/>PX millisecond：设置键的过期时间为millisecond毫秒，当超过这个时间后，设置的键会自动失效</p><p><br/>上述代码示例是指， <br/>当redis中不存在user_key这个键的时候，才会去设置一个user_key键，并且给这个键的值设置为 user_value，且这个键的存活时间为10000ms</p><p><br/>为什么这个命令可以帮我们实现锁机制呢？ </p><p><br/>因为这个命令是只有在某个key不存在的时候，才会执行成功。那么当多个进程同时并发的去设置同一个key的时候，就永远只会有一个进程成功。 <br/>当某个进程设置成功之后，就可以去执行业务逻辑了，等业务逻辑执行完毕之后，再去进行解锁。</p><p><br/>解锁很简单，只需要删除这个key就可以了，不过删除之前需要判断，这个key对应的value是当初自己设置的那个。</p><p><br/>另外，针对redis集群模式的分布式锁，可以采用redis的Redlock机制。<br/></p><ol><li><b>基于ZooKeeper实现</b></li></ol><p>其实基于ZooKeeper，就是使用它的临时有序节点来实现的分布式锁。<br/>原理就是：当某客户端要进行逻辑的加锁时，就在zookeeper上的某个指定节点的目录下，去生成一个唯一的临时有序节点， 然后判断自己是否是这些有序节点中序号最小的一个，如果是，则算是获取了锁。如果不是，则说明没有获取到锁，那么就需要在序列中找到比自己小的那个节点，并对其调用exist()方法，对其注册事件监听，当监听到这个节点被删除了，那就再去判断一次自己当初创建的节点是否变成了序列中最小的。如果是，则获取锁，如果不是，则重复上述步骤。<br/>当释放锁的时候，只需将这个临时节点删除即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9ad28ea3249b579370a40b6c96d8e481_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb\" width=\"603\" data-original=\"https://pic2.zhimg.com/v2-9ad28ea3249b579370a40b6c96d8e481_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;603&#39; height=&#39;479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"603\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"603\" data-original=\"https://pic2.zhimg.com/v2-9ad28ea3249b579370a40b6c96d8e481_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9ad28ea3249b579370a40b6c96d8e481_b.jpg\"/></figure><p><br/>（图片来自网络）</p><p><br/>如图，locker是一个持久节点，node_1/node_2/…/node_n 就是上面说的临时节点，由客户端client去创建的。 <br/>client_1/client_2/…/clien_n 都是想去获取锁的客户端。以client_1为例，它想去获取分布式锁，则需要跑到locker下面去创建临时节点（假如是node_1）创建完毕后，看一下自己的节点序号是否是locker下面最小的，如果是，则获取了锁。如果不是，则去找到比自己小的那个节点（假如是node_2），找到后，就监听node_2，直到node_2被删除，那么就开始再次判断自己的node_1是不是序列中最小的，如果是，则获取锁，如果还不是，则继续找一下一个节点。</p><p><br/>以上，就讲完了为什么我们需要分布式锁这个技术，以及分布式锁中常见的三种机制，欢迎大家一起交流。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。</p>", 
            "topic": [
                {
                    "tag": "架构师", 
                    "tagLink": "https://api.zhihu.com/topics/19557488"
                }, 
                {
                    "tag": "系统架构师", 
                    "tagLink": "https://api.zhihu.com/topics/19674278"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42609238", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "数据库的这些性能优化，你做了吗？", 
            "content": "<p>在互联网项目中，当业务规模越来越大，数据也越来越多，随之而来的就是数据库压力会越来越大。<br/>我们可能会采取各种方式去优化，比如之前文章提到的缓存方案，SQL优化等等，除了这些方式以外，这里再分享几个针对数据库优化的常规手段：「数据读写分离」与「数据库Sharding」。这两点基本上是大中型互联网项目中应用的非常普遍的方案了。<br/>下面我们来详细看一看，</p><p><b>一、从读写分离到CQRS</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-afaf4a738608d2eea26c712a45bfdc4f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"373\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"373\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-afaf4a738608d2eea26c712a45bfdc4f_b.jpg\"/></figure><p><br/>（图片来源阿里云）</p><p><br/>由于互联网业务场景，大多数是读多写少，因此进行数据库的读写分离是一件非常简单且有效率的方案。 </p><p><br/>读写分离简单点来说就是把对数据的读操作和写操作进行分开来，让这两种操作去访问不同的数据库，这样的话，就可以减轻数据库的压力了。</p><p><br/>例如上图中，数据库会有一个「主实例」，这个主要用来提供写操作的（偶尔也会承担一点读操作），除了「主实例」以外，还会有多个「从实例」（在图中显示的是 只读实例），「从实例」的功能只是用来承担读操作的。</p><p><br/>那上面就出现了多个数据库了，在多个数据库之间的数据是怎么保证一致性的呢？<br/>其实，我们常用的数据库就自带这类同步功能，比如 Mysql，它自己有一个master-slave功能，可以实现主库与从库数据的自动同步，是基于二进制日志复制来实现的。在主库进行的写操作，会形成二进制日志，然后Mysql会把这个日志异步的同步到从库上，从库再自动执行一遍这个二进制日志，那么数据就跟主库一致了。</p><p><br/>除了Mysql以外，像Oracle等商业数据库都有类似的功能，甚至是网络上还有很多开源的第三方数据同步工具，也有很多成熟好用的。</p><p><br/>好了，「主实例」与「从实例」之间的数据同步问题解决了，那现在还有一个问题就是，项目中是怎样让 写请求 去访问「主实例」，让 读请求 去访问「从实例」的，这个路由规则是怎么实现的呢？</p><p><br/>常规的有2种方式：<br/></p><ol><li><b>使用编码方式</b> <br/>这个方式主要是靠开发同学在编码的时候，根据读写不同的操作需求，去调用不同的数据源。例如在数据操作层（DAO层）将读数据与写数据分开为两个方法（函数），然后为这两个方法分别指定不同的数据库即可。 <br/>但是这种方式有点硬编码的味道了，而且对开发同学而言还得额外关注这个事情，多了一个编码成本且容易不小心忽略掉。</li><li><b>使用中间件</b> <br/>这种方式就是在后端数据库的前面，前置一个 数据库代理服务，如下图的：MySQL-Proxy 是Mysql提供的一个中间件，用于实现读写分离请求，但这个组件实际用的人不多，我们可以选择其它的一些开源的组件替代，例如：MyCat、ProxySQL 等等，但大致的原理比较类似，通过这个图很容易理解这个模式。</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3660ea3dbd764ab7efe1fad029511539_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"489\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb\" width=\"489\" data-original=\"https://pic2.zhimg.com/v2-3660ea3dbd764ab7efe1fad029511539_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;489&#39; height=&#39;501&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"489\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"489\" data-original=\"https://pic2.zhimg.com/v2-3660ea3dbd764ab7efe1fad029511539_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3660ea3dbd764ab7efe1fad029511539_b.jpg\"/></figure><p><br/>好了，基础的读写分离就讲完了，但感觉这个方式虽然实用是实用，就是不怎么有逼格。<br/>OK，想要有逼格是吧，满足你，</p><p>那我们就来聊一聊另一个有逼格的读写分离概念: 「 CQRS 」</p><p><br/><b>CQRS</b>：Command Query Responsibility Segregation <br/><b>命令（增删改）和查询的责任分离</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2c10abc48f25978148558512d50bcabf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-2c10abc48f25978148558512d50bcabf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-2c10abc48f25978148558512d50bcabf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2c10abc48f25978148558512d50bcabf_b.jpg\"/></figure><p><br/>我们还是先看图，通过上图可以简单的理解一下CQRS</p><p><br/>CQRS 重点强调的就是 Query（读） 和 Command（写）的分离，在业务上将职责分离清晰，Command 主要做业务逻辑的执行，Query来负责数据查询和展示。同时 这两种操作是基于不同的数据源，甚至是一个是数据库，另外一个是NoSQL都可以，Query去查询的数据源可以直接按照领域模型进行存储，而并不是按照数据模型去存储，这样查询出来就立即可以展示，而不用转换，且查询效率高。</p><p><br/>其实CQRS是由鼎鼎大名的 Martin Fowler 提出，搞计算机的应该都认识。想要更深入的去学习CQRS，可以翻看Martin Fowler公开的资料。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二、Sharding（分库分表）</b><br/>上面讲完了数据库的读写分离，现在我们来聊一下数据库的Sharding。</p><p><br/>随着数据库里的数据越来越大，单表查询的性能已经不能满足业务要求了，这个时候就需要进行分表处理了，将大表拆分为若干个小表，不同的分表中数据也不一样，这样可以分散查询压力，提高处理效率。</p><p><br/>然而，当表越来越多，所有的数据都在一个数据库上时，网络IO以及文件IO也都会集中在一个数据库上，可能会超过单台服务器的容量， CPU、内存、文件IO、网络IO 都会成为系统的瓶颈，QPS/TPS也会超过单数据库实例的处理极限。那么这个时候就需要对数据库进行分片处理。</p><p><br/>因为分表和分库的思路类似，因此下面统一来聊技术方案。 <br/>其实分库分表只是我们通俗的便于理解的说话，正确的描述应该是：数据分片<br/>数据的分片主要有2种模式：<br/></p><ul><li><b>垂直拆分</b></li><li><b>水平拆分</b></li></ul><p>两种拆分应用的场景是不同的：<br/></p><ol><li><b>垂直拆分</b>，是指按照业务模块进行拆分。简单来讲，就是把业务紧密的模块的字段/表放在一起，放在同一个数据库或者服务器上。将不同业务的字段/表进行独立，拆到不同的数据库或者服务器上。比如一个游戏系统中，可以将玩家基本信息与道具公会等信息进行拆分。 <br/>如图示例：</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-29406f017c2cddc15ec8785c0e5f29b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic1.zhimg.com/v2-29406f017c2cddc15ec8785c0e5f29b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic1.zhimg.com/v2-29406f017c2cddc15ec8785c0e5f29b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-29406f017c2cddc15ec8785c0e5f29b8_b.jpg\"/></figure><p><br/>（图片来源网络）<br/></p><ol><li><b>水平拆分</b>，是指纯粹的按照某种数据规则/格式进行拆分。例如 按照数据唯一ID的哈希散列拆分、按照数据的日期拆分、按照某种范围拆分等等。水平拆分需要注意的是，随着数据动态的变化，分片数量可能需要随之动态调整，另外就是水平分片是没有考虑业务特征的，因此在进行业务汇总查询或者分片中事物处理的时候就比较麻烦一些。 <br/>如图示例：</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0e5b87756c1f9f7bca6fe29fd8846906_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"1137\" data-original=\"https://pic3.zhimg.com/v2-0e5b87756c1f9f7bca6fe29fd8846906_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1137&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1137\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1137\" data-original=\"https://pic3.zhimg.com/v2-0e5b87756c1f9f7bca6fe29fd8846906_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0e5b87756c1f9f7bca6fe29fd8846906_b.jpg\"/></figure><p><br/>另外，在实际应用中，两种拆分模式一般会结合在一起使用，效果更佳。<br/>以上就是数据库性能优化之「数据读写分离」与「数据库Sharding」方法，欢迎大家一起交流。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。</p>", 
            "topic": [
                {
                    "tag": "性能优化", 
                    "tagLink": "https://api.zhihu.com/topics/19633850"
                }, 
                {
                    "tag": "数据库性能", 
                    "tagLink": "https://api.zhihu.com/topics/19554130"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42276548", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "缓存服务的更新策略有哪些？", 
            "content": "<p>在互联网项目开发中，缓存的应用是非常普遍了，缓存可以帮助页面提高加载速度，减少服务器或数据源的负载。<br/></p><h2><b>1、为什么需要缓存？</b></h2><p>一般在项目中，最消耗性能的地方就是后端服务的数据库了。而数据库的读写频率常常都是不均匀分布的，大多情况是读多写少，并且读操作（select）还会有一些复杂的判断条件，比如 like、group、join 等等，这些语法是非常消耗性能的，所有会出现很多的慢查询，因此数据库很容易在读操作的环节遇到瓶颈。</p><p>那么通过在数据库前面，前置一个缓存服务，就可以有效的吸收不均匀的请求，抵挡流量波峰。</p><p>另外，如果应用与数据源不在同一个服务器的情况下，中间还会有很多的网络消耗，也会对应用的响应速度有很大影响，如果当前应用对数据实时性的要求不那么强的话，在应用侧加上缓存就能很快速的提升效率。</p><h2><b>2、那使用缓存会遇到哪些问题呢？</b></h2><p>虽然缓存可以提高整体性能，但是它也可能会带来别的问题。例如使用缓存之后，就相当于把数据存放了2份，一份是在数据库中，另一份存放在缓存中。当有新的数据要写入或者旧数据需要更新的时候，如果我们只更新了其中一份数据源，那两边的数据就不一致了，所以这里就存在一个缓存数据与数据库数据如何进行有效且快速的同步问题，才可以保证数据的最终一致性。</p><p>另外，加上缓存服务其实也引入了系统架构的复杂度，因为还需要额外的关注缓存自身带来的下列问题：</p><ol><li>缓存的过期时间问题：<br/>设计缓存的过期时间需要非常的有技巧，且必须与业务实际情况相结合。因为如果设计的过期时间太短了，那会导致缓存效果不佳，且还会造成频繁的从数据库中往缓存里写数据。如果缓存设计的过期时间太长了，又会导致内存的浪费。</li><li>缓存的命中率问题：<br/>这也是设计缓存中需要存放哪些数据的很重要一点，如果设计的不好，可能会导致缓存命中率过低，失去缓存效果。一般对于热点数据而言，要保证命中率达到70%以上效果最佳。</li><li>缓存的穿透/雪崩问题：<br/>是指如果缓存服务一旦宕机或全部丢失，那么有可能一瞬间所有的流量都直接打到了后端数据库上，可能会造成连锁反应，瞬间的请求高峰极有可能导致数据库无法承载。</li></ol><h2><b>3、缓存的更新策略具体有哪些？</b></h2><p>典型的缓存模式，一般有如下几种：</p><ul><li><b>Cache Aside</b></li><li><b>Read/Write Through</b></li><li><b>Write Behind</b></li></ul><p>每种模式都有不同的特点，适应与不同的项目场景，下面来依次看看：</p><ol><li><b>Cache Aside 模式</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9c8dd1bbe4674296cf557d809f038a64_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"200\" class=\"content_image\" width=\"265\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;265&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"265\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"265\" data-actualsrc=\"https://pic1.zhimg.com/v2-9c8dd1bbe4674296cf557d809f038a64_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这是大家经常用到的一种策略模式。这种模式主要流程如下：</p><ul><li>应用在查询数据的时候，先从缓存Cache中读取数据，如果缓存中没有，则再从数据库中读取数据，得到数据库的数据之后，将这个数据也放到缓存Cache中。</li><li>如果应用要更新某个数据，也是先去更新数据库中的数据，更新完成之后，则通过指令让缓存Cache中的数据失效。</li></ul><p>这里为什么不让更新操作在写完数据库之后，紧接着去把缓存Cache中的数据也修改了呢？</p><p>主要是因为这样做的话，就有2个写操作的事件了，担心在并发的情况下会导致脏数据，举个例子：<br/>假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去更新数据。初始状态缓存中是没有数据的，当请求A读到数据之后，准备往回写的时候，此刻，请求B正好要更新数据，更新完了数据库之后，又去把缓存更新了，那请求A再往缓存中写的就是旧数据了，属于脏数据。</p><p>那么 Cache Aside 模式就没有脏数据问题了吗？不是的，在极端情况下也可能会产生脏数据，比如：</p><p>假如同时有2个请求，请求A和请求B，并发的执行。请求A是要去读数据，请求B是要去写数据。假如初始状态缓存中没有这个数据，那请求A发现缓存中没有数据，就会去数据库中读数据，读到了数据准备写回缓存中，就在这个时候，请求B是要去写数据的，请求B在写完数据库的数据之后，又去设置了缓存失效。这个时候，请求A由于在数据库中读到了之前的旧数据，开始往缓存中写数据了，此时写进入的就也是旧数据。那么最终就会导致，缓存中的数据与数据库的数据不一致，造成了脏数据。</p><p>不过这种概率比上面一种概率要小很多。所以整体而言  Cache Aside 模式 还是一种比较简单实用的方式。</p><ol><li><b>Read/Write Through 模式</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0b75a05b916606c89142b00695104f35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"199\" data-rawheight=\"244\" class=\"content_image\" width=\"199\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;199&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"199\" data-rawheight=\"244\" class=\"content_image lazy\" width=\"199\" data-actualsrc=\"https://pic2.zhimg.com/v2-0b75a05b916606c89142b00695104f35_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这个模式其实就是将 缓存服务 作为主要的存储，应用的所有读写请求都是直接与缓存服务打交道，而不管最后端的数据库了，数据库的数据由缓存服务来维护和更新。不过缓存中数据变更的时候是同步去更新数据库的，在应用的眼中只有缓存服务。</p><p>流程就相当简单了：</p><ul><li>应用要读数据和更新数据都直接访问缓存服务</li><li>缓存服务同步的将数据更新到数据库</li></ul><p>这个模式出现脏数据的概率就比较低，但是就强依赖缓存了，对缓存服务的稳定性有较大要求，另外，增加新缓存节点时还会有初始状态空数据问题。</p><ol><li><b>Write Behind 模式</b></li></ol><p>这个模式就是 Read/Write Through 模式 的一个变种。区别就是 Read/Write Through 模式的缓存写数据库的时候是同步的，而 Write Behind 模式 的缓存操作数据库是异步的。</p><p>流程如下：</p><ul><li>应用要读数据和更新数据都直接访问缓存服务</li><li>缓存服务异步的将数据更新到数据库（通过异步任务）</li></ul><p>这个模式的特点就是速度很快，效率会非常高，但是数据的一致性比较差，还可能会有数据的丢失情况，实现逻辑也较为复杂。</p><p>以上就是目前三种主流的缓存更新策略，另外还有Refrsh-Ahead模式等由于使用的不是很常见就不详细介绍了。</p><p>缓存是互联网项目中非常普遍的一个提高效率的方案，用法比较多，也比较关键，大家可以一起交流。</p><blockquote>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流互联网认知、项目管理、大数据、Web、区块链技术。</blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "memcached缓存", 
                    "tagLink": "https://api.zhihu.com/topics/20036728"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42036437", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "揭秘区块链的核心技术之「哈希与加密算法 」", 
            "content": "<p>大家都知道，区块链的关键技术组成主要为：P2P网络协议、共识机制、密码学技术、账户与存储模型。而这些技术中，又以 密码学与共识机制 这两点为最核心。那么今天我们来详细的聊一聊密码学，看一看密码学技术是如何在区块链中应用的。</p><p><br/>首先，我们需知道区块链中用到的密码学算法有哪些？其实就两大类：<br/></p><ul><li>哈希算法</li><li>非对称加密算法</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一、区块链中的哈希算法</b><br/>哈希算法是区块链中用的最多的一种算法，它被广泛的使用在构建区块和确认交易的完整性上。<br/>它是一类数学函数算法，又被称为散列算法，需具备三个基本特性：<br/></p><ol><li>其输入可为任意大小的字符串</li><li>它产生固定大小的输出</li><li>它能进行有效计算，也就是能在合理的时间内就能算出输出值</li></ol><p>如果要求哈希算法达到密码学安全的话，我们还要求它具备以下三个附加特性：<br/></p><ol><li>碰撞阻力： <br/>是指对于两个不同的输入，必须产生两个不同的输出。如果对于两个不同的输入产生了相同的输出，那么就说明不具备碰撞阻力，或是弱碰撞阻力。</li><li>隐秘性： <br/>也被称为不可逆性，是指 y = HASH（x）中，通过输入值x，可以计算出输出值y，但是无法通过y值去反推计算出x值。为了保证不可逆，就得让x的取值来自一个非常广泛的集合，使之很难通过计算反推出x值。</li><li>谜题友好： <br/>这个特性可以理解为，谜题是公平友好的，例如算法中 y = HASH（x），如果已知y值，想去得到x值，那就必须暴力枚举，不断的尝试才能做到，并且没有比这更好的办法，没有捷径。</li></ol><p>哈希算法有很多，比特币主要使用的哈希算法是 SHA-256 算法。<br/>除此之外，还有其他一些哈希算法也很流行，例如 MD5、SHA-1、SHA-2（SHA-224、SHA-256、SHA-384、SHA-512）、SHA-3 等，其中 MD5、SHA-1 已被证明了不具备 强碰撞阻力，安全性不够高，因此市场上不再推荐使用。</p><p><br/>我们以比特币为例，来看一下哈希算法的具体应用： <br/>在比特币中，使用哈希算法把交易生成数据摘要，当前区块里面包含上一个区块的哈希值，后面一个区块又包含当前区块的哈希值，就这样一个接一个的连接起来，形成一个哈希指针链表，如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b54961586762c1ce1c6b5f12fdccc8f1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"757\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb\" width=\"757\" data-original=\"https://pic2.zhimg.com/v2-b54961586762c1ce1c6b5f12fdccc8f1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;757&#39; height=&#39;304&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"757\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"757\" data-original=\"https://pic2.zhimg.com/v2-b54961586762c1ce1c6b5f12fdccc8f1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b54961586762c1ce1c6b5f12fdccc8f1_b.jpg\"/></figure><p><br/>上面只是示意图，那么在实际比特币系统中，每个区块包含哪些内容呢：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c4cf4b4e840b3940d38236743a392513_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb\" width=\"590\" data-original=\"https://pic4.zhimg.com/v2-c4cf4b4e840b3940d38236743a392513_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;590&#39; height=&#39;323&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"590\" data-original=\"https://pic4.zhimg.com/v2-c4cf4b4e840b3940d38236743a392513_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c4cf4b4e840b3940d38236743a392513_b.jpg\"/></figure><p><br/>重点关注一下上图中的：<br/></p><ul><li>Prev Block：记录签一个区块的hash地址，32字节</li><li>Merkle Root：是一个记录当前块内的所有交易信息的数据摘要hash值，32字节</li><li>Nonce：一个随机值，需要通过这个随机值去找到满足某个条件的hash值（挖矿），4字节</li></ul><p>上面只是解释了几个重点的字段，其它字段通过字面应该容易理解就不一一解释了。 <br/>这所有的字段一起就组成了 block header（区块头），然后需要对 block header 进行2次hash计算，计算完成的值就是当前比特币区块的hash值。因为比特币系统要求计算出来的这个hash值满足一定的条件（小于某个数值），因此需要我们不断的遍历Nonce值去计算新的hash值以满足要求，只有找到了满足要求的hash值，那么这就是一个合法区块了（这一系列动作也叫作挖矿）</p><p>示例： <br/>SHA-256(SHA-256 (Block Header) </p><p><br/>我们再看一下上面的另一个重要字段： Merkle tree 字段。 <br/>Merkle tree 被称为 默克尔树，它也是哈希算法的一个重要应用。 <br/>它其实是一个用哈希指针建立的二叉树或多叉树。</p><p><br/>Merkle tree 如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cb86f2b155b7b79b0b8dd02d6f554200_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"785\" data-original=\"https://pic1.zhimg.com/v2-cb86f2b155b7b79b0b8dd02d6f554200_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;785&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"785\" data-original=\"https://pic1.zhimg.com/v2-cb86f2b155b7b79b0b8dd02d6f554200_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cb86f2b155b7b79b0b8dd02d6f554200_b.jpg\"/></figure><p><br/>其树的顶端叫做 默克尔根（Merkle Root），Merkle Root 也是一个hash值，它是怎么计算出来的呢？</p><p><br/>比特币中对每一笔交易做一个hash计算，然后把每2个交易的hash再进行合并做hash，如图中的 交易A的hash值是 H（A），交易B的hash值是H（B），再对这2个交易合并hash后就是H（hA|hb），就这样一直往上合并计算，算到最后的根部就是 Merkle Root 了。<br/>在比特币和以太坊中都是使用的默克尔树结构，但是以太坊为了实现更多复杂的功能，所以有三个默克尔树。</p><p><br/>至此，区块链中的哈希算法应用就介绍完了，接下来我们看一下非对称加密算法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二、区块链中的非对称加密算法</b></p><p><br/>区块链中有一个很关键的点就是账户问题，但比特币中是没有账户概念的，那大家是怎么进行转账交易的呢？</p><p><br/>这里就得先介绍区块链中的非对称加密技术了。<br/>非对称加密技术有很多种，如：RSA、ECC、ECDSA 等，比特币中是使用的 ECDSA 算法。 <br/>ECDSA 是美国政府的标准，是利用了椭圆曲线的升级版，这个算法经过了数年的细致密码分析，被广泛认为是安全可靠的。</p><p><br/>所谓非对称加密是指我们在对数据进行加密和解密的时候，需使用2个不同的密钥。比如，我们可以用A密钥将数据进行加密，然后用B密钥来解密，相反，也可以用B来加密，然后使用A来解密。那么如果我想给某个人传递信息，那我可以先用A加密后，将密文传给她，她拿到密文之后，用手上的B密钥去解开。这2个密钥，一个被成为公钥、一个是私钥。</p><p><br/>在比特币中，每个用户都有一对密钥（公钥和私钥），比特币系统中是使用用户的公钥作为交易账户的。 <br/>我们先看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-456810e8d8038bea6585c3ebb114939f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-456810e8d8038bea6585c3ebb114939f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;616&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-456810e8d8038bea6585c3ebb114939f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-456810e8d8038bea6585c3ebb114939f_b.jpg\"/></figure><p><br/>在图中可以看到，在第一笔交易记录中，是 用户U0 来发起的交易，要将代币支付给 用户U1，是怎么实现的呢？<br/></p><ol><li>首先 用户U0 写好交易信息：data（明文，例如：用户U0转账100元给用户U1）</li><li>用户U0 使用哈希算法将交易信息进行计算，得出 H = hash（data），然后再使用自己的私钥对 H 进行签名，即 S(H)，这一步其实是为了防止交易信息被篡改用的</li><li>然后基于区块链网络，将 签名S(H) 和 交易信息data 传递给 用户U1</li><li>用户U1 使用 用户U0 的公钥 来对 S(H) 解密，就得到了交易信息的哈希值 H</li><li>同时，用户U1 还使用哈希算法对 交易信息data 进行计算，得出 H2 = hash（data）</li><li>对比上面2个哈希值，如果 H1==H2，则交易合法。说明 用户U0 在发起交易的时候确实拥有真实的私钥，有权发起自己账户的交易</li><li>网络中每一个节点都可以参与上述的验证步骤。</li></ol><p>这个示例，就是比特币中一次交易的签名流程，即将 哈希算法与非对称算法结合在一起用于了比特币交易的数字签名。 </p><p><br/>除此之外，比特币中，公私钥的生成、比特币地址的生成也是由非对称加密算法来保证的。<br/>以上，就是区块链体系中，核心技术之哈希算法与加密算法的应用情况，欢迎一起交流。</p><p><br/>本文原创发布于微信公众号「 不止思考 」，欢迎关注，交流 互联网认知、工作管理、大数据、Web、区块链技术。</p>", 
            "topic": [
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "加密算法", 
                    "tagLink": "https://api.zhihu.com/topics/19746975"
                }, 
                {
                    "tag": "加密", 
                    "tagLink": "https://api.zhihu.com/topics/19569234"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/41457863", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "从拜占庭将军问题看：区块链「 共识算法 」", 
            "content": "<p>假如你是古代某个国家的将军，你们国家除了你以外，还有另外9个将军，每个将军带领着一支军队，总共10支军队，这10支军队在地域上分散驻扎。你们国家想要进攻一个强大的敌国，这个敌国也有一定的实力，足以抵御你们5支军队的同时袭击。因此你们10支军队必须要成一致意见，起码要大部分军队达成一致，才可顺利的消灭掉这个敌国。</p><p>而由于地域上特殊原因，你们这10支军队不能集合在一起单点进攻，必须在分开的状态下同时包围攻击敌国。如果是单支军队单独进攻的话是毫无胜算的，除非有至少有6支军队同时调遣一起袭击才能攻下敌国。你们分散在敌国的四周，依靠通信兵相互通信来协商进攻意向和进攻时间。</p><p>此时困扰着你们10个将军的问题是，你们没有一个中心领导，10名将军都是平等的，且你们当中可能会有叛徒，叛徒可能擅自变更进攻意向或者进攻时间，甚至是传递假的进攻消息，在这种状态下，你们10名将军们能否找到一种分布式的协作方式，来让你们能够远程、准确无误的协商，从而赢取战斗呢？</p><p>这就是著名的「拜占庭将军问题」。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff31a54d3982cfd79aa44d1d9d31bfea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"519\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-ff31a54d3982cfd79aa44d1d9d31bfea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;519&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"519\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-ff31a54d3982cfd79aa44d1d9d31bfea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff31a54d3982cfd79aa44d1d9d31bfea_b.jpg\"/></figure><p><b>拜占庭将军问题就是要解决去中心化的共识机制问题，而这个共识问题也是比特币中区块链网络所需要解决的。</b></p><p>因为拜占庭将军们是分散的，没有一个中心的领导机构，因此他们在进攻敌方的时候必须事先对进攻地点和时间进行协商，达成共识。那么在有限的时间内，要解决提案（进攻方案）的一致性且获取大部分将军的认可，才能解决拜占庭将军问题。</p><p>在区块链网络中也是类似情况。</p><p>区块链的分布式网络中可能会有多个人提出打包区块的请求，并且其中还有可能是有伪造的区块，那么只能靠分布式共识算法来解决这个问题了。</p><p>我们知道区块链的核心价值之一就是共识，这也是大家一直所追捧区块链的特性之一。那今天我们就来重点来聊一聊区块链是怎样通过「共识机制」来解决上述问题的。</p><p>其实共识机制的概念并非是由区块链兴起才有的，它早在数学领域就是长期以来在研究和攻克的方向，尤其是在计算机领域针对分布式共识机制也已经有了一些知名的解决方案，取得了非常卓越的成就。</p><p>区块链算是一个将「共识机制」充分应用的一个场景。</p><h2><b>一、什么是共识算法？</b></h2><p>共识算法 顾名思义，就是通过算法手段让各参与方对某个确定的结果达成一致的方案。<br/>在区块链里，就是指在不可靠的网络环境里，在不可信的各参与方中，寻找一个传递和验证信息的可靠策略。</p><p>不过，这里的可靠也是相对而言的，非法节点必须控制在一定的比例之内才能保证可靠性。<br/>共识算法有很多种，目前比特币所采用的是：工作量证明的共识机制。</p><h2><b>二、区块链为什么需要共识算法？</b></h2><p>拿比特币举例，在比特币的区块链网络中，因为是去中心化的，每个节点都是平等的，每个节点都会有一个账本、都可以记账，那最终就会产生很多个不同的账本。</p><p>但事实上我们是需要所有人都掌握同样一个账本，才能保证系统数据的一致性，系统才能有效运行。</p><p>那如何保证在一段时间内只有允许一个节点去生成合法账本、保证大家的账本是一致的（起码大部分人的账本是一致的），如何验证合法的账本、鉴别非法账本呢？</p><p>这些问题是在去中心化的区块链网络中必须要解决的，不然谁都可以随意篡改账本内容，然后说自己的账本才是合法的，这样的话，比特币系统就乱套了。</p><p>比特币是怎么解决这个问题的呢，它采用的是PoW（Proof of Work）的共识算法。这个算法不仅可以保证在一段时间内网络中出现的提案（提出记账请求）的个数是有限的，同时也放弃了强一致性的要求，改为最终一致性要求（即允许链中同一时刻有多个合法区块，出现链路分叉，但最后会以工作量最大的那个链路，也就是最长的那条链为最终的合法链）</p><p>除了比特币，其它一些代币的区块链网络都是使用什么样的共识算法呢？</p><h2><b>三、共识算法有哪些？</b></h2><p>共识算法比较多，有 PBFT（Practical Byzantine Fault Tolerance，实用拜占庭容错算法）、PoW（Proof of Work，工作量证明）、PoS（Proof of Stake，权益证明）、DPoS（Delegate Proof of Stake，委托权益证明）、Ripple（瑞波），还有 分布式一致性算法（Pasox、Raft） 等等，每种算法的玩法都不一样。</p><p>这里重点来介绍一下区块链中常用的几种：</p><ol><li><b>PoW （Proof of Work，工作量证明）</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-326a8fe0576c537efb2e65026208bd82_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb\" width=\"456\" data-original=\"https://pic3.zhimg.com/v2-326a8fe0576c537efb2e65026208bd82_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;456&#39; height=&#39;326&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"456\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"456\" data-original=\"https://pic3.zhimg.com/v2-326a8fe0576c537efb2e65026208bd82_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-326a8fe0576c537efb2e65026208bd82_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>比特币和以太坊都是基于这种算法来实现的。简单来说，PoW 就是一份确认工作端做过一定量工作的证明。PoW 系统的主要特征是计算的不对称性，工作端需要做一定难度的工作才能得出一个结果，而验证方却很容易通过结果来检查工作端是不是做了相应的工作，哈哈，这就是俗话说的 完成工作很辛苦，检查工作很容易。</p><p>在比特币系统中，大约每10分钟就开始一轮算力的竞争工作，大家将特定的字符串+随机nonce数进行SHA256运算，期望得到一个符合系统预期的值，如果算出来的结果不满足预期，则不断的调整nonce值，重新计算，一直到满足预期值为止，所以要找到预期值还是比较难的，而且没有捷径可走，必须要不停的尝试nonce值，会消耗巨大的计算量，这也就是所谓的挖矿（这里为方便理解对工作原理介绍的比较粗略，更为具体的我会在另外一篇讲区块链哈希算法的文章中介绍）。</p><p>如果某一个节点运气好，计算的结果恰好满足预期值，那么这个节点就需要告诉全网的其它节点，让其它节点来验证它的工作是否正确，别人验证起来运算量是非常简单的，所以说PoW是一种计算力不对称性的算法。如果其它节点经过快速验证没有问题，那么这个运气好的节点就拥有了记账权，可以将自己刚才打包的区块放到区块链里。</p><p>PoW的特点是：</p><ul><li>完全去中心化，节点自由进出</li><li>只要网络中非法节点的算力不超过50%，那么这种验证方法就是可靠的</li><li>造成大量的计算资源的浪费（因为这种寻找随机数的挖矿行为消耗GPU等算力但不产生价值）</li></ul><p>所以PoW的优点和缺点都挺明显的，尤其是算力空耗的问题在比特币上经常被人诟病，因此以太坊的规划目标是变更为PoS算法。</p><ol><li><b>PoS  （Proof of Stake，权益证明）</b><br/><br/></li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fc0661d7205beed8617644e8c50c940e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"426\" data-original=\"https://pic3.zhimg.com/v2-fc0661d7205beed8617644e8c50c940e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;426&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"426\" data-original=\"https://pic3.zhimg.com/v2-fc0661d7205beed8617644e8c50c940e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fc0661d7205beed8617644e8c50c940e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>PoS算法解决了PoW的算力空耗的问题。POS叫权益证明，也可以称为股权证明，它其实是一种要求各节点提供拥有一定数量虚拟币证明的方式来竞争区块链记账权的共识机制。</p><p>在PoS模式下，记账权不再像PoW那样由谁的算力大谁就有更高的概率来记账，而是由谁的代币多，谁就越有可能获得记账权。可以想象一下， PoW类似于多劳多得，PoS类似于有钱人多得。</p><p>单纯靠代币多少来分配记账权，很有可能会导致记账权的中心化，所以有些代币系统在记账权的竞争中，除了计算谁的代币多以外，还会计算持有代币的时间长短，例如点点币。</p><p>虽然PoS很明显的解决了算力空耗的问题，且缩短了共识的达成时间。但PoS算法也可能会导致一些新的问题，比如，由于马太效应，系统的决策权和收益会越来越集中到少数人手中，失去公正。另外，在PoS系统上容易受到「分叉攻击」导致「双重支付」等问题。</p><p>因此POS算法也有了各种变化和升级，比如DPos算法。</p><ol><li><b>DPoS （Delegate Proof of Stake，委托权益证明）</b></li></ol><p>DPos算法称为 委托权益证明或股权委托证明。它相比较于PoW与PoS，更进一步的提高了区块链的效率。</p><p>DPoS机制不需要网络中的所有节点都参与区块的创建和校验，它会不定期的选出一小群节点，让这小群节点去做区块链的创建和校验，这样对整个网络的资源消耗进一步减少了，也提高了区块链的工作效率，例如EOS。</p><p>但这一小群节点是怎么定出来的呢？其实是由大家投票选出来的，在DPoS系统下，每个token都是一个选票，充分利用了持股人的投票，以公平的方式达成共识，大家选出N个见证人（也就是N个矿池），这N个见证人权力平等，只有见证人才可以生成和管理区块。另外，持股人可以随时通过投票来更换这些见证人。</p><p>还有一些其它共识算法就不在这里一一展开了。在区块链中，由于每个项目的场景不同，所以设计的架构和采用的共识算法都不尽相同。主要还是从 去中心化、安全、性能 三要素中根据不同的应用场景，进行不同的组合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>本文原创发布于微信公众号「 bzsikao 」，欢迎关注，交流更多的 互联网认知、工作管理、大数据、Web、区块链技术。</p>", 
            "topic": [
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "共识机制", 
                    "tagLink": "https://api.zhihu.com/topics/20138565"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/40982579", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 6, 
            "title": "架构设计之「服务限流」", 
            "content": "<p>上一篇我们聊过了架构设计中的「服务隔离」模式，今天我们继续来探索一下在分布式系统架构中的另一个常用的设计：服务限流。<br/>那么，什么是「服务限流」呢？ <br/>在解释「服务限流」之前，我们来看一下前些时间网上很火的一个段子，说的是新浪微博的一名工程师正在家里办婚礼，突然接到公司的电话要紧急处理线上流量激增的问题，那天应该是某当红明星突然在微博上公布恋情，微博流量突增好几倍，导致系统功能出现不稳定，用户访问不畅。然后这名工程师就只好晾开新娘，在婚礼现场穿着西装打开笔记本调试代码了。<br/>当时这名工程师内心肯定是崩溃的，肯定在想：为啥要在今天公布恋情！等我把系统的扩容和服务限流机制做好先啊。<br/>哈哈，看完了段子，基本上服务限流的作用也就明白： <br/>服务限流其实是指当系统资源不够，不足以应对大量请求，即系统资源与访问量出现矛盾的时候，我们为了保证有限的资源能够正常服务，因此对系统按照预设的规则进行流量限制或功能限制的一种方法。</p><p><b>一、为什么要做服务限流设计？</b><br/>再举一个我们生活中的例子：一些热门的旅游景点，往往会对每日的旅游参观人数有严格的限制，比如厦门的鼓浪屿、北京的故宫等，每天只会卖出固定数目的门票，如果你去的晚了，可能当天的票就已经卖完了，当天就无法进去游玩了。<br/>为什么旅游景点要做这样的限制呢？多卖一些门票多赚一些钱岂不是更好？<br/>其实对于旅游景点而言，她们也很无奈，因为景点的服务资源有限嘛，每日能服务的人数是有限的，一旦放开限制了，景点的工作人员就会不够用，卫生情况也得不到保障，安全也有隐患，超密集的人群也会严重的影响游客的体验。 <br/>但由于景区名气大，来游玩的旅客络绎不绝，远超出了景区的承载能力，因此景区只好做出限制每日人员流量的举措。<br/>同理，在IT软件行业中，系统服务也是这样的。<br/>如果你的系统理论是时间单位内可服务100W用户，但是今天却突然来了300W用户，由于用户流量的随机性，如果不加以限流，很有可能这300W用户一下子就压垮了系统，导致所有人都得不到服务。<br/>因此为了保证系统至少还能为100W用户提供正常服务，我们需要对系统进行限流设计。<br/>有的人可能会想，既然会有300W用户来访问，那为啥系统不干脆设计成能足以支撑这么大量用户的集群呢？<br/>这是个好问题。如果系统是长期有300W的用户来访问，肯定是要做上述升级的，但是常常面临的情况是，系统的日常访问量就是100W，只不过偶尔有一些不可预知的特定原因导致的短时间的流量激增，这个时候，公司往往出于节约成本的考虑，不会为了一个不常见的尖峰来把我们的系统扩容到最大的尺寸。</p><p><b>二、服务限流应该怎么做？</b><br/>对系统服务进行限流，一般有如下几个模式：<br/></p><ol><li><b>熔断</b>： <br/>这个模式是需要系统在设计之初，就要把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。</li><li><b>服务降级</b>： <br/>将系统的所有功能服务进行一个分级，当系统出现问题，需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。 <br/>例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单/补偿处理。 <br/>除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。</li><li><b>延迟处理</b>： <br/>这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。</li><li><b>特权处理</b>： <br/>这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。</li></ol><p>那在实际项目中，对访问流量的限制，可采用如下几种技术方法：<br/></p><ul><li><b>熔断技术</b> <br/>熔断的技术可以重点参考Netflix的开源组件hystrix的做法，主要有三个模块：熔断请求判断算法、熔断恢复机制、熔断报警。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-acd5065dc2d1eca9ee540da46f648235_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-acd5065dc2d1eca9ee540da46f648235_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;557&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"557\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"557\" data-original=\"https://pic2.zhimg.com/v2-acd5065dc2d1eca9ee540da46f648235_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-acd5065dc2d1eca9ee540da46f648235_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>计数器方法</b> <br/>系统维护一个计数器，来一个请求就加1，请求处理完成就减1，当计数器大于指定的阈值，就拒绝新的请求。 <br/>基于这个简单的方法，可以再延伸出一些高级功能，比如阈值可以不是固定值，是动态调整的。另外，还可以有多组计数器分别管理不同的服务，以保证互不影响等。</li><li><b>队列方法</b> <br/>就是基于FIFO队列，所有请求都进入队列，后端程序从队列中取出待处理的请求依次处理。 <br/>基于队列的方法，也可以延伸出更多的玩法来，比如可以设置多个队列以配置不同的优先级。</li><li><b>令牌桶方法</b> <br/>首先还是要基于一个队列，请求放到队列里面。但除了队列以外，还要设置一个令牌桶，另外有一个脚本以持续恒定的速度往令牌桶里面放令牌，后端处理程序每处理一个请求就必须从桶里拿出一个令牌，如果令牌拿完了，那就不能处理请求了。我们可以控制脚本放令牌的速度来达到控制后端处理的速度，以实现动态流控。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>三、服务限流的注意事项</b><br/>我们在做服务限流的时候，还是有一些原则和事项需要注意的：<br/></p><ul><li>实时监控：系统必须要做好全链路的实时监控，才能保证限流的及时检测和处理。</li><li>手动开关：除系统自动限流以外，还需要有能手动控制的开关，以保证随时都可以人工介入。</li><li>限流的性能：限流的功能理论上是会在一定程度影响到业务正常性能的，因此需要做到限流的性能优化和控制。</li></ul><p>系统故障常常都是不可预测且难以避免的，因此作为系统设计师的我们，必须要提前预设各种措施，以应对随时可能的系统风险。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 bzsikao 」，更多内容欢迎关注交流，互联网认知、工作管理、大数据、Web、区块链技术。</blockquote><p></p><p></p>", 
            "topic": [
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }, 
                {
                    "tag": "云服务", 
                    "tagLink": "https://api.zhihu.com/topics/19563010"
                }
            ], 
            "comments": [
                {
                    "userName": "吴乎", 
                    "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                    "content": "<p>求加更此系列</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>哈哈，没有问题，我找时间再写写架构设计方向的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "吴乎"
                        }
                    ]
                }, 
                {
                    "userName": "王丹", 
                    "userLink": "https://www.zhihu.com/people/56c31f8717bfbf5ac8fa808bc394d78c", 
                    "content": "<p>为啥感觉逻辑层次不够清晰，限流是限流，降级是降级，限流和降级以及缓存是我们保护服务的常用措施，熔断算是降级范畴里的，不应该把熔断和降级放在限流里面讲吧</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/40475855", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "架构设计之「服务隔离」", 
            "content": "<p>我们在做系统架构设计的时候，经常离不开的一个话题就是进行服务的隔离设计。</p><p>那什么是「服务隔离」呢？<br/>顾名思义，它是指将系统按照一定的原则划分为若干个服务模块，各个模块之间相对独立，无强依赖。当有故障发生时，能将问题和影响隔离在某个模块内部，而不扩散风险，不波及其它模块，不影响整体的系统服务。</p><p>其实隔离设计并非软件行业独创，它是借鉴于造船行业。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0511ab9c140566db0d349a108b4952fa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-0511ab9c140566db0d349a108b4952fa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-0511ab9c140566db0d349a108b4952fa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0511ab9c140566db0d349a108b4952fa_b.jpg\"/></figure><p>如上图，造船行业有一个专业术语叫做「舱壁隔离」。利用舱壁将不同的船舱隔离起来，如果某一个船舱进了水，那么就可以立即封闭舱门，形成舱壁隔离，只损失那一个船舱，其他船舱不受影响，整个船只还是可以正常航行。</p><h2><b>一、为什么要做服务隔离设计呢？</b> </h2><p>我们在做系统设计的时候，必须有一个清楚的认知是：任何软件系统，故障是不可避免的，并且大多数还是不可预测的，因此，我们只能在系统的设计之初就充分的考虑好应对措施，如何在故障发生时，去尽最大可能的止损和减少故障范围。</p><p>没有人敢说他的系统是百分百可用，我们能做的就是，使用一切方法去减少故障的影响面，尽可能的去提高系统的整体可用率。</p><p>而把系统分离成子服务，将子服务进行一定程度隔离的做法，能保证在有不可预测的故障发生时，缩小故障范围的最佳手段。</p><h2><b>二、服务隔离应该怎么做？</b> </h2><p>那在实际项目中，一般通过什么方法去做服务隔离呢？主要有以下两种：</p><ul><li>按服务/功能做隔离</li><li>按用户分类隔离</li></ul><p>首先说一下<b>按照服务进行隔离</b>的做法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-daeca7fb428c7a94715189ea917d80e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"494\" data-original=\"https://pic1.zhimg.com/v2-daeca7fb428c7a94715189ea917d80e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;494&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"494\" data-original=\"https://pic1.zhimg.com/v2-daeca7fb428c7a94715189ea917d80e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-daeca7fb428c7a94715189ea917d80e4_b.jpg\"/></figure><p>网上找了一张图，虽然原图的作用不是用来表述这个的，但是也类似，将就看吧。</p><p>比如上图里面，微博项目可以把 Feed信息流、用户系统、评论系统 都分拆为独立业务模块，这些模块无论是对外的接口应用、还是到数据库、到底层硬件资源都是完全隔离的。其中任何一个模块的故障，理论上都不会影响到其它模块。</p><p>再举个例子，如果我们要设计个电商平台，可以将其中的 用户系统、订单系统、支付系统、仓储系统 都分别进行独立隔离，这样做就是从服务层面实现了故障的隔离效果。</p><p>那按照服务隔离有没有弊端呢？有，肯定有。</p><ol><li>当我们某个功能操作需要关联多个服务模块或者同时查询所个模块数据的时候，代码写起来就会相对麻烦一些了，其中涉及到多模块调用的性能问题、数据一致性问题、事物问题等。</li><li>不同服务模块之间的交互也会比较复杂一些，因为要做服务隔离，避免服务强依赖，所以模块之间的交互调用最好是走异步模式，需要通过异步线程或消息中间件来传递实现。</li><li>在进行运营大数据分析的时候，由于数据是散落在不同服务模块的，因此需要做额外的汇聚操作，还得有唯一字段保证数据在不同模块产生的先后顺序。</li></ol><p>接下来说一下<b>按用户隔离</b>的做法。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ef6434c7459b78c0367b3f309e3d0f0a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-ef6434c7459b78c0367b3f309e3d0f0a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;579&#39; height=&#39;328&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"579\" data-rawheight=\"328\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"579\" data-original=\"https://pic3.zhimg.com/v2-ef6434c7459b78c0367b3f309e3d0f0a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ef6434c7459b78c0367b3f309e3d0f0a_b.jpg\"/></figure><p>继续网上找图，虽然原图的作用不是用来表述这个的，但是也类似。粉丝又不多，我又懒得画图，将就看吧，多发挥一下想象力，哈哈。</p><p>简单一句话解释就是：我们先部署多套一模一样的业务服务，然后将用户根据一定的特征去做分类，让不同分类的用户去访问不同的业务实例，达到分流和隔离的效果。</p><p>怎么给用户分类？<br/>可以用按照用户是否VIP、用户等级、用户IP等等，方法很多，要结合自己实际业务的特性来做。</p><p>其实这也是一种「多租户架构」，在SaaS服务中用得比较多。<br/>多租户模式有三种形式：</p><ol><li>完全的隔离，即服务和数据都是完全独立的。</li><li>公共服务、独立数据源，即多个租户是用的同一台服务程序，但是底层的数据源是独立的。</li><li>公用服务、公用数据源，即多个租户的服务程序与数据库源都是共享的，不同数据可能会做分区分表来独立。</li></ol><p>上述三种方式，从下到上，独立性和安全性越来越高，资源利用率越来越低，根据业务特性去选择，一般选择折中方案。</p><p>另外，功能隔离和用户隔离 两种方式并非互斥的，是可以结合在一起使用的。</p><h2><b>三、服务隔离的注意事项</b> </h2><p>我们在做服务隔离的时候，还是有一些原则和事项需要注意的：</p><ol><li>不可越界：能在隔离模块内完成的逻辑，就尽量不要跨模块调用，减少依赖。</li><li>不可共享：数据和资源能独享的就尽量不要共享，不然很容易造成隔离失效。</li><li>考虑效率：设计隔离模块的时候，要根据业务情况而定，充分的考虑到未来的拓补结构，减少调用效率的损失。</li><li>考虑颗粒度：隔离模块设计的大小问题，过大和过小都不合适，需充分考虑。</li><li>服务的全面监控：既然服务或用户进行隔离了，那么系统的复杂度肯定是比之前要高了，那么针对多服务的全链路监控是必不可少的。</li></ol><p>服务隔离的设计模式能降低依赖服务对整个系统的影响，保护有限的资源不被耗尽，提高了整个系统的可用性。本文参考了很多其它资料，属于抛砖引玉，希望大家能一起交流，提出更好的架构设计思路。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote> 欢迎小伙们关注微信公众号：「 bzsikao 」一起交流更多的互联网技术、管理、认知。</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "系统架构", 
                    "tagLink": "https://api.zhihu.com/topics/19578413"
                }, 
                {
                    "tag": "软件架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556273"
                }
            ], 
            "comments": [
                {
                    "userName": "krole", 
                    "userLink": "https://www.zhihu.com/people/678de180ea5cf3052c33ec9afd68d845", 
                    "content": "问一下，这和微服务架构有什么区别。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>类似。这本身只是一种架构模式，微服务也是具有服务隔离特性的一种架构，同时微服务还具有其它更多的特性。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "krole"
                        }
                    ]
                }, 
                {
                    "userName": "吴乎", 
                    "userLink": "https://www.zhihu.com/people/d6d65544eb89fbbd4c5fd8d128d1c1fc", 
                    "content": "<p>图文并茂，条理清晰，赞！</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>感谢</p>", 
                            "likes": 0, 
                            "replyToAuthor": "吴乎"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/40134922", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 5, 
            "title": "技术负责人所需的这四个核心能力，你具备几个？", 
            "content": "<p>「技术负责人」这一称呼其实比较泛了。往大了讲，可以指 CTO、技术VP、技术总监，往小了讲，可以指 小组Leader、技术主管、架构师 等。</p><p>这些不同岗位的「技术负责人」在工作中会处理着各不相同的问题，因此对他能力要求的侧重点肯定也是不同的。</p><p>比如，CTO/技术VP 是需要有全面的综合能力，具有公司战略、研发体系搭建、人才策略的能力；而 技术主管 则更偏向于技术架构、带领团队、技术落地的能力。</p><p>不仅如此，甚至就算是同一个角色/岗位，在公司发展的不同阶段，也需要侧重不同的能力。</p><p>以技术经理为例，如果是在公司刚起步的创业阶段，需要具备极强的带领团队去披荆斩棘、冲锋陷阵的能力，能使产品快速的落地，需亲自带人培养团队，支撑业务的增长。而如果公司到了一个业务稳定时期，此时的技术经理，需具备研发文化搭建能力、团队管理能力、规范构造能力。</p><p>好了，既然各类「技术负责人」在处于不同的角色、不同的时期，所需要的能力有而不尽相同，<br/>那么，到底什么才是衡量「技术负责人」核心能力的标准呢？</p><p>那就需要我们从中去找出一些共同点的地方，这些 共性 的东西，就是作为一名优秀的技术负责人自始至终所应具备的核心能力。</p><p>我认为它主要包括4点：技术视野、商业洞察力、自我进化力 以及 团队力，下面一一分别阐述：</p><h2><b>一、具备良好技术视野，能洞察技术行业趋势</b> </h2><p>需要「技术负责人」有丰富的经验和技术沉淀，具有优秀的架构设计能力，虽然不要求对各类技术都精通，但是必须有自己专精深入的方向，且对其它技术领域都有涉猎。能够知道在什么场景、什么阶段应用哪些技术。具备一定的技术前瞻性，清楚的知道团队应该做哪些技术的储备和预研。</p><p>能够用清晰易懂、普通人都能理解的语言/话术，把技术给讲清楚。这一点非常重要，我觉得技术人员与技术主管的很重要的一个区别就在这里，技术人很容易沉浸在自己的技术世界里，沟通起来一嘴儿的专业术语，导致产品同学、运营同学以及其他合作的同学很难理解他想表达的技术和逻辑，就会带来沟通上的不畅。</p><p><br/>因此用人话把技术讲清楚也是一项非常关键的能力。</p><p>有技术宣传能力，技术团队往往属于一种默默无闻付出型的一群人，善于用技术去解决问题，但并不善于去表达自己的能力和成绩，因此作为团队的技术负责人，应具备一定的技术宣传能力，对技术团队而言非常有帮助。</p><h2><b>二、具备敏锐的商业洞察力和产品意识</b> </h2><p>提到 商业洞察和产品意识，可能很多技术同学会觉得这似乎不是技术人成长的重点。<br/>但事实上，恰恰相反，我认为商业敏感性和产品意识也许对普通技术同学而言不是那么重要，但对于一名技术负责人而言，就尤为关键了。</p><p>因为，一名优秀的技术负责人，必须要懂业务懂产品，这样不仅在与业务、运营部门做需求沟通时，会更顺畅。而且，因为有了产品意识和业务视野，也会更有利于自己对技术的判断，会帮助我们更好的去制定技术方案、优先级等研发决策。</p><p>同时，做到深刻的理解客户和产品，才能从更高的层面去研发产品、从技术可实现的角度去改进产品，把技术和商业结合起来，才能更大的发挥技术的价值。</p><h2><b>三、迭代自己的能力</b> </h2><p>作为技术负责人，必须要有「迭代自己的能力」，这里的迭代自己，是指具有出色的学习能力。因为IT互联网行业的技术日新月异，每个月都有新的技术出来，如果没有持续不断的学习能力，是很难跟上技术趋势，实现技术价值的。</p><p>同时，这里的「迭代自己」又不仅仅是指学习能力，它应该还包括自我反思、自我重塑的能力。<br/>例如我们经常可以看到武侠剧中的一些剑侠们，为了学习最高层次的剑法，需要他改变自己之前剑法习惯、忘掉自己已掌握的一些低层次剑法，才能吸收新的剑法，才会有新的认识，更高的提升。</p><h2><b>四、带团队能力</b> </h2><p>作为技术负责人，必须能打造一支能战斗的团队、能够打造技术文化，构建开放的技术氛围。<br/>具有一定的影响力，能团结凝聚更多的小伙伴，吸引到志同道合的小伙伴们一起共同奋斗。<br/>对团队人员素质要有准确的判断、做好分工协作、关心团队小伙伴的成长、且需要有极强的沟通能力、能够管理自己的上级和下级。</p><p>因为能力再强的个人也比不上一只优秀的团队，因此对于技术负责人而言，能带好一个团队，是对他最基础的要求，也只有做好了这一点，才能真正称之为技术小伙伴们的带路人。<br/><br/><br/>以上四点我认为是作为一名技术负责人应具备的核心能力，希望大家可以一起探讨。<br/>愿每一位技术人都能找到适合自己的技术道路，坚持初心，爱你所爱，行你所行，听从你心，无问西东。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote> 欢迎小伙们关注微信公众号：「 bzsikao 」一起交流更多的互联网技术、管理、认知。</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "团队管理", 
                    "tagLink": "https://api.zhihu.com/topics/19578375"
                }, 
                {
                    "tag": "技术总监", 
                    "tagLink": "https://api.zhihu.com/topics/19562932"
                }, 
                {
                    "tag": "技术负责人", 
                    "tagLink": "https://api.zhihu.com/topics/19610033"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39840718", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "对生命的思索，对自己的真实", 
            "content": "<blockquote>对自己的真实就是：你看到什么、听到什么、做什么、和谁在一起，有一种从心灵深处溢出来的不懊悔、也不羞耻的平和、与喜悦。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>来自「 无问西东」：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>你看到的和你听到的，经常会令你们沮丧，世俗是这样强大，强大到生不出改变它们的念头来。<br/>可是如果有机会提前了解你们的人生，知道青春也不过只有这些日子，不知你们是否还会在意那些世俗希望你们在意的事情。比如占有多少，才更荣耀，拥有什么，才能被爱。<br/>等你们长大，你们会因绿芽冒出土地而喜悦，会对初升的朝阳欢呼雀跃，也会给别人善意和温暖。但是却会在赞美别的生命的同时，常常、甚至永远地忘了自己的珍贵。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>愿你在迷茫时，坚信你的珍贵，爱你所爱，行你所行，听从你心，无问西东。</p>", 
            "topic": [
                {
                    "tag": "生命的意义", 
                    "tagLink": "https://api.zhihu.com/topics/19596874"
                }, 
                {
                    "tag": "初心", 
                    "tagLink": "https://api.zhihu.com/topics/20008952"
                }, 
                {
                    "tag": "无问西东（电影）", 
                    "tagLink": "https://api.zhihu.com/topics/20163995"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39618288", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "初探互联网中程序化广告的前世今生", 
            "content": "<p>计算广告格局已建，日渐成熟，今天就补上一篇扫盲科普文。</p><h2><b>1、网络上主要有哪些形式的广告？</b></h2><ul><li><b>各种展示广告</b>：焦点图、Banner位、按钮广告、文字链广告、弹出广告、视频广告</li><li><b>搜索引擎广告</b>：搜索引擎的竞价推广，在搜索引擎上搜索关键字时，匹配出的推荐广告，例如Google Adwords、百度竞价排名等</li><li><b>原生广告</b>：即广告与原生内容结合在一起，不容易分辨，在信息流广告中尤为明显，例如新浪微博的信息流广告、今日头条的新闻列表流广告</li></ul><h2><b>2、网络广告的常见结算方式有哪些？</b></h2><ul><li><b>CPT</b>：Cost-per-Time，按展示时间结算。按时间包段的进行广告位售卖。的这是很多大中型媒体喜欢采用的结算方式。</li><li><b>CPM</b>：Cost-per-Mille，每千次展示成本，也就是说广告每展示一千次所需要的费用。比如一个弹出广告的售价是20元/CPM，那意思就是说这个广告位每展示1000次，即收费20元。</li><li><b>CPC</b>：Cost-per-Click，按点击结算。根据广告被点击的次数来收费。</li><li><b>CPA</b>：Cost-per-Action，按广告效果收费。也就是说根据广告投放后的反馈或激活的数量来结算。</li><li><b>CPS</b>：Cost-per-Sale，按销售结算，也就是分成结算。根据广告投放后，实际产品的销售数据来分成结算。<br/></li></ul><p>其它还有一些不是特别常用的结算方式，这里就不一一赘述了。但即使是以上这些，在实际交易中，也有很多灵活的操作，甚至可能是多种结算方式相互结合的。</p><h2><b>3、「 程序化广告」是啥？</b></h2><p>来一个百科级解释：</p><blockquote>程序化广告（Programmatic Advertising）是指利用技术手段进行广告交易和管理。<br/>广告主可以程序化采购媒体资源，并利用大数据和技术自动实现精准的目标受众定向，只把广告投放给对的人。<br/>媒体可以程序化售卖媒体资源，并利用技术实现广告流量的分级，进行差异化定价。</blockquote><p>因此，程序化广告可以理解为：以技术手段结合大数据实现精准的广告定向。</p><h2><b>4、为啥会出现这个叫做「 程序化广告」的东东？</b></h2><p>传统的互联网广告投放都是以「排期」的形式在进行。各大媒体将自己的广告位按照时间排期进行售卖，即CPT模式，固定的位置、承诺的展示时间、承诺一定的流量和效果，那么在这个排期内，广告主对整个广告位是独占的。</p><p>这种形式，对媒体资源的售卖率是有一定保证的，而且交易模式也比较简单成熟，上下游的利益都能保证，大家都乐于接受。到目前为止，互联网上很大部分优质广告位还是这种模式售卖。</p><p>但是这种排期模式也会有明显的问题。对于媒体方而言，能卖出去的都是一些 “优质的广告位置”，例如网站的首页、Banner位等等，而媒体还有很多其它的边角位置，比如网站内页、侧边栏等等，这些位置往往不太受排期包段模式下的广告主所欢迎，所以这类位置，以前大多都是赠送或者捆绑销售。所以很自然的，媒体方就希望将这部分流量也体现出价值，转化成收益，这就是所谓的“剩余流量”变现的需求。</p><p>除此之外，对于广告主而言也有弊端，因为排期包段买到的广告位，是面向所有用户的，那么这些流量中可能有很大部分并非品牌的目标受众。比如一个汽车品牌的广告主，采买了视频网站的插片广告，但是如果当前进入视频网站的用户是一个汽车爱好者或者观看汽车类视频的用户，则这个广告投的就很有价值了。如果进视频网站的是一位看动画片的小朋友，那么虽然广告还是展示了（因为包时段了），但是流量其实是被浪费了，因为他根本不是汽车的潜在用户。</p><p>为了解决传统排期广告的一些痛点，市面上就出现了各种各种形式的广告交易模式，例如 AdNetwork（广告联盟）、剩余流量RTB、PDB、私有竞价PA 等等。</p><p>其中，RTB（Real-Time Bidding）是程序化广告中很关键的部分。 <br/>媒体方将流量接入SSP（供给方平台）进行管理，广告主通过DSP（需求方平台）进行广告投放，而ADX（广告交易平台）是衔接流量卖方与广告买方的重要环节，双方在ADX中基于RTB实时竞价进行广告的实时交易。</p><p>程序化广告投放对大数据的依赖非常明显，因此在产业链条中出现了一批数据服务公司，例如提供DMP服务（数据管理平台）对精准的广告投放进行数据支撑。</p><p>随着程序化广告越来越成熟，分工也越来越细致，除了上述提到的 广告买方、流量卖方、广告交易平台、数据公司以外，还有一个重要角色就是 「第三方监测」。有些广告主在投放中，需要依赖第三方的监测数据来作为结算依据，这类第三方数据监测公司典型的比如 talkdingdata、admaster等。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3055100573594f8a39646b198cacbda1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic2.zhimg.com/v2-3055100573594f8a39646b198cacbda1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;616&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"616\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic2.zhimg.com/v2-3055100573594f8a39646b198cacbda1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3055100573594f8a39646b198cacbda1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5、用户唯一ID识别 与「 程序化广告」的技术规范？</b></h2><p>为了打破数据孤岛，对用户数据进行互联互通，提高广告投放的精准度，我们需要对用户有一个唯一ID标识。移动设备的唯一标识可以参考之前写的另一篇文章： <br/><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzI2MTExOTA3Nw%3D%3D%26mid%3D2650501999%26idx%3D1%26sn%3Db63d721bf43c655dfec45d31d43b435d%26chksm%3Df2509e65c5271773236aaf9c3739e3a1033cb0d25701e06b0aee4e09ed230a679eec68bfbcf3%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">移动设备（手机）的唯一ID有哪些</a></p><p>另外，在程序化广告行业里，有个非常重要组织「IAB」（美国互动广告局），它是一个广告标准制定的组织，制定了很多网络广告和程序化广告的标准，在行内认可度比较高，大家可以直接去官网查询相关标准的资料。 <br/>比如RTB竞价广告标准：OpenRTB就是由「IAB」推出的技术接口规范。 <br/>国内的话，例如MMA中国无线营销联盟也是做得比较不错的组织。</p><p>如果各个厂商都能按照统一标准去开发的话，能最大程度的减少对接成本，提高行业的互通效率。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>关注微信公众号： <br/>「 bzsikao 」</blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "计算广告学", 
                    "tagLink": "https://api.zhihu.com/topics/19591877"
                }, 
                {
                    "tag": "程序化广告", 
                    "tagLink": "https://api.zhihu.com/topics/20166684"
                }, 
                {
                    "tag": "实时竞价（RTB）", 
                    "tagLink": "https://api.zhihu.com/topics/19739079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39099670", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "7月，2018过去一半了，你焦虑了吗", 
            "content": "<p>最近跟几个在换新工作的同学聊天，突然发现周边人都挺焦虑的。</p><p>其实想想也对，对于我们这样一个普通家庭的人来说，确实到了开始焦虑的时间点，</p><ul><li>大多年纪也都不小了（对于IT行业），所以对职业会有一种焦虑。</li><li>大多上有老下有小，对家庭压力产生的焦虑。</li><li>大多是只靠上班收入，单一收入来源，对经济的焦虑。</li></ul><p>再加上现在网上各种吹嘘中年焦虑的网红文章，各种不负责的言论到处充斥着，更加大了大家的焦虑情绪。</p><p>但是要怎么才能化解焦虑，给自己打开一扇新的窗户呢？</p><p>说实话，我也不知道，我一直在思考。但我认为，要解决这个问题，首先要做的是去 「改变自己的心态」「突破自己的做事方向」，也许这个周期比较长，但因此更需要我们拥有耐心。</p><p>好了，换个时间再仔细聊「焦虑」的话题吧，今天的重点不在这里。</p><p>今天这篇文章，是准备用来汇报一下1-6月我在读书和写作方面的一些进度，只不过在梳理的过程中，突然有点时间焦虑了，就岔开话题聊一点。</p><p>18年开年后，我决定捡起N年没写的博客，开始写写东西，每周一篇文章，记录记录技术与心得，并且每月精读一本书。</p><p>上半年在公众号写了大概 <b>17篇</b> 文章，如果按照一周一篇，半年应该是 <b>24篇</b>，好吧，看来产量还需要增加。</p><p>到目前为止，上半年精读过大概十本书：</p><ul><li>「区块链-技术驱动金融」</li><li>「区块链-从数字货币要信用社会」</li><li>「腾讯传」</li><li>「如何阅读一本书」</li><li>「阿里铁军」</li><li>「高效能阅读」</li><li>「智能时代」</li><li>「光荣与荣耀」部分</li><li>「大数据之路」</li><li>「TED TALKS」</li></ul><p>继续努力的吧！</p>", 
            "topic": [
                {
                    "tag": "焦虑", 
                    "tagLink": "https://api.zhihu.com/topics/19571469"
                }, 
                {
                    "tag": "时间", 
                    "tagLink": "https://api.zhihu.com/topics/19553548"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38937566", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "如何将你的思想植入听众的内心", 
            "content": "<p>我越来越觉得展示自己的思想将是一种非常必要的技能，学会展示自己思想的一个很重要的方法就是演讲。</p><p>演讲可以分为公共演讲和即兴谈话演讲，无论哪一种场景，演讲这项技能，对于每一个人都非常有帮助，它可以帮助我们：</p><ul><li>建立自信</li><li>开创一番事业</li><li>在工作中取得进步</li><li>获得威望</li><li>与他人建立联系</li><li>激发行动以产生影响</li><li>将思想植入听众的内心<br/></li></ul><p>尤其是对于一个创业者/领导者而言，通过演讲来表达自己的思想至关重要。它可以寻求共鸣，激发热情，还可以分享知识和见解，带动的大家追求共同的梦想。</p><p>上面说了演讲虽然有很多的作用，但是我们一定要清楚的是，演讲的最终目的是用自己独特的方式真诚的去分享有价值的思想。</p><p>演讲其实是一种展示技能，用于展示自己的思想，将自己的观念植入到听众的内心。任何一个人，只要拥有值得分享的思想，就能发表精彩的演讲。而这个思想，应该是你独有的体会，是你的第一手的经验，才能更打动人心。</p><p>当人们坐下来听你的演讲时，他们给你的是某种非常宝贵的东西，某种一旦给予便无法收回的东西，那就是他们的时间和精力。因此，你的演讲必须是有灵魂的，有价值的，对大家有帮助的东西。</p><p>演讲其实还是一种「 知识 」的传输，但是知识并不能被强塞进听众的大脑，而是要让大脑主动的吸收。在把一个知识/一个思想植入他人内心之前，首先需要得到他们的允许，要消除他们的戒备，并与观众建立起联系、建立起信任的纽带。这样，他们才愿意在短时间内向你真正的尚开心扉，开始接受你的观点。</p><h2><b>建立联系</b></h2><p>如何与观众建立联系、建立信任的纽带呢。有几个方法可以参考：</p><ul><li>与观众进行眼神交流并适当微笑。表现得温暖、真诚而自然，这样，他们就会信任你、喜欢你、并开始被你的激情所感染</li><li>展示自己的弱点。有的时候展示弱点是演讲者可以利用的非常强有力的工具之一</li><li>让观众发出笑声。幽默是吸引观众注意力的非常有效的方法，但幽默是一种技术性艺术，并非所有人都能驾驭，如果你不擅长幽默，那么就不要使用笨拙的幽默方式，不然会适得其反</li><li>讲故事。真诚的讲故事，适当的提供细节，如果细节太少，故事会显得不够生动<br/></li></ul><p>在传达思想和观点的时候，快速的把一件事情/一个理念解释清楚的能力也非常重要，而最好用的解释方式就是打比方和举例子。</p><h2><b>幻灯片</b></h2><p>另外，演讲中我们要善用幻灯片PPT，有的时候通过语言不能很好表达的地方，用一张幻灯片却能解释得非常清晰，这就是所谓的一张图抵得上千言万语。除此之外，一张好的幻灯片还能增加观众的视觉美感。</p><p>不过使用幻灯片的前提是要精致，有一条基本的使用原则是：没有幻灯片要优于糟糕的幻灯片。</p><h2><b>演讲稿</b></h2><p>一个完美的演讲是需要做好充分的准备的，这个准备除上述要求以外，包括演讲稿。 <br/>可以将全部演讲的内容写下来，作为一份演讲稿，然后背下来。但要注意的是，演讲稿必须是口头语言，并且要反复多次的背诵和试讲，要确保对讲稿足够的熟悉，使讲出来的话听上去是由衷的表达，尽力避免使之听上去是背诵。</p><p>不断的排练，使演讲水到渠成。</p><p>无论今天演讲有多么重要，未来只会更加重要。</p>", 
            "topic": [
                {
                    "tag": "演讲", 
                    "tagLink": "https://api.zhihu.com/topics/19553107"
                }, 
                {
                    "tag": "思想", 
                    "tagLink": "https://api.zhihu.com/topics/19560566"
                }, 
                {
                    "tag": "说话艺术", 
                    "tagLink": "https://api.zhihu.com/topics/20027058"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38364601", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 8, 
            "title": "GDP发展史-小视频看着挺燃的", 
            "content": "<p>请盯着中国看，燃不燃？</p><a href=\"https://link.zhihu.com/?target=https%3A//v.qq.com/x/page/r0688xwukz2.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-a772a2982020f0c43d39432a93d041da_180x120.jpg\" data-image-width=\"320\" data-image-height=\"180\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GDP发展史 中华民族伟大复兴_腾讯视频</a><p></p>", 
            "topic": [
                {
                    "tag": "经济增长", 
                    "tagLink": "https://api.zhihu.com/topics/19700839"
                }, 
                {
                    "tag": "国内生产总值（GDP）", 
                    "tagLink": "https://api.zhihu.com/topics/19685970"
                }, 
                {
                    "tag": "中美比较", 
                    "tagLink": "https://api.zhihu.com/topics/19906729"
                }
            ], 
            "comments": [
                {
                    "userName": "薛康泰", 
                    "userLink": "https://www.zhihu.com/people/4be9762b646c1a0e1b75f30a0b0b2537", 
                    "content": "数据整体上缩小了10倍？", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Njcity", 
                    "userLink": "https://www.zhihu.com/people/9ae4eaf6591d2abd78732fb1711eff86", 
                    "content": "说实话文化跟不上经济没什么可值得高兴的", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "薛康泰", 
                    "userLink": "https://www.zhihu.com/people/4be9762b646c1a0e1b75f30a0b0b2537", 
                    "content": "数据整体上缩小了10倍？", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Njcity", 
                    "userLink": "https://www.zhihu.com/people/9ae4eaf6591d2abd78732fb1711eff86", 
                    "content": "说实话文化跟不上经济没什么可值得高兴的", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37754034", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "闲聊：据说二战中日本并没有偷袭珍珠港？", 
            "content": "<p>最近在看《光荣与荣耀》一书，仔细读了二战中太平洋战争这段历史，发现了一段有意思且以前没有注意到的一个战争细节。本文就在这里就事论事，不带有感情色彩的聊一聊。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>二战中，据说日本并没有偷袭珍珠港</b></p><p>偷袭珍珠港是一个乌龙事件，准确描述应该是 “日本奇袭了珍珠港” ，因为在轰炸珍珠港之前，宣战书已经提前通知了，但由于某些原因没有及时传达，所以这次轰炸应该算做一次奇袭。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>偷袭与奇袭有什么区别呢？</b></p><p>偷袭是在事先没有通知的情况下就开展的，对方还没有跟你对战的意愿和准备，就开始突然进攻了，这种行为在战争中，是非常没有道德、非常可耻的做法。</p><p>奇袭是在通知过对方了，准备交战了，然后再进行的攻击，至于打哪儿、怎么打，这就属于战术范畴了，属于正常作战手段。</p><p>哈哈，是不是有一点标题党。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>首先说说这个偷袭珍珠港的乌龙事件：</b></p><p>当时美日两国还在进行谈判着呢，负责攻击珍珠港的山本五十六还在等着日本大本营的通知，如果谈判失败了，就会发动袭击珍珠港，如果判断成功了，就会率领全部舰队返回基地。</p><p>虽然从当时国际形势看，谈判很难谈拢，但山本五十六还是要求，一定要提前宣战，再进行攻击。可是就在宣战书发到日本驻美国大使馆的时候，译电员已经下班了，等到第二天宣战书翻译出来，将宣战书送到美国国务卿 赫尔 手中时，珍珠港此时已经被轰炸了两个小时了。</p><p>此时 赫尔 的心情可想而知，据说他气的手发抖，然后骂道： <br/>“我做国务卿这么多年，从来没有见过哪个国家能做出如此厚颜无耻之事”</p><p>这段不知真假的历史大概就是这样了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>不过可以再多聊一点点，为啥 当时日本一定要轰炸珍珠港呢？</b></p><p>因为当时在打仗啊，美英对日本实行石油禁运，除非日本答应从中国撤军并停止扩张的要求。而当时日本国内的石油只能维持3-6个月的时间，石油一旦没了，那些战争机器 军舰、飞机 都成了一堆废铜乱铁啊，形势对于日本还是很严峻的。</p><p>日本是一个岛国，资源本来就少，天然有扩张获取资源的需求，加上日本一直走军国主义道路，且当时日本的战斗力还不错。所以日本并没有选择撤退中国的条件，而是打算投入所有的资源来一场速战速决的战斗，先轰炸珍珠港削弱美军实力，再同时攻打菲律宾，企图获取丰富的石油、大米、橡胶等资源。当然，碰到了美国这个现代化、又有资源的国家，结果就很明显了。</p><p>二战故事挺多的，《光荣与梦想》是一本好书。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>关注微信公众号： 「 bzsikao 」</blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "珍珠港", 
                    "tagLink": "https://api.zhihu.com/topics/19666086"
                }, 
                {
                    "tag": "第二次世界大战", 
                    "tagLink": "https://api.zhihu.com/topics/19608803"
                }, 
                {
                    "tag": "太平洋战争", 
                    "tagLink": "https://api.zhihu.com/topics/19941669"
                }
            ], 
            "comments": [
                {
                    "userName": "stargazer986", 
                    "userLink": "https://www.zhihu.com/people/a462e9d6aee54fb869d637a3f988c6ee", 
                    "content": "中文翻译的政治正确瞎定性而已。英语圈对这次事件的描述，不管是surprise military attack还是preventive action，strike raid，都是突出强调行动本身有预谋和突然性。现代军事行动本来就是高度组织规划，甚至伴随欺敌行动，根本谈不上什么突发性袭击。不宣而战主要是政治层面对整场战争的定性，单一的军事行动本身很难套用这个概念。", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>哈哈，历史总是各说风云嘛。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "stargazer986"
                        }
                    ]
                }, 
                {
                    "userName": "stargazer986", 
                    "userLink": "https://www.zhihu.com/people/a462e9d6aee54fb869d637a3f988c6ee", 
                    "content": "比如奇袭:<br>毛泽东《中国革命战争的战略问题》第五节：“红军的作战一般是奇袭”。<br>红军打仗什么时候要通知对面我们来了？", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>哈哈，不是每一场战役都需要通知的，只需要在第一次开战之前宣战即可。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "stargazer986"
                        }
                    ]
                }, 
                {
                    "userName": "DJN", 
                    "userLink": "https://www.zhihu.com/people/04f649274cb3d3e3a59849f5a01d23fe", 
                    "content": "不过是有传言说罗斯福知道日本要轰炸珍珠港，只是为了让国会同意罗斯福宣战，才隐瞒了情报", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>哈哈，感谢回复。貌似是有这么一种传言，据说因此美国航母知道消息提前出海了。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "DJN"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37584543", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 2, 
            "title": "大数据之数据采集", 
            "content": "<p>大数据体系一般分为：数据采集、数据计算、数据服务、以及数据应用 几大层次。</p><p>在数据采集层，主要分为 日志采集 和 数据源数据同步。</p><h2><b>日志采集</b></h2><p>根据产品的类型 又有可以分为：</p><ul><li>浏览器页面 的日志采集</li><li>客户端 的日志采集 <br/></li></ul><p><b>浏览器页面采集</b>： <br/>主要是收集页面的 浏览日志（PV/UV等） 和 交互操作日志（操作事件）。</p><p>这些日志的采集，一般是在页面上植入标准的统计JS代码来进执行。但这个植入代码的过程，可以在页面功能开发阶段由开发同学手动写入，也可以在项目运行的时候，由服务器在相应页面请求的时候动态的植入。</p><p>事实上，统计JS在采集到数据之后，可以立即发送到数据中心，也可以进行适当的汇聚之后，延迟发送到数据中心，这个策略取决于不同场景的需求来定。</p><p>页面日志在收集上来之后，需要在服务端进行一定的清晰和预处理。 <br/>比如 清洗假流量数据、识别攻击、数据的正常补全、无效数据的剔除、数据格式化、数据隔离等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>客户端日志采集</b>： <br/>一般会开发专用统计SDK用于APP客户端的数据采集。</p><p>客户端数据的采集，因为具有高度的业务特征，自定义要求比较高，因此除应用环境的一些基本数据以外，更多的是从 “按事件”的角度来采集数据，比如 点击事件、登陆事件、业务操作事件 等等。</p><p>基础数据可由SDK默认采集即可，其它事件由业务侧来定义后，按照规范调用SDK接口。</p><p>因为现在越来越多APP采用Hybrid方案，即 H5 与 Native相结合的方式，因此对于日志采集来说，既涉及到H5页面的日志，也涉及到Native客户端上的日志。在这种情况下，可以分开采集分开发送，也可以将数据合并到一起之后再发送。</p><p>常规情况下是推荐将 H5上的数据往Native上合并，然后通过SDK统一的发送。这样的好处是 既可以保证采集到的用户行为数据在行为链上是完整的，也可以通过SDK采取一些压缩处理方案来减少日志量，提高效率。</p><p>APP上的数据采集，还有一点比较重要的就是唯一ID了，所有的数据都必须跟唯一ID相关联，才能起到更好的分析作用，至于移动设备唯一ID我在上一篇文章中有详细讲到。 <br/></p><p>日志收集，还有很重要的一条原则就是 “标准化”、“规范化”，只有采集的方式标准化、规范化，才能最大限度的减少收集成本，提高日志收集效率、更高效的实现接下来的统计计算。</p><h2><b>数据源数据同步</b></h2><p>根据同步的方式 可以分为：</p><ul><li>直接数据源同步</li><li>生成数据文件同步</li><li>数据库日志同步 <br/></li></ul><p><b>直接数据源同步</b>： <br/>是指直接的连接业务数据库，通过规范的接口（如JDBC）去读取目标数据库的数据。这种方式比较容易实现，但是如果业务量比较大的数据源，可能会对性能有所影响。</p><p><b>生成数据文件同步</b>： <br/>是指从数据源系统现生成数据文件，然后通过文件系统同步到目标数据库里。 <br/>这种方式适合数据源比较分散的场景，在数据文件传输前后必须做校验，同时还需要适当进行文件的压缩和加密，以提高效率、保障安全。</p><p><b>数据库日志同步</b>： <br/>是指基于源数据库的日志文件进行同步。现在大多数数据库都支持生成数据日志文件，并且支持用数据日志文件来恢复数据。因此可以使用这个数据日志文件来进行增量同步。 <br/>这种方式对系统性能影响较小，同步效率也较高。 <br/></p><p>数据采集本身不是目的，只有采集到的数据是可用、能用，且能服务于最终应用分析的数据采集才是根本。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>关注微信公众号： 「 bzsikao 」 </blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "大数据分析", 
                    "tagLink": "https://api.zhihu.com/topics/19831849"
                }, 
                {
                    "tag": "数据采集", 
                    "tagLink": "https://api.zhihu.com/topics/19574843"
                }, 
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }
            ], 
            "comments": [
                {
                    "userName": "火星驻地球办事处", 
                    "userLink": "https://www.zhihu.com/people/2a11650fe8012c2a97dfec47384480e2", 
                    "content": "<p>海量真实动态IP地址可以试试飞蚁IP代理</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37455363", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 13, 
            "title": "移动设备（手机）的唯一ID有哪些", 
            "content": "<p>在移动广告领域，设备的ID 是用来追踪一个人的最重要的标识。</p><p>对于APP自身产品而言，使用设备唯一ID可以追踪到用户从下载到激活、注册、使用、流失、回归的全流程数据，对产品运营工作非常有帮助。</p><p>对于精准广告和个性化推荐而言，可以使用设备ID进行数据收集、然后进行千人千面的精准营销。</p><p>对于与外部数据打通而言，移动设备ID 是能与公司外的数据进行打通、交换、补充的唯一性ID，也是市场上大家都认可的ID。</p><p>既然移动设备ID 如此的重要，那我们就来聊一聊，有哪些ID我们是可以使用的：</p><h2><b>一、IMEI</b></h2><p><b>IMEI</b>是国际移动设备识别码，一串15位的号码，每部通过正规渠道销售的GSM手机均有唯一的<b>IMEI</b>码。IMEI码由GSMA协会统一规划，并授权各地区组织进行分配，一般由运营商存储在SIM卡中。</p><p>1、IOS体系下：无法获取 <br/>在IOS5.0以后，苹果官方就屏蔽了获取IMEI号的接口，因此后续版本的苹果设备都无法获取到<b>IMEI</b>号。</p><p>2、Andriod体系下：可以获取 <br/>Andriod的手机设备是允许开发者获取<b>IMEI</b>号的，但在Andriod6.0以后版本需要得到用户的主动授权才能获取。</p><h2><b>二、IDFA</b></h2><p>苹果和Google针对移动设备推出的 广告标识符</p><p>1、IOS体系下：可以获取 <br/>在IOS6.0以后版本均可以正常获取<b>IDFA</b>，但手机用户可以手动还原 以及 手动禁止获取（手动关闭广告追踪，目前关闭的用户占比较小）。</p><p>2、Andriod体系下：受限获取 <br/>其实在Andriod2.3以后，Google也学苹果推出了<b>IDFA</b>，用于跟踪广告的唯一标识，功能基本上与苹果的<b>IDFA</b>是一样一样的。但是Google的这个<b>IDFA</b>是需要基于Google Play等基础APP的，在国内环境下，Google的这些基础APP要么无法访问使用，要么被手机厂商直接去掉了，因此Android手机上的<b>IDFA</b>在国内没有起到唯一ID的作用。</p><h2><b>三、UDID</b></h2><p>原苹果设备的唯一识别ID，它是40个字符组成。</p><p>1、IOS体系下：无法获取 <br/>在IOS旧版本可以使用，但在IOS7.0以后版本苹果停用了此ID，新版都无法获取。</p><p>2、Andriod体系下：无法获取 <br/>Andriod体系没有这个ID。</p><h2><b>四、MAC</b></h2><p><b>MAC</b>是指无线网卡地址</p><p>1、IOS体系下：无法获取 <br/>在IOS7.0以后版本IOS设备无法获取到<b>MAC</b>（准确说是会返回一个固定值的MAC，不具有唯一性）。</p><p>2、Andriod体系下：可以获取 <br/>APP的开发者可以主动获取当前Andriod手机的<b>MAC</b>地址，另外 如果是通过 WIFI上网 或者 WIFI AP 探针 也都可以获取到当前设备的<b>MAC</b>地址。</p><h2><b>五、Andriod_ID</b></h2><p><b>Andriod_ID</b> 是Andriod设备独有的ID，每一个新设备系统都会随机的分配一个<b>Andriod_ID</b>，为64位数字。如果将设备恢复出厂设置、刷机，则会生成一个新的ID。</p><h2><b>六、其它 IDFV、openUDID、UUID</b></h2><p><b>IDFV</b> 是苹果设备给单个APP自身用于追踪用户的唯一ID，这个<b>IDFV</b>在一个APP内是唯一的，跨APP就不唯一了，因此只能用于单个APP自身用于追踪用户行为。</p><p><b>openUDID</b> 是非官方提供的API，在IOS和Andriod体系下都可以使用，效果一般，有部分公司也会使用这个ID。</p><p><b>UUID</b>由于Andriod体系ID确实太复杂了，所以还有厂商会根据UUID生成标准在APP中生成UUID来使用。</p><blockquote>无论是苹果还是Google，都越来越注重用户隐私的保护。因此可以看到，只要是涉及到 设备的唯一性且不可更改性的ID，都慢慢的不会苹果/Google推荐使用，例如 MAC地址、UDID等，都是与设备永久性绑定，一旦泄漏涉嫌侵犯用户隐私的。所以现在厂商都开始推各类的 广告ID，例如 IDFA，可用于追踪广告，也可由用户自主设置。</blockquote><h2><b>目前，在国内，Android设备主要还是以 IMEI 为主，IOS设备主要以 IDFA 为主。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>参考资料 MMA中国无线营销联盟、《程序化广告实战》书籍等。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>关注微信号： 「 bzsikao 」</blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "移动终端", 
                    "tagLink": "https://api.zhihu.com/topics/19577425"
                }, 
                {
                    "tag": "Android", 
                    "tagLink": "https://api.zhihu.com/topics/19603145"
                }, 
                {
                    "tag": "iOS 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19555404"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37302870", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "公司跟你聊企业文化了吗", 
            "content": "<p>最近听到一些人在聊企业文化。有的人觉得这是公司管理的灵魂，但有的人觉得这玩意儿很玄乎，虚得很。为啥会有不同的认识呢，我觉得可能还是因为大家身处的公司、位置，以及所接触到的不同企业文化所导致的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天我就聊一聊企业文化的哪些事情儿。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>什么是企业文化？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果想了解教科书标准的解释，可百度百科。 <br/>我比较欣赏的一种通俗解释就是：企业文化就是在没有行政命令、没有制度的要求下，企业员工默认行事风格。 </p><p><br/>企业文化是一套观念、价值观，并且这套价值观还要得到全体员工的共识，它是要能实际影响员工行为的，它并不只是一句口号。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>企业文化就是一家企业做事的方式，有些公司将企业文化制度写的很好、口号喊得很响，如果实际不那么做，那么写出来的这些文化都是假的，实际做的那个文化才是真的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如 有的公司制度文化中号称高效工作、不鼓励加班。但是实际你去一看，到了下班的点没有一个人走。这是什么文化，这是加班文化。</p><p>有的公司制度文化中号称鼓励创新。但是在实际过程中，遇到一点点的问题就开始追究责任，这其实就是在默默的告诉大家做的越多错的越多，没人敢做创新的事情了，慢慢的就形成了一种无创新的文化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>企业文化的生长，是需要有合适的土壤的，如果只是单向传播，只会给员工洗脑，无异于耍流氓。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>作为一个技术管理者，我怎么看待企业文化？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>企业文化首先应该是自上而下的文化，在中国的这样的人文环境下，由于领导者的独特地位和强大的的影响力，由于上行下效的文化观念，很多公司的企业文化其实就是 “老板文化”、“一把手文化”。</p><p>公司的一把手塑造企业级别的文化，部门的一把手塑造部门级别的文化。这并不是特意而为之，只不过他们的一言一行都在影响员工的行为、都在影响着这些文化的形成。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1、企业文化要着眼于未来，不应该是两年一小改、三年一大改。应该是一个结合行业特征和企业自身目标而定的一种团队文化。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、需要通过各种有效手段保障制定的企业文化。假如公司自己的企业文化应该是创新，那么就应该通过制度来鼓励创新、鼓励试错。这里的制度，应该是制定保障企业文化的措施，而不是单单是将文化口号写在制度表中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3、全部员工对企业文化的共识。团队成员要对这个文化理念达成一致，共识，才能整个团队一起发力，而不是单单几个人在努力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4、要体现出价值观、要有做人和做事的价值衡量，什么是公司鼓励的，什么是不鼓励的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>5、企业文化从一把手竖起榜样。企业不能口中要求员工这样那样，但公司领导却不遵守，这种也是毫无意义的。经常见到有些企业要求员工要有创新，但在实际运作中处处都是规矩。还有见到过企业号称一切为客户着想，但在实际利益与客户体验两者需要取其一的时候，往往又抛弃了客户。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>腾讯之前一直被诟病为抄袭的问题，但是最近几个新闻确实看出了作为腾讯的掌门人马化腾坚持朔造新文化的态度：<br/><br/>1、前段时间，腾讯的一个创新团队推出了一个叫做 “立知”的APP，完全是在模仿 “即刻”，被媒体吐槽后，马化腾立即让“立知”APP下架，相信作为掌舵人表现出的这种反对抄袭的态度与决心，是会对整个公司有非常大的影响的。 <br/><br/>2、就在前几天，腾讯TPOIC基金（腾讯兴趣内容基金）投资了公众号“差评”，相信很多人都知道那个公众号，粉丝确实非常多，但是那个公众号有一个不能被行业所接受的行为就是“洗稿”，经常从各种媒体平台上搜罗稿件、东平西凑出一篇文章、修修改改就作为自己的文章去发表，这种“洗稿”行为一直以来都被各媒体吐槽指责，而正是以“洗稿”出身的一个公众号竟然获得了腾讯的3000W人民币投资，在新闻出来后，媒体圈开始炸了，大家指责腾讯一个号称保护原创的公司竟然投资一家抄袭的公司。然而，就在当天晚上，马化腾就在朋友圈发表申明，解释因业务部门没有做好尽职调查，此次投资会重新考虑。相应之快，对文化理念之坚持，可见一斑。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>企业文化，其实没有那么复杂，没有那么高深，就是一群人在一个公司养成了一样的思考做事习惯 。<br/></p><p>对了，在互联网企业中，还有一个研发文化，也是值得仔细去琢磨的一块儿，下次聊这个话题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>附录几家科技公司企业文化：</p><blockquote>Google谷歌： <br/>Don’tbeevil（不作恶）<br/><br/>腾讯： <br/>正直，进取，合作，创新<br/><br/>本田： <br/>为自己而工作<br/><br/>华为： <br/>狼性文化，学习、创新、获益、团结<br/><br/>网易： <br/>网易的企业文化感觉就是没有企业文化，哈哈哈哈哈哈</blockquote>", 
            "topic": [
                {
                    "tag": "创业", 
                    "tagLink": "https://api.zhihu.com/topics/19550560"
                }, 
                {
                    "tag": "企业管理", 
                    "tagLink": "https://api.zhihu.com/topics/19559804"
                }, 
                {
                    "tag": "企业文化", 
                    "tagLink": "https://api.zhihu.com/topics/19550241"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36555908", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 3, 
            "title": "读者的权力", 
            "content": "<p></p><p>作为一名不善于读书的人，拿到一本书之后，往往会被 “必须从头读到尾” 的传统观念所束缚。 <br/>自从读了「高效能阅读」，看到了 读者十条权力 后，观念有了非常大的改变，甚受鼓舞，这 十条权力 分别是：</p><ul><li>第一条 不读的权力</li><li>第二条 跳读的权力</li><li>第三条 不读完的权力</li><li>第四条 重读的权力</li><li>第五条 读不择书的权力</li><li>第六条 包法利症的权力（易被小说内容感染的症状）</li><li>第七条 读不择地的权力</li><li>第八条 随意选读的权力</li><li>第九条 朗读的权力</li><li>第十条 默读的权力</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>尤其是其中 跳读的权力、不读完的权力、随意选读的权力，这些简直使读者的心灵得到了解放。</p><p>不善于读书的人大多患有必须读完一本书的强迫症。现在知道了 “读者权力十条” ，请大家高举权力的旗帜，不要被书所困，大胆的采用适合自己的读法，这样的读书才会感觉轻松。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>既然提到了读者的权力，那我再来聊一聊读书的几个技巧：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>1、速读</b></p><p>当今信息如此泛滥，那么如何迅速读取有效信息的技巧就显得尤为重要了，这里就介绍一个速读的诀窍。 <br/>速读的关键，其实是在于快速的进行 “关键词的发掘” 和 “假设验证型读书”。</p><p>也就是说，我们在读一本书的时候，先把着眼点放在 “关键词的发掘” 上，仔细阅读目录、开章介绍、总结段落等地方，对书籍的内容有一个大概的预判。然后在快速浏览正文的时候，快速的寻找作者想表达的核心思想和关键词句，同时根据关键词句在大脑中去论证自己刚开始的预判。</p><p>用一句话解释就是：怀有问题意识去看书，找到线索后，在其带动下进行快速、多次阅读。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>2、垂直型阅读和水平型阅读</b></p><p>垂直型阅读，是培养成 “专才” 的一种阅读方法。 <br/>所谓 “专才” 是指在业务上与其他人存在明显差别，在特定领域具备深厚知识和专业技能，并且专注于该领域的工作者。若想成为专才，在垂直方向上深化特定领域的读书是不可或缺的。</p><p>水平型阅读，是成长为 “通才” 的一种阅读方法。 <br/>所谓 “通才” 是指不限于特定领域，在多方面都具备一定水平以上的广泛知识和技能的工作者。若想成为通才，需要在水平方向上阅读所有领域的书籍。</p><p>选书的最佳方式是：70:20:10 <br/>即，如果要读100本书的话，那么建议读70本自己专业领域书籍、20本与本领域相关的书籍、10本完全新领域的书籍。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、以产出为目的的读书</b> </p><p>读书一定要 “重视产出” ，因为书籍只有经过自己消化了，才能转化成自己的知识或思想，将这个知识或思想讲出来或者记录下来，才能说明自己是真的理解了，也更有利于记忆。</p><p>希望以上读书方式和技巧，能够帮助大家更高效的去阅读。</p><hr/><blockquote>本文原创发布于微信公众号： <br/>「 bzsikao 」 </blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "读者（杂志）", 
                    "tagLink": "https://api.zhihu.com/topics/19659118"
                }, 
                {
                    "tag": "读书方法", 
                    "tagLink": "https://api.zhihu.com/topics/19635758"
                }, 
                {
                    "tag": "快速阅读", 
                    "tagLink": "https://api.zhihu.com/topics/19635365"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36180811", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "那些人都是怎么定下自己创业项目的？", 
            "content": "<p>如果打算互联网创业，那首先肯定得有个方向嘛。可是大家一般都是怎么去选择自己的创业方向的呢？<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-021899f5b328233656e6827545bc4b89_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb\" width=\"428\" data-original=\"https://pic2.zhimg.com/v2-021899f5b328233656e6827545bc4b89_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;428&#39; height=&#39;240&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"240\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"428\" data-original=\"https://pic2.zhimg.com/v2-021899f5b328233656e6827545bc4b89_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-021899f5b328233656e6827545bc4b89_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>今天读到罗胖的一篇文章，讲的是教大家怎么去选择自己的创业方向，感觉很有趣，也很有启发。这里我就来聊一聊。</p><p>针对大多数人的互联网创业，在考虑方向的时候，其实有这么几个方法是可以参考的：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>•  选一个垂直/细分领域去做创新</b></p><p><b>•  找到一个供给不足的市场去深根细作</b></p><p><b>•  拥有了一个非常牛或革命性的技术</b></p><p><b>•  为了自己喜好或一直以来的梦想</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面四个方法，从上至下依次实现起来也是越来越难。  </p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面就分别解读一下这四种方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>01</p><p><b>选择一个垂直或细分领域去做创新</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种方式只要用心的仔细去挖掘，相对来说，发现和成功的可能性还是比较大的。这种方式其实就是需要你在某一个细分的行业内，找到一个小的蓝海，它有可能会有巨大的市场需求，但目前还未开拓。那么这种时候，就可以认为这是一个较好的创业项目。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如O2O火的时候，所有人都知道“饿了么”完美的解决了人们对外卖的需求。但恰好，你发现，还有另一个需求没有解决，比如外送药品，这个细分领域的需求还没人做，并且调研之后发现，确实有一定的受众，这个时候你赶紧出了一款“好药师APP”专门用来送医药O2O服务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>再或者当知识付费或在线付费问答非常火的时候，你做了某个细分领域的知识付费产品，这也极有可能成为这个细分领域内的蓝海。比如专门给程序员知识付费的“极客时间”，就是在细分领域内对标通用领域的“得到”。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>理论上，在一个大家都比较认可的方式下，找出细分的小蓝海，然后第一批冲进去，尽快弄出新的品类，好的产品，从而实现一些创业成绩，这个成功的可能性还是非常大的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但要重点阐明一个观点，想到一个创意或新品类并不难，贵在执行和坚持。单纯的好点子是不值钱的，很多聪明人都能想到，但并不是所有人都将想到的好点子进行仔细论证后，高效率的付诸行动。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>02</p><p><b>找到一个供给不足的市场去深根细作</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种方法其实相对比较难，不过也是大多数人所选择的一种创业道路。这种方式比较务实，容易想到和看到，但是执行起来却比较辛苦了。它指的是，某个市场已经有了，但是存在供给不足的情况，并给这个市场的增长势头还没有完，很有可能跟着去分一杯羹。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如前几年的智能手机市场，但是可能大家都知道智能手机普及还未完成，还有巨大市场，而市面上的智能手机又有各种不完美，那么是否可以考虑切入进入呢。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是如果选择这样一个方向，就不能指望快速的成事，这个创业过程肯定是艰难的、缓慢的过程。要有良好的心理素质和耐性。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>03</p><p><b>拥有一个非常牛或革命性的技术</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种就属于可遇不可求的机会了。如果你拥有一个颠覆性的技术，并且准备尝试将其进行运作为商业化的产品，那么这就是一个非常完美的创业方向。当然，对于大多数人来说，遇到这种机会的可能性极低。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果经过你的苦心钻研，终于解决了智能驾驶、瞬间移动等革命性技术，那就赶紧创业吧，别犹豫了。比如汽车的发明、莱特兄弟的飞机发明等等，都属于这一类。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>04</p><p><b>为了自己的喜好或从小的梦想</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>假设你的创业是为了自己的某一个偏好，或者从小对某个方向就创业梦想，所以才去创业，甚至是不计后果的去做这件事，有一股“老子就是要干这事”的思想，这也是可以的，甚至是真的有一小波人创业的动机就是这个。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>比如从小就想实现飞往太空的马克斯，或者你从小就要立志解决某一个共识问题，然后成年后义无反顾的投入到这个创业大军中。不过这种创业方法，在大多数情况下，创业成功的几率都是非常低的，不太现实的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>技术、思考、互联网</p><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p>微信公众号「 bzsikao 」</p><p>长按二维码关注</p>", 
            "topic": [
                {
                    "tag": "创业", 
                    "tagLink": "https://api.zhihu.com/topics/19550560"
                }, 
                {
                    "tag": "创业项目", 
                    "tagLink": "https://api.zhihu.com/topics/19569726"
                }, 
                {
                    "tag": "互联网创业", 
                    "tagLink": "https://api.zhihu.com/topics/19557593"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35949092", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "树立自己的职场口碑", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5e1eab4e18305e05fd371f7625161ee9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"803\" data-rawheight=\"626\" class=\"origin_image zh-lightbox-thumb\" width=\"803\" data-original=\"https://pic2.zhimg.com/v2-5e1eab4e18305e05fd371f7625161ee9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;803&#39; height=&#39;626&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"803\" data-rawheight=\"626\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"803\" data-original=\"https://pic2.zhimg.com/v2-5e1eab4e18305e05fd371f7625161ee9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5e1eab4e18305e05fd371f7625161ee9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>每年的2-5月份属于招聘高峰，这也几乎是各家公司在一年中人员流动最大的时候。很多人会在这个时候去找一份新的工作，很多公司也会抓住这个时候去补充一些高级岗位。</p><p>在这样一个双方都有强烈意愿想要去达成交易的时期，对于求职者而言，能够影响到自己是否能成功入职到心仪公司和岗位的诸多因素中，我觉得有一条非常的重要，而这条也往往容易被求职者忽视，今天就来重点聊聊这个：</p><h2><b>职场口碑</b></h2><p>什么是职场口碑？简单来说，就是在职场上别人对你的认可度。这里的“别人”可以是你的直接领导、你的间接领导、你的同事、以及你的客户。</p><p>有人可能会想：”我承认职场口碑很重要，可是这跟面试找新工作有什么关系呢，新的工作不是更多的会看重简历吗“</p><p>有这种想法和认知的同学，要么就是对一些大公司完整的招聘流程还不太了解，又或者是你面试的岗位还比较初级。不然不可能不知道“背景调查”这回事。在应聘中，最容易凸显“职场口碑”价值的地方就是企业对候选人做的背景调查了。</p><p>在大部分正规公司和关键岗位上，除了正常面试流程以外，一般在发放offer之前，会有一个”背景调查“环节，尤其是在互联网公司，这个甚至已经是必须的环节了，越高级，越关键的岗位，在进行背景调查时，也会相应的越严格。</p><p>中小企业对候选人的背景调查可能就是人事部门或相关主管利用自己的一些行业关系基于候选人提供的资料进行一次审核工作。而大型知名企业的背景调查，往往会委托第三方机构进行背调，从而可能会更细致。无论哪种方式，一般都会包括向候选人前公司的上级或同事询问候选人的工作表现情况。</p><p>如果企业在做背调时，发现候选人的职场口碑/评价不佳时，很可能会选择不发放offer。但能进入到背调环节，往往也是候选人披荆斩棘，通过层层选拔之后了，若此时由于背调的原因错失机会，那就非常的可惜了。</p><h2><b>所以，我会一再对身边的朋友强调，在职场中，一定要注重好个人的口碑。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>如何树立职场口碑呢，我觉得起码要做到以下几点：</p><ul><li><b>1.诚信 </b><br/>建立信用可能需要很长一段时间，但毁掉信用，可能就是一件事，一瞬间的事情，所以一定要珍惜好自己的信用，在工作中一定要诚信对人对事（其实生活中也是）。 <br/>比如在工作中，不要轻易承诺自己无法做到的事情，承诺了就要努力去做到。这一点真的很重要，不要碍于面子去揽下自己无法完成的事情，不然到最后事情没搞定，反而会让人觉得不守信不靠谱。 <br/>如果你是Leader，同样，对于给下属的承诺也应该是实际的，可达成的，不应该短时间内为了激励而一味的画大饼，大饼有的时候需要画一点，但是也绝不能只画不落实，这也是有损职场诚信的地方。 <br/><br/></li><li><b>2.工作态度</b> <br/>对待工作的态度和责任心其实是一件很容易分辨的事情，是积极的去完成工作还是混日子，大部分职场人都能看清楚，在平时，大多数人也能做的不太差。但这里要重点提醒的一点是，有的人离职前的一段时间，消极怠工非常明显，工作交接也非常敷衍，也不怎么听安排了。可能他认为反正马上要离职了，这些都无所谓了，不再重视这些行为是否符合职业素养了，甚至也不在乎是否符合公司规章制度了。但是殊不知，往往正是这一行为，容易被团队人员给他贴上“工作态度差 ”，”不靠谱“的标签。 <br/><br/></li><li><b>3.操守 </b><br/>一定要有职业操守，不能因为公司或业绩，就做出败人品，无节操的事情。这跟话题非常大，总而言之，不能为了眼前的利益，而牺牲了自己的品性和操守。 <br/><br/></li></ul><p>职场口碑不是一天建成的，它来源于我们工作中的一点一滴，是一个慢慢积累的过程。</p><p>职场口碑这东西，大部分时候可能真的发现不了有多大的作用，它就像你在人行的征信一样，时时刻刻记录着，保存着，等到关键的某一天，等你想要发展的时候，往往会给你一个非常大的帮助。</p><p>希望我们一起 学会树立自己的个人品牌，珍视自己的职场口碑。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><blockquote>本文原创发布于微信公众号： <br/>「 bzsikao 」</blockquote><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/szlmfrrEM_dMrf4d92yh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/szlmfrr</span><span class=\"invisible\">EM_dMrf4d92yh</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "职场", 
                    "tagLink": "https://api.zhihu.com/topics/19557876"
                }, 
                {
                    "tag": "口碑", 
                    "tagLink": "https://api.zhihu.com/topics/19560426"
                }, 
                {
                    "tag": "工作", 
                    "tagLink": "https://api.zhihu.com/topics/19588006"
                }
            ], 
            "comments": [
                {
                    "userName": "明月清风与我", 
                    "userLink": "https://www.zhihu.com/people/5c18376a75b04644df1b9a7cb88112fe", 
                    "content": "我以前就是属于已经递交辞职报告之后就会开始非常敷衍工作的人，从没有认真考虑过工作上口碑的事情。这两天因为太忙反而有些地方做的不到位。领导委婉的说我了。然后还夸另一个同事在单位里口碑挺好的。<br>我才突然意识到，我自己是不是一直都在得过且过，所以才会在工作中表现的不那么好。而领导突然说起口碑，才让我意识到我的不到位可能会让我的职场口碑变差。唉，职场口碑真的这么重要吗？我们单位是一家60年了的老单位，里面人际关系错综复杂，每个人的一点点事情都可以流传几十年。作为一个今年的新进职工，除了你的文章外，我还有什么需要注意的吗？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "不止思考(奎哥)", 
                            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
                            "content": "<p>先改变心态。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "明月清风与我"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35530167", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "如何阅读一本书", 
            "content": "<p>要达到阅读的所有目的，就必须在阅读不同书籍的时候，运用适当的不同速度和方法。</p><p>在找来《如何阅读一本书》这本书的时候，我是以为在书中可以学习到如何快速看书的方法，以这个目的去买这本书的。但是当真正看完本书之后才发现，阅读不能只追求快，需要根据不同类型的数以及阅读的不同目的，采用不同的速度去看书，读的太快或太慢，都一无所获。</p><h2><b>阅读貌似是一件很简单的事情，但是并非所有人都在用正确的方式在阅读</b></h2><p>阅读是一种活动，我们在进行阅读的时候，必须要有一些主动的活力。拿同样的书给不同的人阅读，一个却读得比另一个人好这件事，首先，就在与这个人的阅读更主动，其次，在与他阅读中的每一种活动都参与了更多的技巧。</p><p>一般人阅读有2个目标：</p><ul><li>为了获得资讯而读</li><li>为了求得理解而读</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>读不同的书，用不同的技巧，可以帮助我们实现这2个阅读的目标。</p><p>想要增进阅读的技巧之前，一定要先了解阅读层次的不同，一共有四个层次的阅读：</p><ul><li>第一层的阅读：基础阅读</li><li>第二层的阅读：检视阅读</li><li>第三层的阅读：分析阅读</li><li>第四层的阅读：主题阅读</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>这四个层次的阅读是依次渐进的。下面分别来解释一下四层阅读的区别：</p><h2><b>基础阅读</b></h2><p>这个层次，也可以成为初级阅读，这个层次阅读的能力通常是在小学的时候就学会了的。只要能看得懂文字，明白每个句子的字面意思即可，并不用关心语句背后的意义。</p><h2><b>检视阅读</b></h2><p>这个层次的阅读可以称为略读或预读，其特点在强调时间，在这个阅读层次，必须在规定的时间内完成一项阅读功课。比如用十五分钟读完一本书。因此这个层次讲究是在一定的时间内，抓出一本书的重点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>检视阅读是系统化略读的一门艺术。</p><p>那如何去做系统化的略读呢，有几个建议：</p><ol><li>先看书名页，然后如果有序就先看序</li><li>研究目录页</li><li>如果书中附有索引，也要检阅一下</li><li>如果那是一本包着书衣的新书，不妨读一下出版者的介绍</li><li>从书的目录中，开始挑选几个看起来与主题息息相关的篇章来看</li><li>最后一步，把书打开，东翻翻西翻翻，念个一两段，有时候连续读几页，但不要太多，不要忽略最后的两三页</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>检视阅读看来简单，其实是一种需要非常主动的阅读，一个人如果不够灵活，不能集中精神来阅读，就没有办法很好的进行检视阅读。</p><p>在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于理解。</p><h2><b>分析阅读</b></h2><p>分析阅读就是全盘的阅读、完整的阅读，或者说是优质的阅读，比起前面提到的两种阅读方式，这种要更加复杂，更系统化。有的读者在使用这种阅读法的时候，多少会有些吃力。</p><p>如果说检视阅读是在有限的时间内，最好也最完整的阅读，那么分析阅读就是在无限的时间里，最好也最完整的阅读。</p><p>分析阅读的第一阶段:</p><ol><li>把书依照种类或主题做个分类</li><li>用最简短的句子说出整本书在讲些什么</li><li>列出全书最重要的部分，拟出全书的大纲</li><li>找出作者在问题的问题，或作者想要解决的问题</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>分析阅读的第二阶段：</p><ol><li>诠释作者使用的关键字，与作者达成共识</li><li>从最重要的句子中找出作者的主旨</li><li>找出作者的论述，明白作者的主张</li><li>确定作者已解决的问题，还有哪些是未解决的</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>分析阅读就是要咀嚼与消化一本书。分析阅读就是特别在追寻理解的。</p><h2><b>主题阅读</b></h2><p>最高层次的阅读，称之为主题阅读。是所有阅读中最复杂最系统化的阅读法。 <br/>在做主题阅读的时候，读者会读很多书，而不是一本书，并列举出这些书之间的相关之处，提出一个所有书都谈到的主题。</p><p>很显然，主题阅读是最主动，也是最花力气的一种阅读。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 bzsikao 」</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "阅读技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19629666"
                }, 
                {
                    "tag": "如何有效阅读一本书（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20125956"
                }, 
                {
                    "tag": "阅读习惯", 
                    "tagLink": "https://api.zhihu.com/topics/19566442"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35529496", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "聊聊腾讯传", 
            "content": "<p>这几天读《腾讯传》，感触还蛮深的。即使是这么大的一个巨无霸企业在创业和成长过程中都非常的不容易，而且创业的路上，运气这件事情还挺重要的。</p><p>书中提到马化腾做到的三件事，我挺认可的。虽然不一定是腾讯成功的决定因素，但是也绝对是成就腾讯今日的必要因素。</p><ul><li>腾讯对ICQ的模仿是建立在微创新的基础上的。虽然很多人一提到QQ项目，就会说它是对ICQ的抄袭（ICQ是一款以色列人开发的，后来被美国在线收购的即时通信工具），QQ对它的模仿是肯定的，但是在ICQ的基础上按照国内的环境做了很多的创新（比如好友列表、聊天记录存在云端而不是本地，要知道当初大家都是去网吧上网，如果像ICQ一样把好友存在本地，下次再去使用，所有内容都会丢失的，另外还有QQ独创了群聊功能等等，这些都是根据国情进行的微创新），这一点其实也提醒着后来众多模仿外国软件的创业团队应该学习的。</li><li>通过虚拟币解决支付问题，提出会员服务，形成了虚拟道具服务的创新，成为了全球最早的社区网络的试水者之一。</li><li>谋求资本市场的支持。在腾讯正缺钱，在马化腾正在满世界找钱的时候，风险投资在那个时候已经进入了中国市场，IDG、盈科、MIH在腾讯早期发展中起到了非常重要的资本输血作用。</li></ul><p>书中总结了马化腾的七种武器，非常棒的公司文化，确实值得我们去学习和思考。</p><p>1.产品极简主义 <br/>2.用户驱动战略 <br/>3.内部赛马机制 <br/>4.试错迭代策略 <br/>5.生态养成模式 <br/>6.资本整合能力 <br/>7.专注创业初心</p><p>这七个武器就不展开讲了，通过名字基本上也能明白思路。</p><p>腾讯的发展史，可以分为三大阶段。</p><p>第一个阶段为 创业，1988-2004年。</p><p>腾讯在1988年创立，于2004年在香港上市。马化腾家里的条件按照现在流行的方式来形容应该算是中产阶级。马化腾在深圳大学毕业后就去了润迅公司上班，在工作期间还自己搭建了惠多网的深圳分站，起名ponysoft，人称马站长，他也是中国的第一批互联网人。</p><p>在1998年，马化腾邀请大学校友马志东、陈一丹、许晨华、曾李青，五人一起创业，成立了腾讯。刚开始的目标是做“无线网络寻呼系统”，销售对象是全国各地的寻呼台。其实在那个时间点，寻呼机已经快是夕阳行业了。所以结果也可想而知，在一个缺乏成长性的产业里，任何创新都很难获得等值回报，因而是没有意义的。</p><p>然而就在创业陷入瓶颈的时候，以色列的ICQ产品出现的团队的面前（虽然马化腾在很早就开始听说过这个产品），引起了团队的重视，大家决定立项OICQ（后来改名为QQ），把它养起来。</p><p>OICQ的很多功能确实是模仿ICQ的，但它也做了很多创新的地方，尤其是在马化腾这位注重产品体验的人手上，确实是做出了自己的特点。不到半年的时候，OICQ就成为了华军软件园里下载量最大的软件了，随着用户量的暴增，各种挑战也随之而来，通讯没有加密的安全问题、服务器负载高的问题、lOGO和域名版权的问题，一时间，腾讯这家公司快养不起OICQ了，团队去了很多公司找钱，包括丁磊。但是在当时，没有人看得懂这个即时通信软件的商业模式，都不愿意投钱，直到他们遇到风险投资公司IDG与盈科，以及后来的MIH，这算是雪中送炭。并且这个雪中送炭非常的关键，时间点就在2000年互联网泡沫的前夕，如果再晚一点，恐怕腾讯不一定能拿到这笔救命钱。当然，拿到这笔救命钱之后，腾讯从此摆脱了资金短缺的困扰。</p><p>腾讯真正开始盈利，还是与中国移动合作的“移动梦网”开始的，梦网在当时几乎拯救了中国互联网。当时很多公司，包括网易搜狐等都在加入梦网项目。梦网占腾讯的最最主要收入，这其实非常的危险，所以腾讯也在不断的尝试其他商业模式，比如注册QQ账号收费、会员收费、QQ秀等，注册账号收费曾经让腾讯一时间饱受舆论的争议，还受到竞争对手乘虚猛烈的市场攻击，因此后才又转回了免费政策。但QQ秀确实一个非常成功的产品，符合中国人的文化，QQ秀让腾讯在“移动梦网”业务之外，寻找到了互联网增值业务的新的盈利模式。</p><p>高收入的梦网以及高活跃的用户，促使了腾讯在2004年的香港成功上市。</p><p>第二阶段为 出击，2005-2009年。</p><p>腾讯提出一站式在线生活，提出战略“互联网像水和电一样融入生活”，在这几年，马化腾试图全面接管中国网民的网络生活。从QQ秀、QQ空间、游戏、电商、广告 等领域四面出击。虽然在游戏方面腾讯失败了很多次，但也一直没放弃，才有了后来在游戏行业的成功。</p><p>在这个过程中，腾讯阻挡了各个大小互联网公司的各种IM工具的围剿，并且战胜了MSN。打胜MSN这场战役，其实与MSN自身有很大关系，一个跨国公司，在中国的分公司，受限的东西太多了。在微软的管理体系内部，罗川的市场部门与熊明华的研发中心分别向两个大区上司汇报，相当于在中国市场上，MSN没有一个统筹全局的负责人，并且MSN的技术研发方向被微软总部控制，开发需求需要层层审批，比如一个离线消息的功能中国分公司在2005年就提出了需求，却直到2008年才批准开发。所以在这场战役中，QQ充分占据了本土优势，完成了这场决胜。</p><p>在这几年，游戏和广告成为了腾讯新的2个金矿，进一步固定了腾讯的地位。</p><p>第三个阶段为 巨头，2010-2016年。</p><p>进入移动互联网时代，微信成功的提腾讯拿下来了移动互联网时代的“站台票”，加上手机QQ的自我变革，以及泛娱乐的环型生态，组成了一个巨无霸的腾讯巨头。</p><p>看完《腾讯传》，感想就是，创业不易。</p><ul><li>运气很重要 <br/>在创业转型中发掘了OICQ、在2000年互联网泡面前夕拿到风投资金、碰到了梦网这个拯救了中国互联网的业务、在移动互联网时代发掘了微信，等等，不能不说运气在其中有着不可言喻的作用。</li><li>坚持很重要 <br/>创业的道路始终没有放弃，在资金困难中坚持了下来，在游戏多次失败中坚持了下来，在新闻资讯远远落后的情况中坚持了下来，坚持了多年才有了商业模式，正是这些坚持才有了今日的腾讯。</li><li>努力很重要 <br/>努力是当做那个创业团队中的每一个人的特质。很牛逼的团队。</li></ul><p>另外，再给大家一个激励，5个创始人中，4个是技术出身，技术出身也很有优势。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>本文原创发布于微信公众号「 bzsikao 」</blockquote>", 
            "topic": [
                {
                    "tag": "互联网创业", 
                    "tagLink": "https://api.zhihu.com/topics/19557593"
                }, 
                {
                    "tag": "腾讯", 
                    "tagLink": "https://api.zhihu.com/topics/19550757"
                }, 
                {
                    "tag": "书籍推荐", 
                    "tagLink": "https://api.zhihu.com/topics/19550376"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34177671", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "技术人更应该关注保险保障", 
            "content": "<p>其实想给大家普及的意识是，人人都应该买保险，人人都应该学会用保险来做一定程度的风险规避。在发达的国家，保险是一件非常普及的事情，但是在中国，由于各种原因，保险并没有被国人普遍接受。大多数人对保险的认识，还处于一种很原始的状态，或者干脆将保险误解成是骗人的东西。如果还是处于这种层次的理解，那么我们真的应该花点时间好好的去了解了解保险了。</p><p>尤其是对于技术人而言，保险这还是一件蛮重要的事情，因为技术人加班多啊，健康透支也严重啊，而且大多数技术人还是家庭主要经济支柱，更需要保障。</p><p>保险本质上是一种风险转移工具，能将你承受不起的风险转移给保险公司。就是用少量的钱买一份心安，希望保险永远都用不上。</p><p>这里的保险指的是 医疗险、意外险、重疾险、寿险等。并不是指理财保险，理财保险只是具有一个长期理财的功能特殊险种，并不能对人身健康起到保障作用，所以不在本文讨论范围内。</p><p>这篇文章是想跟大家聊聊，一个技术人的家庭应该怎么去做一份合理的保险配置。</p><h2><b>保险配置顺序</b></h2><p>发现大多数人对保险的了解，都是从有了小孩之后开始关注的，身边的很多同事朋友都是这样。我也是有个小孩之后，开始了解并且研究如果购买商业保险的。但是一个正确的购买商业保险的顺序其实是：先大人，后小孩，优先考虑家庭经济支柱。</p><p>大部分喜欢先给孩子买，其实父母才是孩子最大的保障，优先考虑保障家庭经济支柱，万一发生意外，也能最大限度缓解家庭状况，维持正常生活。当然，有条件的，建议全部家庭成员都进行保险保障。</p><h2><b>保险的分类</b></h2><p>保险主要有 社保保险 和 商业保险。 <br/>社保保险是每一个参加工作的人都缴纳的保险保障，是国家要求的，也是一种最基础的保障制度。非常重要，但它并不全面，比如自费药/进口药不报销，有比例有限额等等。因此，就有了商业保险的诞生。 <br/>商业保险是一种对社会保险的补充。商业保险可细分为：医疗险、意外险、重疾险、寿险等。</p><ul><li>医疗险</li></ul><p>医疗险，顾名思义，就是用于报销医疗费用的保险。有针对住院医疗进行报销的，有针对门诊医疗进行报销的，有大额度的，也有小额度的，价钱不等。拿住院医疗保险举例，只要是投保人生病入院了，并且符合保险中的一些规定，出院后就可以拿着发票找保险公司去报销。不同险种的规定都不同，比如有的要求医院等级达到什么要求、有的有用药范围的要求等等。</p><p>这里对技术人推荐一种医疗保险，一般概括称为 “百万医疗险”，很多保险公司都有这类保险，各家的名字可能不一样，年轻人投保很便宜，几百块钱，可以去搜索看看。</p><ul><li>意外险</li></ul><p>意外险，一般是保障意外身故、意外伤残、意外医疗的。如果发生意外导致身故、伤残了就按照伤残等级进行一次性赔付金额，如果是意外导致的治疗，那就是按照治疗费用进行报销。每一款险种都有一些细节上的区别。</p><p>这里推荐消费性综合意外险，几乎每家保险公司都有类似产品，名称不同，可以仔细对比。消费性意外险100万保额一年大概只需要三四百块钱即可，应该是年轻人最先考虑购买的保险。</p><ul><li>重疾险</li></ul><p>重疾险，就是在被保险人发生“重大疾病”时，保险公司一次性赔付一定的进行金额。哪些疾病属于“重大疾病”，在保险中是有明确的规定的。这个险种稍微贵一点，但是也是最应该配置的保险之一。</p><p>推荐购买消费型重疾险，一般30岁左右男性，购买50万额度的重疾险，保障到终生的话，大概需要几千块钱一年。每个保险公司的产品不同价格也不同。</p><ul><li>寿险</li></ul><p>寿险是保障身故的，被保险人如果身故，保险公司就会赔付一定额度保险金，其实是给被保险人家人的。很多技术人员是家庭的主要经济支柱，可以考虑补充这种保险。</p><p>推荐购买消费性寿险，一般30岁左右男性，购买50万额度的寿险，保障到终生的话，大概需要几千块钱一年。每个保险公司的产品不同价格也不同。</p><p>商业保险有 消费型 和 返还型，消费型的一般便宜一些，纯保障，返还型的在一定的年限后还会把当初交的保费还给客户，因为贵一些。具体的选择还是要看险种和家庭情况。</p><p>无论是哪个险种，一般在投保之前，保险公司都要求投保人是健康体，也就是在投保之前要向保险公司告知自己的身体健康情况，满足保险公司的健康要求才能投保，所以保险购买越早越好。</p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "保险", 
                    "tagLink": "https://api.zhihu.com/topics/19562045"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34108256", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 1, 
            "title": "作为技术Leader，一定要坚持己见", 
            "content": "<p>最近一直在思考 “坚持己见” 这件事情。如题，这就是我的观点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是当我准备写这篇文章记录下我的想法的时候，又突然觉得，这个事情，也许还得分人来看。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有的Leader，本身性格就是比较自嗨型，一旦有个想法就容易陷入固执，不太容易听得进其他人的意见。这种情况下，再鼓励他一定要坚持己见，恐怕不太妥。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有的Leader，想法比较多，考虑的也比较多，一个问题思前想后，不同人给的意见都会去斟酌一下，一不小心就可能受到外界误导。这种时候是最应该鼓励他坚持己见的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在实际工作中，上述两种类型的Leader，可能我们都遇到过。不过这里我重点聊聊第二种。因为我认为坚持己见应该是一个技术领导者必备的素质。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>坚持己见，说起来好像挺简单的，但是做起来是否能真如此呢。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>举个例子，在一些大公司环境下，作为技术Leader，经常会受到多个业务方提出的需求和建议，甚至同时会收到多个领导提出的要求，其中也许还不乏有冲突的地方。那这个时候该怎么办？多方妥协？明显这不是一个正确的办法，更别说互相冲突的意见往往是无法找到妥协点的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>完全置之不理？也貌似也不是一个职场环境下，一个职业Leader该有的行为。</p><p>那此时应该怎么做呢，从方法的角度有很多。大多人一般会建议收集各方意见、分析问题根源、反复论证、换位思考，再根据适合当前条件或未来方向的方案权衡利弊，等等。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但这些都是属于 “方法”。Leader在依据这些方法去处理任何事情的时候都必须有一个核心的思想：基于自身的认知对所持观点的坚持和判断。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>引用《如果》的一段话：<br/>如果众人都失去理智，苛责于你，<br/>你仍不乱条理；<br/>如果众人都怀疑你，<br/>你仍能坚信自己，泰然处之；<br/>如果你要等待，不要因此厌烦，<br/>为人所骗，不可骗诳，<br/>为人所恨，不可愤然，<br/>戒张扬，戒虚妄；</blockquote><p></p>", 
            "topic": [
                {
                    "tag": "团队管理", 
                    "tagLink": "https://api.zhihu.com/topics/19578375"
                }, 
                {
                    "tag": "技术管理", 
                    "tagLink": "https://api.zhihu.com/topics/19624229"
                }, 
                {
                    "tag": "互联网公司", 
                    "tagLink": "https://api.zhihu.com/topics/19608437"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34108196", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "一对一沟通", 
            "content": "<p>聊一聊在工作中的一对一沟通。</p><p>先说结论，IM工具越丰富，我们越需要一对一的面对面交流，尤其是在工作中。</p><p>现在互联网软件这么丰富，各种IM工具发达，企业QQ、TM、微信、钉钉，交流起来真的很方便，效率也很高。但是这种交流是缺少触觉的，是无法捕捉到对方的表情和肢体语言的，很难以做深入沟通的，更别提安全感了。</p><p>我一直都很赞成和提倡，在工作中，多多进行一对一沟通，尤其是管理者和下属团队成员。</p><p>管理者和成员的沟通，一定要以成员为核心，聊成员感兴趣的话题，多听成员说，自己少说。</p><p>对于刚入职还在试用期的新人来说，这种沟通对于新人的融入或是管理者对新人的了解都是很有帮助的，至少每个月进行一次，理应作为管理工作中很重要的一部分。</p><p>对于老员工而言，他们更希望通过面谈获得更多的信息，比如公司决策、企业文化、产品和项目信息等。同时由于老员工在公司的时间比较长，他也会有很多诉求，也能提出很多问题和建议，这些都非常适合在面对面一对一场景时进行沟通。</p><p>以一个10人的团队为例，每人每月沟通半个小时，那么每个月会占用团队负责人5个小时的时间。但不要觉得时间是被浪费，在团队成员身上花的这30分钟，很有可能会提升他接下来一段时间的工作品质。同时也可以使负责人学习和了解更多的东西，这是一项非常值得的投入。</p><p>一对一沟通主要的目的在于互通信息以及彼此学习，经过对特定事项的讨论，团队负责人可以将其技能和经验传授给下属，并同时建议他切入问题的方式。而下属也能对工作中碰到的问题进行汇报。</p><p>建议在谈话内容上不要做过多的约束，这里抛砖引玉，可以聊的话题很多：</p><ul><li>当前项目进展</li><li>对产品的想法（有哪些可以提高的地方）</li><li>对团队的建议</li><li>个人绩效</li><li>工作中挑战、有没有阻力</li><li>技术和业务的探讨</li><li>最近的生活和家庭状况</li><li>个人未来一段时间的计划</li><li>情绪上的问题</li><li>需要团队Leader给予的支持</li></ul><p>上述等等都可以作为沟通的思路。 </p><p>虽然不一定每次都有很值得讨论的话题，但是保持这样一个通畅的交流渠道和方式很有必要。</p>", 
            "topic": [
                {
                    "tag": "沟通", 
                    "tagLink": "https://api.zhihu.com/topics/19566252"
                }, 
                {
                    "tag": "职场沟通", 
                    "tagLink": "https://api.zhihu.com/topics/19662729"
                }, 
                {
                    "tag": "互联网企业管理", 
                    "tagLink": "https://api.zhihu.com/topics/19563591"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34108109", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "时间都去哪儿了-技术人员的时间管理", 
            "content": "<p>是不是有这样一种感觉，明明一天开始的时候计划要做很多事情，但是忙忙碌碌一天之后发现，杂七杂八的事情做了一堆，重要的事情却一件没完成。</p><p>时间不知不觉溜走了，事情还是那么多，而且一天下来，还真的挺累的。所以很多人对时间有一种莫名的焦虑。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>老天给了所有人同样多的时间，而有的人能够把时间用好，有的人却不能把时间用好。日积月累，人和人的差距就越来越大了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>就拿写一篇文章举例，其实专注的投入，可能一个小时就能搞定，但经常拖拖拉拉，写的过程中，时不时看看邮件，看看IM消息，时不时的处理一下大脑中突然冒出来的各种事情，等回过神来，哇，一个下午又过去了，文章才写到一半。时间就是这样悄悄不见的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有的同学说，这是时间管理的问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这句话，其实只答对了一半。时间固然是需要合理的去管理。但每天24小时，每个人都是公平的，不会多一分也不对少一秒。</p><p>我们常常听到一个人说，他已经非常忙了，某某事情实在是无精力去做。</p><p>恰好是这句话，让我思考到，我们其实要追求在固定的时间内，完成更多重要的事情，那么时间管理的本质就不再是对时间进行管理了，而是在对精力上进行管理。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>能做好时间管理的人，其实就是管理好了他的精力。一个人要完成大量工作，重点其实不在于要投入多少时间，而在于要投入多少精力和注意力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>尤其是对于技术同学，互联网技术革新这么快，每个月都有新的技术、新的框架出现，我们除了需要掌握好已熟知的领域外，还需要不断的去学习新的技能。这对技术同学的时间管理，提出了更高的要求。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>从大的方面来讲，我们应该</p><p>1、主动掌控时间，而不是被动的随时间驱动</p><p>2、学会说“不”，做好任务的分类分级</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我不太想把这两点展开来讲，会容易觉得太理论。所以我这里直接上手，介绍一种自我效率的管理方式：番茄工作法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>先用一句话来介绍它：</p><p><b>番茄工作法 是一套简单的工具和流程，可以用来提升个人和所在团队的生产力。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>番茄工作法，它要求一次只做一件事情。</p><p>它的方法能让我们减轻对时间的焦虑，不会再因为离任务指定时限越来越近而充满焦虑，我们要做的就是定好25分钟番茄钟，然后全然专注于手头上的任务即可。如果25分钟后番茄铃声响起，此时任务已完成，那非常完美，可以休息并继续下一个任务了。但如果铃声响起时，任务没有完成，那也不要紧，因为我们已经全神贯注的高效工作了25分钟，此时的铃声正是为了这高效的25分钟所喝彩，此时也不再会有时间焦虑。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>我们为什么要用番茄工作法呢，</b></p><p>上面写文章拖拉的例子就是一个典型，我们在做事情的时候，有时很难以集中于单项活动，头脑中的其他想法不停的往外冒，我们会不停的切换上下文去处理别的事情。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>尤其是对于有拖延症的人，在面对复杂的事情的时候，一想到某个任务要花很多时间很多精力，甚至就连开始去做的勇气都没有。还有时候，做事情想到哪儿做到哪儿，到最后，重要的事情一件没做，一天都处理琐碎事情去了。说到这里，是不是很有感触？有没有找到自己的影子？</p><p>没关系，我们用番茄工作法来解救你。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>好了，那我具体来讲讲 什么是番茄工作法：</b></p><p>用一句话简单描述就是，列出你当天要做的任务清单，设置25分钟闹钟，然后按照优先级依次开始。</p><p>当然，除此之外，还有每日回顾、控制中断、预估时间、休息设定等等，后面都会一一详细讲到。</p><p>不过。真心讲，番茄工作法，是一种简单到令人发指的工具方法，它的方式还可以根据你的需要随时进行调整。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>那如何使用番茄工作法呢，</b></p><p>在使用番茄工作法之前，我们需要准备一些简单的工具：</p><ul><li>一支笔</li><li>一个番茄钟（可以用厨房定时器/手机APP等）</li><li>三张纸（一张用于“活动清单”，一张用于“今日任务清单”，还有一张用于记录数据优化流程的表）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>详细解释一下这三纸：</p><p>1、活动清单：一个活动写一行，用剪短的语言来描述活动，如果这个活动有时间期限，那么可以在活动的后面加上期限的时间点。</p><p>例如：</p><p>#发邮件给haha</p><p>#写一篇关于AI的技术文章  19:00</p><p>#调研某一款产品</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、今日任务清单：每天早上从“活动清单”中提取今天需要进行的任务，放到“进入任务清单”即可，格式同上。</p><p>在这个清单里面的内容，就是承诺今天会去完成的事情，如果某件事情不打算今天做，那么就不要放到这个清单里，所以也需要对自己一天的工作量有一个合理的评估，对时间评估把控可以在开展番茄工作法的过程中不停的调整。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3、记录表：每天晚上记录一下当天完成了多少个番茄钟，并且中断了多少次，有多少任务是在当天没有完成的，对每一项任务评估的番茄钟数合不合理，以便第二天改进。</p><p>番茄工作法是一套典型的PDCA流程：Plan（计划）、Do（执行）、Check（评估）、Act（应用）</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>番茄工作者每天也是要按照这四项进行：</b></p><p>1、计划：</p><p>首先需要准备一份“活动清单”，将脑海中接下来一周要进行的任务全部记录到“活动清单”。每天早上，从“活动清单”中提取今天要进行的重要任务，填入到“今日任务清单”。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、跟踪：</p><p>早上开始的时候，从当天的“今日任务清单”中按照重要程度开始每一项任务，每隔25分钟休息一次（每25分钟称为一个番茄钟），如果在番茄钟期间被其它事情中断了，记录下中断次数。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>每完成一个番茄钟，就需要进行5分钟的休息。休息的时候是需要完全的放下手上的工作，番茄钟一响，就在30秒之内迅速完成手上的事情，如果是在写文章，多一个字都不要再写，远离任何的智力思考活动，让大脑完全放松，可以是到处转一下、喝点茶水咖啡等。千万不要无视休息的重要性，有规律的工作与休息才能持久的实现高效率。休息完成之后，你可以决定继续刚才的任务，还是从“今天任务清单”中挑选另外一件更重要的任务进行。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>除了这种常规小休息以外，番茄工作法还要求，每4个番茄钟之后，要进行一次阶段性休息，这种阶段性休息通常是15-30分钟，这个休息时间可以做稍长时间的消遣，比如看看新闻、运动运动之类的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>要注意的是，在番茄工作法中，一个番茄钟就表示25分钟的努力，番茄钟是一个原子单位，不可分割，在每个番茄钟内专注的只做一件事，也不要中途停下来休息，不然会打乱节奏。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3、记录：</p><p>每天结束时，记录下当天完成的番茄钟个数以及中断次数</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在做一件事情的时候，其实经常容易被其它事情打断，可能来源于外部打断（外部事件干扰，例如同事过来沟通），也可能来源于内部打断（比如大脑中突然冒出某个想法要去做），这些都称之为中断，其实我们工作的记忆容量有限，每一次的干扰都会让我们大脑的信息、注意力丢失，相当于电脑CPU的上下文切换，要找回刚刚的大脑状态，需要付出额外的精力。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么针对中断，应该怎么处理呢？</p><p>如果是内部中断，比如大脑中突然冒出一个要做的事情，此时并非停止手上的任务去做，而是应该将大脑冒出的那件事填入到“今日任务清单”中，并标注上，属于“计划外紧急”，每一次中断都需要做一次符号标记（例如用~号，方便一天结束时统计），这种处理方式简单来说就是：接受它，记录它，然后立即继续手上任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果是外部中断，因为外部中断具有互动性（例如是有同事过来找你沟通事情），如果是可以协商到稍后处理的事件，那么可以参考内部中断的处理方式（不过需要采用不同的符号标记），如果外部中断的事情非常紧急，需要立即处理，那只能中断当前的任务，投入新的任务中去，但是同样需要记录到“今日任务清单”中，且标记上“计划外紧急”，同时因为当前在进行的番茄钟的任务被放下了，那这个番茄钟必须作废，重新一个番茄钟来开始它。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4、优化：</p><p>通过每天的记录，找出改进流程的思路，例如评估任务的时间是否合理、每天任务数是否合理，工作和休息间隔的时间是否合理等等，按照自己的工作习惯，进行自我调整。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>番茄工作法的特点是可以根据每个人的不同，定期调整工作和休息的间隔时间以及记录的方式，这些节奏都可以根据实际情况优化。但是如果你是刚学会番茄工作法，那么建议你坚持使用常规的方法，至少两周内不要做任何改动。你需要亲身经历，以便确切的知道哪里适合你，哪里不适合。</p><p>其实时间管理，不在于你一天内完成了多少个任务，而在于每一个任务的执行期间，你是否都在尽力专注的去做。一次只做一件事情，这就是番茄工作法的精髓。</p>", 
            "topic": [
                {
                    "tag": "时间管理", 
                    "tagLink": "https://api.zhihu.com/topics/19550921"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }, 
                {
                    "tag": "研发", 
                    "tagLink": "https://api.zhihu.com/topics/19552045"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34107876", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 4, 
            "title": "如何应对线上故障", 
            "content": "<p>线上故障是我们技术同学经常遇到，也是技术成长中经常要经历的事。从故障中我们可以吸取到很多教训，变得越来越有经验。</p><p>但是并不是每一个团队/技术同学在应对故障的处理方式上，都能做到合理和科学。</p><p>下面就从工作中遇到的实际情况，结合最近读陈皓文章心得，来聊一聊我对线上故障处理的看法。</p><p><b>故障发生时的处理：</b></p><p><b>1、快速定位故障</b></p><p>在复杂的系统架构中，尤其是微服务架构中，一旦发生故障可能会出现“多米诺骨牌效应”，系统会由一个故障点波及到其他关联的模块。 <br/>那么一旦定位不及时，不仅仅会扩大故障，还可能会由于多个模块都在报错、报警，给故障源的定位带来困难。</p><p>因此我们要有一套快速的故障定位方法。我比较推荐的就是 全链条投入排查。即一旦发现线上故障，当前系统以及相关系统所对应的开发、运维、测试等方向，各抽调对口人，全都叫到线上去处理问题，各自排查各自模块/服务，如果排查自己负责的范围没有问题就可以在旁边待命，以备在需要的时候进行配合。重点就是从一开始就一起介入。</p><p>不要小看这一点，看似平淡无奇，但实际场景下，要能保证有序的这么去做到，还是挺难的，亚马逊都是通过一套制度和任务分配系统来保障这种全链路排查方案得以持久实施的。</p><p>其实这么做的目的就是在跟故障抢时间。</p><p>我们平时大多数情况下是怎么做的呢，收到一个线上功能的错误报告，然后对应功能的前端同学开始排查，排查了半天，发现是后端接口不正常，将问题转到后端同学继续排查，后端同学经过一段时间排查后，发现是运维问题或者是依赖的其他模块的问题，就再次将问题转到运维或者其他项目组，然后后者接手开始排查。这样来来去去，等定位到真正故障源的时候，黄花菜都凉了，不仅导致服务长时间的不可用，而且故障随着时间的推移也在不断扩大波及面，问题也越来越难以定位。</p><p><b>2、故障止损和恢复</b></p><p> 在故障源定位之后，一般恢复系统的常用手段无非下面几种：</p><ul><li>重启：部分问题是可以通过重启的手段来临时恢复的，以保障系统的暂时可用，但后续还需有其他方法彻底解决问题</li><li>限流和降级：这其实还是一个临时手段，通过将部分非核心系统进行降级和限制流量处理，来避免核心业务受到影响</li><li>回滚：如果属于更新的代码BUG导致的问题，一般可通过回滚上一个程序版本来迅速恢复，不过会导致部分新功能不可用</li><li>紧急更新：这个方式会经常被用到，明确定位问题源后，迅速修复代码或组件，然后快速更新上线，比较依赖整个团队的上线协同能力</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>故障发生前的准备</b></p><ul><li>设定故障等级：这是一个所有项目共同认定的等级划分，一般无须为单独项目设定</li><li>服务-资源图：需要针对项目有完整的服务与资源对应图，以便能速查</li><li>项目指标和应急方案：给系统设定风险阈值，超出阈值有应急方案提前准备着</li><li>故障演练：针对特定的重大的风险点，进行演练，以验证上述的应急方案可用性</li><li>灰度发布：也就是对要发布的新版本进行A/B测试，是一种非常有效的产品验证和功能改进的方法</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>故障发生后的复盘</b></p><p>说到故障后复盘，离不开的一个话题就是程序员的追责和惩罚。这其实是另一个要讨论的主题了，不过这里，我简单的描述一下我的观点：对于线上事故，理应追究责任，但无需惩罚（特别严重的问题或特别不能容忍的错误以外），最重要的其实是做好善后工作，避免下次再犯，从根本上反思，刨根问底，找出问题的根源。这其实也就是下面要聊到的 “Ask Some Whys”。</p><p>重点来聊聊复盘要做的事情吧</p><ul><li>记录故障处理全过程： <br/>需要详细的记录下故障发现的时间，什么途径发现的，用了什么样的排查手段，什么样子的处理流程，处理过程中，几点几分做了什么事情，将整个过程都一一的记录下来。</li><li>分析故障原因： <br/>需要将团队成员聚在一起，进行讨论，分析故障发生的原因，这里的原因不是指表象的原因，需要剖析出问题的根源。</li><li>故障整改计划： <br/>针对当前故障要做哪些改进措施，应对类似问题，如何预防。给出可实施的方案以及时间计划。同时对故障等级进行认定，以及团队成员责任的追究和备案（但不提倡惩罚）。</li></ul><p>另外就是 <b>Ask Some Whys</b>： <br/>多问几个为什么，这也是需要团队成员在一起问自己和问对方的。比如：为什么没有进行灰度发布（如果灰度发布能避免问题的话），为什么测试没有覆盖到，为什么故障处理耗时这么久，等等，根据当前故障进行层层反问和深挖。</p>", 
            "topic": [
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }, 
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "运维", 
                    "tagLink": "https://api.zhihu.com/topics/19560830"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/34095356", 
            "userName": "不止思考(奎哥)", 
            "userLink": "https://www.zhihu.com/people/1ae2f7b665a4f4d0aae082b0ab823369", 
            "upvote": 0, 
            "title": "聊聊区块链", 
            "content": "<p>在聊区块链（Blockchain）之前，我先推荐两本书，《区块链 从数字货币到信用社会》、《区块链 技术驱动金融》。 <br/>前一本是属于概念普及型，适合概览的去了解区块链，从区块链的基础到智能合约、以及应用都全面的进行了介绍，通俗易懂。后面一本就稍微深入一些，讲解了基本技术原理、算法、生态，但读起来也没有什么门槛。建议两本结合起来读，会对区块链理解的更为深刻一些。这两本书我都读过，所以这篇文章也算是一个读书心得。</p><p>区块链技术的产生和发展是离不开比特币的。因为比特币的诞生，区块链才得以公布于众，而且到目前为止，比特币还是区块链技术最成功的应用。但需要注意的一点是，比特币里的区块链是为比特币体系所定制的，所以比特币的区块链技术并不完全等同于区块链技术。目前基于区块链技术所实现的加密数字货币有上百种，但比特币的市值占所有加密数字货币市值的90%，比特币最为主流。</p><p>说到区块链，都是知道区块链的几个特性：去中心化、公开透明、可追溯、匿名性、不可篡改等。那区块链到底是什么呢，用一个专业的术语描述应该为：</p><blockquote>区块链是一个去中心化的分布式数据库，该数据库由一串使用密码学方法产生的数据区块有序链接而成，区块中包含有一定时间内产生的无法被篡改的数据记录信息。</blockquote><p>区块链有哪些分类呢，可以范围三大类：</p><ul><li>公共区块链：所有人都可以访问、发送交易。例如比特币、以太坊等</li><li>共同体区块链：又称为联盟链，参与的节点是有约定的、合作关系。例如超级账本、区块链联盟R3CEV</li><li>私有区块链：参与的节点只是有限范围、特定用户。例如Eris Industries</li></ul><p>区块链的工作流程主要有以下步骤：</p><ol><li>发送节点将新的数据记录向全网广播</li><li>接收节点对收到的数据记录信息进行检验，比如记录信息是否合法，通过检验后，数据记录将被纳入一个区块中</li><li>全网所有的接收节点对区块执行共识算法（有工作量证明法、权益证明法等）</li><li>区块通过共识算法过程后被正式纳入区块链中存储，全网节点均表示接受该区块，而表示接受的方法，就是将该区块的随机散列值视为最新的区块散列值，新区块的制造者将以区块链为基础进行延长</li></ol><p>如果是没有接触过比特币的同学，对上述流程可能不太容易理解，这里我就以比特币举个例子：</p><ol><li>先简单的说说节点，节点分为发送节点和接收节点，发送节点在比特币体系里就是用于提交交易信息的用户，如果有新的交易要提交，那么发送节点就会在比特币网络进行交易信息的广播。接收节点在比特币体系里面就是通常指矿工，矿工是需要一直监听比特币网络里是否有交易广播。</li><li>矿工收到广播的交易信息后，需要校验这个信息的签名等内容是否合法。如果校验通过后，就需要将收到的所有交易信息按照一定的规则组装成一个数据块，也就是区块。</li><li>刚刚组装的区块还只是在自己这里，还未被纳入比特币网络中正式的区块链中。如何才能被正式纳入呢，这里就涉及到共识算法了。因为每个矿工都可能组装了自己的区块，在每10分钟之内，只可能有一个区块被纳入正式区块链，那么所有的矿工就要根据规则在最短的时间内使自己的区块被其它矿工认可，谁最先做到，那么谁的区块就会被正式纳入。</li><li>能纳入区块链的规则就是共识算法，比特币中使用的共识算法是工作量证明法，即让所有的矿工都去寻找一个随机数，这个随机数是通过Hash算法算出来的，并且算出来的随机数需要满足一定的条件才是大家认可的随机数（需要满足该随机数能使整个区块的哈希值小于目标值），谁先计算/猜到这个随机数，它的区块就能被全网接受。</li><li>然后这个区块就可以纳入正式区块链，放到链条的最后面，然后各个节点再开始挖下一个区块，就这么一直接龙下去。</li><li>能挖到有效区块的节点，是可以获得奖励的，这个奖励主要有2部分组成，一个是比特币体系约定的，目前是每挖到一个奖励25比特币，另一个奖励就是交易手续费了，前面提到了交易信息的提交节点需要付这一笔交易手续费，也是比特币的形式。</li></ol><p>通过以上，应该可以对区块链技术流程有一个初步的认识了。</p><p>但聊到区块链，就不得不提起一个重要的概念“智能合约”，区块链技术的可支持编程合约、具去中心化、不可篡改、透明可追踪等优点天然适合于智能合约。也可以说，智能合约是区块链技术的特性之一。</p><blockquote>智能合约：是一套以数字形式定义的承诺，承诺了数字资产并包含了合约参与者约定的权力和义务，由计算机系统自动执行。</blockquote><p>智能合约是区块链中非常重要的一个特性，内容也非常的多，就不在本文中详述了，有兴趣的同学可以找一下相关资料深入研究一下。</p>", 
            "topic": [
                {
                    "tag": "区块链(Blockchain)", 
                    "tagLink": "https://api.zhihu.com/topics/19901773"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/bzsikao"
}
