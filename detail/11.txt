{
    "title": "linux系统编程", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/zjun-1", 
        "https://www.zhihu.com/people/he-zheng-e", 
        "https://www.zhihu.com/people/li-qing-15-6", 
        "https://www.zhihu.com/people/helbing", 
        "https://www.zhihu.com/people/no-die-no-do", 
        "https://www.zhihu.com/people/eval-60", 
        "https://www.zhihu.com/people/viggo-97", 
        "https://www.zhihu.com/people/rubuspi", 
        "https://www.zhihu.com/people/cang-feng-55-98", 
        "https://www.zhihu.com/people/shuai-tian-qiang", 
        "https://www.zhihu.com/people/stayrichcool", 
        "https://www.zhihu.com/people/mai-di-9-77", 
        "https://www.zhihu.com/people/yijiu-7", 
        "https://www.zhihu.com/people/chen-you-13-25", 
        "https://www.zhihu.com/people/yang-yong-le-89", 
        "https://www.zhihu.com/people/chen-yuan-jiang-85", 
        "https://www.zhihu.com/people/du-qi-7-72", 
        "https://www.zhihu.com/people/ruide", 
        "https://www.zhihu.com/people/liu-hai-80-19", 
        "https://www.zhihu.com/people/xu-jiong-27", 
        "https://www.zhihu.com/people/qhethe-qhethe", 
        "https://www.zhihu.com/people/ping-ye-5", 
        "https://www.zhihu.com/people/haohaohao-42", 
        "https://www.zhihu.com/people/zi-xu-san-ren", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/sun-xiao-hu-13-13", 
        "https://www.zhihu.com/people/bo-si-xian-sheng-14", 
        "https://www.zhihu.com/people/tianrui007", 
        "https://www.zhihu.com/people/fuyecheng", 
        "https://www.zhihu.com/people/sunnyos", 
        "https://www.zhihu.com/people/xu-han-san", 
        "https://www.zhihu.com/people/ping-you-l", 
        "https://www.zhihu.com/people/peng-jin-yi", 
        "https://www.zhihu.com/people/123-21-60-23", 
        "https://www.zhihu.com/people/gao-chang-chun-36", 
        "https://www.zhihu.com/people/jiang-yi-feng-953", 
        "https://www.zhihu.com/people/herry-57", 
        "https://www.zhihu.com/people/zhang-tong-xue-85-36", 
        "https://www.zhihu.com/people/zhang-chi-chi-43-31", 
        "https://www.zhihu.com/people/zhang-xin-hao-11", 
        "https://www.zhihu.com/people/dong-sheng-91", 
        "https://www.zhihu.com/people/artichoke", 
        "https://www.zhihu.com/people/sole_cc", 
        "https://www.zhihu.com/people/jinkuaikuai", 
        "https://www.zhihu.com/people/dong-fang-qing-yang-94", 
        "https://www.zhihu.com/people/zsmj-83-87", 
        "https://www.zhihu.com/people/zhang-feng-82-38-55", 
        "https://www.zhihu.com/people/geng-yan-yong-9", 
        "https://www.zhihu.com/people/li-chun-hui-79", 
        "https://www.zhihu.com/people/li-jie-cheng-1", 
        "https://www.zhihu.com/people/simon-33-58", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/te-si-la-de-deng-pao", 
        "https://www.zhihu.com/people/yan-chi-man-zu-15", 
        "https://www.zhihu.com/people/jcyongqin", 
        "https://www.zhihu.com/people/wang-lei-46-12", 
        "https://www.zhihu.com/people/huang-fu-sheng-97", 
        "https://www.zhihu.com/people/xiao-wang-11-9-78", 
        "https://www.zhihu.com/people/zhang-tao-60-41", 
        "https://www.zhihu.com/people/wangzhigang1101", 
        "https://www.zhihu.com/people/qiu-yu-44-47", 
        "https://www.zhihu.com/people/yu-hua-deng-xian-52-11", 
        "https://www.zhihu.com/people/mel-tor", 
        "https://www.zhihu.com/people/zhu-xuan-71-88", 
        "https://www.zhihu.com/people/zxloas", 
        "https://www.zhihu.com/people/jin-ji-de-meng-yuan", 
        "https://www.zhihu.com/people/zhan-jia-rong-46", 
        "https://www.zhihu.com/people/dansesu", 
        "https://www.zhihu.com/people/liu-jian-62-78", 
        "https://www.zhihu.com/people/beltor", 
        "https://www.zhihu.com/people/liu-liu-59-80-38", 
        "https://www.zhihu.com/people/yang-jian-feng-85-30", 
        "https://www.zhihu.com/people/forests-blazing", 
        "https://www.zhihu.com/people/yao-chen-1", 
        "https://www.zhihu.com/people/meng-ya-21-65", 
        "https://www.zhihu.com/people/guo-de-gang-43-86", 
        "https://www.zhihu.com/people/lu-ren-jia-53-32", 
        "https://www.zhihu.com/people/xie-xiao-yang-47", 
        "https://www.zhihu.com/people/lawrence-82-54", 
        "https://www.zhihu.com/people/roachsinai", 
        "https://www.zhihu.com/people/matnix", 
        "https://www.zhihu.com/people/jkhenryer", 
        "https://www.zhihu.com/people/michaelww-24", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/jian-zhi-jiu-tian-22", 
        "https://www.zhihu.com/people/jorry-36", 
        "https://www.zhihu.com/people/gh_ke1990", 
        "https://www.zhihu.com/people/lyer-38", 
        "https://www.zhihu.com/people/han-xiao-wei-37", 
        "https://www.zhihu.com/people/hello-87-64", 
        "https://www.zhihu.com/people/lu-yi-xing-74", 
        "https://www.zhihu.com/people/bai-quan-hu", 
        "https://www.zhihu.com/people/wang-qing-yi", 
        "https://www.zhihu.com/people/cui-long-hai-83", 
        "https://www.zhihu.com/people/bai-yao-wei", 
        "https://www.zhihu.com/people/zhang-rui-18-58-7", 
        "https://www.zhihu.com/people/su-jun-jie", 
        "https://www.zhihu.com/people/niu-jian-74", 
        "https://www.zhihu.com/people/idonis", 
        "https://www.zhihu.com/people/steel-13-83", 
        "https://www.zhihu.com/people/he-he-da-42-41", 
        "https://www.zhihu.com/people/xiao-yu-6068", 
        "https://www.zhihu.com/people/cha-zhu-6", 
        "https://www.zhihu.com/people/wei-well-83", 
        "https://www.zhihu.com/people/man-bu-xian-sen", 
        "https://www.zhihu.com/people/yijian-ling-yun", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/chanme", 
        "https://www.zhihu.com/people/ggsmida-48", 
        "https://www.zhihu.com/people/spring-star", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/huang-bo-xu", 
        "https://www.zhihu.com/people/activity00", 
        "https://www.zhihu.com/people/wood-sun", 
        "https://www.zhihu.com/people/lu-zheng-ji-35", 
        "https://www.zhihu.com/people/zzLikezz", 
        "https://www.zhihu.com/people/cheney-49-99", 
        "https://www.zhihu.com/people/524926can", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/shi-kong-chuan-suo-64", 
        "https://www.zhihu.com/people/xiao-han-13-60", 
        "https://www.zhihu.com/people/xilouch", 
        "https://www.zhihu.com/people/qi-zhu-qu-kan-hai-31", 
        "https://www.zhihu.com/people/whitehall", 
        "https://www.zhihu.com/people/yun-dong-nei-yi", 
        "https://www.zhihu.com/people/really-8", 
        "https://www.zhihu.com/people/zhao-jun-8-93", 
        "https://www.zhihu.com/people/yang-guang-48-37", 
        "https://www.zhihu.com/people/codejw", 
        "https://www.zhihu.com/people/xuyun-72", 
        "https://www.zhihu.com/people/lan-xin-yu", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/xu-zhi-17-74", 
        "https://www.zhihu.com/people/xiao-yi-81-48", 
        "https://www.zhihu.com/people/jiu-bu-gao-su-ni-42", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/ibrother", 
        "https://www.zhihu.com/people/lmy-97", 
        "https://www.zhihu.com/people/tphz", 
        "https://www.zhihu.com/people/mu-rong-feng-69", 
        "https://www.zhihu.com/people/li-vera-69", 
        "https://www.zhihu.com/people/Clownlooming", 
        "https://www.zhihu.com/people/wang-bing-cao", 
        "https://www.zhihu.com/people/wu-yue-46-99", 
        "https://www.zhihu.com/people/irelandken", 
        "https://www.zhihu.com/people/xiao-liao-98", 
        "https://www.zhihu.com/people/liuxiangxu137", 
        "https://www.zhihu.com/people/guo-zi-7-28-85"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/73576057", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 4, 
            "title": "Linux网络协议栈【驱动和网卡怎样交互？】", 
            "content": "<p>驱动和网卡的交互过程很少人会关注，但是如果你懂这方面的知识，会对用户态的网络编程更加理解深刻和通透。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>驱动和网卡之间是异步通信。驱动在请求发送数据之后CPU就去干别的事情去了。网卡发送完包之后通过中断通知CPU，CPU再通过驱动程序了解到结果。和发送数据一样，接收数据也是异步的。网卡把数据倒腾到主存之后再通过中断通知CPU。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，预留一些空间来缓存发送和接受的buffer是必要的。大多数情况下，网卡使用环结构，这个环基本上就是一个队列，它具有固定的条目数，每一个条目存储一个发送或者接受的数据。条目被顺序的轮流使用，可以复用。如下图所示，可以看到数据传送过程。 </p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9c925b480e0f20ff8d7e30f8e7649786_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-9c925b480e0f20ff8d7e30f8e7649786_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic3.zhimg.com/v2-9c925b480e0f20ff8d7e30f8e7649786_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9c925b480e0f20ff8d7e30f8e7649786_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>发送数据流</b><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>驱动接收上层的数据并创建一个网卡可以理解的数据包描述(send descriptor)，包含了主存地址和大小。由于网卡只认识物理地址，所以驱动还需将虚拟地址转换成物理地址，之后把send descriptor放到Tx ring之中。下一步通过通知网卡有新的数据了，之后网卡通过DMA(直接内存访问)获取元数据和数据发送出去。发送完之后通过DMA把结果写回，之后发送中断通知。</p><p>数据的接收和发送反推过程差不多，自己看图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-81f6dc3d960700bce9406feb7aa2937c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"1066\" data-original=\"https://pic1.zhimg.com/v2-81f6dc3d960700bce9406feb7aa2937c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1066&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1066\" data-original=\"https://pic1.zhimg.com/v2-81f6dc3d960700bce9406feb7aa2937c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-81f6dc3d960700bce9406feb7aa2937c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>不多说了，自己看图也能理解了。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>本片文章内容非常精简，但不代表知识量少，大家可能也发现了源理君的文章篇幅不是很长，但会把知识讲清楚、明白。</b></p><p><br/> </p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "协议栈", 
                    "tagLink": "https://api.zhihu.com/topics/20070536"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73575748", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 3, 
            "title": "Linux 网络I/O模型", 
            "content": "<p>在开始讲<b>网络IO模式</b>之前，我们先来熟悉一下几个概念：</p><ul><li>用户空间和内核空间</li><li>进程切换</li><li>文件描述符</li><li>buffer IO</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>用户空间和内核空间</h2><p>在Linux中不管是内核空间还是用户空间都是使用虚拟地址，在32位平台而言，它的寻址范围是4GB，如下图所示：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-63115d3cfb4231b46f35948063b24834_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"628\" class=\"content_image\" width=\"377\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;377&#39; height=&#39;628&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"377\" data-rawheight=\"628\" class=\"content_image lazy\" width=\"377\" data-actualsrc=\"https://pic1.zhimg.com/v2-63115d3cfb4231b46f35948063b24834_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>所以从较低3GB（<b>0x00000000到0xBFFFFFFF</b>）称之为用户空间,较高1GB（<b>0xC0000000到0xFFFFFFFF</b>）称之为内核空间。在我的《<b>Linux内存管理</b>》文章有更加详细的说明，可自行前往参考。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>进程切换</h2><p>在Linux中存在多线程的情况下，肯定需要进程的切换，也就是说需要挂起正在运行的进程，然后运行正在就绪状态的进程。这种行为我们称之为<b>进程切换</b>。进程切换有哪些变化呢？<br/></p><ol><li>首先需要保存寄存器现场，保存处理机上下文</li><li>更新PCB信息</li><li>把进程的PCB加入到某些队列中（例如就绪队列）</li><li>选择需要运行的进程，并且执行，然后更新其PCB</li><li>更新内存管理的结构</li><li>恢复处理机上下文</li></ol><p>虽然从这六个步骤中，无法感觉，但是真的挺繁琐的，非常消耗CPU资源。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>文件描述符</h2><p>文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>buffer IO</h2><p>buffer IO也就是标准IO，是默认的IO模式。在用户态write或者read等IO操作时，内核中数据是存储在文件系统的页缓存中。它有个缺点：<b>许多多次拷贝的消耗，带来CPU和内存的消耗</b>。在本人之前的《<b>Linux直接IO原理</b>》中有详细比较两种IO的优缺点。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>IO模型</h2><p>先直接给出五种网络模型：</p><ol><li>阻塞I/O</li><li>非阻塞I/O</li><li>I/O多路复用</li><li>信号驱动I/O</li><li>异步I/O</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>在Linux中，socket的<b>I/O默认都是阻塞</b>的，流程图，如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-826231be8745a768c095f354bc9599fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"368\" data-rawheight=\"322\" class=\"content_image\" width=\"368\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;368&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"368\" data-rawheight=\"322\" class=\"content_image lazy\" width=\"368\" data-actualsrc=\"https://pic3.zhimg.com/v2-826231be8745a768c095f354bc9599fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当应用程序调用recvfrom系统调用，内核进入第一个阶段：<b>等待数据</b>。所以在用户态这边整个进程都会阻塞。当内核准备数据之后，还需要将数据拷贝到用户态内存，然后才会return，之后用户进程才会接触阻塞状态。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>非阻塞I/O</b></p><p>设置I/O属性可以修改socket为非阻塞模式，当进行读操作时候，流程图如下图：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当用户进程read操作时候，如果内核还没数据，就会返回无数据状态。在用户进程的角度上，如果是无数据，继续recvfrom等待。直到内核数据准备好，拷贝到用户空间内存中。所以<b>非阻塞I/O需要用户进程一直轮询IO</b>。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>I/O多路复用（I/O multiplexing）</b></p><p>IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。<b>epoll的方式有所不一样，这里不展开。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-75bba50471f960547869bb06e0048b08_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-75bba50471f960547869bb06e0048b08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"476\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-75bba50471f960547869bb06e0048b08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-75bba50471f960547869bb06e0048b08_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以看出，当调用select，整个进程都会阻塞，select可以同时监听多个socket，一旦其中任意一个socket准备就绪状态，select就会立即返回，用户进程就可以read操作了。</p><p>上图和<b>阻塞IO</b>的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而阻塞 IO只调用了一个系统调用(recvfrom)。但是，select的真正优势在于它可以同时处理多个connection。</p><p>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p><p>在IO multiplexing 模型中，实际中，对于所有的socket，一般都设置成为非阻塞的。但是，如上图所示，整个用户进程其实是一直被阻塞的。只不过进程是被select这个函数阻塞的，而不是被socket IO给阻塞。</p><p><b>异步I/O</b></p><p>Linux中异步I/O其实用的很少。下图流程：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3ed84d4037c7848f7b57dd6a574d7189_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb\" width=\"445\" data-original=\"https://pic2.zhimg.com/v2-3ed84d4037c7848f7b57dd6a574d7189_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;445&#39; height=&#39;322&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"322\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"445\" data-original=\"https://pic2.zhimg.com/v2-3ed84d4037c7848f7b57dd6a574d7189_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3ed84d4037c7848f7b57dd6a574d7189_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>用户进程发起read操作之后，这个时候就可以去干其他事情了。而从kernel的角度，当它受到一个异步 read之后，首先它会立刻返回，所以不会对用户进程产生任何阻塞。然后，内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号，告诉它read操作完成了。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>看下图各I/O模型比较图：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-899368800b6e6162f33155884ef9eb99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb\" width=\"533\" data-original=\"https://pic2.zhimg.com/v2-899368800b6e6162f33155884ef9eb99_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;533&#39; height=&#39;423&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"423\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"533\" data-original=\"https://pic2.zhimg.com/v2-899368800b6e6162f33155884ef9eb99_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-899368800b6e6162f33155884ef9eb99_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以发现，非阻塞和异步的区别还是很明显的，在非阻塞中进程大部分不会阻塞的，但是需要主动check I/O。而异步I/O就不需要，内核将数据拷贝完成后，发送信号通知进程就行了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>觉得不错，记得关注，转发，点赞！</b></p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "老哥同事啊", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "日月之迹", 
                    "userLink": "https://www.zhihu.com/people/20a6abc162e7a9fb9354e7e1928f0dac", 
                    "content": "同事+1", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "技术原理君", 
                    "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
                    "content": "哈哈，很巧啊", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73575655", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 6, 
            "title": "Linux内核体系结构", 
            "content": "<p>大家都知道源理君很多期的文章都是关于Linux内核的功能，本着公众号的原则，只讲原理，将复杂的代码转换为通俗易懂的文字，图片。最后呈现给大家。可是源理君一直没有从大框架上系统的给各位梳理Linux内核体系结构。那本文就一个目的，站在山顶向下看。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Linux系统的层次框架</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4bdbc6a2a607d9434767be9a6dd2b32d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"841\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb\" width=\"841\" data-original=\"https://pic2.zhimg.com/v2-4bdbc6a2a607d9434767be9a6dd2b32d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;841&#39; height=&#39;764&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"841\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"841\" data-original=\"https://pic2.zhimg.com/v2-4bdbc6a2a607d9434767be9a6dd2b32d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4bdbc6a2a607d9434767be9a6dd2b32d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以分为两个层次：</p><ol><li><b>用户空间</b></li><li><b>内核空间</b></li></ol><p>在最上层是用户空间，也就是运行应用程序。用户空间的下层就是经常使用的gblic库，它的作用就是封装系统调用接口。不使用gblic库，而大量的直接使用系统调用接口是非常不明智的选择。用户空间运行的进程，他们各自拥有独立的虚拟地址空间，而内核则有单独的地址空间。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下层就是内核空间了。Linux内核空间又分为了三层：</p><ol><li>系统调用层；它是属于最上层，它提供了用户空间和内核空间通信的方式。</li><li>Linux内核，应该更加确切的说是独立于体系结构的内核代码，这些通用的代码适用于任何体系结构。</li><li>依赖体系结构的代码：这部分我们通常称之为BSP，这些代码主要是为了兼容不同平台或者处理器而引入的。</li></ol><p>Linux 内核实现了很多重要的体系结构属性。在或高或低的层次上，内核被划分为多个子系统。Linux 也可以看作是一个整体，因为它会将所有这些基本服务都集成到内核中。这与微内核的体系结构不同，后者会提供一些基本的服务，例如通信、I/O、内存和进程管理，更具体的服务都是插入到微内核层中的。每种内核都有自己的优点，不过这里并不对此进行讨论。<br/>    随着时间的流逝，Linux 内核在内存和 CPU 使用方面具有较高的效率，并且非常稳定。但是对于 Linux 来说，最为有趣的是在这种大小和复杂性的前提下，依然具有良好的可移植性。Linux 编译后可在大量处理器和具有不同体系结构约束和需求的平台上运行。一个例子是 Linux 可以在一个具有内存管理单元（MMU）的处理器上运行，也可以在那些不提供 MMU 的处理器上运行。Linux 内核的 uClinux 移植提供了对非 MMU 的支持。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Linux内核体系结构</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2585278f4a344acd5f2d1c9b76c9ab72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb\" width=\"683\" data-original=\"https://pic3.zhimg.com/v2-2585278f4a344acd5f2d1c9b76c9ab72_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;683&#39; height=&#39;764&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"683\" data-rawheight=\"764\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"683\" data-original=\"https://pic3.zhimg.com/v2-2585278f4a344acd5f2d1c9b76c9ab72_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2585278f4a344acd5f2d1c9b76c9ab72_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Linux内核的主要组件有：</p><ol><li>系统调用接口</li><li>进程管理</li><li>内存管理</li><li>虚拟文件系统</li><li>网络堆栈</li><li>设备驱动程序、硬件架构的相关代码。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）系统调用接口<br/>系统调用层提供了某些机制执行从用户空间到内核的函数调用。它是依赖真个体系结构的。在这一层提供多路复用和多路分解服务。</p><p>（2）进程管理<br/>进程管理的核心就是进程的调度。在Linux内核中，进程调度的单元是进程，线程对与调度来说相当于进程概念。内核通过系统调用提供了应用程序编程接口。例如：创建新进程（fork，exec），结束进程（kill， exit），并且提供了控制进程，同步进程和进程间通信的接口。</p><p>进程管理还包括处理活跃进程之间共享CPU的需求。内核使用的是CFS完全公平调度器，在我之前文章<b>《Linux完全公平调度器CFS》</b>有详细阐述。</p><p>（3）内存管理<br/>内核所管理的另外一个重要资源是内存。为了提高效率，如果由硬件管理虚拟内存，内存是按照所谓的<b>内存页</b> 方式进行管理的（对于大部分体系结构来说都是 4KB）。Linux 包括了管理可用内存的方式，以及物理和虚拟映射所使用的硬件机制。不过内存管理要管理的可不止 4KB 缓冲区。Linux 提供了对 4KB 缓冲区的抽象，例如 slab 分配器。这种内存管理模式使用 4KB 缓冲区为基数，然后从中分配结构，并跟踪内存页使用情况，比如哪些内存页是满的，哪些页面没有完全使用，哪些页面为空。这样就允许该模式根据系统需要来动态调整内存使用。为了支持多个用户使用内存，有时会出现可用内存被消耗光的情况。由于这个原因，页面可以移出内存并放入磁盘中。这个过程称为交换，因为页面会被从内存交换到硬盘上。内存管理的源代码可以在 ./linux/mm 中找到。</p><p>（4）虚拟文件系统<br/>虚拟文件系统（VFS）是 Linux 内核中非常有用的一个方面，因为它为文件系统提供了一个通用的接口抽象。VFS 在 系统调用 和内核所支持的文件系统之间提供了一个屏蔽层。如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b54e8502d76f1c90d9b27e8b45218603_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"361\" data-rawheight=\"295\" class=\"content_image\" width=\"361\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;361&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"361\" data-rawheight=\"295\" class=\"content_image lazy\" width=\"361\" data-actualsrc=\"https://pic4.zhimg.com/v2-b54e8502d76f1c90d9b27e8b45218603_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在 VFS 上面，是对诸如 open、close、read 和 write 之类的函数的一个通用 API 抽象。在 VFS 下面是文件系统抽象，它定义了上层函数的实现方式。它们是给定文件系统（超过 50 个）的插件。文件系统的源代码可以在 <b>./linux/fs</b> 中找到。文件系统层之下是缓冲区缓存，它为文件系统层提供了一个通用函数集（与具体文件系统无关）。这个缓存层通过将数据保留一段时间（或者随即预先读取数据以便在需要是就可用）优化了对物理设备的访问。缓冲区缓存之下是设备驱动程序，它实现了特定物理设备的接口。<br/></p><p>（5）网络协议栈<br/>网络协议栈在设计上遵循模拟协议本身的分层体系结构。回想一下，Internet Protocol (IP) 是传输协议（通常称为传输控制协议或 TCP）下面的核心网络层协议。TCP 上面是 socket 层，它是通过系统调用层进行调用的。socket 层是网络子系统的标准 API，它为各种网络协议提供了一个用户接口。从原始帧访问到 IP 协议数据单元（PDU），再到 TCP 和 User Datagram Protocol (UDP)，socket 层提供了一种标准化的方法来管理连接，并在各个终点之间移动数据。内核中网络源代码可以在 ./linux/net 中找到。<br/>（6）设备驱动程序<br/>Linux 内核中有大量代码都在设备驱动程序中，它们能够运转特定的硬件设备。Linux 源码树提供了一个驱动程序子目录，这个目录又进一步划分为各种支持设备，例如 Bluetooth、I2C、serial 等。设备驱动程序的代码可以在 ./linux/drivers 中找到。<br/>（7）依赖体系结构的代码<br/>尽管 Linux 很大程度上独立于所运行的体系结构，但是有些元素则必须考虑体系结构才能正常操作并实现更高效率。./linux/arch 子目录定义了内核源代码中依赖于体系结构的部分，其中包含了各种特定于体系结构的子目录（共同组成了 BSP）。对于一个典型的桌面系统来说，使用的是 x86 目录。每个体系结构子目录都包含了很多其他子目录，每个子目录都关注内核中的一个特定方面，例如引导、内核、内存管理等。这些依赖体系结构的代码可以在 ./linux/arch 中找到。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Linux 还是一个动态内核，支持动态添加或删除软件组件。被称为动态可加载内核模块，它们可以在引导时根据需要（当前特定设备需要这个模块）或在任何时候由用户插入。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>参考</h2><p>源理君参考了这篇文章 <a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/zhoudaxia/article/details/7172192\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/zhoudaxia</span><span class=\"invisible\">/article/details/7172192</span><span class=\"ellipsis\"></span></a> </p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/73575373", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 6, 
            "title": "Linux 中CPU如何访问内存？", 
            "content": "<p>在之前的《Linux内存管理》文章中，我们大致讲解了Linux内存管理的体系架构和映射过程。当然内存管理是一个复杂的模块。它涉及到硬件的交互和复杂的软件算法。本片文章我们就来讲解下硬件原理和分页管理。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>CPU如果访问内存？</h2><p>答案很简单，通过内存管理单元（MMU），我们先看一张很简单的CPU访问内存的流程图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6edde6b47037fd072550d6050be7edeb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-6edde6b47037fd072550d6050be7edeb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;561&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-6edde6b47037fd072550d6050be7edeb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6edde6b47037fd072550d6050be7edeb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>TLB</b>:转换lookaside 缓存，有了它可以让虚拟地址到物理地址转换速度大增。</p><p>从上图中我们可以清楚的知道了,CPU,DDR,MMU它们三者之间的关系。CPU在MMU开启的情况下，访问的都是虚拟地址。首先通过MMU将虚拟地址转换为物理地址，然后再通过总线上去访问内存（我们都知道内存是挂在总线上的）。</p><p><b>那MMU是怎么将虚拟地址转换为物理地址呢？</b>当然之前的文章也讲过了，是通过页表的方式。MMU从页表中查出虚拟地址对应的物理地址是什么，然后就去访问物理内存了。</p><p>所以搞懂了上面的问题，也就解决了标题的问题：《<b>CPU如何访问内存的</b>？》</p><p><b>页表是什么？</b>页表就是一种特殊的数据结构，它保存的是逻辑页和物理页帧的映射关系，而且每一个进程都各自拥有自己的页表。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虚拟地址在我们看来是一个整体，其实不然，它是可以拆分的。可以分为：</p><ol><li>p（页号），它可以存储页表的索引；</li><li>d（偏移），可以在页内进行地址偏移</li></ol><p>我们假设页大小为4KB，而且页表只有一级，也就是一级页表。那虚拟地址的拆分后的样子是这样的：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-301b7e6d7858922309a1c657ddf73193_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb\" width=\"679\" data-original=\"https://pic4.zhimg.com/v2-301b7e6d7858922309a1c657ddf73193_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;679&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"679\" data-original=\"https://pic4.zhimg.com/v2-301b7e6d7858922309a1c657ddf73193_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-301b7e6d7858922309a1c657ddf73193_b.jpg\"/></figure><p>下面我们来看下CPU,虚拟地址，页表和物理地址之间的关系。看下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-030065982d7f1a62a08b83f6c0a2ba45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-030065982d7f1a62a08b83f6c0a2ba45_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;440&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"440\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-030065982d7f1a62a08b83f6c0a2ba45_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-030065982d7f1a62a08b83f6c0a2ba45_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>很简单的吧，应该看懂了吧。我们可以发现如果采用一级页表的话，每个进程需要维护一个4MB大小的页表（我们可以算下，如果是32位平台，地址空间大小为4GB，页面大小为4KB，每个页表项占用4字节，所以4GB/4KB*4=4MB）。</p><p>因为每个进程都有自己的页表，所以在多进程的情况下，内存消耗简直惊人。所以一级页表是不合理的。<b>那有没有优化的办法呢？</b>答案是有的，就是利用多级页表，可以节省内存。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二级页表就是将页表再次分页。再次举例，将逻辑地址分为10位页码p1+10位页码p2+12位页偏移。我们直接看图吧。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-194bce32349357e2288c737289cdf2dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-194bce32349357e2288c737289cdf2dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-194bce32349357e2288c737289cdf2dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-194bce32349357e2288c737289cdf2dd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>访问过程如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b2c4a73e657c9ce8849a32456242c449_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-b2c4a73e657c9ce8849a32456242c449_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;775&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"775\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"775\" data-original=\"https://pic2.zhimg.com/v2-b2c4a73e657c9ce8849a32456242c449_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b2c4a73e657c9ce8849a32456242c449_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>觉得不错，记得关注，转发！</b></p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "中央处理器 (CPU)", 
                    "tagLink": "https://api.zhihu.com/topics/19553309"
                }, 
                {
                    "tag": "内存管理", 
                    "tagLink": "https://api.zhihu.com/topics/19579205"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72754729", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 9, 
            "title": "Linux进程调度：完全公平调度器CFS", 
            "content": "<p>对于分时操作系统来说，表面上看起来同时多个进程在运行，其实系统内部同一时间只有一个进程在运行，但进程是以比较快的速度在切换。这样就引入了进程切换和进程调度的概念了。进程调度应该是操作系统的核心功能了，它非常的复杂。</p><p>尽管刚出Linux开发为的是桌面操作系统，但现在服务器，嵌入式设备，个人pc都会使用它，不同领域对进程调度的差异非常大，所以要考虑整体的平衡性。Linux进程在调度器中被分为三种：<br/></p><ol><li><b>交互式进程</b>：大量的人机交互，所以会有大量的睡眠状态，等待用户操作。例如：编辑器，这类进程需要比较高的响应速度。</li><li><b>批处理进程</b>：这类进程需要大量的CPU资源，但是响应延迟可以忍受，比如：视频编码，算法；</li><li><b>实时进程</b>：对调度延迟要求最高。比如：视频播放</li></ol><p><b>在Linux中，线程和进程一视同仁，所以讲到进程调度，也包含了线程调度。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>Linux调度器的简史</b></h2><p>Linux进程调度，有一段非常有趣的历史。在2.5版本之前，Linux采用传统的UNIX调度算法。由于没有考虑到SMP，所以SMP不支持。性能表现就非常不好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>所以在后来的2.5版本中，进行了大改。采用了O（1）的算法，之所以O(1)，因为它的运行时间是常量，与系统的任务数量是无关的。该调度器增加了对SMP的支持。但是在许多的桌面交互进程的响应时间却表现不是很好。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在之后的2.6版本中，调度器再一次的大的改动。2.6.23的版本中，<b>完全公平调度器（CFS）</b>最终成为Linux调度算法。</p><p>Linux的进程调度基于调度类。每个调度类都有一个特定优先级。每一个不同的调度类，都有不同的调度算法，就是为了满足不同的需要。也许手机中的Linux和服务器的Linux调度器准则也是不一样。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Linux内核有两个调度类：<b>CFS和实时调度类。</b></p><h2>CFS</h2><p>CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。每个任务分配的具体比例是根据nice值来计算的。nice值的范围从 -20 到 +19，数值较低的nice值表示较高的相对优先级。具有较低nice值的任务，与具有较高nice值的任务相比，会得到更高比例的处理器处理时间。默认nice值为 0。</p><p><b>为什么叫nice？当一个任务增加了它的nice，说明它的优先级降低了，进而对其他任务变得nice</b></p><p>CFS 调度程序没有直接分配优先级。相反，它通过每个任务的变量 vruntime 以便维护虚拟运行时间，进而记录每个任务运行多久。虚拟运行时间与基于任务优先级的衰减因子有关，更低优先级的任务比更高优先级的任务具有更高衰减速率。对于正常优先级的任务（nice值为 0），虚拟运行时间与实际物理运行时间是相同的。下面分析一下 CFS 调度程序是如何工作的。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>假设有两个任务，它们具有相同的nice值。一个任务是 I/O 密集型而另一个为 CPU 密集型。通常，I/O 密集型任务在运行很短时间后就会阻塞以便等待更多的 I/O；而 CPU 密集型任务只要有在处理器上运行的机会，就会用完它的时间片。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，I/O 密集型任务的虚拟运行时间最终将会小于 CPU 密集型任务的，从而使得 I/O 密集型任务具有更高的优先级。这时，如果 CPU 密集型任务在运行，而 I/O 密集型任务变得有资格可以运行（如该任务所等待的 I/O 已成为可用)，那么 I/O 密集型任务就会抢占 CPU 密集型任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>实时调度</h2><p>采用 SCHED_FIFO 或 SCHED_RR 实时策略来调度的任何任务，与普通（非实时的）任务相比，具有更高的优先级。<br/><br/>Linux 采用两个单独的优先级范围，一个用于实时任务，另一个用于正常任务。实时任务分配的静态优先级为 0〜99，而正常任务分配的优先级为 100〜139。<br/><br/>这两个值域合并成为一个全局的优先级方案，其中较低数值表明较高的优先级。正常任务，根据它们的nice值，分配一个优先级；这里 -20 的nice值映射到优先级 100，而 +19 的nice值映射到 139。下图显示了这个方案。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9b2237e98d46e825ee07acebe9019661_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"641\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"641\" data-original=\"https://pic2.zhimg.com/v2-9b2237e98d46e825ee07acebe9019661_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;641&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"641\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"641\" data-original=\"https://pic2.zhimg.com/v2-9b2237e98d46e825ee07acebe9019661_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9b2237e98d46e825ee07acebe9019661_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>CFS 性能</h2><p>Linux CFS 调度程序釆用高效算法，以便选择运行下个任务。每个可运行的任务放置在红黑树上（这是一种平衡的、二分搜索树，它的键是基于虚拟运行时间的）。这种树如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d5580bfcf145ba594295e22525e09933_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb\" width=\"534\" data-original=\"https://pic4.zhimg.com/v2-d5580bfcf145ba594295e22525e09933_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;534&#39; height=&#39;326&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"534\" data-original=\"https://pic4.zhimg.com/v2-d5580bfcf145ba594295e22525e09933_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d5580bfcf145ba594295e22525e09933_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当一个任务变成可运行时，它被添加到树上。当一个任务变成不可运行时（例如，当阻塞等待 I/O 时），它从树上被删除。一般来说，得到较少处理时间的任务（虚拟运行时间较小）会偏向树的左侧；得到较多处理时间的任务会偏向树的右侧。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>根据二分搜索树的性质，最左侧的结点有最小的键值；从 CFS 调度程序角度而言，这也是具有最高优先级的任务。由于红黑树是平衡的，找到最左侧结点会需要 <code>O(lgN)</code> 操作（这里 N 为树内结点总数）。不过，为高效起见，Linux 调度程序将这个值缓存在变量 rb_leftmost 中，从而确定哪个任务运行只需检索缓存的值。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>本文没有特别复杂的一些细节，只是把原理告诉大家。没有告诉进程权重的概念，觉得大部分不是做内核开发，没有必要掌握的太细。只需要把原理弄懂即可，也足够。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>                  觉得不错，记得转发，关注！</b></p><p></p>", 
            "topic": [
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }, 
                {
                    "tag": "调度算法", 
                    "tagLink": "https://api.zhihu.com/topics/19795728"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>讲得不错，有所收获。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69555454", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 4, 
            "title": "mmap实现原理浅析", 
            "content": "<p>在Unix/Linux系统下读写文件，一般有两种方式。</p><p>一种是open一个文件，然后使用read系统调用读取文件的一部分或全部。这个read过程是这样的：内核将文件中的数据从磁盘区域读取到内核页高速缓冲区，再从内核的高速缓冲区读取到用户进程的地址空间。这里就涉及到了数据的两次拷贝：磁盘-&gt;内核，内核-&gt;用户态。</p><p>而且当存在多个进程同时读取同一个文件时，每一个进程中的地址空间都会保存一份副本，这样肯定不是最优方式的，造成了物理内存的浪费。看下图：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b1ed113ee5e9ee4e44f585f50e9fbb6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"979\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb\" width=\"979\" data-original=\"https://pic3.zhimg.com/v2-b1ed113ee5e9ee4e44f585f50e9fbb6e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;979&#39; height=&#39;540&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"979\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"979\" data-original=\"https://pic3.zhimg.com/v2-b1ed113ee5e9ee4e44f585f50e9fbb6e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b1ed113ee5e9ee4e44f585f50e9fbb6e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>第二种方式就是使用内存映射的方式</b>。具体操作方式是：open一个文件，然后调用mmap系统调用，将文件的内容的全部或一部分直接映射到进程的地址空间，映射完成后，进程可以像访问普通内存一样做其他的操作，比如memcpy等等。mmap并不分配物理地址空间，它只是占有进程的虚拟地址空间。这跟第一种方式不一样的，第一种方式需要预先分配好物理内存，内核才能将页高速缓冲中的文件数据拷贝到用户进程指定的内存空间中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>而第二种方式，当多个进程需要同时访问同一个文件时，每个进程都将文件所存储的内核高速缓冲映射到自己的进程地址空间。当第一个进程访问内核中的缓冲区时候，前面讲过并没有实际拷贝数据，这时MMU在地址映射表中是无法找到与地址空间相对应的物理地址的，也就是MMU失败，就会触发缺页中断。内核将文件的这一页数据读入到内核高速缓冲区中，并更新进程的页表，使页表指向内核缓冲中的这一页。之后有其他的进程再次访问这一页的时候，该页已经在内存中了，内核只需要将进程的页表登记并且指向内核的页高速缓冲区即可。如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a1c7303b982b50cd195b3b3d359fd57f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"979\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb\" width=\"979\" data-original=\"https://pic4.zhimg.com/v2-a1c7303b982b50cd195b3b3d359fd57f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;979&#39; height=&#39;540&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"979\" data-rawheight=\"540\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"979\" data-original=\"https://pic4.zhimg.com/v2-a1c7303b982b50cd195b3b3d359fd57f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a1c7303b982b50cd195b3b3d359fd57f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>上面只是讲述了基本原理，下篇文章继续深入内核源码一探究竟。下面mmap使用方法（经供参考）：</b></p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/mman.h&gt; /* for mmap and munmap */</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/types.h&gt; /* for open */</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/stat.h&gt; /* for open */</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;fcntl.h&gt;     /* for open */</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;    /* for lseek and write */</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span> \n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"o\">**</span><span class=\"n\">argv</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">;</span>\n  <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">mapped_mem</span><span class=\"p\">,</span> <span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n  <span class=\"kt\">int</span> <span class=\"n\">flength</span> <span class=\"o\">=</span> <span class=\"mi\">1024</span><span class=\"p\">;</span>\n  <span class=\"kt\">void</span> <span class=\"o\">*</span> <span class=\"n\">start_addr</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n \n  <span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">open</span><span class=\"p\">(</span><span class=\"n\">argv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">O_RDWR</span> <span class=\"o\">|</span> <span class=\"n\">O_CREAT</span><span class=\"p\">,</span> <span class=\"n\">S_IRUSR</span> <span class=\"o\">|</span> <span class=\"n\">S_IWUSR</span><span class=\"p\">);</span>\n  <span class=\"n\">flength</span> <span class=\"o\">=</span> <span class=\"n\">lseek</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">SEEK_END</span><span class=\"p\">);</span>\n  <span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"s\">&#34;</span><span class=\"se\">\\0</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"cm\">/* 在文件最后添加一个空字符，以便下面printf正常工作 */</span>\n  <span class=\"n\">lseek</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">SEEK_SET</span><span class=\"p\">);</span>\n  <span class=\"n\">mapped_mem</span> <span class=\"o\">=</span> <span class=\"n\">mmap</span><span class=\"p\">(</span><span class=\"n\">start_addr</span><span class=\"p\">,</span> <span class=\"n\">flength</span><span class=\"p\">,</span> <span class=\"n\">PROT_READ</span><span class=\"p\">,</span>        <span class=\"c1\">//允许读\n</span><span class=\"c1\"></span>    <span class=\"n\">MAP_PRIVATE</span><span class=\"p\">,</span>       <span class=\"c1\">//不允许其它进程访问此内存区域\n</span><span class=\"c1\"></span>      <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n  \n  <span class=\"cm\">/* 使用映射区域. */</span>\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">mapped_mem</span><span class=\"p\">);</span> <span class=\"cm\">/* 为了保证这里工作正常，参数传递的文件名最好是一个文本文件 */</span>\n  <span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n  <span class=\"n\">munmap</span><span class=\"p\">(</span><span class=\"n\">mapped_mem</span><span class=\"p\">,</span> <span class=\"n\">flength</span><span class=\"p\">);</span>\n  <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "内存（RAM）", 
                    "tagLink": "https://api.zhihu.com/topics/19570383"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69554144", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 17, 
            "title": "怎样去理解Linux用户态和内核态？", 
            "content": "<p>在Linux技术讨论中经常会<b>用户态</b>和<b>内核态</b>术语脱口而出，可你们想过吗？用户态和内核态代表是什么？本片文章，就来谈一谈这个话题。</p><p>我们先来看一张Linux整体架构图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d3723a14f07a42c7e016ae9bc38eddef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"793\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"793\" data-original=\"https://pic4.zhimg.com/v2-d3723a14f07a42c7e016ae9bc38eddef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;793&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"793\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"793\" data-original=\"https://pic4.zhimg.com/v2-d3723a14f07a42c7e016ae9bc38eddef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d3723a14f07a42c7e016ae9bc38eddef_b.jpg\"/></figure><p>从图上我们可以看出来通过<b>系统调用</b>将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间）。那内核态到底是什么呢？其实从本质上说就是我们所说的内核，它是一种<b>特殊的软件程序</b>，特殊在哪儿呢？<b>控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行</b>。<br/></p><p>用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫<b>系统调用。</b></p><h2>系统调用</h2><p><b>系统调用</b>时操作系统的最小功能单位。根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。这些系统调用组成了用户态跟内核态交互的基本接口，<b>例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。</b></p><h2>库函数</h2><p><b>库函数</b>就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：<b>open（），write（），read（）</b>等等。库函数根据不同的标准也有不同的版本，例如：<b>glibc库，posix库</b>等。</p><h2>shell</h2><p>shell顾名思义，就是外壳的意思。就好像把内核包裹起来的外壳。它是一种特殊的应用程序，俗称命令行。为了方便用户和系统交互，一般一个shell对应一个终端，呈现给用户交互窗口。当然shell也是编程的，它有标准的shell语法，符合其语法的文本叫<b>shell脚本</b>。很多人都会用shell脚本实现一些常用的功能，可以提高工作效率。<br/></p><p>我们再来看一个更加细化的Linux体系架构图。我们可以总结下：内核控制并且管理硬件资源，包括进程的调度和管理、内存管理、文件系统管理、设备驱动管理、网络管理等等。并且提供应用程序统一的系统调用接口。这种分层的架构，极大的提升了系统的稳定性和扩展性，兼容性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7ea6c1c1600a8edb31eb7f5b59b485ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb\" width=\"830\" data-original=\"https://pic4.zhimg.com/v2-7ea6c1c1600a8edb31eb7f5b59b485ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;830&#39; height=&#39;565&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"830\" data-original=\"https://pic4.zhimg.com/v2-7ea6c1c1600a8edb31eb7f5b59b485ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7ea6c1c1600a8edb31eb7f5b59b485ef_b.jpg\"/></figure><h2>用户态到内核态怎样切换？</h2><p>往往我们的系统的资源是固定的，例如内存2G，CPU固定，磁盘2TB，网络接口固定。所以就需要操作系统对资源进行有效的利用。假设某个应用程序过分的访问这些资源，就会导致整个系统的资源被占用，如果不对这种行为进行限制和区分，就会导致资源访问的冲突。所以，Linux的设计的初衷：<b>给不同的操作给与不同的“权限”</b>。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。</p><p>各位有没有发现，前面讲了这么多内核态和用户态什么不同，其实用一句话就能概括：<b>它们权限不同</b>。用户态的进程能够访问的资源受到了极大的控制，而运行在内核态的进程可以“<b>为所欲为</b>”。一个进程可以运行在用户态也可以运行在内核态，那它们之间肯定存在用户态和内核态切换的过程。打一个比方：<b>C库接口malloc申请动态内存，malloc的实现内部最终还是会调用brk（）或者mmap（）系统调用来分配内存。</b></p><p><b>那为问题又来了，从用户态到内核态到底怎么进入？只能通过系统调用吗？还有其他方式吗？</b></p><p>从用户态到内核态切换可以通过三种方式：</p><ol><li>系统调用，这个上面已经讲解过了，在我公众号之前的文章也有讲解过。其实系统调用本身就是中断，但是软件中断，跟硬中断不同。</li><li>异常：如果当前进程运行在用户态，如果这个时候发生了异常事件，就会触发切换。例如：缺页异常。</li><li>外设中断：当外设完成用户的请求时，会向CPU发送中断信号。</li></ol><h2>总结</h2><p>本片文章，没有非常深入的Linux内核实现，只是从宏观的角度阐述了下。看完上面的文章，也能得出一点结论就是：<b>系统调用真的开销蛮大的</b>。涉及到上下文的切换。在上篇文章中【Linux的直接I/O原理】中有讲述到这些，Linux内核真的是复杂的工程，更多技术细节，需要点滴积累。</p><p><b>觉得不错，记得关注、点赞、转发、“在看”</b></p>", 
            "topic": [
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "用户态", 
                    "tagLink": "https://api.zhihu.com/topics/20050742"
                }
            ], 
            "comments": [
                {
                    "userName": "李明理", 
                    "userLink": "https://www.zhihu.com/people/8d8d5f2578e840f1e8fc767221ae83e6", 
                    "content": "系统调用为什么开销大？进程用户态内核态切换为什么开销大？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69553562", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 15, 
            "title": "Linux进程间通信的实现原理？", 
            "content": "<p>作为Linux应用程序的开发人员，对Linux的进程间通信方式肯定是了如指掌，平时的开发中应该会大量的使用到。当你迅速的在键盘上按下【CTRL+C】终止掉一个正在运行中的命令时，你有没有仔细的思考过背后的原理呢？或者是他们是通过什么通信方式呢？这个通信方式是怎样实现的呢？本文就带着大家去<b>Linux进程间通信</b>一探究竟，找出他们的原理。</p><h2>概念</h2><p>我们都知道，应用程序在运行起来之后（进程），是相互独立的，都有自己的进程地址空间。但是往往在一些业务上需要进程间的通信，来完成系统的某个完整的功能。<b>我们来看下进程间通信能干那些事情</b>？首先当然最重要的是：</p><ol><li><b>数据传输</b>。一个进程需要发送数据到另一个进程，这种需求肯定是存在的。</li><li><b>共享数据</b>。如果有多个进程想要访问数据，一个进程修改了内容，另一个进程能够立即看到内容变化。</li><li><b>资源保护</b>：上面的的操作中存在竞争情况，内核需要提供锁和同步机制。</li><li><b>通知</b>：一个进程需要向另一个进程发送消息，通知发生了某个事件。</li><li><b>控制</b>：有些进程需要控制另一个进程的运行。典型的例子就是gdb，可参考之前文章【<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzU3NzY4MjU5MQ%3D%3D%26mid%3D2247484003%26idx%3D1%26sn%3D3e08065d6c5cc49ac2be1e938f93912d%26chksm%3Dfd01af93ca76268537096a7f773414110efc86fb4d2244ad6a958260fdd794a8cc33a9a31ecb%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">gdb到底是怎么实现的？</a>】</li></ol><h2>通信方式</h2><p>进程间的通信方式一般可以分为八种，如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3e8371ea82c8b9855dd82b061ded8402_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb\" width=\"1066\" data-original=\"https://pic3.zhimg.com/v2-3e8371ea82c8b9855dd82b061ded8402_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1066&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"154\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1066\" data-original=\"https://pic3.zhimg.com/v2-3e8371ea82c8b9855dd82b061ded8402_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3e8371ea82c8b9855dd82b061ded8402_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>他们在不同的标准都有不同的实现，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;329&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"329\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c6aeb64f7e87579f12f6cc2c92dc95c0_b.jpg\"/></figure><p>我们先从管道开始讲起来吧。</p><h2><b>管道</b></h2><p>这里说的管理特指的是无名管道，它是一种半双工的通信方式。也就是说数据只能单向流动，一般是在具有亲缘关系的进程间使用，比如父子进程。当一个进程创建了一个管道,并调用fork创建自己的一个子进程后,父进程关闭读管道端,子进程关闭写管道端,这样提供了两个进程之间数据流动的一种方式。<br/></p><p><b>管道是怎么通信的呢？</b></p><p>首先管道是内核的一个缓冲区，而且是在内存中。管道一头连接着一个进程的输出，另一头连接着另一个进程的输入。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。看下图：<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6337d5bd37b421edc01b94be6da1a490_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-6337d5bd37b421edc01b94be6da1a490_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-6337d5bd37b421edc01b94be6da1a490_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6337d5bd37b421edc01b94be6da1a490_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>那管道怎样建立的呢？</b></p><p>从原理上，管道利用fork机制建立，从而让两个进程可以连接到同一个PIPE上。最开始的时候，上面的两个箭头都连接在同一个<b>进程1</b>上(连接在<b>进程1</b>上的两个箭头)，如下图。当fork复制进程的时候，会将这两个连接也复制到新的进程(<b>进程2</b>)。随后，每个进程关闭自己不需要的一个连接 (两个黑色的箭头被关闭; <b>进程1</b>关闭从PIPE来的输入连接，<b>进程2</b>关闭输出到PIPE的连接)，这样，剩下的红色连接就构成了如上图的PIPE。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c7250178142645de75714382e5b40bce_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"453\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-c7250178142645de75714382e5b40bce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;453&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"453\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-c7250178142645de75714382e5b40bce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c7250178142645de75714382e5b40bce_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>管道在内核中具体怎么实现的呢？</b></p><p>在Linux内核中，并没有针对管道新增数据结构。而是巧妙的借用了文件系统的file结构和虚拟文件系统的索引节点<b>inode。</b>通过将两个 file 结构指向同一个临时的 VFS 索引节点，而这个 VFS 索引节点又指向一个物理页面而实现的<b>。</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c2e0bc11dbacf150ebf17f5f5baf6c9a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1128\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-c2e0bc11dbacf150ebf17f5f5baf6c9a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1128&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1128\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-c2e0bc11dbacf150ebf17f5f5baf6c9a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c2e0bc11dbacf150ebf17f5f5baf6c9a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>具体实现</b></p><p>管道的实现其实也不难，源代码在内核工程中的<b>fs/pipe.c</b>，我们着重的讲两个比较重要的接口吧，也就是常用的pipe_read()和pipe_write()，前者是管道读函数，后者是管道写函数。</p><p>管道写函数将字节数据复制到虚拟文件系统索引节点指向的物理内存页，而读函数则是相反：读出数据。当然这里存在着竞争的管理，需要一定的同步机制，使用锁，等待队列和信号。</p><p>当我们写的时候，调用write（），内核根据传入的文件描述符fd，找到该文件的file结构。然后执行结构中f_op中的写函数。写函数在向内存写入数据之前，必须首先检查虚拟文件系统索引节点信息，检查<b>是否有足够的内存空间可以写和内存没有被读程序锁定</b>这两个条件，只有满足了，才真正的进行内存拷贝。</p><p>接下来写函数就会锁定内存，然后复制数据到内存，否则就在虚拟文件系统inode的等待队列中。</p><p><b>管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。</b>反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。</p><h2>总结</h2><p>由于篇幅的限制，八大进程间通信只讲了管道，文章开头的疑问也只能等到后续文章了，也算是留个悬念吧。<b>未完待续....</b><br/></p><p><b>觉得不错，记得点赞转发，关注我！</b></p>", 
            "topic": [
                {
                    "tag": "进程间通信", 
                    "tagLink": "https://api.zhihu.com/topics/20138175"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "进程", 
                    "tagLink": "https://api.zhihu.com/topics/19634510"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "先赞为敬", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "俞阳", 
                    "userLink": "https://www.zhihu.com/people/a88e3c42618bf6e3e40776d5e9407d13", 
                    "content": "666", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>最下一张图右侧，op和inode箭头是不是错了？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69552919", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 2, 
            "title": "怎样理解socket的实现机制", 
            "content": "<p>要写网络程序就必须用Socket，这是程序员都知道的。而且，面试的时候，我们也会被问对方会不会Socket编程？</p><p>一般来说，很多人都会说，Socket编程基本就是listen，accept以及send，write等几个基本的操作。是的，就跟常见的文件操作一样，只要写过就一定知道。<br/><br/>对于网络编程，我们也言必称TCP/IP，似乎其它网络协议已经不存在了。对于TCP/IP，我们还知道TCP和UDP，前者可以保证数据的正确和可靠性，后者则允许数据丢失。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>最后，我们还知道，在建立连接前，必须知道对方的IP地址和端口号。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>除此，普通的程序员就不会知道太多了，很多时候这些知识已经够用了。最多，写服务程序的时候，会使用多线程来处理并发访问。<br/><br/>我们还知道如下几个事实：</p><ol><li>一个指定的端口号不能被多个程序共用。比如，如果IIS占用了80端口，那么Apache就不能也用80端口了。</li><li>很多防火墙只允许特定目标端口的数据包通过。</li><li>服务程序在listen某个端口并accept某个连接请求后，会生成一个新的socket来对该请求进行处理。<br/><br/></li></ol><p class=\"ztext-empty-paragraph\"><br/></p><h2>问题</h2><p>于是，好奇心的疑问就来了，经典的四连问。</p><ul><li>如果一个socket创建后并与80端口绑定后，是否就意味着该socket占用了80端口呢？</li><li>如果是这样的，那么当其accept一个请求后，生成的新的socket到底使用的是什么端口呢（系统会默认给其分配一个空闲的端口号）？</li><li>如果是一个空闲的端口，那一定不是80端口了，于是以后的TCP数据包的目标端口就不是80了--防火墙一定会阻止其通过的！实际上，我们可以看到，防火墙并没有阻止这样的连接，而且这是最常见的连接请求和处理方式。然而不解就是，为什么防火墙没有阻止这样的连接？</li><li>它是如何判定那条连接是因为connect 80端口而生成的？是不是TCP数据包里有什么特别的标志？或者防火墙记住了什么东西？</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>分析<br/>带着这些问题，我们再来了解TCP/IP协议栈的原理。</h2><p>TCP和UDP同属于传输层，共同架设在IP层（网络层）之上。而IP层主要负责的是在节点之间（End to End）的数据包传送，这里的节点是一台网络设备，比如计算机。因为IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，端口于是标识的是一个节点上的一个应用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>除了增加端口信息，UDP协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口（Slice Window），以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。<br/><br/>所以，有理由怀疑，防火墙并没有足够的信息判断TCP数据包的更多信息，除了IP地址和端口号。而且，我们也看到，所谓的端口，是为了区分不同的应用的，以在不同的IP包来到的时候能够正确转发。<br/><br/>TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。就像操作系统会提供标准的编程接口，比如Win32编程接口一样，TCP/IP也必须对外提供编程接口，这就是Socket编程接口。<br/><br/>在Socket编程接口里，设计者提出了一个很重要的概念，那就是socket。这个socket跟文件句柄很相似，实际上在BSD系统里就是跟文件句柄一样存放在一样的进程句柄表里。这个socket其实是一个序号，表示其在句柄表中的位置。这一点，我们已经见过很多了，比如文件句柄，窗口句柄等等。这些句柄，其实是代表了系统中的某些特定的对象，用于在各种函数中作为参数传入，以对特定的对象进行操作--这其实是C语言的问题，在C++语言里，这个句柄其实就是this指针，实际就是对象指针啦。<br/><br/>现在我们知道，socket跟TCP/IP并没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以，socket的出现只是可以更方便的使用TCP/IP协议栈而已，其对TCP/IP进行了抽象，形成了几个最基本的函数接口。比如create，listen，accept，connect，read和write等等。<br/><br/>现在我们明白，如果一个程序创建了一个socket，并让其监听80端口，其实是向TCP/IP协议栈声明了其对80端口的占有。以后，所有目标是80端口的TCP数据包都会转发给该程序（这里的程序，因为使用的是Socket编程接口，所以首先由Socket层来处理）。</p><p>所谓accept函数，其实抽象的是TCP的连接建立过程。accept函数返回的新socket其实指代的是本次创建的连接，而一个连接是包括两部分信息的，一个是源IP和源端口，另一个是宿IP和宿端口。</p><p>所以，accept可以产生多个不同的socket，而这些socket里包含的宿IP和宿端口是不变的，变化的只是源IP和源端口。这样的话，这些socket宿端口就可以都是80，而Socket层还是能根据源/宿对来准确地分辨出IP包和socket的归属关系，从而完成对TCP/IP协议的操作封装！而同时，放火墙的对IP包的处理规则也是清晰明了，不存在前面设想的种种复杂的情形。</p><h2><br/><br/>总结</h2><p>明白socket只是对TCP/IP协议栈操作的抽象，而不是简单的映射关系，这很重要！</p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66922957", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 3, 
            "title": "怎样深入理解堆和栈", 
            "content": "<p>文章的标题看起来，确实有一点老生常谈的感觉，堆栈的文章多如牛毛。你先别急着关闭页面，接着往下看，这篇文章会带各位更加<b>深入的理解堆和栈。</b><br/></p><p> 对于大多数新手来说， “堆栈” 却不是一个很清晰的概念。堆栈是同一个东西？是数据结构，还是内存分配方式？<br/></p><p><b>堆栈：一种数据结构，一个在程序运行时用于存放的地方”，相信这可能是很多初学者共同的认识，这也是大部分教科书对“堆栈”的解释。</b><br/></p><p> 很显然，用这么简单的概括来解释“堆栈”是不合适的。要深刻认识堆和栈的概念与区别，还必须从如下两方面说起：</p><ul><li><b>数据结构的堆和栈</b></li><li><b>内存分配方式的堆和栈</b></li></ul><p>这是第一步</p><p>第二步再<b>深入系统实现方式理解堆和栈。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>第一步</b></p><h2><b>数据结构的堆和栈</b></h2><p>    在数据结构中，栈是一种可以实现“先进后出”（或者称为“后进先出”）的存储结构。假设给定栈 S=（a0，a1，…，an-1），则称 a0为栈底，an-1 为栈顶。进栈则按照 a0，a1，…，an-1 的顺序进行进栈；而出栈的顺序则需要反过来，按照“后存放的先取，先存放的后取”的原则进行，则 an-1 先退出栈，然后 an-2 才能够退出，最后再退出 a0。<br/>    在实际编程中，可以通过两种方式来实现：</p><ul><li>使用数组的形式来实现栈，这种栈也称为静态栈；</li><li>使用链表的形式来实现栈，这种栈也称为动态栈。</li></ul><p>    相对于栈的“先进后出”特性，堆则是一种经过排序的树形数据结构，常用来实现优先队列等。假设有一个集合 K={k0，k1，…，kn-1}，把它的所有元素按完全二叉树的顺序存放在一个数组中，并且满足：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9c59e250d2b5a893463072465282f0fb_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"21\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-9c59e250d2b5a893463072465282f0fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;21&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"21\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic4.zhimg.com/v2-9c59e250d2b5a893463072465282f0fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9c59e250d2b5a893463072465282f0fb_b.png\"/></figure><p>则称这个集合 K 为最小堆（或者最大堆）。</p><p>    由此可见，堆是一种特殊的完全二叉树。其中，节点是从左到右填满的，并且最后一层的树叶都在最左边（即如果一个节点没有左儿子，那么它一定没有右儿子）；每个节点的值都小于（或者都大于）其子节点的值。</p><p><br/><b>内存分配中的堆和栈</b><br/></p><p>在 C 语言中，内存分配方式不外乎有如下三种形式：</p><ol><li>从静态存储区域分配：它是由编译器自动分配和释放的，即内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，直到整个程序运行结束时才被释放，如全局变量与 static 变量。</li><li>在栈上分配：它同样也是由编译器自动分配和释放的，即在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将被自动释放。需要注意的是，栈内存分配运算内置于处理器的指令集中，它的运行效率一般很高，但是分配的内存容量有限。</li><li>从堆上分配：也被称为动态内存分配，它是由程序员手动完成申请和释放的。即程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完之后再由程序员自己负责使用内存释放函数（如 free 函数）来释放内存。也就是说，动态内存的整个生存期是由程序员自己决定的，使用非常灵活。需要注意的是，如果在堆上分配了内存空间，就必须及时释放它，否则将会导致运行的程序出现内存泄漏等错误。</li></ol><p><br/>    由此可见，内存分配的堆栈与数据结构中所阐述的堆栈有着本质的区别，这一点千万不要混淆。同样，在内存分配中的堆和栈也存在着很大的区别，也不要混淆这两者的概念。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>内存分配中的栈与堆主要存在如下区别。<br/></p><h3><b>1) 分配与释放方式</b></h3><p>栈内存是由编译器自动分配与释放的，它有两种分配方式：静态分配和动态分配。<br/></p><ul><li>静态分配是由编译器自动完成的，如局部变量的分配（即在一个函数中声明一个 int 类型的变量i时，编译器就会自动开辟一块内存以存放变量 i）。与此同时，其生存周期也只在函数的运行过程中，在运行后就释放，并不可以再次访问。</li><li>动态分配由 alloca 函数进行分配，但是栈的动态分配与堆是不同的，它的动态分配是由编译器进行释放，无需任何手工实现。值得注意的是，虽然用 alloca 函数可以实现栈内存的动态分配，但 alloca 函数的可移植性很差，而且在没有传统堆栈的机器上很难实现。因此，不宜使用于广泛移植的程序中。当然，完全可以使用 C99 中的变长数组来替代 alloca 函数。</li></ul><p><br/>    而堆内存则不相同，它完全是由程序员手动申请与释放的，程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完再由程序员自己负责使用内存释放函数（如 free 函数）释放内存，如下面的代码所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ce926791c766afcc432f18376c834868_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic1.zhimg.com/v2-ce926791c766afcc432f18376c834868_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic1.zhimg.com/v2-ce926791c766afcc432f18376c834868_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ce926791c766afcc432f18376c834868_b.jpg\"/></figure><p>对栈内存的自动释放而言，虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的潜在错误。<br/></p><h3><b>2) 分配的碎片问题</b></h3><p>    对堆来说，频繁分配和释放（malloc / free）不同大小的堆空间势必会造成内存空间的不连续，从而造成大量碎片，导致程序效率降低；而对栈来讲，则不会存在这个问题。<br/></p><h3><b>3) 分配的效率</b></h3><p>    大家都知道，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，这就决定了栈的效率比较高。一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出。<br/><br/>    而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。例如，为了分配一块堆内存，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。而对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。很显然，堆的分配效率比栈要低得多。<br/></p><h3><b>4) 申请的大小限制</b></h3><p>    由于操作系统是用链表来存储空闲内存地址（内存区域不连续）的，同时链表的遍历方向是由低地址向高地址进行的。因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存。<br/><br/>    而栈则不同，它是一块连续的内存区域，<b>其地址的增长方向是向下进行的，向内存地址减小的方向增长</b>。由此可见，栈顶的地址和栈的最大容量一般都是由系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。由此可见，相对于堆，能够从栈中获得的空间相对较小。<br/></p><h3><b>5) 存储的内容</b></h3><p>    对栈而言，一般用于存放函数的参数与局部变量等。例如，在函数调用时，第一个进栈的是（主函数中的）调用处的下一条指令（即函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，<b>在大多数 C 编译器中，参数是由右往左入栈的，最后是函数中的局部变量（注意 static 变量是不入栈的）</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>对堆而言，具体存储内容由程序员根据需要决定存储数据。</b><br/><br/>最后介绍一下 C 语言中各类型变量的存储位置和作用域。<br/></p><ul><li>全局变量。从静态存储区域分配，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用。与此同时，如果程序是由多个源文件构成的，那么全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，但必须在其他文件中通过使用extern关键字来声明该全局变量。</li><li>全局静态变量。从静态存储区域分配，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用。但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用。</li><li>局部变量。从栈上分配，其作用域只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</li><li>局部静态变量。从静态存储区域分配，其在第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>第二步</b></p><p>数据结构的堆栈也没有特别深奥难以理解，所以暂且略过。so最值得去讲的是<b>内存分配方式的堆栈，以x86为例。</b></p><p>栈寄存器和栈操作</p><ol><li><b>与栈相关的寄存器有两个：esp和ebp。</b><br/></li></ol><div class=\"highlight\"><pre><code class=\"language-text\">esp，栈指针，指向栈顶\nebp，基址指针，指向栈底\n</code></pre></div><ol><li><b>栈操作</b></li></ol><p><b>push 进栈</b></p><p>栈顶指针减少4个字节（栈是由高地址向低地址增长的），例如 <b>pushl %eax</b>相当于：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">subl $4, %esp\nmovl %eax, (%esp)\n</code></pre></div><p><b>pop 出栈</b></p><p>栈顶地址增加4个字节，例如，popl %eax相当于<br/></p><div class=\"highlight\"><pre><code class=\"language-text\"> movl (%esp), %eax\n add $4, %esp \n</code></pre></div><p><b>3.call</b></p><p>eip，程序计数器，总是指向下一条指令的位置。在进行函数调用时，会执行call指令，将eip中内容指向对应函数的位置。call具体执行过程如下：</p><p>首先将eip的值压如栈顶，然后将eip执行被调用函数的入口地址。具体指令如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">\n\n pushl %eip\n movl 0x12345, %eip\n ret\n</code></pre></div><ol><li>弹出原来保存在栈顶的原eip中的值，放入eip。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>函数的栈框架</p><p>每一个函数都会维持一个栈。栈框架会包裹函数执行体。如下图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fbc95d82b56a4972330b296aba84950c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-fbc95d82b56a4972330b296aba84950c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;528&#39; height=&#39;301&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"301\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-fbc95d82b56a4972330b296aba84950c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fbc95d82b56a4972330b296aba84950c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>分析demo</b></p><p><b>源码：</b><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">#include&lt;stdio.h&gt;\n#include&lt;stdlib.h&gt;\nvoid p1(char c)\n{\n printf(%c\n&#34;,c);\n}\nint p2(int x,int y)\n{\n return x + y;\n} \nint main()\n{\n char c = &#39;a&#39;;\n int x,y,z;\n x = 1;\n y = 2;\n p1(c);\n z = p2(x,y);\n printf(&#34;%d = %d + %d\n&#34;,z,x,y);\n}\n</code></pre></div><p><b>反汇编后</b>：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">.LC0:\n .string &#34;%c\n&#34;\n .text\np1:\n pushl %ebp\n movl %esp, %ebp\n subl $12, %esp\n movl 8(%ebp), %eax\n movb %al, -4(%ebp)\n movsbl -4(%ebp),%eax\n movl %eax, 4(%esp)\n movl $.LC0, (%esp)\n call printf\n leave\n ret\np2:\n pushl %ebp\n movl %esp, %ebp\n movl 12(%ebp), %eax\n addl 8(%ebp), %eax\n popl %ebp\n ret\n.LC1:\n .string &#34;%d = %d + %d\n&#34;\n .text\nmain:\n pushl %ebp\n movl %esp, %ebp\n subl $32, %esp\n movb $97, -13(%ebp)\n movl $1, -12(%ebp)\n movl $2, -8(%ebp)\n movsbl -13(%ebp),%eax\n movl %eax, (%esp)\n call p1\n movl -8(%ebp), %eax\n movl %eax, 4(%esp)\n movl -12(%ebp), %eax\n movl %eax, (%esp)\n call p2\n movl %eax, -4(%ebp)\n movl -8(%ebp), %eax\n movl %eax, 12(%esp)\n movl -12(%ebp), %eax\n movl %eax, 8(%esp)\n movl -4(%ebp), %eax\n movl %eax, 4(%esp)\n movl $.LC1, (%esp)\n call printf\n leave\n ret\n</code></pre></div><p><b>接下来我们分析下栈的过程</b></p><div class=\"highlight\"><pre><code class=\"language-text\">pushl %ebp\nmovl %esp, %ebp\n</code></pre></div><p>以上两条指令属于函数调用框架，作用就是为main函数建议一个新的空的栈。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07bd68ee8d290740f57086db54be7eca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-07bd68ee8d290740f57086db54be7eca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-07bd68ee8d290740f57086db54be7eca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-07bd68ee8d290740f57086db54be7eca_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">subl $32, %esp\nmovb $97, -13(%ebp)\nmovl $1, -12(%ebp)\nmovl $2, -8(%ebp)\n</code></pre></div><p>第一条指令的目的是在栈中开辟32字节的空间，存储局部变量。编译器会事先扫描函数中局部变量个数和大小，预分配给一个空间，供存储局部变量和参数调用。</p><p>剩下三条指令为将局部变量压栈。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-828c9ed7889a377b72487ba8e3b1ee9c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-828c9ed7889a377b72487ba8e3b1ee9c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"263\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-828c9ed7889a377b72487ba8e3b1ee9c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-828c9ed7889a377b72487ba8e3b1ee9c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">movsbl -13(%ebp),%eax\nmovl %eax, (%esp)\n</code></pre></div><p>将参数c=‘a’压栈</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-137bfd4864f4b4267fcd40e42c9d781e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image\" width=\"1\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1&#39; height=&#39;1&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image lazy\" width=\"1\" data-actualsrc=\"https://pic3.zhimg.com/v2-137bfd4864f4b4267fcd40e42c9d781e_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">call p1\n</code></pre></div><p>相当于：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\"> pushl %eip\n movl p1, %eip\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1b2b08ea0fe58151bab2246691c97c30_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"514\" data-original=\"https://pic1.zhimg.com/v2-1b2b08ea0fe58151bab2246691c97c30_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;514&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"514\" data-original=\"https://pic1.zhimg.com/v2-1b2b08ea0fe58151bab2246691c97c30_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1b2b08ea0fe58151bab2246691c97c30_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">pushl %ebp\nmovl %esp, %ebp\nsubl $12, %esp\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-84d3dc0ac2b9fe0fbf99abfb196a95af_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-84d3dc0ac2b9fe0fbf99abfb196a95af_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;513&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"513\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-84d3dc0ac2b9fe0fbf99abfb196a95af_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-84d3dc0ac2b9fe0fbf99abfb196a95af_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">movl 8(%ebp), %eax\nmovb %al, -4(%ebp)\nmovsbl -4(%ebp),%eax\nmovl %eax, 4(%esp)\nmovl $.LC0, (%esp)\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-137bfd4864f4b4267fcd40e42c9d781e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image\" width=\"1\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1&#39; height=&#39;1&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1\" data-rawheight=\"1\" class=\"content_image lazy\" width=\"1\" data-actualsrc=\"https://pic3.zhimg.com/v2-137bfd4864f4b4267fcd40e42c9d781e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">call printf\nleave\nret\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-81951a4652009645db3bb818facd81c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"337\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-81951a4652009645db3bb818facd81c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;337&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"337\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-81951a4652009645db3bb818facd81c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-81951a4652009645db3bb818facd81c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">movl -8(%ebp), %eax\nmovl %eax, 4(%esp)\nmovl -12(%ebp), %eax\nmovl %eax, (%esp)\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-df7ffeedf3f93add62d9a448ce6c09e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-df7ffeedf3f93add62d9a448ce6c09e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;528&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"528\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-df7ffeedf3f93add62d9a448ce6c09e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-df7ffeedf3f93add62d9a448ce6c09e9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>进入p2函数，过程和p1函数调用过程相似。以上就是函数调用栈的过程。</p><p><b>堆的深入理解</b></p><p>栈上的数据在函数返回时就会被释放掉，所以无法将数据传至函数外部，而全局变量没有办法动态地产生，只能在编译的时候定义，在这种情况下，堆是唯一地选择。malloc是C语言申请堆空间的函数，但是它是怎么实现的那？</p><p>其实可以直接让操作系统的内核来管理进程的内存，但是每次申请内存都要经过系统调用，如果操作频繁会导致效率很低，程序性能降低。比较好的做法是程序向操作系统申请一块适当的堆空间，然后由程序的运行库根据算法管理堆空间的分配，当堆空间不够的时候再向操作系统申请堆空间。linux下提供两种堆空间分配方式：<b>一个是brk（）系统调用，另外一个是mmap（）。</b></p><ul><li><br/></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">int brk (void *end_data_segment)\n</code></pre></div><p>brk()的作用实际上就是设置进程数据段的结束地址，她可以扩大或者缩小数据段。</p><ul><li><br/></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">void mmap（void *start, size_t length, int port, int flags, int fd, off_t offset）\n</code></pre></div><p>mmap的前两个参数分别指定需要申请的空间的起始地址和长度，如果其实地址设为0，那么操作系统会挑选合适的起始地址。port/flags这两个参数用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件类型，匿名空间等），最后两个参数用于文件映射是指定文件的描述符和文件偏移。用mmap实现的malloc函数：</p><ul><li><br/></li></ul><div class=\"highlight\"><pre><code class=\"language-text\">void *malloc(size_t nbytes)\n{\n void *ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 , 0);\n if (ret == MAP_FAILED)\n return 0;\n return ret;\n}\n</code></pre></div><p><b>mmap（）的作用是向操作系统申请一段虚拟空间，当这块虚拟空间可以映射到某个文件（也就是这个系统调用的最初的作用），当他不将地址空间映射到某个文件时，我们又称这块空间为匿名空间。</b></p><p>glibc的malloc 函数是这样处理用户的空间请求的：对于小于128KB的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间返回，对于大于128KB的请求来说，它会使用mmap（）函数为它分配一块匿名空间，然后再这个匿名空间中为用户分配空间。（所以问一个很常见的问题，malloc申请的内存，进程结束以后还会不会存在？ 答案是不存在）</p><p><b>堆分配算法</b></p><p><b>1、空闲链表法</b></p><p>空闲链表的方法是把堆中各个空闲的快按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的快并且将它拆分，当用户释放空间时将它合并到空闲链表中。</p><p><b>2、位图</b></p><p>核心思想就是将整个堆划分为大量的块，每个块大小相同。当用户请求内存的时候总是分配整个块的空间给用户。第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。</p><p><b>优点：速度快，稳定性好，容易管理。</b></p><p><b>缺点：容易产生碎片，浪费空间。</b></p><p><b>3、对象池</b></p><p>如果实际上在一些场合，被分配对象的大小是固定的几个值，我们可以采用对象池的方法。对象池思想就是，如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求只要找到一个空闲的小块就可以了。</p><p><b>实际上很多应用中，堆的分配算法往往是采取多种算法复合而成的，对于glibc来说，小于64字节的采用对象池的方法，对于大于512字节的采用最佳适配算法，对于64字节和512字节之间的采取最佳折中策略；对于大于128kb的申请，它会直接使用mmap向操作系统申请空间。</b></p><p><b>总结</b></p><p>这篇文章花了我8个小时的时间，真的不容易。从基本到深入，从堆到栈。从数据结构到内存分配方式。要想吃透还得在工作中加以实践。</p>", 
            "topic": [
                {
                    "tag": "计算机", 
                    "tagLink": "https://api.zhihu.com/topics/19555547"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66171133", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 4, 
            "title": "原子操作，内存屏障，锁总结", 
            "content": "<h2>原理</h2><ul><li>CPU提供了原子操作、关中断、锁内存总线,内存屏障等机制；OS基于这几个CPU硬件机制，就能够实现锁；再基于锁，就能够实现各种各样的同步机制（信号量、消息、Barrier等等等等）。</li><li>所有的同步操作最基础的理论就是原子操作。内存屏障,锁都是为了保证在不同的平台或者是CPU类型下的原子操作。</li><li>原子操作在单核，单线程/无中断，且编译器不优化的情况下是确定的，是按照C/C++代码顺序执行的，所以不存在异步问题。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>为了能够理解异步操作产生的原因，我们先来了解下CPU处理的过程：</p><p>1.先启动的处理器为有序处理器，指令处理顺序:</p><ul><li>a.读取指令</li><li>b.执行指令如果寄存器可写就从内存取出a的数据到寄存器，寄存器不可写就等待</li><li>c.寄存器处理指令</li><li>d.将寄存器结果存入内存</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>2.现在的处理器大多数为乱序处理器,处理顺序：</p><ul><li>a.读取指令</li><li>b.指令被划分到指令队列</li><li>c.指令在队列中等待,如果寄存器可写就从内存取出a的数据到寄存器，寄存器不可写就等待</li><li>d.寄存器处理指令</li><li>e.将执行结果存入队列(而不是立即写入寄存器堆)</li><li>f.只有当所有更早的请求执行的指令结果被写入内存之后，执行的结果才会被存入内存(执行结果重排序，让执行看起来是有序的)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>那么问题来了：</h2><p>1.一条简单的a++语句究竟会有这么多条指令，而这一组指令是可以在任意时候异步执行的(共享数据)</p><ul><li>a.单核多线程情况下,线程是存在中断的，中断的时候cpu调用另一线程的同一指令组，所以是可能出现交叉执行的可能，也就是说单线程或者关掉中断可以解决异步问题，但很多时候这种做法并不实际。</li><li>b.多核多线程情况下共享数据被多个核并行处理，不论哪一种处理器都存在同时执行的可能，这就导致了异步问题。</li><li>c.现在的编译器都具有优化及自动优化功能，优化之后可能会对共享变脸的访问顺序进行调整，可能会造成与预期不相符的结果。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>内存屏障的作用</h2><ul><li>a.在编译时:拒绝编译器优化屏障前后的指令,防止内存乱序访问。</li><li>b.在运行时:告诉内存地址总线共享数据地址的数据必须同步(当多个线程同时将一个共享数据地址的数据加载到队列里的时候,先完成处理从cpu到内存的时候总是通知其他线程跟新队列中的该共享数据,从而保证一致性)。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>常用场合</h2><ul><li>1.实现同步原语（synchronization primitives）</li><li>2.实现无锁数据结构（lock-free data structures）</li><li>3.驱动程序</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>锁</h2><p>从上面可以看出内存屏障并不是锁，而锁是使用了内存屏障实现的一种用户层的同步处理方式,锁使用的汇编原语有LOCK,UNLOCK等是内存屏障的一种隐式形式,它们都是LOCK操作和UNLOCK操作的变种，所以几乎所有的锁都使用了内存屏障。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>锁的种类</h2><ul><li>原子锁：使用了锁总线的方式实现原子操作</li><li>自旋锁：while等待,不可抢占的单CPU内核下是无效的，有软中断的情况下，必须使用时本地软中断失效的方法。自旋锁更像是一种用户层控制的while等待处理</li><li>读写锁: 读写锁实际是一种特殊的自旋锁，它把对共享资源的访问者划分成读者和写者，读者只对共享资源进行读访问，写者则需要对共享资源进行写操作</li><li>互斥锁：沉睡/休眠等待,所以互斥锁比自旋锁调度耗时。</li><li>信号量：用于同一时刻有多个个实例能获取锁，可用于表示同时有多少个client请求允许访问同一个数据块，允许锁个数设置为1的时候就是互斥锁.</li><li>读写信号量：对同时拥有的读者数不受限制，只能一个写者，写者发现不需要写的时候降级为读者。</li><li>顺序锁：用于能够区分读与写的场合，并且是读操作很多、写操作很少，写操作的优先权大于读操作。</li><li>读拷贝锁：RCU（read-copy-update）(RCU也是用于能够区分读与写的场合，并且也是读多写少，但是读操作的优先权大于写操作)</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>小总结</h2><p>上面的总结，写的比较乱，只是将自己的想法表达出来，没有构思文章结构，还请包含。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>如果喜欢我的文章，请长按二维码关注：cpp软件架构狮</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\"/></figure><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66170899", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 9, 
            "title": "怎样去理解Linux中的inode？", 
            "content": "<h2>一、inode是什么？</h2><p>理解inode，要从文件储存说起。</p><p>文件储存在硬盘上，硬盘的最小存储单位叫做&#34;扇区&#34;（Sector）。每个扇区储存512字节（相当于0.5KB）。</p><p>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个&#34;块&#34;（block）。这种由多个扇区组成的&#34;块&#34;，是文件存取的最小单位。&#34;块&#34;的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p><p>文件数据都储存在&#34;块&#34;中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为&#34;索引节点&#34;。</p><p>每一个文件都有对应的inode，里面包含了与该文件有关的一些信息。</p><h2>二、inode的内容</h2><p>inode包含文件的元信息，具体来说有以下内容：</p><blockquote>* 文件的字节数<br/>* 文件拥有者的User ID<br/>* 文件的Group ID<br/>* 文件的读、写、执行权限<br/>* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的时间。<br/>* 链接数，即有多少文件名指向这个inode<br/>* 文件数据block的位置</blockquote><p>可以用stat命令，查看某个文件的inode信息：</p><blockquote>stat example.txt</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0f28f476c86e63bf6dbb9382052a3d5c_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"154\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-0f28f476c86e63bf6dbb9382052a3d5c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;154&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"154\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-0f28f476c86e63bf6dbb9382052a3d5c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0f28f476c86e63bf6dbb9382052a3d5c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>总之，除了文件名以外的所有文件信息，都存在inode之中。至于为什么没有文件名，下文会有详细解释。</p><h2>三、inode的大小</h2><p>inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是inode区（inode table），存放inode所包含的信息。</p><p>每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达到128MB，占整块硬盘的12.8%。</p><p>查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令。</p><blockquote>df -i</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6970f5b53a98aada6e072ac787353d2d_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"177\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-6970f5b53a98aada6e072ac787353d2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;177&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"177\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-6970f5b53a98aada6e072ac787353d2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6970f5b53a98aada6e072ac787353d2d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>查看每个inode节点的大小，可以用如下命令：</p><blockquote>sudo dumpe2fs -h /dev/hda | grep &#34;Inode size&#34;</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2ef86620b416007001c99e079c3a9a41_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"127\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-2ef86620b416007001c99e079c3a9a41_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;127&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"127\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-2ef86620b416007001c99e079c3a9a41_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2ef86620b416007001c99e079c3a9a41_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由于每个文件都必须有一个inode，因此有可能发生inode已经用光，但是硬盘还未存满的情况。这时，就无法在硬盘上创建新文件。</p><h2>四、inode号码</h2><p>每个inode都有一个号码，操作系统用inode号码来识别不同的文件。</p><p>这里值得重复一遍，Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰号。</p><p>表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。</p><p>使用ls -i命令，可以看到文件名对应的inode号码：</p><blockquote>ls -i example.txt</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-817b4dc9ec2b2900491df0a168eb5311_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"95\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-817b4dc9ec2b2900491df0a168eb5311_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"95\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-817b4dc9ec2b2900491df0a168eb5311_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-817b4dc9ec2b2900491df0a168eb5311_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>五、目录文件</h2><p>Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。</p><p>目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的inode号码。</p><p>ls命令只列出目录文件中的所有文件名：</p><blockquote>ls /etc</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a6f7e98f0f0107caa76c8a25d9653fb5_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"94\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-a6f7e98f0f0107caa76c8a25d9653fb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"94\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic2.zhimg.com/v2-a6f7e98f0f0107caa76c8a25d9653fb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a6f7e98f0f0107caa76c8a25d9653fb5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>ls -i命令列出整个目录文件，即文件名和inode号码：</p><blockquote>ls -i /etc</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-93f0f9df512468a1fbed9d55cedcb214_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"107\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-93f0f9df512468a1fbed9d55cedcb214_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;107&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"107\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-93f0f9df512468a1fbed9d55cedcb214_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-93f0f9df512468a1fbed9d55cedcb214_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果要查看文件的详细信息，就必须根据inode号码，访问inode节点，读取信息。ls -l命令列出文件的详细信息。</p><blockquote>ls -l /etc</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-18f506021ac4b7ca1c64f6859f8b4ba7_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"160\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-18f506021ac4b7ca1c64f6859f8b4ba7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"160\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic4.zhimg.com/v2-18f506021ac4b7ca1c64f6859f8b4ba7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-18f506021ac4b7ca1c64f6859f8b4ba7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>理解了上面这些知识，就能理解目录的权限。目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内只有文件名和inode号码，所以如果只有读权限，只能获取文件名，无法获取其他信息，因为其他信息都储存在inode节点中，而读取inode节点内的信息需要目录文件的执行权限（x）。</p><h2>六、硬链接</h2><p>一般情况下，文件名和inode号码是&#34;一一对应&#34;关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名指向同一个inode号码。</p><p>这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一个文件名的访问。这种情况就被称为&#34;硬链接&#34;（hard link）。</p><p>ln命令可以创建硬链接：</p><blockquote>ln 源文件 目标文件</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d549dfec4bdcb988a41445239d9c5d6a_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"207\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-d549dfec4bdcb988a41445239d9c5d6a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;207&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"207\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-d549dfec4bdcb988a41445239d9c5d6a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d549dfec4bdcb988a41445239d9c5d6a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做&#34;链接数&#34;，记录指向该inode的文件名总数，这时就会增加1。</p><p>反过来，删除一个文件名，就会使得inode节点中的&#34;链接数&#34;减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收这个inode号码，以及其所对应block区域。</p><p>这里顺便说一下目录文件的&#34;链接数&#34;。创建目录时，默认会生成两个目录项：&#34;.&#34;和&#34;..&#34;。前者的inode号码就是当前目录的inode号码，等同于当前目录的&#34;硬链接&#34;；后者的inode号码就是当前目录的父目录的inode号码，等同于父目录的&#34;硬链接&#34;。所以，任何一个目录的&#34;硬链接&#34;总数，总是等于2加上它的子目录总数（含隐藏目录）。</p><h2>七、软链接</h2><p>除了硬链接以外，还有一种特殊情况。</p><p>文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的&#34;软链接&#34;（soft link）或者&#34;符号链接（symbolic link）。</p><p>这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错：&#34;No such file or directory&#34;。这是软链接与硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode&#34;链接数&#34;不会因此发生变化。</p><p>ln -s命令可以创建软链接。</p><blockquote>ln -s 源文文件或目录 目标文件或目录</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-cdde292000c8187ecdbcfd4526773f08_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"193\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-cdde292000c8187ecdbcfd4526773f08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;193&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"193\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-cdde292000c8187ecdbcfd4526773f08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-cdde292000c8187ecdbcfd4526773f08_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>八、inode的特殊作用</h2><p>由于inode号码与文件名分离，这种机制导致了一些Unix/Linux系统特有的现象。</p><ul><li>1. 有时，文件名包含特殊字符，无法正常删除。这时，直接删除inode节点，就能起到删除文件的作用。</li><li>2. 移动文件或重命名文件，只是改变文件名，不影响inode号码。</li><li>3. 打开一个文件以后，系统就以inode号码来识别这个文件，不再考虑文件名。因此，通常来说，系统无法从inode号码得知文件名。</li></ul><p>第3点使得软件更新变得简单，可以在不关闭软件的情况下进行更新，不需要重启。因为系统通过inode号码，识别运行中的文件，不通过文件名。更新的时候，新版文件以同样的文件名，生成一个新的inode，不会影响到运行中的文件。等到下一次运行这个软件的时候，文件名就自动指向新版文件，旧版文件的inode则被回收。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>END</p><hr/><p><b>如果喜欢我的文章，请长按二维码关注：cpp软件架构狮</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\"/></figure><p></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66051508", 
            "userName": "技术原理君", 
            "userLink": "https://www.zhihu.com/people/614efeb0fec90b6a46ae6dc8e5538f05", 
            "upvote": 4, 
            "title": "Linux信号（signal) 机制分析", 
            "content": "<h2><b>1，信号本质</b></h2><p>软中断信号（signal，又简称为信号）用来通知进程发生了异步事件。在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。进程之间可以互相通过系统调用kill发送软中断信号。内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p><p>收到信号的进程对各种信号有不同的处理方法。处理方法可以分为三类：</p><ul><li>第一种是类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。</li><li>第二种方法是，忽略某个信号，对该信号不做任何处理，就象未发生过一样。</li><li>第三种方法是，对该信号的处理保留系统的默认值，这种缺省操作，对大部分的信号的缺省操作是使得进程终止。进程通过系统调用signal来指定进程对某个信号的处理行为。</li></ul><h2><b>2，信号的种类</b></h2><p>可以从两个不同的分类角度对信号进行分类：</p><ul><li>可靠性方面：可靠信号与不可靠信号；</li><li>与时间的关系上：实时信号与非实时信号。</li></ul><h2><b>2.1，可靠信号与不可靠信号</b></h2><p>Linux信号机制基本上是从Unix系统中继承过来的。早期Unix系统中的信号机制比较简单和原始，信号值小于SIGRTMIN的信号都是不可靠信号。这就是&#34;不可靠信号&#34;的来源。它的主要问题是信号可能丢失。</p><p>随着时间的发展，实践证明了有必要对信号的原始机制加以改进和扩充。由于原来定义的信号已有许多应用，不好再做改动，最终只好又新增加了一些信号，并在一开始就把它们定义为可靠信号，这些信号支持排队，不会丢失。</p><p>信号值位于SIGRTMIN和SIGRTMAX之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。Linux在支持新版本的信号安装函数sigation()以及信号发送函数sigqueue()的同时，仍然支持早期的signal()信号安装函数，支持信号发送函数kill()。</p><p>信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。目前linux中的signal()是通过sigation()函数实现的，因此，即使通过signal()安装的信号，在信号处理函数的结尾也不必再调用一次信号安装函数。同时，由signal()安装的实时信号支持排队，同样不会丢失。</p><p>对于目前linux的两个信号安装函数：signal()及sigaction()来说，它们都不能把SIGRTMIN以前的信号变成可靠信号（都不支持排队，仍有可能丢失，仍然是不可靠信号），而且对SIGRTMIN以后的信号都支持排队。这两个函数的最大区别在于，经过sigaction安装的信号都能传递信息给信号处理函数，而经过signal安装的信号不能向信号处理函数传递信息。对于信号发送函数来说也是一样的。</p><h2><b>2.2，实时信号与非实时信号</b></h2><p>早期Unix系统只定义了32种信号，前32种信号已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号都有各自的缺省动作。如按键盘的CTRL ^C时，会产生SIGINT信号，对该信号的默认反应就是进程终止。后32个信号表示实时信号，等同于前面阐述的可靠信号。这保证了发送的多个实时信号都被接收。</p><p>非实时信号都不支持排队，都是不可靠信号；</p><p>实时信号都支持排队，都是可靠信号。</p><h2><b>3， 信号处理流程</b></h2><p>对于一个完整的信号生命周期(从信号发送到相应的处理函数执行完毕)来说，可以分为三个阶段：</p><ul><li>信号诞生</li><li>信号在进程中注册</li><li>信号的执行和注销</li></ul><h2><b>3.1，信号诞生</b></h2><p>信号事件的发生有两个来源：硬件来源(比如我们按下了键盘或者其它硬件故障)；软件来源，最常用发送信号的系统函数是kill, raise, alarm和setitimer以及sigqueue函数，软件来源还包括一些非法运算等操作。</p><p>这里按发出信号的原因简单分类，以了解各种信号：</p><ol><li>与进程终止相关的信号。当进程退出，或者子进程终止时，发出这类信号。</li><li>与进程例外事件相关的信号。如进程越界，或企图写一个只读的内存区域（如程序正文区），或执行一个特权指令及其他各种硬件错误。</li><li>与在系统调用期间遇到不可恢复条件相关的信号。如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。</li><li>与执行系统调用时遇到非预测错误条件相关的信号。如执行一个并不存在的系统调用。</li><li>在用户态下的进程发出的信号。如进程调用系统调用kill向其他进程发送信号。</li><li>与终端交互相关的信号。如用户关闭一个终端，或按下break键等情况。</li><li>跟踪进程执行的信号。</li></ol><p>Linux支持的信号列表如下。很多信号是与机器的体系结构相关的</p><p>信号值 默认处理动作 发出信号的原因</p><p>SIGHUP 1 A 终端挂起或者控制进程终止</p><p>SIGINT 2 A 键盘中断（如break键被按下）</p><p>SIGQUIT 3 C 键盘的退出键被按下</p><p>SIGILL 4 C 非法指令</p><p>SIGABRT 6 C 由abort(3)发出的退出指令</p><p>SIGFPE 8 C 浮点异常</p><p>SIGKILL 9 AEF Kill信号</p><p>SIGSEGV 11 C 无效的内存引用</p><p>SIGPIPE 13 A 管道破裂: 写一个没有读端口的管道</p><p>SIGALRM 14 A 由alarm(2)发出的信号</p><p>SIGTERM 15 A 终止信号</p><p>SIGUSR1 30,10,16 A 用户自定义信号1</p><p>SIGUSR2 31,12,17 A 用户自定义信号2</p><p>SIGCHLD 20,17,18 B 子进程结束信号</p><p>SIGCONT 19,18,25 进程继续（曾被停止的进程）</p><p>SIGSTOP 17,19,23 DEF 终止进程</p><p>SIGTSTP 18,20,24 D 控制终端（tty）上按下停止键</p><p>SIGTTIN 21,21,26 D 后台进程企图从控制终端读</p><p>SIGTTOU 22,22,27 D 后台进程企图从控制终端写</p><p>处理动作一项中的字母含义如下</p><ul><li>A 缺省的动作是终止进程</li><li>B 缺省的动作是忽略此信号，将该信号丢弃，不做处理</li><li>C 缺省的动作是终止进程并进行内核映像转储（dump core），内核映像转储是指将进程数据在内存的映像和进程在内核结构中的部分内容以一定格式转储到文件系统，并且进程退出执行，这样做的好处是为程序员提供了方便，使得他们可以得到进程当时执行时的数据值，允许他们确定转储的原因，并且可以调试他们的程序。</li><li>D 缺省的动作是停止进程，进入停止状况以后还能重新进行下去，一般是在调试的过程中（例如ptrace系统调用）</li><li>E 信号不能被捕获</li><li>F 信号不能被忽略</li></ul><h2><b>3.2,信号在目标进程中注册</b></h2><p>在进程表的表项中有一个软中断信号域，该域中每一位对应一个信号。内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。如果发送给一个处于可运行状态的进程，则只置相应的域即可。</p><p>进程的task_struct结构中有关于本进程中未决信号的数据成员： </p><p>struct sigpending pending：</p><blockquote>struct sigpending{<br/>        struct sigqueue *head, *tail;<br/>        sigset_t signal;<br/>};</blockquote><p>第三个成员是进程中所有未决信号集.</p><p>第一、第二个成员分别指向一个sigqueue类型的结构链（称之为&#34;未决信号信息链&#34;）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:</p><blockquote>struct sigqueue{<br/>        struct sigqueue *next;<br/>        siginfo_t info;<br/>}</blockquote><p>信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该信号被进程阻塞。</p><p>当一个实时信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失，因此，实时信号又叫做&#34;可靠信号&#34;。这意味着同一个实时信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个实时信号，都会为它分配一个结构来登记该信号信息，并把该结构添加在未决信号链尾，即所有诞生的实时信号都会在目标进程中注册）。</p><p>当一个非实时信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失。因此，非实时信号又叫做&#34;不可靠信号&#34;。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。</p><p>总之信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）</p><h2><b>3.3，信号的执行和注销</b></h2><p>内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当其由于被信号唤醒或者正常调度重新获得CPU时，在其从内核空间返回到用户空间时会检测是否有信号等待处理。如果存在未决信号等待处理且该信号没有被进程阻塞，则在运行相应的信号处理函数前，进程会把信号在未决信号链中占有的结构卸掉。</p><p>对于非实时信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）；而对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，因此应该针对占用sigqueue结构的数目区别对待：如果只占用一个sigqueue结构（进程只收到该信号一次），则执行完相应的处理函数后应该把信号在进程的未决信号集中删除（信号注销完毕）。否则待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号。</p><p>当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。</p><p>内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。</p><p>处理信号有三种类型：</p><ul><li>进程接收到信号后退出；</li><li>进程忽略该信号；</li><li>进程收到信号后执行用户设定用系统调用signal的函数。</li></ul><p>当进程接收到一个它忽略的信号时，进程丢弃该信号，就象没有收到该信号似的继续运行。如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。而且执行用户定义的函数的方法很巧妙，内核是在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。</p><p>END</p><hr/><p><b>如果喜欢我的文章，请长按二维码关注：cpp软件架构狮</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"688\" data-rawheight=\"688\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-afeca3f65a3307a220bc1438f155cf8f_b.jpg\"/></figure><p></p>", 
            "topic": [], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1038427674183573504"
}
