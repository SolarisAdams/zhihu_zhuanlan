{
    "title": "无服务器(Serverless)架构", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/wang-xiang-zhong-5", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/reed-84-49"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/65106115", 
            "userName": "王浚立", 
            "userLink": "https://www.zhihu.com/people/bc4be4698609edee072f3d42c3cf5420", 
            "upvote": 6, 
            "title": "创建无服务器的WebSocket应用", 
            "content": "<p>近期AWS 的API Gateway做了一次<a href=\"https://link.zhihu.com/?target=https%3A//aws.amazon.com/cn/blogs/compute/announcing-websocket-apis-in-amazon-api-gateway/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">更新</a>，开发者可以在API Gateway中使用websocket API从而建立服务和应用的双向通讯，同时也无需管理任何服务器。让我们来探究一下如何使用这个新功能吧。</p><p>首先我们先来比较一下WebSocket和传统HTTP的区别。</p><p>基于HTTP的API是一种请求和响应的模型，也就是一个客户端发起一个请求到一个服务，然后服务同步地响应客户端的请求。而基于WebSocket的API实质上则是双向的。也就是说，客户端可以发送消息到一个服务，同时服务也可以独立的发送消息到客户端。</p><p>这种双向通讯使得服务和客户端的交互更具多样性，因为服务不需要客户端显式请求就能向客户端推送数据。 通常一些实时应用会使用WebSocket API，比如聊天应用，协作平台，多人游戏，金融交易平台等。</p><p>让我们言归正传，演示下如何使用WebSocket API和API Gateway来搭建一个无服务，实时的聊天应用。</p><h2><b>简介</b></h2><p>以前，为了写WebSocket API需要搞一堆机器用于管理持久化连接。这些工作在用了API Gateway之后就没必要了。API Gateway会处理客户端和服务之间的连接，你就更能专注于写自己的业务逻辑。</p><p>在阅读文章之前，先要理解几个WebSocket API在API Gateway中的概念。第一个就是叫做`<b>route</b>`（路由）的资源类型。它描述了API Gateway该如何处理特定类型的客户端请求，它包含了一个`<b>routeKey</b>` 参数和一个用于区分route的值。</p><p>一个WebSocket API可能由一个或多个route组成。你要写一个路由选择表达式用于决定每个请求使用哪个路由。每次请求到达的时候，就会根据这个表达式来生成一个值，然后这个值就会对应到routeKey。</p><p>API Gateway允许定义三种特殊的routeKey值</p><ol><li><b>$default</b>-当路由选择表达式产生的值无法对应到任何routeKey上的时候，会被触发，可以用于实现一些通用的错误处理</li><li><b>$connect</b>-当客户端首次连接上你的WebSocket API使用的路由</li><li><b>$disconnect</b>-当客户端从API断开时使用的路由</li></ol><p>这些特殊的routeKey不是必须要定义的。</p><h2>如何做一个无服务器的实时聊天应用</h2><p>为了让大家理解如何使用API Gateway的WebSocket API功能，这里会演示如何构建一个实时的聊天室应用。简化起见，我们假定这个应用里面只有一个聊天室，它包含以下功能</p><p>1. 客户端在连接上WebSocket 之后加入聊天室</p><p>2. 用户连上WebSocket之后提供一个回调URL，后端可以通过调用这个回调url向特定用户发送消息。</p><p>3. 用户可以向聊天室发送消息</p><p>4. 客户端断开连接后，会被移出聊天室</p><p>以下是一个总览图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e29cae3100a1184ace9aba656e629019_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"747\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb\" width=\"747\" data-original=\"https://pic2.zhimg.com/v2-e29cae3100a1184ace9aba656e629019_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;747&#39; height=&#39;429&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"747\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"747\" data-original=\"https://pic2.zhimg.com/v2-e29cae3100a1184ace9aba656e629019_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e29cae3100a1184ace9aba656e629019_b.jpg\"/></figure><p>图中1，表示WebSocket放在API Gateway中，用于管理客户端和服务器的连接。图中2和5分别对应用于响应客户端连接和断开连接时的AWS lambda云函数。 图中3表示当客户端向服务器发请求后一个云函数被触发， 服务器可以使用新API Gateway 的API向所有连接上的客户端发送消息（图中4）。Connection Id则存放在DynamoDB的表中以追踪所有已连接的客户端。</p><p>这里有个github 的repo存放<a href=\"https://link.zhihu.com/?target=https%3A//github.com/aws-samples/simple-websockets-chat-app\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">示例代码</a>。</p><h2>创建一个新的WebSocket API</h2><ol><li>在API Gateway控制台中，选择创建API，新API</li><li>在选择协议中，选择WebSocket</li><li>输入My Chat API作为API名称</li><li>对于路由选择表达式，输入<b>$request.body.action</b></li></ol><p>在路由选择表达式中定义的属性要确保存在于每条发至API的消息中，例如</p><div class=\"highlight\"><pre><code class=\"language-json\"><span class=\"p\">{</span>\n    <span class=\"nt\">&#34;action&#34;</span><span class=\"p\">:</span> <span class=\"s2\">&#34;sendmessage&#34;</span><span class=\"p\">,</span>\n    <span class=\"nt\">&#34;data&#34;</span><span class=\"p\">:</span> <span class=\"err\">&#34;你好，我是一条消息”</span>\n<span class=\"p\">}</span></code></pre></div><h2>管理路由</h2><p>你现在可以配置新的API用来响应请求了。对于这个app，就照着前面说的创建三个路由。</p><p>首先，创建一个sendMessage路由并和一个lambda云函数结合</p><ol><li>在API Gateway控制台中，在My Chat API下，选择路由</li><li>选 新的路由Key，输入sendmessage，然后确认</li></ol><p>创建完之后，就可以用一个lambda云函数和它集成了，以下是云函数的部分代码</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">DDB</span><span class=\"p\">.</span><span class=\"nx\">scan</span><span class=\"p\">(</span><span class=\"nx\">scanParams</span><span class=\"p\">,</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 为了简洁删除部分代码\n</span><span class=\"c1\"></span>   <span class=\"kd\">var</span> <span class=\"nx\">apigwManagementApi</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">AWS</span><span class=\"p\">.</span><span class=\"nx\">ApiGatewayManagementApi</span><span class=\"p\">({</span>\n      <span class=\"nx\">apiVersion</span><span class=\"o\">:</span> <span class=\"s2\">&#34;2018-11-29&#34;</span><span class=\"p\">,</span>\n      <span class=\"nx\">endpoint</span><span class=\"o\">:</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">requestContext</span><span class=\"p\">.</span><span class=\"nx\">domainName</span> <span class=\"s2\">&#34; /&#34;</span> <span class=\"o\">+</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">requestContext</span><span class=\"p\">.</span><span class=\"nx\">stage</span>\n   <span class=\"p\">});</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">postParams</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n        <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">parse</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">).</span><span class=\"nx\">data</span>\n    <span class=\"p\">};</span>\n    <span class=\"kd\">let</span> <span class=\"nx\">callbackArray</span> <span class=\"o\">=</span> <span class=\"nx\">data</span><span class=\"p\">.</span><span class=\"nx\">Items</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span> <span class=\"kr\">async</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span> <span class=\"p\">...</span> <span class=\"p\">});</span>\n    <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">all</span><span class=\"p\">(</span><span class=\"nx\">callbackArray</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 为了简洁删除部分代码\n</span><span class=\"c1\"></span><span class=\"p\">});</span>\n</code></pre></div><p>当一个客户端发送一个action为‘sendmessage’的消息，这个云函数就会扫描DynamoDB表找到所有已连接的客户端，对于每个客户端都使用提供的数据发送信息。</p><p>剩下的要做的，就是管理有哪些客户端已经连接到聊天室了，实现这个就使用特殊的routeKey，一个是$connect,另一个是$disconnect</p><p>以下onConnect函数是把requestContext中的connectionId插入到DynamoDB中</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">handler</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"nx\">context</span><span class=\"p\">,</span> <span class=\"nx\">callback</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">putParams</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">TableName</span><span class=\"o\">:</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">TABLE_NAME</span><span class=\"p\">,</span>\n    <span class=\"nx\">Item</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">connectionId</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">S</span><span class=\"o\">:</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">requestContext</span><span class=\"p\">.</span><span class=\"nx\">connectionId</span> <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">};</span>\n\n  <span class=\"nx\">DDB</span><span class=\"p\">.</span><span class=\"nx\">putItem</span><span class=\"p\">(</span><span class=\"nx\">putParams</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">,</span> <span class=\"nx\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n      <span class=\"nx\">statusCode</span><span class=\"o\">:</span> <span class=\"nx\">err</span> <span class=\"o\">?</span> <span class=\"mi\">500</span> <span class=\"o\">:</span> <span class=\"mi\">200</span><span class=\"p\">,</span>\n      <span class=\"nx\">body</span><span class=\"o\">:</span> <span class=\"nx\">err</span> <span class=\"o\">?</span> <span class=\"s2\">&#34;Failed to connect: &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"s2\">&#34;Connected&#34;</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>onDisconnect函数是把特定的connectionId值移出</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">exports</span><span class=\"p\">.</span><span class=\"nx\">handler</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">event</span><span class=\"p\">,</span> <span class=\"nx\">context</span><span class=\"p\">,</span> <span class=\"nx\">callback</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"kd\">var</span> <span class=\"nx\">deleteParams</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">TableName</span><span class=\"o\">:</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">TABLE_NAME</span><span class=\"p\">,</span>\n    <span class=\"nx\">Key</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n      <span class=\"nx\">connectionId</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">S</span><span class=\"o\">:</span> <span class=\"nx\">event</span><span class=\"p\">.</span><span class=\"nx\">requestContext</span><span class=\"p\">.</span><span class=\"nx\">connectionId</span> <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">};</span>\n\n  <span class=\"nx\">DDB</span><span class=\"p\">.</span><span class=\"nx\">deleteItem</span><span class=\"p\">(</span><span class=\"nx\">deleteParams</span><span class=\"p\">,</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">callback</span><span class=\"p\">(</span><span class=\"kc\">null</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n      <span class=\"nx\">statusCode</span><span class=\"o\">:</span> <span class=\"nx\">err</span> <span class=\"o\">?</span> <span class=\"mi\">500</span> <span class=\"o\">:</span> <span class=\"mi\">200</span><span class=\"p\">,</span>\n      <span class=\"nx\">body</span><span class=\"o\">:</span> <span class=\"nx\">err</span> <span class=\"o\">?</span> <span class=\"s2\">&#34;Failed to disconnect: &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"s2\">&#34;Disconnected.&#34;</span>\n    <span class=\"p\">});</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>前面提到，onDisconnect函数不一定会被调用。为了防止反复重试失效的连接，就在发送消息的逻辑里多做一些处理，当发现connection不再有效时，就把对应的id从DynamoDb里删除。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">.</span><span class=\"nx\">statusCode</span> <span class=\"o\">===</span> <span class=\"mi\">410</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;Found stale connection, deleting &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">postParams</span><span class=\"p\">.</span><span class=\"nx\">connectionId</span><span class=\"p\">);</span>\n  <span class=\"nx\">DDB</span><span class=\"p\">.</span><span class=\"nx\">deleteItem</span><span class=\"p\">({</span> <span class=\"nx\">TableName</span><span class=\"o\">:</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">TABLE_NAME</span><span class=\"p\">,</span>\n                   <span class=\"nx\">Key</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">connectionId</span><span class=\"o\">:</span> <span class=\"p\">{</span> <span class=\"nx\">S</span><span class=\"o\">:</span> <span class=\"nx\">postParams</span><span class=\"p\">.</span><span class=\"nx\">connectionId</span> <span class=\"p\">}</span> <span class=\"p\">}</span> <span class=\"p\">});</span>\n<span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s2\">&#34;Failed to post. Error: &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">JSON</span><span class=\"p\">.</span><span class=\"nx\">stringify</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>部署WebSocket API</h2><p>接下来就是部署WebSocket API了,由于是第一次部署，就需要创建一个stage，例如‘dev’，然后写一下描述。</p><p>Stage编辑器会显示你API的所有信息，例如设置，日志，变量以及部署历史。与此同时，记得要确认一下API的限制。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-777500548a3b6a2e836c201ff97be34b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-777500548a3b6a2e836c201ff97be34b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;618&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-777500548a3b6a2e836c201ff97be34b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-777500548a3b6a2e836c201ff97be34b_b.jpg\"/></figure><h2>测试聊天API</h2><p>可以使用wscat测试API</p><ol><li>安装npm</li><li>安装wscat</li></ol><div class=\"highlight\"><pre><code class=\"language-bash\">$ npm install -g wscat</code></pre></div><p>3. 在命令行中，可以用这个命令连接上websocket</p><div class=\"highlight\"><pre><code class=\"language-bash\">$ wscat -c wss://<span class=\"o\">{</span>YOUR-API-ID<span class=\"o\">}</span>.execute-api.<span class=\"o\">{</span>YOUR-REGION<span class=\"o\">}</span>.amazonaws.com/<span class=\"o\">{</span>STAGE<span class=\"o\">}</span></code></pre></div><p>4. 要测试sendmessage函数的话，就像如下发送json消息就行了，Lambda云函数就会使用回调URL返回消息。</p><div class=\"highlight\"><pre><code class=\"language-bash\">$ wscat -c wss://<span class=\"o\">{</span>YOUR-API-ID<span class=\"o\">}</span>.execute-api.<span class=\"o\">{</span>YOUR-REGION<span class=\"o\">}</span>.amazonaws.com/dev\nconnected <span class=\"o\">(</span>press CTRL+C to quit<span class=\"o\">)</span>\n&gt; <span class=\"o\">{</span><span class=\"s2\">&#34;action&#34;</span>:<span class=\"s2\">&#34;sendmessage&#34;</span>, <span class=\"s2\">&#34;data&#34;</span>:<span class=\"s2\">&#34;hello world&#34;</span><span class=\"o\">}</span>\n&lt; hello world</code></pre></div><h2>结语</h2><p>这篇文章主要针对亚马逊API Gateway升级指导大家如何创建无服务器的WebSocket应用。大家可以以此为参考，在自己熟悉的PaaS平台来构建自己的WebSocket应用。</p><hr/><p>考虑到一些读者的阅读习惯，我们还建立了“无服务器架构 Serverless”微信公众号，满足不同人群的阅读需求~ 欢迎大家关注！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-695b2e13f1bef188339121e77b91c340_b.jpg\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image\" width=\"258\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;258&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"258\" data-rawheight=\"258\" class=\"content_image lazy\" width=\"258\" data-actualsrc=\"https://pic1.zhimg.com/v2-695b2e13f1bef188339121e77b91c340_b.jpg\"/><figcaption>“无服务器架构 Serverless”微信公众号二维码</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "Serverless", 
                    "tagLink": "https://api.zhihu.com/topics/20086226"
                }, 
                {
                    "tag": "Amazon Web Services (AWS)", 
                    "tagLink": "https://api.zhihu.com/topics/19558548"
                }, 
                {
                    "tag": "WebSocket", 
                    "tagLink": "https://api.zhihu.com/topics/19657811"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1090926874267275264"
}
