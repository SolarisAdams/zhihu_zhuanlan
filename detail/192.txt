{
    "title": "leslee爱学习", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/liu-yu-hang-de-ji-qi-ren-di-guo", 
        "https://www.zhihu.com/people/tu-jia-xing-77", 
        "https://www.zhihu.com/people/xingchenzhang", 
        "https://www.zhihu.com/people/joine-77", 
        "https://www.zhihu.com/people/laurel-83-90", 
        "https://www.zhihu.com/people/li-ling-12-18-63", 
        "https://www.zhihu.com/people/the-king-85", 
        "https://www.zhihu.com/people/yuanye-83-29", 
        "https://www.zhihu.com/people/yg2018-35", 
        "https://www.zhihu.com/people/hqwsky", 
        "https://www.zhihu.com/people/jiang-yi-fan-97-77", 
        "https://www.zhihu.com/people/nan-pu-2", 
        "https://www.zhihu.com/people/aitracker", 
        "https://www.zhihu.com/people/liu-liang-48-82", 
        "https://www.zhihu.com/people/frank-22-12", 
        "https://www.zhihu.com/people/tang-73", 
        "https://www.zhihu.com/people/zhi-xue-xing-yi", 
        "https://www.zhihu.com/people/lu-zai-jiao-xia-36", 
        "https://www.zhihu.com/people/zai-jian-feng-yun-9", 
        "https://www.zhihu.com/people/he-zheng-e", 
        "https://www.zhihu.com/people/rgb-d", 
        "https://www.zhihu.com/people/li-zi-wen-45", 
        "https://www.zhihu.com/people/zhang-yi-xin-49", 
        "https://www.zhihu.com/people/oliver-kahn-60", 
        "https://www.zhihu.com/people/peng-zheng-62-65", 
        "https://www.zhihu.com/people/wang-peng-cheng-39-36", 
        "https://www.zhihu.com/people/dakara", 
        "https://www.zhihu.com/people/liu-jun-51-66", 
        "https://www.zhihu.com/people/hanspond", 
        "https://www.zhihu.com/people/wayc-97", 
        "https://www.zhihu.com/people/song-wen-30", 
        "https://www.zhihu.com/people/yanzllll", 
        "https://www.zhihu.com/people/kong-he-zhuang-xin", 
        "https://www.zhihu.com/people/bie-kai-qiang-56", 
        "https://www.zhihu.com/people/catomy", 
        "https://www.zhihu.com/people/tjamc80", 
        "https://www.zhihu.com/people/fenggege", 
        "https://www.zhihu.com/people/li-ya-bo-93", 
        "https://www.zhihu.com/people/san-nian-yi-hou-shou", 
        "https://www.zhihu.com/people/zhao-xin-99-25", 
        "https://www.zhihu.com/people/liu-xing-bao-yu-47", 
        "https://www.zhihu.com/people/ykp-41", 
        "https://www.zhihu.com/people/deng-xiao-lin-58", 
        "https://www.zhihu.com/people/astronstar", 
        "https://www.zhihu.com/people/xue-wen-dong-17", 
        "https://www.zhihu.com/people/yuan-zhao-48", 
        "https://www.zhihu.com/people/dream-43-63-28", 
        "https://www.zhihu.com/people/xu-yin-da-58", 
        "https://www.zhihu.com/people/zhang-hui-peng-62", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/yang-pei-wen-22", 
        "https://www.zhihu.com/people/duan-xing-99", 
        "https://www.zhihu.com/people/pengchengma", 
        "https://www.zhihu.com/people/kai-wen-85", 
        "https://www.zhihu.com/people/yeu-yang", 
        "https://www.zhihu.com/people/zhang-xin-sheng-74", 
        "https://www.zhihu.com/people/karry-70-61", 
        "https://www.zhihu.com/people/wang-jing-bo-27-88", 
        "https://www.zhihu.com/people/whjxnyzh", 
        "https://www.zhihu.com/people/zhu-forrest", 
        "https://www.zhihu.com/people/feng-xing-long-5", 
        "https://www.zhihu.com/people/yildhd-wang", 
        "https://www.zhihu.com/people/heyang-36", 
        "https://www.zhihu.com/people/en-wei-29", 
        "https://www.zhihu.com/people/sunnyos", 
        "https://www.zhihu.com/people/a-ming-74-40"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/50763998", 
            "userName": "lichong", 
            "userLink": "https://www.zhihu.com/people/c811e6f611fa8223c032a581e7dc8d63", 
            "upvote": 86, 
            "title": "单级目标检测：YOLO与SSD，我选SSD！！！", 
            "content": "<p>大家好，我是leslee，又和大家见面了。这次的主人公是图像目标检测领域单级目标检测经典算法SSD和YOLO，但是这里我讲的主要是SSD和YOLO的异同，以及目前以我个人的见解，觉得SSD要优于YOLO的理由。</p><p>本文主要从下面几个方面讲：</p><ul><li>单级目标检测背景介绍</li><li>SSD和YOLO检测方法的差异，以及SSD 比YOLO好的原因</li></ul><hr/><ol><li>单级目标检测背景介绍</li></ol><p>目标检测：检测到图片当中目标的具体位置，需要做到两点： 目标在图像的哪儿-定位，目标是什么-分类</p><p>通常目标检测的方法有两个大的方向：</p><p>两级目标检测，主要是faster-rcnn等一系列two-stage方法</p><p>单级目标检测，主要是ssd和yolo为代表的one-stage方法</p><ul><li>两级目标检测</li></ul><p>两级目标检测的思想就是粗定位+细分类。简单点说就是先从图像里找到可能存在目标的位置，然后再对这些位置进行分类。该方法有一个明显的好处就是在分类的时候，提取的特征是存在目标的位置的整体特征，是一个框所在的位置的特征(尽管做了ROI_Pooling)，这是two-stage方法&#34;准&#34;的原因，同时由于要对目标框的全部特征进行分类，这也是该方法&#34;慢&#34;的原因。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-316a7e9e37e32492d7a38aa926602f41_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"407\" class=\"origin_image zh-lightbox-thumb\" width=\"785\" data-original=\"https://pic2.zhimg.com/v2-316a7e9e37e32492d7a38aa926602f41_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;785&#39; height=&#39;407&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"407\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"785\" data-original=\"https://pic2.zhimg.com/v2-316a7e9e37e32492d7a38aa926602f41_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-316a7e9e37e32492d7a38aa926602f41_b.jpg\"/></figure><ul><li>单级目标检测</li></ul><p>显然，单级目标检测器就是直接定位+分类了，没有粗定位筛选的过程。通俗点说就是所看即所见了。但是这个看要仔细看了，不然看错了就没法再更改了</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-dc60ebf60697e4ab5edec00d6ca94f3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"330\" class=\"content_image\" width=\"397\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;397&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"397\" data-rawheight=\"330\" class=\"content_image lazy\" width=\"397\" data-actualsrc=\"https://pic3.zhimg.com/v2-dc60ebf60697e4ab5edec00d6ca94f3a_b.jpg\"/></figure><hr/><p>2.  SSD和YOLO目标检测方法的差异，以及SSD 比YOLO好的原因</p><ul><li>YOLO不比SSD快</li></ul><p>       之前看论文和博客得到的结论基本都是YOLO是最快的算法，看了下算法实现，感觉确实也是这么回事，那么真的就是这样吗？</p><p>       作者这里均采用resnet50作为网络的backbones，网络结构均采用fpn，保证两者前面的网络一致，那么在SSD和YOLO的网络传输里，不同的部分只有如下代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">SSD\nloc_layers += [nn.Conv2d(in_channels, box * 4, kernel_size=3, padding=1)]\nconf_layers += [nn.Conv2d(in_channels, box * num_classes, kernel_size=3, padding=1)]\n总的 out_channels = box * (num_classes + 4)\nYOLO\nout_channels = box * (num_classes + 5)  or out_channels = box * (num_classes -1 + 5)\nconf_loc_layers += [nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)]\n这里box为特征图像素点对应的anchors个数</code></pre></div><p>通过代码分析可以知道，</p><p>如果YOLO在num_classes里不包含背景，是不是背景的区分放入前面的confidence置信度里，那么SSD和YOLO在网络的计算量上是一致的，YOLO只是将loc、cls两部分concat一起了。如果YOLO在num_classes里包含背景，那么SSD的网络计算量甚至比YOLO还要少。所以结论是，在网络传输速度上，YOLO是不比SSD快的！！！</p><ul><li>YOLO的正负样本产生，SSD也完全可同样的做，只是没必要</li></ul><p>我们先看看YOLO的正负样本是怎样生成的，这里先盗用boss的一张图，如下图所示，目标的中心点落在了橘黄网格中，橘黄网格及其网格所代表的anchors就负责正例区域，绿色网格及其网格对应的anchors 与目标的IOU很小，作为负例样本。白色网格及其网格对应的anchors与目标的IOU比较大，但是目标的中心点不在该网格类，这类样本不参与训练。因此，这就是与SSD最大的不同了，在SSD里，看的是所有anchors与目标的IOU距离，如果IOU大于0.7，所在的anchors都是正例样本。而在YOLO里，只看中心点所在的网格对应的anchors,其他与之对应的anchors要么当作负样本了，要么就不参与训练了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1e5e63b597bbcbe9b3f5c8bdddae8bdd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"853\" data-rawheight=\"841\" class=\"origin_image zh-lightbox-thumb\" width=\"853\" data-original=\"https://pic2.zhimg.com/v2-1e5e63b597bbcbe9b3f5c8bdddae8bdd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;853&#39; height=&#39;841&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"853\" data-rawheight=\"841\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"853\" data-original=\"https://pic2.zhimg.com/v2-1e5e63b597bbcbe9b3f5c8bdddae8bdd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1e5e63b597bbcbe9b3f5c8bdddae8bdd_b.jpg\"/></figure><p>这里YOLO的方法就有几个问题与好处。</p><p>问题是，临近区域产生的相近的anchors如果当作负样本，会导致相似的样本当作负样本里，显然，准确率会提高，但是召回率会大大降低，而且正负样本比例也会比SSD更加严重</p><p>好处是，anchors的选择只在中心点所在的网格内，那么实际上不必要产生真实的anchors，因为先确定了中心点，anchors就只需要长和宽了，并不需要位置信息了，这是与SSD的不同之处，这样在测试计算的时候可以省一点时间，但是作者认为这个省不了太多时间。</p><p>同时还可以注意到，YOLO产生正负样本的方式，SSD可以用同样的方式产生这些样本。因为SSD产生的anchors有位置信息，只需要对位置信息按照YOLO的规则做一次过滤即可，但作者觉得YOLO的样本方式是一个缺陷，SSD没必要这么做</p><ul><li>YOLO的损失函数实现过于复杂，难以调参</li></ul><p>看下面的代码表明，YOLO在位置回归上，用的是MSE回归，采用MSE回归的方法对归一化的数值很敏感，某些长宽比不一致，但是IOU却很大的目标的回归产生的loss会比较大。作者后续准备直接采用SSD里的smooth_L1_loss替换。而在是不是目标的损失函数里，YOLO采用sigmoid+cross entropy，但是YOLO是将大量的负例(几乎是全部的负例，除了正样本所在网格区域的某些IOU比较大的anchors外)，这个步骤其实SSD也可以做，只是SSD并没有这样做，因为这样会导致正负样本严重不平衡。实验神奇的一点是，负样本太多，应该是召回低准确高，产生的噪声少才对，但是作者实验里确产生了更多的噪声！！于是作者又在分类那里加入了负样本类别，同时负样本类别的挑选仿照SSD里的方式。</p><div class=\"highlight\"><pre><code class=\"language-text\">SSD的损失函数：\nloss_l = F.smooth_l1_loss(loc_p, loc_t, size_average=False)\nloss_c = F.cross_entropy(conf_p, targets_weighted, size_average=False)\n\nYOLO的损失函数：\nself.mse_loss = nn.MSELoss(reduction=&#39;mean&#39;)  # Coordinate loss\nself.bce_loss = nn.BCELoss(reduction=&#39;mean&#39;)  # Confidence loss\nself.ce_loss = nn.CrossEntropyLoss(reduction=&#39;mean&#39;)  # Class loss\nhard_negatives = negatives[pred_conf[conf_mask_false] &gt; 0.8]\nhard_negsamples = hard_negatives[rand_index]\neasy_negatives = negatives[pred_conf[conf_mask_false] &lt; 0.8]\neasy_negsamples = easy_negatives[easy_rand_index]\nnegsamples = torch.cat([hard_negsamples,easy_negsamples])\nneglabels = torch.zeros(negsamples.shape[0]).type(LongTensor)\ncls_samples =  torch.cat([pred_cls[mask],negsamples])\ncls_labels = torch.cat([torch.argmax(tcls[mask], 1),neglabels])\nloss_cls = self.ce_loss(cls_samples, cls_labels)\nloss_x = self.mse_loss(x[mask], tx[mask])\nloss_y = self.mse_loss(y[mask], ty[mask])\nloss_w = self.mse_loss(w[mask], tw[mask])\nloss_h = self.mse_loss(h[mask], th[mask])\nloss_conf = self.bce_loss(pred_conf[conf_mask_false], tconf[conf_mask_false]) \n+ self.bce_loss(pred_conf[conf_mask_true], tconf[conf_mask_true])  </code></pre></div><ul><li>初步的实验结果</li></ul><p>作者这里是对短视频里的人手做检测，目标只有两类，手+负样本，特征缩放尺度选择了16，32，64。anchors的ratios和scales如下参数配置</p><div class=\"highlight\"><pre><code class=\"language-text\">FX_SCALES: [[32,48,64,80],[128,192],[256]]\n#### width / height\nFX_RATIOS: [[0.5,1,2],[0.5,1,2],[0.5,1,2]]\nFX_STEPS: [16,32,64]\nFRAMEWORKS: leslee_resnet\nBACKBONES: ResNet50_conv4_body\nPadding_Size: 416\nNUM_CLASSES: 2\nFEATURE_LAYER: [[&#39;res4&#39;, &#39;S&#39;,&#39;S&#39;], [1024,512,256]]</code></pre></div><p>实验结果：</p><p>首先，同样的网络和初始化和参数配置，训练YOLO需要更小的学习率0.0001，ssd的为0.001。过大在lossh和lossw上会爆炸，应该是YOLO采用了MES，而w和h的归一化偏差数值受到anchors大小和长宽比的影响比较大</p><p>然后，同样的网络和初始化和参数配置，在手势检测上，SSD的效果要明显好于YOLO，收敛也更快。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2e2ae6d36c9d0ebb8e5fdcaef6f6736d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"262\" data-rawheight=\"75\" class=\"content_image\" width=\"262\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;262&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"262\" data-rawheight=\"75\" class=\"content_image lazy\" width=\"262\" data-actualsrc=\"https://pic2.zhimg.com/v2-2e2ae6d36c9d0ebb8e5fdcaef6f6736d_b.jpg\"/></figure><p>最后的问题：</p><p>由于是两类，除了手就是负样本，根据原始的YOLO算法，是不需要后面的类别分类的，只需要回答是不是目标，以及目标的位置，作者同样跑了实验，结果确是要非常高的阈值才能提高准确率，否则会有非常多的噪声，这貌似跟YOLO的原理负样本参与训练的数目远远大于正样本这一事实矛盾啊，以后作者再多做实验分析吧。。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1e7d0ebab83ae9055dc90ec398c8afc6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"990\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb\" width=\"990\" data-original=\"https://pic3.zhimg.com/v2-1e7d0ebab83ae9055dc90ec398c8afc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;990&#39; height=&#39;724&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"990\" data-rawheight=\"724\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"990\" data-original=\"https://pic3.zhimg.com/v2-1e7d0ebab83ae9055dc90ec398c8afc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1e7d0ebab83ae9055dc90ec398c8afc6_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "目标检测", 
                    "tagLink": "https://api.zhihu.com/topics/19596960"
                }, 
                {
                    "tag": "固态硬盘", 
                    "tagLink": "https://api.zhihu.com/topics/19562697"
                }, 
                {
                    "tag": "计算机视觉", 
                    "tagLink": "https://api.zhihu.com/topics/19590195"
                }
            ], 
            "comments": [
                {
                    "userName": "何志", 
                    "userLink": "https://www.zhihu.com/people/876aabe6908d956a157c6851f00ba680", 
                    "content": "当初看yolo的时候就一直有这样的疑问，一个目标一般会占好几个格子，难道就只有中间的是正样本，其它的就作负样本了？一开始还以为自己理解错了，后来发现它确实是这么干的。。。。", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "第一次看yolo就对他的正负样本均衡问题很怀疑，虽然他加了权重", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "zonechan", 
                    "userLink": "https://www.zhihu.com/people/3c7cfb0c4d596e618a6e282daf4d282e", 
                    "content": "大佬。yolov1里面。。。不叫anchor。。。v2才有anchor。。", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "可乐", 
                    "userLink": "https://www.zhihu.com/people/ab1817099280ad8f3b0e2b8f8e0bf1b3", 
                    "content": "我是谁，我在哪儿？为什么给我推这个？这说的是啥？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "良月有风", 
                            "userLink": "https://www.zhihu.com/people/9a7c3f79b390c61b2971029b0bef3d1c", 
                            "content": "Hhhh因为作者把这个归分到固态硬盘话题了", 
                            "likes": 4, 
                            "replyToAuthor": "可乐"
                        }, 
                        {
                            "userName": "雷雷学长", 
                            "userLink": "https://www.zhihu.com/people/e2cfcf21a4a90ddb3f18223226a1c752", 
                            "content": "我也是！！这特么是啥？为啥会给我推这个", 
                            "likes": 0, 
                            "replyToAuthor": "可乐"
                        }
                    ]
                }, 
                {
                    "userName": "王司图", 
                    "userLink": "https://www.zhihu.com/people/59fcae62596fb6ba08f2860a5fe6f171", 
                    "content": "YOLO v1每个格子只预测同一类别的两个框，所以速度快准确率低。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "许胤达", 
                    "userLink": "https://www.zhihu.com/people/c468a1082c7bd317674f085d8252fc57", 
                    "content": "怪不得文本检测的textbox++会站队ssd", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "科密中的科蜜", 
                    "userLink": "https://www.zhihu.com/people/444bcf797b0250b6fea7cb121fb07c3b", 
                    "content": "SSD是IOU大于0.5吧，大佬你是哪个公司的？", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>我怎么感觉这样对比怪怪的，太粗暴了，而且不够严谨</p>", 
                    "likes": 3, 
                    "childComments": []
                }, 
                {
                    "userName": "程诺", 
                    "userLink": "https://www.zhihu.com/people/71752ad99513d2ff4f1e0b179a453deb", 
                    "content": "V1的效果的确不行，但是v2和v3真的很牛", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "wxrui", 
                    "userLink": "https://www.zhihu.com/people/5102eae617d3e3e54415b58091bc10f4", 
                    "content": "<p>为什么实验结果中YOLO的召回率反而是比较高的..</p>", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "小小鸟", 
                    "userLink": "https://www.zhihu.com/people/266349c7dd5f3cccadff153500def315", 
                    "content": "<p>根据这两个算法出来的先后顺序，也基本能判断SSD准确率高于YOLO呀，毕竟YOLO最大特点是速度快。</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "hao", 
                    "userLink": "https://www.zhihu.com/people/f097dddb87ae9ff0ee7a1b150a506f0e", 
                    "content": "<p>你说SSD比yolo快，恩论文里是这样说的，但是SSD的输入尺寸是300，YOLO是418感觉是快在输入尺寸上的。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48249974", 
            "userName": "lichong", 
            "userLink": "https://www.zhihu.com/people/c811e6f611fa8223c032a581e7dc8d63", 
            "upvote": 51, 
            "title": "KCF相关滤波跟踪算法", 
            "content": "<p>论文下载地址：<a href=\"https://link.zhihu.com/?target=https%3A//ieeexplore.ieee.org/abstract/document/6870486\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">kcf_paper</a></p><p>写作理由：看了网上各种版本的kcf原理，都不是特别理解(主要是不能特别说服我，哈哈)。详细琢磨了下，谈谈自己的理解，本人水平有限，难免有理解不到位的地方，请大家批评指正</p><p>本文主要会从下面几个方面讲：</p><ul><li>目标跟踪背景情况介绍</li><li>跟踪数学建模</li><li>模型优化</li><li>KCF工程实现</li></ul><ol><li>目标跟踪背景情况介绍</li></ol><p>       视觉目标跟踪是计算机视觉中的一个重要研究方向，有着广泛的应用，如：视频监控，人机交互， 无人驾驶等。但同时又是一个很混乱的方向，也是一个工程占主导的研究方向，在相关滤波和深度学习方法出现之前，大家更多的是各自为战，提出工程性的方法解决跟踪问题</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c35d322c8e627452660b73223cd667ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb\" width=\"820\" data-original=\"https://pic3.zhimg.com/v2-c35d322c8e627452660b73223cd667ea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;820&#39; height=&#39;474&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"820\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"820\" data-original=\"https://pic3.zhimg.com/v2-c35d322c8e627452660b73223cd667ea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c35d322c8e627452660b73223cd667ea_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>但是在14年KCF相关滤波算法出来之后，基本就相当于alexnet之于深度学习的地位。下图是KCF系列算法(KCF、DCF、MOSSE，其中MOSSE是目标跟踪领域的第一篇相关滤波类方法，真正第一次显示了相关滤波的潜力,只是由于选取特征过于简单，效果并不是最好的)在OTB50上的实验结果，Precision和FPS碾压了OTB50上最好的Struck</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2df7d84523805e331e2f2813f593e2d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"717\" data-original=\"https://pic2.zhimg.com/v2-2df7d84523805e331e2f2813f593e2d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;717&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"717\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"717\" data-original=\"https://pic2.zhimg.com/v2-2df7d84523805e331e2f2813f593e2d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2df7d84523805e331e2f2813f593e2d1_b.jpg\"/></figure><p>从此目标跟踪就只有两大方向，一个是实时性的相关滤波方向，另一个当然是随主流的深度学习方向了，但目前在速度方面，还是相关滤波碾压一切算法，是当前工业界目标跟踪领域使用的主要算法框架</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-da3ebee46b264382adad401505ea651d_b.jpg\" data-size=\"normal\" data-rawwidth=\"905\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb\" width=\"905\" data-original=\"https://pic2.zhimg.com/v2-da3ebee46b264382adad401505ea651d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;905&#39; height=&#39;570&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"905\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"905\" data-original=\"https://pic2.zhimg.com/v2-da3ebee46b264382adad401505ea651d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-da3ebee46b264382adad401505ea651d_b.jpg\"/><figcaption>两大方向发展脉络</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2. 跟踪数学建模</p><p><b>首先我们看下跟踪的一般过程：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6021785a450ef7158e5b4e91067d9f4c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"625\" data-original=\"https://pic1.zhimg.com/v2-6021785a450ef7158e5b4e91067d9f4c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;625&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"625\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"625\" data-original=\"https://pic1.zhimg.com/v2-6021785a450ef7158e5b4e91067d9f4c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6021785a450ef7158e5b4e91067d9f4c_b.jpg\"/></figure><p>跟踪里，由于目标和周围环境实时变化，一般需要 <img src=\"https://www.zhihu.com/equation?tex=online\" alt=\"online\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=learning\" alt=\"learning\" eeimg=\"1\"/> 。下图所示，在当前帧目标区域及周围随机采样，生成正负样本，训练分类器。然后在下一帧对应位置随机采样，通过分类器得到输出响应，选择响应最大的采样作为跟踪到的目标</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2824de7c439a754eddc7f42f51b1e349_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"584\" class=\"origin_image zh-lightbox-thumb\" width=\"870\" data-original=\"https://pic2.zhimg.com/v2-2824de7c439a754eddc7f42f51b1e349_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;870&#39; height=&#39;584&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"584\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"870\" data-original=\"https://pic2.zhimg.com/v2-2824de7c439a754eddc7f42f51b1e349_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2824de7c439a754eddc7f42f51b1e349_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>然后利用样本循环移位代替采样窗口：</b></p><p>(这里先不要问为什么要这么做，这是KCF算法建模的过程，有了这些前提，KCF算法才能优化，从而实现加速)</p><p>把向量 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 变化到 <img src=\"https://www.zhihu.com/equation?tex=newx\" alt=\"newx\" eeimg=\"1\"/> 的过程，叫做向量 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 右移一位</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7cc9eb1ec31a5f6f87cddab00037dc66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb\" width=\"730\" data-original=\"https://pic3.zhimg.com/v2-7cc9eb1ec31a5f6f87cddab00037dc66_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;730&#39; height=&#39;58&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"58\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"730\" data-original=\"https://pic3.zhimg.com/v2-7cc9eb1ec31a5f6f87cddab00037dc66_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7cc9eb1ec31a5f6f87cddab00037dc66_b.jpg\"/></figure><p>并且有：任意循环移位的向量，都可由排列矩阵P乘以向量 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 生成，推广到二维一样的成立：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-59c8efc3f7c03ae1b386df5d228041e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"529\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb\" width=\"529\" data-original=\"https://pic2.zhimg.com/v2-59c8efc3f7c03ae1b386df5d228041e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;529&#39; height=&#39;206&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"529\" data-rawheight=\"206\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"529\" data-original=\"https://pic2.zhimg.com/v2-59c8efc3f7c03ae1b386df5d228041e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-59c8efc3f7c03ae1b386df5d228041e1_b.jpg\"/></figure><p>对当前目标区域进行循环移位，可以近似滑窗产生样本的效果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f516e8a7e024ddbe2801236090eeb7f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb\" width=\"533\" data-original=\"https://pic2.zhimg.com/v2-f516e8a7e024ddbe2801236090eeb7f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;533&#39; height=&#39;173&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"173\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"533\" data-original=\"https://pic2.zhimg.com/v2-f516e8a7e024ddbe2801236090eeb7f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f516e8a7e024ddbe2801236090eeb7f9_b.jpg\"/></figure><p>注意，这里必须要加pad，且框周围区域要平滑(可以通过cosine window加权)，避免目标被分解重组合，以及由于边界移位导致图像不光滑。</p><p>循环移位产生的图像当作分类器的训练样本，生成训练样本矩阵：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4352ce005b11bfc6984d49419f9b866a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic3.zhimg.com/v2-4352ce005b11bfc6984d49419f9b866a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic3.zhimg.com/v2-4352ce005b11bfc6984d49419f9b866a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4352ce005b11bfc6984d49419f9b866a_b.jpg\"/></figure><p>注意：如果将当前帧的目标样本放入矩阵的中心，记为(0,0)，那么左上角点(-1,-1)的样本中心相当于目标样本中心往左边上边移动了(-1，-1）</p><p><b>最后，建立模型，求解分类器</b> <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/></p><p>设我们需要学习的分类器为 <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> ，要实现的分类目标如下图所示，图中， <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> (base)=0.3表示下一帧目标移动到左上角的概率是0.3， <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> (x)=1.0表示下一帧目标还是当前目标位置的概率是1.0， <img src=\"https://www.zhihu.com/equation?tex=y\" alt=\"y\" eeimg=\"1\"/> 是回归概率矩阵，数值可以采用高斯分布。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d611c894fff54874d3ee03a067da2a1c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"501\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb\" width=\"501\" data-original=\"https://pic1.zhimg.com/v2-d611c894fff54874d3ee03a067da2a1c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;501&#39; height=&#39;396&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"501\" data-rawheight=\"396\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"501\" data-original=\"https://pic1.zhimg.com/v2-d611c894fff54874d3ee03a067da2a1c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d611c894fff54874d3ee03a067da2a1c_b.jpg\"/></figure><p>假设 <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> 是 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 的线性函数，有：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c1ff298b19b83ac9cdd99a8ff6f5c6dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"729\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"729\" data-original=\"https://pic1.zhimg.com/v2-c1ff298b19b83ac9cdd99a8ff6f5c6dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;729&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"729\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"729\" data-original=\"https://pic1.zhimg.com/v2-c1ff298b19b83ac9cdd99a8ff6f5c6dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c1ff298b19b83ac9cdd99a8ff6f5c6dc_b.jpg\"/></figure><p>可以通过岭回归，得到损失最小的最优解：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b22b47e1516aa534a770f1c940017c9b_b.jpg\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-b22b47e1516aa534a770f1c940017c9b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;616&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-b22b47e1516aa534a770f1c940017c9b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b22b47e1516aa534a770f1c940017c9b_b.jpg\"/><figcaption>岭回归</figcaption></figure><h2>这里<img src=\"https://www.zhihu.com/equation?tex=X%5E%7BT%7DX\" alt=\"X^{T}X\" eeimg=\"1\"/> 的展开形式为：</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-05adcef2336b11e9d548f70cc49f5a0f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"439\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb\" width=\"439\" data-original=\"https://pic4.zhimg.com/v2-05adcef2336b11e9d548f70cc49f5a0f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;439&#39; height=&#39;130&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"439\" data-rawheight=\"130\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"439\" data-original=\"https://pic4.zhimg.com/v2-05adcef2336b11e9d548f70cc49f5a0f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-05adcef2336b11e9d548f70cc49f5a0f_b.jpg\"/></figure><p>假设向量 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 的长度也为 <img src=\"https://www.zhihu.com/equation?tex=n\" alt=\"n\" eeimg=\"1\"/> ，那么计算 <img src=\"https://www.zhihu.com/equation?tex=X%5E%7BT%7DX\" alt=\"X^{T}X\" eeimg=\"1\"/> 的运算次数为 <img src=\"https://www.zhihu.com/equation?tex=n%2An%2An%2An\" alt=\"n*n*n*n\" eeimg=\"1\"/> ， <img src=\"https://www.zhihu.com/equation?tex=n%2An\" alt=\"n*n\" eeimg=\"1\"/> 矩阵求逆的时间复杂度为 <img src=\"https://www.zhihu.com/equation?tex=o%28n%5E%7B3%7D%29\" alt=\"o(n^{3})\" eeimg=\"1\"/> ，显然这样的计算量是无法 <img src=\"https://www.zhihu.com/equation?tex=online\" alt=\"online\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=learning\" alt=\"learning\" eeimg=\"1\"/> 的。</p><p>同时，分类器 <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> 通常不是特征向量 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 的线性表达。但是通过核函数技巧，可以将非线性问题通过特征的非线性映射，在映射后的特征空间满足线性关系。于是有了核空间的岭回归</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7db33d85b38b900a4760511ea2075dcc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"788\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"788\" data-original=\"https://pic1.zhimg.com/v2-7db33d85b38b900a4760511ea2075dcc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;788&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"788\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"788\" data-original=\"https://pic1.zhimg.com/v2-7db33d85b38b900a4760511ea2075dcc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7db33d85b38b900a4760511ea2075dcc_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8fbe6522723bcc4cf15bdb76d8cb0294_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-8fbe6522723bcc4cf15bdb76d8cb0294_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;353&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"353\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-8fbe6522723bcc4cf15bdb76d8cb0294_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8fbe6522723bcc4cf15bdb76d8cb0294_b.jpg\"/></figure><p>至此，已经完成了利用循环样本近似滑动扫描窗进行样本采集，以及利用核空间的岭回归算法求解分类器 <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> 的建模过程。</p><p>3. 模型优化</p><p>       这里通过核函数映射，解决了回归的非线性问题，但是时间复杂度的问题依然没有得到解决，同样无法 <img src=\"https://www.zhihu.com/equation?tex=online\" alt=\"online\" eeimg=\"1\"/> <img src=\"https://www.zhihu.com/equation?tex=learning\" alt=\"learning\" eeimg=\"1\"/> ，可以利用特殊矩阵的性质优化回归参数 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> 的求解。遵循此思路，下面先摆出结论：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8eea5f75152e82936d8c0cb8d04f9467_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic4.zhimg.com/v2-8eea5f75152e82936d8c0cb8d04f9467_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic4.zhimg.com/v2-8eea5f75152e82936d8c0cb8d04f9467_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8eea5f75152e82936d8c0cb8d04f9467_b.jpg\"/></figure><p>讲解到这里，有必要普及一下数学知识了，讲讲什么是循环矩阵，以及循环矩阵有哪些性质：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9f9d81b26fd4d3283b65bb61348d8d39_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"746\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"746\" data-original=\"https://pic2.zhimg.com/v2-9f9d81b26fd4d3283b65bb61348d8d39_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;746&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"746\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"746\" data-original=\"https://pic2.zhimg.com/v2-9f9d81b26fd4d3283b65bb61348d8d39_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9f9d81b26fd4d3283b65bb61348d8d39_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cd816a265098a46f65cce6f78270130e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"734\" data-original=\"https://pic3.zhimg.com/v2-cd816a265098a46f65cce6f78270130e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;734&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"734\" data-original=\"https://pic3.zhimg.com/v2-cd816a265098a46f65cce6f78270130e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cd816a265098a46f65cce6f78270130e_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7d2120b8d2a3a2ee37dddcaf2b136dd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"689\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"689\" data-original=\"https://pic4.zhimg.com/v2-7d2120b8d2a3a2ee37dddcaf2b136dd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;689&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"689\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"689\" data-original=\"https://pic4.zhimg.com/v2-7d2120b8d2a3a2ee37dddcaf2b136dd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7d2120b8d2a3a2ee37dddcaf2b136dd7_b.jpg\"/></figure><p>由上可知，<img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 是循环矩阵，是优化的关键，现在就来分析，怎样让 <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 是循环矩阵，如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1da2d46283e02e8bdc650e03f3e53195_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"762\" data-original=\"https://pic2.zhimg.com/v2-1da2d46283e02e8bdc650e03f3e53195_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;762&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"762\" data-original=\"https://pic2.zhimg.com/v2-1da2d46283e02e8bdc650e03f3e53195_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1da2d46283e02e8bdc650e03f3e53195_b.jpg\"/></figure><p>注意，推导到这里，其实我们还是不知道核函数 <img src=\"https://www.zhihu.com/equation?tex=k%28x%2Cz%29\" alt=\"k(x,z)\" eeimg=\"1\"/> 的形式，也不知道特征 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 非线性映射 <img src=\"https://www.zhihu.com/equation?tex=%5Cphi%28x%29\" alt=\"\\phi(x)\" eeimg=\"1\"/> 的形式，但是只要 <img src=\"https://www.zhihu.com/equation?tex=k%28x%2Cz%29\" alt=\"k(x,z)\" eeimg=\"1\"/> 满足条件， <img src=\"https://www.zhihu.com/equation?tex=K\" alt=\"K\" eeimg=\"1\"/> 就是循环矩阵！！！还要注意的是，这里要求 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 也是循环移位向量，而这里的 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 就是训练样本，所以就回答了为什么要用循环样本采样替代滑窗采样的原因！！！</p><p>以上我们不但求解了 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> 而且优化了 <img src=\"https://www.zhihu.com/equation?tex=%5Calpha\" alt=\"\\alpha\" eeimg=\"1\"/> 的计算，这样 <img src=\"https://www.zhihu.com/equation?tex=f\" alt=\"f\" eeimg=\"1\"/> 也就出来了。下面就是测试阶段了。跟踪的测试过程是通过对下一帧在前一帧目标位置的滑窗产生一系列测试样本， <img src=\"https://www.zhihu.com/equation?tex=z_%7B1%7D%2Cz_%7B2%7D%2C...z_%7Bn%7D\" alt=\"z_{1},z_{2},...z_{n}\" eeimg=\"1\"/> 同样的，用目标位置的循环移位产生的样本代替需要滑窗产生的测试样本，完整的测试过程如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b5de4db78ae30f75d6cfa71c7a801beb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1038\" data-rawheight=\"661\" class=\"origin_image zh-lightbox-thumb\" width=\"1038\" data-original=\"https://pic4.zhimg.com/v2-b5de4db78ae30f75d6cfa71c7a801beb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1038&#39; height=&#39;661&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1038\" data-rawheight=\"661\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1038\" data-original=\"https://pic4.zhimg.com/v2-b5de4db78ae30f75d6cfa71c7a801beb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b5de4db78ae30f75d6cfa71c7a801beb_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8b0817cb11c49d1bd42dacabdc2b6843_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1101\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb\" width=\"1101\" data-original=\"https://pic4.zhimg.com/v2-8b0817cb11c49d1bd42dacabdc2b6843_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1101&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1101\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1101\" data-original=\"https://pic4.zhimg.com/v2-8b0817cb11c49d1bd42dacabdc2b6843_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8b0817cb11c49d1bd42dacabdc2b6843_b.jpg\"/></figure><p>注意，这里的 <img src=\"https://www.zhihu.com/equation?tex=x%2Cz\" alt=\"x,z\" eeimg=\"1\"/> 分别是训练和测试的循环移位样本。 <img src=\"https://www.zhihu.com/equation?tex=f%28Z%29\" alt=\"f(Z)\" eeimg=\"1\"/> 是所有测试样本的全部输出，每个输出点的值表示该位置循环移位样本的响应，也是对应窗口滑动样本的响应，显然找到最大响应值，其所在位置与当前帧的位置差就表示目标移动的距离了。</p><p>那么现在问题的关键就是求核函数生成向量 <img src=\"https://www.zhihu.com/equation?tex=k%5E%7Bxz%7D\" alt=\"k^{xz}\" eeimg=\"1\"/> 和 <img src=\"https://www.zhihu.com/equation?tex=k%5E%7Bxx%7D\" alt=\"k^{xx}\" eeimg=\"1\"/> 的表达了，直接摘抄论文片段如下：（同时再次注意，核函数必须满足的条件！！！）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9312b8a658ec656d8627c220273c173b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1082\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb\" width=\"1082\" data-original=\"https://pic4.zhimg.com/v2-9312b8a658ec656d8627c220273c173b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1082&#39; height=&#39;153&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1082\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1082\" data-original=\"https://pic4.zhimg.com/v2-9312b8a658ec656d8627c220273c173b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9312b8a658ec656d8627c220273c173b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8c56c6071a988cf6e610638704370be2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb\" width=\"799\" data-original=\"https://pic3.zhimg.com/v2-8c56c6071a988cf6e610638704370be2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;799&#39; height=&#39;587&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"799\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"799\" data-original=\"https://pic3.zhimg.com/v2-8c56c6071a988cf6e610638704370be2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8c56c6071a988cf6e610638704370be2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-84f8dc12d20d9b83cb46f553cc873b01_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"584\" class=\"origin_image zh-lightbox-thumb\" width=\"748\" data-original=\"https://pic2.zhimg.com/v2-84f8dc12d20d9b83cb46f553cc873b01_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;748&#39; height=&#39;584&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"584\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"748\" data-original=\"https://pic2.zhimg.com/v2-84f8dc12d20d9b83cb46f553cc873b01_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-84f8dc12d20d9b83cb46f553cc873b01_b.jpg\"/></figure><p>至此，模型优化的全部过程分析已经完毕！！！(哈哈哈，确实不容易啊，给自己一个赞)</p><p>4. KCF工程实现</p><p>       KCF是典型的原理复杂，实现简单的代表作（一般特别经典的论文和算法，好像都有这个特质），是当前工业界目标跟踪领域使用的主要算法框架。根据模型优化后得到的最终公式，</p><p>可知，在工程上，利用这个公式(框架)，可以做的就是特征提取的选择(比如样本 <img src=\"https://www.zhihu.com/equation?tex=x\" alt=\"x\" eeimg=\"1\"/> 的像素特征，颜色特征，HOG特征，卷积特征等)，以及核函数的选择。下面给出简单的算法实现过程</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-056dee74200aee501fa2035664f17e3c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1045\" data-rawheight=\"673\" class=\"origin_image zh-lightbox-thumb\" width=\"1045\" data-original=\"https://pic1.zhimg.com/v2-056dee74200aee501fa2035664f17e3c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1045&#39; height=&#39;673&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1045\" data-rawheight=\"673\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1045\" data-original=\"https://pic1.zhimg.com/v2-056dee74200aee501fa2035664f17e3c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-056dee74200aee501fa2035664f17e3c_b.jpg\"/></figure><p>注意：这里采用了高斯核函数，显然指数的计算会影响计算速度，再给出速度最快的MOSSE算法采用的核函数技巧：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-348b72ffb0f7e45630e9ef11ff51132a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"974\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb\" width=\"974\" data-original=\"https://pic3.zhimg.com/v2-348b72ffb0f7e45630e9ef11ff51132a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;974&#39; height=&#39;502&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"974\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"974\" data-original=\"https://pic3.zhimg.com/v2-348b72ffb0f7e45630e9ef11ff51132a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-348b72ffb0f7e45630e9ef11ff51132a_b.jpg\"/></figure><p>工程上，还需要注意的一些问题：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8636d5a61829c8f1ead9df337218c442_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1228\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb\" width=\"1228\" data-original=\"https://pic3.zhimg.com/v2-8636d5a61829c8f1ead9df337218c442_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1228&#39; height=&#39;393&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1228\" data-rawheight=\"393\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1228\" data-original=\"https://pic3.zhimg.com/v2-8636d5a61829c8f1ead9df337218c442_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8636d5a61829c8f1ead9df337218c442_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "目标跟踪", 
                    "tagLink": "https://api.zhihu.com/topics/20185713"
                }, 
                {
                    "tag": "计算机视觉", 
                    "tagLink": "https://api.zhihu.com/topics/19590195"
                }
            ], 
            "comments": [
                {
                    "userName": "Don't", 
                    "userLink": "https://www.zhihu.com/people/13fd05386d38adf85957e5b7a47bb1a8", 
                    "content": "<p>你好，文中引用的资料方便分享一下吗？</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "猴小六", 
                    "userLink": "https://www.zhihu.com/people/63e3e830cfea0b3eeb25637a45c0e384", 
                    "content": "<p>你好，我的推导过程跟你的一模一样，为什么原文里有几处没有加上共轭符号，请问这对代码的执行没有影响么？</p><p></p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Devin", 
                    "userLink": "https://www.zhihu.com/people/580c3d03824f34cf96fa07cedc0b6732", 
                    "content": "请问kcf对背景一直运动的前景能有效跟踪到么？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1041684602716413952"
}
