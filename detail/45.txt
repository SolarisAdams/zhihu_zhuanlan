{
    "title": "通用后台技术", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/tian-tian-xiang-shang-96-50", 
        "https://www.zhihu.com/people/duo-duo-luo-20-59", 
        "https://www.zhihu.com/people/da-da-83-97", 
        "https://www.zhihu.com/people/panovr", 
        "https://www.zhihu.com/people/kong-cheng-09-03", 
        "https://www.zhihu.com/people/return_error", 
        "https://www.zhihu.com/people/dong-dong-93-16-9", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/hai-feng-hen-xiang-ni", 
        "https://www.zhihu.com/people/sunnyos", 
        "https://www.zhihu.com/people/123456-36-71", 
        "https://www.zhihu.com/people/sisyphusmyth", 
        "https://www.zhihu.com/people/lu-zhong-qiu-heng-6", 
        "https://www.zhihu.com/people/zhang-jia-jia-94-32", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/feng-chui-de-ri-zi", 
        "https://www.zhihu.com/people/fangying712", 
        "https://www.zhihu.com/people/liushiqi9", 
        "https://www.zhihu.com/people/huang-da-26-59", 
        "https://www.zhihu.com/people/jizu", 
        "https://www.zhihu.com/people/zhang-wang-nian", 
        "https://www.zhihu.com/people/huang-wei-tong-59", 
        "https://www.zhihu.com/people/qianhen", 
        "https://www.zhihu.com/people/wa-ha-ha-93-59", 
        "https://www.zhihu.com/people/wei-98-52", 
        "https://www.zhihu.com/people/xiang-bian-cheng-kong-long-de-ma-yi", 
        "https://www.zhihu.com/people/xiaoq-41", 
        "https://www.zhihu.com/people/zheng-chen-62-5", 
        "https://www.zhihu.com/people/wu-teng-fei-28", 
        "https://www.zhihu.com/people/ben-pao-de-zhui-meng-zhe-8", 
        "https://www.zhihu.com/people/deng-yu-55", 
        "https://www.zhihu.com/people/gao-ying-da", 
        "https://www.zhihu.com/people/mu-lin-mu-91", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/mrxiaosen-85", 
        "https://www.zhihu.com/people/jing-jing-71-57", 
        "https://www.zhihu.com/people/wang-zhi-qiang-30-55", 
        "https://www.zhihu.com/people/marklin-55", 
        "https://www.zhihu.com/people/xueyouchao", 
        "https://www.zhihu.com/people/bihuchao", 
        "https://www.zhihu.com/people/su-chang-60-5", 
        "https://www.zhihu.com/people/kevin.kang", 
        "https://www.zhihu.com/people/zebgboyuan", 
        "https://www.zhihu.com/people/wusuowei-20", 
        "https://www.zhihu.com/people/le-yi-xian-sheng", 
        "https://www.zhihu.com/people/pkuzhou", 
        "https://www.zhihu.com/people/iskywalker", 
        "https://www.zhihu.com/people/atom-rong", 
        "https://www.zhihu.com/people/liu-lin-qi-78", 
        "https://www.zhihu.com/people/lee8790", 
        "https://www.zhihu.com/people/jerica-edith", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/zhu-forrest", 
        "https://www.zhihu.com/people/si-wei-35-60", 
        "https://www.zhihu.com/people/wenchy", 
        "https://www.zhihu.com/people/you-wei-98", 
        "https://www.zhihu.com/people/spriteray", 
        "https://www.zhihu.com/people/yu-sui-wu-tong", 
        "https://www.zhihu.com/people/asmlover", 
        "https://www.zhihu.com/people/kiliu-5", 
        "https://www.zhihu.com/people/18344264714", 
        "https://www.zhihu.com/people/gu-gu-55-25", 
        "https://www.zhihu.com/people/hai-tao-83-86", 
        "https://www.zhihu.com/people/zhang-jia-min-80", 
        "https://www.zhihu.com/people/233-12-93", 
        "https://www.zhihu.com/people/kissweb", 
        "https://www.zhihu.com/people/zagnix", 
        "https://www.zhihu.com/people/li-hua-cheng-86", 
        "https://www.zhihu.com/people/yang-xa", 
        "https://www.zhihu.com/people/nomad03", 
        "https://www.zhihu.com/people/charles-meng-17", 
        "https://www.zhihu.com/people/xiao-xiao-zi-64-63", 
        "https://www.zhihu.com/people/ruan-jian-wei-7", 
        "https://www.zhihu.com/people/yang-wang-55-37", 
        "https://www.zhihu.com/people/hao-yu-80", 
        "https://www.zhihu.com/people/shuweiqun", 
        "https://www.zhihu.com/people/coder_wolf", 
        "https://www.zhihu.com/people/noeltoby", 
        "https://www.zhihu.com/people/lin-xiao-jia-98-89", 
        "https://www.zhihu.com/people/wang-xin-zhong-40", 
        "https://www.zhihu.com/people/chen-lei-dong", 
        "https://www.zhihu.com/people/shi-ran-87-63", 
        "https://www.zhihu.com/people/herman-70-95", 
        "https://www.zhihu.com/people/mei-ying-xing-hen", 
        "https://www.zhihu.com/people/chen_feng_escape", 
        "https://www.zhihu.com/people/craftsliu", 
        "https://www.zhihu.com/people/world-hello-74-14", 
        "https://www.zhihu.com/people/gq-zhou-63", 
        "https://www.zhihu.com/people/ma-geng-bin", 
        "https://www.zhihu.com/people/shijiaqi88", 
        "https://www.zhihu.com/people/songzhili", 
        "https://www.zhihu.com/people/nvwangdarenla", 
        "https://www.zhihu.com/people/king-montain", 
        "https://www.zhihu.com/people/wang-lin-tao-85", 
        "https://www.zhihu.com/people/ming-que-89", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/ha-ha-17-96-16", 
        "https://www.zhihu.com/people/wang-li-zhi-23-2", 
        "https://www.zhihu.com/people/iEpoch", 
        "https://www.zhihu.com/people/xing-ba-tai-ji", 
        "https://www.zhihu.com/people/piao-ling-de-lang-hua", 
        "https://www.zhihu.com/people/liu-shao-kun-68", 
        "https://www.zhihu.com/people/DavidAlphaFox", 
        "https://www.zhihu.com/people/chen-zhi-wei-37-90", 
        "https://www.zhihu.com/people/xu-xiao-qing-19-13", 
        "https://www.zhihu.com/people/blueliuyun", 
        "https://www.zhihu.com/people/channing-xiao", 
        "https://www.zhihu.com/people/zheng-hua-31-46", 
        "https://www.zhihu.com/people/chen-xian-17", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/li-xin-meng-96-20", 
        "https://www.zhihu.com/people/lian-zhi-wen", 
        "https://www.zhihu.com/people/xiaoliangzi", 
        "https://www.zhihu.com/people/wang-zi-liang-58-18", 
        "https://www.zhihu.com/people/khaki_w", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/homurasuka", 
        "https://www.zhihu.com/people/liu-feng-kuang-5", 
        "https://www.zhihu.com/people/shen-yiyang-de-ren-75", 
        "https://www.zhihu.com/people/current1990", 
        "https://www.zhihu.com/people/wtzhang95", 
        "https://www.zhihu.com/people/lei-zhen-hao-48", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/zhong-ju-pai", 
        "https://www.zhihu.com/people/diu-mao-19", 
        "https://www.zhihu.com/people/yang-jun-yi-98-1", 
        "https://www.zhihu.com/people/mou-mou-48-20", 
        "https://www.zhihu.com/people/liu-lang-hai", 
        "https://www.zhihu.com/people/stillbemyself", 
        "https://www.zhihu.com/people/bai-shi-jie", 
        "https://www.zhihu.com/people/cliff-yuan", 
        "https://www.zhihu.com/people/a-shi-da-fu-57", 
        "https://www.zhihu.com/people/zhao-en-bo-81", 
        "https://www.zhihu.com/people/wang-jing-cai-31", 
        "https://www.zhihu.com/people/sfzhao", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/openthedoors", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/li-hao-86", 
        "https://www.zhihu.com/people/reader2018", 
        "https://www.zhihu.com/people/yy158125", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/glen-wang-36", 
        "https://www.zhihu.com/people/he-ping-33-22", 
        "https://www.zhihu.com/people/chen-hao-nan-42", 
        "https://www.zhihu.com/people/huang-han-tao-54", 
        "https://www.zhihu.com/people/tian-qi-yu-bao-62", 
        "https://www.zhihu.com/people/lsl-1", 
        "https://www.zhihu.com/people/robin-90-24", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/yuzhenjin", 
        "https://www.zhihu.com/people/gabbar-wang", 
        "https://www.zhihu.com/people/zhang-wen-71-57", 
        "https://www.zhihu.com/people/yang-kan-81", 
        "https://www.zhihu.com/people/zhang-wei-wei-67-91", 
        "https://www.zhihu.com/people/cui-xiao-yu-85", 
        "https://www.zhihu.com/people/zhu-jin-dong-89", 
        "https://www.zhihu.com/people/exiledkingcc", 
        "https://www.zhihu.com/people/xiao-liu-90-21", 
        "https://www.zhihu.com/people/tai-bai-52", 
        "https://www.zhihu.com/people/su-xiao-ming-71", 
        "https://www.zhihu.com/people/xin-shuai-feng", 
        "https://www.zhihu.com/people/wenying-chen", 
        "https://www.zhihu.com/people/cai-long-67", 
        "https://www.zhihu.com/people/qiao-hai-jun", 
        "https://www.zhihu.com/people/liumen", 
        "https://www.zhihu.com/people/xiao-han-13-60", 
        "https://www.zhihu.com/people/luo-bing-31-48", 
        "https://www.zhihu.com/people/hu-niu-59-27", 
        "https://www.zhihu.com/people/manorsuperman", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/obitote", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/yan-bin-42-10", 
        "https://www.zhihu.com/people/liu-yan-hua-85", 
        "https://www.zhihu.com/people/yong-hu-5189439695", 
        "https://www.zhihu.com/people/tan-yu-hao-49", 
        "https://www.zhihu.com/people/123-31-57-95", 
        "https://www.zhihu.com/people/lin-shao-hui-98-1", 
        "https://www.zhihu.com/people/nikko-9", 
        "https://www.zhihu.com/people/marvine.cn", 
        "https://www.zhihu.com/people/hal-he", 
        "https://www.zhihu.com/people/donewell", 
        "https://www.zhihu.com/people/uestcpeco", 
        "https://www.zhihu.com/people/viscly", 
        "https://www.zhihu.com/people/ANTIDARKSTAR", 
        "https://www.zhihu.com/people/sheldon-18-75"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/58707582", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 2, 
            "title": "分块锁与unordered_map", 
            "content": "<p></p><h2><b>分块锁不可以和unordered_map联用</b></h2><h2><b>unordered_map 的rehash机制</b></h2><p>unordered_map 的底层数据结构为HashTable。<br/>HashTable有rehash机制，触发的时机为&#34;Rehash will occur only if the new number of buckets respect the unordered_map maximum load factor.&#34;</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">_Key</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_Value</span><span class=\"p\">,</span>\n    <span class=\"k\">typename</span> <span class=\"n\">_Alloc</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_ExtractKey</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_Equal</span><span class=\"p\">,</span>\n    <span class=\"k\">typename</span> <span class=\"n\">_H1</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_H2</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_Hash</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">_RehashPolicy</span><span class=\"p\">,</span>\n    <span class=\"k\">typename</span> <span class=\"n\">_Traits</span><span class=\"o\">&gt;</span>\n    <span class=\"kt\">void</span>\n    <span class=\"n\">_Hashtable</span><span class=\"o\">&lt;</span><span class=\"n\">_Key</span><span class=\"p\">,</span> <span class=\"n\">_Value</span><span class=\"p\">,</span> <span class=\"n\">_Alloc</span><span class=\"p\">,</span> <span class=\"n\">_ExtractKey</span><span class=\"p\">,</span> <span class=\"n\">_Equal</span><span class=\"p\">,</span>\n        <span class=\"n\">_H1</span><span class=\"p\">,</span> <span class=\"n\">_H2</span><span class=\"p\">,</span> <span class=\"n\">_Hash</span><span class=\"p\">,</span> <span class=\"n\">_RehashPolicy</span><span class=\"p\">,</span> <span class=\"n\">_Traits</span><span class=\"o\">&gt;::</span>\n    <span class=\"n\">_M_rehash_aux</span><span class=\"p\">(</span><span class=\"n\">size_type</span> <span class=\"n\">__n</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">true_type</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n      <span class=\"n\">__bucket_type</span><span class=\"o\">*</span> <span class=\"n\">__new_buckets</span> <span class=\"o\">=</span> <span class=\"n\">_M_allocate_buckets</span><span class=\"p\">(</span><span class=\"n\">__n</span><span class=\"p\">);</span>\n      <span class=\"n\">__node_type</span><span class=\"o\">*</span> <span class=\"n\">__p</span> <span class=\"o\">=</span> <span class=\"n\">_M_begin</span><span class=\"p\">();</span>\n      <span class=\"n\">_M_before_begin</span><span class=\"p\">().</span><span class=\"n\">_M_nxt</span> <span class=\"o\">=</span> <span class=\"k\">nullptr</span><span class=\"p\">;</span>\n      <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">__bbegin_bkt</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">__p</span><span class=\"p\">)</span>\n <span class=\"p\">{</span>\n   <span class=\"n\">__node_type</span><span class=\"o\">*</span> <span class=\"n\">__next</span> <span class=\"o\">=</span> <span class=\"n\">__p</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_next</span><span class=\"p\">();</span>\n   <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">size_t</span> <span class=\"n\">__bkt</span> <span class=\"o\">=</span> <span class=\"n\">__hash_code_base</span><span class=\"o\">::</span><span class=\"n\">_M_bucket_index</span><span class=\"p\">(</span><span class=\"n\">__p</span><span class=\"p\">,</span> <span class=\"n\">__n</span><span class=\"p\">);</span>\n   <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">__new_buckets</span><span class=\"p\">[</span><span class=\"n\">__bkt</span><span class=\"p\">])</span>\n     <span class=\"p\">{</span>\n       <span class=\"n\">__p</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_nxt</span> <span class=\"o\">=</span> <span class=\"n\">_M_before_begin</span><span class=\"p\">().</span><span class=\"n\">_M_nxt</span><span class=\"p\">;</span>\n       <span class=\"n\">_M_before_begin</span><span class=\"p\">().</span><span class=\"n\">_M_nxt</span> <span class=\"o\">=</span> <span class=\"n\">__p</span><span class=\"p\">;</span>\n       <span class=\"n\">__new_buckets</span><span class=\"p\">[</span><span class=\"n\">__bkt</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">_M_before_begin</span><span class=\"p\">();</span>\n       <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">__p</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_nxt</span><span class=\"p\">)</span>\n  <span class=\"n\">__new_buckets</span><span class=\"p\">[</span><span class=\"n\">__bbegin_bkt</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">__p</span><span class=\"p\">;</span>\n       <span class=\"n\">__bbegin_bkt</span> <span class=\"o\">=</span> <span class=\"n\">__bkt</span><span class=\"p\">;</span>\n     <span class=\"p\">}</span>\n   <span class=\"k\">else</span>\n     <span class=\"p\">{</span>\n       <span class=\"n\">__p</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_nxt</span> <span class=\"o\">=</span> <span class=\"n\">__new_buckets</span><span class=\"p\">[</span><span class=\"n\">__bkt</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_nxt</span><span class=\"p\">;</span>\n       <span class=\"n\">__new_buckets</span><span class=\"p\">[</span><span class=\"n\">__bkt</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">_M_nxt</span> <span class=\"o\">=</span> <span class=\"n\">__p</span><span class=\"p\">;</span>\n     <span class=\"p\">}</span>\n   <span class=\"n\">__p</span> <span class=\"o\">=</span> <span class=\"n\">__next</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n      <span class=\"n\">_M_deallocate_buckets</span><span class=\"p\">(</span><span class=\"n\">_M_buckets</span><span class=\"p\">,</span> <span class=\"n\">_M_bucket_count</span><span class=\"p\">);</span><span class=\"c1\">//销毁旧内存地址\n</span><span class=\"c1\"></span>      <span class=\"n\">_M_bucket_count</span> <span class=\"o\">=</span> <span class=\"n\">__n</span><span class=\"p\">;</span><span class=\"c1\">//更新桶数\n</span><span class=\"c1\"></span>      <span class=\"n\">_M_buckets</span> <span class=\"o\">=</span> <span class=\"n\">__new_buckets</span><span class=\"p\">;</span><span class=\"c1\">//指向新内存地址\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n</code></pre></div><p>如上，rehash操作时存在旧地址数据拷贝到新地址，及旧地址销毁、更新地址指向的过程。<br/>当多线程环境下分块锁+unordered_map使用如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unordered_map</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">,</span><span class=\"n\">MidInfo</span><span class=\"o\">*&gt;</span> <span class=\"n\">mid_tag_cache_</span>\n\n  <span class=\"kt\">int</span> <span class=\"n\">InsertMidTagToCache</span><span class=\"p\">(</span><span class=\"n\">MidInfo</span><span class=\"o\">*</span> <span class=\"n\">info</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"n\">info</span><span class=\"o\">-&gt;</span><span class=\"n\">mid</span><span class=\"p\">;</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">Hash</span><span class=\"p\">(</span><span class=\"n\">mid</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">(),</span><span class=\"n\">mid</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">(),</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mutex_index</span> <span class=\"o\">=</span> <span class=\"n\">hash</span> <span class=\"o\">%</span> <span class=\"n\">mid_tag_lock_num_</span><span class=\"p\">;</span>\n    <span class=\"n\">info</span><span class=\"o\">-&gt;</span><span class=\"n\">mid_hash</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"o\">&amp;</span><span class=\"n\">mutex_lock</span> <span class=\"o\">=</span> <span class=\"n\">mid_tag_mutex_</span><span class=\"p\">[</span><span class=\"n\">mutex_index</span><span class=\"p\">];</span>\n\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex_lock</span><span class=\"p\">);</span>\n\n    <span class=\"n\">mid_tag_cache_</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"n\">info</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">int</span> <span class=\"n\">GetMidInfo</span><span class=\"p\">(</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">mid</span><span class=\"p\">,</span><span class=\"n\">MidInfo</span><span class=\"o\">*</span> <span class=\"n\">mid_info</span><span class=\"p\">)</span><span class=\"k\">const</span> <span class=\"p\">{</span>\n      <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">Hash</span><span class=\"p\">(</span><span class=\"n\">mid</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">(),</span><span class=\"n\">mid</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">(),</span><span class=\"mi\">0</span><span class=\"p\">);</span>                                                                                              \n      <span class=\"kt\">int</span> <span class=\"n\">mutex_index</span> <span class=\"o\">=</span> <span class=\"n\">hash</span> <span class=\"o\">%</span> <span class=\"n\">mid_tag_lock_num_</span><span class=\"p\">;</span>  \n      <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"o\">&amp;</span><span class=\"n\">mutex_lock</span> <span class=\"o\">=</span> <span class=\"n\">mid_tag_mutex_</span><span class=\"p\">[</span><span class=\"n\">mutex_index</span><span class=\"p\">];</span>\n\n      <span class=\"kt\">int</span> <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n      <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex_lock</span><span class=\"p\">);</span> \n      <span class=\"k\">auto</span> <span class=\"n\">iter</span> <span class=\"o\">=</span> <span class=\"n\">mid_tag_cache_</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"n\">mid</span><span class=\"p\">);</span>\n      <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">iter</span> <span class=\"o\">!=</span> <span class=\"n\">mid_tag_cache_</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n        <span class=\"n\">MidTagInfo</span><span class=\"o\">*</span> <span class=\"n\">cache_info</span> <span class=\"o\">=</span> <span class=\"n\">iter</span><span class=\"o\">-&gt;</span><span class=\"n\">second</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span><span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">NOT_EXIST</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n      <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>在unordered_map触发rehash后，存在程序core的风险。</p><h2><b>问题解决</b></h2><p>在阅读levelDb lrucache代码，结合此问题，理解了lrucache的设计思想。</p><h2><b>unordered_map使用心得</b></h2><p>unordered_map默认的桶数为11 ，load_factor是1。<br/>在实际使用中如果需要存储有大量数据，频繁的rehash会非常影响性能。<br/>解决办法是在unordered_map建立时根据实际需要预先设定桶数和元素数避免后期可能的rehash</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">unordered_map</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n    <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"mi\">10000000</span><span class=\"p\">);</span><span class=\"c1\">//预设元素数\n</span><span class=\"c1\"></span>    <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">rehash</span><span class=\"p\">(</span><span class=\"mi\">10000000</span><span class=\"p\">);</span><span class=\"c1\">//预设桶数\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">10000000</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">t</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">make_pair</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "STL", 
                    "tagLink": "https://api.zhihu.com/topics/19583423"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58205592", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 0, 
            "title": "分布式基础理论及ZK应用", 
            "content": "<p>分布式基础理论及ZK</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0d288dc54f54fab9609f40339ca52284_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"854\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb\" width=\"854\" data-original=\"https://pic1.zhimg.com/v2-0d288dc54f54fab9609f40339ca52284_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;854&#39; height=&#39;475&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"854\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"854\" data-original=\"https://pic1.zhimg.com/v2-0d288dc54f54fab9609f40339ca52284_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0d288dc54f54fab9609f40339ca52284_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9e033d4ee1ec6f4bd9622347462410b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"938\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb\" width=\"938\" data-original=\"https://pic4.zhimg.com/v2-9e033d4ee1ec6f4bd9622347462410b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;938&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"938\" data-rawheight=\"505\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"938\" data-original=\"https://pic4.zhimg.com/v2-9e033d4ee1ec6f4bd9622347462410b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9e033d4ee1ec6f4bd9622347462410b3_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4604b6f4eda6615c30d24774c5af01b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"903\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb\" width=\"903\" data-original=\"https://pic1.zhimg.com/v2-4604b6f4eda6615c30d24774c5af01b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;903&#39; height=&#39;473&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"903\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"903\" data-original=\"https://pic1.zhimg.com/v2-4604b6f4eda6615c30d24774c5af01b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4604b6f4eda6615c30d24774c5af01b4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2dd4486739a3202825a9798adfd09492_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb\" width=\"901\" data-original=\"https://pic3.zhimg.com/v2-2dd4486739a3202825a9798adfd09492_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;901&#39; height=&#39;479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"901\" data-original=\"https://pic3.zhimg.com/v2-2dd4486739a3202825a9798adfd09492_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2dd4486739a3202825a9798adfd09492_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-92152f8bf0f3dbbeec25a6c4eed926b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"935\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb\" width=\"935\" data-original=\"https://pic1.zhimg.com/v2-92152f8bf0f3dbbeec25a6c4eed926b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;935&#39; height=&#39;489&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"935\" data-rawheight=\"489\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"935\" data-original=\"https://pic1.zhimg.com/v2-92152f8bf0f3dbbeec25a6c4eed926b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-92152f8bf0f3dbbeec25a6c4eed926b4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7a45b81e34e28d1d4d43e26839904cba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"931\" data-rawheight=\"493\" class=\"origin_image zh-lightbox-thumb\" width=\"931\" data-original=\"https://pic3.zhimg.com/v2-7a45b81e34e28d1d4d43e26839904cba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;931&#39; height=&#39;493&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"931\" data-rawheight=\"493\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"931\" data-original=\"https://pic3.zhimg.com/v2-7a45b81e34e28d1d4d43e26839904cba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7a45b81e34e28d1d4d43e26839904cba_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2406a5cb3299afffed8ff110b14c36a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb\" width=\"928\" data-original=\"https://pic2.zhimg.com/v2-2406a5cb3299afffed8ff110b14c36a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;928&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"928\" data-original=\"https://pic2.zhimg.com/v2-2406a5cb3299afffed8ff110b14c36a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2406a5cb3299afffed8ff110b14c36a5_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d286edba9fc34f6910ee0dc3e80730f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic2.zhimg.com/v2-d286edba9fc34f6910ee0dc3e80730f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic2.zhimg.com/v2-d286edba9fc34f6910ee0dc3e80730f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d286edba9fc34f6910ee0dc3e80730f9_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-daa84d8d78dee75f75e71ff55ab4be04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"922\" data-rawheight=\"497\" class=\"origin_image zh-lightbox-thumb\" width=\"922\" data-original=\"https://pic1.zhimg.com/v2-daa84d8d78dee75f75e71ff55ab4be04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;922&#39; height=&#39;497&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"922\" data-rawheight=\"497\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"922\" data-original=\"https://pic1.zhimg.com/v2-daa84d8d78dee75f75e71ff55ab4be04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-daa84d8d78dee75f75e71ff55ab4be04_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d551b8c04e6a174d190f0585bc64dd30_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-d551b8c04e6a174d190f0585bc64dd30_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;929&#39; height=&#39;507&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-d551b8c04e6a174d190f0585bc64dd30_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d551b8c04e6a174d190f0585bc64dd30_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c11e5adde53e8440cb0b8c9dc6114ab3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"886\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb\" width=\"886\" data-original=\"https://pic4.zhimg.com/v2-c11e5adde53e8440cb0b8c9dc6114ab3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;886&#39; height=&#39;538&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"886\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"886\" data-original=\"https://pic4.zhimg.com/v2-c11e5adde53e8440cb0b8c9dc6114ab3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c11e5adde53e8440cb0b8c9dc6114ab3_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-25fe6ac4f59cd4d59fde6d12145cddf3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"488\" class=\"origin_image zh-lightbox-thumb\" width=\"908\" data-original=\"https://pic4.zhimg.com/v2-25fe6ac4f59cd4d59fde6d12145cddf3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;908&#39; height=&#39;488&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"908\" data-rawheight=\"488\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"908\" data-original=\"https://pic4.zhimg.com/v2-25fe6ac4f59cd4d59fde6d12145cddf3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-25fe6ac4f59cd4d59fde6d12145cddf3_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f386a591a0f0a9c7e4c4ccaa2789ad8c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb\" width=\"925\" data-original=\"https://pic1.zhimg.com/v2-f386a591a0f0a9c7e4c4ccaa2789ad8c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;925&#39; height=&#39;479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"925\" data-original=\"https://pic1.zhimg.com/v2-f386a591a0f0a9c7e4c4ccaa2789ad8c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f386a591a0f0a9c7e4c4ccaa2789ad8c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4501d9e956cbc491be2350665628b7e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb\" width=\"932\" data-original=\"https://pic2.zhimg.com/v2-4501d9e956cbc491be2350665628b7e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;932&#39; height=&#39;517&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"932\" data-rawheight=\"517\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"932\" data-original=\"https://pic2.zhimg.com/v2-4501d9e956cbc491be2350665628b7e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4501d9e956cbc491be2350665628b7e9_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-98b140784b78252f411275c34f5698a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"510\" class=\"origin_image zh-lightbox-thumb\" width=\"925\" data-original=\"https://pic2.zhimg.com/v2-98b140784b78252f411275c34f5698a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;925&#39; height=&#39;510&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"510\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"925\" data-original=\"https://pic2.zhimg.com/v2-98b140784b78252f411275c34f5698a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-98b140784b78252f411275c34f5698a1_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9accdce6042a5b9387e023cce1db63c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-9accdce6042a5b9387e023cce1db63c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;940&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-9accdce6042a5b9387e023cce1db63c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9accdce6042a5b9387e023cce1db63c3_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d9f41cf398cb8e8ac6bd80d8fd9a2b8b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"916\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb\" width=\"916\" data-original=\"https://pic4.zhimg.com/v2-d9f41cf398cb8e8ac6bd80d8fd9a2b8b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;916&#39; height=&#39;511&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"916\" data-rawheight=\"511\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"916\" data-original=\"https://pic4.zhimg.com/v2-d9f41cf398cb8e8ac6bd80d8fd9a2b8b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d9f41cf398cb8e8ac6bd80d8fd9a2b8b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-244b9a55bc6f6a9523ac1fa4008daa9b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb\" width=\"901\" data-original=\"https://pic4.zhimg.com/v2-244b9a55bc6f6a9523ac1fa4008daa9b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;901&#39; height=&#39;496&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"901\" data-rawheight=\"496\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"901\" data-original=\"https://pic4.zhimg.com/v2-244b9a55bc6f6a9523ac1fa4008daa9b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-244b9a55bc6f6a9523ac1fa4008daa9b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-815b4ae3c0d609770a851e6df9e88e0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"941\" data-rawheight=\"490\" class=\"origin_image zh-lightbox-thumb\" width=\"941\" data-original=\"https://pic1.zhimg.com/v2-815b4ae3c0d609770a851e6df9e88e0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;941&#39; height=&#39;490&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"941\" data-rawheight=\"490\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"941\" data-original=\"https://pic1.zhimg.com/v2-815b4ae3c0d609770a851e6df9e88e0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-815b4ae3c0d609770a851e6df9e88e0c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-53318a4b02b157d8f7751768b39f3e16_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb\" width=\"856\" data-original=\"https://pic3.zhimg.com/v2-53318a4b02b157d8f7751768b39f3e16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;856&#39; height=&#39;501&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"501\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"856\" data-original=\"https://pic3.zhimg.com/v2-53318a4b02b157d8f7751768b39f3e16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-53318a4b02b157d8f7751768b39f3e16_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c05c3c070228ceac6cb55cf2550df914_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"934\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb\" width=\"934\" data-original=\"https://pic1.zhimg.com/v2-c05c3c070228ceac6cb55cf2550df914_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;934&#39; height=&#39;520&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"934\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"934\" data-original=\"https://pic1.zhimg.com/v2-c05c3c070228ceac6cb55cf2550df914_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c05c3c070228ceac6cb55cf2550df914_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "ZooKeeper", 
                    "tagLink": "https://api.zhihu.com/topics/19657747"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57869129", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 5, 
            "title": "协程的实现", 
            "content": "<h2><b>协程与线程</b></h2><p>通过上文（协程之CPU切换），可以明白上下文切换进程&gt;线程&gt;协程，这就是进化路线。</p><h2><b>协程的问题</b></h2><p>就是系统并不感知，所以操作系统不会帮你做切换。<br/>那么谁来帮你做切换？让需要执行的协程更多的获得CPU时间才是问题的关键。</p><h2><b>协程的实现</b></h2><p>目前的协程框架一般都是设计成 1:N 模式。<br/>所谓 1:N 就是一个线程作为一个容器里面放置多个协程。<br/>那么谁来适时的切换这些协程？答案是有协程自己主动让出CPU，<br/>也就是每个协程池里面有一个调度器，这个调度器是被动调度的。<br/>意思就是他不会主动调度。<br/>而且当一个协程发现自己执行不下去了(比如异步等待网络的数据回来，但是当前还没有数据到)，<br/>这个时候就可以由这个协程通知调度器，<br/>这个时候执行到调度器的代码，调度器根据事先设计好的调度算法找到当前最需要CPU的协程。<br/>切换这个协程的CPU上下文把CPU的运行权交个这个协程，直到这个协程出现执行不下去需要等等的情况，<br/>或者它调用主动让出CPU的API之类，触发下一次调度。对的没错就是类似于 领导人模式那么这个实现有没有问题？<br/>其实是有问题的，假设这个线程中有一个协程是CPU密集型的他没有IO操作，也就是自己不会主动触发调度器调度的过程，<br/>那么就会出现其他协程得不到执行的情况，所以这种情况下需要程序员自己避免。<br/>这是一个问题，假设业务开发的人员并不懂这个原理的话就可能会出现问题。</p><h2><b>协程的适用场景</b></h2><p>协程的适用在IO密集型的程序。<br/>由于IO操作远远小于CPU的操作，<br/>所以往往需要CPU去等IO操作。同步IO下系统需要切换线程，让操作系统可以再IO过程中执行其他的东西。<br/>这样虽然代码是符合人类的思维习惯但是由于大量的线程切换带来了大量的性能的浪费，尤其是IO密集型的程序。<br/>所以人们发明了异步IO。就是当数据到达的时候触发我的回调。来减少线程切换带来性能损失。<br/>但是这样的坏处也是很大</p><p># 参考</p><p><a href=\"https://www.zhihu.com/question/32218874\" class=\"internal\">为什么觉得协程是趋势？</a></p>", 
            "topic": [
                {
                    "tag": "协程", 
                    "tagLink": "https://api.zhihu.com/topics/19890065"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>协程历史比线程久；</p><p>协程和线程无对比关系，应该和函数调用call/return机制对比；</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57856450", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 15, 
            "title": "协程背景知识之CPU上下文切换", 
            "content": "<p><b>声明</b></p><p>这篇文章是本人学习协程时从网上的摘抄，记录在本专栏的目的是让大家，从“源”上理解为了实现更高的性能，从进程到线程再到协程的进化过程。</p><h2><b>CPU切换的定义</b></h2><p>在每个任务运行前， CPU 都需要知道任务从哪里加载、又从哪里开始运行、也就是说，需要系统事先给他设置好 CPU 寄存器和程序计数器（Program Counter， PC）<br/>CPU 寄存器：是 CPU 内置的容量小、但速度极快的内存。<br/>程序计数器：是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。<br/>它们都是 CPU 在运行任何任务前，比如的依赖环境，因此也被叫做 CPU 上下文</p><p>上下文切换：就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。<br/>根据任务的不同，又分为进程上下文切换、线程上下文切换、中断上下文切换</p><h2><b>进程上下文切换</b></h2><h2><b>进程的运行态</b></h2><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源。</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><h2><b>系统调用</b></h2><p>从用户态到内核态的转变，需要通过系统调用来完成。比如查看文件时，需要执行多次系统调用：open、read、write、close等。系统调用的过程如下：</p><p>首先，把 CPU 寄存器里原来用户态的指令位置保存起来</p><p>为了执行内核代码，CPU 寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。</p><p>系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</p><p>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p><h2><b>进程上下文切换和系统调用的区别</b></h2><p>进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>系统调用过程中，并不涉及到虚拟内存等进程用户态的资源，也不会切换进程。</p><p>进程上下文切换，是指从一个进程切换到另一个进程进行。</p><p>系统调用过程中一直是同一个进程在运行。</p><p>因此，进程的上下文切换比系统调用时多了一步：在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一个进程的内核态后，还需要刷新进程的虚拟内存和用户栈。</p><h2><b>什么时候会切换进程上文</b></h2><p>进程执行终止，它之前使用的 CPU 会释放出来，这时再从就绪队列里，拿一个新的进程过来运行。</p><p>当某个进程的时间片耗尽了，就会被系统挂起，切换到其他正在等待 CPU 的进程进行</p><p>进程在系统资源不足（比如内存不足）时，等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p><p>当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。</p><p>当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。</p><p>发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断程序服务。</p><h2><b>线程上下文切换</b></h2><h2><b>线程和进程的区别</b></h2><p>线程是调度的基本单位，而进程则是资源拥有的基本单位。</p><p>当进程只有一个线程时，可以认为进程就等于线程。</p><p>当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。</p><p>线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><h2><b>线程的上下文切换两种情况</b></h2><p>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样的。</p><p>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。</p><h2><b>中断上下文切换</b></h2><p>中断处理会打断进程的正常调度和执行。在打断其他进程时，需要将进程当前的状态保存下来，中断结束后，进程仍然可以从原来的状态恢复运行。</p><h2><b>进程上下文切换和中断上下文切换的区别</b></h2><p>中断上下文切换并不涉及到进程的用户态。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必须的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。</p><p>对同一个 CPU 来说，中断处理比进程拥有更高的优先级。</p><p>进程上下文切换和中断上文切换的相同之处</p><p>都需要消耗CPU，切换次数过多会耗费大量 CPU，甚至严重降低系统的整体性能。</p><h2><b>协程的上下文切换</b></h2><p>协程在线程内部，因此协程的切换只是单纯的操作CPU的上下文，所以一秒钟切换个上百万次系统都抗的住。</p><h2><b>CPU 上下文切换小结</b></h2><p>CPU 上下文切换，是保证 Linux 系统正常工作的核心功能之一，一般情况下不需要我们特别关注。</p><p>但过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</p><h2><b>参考</b></h2><p><a href=\"https://link.zhihu.com/?target=https%3A//www.linuxblogs.cn/articles/linux-context-switch.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">linuxblogs.cn/articles/</span><span class=\"invisible\">linux-context-switch.html</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "协程", 
                    "tagLink": "https://api.zhihu.com/topics/19890065"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }
            ], 
            "comments": [
                {
                    "userName": "laputa", 
                    "userLink": "https://www.zhihu.com/people/ffd8c0a0f7c762fefe477d28edbb2234", 
                    "content": "错误有点多……", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57542680", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 5, 
            "title": "LevelDB-LruCache源码学习", 
            "content": "<h2><b>什么是 LRU</b></h2><p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是&#34;如果数据最近被访问过，那么将来被访问的几率也很高&#34;，反过来说&#34;如果数据最近这段时间一直都没有访问,那么将来被访问的概率也会很低&#34;。</p><h2><b>Lurcache核心数据结构</b></h2><h2><b>Lrucache的存储结构</b></h2><p>此结构既用于双向链表也用于hash表。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">LRUHandle</span> <span class=\"p\">{</span>\n  <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">value</span><span class=\"p\">;</span><span class=\"c1\">//缓存的内容\n</span><span class=\"c1\"></span>  <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">deleter</span><span class=\"p\">)(</span><span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">value</span><span class=\"p\">);</span><span class=\"c1\">//回调函数，自定义清理value、key\n</span><span class=\"c1\"></span>  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">next_hash</span><span class=\"p\">;</span><span class=\"c1\">//在HandleTable LRUCache::table_中当hash冲突时指向后续LRUHandle\n</span><span class=\"c1\"></span>  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">next</span><span class=\"p\">;</span><span class=\"c1\">//在LRUHandle LRUCache::lru_(双向链表)中指向后驱节点\n</span><span class=\"c1\"></span>  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">prev</span><span class=\"p\">;</span><span class=\"c1\">//在LRUHandle LRUCache::lru_(双向链表)中指向前驱节点\n</span><span class=\"c1\"></span>  <span class=\"n\">size_t</span> <span class=\"n\">charge</span><span class=\"p\">;</span> <span class=\"c1\">// TODO(opt): Only allow uint32_t?\n</span><span class=\"c1\"></span>  <span class=\"n\">size_t</span> <span class=\"n\">key_length</span><span class=\"p\">;</span><span class=\"c1\">//key字节数\n</span><span class=\"c1\"></span>  <span class=\"n\">uint32_t</span> <span class=\"n\">refs</span><span class=\"p\">;</span><span class=\"c1\">//引用计数\n</span><span class=\"c1\"></span>  <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">;</span> <span class=\"c1\">// Hash of key(); used for fast sharding and comparisons\n</span><span class=\"c1\"></span>  <span class=\"n\">uint64_t</span> <span class=\"n\">timestamp</span><span class=\"p\">;</span><span class=\"c1\">//改造lurcache支持时间淘汰\n</span><span class=\"c1\"></span>  <span class=\"kt\">char</span> <span class=\"n\">key_data</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span> <span class=\"c1\">// Beginning of key\n</span><span class=\"c1\"></span>  <span class=\"n\">Slice</span> <span class=\"nf\">key</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// For cheaper lookups, we allow a temporary Handle object\n</span><span class=\"c1\"></span>    <span class=\"c1\">// to store a pointer to a key in &#34;value&#34;.\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">next</span> <span class=\"o\">==</span> <span class=\"k\">this</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">Slice</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"n\">Slice</span><span class=\"p\">(</span><span class=\"n\">key_data</span><span class=\"p\">,</span> <span class=\"n\">key_length</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2><b>哈希表--HandleTable实现</b></h2><h2><b>核心成员</b> </h2><p>LRUHandle** list_; 即使用拉链法实现哈希表。</p><h2><b>源码分析</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">HandleTable</span> <span class=\"p\">{</span>\n <span class=\"k\">public</span><span class=\"o\">:</span>\n  <span class=\"n\">HandleTable</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">length_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">elems_</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">list_</span><span class=\"p\">(</span><span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">Resize</span><span class=\"p\">();</span> <span class=\"p\">}</span>\n  <span class=\"o\">~</span><span class=\"n\">HandleTable</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">delete</span><span class=\"p\">[]</span> <span class=\"n\">list_</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">Lookup</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">FindPointer</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">hash</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">Insert</span><span class=\"p\">(</span><span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">h</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">//判断h指向的内容在table中是不是已存在，存在返回，否则返回NULL。\n</span><span class=\"c1\"></span>    <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">FindPointer</span><span class=\"p\">(</span><span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">key</span><span class=\"p\">(),</span> <span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">hash</span><span class=\"p\">);</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n    <span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span> <span class=\"o\">?</span> <span class=\"nb\">NULL</span> <span class=\"o\">:</span> <span class=\"n\">old</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span><span class=\"p\">);</span>\n    <span class=\"c1\">//这里特别注意的是返回二级指针的原因。\n</span><span class=\"c1\"></span>    <span class=\"c1\">//list_[hash &amp; (length_ - 1)]是一个分配在堆上的指针\n</span><span class=\"c1\"></span>    <span class=\"c1\">//情况1、 list_[hash &amp; (length_ - 1)]==NULL时，新添加的节点需添加在其后，\n</span><span class=\"c1\"></span>    <span class=\"c1\">//因此list_[hash &amp; (length_ - 1)]= 新添加的节点内存地址\n</span><span class=\"c1\"></span>    <span class=\"c1\">//情况2、list_[hash &amp; (length_ - 1)]!=NULL时，通常链表插入时需修改前一个\n</span><span class=\"c1\"></span>    <span class=\"c1\">//节点的next_hash,因此需要前一个节点的地址，函数返回为二级指针，\n</span><span class=\"c1\"></span>    <span class=\"c1\">//就是前一个节点next_hash指针的自身地址因此一行 *ptr = h;就完成了旧指针的踢出\n</span><span class=\"c1\"></span>    <span class=\"c1\">//及新节点的加入\n</span><span class=\"c1\"></span>    <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"o\">++</span><span class=\"n\">elems_</span><span class=\"p\">;</span>\n      <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">elems_</span> <span class=\"o\">&gt;</span> <span class=\"n\">length_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// Since each cache entry is fairly large, we aim for a small\n</span><span class=\"c1\"></span>        <span class=\"c1\">// average linked list length (&lt;= 1).\n</span><span class=\"c1\"></span>        <span class=\"n\">Resize</span><span class=\"p\">();</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">old</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">Remove</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">FindPointer</span><span class=\"p\">(</span><span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">hash</span><span class=\"p\">);</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">result</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">result</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span><span class=\"p\">;</span>\n      <span class=\"o\">--</span><span class=\"n\">elems_</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">uint32_t</span> <span class=\"n\">Size</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">elems_</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n <span class=\"k\">private</span><span class=\"o\">:</span>\n  <span class=\"c1\">// The table consists of an array of buckets where each bucket is\n</span><span class=\"c1\"></span>  <span class=\"c1\">// a linked list of cache entries that hash into the bucket.\n</span><span class=\"c1\"></span>  <span class=\"n\">uint32_t</span> <span class=\"n\">length_</span><span class=\"p\">;</span>\n  <span class=\"n\">uint32_t</span> <span class=\"n\">elems_</span><span class=\"p\">;</span>\n  <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">list_</span><span class=\"p\">;</span>\n\n  <span class=\"c1\">//返回二级指针很有技巧性\n</span><span class=\"c1\"></span>  <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"nf\">FindPointer</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">list_</span><span class=\"p\">[</span><span class=\"n\">hash</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">length_</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)];</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span> <span class=\"o\">&amp;&amp;</span>\n           <span class=\"p\">((</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">hash</span> <span class=\"o\">!=</span> <span class=\"n\">hash</span> <span class=\"o\">||</span> <span class=\"n\">key</span> <span class=\"o\">!=</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">key</span><span class=\"p\">()))</span> <span class=\"p\">{</span>\n      <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ptr</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"kt\">void</span> <span class=\"nf\">Resize</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">new_length</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">new_length</span> <span class=\"o\">&lt;</span> <span class=\"n\">elems_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">new_length</span> <span class=\"o\">*=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">new_list</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LRUHandle</span><span class=\"o\">*</span><span class=\"p\">[</span><span class=\"n\">new_length</span><span class=\"p\">];</span>\n    <span class=\"n\">memset</span><span class=\"p\">(</span><span class=\"n\">new_list</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">new_list</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">*</span> <span class=\"n\">new_length</span><span class=\"p\">);</span>\n    <span class=\"n\">uint32_t</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">length_</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">list_</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n      <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">h</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span><span class=\"p\">;</span>\n        <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">hash</span><span class=\"p\">;</span>\n        <span class=\"c1\">//采用链表的表头插入法\n</span><span class=\"c1\"></span>        <span class=\"n\">LRUHandle</span><span class=\"o\">**</span> <span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">new_list</span><span class=\"p\">[</span><span class=\"n\">hash</span> <span class=\"o\">&amp;</span> <span class=\"p\">(</span><span class=\"n\">new_length</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)];</span>\n        <span class=\"n\">h</span><span class=\"o\">-&gt;</span><span class=\"n\">next_hash</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n        <span class=\"c1\">//h做为新表头节点\n</span><span class=\"c1\"></span>        <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"p\">;</span>\n        <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">elems_</span> <span class=\"o\">==</span> <span class=\"n\">count</span><span class=\"p\">);</span>\n    <span class=\"k\">delete</span><span class=\"p\">[]</span> <span class=\"n\">list_</span><span class=\"p\">;</span>\n    <span class=\"n\">list_</span> <span class=\"o\">=</span> <span class=\"n\">new_list</span><span class=\"p\">;</span>\n    <span class=\"n\">length_</span> <span class=\"o\">=</span> <span class=\"n\">new_length</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2><b>LRUCache</b></h2><h2><b>核心结构</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// Initialized before use.\n</span><span class=\"c1\"></span>  <span class=\"n\">size_t</span> <span class=\"n\">capacity_</span><span class=\"p\">;</span><span class=\"c1\">//缓存容量已字节为单位\n</span><span class=\"c1\"></span>  <span class=\"c1\">// mutex_ protects the following state.\n</span><span class=\"c1\"></span>  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span> <span class=\"n\">mutex_</span><span class=\"p\">;</span><span class=\"c1\">//锁\n</span><span class=\"c1\"></span>  <span class=\"n\">size_t</span> <span class=\"n\">usage_</span><span class=\"p\">;</span><span class=\"c1\">//当前缓存使用量，以字节为单位\n</span><span class=\"c1\"></span>  <span class=\"c1\">// Dummy head of LRU list.\n</span><span class=\"c1\"></span>  <span class=\"c1\">// lru.prev is newest entry, lru.next is oldest entry.\n</span><span class=\"c1\"></span>  <span class=\"n\">LRUHandle</span> <span class=\"n\">lru_</span><span class=\"p\">;</span> <span class=\"c1\">//双向链表，lru_为表头，插入新节点时采用表头法\n</span><span class=\"c1\"></span>  <span class=\"n\">HandleTable</span> <span class=\"n\">table_</span><span class=\"p\">;</span><span class=\"c1\">//hash表\n</span></code></pre></div><h2><b>源码分析</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">LRUCache</span><span class=\"o\">::</span><span class=\"n\">LRU_Append</span><span class=\"p\">(</span><span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">e</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 采用表头法插入新节点\n</span><span class=\"c1\"></span>  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">lru_</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">lru_</span><span class=\"p\">.</span><span class=\"n\">prev</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">prev</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">prev</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"n\">Cache</span><span class=\"o\">::</span><span class=\"n\">Handle</span><span class=\"o\">*</span> <span class=\"n\">LRUCache</span><span class=\"o\">::</span><span class=\"n\">Insert</span><span class=\"p\">(</span>\n    <span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">value</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">charge</span><span class=\"p\">,</span>\n    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">deleter</span><span class=\"p\">)(</span><span class=\"k\">const</span> <span class=\"n\">Slice</span><span class=\"o\">&amp;</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">value</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n\n  <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">lock_guard</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">mutex</span><span class=\"o\">&gt;</span> <span class=\"n\">lock</span><span class=\"p\">(</span><span class=\"n\">mutex_</span><span class=\"p\">);</span>\n\n  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">LRUHandle</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span>\n      <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">LRUHandle</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()));</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">deleter</span> <span class=\"o\">=</span> <span class=\"n\">deleter</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">charge</span> <span class=\"o\">=</span> <span class=\"n\">charge</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">key_length</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"p\">;</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">timestamp</span> <span class=\"o\">=</span> <span class=\"n\">base</span><span class=\"o\">::</span><span class=\"n\">TimeUtil</span><span class=\"o\">::</span><span class=\"n\">CurrentTimeInSec</span><span class=\"p\">();</span>\n  <span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">refs</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">// One from LRUCache, one for the returned handle\n</span><span class=\"c1\"></span>  <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"o\">-&gt;</span><span class=\"n\">key_data</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">data</span><span class=\"p\">(),</span> <span class=\"n\">key</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n  <span class=\"n\">LRU_Append</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n  <span class=\"n\">usage_</span> <span class=\"o\">+=</span> <span class=\"n\">charge</span><span class=\"p\">;</span>\n\n  <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"n\">table_</span><span class=\"p\">.</span><span class=\"n\">Insert</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">!=</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">LRU_Remove</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">);</span>\n    <span class=\"n\">Unref</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n  <span class=\"c1\">//缓存淘汰。当到达容量上限后，淘汰访问最不频繁的节点即表头lru_的next。\n</span><span class=\"c1\"></span>  <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">usage_</span> <span class=\"o\">&gt;</span> <span class=\"n\">capacity_</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">lru_</span><span class=\"p\">.</span><span class=\"n\">next</span> <span class=\"o\">!=</span> <span class=\"o\">&amp;</span><span class=\"n\">lru_</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">LRUHandle</span><span class=\"o\">*</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"n\">lru_</span><span class=\"p\">.</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"n\">LRU_Remove</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">);</span>\n    <span class=\"n\">table_</span><span class=\"p\">.</span><span class=\"n\">Remove</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"o\">-&gt;</span><span class=\"n\">key</span><span class=\"p\">(),</span> <span class=\"n\">old</span><span class=\"o\">-&gt;</span><span class=\"n\">hash</span><span class=\"p\">);</span>\n    <span class=\"n\">Unref</span><span class=\"p\">(</span><span class=\"n\">old</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">return</span> <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">Cache</span><span class=\"o\">::</span><span class=\"n\">Handle</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2><b>hash分片的设置</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">kNumShardBits</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">kNumShards</span> <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">kNumShardBits</span><span class=\"p\">;</span>\n\n  <span class=\"k\">static</span> <span class=\"n\">uint32_t</span> <span class=\"nf\">Shard</span><span class=\"p\">(</span><span class=\"n\">uint32_t</span> <span class=\"n\">hash</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">hash</span> <span class=\"o\">&gt;&gt;</span> <span class=\"p\">(</span><span class=\"mi\">32</span> <span class=\"o\">-</span> <span class=\"n\">kNumShardBits</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n</code></pre></div><p>hash分片数是2的n次方的原因是将常规的%运算转化为位运算实现，因为位运算效率更高，差不多是%的3倍。</p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "LevelDB", 
                    "tagLink": "https://api.zhihu.com/topics/19819000"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56941754", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 9, 
            "title": "Redis内部数据结构之跳表", 
            "content": "<p>跳表的核心思想</p><p>一次典型的跳表查询过程</p><p>源码分析</p><p>核心数据结构</p><p>随机算法</p><p>初始化</p><p>插入实现</p><p>图示</p><p>节点删除</p><p>Q与A</p><p>redis中节点上限为啥是32？</p><p>redis中为啥不用红黑树二用跳表？</p><h2><b>跳表的核心思想</b></h2><p>跳表的核心思想是<b>“剪枝”</b>，具体是如下方式实现<br/>如果是一个简单的链表，那么我们知道在链表中查找一个元素I的话，需要将整个链表遍历一次。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-90d3217ca65ece919930fa6928e9c1de_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"988\" data-rawheight=\"57\" class=\"origin_image zh-lightbox-thumb\" width=\"988\" data-original=\"https://pic3.zhimg.com/v2-90d3217ca65ece919930fa6928e9c1de_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;988&#39; height=&#39;57&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"988\" data-rawheight=\"57\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"988\" data-original=\"https://pic3.zhimg.com/v2-90d3217ca65ece919930fa6928e9c1de_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-90d3217ca65ece919930fa6928e9c1de_b.png\"/></figure><p>如果是说链表是排序的，并且节点中还存储了“跳跃”的指向后续节点的指针的话，那么在查找一个节点时，仅仅需要遍历N/2个节点即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-aea8a7ceef87542a7645b016544e29e5_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"972\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb\" width=\"972\" data-original=\"https://pic2.zhimg.com/v2-aea8a7ceef87542a7645b016544e29e5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;972&#39; height=&#39;76&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"972\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"972\" data-original=\"https://pic2.zhimg.com/v2-aea8a7ceef87542a7645b016544e29e5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-aea8a7ceef87542a7645b016544e29e5_b.png\"/></figure><p>从上图中已经可以看到&#34;层&#34;的出现使得时间复杂度降为原来的一半。</p><h2><b>一次典型的跳表查询过程</b> </h2><p>skiplist上的查找路径展示</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-be6d1566e00cc463cfb4b0adb8d48b40_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic1.zhimg.com/v2-be6d1566e00cc463cfb4b0adb8d48b40_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;334&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"334\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic1.zhimg.com/v2-be6d1566e00cc463cfb4b0adb8d48b40_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-be6d1566e00cc463cfb4b0adb8d48b40_b.jpg\"/></figure><p><br/>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的1/P(redis中P为0.25)，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到<b>O(log n)</b>。</p><h2><b>源码分析</b></h2><h2><b>核心数据结构</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#define ZSKIPLIST_MAXLEVEL 32 </span><span class=\"c1\">//最大层数\n</span><span class=\"c1\"></span><span class=\"cp\">#define ZSKIPLIST_P 0.25 </span><span class=\"c1\">//P\n</span><span class=\"c1\"></span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">zskiplistNode</span> <span class=\"p\">{</span>\n    <span class=\"n\">robj</span> <span class=\"o\">*</span><span class=\"n\">obj</span><span class=\"p\">;</span>\n    <span class=\"kt\">double</span> <span class=\"n\">score</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">backward</span><span class=\"p\">;</span> <span class=\"c1\">//后向指针\n</span><span class=\"c1\"></span>    <span class=\"k\">struct</span> <span class=\"n\">zskiplistLevel</span> <span class=\"p\">{</span>\n        <span class=\"k\">struct</span> <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">forward</span><span class=\"p\">;</span><span class=\"c1\">//每一层中的前向指针\n</span><span class=\"c1\"></span>        <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">span</span><span class=\"p\">;</span><span class=\"c1\">//x.level[i].span 表示节点x在第i层到其下一个节点需跳过的节点数。注：两个相邻节点span为1\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span> <span class=\"n\">level</span><span class=\"p\">[];</span>\n<span class=\"p\">}</span> <span class=\"n\">zskiplistNode</span><span class=\"p\">;</span>\n\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"n\">zskiplist</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">header</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">tail</span><span class=\"p\">;</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">length</span><span class=\"p\">;</span><span class=\"c1\">//节点总数\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">level</span><span class=\"p\">;</span><span class=\"c1\">//总层数\n</span><span class=\"c1\"></span><span class=\"p\">}</span> <span class=\"n\">zskiplis</span>\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d679e616dd3312da3d002d555e3c0b7c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1535\" data-rawheight=\"787\" class=\"origin_image zh-lightbox-thumb\" width=\"1535\" data-original=\"https://pic1.zhimg.com/v2-d679e616dd3312da3d002d555e3c0b7c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1535&#39; height=&#39;787&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1535\" data-rawheight=\"787\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1535\" data-original=\"https://pic1.zhimg.com/v2-d679e616dd3312da3d002d555e3c0b7c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d679e616dd3312da3d002d555e3c0b7c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>随机算法</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">zslRandomLevel</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"c1\">// TODO 了解这个公式背后的数学原理\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span> <span class=\"p\">((</span><span class=\"n\">random</span><span class=\"p\">()</span><span class=\"o\">&amp;</span><span class=\"mh\">0xFFFF</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"p\">(</span><span class=\"n\">ZSKIPLIST_P</span> <span class=\"o\">*</span> <span class=\"mh\">0xFFFF</span><span class=\"p\">))</span>\n        <span class=\"n\">level</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">level</span><span class=\"o\">&lt;</span><span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"nl\">level</span> <span class=\"p\">:</span> <span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>使用随机算法，在概率上可以保证上一层的节点数为下一层的<b>1/P</b>。那么SkipList可以看成是一棵<b>平衡的P叉树</b>，从最顶层开始查找某个节点需要的时间是<code>O(logpN)</code></p><h2><b>初始化</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">zskiplist</span> <span class=\"o\">*</span><span class=\"nf\">zslCreate</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">j</span><span class=\"p\">;</span>\n    <span class=\"n\">zskiplist</span> <span class=\"o\">*</span><span class=\"n\">zsl</span><span class=\"p\">;</span>\n    <span class=\"n\">zsl</span> <span class=\"o\">=</span> <span class=\"n\">zmalloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">zsl</span><span class=\"p\">));</span>\n    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"c1\">//这点很重要，跳表的层数是动态变化的。\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 初始化头节点， O(1)\n</span><span class=\"c1\"></span>    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span> <span class=\"o\">=</span> <span class=\"n\">zslCreateNode</span><span class=\"p\">(</span><span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">,</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"nb\">NULL</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 初始化层指针，O(1)\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">zsl</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2><b>插入实现</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"nf\">zslInsert</span><span class=\"p\">(</span><span class=\"n\">zskiplist</span> <span class=\"o\">*</span><span class=\"n\">zsl</span><span class=\"p\">,</span> <span class=\"kt\">double</span> <span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">robj</span> <span class=\"o\">*</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\n    <span class=\"c1\">// 记录寻找元素过程中，每层能到达的最右节点\n</span><span class=\"c1\"></span>    <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">],</span> <span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// 记录寻找元素过程中，每层所跨越的节点数\n</span><span class=\"c1\"></span>    <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">];</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">level</span><span class=\"p\">;</span>\n\n    <span class=\"n\">redisAssert</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">isnan</span><span class=\"p\">(</span><span class=\"n\">score</span><span class=\"p\">));</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 记录沿途访问的节点，并计数 span 等属性\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 平均 O(log N) ，最坏 O(N)\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"cm\">/* store rank that is crossed to reach the insert position */</span>\n        <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"p\">(</span><span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n\n        <span class=\"c1\">// 右节点不为空\n</span><span class=\"c1\"></span>        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">&amp;&amp;</span>                   \n            <span class=\"c1\">// 右节点的 score 比给定 score 小\n</span><span class=\"c1\"></span>            <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">score</span> <span class=\"o\">&lt;</span> <span class=\"n\">score</span> <span class=\"o\">||</span>      \n                <span class=\"c1\">// 右节点的 score 相同，但节点的 member 比输入 member 要小\n</span><span class=\"c1\"></span>                <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">score</span> <span class=\"o\">==</span> <span class=\"n\">score</span> <span class=\"o\">&amp;&amp;</span> \n                <span class=\"n\">compareStringObjects</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">obj</span><span class=\"p\">,</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)))</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 记录跨越了多少个元素\n</span><span class=\"c1\"></span>            <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span><span class=\"p\">;</span>\n            <span class=\"c1\">// 继续向右前进\n</span><span class=\"c1\"></span>            <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 保存访问节点\n</span><span class=\"c1\"></span>        <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"cm\">/* we assume the key is not already inside, since we allow duplicated\n</span><span class=\"cm\">     * scores, and the re-insertion of score and redis object should never\n</span><span class=\"cm\">     * happpen since the caller of zslInsert() should test in the hash table\n</span><span class=\"cm\">     * if the element is already inside or not. */</span>\n    <span class=\"c1\">// 因为这个函数不可能处理两个元素的 member 和 score 都相同的情况，\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 所以直接创建新节点，不用检查存在性\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 计算新的随机层数\n</span><span class=\"c1\"></span>    <span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"n\">zslRandomLevel</span><span class=\"p\">();</span>\n    <span class=\"c1\">// 如果 level 比当前 skiplist 的最大层数还要大\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 那么更新 zsl-&gt;level 参数\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 并且初始化 update 和 rank 参数在相应的层的数据\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">level</span> <span class=\"o\">&gt;</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n            <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"p\">;</span>\n            <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">length</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"n\">level</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 创建新节点\n</span><span class=\"c1\"></span>    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">zslCreateNode</span><span class=\"p\">(</span><span class=\"n\">level</span><span class=\"p\">,</span><span class=\"n\">score</span><span class=\"p\">,</span><span class=\"n\">obj</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 根据 update 和 rank 两个数组的资料，初始化新节点\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 并设置相应的指针\n</span><span class=\"c1\"></span>    <span class=\"c1\">// O(N)\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 设置指针\n</span><span class=\"c1\"></span>        <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">=</span> <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">;</span>\n        <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n\n        <span class=\"cm\">/* update span covered by update[i] as x is inserted here */</span>\n        <span class=\"c1\">// 设置 span\n</span><span class=\"c1\"></span>        <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">rank</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"cm\">/* increment span for untouched levels */</span>\n    <span class=\"c1\">// 更新沿途访问节点的 span 值\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 设置后退指针\n</span><span class=\"c1\"></span>    <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">update</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"nb\">NULL</span> <span class=\"o\">:</span> <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"c1\">// 设置 x 的前进指针\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">)</span>\n        <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span>\n        <span class=\"c1\">// 这个是新的表尾节点\n</span><span class=\"c1\"></span>        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// 更新跳跃表节点数量\n</span><span class=\"c1\"></span>    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">length</span><span class=\"o\">++</span><span class=\"p\">;</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2><b>图示</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4bffeff1611dbd9158ead94d7b0125d1_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"973\" data-rawheight=\"116\" class=\"origin_image zh-lightbox-thumb\" width=\"973\" data-original=\"https://pic2.zhimg.com/v2-4bffeff1611dbd9158ead94d7b0125d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;973&#39; height=&#39;116&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"973\" data-rawheight=\"116\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"973\" data-original=\"https://pic2.zhimg.com/v2-4bffeff1611dbd9158ead94d7b0125d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4bffeff1611dbd9158ead94d7b0125d1_b.png\"/></figure><p>以<code>节点19</code>插入为例，其中<br/>黑色箭头的表示的跨度为<code>update[i]-&gt;level[i].span</code><br/>蓝色箭头表示的跨度为<code>rank[0] - rank[i]</code>即节点19在<code>level_0</code>的<code>update[0]</code>为11，在<code>level_1</code>的<code>update[1]</code>为7，rank[0] - rank[i]为节点7与节点11之间的跨度<br/>绿色箭头表示的跨度为<code>节点19</code>到<code>节点37</code>的<code>span</code></p><h2><b>节点删除</b> </h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">zslDelete</span><span class=\"p\">(</span><span class=\"n\">zskiplist</span> <span class=\"o\">*</span><span class=\"n\">zsl</span><span class=\"p\">,</span> <span class=\"kt\">double</span> <span class=\"n\">score</span><span class=\"p\">,</span> <span class=\"n\">robj</span> <span class=\"o\">*</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">ZSKIPLIST_MAXLEVEL</span><span class=\"p\">],</span> <span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 遍历所有层，记录删除节点后需要被修改的节点到 update 数组\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">--</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">&amp;&amp;</span>\n            <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">score</span> <span class=\"o\">&lt;</span> <span class=\"n\">score</span> <span class=\"o\">||</span>\n                <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">score</span> <span class=\"o\">==</span> <span class=\"n\">score</span> <span class=\"o\">&amp;&amp;</span>\n                <span class=\"n\">compareStringObjects</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">obj</span><span class=\"p\">,</span><span class=\"n\">obj</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)))</span>\n            <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">;</span>\n        <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"cm\">/* We may have multiple elements with the same score, what we need\n</span><span class=\"cm\">     * is to find the element with both the right score and object. */</span>\n    <span class=\"c1\">// 因为多个不同的 member 可能有相同的 score \n</span><span class=\"c1\"></span>    <span class=\"c1\">// 所以要确保 x 的 member 和 score 都匹配时，才进行删除\n</span><span class=\"c1\"></span>    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">score</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">score</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">equalStringObjects</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">obj</span><span class=\"p\">,</span><span class=\"n\">obj</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n        <span class=\"n\">zslDeleteNode</span><span class=\"p\">(</span><span class=\"n\">zsl</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">update</span><span class=\"p\">);</span>\n        <span class=\"n\">zslFreeNode</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"cm\">/* not found */</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"cm\">/* not found */</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"nf\">zslDeleteNode</span><span class=\"p\">(</span><span class=\"n\">zskiplist</span> <span class=\"o\">*</span><span class=\"n\">zsl</span><span class=\"p\">,</span> <span class=\"n\">zskiplistNode</span> <span class=\"o\">*</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">zskiplistNode</span> <span class=\"o\">**</span><span class=\"n\">update</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// 修改相应的指针和 span , O(N)\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">==</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">+=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">update</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">].</span><span class=\"n\">span</span> <span class=\"o\">-=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 处理表头和表尾节点\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">forward</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">tail</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">-&gt;</span><span class=\"n\">backward</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 收缩 level 的值, O(N)\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">header</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"p\">[</span><span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">].</span><span class=\"n\">forward</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span><span class=\"p\">)</span>\n        <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">level</span><span class=\"o\">--</span><span class=\"p\">;</span>\n\n    <span class=\"n\">zsl</span><span class=\"o\">-&gt;</span><span class=\"n\">length</span><span class=\"o\">--</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2><b>Q与A</b></h2><h2><b>跳表层数上限为啥是32？</b> </h2><p>根据前面的随机算法当level[0]有2的64次方个节点时，才能达到32层，因此层数上限是32完全够用了。</p><h2><b>redis中为啥不用红黑树二用跳表？</b> </h2><p><a href=\"https://link.zhihu.com/?target=https%3A//news.ycombinator.com/item%3Fid%3D1171423\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">news.ycombinator.com/it</span><span class=\"invisible\">em?id=1171423</span><span class=\"ellipsis\"></span></a><br/>1 内存占用方面跳表比红黑树多，但是多的内存很有限<br/>2 实现比红黑树简单<br/>3 跟红黑树更方便的支持范围查询</p><h2><b>参考</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//zhangtielei.com/posts/blog-redis-skiplist.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">zhangtielei.com/posts/b</span><span class=\"invisible\">log-redis-skiplist.html</span><span class=\"ellipsis\"></span></a> <br/><a href=\"https://link.zhihu.com/?target=http%3A//lcm.csa.iisc.ernet.in/dsa/node52.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">lcm.csa.iisc.ernet.in/d</span><span class=\"invisible\">sa/node52.html</span><span class=\"ellipsis\"></span></a><br/><a href=\"https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000013418471\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">segmentfault.com/a/1190</span><span class=\"invisible\">000013418471</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "跳表", 
                    "tagLink": "https://api.zhihu.com/topics/19698527"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/56930505", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 70, 
            "title": "linux 进程如何使用内存", 
            "content": "<p></p><h2><b>X86进程布局</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-967a019600b06c827333c2bf9a399fcd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"903\" data-rawheight=\"568\" class=\"origin_image zh-lightbox-thumb\" width=\"903\" data-original=\"https://pic2.zhimg.com/v2-967a019600b06c827333c2bf9a399fcd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;903&#39; height=&#39;568&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"903\" data-rawheight=\"568\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"903\" data-original=\"https://pic2.zhimg.com/v2-967a019600b06c827333c2bf9a399fcd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-967a019600b06c827333c2bf9a399fcd_b.jpg\"/></figure><ul><li>1.代码段（text）<br/>代码段由各个函数产生，函数的每一个语句将最终经过编绎和汇编生成二进制机器代码（具体生生哪种体系结构的机器代码由编译器决定）。</li><li>2.只读数据段（rodata）<br/>只读数据段由程序中所使用的数据产生，该部分数据的特点是在运行中不需要改变，因此编译器会将该数据段放入只读的部分中。<b>C语言中的只读全局变量，程序中使用的字符串常量等会在编译时被放入到只读数据区</b>。const修饰的全局变量在常量区；const修饰的局部变量只是为了防止修改，没有放入常量区。</li><li>3.读写数据段（data）<br/>读写数据段表示了在目标文件中一部分可以读也可以写的数据区，在某些场合它们又被称为已初始化数据段，这部分数据段和代码段，与只读数据段一样都属于程序中的静态区域，但具有可写性的特点。<b>通常已初始化的全局变量和局部静态变量被放在了读写数据段。</b></li><li>4.未初始化数据段（bss）<br/>与读写数据段类似，它也属于静态数据区，但是该段中的数据没有经过初始化。<b>被初始化为0的全局变量也会被放入.bss段。如 全局变量 int* p_pro = NULL;</b></li><li>5.堆（heap）<br/>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li><li>6.栈<br/>栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li></ul><h2><b>堆（heap）</b></h2><h2><b>为什么需要虚拟内存？</b></h2><p><b>核心思想就是用有限内存承载尽量多的进程</b>。<br/>程序是一系列代码段，数据段的集合，而程序要运行必须是加载到内存里的，但是物理内存就那么大，如何能保证很多个程序都装载进去呢？这里就引进了虚拟内存的概念，虚拟内存基本思想就是，给每个程序都分配一个4G的虚拟的内存，但这部分内存占用的不是物理内存，而是磁盘空间，这部分叫做虚拟存储器，就是安装Linux系统时候的SWAP空间。而对应的物理内存就是物理存储器。<br/>有没有觉得整个过程像开了“空头支票”一样？程序要跑起来，操作系统许诺它给你4G的空间，但却是不能用的，那真要执行的时候怎么办呢？操作系统会把磁盘上的程序代码数据“移”到内存里，把不需要的还会“移”出去到磁盘上，这样看上去就好像可以跑很多进程了。</p><h2><b>虚拟内存和物理内存映射实现(MMU)</b> </h2><p>CPU中含有一个被称为内存管理单元（Memory Management Unit, MMU）的硬件，它的功能是将虚拟地址转换为物理地址。MMU需要借助存放在内存中的页表来动态翻译虚拟地址，该页表由操作系统管理。</p><h2><b>页表</b> </h2><p>操作系统通过将虚拟内存分割为大小固定的块来作为硬盘和内存之间的传输单位，这个块被称为虚拟页（Virtual Page, VP），每个虚拟页的大小为P=2^p字节。物理内存也会按照这种方法分割为物理页（Physical Page, PP），大小也为P字节。<br/>CPU在获得虚拟地址之后，需要通过MMU将虚拟地址翻译为物理地址。而在翻译的过程中还需要借助页表，所谓页表就是一个存放在物理内存中的数据结构，它记录了虚拟页与物理页的映射关系。<br/>页表是一个元素为页表条目（Page Table Entry, PTE）的集合，每个虚拟页在页表中一个固定偏移量的位置上都有一个PTE。下面是PTE仅含有一个有效位标记的页表结构，该有效位代表这个虚拟页是否被缓存在物理内存中。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ebd7fbde9ea448926a319dcf58d3c7f1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"693\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb\" width=\"693\" data-original=\"https://pic2.zhimg.com/v2-ebd7fbde9ea448926a319dcf58d3c7f1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;693&#39; height=&#39;515&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"693\" data-rawheight=\"515\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"693\" data-original=\"https://pic2.zhimg.com/v2-ebd7fbde9ea448926a319dcf58d3c7f1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ebd7fbde9ea448926a319dcf58d3c7f1_b.jpg\"/></figure><p>虚拟页VP 0、VP 4、VP 6、VP 7被缓存在物理内存中，虚拟页VP 2和VP 5被分配在页表中，但并没有缓存在物理内存，虚拟页VP 1和VP 3还没有被分配。<br/>在进行动态内存分配时，例如malloc()函数或者其他高级语言中的new关键字，操作系统会在硬盘中创建或申请一段虚拟内存空间，并更新到页表（分配一个PTE，使该PTE指向硬盘上这个新创建的虚拟页）。<br/>由于CPU每次进行地址翻译的时候都需要经过PTE，所以如果想控制内存系统的访问，可以在PTE上添加一些额外的许可位（例如读写权限、内核权限等），这样只要有指令违反了这些许可条件，CPU就会触发一个一般保护故障，将控制权传递给内核中的异常处理程序。一般这种异常被称为“段错误（Segmentation Fault）”。</p><h2><b>内存分配</b></h2><p>从操作系统角度来看，进程分配内存有两种方式，分别由两个系统调用完成：brk和mmap（不考虑共享内存）。 </p><ul><li>1、brk是将数据段(.data)的最高地址指针_edata往高地址推； </li><li>2、mmap是在进程的虚拟地址空间中（堆和栈中间，称为文件映射区域的地方）找一块空闲的虚拟内存。</li></ul><h2><b>情况一、malloc小于128k的内存，使用brk分配内存</b> </h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6a8ccbdcc133ccee3d80a3065542177e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6a8ccbdcc133ccee3d80a3065542177e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;523&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6a8ccbdcc133ccee3d80a3065542177e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6a8ccbdcc133ccee3d80a3065542177e_b.jpg\"/></figure><p>这里写图片描述<br/>brk分配的内存需要等到高地址内存释放以后才能释放（例如，在B释放之前，A是不可能释放的，这就是内存碎片产生的原因，什么时候紧缩看下面），而mmap分配的内存可以单独释放。 </p><h2><b>情况二、malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配</b> </h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-caf089e52835f52c5c6bb1e13b4e1d5d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-caf089e52835f52c5c6bb1e13b4e1d5d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;523&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"523\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-caf089e52835f52c5c6bb1e13b4e1d5d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-caf089e52835f52c5c6bb1e13b4e1d5d_b.jpg\"/></figure><p>这里写图片描述<br/>mmap是用来建立从虚拟空间到磁盘空间的映射的，可以将一个虚拟空间地址映射到一个磁盘文件上，当不设置这个地址时，则由系统自动设置，函数返回对应的内存地址（虚拟地址），当访问这个地址的时候，就需要把磁盘上的内容拷贝到内存了，然后就可以读或者写，最后通过manmap可以将内存上的数据换回到磁盘，也就是解除虚拟空间和内存空间的映射，这也是一种读写磁盘文件的方法，也是一种进程共享数据的方法 共享内存。</p><h2><b>代码段/数据段/BSS段/栈</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span><span class=\"cpf\">&lt;malloc.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span><span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"n\">bss_var</span><span class=\"p\">;</span><span class=\"c1\">//.bss,但被编译器优化了\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">data_var0</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"c1\">//.data\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">global_var1</span> <span class=\"o\">=</span><span class=\"mi\">9</span><span class=\"p\">;</span><span class=\"c1\">//.rodata\n</span><span class=\"c1\"></span><span class=\"kt\">int</span><span class=\"o\">*</span> <span class=\"n\">p_pro</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span><span class=\"c1\">//.bss\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span><span class=\"kt\">char</span> <span class=\"o\">**</span><span class=\"n\">argv</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n  <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">p3</span> <span class=\"o\">=</span> <span class=\"s\">&#34;123456&#34;</span><span class=\"p\">;</span><span class=\"c1\">//&#34;123456&#34;放.rodata\n</span><span class=\"c1\"></span>  <span class=\"kt\">char</span> <span class=\"n\">p4</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"s\">&#34;123456&#34;</span><span class=\"p\">;</span><span class=\"c1\">//&#34;123456&#34;不放.rodata(猜测放text段，待验证)\n</span><span class=\"c1\"></span>  <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">99</span><span class=\"p\">;</span><span class=\"c1\">//99同下不放.rodata采用立即数寻址,故放在text段;局部const变量i不放.rodata\n</span><span class=\"c1\"></span>  <span class=\"kt\">int</span> <span class=\"n\">stack_var0</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">;</span>\n  <span class=\"kt\">int</span> <span class=\"n\">stack_var1</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">;</span>\n  <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">data_var1</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"p\">;</span><span class=\"c1\">//局部static data_var1保存于.data\n</span><span class=\"c1\"></span>  <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n <span class=\"p\">}</span>\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bdbbb653a06639d1f0a1bae0a9f00965_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb\" width=\"821\" data-original=\"https://pic2.zhimg.com/v2-bdbbb653a06639d1f0a1bae0a9f00965_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;821&#39; height=&#39;369&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"821\" data-rawheight=\"369\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"821\" data-original=\"https://pic2.zhimg.com/v2-bdbbb653a06639d1f0a1bae0a9f00965_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bdbbb653a06639d1f0a1bae0a9f00965_b.jpg\"/></figure><p>保存于.data的变量有data_var0、data_var1 占用8字节</p><p>保存于.bss的变量有p_pro 占用8字节（64bit机器）</p><p>保存于.rodata的变量有global_var1、&#34;123456&#34; 共占用11字节</p><h2><b>内核栈</b></h2><p>内核栈存在于内核地址空间，用于实现系统调用。</p><h2>系统调用</h2><p>比如查看文件时，需要执行多次系统调用：open、read、write、close等。</p><h2>过程如下</h2><p>首先，把 CPU 寄存器里原来用户态的指令位置保存起来</p><p>为了执行内核代码，CPU 寄存器需要更新为内核态指令的新位置，最后跳转到内核态运行内核任务。</p><p>系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</p><p>所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换。</p><h2><b>线程栈</b></h2><p>　从 Linux 内核的角度来说，其实它并没有线程的概念，Linux 把所有线程都当做进程来实现，<br/>线程仅仅被视为一个与其他进程共享某些资源的进程，<br/>而是否共享地址空间几乎是进程和 Linux 中所谓线程的唯一区别。<br/>pthread库是通过调用mmap()来为新的线程创建栈空间。</p><h2><b>线程共享的资源</b></h2><p>地址空间<br/>全局变量<br/>文件描述符<br/>子进程<br/>信号及信号处理函数</p><h2><b>独享的资源</b></h2><p>程序计数器<br/>寄存器<br/>线程栈</p><h2><b>举一反三之Segmentation Fault错误原因总结</b></h2><p>当程序试图访问不被允许访问的内存区域（比如，尝试写一块属于操作系统的内存），或以错误的类型访问内存区域（比如，尝试写一块只读内存），即段错误应该就是访问了不可访问的内存，这个内存要么是不存在的，要么是受系统保护的</p><h2><b>产生SIGSEGV的可能情况</b></h2><p>我们把指针运算（加减）引起的越界、野指针、空指针都归为指针越界。SIGSEGV在很多时候是由于指针越界引起的，但并不是所有的指针越界都会引发SIGSEGV。一个越界的指针，如果不引用它，是不会引起SIGSEGV的。而即使引用了一个越界的指针，也不一定引起SIGSEGV。</p><ul><li>1、试图写只读数据</li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Foo&#34;</span><span class=\"p\">;</span> <span class=\"c1\">// Compiler marks the constant string as read-only\n</span><span class=\"c1\"></span><span class=\"o\">*</span><span class=\"n\">str</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;b&#39;</span><span class=\"p\">;</span> <span class=\"c1\">// Which means this is illegal and results in a segfault\n</span></code></pre></div><p>由上 str执行的内容是放在.rodata中的是只读的。</p><ul><li>2、访问不存在的内存地址</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">int i=0; \nscanf (&#34;%d&#34;, i); /* should have used &amp;i */ \nprintf (&#34;%d\\n&#34;, i);\nreturn 0;\n</code></pre></div><ul><li>3、访问空地址</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">int *p = null;\n*p = 1;\n</code></pre></div><ul><li>4、数组访问越界</li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span> \n        <span class=\"kt\">char</span> <span class=\"n\">test</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span> \n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%c&#34;</span><span class=\"p\">,</span> <span class=\"n\">test</span><span class=\"p\">[</span><span class=\"mi\">10</span><span class=\"p\">]);</span> \n        <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span> \n<span class=\"p\">}</span>　\n</code></pre></div><ul><li>5、 试图把一个整数按照字符串的方式输出</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">int main() { \n    int b = 10; \n    printf(&#34;%s\\n&#34;, b);\n    return 0; \n}　\n</code></pre></div><ul><li>6、  堆栈溢出<br/>1、就是不顾堆栈中分配的局部数据块大小，向该数据块写入了过多的数据，导致数据越界，结果覆盖了别的数据<br/>此种情况不一定会引发段错误。<br/>2、超过系统设置的栈大小上限。</li></ul><h2><b>举一反三之使用mmap实现共享内存</b></h2><p>map_normalfile2试图打开命令行参数指定的一个普通文件，把该文件映射到进程的地址空间，并对映射后的地址空间进行写操作。map_normalfile1把命令行参数指定的文件映射到进程地址空间，然后对映射后的地址空间执行读操作。这样，两个进程通过命令行参数指定同一个文件来实现共享内存方式的进程间通信。<br/>注：实现共享内存也可以基于shm(Linux环境下的低延迟通信 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/MengRao/tcpshm\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/MengRao/tcps</span><span class=\"invisible\">hm</span><span class=\"ellipsis\"></span></a>)</p><h2>举一反三之多个进程调用同一个动态库</h2><p>多个进程为什么可以同时调用同一个动态库而没有任何问题？</p><p>原因是多个进程只共享so的代码段，不共享数据段。</p><p>详见：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/u010312436/article/details/81263980\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/u01031243</span><span class=\"invisible\">6/article/details/81263980</span><span class=\"ellipsis\"></span></a></p><h2><b>参考</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//blog.51cto.com/wulingdong/2047496\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.51cto.com/wulingdo</span><span class=\"invisible\">ng/2047496</span><span class=\"ellipsis\"></span></a>  邬领东-漫游计算机系统之虚拟存储器<br/><a href=\"https://link.zhihu.com/?target=http%3A//www.kerneltravel.net/journal/v/mem.htm\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">kerneltravel.net/journa</span><span class=\"invisible\">l/v/mem.htm</span><span class=\"ellipsis\"></span></a> Linux内存管理<br/><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/59f8691b51882534af254317\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">juejin.im/post/59f8691b</span><span class=\"invisible\">51882534af254317</span><span class=\"ellipsis\"></span></a>  虚拟内存那点事儿<br/><a href=\"https://link.zhihu.com/?target=http%3A//codefine.site/1191.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">codefine.site/1191.html</span><span class=\"invisible\"></span></a>   从一个非典型的内存越界访问问题看Linux的进程内存布局<br/><a href=\"https://link.zhihu.com/?target=http%3A//blog.jobbole.com/110272/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">blog.jobbole.com/110272</span><span class=\"invisible\">/</span><span class=\"ellipsis\"></span></a>   一个由进程内存布局异常引起的问题<br/><a href=\"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/2346806/what-is-a-segmentation-fault\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/2346806/what-is-a-segmentation-fault</span><span class=\"ellipsis\"></span></a> <br/><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/u010150046/article/details/77775114\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/u01015004</span><span class=\"invisible\">6/article/details/77775114</span><span class=\"ellipsis\"></span></a>  Segmentation Fault错误原因总结</p>", 
            "topic": [
                {
                    "tag": "虚拟内存", 
                    "tagLink": "https://api.zhihu.com/topics/19831239"
                }, 
                {
                    "tag": "后台开发", 
                    "tagLink": "https://api.zhihu.com/topics/19693303"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }
            ], 
            "comments": [
                {
                    "userName": "巨金怪", 
                    "userLink": "https://www.zhihu.com/people/47ae38e7263f4299ecfd03fe27cf4607", 
                    "content": "那个第六点写错了，栈是先进后出", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Markman101", 
                            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
                            "content": "跟栈先进后出的关系是?", 
                            "likes": 0, 
                            "replyToAuthor": "巨金怪"
                        }, 
                        {
                            "userName": "巨金怪", 
                            "userLink": "https://www.zhihu.com/people/47ae38e7263f4299ecfd03fe27cf4607", 
                            "content": "我意思是第六点你写的是基于栈的先进先出特点，这块应该是笔误吧，写错了", 
                            "likes": 0, 
                            "replyToAuthor": "Markman101"
                        }
                    ]
                }, 
                {
                    "userName": "胡伟强", 
                    "userLink": "https://www.zhihu.com/people/84697e5049093a7c2a205be162a438f3", 
                    "content": "free 并不意味 heap 收缩了吧，只是把 heap 内一段内存设为空闲，heap 伸缩应该是根据 sbrk 函数实现的", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "LAsir", 
                    "userLink": "https://www.zhihu.com/people/0662c8bbd87d0624e47fc9a51540029d", 
                    "content": "每个进程创建时都会占用4g的磁盘空间？那进程多的时候磁盘空间岂不是很快就满了？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52843220", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 1, 
            "title": "多线程系列(1)-信号量", 
            "content": "<p>通过使用信号量可以很好的完成线程同步。两个线程同时监视同一个信号量。A线程增加信号量的值，B<br/>线程减少信号量的值。 当A线程增加信号量大于0时，B线程的等待信号量就会触发，每触发一次将信号量减1，直到将信号量减为0，B线程继续等待A线程增加信号量。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">sem_init</span><span class=\"p\">(</span><span class=\"n\">sem_t</span> <span class=\"o\">*</span><span class=\"n\">sem</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">pshared</span><span class=\"p\">,</span> <span class=\"kt\">unsigned</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"p\">);</span>\n</code></pre></div><p><code>sem_init()</code> 初始化一个定位在 sem 的匿名信号量。value 参数指定信号量的初始值。 pshared 参数指明信号量是由进程内线程共享，还是由进程之间共享。如果 pshared 的值为 0，那么信号量将被进程内的线程共享，并且应该放置在所有线程都可见的地址上(如全局变量，或者堆上动态分配的变量)。<br/>如果 pshared 是非零值，那么信号量将在进程之间共享，并且应该定位共享内存区域(见 <code>shm_open(3)、mmap(2) 和 shmget(2)</code>)。(因为通过 <code>fork(2)</code>创建的孩子继承其父亲的内存映射，因此它也可以见到这个信号量。所有可以访问共享内存区域的进程都可以用 <code>sem_post(3)、sem_wait(3)</code>等等操作信号量。初始化一个已经初始的信号量其结果未定义。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">sem_post</span><span class=\"p\">(</span><span class=\"n\">sem_t</span> <span class=\"o\">*</span><span class=\"n\">sem</span><span class=\"p\">);</span>\n</code></pre></div><p><code>sem_post</code>函数的作用是给信号量的值加上一个“1”，它是一个“原子操作”－－－即同时对同一个信号量做加“1”操作的两个线程是不会冲突的；而同 时对同一个文件进行读、加和写操作的两个程序就有可能会引起冲突。信号量的值永远会正确地加一个“2”－－因为有两个线程试图改变它。  当有线程阻塞在这个信号量上时，调用这个函数会使其中一个线程不在阻塞，选择机制是有线程的调度策略决定的。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">sem_wait</span><span class=\"p\">(</span><span class=\"n\">sem_t</span> <span class=\"o\">*</span> <span class=\"n\">sem</span><span class=\"p\">);</span>\n</code></pre></div><p><code>sem_wait</code>函数也是一个原子操作，它的作用是从信号量的值减去一个“1”，但它永远会先等待该信号量为一个非零值才开始做减法。也就是说，如果你对一个值为2的信号量调用<code>sem_wait()</code>,线程将会继续执行，这信号量的值将减到1。如果对一个值为0的信号量调用<code>sem_wait()</code>，这个函数就 会地等待直到有其它线程增加了这个值使它不再是0为止。如果有两个线程都在<code>sem_wait()</code>中等待同一个信号量变成非零值，那么当它被第三个线程增加 一个“1”时，等待线程中只有一个能够对信号量做减法并继续执行，另一个还将处于等待状态。<code>sem_trywait(sem_t  *sem)</code>是函数sem_wait的非阻塞版，它直接将信号量<code>sem</code>减1，同时返回错误代码。</p>", 
            "topic": [
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52843681", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 0, 
            "title": "多线程系列(2)-条件变量", 
            "content": "<h2><b>虚假唤醒</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">while(条件不满足){  \n   condition_wait(cond, mutex);  \n}  \n而不是:  \nIf( 条件不满足 ){  \n   Condition_wait(cond,mutex);  \n}\n</code></pre></div><p>这是因为可能会存在虚假唤醒<code>”spurious wakeup”</code>的情况。 <br/>也就是说，即使没有线程调用<code>condition_signal</code>, 原先调用<code>condition_wai</code>t的函数也可能会返回。</p><h2><b>条件变量和互斥量连用</b></h2><p>为了防止race-condition，条件变量总是和互斥锁变量mutex结合在一起使用。<br/>Why it is required to lock a mutex before calling pthread_cond_wait?<br/>Because otherwise there is an unavoidable race condition.</p><p>A mutex protects shared state. A condition variable is associated with some predicate (&#34;condition&#34;) on the state. The basic idea is that you want to:</p><p>1) check the predicate</p><p>2) if the predicate is false, go to sleep until it becomes true</p><p>In a concurrent system, it is always possible for some thread to make the predicate true between (1) and (2). To avoid this race, you must hold a mutex before (1) and you must release it atomically as you perform (2).</p><p>For example, for a queue the predicate might be &#34;the queue is not empty&#34;. But between the time you check to see if the queue is non-empty and the time you go to sleep, some other thread might add something to the queue.</p><p>Thus you must hold the mutex both while checking the predicate and at the time you call pthread_cond_wait.</p><p>来源： <a href=\"https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/6312342/pthread-cond-wait-and-mutex-requirement\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/6312342/pthread-cond-wait-and-mutex-requirement</span><span class=\"ellipsis\"></span></a></p><h2><b>条件变量的使用</b></h2><p>条件变量(<code>Condtion Variable</code>)是在多线程程序中用来实现“等待-&gt;唤醒”逻辑常用的方法。举个简单的例子，应用程序A中包含两个线程<code>t1</code>和<code>t2</code>。t1需要在bool变量<code>test_cond</code>为true时才能继续执行，而<code>test_cond</code>的值是由<code>t2</code>来改变的，这种情况下，如何来写程序呢？可供选择的方案有两种：</p><p>第一种是t1定时的去轮询变量<code>test_cond</code>，如果test_cond为false，则继续休眠；如果<code>test_cond</code>为true，则开始执行。<br/>第二种就是上面提到的条件变量，t1在<code>test_cond</code>为false时调用cond_wait进行等待，t2在改变test_cond的值后，调用<code>cond_signal</code>，唤醒在等待中的t1，告诉t1 test_cond的值变了，这样t1便可继续往下执行。<br/>很明显，上面两种方案中，第二种方案是比较优的。在第一种方案中，在每次轮询时，如果t1休眠的时间比较短，会导致cpu浪费很厉害；如果t1休眠的时间比较长，又会导致应用逻辑处理不够及时，致使应用程序性能下降。第二种方案就是为了解决轮询的弊端而生的。然而条件变量在使用的过程中，比较容易出错，如何用得不正确的话，会适得其反的，接下来，我将详细分析如何来使用条件变量，希望能够给在使用条件变量过程中遇到问题的朋友有所帮助。<br/>在开始介绍之前，需要说明一下，在接下来的介绍中，需要用到互斥锁和条件变量相关的内容，在这里我以linux下的<code>pthread_mutex_t</code>为互斥锁类型，pthread_cond_t为条件变量类型来进行介绍，对pthread不熟的朋友，可以参考一下linux下的<code>manual</code>。</p><ol><li>下面是把刚开始举的例子翻译后的程序：</li></ol><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">pthread_mutex_t</span> <span class=\"n\">mutex</span><span class=\"p\">;</span>  <span class=\"c1\">///&lt; 互斥锁\n</span><span class=\"c1\"></span><span class=\"n\">pthread_cond_t</span>  <span class=\"n\">cond</span><span class=\"p\">;</span>   <span class=\"c1\">///&lt; 条件变量\n</span><span class=\"c1\"></span><span class=\"kt\">bool</span> <span class=\"n\">test_cond</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"c1\">/// TODO 初始化mutex和cond\n</span><span class=\"c1\"></span>\n<span class=\"c1\">/// thread 1:\n</span><span class=\"c1\"></span><span class=\"n\">pthread_mutex_lock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>            <span class=\"c1\">///&lt; 1\n</span><span class=\"c1\"></span><span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">test_cond</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">pthread_cond_wait</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">cond</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>  <span class=\"c1\">///&lt; 2,3\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"n\">pthread_mutex_unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>          <span class=\"c1\">///&lt; 4\n</span><span class=\"c1\"></span><span class=\"n\">RunThread1Func</span><span class=\"p\">();</span>\n\n<span class=\"c1\">/// thread 2:\n</span><span class=\"c1\"></span><span class=\"n\">pthread_mutex_lock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>            <span class=\"c1\">///&lt; 5\n</span><span class=\"c1\"></span><span class=\"n\">test_cond</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"n\">pthread_mutex_unlock</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">mutex</span><span class=\"p\">);</span>          <span class=\"c1\">///&lt; 6\n</span><span class=\"c1\"></span>\n<span class=\"n\">pthread_cond_signal</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">cond</span><span class=\"p\">);</span>\n\n<span class=\"c1\">/// TODO 销毁mutex和cond\n</span></code></pre></div><p>通过上面的例子，下面我来介绍一下条件变量在使用过程中需要注意的几点（也是比较容易出错的）：<br/>（1）条件变量的使用过程中，最为关键的一点是互斥锁的使用。细心的朋友应该发现了，我在上面的例子中标了1、2、3、4、5、6个标号。在这里1、4、5、6都是正常的lock/unlock，2、3是需要特别说明的。2是进入pthread_cond_wait后的，pthread_cond_wait调的pthread_mutex_unlock，这样做的目的是为了保证在thread1阻塞wait后，thread2获取同一把锁mutex的时候，能够正常获取（即5，6）。3是thread1被唤醒后，要退出pthead_cond_wait之前，pthread_cond_wait调的pthread_mutex_lock，这样做的目的是为了把mutex的控制权还给调用pthread_cond_wait的线程（即thread1）。整理一下基本的时序为：</p><div class=\"highlight\"><pre><code class=\"language-text\">thread 1 lock-&gt;thread 1 wait-&gt; thread 1 unlock(in wait)\n-&gt;thread 2 lock-&gt;thread 2 signal-&gt;thread 2 unlock\n-&gt;thread 1 lock(in wait)-&gt;thread 1 unlock\n</code></pre></div><p>（2）条件变量使用的过程中，通常会加一个bool或者int的值test_cond来配合使用。这里需要注意的一点是一定要在signal之前来改变test_cond，这样才能保证wait的线程被唤醒后，能够取到正确的test_cond的值，否则后果是不可预测的。</p><p>PS:条件变量机制不是异步信号安全的，也就是说，在信号处理函数中调用pthread_cond_signal()或者pthread_cond_broadcast()很可能引起死锁</p><h2><b>single和broadcast</b></h2><p><code>pthread_cond_signal()</code>激活一个等待该条件的线程，存在多个等待线程时按入队顺序激活其中一个；而<code>pthread_cond_broadcast()</code>则激活所有等待线程</p><h2><b>参考</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//www.wuzesheng.com/%3Fp%3D1668\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">wuzesheng.com/?</span><span class=\"invisible\">p=1668</span><span class=\"ellipsis\"></span></a>\\<br/><a href=\"https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/3513045/conditional-variable-vs-semaphore\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/3513045/conditional-variable-vs-semaphore</span><span class=\"ellipsis\"></span></a><br/><a href=\"https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/11681381/difference-between-a-semaphore-and-a-conditional-variable\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/11681381/difference-between-a-semaphore-and-a-conditional-variable</span><span class=\"ellipsis\"></span></a><br/><a href=\"https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/70773/pthread-cond-wait-versus-semaphore\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">stackoverflow.com/quest</span><span class=\"invisible\">ions/70773/pthread-cond-wait-versus-semaphore</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52843823", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 1, 
            "title": "多线程系列(3)-总结", 
            "content": "<p><b>多线程</b></p><h2><b>线程函数</b></h2><h2><b>创建线程</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;pthread.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">int</span> <span class=\"nf\">pthread_create</span><span class=\"p\">(</span><span class=\"n\">pthread_t</span> <span class=\"o\">*</span><span class=\"kr\">thread</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">pthread_attr_t</span> <span class=\"o\">*</span><span class=\"n\">attr</span><span class=\"p\">,</span>\n            <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">start_routine</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">),</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">arg</span><span class=\"p\">);</span>\n<span class=\"err\">参数：</span>\n    <span class=\"kr\">thread</span> <span class=\"err\">线程</span><span class=\"n\">ID</span>\n    <span class=\"n\">attr</span> <span class=\"err\">指向一个</span> <span class=\"n\">pthread_attr_t</span> <span class=\"err\">结构，它包含在线程创建时使用的属性值：这个结构通过</span> <span class=\"n\">pthread_attr_init</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"err\">等相关函数初始化。如果</span> <span class=\"n\">attr</span> <span class=\"err\">是</span> <span class=\"nb\">NULL</span><span class=\"err\">，则线程使用默认属性创建</span>\n    <span class=\"nl\">start_routine</span><span class=\"p\">:</span><span class=\"err\">是个函数地址，线程启动后要执行的函数</span>\n    <span class=\"nl\">arg</span><span class=\"p\">:</span><span class=\"err\">传给线程启动函数的参数</span>\n    <span class=\"err\">返回值：成功返回</span><span class=\"mi\">0</span><span class=\"err\">；失败返回错误码</span>\n</code></pre></div><h2><b>终止同进程其他线程</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">pthread_cancel</span><span class=\"p\">(</span><span class=\"n\">pthread_t</span> <span class=\"kr\">thread</span><span class=\"p\">)</span>\n<span class=\"err\">在默认的情况下，一个线程是可取消的并且是同步取消的</span><span class=\"p\">.</span>\n<span class=\"err\">参数：</span><span class=\"kr\">thread</span> <span class=\"err\">要取消的线程</span><span class=\"n\">ID</span>\n</code></pre></div><h2><b>等待线程结束:</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"nf\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">pthread_t</span> <span class=\"kr\">thread</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">**</span><span class=\"n\">retval</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>线程显示退出</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">pthread_exit</span><span class=\"p\">(</span> <span class=\"kt\">void</span> <span class=\"o\">*</span> <span class=\"n\">value_ptr</span> <span class=\"p\">);</span>\n</code></pre></div><h2><b>线程编程</b></h2><p>属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数 之前调用。属性对象主要包括是否绑定、是否分离、堆栈地址、堆栈大小、优先级。默认的属性为非绑定、非分离、缺省1M的堆栈、与父进程同样级别的优先级。</p><h2><b>线程终止</b></h2><p>线程终止可以有三种方法：<br/>1、从线程函数return。这种方法对主线程不适用，从main函数return相当于调用exit，而如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止。<br/>2、一个线程可以调用pthread_cancel 终止同一进程中的另一个线程。<br/>3、线程可以调用pthread_exit终止自己。</p><h2><b>分离与非分离</b></h2><p>当一个非分离的线程终止后，该线程的内存资源(线程描述符和栈)并不会被释放，直到有线程对它使   用了pthread_join时才被释放。调用pthread_join的线程将被挂起直到参数thread所代表的线程终止时为止。<br/>如果线程已经结束，那么该函数会立即返回.<br/>pthread_join是一个线程阻塞函数，调用它的函数将一直等到被等待的线程结束为止。<br/>pthread_exit函数唯一的参数value_ptr是函数的返回代码，只要pthread_join中的第二个参数value_ptr不是NULL，这个值将被传递给value_ptr.</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">pthread_exit和pthread_join函数的用法</span><span class=\"err\">：</span>\n<span class=\"n\">a</span><span class=\"p\">.</span> <span class=\"err\">线程</span><span class=\"n\">A调用pthread_join</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">rval_ptr</span><span class=\"p\">)</span><span class=\"err\">，被</span><span class=\"n\">Block</span><span class=\"err\">，进入</span><span class=\"n\">Detached状态</span><span class=\"err\">（如果已经进入</span><span class=\"n\">Detached状态</span><span class=\"err\">，则</span><span class=\"n\">pthread_join函数返回EINVAL</span><span class=\"err\">）。如果对</span><span class=\"n\">B的结束代码不感兴趣</span><span class=\"err\">，</span><span class=\"n\">rval_ptr可以传NULL</span><span class=\"err\">。</span>\n<span class=\"n\">b</span><span class=\"p\">.</span> <span class=\"err\">线程</span><span class=\"n\">B调用pthread_exit</span><span class=\"p\">(</span><span class=\"n\">rval_ptr</span><span class=\"p\">)</span><span class=\"err\">，退出线程</span><span class=\"n\">B</span><span class=\"err\">，结束代码为</span><span class=\"n\">rval_ptr</span><span class=\"err\">。注意</span><span class=\"n\">rval_ptr指向的内存的生命周期</span><span class=\"err\">，不应该指向</span><span class=\"n\">B的Stack中的数据</span><span class=\"err\">。</span>\n<span class=\"n\">c</span><span class=\"p\">.</span> <span class=\"err\">线程</span><span class=\"n\">A恢复运行</span><span class=\"err\">，</span><span class=\"n\">pthread_join函数调用结束</span><span class=\"err\">，线程</span><span class=\"n\">B的结束代码被保存到rval_ptr参数中去</span><span class=\"err\">。如果线程</span><span class=\"n\">B被Cancel</span><span class=\"err\">，那么</span><span class=\"n\">rval_ptr的值就是PTHREAD_CANCELLED</span><span class=\"err\">。</span>\n</code></pre></div><h2><b>线程同步取消</b></h2><p>同步取消的意思就是说，在收到一个取消请求之后，它会继续执行下去，直到找到下一个取消点进行退出。<br/>那么什么是取消点呢？：<br/>取消点是在程序在运行的时候检测是否收到取消请求，是否允许允许操作执行的点。下面的POSIX线程函数就是取消点：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">pthread_join</span><span class=\"p\">()</span>\n<span class=\"n\">thread_cond_wait</span><span class=\"p\">()</span>\n<span class=\"n\">pthread_cond_timedwait</span><span class=\"p\">()</span>\n<span class=\"n\">pthread_testcancel</span><span class=\"p\">()</span>\n<span class=\"n\">sem_wait</span><span class=\"p\">()</span>\n<span class=\"n\">sigwait</span><span class=\"p\">()</span>\n</code></pre></div><h2><b>多线程下的文件读写操作</b></h2><p>pread, pread64 -- atomic position and read</p><div class=\"highlight\"><pre><code class=\"language-cpp\">   <span class=\"cp\">#include</span> <span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>   <span class=\"n\">ssize_t</span> <span class=\"nf\">pread</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">nbytes</span><span class=\"p\">,</span> <span class=\"n\">off_t</span> <span class=\"n\">offset</span><span class=\"p\">);</span>\n   <span class=\"n\">ssize_t</span> <span class=\"nf\">pread64</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">buf</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"n\">nbytes</span><span class=\"p\">,</span> <span class=\"n\">off64_t</span> <span class=\"n\">offset</span><span class=\"p\">);</span>\n</code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//uw714doc.sco.com/en/man/html.2/pread.2.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">uw714doc.sco.com/en/man</span><span class=\"invisible\">/html.2/pread.2.html</span><span class=\"ellipsis\"></span></a></p><h2><b>线程同步</b></h2><p>线程进程同步的机制：Mutex（互斥量）、信号量、原子操作、Spin lock（自旋锁）。</p><h2><b>Mutex（互斥量）</b></h2><p>典型应用：基于Read/Write lock（读写锁）的自动锁</p><h2><b>可重入锁(递归锁)和非可重入锁</b></h2><p>递归互斥锁（或可重入互斥锁）：同一个线程可以对递归互斥锁重复递归地加锁，即允许同一线程在互斥锁解锁之前对该互斥锁进行多次加锁，但实际上是增加加锁的引用计数，因此相比非递归互斥锁多了一个计数器。在加锁次数和解锁次数不同的情况下，线程不会释放锁。同时不用考虑自我死锁问题，但有可能造成外层和内存函数同时拿到互斥锁的情况，若改变的是同一对象，其结果不可知<br/>非递归互斥锁（或非可重入互斥锁）：同一个线程不可以对非递归互斥锁重复递归地加锁，否则（当内存和外层函数同时拿到同一把锁时）会立即自我死锁.</p><p>Linux下的<code>pthread_mutex_t</code>锁默认是非递归的。可以显示的设置<code>PTHREAD_MUTEX_RECURSIVE</code>属性，将<code>pthread_mutex_t</code>设为递归锁</p><h2><b>锁竞争处理</b></h2><p>一个线程尝试对一个共享资源加锁但是没有成功，说明互斥锁已经被锁住。这个未获取锁的线程将休眠知道持有锁的线程释放了互斥锁。</p><h2><b>线程休眠方式解决锁竞争可能存在的问题</b></h2><p>由于线程休眠和唤醒的需要消耗大量CPU指令，因此对于锁占用时间很短(小于线程休眠和唤醒的时间消耗)的场景线程频繁的休眠和唤醒会带来额外的CPU消耗。但反之于锁占用时间较长此种方式对CPU反而消耗小。                                             </p><h2><b>信号量</b></h2><p>线程间同步的首选</p><h2><b>原子操作</b></h2><p>功能简单，适用于int long 型自增变化。<br/><code>__sync_fetch_and_add</code>系列命令</p><h2><b>Spin lock（自旋锁）</b></h2><p>一个线程尝试对一个共享资源加锁但是没有成功，说明自旋锁锁已经被锁住。这个未获取锁的线程将以轮询的方式持续进行锁请求，直到加锁成功。</p><h2><b>轮询请求方式解决锁竞争可能存在的问题</b></h2><p>由于线程休眠和唤醒的需要消耗大量CPU指令，因此对于锁占用时间很短(小于线程休眠和唤醒的时间消耗)的场景此种方式对CPU反而消耗小。但反之锁占用时间较长轮询尝试加锁会消耗CPU.<br/><code>尤其注意：在单核环境不要使用自旋锁</code></p><h2><b>多线程互斥和同步总结</b></h2><p>实际上， 绝大部分现代的操作系统采用的是混合型互斥锁(hybrid mutexes)和混合型自旋锁(hybrid spinlocks)。 它们是什么意思呢？</p><ul><li>混合型互斥锁<br/>在多核系统上起初表现的像自旋锁一样， 如果一个线程不能获取互斥锁， 它不会马上被切换为休眠状态， 因为互斥量可能很快就被解锁， 所以这种机制会表现的像自旋锁一样。 只有在一段时间以后(或者尝试一定次数，或者其他指标)还不能获取锁， 它就会被切换为休眠状态。 如果运行在单核/单CPU上， 这种机制将不会自旋(就像上面解释的， 这种情况自旋没有什么好处)。</li><li>混合型自旋锁<br/>起初表现的和正常自旋锁一样， 但是为了避免浪费大量的CPU时间， 会有一个折中的策略。 这种机制不会把线程切换到休眠态(既然想要使用自旋锁， 那么你并不希望这种情况发生)， 也许会决定放弃这个线程的执行(马上放弃或者等一段时间)并允许其他线程运行， 这样提高了自旋锁被解锁的可能性(大多数情况， 线程之间的切换操作比使线程休眠而后唤醒它要昂贵， 尽管那不是很明显</li></ul><h2><b>线程上下文</b></h2><h2><b>概念</b></h2><p>线程上下文包括为使线程在线程的宿主进程地址空间中无缝地继续执行所需的所有信息，包括线程的CPU 寄存器组和堆栈。<br/>对多线程的调度，支持抢占式多任务处理的操作系统一般会采用时间片轮转调度的方案。</p><h2><b>实现方式</b></h2><p>系统会为每个线程分配时间片(Time slice)，其特点为线程越多每个线程被分配的时间片越短。<br/>当前执行的软件线程在其时间片结束时被挂起，而另一个软件线程继续运行。当系统从一个软件线程切换到另一个软件线程时，它将保存被抢占的软件线程的线程上下文，并重新加载线程队列中下一个软件线程的已保存线程上下文。</p><h2><b>效果</b></h2><p>时间片轮转机制保证所有线程可以较公平的调度，并有效防止线程出现出现饥饿（starvation）的情况。</p><h2><b>缺点</b></h2><p>时间片轮转也会导致频繁的线程切换，带来额外的开销即线程间切换时保存和恢复进程寄存器的开销。<br/>当存在少量线程的时候，进程调度程序会给每一个线程分配足够长的时间片，相比较之下，保存和恢复线程寄存器的开销变得不是很显著。但是随着线程数目的增加，线程调度程序分给每个线程的时间片也会相应减少，而保存和恢复线程寄存器的开销不变，这样，在每个时间片当中，系统将更多的时间用于保存和恢复线程寄存器，就会显著地降低系统性能。</p><h2><b>多线程性能调优</b></h2><p>多线程调优最直接的方法是降低锁竞争，这也是多线程程序的性能瓶颈之一。<br/>从阿姆达尔法则我们可以看到，并行程序的性能很大程度上被只能串行执行的部分给限制住了，而由锁竞争引起的串行执行正是造成串行性能瓶颈的主要原因之一</p><h2><b>尽量避免使用锁</b></h2><p>原则：能不使用锁就不使用锁。<br/>通过复制资源副本的方式避免锁的使用。比如双缓冲队列。</p><h2><b>读写锁</b></h2><p>读写锁的特点是读并发、写独占。最佳的应用场景：读多写少且写操作持续时间短<br/>读锁、写锁各有独立的等待队列。<br/>读等待队列：</p><ul><li>写锁被占用时其他线程请求读锁--将请求读锁的线程放入读等待队列。<br/>写等待队列：</li><li>写锁被占用时其他线程请求写锁--将请求写锁的线程放入写等待队列。</li><li>读锁被占用时其他线程请求写锁--将请求写锁的线程放入写等待队列。<br/>总结：写读竞争入读队列；写写竞争入写队列；读写竞争入写队列。<br/>总的执行特点：读写锁交替执行。</li><li>写锁解锁<br/>  (1)读等待队列中所有线程被赋予读锁，读并发<br/>  (2)读锁释放完毕，则执行写等待队列中请求写锁线程</li><li>读锁解锁   (1)写队列中下一个请求写锁线程获得写锁   (2)写锁释放完毕，则执行读等待队列中请求读锁线程 实例：读写锁配合使用</li><ul><li>在用户管理超时检测中，`先使用`RLock`获得待删除车机map,再用`WLock`处理此map可有效降低锁粒度同时减少锁竞争从而提高性能`-Pcc&amp;DevRunAreaMgr.cpp</li><li>大并发用户时间戳更新，设置用户时间戳更新时间间隔。要更新用户时间戳前采用`RLock`保护查询用户当前时间戳从而验证此用户时间戳是否需要更新。对于需要更新的用户采用`WLock`保护进行时间戳更新操作。<br/>从而效降低锁粒度同时减少锁竞争。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>减少锁保护时间</b></h2><p>尽量减少加锁持续时间，将不必要的操作挪移到锁保护外面执行。</p><h2><b>记住原子操作效率更高</b></h2><p>__sync_fetch_and_add`系列命令可以实现原子操作，其效率高于互斥锁。</p><h2><b>降低锁粒度</b></h2><p>使用分段所比如Msg hashtable实现。</p><h2><b>锁粒度级别</b></h2><p>过细粒度将增加对锁的请求和释放的频率，因而会增加额外的指令。您必须在过细和过粗粒度之间找到平衡  </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8f5a3cd12b157b1248d92adae449b70b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic4.zhimg.com/v2-8f5a3cd12b157b1248d92adae449b70b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic4.zhimg.com/v2-8f5a3cd12b157b1248d92adae449b70b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8f5a3cd12b157b1248d92adae449b70b_b.jpg\"/></figure><p>垂直轴或y 轴表示吞吐量。水平轴或x 轴表示粒度  <br/>参考：Intel 多核多线程技术--<a href=\"https://link.zhihu.com/?target=https%3A//software.intel.com/zh-cn/articles/book-Multicore-Multithread-Technology\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">software.intel.com/zh-c</span><span class=\"invisible\">n/articles/book-Multicore-Multithread-Technology</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619468"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52844382", 
            "userName": "Markman101", 
            "userLink": "https://www.zhihu.com/people/5b1155030a0df74d676cf1e5ad98eb8c", 
            "upvote": 7, 
            "title": "C++网络库开发", 
            "content": "<p></p><h2><b>C++网络库开发</b></h2><h2><b>要点1 socket基本操作</b></h2><h2><b>I/O复用(multiplexing)</b></h2><p>指的是linux/unix/freebsd等系统下，调用select/poll/epoll/kqueue等函数来告知操作系统自己关心的描述符，让操作系统在这些描述符可读可写或异常时通知你。<br/>I/O multiplexing means what it says - allowing the programmer to examine and block on multiple I/O streams (or other &#34;synchronizing&#34; events), being notified whenever any one of the streams is active so that it can process data on that stream.</p><h2><b>epoll</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"> <span class=\"cp\">#include</span> <span class=\"cpf\">&lt;sys/epoll.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"mi\">1</span><span class=\"err\">、</span> <span class=\"kt\">int</span> <span class=\"n\">epoll_create</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">size</span><span class=\"p\">);</span>\n    <span class=\"err\">描述：</span><span class=\"n\">epoll_create</span><span class=\"p\">()</span> <span class=\"err\">返回一个引用创建</span> <span class=\"n\">epoll</span> <span class=\"err\">实例的文件描述符</span>\n    <span class=\"err\">使用完毕调用</span> <span class=\"n\">close函数关闭epoll句柄</span><span class=\"err\">。</span>\n\n<span class=\"mi\">2</span><span class=\"err\">、</span> <span class=\"kt\">int</span> <span class=\"n\">epoll_ctl</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">op</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span><span class=\"n\">event</span><span class=\"p\">);</span>\n    <span class=\"err\">描述：</span> <span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"o\">-</span><span class=\"n\">epoll句柄</span>\n          <span class=\"kt\">int</span> <span class=\"n\">op</span> <span class=\"err\">对</span><span class=\"n\">fd的操作类型</span>\n                <span class=\"n\">EPOLL_CTL_ADD</span> <span class=\"err\">将</span><span class=\"n\">fd注册到epoll上</span><span class=\"err\">，一旦</span><span class=\"n\">fd对应event事件发生则epoll发出通知</span>\n                <span class=\"n\">EPOLL_CTL_MOD</span> <span class=\"err\">修改</span><span class=\"n\">fd对应的event事件</span>\n                <span class=\"n\">EPOLL_CTL_DEL</span> <span class=\"err\">将</span><span class=\"n\">fd从epoll上清除</span>\n<span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"err\">定义如下：</span>\n<span class=\"k\">typedef</span> <span class=\"k\">union</span> <span class=\"n\">epoll_data</span> <span class=\"p\">{</span>\n   <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n   <span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">;</span>\n   <span class=\"n\">uint32_t</span> <span class=\"n\">u32</span><span class=\"p\">;</span>\n   <span class=\"n\">uint64_t</span> <span class=\"n\">u64</span><span class=\"p\">;</span>\n<span class=\"p\">}</span> <span class=\"n\">epoll_data_t</span><span class=\"p\">;</span>\n<span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"p\">{</span>\n   <span class=\"n\">uint32_t</span> <span class=\"n\">events</span><span class=\"p\">;</span> <span class=\"cm\">/* Epoll 事件 */</span>\n   <span class=\"n\">epoll_data_t</span> <span class=\"n\">data</span><span class=\"p\">;</span> <span class=\"cm\">/* 用户数据变量 */</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>结构体epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件. <br/>其中epoll_data 联合体用来保存触发事件的某个文件描述符相关的数据.<br/>在使用中通常的做法是将fd赋值到event结构中epoll_data fd成员。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"> <span class=\"mi\">3</span><span class=\"err\">、</span><span class=\"kt\">int</span> <span class=\"n\">epoll_wait</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span><span class=\"n\">events</span><span class=\"p\">,</span><span class=\"kt\">int</span> <span class=\"n\">maxevents</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">timeout</span><span class=\"p\">)</span>\n    <span class=\"err\">当注册到</span><span class=\"n\">epoll上的fd对应event事件发生时通过此函数返回通知</span><span class=\"err\">。</span>\n    <span class=\"err\">描述：</span><span class=\"kt\">int</span> <span class=\"n\">epfd</span><span class=\"err\">，</span><span class=\"n\">epoll句柄</span>\n         <span class=\"k\">struct</span> <span class=\"n\">epoll_event</span> <span class=\"o\">*</span><span class=\"n\">events</span><span class=\"p\">,</span> <span class=\"err\">接收事件通知的</span><span class=\"n\">event缓冲区</span>\n         <span class=\"n\">maxevents</span><span class=\"p\">,</span> <span class=\"n\">event缓冲区包含的event事件结构体个数</span>\n         <span class=\"n\">timeout</span><span class=\"p\">,</span><span class=\"err\">单位为</span><span class=\"n\">millisecond</span><span class=\"p\">(</span><span class=\"err\">毫秒</span><span class=\"p\">),</span><span class=\"err\">等待</span><span class=\"n\">event事件发生超时时间</span><span class=\"err\">，超时后</span><span class=\"n\">epoll_wait返回0</span><span class=\"err\">。生成环境</span><span class=\"n\">timeout设置为1ms</span><span class=\"p\">.</span>\n    <span class=\"n\">epoll_wait返回有3种情况</span><span class=\"err\">：</span>\n    <span class=\"mi\">1</span> <span class=\"err\">当发生事件个数达到</span><span class=\"n\">maxevents时</span><span class=\"err\">，</span><span class=\"n\">epoll_wait立即返回</span>\n    <span class=\"mi\">2</span> <span class=\"err\">当超时时，</span><span class=\"n\">epoll_wait返回</span><span class=\"err\">，如果超时时间内无事件发生则返回</span><span class=\"mi\">0</span>\n    <span class=\"mi\">3</span> <span class=\"err\">发生错误时，</span><span class=\"n\">epoll返回</span><span class=\"o\">-</span><span class=\"mf\">1.</span>\n    <span class=\"err\">在其后使用中，开发者通过返回的</span><span class=\"n\">event结构中epoll_data</span> <span class=\"n\">fd获得网络套接字进行数据的收发</span><span class=\"err\">。</span>                   \n</code></pre></div><h2><b>套接字基本操作</b></h2><p><a href=\"https://link.zhihu.com/?target=http%3A//cpp.ezbty.org/category/cpp/socket_api\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">cpp.ezbty.org/category/</span><span class=\"invisible\">cpp/socket_api</span><span class=\"ellipsis\"></span></a></p><h2><b>1、socket</b></h2><div class=\"highlight\"><pre><code class=\"language-text\">#include&lt;sys/socket.h&gt;\nint socket(int family, int type, int protocol)\n</code></pre></div><blockquote> 返回：非负描述字──成功， -1──出错<br/>参数：int family,网络层协议AF_INET──指定为IPv4协议，AF_INET6──指定为IPv6<br/>int type,套接口的类型，套接口可能的类型有：SOCK_STREAM、SOCK_DGRAM、SOCK_SEQPACKET、SOCK_RAW等等，它们分别表明字节流、数据报、有序分组、原始套接口<br/>int protocol,传输层协议，因为系统为每一个网络层协议和套接字类型对应一个传输层协议，因此此protocol通常为0。<br/> <b>2、bind</b><br/> </blockquote><div class=\"highlight\"><pre><code class=\"language-text\">#include&lt;sys/socket.h&gt;\nint bind(int sockfd, struct sockaddr* addr, socklen_t addrlen)\n</code></pre></div><p>返回：0──成功， -1──失败<br/>套接字只是用户程序和内核交互信息的通道，其本身并无网络地址和端口等信息。在进行网络通信的时候，必须把一个套接字与一个地址相关联，这个过程就是地址绑定的过程。许多时候内核会我们自动绑定一个地址。自动绑定的地址和端口每次重启后是变化的。在服务端开发中，server端必须网络地址和端口必须是固定所有调用bind把用户进程绑定一个具体的地址和端口。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"err\">地址结构：</span>\n<span class=\"n\">include</span> <span class=\"o\">&lt;</span><span class=\"n\">netinet</span><span class=\"o\">/</span><span class=\"n\">in</span><span class=\"p\">.</span><span class=\"n\">h</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">sockaddr</span> <span class=\"p\">{</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">short</span>    <span class=\"n\">sa_family</span><span class=\"p\">;</span>    <span class=\"c1\">// 2 bytes address family, AF_xxx\n</span><span class=\"c1\"></span>    <span class=\"kt\">char</span>              <span class=\"n\">sa_data</span><span class=\"p\">[</span><span class=\"mi\">14</span><span class=\"p\">];</span>     <span class=\"c1\">// 14 bytes of protocol address\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"c1\">// IPv4 AF_INET sockets:\n</span><span class=\"c1\"></span><span class=\"k\">struct</span> <span class=\"n\">sockaddr_in</span> <span class=\"p\">{</span>\n    <span class=\"kt\">short</span>            <span class=\"n\">sin_family</span><span class=\"p\">;</span>       <span class=\"c1\">// 2 bytes e.g. AF_INET, AF_INET6\n</span><span class=\"c1\"></span>    <span class=\"kt\">unsigned</span> <span class=\"kt\">short</span>   <span class=\"n\">sin_port</span><span class=\"p\">;</span>    <span class=\"c1\">// 2 bytes e.g. htons(3490)\n</span><span class=\"c1\"></span>    <span class=\"k\">struct</span> <span class=\"n\">in_addr</span>   <span class=\"n\">sin_addr</span><span class=\"p\">;</span>     <span class=\"c1\">// 4 bytes see struct in_addr, below\n</span><span class=\"c1\"></span>    <span class=\"kt\">char</span>             <span class=\"n\">sin_zero</span><span class=\"p\">[</span><span class=\"mi\">8</span><span class=\"p\">];</span>     <span class=\"c1\">// 8 bytes zero this if you want to\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"k\">struct</span> <span class=\"n\">in_addr</span> <span class=\"p\">{</span>\n    <span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"n\">s_addr</span><span class=\"p\">;</span>          <span class=\"c1\">// 4 bytes load with inet_pton()\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"n\">IP转换函数</span><span class=\"err\">：</span>\n <span class=\"cp\">#include</span> <span class=\"cpf\">&lt;arpa/inet.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span> <span class=\"n\">in_addr_t</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span> <span class=\"n\">strptr</span><span class=\"p\">);</span><span class=\"c1\">//点分字符串IP地址转换为in_addr_t结构(long型)\n</span><span class=\"c1\"></span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"nf\">inet_ntoa</span><span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">in_addr</span> <span class=\"n\">in</span><span class=\"p\">);</span><span class=\"c1\">//将in_addr结构(long型)转换为点分字符串IP地址\n</span><span class=\"c1\"></span><span class=\"err\">实例：</span>\n  <span class=\"k\">struct</span> <span class=\"n\">sockaddr_in</span> <span class=\"n\">saddr</span><span class=\"p\">;</span>\n  <span class=\"n\">memset</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">saddr</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">saddr</span><span class=\"p\">));</span>\n  <span class=\"n\">saddr</span><span class=\"p\">.</span><span class=\"n\">sin_family</span> <span class=\"o\">=</span> <span class=\"n\">AF_INET</span><span class=\"p\">;</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span> <span class=\"n\">pIp</span> <span class=\"o\">==</span> <span class=\"nb\">NULL</span> <span class=\"o\">||</span> <span class=\"o\">*</span><span class=\"n\">pIp</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span>\n <span class=\"n\">saddr</span><span class=\"p\">.</span><span class=\"n\">sin_addr</span><span class=\"p\">.</span><span class=\"n\">s_addr</span> <span class=\"o\">=</span> <span class=\"n\">INADDR_ANY</span> <span class=\"p\">;</span>\n  <span class=\"k\">else</span>\n <span class=\"n\">saddr</span><span class=\"p\">.</span><span class=\"n\">sin_addr</span><span class=\"p\">.</span><span class=\"n\">s_addr</span> <span class=\"o\">=</span> <span class=\"n\">inet_addr</span><span class=\"p\">(</span><span class=\"n\">pIp</span><span class=\"p\">);</span>\n  <span class=\"n\">saddr</span><span class=\"p\">.</span><span class=\"n\">sin_port</span> <span class=\"o\">=</span> <span class=\"n\">htons</span><span class=\"p\">((</span><span class=\"n\">u_short</span><span class=\"p\">)</span> <span class=\"n\">port</span><span class=\"p\">);</span>\n  <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">bind</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">sockaddr</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"n\">saddr</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">saddr</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>3、listen</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span><span class=\"cpf\">&lt;sys/socket.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"n\">listen</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">backlog</span><span class=\"p\">)</span>\n</code></pre></div><p>返回：0──成功， -1──失败<br/>参数：int backlog，连接等待队列大小。生产环境backlog设置为10.<br/>系统默认一个套接字是主动连接的,listen函数使用主动连接套接口变为被连接套接口，使得一个进程可以接受其它进程的请求，从而成为一个服务器进程.</p><h2><b>4、accept</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span><span class=\"cpf\">&lt;sys/socket.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"n\">accept</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"k\">struct</span> <span class=\"n\">sockaddr</span><span class=\"o\">*</span> <span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"n\">socklen_t</span><span class=\"o\">*</span> <span class=\"n\">len</span><span class=\"p\">)</span>\n</code></pre></div><p>返回：非负描述字——成功， -1——失败<br/>通过输出参数sockaddr* addr获得接入端网络地址和端口。<br/>实例代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">sockaddr_in</span> <span class=\"n\">addr</span><span class=\"p\">;</span>\n  <span class=\"n\">addrlen</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">);</span>\n  <span class=\"kt\">int</span> <span class=\"n\">nRet</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"o\">::</span><span class=\"n\">accept</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"k\">struct</span> <span class=\"n\">sockaddr</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"n\">addr</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">addrlen</span><span class=\"p\">);</span>\n  <span class=\"n\">ip</span> <span class=\"o\">=</span> <span class=\"n\">inet_ntoa</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">.</span><span class=\"n\">sin_addr</span><span class=\"p\">);</span>\n  <span class=\"n\">port</span> <span class=\"o\">=</span> <span class=\"n\">ntohs</span><span class=\"p\">(</span><span class=\"n\">addr</span><span class=\"p\">.</span><span class=\"n\">sin_port</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>5、connect</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span><span class=\"cpf\">&lt;sys/socket.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"n\">connect</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"k\">struct</span> <span class=\"n\">sockaddr</span><span class=\"o\">*</span> <span class=\"n\">server_addr</span><span class=\"p\">,</span> <span class=\"n\">socklen_t</span> <span class=\"n\">addrlen</span><span class=\"p\">)</span>\n</code></pre></div><p>返回：0──成功， -1──失败。<br/>参数server_addr指定数据发送的目的地，也就是服务器端的地址</p><h2><b>套接字属性设置</b></h2><p>套接字属性设置代码需在Listen前。<br/>  注明：使用<code>getsockopt</code>查看套接字属性时，参数5按如下方式初始化:</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">data</span> <span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> \n<span class=\"n\">socklen_t</span> <span class=\"n\">len</span> <span class=\"o\">=</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">);</span>\n<span class=\"n\">getsockopt</span><span class=\"p\">(</span><span class=\"n\">listenfd</span><span class=\"p\">,</span><span class=\"n\">SOL_SOCKET</span><span class=\"p\">,</span><span class=\"n\">SO_SNDBUF</span><span class=\"p\">,</span><span class=\"o\">&amp;</span><span class=\"n\">data</span><span class=\"p\">,</span><span class=\"o\">&amp;</span><span class=\"n\">len</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>地址复用</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">sflag</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">(</span><span class=\"n\">setsockopt</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">SOL_SOCKET</span><span class=\"p\">,</span> <span class=\"n\">SO_REUSEADDR</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"n\">sflag</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">sflag</span><span class=\"p\">))</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>非阻塞</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">fcntl</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">F_SETFL</span><span class=\"p\">,</span> <span class=\"n\">O_NONBLOCK</span><span class=\"p\">)</span>\n</code></pre></div><h2><b>linger</b></h2><p>SO_LINGER选项用来改变此缺省设置。使用如下结构：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">linger</span> <span class=\"p\">{</span>\n     <span class=\"kt\">int</span> <span class=\"n\">l_onoff</span><span class=\"p\">;</span> <span class=\"cm\">/* 0 = off, nozero = on */</span>\n     <span class=\"kt\">int</span> <span class=\"n\">l_linger</span><span class=\"p\">;</span> <span class=\"cm\">/* linger time */</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>有下列三种情况：<br/>1、设置 l_onoff为0，则该选项关闭，l_linger的值被忽略，等于内核缺省情况，close调用会立即返回给调用者，如果可能将会传输任何未发送的数据；<br/>2、设置 l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST给对方，而不是通常的四分组终止序列(FIN)，这避免了TIME_WAIT状态；<br/>3、设置 l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完成。<br/>在实际使用中采用第二种情况：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">struct</span> <span class=\"n\">linger</span> <span class=\"n\">ld</span> <span class=\"p\">;</span>\n<span class=\"n\">ld</span><span class=\"p\">.</span><span class=\"n\">l_onoff</span>  <span class=\"o\">=</span> <span class=\"mi\">1</span> <span class=\"p\">;</span>\n<span class=\"n\">ld</span><span class=\"p\">.</span><span class=\"n\">l_linger</span> <span class=\"o\">=</span> <span class=\"mi\">0</span> <span class=\"p\">;</span>\n<span class=\"n\">setsockopt</span><span class=\"p\">(</span> <span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">SOL_SOCKET</span> <span class=\"p\">,</span> <span class=\"n\">SO_LINGER</span> <span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"n\">ld</span> <span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ld</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span> <span class=\"p\">;</span>\n</code></pre></div><p>参考：<a href=\"https://link.zhihu.com/?target=http%3A//stackoverflow.com/questions/3757289/tcp-option-so-linger-zero-when-its-required\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">When to use SO_LINGER with timeout 0</a></p><h2><b>发送缓冲区</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"p\">(</span> <span class=\"n\">setsockopt</span><span class=\"p\">(</span> <span class=\"n\">fd</span> <span class=\"p\">,</span> <span class=\"n\">SOL_SOCKET</span><span class=\"p\">,</span> <span class=\"n\">SO_SNDBUF</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span><span class=\"n\">max</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span>  <span class=\"p\">)</span><span class=\"c1\">//buf单位为byte,生产环境为640000byte\n</span></code></pre></div><ul><li>经过试验发现(Centos 6.5-b4bit)接收缓冲区大小如不采用setsockopt方式设置，会使用内核参数<code>/proc/sys/net/ipv4/tcp_wmem</code>:<br/>使用<code>16380-tcp_wmem <a href=\"https://link.zhihu.com/?target=http%3A//i.imgur.com/4JYDCgo.png\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1</a></code></li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"err\">$</span> <span class=\"n\">cat</span> <span class=\"o\">/</span><span class=\"n\">proc</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">/</span><span class=\"n\">net</span><span class=\"o\">/</span><span class=\"n\">ipv4</span><span class=\"o\">/</span><span class=\"n\">tcp_wmem</span>\n<span class=\"mi\">4096</span>       <span class=\"mi\">16384</span>    <span class=\"mi\">4194304</span>\n<span class=\"err\">默认值为</span><span class=\"mi\">16384</span> <span class=\"n\">byte</span> <span class=\"err\">≈</span> <span class=\"mi\">16</span><span class=\"n\">K</span><span class=\"err\">，最小为</span><span class=\"mi\">4096</span> <span class=\"n\">byte</span><span class=\"o\">=</span><span class=\"mi\">4</span><span class=\"n\">K</span><span class=\"err\">，最大值为</span><span class=\"mi\">4194</span><span class=\"n\">K</span>\n</code></pre></div><ul><li>当使用setsockopt设置接收缓冲区大小大于<code>/proc/sys/net/core/wmem_max</code>,则使用<code>/proc/sys/net/core/wmem_max</code>值:<br/>/proc/sys/net/core/wmem_max如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"err\">$</span> <span class=\"n\">cat</span>  <span class=\"o\">/</span><span class=\"n\">proc</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">/</span><span class=\"n\">net</span><span class=\"o\">/</span><span class=\"n\">core</span><span class=\"o\">/</span><span class=\"n\">wmem_max</span>\n     <span class=\"mi\">124928</span>\n</code></pre></div><ul><li>实际接收缓冲区值与设置值的相等。</li></ul><h2><b>接收缓冲区</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"p\">(</span><span class=\"n\">setsockopt</span><span class=\"p\">(</span> <span class=\"n\">fd</span> <span class=\"p\">,</span> <span class=\"n\">SOL_SOCKET</span><span class=\"p\">,</span> <span class=\"n\">SO_RCVBUF</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"o\">&amp;</span><span class=\"n\">max</span> <span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">)</span>  <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"p\">)</span><span class=\"c1\">//buf单位为byte,生产环境为640000byte\n</span></code></pre></div><ul><li>经过试验发现(Centos 6.5-b4bit)接收缓冲区大小如不采用setsockopt方式设置，会使用内核参数<code>/proc/sys/net/ipv4/tcp_rmem</code>:<br/>使用<code>87380 -tcp_rmem<a href=\"https://link.zhihu.com/?target=http%3A//i.imgur.com/4JYDCgo.png\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">1</a></code></li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"err\">$</span> <span class=\"n\">cat</span> <span class=\"o\">/</span><span class=\"n\">proc</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">/</span><span class=\"n\">net</span><span class=\"o\">/</span><span class=\"n\">ipv4</span><span class=\"o\">/</span><span class=\"n\">tcp_rmem</span>\n   <span class=\"mi\">4096</span>      <span class=\"mi\">87380</span> <span class=\"mi\">4194304</span>\n</code></pre></div><ul><li>当使用setsockopt设置接收缓冲区大小大于<code>/proc/sys/net/core/rmem_max</code>,则使用<code>/proc/sys/net/core/rmem_max</code>值:<br/>/proc/sys/net/core/rmem_max如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"err\">$</span> <span class=\"n\">cat</span>  <span class=\"o\">/</span><span class=\"n\">proc</span><span class=\"o\">/</span><span class=\"n\">sys</span><span class=\"o\">/</span><span class=\"n\">net</span><span class=\"o\">/</span><span class=\"n\">core</span><span class=\"o\">/</span><span class=\"n\">rmem_max</span>\n    <span class=\"mi\">124928</span>\n</code></pre></div><ul><li>实际接收缓冲区值为设置值的2倍。</li></ul><p><b>注明</b>:<br/>accept返回的对端socket继承监听socket的发送缓存、接收缓存选项</p><h2><b>Nagle算法</b></h2><p>TCP/IP协议中，无论发送多少数据，总是要在数据前面加上协议头，同时，对方接收到数据，也需要发送ACK表示确认。为了尽可能的利用网络带宽，TCP总是希望尽可能的发送足够大的数据。（一个连接会设置MSS参数，因此，TCP/IP希望每次都能够以MSS尺寸的数据块来发送数据）。<code>Nagle</code>算法就是为了避免发送大量的小包，防止小包泛滥于网络。<br/> <code>Nagle</code>算法的基本定义是<b>任意时刻，最多只能有一个未被确认的小段</b>。 所谓“小段”，指的是小于MSS尺寸的数据块，所谓“未被确认”，是指一个数据块发送出去后，没有收到对方发送的ACK确认该数据已收到。<br/> <code>Nagle</code>算法的规则（可参考tcp_output.c文件里tcp_nagle_check函数注释）：<br/>（1）如果包长度达到MSS，则允许发送；<br/>（2）如果该包含有FIN，则允许发送；<br/>（3）设置了TCP_NODELAY选项(禁用nagle算法)，则允许发送；<br/>（4）未设置TCP_CORK选项时，若所有发出去的小数据包（包长度小于MSS）均被确认，则允许发送；<br/>      TCP_NODELAY和TCP_CORK都是禁用Nagle算法，但两者不能同时设置。<br/>（5）上述条件都未满足，但发生了超时（一般为200ms），则立即发送。</p><ul><li>1 例子<br/>比如之前的blog中的实验，一开始client端调用socket的write操作将一个int型数据（称为A块）写入到网络中，由于此时连接是空闲的（也就是说还没有未被确认的小段），因此这个int型数据会被马上发送到server端，接着，client端又调用write操作写入‘\\r\\n’（简称B块），这个时候，A块的ACK没有返回，所以可以认为已经存在了一个未被确认的小段，所以B块没有立即被发送，一直等待A块的ACK收到（大概40ms之后），B块才被发送。整个过程如图所示：<br/>这里还隐藏了一个问题，就是A块数据的ACK为什么40ms之后才收到？这是因为TCP/IP中不仅仅有nagle算法，还有一个<code>TCP确认延迟机制</code> 。当Server端收到数据之后，它并不会马上向client端发送ACK，而是会将ACK的发送延迟一段时间（假设为t），它希望在t时间内server端会向client端发送应答数据，这样ACK就能够和应答数据一起发送，就像是应答数据捎带着ACK过去。在我之前的时间中，t大概就是40ms。这就解释了为什么&#39;\\r\\n&#39;（B块）总是在A块之后40ms才发出。<br/>　　当然，TCP确认延迟40ms并不是一直不变的，TCP连接的延迟确认时间一般初始化为最小值40ms，随后根据连接的重传超时时间（RTO）、上次收到数据包与本次接收数据包的时间间隔等参数进行不断调整。另外可以通过设置<code>TCP_QUICKACK</code>选项来取消确认延迟。</li><li>2 结论<br/>默认情况下，发送数据采用Negale 算法。这样虽然提高了网络吞吐量，但是实时性却降低了，在一些交互性很强的应用程序来说是不允许的，使用TCP_NODELAY选项可以禁止Negale 算法。<br/> 此时，应用程序向内核递交的每个数据包都会立即发送出去。需要注意的是，虽然禁止了Negale 算法，但网络的传输仍然受到TCP确认延迟机制的影响。<br/> <code>Nagle</code> 算法适用于发送方需要发送大批量数据, 并且接收方会及时作出回应的场合, 这种算法通过减少传输数据的次数来提高通信效率。<br/>如果发送方持续地发送小批量的数据, 并且接收方不一定会立即发送响应数据, 那么Nagle算法会使发送方运行很慢。</li><li>3 场景分析<br/> Nagle算法会引发几种HTTP的性能问题。比如小的HTTP报文可能无法填满一个分组，所以要缓存等待起来，要么就等待确认分组的抵达(确认分组的时延大概在100-200毫秒)。</li></ul><p>所以HTTP应用程序常常会在自己的协议栈中设置参数TCP_NODELAY，禁用Nagle算法来提高性能。</p><p>设置该选项:</p><div class=\"highlight\"><pre><code class=\"language-cpp\">   <span class=\"n\">setsockopt</span><span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">,</span><span class=\"n\">IPPRO_TCP</span><span class=\"p\">,</span><span class=\"n\">TCP_NODELAY</span><span class=\"p\">,(</span><span class=\"k\">const</span> <span class=\"kt\">char</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">&amp;</span><span class=\"n\">on</span><span class=\"p\">,</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">));</span>\n</code></pre></div><h2><b>TCP延时确认机制(Delayed Ack)</b></h2><p>有什么办法解决TCP时延确认机制？<br/>A：TCP延迟确认是由一些实现采用的技术，努力提高网络性能的传输控制协议 。从本质上讲，几个应答响应可能结合在一起，成一个响应，减少协议开销 。然而，在某些情况下，该技术可以降低应用程序的性能。TCP中，每次recv到数据后，调用一次setsockopt函数，设置TCP_QUICKACK。</p><div class=\"highlight\"><pre><code class=\"language-cpp\">   <span class=\"err\">例如</span><span class=\"o\">:</span> <span class=\"n\">setsockopt</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"n\">IPPROTO_TCP</span><span class=\"p\">,</span> <span class=\"n\">TCP_QUICKACK</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"o\">*</span><span class=\"p\">)</span><span class=\"err\">（</span><span class=\"mi\">1</span><span class=\"err\">）</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">));</span> \n</code></pre></div><p>Q：为什么TCP_QUICKACK需要在每次recv后重新设置？<br/>A：因为TCP_QUICKACK不是永久的，所以在每次recv数据后，应该重新设置。 <br/>   具体原因为：当TCP链接在要发送一个数据包时，会进行比较当前时间与最近一次接收数据包的时间间隔是否小于计算的延迟确认超时时间，是则重新进入交互数据流模式。<br/>   也可以这么理解：延迟确认机制被确认有效，会自动进入交互式。<br/>参考：<a href=\"https://link.zhihu.com/?target=http%3A//blog.csdn.net/sjin_1314/article/details/9820195\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">再探Linux下的TCP延迟确认机制--TCP_QUICKACK</a></p><h2><b>TCP(Slow start)慢启动(拥塞控制)</b></h2><p>TCP发送方使用CWND(<code>congestion window</code>)进行发送方发送流控。</p><h2><b>TIME_WAIT累积与端口耗尽</b></h2><p>主动断开连接的一方最后进入TIME_WAIT状态.<br/>TCP连接关闭时，会在内存中记录最近关闭连接的IP地址和端口号，这类信息一般只存一小段时间，比如2分钟。主要作用是避免2分钟内创建了完全一样的套接字，从而导致第一个TCP连接的分组因为延时而混入到第二个TCP连接中。</p><h2><b>基本操作问与答</b></h2><h2><b>close和shutdown区别？</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\">    <span class=\"cp\">#include</span><span class=\"cpf\">&lt;unistd.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>    <span class=\"kt\">int</span> <span class=\"n\">close</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">)</span>\n    <span class=\"err\">返回：</span><span class=\"mi\">0</span><span class=\"err\">——成功，</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"err\">——失败</span>\n    <span class=\"cp\">#include</span><span class=\"cpf\">&lt;sys/socket.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>    <span class=\"kt\">int</span> <span class=\"n\">shutdown</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">howto</span><span class=\"p\">)</span>\n<span class=\"o\">&gt;</span> <span class=\"err\">返回：</span><span class=\"mi\">0</span><span class=\"err\">——成功，</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"err\">——失败</span>\n</code></pre></div><p>其中howto值如下：<br/><code>SHUT_RD(0)</code>：关闭读，套接字不能再发出接收请求，当前套接字接收缓冲区中的数据都会被丢弃、后续接收到的数据都会被丢弃。但仍可通过此套接字发送数据，对等方不知道这个过程。<br/><code>SHUT_WR(1)</code>：关闭写，套接字不能再发出发送请求，当前套接字发送缓冲区中的数据将会被发送到对端，发送完毕后进行正常的TCP连接终止序列(即发送FIN).对接收缓冲区无影响。<br/><code>SHUT_RDWR(2)</code>：等价于<code>SHUT_RD(0)</code>+<code>SHUT_WR(1)</code><br/> 对fd调用close(),会参考引用计数，除非此fd引用计数为0，close()才会释放此fd。只有当fd的引用计数为0，close 才会发送FIN段，否则只是将引用计数减1而已。也就是说只有当所有进程（可能fork多个子进程都打开了这个套接字）都关闭了这个套接字，close 才会发送FIN 段。<br/> 从上面可以看出执行shutdown(无论1 、2 、0)后套接字仍然是有效的。<br/> 否则如果SHUT_RD(0)会关闭套接字的话，“但仍可通过此套接字发送数据”就不成立<br/> 如果 SHUT_WR(1)会关闭套接字的话，“对接收缓冲区无影响”就不成立。<br/> <code>shutdown</code>特点：<br/>  1 <code>shutdown</code> causes one side of the TCP connection to stop reading (<code>0</code>), or writing (<code>1</code>), or both (<code>2</code>)<br/>  2 <code>shutdown</code> does not release the file descriptor。<br/>  结论：shutdown与socket描述符没有关系，即使调用shutdown(fd, SHUT_RDWR)也不会关闭fd，最终还需close(fd)</p><h2><b>shutdown可否替代close?</b></h2><p>close函数会关闭套接字ID，如果有其他的进程共享着这个套接字，那么它仍然是打开的，这个连接仍然可以用来读和写，并且有时候这是非常重要的 ，特别是对于多进程并发服务器来说。所以在shutdown无法完全替代close。  <br/>在多进程并发服务器中，父子进程共享着套接字，套接字描述符引用计数记录着共享着的进程个数，当父进程或某一子进程close掉套接字时，描述符引用计数会相应的减一，当引用计数仍大于零时，这个close调用就不会引发TCP的四路握手断连过程。</p><h2><b>TCP之半关闭与CLOSE_WAIT</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>TCP正常连接断开过程：</p><p>We have two peers: A and B</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>A calls <code>close()</code></li></ol><ul><li>A sends `FIN` to B</li><li>A goes into `FIN_WAIT_1` state</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>B receives <code>FIN</code></li></ol><ul><li>B sends `ACK` to A</li><li>B goes into `CLOSE_WAIT` state</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>A receives <code>ACK</code></li></ol><ul><li>A goes into `FIN_WAIT_2` state</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>B calls <code>close()</code></li></ol><ul><li>B sends `FIN` to A</li><li>B goes into `LAST_ACK` state</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>A receives <code>FIN</code></li></ol><ul><li>A sends `ACK` to B</li><li>A goes into `TIME_WAIT` state</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>B receives <code>ACK</code></li></ol><ul><li>B goes to `CLOSED` state – i.e. is removed from the socket tables<br/>主动断开的一端最终进入TIME_WAIT状态。    </li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>(FIN_WAIT_1) A      ---FIN---&gt;       B(CLOSE_WAIT)<br/>(FIN_WAIT_2) A      &lt;--ACK---        B(CLOSE_WAIT) (TIME_WAIT)A        &lt;--FIN----       B(LAST_ACK) (TIME_WAIT)A        -----ACK-&gt;       B(CLOSED)</p><p>服务端大量出现CLOSE_WATI是因为客户端连接断开后，服务器端接收客户端发送FIN并返回ACK，但其后服务端连接并没有发送FIN.<br/> <b>没有发送FIN的原因：</b><br/>    服务端调用close(),如上此时fd只是引用计数减1，并没有真正关闭套接字并发送FIN.<br/>正确的用法为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">shutdown</span><span class=\"p\">(</span><span class=\"n\">sockfd</span><span class=\"p\">,</span> <span class=\"n\">SHUT_RDWR</span><span class=\"p\">);</span>\n<span class=\"n\">close</span><span class=\"p\">(</span><span class=\"n\">sockfd</span><span class=\"p\">);</span>\n</code></pre></div><h2><b>要点2 网络事件处理模型</b></h2><blockquote> 典型的半同步半异步模型(half-sync/half-async)。<br/> HSHA模型：<br/> 半同步-半异步模式的出现是为了给服务器的功能进行划分,尽可能将的可能阻塞的操作放在同步模块中,这样不会影响到异步模块的处理.从而实现<i>异步接收同步处理</i>，提高网络服务器性能。<br/> </blockquote><h2><b>半同步半异步模型</b></h2><p>1、异步任务层采用单线程实现，同步任务层为多个workthread从同享的message queue获取数据包。<br/> 优点：<br/>      同一个用户的数据包处理顺序与接收顺序一致<br/> 缺点：<br/>     多个workthread争抢共享的message queue带来额外的锁消耗<br/>2、每一个workthread都有一个message queue,由异步任务层决定数据包enqueue的workqueue.<br/>优点：<br/>  避免了线程池争抢共享的message queue的锁消耗。<br/>缺点:<br/> 同一接入端的数据包在不同workthread处理，有造成包接收顺序与处理顺序不一致的可能性，在一些应用场景下会产生业务问题。</p><p>Q:tcp服务端新连接通知和有事件可读Event都是EPOLLIN如何区分？<br/>A:通过event结构中epoll_data fd成员区分，新连接时对应的fd是Tcpserver的fd.<br/>  有数据时是注册到到epoll上的客户端fd。因此与Tcpserver的fd一样则是新连接，否则是客户端数据。</p><h2><b>要点3 sokcet管理</b></h2><p>socket管理是网络库编程中最容易导致崩溃的地方。同一个socket对象指针在多线程中共用，如何保证此socket对象指针在线程释放清理而不引起其他多线程访问错误是网络库设计必须考虑的问题。</p><h2><b>socket对象状态</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//socket状态定义\n</span><span class=\"c1\"></span><span class=\"cp\">#define SOCKET_CLOSE     0       </span><span class=\"c1\">// 禁用状态\n</span><span class=\"c1\"></span><span class=\"cp\">#define SOCKET_LIVE     1       </span><span class=\"c1\">// 启用状态\n</span><span class=\"c1\"></span><span class=\"cp\">#define SOCKET_WAITCLOSE 2       </span><span class=\"c1\">// SOCKET等待关闭状态\n</span><span class=\"c1\"></span><span class=\"cp\">#define SOCKET_SENDBUFFER       3 </span><span class=\"c1\">// 发送数据不出\n</span><span class=\"c1\"></span><span class=\"cp\">#define SOCKET_EWOULDBLOCK      2 </span><span class=\"c1\">// 发送缓存区满\n</span></code></pre></div><h2><b>socket对象封装</b></h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 连接对象\n</span><span class=\"c1\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">socket_t</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"n\">socket_t</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n<span class=\"n\">init</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">socket_t</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"c1\">// 连接类型\n</span><span class=\"c1\"></span><span class=\"kt\">unsigned</span> <span class=\"kt\">char</span> <span class=\"n\">_type</span> <span class=\"p\">;</span>\n<span class=\"c1\">// 网连接SOCKET\n</span><span class=\"c1\"></span><span class=\"kt\">int</span>   <span class=\"n\">_fd</span> <span class=\"p\">;</span>\n<span class=\"c1\">// 事件对象\n</span><span class=\"c1\"></span><span class=\"kt\">unsigned</span> <span class=\"kt\">int</span>   <span class=\"n\">_events</span> <span class=\"p\">;</span>\n<span class=\"c1\">// 接入IP地址\n</span><span class=\"c1\"></span><span class=\"kt\">char</span>   <span class=\"n\">_szIp</span><span class=\"p\">[</span><span class=\"mi\">32</span><span class=\"p\">];</span>  <span class=\"c1\">// 服务器的IP\n</span><span class=\"c1\">// 接入的端口\n</span><span class=\"c1\"></span><span class=\"kt\">unsigned</span> <span class=\"kt\">short</span> <span class=\"n\">_port</span> <span class=\"p\">;</span><span class=\"c1\">// 服务器的端口\n</span><span class=\"c1\">// 最后一次接收数据时间\n</span><span class=\"c1\"></span><span class=\"n\">time_t</span>    <span class=\"n\">_last</span> <span class=\"p\">;</span><span class=\"c1\">//更新时间戳\n</span><span class=\"c1\">// 连接状态\n</span><span class=\"c1\"></span><span class=\"kt\">unsigned</span> <span class=\"kt\">char</span>       <span class=\"n\">_activity</span><span class=\"p\">;</span><span class=\"c1\">//连接对象状态\n</span><span class=\"c1\">// 允许用户扩展数据指针\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"o\">*</span> <span class=\"n\">_ptr</span> <span class=\"p\">;</span><span class=\"c1\">//存放socket绑定的业务对象\n</span><span class=\"c1\">// str类型的绑定\n</span><span class=\"c1\"></span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span>         <span class=\"n\">_str_uid</span><span class=\"p\">;</span>\n<span class=\"c1\">// long long 类型的绑定\n</span><span class=\"c1\"></span><span class=\"kt\">unsigned</span> <span class=\"kt\">long</span> <span class=\"kt\">long</span>  <span class=\"n\">_uid</span><span class=\"p\">;</span>\n<span class=\"c1\">// 指向下一个数据指针\n</span><span class=\"c1\"></span><span class=\"n\">socket_t</span>     <span class=\"o\">*</span><span class=\"n\">_next</span> <span class=\"p\">;</span>\n<span class=\"c1\">// 前驱节点\n</span><span class=\"c1\"></span><span class=\"n\">socket_t</span>   <span class=\"o\">*</span><span class=\"n\">_pre</span> <span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2><b>管理方案之socket对象池</b></h2><p>为了避免上述问题，对socket采用复用策略。即建立socket对象池，socket关闭后不是释放而是push对象池,同时修改socket状态为不可用。<br/>socketMgr数据结构设计：</p><div class=\"highlight\"><pre><code class=\"language-text\">// 数据队列头\nTQueue&lt;socket_t&gt;     _queue ;\n// 在线队列管理\nstd::set&lt;socket_t*&gt;  _index ;\n// 在线队列管理\nTQueue&lt;socket_t&gt; _online ;\n// 回收队列中\nTQueue&lt;socket_t&gt; _recyle;\n// 数据同步操作锁\nshare::Mutex         _mutex ;\n// SOCK事件处理对象\nCSocketHandle     *  _eventer;\n</code></pre></div><p>在实现中启动两个独立的线程check线程和data线程。<br/> check线程定时扫描_online队列根据更新时间戳获得超时(180s)的socket对象并将所有超时的对象push到_recyle队列等待data线程回收。同时特别注意扫描超时连接的过程是读操作并不把超时的socket对象从_online中清除。<br/> 在data线程的处理函数分为两部分：<br/> 1、 处理epoll_wait传递的Event<br/> 2、 遍历_recyle对象并将其从_online中清除、加入_queue(对象池队列)。<br/>     将socket对象的fd从epoll上清除，这样在下一轮调用epoll_wait时不会再接收此fd对应的数据。<br/>     因此<b><i>_reycle队列存在的意义</i></b>是对超时的socket进行缓存，并且使对epoll_event的处理和对socket对象的回收同在data线程先后处理，防止对socket对象的回收操作和对epoll_event处理并发执行，尽可能的降低多线程访问错误。同时将socket状态置为SOCKET_CLOSE，将socket对象的fd从epoll上清除。<br/>     将<b><i>socket状态置为SOCKET_CLOSE</i></b>这点特别重要，因为通讯库采用半同步半异步实现。解包后，包会先缓存到队列层。在异常情况下可能出现处理延时，队列层出现包堆积。如果socket对象回收在前，包处理在后，在操作socket时发现此socket为不可用状态则不处理。</p><h2><b>对象池机制对业务层的影响</b></h2><p>在业务层处理时会将socket_t::_ptr用业务对象指针（pUser）赋值,同时pUser的socket_t指针也会用socket_t指针赋值。在业务处理很多时候都是通过socket_t::_ptr获得绑定的业务对象进而进行业务处理。为了防止出现业务处理错误在关闭时socket对象一定要与pUser解绑。</p><h2><b>要点4 接收缓冲区管理</b></h2><p>在ctfolib中实现为DataBuffer类。</p><h2><b>接收缓存类行为概述</b></h2><p>pbuf为buf头指针，pend为buf尾指针。<br/>pfree为buf写指针，pdata为buf读指针。<br/>写指针随着write操作向后偏移<br/>读指针随着read操作向后偏移</p><p>当前空闲内存空间长度(L_free)与要写入的数据长度(L_new_data)，当前数据长度计为L_cur_data,<br/>首次写操作时，bufsize设置为256，</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">bufsize</span><span class=\"o\">&lt;</span><span class=\"n\">L_new_data</span>\n</code></pre></div><p>则接收执行循环扩容每次循环bufsize*2直到</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">bufsize</span><span class=\"o\">&gt;</span><span class=\"n\">L_new_data</span>\n</code></pre></div><p>非首次写操作时比较L_free与L_new_data，</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">L_free</span><span class=\"o\">&lt;</span><span class=\"n\">L_new_data</span>\n</code></pre></div><p>则接收执行循环扩容每次循环bufsize*2直到</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">bufsize</span><span class=\"o\">-</span><span class=\"n\">L_cur_data</span><span class=\"o\">&gt;</span><span class=\"n\">L_new_data</span>\n</code></pre></div><h2><b>缓存处理策略</b></h2><p>1、为了防止epoll ET模式时数据丢失<br/>   在网络库读操作时采用while循环方式接收<br/>   包缓存策略如图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-22a50226d423244fd3c54eb0c3868ef3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb\" width=\"517\" data-original=\"https://pic4.zhimg.com/v2-22a50226d423244fd3c54eb0c3868ef3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;517&#39; height=&#39;377&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"517\" data-original=\"https://pic4.zhimg.com/v2-22a50226d423244fd3c54eb0c3868ef3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-22a50226d423244fd3c54eb0c3868ef3_b.jpg\"/></figure><p>解包后缓存处理策略：<br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-de248437d80ec2ffe4e42acf0670a2e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb\" width=\"804\" data-original=\"https://pic4.zhimg.com/v2-de248437d80ec2ffe4e42acf0670a2e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;804&#39; height=&#39;275&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"275\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"804\" data-original=\"https://pic4.zhimg.com/v2-de248437d80ec2ffe4e42acf0670a2e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-de248437d80ec2ffe4e42acf0670a2e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>  在步骤2 执行memmove操作将非完整数据偏移到pbuf位置等待非完整包的后续部分及新网络数据。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>要点5 协议解析器</b></h2><p>TCP分包</p><h2><b>序列化</b></h2><p>包头定义：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#define MSG_VERSION  0x0001 </span><span class=\"c1\">// 消息版本号\n</span><span class=\"c1\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">CMsgHeader</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"n\">CMsgHeader</span><span class=\"p\">(</span> <span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"n\">_ver</span> <span class=\"o\">=</span> <span class=\"n\">MSG_VERSION</span><span class=\"p\">;</span>\n<span class=\"n\">_type</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"n\">_seq</span> <span class=\"o\">=</span> <span class=\"n\">_len</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"o\">~</span><span class=\"n\">CMsgHeader</span><span class=\"p\">(</span> <span class=\"p\">){}</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"c1\">// 协议的版本号\n</span><span class=\"c1\"></span><span class=\"n\">uint16_t</span> <span class=\"n\">_ver</span><span class=\"p\">;</span>\n<span class=\"c1\">// 协议的类型\n</span><span class=\"c1\"></span><span class=\"n\">uint16_t</span> <span class=\"n\">_type</span><span class=\"p\">;</span>\n<span class=\"c1\">//　协议的序号\n</span><span class=\"c1\"></span><span class=\"n\">uint32_t</span> <span class=\"n\">_seq</span><span class=\"p\">;</span>\n<span class=\"c1\">// 数据长度\n</span><span class=\"c1\"></span><span class=\"n\">uint32_t</span> <span class=\"n\">_len</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><h2><b>解包分两步：</b></h2><p>1、在接收buf中定位包头CMsgHeader，获得_len字段<br/>      在接收buf中<b>逐字节</b>匹配包头。<br/>2、成功定位包头后根据包头中的_len字段获得包体长度进而获得完整数据包。</p><h2><b>tcp坏包的处理</b></h2><p>所谓的tcp坏包是在应用层tcp数据传输过程存在的不遵循应用层协议的数据包，如实际包体长度与包头中不同、<br/>数据包缺少包头或者包尾。<br/>    在包头定位过程中通过逐字节匹配包头的方式，可有效避免坏包造成的问题，同时也可以避免Tcp粘包。</p>", 
            "topic": [
                {
                    "tag": "网络编程", 
                    "tagLink": "https://api.zhihu.com/topics/19611616"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1059052843939590144"
}
