{
    "title": "果壳学院疯狂编程", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/gang-qin-shou-77", 
        "https://www.zhihu.com/people/feiji-81", 
        "https://www.zhihu.com/people/guo-zu-yu-70", 
        "https://www.zhihu.com/people/wang-shi-bing-bu-ru-yan-9-39", 
        "https://www.zhihu.com/people/xiao-ju-zi-31-72-71", 
        "https://www.zhihu.com/people/zjy139", 
        "https://www.zhihu.com/people/xftjywx", 
        "https://www.zhihu.com/people/cloud-ideal", 
        "https://www.zhihu.com/people/xue-gan-82", 
        "https://www.zhihu.com/people/huang-yige-15-3", 
        "https://www.zhihu.com/people/anru-chen", 
        "https://www.zhihu.com/people/liuhong-82", 
        "https://www.zhihu.com/people/zhong-ri-min-zu-chou-hen-nan-you-hao", 
        "https://www.zhihu.com/people/ya-ya-99-20-40", 
        "https://www.zhihu.com/people/zhang-zhi-chao-7-86", 
        "https://www.zhihu.com/people/xue-xi-84-21", 
        "https://www.zhihu.com/people/qiu-tian-de-yu-58-76", 
        "https://www.zhihu.com/people/wo-xiang-wen-yi-xia-63", 
        "https://www.zhihu.com/people/wen-xue-zao-po", 
        "https://www.zhihu.com/people/jiahua-wu", 
        "https://www.zhihu.com/people/wood0sky", 
        "https://www.zhihu.com/people/fong-34-17", 
        "https://www.zhihu.com/people/xi-men-han-feng", 
        "https://www.zhihu.com/people/a-qiu-74-59", 
        "https://www.zhihu.com/people/wang-zi-feng-18-98", 
        "https://www.zhihu.com/people/jin-gou-jun", 
        "https://www.zhihu.com/people/xi-de-87", 
        "https://www.zhihu.com/people/zhu-wang-xiao-xian", 
        "https://www.zhihu.com/people/xiao-yu-er-82-77", 
        "https://www.zhihu.com/people/wei-yang-85-13", 
        "https://www.zhihu.com/people/bian-cheng-99-44", 
        "https://www.zhihu.com/people/tan-yan-wei-zhong-58", 
        "https://www.zhihu.com/people/qiu-suo-zhong-36", 
        "https://www.zhihu.com/people/zhang-jin-jin-7-80", 
        "https://www.zhihu.com/people/mao-xiao-mi-51-14", 
        "https://www.zhihu.com/people/ji-tong-24-6", 
        "https://www.zhihu.com/people/yooyooy", 
        "https://www.zhihu.com/people/newchaos-27", 
        "https://www.zhihu.com/people/lao-gong-30-78", 
        "https://www.zhihu.com/people/7639652", 
        "https://www.zhihu.com/people/jian-zhi-jiu-tian-22", 
        "https://www.zhihu.com/people/feng-zhong-zhi-xie-36", 
        "https://www.zhihu.com/people/xie-lao-da-38-69", 
        "https://www.zhihu.com/people/zhang-jie-56-74-2", 
        "https://www.zhihu.com/people/jin-zhou-53-48", 
        "https://www.zhihu.com/people/bei-meng-13", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/zhang-shou-peng", 
        "https://www.zhihu.com/people/lao-wang-57-39-90", 
        "https://www.zhihu.com/people/ban-bei-zui-37", 
        "https://www.zhihu.com/people/mystert-18", 
        "https://www.zhihu.com/people/yi-qi-keng"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/77809972", 
            "userName": "果壳王子", 
            "userLink": "https://www.zhihu.com/people/440030a7b7bc3da48675ff7d4ba115ba", 
            "upvote": 10, 
            "title": "果壳疯狂编程：机械姬 • 汇编之美", 
            "content": "<p><b>第一章：汇编基础知识</b></p><p><b>引</b> <b>言</b></p><p>学习CE(游戏修改工具)不得不先了解相关汇编知识。如同爱必经纯洁的革命友谊升华到初恋，才会懂得爱情，才会成长。</p><p>汇编语言是和具体的微处理器相联系的，每一种微处理器的汇编语言都不一样，因此我们只能通过一种常用的结构简洁的微处理器汇编语言来进行学习。</p><p>本书采用8086CPU为中央处理器的计算机进行讲解。8086CPU结构简洁，便于疯狂式汇编教学。</p><p><i>最疯狂且优美的，应是最简洁而有力度的。</i></p><p><b>—— 果壳学院疯狂编程 </b>● <b>机械姬系列：汇编之美</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.1</b> <b>机器语言</b></h2><p>说到汇编语言的产生，首先要讲一下机器语言。机器语言是机器指令的集合。什么是机器指令？我们在使用CE时，常常见到。请看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_b.jpg\"/></figure><p>图中所示的就是机器指令（或称机器码），这是十六进制的，如果要让计算机识别，则必须是二进制的。</p><p>例如机器指令 89 5C 24 38 转为二进制是10001001010111000010010000111000。你看得懂这条机器指令的具体含义是什么吗？不懂是吧，我也不懂。可见，机器指令是如此晦涩难懂，于是汇编语言便孕育而生了。汇编语言是程序猿中的普罗米修斯为猿类盗取的编程圣火！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;457&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_b.jpg\"/></figure><p><br/><b>上帝说，要有光，于是便有了光……</b><br/><br/><b> ──《圣经 ●</b> <b>创世纪》</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.2 汇编语言</b></h2><p>汇编语言的主体是汇编指令，汇编指令我们在使用CE时，也是常常见到。见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_b.jpg\"/></figure><p>汇编指令和机器指令是一一对应的。比如：机器指令 89D8和汇编指令mov ax,bx的含义是相同的，然而我们很难懂89D8的含义是什么，mov ax,bx的含义一看就懂了，其含义是：把寄存器bx中的数据传送给ax。汇编指令的写法与人类语言接近，便于阅读和记忆。既然有了如此简明易懂的汇编指令，为什么不把机器指令抛弃掉？因为计算机指令最终是由CPU来执行的，但是CPU只认识机器指令，不认识汇编指令。简言之：汇编指令是给人看的，机器指令是给狗看的──不对，是给CPU看的（写得太入戏，有点儿鸡动)。</p><p>有一个东西可以把汇编指令翻译成机器指令，这个东西就是汇编语言编译器。</p><p>程序员用汇编语言写出源程序，再用编译器将其编译为机器码，由计算机最终执行，下图描述了这个工作过程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;638&#39; height=&#39;118&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.3 指令和数据</b></h2><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放。存储器也就是我们平常说的内存。</p><p>在内存中，<u>指令和数据没有任何本质上的区别</u>，都是二进制信息，只不过CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，即为同样的信息赋予了不同的意义！就好比同样叫“黑呀呀”，有的同学理解为可爱的黑鸭鸭，有的同学理解为冷艳执鞭黑衣女教师——是不是很有画面感？又如围棋的棋子，在棋盒里的时候没有任何区别，在对弈的时候就有了不同的意义。</p><p>同样，内存中的二进制信息 1000100111011000，计算机既可以把它看作 89D8H 数据本身来处理，也可以把它看作指令 mov ax,bx 来处理。</p><p>1000100111011000 → 89D8H（数据）</p><p>1000100111011000 → mov ax,bx（指令）</p><p>那么，CPU在什么时候把它看作数据？在什么时候把它看作指令呢？这个在后面会讲到。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.4 存储单元</b></h2><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，例如一个存储器有128个存储单元，编号从0~127，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0162f0161c2a8695b22dc425c89bd001_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"165\" data-rawheight=\"434\" class=\"content_image\" width=\"165\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;165&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"165\" data-rawheight=\"434\" class=\"content_image lazy\" width=\"165\" data-actualsrc=\"https://pic2.zhimg.com/v2-0162f0161c2a8695b22dc425c89bd001_b.png\"/></figure><p>那么一个存储单元能存储多少信息呢？我们知道计算机的最小信息单位是bit，也就是一个二进制位，8个bit组成一个Byte，也就是通常讲的一个字节，微机存储器的一个存储单元可以存储一个Byte，即8个bit（8个二进制位），一个存储器有128个存储单元，它可以存储128个Byte。</p><p>微机存储器的容量是以字节为最小单位来计算的，对于拥有128个存储单元的存储器，我们可以说它的容量是128个字节。</p><p>对于大容量的存储器，一般还用以下单位来计量容量（以下用B代表Byte）。</p><p>1KB=1024B 1MB=1024KB 1GB=1024MB 1TB=1024GB</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.5 CPU对存储器的读写</b></h2><p>以上讲到，存储器被划分成多个存储单元，存储单元从0开始顺序编号，这些编号就是存储单元的内存地址，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f39aff77f0baa392d83ec62c09722e75_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"187\" data-rawheight=\"500\" class=\"content_image\" width=\"187\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;187&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"187\" data-rawheight=\"500\" class=\"content_image lazy\" width=\"187\" data-actualsrc=\"https://pic2.zhimg.com/v2-f39aff77f0baa392d83ec62c09722e75_b.png\"/></figure><p>CPU要从内存中读取或写入数据，首先要指定内存地址，并指明要对哪一个器件进行操作，是读取数据还是写入数据，因而，CPU要想进行数据的读写，必须和外部器件的芯片进行下面3类信息的交互：</p><p>1：内存地址（地址信息）</p><p>2：器件的选择，读或写命令（控制信息）</p><p>3：读或写的数据（数据信息）</p><p>那么CPU是通过什么将地址、控制信息和数据传到内存中呢？是导线，是连接CPU和其他芯片的导线，通常称之为总线。</p><p>根据传送信息的不同，总线从逻辑上分为3类：地址总线、控制总线、数据总线。</p><p>CPU从内存3读取数据的过程如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_b.jpg\"/></figure><p>1：CPU通过地址线将地址信息3发出。</p><p>2：CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</p><p>3：存储器将内存地址3中的数据8通过数据线送入CPU。</p><p>写入数据的过程和读取数据的过程相似。例如向内存地址3写入数据26，操作步骤如下。</p><p>1：CPU通过地址线将地址信息3发出。</p><p>2：CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，将要从中写入数据。</p><p>3：CPU通过数据线将数据26送入内存地址3的存储单元中。</p><p>从上面我们知道了CPU是如何进行数据读写的工作原理，可是，如何发出具体指令命令计算机进行数据读写呢？这就需要依靠能够驱动它进行工作的简洁而有力的机器指令了！</p><p>对于8086CPU，下面的机器指令就能够完成从内存地址3的存储单元中读取数据的操作。</p><p>机器指令：101000000000001100000000</p><p>汇编指令：mov ax,[3]</p><p>含义：从内存地址3的存储单元读取数据送入寄存器ax中。</p><hr/><h2><b>第2章：寄存器(CPU工作原理)</b></h2><p><b>引</b> <b>言</b></p><p>一个典型的CPU，由运算器、控制器、寄存器等器件组成，对于游戏修改者来说，重点学习寄存器，其它不必管。</p><p>不同的CPU，寄存器的个数、结构是不相同的，8086CPU有14个寄存器，每个寄存器有一个名称，我们对它进行分类：</p><p>1． 通用寄存器：AX、BX、CX、DX</p><p>2． 段寄存器：CS、SS、DS、ES</p><p>3． 指针寄存器：SP、BP</p><p>4． 变址寄存器：SI、DI</p><p>5． 指令指针寄存器：IP</p><p>6． 标志寄存器：FR</p><p>以上寄存器都是16位的，更古老的CPU的寄存器是8位的，这个就不讲了。现在的CPU的寄存器是32位的，这个将在后续章节中与16位寄存器一起讲解。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.1 通用寄存器</b></h2><p>AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p><p>以AX为例，寄存器的逻辑结构图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb\" width=\"673\" data-original=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;673&#39; height=&#39;139&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"673\" data-original=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一个16位寄存器可以存储一个16位的数据，数据在寄存器中的存放情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>黑呀呀提问：一个16位寄存器所能存储的数据的最大值是多少？</p><p>王子答曰：16位即16个bit，16个bit等于2个字节，范围从0~65535，最大值是65536B，因为1KB=1024B，65536B÷1024B=64KB，所以最大值是64KB。</p><p>8086CPU的AX、BX、CX、DX这4个寄存器为了兼容8位寄存器，每个寄存器都可以分为两个可独立使用的8位寄存器。</p><p>AX可分为AH和AL，BX可分为BH和BL，CX可分为CH和CL，DX可分为DH和DL。</p><p>8086CPU的16位寄存器分为2个8位寄存器的情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;217&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>AX的低8位（0位~7位）构成了AL寄存器，高8位（8~15位）构成了AH寄存器。对于AH和AL的名字可以这样理解：H=High（高的），L=Low（低的）。AH和AL寄存器都是可以独立使用的8位寄存器，下图展示了16位寄存器及它所分成的2个8位寄存器的数据存储的情况：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;398&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>小洁儿提问：一个8位寄存器所能存储的数据的最大值为多少？</p><p>王子答曰：8位即8个bit，8个bit等于1个字节，范围从0~255，所以最大值是256B。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.2 字在寄存器中的存储</b></h2><p>字节，即为byte，一个字节由8个bit组成。字，即为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"426\" data-original=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;426&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"426\" data-original=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_b.jpg\"/></figure><p>一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节分别存在这个寄存器的高8位寄存器和低8位寄存器中。</p><p>大师娘卡特黑兰：“说了半天，这都是干嘛用的，这和咱们要学的CE有几毛钱关系鸭？”</p><p>王子曰：“切莫性急(渴)，温火方能煲靓汤，提前热身——方能长久作战！”</p><p>“燃烧我的卡路里！”</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.3 物理地址</b></h2><p>在1.４节我们学习了存储单元，存储单元又叫内存单元，以后我们多数用内存单元这一名称。</p><p>所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p><p>CPU通过地址总线送入内存的，必须是一个内存单元的物理地址，在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式，我们现在讨论8086CPU是如何在内部形成内存单元的物理地址的。</p><p>在进入下一个小节深入讲解8086CPU如何给出物理地址的方法之前，我们先分享一则圣经小故事，放松一下肌肉和心情。</p><p>上帝使他沉睡，他就睡了，于是上帝取下他一条肋骨，又把肉合起来（旁白：“哇靠这都行！”）。</p><p>耶和华(又名“爷火化”)就用那人身上所取的肋骨，造出一个女人，领她到那人跟前（那会儿福利可真好）。</p><p>那人便是亚当，当他醒来看到上帝这一件新作品时，便说道：“这是我的骨中骨、肉中肉，可以称她为女人，因她是从男人身上取出来的。”</p><p>于是，美丽的夏娃诞生了！她和亚当幸福快乐地生活在伊甸园……据说后来，夏娃在苹果树下偷吃了一个苹果，并把那苹果带回来分给亚当吃……自此以后，他们就更觉幸福了……</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8807b41f11c13a1e4db39dde0ba9a256_b.jpg\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"239\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"239\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic3.zhimg.com/v2-8807b41f11c13a1e4db39dde0ba9a256_b.jpg\"/><figcaption>（别太入戏）</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.4 8086CPU给出物理地址的方法</b></h2><p>8086CPU有20位地址总线，最多可以传送20位地址，然而8086CPU内部结构是16位的，一次性只能传送16位的地址，那么怎么解决20位地址（总线）与16位地址（内部结构）不一致的问题呢？8086CPU采用一种在内部用2个16位地址合成的方法来形成一个20位的物理地址。</p><p>当8086CPU要读写内存时，怎样在CPU内部形成物理地址的呢？</p><p>1：CPU中的相关部件提供2个16位的地址，一个称为段地址，另一个称为偏移地址。</p><p>2：段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。</p><p>3：地址加法器将这两个16位地址合成为1个20位的物理地址。</p><p>地址加法器采用“段地址×16＋偏移地址”的方法合成物理地址。即：<b>段地址×16＋偏移地址=物理地址</b>。</p><p>“段地址×16”可以理解为段地址的16倍(段地址的十进制数*16)。以下这个说法更好理解。</p><p>我们把16转化为十六进制10，然后计算一下。假设段地址=2A7，2A7×10=2A70，计算结果2A70相对于段地址2A7左移了一位，所以，段地址×16可以理解为：段地址左移一位。</p><p>请问同学们：“如果段地址=A100，偏移地址=42B，那么，物理地址=？”</p><p>聪明如你，一定知道这个答案：“段地址×16=段地址左移一位，即A100左移一位=A1000，A1000＋42B=A142B，所以，物理地址是：A142B”</p><p>8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如下图所示（图中数据皆为十六进制表示）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_b.jpg\"/></figure><p>段地址×16又叫基础地址，所以，物理地址=基础地址＋偏移地址。（旁白：有没有感觉到，CE中的基址和偏移的概念慢慢浮出了水面？）</p><p>观察下面的地址，你有什么发现？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;504&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_b.jpg\"/></figure><p>结论：CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.5 CS和IP</b></h2><p>8086CPU在访问内存时，要由相关部件提供内存单元的段地址和偏移地址，然后送入地址加法器合成物理地址，那么，是什么部件提供段地址呢？是段寄存器提供段地址！8086CPU有4个段寄存器：CS、DS、SS、ES，本章先讲解CS。</p><p>CS和IP是8086CPU中2个最为关键的寄存器，它们指示了CPU当前要读取指令的地址，我们看一下CE，可以看出在游戏中，什么是CPU要读取的指令地址，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_b.jpg\"/></figure><p>图中左边所示的代码地址就是游戏中CPU要读取指令的地址。CS叫代码段寄存器，IP叫指令指针寄存器。</p><p>在8086CPU机中，任意时刻，设CS的值为M，设IP的值为N，8086CPU将从内存“M×16＋N”单元开始，向下读取每一条指令并执行。也可以这样描述：在8086CPU机中，任意时刻，CPU将CS和IP（CS:IP）配合指向的内存单元里的信息当作指令执行。</p><p><b>下列一组图展示了8086CPU读取、执行指令的工作原理（图中数字皆为十六进制）：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_b.jpg\"/></figure><p>上图为读取、执行指令前的初始状态，CS=2000H，IP=0000H。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_b.jpg\"/></figure><p>上图CS、IP中的数值送入地址加法器，地址加法器完成：物理地址=段地址×16＋偏移地址。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_b.jpg\"/></figure><p>上图地址加法器将物理地址送入“输入输出控制电路”。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_b.jpg\"/></figure><p>上图输入输出控制电路将物理地址20000H送上地址总线。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_b.jpg\"/></figure><p>上图从内存20000H单元开始，将存放其中(3个字节)的机器指令 B8 23 01 通过数据总线送入CPU。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_b.jpg\"/></figure><p>上图输入输出控制电路将机器指令 B8 23 01 送入指令缓冲器。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;662&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_b.jpg\"/></figure><p>上图读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令。因当前读入的指令 B8 23 01长度为3个字节，</p><p><b>所以IP中的值加3，此时，CS：IP指向内存单元2000：0003。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_b.jpg\"/></figure><p>上图执行控制器执行指令 B8 23 01（mov ax,0123h）。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_b.jpg\"/></figure><p>上图指令执行后，AX中的数值为0123H。那么，接下来就是读取、执行下一条指令 BB 03 00（mov bx,0003h）了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>CS和IP的重要性在于它们的数值提供了CPU要执行指令的地址。</p><p>在1.3节中，我们说过，在内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，那么，CPU在什么时候把它看作指令？在什么时候把它看作数据呢？现在我们可以更有深度的回答这个问题了。</p><p>只要内存单元（二进制信息）被CS：IP指向，这些内存单元就会被CPU看作指令执行（如mov ax,bx），否则它依然代表着数据本身（如89D8H）。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.6 修改CS和IP的指令</b></h2><p>Mov被称为传送指令，可以修改大部分寄存器的值。如：mov ax,123H，将ax中的值设为123H。同样地，我们也可以执行 mov bx,2a4H、mov cx,5f0H、mov dx,b29H 等等。但是，mov不能修改CS和IP这两个寄存器的值，因为8086CPU没有提供这样的功能。</p><p>要修改CS和IP的值，可以用jmp指令，事实上，还有一些指令是可以修改CS和IP的，这些指令被统称为转移指令，这个在后面的章节会讲到，现在先学习这个最简单的转移指令：jmp。</p><p>若想同时修改CS和IP的值，可用形如“jmp 段地址：偏移地址”的指令完成。如：jmp 2ae3:9，执行后：CS=2ae3H，IP=9H，CPU将从2ae39H（2ae3*10+9H）处读取指令。</p><p>“jmp 段地址：偏移地址”指令的功能为：用指令中给出的第一个参数“段地址”修改CS，用第二个参数“偏移地址”修改IP。</p><p>若想仅修改IP的值，可用形如“jmp 某一合法寄存器”的指令完成。如：jmp ax，执行前ax=437aH，CS=17f0H，IP=423cH，执行后，CS不变，IP=437aH。即将原IP值 &#34;423cH&#34;修改为ax里的值&#34;437aH&#34;。</p><p>“jmp 某一合法寄存器”指令的功能为：用现有寄存器中的值来修改IP。为什么叫“某一合法寄存器”呢？因为并不是所有寄存器都可以修改IP！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.7 代码段</b></h2><p>在编程时，可以根据需要，将一组内存单元定义为一个段。段分3种类型：代码段、数据段、栈段。</p><p>对于8086PC机，我们可以将长度为N（N≤64KB）的一组代码（机器指令和汇编指令），存放在一组地址连续、起始地址为16的倍数的内存单元中，我们将这一组内存单元定义为代码段。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb\" width=\"524\" data-original=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;524&#39; height=&#39;304&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"524\" data-original=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_b.jpg\"/></figure><p>这段长度为10字节的指令，存放于123B0H~123B9H的一组内存单元中，我们就可以认为这是一个代码段。若要让CPU执行这些指令，必须要将CS：IP指向代码段中第一条指令的首地址（123B0H）。</p><hr/><h2><b>第3章：寄存器（内存访问）</b></h2><p><b>引言</b></p><p>在电影《骇客帝国》中，男主角发现，看似正常的现实世界实际上似乎被某种程序的力量控制着，人类原来的现实世界已不复存在，眼前的一切不过是人工智能精细设计出来的为获得人类生物电能，从而欺骗人类大脑的虚拟网格世界（请参考“缸中之脑”的思想实验）。在影片中有这样一个桥段：男主角等人置身于一个由无数个小房间组成的矩阵中，他们在各房间走道中不断穿梭，希望能寻找到一把神秘钥匙，打开一扇指定的门。这一行为在计算机内存中，叫做内存访问，即通过地址+偏移的方式来访问某一个内存单元，并实现把数据压入栈空间或者从栈中取出（入栈、出栈的操作）。而男主角等人要寻找的这把特殊的key， 在汇编术语中称之为：“SS:SP”。让我们带着这些抽象的概念和电影动人的画面感，进入第3章的旅程！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_b.jpg\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_b.jpg\"/><figcaption>电影《骇客帝国》</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.1 内存中字的存储</b></h2><p>CPU中，一个字在16位寄存器存储时，高位字节存放在高8位寄存器中，低位字节存放在低8位寄存器中。<br/><br/>字在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。如：字4E20H在内存中的存放情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4cf1448b240817608a694effdd3e331_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"257\" data-rawheight=\"263\" class=\"content_image\" width=\"257\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;257&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"257\" data-rawheight=\"263\" class=\"content_image lazy\" width=\"257\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4cf1448b240817608a694effdd3e331_b.jpg\"/></figure><p>字节单元：一个内存单元存放一个字节（8位）。</p><p>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.2 DS和[address]</b></h2><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址和偏移地址组成，其中，段地址存放在段寄存器DS中，DS称作数据段寄存器（是否还记得8086CPU有4个段寄存器：CS、DS、SS、ES，上一章已讲过CS，本章讲DS）。</p><p>如果我们要将内存地址为14A70的内存单元中的数据送入AL中，可以用如下的程序段进行：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_b.png\" data-size=\"normal\" data-rawwidth=\"1028\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb\" width=\"1028\" data-original=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1028&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1028\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1028\" data-original=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_b.png\"/><figcaption>段地址(1000)*10+偏移地址(4A70)=内存单元(14A70)</figcaption></figure><p><br/>[address]表示一个内存单元，上图中的内存单元[address]中存放着偏移地址 [4A70]。<br/><br/><b>内存单元[address]，我们可以知道它的地址是多少，但它的数值是多少，我们无从知晓。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.3 Mov指令</b></h2><p>传送指令mov可以完成以下4种传送：</p><p>1：将数据直接送入寄存器。如：mov ax，1230H</p><p>2：将一个寄存器中的数据送入另一个寄存器。如：mov ax，bx</p><p>3：将一个内存单元中的数据送入一个寄存器。如：mov ax，[27b0]</p><p>4：将一个寄存器中的数据送入内存单元中。如：mov [607c]，bx</p><p>注意：不能直接用数据送给段寄存器，如：mov ds，1230H 是错误的，必须要用一个寄存器来进行中转。比如：</p><p><b>Mov bx，1230H</b><br/><b>Mov ds，bx</b></p><p>这样就行了。至于为什么8086CPU不支持将数据直接送入段寄存器呢？这属于8086CPU硬件设计的问题，我们只需知道这一点即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.4 Add和Sub指令</b></h2><p>Mov指令有两个操作对象，Add和Sub同样有两个操作对象。<br/><br/><b>ADD含意：</b>加法指令。<br/><b>ADD格式</b>：Add 操作对象1，操作对象2。<br/><b>ADD功能：</b>两数相加，并把结果保存到操作对象1中。<br/><br/>Add 具有以下几种形式：<br/>Add 寄存器，数据 如：add ax, 8<br/>Add 寄存器，寄存器 如：add ax, bx<br/>Add 寄存器，内存单元 如：add ax, [27a0]<br/>Add 内存单元，寄存器 如：add [46e9], bx<br/><br/><br/><b>SUB含意：</b>减法指令。<br/><b>SUB格式：</b>Sub 操作对象1，操作对象2。<br/><b>SUB功能：</b>两数相减，即从操作对象1减去操作对象2，并将其结果保存到操作对象1中。<br/><br/>Sub 具有以下几种形式：<br/>Sub 寄存器，数据 如：sub ax, 9<br/>Sub 寄存器，寄存器 如：sub ax, bx<br/>Sub 寄存器，内存单元 如：sub ax, [b027]<br/>Sub 内存单元，寄存器 如：sub [8601], bx<br/><br/></p><h2><b>3.5 数据段</b></h2><p>前面讲过（参见2.7节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N（N≤64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p><p>比如：用123B0H~123B9H这段内存空间来存放数据，我们就可以认为123B0H~123B9H这段内存是一个数据段，长度为10个字节。<br/><br/>如何访问数据段中的数据呢？首先用DS存放数据段的段地址，然后用相关的指令访问数据段中的内存单元。<br/><br/>比如，将123B0H~123B9H的内存单元定义为数据段，现在要累加这个数据段中的前3个单元<br/>中的数据，代码如下：<br/><br/>Mov ax, 123BH<br/>Mov ds, ax 将123BH送入ds中，作为数据段的段地址。<br/>Mov al, 0 用al存放累加结果，先把al中的数据清零。<br/>Add al, [0] 将ds数据段第一个单元（偏移地址为0）中的数值加到al中。<br/>Add al, [1] 将ds数据段第二个单元（偏移地址为1）中的数据加到al中。<br/>Add al, [2] 将ds数据段第三个单元（偏移地址为2）中的数据加到al中。<br/><br/>在1.5节中，我们说过，在内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，那么CPU在什么时候把它看作指令？在什么时候把它看作数据呢？在2.5节中我们回答了第一个问题“什么时候把它看作指令&#34;。</p><p>现在可以回答第二个问题了：什么时候把它看作数据？<br/><br/>答：只要把一段内存单元的段地址放到DS中，并用Mov、Add、Sub等访问内存单元时，CPU就会将这些内存单元看作数据来访问。<br/><br/></p><h2><b>3.6 修改游戏的两种方式（改数据和改指令）</b></h2><p>指令和数据虽然从表面上看其内存结构并无区别，见下图(注意看附加在图片下边的半隐形美丽注解)：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_b.jpg\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_b.jpg\"/><figcaption>就像西施和貂蝉一样都是古典大美女——想什么呐！</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但实际上，它们的差别可大着呢，见下图(注意看附加在图片下边的半隐形危险提示)：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_b.jpg\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"1044\" data-original=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1044&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1044\" data-original=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_b.jpg\"/><figcaption>然而她们的手法、口活、体力活以及各种生活技能也许大不相同哦（危险）</figcaption></figure><p><br/><br/><br/>以上是两者在实际意义上的区别（数据表示属性，指令表示行为）。</p><p>然而当我们从哲学的角度或用辩证法思维来思考问题时却发现：它们既是有区别的，又是密切相关的。数据和指令（或者说属性和行为），此二者是一个矛盾体：既非我族类，互不相同，又唇齿相依，相互合作。举个例子来说明这种思想：</p><p>某个游戏，初始有500份木材，建造一座房子消耗木材50份，如何实现木材数量（属性数据）的读写操作呢？</p><p>需要如下指令（行为方法）：</p><p>Mov ax, [bx＋270]<br/>Sub [bx＋16a], ax</p><p>内存单元[bx＋270]为建造房子时消耗的木材数量，每次消耗50份木材。内存单元[bx＋16a]为当前木材数量。假设木材初始数量为500，当我们建造一座房子（首套房）时，则CPU会从内存单元[bx＋270]中读取数据50送入ax，然后内存单元[bx＋16a]的数值减去ax，并把计算结果450（由500-50而得）写入该内存单元[bx＋16a]中，则当前木材数量变为450。上面这两条指令（Mov和Sub）实现了木材数量（属性数据）的读写操作，致使游戏中的伐木造房功能得以实现！</p><p>从上面这个简单的例子，可以看出数据与指令是怎样的关系。只有数据没有指令，那么数据就没法读写，只有指令没有数据，那么只能是空指令，没有实质意义，如同巧妇难为无米之炊。</p><p>修改数据和指令就是修改游戏的两种方式。以前我们用《金山游侠》、《gamemaster》等修改器修改的都是数据，现在有了CE，CE除了可以修改数据，还可以修改指令，棒到家——可以修改西施和貂蝉的行为了！</p><p><b>赶紧对她们下达“主人的指令”吧！</b></p><p><i>—— 妲己：主人的命令是绝对的。</i></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_b.jpg\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"837\" data-original=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;837&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"837\" data-original=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_b.jpg\"/><figcaption>（非法制绘）</figcaption></figure><h2><b>3.7 栈</b></h2><p>栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于：最后进入这个空间的数据最先出去。可以用一个盒子和3本书来描述栈的这种操作方式。</p><p>一个开口的盒子就可以看成一个栈空间，现有3本名著：《金瓶梅》、《肉蒲团》、《剪灯新话》，把它们放到盒子中，操作过程如下图所示（注意轻拿轻放，都是中国古典辉煌著作）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;776&#39; height=&#39;587&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_b.jpg\"/></figure><p><br/><b>上图把书放进盒子，这种操作可以称之为“入栈”。</b>现在的问题是：一次只允许取一本，我们如何将3本书从盒子中取出来呢？</p><p>显然，必须从盒子的最上边取，这样取出的顺序就是：《剪灯新话》、《肉蒲团》、《金瓶梅》，和放入的顺序相反，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"615\" class=\"origin_image zh-lightbox-thumb\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;831&#39; height=&#39;615&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"615\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>上图把书从盒子中取出，这种操作可以称为“出栈”。</b></p><p>如果说，上例中的盒子就是一个栈，那么对于栈有两个基本操作：入栈和出栈。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出，栈的这种操作规则被称为 LIFO（last in first out：<b>后进先出</b>）。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_b.jpg\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb\" width=\"511\" data-original=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;511&#39; height=&#39;305&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"511\" data-original=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_b.jpg\"/><figcaption>入栈出栈，后进先出之遐想：商女不知亡国恨，隔江尤唱后庭花。</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>小知识点：想必大家对《金瓶梅》和《肉蒲团》并不陌生，对《剪灯新话》却缺乏相当的了解，那么今天果壳大湿就给大家来讲讲《剪灯新话》这本文学著作。</i><br/><br/><i>《剪灯新话》是明代瞿佑撰写的文言短篇小说，中国十大禁书之一，此书为中国历史上第一部禁毁小说。书中除描摹普罗男女的畸变离奇隐秘之事外，其人鬼相恋，“交合之事，一如人间”，亦成为扣脚大汉和金刚芭比津津乐道，奉之为宅男宅女圣经宝典之根由，并不断从中汲取文学养分。中国文化博大精深——外国人和外行人是看不懂的。</i></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.8 CUP提供的栈机制</b></h2><p>现如今的CPU中都会有栈的设计。8086CPU提供的入栈和出栈指令，最基本的两个是：push（入栈）和pop（出栈）。</p><p>Push ax 表示将寄存器ax中的数据送入栈中，pop ax 表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。</p><p>下面两张图描述了push和pop指令的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb\" width=\"978\" data-original=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;978&#39; height=&#39;459&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"978\" data-original=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_b.jpg\" data-size=\"normal\" data-rawwidth=\"980\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"980\" data-original=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;980&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"980\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"980\" data-original=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_b.jpg\"/><figcaption>pop ax时，将数据1122H从1000BH-1000AH地址处取出；pop bx时，将数据2266H从1000DH-1000CH地址处取出；pop cx时，将数据0123H从1000FH-1000EH地址处取出。</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面两张图指令的执行过程，写成代码如下：</p><p>Mov ax, 123H</p><p>Push ax</p><p>Mov bx, 2266H</p><p>Push bx</p><p>Mov cx, 1122H</p><p>Push cx</p><p>Pop ax</p><p>Pop bx</p><p>Pop cx</p><p><b>注意：字型数据用两个内存单元存放，高地址单元存放高8位，低地址单元存放低8位。</b></p><p>看了上面两张图后，现在提出两个问题。</p><p>问题一<b>（栈空间）</b>：我们将10000H~1000FH这段内存当作栈来使用，CPU是如何知道这段空间是栈？关于这个问题将在3.10节中进行解答（现在先把问题抛出来供大家思考）。</p><p>问题二<b>（栈顶单元）</b>：push ax等入栈指令执行时，要将寄存器中的数据放入当前栈顶单元的上方，成为新的栈顶元素；pop ax等指令执行时，要从栈顶单元取出数据送入寄存器中。显然，push、pop在执行的时候，CPU必须要知道哪个单元是栈顶单元，可是，如何知道？</p><p>王子解答：8086CPU中，有这么两个寄存器——堆栈段寄存器SS和堆栈指针寄存器SP。栈顶的段地址存放在SS中，栈顶的偏移地址则存放在SP中。任意时刻，SS:SP将会指向栈顶元素。push和pop指令在执行时，CPU会自动从SS和SP中得到栈顶单元的地址。</p><p><b><i>这也就是本章开篇引言中讲述的关于《骇客帝国》男主角等人在房间矩阵中苦苦寻找的key：SS:SP。有了key就能定位到栈顶单元。</i></b></p><p>现在，我们可以完整地描述push和pop指令的功能实现机制了，例如push ax的执行，由以下两步骤完成：</p><p>1. SP=SP－2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</p><p>2. 将ax中的数据送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</p><p><br/>下图描述了push ax的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1030&#39; height=&#39;544&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_b.jpg\"/></figure><p><br/>小马提问：如果10000H~1000FH这段空间为栈，初始状态栈是空的，此时，SS=1000H，SP=？</p><p>王子答曰：此时SP需要SP=SP+2，则SP=0010H。具体分析见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_b.jpg\"/></figure><p><br/>将10000H~1000FH这段空间当作栈段，SS=1000H，栈空间大小为16字节，栈最底部的字单元地址为1000:000E，任意时刻，SS:SP指向栈顶，当栈中只有一个元素时，SS=1000H，SP=000EH。若栈为空，相当于栈中唯一的元素出栈后，SP=SP＋2，原来为000EH，加2后SP=0010H，所以，当栈为空的时候，SS=1000H，SP=0010H。</p><p>换一个角度看，任意时刻，SS:SP指向栈顶元素，当栈为空的时候栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址＋2（即SP+SP+2），栈最底部字单元的地址为1000:000E，所以，栈空时，SP=0010H。</p><p><br/>接下来，我们描述pop指令的功能实现机制，例如：pop ax。Pop ax的执行过程和push ax刚好相反，由以下两步完成：</p><p>1. 将SS:SP指向的内存单元处的数据送入ax中。</p><p>2. SP=SP＋2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p><p>下图描述了pop ax的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1008\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"1008\" data-original=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1008&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1008\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1008\" data-original=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_b.jpg\"/></figure><p><br/>注意：上图中，出栈后，SS:SP指向新的栈顶1000EH，pop操作前的栈顶元素，1000CH处的数据2266H依然存在，但是，它已不在栈中(不在栈中在哪里，以后再讲)，当再次执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，将它覆盖。</p><p><br/>小知识点：根据上述出入栈原理，我们可以得知，为什么当我们删除硬盘中的文件后，若尚未存入新文件，则仍有可能实现“硬盘数据恢复”，但一旦在原处覆盖存入新文件则旧文件必将永远丢失，好多种子万劫不复！出栈入栈与硬盘数据丢失，两者同理。此时此刻，想起那些被误删的种子和那段无法被遗忘的岁月，王子&#34;湿&#34;性大发，&#34;性&#34;甚至哉，不得不淫它曹操一“手&#34;：《观沧海》。<br/><br/><i>东临碣石</i>，<i>以观沧海。</i></p><p><i>水何澹澹，山岛竦峙</i>。</p><p><i>树木丛生，百草丰茂。</i></p><p><i>秋风萧瑟，洪波涌起。</i></p><p><i>日月之行，若出其中。</i></p><p><i>星汉灿烂，若出其里。</i></p><p><i>幸甚至哉，歌以咏志！</i><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_b.jpg\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_b.jpg\"/><figcaption>出栈入栈与硬盘数据（种子）丢失两者同理之遐思：日月之行若出其中，星汉灿烂若出其里</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3.9 push和pop指令的两种运用形式</h2><p><br/>PUSH和POP指令的格式有如下两种形式。<br/><br/><b>第一种形式（push 寄存器、POP 寄存器）：</b><br/>&#34;push 寄存器&#34;，入栈，将一个寄存器中的数据压入栈中。<br/>&#34;POP 寄存器&#34;，出栈，用一个寄存器接收出栈的数据。<br/><br/><i>这一种形式，它们可以在栈和寄存器之间传送数据。</i><br/>注意：上面的寄存器可以是段寄存器，比如，可以是：push ds、pop ds。</p><p><b>第二种形式（push 内存单元 、POP 内存单元）：</b><br/>&#34;push 内存单元&#34;，入栈，将一个内存单元中的字型数据入栈（注意，栈操作都是以字为单位）。<br/>&#34;POP 内存单元&#34;，出栈，用一个内存字单元接收出栈的数据。</p><p>示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"261\" class=\"origin_image zh-lightbox-thumb\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;469&#39; height=&#39;261&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"261\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_b.jpg\"/></figure><p><i>这一种形式，它们可以在栈和内存单元之间传送数据。</i><br/><br/>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中给出内存单元的偏移地址。段地址在指令执行时，CPU会自动从DS中取得段地址。<br/><br/><br/><b>小结：</b><br/>Push和pop实质上是一种内存传送指令，与mov指令不同的是，push和pop指令访问的栈空间的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还需要改变SP中的数值。Mov指令只需一步操作，就是传送，而执行push、pop指令需要两步操作，执行push时，先改变SP，后向SS:SP处传送数据入栈；执行pop时，先读取SS:SP处的数据并将其送出栈，而后改变SP。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3.10 栈段</h2><p>前面讲过（参见2.7节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N≤64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。</p><p>比如，我们将10010H~1001FH这段内存空间当作栈来用，以栈的方式进行访问，这段空间就可以认为是一个栈段，大小为16个字节。</p><p>如何使得如push、pop等栈操作指令访问我们定义的栈段呢？那就是要将SS:SP指向我们定义的栈段。现在我们来回答3.8节中的第一个问题：CPU是如何知道这段空间是栈？</p><p>王子潇洒答曰：只要这段内存单元被SS:SP指向，那么，CPU就会把这段空间当作栈来使用！</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2><b>第4章：寻址方式</b></h2><p><b>引言</b></p><p><i>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急！雁过也，正伤心，却是旧时相识。</i></p><p><i>满地黄花堆积，憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！</i></p><p><br/><i>本章精彩内容介绍——</i></p><p><i>1.李清照寻夫：Mov ax, [bx]</i></p><p><i>2.其夫未归，如何用另一种更灵活的方式来玩转她：Mov ax, [bx＋idata]</i></p><p><i>3.那么清照妹妹身上的物理地址究竟在哪里？物理地址=基础地址＋偏移地址。</i></p><p><i>4.上下探索，尝试不同玩法，从[idata]一直到[bx＋si＋idata]，无一死角，遍体酥麻……</i></p><p><i>5.到黄昏、点点滴滴……这次第，怎一个&#34;抽&#34;字了得！</i></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_b.jpg\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;526&#39; height=&#39;655&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_b.jpg\"/><figcaption>清照妹妹</figcaption></figure><h2><br/><b>4.1 内存单元和[bx]的描述</b></h2><p>要完整地描述一个内存单元，需要两种信息：<br/>1.内存单元的物理地址（物理地址=基础地址＋偏移地址）。<br/>2.内存单元的长度（字单元、字节单元）。<br/><br/>如：mov ax, [2a78] 表示将一个内存单元中的数据送入ax（16位寄存器）中，这个内存单元的长度为2字节（<b>字单元</b>），存放一个字，偏移地址为2a78H，段地址在DS中。</p><p>如：mov al, [10f3] 表示将一个内存单元中的数据送入al（8位寄存器）中，这个内存单元的长度为1字节（<b>字节单元</b>），存放一个字节，偏移地址为10f3H，段地址在DS中。<br/><br/>一个内存单元，段地址默认在DS中，偏移地址可以直接给出，单元的长度可以由具体指令中的其它操作对象（比如上述的ax寄存器、al寄存器）指出。<br/><br/>上面两条指令中，内存单元[2a78]和[10f3]，它们的偏移地址分别是2a78H和10f3H，第一条指令中，ax为16位寄存器，这意味着[2a78]是字单元；第二条指令，al为低8位寄存器，这意味着[10f3]是字节单元（8位相当于单字节，16位相当于双字节）。<br/><br/>再看下面两条指令：<br/>Mov ax, [bx] <br/>Mov al, [bx]<br/><br/>[bx]同样也表示一个内存单元，它的偏移地址就是bx的数值。<br/><br/></p><h2><b>4.2 [bx＋idata]</b></h2><p>请看下面三组指令：<br/>Mov ax, [127a]、 Mov ax, [30e0]、Mov ax, [c950]<br/>指令中的127a、30e0、c950皆为常量，我们可以用idata来表示常量：mov ax, [idata]。<br/><br/>同理：Mov bx, 123aH、Mov bx, 8762H、Mov bx, 4c0eH<br/>即可表示为：mov bx, idata。<br/><br/>假设我们用[idata]和[bx]的方式来指明一个内存单元：<br/>Mov bx, idata <br/>Mov ax, [bx]</p><p>则我们还可以用另一种更灵活的方式来玩转它：Mov ax, [bx＋idata]。偏移地址为bx中的数值加上idata。<br/><br/>我们看一下指令mov ax, [bx＋200]的含义。将内存单元[bx＋200]中的数据送入ax，长度为2个字节（字单元），偏移地址为bx中的数值加上200，段地址在DS中。<br/><br/>该指令也可以写成如下常用格式：<br/>Mov ax, [200＋bx]、mov ax, 200[bx]、mov ax, [bx].200</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.3 SI和DI</b></h2><p>SI是源变址寄存器，DI是目的变址寄存器，它们的功能与BX相近，但它们不能分成两个8位寄存器。<br/><br/>以下指令把内存单元[13b2]中的数据送入ax。<br/>Mov bx, 13b2H<br/>Mov ax, [bx] <br/><br/>同样地，可以：<br/>Mov si, 13b2H<br/>Mov ax, [si] <br/><br/>也可以：<br/>Mov di, 13b2H<br/>Mov ax, [di] <br/><br/><br/>以下指令把内存单元[2a7c＋123]中的数据送入ax。<br/>mov bx, 2a7cH<br/>Mov ax, [bx＋123] <br/><br/>同样地，可以：<br/>Mov si, 2a7cH<br/>Mov ax, [si＋123] <br/><br/>也可以：<br/>Mov di, 2a7cH<br/>Mov ax, [di＋123]</p><p>由此可见，我们用[bx]的方式来指明一个内存单元，同样地我们也可以用[si]或[di]的方式来指明一个内存单元，它们的含义基本相同。<br/><br/>而当我们用[bx＋idata]的灵活方式来指明一个内存单元时，同样地我们亦可以用[si＋idata]或[di＋idata]的方式来指明一个内存单元，含义近似。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.4 [bx＋si]和[bx＋di]</b></h2><p>本节我们学习比前面几节讲解的更为灵活的指明一个内存单元的方式：[bx＋si]和[bx＋di]。 <br/>[bx＋si]和[bx＋di]的含义相似，我们以[bx＋si]为例进行讲解。</p><p><b>[bx＋si]表示一个内存单元，它的偏移地址为bx的数值加上si的数值。</b><br/><br/>指令mov ax, [bx＋si]的含义如下：<br/>将一个内存单元[bx＋si]中的数据送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx的数值加上si的数值，段地址在DS中。<br/><br/>该指令也可以写成如下常用格式：mov ax, [bx][si]</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.6 寻址方式的含义</b></h2><p>前面我们学习了几种定位内存地址的方法，现在总结一下：<br/><br/>1.[idata] 用一个常量来表示地址，可用于直接定位一个内存单元。<br/>2.[bx] 用一个变量来表示内存地址，可在一个起始地址的基础上间接定位一个内存单元。<br/>3.[bx＋idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量+常量的方式间接定位一个内存单元。<br/>4.[bx＋si] 用两个变量表示地址（间接定位）。<br/>5.[bx＋si＋idata] 用两个变量和一个常量表示地址（间接定位）。<br/><br/>可以看到，从[idata]一直到[bx＋si＋idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。以上这几种定位内存地址的方法就称作寻址方式。</p><p><i>下一章我们将对寻址方式的问题进行深入浅出的探讨，敬请关注！</i><br/><br/><i><b>关注果壳不迷路，果壳带你上高速！</b></i><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_b.jpg\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;574&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_b.jpg\"/><figcaption>我的机器女友，今晚一起上高速。</figcaption></figure><hr/><h2><b>第5章：数据处理的两个基本问题</b></h2><p><b>引言</b><br/><br/>我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：<br/><br/>1. 处理的数据在什么地方？<br/>2. 要处理的数据有多长？<br/><br/>这两个问题，在机器指令中，必须给以明确或隐含的说明，否则计算机就无法工作。本章中，我们就要针对8086CPU对这两个基本问题进行讨论。</p><h2><b>5.1 bx、si、di和bp</b></h2><p>Bx、si和di这3个寄存器我们已经学过了，现在总结以下两个要点，并学学bp。<br/><br/>1：在8086CPU中，只有这4个寄存器可以用在[…]中来进行内存单元的寻址。比如，下面的指令都是正确的：<br/>Mov ax, [bx]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋di]<br/>Mov ax, [bp]<br/>Mov ax, [bp＋si]<br/>Mov ax, [bp＋di]<br/><br/>而下面的指令则是错误的：<br/>Mov ax, [ax]<br/>Mov ax, [cx]<br/>Mov ax, [dx]<br/>Mov ax, [ds]<br/><br/><br/>2：在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：<br/>组合一：bx和si <br/>组合二：bx和di <br/>组合三：bp和si <br/>组合四：bp和di。<br/><br/>比如下面的指令都是正确的：<br/>Mov ax, [bx]<br/>Mov ax, [si]<br/>Mov ax, [di]<br/>Mov ax, [bp]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋di]<br/>Mov ax, [bp＋si]<br/>Mov ax, [bp＋di]<br/>Mov ax, [bx＋si＋idata]<br/>Mov ax, [bx＋di＋idata]<br/>Mov ax, [bp＋si＋idata]<br/>Mov ax, [bp＋di＋idata]<br/><br/>而下面的指令则是错误的：<br/>Mov ax, [bx＋bp]<br/>Mov ax, [si＋di]<br/><br/><br/><br/>我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：<br/>Mov ax, SS:[bx] 段地址在SS中。<br/>Mov ax, DS:[bp] 段地址在DS中。<br/>Mov ax, CS:[bp] 段地址在CS中。<br/>Mov ax, ES:[bp] 段地址在ES中。<br/><br/>在上面的指令 mov ax, ES:[bp] 中，我们接触到了一个新的段寄存器ES，ES叫附加段寄存器，它的功能与DS基本相同。<br/><br/>如果在[…]中使用寄存器bp，而指令中没有显式地给出段地址，段地址就默认在SS中。比如，下面的指令：<br/>Mov ax, [bp＋200] 内存单元[bp＋200]的段地址就在SS中。<br/><br/>BP被称作基址指针寄存器，它可以作SP使用，除了BP可以作为间接寻址寄存器而SP不能外，其余功能基本相同。<br/><br/>事实上，通用寄存器除了第2章引言中提及的ax、bx、cx、dx这4个外，从广义上讲还应包括sp、bp、si、di这4个16位寄存器，以及ah、al、bh、bl、ch、cl、dh、dl这8个8位寄存器，也就是说，通用寄存器实际上一共有以上这16个。</p><h2><b>5.2 机器指令处理的数据在什么地方</b></h2><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口，比如下图所列的指令：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1026\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"1026\" data-original=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1026&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1026\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1026\" data-original=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5.3 汇编语言中的数据位置的表达</b></h2><p>在汇编语言中如何表达数据位置？汇编语言中用3个概念来表达数据的位置，即立即数、寄存器、地址（段地址和偏移地址）。<br/><br/>1. 立即数（idata）<br/>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称之为“立即数”。例如：<br/>Mov ax, 136aH 指令要处理的数据就是立即数136aH。<br/>Add ax, 2000H 指令要处理的数据就是立即数2000H。<br/>Sub ax, a2c7H 指令要处理的数据就是立即数a2c7H。<br/><br/>2. 寄存器<br/>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：<br/>Mov ax, bx 指令要处理的数据在bx寄存器中。<br/>Mov ds, ax 指令要处理的数据在ax寄存器中。<br/>Push bx 指令要处理的数据在bx寄存器中。<br/>Mov DS:[123a], bx 指令要处理的数据在bx寄存器中，段地址在DS中。<br/><br/>3. 段地址和偏移地址<br/>指令要处理的数据在内存中，在汇编指令中可用[…]的格式给出偏移地址，段地址在某个段寄存器中。例如：<br/>Mov ax, [107a]<br/>Mov ax, [di]<br/>Mov ax, [bx＋8]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋si＋8]<br/>指令要处理的数据偏移地址在[…]中，段地址默认在DS中。<br/><br/><br/>再看下面的指令：<br/>Mov ax, [bp]<br/>Mov ax, [bp＋8]<br/>Mov ax, [bp＋si]<br/>Mov ax, [bp＋si＋8]<br/>指令要处理的数据偏移地址在[…]中，段地址默认在SS中。<br/><br/><br/>存放段地址的寄存器也可以是显性地给出，比如以下指令：<br/>Mov ax, DS:[bp] 指令要处理的数据偏移地址在[…]中，段地址在DS中。<br/>Mov ax, ES:[bx] 指令要处理的数据偏移地址在[…]中，段地址在ES中。<br/>Mov ax, SS:[bx＋si] 指令要处理的数据偏移地址在[…]中，段地址在SS中。<br/>Mov ax, CS:[bx＋si＋8] 指令要处理的数据偏移地址在[…]中，段地址在CS中。</p><h2><b>5.4 寻址方式（总结）</b></h2><p>本节对寻址方式进行一下总结，见下表。<br/><br/>看表前先看以下说明：<br/>1.表中EA表示偏移地址，SA表示段地址。<br/>2.表中寄存器加上一个小括号，表示这个寄存器中的数值，比如：EA=(bx)；SA=(ds)，（bx）就表示bx中的数值，（ds）就表示ds中的数值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"861\" class=\"origin_image zh-lightbox-thumb\" width=\"913\" data-original=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;913&#39; height=&#39;861&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"861\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"913\" data-original=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5.5 指令要处理的数据有多长</b></h2><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作，对于这个问题，汇编语言中用以下方式处理。<br/><br/>1. 通过寄存器名指明要处理的数据的尺寸。<br/>例如，下面的指令中，寄存器指明了指令进行的是字操作，因为这些寄存器都是16位的。<br/>Mov ax, 123H<br/>Mov bx, DS:[210a]<br/>Add ax, 1000H<br/>Sub bx, 2ffH<br/><br/>下面的指令中，寄存器指明了指令进行的是字节操作，因为这些寄存器都是8位的。<br/>Mov al, 12H<br/>Mov bl, DS:[210a]<br/>Add al, 10H<br/>Sub bl, 2fH<br/><br/><br/>2. 在没有寄存器名存在的情况下，用操作符word prt或byte prt指明内存单元的长度，前者为字单元，后者为字节单元。<br/>例如，下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元。<br/>Mov word ptr DS:[a017]，28H<br/>Add word ptr [bx]，78H<br/><br/>下面的指令中，用byte prt指明了指令访问的内存单元是一个字节单元。<br/>Mov byte ptr DS:[1a7]，1aH<br/>Add byte ptr [bx]，62H<br/><br/>在没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度是很有必要的，否则，CPU无法得知所要访问的单元是字单元还是字节单元，从而造成错误。<br/><br/><br/>3. 其它方法。有些指令已经默认了所访问的内存单元是字单元还是字节单元，比如：push [123a]和pop[123c]就不用指明访问的是字单元还是字节单元，因为push和pop指令只进行字操作。<br/><br/></p><h2><b>5.6 mul指令</b></h2><p>Mul为乘法指令，使用mul做乘法的时候，注意以下两点：<br/>1. 两个相乘的数：这两个相乘的数，要么都是8位，要么都是16位，如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中；如果是16位，一个默认放在ax中，另一个放在16位寄存器或内存字单元中。<br/>2.结果：如果是8位乘法，其结果默认存放在ax中；如果是16位乘法，其结果的高位默认存放在<b>dx</b>中，低位则存放在ax中。<br/><br/>Mul 指令格式如下：<br/>Mul 通用寄存器<br/>Mul 内存单元</p><p>内存单元可以用不同的寻址方式给出，比如：<br/>Mul byte ptr DS:[7102] 8位乘法。<br/>Mul word ptr [bx＋si＋8] 16位乘法。<br/><br/>例1：计算100×10。<br/>100和10都小于255，可以做8位乘法，代码如下：<br/>Mov al, 100<br/>Mov bl, 10<br/>Mul bl<br/>结果：ax=al×bl=100×10=1000（3E8H）<br/><br/>例2：计算100×10000。<br/>100小于255，可10000大于255，所以必须做16位乘法，代码如下：<br/>Mov ax, 100<br/>Mov bx, 10000<br/>Mul bx<br/>结果：ax×bx=100×10000=1000000（F4240H）<br/>存放：Ax=4240H（低16位值）；Dx=FH（高16位值）<br/><br/></p><h2><b>5.7 div指令</b></h2><p>Div是除法指令，使用div做除法的时候，应注意以下问题：<br/>1. 除数：有8位和16位两种，在一个寄存器或内存单元中。<br/>2. 被除数：如果除数为8位，被除数则为16位，则默认放在ax中；如果除数为16位，被除数则为32位，则在dx和ax中存放，其中dx存放高16位，ax存放低16位。<br/>3. 结果：如果除数为8位，则al存储结果的商，ah存储结果的余数；如果除数为16位，则ax存储结果的商，dx存储结果的余数。<br/><br/>Div 指令格式如下：<br/>Div 通用寄存器<br/>Div 内存单元<br/><br/>内存单元可以用不同的寻址方式给出，比如：<br/>Div byte ptr DS:[21a5] 除数为8位的除法。<br/>Div word ptr [bx＋si＋8] 除数为16位的除法。<br/><br/>例1：计算100001÷100。<br/>被除数100001为32位，转化成16进制为186a1H，低16位值86a1H放在ax中，高16位值1H放在Dx中，除数100转化为16进制64H后，放在一个16位寄存器中，代码如下：<br/>Mov dx, 1H<br/>Mov ax, 86a1H<br/>Mov bx, 64H<br/>Div bx<br/>结果：(dx×10000H＋ax)÷bx=186a1H÷64H=3E8H余1。<br/>存放：Ax=3e8H（1000）；dx=1H<br/><br/>例2：计算1001÷100。<br/>被除数1001可用ax存放，除数100可用8位寄存器存放，代码如下：<br/>Mov ax, 1001<br/>Mov bl, 100<br/>Div bl<br/>结果：ax÷bl=1001÷100=10余1。<br/>存放：Al=10；Ah=1</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_b.jpg\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_b.jpg\"/><figcaption>（寄存器存放高低位数据之遐思）</figcaption></figure><hr/><h2><b>第6章：转移指令和原理</b></h2><p><b>引言</b></p><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。<br/><br/>8086CPU的转移行为有以下几类：<br/>1. 同时修改CS和IP时，称为段间转移，比如：jmp 100:2a7。<br/>2. 只修改IP时，称为段内转移，比如：jmp ax。由于转移指令对IP的修改范围不同，段内转移又分为“短转移”和“近转移”。<br/>3. 段内短转移IP的修改范围为：-128~127。<br/>4. 段内近转移IP的修改范围为：-32768~32767。<br/><br/>8086CPU的转移指令分为以下几类：<br/>1. 无条件转移指令（比如：jmp）<br/>2. 条件转移指令<br/>3. 循环指令<br/>4. 过程<br/>5. 中断<br/>这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的，我们在这一章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。<br/><br/></p><h2><b>6.1 jmp指令</b></h2><p>Jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。<br/><br/>Jmp指令要给出两种信息：<br/>1. 转移的目的地址。<br/>2. 转移的距离（段间转移、段内短转移、段内近转移）。<br/><br/>不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令，下面的几节内容中，我们以给出目的地址的不同方法为主线，讲解jmp指令的主要应用格式和CPU执行转移指令的基本原理。<br/><br/></p><h2><b>6.2 依据位移进行转移的jmp指令</b></h2><p>Jmp short 标号（转到标号处执行指令）。</p><p>这种格式的jmp指令，实现的是段内短转移，它对IP的修改范围为：-128~127。也就是说，它向前转移时可以多越过128个字节，向后转移可以最多越过127个字节。Jmp指令中的“short”符号，说明指令进行的是短转移，jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，转移指令执行结束后，CS:IP应该指向标号处的指令。</p><p>请看下面一段代码：</p><p>Mov ax, 0</p><p>Jmp short S</p><p>Add ax, 1</p><p>S:add ax, 2</p><p>最下面那条指令中的S就是标号，jmp short S指令执行后，CS:IP指向S:add ax, 2，上面那条指令Add ax, 1已被跳过，没有被CPU执行。有没有觉得：有点像高级语言中的GOTO语句？</p><p>在“jmp short 标号”指令所对应的机器码中，不包含转移的目的地址，而包含的是转移的位移，这个位移是编译器根据汇编指令中的“标号”计算出来的，具体的计算方法如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;807&#39; height=&#39;444&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_b.jpg\"/></figure><p><br/><br/>上图中，标号处的指令s0:inc bx的偏移地址为6，指令jmp s0后的第一个字节的偏移地址为3，位移量就是：6－3= 3。</p><p>再来看，标号处的指令s:inc ax的偏移地址为0，指令jmp s后的第一个字节的偏移地址为9，则位移量就是0－9 =﹣9。</p><p>“Jmp short 标号”的功能表示：IP=IP＋8位位移。请看以下四个要点：</p><p>1：8位位移=标号处的地址－jmp指令后的第一个字节的地址。</p><p>2：short指明此处的位移为8位位移。</p><p>3：8位位移的范围为﹣128~127，用补码表示（本教程不讲解补码，若你想了解，请看相关书籍）。</p><p>4：8位位移由编译程序在编译时算出。</p><p>还有一种和“jmp short 标号”功能相近的指令格式：“jmp near ptr 标号”，它实现的是段内近转移。</p><p>“jmp near ptr 标号”的功能表示为：IP=IP＋16位位移。</p><p>1：16位位移=标号处的地址－jmp指令后的第一个字节的地址。</p><p>2：near ptr指明此处的位移为16位位移，进行的是段内近转移。</p><p>3：16位位移的范围为﹣32768~32767，用补码表示。</p><p>4：16位位移由编译程序在编译时算出。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6.3 转移地址在指令中或寄存器中的jmp指令</b></h2><p>“Jmp far ptr 标号”实现的是段间转移（又称为远转移），功能如下：</p><p>CS=标号所在段的段地址，IP=标号在段中的偏移地址。<br/>&#34;Far ptr&#34;指明了指令用标号的段地址和偏移地址修改CS和IP。<br/>在“jmp far ptr 标号”指令所对应的机器码中，包含转移目的地的地址。<br/><br/>转移的目的地在寄存器中的jmp指令，指令格式为：<br/>Jmp 16位通用寄存器。<br/>功能：IP=16位通用寄存器<br/>这种指令我们在前面的内容（参见2.6节）中已经讲过，这里就不再详述。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_b.jpg\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_b.jpg\"/><figcaption>师娘大变身：爱的魔力转圈圈（转移地址jmp指令之海边遐想）</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6.4 转移地址在内存中的jmp指令</b></h2><p>转移地址在内存中的jmp指令有两种格式：<br/><br/>1. “jmp word ptr 内存单元地址”（段内转移）。<br/>功能：从内存单元地址处开始存放着一个字，用做转移的目标偏移地址。内存单元地址可用寻址方式的任一格式给出，比如，下面的指令：<br/><br/>Mov ax, 123H<br/>Mov DS:[200], ax<br/>Jmp word ptr DS:[200]<br/>执行后，IP=123H<br/><br/>又比如，下面的指令：<br/>Mov ax, 123H<br/>Mov [bx], ax<br/>Jmp word ptr [bx]<br/>执行后，IP=123H<br/><br/><br/>2. “jmp dword ptr 内存单元地址”（段间转移）。<br/>功能：从内存单元地址处开始存放着两个字，高地址处的字为转移的目标段地址，低地址处的字为转移的目标偏移地址。<br/><br/>CS=内存单元地址＋2<br/>IP=内存单元地址<br/><br/>内存单元地址可用寻址方式的任一格式给出。比如，下面的指令：<br/>Mov ax, 123H<br/>Mov DS:[200], ax<br/>Mov word ptr DS:[202], 100<br/>Jmp dword ptr DS:[200]<br/>执行后，CS=100H，IP=123H，CS:IP指向100:123。<br/><br/>又比如，下面的指令：<br/>Mov ax, 123H<br/>Mov [bx], ax<br/>Mov word ptr [bx＋2], 100<br/>Jmp dword ptr [bx]<br/>执行后，CS=100H，IP=123H，CS:IP指向100:123。<br/><br/>在上面的指令中，我们接触到了一个新的符号“dword”，它表示什么意思呢？前面我们已学过，Byte表示字节，word表示字，dword则表示双字，谢谢。<br/><br/></p><h2><b>6.5 CALL指令</b></h2><p>Call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP，它们经常被共同用来实现子程序的设计。这两节，我们讲解call和ret指令的原理。<br/><br/>CPU执行call指令时，进行两步操作：<br/>1.将当前的IP（或CS和IP）压入栈中。<br/>2.转移。<br/><br/><br/>Call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同，下面我们以给出转移目标地址的不同方法为主线，讲解call指令的主要应用格式。<br/><br/>1. 依据位移进行转移的call指令。<br/>Call 标号（将当前的IP压入栈后，转到标号处执行指令）。指令执行时，它的功能相当于：<br/>Push IP<br/>Jmp near ptr 标号<br/><br/><br/>2. 转移地址在指令中的call指令。<br/>Call far ptr 标号（实现的是段间转移）。<br/>指令执行时，它的功能相当于：<br/>Push CS<br/>Push IP<br/>Jmp far ptr 标号<br/><br/><br/>3. 转移地址在寄存器中的call指令。<br/>指令格式：call 16位通用寄存器。<br/>指令执行时，它的功能相当于：<br/>Push IP<br/>Jmp 16位通用寄存器<br/><br/><br/>4. 转移地址在内存中的call指令。<br/>这种call指令有两种格式：<br/>格式1：call word ptr 内存单元地址。<br/>指令执行时，它的功能相当于：<br/>Push IP<br/>Jmp word ptr 内存单元地址<br/><br/>格式2：call dword ptr 内存单元地址。<br/>指令执行时，它的功能相当于：<br/>Push CS<br/>Push IP<br/>Jmp dword ptr 内存单元地址<br/><br/></p><h2><b>6.6 子程序</b></h2><p>Ret指令用栈中的数据修改IP的数值，从而实现近转移。Ret指令执行时，进行下面两步操作：<br/>1. IP =（SS×16＋SP）<br/>2. SP=SP＋2<br/><br/>指令执行时，它的功能相当于：pop IP<br/>学习了call和ret指令，现在来看一下，如何将它们配合使用来实现子程序的机制。请看下面的一段代码：<br/><br/>Mov ax, 1<br/>Mov cx, 3<br/>Call s<br/>Mov bx, ax<br/>Mov ax, 4c00H<br/>Int 21H<br/>S:add ax,ax<br/>Loop s<br/>Ret<br/><br/>我们来分析一下CPU执行这一段代码的过程。<br/>1. CPU执行第一、第二条指令后，CS:IP指向call s。<br/>2. CPU将call s指令的机器码读入，IP指向call s后的指令mov bx, ax。<br/>3. 执行call s指令，将当前IP值（指令mov bx, ax的偏移地址）压入栈中，并将IP的值改变为标号s处的偏移地址。<br/>4. CPU从标号s处执行指令，直至loop指令循环完毕（loop将会循环3次，因为cx=3，cx寄存器用于存放loop循环次数）。<br/>5. CPU指向并执行ret指令，从栈中弹出一个数据（即先前压入栈中的指令mov bx, ax的偏移地址）送入IP，则CS:IP指向指令mov bx, ax。<br/>6. CPU执行指令mov bx, ax。此时bx中存放了ax累加其自身3次的值：3。<br/>7. CPU继续向下执行，直到执行int 21H后，程序结束。</p><p><br/>上面第3、第5项是重点，它揭示了子程序执行完之后，如何让CPU接着call指令向下执行。什么是子程序？具有一定功能的程序段，我们称之为子程序。<br/><br/>比如，上面的那一段代码，s:add ax, bx到ret那3条指令就是一个简单的子程序，它的功能是把ax中的数值累加3次，用循环指令loop实现累加（累加次数由cx中的值决定）。<br/><br/>在需要的时候，我们用call指令转去执行它，执行完子程序后，要让CPU接着call指令向下执行，则需要用到ret指令，call指令转去执行子程序之前，call指令后面的指令的地址将被存储在栈中，在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>另外，在上面的示例代码中，int 21H和MOV AX,4C00H这两条指令又代表什么意思呢？请看下面的图文讲解。</p><p>其实很简单，INT 21H 调用了系统中断。<br/><br/>MOV AX,4C00H，意即：AH=4CH。<br/><br/>那么INT 21H和AH=4CH两者搭配的作用就是：调用 INT 21H 的 4CH 号中断，该中断就是安全退出程序。</p><p>换句话说，MOV AX,4C00H、INT 21H 这两句可以等价于以下两句：<br/>MOV AH,4CH<br/>INT 21H <br/><br/>接下来看看下面的图解，帮助自己理解所谓“中断例程”，实在理解不了也没关系，就当满足知识拓展之需要。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c22922fae407e8fdd44dfe66595bc6a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"252\" class=\"content_image\" width=\"398\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;398&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"252\" class=\"content_image lazy\" width=\"398\" data-actualsrc=\"https://pic1.zhimg.com/v2-c22922fae407e8fdd44dfe66595bc6a4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5342f267533dedcd7b5dc2db574ab164_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"245\" class=\"content_image\" width=\"399\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;399&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"245\" class=\"content_image lazy\" width=\"399\" data-actualsrc=\"https://pic1.zhimg.com/v2-5342f267533dedcd7b5dc2db574ab164_b.jpg\"/></figure><hr/><h2><b>第7章：标志寄存器</b></h2><p><b>引言</b></p><p>CPU内部的寄存器中，有一种特殊的寄存器，它具有以下3种作用：<br/>1. 用来存储相关指令的某些执行结果。<br/>2. 用来为CPU执行相关指令提供行为依据。<br/>3. 用来控制CPU的相关工作方式。<br/><br/>这种特殊的寄存器在8086CPU中，被称为<b>标志寄存器</b>。<br/><br/>8086CPU的寄存器，在前面已经学过13个了，现在学习最后一个寄存器：FR-标志寄存器。<br/><br/>FR与其它寄存器不一样，其它寄存器是用来存放数据的，都是整个寄存器具有一个含义，而FR寄存器是按位起作用的，也就是说它的每一位都有专门的含义，记录特定的信息。<br/><br/>8086CPU的FR寄存器的结构如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;929&#39; height=&#39;124&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_b.png\"/></figure><p><br/>FR的第1、3、5、12、13、14、15位是空白位，在8086CPU中没有使用，不具有任何意义，而第0、2、4、6、7、8、9、10、11位都具有特殊的含义。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>7.1 CF标志</b></h2><p>FR的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br/><br/>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N－1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"829\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"829\" data-original=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;829&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"829\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"829\" data-original=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_b.jpg\"/></figure><p><br/>我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位，比如，两个位数据：98H＋98H，将产生进位，这个进位值就用CF标志位来保存。<br/><br/>比如，下面的指令：<br/>Mov al, 98H<br/>Add al, al<br/><br/>执行后，计算结果为130H，al=30H，CF=1，CF记录了从最高有效位向更高位的进位值。<br/>两数相加，如果产生了进位，则CF=1，如果没有产生进位，则CF=0。<br/><br/>当两个数据做减法的时候，有可能向更高位借位，比如，两个8位数据：97H－98H，将产生借位，借位后相当于计算197H－98H，而FR的CF标志位也可以用来记录这个借位值。<br/><br/>比如，下面的指令：<br/>Mov al, 97H<br/>Sub al, 98H<br/><br/>执行后，计算结果为197H－98H=ffH，al=ffH，CF=1，CF记录了向更高位的借位值。<br/>两数相减，如果产生借位，则CF=1，如果没有产生借位，则CF=0。<br/><br/></p><h2><b>7.2 ADC指令</b></h2><p>Adc是带进位加法指令，它利用了CF位上记录的进位值。<br/>格式：adc 操作对象1，操作对象2<br/>功能：操作对象1=操作对象1＋操作对象2＋CF<br/><br/><br/>例1：<br/><br/>mov ax, 1<br/>Add ax, ax 结果：ax=2，没有产生进位值，CF=0。<br/>Adc ax, 3 结果：ax=ax＋3＋CF=2＋3＋0=5。<br/><br/><br/>例2：<br/><br/>mov al, 98H<br/>Add al, al 结果=130H，产生了进位值，CF=1，al=30H。<br/>Adc al, 3 结果：al=al＋3＋CF=30H＋3＋1=34H。<br/><br/>可以看出，adc指令比add指令多加了一个CF位的值，为什么要加上CF的值呢？CPU为什么要提供这样一条指令呢？<br/>我们来看一下两个数据：0198H和0183H是如何相加的，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-122f429a2d6cbabbabb76edf2ed45712_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"150\" class=\"content_image\" width=\"174\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;174&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"174\" data-actualsrc=\"https://pic3.zhimg.com/v2-122f429a2d6cbabbabb76edf2ed45712_b.png\"/></figure><p><br/>可以看出，加法可以分两步来进行：</p><p>1.低位相加（98＋83）。<br/>2.高位相加再加上低位相加产生的进位值（1＋1＋1）。<br/><br/>看来CPU提供adc指令的目的，就是来进行加法的第二步运算的。用adc指令和add指令相配合就可以对更大的数据进行加法运算。<br/><br/><br/><br/>例3：计算1EF000H＋201000H，结果放在ax（高16位）和bx（低16位）中。<br/>因为两个数据的位数都大于16位，用add指令无法进行计算，我们将计算分两步进行，先将低16位（F000H和1000H）相加，然后将高16位（1EH和20H）和进位值相加，代码如下：<br/><br/>Mov ax, 1eH<br/>Mov bx, f000H<br/>Add bx, 1000H（低16位相加，结果：f000H＋1000H=10000H 产生了进位值，CF=1，bx=0）<br/>Adc ax, 20H（高16位相加，结果：ax=ax＋20H＋CF=1eH＋20H＋1=3fH）<br/><br/>最终结果：ax=3fH，bx=0，1EF000H＋201000H=3f0000H。<br/>Adc指令执行后，也可能产生进位值，所以也会对CF位进行设置，由于有这样的功能，我们就可以对任意大的数据进行加法运算。<br/><br/><br/><br/>例4：计算1EF0001000H＋2010001EF0H，结果放在ax（最高16位），bx（次高16位），cx（低16位）中。<br/><br/>计算分3步进行：<br/>1.先将低16位（1000H和1EF0H）相加，完成后，CF记录本次相加的进位值。<br/>2. 再将次高16位（F000H和1000H）和CF（来自低16位的进位值）相加，完成后，CF记录本次相加的进位值。<br/>3.最后最高16位（1EH和20H）和CF（来自次高16位的进位值）相加，完成后，CF记录本次相加的进位值。<br/><br/>代码如下：<br/>Mov ax, 1eH<br/>Mov bx, f000H<br/>Mov cx, 1000H<br/>Add cx, 1ef0H（低16位相加，结果：1000H＋1ef0H=2ef0H，没有产生进位值，CF=0，cx=2ef0H）<br/>Adc bx, 1000H（次高16位相加，结果：f000H＋1000H＋0=10000H，产生进位值，CF=1，bx=0）<br/>Adc ax, 20H（最高16位相加，结果：ax=ax＋20H＋CF=1eH＋20H＋1=3fH，没有产生进位，CF=0）<br/><br/>最终结果：ax=3fH，bx=0，cx=2ef0H。1EF0001000H＋2010001EF0H=3F00002EF0H。<br/><br/></p><h2><b>7.3 SBB指令</b></h2><p>Sbb是带借位减法指令，它利用了CF位上记录的借位值。<br/><br/>格式：sbb 操作对象1，操作对象2<br/>功能：操作对象1=操作对象1－操作对象2－CF<br/><br/>Sbb指令执行后，将对CF进行设置，利用sbb指令和sub指令配合使用可以对任意大的数据进行减法运算。<br/><br/><br/>例1：计算3E1000H－202000H，结果放在ax（高16位），bx（低16位）。<br/>计算分两步进行，先将低16位（1000H和2000H）相减，然后将高16位（3EH和20H）和借位值相减，代码如下：<br/><br/>Mov bx, 1000H<br/>Mov ax, 3eH<br/>Sub bx, 2000H（低16位相减，结果：1000H－2000H=11000H－2000H=f000H，产生了借位值，CF=1，bx=f000H）<br/>Sbb ax, 20H（高16位相减，结果：ax=ax－20H－CF=3eH－20H－1=1dH，没有产生借位值，CF=0）<br/><br/>最终结果：ax=1dH，bx=f000H，3E1000H－202000H=1DF000H。<br/><br/><br/><br/>例2：计算6E4F0031C0H－1FA2002700H。结果放在ax（最高16位），bx（次高16位），cx（低16位）。</p><p>计算分3步进行：<br/>1. 先将低16位（31C0H和2700H）相减，完成后，CF记录本次相减的借位值。<br/>2. 再将次高16位（4F00H和A200H）和CF（来自低16位的借位值）相减，完成后，CF记录本次相减的借位值。<br/>3. 最后将最高16位（6EH和1FH）和CF（来自次高16位的借位值）相减，完成后，CF记录本次相减的借位值。<br/><br/>代码如下：<br/>Mov ax, 6eH<br/>Mov bx, 4f00H<br/>Mov cx, 31c0H<br/>Sub cx, 2700H（低16位相减，结果：31c0H－2700H=ac0H，没有产生借位值，CF=0，cx=ac0H）<br/>Sbb bx, a200H（次高16位相减，结果：14f00H－a200H=ad00H，产生借位值，CF=1，bx=ad00H）<br/>Sbb ax, 1fH（最高16位相减，结果：ax=ax－1fH－CF=6eH－1fH－1=4eH，没有产生借位值，CF=0）<br/><br/>最终结果：ax=4eH，bx=ad00H，cx=ac0H，6E4F0031C0H－1FA2002700H=4EAD000AC0H。</p><h2><b>7.4 ZF标志</b></h2><p>FR的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果（真），结果为0，那么ZF=1；如果（假），结果非0，那么ZF=0。<br/><br/>对于ZF的值，我们可以这样来看：在计算机中1表示逻辑真，表示肯定，所以当结果为0的时候，ZF=1；在计算机中0表示逻辑假，表示否定，所以当结果不为0的时候，ZF=0。<br/><br/><br/>且看下面的指令：<br/><br/>Mov ax, 5<br/>Sub ax, ax<br/>执行后，结果为0，表示真，则ZF=1。<br/><br/>Mov ax, 5<br/>Sub ax, 1<br/>执行后，结果不为0，表示假，则ZF=0。</p><h2><b>7.5 cmp指令</b></h2><p>Cmp是比较指令，它的功能相当于sub指令，只是不保存结果。Cmp指令执行后，将对标志寄存器产生影响，其它相关指令通过识别这些被影响的标志位来得知比较结果。<br/><br/>指令格式：cmp 操作对象1，操作对象2<br/>功能：计算操作对象1－操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器的标志位进行设置。<br/><br/>Cmp指令执行后，依据标志位的值就可以看出比较结果。<br/><br/>比如，<b>cmp ax, bx</b>执行后：<br/>如果ZF=1，说明ax=bx，因为ax－bx=0，那么ax必定等于bx。<br/>如果ZF=0，说明ax≠bx，因为ax－bx≠0，那么ax与bx必定不相等。<br/>如果CF=1，说明ax＜bx，因为ax－bx产生了借位，那么ax必定小于bx。<br/>如果CF=0，说明ax≥bx，因为ax－bx没有产生借位，那么ax必定大于或等于bx。<br/>如果CF=0，并且ZF=0，说明ax＞bx，因为ax－bx没有产生借位，并且ax－bx≠0，那么ax必定大于bx。<br/>如果CF=1或ZF=1，说明ax≤bx，因为ax－bx产生了借位，又或者ax－bx=0，那么ax必定小于或等于Bx。</p><h2><b>7.6 检测比较结果的条件转移指令</b></h2><p>转移指的是它能够修改IP，而条件指的是它可以根据某种条件，决定是否修改IP，所有条件转移指令都是短转移，转移的位移范围为﹣128~127。 <br/><br/>大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP，它们所检测的标志位都是被cmp指令影响的那些表示比较结果的标志位。<br/><br/><br/>下面是常用的根据无符号数的比较结果进行转移的条件转移指令：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;612&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_b.jpg\"/></figure><p><br/>以上这些条件转移指令是根据检测相关的标志位来决定是否转移，比如：je是检测ZF的值来决定是否转移，如果ZF=1则转移，至于根据逻辑含义来决定是否转移，则需要与cmp指令配合使用，这个在下一节会讲到。</p><h2><br/><b>7.7 cmp与条件转移指令配合使用</b></h2><p>上一节介绍的条件转移指令，所检测的标志位都是cmp指令进行无符号数比较的时候，记录比较结果的标志位，比如，je检测ZF位，当ZF=1时转移，如果在je前面使用了cmp指令，那么je对ZF的检测，实际上是间接地检测cmp的比较结果是否为两数相等。<br/><br/>请看下面一段代码：<br/>Cmp ax, bx<br/>Je s<br/>Add ax, bx<br/>Jmp short ok<br/>S:add ax, ax<br/>ok: … <br/><br/>上面的代码执行时，如果ax=bx,则cmp ax, bx使ZF=1，而je检测ZF是否为1，如果为1，则转移到标号S处执行指令add ax, ax，我们也可以这样说，cmp比较ax, bx后所得到的相等的结果使得je指令进行转移，这种说法很好地体现了je指令的逻辑含义，即“相等则转移“。<br/><br/>“相等则转移”这种逻辑含义是通过和cmp指令配合使用来体现的，我们用cmp指令与条件转移指令配合使用的时候，不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测，因为相关的标志位只是为 Cmp和je等指令传递比较结果，我们可以直接考虑cmp与je等指令配合使用时，表现出来的逻辑含义。<br/><br/><br/>请看下面的指令：<br/><br/>Cmp byte ptr [bx], 8（和8比较）<br/>Je 标号（如果等于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jne 标号（如果不等于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jb 标号（如果低于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jnb 标号（如果不低于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Ja 标号（如果高于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jna 标号（如果不高于则转移）<br/><br/>上面的指令，用[bx]中的数值和8比较，“如果怎么怎么样则转移”，我们在修改游戏时，可以根据这些逻辑含义，选择合适的条件转移指令。</p><p><br/><i><b>妲己师娘：</b>Jb标号，和你的“<b>8</b>”相比较，如果怎么怎么样则<b>转移体位,</b>随着<b>爱的魔力</b>转圈圈！</i></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_b.jpg\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_b.jpg\"/><figcaption>cmp与条件转移指令之迷思：主人的命令是绝对的，爱的魔力转不停，好疯狂！</figcaption></figure><h2><br/><b>7.8 其它标志位</b></h2><p>标志寄存器的大部分标志位，我们都不必深入地去学习，因为这和修改游戏没有多大关系，我们只需简单了解一下即可，FR一共有9个标志位，前面已学习了ZF和CF这两个标志位，现在讲讲余下的7个标志位。<br/><br/>PF：奇偶标志位。它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数，如果（真），1的个数为偶数，PF=1，如果（假），1的个数为奇数，PF=0。<br/><br/>比如，某些指令执行后，其结果二进制值为01001011，有4（偶数）个1，则PF=1；某些指令执行后，其结果二进制值为00001011，有3（奇数）个1，则PF=0。<br/><br/><br/>SF：符号标志位。它记录相关指令执行后，其结果是否为负，如果（真），结果为负，SF=1，如果（假），结果非负，SF=0。<br/><br/><br/>OF：溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出，如果（真），发生了溢出，OF=1，如果（假），没有发生溢出，0F=0。<br/><br/>什么是溢出？在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。那么，机器所能表示的范围是多少呢？对于8位的有符号数据，机器所能表示的范围就是：-128~127；对于16位的有符号数据，机器所能表示的范围就是：﹣32768~32767。如果运算结果超出了机器所能表达的范围，将会产生溢出。<br/><br/>比如，指令：<br/>Mov al, 98<br/>Add al, 99<br/><br/>执行后，al=98＋99=197，197超出了机器所能表示的8位有符号数的范围：﹣128~127，所以产生了溢出。<br/><br/><br/>DF：方向标志位。在串处理指令中，控制每次操作后SI、DI的增减。<br/>DF=0，每次操作后SI、DI递增；DF=1，每次操作后SI、DI递减。<br/><br/>DF标志位与串传送指令（movsb、movsw）有关，而串传送指令与游戏修改无关，所以不讲了（呵呵……）。<br/><br/><br/>TF：跟踪标志位。用于程序调试。<br/>如果TF=1，则CPU处于单步执行指令的工作方式，此时，每执行完一条指令，就显示CPU各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。<br/><br/><br/>AF：辅助进位标志位。在下列情况下，AF的值被设置为1，否则其值为0。<br/>1. 在字操作时，发生低字节向高字节进位或借位时。<br/>2. 在字节操作时，发生低4位向高4位进位或借位时。<br/><br/><br/>IF：中断允许标志位。用来决定CPU是否响应CPU外部的&#34;可屏蔽中断&#34;发出的中断请求，当IF=1，响应中断请求，当IF=0，不响应中断请求。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;716&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_b.jpg\"/></figure><h2><b>7.9 lea和nop指令</b></h2><p>Lea为有效地址传送指令。<br/><br/>格式：lea 操作对象1，操作对象2<br/>功能：将源操作数给出的有效地址传送到指定的寄存器中。<br/>说明：操作对象1为目的操作数，可为任意一个16位的通用寄存器，操作对象2为源操作数，可为地址表达式。<br/><br/>比如，指令：<br/>Lea ax, [217a]<br/>执行后，ax=217aH<br/><br/>Lea ax, [bx＋si＋200]<br/>执行后，ax= bx＋si＋200H<br/><br/><br/>Nop为空操作指令。<br/>格式：nop<br/>功能：本指令不产生任何结果，仅消耗几个时钟周期的时间，接着执行后续指令，常用于程序的延时等待。<br/>其它用途：在修改游戏的时候，可用于锁定某些数据的数值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9b119ec08b69de712cac734fe4d0d4a2_b.jpg\" data-size=\"normal\" data-rawwidth=\"1357\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb\" width=\"1357\" data-original=\"https://pic3.zhimg.com/v2-9b119ec08b69de712cac734fe4d0d4a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1357&#39; height=&#39;641&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1357\" data-rawheight=\"641\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1357\" data-original=\"https://pic3.zhimg.com/v2-9b119ec08b69de712cac734fe4d0d4a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9b119ec08b69de712cac734fe4d0d4a2_b.jpg\"/><figcaption>Nop锁定机械姬 • 邪恶大师娘的所有欲念数据——色即是空</figcaption></figure><hr/><h2><b>第8章：寄存器（功能详解）</b></h2><p><b>引言</b></p><p>本章对各种寄存器的功能进行详细的讲解，并且把32位寄存器和16位寄存器合并讲解。<br/><br/><u>32位寄存器有16个，分别是：</u><br/>4个数据寄存器（EAX、EBX、ECX、EDX）。<br/>2个变址寄存器（ESI、EDI）。<br/>2个指针寄存器（ESP、EBP）。<br/>6个段寄存器（ES、CS、SS、DS、FS、GS）。<br/>1个指令指针寄存器（EIP）。<br/>1个标志寄存器（EFlags）。<br/><br/></p><h2><b>8.1 数据寄存器</b></h2><p>数据寄存器主要用来保存操作数和运算结果等信息，从而节省读取操作数所需占用总线和访问存储器（内存）的时间。<br/><br/>32位CPU有4个32位通用寄存器：EAX、EBX、ECX和EDX。<br/><br/>低16位寄存器分别是：AX、BX、CX和DX。它们和8086CPU中的寄存器相一致。 对低16位数据的取存，不会影响高16位的数据。<br/><br/>4个16位寄存器又可分割成8个独立的8位寄存器（AX：ah~al、BX：bh~bl、CX：ch~cl：DX：dh~dl）。<br/><br/>每个寄存器都有自己的名称，可独立存取。程序员可利用数据寄存器的这种“可合可分”的特性，灵活地处理字/字节的信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>为加深数据寄存器&#34;可合可分&#34;的印象，插播一篇：鬼谷子 • 捭阖第一</b></p><p><i>粤若稽古，圣人之在天地间也，为众生之先，观阴阳之开阖以名命物，知存亡之门户。筹策万类之终始，达人心之理，见变化之联焉，而守司其门户。</i><br/><i><u>故圣人之在天下也，自古及今，其道一也。变化无穷，各有所归。或阴或阳，或柔或刚，或开或闭，或驰或张。是故圣人一守司其门户，审察其先后，度权量能，校其伎巧短长。</u></i></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c66c4d66a9301204ce703d6e7eb39c95_b.jpg\" data-size=\"normal\" data-rawwidth=\"1518\" data-rawheight=\"733\" class=\"origin_image zh-lightbox-thumb\" width=\"1518\" data-original=\"https://pic2.zhimg.com/v2-c66c4d66a9301204ce703d6e7eb39c95_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1518&#39; height=&#39;733&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1518\" data-rawheight=\"733\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1518\" data-original=\"https://pic2.zhimg.com/v2-c66c4d66a9301204ce703d6e7eb39c95_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c66c4d66a9301204ce703d6e7eb39c95_b.jpg\"/><figcaption>数据寄存器“可合可分”特性之鬼谷子 • 捭阖术之遐想</figcaption></figure><p><br/><br/><br/> AX和al通常称为累加器，用累加器进行的操作可能需要更少时间，累加器可用于乘、除、输入/输出等操作，它们的使用频率很高。<br/><br/>BX称为基地址寄存器，它可作为存储器指针来使用。<br/><br/>CX称为计数寄存器，在循环时，要用它来控制循环次数；在字符串操作（即位移操作）时，需要用cl来指明位移的位数。<br/><br/>DX称为数据寄存器，在进行乘、除运算时，它可以为默认的操作数参与运算，也可用于存放I/O的端口地址。<br/><br/>在16位CPU中，AX、BX、CX和DX不能作为基址和变址寄存器来存放存储单元的地址，但在32位CPU中，其32位寄存器EAX、EBX、ECX和EDX不仅可传送数据、暂存数据、保存算术逻辑运算结果，而且也可作为指针寄存器，所以，这些32位寄存器更具有通用性。<br/><br/></p><h2><b>8.2 变址寄存器</b></h2><p>32位CPU有2个32位通用寄存器ESI和EDI，其低16位对应先前介绍的CPU中的SI和DI，对低16位数据的存取，不影响高16位的数据。<br/><br/>ESI、EDI、SI和DI称为变址寄存器，它们主要用于存放存储单元在段内的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。<br/><br/>变址寄存器不可分割成8位寄存器，作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。<br/><br/>它们可作一般的存储器指针使用，在字符串操作指令的执行过程中，对它们有特定的要求，而且还具有特殊的功能。<br/><br/></p><h2><b>8.3 指针寄存器</b></h2><p>32位CPU有2个32位通用寄存器EBP和ESP，其低16位对应先前介绍的CPU中的BP和SP，对低16位数据的存取，不影响高16位的数据。<br/><br/>EBP、ESP、BP和SP称为指针寄存器，主要用于存放堆栈内存储单元的偏移量，用它们可实现多种存储器操作数的寻址方式，为以不同的地址形式访问存储单元提供方便。<br/><br/>指针寄存器不可分割成8位寄存器，作为通用寄存器，也可存储算术逻辑运算的操作数和运算结果。<br/><br/>指针寄存器主要用于访问堆栈内的存储单元，并且以下两条规定：<br/>一：BP为基指针寄存器，用它可直接存取堆栈中的数据。<br/>二：SP为堆栈指针寄存器，用它只可访问栈顶。<br/><br/></p><h2><b>8.4 段寄存器</b></h2><p>段寄存器是根据内存分段的管理模式而设置的。内存单元的物理地址由段寄存器的值和一个偏移量组合而成的，这样可用两个较少位数的值组合成一个可访问较大物理空间的内存地址。<br/><br/>32位CPU有6个段寄存器，分别如下。<br/>CS：代码段寄存器    <br/>ES：附加段寄存器<br/>DS：数据段寄存器    <br/>FS：附加段寄存器<br/>SS：堆栈段寄存器    <br/>GS：附件段寄存器<br/><br/>在16位CPU系统中，只有4个段寄存器，所以，程序在任何时刻至多有4个正在使用的段可直接访问，在32位微机系统中，它有6个段寄存器，所以在此环境下开发的程序最多可同时访问6个段。<br/><br/>32位CPU有两个不同的工作方式：实方式和保护方式。在每种方式下，段寄存器的作用是不同的，有关规定简单描述如下。<br/><br/>实方式：段寄存器CS、DS、ES和SS与先前介绍的CPU中的所对应的段寄存器的含义完全一致，内存单元的逻辑地址仍为“段地址：偏移地址”的形式，为访问某内存段内的数据，必须使用该段寄存器和存储单元的偏移地址。<br/><br/>保护方式：在此方式下，情况要复杂得多，装入段寄存器的不再是段值，而是称为“选择子”的某个值。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>8.5 指令指针寄存器</b></h2><p>32位CPU把指令指针扩展到32位，并记作EIP，EIP的低16位与先前介绍的CPU中的IP作用相同。<br/><br/>指令指针EIP、IP是存放下次将要执行的指令在代码段的偏移地址，在具有预取指令功能的系统中，下次要执行的指令通常已被预取到指令队列中，除非发生转移情况，所以，在理解它们的功能时，不考虑存在指令队列的情况。<br/><br/>在实方式下，由于每个段的最大范围为64KB，所以，EIP的高16位肯定都为0，此时，相当于只用其低16位的IP来反映程序中的指令的执行次序。<br/><br/></p><h2><b>8.6  标志寄存器(详解)</b></h2><p>16位标志寄存器有9个标志位，可以分为两大类：<br/><br/>1.运算结果标志位。一共6个，包括：CF进位标志位、PF奇偶标志位、AF辅助进位标志位、ZF零标志位、SF符号标志位、OF溢出标志位。<br/><br/>2.状态控制标志位。一共3个，包括：TF追踪标志位、IF中断允许标志位、DF方向标志位。<br/>以上标志位在第7章里都讲过了，在这里就不再解释了。</p><p><br/>现在讲讲32位标志寄存器增加的4个标志位。<br/><br/>1. I/O特权标志IOPL。<br/>IOPL用两位二进制位来表示，也称为I/O特权级字段，该字段指定了要求执行I/O指令的特权级，如果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。<br/><br/>2. 嵌套任务标志NT。<br/>NT用来控制中断返回指令IRET的执行。具体规定如下：<br/>（1） 当NT=0，用堆栈中保存的值恢复EFlags、CS和EIP，执行常规的中断返回操作。<br/>（2） 当NT=1，通过任务转换实现中断返回。<br/><br/>3. 重启动标志RF。<br/>RF用来控制是否接受调试故障。规定：RF=0时，表示接受，否则拒绝。<br/><br/>4. 虚拟8086方式标志VM。<br/>如果VM=1，表示处理器处于虚拟的8086方式下的工作状态，否则，处理器处于一般保护方式下的工作状态。<br/><br/></p><h2><b>8.7 32位地址的寻址方式</b></h2><p>最后说一下32位地址的寻址方式。在前面我们学习了16位地址的寻址方式，一共有5种，在32位微机系统中，又提供了一种更灵活、方便但也更复杂的内存寻址方式，从而使内存地址的寻址范围得到了进一步扩大。<br/><br/>在用16位寄存器来访问存储单元时，只能使用基地址寄存器（BX和BP）和变址寄存器（SI和DI）来作为偏移地址的一部分，但在用32位寄存器寻址时，不存在上述限制，所有32位寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP、和ESP）都可以是偏移地址的一个组成部分。<br/><br/>当用32位地址偏移量进行寻址时，偏移地址可分为3部分：<br/>1. 一个32位基址寄存器（EAX、EBX、ECX、EDX、ESI、EDI、EBP、ESP）。<br/>2. 一个可乘以1、2、4、8的32位变址寄存器（EAX、EBX、ECX、EDX、ESI、EDI和EBP）。<br/>3. 一个8位~32位的偏移常量。<br/><br/>比如，指令：mov ebx, [eax＋edx*2＋300]<br/>eax就是基址寄存器，edx就是变址寄存器，300H就是偏移常量。<br/><br/>上面那3部分可进行任意组合，省去其中之一或之二。<br/><br/><br/>下面列举几个32位地址寻址指令：<br/>Mov ax,  [123456]<br/>Mov eax,  [ebx]<br/>Mov ebx,  [ecx*2]<br/>Mov ebx,  [eax＋100]<br/>Mov ebx,  [eax*4＋200]<br/>Mov ebx,  [eax＋edx*2]<br/>Mov ebx,  [eax＋edx*4＋300]<br/>Mov ax,  [esp]<br/><br/>由于32位寻址方式能使用所有的通用寄存器，所以，和该有效地址相组合的段寄存器也就有新的规定，具体规定如下：<br/><br/>1. 地址中寄存器的书写顺序决定该寄存器是基址寄存器还是变址寄存器。如：[ebx＋ebp]中的ebx是基址寄存器，ebp是变址寄存器，而[ebp＋ebx]中的ebp是基址寄存器，ebx是变址寄存器，可以看出，左边那个是基址寄存器，另一个是变址寄存器。<br/><br/>2. 默认段寄存器的选用取决于基址寄存器。<br/><br/>3. 基址寄存器是ebp或esp时，默认的段寄存器是SS，否则，默认的段寄存器是DS。<br/><br/>4. 在指令中，如果显式地给出段寄存器，那么显式段寄存器优先。<br/><br/><br/>下面列举几个32位地址寻址指令及其内存操作数的段寄存器。<br/><br/> <b>指令列举：</b> <b>访问内存单元所用的段寄存器</b><br/> mov ax, [123456]（默认段寄存器为DS）<br/> mov ax,  [ebx＋ebp]（默认段寄存器为DS）<br/> mov ebx,  [ebp＋ebx] （默认段寄存器为SS）<br/> mov ebx,  [eax＋100] （默认段寄存器为DS）<br/> mov edx,  ES:[eax*4＋200]（显式段寄存器为ES）<br/> mov [esp＋edx*2], ax（默认段寄存器为SS）<br/> mov ebx,  GS:[eax＋edx*8＋300]（显式段寄存器为GS）<br/> mov ax, [esp]（默认段寄存器为SS）</p><hr/><h2><b>第9章：与游戏修改相关的汇编指令</b></h2><p><b>引言</b><br/><br/>汇编指令总共116个,其中与游戏修改相关的指令大约20个,我们对这20个指令进行一下分类：<br/><br/>1. 传送指令（4个）：mov、push、pop、lea。<br/>2. 转移指令（8个）：call、jmp、je、jne、jb、jnb、ja、jna。<br/>3. 运算指令（7个）：add、sub、mul、div、adc、sbb、cmp。<br/>4. 处理器控制指令（1个）：nop。<br/><br/>以上这些指令，我们在前面的章节中都已学过了，在本章中用表格的形式进行总结性的描述，包括：指令的名称、类型、格式、功能、说明、示例。<br/><br/>如果你在修改游戏的时候，忘掉了某个指令的用法，可直接在本章中查询。<br/><br/></p><h2><b>9.1 传送指令</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c85efd0301075aee69ec75a1a6bda659_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb\" width=\"846\" data-original=\"https://pic2.zhimg.com/v2-c85efd0301075aee69ec75a1a6bda659_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;846&#39; height=&#39;465&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"465\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"846\" data-original=\"https://pic2.zhimg.com/v2-c85efd0301075aee69ec75a1a6bda659_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c85efd0301075aee69ec75a1a6bda659_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-da4f6c18fcd9e8b8557cc38738a023fa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic3.zhimg.com/v2-da4f6c18fcd9e8b8557cc38738a023fa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic3.zhimg.com/v2-da4f6c18fcd9e8b8557cc38738a023fa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-da4f6c18fcd9e8b8557cc38738a023fa_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f6208d78f8bfd242ce539aa701ac988d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-f6208d78f8bfd242ce539aa701ac988d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;431&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"431\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-f6208d78f8bfd242ce539aa701ac988d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f6208d78f8bfd242ce539aa701ac988d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a82d7a9fe1ffc73f837cd2ec96a2e5f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"405\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic2.zhimg.com/v2-a82d7a9fe1ffc73f837cd2ec96a2e5f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;405&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"405\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic2.zhimg.com/v2-a82d7a9fe1ffc73f837cd2ec96a2e5f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a82d7a9fe1ffc73f837cd2ec96a2e5f9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>9.2 转移指令</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cd75c433d14d42917f58b9a2e719bcf1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-cd75c433d14d42917f58b9a2e719bcf1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-cd75c433d14d42917f58b9a2e719bcf1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cd75c433d14d42917f58b9a2e719bcf1_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8ca3411aebc25460d72898f1d313f91a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-8ca3411aebc25460d72898f1d313f91a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-8ca3411aebc25460d72898f1d313f91a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8ca3411aebc25460d72898f1d313f91a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e8498ac0fad0592a40e58711084f8c7d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic2.zhimg.com/v2-e8498ac0fad0592a40e58711084f8c7d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic2.zhimg.com/v2-e8498ac0fad0592a40e58711084f8c7d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e8498ac0fad0592a40e58711084f8c7d_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0bcb63c6a1c285f0dcd2281242b40751_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-0bcb63c6a1c285f0dcd2281242b40751_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic2.zhimg.com/v2-0bcb63c6a1c285f0dcd2281242b40751_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0bcb63c6a1c285f0dcd2281242b40751_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7643b76ce88b94c5341729c34cce3216_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-7643b76ce88b94c5341729c34cce3216_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;133&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-7643b76ce88b94c5341729c34cce3216_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7643b76ce88b94c5341729c34cce3216_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-abbd51c116574a16d34eabb591ffd65f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"177\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-abbd51c116574a16d34eabb591ffd65f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;177&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"177\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic4.zhimg.com/v2-abbd51c116574a16d34eabb591ffd65f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-abbd51c116574a16d34eabb591ffd65f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7e36f267362710cc3639e00e59000cb1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"842\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb\" width=\"842\" data-original=\"https://pic2.zhimg.com/v2-7e36f267362710cc3639e00e59000cb1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;842&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"842\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"842\" data-original=\"https://pic2.zhimg.com/v2-7e36f267362710cc3639e00e59000cb1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7e36f267362710cc3639e00e59000cb1_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ac6518bfeff738d2fd0db06453cfcb88_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb\" width=\"846\" data-original=\"https://pic1.zhimg.com/v2-ac6518bfeff738d2fd0db06453cfcb88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;846&#39; height=&#39;133&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"133\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"846\" data-original=\"https://pic1.zhimg.com/v2-ac6518bfeff738d2fd0db06453cfcb88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ac6518bfeff738d2fd0db06453cfcb88_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>9.3 运算指令</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-62caef8366705f71be0b64a64c97a3a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"558\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic4.zhimg.com/v2-62caef8366705f71be0b64a64c97a3a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;558&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"558\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic4.zhimg.com/v2-62caef8366705f71be0b64a64c97a3a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-62caef8366705f71be0b64a64c97a3a3_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0079a29fabc9ae52b46144bc482413ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-0079a29fabc9ae52b46144bc482413ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;260&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"260\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-0079a29fabc9ae52b46144bc482413ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0079a29fabc9ae52b46144bc482413ff_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aa03a08f0beec5855b73b756fea8d786_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-aa03a08f0beec5855b73b756fea8d786_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"386\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-aa03a08f0beec5855b73b756fea8d786_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aa03a08f0beec5855b73b756fea8d786_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a1de0dcd5511317557c8bb4c8b8bbbd4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic1.zhimg.com/v2-a1de0dcd5511317557c8bb4c8b8bbbd4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;516&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"516\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic1.zhimg.com/v2-a1de0dcd5511317557c8bb4c8b8bbbd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a1de0dcd5511317557c8bb4c8b8bbbd4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bfa29dd1f3a5868cd6bcffd02c38000a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-bfa29dd1f3a5868cd6bcffd02c38000a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;843&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"843\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"843\" data-original=\"https://pic3.zhimg.com/v2-bfa29dd1f3a5868cd6bcffd02c38000a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bfa29dd1f3a5868cd6bcffd02c38000a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-43ef934bf05435e1206d982df9e6f24e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-43ef934bf05435e1206d982df9e6f24e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic3.zhimg.com/v2-43ef934bf05435e1206d982df9e6f24e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-43ef934bf05435e1206d982df9e6f24e_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5e480ae4ff70886dbe1dc1977800e0bf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-5e480ae4ff70886dbe1dc1977800e0bf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;473&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-5e480ae4ff70886dbe1dc1977800e0bf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5e480ae4ff70886dbe1dc1977800e0bf_b.jpg\"/></figure><h2><b>9.4  处理器控制指令</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-76831cabf76854f7a8643725f2d23f03_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-76831cabf76854f7a8643725f2d23f03_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;844&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"844\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"844\" data-original=\"https://pic4.zhimg.com/v2-76831cabf76854f7a8643725f2d23f03_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-76831cabf76854f7a8643725f2d23f03_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>果壳 • 鬼谷子大法：“乃可以纵，乃可以横，而无敌于天下” </b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4ff1225fa5623ee904c59bc5af2b564d_b.jpg\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"543\" class=\"origin_image zh-lightbox-thumb\" width=\"864\" data-original=\"https://pic2.zhimg.com/v2-4ff1225fa5623ee904c59bc5af2b564d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;864&#39; height=&#39;543&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"864\" data-rawheight=\"543\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"864\" data-original=\"https://pic2.zhimg.com/v2-4ff1225fa5623ee904c59bc5af2b564d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4ff1225fa5623ee904c59bc5af2b564d_b.jpg\"/><figcaption>妲己师娘的使命完成了——32位寻址全身——乃可以纵,乃可以横。</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2>（全书完）</h2><h2><b>本书由果壳王子撰写，如有雷同，那就雷同！</b></h2><p><br/><b><i>果壳王子微信：gkwz1983</i></b></p><p><b><i>果壳学院QQ群：1群（327610461）、2群（465560580）</i></b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "汇编入门书籍", 
                    "tagLink": "https://api.zhihu.com/topics/19999182"
                }, 
                {
                    "tag": "汇编语言（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20731784"
                }
            ], 
            "comments": [
                {
                    "userName": "吃一口草莓", 
                    "userLink": "https://www.zhihu.com/people/7501cd04353409e9286f2313b7a2bba2", 
                    "content": "<p>讲的很好</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/72016353", 
            "userName": "果壳王子", 
            "userLink": "https://www.zhihu.com/people/440030a7b7bc3da48675ff7d4ba115ba", 
            "upvote": 51, 
            "title": "果壳疯狂编程：汇编语言从入门到神通", 
            "content": "<p><b>第一章：汇编基础知识</b></p><p><b>引</b> <b>言</b></p><p>学习CE(游戏修改工具)不得不先了解相关汇编知识。如同爱必经纯洁的革命友谊升华到初恋，才会懂得爱情，才会成长。</p><p>汇编语言是和具体的微处理器相联系的，每一种微处理器的汇编语言都不一样，因此我们只能通过一种常用的结构简洁的微处理器汇编语言来进行学习。</p><p>本书采用8086CPU为中央处理器的计算机进行讲解。8086CPU结构简洁，便于疯狂式汇编教学。</p><p><i>最疯狂且优美的，应是最简洁而有力度的。</i></p><p><b>── 果壳学院疯狂编程 ● 汇编之美</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.1</b> <b>机器语言</b></h2><p>说到汇编语言的产生，首先要讲一下机器语言。机器语言是机器指令的集合。什么是机器指令？我们在使用CE时，常常见到。请看下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6f3a7a7d002415184bce5a6e5cd4f15d_b.jpg\"/></figure><p>图中所示的就是机器指令（或称机器码），这是十六进制的，如果要让计算机识别，则必须是二进制的。</p><p>例如机器指令 89 5C 24 38 转为二进制是10001001010111000010010000111000。你看得懂这条机器指令的具体含义是什么吗？不懂是吧，我也不懂。可见，机器指令是如此晦涩难懂，于是汇编语言便孕育而生了。汇编语言是程序猿中的普罗米修斯为猿类盗取的编程圣火！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;457&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5f9f4d1757ff8d515f5b0767377cdf94_b.jpg\"/></figure><p><br/><b>上帝说，要有光，于是便有了光……</b></p><p><b> ──《圣经 ●</b> <b>创世纪》</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.2 汇编语言</b></h2><p>汇编语言的主体是汇编指令，汇编指令我们在使用CE时，也是常常见到。见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-551c3f2bba2c4dcd7ba2d95e9c6a3872_b.jpg\"/></figure><p>汇编指令和机器指令是一一对应的。比如：机器指令 89D8和汇编指令mov ax,bx的含义是相同的，然而我们很难懂89D8的含义是什么，mov ax,bx的含义一看就懂了，其含义是：把寄存器bx中的数据传送给ax。汇编指令的写法与人类语言接近，便于阅读和记忆。既然有了如此简明易懂的汇编指令，为什么不把机器指令抛弃掉？因为计算机指令最终是由CPU来执行的，但是CPU只认识机器指令，不认识汇编指令。简言之：汇编指令是给人看的，机器指令是给狗看的──不对，是给CPU看的（写得太入戏，有点儿鸡动)。</p><p>有一个东西可以把汇编指令翻译成机器指令，这个东西就是汇编语言编译器。</p><p>程序员用汇编语言写出源程序，再用编译器将其编译为机器码，由计算机最终执行，下图描述了这个工作过程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;638&#39; height=&#39;118&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"638\" data-rawheight=\"118\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"638\" data-original=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e0f0bf8247a610a16d15ef62c416d958_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.3 指令和数据</b></h2><p>CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU工作，就必须向它提供指令和数据，指令和数据在存储器中存放。存储器也就是我们平常说的内存。</p><p>在内存中，<u>指令和数据没有任何本质上的区别</u>，都是二进制信息，只不过CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，即为同样的信息赋予了不同的意义！就好比同样叫“黑呀呀”，有的同学理解为可爱的黑鸭鸭，有的同学理解为冷艳执鞭黑衣女教师——是不是很有画面感？又如围棋的棋子，在棋盒里的时候没有任何区别，在对弈的时候就有了不同的意义。</p><p>同样，内存中的二进制信息 1000100111011000，计算机既可以把它看作 89D8H 数据本身来处理，也可以把它看作指令 mov ax,bx 来处理。</p><p>1000100111011000 → 89D8H（数据）</p><p>1000100111011000 → mov ax,bx（指令）</p><p>那么，CPU在什么时候把它看作数据？在什么时候把它看作指令呢？这个在后面会讲到。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.4 存储单元</b></h2><p>存储器被划分成若干个存储单元，每个存储单元从0开始顺序编号，例如一个存储器有128个存储单元，编号从0~127，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0162f0161c2a8695b22dc425c89bd001_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"165\" data-rawheight=\"434\" class=\"content_image\" width=\"165\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;165&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"165\" data-rawheight=\"434\" class=\"content_image lazy\" width=\"165\" data-actualsrc=\"https://pic2.zhimg.com/v2-0162f0161c2a8695b22dc425c89bd001_b.png\"/></figure><p>那么一个存储单元能存储多少信息呢？我们知道计算机的最小信息单位是bit，也就是一个二进制位，8个bit组成一个Byte，也就是通常讲的一个字节，微机存储器的一个存储单元可以存储一个Byte，即8个bit（8个二进制位），一个存储器有128个存储单元，它可以存储128个Byte。</p><p>微机存储器的容量是以字节为最小单位来计算的，对于拥有128个存储单元的存储器，我们可以说它的容量是128个字节。</p><p>对于大容量的存储器，一般还用以下单位来计量容量（以下用B代表Byte）。</p><p>1KB=1024B  1MB=1024KB  1GB=1024MB  1TB=1024GB</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.5 CPU对存储器的读写</b></h2><p>以上讲到，存储器被划分成多个存储单元，存储单元从0开始顺序编号，这些编号就是存储单元的内存地址，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f39aff77f0baa392d83ec62c09722e75_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"187\" data-rawheight=\"500\" class=\"content_image\" width=\"187\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;187&#39; height=&#39;500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"187\" data-rawheight=\"500\" class=\"content_image lazy\" width=\"187\" data-actualsrc=\"https://pic2.zhimg.com/v2-f39aff77f0baa392d83ec62c09722e75_b.png\"/></figure><p>CPU要从内存中读取或写入数据，首先要指定内存地址，并指明要对哪一个器件进行操作，是读取数据还是写入数据，因而，CPU要想进行数据的读写，必须和外部器件的芯片进行下面3类信息的交互：</p><p>1：内存地址（地址信息）</p><p>2：器件的选择，读或写命令（控制信息）</p><p>3：读或写的数据（数据信息）</p><p>那么CPU是通过什么将地址、控制信息和数据传到内存中呢？是导线，是连接CPU和其他芯片的导线，通常称之为总线。</p><p>根据传送信息的不同，总线从逻辑上分为3类：地址总线、控制总线、数据总线。</p><p>CPU从内存3读取数据的过程如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;633&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"633\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"633\" data-original=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-49464c47ef1fa174563f17a13d6af957_b.jpg\"/></figure><p>1：CPU通过地址线将地址信息3发出。</p><p>2：CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据。</p><p>3：存储器将内存地址3中的数据8通过数据线送入CPU。</p><p>写入数据的过程和读取数据的过程相似。例如向内存地址3写入数据26，操作步骤如下。</p><p>1：CPU通过地址线将地址信息3发出。</p><p>2：CPU通过控制线发出内存写命令，选中存储器芯片，并通知它，将要从中写入数据。</p><p>3：CPU通过数据线将数据26送入内存地址3的存储单元中。</p><p>从上面我们知道了CPU是如何进行数据读写的工作原理，可是，如何发出具体指令命令计算机进行数据读写呢？这就需要依靠能够驱动它进行工作的简洁而有力的机器指令了！</p><p>对于8086CPU，下面的机器指令就能够完成从内存地址3的存储单元中读取数据的操作。</p><p>机器指令：101000000000001100000000</p><p>汇编指令：mov ax,[3]</p><p>含义：从内存地址3的存储单元读取数据送入寄存器ax中。</p><hr/><h2><b>第2章：寄存器(CPU工作原理)</b></h2><p><b>引</b> <b>言</b></p><p>一个典型的CPU，由运算器、控制器、寄存器等器件组成，对于游戏修改者来说，重点学习寄存器，其它不必管。</p><p>不同的CPU，寄存器的个数、结构是不相同的，8086CPU有14个寄存器，每个寄存器有一个名称，我们对它进行分类：</p><p>1． 通用寄存器：AX、BX、CX、DX</p><p>2． 段寄存器：CS、SS、DS、ES</p><p>3． 指针寄存器：SP、BP</p><p>4． 变址寄存器：SI、DI</p><p>5． 指令指针寄存器：IP</p><p>6． 标志寄存器：FR</p><p>以上寄存器都是16位的，更古老的CPU的寄存器是8位的，这个就不讲了。现在的CPU的寄存器是32位的，这个将在后续章节中与16位寄存器一起讲解。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.1 通用寄存器</b></h2><p>AX、BX、CX、DX这4个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p><p>以AX为例，寄存器的逻辑结构图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb\" width=\"673\" data-original=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;673&#39; height=&#39;139&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"673\" data-original=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d9478e1c06f56baf3c9bbcc86713ab72_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一个16位寄存器可以存储一个16位的数据，数据在寄存器中的存放情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b03eaac99802026bd5bf5dec8462b90a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>黑呀呀提问：一个16位寄存器所能存储的数据的最大值是多少？</p><p>王子答曰：16位即16个bit，16个bit等于2个字节，范围从0~65535，最大值是65536B，因为1KB=1024B，65536B÷1024B=64KB，所以最大值是64KB。</p><p>8086CPU的AX、BX、CX、DX这4个寄存器为了兼容8位寄存器，每个寄存器都可以分为两个可独立使用的8位寄存器。</p><p>AX可分为AH和AL，BX可分为BH和BL，CX可分为CH和CL，DX可分为DH和DL。</p><p>8086CPU的16位寄存器分为2个8位寄存器的情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;217&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e27794c75fd571f57d3255fd77365129_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>AX的低8位（0位~7位）构成了AL寄存器，高8位（8~15位）构成了AH寄存器。对于AH和AL的名字可以这样理解：H=High（高的），L=Low（低的）。AH和AL寄存器都是可以独立使用的8位寄存器，下图展示了16位寄存器及它所分成的2个8位寄存器的数据存储的情况：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;398&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"398\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a577f3f6b7474faffb1507ad56a66f8f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>小洁儿提问：一个8位寄存器所能存储的数据的最大值为多少？</p><p>王子答曰：8位即8个bit，8个bit等于1个字节，范围从0~255，所以最大值是256B。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.2 字在寄存器中的存储</b></h2><p>字节，即为byte，一个字节由8个bit组成。字，即为word，一个字由两个字节组成，这两个字节分别称为这个字的高位字节和低位字节，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb\" width=\"426\" data-original=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;426&#39; height=&#39;138&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"138\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"426\" data-original=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5e27122067ce36ff0422bd507501df10_b.jpg\"/></figure><p>一个字可以存在一个16位寄存器中，这个字的高位字节和低位字节分别存在这个寄存器的高8位寄存器和低8位寄存器中。</p><p>大师娘卡特黑兰：“说了半天，这都是干嘛用的，这和咱们要学的CE有几毛钱关系鸭？”</p><p>王子曰：“切莫性急(渴)，温火方能煲靓汤，提前热身——方能长久作战！”</p><p>“燃烧我的卡路里！”</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6fcc597f6d110023552371bb4e5493b5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.3 物理地址</b></h2><p>在1.４节我们学习了存储单元，存储单元又叫内存单元，以后我们多数用内存单元这一名称。</p><p>所有的内存单元构成的存储空间是一个一维的线性空间，每一个内存单元在这个空间中都有唯一的地址，我们将这个唯一的地址称为物理地址。</p><p>CPU通过地址总线送入内存的，必须是一个内存单元的物理地址，在CPU向地址总线上发出物理地址之前，必须要在内部先形成这个物理地址，不同的CPU可以有不同的形成物理地址的方式，我们现在讨论8086CPU是如何在内部形成内存单元的物理地址的。</p><p>在进入下一个小节深入讲解8086CPU如何给出物理地址的方法之前，我们先分享一则圣经小故事，放松一下肌肉和心情。</p><p>上帝使他沉睡，他就睡了，于是上帝取下他一条肋骨，又把肉合起来（旁白：“哇靠这都行！”）。</p><p>耶和华(又名“爷火化”)就用那人身上所取的肋骨，造出一个女人，领她到那人跟前（那会儿福利可真好）。</p><p>那人便是亚当，当他醒来看到上帝这一件新作品时，便说道：“这是我的骨中骨、肉中肉，可以称她为女人，因她是从男人身上取出来的。”</p><p>于是，美丽的夏娃诞生了！她和亚当幸福快乐地生活在伊甸园……据说后来，夏娃在苹果树下偷吃了一个苹果，并把那苹果带回来分给亚当吃……自此以后，他们就更觉幸福了……</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8807b41f11c13a1e4db39dde0ba9a256_b.jpg\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"239\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"239\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic3.zhimg.com/v2-8807b41f11c13a1e4db39dde0ba9a256_b.jpg\"/><figcaption>（别太入戏）</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.4 8086CPU给出物理地址的方法</b></h2><p>8086CPU有20位地址总线，最多可以传送20位地址，然而8086CPU内部结构是16位的，一次性只能传送16位的地址，那么怎么解决20位地址（总线）与16位地址（内部结构）不一致的问题呢？8086CPU采用一种在内部用2个16位地址合成的方法来形成一个20位的物理地址。</p><p>当8086CPU要读写内存时，怎样在CPU内部形成物理地址的呢？</p><p>1：CPU中的相关部件提供2个16位的地址，一个称为段地址，另一个称为偏移地址。</p><p>2：段地址和偏移地址通过内部总线送入一个称为地址加法器的部件。</p><p>3：地址加法器将这两个16位地址合成为1个20位的物理地址。</p><p>地址加法器采用“段地址×16＋偏移地址”的方法合成物理地址。即：<b>段地址×16＋偏移地址=物理地址</b>。</p><p>“段地址×16”可以理解为段地址的16倍(段地址的十进制数*16)。以下这个说法更好理解。</p><p>我们把16转化为十六进制10，然后计算一下。假设段地址=2A7，2A7×10=2A70，计算结果2A70相对于段地址2A7左移了一位，所以，段地址×16可以理解为：段地址左移一位。</p><p>请问同学们：“如果段地址=A100，偏移地址=42B，那么，物理地址=？”</p><p>聪明如你，一定知道这个答案：“段地址×16=段地址左移一位，即A100左移一位=A1000，A1000＋42B=A142B，所以，物理地址是：A142B”</p><p>8086CPU要访问地址为123C8H的内存单元，此时，地址加法器的工作过程如下图所示（图中数据皆为十六进制表示）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d21113abdd7e3a501df1699ca7a23dd6_b.jpg\"/></figure><p>段地址×16又叫基础地址，所以，物理地址=基础地址＋偏移地址。（旁白：有没有感觉到，CE中的基址和偏移的概念慢慢浮出了水面？）</p><p>观察下面的地址，你有什么发现？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;504&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"504\" data-rawheight=\"200\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"504\" data-original=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2550dc42ec377a6da1e268b7100ae1be_b.jpg\"/></figure><p>结论：CPU可以用不同的段地址和偏移地址形成同一个物理地址。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.5 CS和IP</b></h2><p>8086CPU在访问内存时，要由相关部件提供内存单元的段地址和偏移地址，然后送入地址加法器合成物理地址，那么，是什么部件提供段地址呢？是段寄存器提供段地址！8086CPU有4个段寄存器：CS、DS、SS、ES，本章先讲解CS。</p><p>CS和IP是8086CPU中2个最为关键的寄存器，它们指示了CPU当前要读取指令的地址，我们看一下CE，可以看出在游戏中，什么是CPU要读取的指令地址，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;660&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"660\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"660\" data-original=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2c007806fe1ad65e7cb8741b7f1d9dfd_b.jpg\"/></figure><p>图中左边所示的代码地址就是游戏中CPU要读取指令的地址。CS叫代码段寄存器，IP叫指令指针寄存器。</p><p>在8086CPU机中，任意时刻，设CS的值为M，设IP的值为N，8086CPU将从内存“M×16＋N”单元开始，向下读取每一条指令并执行。也可以这样描述：在8086CPU机中，任意时刻，CPU将CS和IP（CS:IP）配合指向的内存单元里的信息当作指令执行。</p><p><b>下列一组图展示了8086CPU读取、执行指令的工作原理（图中数字皆为十六进制）：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6d29bd82fb4d75f6e05f7e56a1c89922_b.jpg\"/></figure><p>上图为读取、执行指令前的初始状态，CS=2000H，IP=0000H。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3e2ceead55b63013f5d0e2ad20d8e449_b.jpg\"/></figure><p>上图CS、IP中的数值送入地址加法器，地址加法器完成：物理地址=段地址×16＋偏移地址。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"669\" data-rawheight=\"279\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46afddcf56fa5ff1c596d17fca44bbbf_b.jpg\"/></figure><p>上图地址加法器将物理地址送入“输入输出控制电路”。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-010a1b5beb11d66cd1991f32be89d636_b.jpg\"/></figure><p>上图输入输出控制电路将物理地址20000H送上地址总线。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;273&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"659\" data-rawheight=\"273\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-aebb363fcb616ff2da1e31c2ad275786_b.jpg\"/></figure><p>上图从内存20000H单元开始，将存放其中(3个字节)的机器指令 B8 23 01 通过数据总线送入CPU。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2e1b9f7d027da42ec6a99a269f59d88d_b.jpg\"/></figure><p>上图输入输出控制电路将机器指令 B8 23 01 送入指令缓冲器。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;662&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"662\" data-rawheight=\"281\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"662\" data-original=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-148e43c5eb5b2d994f4502eceefd4a3d_b.jpg\"/></figure><p>上图读取一条指令后，IP中的值自动增加，以使CPU可以读取下一条指令。因当前读入的指令 B8 23 01长度为3个字节，</p><p><b>所以IP中的值加3，此时，CS：IP指向内存单元2000：0003。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;665&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"665\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"665\" data-original=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6b7e051be87aff81f14a4073fde8dc2e_b.jpg\"/></figure><p>上图执行控制器执行指令 B8 23 01（mov ax,0123h）。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"661\" data-original=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;661&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"661\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"661\" data-original=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f685925fca58089efd70bb6028eb27bc_b.jpg\"/></figure><p>上图指令执行后，AX中的数值为0123H。那么，接下来就是读取、执行下一条指令 BB 03 00（mov bx,0003h）了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>CS和IP的重要性在于它们的数值提供了CPU要执行指令的地址。</p><p>在1.3节中，我们说过，在内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，那么，CPU在什么时候把它看作指令？在什么时候把它看作数据呢？现在我们可以更有深度的回答这个问题了。</p><p>只要内存单元（二进制信息）被CS：IP指向，这些内存单元就会被CPU看作指令执行（如mov ax,bx），否则它依然代表着数据本身（如89D8H）。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.6 修改CS和IP的指令</b></h2><p>Mov被称为传送指令，可以修改大部分寄存器的值。如：mov ax,123H，将ax中的值设为123H。同样地，我们也可以执行 mov bx,2a4H、mov cx,5f0H、mov dx,b29H 等等。但是，mov不能修改CS和IP这两个寄存器的值，因为8086CPU没有提供这样的功能。</p><p>要修改CS和IP的值，可以用jmp指令，事实上，还有一些指令是可以修改CS和IP的，这些指令被统称为转移指令，这个在后面的章节会讲到，现在先学习这个最简单的转移指令：jmp。</p><p>若想同时修改CS和IP的值，可用形如“jmp 段地址：偏移地址”的指令完成。如：jmp 2ae3:9，执行后：CS=2ae3H，IP=9H，CPU将从2ae39H（2ae3*10+9H）处读取指令。</p><p>“jmp 段地址：偏移地址”指令的功能为：用指令中给出的第一个参数“段地址”修改CS，用第二个参数“偏移地址”修改IP。</p><p>若想仅修改IP的值，可用形如“jmp 某一合法寄存器”的指令完成。如：jmp ax，执行前ax=437aH，CS=17f0H，IP=423cH，执行后，CS不变，IP=437aH。即将原IP值 &#34;423cH&#34;修改为ax里的值&#34;437aH&#34;。</p><p>“jmp 某一合法寄存器”指令的功能为：用现有寄存器中的值来修改IP。为什么叫“某一合法寄存器”呢？因为并不是所有寄存器都可以修改IP！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2.7 代码段</b></h2><p>在编程时，可以根据需要，将一组内存单元定义为一个段。段分3种类型：代码段、数据段、栈段。</p><p>对于8086PC机，我们可以将长度为N（N≤64KB）的一组代码（机器指令和汇编指令），存放在一组地址连续、起始地址为16的倍数的内存单元中，我们将这一组内存单元定义为代码段。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb\" width=\"524\" data-original=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;524&#39; height=&#39;304&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"524\" data-rawheight=\"304\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"524\" data-original=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c08c8954a5aed19b056bcc72ab33b97a_b.jpg\"/></figure><p>这段长度为10字节的指令，存放于123B0H~123B9H的一组内存单元中，我们就可以认为这是一个代码段。若要让CPU执行这些指令，必须要将CS：IP指向代码段中第一条指令的首地址（123B0H）。</p><hr/><h2><b>第3章：寄存器（内存访问）</b></h2><p><b>引言</b></p><p>在电影《骇客帝国》中，男主角发现，看似正常的现实世界实际上似乎被某种程序的力量控制着，人类原来的现实世界已不复存在，眼前的一切不过是人工智能精细设计出来的为获得人类生物电能，从而欺骗人类大脑的虚拟网格世界（请参考“缸中之脑”的思想实验）。在影片中有这样一个桥段：男主角等人置身于一个由无数个小房间组成的矩阵中，他们在各房间走道中不断穿梭，希望能寻找到一把神秘钥匙，打开一扇指定的门。这一行为在计算机内存中，叫做内存访问，即通过地址+偏移的方式来访问某一个内存单元，并实现把数据压入栈空间或者从栈中取出（入栈、出栈的操作）。而男主角等人要寻找的这把特殊的key， 在汇编术语中称之为：“SS:SP”。让我们带着这些抽象的概念和电影动人的画面感，进入第3章的旅程！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_b.jpg\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7ba6552c0a4379ed7931e5974318cfb8_b.jpg\"/><figcaption>电影《骇客帝国》</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.1 内存中字的存储</b></h2><p>CPU中，一个字在16位寄存器存储时，高位字节存放在高8位寄存器中，低位字节存放在低8位寄存器中。<br/><br/>字在内存中存储时，由于内存单元是字节单元（一个单元存放一个字节），则一个字要用两个地址连续的内存单元来存放，这个字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。如：字4E20H在内存中的存放情况如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b4cf1448b240817608a694effdd3e331_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"257\" data-rawheight=\"263\" class=\"content_image\" width=\"257\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;257&#39; height=&#39;263&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"257\" data-rawheight=\"263\" class=\"content_image lazy\" width=\"257\" data-actualsrc=\"https://pic2.zhimg.com/v2-b4cf1448b240817608a694effdd3e331_b.jpg\"/></figure><p>字节单元：一个内存单元存放一个字节（8位）。</p><p>字单元：存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.2 DS和[address]</b></h2><p>CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086CPU中，内存地址由段地址和偏移地址组成，其中，段地址存放在段寄存器DS中，DS称作数据段寄存器（是否还记得8086CPU有4个段寄存器：CS、DS、SS、ES，上一章已讲过CS，本章讲DS）。</p><p>如果我们要将内存地址为14A70的内存单元中的数据送入AL中，可以用如下的程序段进行：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_b.png\" data-size=\"normal\" data-rawwidth=\"1028\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb\" width=\"1028\" data-original=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1028&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1028\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1028\" data-original=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7e9ff8f6698d1ed35d4f2a7b3cda3def_b.png\"/><figcaption>段地址(1000)*10+偏移地址(4A70)=内存单元(14A70)</figcaption></figure><p><br/>[address]表示一个内存单元，上图中的内存单元[address]中存放着偏移地址 [4A70]。<br/><br/><b>内存单元[address]，我们可以知道它的地址是多少，但它的数值是多少，我们无从知晓。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.3 Mov指令</b></h2><p>传送指令mov可以完成以下4种传送：</p><p>1：将数据直接送入寄存器。如：mov ax，1230H</p><p>2：将一个寄存器中的数据送入另一个寄存器。如：mov ax，bx</p><p>3：将一个内存单元中的数据送入一个寄存器。如：mov ax，[27b0]</p><p>4：将一个寄存器中的数据送入内存单元中。如：mov [607c]，bx</p><p>注意：不能直接用数据送给段寄存器，如：mov ds，1230H  是错误的，必须要用一个寄存器来进行中转。比如：</p><p><b>Mov bx，1230H</b><br/><b>Mov ds，bx</b></p><p>这样就行了。至于为什么8086CPU不支持将数据直接送入段寄存器呢？这属于8086CPU硬件设计的问题，我们只需知道这一点即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.4  Add和Sub指令</b></h2><p>Mov指令有两个操作对象，Add和Sub同样有两个操作对象。<br/><br/><b>ADD含意：</b>加法指令。<br/><b>ADD格式</b>：Add 操作对象1，操作对象2。<br/><b>ADD功能：</b>两数相加，并把结果保存到操作对象1中。<br/><br/>Add 具有以下几种形式：<br/>Add 寄存器，数据 如：add ax, 8<br/>Add 寄存器，寄存器 如：add ax, bx<br/>Add 寄存器，内存单元 如：add ax, [27a0]<br/>Add 内存单元，寄存器 如：add [46e9], bx<br/> <br/><br/><b>SUB含意：</b>减法指令。<br/><b>SUB格式：</b>Sub 操作对象1，操作对象2。<br/><b>SUB功能：</b>两数相减，即从操作对象1减去操作对象2，并将其结果保存到操作对象1中。<br/><br/>Sub 具有以下几种形式：<br/>Sub 寄存器，数据    如：sub ax, 9<br/>Sub 寄存器，寄存器    如：sub ax, bx<br/>Sub 寄存器，内存单元    如：sub ax, [b027]<br/>Sub 内存单元，寄存器    如：sub [8601], bx<br/><br/></p><h2><b>3.5 数据段</b></h2><p>前面讲过（参见2.7节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N（N≤64KB）、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p><p>比如：用123B0H~123B9H这段内存空间来存放数据，我们就可以认为123B0H~123B9H这段内存是一个数据段，长度为10个字节。<br/><br/>如何访问数据段中的数据呢？首先用DS存放数据段的段地址，然后用相关的指令访问数据段中的内存单元。<br/> <br/>比如，将123B0H~123B9H的内存单元定义为数据段，现在要累加这个数据段中的前3个单元<br/>中的数据，代码如下：<br/><br/>Mov ax, 123BH<br/>Mov ds, ax     将123BH送入ds中，作为数据段的段地址。<br/>Mov al, 0        用al存放累加结果，先把al中的数据清零。<br/>Add al, [0]      将ds数据段第一个单元（偏移地址为0）中的数值加到al中。<br/>Add al, [1]      将ds数据段第二个单元（偏移地址为1）中的数据加到al中。<br/>Add al, [2]      将ds数据段第三个单元（偏移地址为2）中的数据加到al中。<br/><br/>在1.5节中，我们说过，在内存中指令和数据没有任何区别，都是二进制信息，CPU在工作的时候，把有的信息看作指令，把有的信息看作数据，那么CPU在什么时候把它看作指令？在什么时候把它看作数据呢？在2.5节中我们回答了第一个问题“什么时候把它看作指令&#34;。</p><p>现在可以回答第二个问题了：什么时候把它看作数据？<br/><br/>答：只要把一段内存单元的段地址放到DS中，并用Mov、Add、Sub等访问内存单元时，CPU就会将这些内存单元看作数据来访问。<br/><br/></p><h2><b>3.6 修改游戏的两种方式（改数据和改指令）</b></h2><p>指令和数据虽然从表面上看其内存结构并无区别，见下图(注意看附加在图片下边的半隐形美丽注解)：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_b.jpg\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;760&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"760\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"760\" data-original=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-15e3d6666886009edcf59baf3e08301d_b.jpg\"/><figcaption>就像西施和貂蝉一样都是古典大美女——想什么呐！</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>但实际上，它们的差别可大着呢，见下图(注意看附加在图片下边的半隐形危险提示)：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_b.jpg\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"1044\" data-original=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1044&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1044\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1044\" data-original=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0cfc1168c449211063dfc09bccdc8e2d_b.jpg\"/><figcaption>然而她们的手法、口活、体力活以及各种生活技能也许大不相同哦（危险）</figcaption></figure><p><br/><br/><br/>以上是两者在实际意义上的区别（数据表示属性，指令表示行为）。</p><p>然而当我们从哲学的角度或用辩证法思维来思考问题时却发现：它们既是有区别的，又是密切相关的。数据和指令（或者说属性和行为），此二者是一个矛盾体：既非我族类，互不相同，又唇齿相依，相互合作。举个例子来说明这种思想：</p><p>某个游戏，初始有500份木材，建造一座房子消耗木材50份，如何实现木材数量（属性数据）的读写操作呢？</p><p>需要如下指令（行为方法）：</p><p>Mov ax, [bx＋270]<br/>Sub [bx＋16a], ax</p><p>内存单元[bx＋270]为建造房子时消耗的木材数量，每次消耗50份木材。内存单元[bx＋16a]为当前木材数量。假设木材初始数量为500，当我们建造一座房子（首套房）时，则CPU会从内存单元[bx＋270]中读取数据50送入ax，然后内存单元[bx＋16a]的数值减去ax，并把计算结果450（由500-50而得）写入该内存单元[bx＋16a]中，则当前木材数量变为450。上面这两条指令（Mov和Sub）实现了木材数量（属性数据）的读写操作，致使游戏中的伐木造房功能得以实现！</p><p>从上面这个简单的例子，可以看出数据与指令是怎样的关系。只有数据没有指令，那么数据就没法读写，只有指令没有数据，那么只能是空指令，没有实质意义，如同巧妇难为无米之炊。</p><p>修改数据和指令就是修改游戏的两种方式。以前我们用《金山游侠》、《gamemaster》等修改器修改的都是数据，现在有了CE，CE除了可以修改数据，还可以修改指令，棒到家——可以修改西施和貂蝉的行为了！</p><p><b>赶紧对她们下达“主人的指令”吧！</b></p><p><i>—— 妲己：主人的命令是绝对的。</i></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_b.jpg\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"837\" data-original=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;837&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"837\" data-original=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a048fef4e3c4422b9ccc5aba49f93318_b.jpg\"/><figcaption>（非法制绘）</figcaption></figure><h2><b>3.7 栈</b></h2><p>栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于：最后进入这个空间的数据最先出去。可以用一个盒子和3本书来描述栈的这种操作方式。</p><p>一个开口的盒子就可以看成一个栈空间，现有3本名著：《金瓶梅》、《肉蒲团》、《剪灯新话》，把它们放到盒子中，操作过程如下图所示（注意轻拿轻放，都是中国古典辉煌著作）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;776&#39; height=&#39;587&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e795bf1923914ca2cbab4b47f54581b2_b.jpg\"/></figure><p><br/><b>上图把书放进盒子，这种操作可以称之为“入栈”。</b>现在的问题是：一次只允许取一本，我们如何将3本书从盒子中取出来呢？ </p><p>显然，必须从盒子的最上边取，这样取出的顺序就是：《剪灯新话》、《肉蒲团》、《金瓶梅》，和放入的顺序相反，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"615\" class=\"origin_image zh-lightbox-thumb\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;831&#39; height=&#39;615&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"831\" data-rawheight=\"615\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"831\" data-original=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e0b2f81ab205a0543255f5bbe749b9ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>上图把书从盒子中取出，这种操作可以称为“出栈”。</b></p><p>如果说，上例中的盒子就是一个栈，那么对于栈有两个基本操作：入栈和出栈。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时又最先被从栈中取出，栈的这种操作规则被称为 LIFO（last in first out：<b>后进先出</b>）。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_b.jpg\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb\" width=\"511\" data-original=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;511&#39; height=&#39;305&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"305\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"511\" data-original=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e66b0607925e2db8f258e9f70eb35671_b.jpg\"/><figcaption>入栈出栈，后进先出之遐想：商女不知亡国恨，隔江尤唱后庭花。</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>小知识点：想必大家对《金瓶梅》和《肉蒲团》并不陌生，对《剪灯新话》却缺乏相当的了解，那么今天果壳大湿就给大家来讲讲《剪灯新话》这本文学著作。</i><br/><br/><i>《剪灯新话》是明代瞿佑撰写的文言短篇小说，中国十大禁书之一，此书为中国历史上第一部禁毁小说。书中除描摹普罗男女的畸变离奇隐秘之事外，其人鬼相恋，“交合之事，一如人间”，亦成为扣脚大汉和金刚芭比津津乐道，奉之为宅男宅女圣经宝典之根由，并不断从中汲取文学养分。中国文化博大精深——外国人和外行人是看不懂的。</i></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3.8  CUP提供的栈机制</b></h2><p>现如今的CPU中都会有栈的设计。8086CPU提供的入栈和出栈指令，最基本的两个是：push（入栈）和pop（出栈）。</p><p>Push ax 表示将寄存器ax中的数据送入栈中，pop ax 表示从栈顶取出数据送入ax。8086CPU的入栈和出栈操作都是以字为单位进行的。</p><p>下面两张图描述了push和pop指令的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb\" width=\"978\" data-original=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;978&#39; height=&#39;459&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"978\" data-rawheight=\"459\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"978\" data-original=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9ac83883b435665ca4cb96a9f4a51226_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_b.jpg\" data-size=\"normal\" data-rawwidth=\"980\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"980\" data-original=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;980&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"980\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"980\" data-original=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4711bb4425475a7aa6ad386dd88d4638_b.jpg\"/><figcaption>pop ax时，将数据1122H从1000BH-1000AH地址处取出；pop bx时，将数据2266H从1000DH-1000CH地址处取出；pop cx时，将数据0123H从1000FH-1000EH地址处取出。</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面两张图指令的执行过程，写成代码如下：</p><p>Mov ax, 123H</p><p>Push ax</p><p>Mov bx, 2266H</p><p>Push bx</p><p>Mov cx, 1122H</p><p>Push cx</p><p>Pop ax</p><p>Pop bx</p><p>Pop cx</p><p><b>注意：字型数据用两个内存单元存放，高地址单元存放高8位，低地址单元存放低8位。</b></p><p>看了上面两张图后，现在提出两个问题。</p><p>问题一<b>（栈空间）</b>：我们将10000H~1000FH这段内存当作栈来使用，CPU是如何知道这段空间是栈？关于这个问题将在3.10节中进行解答（现在先把问题抛出来供大家思考）。</p><p>问题二<b>（栈顶单元）</b>：push ax等入栈指令执行时，要将寄存器中的数据放入当前栈顶单元的上方，成为新的栈顶元素；pop ax等指令执行时，要从栈顶单元取出数据送入寄存器中。显然，push、pop在执行的时候，CPU必须要知道哪个单元是栈顶单元，可是，如何知道？</p><p>王子解答：8086CPU中，有这么两个寄存器——堆栈段寄存器SS和堆栈指针寄存器SP。栈顶的段地址存放在SS中，栈顶的偏移地址则存放在SP中。任意时刻，SS:SP将会指向栈顶元素。push和pop指令在执行时，CPU会自动从SS和SP中得到栈顶单元的地址。</p><p><b><i>这也就是本章开篇引言中讲述的关于《骇客帝国》男主角等人在房间矩阵中苦苦寻找的key：SS:SP。有了key就能定位到栈顶单元。</i></b></p><p>现在，我们可以完整地描述push和pop指令的功能实现机制了，例如push ax的执行，由以下两步骤完成：</p><p>1. SP=SP－2，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</p><p>2. 将ax中的数据送入SS:SP指向的内存单元处，SS:SP此时指向新栈顶。</p><p><br/>下图描述了push ax的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1030&#39; height=&#39;544&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"544\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1030\" data-original=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-801ba067d12c4a1179bfc5eed0a43df6_b.jpg\"/></figure><p><br/>小马提问：如果10000H~1000FH这段空间为栈，初始状态栈是空的，此时，SS=1000H，SP=？</p><p>王子答曰：此时SP需要SP=SP+2，则SP=0010H。具体分析见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d67c27d1a29c5edccd2684c1e47b77ed_b.jpg\"/></figure><p><br/>将10000H~1000FH这段空间当作栈段，SS=1000H，栈空间大小为16字节，栈最底部的字单元地址为1000:000E，任意时刻，SS:SP指向栈顶，当栈中只有一个元素时，SS=1000H，SP=000EH。若栈为空，相当于栈中唯一的元素出栈后，SP=SP＋2，原来为000EH，加2后SP=0010H，所以，当栈为空的时候，SS=1000H，SP=0010H。</p><p>换一个角度看，任意时刻，SS:SP指向栈顶元素，当栈为空的时候栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址＋2（即SP+SP+2），栈最底部字单元的地址为1000:000E，所以，栈空时，SP=0010H。</p><p><br/>接下来，我们描述pop指令的功能实现机制，例如：pop ax。Pop ax的执行过程和push ax刚好相反，由以下两步完成：</p><p>1. 将SS:SP指向的内存单元处的数据送入ax中。</p><p>2. SP=SP＋2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</p><p>下图描述了pop ax的执行过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1008\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb\" width=\"1008\" data-original=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1008&#39; height=&#39;482&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1008\" data-rawheight=\"482\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1008\" data-original=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f92d296643189d3efe02c9d83c9186e_b.jpg\"/></figure><p><br/>注意：上图中，出栈后，SS:SP指向新的栈顶1000EH，pop操作前的栈顶元素，1000CH处的数据2266H依然存在，但是，它已不在栈中(不在栈中在哪里，以后再讲)，当再次执行push等入栈指令后，SS:SP移至1000CH，并在里面写入新的数据，将它覆盖。</p><p><br/>小知识点：根据上述出入栈原理，我们可以得知，为什么当我们删除硬盘中的文件后，若尚未存入新文件，则仍有可能实现“硬盘数据恢复”，但一旦在原处覆盖存入新文件则旧文件必将永远丢失，好多种子万劫不复！出栈入栈与硬盘数据丢失，两者同理。此时此刻，想起那些被误删的种子和那段无法被遗忘的岁月，王子&#34;湿&#34;性大发，&#34;性&#34;甚至哉，不得不淫它曹操一“手&#34;：《观沧海》。<br/><br/><i>东临碣石</i>，<i>以观沧海。</i></p><p><i>水何澹澹，山岛竦峙</i>。</p><p><i>树木丛生，百草丰茂。</i></p><p><i>秋风萧瑟，洪波涌起。</i></p><p><i>日月之行，若出其中。</i></p><p><i>星汉灿烂，若出其里。</i></p><p><i>幸甚至哉，歌以咏志！</i><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_b.jpg\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e69fd9a9316185c27f43de9be5c9907_b.jpg\"/><figcaption>出栈入栈与硬盘数据（种子）丢失两者同理之遐思：日月之行若出其中，星汉灿烂若出其里</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3.9  push和pop指令的两种运用形式</h2><p><br/>PUSH和POP指令的格式有如下两种形式。<br/><br/><b>第一种形式（push  寄存器、POP  寄存器）：</b><br/>&#34;push  寄存器&#34;，入栈，将一个寄存器中的数据压入栈中。<br/>&#34;POP  寄存器&#34;，出栈，用一个寄存器接收出栈的数据。<br/><br/><i>这一种形式，它们可以在栈和寄存器之间传送数据。</i><br/>注意：上面的寄存器可以是段寄存器，比如，可以是：push ds、pop ds。<br/> </p><p><b>第二种形式（push  内存单元 、POP  内存单元）：</b><br/>&#34;push  内存单元&#34;，入栈，将一个内存单元中的字型数据入栈（注意，栈操作都是以字为单位）。<br/> &#34;POP  内存单元&#34;，出栈，用一个内存字单元接收出栈的数据。</p><p>示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"261\" class=\"origin_image zh-lightbox-thumb\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;469&#39; height=&#39;261&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"261\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"469\" data-original=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-46245cf43f19ac4a3d09349e7c7aa802_b.jpg\"/></figure><p><i>这一种形式，它们可以在栈和内存单元之间传送数据。</i><br/><br/>指令执行时，CPU要知道内存单元的地址，可以在push、pop指令中给出内存单元的偏移地址。段地址在指令执行时，CPU会自动从DS中取得段地址。<br/><br/><br/><b>小结：</b><br/>Push和pop实质上是一种内存传送指令，与mov指令不同的是，push和pop指令访问的栈空间的地址不是在指令中给出的，而是由SS:SP指出的。同时，push和pop指令还需要改变SP中的数值。Mov指令只需一步操作，就是传送，而执行push、pop指令需要两步操作，执行push时，先改变SP，后向SS:SP处传送数据入栈；执行pop时，先读取SS:SP处的数据并将其送出栈，而后改变SP。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>3.10 栈段</h2><p>前面讲过（参见2.7节），对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N（N≤64KB）的一组地址连续、起始地址为16的倍数的内存单元，当作栈空间来用，从而定义了一个栈段。</p><p>比如，我们将10010H~1001FH这段内存空间当作栈来用，以栈的方式进行访问，这段空间就可以认为是一个栈段，大小为16个字节。</p><p>如何使得如push、pop等栈操作指令访问我们定义的栈段呢？那就是要将SS:SP指向我们定义的栈段。现在我们来回答3.8节中的第一个问题：CPU是如何知道这段空间是栈？</p><p>王子潇洒答曰：只要这段内存单元被SS:SP指向，那么，CPU就会把这段空间当作栈来使用！</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><h2><b>第4章：寻址方式</b></h2><p><b>引言</b></p><p><i>寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，最难将息。三杯两盏淡酒，怎敌他、晚来风急！雁过也，正伤心，却是旧时相识。</i></p><p><i>满地黄花堆积，憔悴损，如今有谁堪摘？守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏、点点滴滴。这次第，怎一个愁字了得！</i></p><p><br/><i>本章精彩内容介绍——</i></p><p><i>1.李清照寻夫：Mov ax, [bx]</i></p><p><i>2.其夫未归，如何用另一种更灵活的方式来玩转她：Mov ax, [bx＋idata]</i></p><p><i>3.那么清照妹妹身上的物理地址究竟在哪里？物理地址=基础地址＋偏移地址。 </i></p><p><i>4.上下探索，尝试不同玩法，从[idata]一直到[bx＋si＋idata]，无一死角，遍体酥麻……</i></p><p><i>5.到黄昏、点点滴滴……这次第，怎一个&#34;抽&#34;字了得！</i></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_b.jpg\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;526&#39; height=&#39;655&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"655\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-11d99944052f012be06e55c5082221eb_b.jpg\"/><figcaption>清照妹妹</figcaption></figure><h2><br/> <b>4.1 内存单元和[bx]的描述</b></h2><p>要完整地描述一个内存单元，需要两种信息：<br/>1.内存单元的物理地址（物理地址=基础地址＋偏移地址）。<br/>2.内存单元的长度（字单元、字节单元）。<br/><br/>如：mov  ax, [2a78] 表示将一个内存单元中的数据送入ax（16位寄存器）中，这个内存单元的长度为2字节（<b>字单元</b>），存放一个字，偏移地址为2a78H，段地址在DS中。</p><p>如：mov  al, [10f3] 表示将一个内存单元中的数据送入al（8位寄存器）中，这个内存单元的长度为1字节（<b>字节单元</b>），存放一个字节，偏移地址为10f3H，段地址在DS中。<br/><br/> 一个内存单元，段地址默认在DS中，偏移地址可以直接给出，单元的长度可以由具体指令中的其它操作对象（比如上述的ax寄存器、al寄存器）指出。<br/><br/>上面两条指令中，内存单元[2a78]和[10f3]，它们的偏移地址分别是2a78H和10f3H，第一条指令中，ax为16位寄存器，这意味着[2a78]是字单元；第二条指令，al为低8位寄存器，这意味着[10f3]是字节单元（8位相当于单字节，16位相当于双字节）。<br/><br/>再看下面两条指令：<br/>Mov ax, [bx]    <br/>Mov al,  [bx]<br/><br/>[bx]同样也表示一个内存单元，它的偏移地址就是bx的数值。<br/> <br/> </p><h2><b>4.2  [bx＋idata]</b></h2><p>请看下面三组指令：<br/>Mov ax, [127a]、 Mov ax,  [30e0]、Mov ax, [c950]<br/>指令中的127a、30e0、c950皆为常量，我们可以用idata来表示常量：mov ax,  [idata]。<br/> <br/>同理：Mov bx,  123aH、Mov bx, 8762H、Mov bx, 4c0eH<br/>即可表示为：mov bx, idata。<br/> <br/>假设我们用[idata]和[bx]的方式来指明一个内存单元：<br/>Mov bx, idata <br/>Mov ax, [bx]</p><p>则我们还可以用另一种更灵活的方式来玩转它：Mov ax, [bx＋idata]。偏移地址为bx中的数值加上idata。<br/><br/>我们看一下指令mov ax, [bx＋200]的含义。将内存单元[bx＋200]中的数据送入ax，长度为2个字节（字单元），偏移地址为bx中的数值加上200，段地址在DS中。<br/><br/>该指令也可以写成如下常用格式：<br/>Mov ax,  [200＋bx]、mov ax, 200[bx]、mov ax, [bx].200</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.3 SI和DI</b></h2><p>SI是源变址寄存器，DI是目的变址寄存器，它们的功能与BX相近，但它们不能分成两个8位寄存器。<br/><br/>以下指令把内存单元[13b2]中的数据送入ax。<br/>Mov bx,  13b2H<br/>Mov ax, [bx]    <br/><br/>同样地，可以：<br/>Mov si,  13b2H<br/>Mov ax, [si]     <br/><br/>也可以：<br/>Mov di, 13b2H<br/>Mov ax, [di]     <br/> <br/><br/>以下指令把内存单元[2a7c＋123]中的数据送入ax。<br/>mov  bx, 2a7cH<br/>Mov ax,  [bx＋123]    <br/><br/>同样地，可以：<br/>Mov si, 2a7cH<br/>Mov ax,  [si＋123]   <br/><br/>也可以：<br/>Mov di, 2a7cH<br/>Mov ax,  [di＋123]     </p><p>由此可见，我们用[bx]的方式来指明一个内存单元，同样地我们也可以用[si]或[di]的方式来指明一个内存单元，它们的含义基本相同。<br/><br/>而当我们用[bx＋idata]的灵活方式来指明一个内存单元时，同样地我们亦可以用[si＋idata]或[di＋idata]的方式来指明一个内存单元，含义近似。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.4  [bx＋si]和[bx＋di]</b></h2><p>本节我们学习比前面几节讲解的更为灵活的指明一个内存单元的方式：[bx＋si]和[bx＋di]。 <br/>[bx＋si]和[bx＋di]的含义相似，我们以[bx＋si]为例进行讲解。</p><p><b>[bx＋si]表示一个内存单元，它的偏移地址为bx的数值加上si的数值。</b><br/><br/>指令mov  ax, [bx＋si]的含义如下：<br/>将一个内存单元[bx＋si]中的数据送入ax，这个内存单元的长度为2字节（字单元），存放一个字，偏移地址为bx的数值加上si的数值，段地址在DS中。<br/><br/>该指令也可以写成如下常用格式：mov ax, [bx][si]</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>4.6 寻址方式的含义</b></h2><p>前面我们学习了几种定位内存地址的方法，现在总结一下：<br/><br/>1.[idata] 用一个常量来表示地址，可用于直接定位一个内存单元。<br/>2.[bx] 用一个变量来表示内存地址，可在一个起始地址的基础上间接定位一个内存单元。<br/>3.[bx＋idata] 用一个变量和常量表示地址，可在一个起始地址的基础上用变量+常量的方式间接定位一个内存单元。<br/>4.[bx＋si] 用两个变量表示地址（间接定位）。<br/>5.[bx＋si＋idata] 用两个变量和一个常量表示地址（间接定位）。<br/><br/>可以看到，从[idata]一直到[bx＋si＋idata]，我们可以用更加灵活的方式来定位一个内存单元的地址。以上这几种定位内存地址的方法就称作寻址方式。</p><p><i>下一章我们将对寻址方式的问题进行深入浅出的探讨，敬请关注！</i><br/><br/><i><b>关注果壳不迷路，果壳带你上高速！</b></i><br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_b.jpg\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;574&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"574\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c5f7b6ac811fa2312e38008cca1ad0a5_b.jpg\"/><figcaption>我的机器女友，今晚一起上高速。</figcaption></figure><hr/><h2><b>第5章：数据处理的两个基本问题</b></h2><p><b>引言</b><br/><br/>我们知道，计算机是进行数据处理、运算的机器，那么有两个基本的问题就包含在其中：<br/><br/>1. 处理的数据在什么地方？<br/>2. 要处理的数据有多长？<br/><br/>这两个问题，在机器指令中，必须给以明确或隐含的说明，否则计算机就无法工作。本章中，我们就要针对8086CPU对这两个基本问题进行讨论。</p><h2><b>5.1 bx、si、di和bp</b></h2><p>Bx、si和di这3个寄存器我们已经学过了，现在总结以下两个要点，并学学bp。<br/><br/>1：在8086CPU中，只有这4个寄存器可以用在[…]中来进行内存单元的寻址。比如，下面的指令都是正确的：<br/>Mov ax, [bx]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋di]<br/>Mov ax, [bp]<br/>Mov ax, [bp＋si]<br/>Mov ax, [bp＋di]<br/><br/>而下面的指令则是错误的：<br/>Mov ax, [ax]<br/>Mov ax, [cx]<br/>Mov ax, [dx]<br/>Mov ax, [ds]<br/><br/><br/>2：在[…]中，这4个寄存器可以单个出现，或只能以4种组合出现：<br/>组合一：bx和si   <br/>组合二：bx和di    <br/>组合三：bp和si     <br/>组合四：bp和di。<br/><br/>比如下面的指令都是正确的：<br/>Mov ax, [bx]<br/>Mov ax, [si]<br/>Mov ax, [di]<br/>Mov ax, [bp]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋di]<br/>Mov ax, [bp＋si]<br/>Mov ax, [bp＋di]<br/>Mov ax, [bx＋si＋idata]<br/>Mov ax, [bx＋di＋idata]<br/>Mov ax, [bp＋si＋idata]<br/>Mov ax, [bp＋di＋idata]<br/><br/>而下面的指令则是错误的：<br/>Mov ax, [bx＋bp]<br/>Mov ax, [si＋di]<br/> <br/><br/><br/>我们可以在访问内存单元的指令中显式地给出内存单元的段地址所在的段寄存器。比如：<br/>Mov  ax, SS:[bx]    段地址在SS中。<br/>Mov ax,  DS:[bp]   段地址在DS中。<br/>Mov ax,  CS:[bp]   段地址在CS中。<br/>Mov ax,  ES:[bp]    段地址在ES中。<br/><br/>在上面的指令 mov ax, ES:[bp] 中，我们接触到了一个新的段寄存器ES，ES叫附加段寄存器，它的功能与DS基本相同。<br/><br/>如果在[…]中使用寄存器bp，而指令中没有显式地给出段地址，段地址就默认在SS中。比如，下面的指令：<br/>Mov ax, [bp＋200]  内存单元[bp＋200]的段地址就在SS中。<br/><br/>BP被称作基址指针寄存器，它可以作SP使用，除了BP可以作为间接寻址寄存器而SP不能外，其余功能基本相同。<br/> <br/>事实上，通用寄存器除了第2章引言中提及的ax、bx、cx、dx这4个外，从广义上讲还应包括sp、bp、si、di这4个16位寄存器，以及ah、al、bh、bl、ch、cl、dh、dl这8个8位寄存器，也就是说，通用寄存器实际上一共有以上这16个。<br/> </p><h2><b>5.2 机器指令处理的数据在什么地方</b></h2><p>绝大部分机器指令都是进行数据处理的指令，处理大致可分为3类：读取、写入、运算。在机器指令这一层来讲，并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在3个地方：CPU内部、内存、端口，比如下图所列的指令：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1026\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"1026\" data-original=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1026&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1026\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1026\" data-original=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ba380e26f53dbfdece1a048f1cb493b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5.3 汇编语言中的数据位置的表达</b></h2><p>在汇编语言中如何表达数据位置？汇编语言中用3个概念来表达数据的位置，即立即数、寄存器、地址（段地址和偏移地址）。<br/> <br/>1. 立即数（idata）<br/>对于直接包含在机器指令中的数据（执行前在CPU的指令缓冲器中），在汇编语言中称之为“立即数”。例如：<br/>Mov ax, 136aH   指令要处理的数据就是立即数136aH。<br/>Add ax, 2000H    指令要处理的数据就是立即数2000H。<br/>Sub ax, a2c7H     指令要处理的数据就是立即数a2c7H。<br/> <br/>2. 寄存器<br/>指令要处理的数据在寄存器中，在汇编指令中给出相应的寄存器名。例如：<br/>Mov ax, bx    指令要处理的数据在bx寄存器中。<br/>Mov ds, ax     指令要处理的数据在ax寄存器中。<br/>Push bx    指令要处理的数据在bx寄存器中。<br/>Mov DS:[123a], bx     指令要处理的数据在bx寄存器中，段地址在DS中。<br/><br/>3. 段地址和偏移地址<br/>指令要处理的数据在内存中，在汇编指令中可用[…]的格式给出偏移地址，段地址在某个段寄存器中。例如：<br/>Mov ax, [107a]<br/>Mov ax, [di]<br/>Mov ax, [bx＋8]<br/>Mov ax, [bx＋si]<br/>Mov ax, [bx＋si＋8]<br/>指令要处理的数据偏移地址在[…]中，段地址默认在DS中。<br/><br/><br/> 再看下面的指令：<br/> Mov ax, [bp]<br/> Mov ax, [bp＋8]<br/> Mov ax, [bp＋si]<br/> Mov ax, [bp＋si＋8]<br/> 指令要处理的数据偏移地址在[…]中，段地址默认在SS中。<br/><br/><br/> 存放段地址的寄存器也可以是显性地给出，比如以下指令：<br/> Mov ax, DS:[bp]   指令要处理的数据偏移地址在[…]中，段地址在DS中。<br/> Mov ax, ES:[bx]     指令要处理的数据偏移地址在[…]中，段地址在ES中。<br/> Mov ax,  SS:[bx＋si]    指令要处理的数据偏移地址在[…]中，段地址在SS中。<br/> Mov ax,  CS:[bx＋si＋8]    指令要处理的数据偏移地址在[…]中，段地址在CS中。<br/> </p><h2><b>5.4 寻址方式（总结）</b></h2><p>本节对寻址方式进行一下总结，见下表。<br/><br/>看表前先看以下说明：<br/>1.表中EA表示偏移地址，SA表示段地址。<br/>2.表中寄存器加上一个小括号，表示这个寄存器中的数值，比如：EA=(bx)；SA=(ds)，（bx）就表示bx中的数值，（ds）就表示ds中的数值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"861\" class=\"origin_image zh-lightbox-thumb\" width=\"913\" data-original=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;913&#39; height=&#39;861&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"913\" data-rawheight=\"861\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"913\" data-original=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-46daed26cdb59db35343a341d1971d7b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>5.5 指令要处理的数据有多长</b></h2><p>8086CPU的指令，可以处理两种尺寸的数据：byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作，对于这个问题，汇编语言中用以下方式处理。<br/><br/>1. 通过寄存器名指明要处理的数据的尺寸。<br/>例如，下面的指令中，寄存器指明了指令进行的是字操作，因为这些寄存器都是16位的。<br/>Mov ax, 123H<br/>Mov bx, DS:[210a]<br/>Add ax, 1000H<br/>Sub bx, 2ffH<br/><br/>下面的指令中，寄存器指明了指令进行的是字节操作，因为这些寄存器都是8位的。<br/>Mov al, 12H<br/>Mov bl,  DS:[210a]<br/>Add al, 10H<br/>Sub bl, 2fH<br/><br/><br/>2. 在没有寄存器名存在的情况下，用操作符word  prt或byte  prt指明内存单元的长度，前者为字单元，后者为字节单元。<br/>例如，下面的指令中，用word ptr指明了指令访问的内存单元是一个字单元。<br/>Mov word ptr DS:[a017]，28H<br/>Add word ptr [bx]，78H<br/><br/>下面的指令中，用byte prt指明了指令访问的内存单元是一个字节单元。<br/>Mov byte ptr DS:[1a7]，1aH<br/>Add byte ptr [bx]，62H<br/><br/>在没有寄存器参与的内存单元访问指令中，用word ptr或byte  ptr显性地指明所要访问的内存单元的长度是很有必要的，否则，CPU无法得知所要访问的单元是字单元还是字节单元，从而造成错误。<br/><br/><br/> 3. 其它方法。有些指令已经默认了所访问的内存单元是字单元还是字节单元，比如：push [123a]和pop[123c]就不用指明访问的是字单元还是字节单元，因为push和pop指令只进行字操作。<br/><br/></p><h2><b>5.6  mul指令</b></h2><p>Mul为乘法指令，使用mul做乘法的时候，注意以下两点：<br/>1. 两个相乘的数：这两个相乘的数，要么都是8位，要么都是16位，如果是8位，一个默认放在al中，另一个放在8位寄存器或内存字节单元中；如果是16位，一个默认放在ax中，另一个放在16位寄存器或内存字单元中。<br/>2.结果：如果是8位乘法，其结果默认存放在ax中；如果是16位乘法，其结果的高位默认存放在<b>dx</b>中，低位则存放在ax中。<br/><br/>Mul 指令格式如下：<br/>Mul 通用寄存器<br/>Mul 内存单元</p><p>内存单元可以用不同的寻址方式给出，比如：<br/>Mul byte ptr  DS:[7102]    8位乘法。<br/>Mul word ptr  [bx＋si＋8]    16位乘法。<br/><br/>例1：计算100×10。<br/>100和10都小于255，可以做8位乘法，代码如下：<br/>Mov al, 100<br/>Mov bl, 10<br/>Mul bl<br/>结果：ax=al×bl=100×10=1000（3E8H）<br/><br/>例2：计算100×10000。<br/>100小于255，可10000大于255，所以必须做16位乘法，代码如下：<br/>Mov ax, 100<br/>Mov bx, 10000<br/>Mul bx<br/>结果：ax×bx=100×10000=1000000（F4240H）<br/>存放：Ax=4240H（低16位值）；Dx=FH（高16位值）<br/><br/></p><h2><b>5.7  div指令</b></h2><p>Div是除法指令，使用div做除法的时候，应注意以下问题：<br/>1. 除数：有8位和16位两种，在一个寄存器或内存单元中。<br/>2. 被除数：如果除数为8位，被除数则为16位，则默认放在ax中；如果除数为16位，被除数则为32位，则在dx和ax中存放，其中dx存放高16位，ax存放低16位。<br/>3. 结果：如果除数为8位，则al存储结果的商，ah存储结果的余数；如果除数为16位，则ax存储结果的商，dx存储结果的余数。<br/><br/>Div 指令格式如下：<br/>Div 通用寄存器<br/>Div 内存单元<br/><br/>内存单元可以用不同的寻址方式给出，比如：<br/>Div byte ptr  DS:[21a5]    除数为8位的除法。<br/>Div word ptr  [bx＋si＋8] 除数为16位的除法。<br/><br/>例1：计算100001÷100。<br/>被除数100001为32位，转化成16进制为186a1H，低16位值86a1H放在ax中，高16位值1H放在Dx中，除数100转化为16进制64H后，放在一个16位寄存器中，代码如下：<br/>Mov dx, 1H<br/>Mov ax,  86a1H<br/>Mov bx, 64H<br/>Div bx<br/>结果：(dx×10000H＋ax)÷bx=186a1H÷64H=3E8H余1。<br/>存放：Ax=3e8H（1000）；dx=1H<br/><br/>例2：计算1001÷100。<br/>被除数1001可用ax存放，除数100可用8位寄存器存放，代码如下：<br/>Mov ax, 1001<br/>Mov bl, 100<br/>Div bl<br/>结果：ax÷bl=1001÷100=10余1。<br/>存放：Al=10；Ah=1</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_b.jpg\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"310\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f4b70a0377c604be812602c79d166003_b.jpg\"/><figcaption>（寄存器存放高低位数据之遐思）</figcaption></figure><hr/><h2><b>第6章：转移指令和原理</b></h2><p><b>引言</b></p><p>可以修改IP，或同时修改CS和IP的指令统称为转移指令。概括地讲，转移指令就是可以控制CPU执行内存中某处代码的指令。<br/><br/>8086CPU的转移行为有以下几类：<br/>1. 同时修改CS和IP时，称为段间转移，比如：jmp 100:2a7。<br/>2. 只修改IP时，称为段内转移，比如：jmp ax。由于转移指令对IP的修改范围不同，段内转移又分为“短转移”和“近转移”。<br/>3. 段内短转移IP的修改范围为：-128~127。<br/>4. 段内近转移IP的修改范围为：-32768~32767。<br/><br/>8086CPU的转移指令分为以下几类：<br/>1. 无条件转移指令（比如：jmp）<br/>2. 条件转移指令<br/>3. 循环指令<br/>4. 过程<br/>5. 中断<br/>这些转移指令转移的前提条件可能不同，但转移的基本原理是相同的，我们在这一章主要通过深入学习无条件转移指令jmp来理解CPU执行转移指令的基本原理。<br/><br/></p><h2><b>6.1  jmp指令</b></h2><p>Jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP。<br/><br/>Jmp指令要给出两种信息：<br/> 1. 转移的目的地址。<br/> 2. 转移的距离（段间转移、段内短转移、段内近转移）。<br/><br/>不同的给出目的地址的方法，和不同的转移位置，对应有不同格式的jmp指令，下面的几节内容中，我们以给出目的地址的不同方法为主线，讲解jmp指令的主要应用格式和CPU执行转移指令的基本原理。<br/><br/></p><h2><b>6.2 依据位移进行转移的jmp指令</b></h2><p>Jmp short 标号（转到标号处执行指令）。</p><p>这种格式的jmp指令，实现的是段内短转移，它对IP的修改范围为：-128~127。也就是说，它向前转移时可以多越过128个字节，向后转移可以最多越过127个字节。Jmp指令中的“short”符号，说明指令进行的是短转移，jmp指令中的“标号”是代码段中的标号，指明了指令要转移的目的地，转移指令执行结束后，CS:IP应该指向标号处的指令。</p><p>请看下面一段代码：</p><p>Mov ax, 0</p><p>Jmp short S</p><p>Add ax, 1</p><p>S:add ax, 2</p><p>最下面那条指令中的S就是标号，jmp short S指令执行后，CS:IP指向S:add ax, 2，上面那条指令Add ax, 1已被跳过，没有被CPU执行。有没有觉得：有点像高级语言中的GOTO语句？</p><p>在“jmp short 标号”指令所对应的机器码中，不包含转移的目的地址，而包含的是转移的位移，这个位移是编译器根据汇编指令中的“标号”计算出来的，具体的计算方法如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;807&#39; height=&#39;444&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-376a978e868c7fe95f1e22d8e51b2571_b.jpg\"/></figure><p><br/><br/>上图中，标号处的指令s0:inc bx的偏移地址为6，指令jmp s0后的第一个字节的偏移地址为3，位移量就是：6－3= 3。</p><p>再来看，标号处的指令s:inc ax的偏移地址为0，指令jmp s后的第一个字节的偏移地址为9，则位移量就是0－9 =﹣9。</p><p>“Jmp short 标号”的功能表示：IP=IP＋8位位移。请看以下四个要点：</p><p>1：8位位移=标号处的地址－jmp指令后的第一个字节的地址。</p><p>2：short指明此处的位移为8位位移。</p><p>3：8位位移的范围为﹣128~127，用补码表示（本教程不讲解补码，若你想了解，请看相关书籍）。</p><p>4：8位位移由编译程序在编译时算出。</p><p>还有一种和“jmp short 标号”功能相近的指令格式：“jmp near ptr 标号”，它实现的是段内近转移。</p><p>“jmp near ptr 标号”的功能表示为：IP=IP＋16位位移。</p><p>1：16位位移=标号处的地址－jmp指令后的第一个字节的地址。</p><p>2：near ptr指明此处的位移为16位位移，进行的是段内近转移。</p><p>3：16位位移的范围为﹣32768~32767，用补码表示。</p><p>4：16位位移由编译程序在编译时算出。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6.3 转移地址在指令中或寄存器中的jmp指令</b></h2><p>“Jmp  far ptr 标号”实现的是段间转移（又称为远转移），功能如下：</p><p>CS=标号所在段的段地址，IP=标号在段中的偏移地址。<br/>&#34;Far ptr&#34;指明了指令用标号的段地址和偏移地址修改CS和IP。<br/> 在“jmp  far ptr 标号”指令所对应的机器码中，包含转移目的地的地址。<br/> <br/> 转移的目的地在寄存器中的jmp指令，指令格式为：<br/> Jmp 16位通用寄存器。<br/> 功能：IP=16位通用寄存器<br/> 这种指令我们在前面的内容（参见2.6节）中已经讲过，这里就不再详述。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_b.jpg\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b1cac551048401b67d4e36efa2121949_b.jpg\"/><figcaption>师娘大变身：爱的魔力转圈圈（转移地址之jmp指令之海边遐想）</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>6.4 转移地址在内存中的jmp指令</b></h2><p>转移地址在内存中的jmp指令有两种格式：<br/> <br/>1. “jmp  word ptr 内存单元地址”（段内转移）。<br/>功能：从内存单元地址处开始存放着一个字，用做转移的目标偏移地址。内存单元地址可用寻址方式的任一格式给出，比如，下面的指令：<br/><br/>Mov ax, 123H<br/>Mov DS:[200],  ax<br/>Jmp word ptr  DS:[200]<br/>执行后，IP=123H<br/><br/>又比如，下面的指令：<br/>Mov ax, 123H<br/>Mov [bx], ax<br/>Jmp word ptr  [bx]<br/>执行后，IP=123H<br/><br/><br/> 2. “jmp  dword ptr 内存单元地址”（段间转移）。<br/>功能：从内存单元地址处开始存放着两个字，高地址处的字为转移的目标段地址，低地址处的字为转移的目标偏移地址。<br/><br/> CS=内存单元地址＋2<br/> IP=内存单元地址<br/><br/> 内存单元地址可用寻址方式的任一格式给出。比如，下面的指令：<br/> Mov ax, 123H<br/> Mov DS:[200],  ax<br/> Mov word ptr DS:[202],  100<br/> Jmp dword ptr  DS:[200]<br/> 执行后，CS=100H，IP=123H，CS:IP指向100:123。<br/><br/> 又比如，下面的指令：<br/> Mov ax, 123H<br/> Mov [bx], ax<br/> Mov word ptr  [bx＋2], 100<br/> Jmp dword ptr  [bx]<br/> 执行后，CS=100H，IP=123H，CS:IP指向100:123。<br/><br/> 在上面的指令中，我们接触到了一个新的符号“dword”，它表示什么意思呢？前面我们已学过，Byte表示字节，word表示字，dword则表示双字，谢谢。<br/><br/></p><h2><b>6.5  CALL指令</b></h2><p>Call和ret指令都是转移指令，它们都修改IP，或同时修改CS和IP，它们经常被共同用来实现子程序的设计。这两节，我们讲解call和ret指令的原理。<br/><br/>CPU执行call指令时，进行两步操作：<br/>1.将当前的IP（或CS和IP）压入栈中。<br/>2.转移。<br/><br/><br/>Call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同，下面我们以给出转移目标地址的不同方法为主线，讲解call指令的主要应用格式。<br/><br/> 1. 依据位移进行转移的call指令。<br/> Call 标号（将当前的IP压入栈后，转到标号处执行指令）。指令执行时，它的功能相当于：<br/> Push IP<br/> Jmp near ptr  标号<br/><br/><br/> 2. 转移地址在指令中的call指令。<br/> Call far ptr  标号（实现的是段间转移）。<br/> 指令执行时，它的功能相当于：<br/> Push CS<br/> Push IP<br/> Jmp far ptr  标号<br/><br/><br/> 3. 转移地址在寄存器中的call指令。<br/> 指令格式：call 16位通用寄存器。<br/> 指令执行时，它的功能相当于：<br/> Push IP<br/> Jmp 16位通用寄存器<br/><br/><br/> 4. 转移地址在内存中的call指令。<br/> 这种call指令有两种格式：<br/> 格式1：call word ptr 内存单元地址。<br/> 指令执行时，它的功能相当于：<br/> Push IP<br/> Jmp word ptr  内存单元地址<br/><br/> 格式2：call dword ptr 内存单元地址。<br/> 指令执行时，它的功能相当于：<br/> Push CS<br/> Push IP<br/> Jmp dword  ptr  内存单元地址<br/><br/></p><h2><b>6.6 子程序</b></h2><p>Ret指令用栈中的数据修改IP的数值，从而实现近转移。Ret指令执行时，进行下面两步操作：<br/> 1. IP =（SS×16＋SP）<br/> 2. SP=SP＋2<br/><br/>指令执行时，它的功能相当于：pop IP<br/>学习了call和ret指令，现在来看一下，如何将它们配合使用来实现子程序的机制。请看下面的一段代码：<br/><br/> Mov ax, 1<br/> Mov cx, 3<br/> Call s<br/> Mov bx, ax<br/> Mov ax, 4c00H<br/> Int 21H<br/> S:add ax,ax<br/> Loop s<br/> Ret<br/><br/>我们来分析一下CPU执行这一段代码的过程。<br/>1. CPU执行第一、第二条指令后，CS:IP指向call s。<br/>2. CPU将call s指令的机器码读入，IP指向call s后的指令mov bx, ax。<br/>3. 执行call s指令，将当前IP值（指令mov bx, ax的偏移地址）压入栈中，并将IP的值改变为标号s处的偏移地址。<br/>4. CPU从标号s处执行指令，直至loop指令循环完毕（loop将会循环3次，因为cx=3，cx寄存器用于存放loop循环次数）。<br/>5. CPU指向并执行ret指令，从栈中弹出一个数据（即先前压入栈中的指令mov bx, ax的偏移地址）送入IP，则CS:IP指向指令mov bx, ax。<br/>6. CPU执行指令mov bx, ax。此时bx中存放了ax累加其自身3次的值：3。<br/>7. CPU继续向下执行，直到执行int  21H后，程序结束。</p><p><br/>上面第3、第5项是重点，它揭示了子程序执行完之后，如何让CPU接着call指令向下执行。什么是子程序？具有一定功能的程序段，我们称之为子程序。<br/><br/>比如，上面的那一段代码，s:add ax, bx到ret那3条指令就是一个简单的子程序，它的功能是把ax中的数值累加3次，用循环指令loop实现累加（累加次数由cx中的值决定）。<br/><br/>在需要的时候，我们用call指令转去执行它，执行完子程序后，要让CPU接着call指令向下执行，则需要用到ret指令，call指令转去执行子程序之前，call指令后面的指令的地址将被存储在栈中，在子程序的后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。<br/> </p><p>另外，在上面的示例代码中，int 21H和MOV AX,4C00H这两条指令又代表什么意思呢？请看下面的图文讲解。</p><p>其实很简单，INT 21H 调用了系统中断。<br/><br/>MOV AX,4C00H，意即：AH=4CH。<br/><br/>那么INT 21H和AH=4CH两者搭配的作用就是：调用 INT 21H 的 4CH 号中断，该中断就是安全退出程序。</p><p>换句话说，MOV AX,4C00H、INT 21H 这两句可以等价于以下两句：<br/>MOV AH,4CH<br/>INT 21H <br/><br/>接下来看看下面的图解，帮助自己理解所谓“中断例程”，实在理解不了也没关系，就当满足知识拓展之需要。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c22922fae407e8fdd44dfe66595bc6a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"252\" class=\"content_image\" width=\"398\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;398&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"398\" data-rawheight=\"252\" class=\"content_image lazy\" width=\"398\" data-actualsrc=\"https://pic1.zhimg.com/v2-c22922fae407e8fdd44dfe66595bc6a4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5342f267533dedcd7b5dc2db574ab164_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"245\" class=\"content_image\" width=\"399\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;399&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"399\" data-rawheight=\"245\" class=\"content_image lazy\" width=\"399\" data-actualsrc=\"https://pic1.zhimg.com/v2-5342f267533dedcd7b5dc2db574ab164_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第7章：标志寄存器</b></h2><p><b>引言</b><br/></p><p>CPU内部的寄存器中，有一种特殊的寄存器，它具有以下3种作用：<br/>1. 用来存储相关指令的某些执行结果。<br/>2. 用来为CPU执行相关指令提供行为依据。<br/>3. 用来控制CPU的相关工作方式。<br/><br/>这种特殊的寄存器在8086CPU中，被称为<b>标志寄存器</b>。<br/><br/>8086CPU的寄存器，在前面已经学过13个了，现在学习最后一个寄存器：FR-标志寄存器。<br/><br/>FR与其它寄存器不一样，其它寄存器是用来存放数据的，都是整个寄存器具有一个含义，而FR寄存器是按位起作用的，也就是说它的每一位都有专门的含义，记录特定的信息。<br/><br/>8086CPU的FR寄存器的结构如下图所示：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;929&#39; height=&#39;124&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"929\" data-rawheight=\"124\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"929\" data-original=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-90e93d80fb8fefafd82c2350a68608c0_b.png\"/></figure><p><br/>FR的第1、3、5、12、13、14、15位是空白位，在8086CPU中没有使用，不具有任何意义，而第0、2、4、6、7、8、9、10、11位都具有特殊的含义。<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>7.1 CF标志</b></h2><p>FR的第0位是CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br/><br/>对于位数为N的无符号数来说，其对应的二进制信息的最高位，即第N－1位，就是它的最高有效位，而假想存在的第N位，就是相对于最高有效位的更高位，如下图所示：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"829\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"829\" data-original=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;829&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"829\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"829\" data-original=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e025b7ce6c3d3438b8374501f9e7ac3_b.jpg\"/></figure><p><br/>我们知道，当两个数据相加的时候，有可能产生从最高有效位向更高位的进位，比如，两个位数据：98H＋98H，将产生进位，这个进位值就用CF标志位来保存。<br/><br/>比如，下面的指令：<br/>Mov al, 98H<br/>Add al, al<br/><br/>执行后，计算结果为130H，al=30H，CF=1，CF记录了从最高有效位向更高位的进位值。<br/>两数相加，如果产生了进位，则CF=1，如果没有产生进位，则CF=0。<br/> <br/>当两个数据做减法的时候，有可能向更高位借位，比如，两个8位数据：97H－98H，将产生借位，借位后相当于计算197H－98H，而FR的CF标志位也可以用来记录这个借位值。<br/><br/>比如，下面的指令：<br/>Mov al, 97H<br/>Sub al, 98H<br/><br/>执行后，计算结果为197H－98H=ffH，al=ffH，CF=1，CF记录了向更高位的借位值。<br/>两数相减，如果产生借位，则CF=1，如果没有产生借位，则CF=0。<br/><br/></p><h2><b>7.2  ADC指令</b></h2><p>Adc是带进位加法指令，它利用了CF位上记录的进位值。<br/>格式：adc  操作对象1，操作对象2<br/>功能：操作对象1=操作对象1＋操作对象2＋CF<br/><br/><br/>例1：<br/><br/>mov ax, 1<br/>Add ax, ax    结果：ax=2，没有产生进位值，CF=0。<br/>Adc ax,  3     结果：ax=ax＋3＋CF=2＋3＋0=5。<br/> <br/><br/>例2：<br/><br/>mov al, 98H<br/>Add al, al    结果=130H，产生了进位值，CF=1，al=30H。<br/>Adc al, 3     结果：al=al＋3＋CF=30H＋3＋1=34H。<br/><br/>可以看出，adc指令比add指令多加了一个CF位的值，为什么要加上CF的值呢？CPU为什么要提供这样一条指令呢？<br/>我们来看一下两个数据：0198H和0183H是如何相加的，见下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-122f429a2d6cbabbabb76edf2ed45712_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"150\" class=\"content_image\" width=\"174\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;174&#39; height=&#39;150&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"150\" class=\"content_image lazy\" width=\"174\" data-actualsrc=\"https://pic3.zhimg.com/v2-122f429a2d6cbabbabb76edf2ed45712_b.png\"/></figure><p><br/>可以看出，加法可以分两步来进行：</p><p>1.低位相加（98＋83）。<br/>2.高位相加再加上低位相加产生的进位值（1＋1＋1）。<br/><br/>看来CPU提供adc指令的目的，就是来进行加法的第二步运算的。用adc指令和add指令相配合就可以对更大的数据进行加法运算。<br/><br/><br/><br/>例3：计算1EF000H＋201000H，结果放在ax（高16位）和bx（低16位）中。<br/>因为两个数据的位数都大于16位，用add指令无法进行计算，我们将计算分两步进行，先将低16位（F000H和1000H）相加，然后将高16位（1EH和20H）和进位值相加，代码如下：<br/> <br/>Mov ax, 1eH<br/>Mov bx,  f000H<br/>Add bx, 1000H（低16位相加，结果：f000H＋1000H=10000H 产生了进位值，CF=1，bx=0）<br/>Adc ax, 20H（高16位相加，结果：ax=ax＋20H＋CF=1eH＋20H＋1=3fH）<br/><br/>最终结果：ax=3fH，bx=0，1EF000H＋201000H=3f0000H。<br/>Adc指令执行后，也可能产生进位值，所以也会对CF位进行设置，由于有这样的功能，我们就可以对任意大的数据进行加法运算。<br/> <br/><br/><br/>例4：计算1EF0001000H＋2010001EF0H，结果放在ax（最高16位），bx（次高16位），cx（低16位）中。<br/> <br/>计算分3步进行：<br/>1.先将低16位（1000H和1EF0H）相加，完成后，CF记录本次相加的进位值。<br/>2. 再将次高16位（F000H和1000H）和CF（来自低16位的进位值）相加，完成后，CF记录本次相加的进位值。<br/>3.最后最高16位（1EH和20H）和CF（来自次高16位的进位值）相加，完成后，CF记录本次相加的进位值。<br/><br/>代码如下：<br/>Mov ax, 1eH<br/>Mov bx,  f000H<br/>Mov cx,  1000H<br/>Add cx, 1ef0H（低16位相加，结果：1000H＋1ef0H=2ef0H，没有产生进位值，CF=0，cx=2ef0H）<br/>Adc bx, 1000H（次高16位相加，结果：f000H＋1000H＋0=10000H，产生进位值，CF=1，bx=0）<br/>Adc ax, 20H（最高16位相加，结果：ax=ax＋20H＋CF=1eH＋20H＋1=3fH，没有产生进位，CF=0）<br/><br/>最终结果：ax=3fH，bx=0，cx=2ef0H。1EF0001000H＋2010001EF0H=3F00002EF0H。<br/><br/></p><h2><b>7.3  SBB指令</b></h2><p>Sbb是带借位减法指令，它利用了CF位上记录的借位值。<br/><br/>格式：sbb  操作对象1，操作对象2<br/>功能：操作对象1=操作对象1－操作对象2－CF<br/><br/>Sbb指令执行后，将对CF进行设置，利用sbb指令和sub指令配合使用可以对任意大的数据进行减法运算。<br/><br/><br/>例1：计算3E1000H－202000H，结果放在ax（高16位），bx（低16位）。<br/>计算分两步进行，先将低16位（1000H和2000H）相减，然后将高16位（3EH和20H）和借位值相减，代码如下：<br/><br/>Mov bx,  1000H<br/>Mov ax, 3eH<br/>Sub bx, 2000H（低16位相减，结果：1000H－2000H=11000H－2000H=f000H，产生了借位值，CF=1，bx=f000H）<br/>Sbb ax, 20H（高16位相减，结果：ax=ax－20H－CF=3eH－20H－1=1dH，没有产生借位值，CF=0）<br/><br/>最终结果：ax=1dH，bx=f000H，3E1000H－202000H=1DF000H。<br/><br/><br/><br/>例2：计算6E4F0031C0H－1FA2002700H。结果放在ax（最高16位），bx（次高16位），cx（低16位）。</p><p>计算分3步进行：<br/>1. 先将低16位（31C0H和2700H）相减，完成后，CF记录本次相减的借位值。<br/>2. 再将次高16位（4F00H和A200H）和CF（来自低16位的借位值）相减，完成后，CF记录本次相减的借位值。<br/>3. 最后将最高16位（6EH和1FH）和CF（来自次高16位的借位值）相减，完成后，CF记录本次相减的借位值。<br/><br/>代码如下：<br/>Mov ax, 6eH<br/>Mov bx,  4f00H<br/>Mov cx,  31c0H<br/>Sub cx, 2700H（低16位相减，结果：31c0H－2700H=ac0H，没有产生借位值，CF=0，cx=ac0H）<br/>Sbb bx, a200H（次高16位相减，结果：14f00H－a200H=ad00H，产生借位值，CF=1，bx=ad00H）<br/>Sbb ax, 1fH（最高16位相减，结果：ax=ax－1fH－CF=6eH－1fH－1=4eH，没有产生借位值，CF=0）<br/><br/>最终结果：ax=4eH，bx=ad00H，cx=ac0H，6E4F0031C0H－1FA2002700H=4EAD000AC0H。<br/></p><h2><b>7.4 ZF标志</b></h2><p>FR的第6位是ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果（真），结果为0，那么ZF=1；如果（假），结果非0，那么ZF=0。<br/><br/>对于ZF的值，我们可以这样来看：在计算机中1表示逻辑真，表示肯定，所以当结果为0的时候，ZF=1；在计算机中0表示逻辑假，表示否定，所以当结果不为0的时候，ZF=0。<br/><br/><br/>且看下面的指令：<br/><br/>Mov ax, 5<br/>Sub ax, ax<br/>执行后，结果为0，表示真，则ZF=1。<br/><br/>Mov ax, 5<br/>Sub ax, 1<br/>执行后，结果不为0，表示假，则ZF=0。<br/></p><h2><b>7.5  cmp指令</b></h2><p>Cmp是比较指令，它的功能相当于sub指令，只是不保存结果。Cmp指令执行后，将对标志寄存器产生影响，其它相关指令通过识别这些被影响的标志位来得知比较结果。<br/><br/>指令格式：cmp 操作对象1，操作对象2<br/>功能：计算操作对象1－操作对象2，但并不保存结果，仅仅根据计算结果对标志寄存器的标志位进行设置。<br/><br/> Cmp指令执行后，依据标志位的值就可以看出比较结果。<br/> <br/>比如，<b>cmp  ax, bx</b>执行后：<br/>如果ZF=1，说明ax=bx，因为ax－bx=0，那么ax必定等于bx。<br/>如果ZF=0，说明ax≠bx，因为ax－bx≠0，那么ax与bx必定不相等。<br/>如果CF=1，说明ax＜bx，因为ax－bx产生了借位，那么ax必定小于bx。<br/>如果CF=0，说明ax≥bx，因为ax－bx没有产生借位，那么ax必定大于或等于bx。<br/>如果CF=0，并且ZF=0，说明ax＞bx，因为ax－bx没有产生借位，并且ax－bx≠0，那么ax必定大于bx。<br/>如果CF=1或ZF=1，说明ax≤bx，因为ax－bx产生了借位，又或者ax－bx=0，那么ax必定小于或等于Bx。<br/></p><h2><b>7.6 检测比较结果的条件转移指令</b></h2><p>转移指的是它能够修改IP，而条件指的是它可以根据某种条件，决定是否修改IP，所有条件转移指令都是短转移，转移的位移范围为﹣128~127。 <br/><br/>大多数条件转移指令都检测标志寄存器的相关标志位，根据检测的结果来决定是否修改IP，它们所检测的标志位都是被cmp指令影响的那些表示比较结果的标志位。<br/><br/><br/>下面是常用的根据无符号数的比较结果进行转移的条件转移指令：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;612&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"612\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"612\" data-original=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-95dc12bed096c41ac6669f8e50dea8dd_b.jpg\"/></figure><p><br/>以上这些条件转移指令是根据检测相关的标志位来决定是否转移，比如：je是检测ZF的值来决定是否转移，如果ZF=1则转移，至于根据逻辑含义来决定是否转移，则需要与cmp指令配合使用，这个在下一节会讲到。</p><h2><br/><b>7.7  cmp与条件转移指令配合使用</b></h2><p>上一节介绍的条件转移指令，所检测的标志位都是cmp指令进行无符号数比较的时候，记录比较结果的标志位，比如，je检测ZF位，当ZF=1时转移，如果在je前面使用了cmp指令，那么je对ZF的检测，实际上是间接地检测cmp的比较结果是否为两数相等。<br/><br/>请看下面一段代码：<br/>Cmp ax, bx<br/>Je s<br/>Add ax, bx<br/>Jmp short ok<br/>S:add ax,  ax<br/>ok: … <br/><br/>上面的代码执行时，如果ax=bx,则cmp ax, bx使ZF=1，而je检测ZF是否为1，如果为1，则转移到标号S处执行指令add ax, ax，我们也可以这样说，cmp比较ax, bx后所得到的相等的结果使得je指令进行转移，这种说法很好地体现了je指令的逻辑含义，即“相等则转移“。<br/><br/>“相等则转移”这种逻辑含义是通过和cmp指令配合使用来体现的，我们用cmp指令与条件转移指令配合使用的时候，不必再考虑cmp指令对相关标志位的影响和je等指令对相关标志位的检测，因为相关的标志位只是为 Cmp和je等指令传递比较结果，我们可以直接考虑cmp与je等指令配合使用时，表现出来的逻辑含义。<br/><br/><br/>请看下面的指令：<br/><br/>Cmp byte ptr [bx], 8（和8比较）<br/>Je 标号（如果等于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jne 标号（如果不等于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jb 标号（如果低于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jnb 标号（如果不低于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Ja 标号（如果高于则转移）<br/>Cmp byte ptr [bx], 8（和8比较）<br/>Jna 标号（如果不高于则转移）<br/><br/>上面的指令，用[bx]中的数值和8比较，“如果怎么怎么样则转移”，我们在修改游戏时，可以根据这些逻辑含义，选择合适的条件转移指令。</p><p><br/><i><b>妲己师娘：</b>Jb标号，和你的“<b>8</b>”相比较，如果怎么怎么样则<b>转移体位,</b>随着<b>爱的魔力</b>转圈圈！</i></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_b.jpg\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;554&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"554\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e128447c179477cdd71555ec34a11cee_b.jpg\"/><figcaption>cmp与条件转移指令之迷思：主人的命令是绝对的，爱的魔力转不停，好疯狂！</figcaption></figure><h2><br/><b>7.8 其它标志位</b></h2><p>标志寄存器的大部分标志位，我们都不必深入地去学习，因为这和修改游戏没有多大关系，我们只需简单了解一下即可，FR一共有9个标志位，前面已学习了ZF和CF这两个标志位，现在讲讲余下的7个标志位。<br/><br/>PF：奇偶标志位。它记录相关指令执行后，其结果的所有二进制位中1的个数是否为偶数，如果（真），1的个数为偶数，PF=1，如果（假），1的个数为奇数，PF=0。<br/><br/>比如，某些指令执行后，其结果二进制值为01001011，有4（偶数）个1，则PF=1；某些指令执行后，其结果二进制值为00001011，有3（奇数）个1，则PF=0。<br/><br/><br/>SF：符号标志位。它记录相关指令执行后，其结果是否为负，如果（真），结果为负，SF=1，如果（假），结果非负，SF=0。<br/><br/><br/>OF：溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出，如果（真），发生了溢出，OF=1，如果（假），没有发生溢出，0F=0。<br/><br/>什么是溢出？在进行有符号数运算的时候，如结果超过了机器所能表示的范围称为溢出。那么，机器所能表示的范围是多少呢？对于8位的有符号数据，机器所能表示的范围就是：-128~127；对于16位的有符号数据，机器所能表示的范围就是：﹣32768~32767。如果运算结果超出了机器所能表达的范围，将会产生溢出。<br/><br/> 比如，指令：<br/> Mov al, 98<br/> Add al, 99<br/><br/>执行后，al=98＋99=197，197超出了机器所能表示的8位有符号数的范围：﹣128~127，所以产生了溢出。<br/><br/><br/>DF：方向标志位。在串处理指令中，控制每次操作后SI、DI的增减。<br/>DF=0，每次操作后SI、DI递增；DF=1，每次操作后SI、DI递减。<br/><br/>DF标志位与串传送指令（movsb、movsw）有关，而串传送指令与游戏修改无关，所以不讲了（呵呵……）。<br/><br/><br/>TF：跟踪标志位。用于程序调试。<br/>如果TF=1，则CPU处于单步执行指令的工作方式，此时，每执行完一条指令，就显示CPU各个寄存器的当前值及CPU将要执行的下一条指令。如果TF=0，则处于连续工作模式。<br/><br/><br/>AF：辅助进位标志位。在下列情况下，AF的值被设置为1，否则其值为0。<br/>1. 在字操作时，发生低字节向高字节进位或借位时。<br/>2. 在字节操作时，发生低4位向高4位进位或借位时。<br/><br/><br/>IF：中断允许标志位。用来决定CPU是否响应CPU外部的&#34;可屏蔽中断&#34;发出的中断请求，当IF=1，响应中断请求，当IF=0，不响应中断请求。<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;716&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"716\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"716\" data-original=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1e645d487e2b525a612839e0a8cd0962_b.jpg\"/></figure><h2><b>7.9  lea和nop指令</b></h2><p>Lea为有效地址传送指令。<br/><br/>格式：lea  操作对象1，操作对象2<br/>功能：将源操作数给出的有效地址传送到指定的寄存器中。<br/>说明：操作对象1为目的操作数，可为任意一个16位的通用寄存器，操作对象2为源操作数，可为地址表达式。<br/><br/>比如，指令：<br/>Lea ax,  [217a]<br/>执行后，ax=217aH。<br/><br/>Lea ax, [bx＋si＋200]<br/>执行后，ax= bx＋si＋200H。<br/> <br/><br/>Nop为空操作指令。<br/>格式：nop。<br/>功能：本指令不产生任何结果，仅消耗几个时钟周期的时间，接着执行后续指令，常用于程序的延时等。<br/>用途：在修改游戏的时候，可用于锁定某些数据的数值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6355eee5cc3568be7711b72d06d64ced_b.jpg\" data-size=\"normal\" data-rawwidth=\"1386\" data-rawheight=\"654\" class=\"origin_image zh-lightbox-thumb\" width=\"1386\" data-original=\"https://pic2.zhimg.com/v2-6355eee5cc3568be7711b72d06d64ced_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1386&#39; height=&#39;654&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1386\" data-rawheight=\"654\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1386\" data-original=\"https://pic2.zhimg.com/v2-6355eee5cc3568be7711b72d06d64ced_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6355eee5cc3568be7711b72d06d64ced_b.jpg\"/><figcaption>Nop锁定机械姬 • 邪恶大师娘的所有欲念数据：色即是空</figcaption></figure><hr/><h2><b><i>注：后续篇章请点下面链接观看——</i></b></h2><a href=\"https://zhuanlan.zhihu.com/p/77809972\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-d3931279b772fe5c251808c791f9cace_180x120.jpg\" data-image-width=\"818\" data-image-height=\"596\" class=\"internal\">果壳王子：果壳疯狂编程——机械姬 • 汇编之美</a><h2><b>本书由果壳王子撰写，如有雷同，那就雷同！</b></h2><p><br/><b><i>果壳王子微信：gkwz1983</i></b></p><p><b><i>果壳学院QQ群：1群（327610461）、2群（465560580）</i></b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;482&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"482\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"482\" data-original=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e2c1f7c8e5d347cb728d14a2e1f79414_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "汇编语言（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20731784"
                }, 
                {
                    "tag": "汇编入门书籍", 
                    "tagLink": "https://api.zhihu.com/topics/19999182"
                }
            ], 
            "comments": [
                {
                    "userName": "卡特黑兰", 
                    "userLink": "https://www.zhihu.com/people/9b45c2de646e58af220b4c600e40ab5f", 
                    "content": "[赞][赞][赞][爱]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "mystert", 
                    "userLink": "https://www.zhihu.com/people/f5d72740d68628fcd6d428e582652844", 
                    "content": "热爱", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "kobe", 
                    "userLink": "https://www.zhihu.com/people/1daa6a55372fbbd86ddc56f74e3e46df", 
                    "content": "<p>王爽</p><a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-ba306425d0a7aee2c7260381f1bf7b97.gif\" data-width=\"\" data-height=\"\">[欢呼]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "专业！", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "10101", 
                    "userLink": "https://www.zhihu.com/people/ddb992ac7381149108ccad0e64c950fa", 
                    "content": "ghs[滑稽]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小橘子", 
                    "userLink": "https://www.zhihu.com/people/8b4121058bc9d5dd7325e3d5093c19c5", 
                    "content": "谢谢大佬拯救!!!", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1129700018508210176"
}
