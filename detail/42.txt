{
    "title": "前端外网文章翻译", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/zheng-xue-bing-72", 
        "https://www.zhihu.com/people/winter-23-64", 
        "https://www.zhihu.com/people/bunny-com", 
        "https://www.zhihu.com/people/CedricChan", 
        "https://www.zhihu.com/people/wang-ting-zhi-77", 
        "https://www.zhihu.com/people/devilsm", 
        "https://www.zhihu.com/people/horizon-88-83", 
        "https://www.zhihu.com/people/sha-la-bo-wa-63", 
        "https://www.zhihu.com/people/iFwu", 
        "https://www.zhihu.com/people/jorden-chang", 
        "https://www.zhihu.com/people/mo-lin-97-96", 
        "https://www.zhihu.com/people/wang-ze-ming-11-75", 
        "https://www.zhihu.com/people/li-yan-liang-99", 
        "https://www.zhihu.com/people/jason-20-17-14", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/zhang-en-hao", 
        "https://www.zhihu.com/people/yh-ding"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/74440436", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 1, 
            "title": "从ElementUI的loading组件说起", 
            "content": "<h2>原文地址：</h2><a href=\"https://link.zhihu.com/?target=https%3A//alfxjx.github.io/2019/07/20/%25E4%25BB%258EElement%25E7%259A%2584loading%25E7%25BB%2584%25E4%25BB%25B6%25E8%25AF%25B4%25E8%25B5%25B7/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从ElementUI的loading组件说起</a><h2><b>前言</b></h2><p>最近发现自己的<a href=\"https://link.zhihu.com/?target=http%3A//www.alfxjx.club/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">主页</a>首屏加载很慢，于是想用一个loading组件掩饰一下，这一下就来到了知识的荒原，对插件几乎一无所知，就知道<code>v-model</code>之流，于是学习了一下<code>element-ui</code>的写法，并自己写一个插件出来。</p><h2><b>element ui 的loading文档</b></h2><p>看一下loading的<a href=\"https://link.zhihu.com/?target=https%3A//element.eleme.cn/%23/zh-CN/component/loading\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">文档</a>，发现loading除了常规的一些配置项之外，有指令式和服务式（directive&amp;service)两种模式：</p><p>指令式是这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"> <span class=\"o\">&lt;</span><span class=\"nx\">el</span><span class=\"o\">-</span><span class=\"nx\">button</span>\n    <span class=\"nx\">type</span><span class=\"o\">=</span><span class=\"s2\">&#34;primary&#34;</span>\n    <span class=\"err\">@</span><span class=\"nx\">click</span><span class=\"o\">=</span><span class=\"s2\">&#34;openFullScreen&#34;</span>\n    <span class=\"nx\">v</span><span class=\"o\">-</span><span class=\"nx\">loading</span><span class=\"p\">.</span><span class=\"nx\">fullscreen</span><span class=\"p\">.</span><span class=\"nx\">lock</span><span class=\"o\">=</span><span class=\"s2\">&#34;fullscreenLoading&#34;</span><span class=\"o\">&gt;</span>\n    <span class=\"nx\">指令方式</span>\n <span class=\"o\">&lt;</span><span class=\"err\">/el-button&gt;</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n    <span class=\"nx\">data</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"k\">return</span> <span class=\"p\">{</span>\n        <span class=\"nx\">fullscreenLoading</span><span class=\"o\">:</span> <span class=\"kc\">false</span>\n      <span class=\"p\">}</span>\n    <span class=\"p\">},</span>\n<span class=\"p\">}</span>    \n</code></pre></div><p>服务式是这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"p\">{</span> <span class=\"nx\">Loading</span> <span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;element-ui&#39;</span><span class=\"p\">;</span>\n<span class=\"kd\">let</span> <span class=\"nx\">loadingInstance</span> <span class=\"o\">=</span> <span class=\"nx\">Loading</span><span class=\"p\">.</span><span class=\"nx\">service</span><span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">);</span>\n<span class=\"c1\">// 以服务的方式调用的 Loading 需要异步关闭\n</span><span class=\"c1\"></span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">$nextTick</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span> \n  <span class=\"nx\">loadingInstance</span><span class=\"p\">.</span><span class=\"nx\">close</span><span class=\"p\">();</span>\n<span class=\"p\">});</span>\n</code></pre></div><p>可以看出，两种模式一个是自定义指令，一个是定义了一个全局方法。</p><h2><b>loading源码分吸</b></h2><p>那就看看源码是怎么实现的吧</p><p>目录结构是这样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">- loading\n    - src\n        - directive.js\n        - index.js\n        - loading.vue\n    - index.js</code></pre></div><p>还是很整齐的。</p><p>在loading/index.js中，引入了指令和服务两种：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"nx\">directive</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./src/directive&#39;</span><span class=\"p\">;</span>\n<span class=\"k\">import</span> <span class=\"nx\">service</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./src/index&#39;</span><span class=\"p\">;</span>\n<span class=\"err\">​</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n  <span class=\"nx\">install</span><span class=\"p\">(</span><span class=\"nx\">Vue</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"nx\">directive</span><span class=\"p\">);</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">$loading</span> <span class=\"o\">=</span> <span class=\"nx\">service</span><span class=\"p\">;</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">directive</span><span class=\"p\">,</span>\n  <span class=\"nx\">service</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3><b>服务式的代码（<a href=\"https://link.zhihu.com/?target=https%3A//github.com/ElemeFE/element/blob/dev/packages/loading/src/index.js\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">src/index.js</a>）</b></h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 通过vue.extend()新建一个子类LoadingConstructor\n</span><span class=\"c1\">// loadingvue是对应的loading的模板\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">LoadingConstructor</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">extend</span><span class=\"p\">(</span><span class=\"nx\">loadingVue</span><span class=\"p\">);</span>\n<span class=\"c1\">// 默认设置项\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">defaults</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"c1\">// 设置样式的一个方法，不是loading的重点\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">addStyle</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">options</span><span class=\"p\">,</span> <span class=\"nx\">parent</span><span class=\"p\">,</span> <span class=\"nx\">instance</span><span class=\"p\">)</span> <span class=\"p\">=&gt;{}</span>\n<span class=\"c1\">// 主要方法\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">Loading</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">options</span> <span class=\"o\">=</span> <span class=\"p\">{})</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"p\">...</span>\n    <span class=\"c1\">// 新建实例\n</span><span class=\"c1\"></span>    <span class=\"kd\">let</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">LoadingConstructor</span><span class=\"p\">({</span>\n        <span class=\"nx\">el</span><span class=\"o\">:</span> <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">createElement</span><span class=\"p\">(</span><span class=\"s1\">&#39;div&#39;</span><span class=\"p\">),</span>\n        <span class=\"nx\">data</span><span class=\"o\">:</span> <span class=\"nx\">options</span>\n    <span class=\"p\">});</span>\n    <span class=\"p\">...</span>\n    <span class=\"c1\">// 挂载，异步显示\n</span><span class=\"c1\"></span>    <span class=\"nx\">parent</span><span class=\"p\">.</span><span class=\"nx\">appendChild</span><span class=\"p\">(</span><span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">$el</span><span class=\"p\">);</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">nextTick</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">visible</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">});</span>\n    <span class=\"k\">return</span> <span class=\"nx\">instance</span>\n<span class=\"p\">}</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">Loading</span><span class=\"p\">;</span>\n</code></pre></div><h3><b>指令式代码（<a href=\"https://link.zhihu.com/?target=https%3A//github.com/ElemeFE/element/blob/dev/packages/loading/src/directive.js\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">src/directive.js</a>）</b></h3><p>对于自定义指令<code>v-loading</code>，只需要绑定<code>Boolean</code>即可。默认状况下，Loading 遮罩会插入到绑定元素的子节点，通过添加<code>body</code>修饰符，可以使遮罩插入至 DOM 中的 body 上。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"nx\">Loading</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./loading.vue&#39;</span><span class=\"p\">;</span>\n<span class=\"p\">...</span>\n<span class=\"k\">const</span> <span class=\"nx\">Mask</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">extend</span><span class=\"p\">(</span><span class=\"nx\">Loading</span><span class=\"p\">);</span>\n<span class=\"k\">const</span> <span class=\"nx\">loadingDirective</span> <span class=\"o\">=</span> <span class=\"p\">{};</span>\n<span class=\"c1\">// main\n</span><span class=\"c1\"></span><span class=\"nx\">loadingDirective</span><span class=\"p\">.</span><span class=\"nx\">install</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">toggleLoading</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">binding</span><span class=\"p\">.</span><span class=\"nx\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">nextTick</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 生成dom并调用insertDOM方法插入dom\n</span><span class=\"c1\"></span>            <span class=\"p\">})</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"nx\">afterLeave</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">.</span><span class=\"nx\">instance</span><span class=\"p\">,</span> <span class=\"nx\">_</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 将loading删掉\n</span><span class=\"c1\"></span>            <span class=\"p\">})</span>\n            <span class=\"nx\">el</span><span class=\"p\">.</span><span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">visible</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"p\">;</span>\n            <span class=\"nx\">el</span><span class=\"p\">.</span><span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">hiding</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">const</span> <span class=\"nx\">insertDom</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">parent</span><span class=\"p\">,</span> <span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{}</span>\n    <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">directive</span><span class=\"p\">(</span><span class=\"s1\">&#39;loading&#39;</span><span class=\"p\">,</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 绑定到dom\n</span><span class=\"c1\"></span>        <span class=\"nx\">bind</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">,</span> <span class=\"nx\">vnode</span><span class=\"p\">){</span>\n            <span class=\"c1\">// 新建了一个loading实例\n</span><span class=\"c1\"></span>            <span class=\"k\">const</span> <span class=\"nx\">mask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">Mask</span><span class=\"p\">()</span>\n            <span class=\"p\">...</span>\n            <span class=\"nx\">binding</span><span class=\"p\">.</span><span class=\"nx\">value</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">toggleLoading</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">);</span>\n        <span class=\"p\">},</span>\n        <span class=\"c1\">// 更新视图\n</span><span class=\"c1\"></span>        <span class=\"nx\">update</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">)</span> <span class=\"p\">{},</span>\n        <span class=\"c1\">// 删除视图\n</span><span class=\"c1\"></span>        <span class=\"nx\">unbind</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">el</span><span class=\"p\">,</span> <span class=\"nx\">binding</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>            <span class=\"nx\">el</span><span class=\"p\">.</span><span class=\"nx\">instance</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">el</span><span class=\"p\">.</span><span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">$destroy</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">})</span>\n<span class=\"p\">}</span>\n<span class=\"err\">​</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">loadingDirective</span><span class=\"p\">;</span>\n</code></pre></div><p>源代码中还有很多配置项的写法，这里就不一一说了。</p><h2><b>vue js 中相关概念</b></h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/plugins.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">plugins</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%23Vue-extend\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vue.extend()</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%23Vue-use\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vue.use()</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/api/%23vm-nextTick\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vm.$nextTick()</a></li></ul><h2><b>实现一个自己的Loading插件</b></h2><h3><b>起步</b></h3><p>设置模板文件<code>loading.vue</code></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n  &lt;div v-show=&#34;show&#34; class=&#34;loading-wrapper&#34;&gt;\n    &lt;img src=&#34;../../assets/loading.png&#34; alt=&#34;&#34; class=&#34;loading&#34;/&gt;\n    &lt;p&gt;loading...&lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n​\n&lt;script type=&#34;text/ecmascript-6&#34;&gt;\n  export default {\n    name: &#39;loading&#39;,\n    data() {\n      return {\n        show: false\n      }\n    }\n  }\n&lt;/script&gt;\n​\n&lt;style&gt;\n  .loading-wrapper {\n    background: #e3e3e3;\n    position: absolute;\n    top: 0;\n    left: 0;\n    z-index: 100;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n    height: 100vh;\n  }\n​\n  .loading {\n    animation: rotate 2s infinite;\n  }\n​\n  @keyframes rotate {\n    0% {\n      transform: rotate(0deg);\n    }\n    50% {\n      transform: rotate(180deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n&lt;/style&gt;\n​</code></pre></div><p><code>index.js</code>负责主要的逻辑</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"nx\">loadingVue</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./loading&#39;</span>\n<span class=\"err\">​</span>\n<span class=\"kd\">let</span> <span class=\"nx\">loading</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n<span class=\"err\">​</span>\n<span class=\"nx\">loading</span><span class=\"p\">.</span><span class=\"nx\">install</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">Vue</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">const</span> <span class=\"nx\">LoadingConstructor</span> <span class=\"o\">=</span> <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">extend</span><span class=\"p\">(</span><span class=\"nx\">loadingVue</span><span class=\"p\">)</span>\n  <span class=\"k\">const</span> <span class=\"nx\">instance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">LoadingConstructor</span><span class=\"p\">()</span>\n<span class=\"err\">​</span>\n  <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">$mount</span><span class=\"p\">(</span><span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">createElement</span><span class=\"p\">(</span><span class=\"s1\">&#39;div&#39;</span><span class=\"p\">))</span>\n  <span class=\"nb\">document</span><span class=\"p\">.</span><span class=\"nx\">body</span><span class=\"p\">.</span><span class=\"nx\">appendChild</span><span class=\"p\">(</span><span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">$el</span><span class=\"p\">)</span>\n<span class=\"err\">​</span>\n  <span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">prototype</span><span class=\"p\">.</span><span class=\"nx\">$loading</span> <span class=\"o\">=</span> <span class=\"p\">()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">show</span> <span class=\"o\">=</span> <span class=\"kc\">true</span>\n    <span class=\"nx\">setTimeout</span><span class=\"p\">(()</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n      <span class=\"nx\">instance</span><span class=\"p\">.</span><span class=\"nx\">show</span> <span class=\"o\">=</span> <span class=\"kc\">false</span>\n    <span class=\"p\">},</span> <span class=\"mi\">2000</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"err\">​</span>\n<span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"nx\">loading</span>\n<span class=\"err\">​</span>\n</code></pre></div><h3><b>使用</b></h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// main.js\n</span><span class=\"c1\"></span><span class=\"k\">import</span> <span class=\"nx\">loading</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./plugins/loading&#39;</span>\n\n<span class=\"nx\">Vue</span><span class=\"p\">.</span><span class=\"nx\">use</span><span class=\"p\">(</span><span class=\"nx\">loading</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// usage\n</span><span class=\"c1\"></span><span class=\"k\">export</span> <span class=\"k\">default</span> <span class=\"p\">{</span>\n\t<span class=\"nx\">created</span><span class=\"p\">(){</span>\n\t\t<span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">$loading</span><span class=\"p\">()</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//www.alfxjx.club/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在线演示</a></p><h2><b>Ref</b></h2><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/plugins.html%23%25E5%25BC%2580%25E5%258F%2591%25E6%258F%2592%25E4%25BB%25B6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Vue.js</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//element.eleme.cn/%23/zh-CN/component/installation\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">element ui doc</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000012224638\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">简单的例子实现vue插件</a></li></ul><p></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "插件", 
                    "tagLink": "https://api.zhihu.com/topics/19561210"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70281238", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 0, 
            "title": "Pandas使用必知必会", 
            "content": "<p>最近又捡起来了python和pandas，因为发现需要一些数据处理的相关知识，这篇文章就是总结了一些比较基本的pandas/python数据处理的操作。</p><p><b>数据来源</b></p><p>这一次的实验数据来自于<a href=\"https://link.zhihu.com/?target=https%3A//data.cityofchicago.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">data.gov</a>里面的芝加哥犯罪记录数据。总计1.7GB（csv），确实可以说是很大了。这个网站上面还有其他的一些数据，并且也配备了在线的可视化工具，可以说是很方便啦。</p><h2><b>基本的读取文件操作</b></h2><p>下面都是用code来解释好啦</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\"># 引入依赖</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"kn\">as</span> <span class=\"nn\">pd</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 读取文件</span>\n<span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s1\">&#39;./Crimes_-_2001_to_present.csv&#39;</span><span class=\"p\">)</span>\n<span class=\"c1\"># 实验环境</span>\n<span class=\"n\">df</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n<span class=\"c1\"># 生产环境</span>\n<span class=\"c1\"># df = data</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 显示实验环境下的尺寸 (10, 30)</span>\n<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">shape</span></code></pre></div><p>对数据进行一些预处理，把其中NaN设置为-1：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\"># 显示实验环境下的尺寸 (10, 30)</span>\n<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n<span class=\"err\">​</span>\n<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">isnull</span><span class=\"p\">()</span>\n<span class=\"err\">​</span>\n<span class=\"c1\"># 替换缺失NAN</span>\n<span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">fillna</span><span class=\"p\">(</span><span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span></code></pre></div><p>接下来根据犯罪的种类统计一下犯罪数，并排序显示</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\"># 统计犯罪种类个数</span>\n<span class=\"n\">crime_count</span> <span class=\"o\">=</span> <span class=\"n\">df</span><span class=\"o\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">by</span><span class=\"o\">=</span><span class=\"s1\">&#39;Primary Type&#39;</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">count</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">sort_values</span><span class=\"p\">(</span><span class=\"s1\">&#39;Case Number&#39;</span><span class=\"p\">,</span> <span class=\"n\">ascending</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\n<span class=\"n\">crime_count</span><span class=\"p\">[</span><span class=\"s1\">&#39;ID&#39;</span><span class=\"p\">]</span></code></pre></div><p>结果(以前十个为例)：</p><blockquote>Primary Type THEFT        5 BATTERY      4 NARCOTICS    1 Name: ID, dtype: int64</blockquote><p>未完待续</p><h2><b>参考</b></h2><a href=\"https://link.zhihu.com/?target=https%3A//data.cityofchicago.org/Public-Safety/Crimes-2001-to-present/ijzp-q8t2\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Crimes - 2001 to present</a><a href=\"https://link.zhihu.com/?target=http%3A//pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pandas.DataFrame.loc - pandas 0.24.2 documentation</a><a href=\"https://link.zhihu.com/?target=http%3A//everyang.net/category/%25e7%25a7%2591%25e6%258a%2580/python/pandas/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-8ab76a45b23a8050eeaedf5bc345331b_180x120.jpg\" data-image-width=\"300\" data-image-height=\"165\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pandas | EverYang 的博客</a><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c9a2e11e51d4561326736b8\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">pandas常用操作总结【持续更新】 - 掘金</a><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "Pandas(Python)", 
                    "tagLink": "https://api.zhihu.com/topics/20179633"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61644044", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 8, 
            "title": "JS如何用正则表达式判断一个数是否是质数", 
            "content": "<p>本文展示了一种判断一个数是否是质数的奇技淫巧，采用的是正则表达式方法。</p><hr/><h3><b>太长不看</b></h3><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">isPrime</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">){</span>\n    <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"nb\">Array</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">).</span><span class=\"nx\">match</span><span class=\"p\">(</span><span class=\"sr\">/^1?$|^(11+?)\\1+?$/</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3><b>原理解释</b></h3><p>这个方法主要分为三步：</p><ol><li>将待求数字转变为一元形式（unary form）;</li><li>检测这个数是一还是零；</li><li>检测这个数是否是很多个1组成；</li></ol><p>我们分开来慢慢说：</p><ol><li><code>Array(n+1).join(1)</code>这是将数字转化为一个长度为待求n+1的数组。<br/>在ES6下，也可以这么写：<code>&#34;1&#34;.repeat(n)</code>;</li><li>接下来就是正则匹配的过程。<code>/^1?$/</code>匹配的是一个开头为1，结尾也是1的数，数量为1个或者一个也没有。这就是第二步的作用。</li><li><code>/^(11+?)\\1+$/</code> 这个正则匹配的是第三步，首先一个捕获组（<code>/11+?</code>/）匹配的是至少两个11为一组的情况，在 <code>+</code> 之后的 <code>?</code> 表示这个匹配是非贪心的，要是没有这个？的话，这个捕获组就会匹配全部的字符串了。</li><li>再之后我们看一下<code>\\1+?</code>，这会返回第一个匹配的位置，<code>+?</code>同样表示非贪心匹配。</li><li>总而言之，第三步是这样匹配的：当捕获组匹配到“11”时，同时会确定他的位置，接着正则表达式会匹配复数个&#34;11&#34;，如果匹配失败了（例如n是奇数的情况），那么匹配会返回之前的位置，并在括号里面加一个1来继续匹配，重复上面的动作。</li><li>这看起来就好像在使用多个数去整除输入的整数n一样。</li><li>如果匹配结果是true，那么就说明这个数是1）0或1；2）它会被整除，因此是合数，所以给返回值添加一个取反(<code>!</code>)。</li></ol><p>ES6 的写法是这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">isPrime</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">){</span>\n    <span class=\"k\">const</span> <span class=\"nx\">regex</span> <span class=\"o\">=</span> <span class=\"sr\">/^1+?$|^(11+?)\\1+?$/</span>\n    <span class=\"k\">return</span> <span class=\"o\">!</span><span class=\"p\">(</span><span class=\"s2\">&#34;1&#34;</span><span class=\"p\">.</span><span class=\"nx\">repeat</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">).</span><span class=\"nx\">match</span><span class=\"p\">(</span><span class=\"nx\">regex</span><span class=\"p\">))</span>\n<span class=\"p\">}</span>\n</code></pre></div><h3><b>其他</b></h3><p>相信你也能看出来，这个方法非常的蛮。是的，一般来说判断一个数是否是质数的方法是这样的：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">isPrime</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">){</span>\n    <span class=\"k\">const</span> <span class=\"nx\">root</span> <span class=\"o\">=</span> <span class=\"nb\">Math</span><span class=\"p\">,</span><span class=\"nx\">sqrt</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"p\">)</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kd\">let</span> <span class=\"nx\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"nx\">i</span><span class=\"o\">&lt;=</span><span class=\"nx\">root</span><span class=\"p\">;</span><span class=\"nx\">i</span><span class=\"o\">+=</span><span class=\"mi\">2</span><span class=\"p\">){</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">n</span><span class=\"o\">%</span><span class=\"nx\">i</span><span class=\"o\">===</span><span class=\"mi\">0</span><span class=\"p\">){</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"kc\">true</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>时间复杂度是O(n^0.5)，这个方法大概是O(n);</p><p>此外，该方法受String长度的限制，大多数浏览器中，string的最大长度小于2.68亿，所以不能判断诸如<code>1000000000000066600000000000001</code>是否是质数。（当然她是）</p><p>总的来说，这个方法也蛮有意思的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=https%3A//itnext.io/a-wild-way-to-check-if-a-number-is-prime-using-a-regular-expression-4edfb725f895\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">原文链接</a></p><p>编译的文章首发于</p><a href=\"https://link.zhihu.com/?target=https%3A//alfxjx.github.io/2019/04/07/%25E5%25A6%2582%25E4%25BD%2595%25E7%2594%25A8%25E6%25AD%25A3%25E5%2588%2599%25E8%25A1%25A8%25E8%25BE%25BE%25E5%25BC%258F%25E5%2588%25A4%25E6%2596%25AD%25E4%25B8%2580%25E4%25B8%25AA%25E6%2595%25B0%25E6%2598%25AF%25E5%2590%25A6%25E6%2598%25AF%25E8%25B4%25A8%25E6%2595%25B0/\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Live life to the fullest.</a><p></p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "正则表达式", 
                    "tagLink": "https://api.zhihu.com/topics/19577832"
                }, 
                {
                    "tag": "素数", 
                    "tagLink": "https://api.zhihu.com/topics/19669697"
                }
            ], 
            "comments": [
                {
                    "userName": "谜之枪兵X", 
                    "userLink": "https://www.zhihu.com/people/1ff925882b19d3b1eea87263a0104360", 
                    "content": "说素数判别方法的时候一般用n代表被判别的数在非一进制中的位数，而不是被判别的数本身。", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59864714", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 1, 
            "title": "Vue-cli3下引入字体以及骨架屏加载实践", 
            "content": "<p>本文主要分为两部分，一个是介绍vue-cli3下的webpack配置，一个是如何将外部字体文件引入进来。</p><p><b>全部代码见</b></p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/Alfxjx/skeleton-vue-test\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-0a7583322a5a58d30cf85fb9e091741f_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Alfxjx/skeleton-vue-test</a><p>这个demo里面还测试了<a href=\"https://link.zhihu.com/?target=https%3A//github.com/hilongjw/vue-lazyload\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">lazy-load</a></p><p><b>演示地址：</b></p><a href=\"https://link.zhihu.com/?target=https%3A//alfxjx.github.io/skeleton-vue-test/\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-82b9c7a5a3f405032b1db71a25f67021_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">skeleton-test</a><p>求个star， 么么哒<a href=\"https://link.zhihu.com/?target=https%3A//alfxjx.github.io/skeleton-vue-test/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">skeleton-test</a>求个star， 么么哒</p><hr/><h2><b>webpack 配置</b></h2><p>Vue-cli3相比于cli2，大大简化了webpack的配置，这是一件好事，也给我带来了一些困扰，比如目前的网上的教程基本都是基于cli2的，很少有关于cli3的，在引入字体的时候，使用<code>assetsPath</code>方法就会报错。</p><p>我的解决方法是这样的：设置一个<code>utils</code>对象，手动添加工具函数。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// vue.config.js\n</span><span class=\"c1\"></span><span class=\"k\">const</span> <span class=\"nx\">utils</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"nx\">assetsPath</span><span class=\"o\">:</span> <span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">_path</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"nx\">assetsSubDirectory</span> <span class=\"o\">=</span> <span class=\"nx\">process</span><span class=\"p\">.</span><span class=\"nx\">env</span><span class=\"p\">.</span><span class=\"nx\">NODE_ENV</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;production&#39;</span>\n        <span class=\"c1\">// 生产环境下的 static 路径\n</span><span class=\"c1\"></span>        <span class=\"o\">?</span> <span class=\"s1\">&#39;static&#39;</span>\n        <span class=\"c1\">// 开发环境下的 static 路径\n</span><span class=\"c1\"></span>        <span class=\"o\">:</span> <span class=\"s1\">&#39;static&#39;</span>\n\n    <span class=\"k\">return</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">posix</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">assetsSubDirectory</span><span class=\"p\">,</span> <span class=\"nx\">_path</span><span class=\"p\">)</span>\n  <span class=\"p\">},</span>\n  <span class=\"nx\">resolve</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(</span><span class=\"nx\">dir</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"s1\">&#39;..&#39;</span><span class=\"p\">,</span> <span class=\"nx\">dir</span><span class=\"p\">)</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样一来就方便添加字体以及骨架屏（skeleton）了。</p><h2><b>如何引入字体文件（ttf...)</b></h2><p>我的方案是这样的：</p><ul><li>首先把字体文件（.ttf之类的）放在<code>src/common/font/</code>下；</li><li>接着在font文件夹里面新建一个<code>font.css</code>:</li><li>在文件夹里面放好字体文件（Avinda.ttf)</li></ul><div class=\"highlight\"><pre><code class=\"language-css\"><span class=\"p\">@</span><span class=\"k\">font-face</span><span class=\"p\">{</span>\n    <span class=\"nt\">font-family</span><span class=\"o\">:</span> <span class=\"s2\">&#34;avinda&#34;</span><span class=\"o\">;</span>\n    <span class=\"o\">//</span> <span class=\"nt\">路径为绝对路径</span>\n    <span class=\"nt\">src</span><span class=\"o\">:</span> <span class=\"nt\">url</span><span class=\"o\">(</span><span class=\"s1\">&#39;Avinda.ttf&#39;</span><span class=\"o\">)</span>\n<span class=\"p\">}</span></code></pre></div><ul><li>在<code>vue.config.js</code>按照这样配置：</li></ul><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">configureWebpack</span><span class=\"o\">:</span><span class=\"p\">{</span>\n        <span class=\"nx\">plugins</span><span class=\"o\">:</span><span class=\"p\">[...],</span>\n        <span class=\"nx\">module</span><span class=\"o\">:</span><span class=\"p\">{</span>\n            <span class=\"nx\">rules</span><span class=\"o\">:</span><span class=\"p\">[</span>\n            <span class=\"p\">{</span>\n              <span class=\"nx\">test</span><span class=\"o\">:</span><span class=\"sr\">/\\.(woff2?|eot|ttf|otf)(\\?.*)$/</span><span class=\"p\">,</span>\n              <span class=\"nx\">loader</span><span class=\"o\">:</span><span class=\"s1\">&#39;url-loader&#39;</span><span class=\"p\">,</span>\n              <span class=\"nx\">options</span><span class=\"o\">:</span><span class=\"p\">{</span>\n                <span class=\"nx\">limit</span><span class=\"o\">:</span> <span class=\"mi\">10000</span><span class=\"p\">,</span>\n                <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"nx\">utils</span><span class=\"p\">.</span><span class=\"nx\">assetsPath</span><span class=\"p\">(</span><span class=\"s1\">&#39;fonrs/[name].[hash:7].[ext]&#39;</span><span class=\"p\">)</span>\n              <span class=\"p\">}</span>\n            <span class=\"p\">}</span>\n          <span class=\"p\">]</span>\n        <span class=\"p\">},</span> \n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样就成功了。</p><h2><b>骨架屏</b></h2><p>骨架屏选择的是这个<b><a href=\"https://link.zhihu.com/?target=https%3A//github.com/lavas-project/vue-skeleton-webpack-plugin\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">vue-skeleton-webpack-plugin</a></b>，使用方法见对应的项目地址，但是这样做了之后，运行<code>npm run serve</code> 的时候，会出现错误：</p><div class=\"highlight\"><pre><code class=\"language-text\">Entry module not found: Error: Can&#39;t resolve &#39;I:\\workspace\\vue\\src\\entry-skeleton.js&#39; in &#39;I:\\workspace\\vue\\skeleton-test&#39;:\nError: Can&#39;t resolve &#39;I:\\workspace\\vue\\src\\entry-skeleton.js&#39; in &#39;I:\\workspace\\vue\\skeleton-test&#39;</code></pre></div><p>检查了一下是路径有问题。</p><p>修改方法：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// in vue.config.js configureWebpack :{}\n</span><span class=\"c1\"></span><span class=\"nx\">plugins</span><span class=\"o\">:</span> <span class=\"p\">[</span>\n      <span class=\"k\">new</span> <span class=\"nx\">SkeletonWebpackPlugin</span><span class=\"p\">({</span>\n        <span class=\"nx\">webpackConfig</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"nx\">entry</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n          <span class=\"c1\">// 地址的解析是从根目录开始的。需要加上/skeleton-test/(项目名称)\n</span><span class=\"c1\"></span>              <span class=\"nx\">app</span><span class=\"o\">:</span> <span class=\"nx\">utils</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">(</span><span class=\"s1\">&#39;./skeleton-test/src/entry-skeleton.js&#39;</span><span class=\"p\">)</span>\n          <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n      <span class=\"p\">})</span>\n<span class=\"p\">],</span>\n</code></pre></div><p>全部代码见<a href=\"https://link.zhihu.com/?target=https%3A//github.com/Alfxjx/skeleton-vue-test\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Github</a>，这个demo里面还测试了<a href=\"https://link.zhihu.com/?target=https%3A//github.com/hilongjw/vue-lazyload\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">lazy-load</a></p><p>求个star， 么么哒</p><p></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }, 
                {
                    "tag": "字体", 
                    "tagLink": "https://api.zhihu.com/topics/19551016"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58967635", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 5, 
            "title": "vue-router技巧分享", 
            "content": "<p>本文是关于VueRouter可以做的一些Vue开发人员很少知道的事情。它不是关于VueRouter的介绍性文章。本文假设您了解VueRouter，并且已经使用过几次或更多次并了解您的使用方法。</p><p>现在你可能永远不需要使用这里提到的东西。但是，请记住这些方法，有备无患。</p><h2><b>查询语句/Query parameters</b></h2><p>你以前可能已经看过这些。它们无法在所有网站上看到，但您可以在进行Google搜索时轻松查看它们。当您执行简单搜索时，您会注意到URL在网站名称后面有一些内容：</p><blockquote><a href=\"https://link.zhihu.com/?target=https%3A//duckduckgo.com/%3Fq%3Dhey%26t%3Dh%26atb%3Dv115-6\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">duckduckgo.com/?</span><span class=\"invisible\">q=hey&amp;t=h&amp;atb=v115-6</span><span class=\"ellipsis\"></span></a>。</blockquote><p>这是我在DuckDuckGo（像谷歌这样的搜索引擎）上用嘿这个词做的简单搜索。如果仔细查看该链接，可以看到字母q和其后的一些其他内容。在q之前还有一个问号。问号（？）之后的所有内容都称为查询。它用于以<b>键值对</b>的形式提供附加信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>VueRouter允许我们非常容易地传递查询参数。在&lt;router-link&gt;中是这样使用查询语句的：</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">router-link</span> <span class=\"na\">:to</span><span class=\"o\">=</span><span class=\"s\">&#34;{\n</span><span class=\"s\">    name:&#39;pathName&#39;,\n</span><span class=\"s\">    params:{id:$route.params.id},\n</span><span class=\"s\">    query:{ locale: &#39;en&#39; }\n</span><span class=\"s\">}&#34;</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">router-link</span><span class=\"p\">&gt;</span></code></pre></div><p>这里我们的参数使用params属性传递，下一个属性是查询。它还接受一个对象，各种查询表示为键值对。</p><p>在这种情况下，URL看起来像这样：</p><blockquote><a href=\"https://link.zhihu.com/?target=https%3A//something.com/user/456locale%3Den\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">something.com/user/456l</span><span class=\"invisible\">ocale=en</span><span class=\"ellipsis\"></span></a></blockquote><h2><b>重定向所有路径</b></h2><p>您已在单独的routes.js文件中准备好所有路径，将它们正确地包含在VueRouter实例中并使用本地开发服务器进行检查。这一切看起来还不错。这样配置的route.js可以包括全部的页面。</p><p>你问一个朋友试一试并提供反馈。你信心满满，什么都不会出错。但突然之间，你的朋友会给你看屏幕。它上面有一个空白页面！但是你覆盖了网站的所有路径。出了什么问题？！</p><p>您肯定涵盖了您的网站所需的所有路径。但这并不能阻止您的朋友或任何其他用户在URL中输入他们想要的内容。由于VueRouter显然无法识别路径，因此显示空白页面。如果用户第一次访问您的网站时意外输入了错误的路径，也可能发生这种情况。</p><p>我知道我很难弄清楚为什么GMail不在<a href=\"https://link.zhihu.com/?target=https%3A//google.gmail.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://google.gmail.com</a>上，而是在<a href=\"https://link.zhihu.com/?target=https%3A//mail.google.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">https://mail.google.com</a>上。好奇怪吧😜。</p><p>不是向用户显示空白页面，而是将它们重定向到您选择的页面可能更好。将以下路径添加到routes.js文件中：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"p\">{</span>\n    <span class=\"nx\">path</span><span class=\"o\">:</span><span class=\"s1\">&#39;*&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">redirect</span><span class=\"o\">:</span><span class=\"s1\">&#39;/&#39;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样做，文件中未处理的所有路由都将重定向到主页。因此，下次有人输入错误的路线时，他们将被重定向回主页。</p><h2><b>添加哈希片段</b></h2><p>不知道你是否访问过维基百科页面？有许多页面（几乎所有页面）都有内容索引。当您单击它们时，页面向下滚动，您可以神奇地跳转到该内容。</p><p>您的网站可能有一个主要内容进一步缩小的页面，您需要在访问该页面后立即向下滚动到该页面。可以使用锚标记&lt;a&gt;并将内容的id放在href属性中来实现此行为。但是，这仅适用于同一页面，而不是在您必须访问其他页面并立即跳转到内容时。为此，您可以使用名为hash的&lt;router-link&gt;属性。它需要内容的id，如锚标签。</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">router-link</span> <span class=\"na\">:to</span><span class=\"o\">=</span><span class=\"s\">&#34;{name:pathName, hash:&#39;#text&#39;}&#34;</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">router-link</span><span class=\"p\">&gt;</span></code></pre></div><p>但是，这只会将文本的id附加到URL。与此类似的东西 -  <a href=\"https://link.zhihu.com/?target=https%3A//something.com/user%23text\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">something.com/user#</span><span class=\"invisible\">text</span><span class=\"ellipsis\"></span></a>。它不会向下滚动到内容。这是因为我们只告诉我们的VueRouter为它的URL添加一个哈希值。我们还没有告诉它如何在页面上滚动。散列片段必须与下面显示的滚动行为相结合。</p><h2><b>滚动行为</b></h2><p>我们现在将设置路由的滚动行为。有了这个，我们可以使用我们附加到URL的哈希自动滚动到我们的内容，甚至让VueRouter记住滚动前的最后位置。这就像在维基百科中，您可以单击索引中的内容标题，单击后退按钮，而不是返回到上一页，页面向上滚动到索引位置。</p><p>将以下函数添加到VueRouter实例：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">import</span> <span class=\"p\">{</span><span class=\"nx\">routes</span><span class=\"p\">}</span> <span class=\"nx\">from</span> <span class=\"s1\">&#39;./routers.js&#39;</span>\n<span class=\"k\">const</span> <span class=\"nx\">router</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">VueRouter</span><span class=\"p\">({</span>\n    <span class=\"nx\">routes</span><span class=\"p\">,</span>\n    <span class=\"nx\">scrollBehaviour</span><span class=\"p\">(</span><span class=\"nx\">to</span><span class=\"p\">,</span><span class=\"nx\">from</span><span class=\"p\">,</span> <span class=\"nx\">savedPosition</span><span class=\"p\">){</span>\n        <span class=\"c1\">// 保存返回的位置\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">savedPosition</span><span class=\"p\">){</span>\n            <span class=\"k\">return</span> <span class=\"nx\">savedPosition</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 设置前往页面的锚点\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">to</span><span class=\"p\">.</span><span class=\"nx\">hash</span><span class=\"p\">){</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"nx\">selector</span><span class=\"o\">:</span> <span class=\"nx\">to</span><span class=\"p\">.</span><span class=\"nx\">hash</span><span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"nx\">x</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nx\">y</span><span class=\"o\">:</span><span class=\"mi\">0</span><span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>译者注：是不是有点像keep-alive的功能。</p><p>这里，路由是我们所有的路由都保存在一个单独的文件中。 scrollBehavior（）函数管理我们路线的滚动。它有3个参数：</p><ol><li>to  - 这代表我们将要访问的新路线</li><li>from  - 这是我们之前的路线。因此，如果我们点击主页上的&lt;router-link&gt;访问“关于”页面，那么将成为我们的“关于”页面，并且从主页开始。</li><li>savedPosition  - 这是重要的参数。 它表示滚动前的前一个位置。 在我解释上述功能的作用后，它会变得清晰。</li></ol><p>当我们只是向下滚动页面时，按后退按钮会将我们返回到页面顶部。这是因为我们在滚动之前的“先前位置”是页面的顶部。这是scrollBehavior（）函数中的第一个条件检查。它检查存储在savedPosition参数中的此保存位置。</p><p>第二个条件检查是针对散列片段。您可能还记得我们在上一节中向我们的URL添加了一个哈希值。但是，此哈希不应用于当前页面。我们点击链接时会应用它。</p><p>访问下一页时，它的路由中会有一个哈希值。第二个条件检查会注意到这个哈希值。它返回一个对象。选择器值指示我们要跳转到的内容的ID。</p><p>因此，当我们点击该链接时，会在URL中添加一个哈希片段，页面会自动向下滚动到我们的内容。 函数的最后一行返回一个对象，该对象具有页面顶部的x和y坐标。当我们刚访问一个页面并且没有散列片段时，这是必要的。当没有任何内容可以滚动到我们也没有手动向下滚动时，我们需要显示页面顶部。</p><p>这是本文的内容。我希望你能学到一些关于VueRouter的新知识。如果你想参考VueRouter的可靠来源，最好的地方是<a href=\"https://link.zhihu.com/?target=https%3A//router.vuejs.org/zh/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">官方文档</a>，因为它们编写得非常好。</p><p>如果您知道VueRouter的更多小功能，欢迎在评论区提出来~</p><hr/><p class=\"ztext-empty-paragraph\"><br/></p><p>翻译： <a href=\"https://link.zhihu.com/?target=https%3A//gitjhub.com/Alfxjx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Alfxjx</a></p><p>原文： medium</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "VueRouter", 
                    "tagLink": "https://api.zhihu.com/topics/20070653"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "这些都写在官方的 guide 里啊。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "薄墨无痕", 
                            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
                            "content": "<p>这个文章应该是面向初学者的，我感觉</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "guide 不就是给初学者看的吗？", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57094567", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 11, 
            "title": "Vue.js 最佳实践✓", 
            "content": "<p>翻译：Alfxjx</p><a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/vue-js-best-practices-c5da8d7af48d\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">原文链接</a><p>开发者们，你们好。</p><p>经过网上的一段搜索以及查阅Vue.js的<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/guide/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">文档</a>，我写下了本文中关于Vue的最佳实践以及风格指南，从而可以更正确，更优雅的使用Vue.js。</p><p>下面的要点指出了其中一些功能/优化相关，其他是VueJs命名约定和元素排序。 更详细的信息可以在<a href=\"https://link.zhihu.com/?target=https%3A//blog.usejournal.com/vue-js-best-practices-c5da8d7af48d%2326f6\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">链接</a>中找到。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-77f54434e54e0b756225ccbdbf776edd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"769\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-77f54434e54e0b756225ccbdbf776edd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;769&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"769\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic2.zhimg.com/v2-77f54434e54e0b756225ccbdbf776edd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-77f54434e54e0b756225ccbdbf776edd_b.jpg\"/></figure><h2><b>在组件销毁之后使用<code>$off</code>清除事件监听器</b></h2><p>当我们在使用<code>$on</code>监听事件的时候，总是需要在事件销毁（<code>destroyed()</code>）的时候使用<code>$off</code>清除事件监听，这样可以有效防止内存泄漏。</p><h2><b>事件名称使用短横线式命名（kebab-case)</b></h2><p>在派发/监听事件的时候，我们应该始终使用短横线式命名（kebab-case)，这是因为事件最终会被自动转换为该命名方式。我们监听的时间格式不能是驼峰式以及Pascal式，因此在声明时间的时候，最好就讲时间命名为短横线式。例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Emitting\n</span><span class=\"c1\"></span><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">$emit</span><span class=\"p\">(</span><span class=\"s1\">&#39;my-event&#39;</span><span class=\"p\">)</span> <span class=\"c1\">// instead of myEvent\n</span><span class=\"c1\">// Listening\n</span><span class=\"c1\"></span><span class=\"nx\">v</span><span class=\"o\">-</span><span class=\"nx\">on</span><span class=\"o\">:</span><span class=\"nx\">my</span><span class=\"o\">-</span><span class=\"nx\">event</span>\n</code></pre></div><h2><b>避免在created以及watch中调用相同的method</b></h2><p>如果我们需要触发组件初始化和属性更改的方法，通常的做法是执行以下操作：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">watch</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">myProperty</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">doSomething</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n<span class=\"nx\">created</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">doSomething</span><span class=\"p\">();</span>\n<span class=\"p\">},</span>\n<span class=\"nx\">methods</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n     <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;doing something...&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n</code></pre></div><p>尽管这样看起来挺正确的，但是这里对于<code>created()</code>的使用是多余的。我们本可以将所有的功能放入<code>watch</code>，从而避免在<code>created()</code>里面写重复的代码，这样同样可以在生成组件实例的时候触发。例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">watch</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">myProperty</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">immediate</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"c1\">// forcing handler on initial status\n</span><span class=\"c1\"></span>    <span class=\"nx\">handler</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">doSomething</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n<span class=\"nx\">methods</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n     <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;doing something...&#39;</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n<span class=\"c1\">// Even better solution\n</span><span class=\"c1\"></span><span class=\"nx\">watch</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n  <span class=\"nx\">myProperty</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">immediate</span><span class=\"o\">:</span> <span class=\"kc\">true</span><span class=\"p\">,</span> <span class=\"c1\">// forcing handler on initial status\n</span><span class=\"c1\"></span>    <span class=\"nx\">handler</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;doing something...&#39;</span><span class=\"p\">);</span> <span class=\"c1\">// No need to declare a function on methods for 1 use case\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">},</span>\n</code></pre></div><h2><b>总是在v-for循环中使用 :key</b></h2><p>通常来说，在模板的循环中添加<code>:key</code>是一个最佳实践，不包含<code>:key</code>的<code>v-for</code>循环会导致很难以查出的bug，尤其是在动画效果里面。</p><h2><b>为混入属性(mixins properties)使用$_符号标记</b></h2><p>Mixins 是是将重复代码放入一个块并将其导入多次的好方法，但很多情况下，这可能会导致一些问题。 在这一点上，我们将解决<b>重叠属性</b>的问题。</p><p>当我们讲一个mixin导入到我们的组件当中时，实际上是在吧minxin的代码和组件中原本的代码合并（merge）起来，那么同名的属性会呈现什么样呢？一般来说，组件的优先级更高，并且会覆盖mixin。</p><p>那么我要是需要mixin有更高的优先级，该怎么办呢？开发过程中并不能声明优先级，但是你可以避免属性的叠加，并且使用合适的<b>命名方式</b>来规避属性的重写。</p><p>In order to differentiate mixin properties from Component properties we use <code>$_</code>. Why these symbols? Well, several reasons: 为了将Mixin的属性与组件的属性相区分，我们使用<code>$_</code>，原因如下：</p><ol><li>这是Vuejs传统风格</li><li><code>_</code>在Vuejs中表示私有属性</li><li><code>$</code>属于Vue的保留字</li></ol><p>在<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Private-property-names-essential\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">风格指南</a>可以看到官方推荐的Mixin命名：<code>$_myMixin_updateUser</code>。</p><p>我发现添加mixin名称会产生比可读性更多的混乱。 但这也取决于mixin，情况和开发人员。</p><p>通过在Mixin之前添加<code>$_</code>，例如<code>$_updateUser</code>，我发现代码更具可读性，可以轻松区分Component和Mixin。</p><h2><b>在Mixin中使用的属性必须全部包含在Mixin之中</b></h2><p>继上一点之后，mixins还有另外一个问题：mixin不够独立。</p><p>如果我们创建一个使用的mixin，比方说，<code>this.language</code>并没有从mixin中的store中定义或获取此属性，那么定义mixin的Component<b>必须</b>包含language属性。</p><p>正如您已经知道的那样，这非常容易出错。 为了避免这些错误，我们在mixin里面获取所有需要的数据。 不要担心，如果我们两次获取数据，VueJs是聪明的，如果检测到从store获取到相同的东西，将不会做双重工作（因为大多数情况下会从Vuex获取数据）</p><h2><b>对单文件组件使用PascalCase或kebab-case</b></h2><p>PascalCase与编辑器具有更好的集成，并允许在常用IDE中实现更好的自动完成/导入功能。</p><p>如果我们想要避免使用不区分大小写的文件系统的问题，那么就应该使用kebab-case。</p><h2><b>基础组件名称之前加前缀</b></h2><p>装饰性、基础组件应该有一个前缀，以区别于其他复杂组件。 这大大提高了项目的可读性以及团队和开发人员之间的合作效率。</p><h2><b>JS组件需以PascalCase 命名</b></h2><p>在JavaScript中，类和原型构造方法一般使用PascalCase 命名，并且Vue组件也需要按此方式命名。</p><p>如果我们只通过<code>Vue.component</code>使用全局组件，那可以使用kebab-case。</p><h2><b>Prop 在声明时需要按照CamelCase命名，但是在模板中需要改成kebab-case</b></h2><p>HTML 中的特性名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名。</p><h2><b>按照风格指南设置组件内部选项顺序</b></h2><p>这看起来没什么意义，但是按此规则写成的组件更适合于大型多人开发项目，并且方便日后的扩展。</p><p>详情在[风格指南]<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Component-instance-options-order-recommended\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/style-guid</span><span class=\"invisible\">e/#Component-instance-options-order-recommended</span><span class=\"ellipsis\"></span></a>)</p><h2><b>不在同一个元素上同时使用v-if和v-for</b></h2><p>这是一个性能杀手，列表越长，这种不良做法会带来越多的性能损失。</p><p>让我们用代码解释一下，想象一下以下案例场景：</p><div class=\"highlight\"><pre><code class=\"language-html\"><span class=\"p\">&lt;</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span>\n  <span class=\"p\">&lt;</span><span class=\"nt\">li</span>\n    <span class=\"na\">v-for</span><span class=\"o\">=</span><span class=\"s\">&#34;game in games&#34;</span>\n    <span class=\"na\">v-if</span><span class=\"o\">=</span><span class=\"s\">&#34;game.isActive&#34;</span>\n    <span class=\"na\">:key</span><span class=\"o\">=</span><span class=\"s\">&#34;game.slug&#34;</span>\n  <span class=\"p\">&gt;</span>\n    {{ game.title }}\n  <span class=\"p\">&lt;</span><span class=\"nt\">li</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">ul</span><span class=\"p\">&gt;</span></code></pre></div><p>与下面这种写法相比较：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">games</span><span class=\"p\">.</span><span class=\"nx\">map</span><span class=\"p\">(</span><span class=\"kd\">function</span> <span class=\"p\">(</span><span class=\"nx\">game</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">game</span><span class=\"p\">.</span><span class=\"nx\">isActive</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">game</span><span class=\"p\">.</span><span class=\"nx\">title</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">})</span>\n</code></pre></div><p>不论<code>games</code>是否改变其活动状态，我们每一次都需要遍历整个games列表。</p><p>在Angular等其他框架中，这样写不能通过编译：</p><p>(<i>`**ngIf</i><code>*can&#39;t go in the same element where there is an*</code><i>*ngFor</i>`<i>)</i>。</p><h2><b>Actions必须要有返回值</b></h2><p>这是Vuex的actions和<code>async</code>/<code>await</code>的冲突造成的，请看这个例子：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Store\n</span><span class=\"c1\"></span><span class=\"p\">[</span><span class=\"nx\">SOME_ACTION</span><span class=\"p\">]</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"c1\">// Doing stuff that takes a while\n</span><span class=\"c1\"></span>   <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Action done&#39;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// Consuming action\n</span><span class=\"c1\"></span><span class=\"kr\">async</span> <span class=\"nx\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"kr\">await</span> <span class=\"nx\">dispatch</span><span class=\"p\">(</span><span class=\"nx\">SOME_ACTION</span><span class=\"p\">);</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Do stuff now&#39;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">This</span> <span class=\"nx\">will</span> <span class=\"nx\">output</span><span class=\"o\">:</span>\n<span class=\"c1\">// Do stuff now\n</span><span class=\"c1\">// Action done\n</span></code></pre></div><p>发生这种情况是因为<code>await</code>不知道要等待什么，相反，如果我们实际返回<code>Promise.resolve()</code>，则<code>await</code>将等待解析然后才继续。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// Store\n</span><span class=\"c1\"></span><span class=\"p\">[</span><span class=\"nx\">SOME_ACTION</span><span class=\"p\">]</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"c1\">// Doing stuff that takes a while\n</span><span class=\"c1\"></span>   <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Action done&#39;</span><span class=\"p\">);</span>\n   <span class=\"nb\">Promise</span><span class=\"p\">.</span><span class=\"nx\">resolve</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// Consuming action\n</span><span class=\"c1\"></span><span class=\"kr\">async</span> <span class=\"nx\">doSomething</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"kr\">await</span> <span class=\"nx\">dispatch</span><span class=\"p\">(</span><span class=\"nx\">SOME_ACTION</span><span class=\"p\">);</span>\n  <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"s1\">&#39;Do stuff now&#39;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"nx\">This</span> <span class=\"nx\">will</span> <span class=\"nx\">output</span><span class=\"o\">:</span>\n<span class=\"c1\">// Action done\n</span><span class=\"c1\">// Do stuff now\n</span></code></pre></div><h2><b>在actions和getters内部使用选择器</b></h2><p>我们创建选择器是不仅要在app过程中使用，还要在Vuex的store中使用。</p><p>例如：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// We have this selector\n</span><span class=\"c1\"></span><span class=\"k\">export</span> <span class=\"k\">const</span> <span class=\"nx\">language</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nx\">state</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"nx\">state</span><span class=\"p\">.</span><span class=\"nx\">userConfig</span><span class=\"p\">.</span><span class=\"nx\">language</span><span class=\"p\">;</span>\n<span class=\"c1\">// In one of our actions, we need language:\n</span><span class=\"c1\">// Bad\n</span><span class=\"c1\"></span><span class=\"p\">[</span><span class=\"nx\">GET_GAMES</span><span class=\"p\">]({</span> <span class=\"nx\">commit</span><span class=\"p\">,</span> <span class=\"nx\">rootState</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n   <span class=\"k\">const</span> <span class=\"nx\">lang</span> <span class=\"o\">=</span> <span class=\"nx\">rootState</span><span class=\"p\">.</span><span class=\"nx\">userConfig</span><span class=\"p\">.</span><span class=\"nx\">language</span><span class=\"p\">;</span>\n   <span class=\"c1\">// Do stuff...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"c1\">// Good\n</span><span class=\"c1\"></span><span class=\"p\">[</span><span class=\"nx\">GET_GAMES</span><span class=\"p\">]({</span> <span class=\"nx\">commit</span><span class=\"p\">,</span> <span class=\"nx\">rootState</span> <span class=\"p\">})</span> <span class=\"p\">{</span>\n   <span class=\"k\">const</span> <span class=\"nx\">lang</span> <span class=\"o\">=</span> <span class=\"nx\">language</span><span class=\"p\">(</span><span class=\"nx\">rootState</span><span class=\"p\">);</span>\n   <span class=\"c1\">// Do stuff...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h2><b>总结</b></h2><ol><li><b>在组件销毁之后使用<code>$off</code>清除事件监听器</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/api/%23vm-off\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>事件名称使用短横线式命名（kebab-case)</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/guide/components-custom-events.html%23Event-Names\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>避免在created以及watch中调用相同的method</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//learn-vuejs.github.io/vue-patterns/patterns/%23productivity-tips\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>总是在v-for循环中使用 :key[</b>source**](<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Keyed-v-for-essential\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/style-guid</span><span class=\"invisible\">e/#Keyed-v-for-essential</span><span class=\"ellipsis\"></span></a>)</li><li><b>为混入属性(mixins properties)使用$_符号标记</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Private-property-names-essential\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>在Mixin中使用的属性必须全部包含在Mixin之中</b></li><li><b>对单文件组件使用PascalCase或kebab-case</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Single-file-component-filename-casing-strongly-recommended\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>基础组件名称之前加前缀</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Base-component-names-strongly-recommended\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>JS组件需以PascalCase 命名</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Component-name-casing-in-JS-JSX-strongly-recommended\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>Prop 在声明时需要按照CamelCase命名，但是在模板中需要改成kebab-case[</b>source**](<a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Prop-name-casing-strongly-recommended\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/style-guid</span><span class=\"invisible\">e/#Prop-name-casing-strongly-recommended</span><span class=\"ellipsis\"></span></a>)</li><li><b>按照风格指南设置组件内部选项顺序</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Component-instance-options-order-recommended\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>不在同一个元素上同时使用v-if和v-for</b> <b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/%23Avoid-v-if-with-v-for-essential\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">source</a></b></li><li><b>Actions必须要有返回值</b></li><li><b>在actions和getters内部使用选择器</b></li></ol><h2><b>参考文献</b></h2><ul><li><b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs-tips.github.io/cheatsheet/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs-tips.github.io/ch</span><span class=\"invisible\">eatsheet/</span><span class=\"ellipsis\"></span></a></b></li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//learn-vuejs.github.io/vue-patterns/patterns/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">learn-vuejs.github.io/v</span><span class=\"invisible\">ue-patterns/patterns/</span><span class=\"ellipsis\"></span></a></b></li><li><b><a href=\"https://link.zhihu.com/?target=https%3A//vuejs.org/v2/style-guide/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">vuejs.org/v2/style-guid</span><span class=\"invisible\">e/</span><span class=\"ellipsis\"></span></a></b></li></ul><h2><b>后记</b></h2><p>这篇文章是在使用VueJs之后完成的。 遵循这些风格指南和最佳实践有助于让每个新开发者都有宾至如归的感觉，并立即投入到工作中！</p><h2><b>翻译后记</b></h2><p>这篇文章着重于代码风格，良好的代码风格是优秀代码的必要条件，也是多人合作过程中必不可少的一部分，之前阅读过阿里的Java手册，深感一个庞大的项目，除了语法之外，也必须在开发之前对于全体开发者的代码风格进行约束，虽然目前有了Eslint之类的风格检查工具，但是诸如命名等还是需要统一约束。</p><p>文章还对一些会影响性能以及容易报错的写法进行了纠正。总体来说值得一读，也值得翻译过来给大家看看😉</p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "Vuex", 
                    "tagLink": "https://api.zhihu.com/topics/20044614"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55616953", 
            "userName": "薄墨无痕", 
            "userLink": "https://www.zhihu.com/people/b4580da49a0ac403de40eb65c5ff19b8", 
            "upvote": 0, 
            "title": "在Vue.js中使用动态组件模板", 
            "content": "<p>原作者： <a href=\"https://link.zhihu.com/?target=https%3A//medium.com/%40philippkuehn\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Philipp Kühn</a> </p><p>翻译： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/Alfxjx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Alfxjx</a></p><blockquote> 组件并不总是有着相同的结构，有时一些组件需要去管理很多的状态（state），因此需要程序去异步（asynchronously）地管理这些状态。<br/> </blockquote><h2>使用场景</h2><p>我们在<a href=\"https://zhuanlan.zhihu.com/p/55616953/edit\" class=\"internal\">Scrumpy</a>（一个在线工作平台）中使用了很多的组件模板，例如通知、评论以及附件等等。首先让我以评论组件为例。</p><p>目前来说，评论栏早已经不是一个简简单单的文本域了。用户在评论的时候不可避免的需要加入诸如超链接、图片、短视频等等多媒体材料。这些复杂的元素都需要在评论中被渲染出来。但是如果你决定在一个组件中把所有工作都做了，这个组件的复杂度将会变得太高，失去了组件的意义。</p><p>​    </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6fd41692d6c5fe49b2c601e6cabfd8ec_b.jpg\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"1061\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic1.zhimg.com/v2-6fd41692d6c5fe49b2c601e6cabfd8ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;1061&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"1061\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic1.zhimg.com/v2-6fd41692d6c5fe49b2c601e6cabfd8ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6fd41692d6c5fe49b2c601e6cabfd8ec_b.jpg\"/><figcaption>The most common previews for links — open graph data, images &amp;amp;amp; videos</figcaption></figure><p>那么我们该如何解决这个问题呢。大多数的程序员会检查所有的可能性，然后分别为此设置特定的组件。例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n    &lt;div class=&#34;comment&#34;&gt;\n        // comment text    \n        &lt;p&gt;...&lt;/p&gt;\n\n        // open graph image\n        &lt;link-open-graph v-if=&#34;link.type === &#39;open-graph&#39;&#34; /&gt;\n        // regular image\n        &lt;link-image v-else-if=&#34;link.type === &#39;image&#39;&#34; /&gt;\n        // video embed\n        &lt;link-video v-else-if=&#34;link.type === &#39;video&#39;&#34; /&gt;\n        ...\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre></div><p>但是，这样一来，随着支持的类型越来越多，模板也会变得越来越复杂。例如我们的评论模板支持包括油管、推特、Github、SoundCloud、vimeo、Figma等等等等，这样的模板就会变得非常复杂。</p><h2>组件的动态模板</h2><p>另一种解决方案就是使用加载器（loader）在特定情况下来加载对应的模板。例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n    &lt;div class=&#34;comment&#34;&gt;\n        // comment text    \n        &lt;p&gt;...&lt;/p&gt;\n\n        // type can be &#39;open-graph&#39;, &#39;image&#39;, &#39;video&#39;...\n        &lt;dynamic-link :data=&#34;someData&#34; :type=&#34;type&#34; /&gt;\n    &lt;/div&gt;\n&lt;/template&gt;</code></pre></div><p>看起来好多了，对吗？</p><p>现在让我们来看看这些组件具体是如何工作的。首先我们需要改变一下文件的结构。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-63604d3c0c87970e91acc8fb231d2858_b.jpg\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"1315\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic1.zhimg.com/v2-63604d3c0c87970e91acc8fb231d2858_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;1315&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"1315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic1.zhimg.com/v2-63604d3c0c87970e91acc8fb231d2858_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-63604d3c0c87970e91acc8fb231d2858_b.jpg\"/><figcaption> folder structure for dynamic component templates</figcaption></figure><p>就我个人而言，我偏向于将每一个组件包裹在一个文件夹里，这样之后可以添加样式以及测试文件。当然文件的结构如何组织其实完全取决于你自己。</p><p>接下来，我们看看<code>&lt;dynamic-link /&gt;</code>是如何工作的。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n    &lt;component :is=&#34;component&#34; :data=&#34;data&#34; v-if=&#34;component&#34; /&gt;\n&lt;/template&gt;\n&lt;script&gt;\nexport default {\n    name: &#39;dynamic-link&#39;,\n    props: [&#39;data&#39;, &#39;type&#39;],\n    data() {\n        return {\n            component: null,\n        }\n    },\n    computed: {\n        loader() {\n            if (!this.type) {\n                return null\n            }\n            return () =&gt; import(`templates/${this.type}`)\n        },\n    },\n    mounted() {\n        this.loader()\n            .then(() =&gt; {\n                this.component = () =&gt; this.loader()\n            })\n            .catch(() =&gt; {\n                this.component = () =&gt; import(&#39;templates/default&#39;)\n            })\n    },\n}\n&lt;/script&gt;</code></pre></div><p>接下来该怎么做？Vue.js默认提供了<a href=\"https://link.zhihu.com/?target=https%3A//cn.vuejs.org/v2/guide/components-dynamic-async.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">动态组件</a>，但是他的缺点就是你需要将你需要的使用的所有组件都导入进来。</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;template&gt;\n    &lt;component :is=&#34;someComponent&#34;&gt;&lt;/component&gt;\n&lt;/template&gt;\n&lt;script&gt;\nimport someComponent from &#39;./someComponent&#39;\nexport default {\n    components: {\n        someComponent,\n    },\n}\n&lt;/script&gt;</code></pre></div><p>这事实上也没有解决我们的问题。</p><p>为了解决这个问题，我们使用Webpack的<a href=\"https://link.zhihu.com/?target=https%3A//medium.com/front-end-hacking/webpack-and-dynamic-imports-doing-it-right-72549ff49234\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">动态加载技术</a>，配合上计算属性返回的方法，可以实现动态组件模板了。</p><div class=\"highlight\"><pre><code class=\"language-text\">computed: {\n    loader() {\n        if (!this.type) {\n           return null\n        }\n        return () =&gt; import(`templates/${this.type}`)\n    },\n},</code></pre></div><p>组件在mounted之后，模板开始加载，为了能够向用户展示错误信息，我们设置了一个报错的模板。</p><div class=\"highlight\"><pre><code class=\"language-text\">mounted() {\n    this.loader()\n        .then(() =&gt; {\n           this.component = () =&gt; this.loader()\n        })\n        .catch(() =&gt; {\n           this.component = () =&gt; import(&#39;templates/default&#39;)\n        })\n},</code></pre></div><h2>结论</h2><ul><li>当一个组件里面需要很多界面的时候，很有必要使用动态组件模板</li><li>具有很好的扩展性</li><li>异步加载，模板只在需要的时候加载</li><li>让你的代码保持<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Don%2527t_repeat_yourself\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DRY</a></li></ul><p><b><a href=\"https://link.zhihu.com/?target=https%3A//medium.com/scrumpy/dynamic-component-templates-with-vue-js-d9236ab183bb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">原文链接</a></b></p>", 
            "topic": [
                {
                    "tag": "Vue.js", 
                    "tagLink": "https://api.zhihu.com/topics/20022242"
                }, 
                {
                    "tag": "前端组件", 
                    "tagLink": "https://api.zhihu.com/topics/20023309"
                }, 
                {
                    "tag": "前端入门", 
                    "tagLink": "https://api.zhihu.com/topics/19590813"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1071767152335302656"
}
