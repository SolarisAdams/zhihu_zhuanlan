{
    "title": "PHP高级开发", 
    "description": "专注于PHP技术免费分享，交流，编程技术的提升，网站开发的研究，thinkphp学习，linux，虚拟机学习，一起学习进步", 
    "followers": [
        "https://www.zhihu.com/people/zhao-yun-56-58-90", 
        "https://www.zhihu.com/people/li-su-37-69", 
        "https://www.zhihu.com/people/jiu-feng-11-12", 
        "https://www.zhihu.com/people/joker-78-24-86", 
        "https://www.zhihu.com/people/luo-teng-yue-49", 
        "https://www.zhihu.com/people/wilson-zhang-78", 
        "https://www.zhihu.com/people/tian-cang-cang-5-88", 
        "https://www.zhihu.com/people/toney-39-2", 
        "https://www.zhihu.com/people/amazing_cat", 
        "https://www.zhihu.com/people/yut2kem", 
        "https://www.zhihu.com/people/307150302", 
        "https://www.zhihu.com/people/bu-chi-bu-qi-81-29", 
        "https://www.zhihu.com/people/shaofan-qi", 
        "https://www.zhihu.com/people/viffen", 
        "https://www.zhihu.com/people/shun-zi-86-79", 
        "https://www.zhihu.com/people/ubuntu-36", 
        "https://www.zhihu.com/people/hui-xing-60", 
        "https://www.zhihu.com/people/iveszhou", 
        "https://www.zhihu.com/people/bu-shuai-de-shuai", 
        "https://www.zhihu.com/people/zhi-xi-16-25", 
        "https://www.zhihu.com/people/yunfeng-1994-lian", 
        "https://www.zhihu.com/people/huang-da-ren-17", 
        "https://www.zhihu.com/people/zhang-xiao-kai-64", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/feng-xiao-jie-73-57", 
        "https://www.zhihu.com/people/shuidf", 
        "https://www.zhihu.com/people/waterbogie", 
        "https://www.zhihu.com/people/yang-guang-48-37", 
        "https://www.zhihu.com/people/excia-40", 
        "https://www.zhihu.com/people/yin-pan-10-39", 
        "https://www.zhihu.com/people/kan-shi-jie-5", 
        "https://www.zhihu.com/people/wang-meng-sheng-12", 
        "https://www.zhihu.com/people/7a57a5a743894a0e", 
        "https://www.zhihu.com/people/ybtk", 
        "https://www.zhihu.com/people/likelxl", 
        "https://www.zhihu.com/people/den-war", 
        "https://www.zhihu.com/people/gq-zhou-63", 
        "https://www.zhihu.com/people/fei-chi-chi-la", 
        "https://www.zhihu.com/people/cui-zheng-yang-91", 
        "https://www.zhihu.com/people/RenZY", 
        "https://www.zhihu.com/people/predator-li", 
        "https://www.zhihu.com/people/xiang-yao-shi-81", 
        "https://www.zhihu.com/people/he-ping-33-22", 
        "https://www.zhihu.com/people/xing-ye-70", 
        "https://www.zhihu.com/people/guanhui07", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/yu-zhan-97-20", 
        "https://www.zhihu.com/people/zheng-hua-31-46", 
        "https://www.zhihu.com/people/allencdzhao", 
        "https://www.zhihu.com/people/phperstar", 
        "https://www.zhihu.com/people/Zou.yu", 
        "https://www.zhihu.com/people/li-ban-xian-99", 
        "https://www.zhihu.com/people/xiao-jie-32", 
        "https://www.zhihu.com/people/CedricChan", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/yao-yi-zheng-84", 
        "https://www.zhihu.com/people/li-zheng-cao-94", 
        "https://www.zhihu.com/people/feng-dian-xiao-ai", 
        "https://www.zhihu.com/people/ma-li-jie", 
        "https://www.zhihu.com/people/qing-huan-60-14", 
        "https://www.zhihu.com/people/kaka-abel", 
        "https://www.zhihu.com/people/xiceman", 
        "https://www.zhihu.com/people/zhang-rui-18-58-7", 
        "https://www.zhihu.com/people/zhang-zhi-cheng-95", 
        "https://www.zhihu.com/people/san-jun-sama", 
        "https://www.zhihu.com/people/ge-ji-bin", 
        "https://www.zhihu.com/people/xuan-yuan-yu-lei", 
        "https://www.zhihu.com/people/noark", 
        "https://www.zhihu.com/people/SecondaryMarquis", 
        "https://www.zhihu.com/people/mr-dogie", 
        "https://www.zhihu.com/people/verygood8", 
        "https://www.zhihu.com/people/junsong-51", 
        "https://www.zhihu.com/people/yumufeng", 
        "https://www.zhihu.com/people/gang-83", 
        "https://www.zhihu.com/people/jia-xin-xiao-zhi-ren", 
        "https://www.zhihu.com/people/object-32", 
        "https://www.zhihu.com/people/thinkwei", 
        "https://www.zhihu.com/people/tai-tou-ying-mian-zong-you-mi-yun", 
        "https://www.zhihu.com/people/peng-yu-xuan-21-88", 
        "https://www.zhihu.com/people/nero-56", 
        "https://www.zhihu.com/people/bu-dong-xiao-xian-sheng-78", 
        "https://www.zhihu.com/people/zheng-zi-jian-86", 
        "https://www.zhihu.com/people/li-shao-en", 
        "https://www.zhihu.com/people/PengKing", 
        "https://www.zhihu.com/people/qiu-he-12-36", 
        "https://www.zhihu.com/people/flesht", 
        "https://www.zhihu.com/people/zhang-jun-86", 
        "https://www.zhihu.com/people/luo-wei-long-13", 
        "https://www.zhihu.com/people/linger-18-20", 
        "https://www.zhihu.com/people/glxe-ge", 
        "https://www.zhihu.com/people/chen-bin-5-78", 
        "https://www.zhihu.com/people/lun-hui-samsara", 
        "https://www.zhihu.com/people/tan-xiao-lu-lu", 
        "https://www.zhihu.com/people/camark", 
        "https://www.zhihu.com/people/ping-dan-xuan-xie-bei-shang", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/xiao-feng-84-84-75", 
        "https://www.zhihu.com/people/zhang-fu-lai-44", 
        "https://www.zhihu.com/people/pei-qi-53-43", 
        "https://www.zhihu.com/people/hu-lao-gong-26", 
        "https://www.zhihu.com/people/xiang0219", 
        "https://www.zhihu.com/people/huang-bo-98", 
        "https://www.zhihu.com/people/cha-liang-mo-guai", 
        "https://www.zhihu.com/people/phpcodebw", 
        "https://www.zhihu.com/people/si-xi-clion", 
        "https://www.zhihu.com/people/huang-min-38-30", 
        "https://www.zhihu.com/people/han-yu-58-27", 
        "https://www.zhihu.com/people/la-tiao-pi-de-da-gu", 
        "https://www.zhihu.com/people/xtlsoft", 
        "https://www.zhihu.com/people/jun-kaka", 
        "https://www.zhihu.com/people/zhaotiliang", 
        "https://www.zhihu.com/people/wang-yan-xiong-1688", 
        "https://www.zhihu.com/people/strikergx", 
        "https://www.zhihu.com/people/bai-ge-6-55", 
        "https://www.zhihu.com/people/fyy-10-74", 
        "https://www.zhihu.com/people/zhang-hao-5-91-22", 
        "https://www.zhihu.com/people/minton-55", 
        "https://www.zhihu.com/people/sunsilen-47", 
        "https://www.zhihu.com/people/ting-ge-92-63", 
        "https://www.zhihu.com/people/igeek", 
        "https://www.zhihu.com/people/jin-gang-xiao-cang", 
        "https://www.zhihu.com/people/xiangaihenfrank", 
        "https://www.zhihu.com/people/gosimn", 
        "https://www.zhihu.com/people/ruo-feng-45-55", 
        "https://www.zhihu.com/people/hu-wei-16-4", 
        "https://www.zhihu.com/people/yue-guang-qu-32", 
        "https://www.zhihu.com/people/a-niu-33-40", 
        "https://www.zhihu.com/people/gao-shi-qing-6-32"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/85012437", 
            "userName": "萝卜", 
            "userLink": "https://www.zhihu.com/people/8beb7ccd36bd8e7976148f9c8e5eae3e", 
            "upvote": 1, 
            "title": "开发中常用的 webpack 插件汇总", 
            "content": "<p>大家好！我是萝卜，这篇文章主要是将我自己平时开发中常用的一些插件和大家做一个分享，大家在自己的工作或者项目中如果有类似的需要可以直接通过这篇文章进行查找以及使用。</p><h2><b>webpack 内置插件：</b></h2><ul><li>webpack.DefinePlugin：定义全局常量插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/define-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack.DefinePlugin</a><ul><li>webpack.EnvironmentPlugin：定义环境变量插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/environment-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">EnvironmentPlugin | webpack</a><ul><li>webpack.BannerPlugin：在代码中添加版权注释等；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/banner-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">BannerPlugin | webpack</a><ul><li>webpack.DllPlugin：使用 DLL 思想来加快编译速度的插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/dll-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DllPlugin | webpack</a><ul><li>webpack.HashedModuleIdsPlugin：可以修改文件 Hash 算法的插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/hashed-module-ids-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HashedModuleIdsPlugin | webpack</a><ul><li>webpack.optimize.SplitChunksPlugin：代码拆分优化插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/split-chunks-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">SplitChunksPlugin | webpack</a><ul><li>webpack.HotModuleReplacementPlugin：开启模块热替换功能，通过监听文件变化并自动加载被修改的文件来减少烦人的浏览器手动重新加载；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/hot-module-replacement-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HotModuleReplacementPlugin | webpack</a><ul><li>webpack.ProgressPlugin：构建进度插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/progress-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ProgressPlugin | webpack</a><ul><li>webpack.ProvidePlugin：自动加载模块，例如出现 $ 则加载 jQuery 等常用库；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/provide-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ProvidePlugin | webpack</a><ul><li>webpack.IgnorePlugin：用于忽略部分文件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//webpack.js.org/plugins/ignore-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">IgnorePlugin | webpack</a><h2><b>非内置插件：</b></h2><ul><li>mini-css-extract-plugin：CSS 文件提取，并且在生产环境构建是可以用于优化 CSS 文件大小；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/mini-css-extract-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-016f6a72129c2dbbea8795f9b9bfc6e2_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack-contrib/mini-css-extract-plugin</a><ul><li>optimize-css-assets-webpack-plugin：压缩 CSS 文件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/NMFR/optimize-css-assets-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-567b1ad66fb9e61116887d4fde031dc0_ipico.jpg\" data-image-width=\"140\" data-image-height=\"140\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NMFR/optimize-css-assets-webpack-plugin</a><ul><li>clean-webpack-plugin：在编译之前清理指定目录指定内容；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/johnagan/clean-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-8fc21dee5f9640b508a63d445ad369d0_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">johnagan/clean-webpack-plugin</a><ul><li>html-webpack-plugin：html 插件，可以根据 JavaScript 模板文件生成 HTML；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/jantimon/html-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-3a9b3a0e33f2c4a3c64abc789680f8db_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">jantimon/html-webpack-plugin</a><ul><li>preload-webpack-plugin：html-webpack-plugin 的插件，给页面添加&lt;link rel=&#34;preload&#34;&gt;资源；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/GoogleChromeLabs/preload-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-978869dfb3deb675f582afbc69015b65_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GoogleChromeLabs/preload-webpack-plugin</a><ul><li>i18n-webpack-plugin：帮助网页做国际化的插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/i18n-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-016f6a72129c2dbbea8795f9b9bfc6e2_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack-contrib/i18n-webpack-plugin</a><ul><li>webpack-manifest-plugin：生成 Webpack 打包文件清单的插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/danethurber/webpack-manifest-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-96d99b5676cc78737b937dce7f8051a0_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">danethurber/webpack-manifest-plugin</a><ul><li>html-webpack-inline-source-plugin：在 HTML 中内联打包出来的资源；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/DustinJackson/html-webpack-inline-source-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-0060048acb57883d55ae26266f8d560c_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DustinJackson/html-webpack-inline-source-plugin</a><ul><li>webpack-bundle-analyzer：webpack bundle 分析插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/webpack-bundle-analyzer\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-016f6a72129c2dbbea8795f9b9bfc6e2_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack-contrib/webpack-bundle-analyzer</a><ul><li>copy-webpack-plugin：文件拷贝插件，可以指定文件夹的文件复制到 output 文件夹，方便打包上线；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/webpack-contrib/copy-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-016f6a72129c2dbbea8795f9b9bfc6e2_ipico.jpg\" data-image-width=\"200\" data-image-height=\"200\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">webpack-contrib/copy-webpack-plugin</a><ul><li>serviceworker-webpack-plugin：生成 PWA service worker 插件；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/oliviertassinari/serviceworker-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-c0b2e9c2773bb5a9317dc8718dfade1d_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">oliviertassinari/serviceworker-webpack-plugin</a><ul><li>hard-source-webpack-plugin：通过缓存提升非首次编译速度；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/mzgoddard/hard-source-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic2.zhimg.com/v2-1b5e180d3c706bab3b71ac42647d3049_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mzgoddard/hard-source-webpack-plugin</a><ul><li>friendly-errors-webpack-plugin：减少 Webpack 无用的构建 log；</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//github.com/geowarin/friendly-errors-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-cb61c4bf02a22e7cd2d166860f9de913_ipico.jpg\" data-image-width=\"400\" data-image-height=\"400\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">geowarin/friendly-errors-webpack-plugin</a><ul><li>stylelint-webpack-plugin：StyleLint 的插件。</li></ul><a href=\"https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/stylelint-webpack-plugin\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-338e4905a2684ca96e08c7780fc68412_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"630\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">stylelint-webpack-plugin</a><p></p>", 
            "topic": [
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }, 
                {
                    "tag": "JavaScript 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19681416"
                }, 
                {
                    "tag": "JavaScript 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052034"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84322543", 
            "userName": "萝卜", 
            "userLink": "https://www.zhihu.com/people/8beb7ccd36bd8e7976148f9c8e5eae3e", 
            "upvote": 0, 
            "title": "细说webpack系列 7. webpack dev server 的使用", 
            "content": "<p>大家好！我是萝卜，今天跟大家分享官方提供开发工具 webpack dev server 的使用。</p><p>webpack-dev-server是一个基于 Express 的本地开发服务器。它使用 webpack-dev-middleware 中间件来为通过 Webpack 打包生成的资源文件提供 Web 服务。它还有一个通过 Socket IO 连接着 webpack-dev-server 服务器的小型运行时程序。webpack-dev-server 发送关于编译状态的消息到客户端，客户端根据消息作出响应。</p><blockquote>Tips：简单来说 webpack-dev-server 就是一个 Express 的小型服务器，它是通过 Express 的中间件 webpack-dev-middleware 和 Webpack 进行交互的。所以我们如果自己的项目本身就是个 Express 服务器，那么可以使用 webpack-dev-middleware 和 webpack-hot-middleware 两个中间件来实现 HMR 功能。</blockquote><h2>命令行</h2><p>webpack-dev-server 安装之后，会提供一个 bin 命令行，通过命令行可以启动对应的服务。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 项目中安装 webpack-dev-server\n</span><span class=\"c1\"></span><span class=\"nx\">npm</span> <span class=\"nx\">i</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">-</span><span class=\"nx\">D</span>\n<span class=\"c1\">// 使用 npx 启动\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span>\n</code></pre></div><p>执行 webpack-dev-server 命令之后，它会读取 Webpack 的配置文件（默认是 webpack.config.js）然后将文件打包到内存中（所以看不到 dist 文件夹的生产，Webpack 会打包到硬盘上），这时候打开 server 的默认地址：localhost:8080 就可以看到文件目录或者页面（默认是显示 index.html，没有则显示目录）。</p><p>跟 webpack-cli 一样，webpack-dev-server 也有一些选项可以添加：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 修改端口号和 host\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">port</span> <span class=\"mi\">3000</span> <span class=\"o\">--</span><span class=\"nx\">host</span> <span class=\"mf\">127.0.0.1</span>\n<span class=\"c1\">// 启动inline 模式的自动刷新\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">hot</span> <span class=\"o\">--</span><span class=\"nx\">inline</span>\n<span class=\"c1\">// 手动指定 webpack config 文件\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">config</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">xxx</span><span class=\"p\">.</span><span class=\"nx\">js</span>\n<span class=\"c1\">// 指定 webpack 的 mode\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">mode</span> <span class=\"nx\">development</span>\n<span class=\"c1\">// watch 功能，文件发生变化则触发重新编译\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">watch</span>\n<span class=\"c1\">// dev-server默认会将工作目录（当前目录）最为基本目录，可以手动修改它\n</span><span class=\"c1\"></span><span class=\"nx\">npx</span> <span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">content</span><span class=\"o\">-</span><span class=\"nx\">base</span> <span class=\"p\">.</span><span class=\"o\">/</span><span class=\"nx\">build</span>\n</code></pre></div><p> 上面只介绍了常用的并且比较重要的一些命令行选项，要查看全部，可以使用webpack-dev-server -h 查看帮助。</p><p> 我们还可以将 webpack-dev-server 放到 package.json 的 scripts 里面，例如下面例子，执行 npm run dev 实际就是执行的对应 webpack-dev-server 命令：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"p\">{</span>\n  <span class=\"err\">‘</span><span class=\"nx\">script</span><span class=\"err\">’</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"err\">‘</span><span class=\"nx\">dev</span><span class=\"err\">’</span><span class=\"o\">:</span> <span class=\"err\">‘</span><span class=\"nx\">webpack</span><span class=\"o\">-</span><span class=\"nx\">dev</span><span class=\"o\">-</span><span class=\"nx\">server</span> <span class=\"o\">--</span><span class=\"nx\">mode</span> <span class=\"nx\">development</span> <span class=\"o\">--</span><span class=\"nx\">config</span> <span class=\"nx\">webpack</span><span class=\"p\">.</span><span class=\"nx\">config</span><span class=\"p\">.</span><span class=\"nx\">dev</span><span class=\"p\">.</span><span class=\"nx\">js</span> <span class=\"o\">--</span><span class=\"nx\">hot</span> <span class=\"o\">--</span><span class=\"nx\">inline</span> <span class=\"o\">--</span><span class=\"nx\">port</span> <span class=\"mi\">3000</span><span class=\"err\">’</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span> \n</code></pre></div><h2>自动刷新</h2><p>在开发中，我们希望边写代码，边看到代码的执行情况，webpack-dev-server 提供自动刷新页面的功能可以满足我们的需求。webpack-dev-server 支持两种模式的自动刷新页面。</p><ul><li>iframe 模式：页面被放到一个 iframe 内，当发生变化时，会重新加载；</li><li>inline 模式：将 webpack-dev-server 的重载代码添加到产出的 bundle 中。</li></ul><p>两种模式都支持模块热替换（Hot Module Replacement）。模块热替换的好处是只替换更新的部分，而不是整个页面都重新加载。</p><p>使用方式：webpack-dev-server --hot --inline 是开启 inline 模式的自动刷新。</p><h2>和 Webpack 配置结合</h2><p>webpack-dev-server 被 Webpack 作为内置插件对外提供了，这样可以直接在对应的 Webpack 配置文件中通过 devServer 这个属性的配置来配置自己的webpack-dev-server。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"k\">const</span> <span class=\"nx\">path</span> <span class=\"o\">=</span> <span class=\"nx\">require</span><span class=\"p\">(</span><span class=\"nx\">path</span><span class=\"p\">);</span>\n<span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">exports</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// ...\n</span><span class=\"c1\"></span>  <span class=\"nx\">devServer</span><span class=\"o\">:</span> <span class=\"p\">{</span>\n    <span class=\"nx\">contentBase</span><span class=\"o\">:</span> <span class=\"nx\">path</span><span class=\"p\">.</span><span class=\"nx\">join</span><span class=\"p\">(</span><span class=\"nx\">__dirname</span><span class=\"p\">,</span> <span class=\"err\">‘</span><span class=\"nx\">dist</span><span class=\"err\">’</span><span class=\"p\">),</span>\n    <span class=\"nx\">port</span><span class=\"o\">:</span> <span class=\"mi\">3000</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p> 其中 devServer.port 表示服务器的监听端口，即运行后我们可以通过 http://localhost:3000 来访问应用；而 devServer.contentBase 表示服务器将从哪个目录去查找内容文件（即页面文件，比如 HTML）。</p><p>配置完之后，在项目中执行 webpack-dev-server 我们可以用http://localhost:3000/这个地址来访问本地开发服务了。</p><blockquote>Tips：<br/>1.启动 devserver 是通过 webpack-dev-server 命令行来启动的，不是 webpack 命令，执行 webpack 时 devServer 内容会被忽略。<br/>2.在使用数组导出配置的方式时，只会使用第一个配置中的 devServer 选项，并将其用于数组中的其他所有配置。</blockquote><h2>Hot Module Replacement</h2><p>HMR 即模块热替换（Hot Module Replacement）的简称，它可以在应用运行的时候，不需要刷新页面，就可以直接替换、增删模块。</p><p>Webpack 可以通过配置 webpack.HotModuleReplacementPlugin 插件来开启全局的 HMR 能力，开启后 bundle 文件会变大一些，因为它加入了一个小型的 HMR 运行时（runtime），当你的应用在运行的时候，Webpack 监听到文件变更并重新打包模块时，HMR 会判断这些模块是否接受 update，若允许，则发信号通知应用进行热替换。</p><p>要开启 HMR 功能，需要三步：</p><p>1.设置 devServer.hot=true，devServer.inline=true（默认）；</p><ul><li>devServer.hot=true：会给 entry 添加 webpack/hot/dev-serve或者webpack/hot/only-dev-serve（devServer.hotOnly=true），这个是实现 HMR 的服务端代码；</li><li>devServer.inline=true：会给 entry 添加webpack-dev-server/client，这是通信客户端；</li></ul><p>2.在 webpack.config.js 中添加 plugins：new webpack.HotModuleReplacementPlugin()；</p><p>3.修改入口文件添加 HMR 支持代码：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"c1\">// 在入口文件 index.js 最后添加如下代码\n</span><span class=\"c1\"></span><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">hot</span><span class=\"p\">){</span>\n<span class=\"c1\">// 通知 webpack 该模块接受 hmr\n</span><span class=\"c1\"></span><span class=\"nx\">module</span><span class=\"p\">.</span><span class=\"nx\">hot</span><span class=\"p\">.</span><span class=\"nx\">accept</span><span class=\"p\">(</span><span class=\"nx\">err</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">err</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">});</span>\n<span class=\"p\">}</span> \n</code></pre></div><p>经过上面配置之后，再次执行 webpack-dev-server，打开http://localhost:3000，然后修改 index.js 内容，就能看到效果了。</p><blockquote>Tips：使用 webpack-dev-server 的 CLI 功能只需要命令行中添加--hot，webpack-dev-server 会自动将webpack.HotModuleReplacementPlugin 这个插件添加到 Webpack 的配置中去，所以开启 HotModuleReplacementPlugin 最简单的方式就是使用 inline 模式（命令行添加 --inline）。</blockquote><h2>Webpack Dev Server 常用配置</h2><ul><li>devServer.historyApiFallback：配置如果找不到页面就默认显示的页面；</li><li>devServer.compress：启用 gzip 压缩；</li><li>devServer.hotOnly：构建失败的时候是否不允许回退到使用刷新网页；</li><li>devServer.inline：模式切换，默认为内联模式，使用false切换到 iframe 模式；</li><li>devServer.open：启动后，是否自动使用浏览器打开首页；</li><li>devServer.openPage：启动后，自动使用浏览器打开设置的页面；</li><li>devServer.overlay：是否允许使用全屏覆盖的方式显示编译错误，默认不允许；</li><li>devServer.port：监听端口号，默认 8080；</li><li>devServer.host：指定 host，使用0.0.0.0可以让局域网内可访问；</li><li>devServer.contentBase：告诉服务器从哪里提供内容，只有在你想要提供静态文件时才需要；</li><li>devServer.publicPath：设置内存中的打包文件的虚拟路径映射，区别于 output.publicPath；</li><li>devServer.https：https 需要的证书签名等配置。</li></ul><h2><b>小结</b></h2><p>Webpack 的 webpack-dev-server 是 Webpack 生态链上很重要的一环，在我们日常的开发环境，我们可以使用 webpack-dev-server 启动本地服务器，而且能够实现 API 接口代理、静态资源服务器、HMR，甚至还能够通过编写 Express 中间件的方式来扩展功能。</p><p>但是 webpack-dev-server 本身也有它的局限性，比如我们项目本身就有一个 Node.js 的业务服务，那么在使用 webpack-dev-server 来模拟接口数据就显得多此一举了。</p>", 
            "topic": [
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "前端工程化", 
                    "tagLink": "https://api.zhihu.com/topics/20010840"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83392001", 
            "userName": "萝卜", 
            "userLink": "https://www.zhihu.com/people/8beb7ccd36bd8e7976148f9c8e5eae3e", 
            "upvote": 4, 
            "title": "细说 webpack系列 1. 为什么要选择 webpack", 
            "content": "<p>大家好！我是萝卜，webpack作为目前最流行的构建工具，几乎成为前端同学武器库中必备的工具之一，写这个系列文章的用意就是想把自己在平时工作中使用webpack的一些经验和心得和大家分享，也是对自己这些年的前端工作做一个阶段性的总结，希望能给大家带来些许的帮助。</p><p>在学习webpack前，需要先知道为什么要用webpack，我将从以下两个方面进行讲解：</p><blockquote>一、前端发展的需要</blockquote><p>近些年，前端世界翻天覆地，新思想和新框架不断涌现，我们可以通过模块化的思想来组织代码，诸如CommonJS、ES6模块化标准规范给前端开发带来了极大的效率提升，但是它们都必须通过工具转换成标准的ES5才能直接运行在浏览器环境下。我们可以使用React、Vue来重构已有的项目或者开发新的项目，React框架通过将JSX语法引入到Javascript语言层面中，可灵活的控制试图的渲染逻辑。Vue框架将HTML模板、Javascript逻辑代码、CSS样式都写在一个文件里。这些框架都通过组件化的方式组织代码，减少开发难度，提升开发效率。但是它们的问题也是无法直接在现成的Javascript引擎里运行，必须经过转换。我们还可以使用新的语言如：ES6、TypeScript、SCSS、LESS等，使用这些新语言可以提升编码效率，但是必须将源代码转换成可以直接在浏览器环境下运行的代码。</p><p>我们在感叹前端技术发展之快的同时也面临着更大的挑战，通过直接编写Javascript、CSS、HTML开发Web应用的方式已经无法应对当前Web应用的发展，我们必须通过构建的方式，将源代码转换成可执行的Javascript、CSS、HTML代码，包括如下内容：</p><ul><li>代码转换：将TypeScript编译成Javascript，将SCSS编译成CSS等。</li><li>文件优化：压缩Javascript、CSS、HTML代码，压缩合并图片等。</li><li>代码分割：提取多个页面的公共代码，提取首屏不需要执行部分的代码让其异步加载。</li><li>模块合并：在采用模块化的项目里会有很多个模块和文件，需要通过构建功能将模块分类合并成一个文件。</li><li>自动刷新：监听本地源代码的变化，自动重新构建、刷新浏览器。</li><li>代码校验：在代码被提交到仓库前需要校验代码是否符合规范，以及单元测试是否通过。</li><li>自动发布：更新代码后，自动构建出线上发布代码并传输给发布系统。</li></ul><p>构建其实是工程化、自动化思想在前端开发中的体现，将一系列流程用代码去实现，让代码自动化的执行这一系列复杂的流程。</p><blockquote>二、常见的构建工具对比</blockquote><p>近些年先后出现了一系列构建工具，它们各有优缺点，由于前端工程师熟悉Javascript，Nodejs又可以胜任所有构建需求，所以大多数构建工具都是用Nodejs开发的，下面就对常见的构建工具进行对比。</p><p><b>Grunt</b></p><p>Grunt是一个任务执行者，有大量现成的插件封装了常见的任务，也能管理任务之间的依赖关系，自动化的执行依赖的任务，每个任务的具体执行代码和依赖关系都写在配置文件Gruntfile.js里，Grunt的优点是：</p><ul><li>灵活，它只负责执行我们定义的任务。</li><li>大量的可复用插件封装好了常见的构建任务。</li></ul><p>Grunt的缺点是集成度不高，要写很多配置后才可以使用，无法做到开箱即用。</p><p><b>Gulp</b></p><p>Gulp是一个基于流的自动化构建工具，除了可以管理和执行任务，还支持监听文件、读写文件。Gulp被设计的非常简单，只通过下面5种方法就可以支持几乎所有构建场景：</p><ul><li>通过gulp.task注册一个任务。</li><li>通过gulp.run执行任务。</li><li>通过gulp.watch监听文件的变化。</li><li>通过gulp.src读取文件。</li><li>通过gulp.dest写文件。</li></ul><p>Gulp的最大特点是引入了流的概念，同时提供了一系列常用的插件去处理流，流可以在插件之间传递。Gulp的优点是好用又不失灵活，既可以单独完成构建，也可以和其他工具搭配使用，其缺点和Grunt类似，集成度不高，要写很多配置后才可以使用，无法做到开箱即用。</p><p>可以将Gulp看作Grunt的加强版。相对于Grunt，Gulp增加了监听文件、读写文件、流式处理的功能。</p><p><b>Fis3</b></p><p>Fis3是一个国产的构建工具，由百度的团队开发和维护，相对于Grunt、Gulp这些只提供了基本功能的工具，Fis3集成了Web开发中的常用构建功能：</p><ul><li>读写文件：通过fis.match读文件，release配置文件的输出路径。</li><li>资源定位：解析文件之间的依赖关系和文件位置。</li><li>文件指纹：在通过useHash配置输出文件时为文件URL加上md5戳，来优化浏览器缓存。</li><li>文件编译：通过parser配置文件解析器做文件转换，例如将ES6编译成ES5。</li><li>压缩资源：通过optimizer配置代码压缩方法。</li><li>图片合并：通过spriter配置合并CSS里导入的图片到一个文件中，减少HTTP请求数。</li></ul><p>Fis3的优点是集成了各种Web开发所需的构建功能，配置简单、开箱即用。其缺点是目前官方已经不再更新和维护，不支持最新版本的Nodejs。</p><p><b>Webpack</b></p><p>Webpack是一个打包模块化Javascript的工具，在Webpack里一切文件皆模块，通过Loader转换文件，通过Plugin注入钩子，最后输出由多个模块组合成的文件，Webpack专注于构建模块化项目，这样的好处是能清晰的描述各个模块之间的依赖关系，以方便Webpack对模块进行组合和打包，经过Webpack的处理，最终会输出浏览器能使用的静态文件。Webpack的优点是：</p><ul><li>专注于处理模块化的项目，能做到开箱即用、一步到位。</li><li>可通过Plugin扩展，完整好用又不失灵活。</li><li>使用场景不局限于Web开发。</li><li>社区庞大灵活，经常引入紧跟业界的新特性，能为大多数场景找到已有的开源扩展。</li><li>良好的开发体验。</li></ul><p>Webpack的缺点是只能用于采用模块化开发的项目。</p><p>三、为什么选择Webpack</p><p>这些构建工具都有各自的定位和专注点，它们之间既可以单独完成任务，也可以相互搭配来弥补各自的不足，之所以我们在开发中选择webpack作为常用的构建工具，主要原因是：</p><ul><li>大多数团队在开发项目时基本都会采用“模块化+新语言+新框架“，webpack可以提供一站式的解决方案。</li><li>Webpack有良好的生态链和维护团队，能够提供良好的开发体验并保证质量。</li><li>Webpack被全世界大量的Web开发者使用和验证，能找到各个层面所需的教程和经验分享。</li></ul><p>欢迎大家继续关注我的文章，下一节我们将进入webpack的世界！</p>", 
            "topic": [
                {
                    "tag": "webpack", 
                    "tagLink": "https://api.zhihu.com/topics/20032877"
                }, 
                {
                    "tag": "前端工程化", 
                    "tagLink": "https://api.zhihu.com/topics/20010840"
                }, 
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83528671", 
            "userName": "萝卜", 
            "userLink": "https://www.zhihu.com/people/8beb7ccd36bd8e7976148f9c8e5eae3e", 
            "upvote": 2, 
            "title": "javascript中的this机制", 
            "content": "<p>大家好！我是萝卜，this关键字是javascript中最复杂的机制之一，this被自动定义在所有函数的作用域中，即使是有多年经验的前端同学，有时也很难说清它到底指向什么，实际上，this机制并没有那么先进，下面就带大家彻底搞懂this。</p><h2>我们为什么要用this</h2><p>既然this关键字是javascript中最复杂的机制之一，那么我们为什么还要使用this，因为this提供了优雅的方式来隐性的“传递”一个对象引用，通过这种方式可以将API设计的更加简洁且易于复用。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">a</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">b</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">str</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;Hello, I&#39;m &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"k\">this</span> <span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">str</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj1</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;胡萝卜&#34;</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;白萝卜&#34;</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj1</span> <span class=\"p\">);</span> <span class=\"c1\">// 胡萝卜\n</span><span class=\"c1\"></span><span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj2</span> <span class=\"p\">);</span> <span class=\"c1\">// 白萝卜\n</span><span class=\"c1\"></span><span class=\"nx\">b</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj1</span> <span class=\"p\">);</span> <span class=\"c1\">// Hello, 我是 胡萝卜\n</span><span class=\"c1\"></span><span class=\"nx\">b</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj2</span> <span class=\"p\">);</span> <span class=\"c1\">// Hello, 我是 白萝卜\n</span></code></pre></div><p>这段代码可以在不同的上下文对象(obj1 和 obj2)中重复使用函数 a() 和 b()，不用针对每个对象编写不同版本的函数。 如果不使用 this，那就需要给 a() 和 b() 显式传入一个上下文对象。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">a</span><span class=\"p\">(</span><span class=\"nx\">context</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nx\">context</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">function</span> <span class=\"nx\">b</span><span class=\"p\">(</span><span class=\"nx\">context</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kd\">var</span> <span class=\"nx\">str</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;Hello, I&#39;m &#34;</span> <span class=\"o\">+</span> <span class=\"nx\">a</span><span class=\"p\">(</span> <span class=\"nx\">context</span> <span class=\"p\">);</span>\n    <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">greeting</span> <span class=\"p\">);</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj1</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;胡萝卜&#34;</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s2\">&#34;白萝卜&#34;</span>\n<span class=\"p\">};</span>\n<span class=\"nx\">a</span><span class=\"p\">(</span> <span class=\"nx\">obj1</span> <span class=\"p\">);</span> <span class=\"c1\">// 胡萝卜\n</span><span class=\"c1\"></span><span class=\"nx\">b</span><span class=\"p\">(</span> <span class=\"nx\">obj2</span> <span class=\"p\">);</span> <span class=\"c1\">//hello, 我是 白萝卜 \n</span></code></pre></div><h2>this到底是什么</h2><p>当一个函数被调用时，会创建一个活动记录也被称为执行上下文。这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数的执行过程中用到。this 既不指向函数自身也不指向函数的词法作用域，this 总是指向一个对象，具体指向哪个对象是在运行时基于函数的执行环境动态绑定的，而非函数被声明时的环境。this 的指向和函数声明的位置没有任何关系，只取决于函数的调用位置。</p><h2>如何找到函数的调用位置 </h2><p>我们可以借助浏览器的开发者工具中的调用栈来找到函数被调用的位置，先看如下代码：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">a</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 当前调用栈是:a\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 因此，当前调用位置是全局作用域\n</span><span class=\"c1\"></span>  <span class=\"nx\">b</span><span class=\"p\">();</span> <span class=\"c1\">// &lt;-- b 的调用位置\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">b</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 当前调用栈是 a -&gt; b\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 因此，当前调用位置在 a 中\n</span><span class=\"c1\"></span>  <span class=\"nx\">c</span><span class=\"p\">();</span> <span class=\"c1\">// &lt;-- c 的调用位置\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"kd\">function</span> <span class=\"nx\">c</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"c1\">// 当前调用栈是 a -&gt; b -&gt; c\n</span><span class=\"c1\"></span>  <span class=\"c1\">// 因此，当前调用位置在 b 中\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"c1\">// a函数的调用位置\n</span><span class=\"c1\"></span><span class=\"nx\">a</span><span class=\"p\">();</span>\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f9049ed1d1e671aa1c776e186cedfc5d_b.jpg\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb\" width=\"2000\" data-original=\"https://pic2.zhimg.com/v2-f9049ed1d1e671aa1c776e186cedfc5d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2000&#39; height=&#39;686&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"2000\" data-rawheight=\"686\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2000\" data-original=\"https://pic2.zhimg.com/v2-f9049ed1d1e671aa1c776e186cedfc5d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f9049ed1d1e671aa1c776e186cedfc5d_b.jpg\"/><figcaption>函数调用栈</figcaption></figure><p>其中Call Stack就是函数在栈中的调用位置，通过这种方式我们就能真正的分析出函数的真正的调用位置。</p><h2>具体开发中常见的4种this的指向</h2><ol><li>作为对象的方法调用</li></ol><p>当函数作为对象的方法被调用时，this指向该对象：</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">obj</span> <span class=\"o\">=</span> <span class=\"p\">{</span> \n  <span class=\"nx\">a</span><span class=\"o\">:</span> <span class=\"mi\">1</span><span class=\"p\">,</span>\n  <span class=\"nx\">getA</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"nx\">alert</span> <span class=\"p\">(</span> <span class=\"k\">this</span> <span class=\"o\">===</span> <span class=\"nx\">obj</span> <span class=\"p\">);</span> <span class=\"c1\">// 输出:true \n</span><span class=\"c1\"></span>    <span class=\"nx\">alert</span> <span class=\"p\">(</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">a</span> <span class=\"p\">);</span> <span class=\"c1\">// 输出: 1\n</span><span class=\"c1\"></span>  <span class=\"p\">}</span> \n<span class=\"p\">};</span>\n<span class=\"nx\">obj</span><span class=\"p\">.</span><span class=\"nx\">getA</span><span class=\"p\">();</span>\n</code></pre></div><p>2. 作为普通函数调用</p><p>当函数不作为对象的属性被调用时，也就是我们常说的普通函数方式，此时的 this 总是指向全局对象。在浏览器的JavaScript里，这个全局对象是 window 对象。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nb\">window</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;globalName&#39;</span><span class=\"p\">;</span>\n<span class=\"kd\">var</span> <span class=\"nx\">getName</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"c1\">// 输出:globalName\n</span><span class=\"c1\"></span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"nx\">getName</span><span class=\"p\">()</span> <span class=\"p\">);</span>\n</code></pre></div><p>3. 构造器调用</p><p>当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">MyClass</span> <span class=\"o\">=</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n    <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;萝卜&#39;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">MyClass</span><span class=\"p\">();</span>\n<span class=\"nx\">alert</span> <span class=\"p\">(</span> <span class=\"nx\">obj</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"p\">);</span> <span class=\"c1\">// 输出:萝卜\n</span></code></pre></div><p>4. Function.prototype.call或Function.prototype.apply调用</p><p>跟普通的函数调用相比，用 Function.prototype.call 或 Function.prototype.apply 可以动态地 改变传入函数的 this。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">var</span> <span class=\"nx\">obj1</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;胡萝卜&#39;</span><span class=\"p\">,</span>\n    <span class=\"nx\">getName</span><span class=\"o\">:</span> <span class=\"kd\">function</span><span class=\"p\">(){</span>\n        <span class=\"k\">return</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;白萝卜&#39;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">obj1</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">());</span> <span class=\"c1\">// 输出: 胡萝卜\n</span><span class=\"c1\"></span><span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span><span class=\"nx\">obj2</span><span class=\"p\">.</span><span class=\"nx\">getName</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span><span class=\"nx\">obj2</span><span class=\"p\">));</span> <span class=\"c1\">// 输出: 白萝卜 \n</span></code></pre></div><h2>ES6中的箭头函数</h2><p>我们之前介绍的4种this指向已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型：箭头函数。</p><p>箭头函数并不是使用 function 关键字定义的，而是使用操作符 =&gt; 定 义的。箭头函数不实用 this 的4种指向，而是根据外层(函数或者全局)作用域来决定。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"kd\">function</span> <span class=\"nx\">a</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 返回一个箭头函数\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"nx\">name</span><span class=\"p\">)</span> <span class=\"p\">=&gt;</span> <span class=\"p\">{</span>\n        <span class=\"c1\">//this 继承自 foo()\n</span><span class=\"c1\"></span>        <span class=\"nx\">console</span><span class=\"p\">.</span><span class=\"nx\">log</span><span class=\"p\">(</span> <span class=\"k\">this</span><span class=\"p\">.</span><span class=\"nx\">name</span> <span class=\"p\">);</span>\n    <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj1</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;胡萝卜&#39;</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">obj2</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"nx\">name</span><span class=\"o\">:</span> <span class=\"s1\">&#39;白萝卜&#39;</span>\n<span class=\"p\">};</span>\n<span class=\"kd\">var</span> <span class=\"nx\">b</span> <span class=\"o\">=</span> <span class=\"nx\">a</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj1</span> <span class=\"p\">);</span>\n<span class=\"nx\">b</span><span class=\"p\">.</span><span class=\"nx\">call</span><span class=\"p\">(</span> <span class=\"nx\">obj2</span> <span class=\"p\">);</span> <span class=\"c1\">// 输出：胡萝卜, 而不是白萝卜! \n</span></code></pre></div><p>a() 内部创建的箭头函数会捕获调用时 a() 的 this。由于 a() 的 this 绑定到 obj1， b(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。</p><h2>小结</h2><p>如果要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后 <br/>就可以顺序应用下面这4种情况来判断 this 的绑定对象。 <br/> 1. 作为对象的方法调用。<br/> 2. 作为普通函数调用。<br/> 3. 构造器调用。<br/> 4. Function.prototype.call或Function.prototype.apply调用。 </p><p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定(无论 this 绑定到什么)。这其实和 ES5 中通过 self = this 这种方式防止作用域漂移是一样的。 <br/> <br/> <br/> <br/> <br/> <br/> </p>", 
            "topic": [
                {
                    "tag": "JavaScript", 
                    "tagLink": "https://api.zhihu.com/topics/19552521"
                }, 
                {
                    "tag": "JavaScript 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052034"
                }, 
                {
                    "tag": "前端开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550901"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83172738", 
            "userName": "喻淑文", 
            "userLink": "https://www.zhihu.com/people/fca63dbde57c6c46616418189ba2dfef", 
            "upvote": 1, 
            "title": "服务器遭受了大规模流量攻击，应该如何防御", 
            "content": "<p>如何判断是否被DDos攻击？</p><p>1、检查网站后台服务器发现大量无用的数据包；</p><p>2、服务器主机上有大量等待的TCP连接；</p><p>3、网络流量出现异常变化突然暴涨；</p><p>4、大量访问源地址是虚假的；</p><p>5、当发现Ping超时或丢包严重时，且同一交换机上的服务器也出现了问题，不能进行正常访问；</p><p>DDOS攻击如何防御？</p><p>1.扩充服务器带宽</p><p>服务器的网络带宽直接决定服务器承受攻击能力。所以在选购服务器时，可以加大服务器网络带宽。</p><p>2.使用硬件防火墙</p><p>部分硬件防火墙基于包过滤型防火墙修改为主，只在网络层检查数据包，若是DDoS攻击上升到应用层，防御能力就比较弱了。</p><p>3.选用高性能设备</p><p>除了使用硬件防火墙。服务器、路由器、交换机等网络设备的安全性能也需要有所保证。</p><p>4.负载均衡</p><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性，对DDoS流量攻击和CC攻击都很见效。</p><p>5.筛查系统漏洞</p><p>要定期筛查系统漏洞，及早发现系统漏洞，及时安装系统补丁。同时针对重要信息（如系统配置信息）做好备份。</p><p>6.限制特定的流量</p><p>如遇到流量异常时，应及时检查访问来源，并做适当的限制。以防止异常、恶意的流量来袭。主动保护网站安全。</p><p>7.选购高防服务器</p><p>高防服务器可以帮助网站拒绝服务攻击，而且高防服务器可以定时扫描现有的网络主节点，还可查找可能存在的安全漏洞的服务器类型。</p><p>希望壹基比小喻整理的这些可以帮助大家。</p>", 
            "topic": [
                {
                    "tag": "服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19554575"
                }, 
                {
                    "tag": "DDoS", 
                    "tagLink": "https://api.zhihu.com/topics/19591790"
                }, 
                {
                    "tag": "网络攻击", 
                    "tagLink": "https://api.zhihu.com/topics/19568943"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80815070", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "一个.git引发的惨案", 
            "content": "<p>最简单的表达形式<i>是越怕</i>出事,越会出事。<br/>—— 墨菲<i>定理</i><br/><i>健硕的系统才是根基，菜是原罪</i><br/><i>最近上线了一个小的程序，架构Linux+Apache+Mysql+PHP（Thinkphp3.2），做系统的时候只是考虑了一些基础的安全比如csrf，sql注入等等，但是没想到栽倒了在git上面，项目使用的是git版本控制器，当你拉取一个项目时候，在你的项目文件夹下面会自动的创建一个.git的隐藏文件，也算是git的驱动文件，有了它你就可以在你的本地使用git进行代码的管理了，之前做项目一直都是Thinkphp3.2，服务器使用的Nginx从未发生过这样的事情（因为Nginx做了验证处理）</i><br/><i>比如我们访问一个网站的使用，<a href=\"https://link.zhihu.com/?target=http%3A//xx/.git/index\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">xx/.git/index</span><span class=\"invisible\"></span></a>，之后就会自动下载一个</i><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-579fcfe925578499e06458abe9e6c99a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-579fcfe925578499e06458abe9e6c99a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-579fcfe925578499e06458abe9e6c99a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-579fcfe925578499e06458abe9e6c99a_b.jpg\"/></figure><p><br/>之后我们可以简单的使用记事本打开一下<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8300f506a61f33b1508a2beb5df8c098_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8300f506a61f33b1508a2beb5df8c098_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-8300f506a61f33b1508a2beb5df8c098_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8300f506a61f33b1508a2beb5df8c098_b.jpg\"/></figure><p><br/>额....居然是你git代码管理器里面的目录结构，之后我们通过一个大神在github分享的一个用python写的小程序，我们居然能下载下来整个项目的目录结构<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6044afe864b36f3c07d3ee80e3e1ddf5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-6044afe864b36f3c07d3ee80e3e1ddf5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-6044afe864b36f3c07d3ee80e3e1ddf5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6044afe864b36f3c07d3ee80e3e1ddf5_b.jpg\"/></figure><p><br/>之后通过日志分析，可以得到网站的一些管理员的账号信息，这样你就可以得到了一些网站的关键信息，至此你就可以登录网站后台了<br/>好了，说了这么多，还是告诉大家怎么解决这个问题了，其实一般注意一下就不会犯这么低级的错误，但是也还好及时发现并修改<br/>1、如果你的服务器是apache，那么你将这样操作<br/>（1）修改apache的配置文件（安装目录可能不同，你可以对照修改）<br/>vim /etc/httpd/httpd.conf<br/>1）首先要开启重写，然后<br/>RewriteEngine on<br/>RewriteRule ^.git - [F,L]<br/><br/>这样就ok了，你可以选择<br/>Apache通过配置.htaccess文件禁止访问.git、.svn等目录<br/>或者像我一样修改httpd.conf，因为我做了路由的重定向，所以选择了修改配置文件<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7e50b40a5d55b61dc5783ecc7f3a9f3e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-7e50b40a5d55b61dc5783ecc7f3a9f3e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic3.zhimg.com/v2-7e50b40a5d55b61dc5783ecc7f3a9f3e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7e50b40a5d55b61dc5783ecc7f3a9f3e_b.jpg\"/></figure><p><br/>（2）重启apache<br/>/usr/local/apache2/bin/apachectl restart<br/>如果你使用了Thinkphp5.0+或者laravel，那么恭喜你，你可以不用担心，因为目录和public不在同一级（配置public的情况下）<br/>2、如果你使用的是Nginx<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4f95e26d9af91cd94a4a299825fa2219_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"455\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"455\" data-original=\"https://pic2.zhimg.com/v2-4f95e26d9af91cd94a4a299825fa2219_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;455&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"455\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"455\" data-original=\"https://pic2.zhimg.com/v2-4f95e26d9af91cd94a4a299825fa2219_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4f95e26d9af91cd94a4a299825fa2219_b.jpg\"/></figure><p><br/>这样配置了重写，那么路由就根本找不到，所以也就不会出现那个问题了。<br/>编程安全，防不胜防，菜是原罪。</p>", 
            "topic": [
                {
                    "tag": "网络安全", 
                    "tagLink": "https://api.zhihu.com/topics/19554927"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/71185595", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 0, 
            "title": "如何创建进程及进程的特性", 
            "content": "<p><b>1.必备知识点</b></p><p>什么是进程：程序被执行的过程，就叫进程。计算机内部原理，由操作系统控制硬盘操作将程序读入内存，调用cpu来执行程序。内存中进程与进程之间的内存空间是绝对物理意义上的隔离的。启动qq，微信，word三个程序，就会在内存中开辟三块独立的内存空间来存放它们，而如果一个程序被你启动了好几次(鼠标点了好几下)那么也是不同的进程，在内存中也是对应有互相隔离的内存空间——即进程与进程之间内存空间也是彼此隔离的(无论是不同的程序之间还是相同的程序亦或是下面介绍的父程序申请创建主程序方式~)</p><p><b>2.创建子进程的两种方式</b></p><p>PS：在程序中再创建子进程的意义在于，想让程序中的任务能够并发去执行！</p><p>第一种：</p><div class=\"highlight\"><pre><code class=\"language-text\">from multiprocessing import Process\nimport time\ndef task():\n print(&#39;子程序开始运行》》》&#39;)\n time.sleep(3)\n print(&#39;主程序运行完毕》》》&#39;)\nif __name__ == &#39;__main__&#39;:\n p=Process(target=task)\n p.start()\n print(&#39;主程序代码读取完毕！&#39;)\n#运行结果\n# 主程序代码读取完毕！\n# 子程序开始运行》》》\n #间隔三秒后打印下面的结果\n# 主程序运行完毕》》》\n首先导入的是专门用来产生子进程的模块Process是一个类\n导入的time模块是为了模拟子进程执行了一段时间\nif __name__==&#39;__main__&#39;:\n 先调用Process类传入参数产生子进程对象 \n 在windows环境下创建子进程的代码必须写在上述条件下面，\n因为程序值执行到p.start()时，其实就是向操作系统发出申请说我需要开一个子进程\n这个操作系统会开辟单独的内存空间，之后重新导入当前文件并运行，将产生的名称空间作为子进程的初始数据库放入新开辟的内存空间中(无论是windows系统还是linux系统，子进程的产生都需要拷贝父进程的数据作为起始运行状态)，\n当主程序发出申请代码块后，就不会再去管子进程什么时候创建运行(程序也决定不了这个事，而是由操作系统说了算)，而继续去运行自身接下来的代码，</code></pre></div><p>第二种：</p><div class=\"highlight\"><pre><code class=\"language-text\">from multiprocessing import Process\nimport time\nclass Myprocess(Process):\n def __init__(self,name):\n super(Myprocess,self).__init__()\n self.name=name\n def run(self):\n print(&#39;%s is running &#39;%self.name)\n time.sleep(3)\n print(&#39;%s is running over&#39;%self.name)\nif __name__ == &#39;__main__&#39;:\n p=Myprocess(&#39;alex&#39;)\n p.start()\n print(&#39;主程序代码运行完毕&#39;)\n既然用来产生子进程的模块是一个类，那么我们学过面向对象及元类，对类的使用应该也是有一定水平的，我们就可以自己为子进程定制一些专属的特性(后面会写一个为子进程定制一个同时获取子进程和父进程pid的小方法)\n首先定义我们自己的类Myprocess继承Process,在调用super()先继承父类的初始化方法，在给子进程添加一个名字属性\n而下面的run()方法是必须要加的，也就是说每一个用来产生子进程的类中肯定对应有一个run()方法，这个run()对应的就是对象调用start()时触发，run()方法里写的就是你想让子进程想干的事情，就是第一种创建子进程的task函数啦~</code></pre></div><p><b>3.验证父进程与子进程之间空间是绝对物理意义上的互相隔离</b></p><div class=\"highlight\"><pre><code class=\"language-text\">from multiprocessing import Process\nx=1000\ndef task():\n global x\n x=1\n print(&#39;子进程运行完毕&#39;)\nif __name__ == &#39;__main__&#39;:\n p=Process(target=task)\n p.start()\n p.join()\n print(&#39;主进程的变量X：%s&#39;%x)\n #result：\n 子进程运行完毕\n 主进程的变量X：1000 \n#这里先在父程序名称空间中定义一个全局变量x=1000，如何产生一个子进程，子进程会拷贝父类代码名称空间，\n#这个时候在子进程函数方法中通过global方法将x的修改变为全局有效，这个时候运行完结果是父程序中变量的值并没有改变，说明子进程并不能影响到父进程的名称空间，\n#这里子进程中的修改操作确实执行了，只不过子进程修改的是子进程自己的名称空间中的x的值 </code></pre></div><p><b>4.父进程在执行带申请创建子进程后原地等待子进程运行结束再去运行自身下面的代码~(join()方法)</b></p><div class=\"highlight\"><pre><code class=\"language-text\">from multiprocessing import Process\nimport time\ndef task():\n print(&#39;子程序开始运行&#39;)\n time.sleep(3)\n print(&#39;子程序运行完毕&#39;)\nif __name__ == &#39;__main__&#39;:\n p=Process(target=task)\n p.start()\n p.join()\n print(&#39;主程序代码读取完毕！&#39;)\n#结果：\n#子程序开始运行\n# 子程序运行完毕\n# 主程序代码读取完毕！\n#这里的join()就是让主程序等着子进程运行结束才能继续往下走，join()在这里并不仅仅是这个效果，起始涉及到了后面要说的僵尸进程和孤儿进程(针对uniux系统)，\njoin()是为了将子进程运行完毕后产生的数据全部回收清空(了解即可)</code></pre></div><p>这里需要明确的是join()是让谁等？是主进程等，卡住的是主进程而绝非其他的进程~~~</p><p><b>5.获取进程的PID(getpid(),getppid())</b></p><p>在计算机每个进程的运行计算机都会随机分配给进程一个PID号，相当于我们的身份证一样，每台计算机中pid号的数量是有限的，那如何获取子进程的pid号呢？</p><div class=\"highlight\"><pre><code class=\"language-text\">from multiprocessing import Process\nimport time,os\nx=1000\ndef task():\n print(&#39;self:%s,parent:%s&#39;%(os.getpid(),os.getppid()))\n time.sleep(3)\nif __name__ == &#39;__main__&#39;:\n p1=Process(target=task)\n p1.start()\n print(p1.pid)#在外部获取子进程的pid，直接调子进程自带的属性，这里可以自己为其定制，通过第二种创建子进程的方式自定义类！\n print(&#39;主程序的：%s&#39;%os.getpid())\n#结果：\n10144\n主程序的：10724\nself:10144,parent:10724</code></pre></div><p><b>6.僵尸进程与孤儿进程(针对uniux，linux系统)</b></p><div class=\"highlight\"><pre><code class=\"language-text\">一：僵尸进程（有害）\n　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。详解如下\n我们知道在unix/linux中，正常情况下子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程到底什么时候结束，如果子进程一结束就立刻回收其全部资源，那么在父进程内将无法获取子进程的状态信息。\n因此，UNⅨ提供了一种机制可以保证父进程可以在任意时刻获取子进程结束时的状态信息：\n1、在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号the process ID，退出状态the termination status of the process，运行时间the amount of CPU time taken by the process等）\n2、直到父进程通过wait / waitpid来取时才释放. 但这样就导致了问题，如果进程不调用wait / waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。\n　　任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。 如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。\n二：孤儿进程（无害）\n　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。\n　　孤儿进程是没有父进程的进程，孤儿进程这个重任就落到了init进程身上，init进程就好像是一个民政局，专门负责处理孤儿进程的善后工作。每当出现一个孤儿进程的时候，内核就把孤 儿进程的父进程设置为init，而init进程会循环地wait()它的已经退出的子进程。这样，当一个孤儿进程凄凉地结束了其生命周期的时候，init进程就会代表党和政府出面处理它的一切善后工作。因此孤儿进程并不会有什么危害。\n我们来测试一下（创建完子进程后，主进程所在的这个脚本就退出了，当父进程先于子进程结束时，子进程会被init收养，成为孤儿进程，而非僵尸进程），文件内容\nimport os\nimport sys\nimport time\npid = os.getpid()\nppid = os.getppid()\nprint &#39;im father&#39;, &#39;pid&#39;, pid, &#39;ppid&#39;, ppid\npid = os.fork()\n#执行pid=os.fork()则会生成一个子进程\n#返回值pid有两种值：\n# 如果返回的pid值为0，表示在子进程当中\n# 如果返回的pid值&gt;0，表示在父进程当中\nif pid &gt; 0:\n print &#39;father died..&#39;\n sys.exit(0)\n# 保证主线程退出完毕\ntime.sleep(1)\nprint &#39;im child&#39;, os.getpid(), os.getppid()\n执行文件，输出结果：\nim father pid 32515 ppid 32015\nfather died..\nim child 32516 1\n看，子进程已经被pid为1的init进程接收了，所以僵尸进程在这种情况下是不存在的，存在只有孤儿进程而已，孤儿进程声明周期结束自然会被init来销毁。\n三：僵尸进程危害场景：\n　　例如有个进程，它定期的产 生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程 退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大 量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进 程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。\n四：测试\n#1、产生僵尸进程的程序test.py内容如下\n#coding:utf-8\nfrom multiprocessing import Process\nimport time,os\ndef run():\n print(&#39;子&#39;,os.getpid())\nif __name__ == &#39;__main__&#39;:\n p=Process(target=run)\n p.start()\n \n print(&#39;主&#39;,os.getpid())\n time.sleep(1000)\n#2、在unix或linux系统上执行\n[root@vm172-31-0-19 ~]# python3 test.py &amp;\n[1] 18652\n[root@vm172-31-0-19 ~]# 主 18652\n子 18653\n[root@vm172-31-0-19 ~]# ps aux |grep Z\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nroot 18653 0.0 0.0 0 0 pts/0 Z 20:02 0:00 [python3] &lt;defunct&gt; #出现僵尸进程\nroot 18656 0.0 0.0 112648 952 pts/0 S+ 20:02 0:00 grep --color=auto Z\n[root@vm172-31-0-19 ~]# top #执行top命令发现1zombie\ntop - 20:03:42 up 31 min, 3 users, load average: 0.01, 0.06, 0.12\nTasks: 93 total, 2 running, 90 sleeping, 0 stopped, 1 zombie\n%Cpu(s): 0.0 us, 0.3 sy, 0.0 ni, 99.7 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st\nKiB Mem : 1016884 total, 97184 free, 70848 used, 848852 buff/cache\nKiB Swap: 0 total, 0 free, 0 used. 782540 avail Mem \n PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND \nroot 20 0 29788 1256 988 S 0.3 0.1 0:01.50 elfin \n#3、\n等待父进程正常结束后会调用wait／waitpid去回收僵尸进程\n但如果父进程是一个死循环，永远不会结束，那么该僵尸进程就会一直存在，僵尸进程过多，就是有害的\n解决方法一：杀死父进程\n解决方法二：对开启的子进程应该记得使用join，join会回收僵尸进程\n参考python2源码注释\nclass Process(object):\n def join(self, timeout=None):\n &#39;&#39;&#39;\n Wait until child process terminates\n &#39;&#39;&#39;\n assert self._parent_pid == os.getpid(), &#39;can only join a child process&#39;\n assert self._popen is not None, &#39;can only join a started process&#39;\n res = self._popen.wait(timeout)\n if res is not None:\n _current_process._children.discard(self)\njoin方法中调用了wait，告诉系统释放僵尸进程。discard为从自己的children中剔除\n解决方法三：http://blog.csdn.net/u010571844/article/details/50419798</code></pre></div><p>其实不管实在哪个操作平台上，子进程都会经历僵尸进程这一阶段，而主进程在没有可以干扰他的代码读取情况下，大家会发现，主进程虽然代码读取完毕了，但是它还是不会结束，而是要等着所有的子进程全部结束才会结束，这就是为了回收子进程的尸体(数据)。详细的请看上述缩进内容</p>", 
            "topic": [
                {
                    "tag": "进程", 
                    "tagLink": "https://api.zhihu.com/topics/19634510"
                }, 
                {
                    "tag": "进程管理", 
                    "tagLink": "https://api.zhihu.com/topics/19632859"
                }, 
                {
                    "tag": "系统进程", 
                    "tagLink": "https://api.zhihu.com/topics/19780192"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/69962183", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 6, 
            "title": "Redis你真的会吗？快戳", 
            "content": "<p>一.Nosql数据库四大类介绍</p><p>1.K，v键值：redis,memcache,</p><p>2.文档性数据库:MongoDB,CouchDB</p><p>3.列存储数据库:分布式文件系统，HBase,Cassandra</p><p>4.图关系数据库:(不是放图形的，放的是关系，例如:朋友圈社交网络，广告推荐等)构建关系图谱</p><p>二.传统的ACID分别是什么？</p><p>1.A:atomicity:原子性</p><p>2.C:consistency:一致性</p><p>3.I:isolation:独立性</p><p>4.D:durability:持久性</p><p>三.CAP又是什么?</p><p>C:Consistency------------------&gt;&gt;强一致性</p><p>A:Availability---------------------&gt;&gt;可用性</p><p>P:Partition tolerance------------&gt;&gt;分区容错性</p><p>四.CAP理论</p><p>1.CAP理论就是说在<b>分布式存储系统</b>中，<b>最多只能实现上面的两点。</b></p><p>而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。</p><p>所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。</p><p>2.CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，</p><p>最多只能同时较好的满足两个。</p><p>因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：</p><p>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</p><p>CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。</p><p>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p><p>五.针对CAP的3进2问题，BASE理论的提出</p><p>BASE就是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。</p><p>BASE其实是下面三个术语的缩写：</p><p>基本可用（Basically Available）</p><p>软状态（Soft state）</p><p><b>最终一致（Eventually consistent）</b></p><p>它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。为什么这么说呢，缘由就在于大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法(例如:淘宝双十一当天，对于商品的评论和访问数可能不需要那么在意，首要是要保证服务器的高可用，崩了什么都白搭了，等双十一过后再在<b>一定的时间内完成最终的数据一致性</b>)</p><p>六.分布式+集群简介</p><p>分布式系统</p><p>分布式系统（distributed system）</p><p>由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。</p><p>简单来讲：</p><p><b>分布式</b>：不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。</p><p><b>集群</b>：不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。</p><p><b>七.redis启动后小知识点汇总</b></p><p>1.单进程</p><p>单进程模型来处理客户端的请求。对读写等事件的响应</p><p>是通过对epoll函数的包装来做到的。Redis的实际处理速度完全依靠主进程的执行效率</p><p>epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，</p><p>它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p><p>2.redis自带的数据库</p><p>默认16个数据库，类似数组下表从零开始，初始默认使用零号库</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-46899d471d6cca9e56816981b3ecd2e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"402\" data-rawheight=\"86\" class=\"content_image\" width=\"402\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;402&#39; height=&#39;86&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"402\" data-rawheight=\"86\" class=\"content_image lazy\" width=\"402\" data-actualsrc=\"https://pic4.zhimg.com/v2-46899d471d6cca9e56816981b3ecd2e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3.select命令切换数据库</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e3fdbf4c260eda11d32b46661616c528_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"96\" class=\"content_image\" width=\"393\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;393&#39; height=&#39;96&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"96\" class=\"content_image lazy\" width=\"393\" data-actualsrc=\"https://pic1.zhimg.com/v2-e3fdbf4c260eda11d32b46661616c528_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4.dbsize查看当前数据库的key的数量</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2fb9bf83c5cd367c2346f88de9d1c9e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"177\" class=\"content_image\" width=\"384\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;384&#39; height=&#39;177&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"177\" class=\"content_image lazy\" width=\"384\" data-actualsrc=\"https://pic3.zhimg.com/v2-2fb9bf83c5cd367c2346f88de9d1c9e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>5.flushdb：清空当前库，Flushall；通杀全部库(两者都不要轻易使用，任意出事...你懂的)</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-836e9b2b9f085b28a6a11c5686887168_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"394\" data-rawheight=\"347\" class=\"content_image\" width=\"394\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;394&#39; height=&#39;347&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"394\" data-rawheight=\"347\" class=\"content_image lazy\" width=\"394\" data-actualsrc=\"https://pic1.zhimg.com/v2-836e9b2b9f085b28a6a11c5686887168_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>6.统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上</b></p><p><b>7.Redis索引都是从零开始</b></p><p><b>8.默认端口6397(6379在是手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字。MERZ长期以来被antirez及其朋友当作愚蠢的代名词。)</b></p><p>软件获取和帮助</p><p><a href=\"https://link.zhihu.com/?target=http%3A//Redis.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Redis.io</span><span class=\"invisible\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//Redis.cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Redis.cn</span><span class=\"invisible\"></span></a></p><p>Download/<a href=\"https://link.zhihu.com/?target=http%3A//redis.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">redis.io</span><span class=\"invisible\"></span></a></p><p><a href=\"https://link.zhihu.com/?target=http%3A//Redisdoc.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">Redisdoc.com</span><span class=\"invisible\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "Redis Cluster", 
                    "tagLink": "https://api.zhihu.com/topics/20173110"
                }, 
                {
                    "tag": "NoSQL", 
                    "tagLink": "https://api.zhihu.com/topics/19560782"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68531023", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 0, 
            "title": "keystone系列：网关协议（下）", 
            "content": "<h2><b>四 网关协议CGI、FastCGI、WSGI、UWSGI</b></h2><p><b>网关协议CGI</b></p><p>什么是CGI？</p><p>CGI即通用网关接口(Common Gateway Interface)，是web app应用程序（CGI程序）与Web服务器之间的接口标准。。</p><p>CGI 的跨平台性能极佳，几乎可以在任何操作系统上实现。</p><p>fork-and-execute模式：apache接收用户动态请求，先要创建cgi的子进程，然后处理请求，处理完后结束这个子进程。</p><p>fork-and-execute模式的弊端：用cgi方式的服务器有多少连接请求就会有多少cgi子进程，子进程反复加载是cgi性能低下的主要原因。当用户请求数量非常多时，会大量挤占系统的资源如内存，CPU时间等，造成效能低下。</p><p>CGI脚本的工作流程：</p><ol><li>浏览器发送动态请求（通过HTML表单或者超链接）</li><li>服务端接收该请求，调用CGI脚本，产生一个CGI进程来处理该动态请求，结果返回给服务器</li><li>服务器将html返回给浏览器</li></ol><p><b>网关协议FASTCGI</b></p><p>什么是FASTCGI？</p><p>FastCGI是从CGI发展改进而来的</p><p>传统CGI接口方式的主要缺点是性能很差，因为每次HTTP服务器遇到动态请求时都需要重新启动脚本解析器来处理，然后返回结果给HTTP服务器。无法应对高并非场景。</p><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次(这是CGI最为人诟病的fork-and-execute 模式)。</p><p>CGI 就是所谓的短生存期应用程序，FastCGI 就是所谓的长生存期应用程序。</p><p>由于 FastCGI 程序并不需要不断的产生新进程，可以大大降低服务器的压力并且产生较高的应用效率。它的速度效率最少要比CGI 技术提高 5 倍以上。它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</p><p>FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中并因此获得较高的性能。众所周知，CGI解释器的反复加载是CGI性能低下的主要原因，如果CGI解释器保持在内存中并接受FastCGI进程管理器调度，则可以提供良好的性能、伸缩性、Fail-Over特性等等。FastCGI接口方式采用C/S结构，可以将HTTP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HTTP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p><p>FastCGI的工作流程:</p><ol><li>Web Server启动时载入FastCGI进程管理器（PHP-CGI或者PHP-FPM或者spawn-cgi)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个php-cgi)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</li><li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出。</li></ol><p>FastCGI 的特点</p><ol><li>打破传统页面处理技术。传统的页面处理技术，程序必须与 Web 服务器或 Application 服务器处于同一台服务器中。这种历史已经早N年被FastCGI技术所打破，FastCGI技术的应用程序可以被安装在服务器群中的任何一台服务器，而通过 TCP/IP 协议与 Web 服务器通讯，这样做既适合开发大型分布式 Web 群，也适合高效数据库控制。</li><li>明确的请求模式。CGI 技术没有一个明确的角色，在 FastCGI 程序中，程序被赋予明确的角色（响应器角色、认证器角色、过滤器角色）。</li></ol><p>PHP-CGI是PHP自带的FastCGI管理器。PHP-CGI的不足：  php-cgi变更php.ini配置后需重启php-cgi才能让新的php-ini生效，不可以平滑重启 直接杀死php-cgi进程php就不能运行了。(PHP-FPM和Spawn-FCGI就没有这个问题,守护进程会平滑从新生成新的子进程。）</p><p><br/>Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作，不过有不少缺点。而PHP-FPM的出现多少缓解了一些问题，但PHP-FPM有个缺点就是要重新编译，这对于一些已经运行的环境可能有不小的风险)，在php 5.3.3中可以直接使用PHP-FPM了。Spawn-FCGI的代码很少，全部才630行，用c语言编写，最近一次提交是5年前。代码主页：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/lighttpd/spawn-fcgi\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/lighttpd/spa</span><span class=\"invisible\">wn-fcgi</span><span class=\"ellipsis\"></span></a>  Spawn-FCGI代码分析如下：  spawn-fcgi 首先create socket,bind,listen 3步创建服务器socket,(把这个socket叫做 fcgi_fd) 用dup2，把fcgi_fd 交换给 FCGI_LISTENSOCK_FILENO （FCGI_LISTENSOCK_FILENO数值上等于0，这是fastcgi协议当中指定用来listen的socket id） 执行execl ,replaces the current process image with a new process image. process image 进程在运行空间的代码段 很显然，Spawn-FCGI也是 pre-fork 模型，只是用了上古C语言编写，充满了N多 unix下暗黑编程技巧。  Spawn-FCGI功能很单一：  只管fork进程，子进程挂了，主进程仅仅log记录一次，根本不会重新fork。在2009年一段时间内，我曾经用spawn-fcgi部署php-cgi，当跑一段时间就会全挂掉，只能用crontab定时重启spawn-fcgi 不负责子进程中的网络IO，把socket放到指定位置就完了，接下来的事情由被spawn的程序处理 Spawn-FCGI是一个很早期的程序，瞻仰一下即可。另外有：1996年的一段代码:<a href=\"https://link.zhihu.com/?target=http%3A//www.fastcgi.com/om_archive/kit/cgi-fcgi/cgi-fcgi.c\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">fastcgi.com/om_archive/</span><span class=\"invisible\">kit/cgi-fcgi/cgi-fcgi.c</span><span class=\"ellipsis\"></span></a>，和spawn-fcgi一个风格</p><p><br/>PHP-FPM是一个PHP FastCGI管理器，是只用于PHP的,可以在 <a href=\"https://link.zhihu.com/?target=http%3A//php-fpm.org/download\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">php-fpm.org/download</span><span class=\"invisible\"></span></a>下载得到。PHP-FPM其实是PHP源代码的一个补丁，旨在将FastCGI进程管理整合进PHP包中。必须将它patch到你的PHP源代码中，在编译安装PHP后才可以使用。FPM（FastCGI 进程管理器）用于替换 PHP-CGI 的大部分附加功能，对于高负载网站是非常有用的。它的功能包括：  支持平滑停止/启动的高级进程管理功能； 可以工作于不同的 uid/gid/chroot 环境下，并监听不同的端口和使用不同的 php.ini 配置文件（可取代 safe_mode 的设置）； stdout 和 stderr 日志记录; 在发生意外情况的时候能够重新启动并缓存被破坏的 opcode; 文件上传优化支持; “慢日志” – 记录脚本（不仅记录文件名，还记录 PHP backtrace 信息，可以使用 ptrace或者类似工具读取和分析远程进程的运行数据）运行所导致的异常缓慢; fastcgi_finish_request() – 特殊功能：用于在请求完成和刷新数据后，继续在后台执行耗时的工作（录入视频转换、统计处理等）； 动态／静态子进程产生； 基本 SAPI 运行状态信息（类似Apache的 mod_status）； 基于 php.ini 的配置文件。<br/></p><p><b>网关协议WSGI</b></p><p>什么是WSGI？</p><p>Web服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI）是为Python语言定义的Web服务器和Web应用程序或框架之间的一种简单而通用的接口。它只是一个接口定义：它不负责服务器的实现，也不负责网页应用的实现，它只是一个两边接口方式的约定。</p><p>自从WSGI被开发出来以后，许多其它语言中也出现了类似接口。WSGI是作为Web服务器与Web应用程序或应用框架之间的一种低级别的接口，以提升可移植Web应用开发的共同点。WSGI是基于现存的CGI标准而设计的。WSGI就是Python的CGI包装，相对于Fastcgi是PHP的CGI包装</p><p>有了WSGI，你就不用去考虑，服务器程序的具体实现，应用程序获得了很好的适用性。比如一个云平台提供了对 WSGI 接口的支持，那么，只要应用是基于 WSGI 的，就可以直接跑起来。其实keystone就是一款python开发的基于WSGI标准的app。</p><p>什么是WSGI中间件？</p><p>基于WSGI 的设计哲学，我们可以写一些对 server 和 application 都兼容的模块，即WSGI中间件（middleware）。所谓的 WSGI 中间件同时实现了API的两方，因此可以在WSGI服务和WSGI应用之间起调解作用：从WSGI服务器的角度来说，中间件扮演应用程序，而从应用程序的角度来说，中间件扮演服务器。</p><p>WSGI中间件的功能与好处？</p><p>WSGI中间件可以完成比如缓存、字符编码转换、根据 url 做应用 routing 等功能。</p><p>这种设计模式，是 WSGI 降低了 server 和 application 耦合度之后的产物，同时，它从另一个角度大大提升了设计的灵活性。</p><p>WSGI的处理模式</p><p>WSGI将 web 组件分为三类： web服务器，web中间件,web应用程序</p><p>wsgi基本处理模式为 ： WSGI Server -&gt; (WSGI Middleware)* -&gt; WSGI Application 。</p><p>在处理一个WSGI请求时，服务器会为应用程序提供环境资讯及一个回呼函数（Callback Function）。当应用程序完成处理请求后，透过前述的回呼函数，将结果回传给服务器。</p><p><b>1.WSGI Server/gateway</b></p><p>wsgi server可以理解为一个符合wsgi规范的web server，接收request请求，封装一系列环境变量，按照wsgi规范调用注册的wsgi app，最后将response返回给客户端。文字很难解释清楚wsgi server到底是什么东西，以及做些什么事情，最直观的方式还是看wsgi server的实现代码。以python自带的wsgiref为例，wsgiref是按照wsgi规范实现的一个简单wsgi server。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2c321381358b81e71e2725314c85cb91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb\" width=\"644\" data-original=\"https://pic2.zhimg.com/v2-2c321381358b81e71e2725314c85cb91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;644&#39; height=&#39;546&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"644\" data-original=\"https://pic2.zhimg.com/v2-2c321381358b81e71e2725314c85cb91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2c321381358b81e71e2725314c85cb91_b.jpg\"/></figure><ol><li>服务器创建socket，监听端口，等待客户端连接。</li><li>当有请求来时，服务器解析客户端信息放到环境变量environ中，并调用绑定的handler来处理请求。</li><li>handler解析这个http请求，将请求信息例如method，path等放到environ中。</li><li>wsgi handler再将一些服务器端信息也放到environ中，最后服务器信息，客户端信息，本次请求信息全部都保存到了环境变量environ中。</li><li>wsgi handler 调用注册的wsgi app，并将environ和回调函数传给wsgi app</li><li>wsgi app 将reponse header/status/body 回传给wsgi handler</li><li>最终handler还是通过socket将response信息塞回给客户端。</li></ol><p><b>2、WSGI Application</b></p><p>wsgi application就是一个普通的callable对象，当有请求到来时，wsgi server会调用这个wsgi app。这个对象接收两个参数，通常为environ,start_response。environ就像前面介绍的，可以理解为环境变量，跟一次请求相关的所有信息都保存在了这个环境变量中，包括服务器信息，客户端信息，请求信息。start_response是一个callback函数，wsgi application通过调用start_response，将response headers/status 返回给wsgi server。此外这个wsgi app会return 一个iterator对象 ，这个iterator就是response body。</p><p>基于python wsgiref制作wsgi server（web server）</p><p><br/>#_*_coding:utf-8_*_ #!/usr/bin/env python from wsgiref.simple_server import make_server # 定义application函数: def application(environ, start_response):     print(environ)     start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/html&#39;)])      f=open(&#39;test.html&#39;,&#39;rb&#39;)     return [f.read()]  # 创建一个服务器，IP地址为空，端口是8000，处理函数是application: httpd = make_server(&#39;&#39;, 8000, application) print(&#39;Serving HTTP on port 8000...&#39;) # 开始监听HTTP请求: httpd.serve_forever()</p><p><br/>&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt;  &lt;form&gt; 用户名:&lt;br&gt; &lt;input type=&#34;text&#34; name=&#34;username&#34;&gt; &lt;br&gt; 密码:&lt;br&gt; &lt;input type=&#34;text&#34; name=&#34;password&#34;&gt; &lt;input type=&#34;submit&#34; value=&#34;登录&#34;&gt; &lt;/form&gt;  &lt;/body&gt; &lt;/html&gt;</p><p><b>3、WSGI MiddleWare</b></p><p>有些功能可能介于服务器程序和应用程序之间，例如，服务器拿到了客户端请求的URL, 不同的URL需要交由不同的函数处理，这个功能叫做 URL Routing，这个功能就可以放在二者中间实现，这个中间层就是 middleware。middleware对服务器程序和应用是透明的，也就是说，服务器程序以为它就是应用程序，而应用程序以为它就是服务器。这就告诉我们，middleware需要把自己伪装成一个服务器，接受应用程序，调用它，同时middleware还需要把自己伪装成一个应用程序，传给服务器程序。</p><p><b>网关协议uWSGI</b></p><p><u><a href=\"https://link.zhihu.com/?target=http%3A//uwsgi-docs.readthedocs.org/en/latest/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">uWSGI</a></u> is gaining steam as a highly-performant WSGI server implementation.</p><h2><b>五 网关协议与keystone</b></h2><p>keystone本质就是python开发的一款基于wsgi的app，社区提倡的部署方法：</p><p>apache(wsgi)+keystone</p><p>nginx(uwsgi)+keystone</p><h2><b>六 概念梳理</b></h2><p><b>客户端</b></p><p>常用浏览器：chrome</p><p><b>web服务</b></p><p>常用web server：apache，nginx，lighttpd</p><p><b>web app</b></p><p>常用web app开发语言：python，php，java</p><p>python常用web app开发框架（Web框架）：</p><p>除了Flask，常见的Python 还有：</p><ul><li><u><a href=\"https://link.zhihu.com/?target=http%3A//flask.pocoo.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Flask</a></u>：轻量级Web app开发框架；</li><li><u><a href=\"https://link.zhihu.com/?target=https%3A//www.djangoproject.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Django</a></u>：全能型Web app开发框架；</li><li><u><a href=\"https://link.zhihu.com/?target=http%3A//webpy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">web.py</a></u>：一个小巧的Web app开发框架；</li><li><u><a href=\"https://link.zhihu.com/?target=http%3A//bottlepy.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Bottle</a></u>：和Flask类似的Web app开发框架；</li><li><u><a href=\"https://link.zhihu.com/?target=http%3A//www.tornadoweb.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Tornado</a></u>：Facebook的开源异步Web app开发框架。</li></ul><p><b>数据库</b></p><p>常用数据库：mysql,db2,oracle,sqlserver</p>", 
            "topic": [
                {
                    "tag": "网关", 
                    "tagLink": "https://api.zhihu.com/topics/19634894"
                }, 
                {
                    "tag": "边界网关协议", 
                    "tagLink": "https://api.zhihu.com/topics/19612679"
                }, 
                {
                    "tag": "CGI", 
                    "tagLink": "https://api.zhihu.com/topics/19569896"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68530494", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 0, 
            "title": "keystone系列：网关协议（上）", 
            "content": "<h2><b>一 静态页面和动态页面</b></h2><p>在了解了http协议后，我们知晓，一个web server的本质就是</p><ol><li>浏览器发送一个HTTP请求；</li><li>服务器收到请求，生成一个HTML文档；</li><li>服务器把HTML文档作为HTTP响应的Body发送给浏览器；</li><li>浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。</li></ol><p>而用户的请求的结果分静态页面和动态页面两种</p><p>静态页面：是一对写死了的html代码，所有的访问者看到的内容都一样，如你访问京东的主页，所有人看到的都一样</p><p>动态页面：动态的概念意味着变，程序中体现&#39;变&#39;的概念就是变量，因而在html代码中需要嵌入变量，变量的值的来源需要用一段代码动态生成，这样不同的用户会提交不同的数据给服务端，服务端分析用户提交过来的数据然后执行这段代码，动态生成值后赋值html中变量，然后返回html给用户，这样对每个用户来说收到的页面都是不一样的。比如你登录京东，登录后返回的页面每个人都不一样。</p><p><b>二 什么是web server</b></p><p>用户上网的本质就是在自己这端启动socket client（浏览器），服务的启动socket server（web server）。</p><p>基于http协议的学习我们知道，web server主要是用来响应用户的http请求然后返回html页面给用户。</p><p>从用户上网的角度来说，早期的互联网只有俩个角色：浏览器&lt;-&gt;web server，此时所有的用户访问的都是静态页面</p><p>现在主流的web server有apache，nginx，lighttpd等，须知，它们只能接收用户的请求然后生成静态页面</p><p><b>三 什么是网关协议</b></p><p><b>3.1 引子</b></p><p>随着互联网的发展，网站为每个用户单独定制个人的东西呈现给用户成为了主流，这时候就产生了动态页面的需求。</p><p>因web server比如apache只能处理静态请求，所以对于动态请求，你需要编写专门的程序来处理</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-53ebe567f12cef9516c6f87a46dbcd71_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"469\" data-original=\"https://pic2.zhimg.com/v2-53ebe567f12cef9516c6f87a46dbcd71_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;469&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"469\" data-original=\"https://pic2.zhimg.com/v2-53ebe567f12cef9516c6f87a46dbcd71_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-53ebe567f12cef9516c6f87a46dbcd71_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>随着互联网的发展，越来越多的用户数据需要永久保存下来，文件是可以永久保存，但是文件的数据处理性能太低，于是数据库慢慢成为了网站大后端的主流</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b675969696e5304f889f98e8ec6828a1_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"668\" data-original=\"https://pic2.zhimg.com/v2-b675969696e5304f889f98e8ec6828a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;668&#39; height=&#39;101&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"668\" data-original=\"https://pic2.zhimg.com/v2-b675969696e5304f889f98e8ec6828a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b675969696e5304f889f98e8ec6828a1_b.png\"/></figure><p>apache无法处理动态请求，所以我们需要自己编写一个个的功能来处理这些动态请求（注意：这些动态请求有的需要查询数据库有的则不需要）</p><p>我们按照一个需要操作数据的动态请求举例，来分析下问题</p><p><br/>1 #处理动态请求的伪代码，可以称之为web application，或者简web app 2 3 一：接收apache提交过来的用户请求，触发函数运行 4 二：连接数据库 5 三：操作数据库（增删改查） 6 四：根据获取的数据进行其他逻辑处理 7 五：返回给apache数据 8 六：关闭数据库<br/>问题一：</p><p>你在编写web app时，需要深入研究apache工作的协议HTTP，等你研究明白了，过去了一百年。这严重影响了开发效率。</p><p>问题二：</p><p>这只是你针对apache这款web server定制的代码，换成了另外的web server你的程序无法重用</p><p>问题三：</p><p>这只是针对一种动态请求的代码实现，对于其他的动态请求呢，你仍然需要写重复的代码去处理。</p><p><b>3.2 网关协议</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cf16e24bf9ef288c9683a45c2f979ee7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"673\" data-original=\"https://pic4.zhimg.com/v2-cf16e24bf9ef288c9683a45c2f979ee7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;673&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"673\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"673\" data-original=\"https://pic4.zhimg.com/v2-cf16e24bf9ef288c9683a45c2f979ee7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cf16e24bf9ef288c9683a45c2f979ee7_b.png\"/></figure><p>如何解决问题一：</p><p>我们迫切需要在web server与web app之间定义一种标准，用来明细分工，web server对外提供一种标准，web app开发者只要遵循这个标准，那么后者就无需考虑web server到底是如何实现的了而可以专注web app的开发，这个标准就是网关协议</p><p>如何解决问题二：</p><p>在web server与web app之间定义了标准，那么只要我的web app是遵循这个标准的，换另外一个也遵循该标准的web server，同样可以运行</p><p>如何解决问题三：</p><p>这里需要引入一个概念叫：web app开发框架(也称web 框架)</p><p>web app开发框架用来为web app开发者提供一套现成的开发工具与开发模式，web app开发者不再需要写重复代码了，只需要使用某种现成的web开发框架，一些重复的功能就不用再去重复造轮子了，这极大的提高了开发效率</p><p>比如web app开发框架一般本事都是基于网关协议标准实现的，因为你用web app开发框架去开发web app，自然就是遵循某种网关协议标准的，你甚至连这个协议具体是什么都无需知道。</p>", 
            "topic": [
                {
                    "tag": "网关", 
                    "tagLink": "https://api.zhihu.com/topics/19634894"
                }, 
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }, 
                {
                    "tag": "Web 服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19629184"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67896292", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 0, 
            "title": "分布式全文检索引擎之ElasticSearch", 
            "content": "<p><b>一 什么是 ElasticSearch</b></p><p>Elasticsearch 是一个分布式可扩展的实时搜索和分析引擎,一个建立在全文搜索引擎 Apache Lucene(TM) 基础上的搜索引擎.当然 Elasticsearch 并不仅仅是 Lucene 那么简单，它不仅包括了全文搜索功能，还可以进行以下工作:</p><ul><li>分布式实时文件存储，并将每一个字段都编入索引，使其可以被搜索。</li><li>可实现亿级数据实时查询</li><li>实时分析的分布式搜索引擎。</li><li>可以扩展到上百台服务器，处理PB级别的结构化或非结构化数据。</li></ul><p><b>二 安装（windows下）</b></p><p>安装包下载地址</p><p>注意：Elasticsearch是用Java开发的，最新版本的Elasticsearch需要安装jdk1.8以上的环境</p><p>安装包下载完，解压，进入到bin目录，启动 elasticsearch.bat 即可</p><p><b>三 python操作ElasticSearch</b></p><div class=\"highlight\"><pre><code class=\"language-text\"># -*- coding:utf-8 -*-\n# Author : liuqingzheng\nfrom elasticsearch import Elasticsearch\nobj = Elasticsearch()\n# 创建索引（Index）\nresult = obj.indices.create(index=&#39;user&#39;, body={&#34;userid&#34;:&#39;1&#39;,&#39;username&#39;:&#39;lqz&#39;},ignore=400)\n# print(result)\n# 删除索引\n# result = obj.indices.delete(index=&#39;user&#39;, ignore=[400, 404])\n# 插入数据\n# data = {&#39;userid&#39;: &#39;1&#39;, &#39;username&#39;: &#39;tank&#39;,&#39;password&#39;:&#39;123&#39;}\n# result = obj.create(index=&#39;news&#39;, doc_type=&#39;politics&#39;, id=1, body=data)\n# print(result)\n# 更新数据\n&#39;&#39;&#39;\n不用doc包裹会报错\nActionRequestValidationException[Validation Failed: 1: script or doc is missing\n&#39;&#39;&#39;\n# data ={&#39;doc&#39;:{&#39;userid&#39;: &#39;1&#39;, &#39;username&#39;: &#39;tank&#39;,&#39;password&#39;:&#39;123ee&#39;,&#39;test&#39;:&#39;test&#39;}}\n# result = obj.update(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=data, id=1)\n# print(result)\n# 删除数据\n# result = obj.delete(index=&#39;news&#39;, doc_type=&#39;politics&#39;, id=1)\n# 查询\n# 查找所有文档\nquery = {&#39;query&#39;: {&#39;match_all&#39;: {}}}\n# 查找名字叫做jack的所有文档\n# query = {&#39;query&#39;: {&#39;term&#39;: {&#39;username&#39;: &#39;tank&#39;}}}\n# 查找年龄大于11的所有文档\n# query = {&#39;query&#39;: {&#39;range&#39;: {&#39;age&#39;: {&#39;gt&#39;: 11}}}}\nallDoc = obj.search(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=query)\nprint(allDoc[&#39;hits&#39;][&#39;hits&#39;][0][&#39;_source&#39;])</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "分布式存储", 
                    "tagLink": "https://api.zhihu.com/topics/19558640"
                }, 
                {
                    "tag": "elastic search", 
                    "tagLink": "https://api.zhihu.com/topics/20740303"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67641891", 
            "userName": "十维教育", 
            "userLink": "https://www.zhihu.com/people/018e4ecacc2de0aeaefd76b28e7241f0", 
            "upvote": 2, 
            "title": "算法基础", 
            "content": "<p>在学习算法之前引用一位大佬的话：如果你只是想成为一个码农或是一个代码搬运工（Code Monkey），你大可不必学习算法，因为算法对你确实没有用；但是如果你想要成为一个优秀的开发者（Developer），扎实的算法必不可少，因为你会不断掉进一些只能借助算法才能爬出去的坑里。</p><p><b>0|1算法定义</b></p><p>算法是指解题方案的准确而完整的描述，非形式的说，算法就是一切良定义的计算过程，该过程取某个值或值的集合作为输入并产生某个值或值的集合作为输出。算法则描述一个特定的计算过程来实现该输入/输出关系。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><p>一个算法主要具有以下七个重要的特征：</p><p>1、有穷性（Finiteness）：算法的有穷性是指算法必须能在执行有限个步骤之后终止；</p><p>2、确切性（Definiteness）：算法的每一步骤必须有确切的定义；</p><p>3、输入项（Input）：一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；</p><p>4、输出项（Output）：一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；</p><p>5、可行性（Effectiveness）：算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）；</p><p>6、高效性（High efficiency）：执行速度快，占用资源少；</p><p>7、健壮性（Robustness）：对数据响应正确</p><p><b>0|1时间复杂度</b></p><p>一提到时间复杂度，第一个想到的绝对就是算法了，而时间复杂度就是指执行算法所需要的计算工作量。</p><p>在计算机科学当中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间,时间复杂度常用大O符号（大O符号（Big O notation）是用于描述函数渐进行为的数学符号。更确切地说，它是用另一个（通常更简单的）函数来描述一个函数数量级的渐近上界。在数学中，它一般用来刻画被截断的无穷级数尤其是渐近级数的剩余项；在计算机科学中，它在分析算法复杂性的方面非常有用。）<b>大O，简而言之可以认为它的含义是“order of”（大约是）</b></p><p>计算方法：</p><p>一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。</p><p>简单来说，算法是我们解决问题的方法，而我们用这个方法解决这个问题所执行的语句次数，称为语句频度或者时间频度，为<b>T（n）</b></p><p>一般情况下，算法的基本操作重复执行的次数是模块n的某一个函数f（n），因此，算法的时间复杂度记作T(n) = O( f( n ) ).随着模块n的增加算法执行的时间增长率和f（n）的增长率成正比，所以f（n）越小，算法的时间复杂度越低，算法的效率越高。</p><p>在计算时间复杂度的时候，先找出算法的基本操作，然后根据相应的各语句确定它的执行次数，再找出T（n）的同数量级（它的同数量级有以下：1，Log2n ，n ，nLog2n ，n的平方，n的三次方，2的n次方，n！），找出后，f（n）=该数量级，若T(n)/f(n)求极限可得到一常数c，则时间复杂度T（n）=O（f（n））</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-09aa2ca4caebe402ff25ee38c8882b6a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"739\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb\" width=\"739\" data-original=\"https://pic3.zhimg.com/v2-09aa2ca4caebe402ff25ee38c8882b6a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;739&#39; height=&#39;521&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"739\" data-rawheight=\"521\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"739\" data-original=\"https://pic3.zhimg.com/v2-09aa2ca4caebe402ff25ee38c8882b6a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-09aa2ca4caebe402ff25ee38c8882b6a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>简单理解</b>：</p><p>循环减半的过程——&gt;O(logn)</p><p>几层循环就是O的几次方的复杂度，</p><p>常见的时间复杂度（按数量级递增排列）：</p><p>常数阶O(1), 对数阶O(log2n), 线性阶O(n), 线性对数阶O(nlog2n), 平方阶O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k), 指数阶O(2^n)</p><p>其中：</p><p>1、O(n)，O(n^2)， 立方阶O(n^3),...， k次方阶O(n^k) 为多项式阶时间复杂度，分别称为一阶时间复杂度，二阶时间复杂度。。。。</p><p>2、O(2^n)，指数阶时间复杂度，该种不实用</p><p>3、对数阶O(log2n), 线性对数阶O(nlog2n)，除了常数阶以外，该种效率最高</p><p>定义：如果一个问题的规模是n，解这一问题的某一算法所需要的时间为T(n)，它是n的某一函数 T(n)称为这一算法的“时间复杂性”。</p><p>当输入量n逐渐加大时，时间复杂性的极限情形称为算法的“渐近时间复杂性”。</p><p>我们常用大O表示法表示时间复杂性，注意它是某一个算法的时间复杂性。大O表示只是说有上界，由定义如果f(n)=O(n)，那显然成立f(n)=O(n^2)，它给你一个上界，但并不是上确界，但人们在表示的时候一般都习惯表示前者。</p><p>此外，一个问题本身也有它的复杂性，如果某个算法的复杂性到达了这个问题复杂性的下界，那就称这样的算法是最佳算法。</p><p>“大O记法”：在这种描述中使用的基本参数是 n，即问题实例的规模，把复杂性或运行时间表达为n的函数。这里的“O”表示量级 (order)，比如说“二分检索是 O(logn)的”,也就是说它需要“通过logn量级的步骤去检索一个规模为n的数组”记法 O ( f(n) )表示当 n增大时，运行时间至多将以正比于 f(n)的速度增长。</p><p>这种渐进估计对算法的理论分析和大致比较是非常有价值的，但在实践中细节也可能造成差异。例如，一个低附加代价的O(n2)算法在n较小的情况下可能比一个高附加代价的 O(nlogn)算法运行得更快。当然，随着n足够大以后，具有较慢上升函数的算法必然工作得更快。</p><p>O(1)</p><p>Temp=i;i=j;j=temp;</p><p>以上三条单个语句的频度均为1，该程序段的执行时间是一个与问题规模n无关的常数。算法的时间复杂度为常数阶，记作T(n)=O(1)。如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。</p><p>O(n^2)</p><p>2.1. 交换i和j的内容</p><p>sum=0； （一次）</p><p>for(i=1;i&lt;=n;i++) （n次 ）</p><p>for(j=1;j&lt;=n;j++) （n^2次 ）</p><p>sum++； （n^2次 ）</p><p>解：T(n)=2n^2+n+1 =O(n^2)</p><p>2.2.</p><p>for (i=1;i&lt;n;i++)</p><p>{</p><p>y=y+1; ①</p><p>for (j=0;j&lt;=(2*n);j++)</p><p>x++; ②</p><p>}</p><p>解： 语句1的频度是n-1</p><p>语句2的频度是(n-1)*(2n+1)=2n^2-n-1</p><p>f(n)=2n^2-n-1+(n-1)=2n^2-2</p><p>该程序的时间复杂度T(n)=O(n^2).</p><p>O(n)</p><p>2.3.</p><p>a=0;</p><p>b=1; ①</p><p>for (i=1;i&lt;=n;i++) ②</p><p>{</p><p>s=a+b;　　　　③</p><p>b=a;　　　　　④</p><p>a=s;　　　　　⑤</p><p>}</p><p>解：语句1的频度：2,</p><p>语句2的频度： n,</p><p>语句3的频度： n-1,</p><p>语句4的频度：n-1,</p><p>语句5的频度：n-1,</p><p>T(n)=2+n+3(n-1)=4n-1=O(n).</p><p>O(log2n )</p><p>2.4.</p><p>i=1; ①</p><p>while (i&lt;=n)</p><p>i=i*2; ②</p><p>解： 语句1的频度是1,</p><p>设语句2的频度是f(n), 则：2^f(n)&lt;=n;f(n)&lt;=log2n</p><p>取最大值f(n)= log2n,</p><p>T(n)=O(log2n )</p><p>O(n^3)</p><p>2.5.</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>for(j=0;j&lt;i;j++)</p><p>{</p><p>for(k=0;k&lt;j;k++)</p><p>x=x+2;</p><p>}</p><p>}</p><p>解：当i=m, j=k的时候,内层循环的次数为k当i=m时, j 可以取 0,1,...,m-1 , 所以这里最内循环共进行了0+1+...+m-1=(m-1)m/2次所以,i从0取到n, 则循环共进行了: 0+(1-1)*1/2+...+(n-1)n/2=n(n+1)(n-1)/6所以时间复杂度为O(n^3).</p><p>我们还应该区分算法的最坏情况的行为和期望行为。如快速排序的最 坏情况运行时间是 O(n^2)，但期望时间是 O(nlogn)。通过每次都仔细 地选择基准值，我们有可能把平方情况 (即O(n^2)情况)的概率减小到几乎等于 0。在实际中，精心实现的快速排序一般都能以 (O(nlogn)时间运行。</p><p>下面是一些常用的记法：</p><p>访问数组中的元素是常数时间操作，或说O(1)操作。一个算法如 果能在每个步骤去掉一半数据元素，如二分检索，通常它就取 O(logn)时间。用strcmp比较两个具有n个字符的串需要O(n)时间。常规的矩阵乘算法是O(n^3)，因为算出每个元素都需要将n对 元素相乘并加到一起，所有元素的个数是n^2。</p><p>指数时间算法通常来源于需要求出所有可能结果。例如，n个元 素的集合共有2n个子集,所以要求出所有子集的算法将是O(2n)的。指数算法一般说来是太复杂了，除非n的值非常小，因为，在 这个问题中增加一个元素就导致运行时间加倍。不幸的是，确实有许多问题 (如著名的“巡回售货员问题” )，到目前为止找到的算法都是指数的。如果我们真的遇到这种情况，通常应该用寻找近似最佳结果的算法替代之。</p><p><b>0|1空间复杂度</b></p><p>空间复杂度是指执行这个算法所需要的内存空间。</p><p>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度，记做S(n)=O(f(n))。</p><p>对于一个算法来说，空间复杂度和时间复杂度往往是相互影响的。当追求一个较好的时间复杂度时，可能会使空间复杂度的性能变差，即可能导致占用较多的存储空间；反之，当追求一个较好的空间复杂度时，可能会使时间复杂度的性能变差，即可能导致占用较长的运行时间。</p><p>有时我们可以用空间来换取时间以达到目的。</p><p><b>0|1列表查找</b></p><p>列表查找（从列表中查找指定元素）</p><p>输入：列表、待查找元素</p><p>输出：元素下标或未查找到元素</p><p>1、顺序查找（遍历）</p><p>从列表第一个元素开始，顺序进行搜索，直到找到为止。</p><p>def linear_search(data_set, value):</p><p>for i in range(range(data_set)):</p><p>if data_set[i] == value:</p><p>return i</p><p>return</p><p>2、二分查找</p><p>从有序列表的候选区data[0:n] 开始，通过对待查找的值与候选区中间值的比较，可以使候选区减少一半。</p><p># li是用来查找的列表，val是将要查找的值</p><p>def bin_search(li, val):</p><p>low = 0</p><p>high = len(li) - 1</p><p>while low &lt;= high:</p><p>mid = (low + high) // 2</p><p>if li[mid] == val:</p><p>return mid</p><p>elif li[mid] &lt; val:</p><p>low = mid + 1</p><p>else:</p><p>high = mid - 1</p><p>return None</p><p>递归版本的二分查找</p><p>def bin_search_rec(data_set, value, low, high):</p><p>if low &lt;= high:</p><p>mid = (low + high) // 2</p><p>if data_set[mid] == value:</p><p>return mid</p><p>elif data_set[mid] &gt; value:</p><p>return bin_search_rec(data_set, value, low, mid - 1)</p><p>else:</p><p>return bin_search_rec(data_set, value, mid + 1, high)</p><p>else:</p><p>return</p><p><b>0|1常用排序</b></p><p><b>名称</b></p><p><b>复杂度</b></p><p><b>说明</b></p><p><b>备注</b></p><p>冒泡排序</p><p>Bubble Sort</p><p>O(N*N)</p><p>将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮</p><p>插入排序</p><p>Insertion sort</p><p>O(N*N)</p><p>逐一取出元素，在已经排序的元素序列中从后向前扫描，放到适当的位置</p><p>起初，已经排序的元素序列为空</p><p>选择排序</p><p>O(N*N)</p><p>首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾。以此递归。</p><p>快速排序</p><p>Quick Sort</p><p>O(n *log2(n))</p><p>先选择中间值，然后把比它小的放在左边，大的放在右边（具体的实现是从两边找，找到一对后交换）。然后对两边分别使用这个过程（递归）。</p><p>堆排序HeapSort</p><p>O(n *log2(n))</p><p>利用堆（heaps）这种数据结构来构造的一种排序算法。堆是一个近似完全二叉树结构，并同时满足堆属性：即子节点的键值或索引总是小于（或者大于）它的父节点。</p><p>近似完全二叉树</p><p>希尔排序</p><p>SHELL</p><p>O(n1+￡)</p><p>0&lt;￡&lt;1</p><p>选择一个步长(Step) ,然后按间隔为步长的单元进行排序.递归,步长逐渐变小,直至为1.</p><p>箱排序</p><p>Bin Sort</p><p>O(n)</p><p>设置若干个箱子，把关键字等于 k 的记录全都装入到第k 个箱子里 ( 分配 ) ，然后按序号依次将各非空的箱子首尾连接起来 ( 收集 ) 。</p><p>分配排序的一种：通过&#34; 分配 &#34; 和 &#34; 收集 &#34; 过程来实现排序。</p><p><b>演示工具：<a href=\"https://link.zhihu.com/?target=https%3A//visualgo.net/en\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">visualgo.net/en</span><span class=\"invisible\"></span></a></b></p><p>冒泡排序</p><p>冒泡排序，是一种计算机科学领域的比较简单的排序算法。</p><p>重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就将他们交换过来。走访数列的工作是重复地进行直到没有在需要交换的，也就是说该数列已经排序完成。</p><p>这个算法的名字由来是因为越大的元素会经由交换慢慢浮到数列的顶端，所以叫做冒泡排序</p><p># 冒泡排序</p><p>def bubble_sort(li):</p><p># i 是要执行的趟数</p><p>for i in range(len(li) - 1):</p><p># j 是指针</p><p>for j in range(len(li) - i - 1):</p><p># 当前数比上一个数大的时候交换两个数的位置</p><p>if li[j] &gt; li[j + 1]:</p><p>li[j],li[j + 1] = li[j + 1],li[j]</p><p>return li</p><p>插入排序</p><p>将列表分成有序区和无序区两个部分。在最开始有序区只有一个元素；每次从无序区选择一个元素，插入到有序区的位置，知道无序区变空</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5241b4e73b0ba97a61da4d450288431d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"320\" class=\"content_image\" width=\"371\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;371&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"371\" data-rawheight=\"320\" class=\"content_image lazy\" width=\"371\" data-actualsrc=\"https://pic2.zhimg.com/v2-5241b4e73b0ba97a61da4d450288431d_b.jpg\"/></figure><p>#### 插入排序</p><p>def insertSort(li):</p><p>for i in range(len(li) - 1):</p><p>tmp = li[i]</p><p>j = i - 1</p><p>while j &gt;= 0 and li[j] &gt; tmp:</p><p>li[j+1] = li[j]</p><p>j = j - 1</p><p>li[j+1] = tmp</p><p>选择排序</p><p>第一趟遍历记录中最小的数，将其放到第一个位置；再一趟遍历记录中剩余的最小的数，继续放置，依次类推，知道所有的记录遍历完毕...</p><p># 选择排序</p><p>def selectSort(li):</p><p>for i in range(len(li) - 1):</p><p>min = i</p><p>for j in range(i+1, len(li)):</p><p>if li[min] &gt; li[j]:</p><p>li[min], li[j] = li[j], li[min]</p><p>快速排序（最常用）</p><p>快排是我在知道算法后听到最多的一种算法，它是好写的排序算法中最快的一种、执行快的排序算法中最好写的。</p><p>要排序一个数组，首先选取任意一个数据（通常选用数组的第一个数）来作为关键数据，然后将所有比它小的数都放到它的前面，所有比它大的数都放到它的后面。这个过程为一趟快速排序。需要注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p><p>#### 快速排序</p><p>def partition(li, left, right): # li 传入的数组</p><p># 默认选取最左边的数</p><p>tmp = li[left]</p><p>while left &lt; right:</p><p># 当最左边的下标小于最右边的下标和最右边的数大于默认选中的数条件成立</p><p>while left &lt; right and li[right] &gt; tmp:</p><p># 依次往左进行判断</p><p>right = right - 1</p><p># 循环结束，就代表li[right]小于默认数，</p><p>li[left] = li[right]</p><p># 当最左边的下标小于最右边的下标和最左边的数小于默认选中的数条件成立</p><p>while left &lt; right and li[left] &lt; tmp:</p><p># 依次往右判断</p><p>left = left + 1</p><p># 循环结束，就代表li[left]大于默认数</p><p>li[right] = li[left]</p><p>li[left] = tmp</p><p>return left</p><p>def quickSort(li, left, right):</p><p>if left &lt; right:</p><p>mid = partition(li, left, right)</p><p>quickSort(li, left, mid - 1)</p><p>quickSort(li, mid+1, right)</p><p>补充：</p><p>斐波那契数列非递归写法</p><p>def climbStairs(n):</p><p>a = 1</p><p>b = 1</p><p>for i in range(n):</p><p>a, b = b, a + b</p><p>return a</p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "算法设计", 
                    "tagLink": "https://api.zhihu.com/topics/19615875"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66768312", 
            "userName": "盛世天骄", 
            "userLink": "https://www.zhihu.com/people/331269e2a734c0baef7d2ea854f89288", 
            "upvote": 1, 
            "title": "五花八门的服务器商我们该怎么样找到适合自己的呢？", 
            "content": "<p></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3402cd5f52f64ad8232f2e514ae7d3ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"780\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb\" width=\"780\" data-original=\"https://pic4.zhimg.com/v2-3402cd5f52f64ad8232f2e514ae7d3ff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;780&#39; height=&#39;414&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"780\" data-rawheight=\"414\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"780\" data-original=\"https://pic4.zhimg.com/v2-3402cd5f52f64ad8232f2e514ae7d3ff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3402cd5f52f64ad8232f2e514ae7d3ff_b.jpg\"/></figure><p>　　如今市面上的服务器有着众多的供应商，可谓参差不齐，那么企业又应该如何选择自己的服务器呢?企业所选服务器的好坏也就决定了企业网站的稳定性，可服务器的配置有那么多内容，那么企业又应该从哪些方面入手去选择好的服务器呢?</p><p>　　一、服务器的稳定性</p><p>　　企业网站死机的频率跟企业所寄存的服务器有着密切关系，若企业所选的服务器不够稳定，那么企业的网站就会发生宕机事件，这不单单会对企业造成负面的影响，也会影响用户对企业的印象，并且还会影响企业网站在GoogleSEO上的排名。若你不知道应该选择哪一个服务器供应商，你最好询问那些用过某服务器产品的<b>服务器被攻击</b>用户体验，从他们的口碑中选择比较好的服务器，若身边没有人购买过，那你也可以从网络中搜索其他用户的使用体验。</p><p>　　二、服务器的可靠性</p><p>　　就算你所选购的服务器其稳定性不错，但可靠性很差，那也会造成企业网站频繁宕机，因为服务器若不够可靠，那么你的网站将可能频繁地受到黑客攻击，而且供应商的服务器也没有良好的措施去防护，所以企业在选择服务器时，需要选择安全稳定可靠的服务器。</p><p>　　三、服务器的快慢</p><p>　　网站的加载速度对企业来讲十分重要，若你的服务器够快，那么你的网站加载速度就会得到保障，否则当用户发现你的网站打开速度奇慢时他们就会主动关<b>高防VPS云服务器</b>掉你的网站，这样不仅让你流失了一大部分客户，还增加了你网站的跳出率。建议选择采用双向CN2线路以及BGP策略的服务器，可最大限度地保障直达中国内地以及整个亚太区的连接速度。</p><p>　　四、服务器的付费模式</p><p>　　一般的服务器供应商都会提供多种不同的服务器月费计划，但企业应依据自己的需求来选择，而不是以价格为先，如不同的月费计划在服务器配置上也会不同，过大或过小也不利于企业的发展。</p><p>　　五、服务器的操作系统(Linux/Windows)</p><p>　　企业在选择虚拟服务器时，除了需要选择不同的计划外，还需要选择服务器的操作系统，也就是Linux跟<b>美国高防服务器</b>Windows操作系统，如你的CMS在Linux系统上运行得比较好，那么你就选择Linux服务器。</p><p>　　六、服务器供应商的线上售后服务</p><p>　　虽然现在不少服务器供应商都会说他们自己的在线时间高达99%,但就算自称100%上线率的服务器供应商，他们也不可能完全能确保服务器不会出现宕机的时候，宕机有时候无可避免，但重要的是宕机后服务器供应商的响应，是否有工作人员及时帮你抢修。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7bb78ee2db00f78734de65c39380f81f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb\" width=\"578\" data-original=\"https://pic4.zhimg.com/v2-7bb78ee2db00f78734de65c39380f81f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;578&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"578\" data-rawheight=\"300\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"578\" data-original=\"https://pic4.zhimg.com/v2-7bb78ee2db00f78734de65c39380f81f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7bb78ee2db00f78734de65c39380f81f_b.jpg\"/></figure><p>　　云服务器供应商可帮助您设计所需的解决方案</p><p>　　另一方面，云服务供应商可以通过提供私有、公共或混合模式来创建自定义的云访问。服务商将使云服务器和工具尽可能安全，并且有助于安排和规划您的部署，因此几乎不会有任何中断。</p><p>　　服务也有所不同：当您创建基于云服务器和工具时，服务商通常会提供指导，并就IT部署解决方案的规模和范围向您提供建议。许多云服务供应商在医疗保健或房地产等特定行业都有工作经验，因此他们知道像您的公司需要什么样的资源方案，以及遵守行业范围的合规性。</p><p>　　此外，一些企业可以将日常IT功能外包给服务商。您的服务商可能会接管监控和数据备份等安全任务，与外部供应商(如数据输入服务或应用程序开发商)合作，提供无需中转的IT访问权限，维护您的网络并定期将您的软件和IT基础架构更新为必要。<b>香港高防服务器</b></p>", 
            "topic": [
                {
                    "tag": "服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19554575"
                }, 
                {
                    "tag": "地方棋牌", 
                    "tagLink": "https://api.zhihu.com/topics/20082715"
                }, 
                {
                    "tag": "网站建设", 
                    "tagLink": "https://api.zhihu.com/topics/19589903"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66779071", 
            "userName": "盛世天骄", 
            "userLink": "https://www.zhihu.com/people/331269e2a734c0baef7d2ea854f89288", 
            "upvote": 1, 
            "title": "云安全面临的威胁和服务器托管的优势", 
            "content": "<p>  　　我们知道如今不断变化环境里面，云安全是一项重要工作。随着越来越多的企业转向私有云和公共云，但风险只会上升。报告数据泄露事件的数量在2017年增加了40%，并有平均每天有4000次勒索软件攻击。 　　可以肯定地说风险非常非常的高，但知识就是力量。了解这些危险以及如何预防这些危险是制定健全安全计划的关键的第一步。本着这种精神，以下是当今云所面临的安全风险的重要几点。  1.数据泄露 　　任何时候，当您将敏感信息放入云中时，您都会将自己与客户，合作伙伴和员工一起置于潜在的数据泄露之外。在数据泄露事件中，信用卡号码和公司知识产权等敏感信息会暴露出来，这可能会产生深远的影响。更具体地说，数据泄露常常需要一个令人尴尬和可能导致收入损害的公开声明，随后多年修复品牌声誉。而且你也可能面临法律诉讼。通过对高防御服务器云托管数据使用加密和多因素身份验证，保护自己免受破坏。  2.永久数据丢失 　　在某些情况下，永久数据丢失可能与数据泄露一样具有破坏性。自然灾害和技术故障往往是罪魁祸首，但也有报道说大规模数据中心黑客造成损失。更重要的是，事故的确发生了，因为开发集成服务GitLab在无意中删除了整个数据库的客户端信息时获悉了这一情况。尽管任何值得使用它的公司都会定期运行备份，但技术故障意味着成千上万的GitLab代码行将永远丢失在数字以太网中。不要让这是你!执行多个云备份，让自己摆脱困境。  3.Dos攻击 　　想象一下，您的网站充斥着大量虚假访客，使您的资源陷入瘫痪，并使您的服务完全无用。如果您曾经度过拒绝服务(DoS)攻击，那么您已经亲身体验过这种感受。DoS攻击会使您的云服务器长时间瘫痪，从而导致棋牌高防服务器您的公司团队和客户群屡屡受挫，唯一的办法就是等待它。 　　您的云存储提供商可能采取了安全措施来防止这些类型的攻击，但您可以使用内容分发网络(CDN)和Web应用防护系统(WAF)为您提供额外有效的保护。  4.内部威胁 　　任何一个企业都希望每个员工都全心全意，道德自信的在公司顺利的做事，但事实并非如此。如果没有设置适当的访问级别，有犯罪心理的员工可以利用敏感数据获取恶意收入，而如果他们的账户在离开后没有正确禁用，那么心怀不满的前雇员可能会造成各种严重破坏。  5.黑客入侵的界面和API 　　万圣节可能已经结束，但是来自云应用程序和第三方API的安全威胁将会让你的骨头一年比一年寒冷。与托管站点和服务器交互的应用程序与其所接触的云一样安全，许多服务为第三方开发人员提供了访问应用程序API的事实，这只会增加该漏洞的复杂性。 　　如果贵公司提供SaaS服务和API，则开发团队应将威胁建模应用程序和系统实施到开发生命周期中。频繁的代码评论也不是一个坏主意，因为这些将帮助你在黑客入侵之前发现安全漏洞。 　　服务器托管的优势 　　托管，由您自行订购服务器，因此对服务器硬件的性能可以做到足够的把握，使您得以保障高性能，并可以随时访问该硬件，以确保您的业务可以始终保持高效运作。 　　租用，由服务器租用服务商提供，您无法实际去访问您的硬件，您将无法获知您所租用的服务器硬件性能、已运行时长，因此存在一定的硬件故障风险。当然，它的资金支出也相比托管自行订购物理硬件要低得多。 　　不论服务器租用还是托管，服务商均提供所有必要的维护、安全、数据中心设施、温度控制等。这两种选择都有其潜在的优点和缺点。免备案服务器安全面临的威胁和服务器托管的优势</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-69b17cf8695b68ace0e56d10c9ddaa93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"250\" class=\"content_image\" width=\"350\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;350&#39; height=&#39;250&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"350\" data-rawheight=\"250\" class=\"content_image lazy\" width=\"350\" data-actualsrc=\"https://pic4.zhimg.com/v2-69b17cf8695b68ace0e56d10c9ddaa93_b.jpg\"/></figure><p>　　我们知道如今不断变化环境里面，云安全是一项重要工作。随着越来越多的企业转向私有云和公共云，但风险只会上升。报告数据泄露事件的数量在2017年增加了40%，并有平均每天有4000次勒索软件攻击。</p><p>　　可以肯定地说风险非常非常的高，但知识就是力量。了解这些危险以及如何预防这些危险是制定健全安全计划的关键的第一步。本着这种精神，以下是当今云所面临的安全风险的重要几点。</p><p> 1.数据泄露</p><p>　　任何时候，当您将敏感信息放入云中时，您都会将自己与客户，合作伙伴和员工一起置于潜在的数据泄露之外。在数据泄露事件中，信用卡号码和公司知识产权等敏感信息会暴露出来，这可能会产生深远的影响。更具体地说，数据泄露常常需要一个令人尴尬和可能导致收入损害的公开声明，随后多年修复品牌声誉。而且你也可能面临法律诉讼。通过对<b>高防御服务器</b>云托管数据使用加密和多因素身份验证，保护自己免受破坏。</p><p> 2.永久数据丢失</p><p>　　在某些情况下，永久数据丢失可能与数据泄露一样具有破坏性。自然灾害和技术故障往往是罪魁祸首，但也有报道说大规模数据中心黑客造成损失。更重要的是，事故的确发生了，因为开发集成服务GitLab在无意中删除了整个数据库的客户端信息时获悉了这一情况。尽管任何值得使用它的公司都会定期运行备份，但技术故障意味着成千上万的GitLab代码行将永远丢失在数字以太网中。不要让这是你!执行多个云备份，让自己摆脱困境。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d711ec1439a01819998b873e5e9c0b17_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb\" width=\"491\" data-original=\"https://pic4.zhimg.com/v2-d711ec1439a01819998b873e5e9c0b17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;491&#39; height=&#39;331&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"491\" data-rawheight=\"331\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"491\" data-original=\"https://pic4.zhimg.com/v2-d711ec1439a01819998b873e5e9c0b17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d711ec1439a01819998b873e5e9c0b17_b.jpg\"/></figure><p> 3.Dos攻击</p><p>　　想象一下，您的网站充斥着大量虚假访客，使您的资源陷入瘫痪，并使您的服务完全无用。如果您曾经度过拒绝服务(DoS)攻击，那么您已经亲身体验过这种感受。DoS攻击会使您的云服务器长时间瘫痪，从而导致<b>棋牌高防服务器</b>您的公司团队和客户群屡屡受挫，唯一的办法就是等待它。</p><p>　　您的云存储提供商可能采取了安全措施来防止这些类型的攻击，但您可以使用内容分发网络(CDN)和Web应用防护系统(WAF)为您提供额外有效的保护。</p><p> 4.内部威胁</p><p>　　任何一个企业都希望每个员工都全心全意，道德自信的在公司顺利的做事，但事实并非如此。如果没有设置适当的访问级别，有犯罪心理的员工可以利用敏感数据获取恶意收入，而如果他们的账户在离开后没有正确禁用，那么心怀不满的前雇员可能会造成各种严重破坏。</p><p> 5.黑客入侵的界面和API</p><p>　　万圣节可能已经结束，但是来自云应用程序和第三方API的安全威胁将会让你的骨头一年比一年寒冷。与托管站点和服务器交互的应用程序与其所接触的云一样安全，许多服务为第三方开发人员提供了访问应用程序API的事实，这只会增加该漏洞的复杂性。</p><p>　　如果贵公司提供SaaS服务和API，则开发团队应将威胁建模应用程序和系统实施到开发生命周期中。频繁的代码评论也不是一个坏主意，因为这些将帮助你在黑客入侵之前发现安全漏洞。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c6574357ce0e5d951d0b732e94ee97bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"225\" class=\"content_image\" width=\"363\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;363&#39; height=&#39;225&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"225\" class=\"content_image lazy\" width=\"363\" data-actualsrc=\"https://pic2.zhimg.com/v2-c6574357ce0e5d951d0b732e94ee97bd_b.jpg\"/></figure><p>　　服务器托管的优势</p><p>　　托管，由您自行订购服务器，因此对服务器硬件的性能可以做到足够的把握，使您得以保障高性能，并可以随时访问该硬件，以确保您的业务可以始终保持高效运作。</p><p>　　租用，由服务器租用服务商提供，您无法实际去访问您的硬件，您将无法获知您所租用的服务器硬件性能、已运行时长，因此存在一定的硬件故障风险。当然，它的资金支出也相比托管自行订购物理硬件要低得多。</p><p>　　不论服务器租用还是托管，服务商均提供所有必要的维护、安全、数据中心设施、温度控制等。这两种选择都有其潜在的优点和缺点。<b>免备案服务器</b></p>", 
            "topic": [
                {
                    "tag": "服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19554575"
                }, 
                {
                    "tag": "地方棋牌", 
                    "tagLink": "https://api.zhihu.com/topics/20082715"
                }, 
                {
                    "tag": "网站建设", 
                    "tagLink": "https://api.zhihu.com/topics/19589903"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64295059", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "记一次商业项目的优化过程", 
            "content": "<p>时间追溯到2月份，一个历时20天的小项目上线了。</p><p>20天。能干点啥，你我都能懂吧，但是还是赶出来了</p><p>项目背景是一个类似企业分享直播的平台（结合第三方），根据客户需求，这次分享最多300人参加（线上=移动+PC），然后架构设计拟定为单体架构，不用过多优化，正常开发就可以。但是就在直播开始的前几分钟，后台出现了，数据库连接数过多，系统一会直接崩了。</p><p>之后迅速查看阿里云后台监控发现tcp连接居然有5000，小声（wocao）</p><p>说好的不到300人呢，你是不是在逗我。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3f562754e4df691675d04ee7ec0f7a10_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-3f562754e4df691675d04ee7ec0f7a10_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>之后迅速升级网站配置，重启服务器，之后还是崩溃？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d1aa5bb7aaf03f957ead6ca731f743d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic2.zhimg.com/v2-d1aa5bb7aaf03f957ead6ca731f743d9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>因为阿里云的服务器（其他的服务器不知）有自我保护意识，到达一定的并发，将自启保护措施（类似），然后这就相当于我们升级分配置服务器将无法使用，之后调整服务器的配置就行优化</p><p>然后重启，趋于稳定，但是这已经是开播的10分钟之后，聊天室此时各种抱怨，怎么刚才进不来。。。。</p><p>最终直播结束，这也宣布这次直播服务失败（编写事故汇报），和客户撕逼</p><p>最终确认下次直播，人数将达到5000人，接下来就是各种优化</p><p>首先我们加了一个cdn，，然后压缩js+css，压缩图片</p><p>之后将首页做了页面静态化，之后升级服务器的带宽，压力测试5000并发，ok了</p><p>在之后就是优化直播页面，难点在于：实时更新在线人数（人气），动态加载用户信息，动态渲染页面</p><p>解决</p><p>（1）实时更新在线人数：使用websocket做长连接，减少每次握手带来的消耗，将数据存储在redis里面，每次请求直接从redis里面获取，之后根据关闭浏览器来减少redis人气数（非强一致性）</p><p>（2）动态加载用户信息</p><p>1）将登陆方式改成点击操作才登陆，这样就能减少一部分并发的可能性</p><p>2）将会用的信息存储在redis里面做队列存储</p><p>由于时间关系，我们选择了第一种方案，然后模拟测试，还算ok</p><p>（3）动态渲染页面：将一些实时的参数通过实时的ajax加载，然后其他非实时参数做静态缓存</p><p>第二次直播，顺利完成！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-80298eecd7068eed66e3187d2c433fc8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-80298eecd7068eed66e3187d2c433fc8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>总结：</p><p>（1）服务器配置要跟得上</p><p>（2）判断是cpu计算密集型还是非密集型</p><p>（3）查看是否吃带宽，然后升级带宽</p><p>（4）尽量将流量限制在上游，让操作数据的业务尽量来的晚一些</p><p>（5）判断业务是否适合做页面静态化，这样大大提高并发</p><p>（6）如果在apache和nginx里面选择的话，nginx处理静态资源真的很强大，还是用nginx吧-非绝对，自己判断</p><p>最后加环境：PHP+Mysql+Nginx+Linux</p><p>祝大家5.1快乐</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f8d542d9caf3c066d8ca29de55214dbc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"174\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;174&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"174\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic1.zhimg.com/v2-f8d542d9caf3c066d8ca29de55214dbc_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "优化", 
                    "tagLink": "https://api.zhihu.com/topics/19570512"
                }, 
                {
                    "tag": "实战", 
                    "tagLink": "https://api.zhihu.com/topics/19876792"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64231935", 
            "userName": "凡猫学院软件测试", 
            "userLink": "https://www.zhihu.com/people/ce9edfb49f5519c6e859296f669f1c7f", 
            "upvote": 1, 
            "title": "最新测试面试题，你知道吗？", 
            "content": "<p>最近整理了一些面试题，正在找工作的亲们可以练习</p><p>1. 画出传统开发流程V 字模型，敏捷开发流程V 字模型。简述其中的测试工作生命周期和流程。（5 分）</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2.黑盒功能测试的目的、方法， 以及测试工作本身的检验指标。(5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>3. 开发人员说这不是Bug，如何应对? (10 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>4.设计测试用例的关键是什么(黑盒/白盒)。(5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>5. 接口测试问题(15 分)</p><p>A. 被测接口人中存在某一参数“时间点”，需要来自于接口B 中的返回值参数(Json)，如何处理被测接口A 中的参数“时间点”。(5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B.依赖于第三方数据的接口如何进行测试? (5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>C.接口测试中依赖登录状态的接口如何测试? (5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>6.性能制试问题（15 分）</p><p>A.性能测试流程（5 分）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B.如何测试MQ?(5 分）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>C. TPS 上不去怎么办? (6 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>7. 自动化UI 方向问题(15 分)</p><p>A.请详细阐述接口测试和UI 测试在测试活动中是如何协同测试的? (5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B.自动化测试的时候是不是需要连接数据库做数据校验?(5 分)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>C. id,name,class, xpath, css selector 这些属性，哪种更常用为什么?（5分）</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>8.工具与测试框架认知(15 分)</p><p>简述你认识的商业/开源测试工具/框架工具名称用途</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>9. Python 代码:说出该代码完成的目标，尝试进行优化：(15 分）</p><p>list = [3.1.5,7.8.6,20,4，9]</p><p>def bubble(list):</p><p>high = len(list)</p><p>while high&gt;O:</p><p>for i in range (O, high):</p><p>if list[i]&gt;list[i+1]：#如果比下一位大</p><p>List[i],list[i+l] = list[i+1], list[i] #交换变量位置</p><p>high -=1</p><p>return list #并返回列表</p><p>print (bubble（list))</p><p>哈哈，想知道答案可以找我获取试题答案</p><p></p>", 
            "topic": [
                {
                    "tag": "软件测试", 
                    "tagLink": "https://api.zhihu.com/topics/19562409"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "自动化测试", 
                    "tagLink": "https://api.zhihu.com/topics/19574587"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64241620", 
            "userName": "凡猫学院软件测试", 
            "userLink": "https://www.zhihu.com/people/ce9edfb49f5519c6e859296f669f1c7f", 
            "upvote": 0, 
            "title": "jmeter之Mysql数据库性能测试初探", 
            "content": "<p><b>加载JDBC驱动 </b><br/></p><p>数据库测试需要加载JDBC 驱动，先下载mysql-connector-java-5.1.4.jar，可以直接拷贝到</p><p>jmeter 安装目录的lib 目录下或在jmeter 中的测试计划中导入，点击测试计划--&gt;点击浏览--&gt;选中mysql驱动jar包--&gt;打开如图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bcbc4ae66b0aada6bd52736c735c9d2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1071\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb\" width=\"1071\" data-original=\"https://pic2.zhimg.com/v2-bcbc4ae66b0aada6bd52736c735c9d2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1071&#39; height=&#39;570&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1071\" data-rawheight=\"570\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1071\" data-original=\"https://pic2.zhimg.com/v2-bcbc4ae66b0aada6bd52736c735c9d2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bcbc4ae66b0aada6bd52736c735c9d2d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>1.在线程组中再新增JDBC连接配置，右键”添加“--”配置元件“--”JDBC Connection Configuration“<br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b04f666b349d6f1b051a0f90c6a9b141_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"527\" class=\"origin_image zh-lightbox-thumb\" width=\"837\" data-original=\"https://pic2.zhimg.com/v2-b04f666b349d6f1b051a0f90c6a9b141_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;837&#39; height=&#39;527&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"837\" data-rawheight=\"527\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"837\" data-original=\"https://pic2.zhimg.com/v2-b04f666b349d6f1b051a0f90c6a9b141_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b04f666b349d6f1b051a0f90c6a9b141_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Database ULR参数:jdbc：mysql：//本地位置：端口号/数据库名</p><p>DBC Driver class参数：org.gjt.mm.mysql.Driver或com.mysql.jdbc.Driver</p><p>Username:填数据库登录用户名；Pasdword填连接数据库的密码<br/></p><p>2.再添加一个JDBC Request（Sampler中能找到这个resquest）;这里的Variable Name要和上面的名字要一样一样，不然会报错；第二个红框部分输入数据库语句</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2d1073c134708617a5ed0f379781db54_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic1.zhimg.com/v2-2d1073c134708617a5ed0f379781db54_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;285&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic1.zhimg.com/v2-2d1073c134708617a5ed0f379781db54_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2d1073c134708617a5ed0f379781db54_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3.添加响应断言和断言结果，在响应断言中添加响应文本如图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a9eb5fae853b1a7b3fea3b0526e9dff1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-a9eb5fae853b1a7b3fea3b0526e9dff1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;227&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic2.zhimg.com/v2-a9eb5fae853b1a7b3fea3b0526e9dff1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a9eb5fae853b1a7b3fea3b0526e9dff1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4.添加聚合报告和查看结果树，这些组件都添加设置完成后，点击绿色启动按钮便可运行起来了。</p><p>聚合报告：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-01daec1ecd6dede3ba15945854ab4f3a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-01daec1ecd6dede3ba15945854ab4f3a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-01daec1ecd6dede3ba15945854ab4f3a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-01daec1ecd6dede3ba15945854ab4f3a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>断言结果：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6974c85d726fa4e4eed6f6bd0bea4d57_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-6974c85d726fa4e4eed6f6bd0bea4d57_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;618&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"618\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"618\" data-original=\"https://pic4.zhimg.com/v2-6974c85d726fa4e4eed6f6bd0bea4d57_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6974c85d726fa4e4eed6f6bd0bea4d57_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>查看结果树：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f484a75fd4de097c53df8212f79e14e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-f484a75fd4de097c53df8212f79e14e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic3.zhimg.com/v2-f484a75fd4de097c53df8212f79e14e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f484a75fd4de097c53df8212f79e14e6_b.jpg\"/></figure><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "jmeter", 
                    "tagLink": "https://api.zhihu.com/topics/19804390"
                }, 
                {
                    "tag": "软件测试", 
                    "tagLink": "https://api.zhihu.com/topics/19562409"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64242290", 
            "userName": "凡猫学院软件测试", 
            "userLink": "https://www.zhihu.com/people/ce9edfb49f5519c6e859296f669f1c7f", 
            "upvote": 0, 
            "title": "python之判断是否是目录或文件", 
            "content": "<p>在python中我们判断是否是目录还是文件用函数 os path. isdir 、os. path .isfile</p><p>该函数作用就是判断是否是目录、判断是否是文件。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-94d563a97fdffdcbaf2d6fb256babfd7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"299\" class=\"content_image\" width=\"383\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;383&#39; height=&#39;299&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"383\" data-rawheight=\"299\" class=\"content_image lazy\" width=\"383\" data-actualsrc=\"https://pic4.zhimg.com/v2-94d563a97fdffdcbaf2d6fb256babfd7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>1.打开pycharm新建一python文件：</p><p>代码如下：</p><p>import os<br/></p><p>print(os.path.isdir(&#39;F:\\untitled\\IO\\文件处理\\python_io&#39;))<br/></p><p>print(os.path.isfile(r&#39;F:\\untitled\\IO\\文件处理\\python_io\\test_dir\\sub_001\\os.path.isdir or os.path.isfile.py&#39;))</p><p>运行代码,返回结果如下所示:</p><p class=\"ztext-empty-paragraph\"><br/></p><p>C:\\Users\\laumcc\\AppData\\Local\\Programs\\Python\\Python37\\python.exe &#34;F:/untitled/IO/文件处理/python_io/test_dir/sub_001/os.path.isdir or os.path.isfile.py&#34;</p><p>False</p><p>True</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：</p><p>1、在字符串前加上r或R，即：r&#39;F:\\untitled\\IO\\文件处理\\python_io\\test_dir\\sub_001\\os.path.isdir or os.path.isfile.py) ，其中r或R在python中表示一个不转义的字符串。</p><p>2、在“\\”前加上&#34;\\&#34;实现转义。即：F:\\\\untitled\\IO\\文件处理\\python_io\\test_dir\\sub_001\\os.path.isdir or os.path.isfile.py </p><p>3、将“\\”换为“/”即：F:/untitled/IO/文件处理/python_io/test_dir/sub_001/os.path.isdir or os.path.isfile.py</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "软件测试", 
                    "tagLink": "https://api.zhihu.com/topics/19562409"
                }, 
                {
                    "tag": "自动化测试", 
                    "tagLink": "https://api.zhihu.com/topics/19574587"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60861200", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "session、cookie、token的区别", 
            "content": "<p>1.什么是Cookie？<br/>Cookie 技术产生源于 HTTP 协议在互联网上的急速发展。随着互联网时代的策马奔腾，带宽等限制不存在了，人们需要更复杂的互联网交互活动，就必须同服务器保持活动状态（简称：保活）。<br/>于是，在浏览器发展初期，为了适应用户的需求技术上推出了各种保持  Web 浏览状态的手段，其中就包括了 Cookie 技术。Cookie 在计算机中是个存储在浏览器目录中的文本文件，当浏览器运行时，存储在  RAM 中发挥作用 （此种 Cookies 称作 Session Cookies），一旦用户从该网站或服务器退出，Cookie  可存储在用户本地的硬盘上 （此种 Cookies 称作 Persistent Cookies）。<br/>Cookie 起源：1993 年，网景公司雇员 Lou Montulli 为了让用户在访问某网站时，进一步提高访问速度，同时也为了进一步实现个人化网络，发明了今天广泛使用的 Cookie。（所以，适当的偷懒也会促进人类计算机发展史的一小步~）<br/>Cookie时效性：目前有些 Cookie 是临时的，有些则是持续的。临时的 Cookie 只在浏览器上保存一段规定的时间，一旦超过规定的时间，该 Cookie 就会被系统清除。<br/>Cookie使用限制：Cookie  必须在 HTML 文件的内容输出之前设置；不同的浏览器 (Netscape Navigator、Internet Explorer) 对  Cookie 的处理不一致，使用时一定要考虑；客户端用户如果设置禁止 Cookie，则 Cookie 不能建立。  并且在客户端，一个浏览器能创建的 Cookie 数量最多为 300 个，并且每个不能超过 4KB，每个 Web 站点能设置的 Cookie  总数不能超过 20 个。<br/>执行流程：<br/>A：首先，客户端会发送一个http请求到服务器端。<br/>B： 服务器端接受客户端请求后，发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。<br/>C：在客户端发起的第二次请求（注意：如果服务器需要我们带上Cookie，我们就需要在B步骤上面拿到这个Cookie然后作为请求头一起发起第二次请求），提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。<br/>为了方便理解，可以先看下这张流程执行图加深概念<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fdcd3a43dff6f6efc7f2e1a989213f37_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"404\" data-rawheight=\"204\" class=\"content_image\" width=\"404\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;404&#39; height=&#39;204&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"404\" data-rawheight=\"204\" class=\"content_image lazy\" width=\"404\" data-actualsrc=\"https://pic4.zhimg.com/v2-fdcd3a43dff6f6efc7f2e1a989213f37_b.jpg\"/></figure><p><br/>image.png<br/>那么，在浏览器上面的请求头和Cookie在那？下图给大家截取了其中一种。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0ca35d87366011634e516c4dfbbb9623_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-0ca35d87366011634e516c4dfbbb9623_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-0ca35d87366011634e516c4dfbbb9623_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0ca35d87366011634e516c4dfbbb9623_b.jpg\"/></figure><p><br/>image.png<br/>那么，上面都是谈浏览器上的Cookie，那么在Android开发中，我们该如何去管理和使用Cookie？<br/>Okhttp作为经典到爆的网络框架，它的API（本文是基于Okhttp3.0版本以上，3.0以下的版本API有所不同）是通过OkhttpClient中的CookieJar或者拦截器去管理Cookie的。理论上，我们只需在构建单例OkhttpClient的时候，设置cookiejar或者拦截器，然后具体的操作（具体的操作也就是保存Cookie，取Cookie），Okhttp框架就会帮我们自动管理Cookie。<br/>如下图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2673b690022e793d563d0fcef02120cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-2673b690022e793d563d0fcef02120cf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"296\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-2673b690022e793d563d0fcef02120cf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2673b690022e793d563d0fcef02120cf_b.jpg\"/></figure><p><br/>image.png<br/>这是其中一种通过集合的增查特性，就可以简单有效的帮我们管理Cookie。但我们还是要通过源代码去一探究竟。首先，CookieJar是一个接口。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a56678b0ea86237a6fa2e0fe7f570378_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-a56678b0ea86237a6fa2e0fe7f570378_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-a56678b0ea86237a6fa2e0fe7f570378_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a56678b0ea86237a6fa2e0fe7f570378_b.jpg\"/></figure><p><br/>image.png<br/>英文注释翻译过来就是（对应段落翻译）：<br/>CookieJar这个接口为HTTP cookies提供了强大的支持和相关策略。<br/>这种策略的实现作用会负责选择接受和拒绝那些cookie。一个合理的策略是拒绝所有的cookie，尽管这样会干扰需要cookie的基于会话的自身身份验证方案。<br/>作为Cookie的持久性，该接口的实现也必须要提供Cookie的存储。一种简单的实现可以将cookie存储在内存中;复杂的系统可以使用文件系统用于保存已接受的cookie的数据库。这里的链接<a href=\"https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc6265\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">tools.ietf.org/html/rfc</span><span class=\"invisible\">6265</span><span class=\"ellipsis\"></span></a>  指定cookie存储模型更新和过期的cookie的策略。<br/>所以，Okhttp的源码告知我们可以将cookie存储在内存中;复杂的系统可以使用文件系统用于保存已接受的cookie的数据库。因此，我们就可以通过Map去简单的管理和使用。<br/>继续分析CookieJar接口里面的方法，依旧上源码<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cfac2484035a563eecab7858e86ce9cd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-cfac2484035a563eecab7858e86ce9cd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-cfac2484035a563eecab7858e86ce9cd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cfac2484035a563eecab7858e86ce9cd_b.jpg\"/></figure><p><br/>image.png<br/>里面有方法一个是saveFromResponse(HttpUrl url, List cookies)、loadForRequest(HttpUrl url)<br/>saveFromResponse方法翻译：根据这个jar的方法，可以将cookie从一个HTTP响应保存到这里。<br/>请注意，如果响应，此方法可能被称为第二次HTTP响应，包括一个追踪。对于这个隐蔽的HTTP特性，这里的cookie只包含其追踪的cookie。简单点理解就是如果我们使用了这个方法，就会进行追踪（说白了就是客户端请求成功以后，在响应头里面去存cookie）<br/>loadForRequest方法翻译：将cookie从这个方法加载到一个HTTP请求到指定的url。这个方法从网络上返回的结果可能是一个空集合。简单的实现将返回尚未过期的已接受的cookie去进行匹配。（说白了就是加载url的时候在请求头带上cookie）。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3dcfe5bec25ab5dccec3ac31191a6238_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-3dcfe5bec25ab5dccec3ac31191a6238_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"284\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic1.zhimg.com/v2-3dcfe5bec25ab5dccec3ac31191a6238_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3dcfe5bec25ab5dccec3ac31191a6238_b.jpg\"/></figure><p><br/>image.png<br/>这样，我们通过以上代码就可以完成了Cookie的非持久化。什么，非持久化，这又是神马？<br/>继续给大家科普，在上面说道，Cookie是具有时效性的，所以，Cookie的管理又分为持久化Cookie和非持久化Cookie。非持久化Cookie存储在内存中，也就意味着，其生命周期基本和app保持一致,app关闭后，Cookie丢失。而持久化Cookie则是存储在本地磁盘中，app关闭后不丢失。那么，如果我们要使用Cookie的持久化策略，思想可以参考上面的非持久化策略，只需要将存储方式改一下即可：<br/>A：通过响应拦截器从response取出cookie并保存到本地，通过请求拦截器从本地取出cookie并添加到请求中<br/>B：自定义CookieJar，在saveFromResponse()中保存cookie到本地，在loadForRequest()从本地取出cookie。<br/>那么在这里主要介绍如何通过Okhttp逼格值较高的拦截器去进行持久化cookie操作。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0dae6afe55b7779eb7aae810e0486beb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-0dae6afe55b7779eb7aae810e0486beb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-0dae6afe55b7779eb7aae810e0486beb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0dae6afe55b7779eb7aae810e0486beb_b.jpg\"/></figure><p><br/>image.png<br/>保存cookie拦截器-1<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-62710415f506109128d2ef9f5b41b223_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-62710415f506109128d2ef9f5b41b223_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic4.zhimg.com/v2-62710415f506109128d2ef9f5b41b223_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-62710415f506109128d2ef9f5b41b223_b.jpg\"/></figure><p><br/>image.png<br/>保存cookie拦截器-2<br/>这个SaveCookiesInterceptor拦截器的实现，是首先从response获取set-cookie字段的值，然后通过SharedPreferences保存在本地。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-016993a68a3f9357acb44ef1845d33cd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-016993a68a3f9357acb44ef1845d33cd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-016993a68a3f9357acb44ef1845d33cd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-016993a68a3f9357acb44ef1845d33cd_b.jpg\"/></figure><p><br/>image.png<br/>将Cookie添加到请求头<br/>AddCookiesInterceptor请求拦截器，这个拦截的作用就是判断如果该请求存在cookie，则为其添加到Header的Cookie中。<br/>写好这两个拦截器之后，我们只需要将实例对象放进OkhttpClient里面即可快速的完成Cookie持久化操作。（PS：这两个拦截器在同步Cookie的时候也是超级好用）<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4b094fca467ed052b11b49a6e0a2f83d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-4b094fca467ed052b11b49a6e0a2f83d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;558&#39; height=&#39;155&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"558\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"558\" data-original=\"https://pic2.zhimg.com/v2-4b094fca467ed052b11b49a6e0a2f83d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4b094fca467ed052b11b49a6e0a2f83d_b.jpg\"/></figure><p><br/>image.png<br/>Okhttp使用cookie拦截器<br/>拓展：如何通过客户端的cookie与H5上面的cookie进行同步，给大家推荐这一篇文章<br/>客户端与H5同步Cookie<br/><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/88084a66c256\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/88084a66c</span><span class=\"invisible\">256</span><span class=\"ellipsis\"></span></a><br/>2.Session<br/>Session是对于服务端来说的，客户端是没有Session一说的。Session是服务器在和客户端建立连接时添加客户端连接标志，最终会在服务器软件（Apache、Tomcat、JBoss）转化为一个临时Cookie发送给给客户端，当客户端第一请求时服务器会检查是否携带了这个Session（临时Cookie），如果没有则会添加Session，如果有就拿出这个Session来做相关操作。<br/>在这里引用别人家的一个小故事来加深印象：<br/>在说session是啥之前，我们先来说说为什么会出现session会话，它出现的机理是什么？<br/>我们知道，我们用浏览器打开一个网页，用到的是HTTP协议，了解计算机的应该都知道这个协议，它是无状态的，什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。但是这种无状态的的好处是快速。所以就会带来一个问题就是，我希望几个请求的页面要有关联，比如：我在<a href=\"https://link.zhihu.com/?target=http%3A//www.a.com/login.php\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">a.com/login.php</span><span class=\"invisible\"></span></a>里面登陆了，我在<a href=\"https://link.zhihu.com/?target=http%3A//www.a.com/index.php\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">a.com/index.php</span><span class=\"invisible\"></span></a>   也希望是登陆状态，但是，这是2个不同的页面，也就是2个不同的HTTP请求，这2个HTTP请求是无状态的，也就是无关联的，所以无法单纯的在index.php中读取到它在login.php中已经登陆了！<br/>那咋搞呢？我不可能这2个页面我都去登陆一遍吧。或者用笨方法这2个页面都去查询数据库，如果有登陆状态，就判断是登陆的了。这种查询数据库的方案虽然可行，但是每次都要去查询数据库不是个事，会造成数据库的压力。   所以正是这种诉求，这个时候，一个新的客户端存储数据方式出现了：cookie。cookie是把少量的信息存储在用户自己的电脑上，它在一个域名下是一个全局的，只要设置它的存储路径在域名<a href=\"https://link.zhihu.com/?target=http%3A//www.a.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">a.com</span><span class=\"invisible\"></span></a>下   ，那么当用户用浏览器访问时，php就可以从这个域名的任意页面读取cookie中的信息。所以就很好的解决了我在<a href=\"https://link.zhihu.com/?target=http%3A//www.a.com/login.php\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">a.com/login.php</span><span class=\"invisible\"></span></a>页面登陆了，我也可以在<a href=\"https://link.zhihu.com/?target=http%3A//www.a.com/index.php\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">a.com/index.php</span><span class=\"invisible\"></span></a>获取到这个登陆信息了。<br/>同时又不用反复去查询数据库。  虽然这种方案很不错，也很快速方便，但是由于cookie  是存在用户端，而且它本身存储的尺寸大小也有限，最关键是用户可以是可见的，并可以随意的修改，很不安全。那如何又要安全，又可以方便的全局读取信息呢？于是，这个时候，一种新的存储会话机制：session  诞生了。<br/>Session 就是在一次会话中解决2次HTTP的请求的关联，让它们产生联系，让2两个页面都能读取到找个这个全局的session信息。session信息存在于服务器端，所以也就很好的解决了安全问题。<br/>3.Token<br/>token是用户身份的验证方式，我们通常叫它：令牌。最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。<br/>应用场景：<br/>A：当用户首次登录成功（注册也是一种可以适用的场景）之后, 服务器端就会生成一个 token 值，这个值，会在服务器保存token值(保存在数据库中)，再将这个token值返回给客户端.<br/>B：客户端拿到 token 值之后,进行本地保存。（SP存储是大家能够比较支持和易于理解操作的存储）<br/>C：当客户端再次发送网络请求(一般不是登录请求)的时候,就会将这个 token 值附带到参数中发送给服务器.<br/>D：服务器接收到客户端的请求之后,会取出token值与保存在本地(数据库)中的token值做对比<br/>对比一：如果两个 token 值相同， 说明用户登录成功过!当前用户处于登录状态!<br/>对比二：如果没有这个 token 值, 则说明没有登录成功.<br/>对比三：如果 token 值不同: 说明原来的登录信息已经失效,让用户重新登录.<br/>#Cookie和Session的区别：<br/>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。<br/>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗,考虑到安全应当使用session。<br/>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。<br/>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。<br/>5、所以个人建议：<br/>将登陆信息等重要信息存放为session<br/>其他信息如果需要保留，可以放在cookie中<br/>Token 和 Session 的区别：<br/>session和   token并不矛盾，作为身份认证token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态。<br/>App通常用restful   api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session  token来标示自己就够了，session/state由api server的逻辑处理。如果你的后端不是stateless的rest  api,那么你可能需要在app里保存session.可以在app里嵌入webkit,用一个隐藏的browser来管理cookie  session.<br/>Session是一种HTTP存储机制，目的是为无状态的HTTP提供的持久机制。所谓Session认证只是简单的把User信息存储到Session里，因为SID的不可预测性，暂且认为是安全的。这是一种认证手段。而Token，如果指的是OAuth  Token或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对App。<br/>其目的是让 某App有权利访问 某用户  的信息。这里的Token是唯一的。不可以转移到其它App上，也不可以转到其它 用户  上。转过来说Session。Session只提供一种简单的认证，即有此SID，即认为有此User的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方App。所以简单来说，如果你的用户数据可能需要和第三方共享，或者允许第三方调用API接口，用Token。如果永远只是自己的网站，自己的App，用什么就无所谓了。<br/>token就是令牌，比如你授权（登录）一个程序时，他就是个依据，判断你是否已经授权该软件；cookie就是写在客户端的一个txt文件，里面包括你登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名；session和cookie差不多，只是session是写在服务器端的文件，也需要在客户端写入cookie文件，但是文件里是你的浏览器编号.Session的状态是存储在服务器端，客户端只有session  id；而Token的状态是存储在客户端。<br/>作者：L惟愿时光善待青春年少<br/>链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/43c3003ac957\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/43c3003ac</span><span class=\"invisible\">957</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "session", 
                    "tagLink": "https://api.zhihu.com/topics/19601625"
                }, 
                {
                    "tag": "cookie (HTTP)", 
                    "tagLink": "https://api.zhihu.com/topics/19616699"
                }, 
                {
                    "tag": "token", 
                    "tagLink": "https://api.zhihu.com/topics/20142011"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60423235", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 14, 
            "title": "Linux 目录结构", 
            "content": "<p>对于每一个Linux学习者来说，了解Linux文件系统的目录结构，是学好Linux的至关重要的一步.，深入了解linux文件目录结构的标准和每个目录的详细功能，对于我们用好linux系统只管重要，下面我们就开始了解一下linux目录结构的相关知识。<br/>当在使用Linux的时候，如果您通过ls  –l / 就会发现，在/下包涵很多的目录，比如etc、usr、var、bin ... ...  等目录，而在这些目录中，我们进去看看，发现也有很多的目录或文件。文件系统在Linux下看上去就象树形结构，所以我们可以把文件系统的结构形象的称为  树形结构。<br/>文件系统的是用来组织和排列文件存取的，所以她是可见的，在Linux中，我们可以通过ls等工具来查看其结构，在Linux系统中，我们见到的都是树形结构；比如操作系统安装在一个文件系统中，他表现为由/  起始的树形结构。linux文件系统的最顶端是/，我们称/为Linux的root，也就是  Linux操作系统的文件系统。Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者。<br/>由于linux是开放源代码，各大公司和团体根据linux的核心代码做各自的操作，编程。这样就造成在根下的目录的不同。这样就造成个人不能使用他人的linux系统的PC。因为你根本不知道一些基本的配置，文件在哪里。。。这就造成了混乱。这就是FHS（Filesystem  Hierarchy Standard  ）机构诞生的原因。该机构是linux爱好者自发的组成的一个团体，主要是是对linux做一些基本的要求，不至于是操作者换一台主机就成了linux的‘文盲’。<br/>根据FHS(<a href=\"https://link.zhihu.com/?target=http%3A//www.pathname.com/fhs/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">pathname.com/fhs/</span><span class=\"invisible\"></span></a>)的官方文件指出，  他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下，  所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。  也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。  这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。<br/>事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动， 而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：<br/><b>可分享的(shareable)</b><br/><b>不可分享的(unshareable)</b><br/><b>不变的(static)</b><br/>/usr (软件放置处)<br/>/etc (配置文件)<br/>/opt (第三方协力软件)<br/>/boot (开机与核心档)<br/><b>可变动的(variable)</b><br/>/var/mail (使用者邮件信箱)<br/>/var/run (程序相关)<br/>/var/spool/news (新闻组)<br/>/var/lock (程序相关)<br/><b>四中类型:</b><br/><b>1. 可分享的：</b><br/>可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据， 是能够分享给网络上其他主机挂载用的目录；<br/><b>2. 不可分享的：</b><br/>自己机器上面运作的装置文件或者是与程序有关的socket文件等， 由于仅与自身机器有关，所以当然就不适合分享给其他主机了。<br/><b>3. 不变的：</b><br/>有些数据是不会经常变动的，跟随着distribution而不变动。 例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；<br/><b>4. 可变动的：</b><br/>经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。<br/>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：<br/><b>/ (root, 根目录)：与开机系统有关；</b><br/><b>/usr (unix software resource)：与软件安装/执行有关；</b><br/><b>/var (variable)：与系统运作过程有关。</b><br/><b>一. 根目录 (/) 的意义与内容：</b><br/>根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，  同时根目录也与开机/还原/系统修复等动作有关。 由于系统开机时需要特定的开机软件、核心文件、开机所需程序、  函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。  因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区，  因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。<br/>因此FHS标准建议：根目录(/)所在分区应该越小越好， 且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。 如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。<b>说白了，就是根目录和Windows的C盘一个样。</b><br/>根据以上原因，FHS认为根目录(/)下应该包含如下子目录：<br/><b>目录</b><br/><b>应放置档案内容</b><br/>/bin<br/>系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限),  chown, date, mv, mkdir, cp, bash等等常用的指令。<br/>/boot<br/>主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。<br/>/dev<br/>在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。  只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty ,  /dev/lp*, / dev/hd*, /dev/sd*等等<br/>/etc<br/>系统主要的设定档几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。  一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。  FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/,  /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。  另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话：  /etc/init.d/iptables start、/etc/init.d/ iptables stop<br/>/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。<br/>/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。<br/>/home<br/>这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： <br/>~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。<br/>/lib<br/>系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已  。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。  尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。<br/>/media<br/>media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。<br/>/mnt<br/>如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。<br/>/opt<br/>这个是给第三方协力软体放置的目录  。  什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。  另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。  不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。<br/>/root<br/>系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。<br/>/sbin<br/>Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system  binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init,  mkfs等等。<br/>/srv<br/>srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。<br/>/tmp<br/>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。<br/>事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：<br/><b>目录</b><br/><b>应放置文件内容</b><br/>/lost+found<br/>这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。  这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found<br/>/proc<br/>这个目录本身是一个虚拟文件系统(virtual  filesystem)喔。  他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如：  /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports,  /proc/net/*等等。呵呵，是虚拟内存吗[guest]？<br/>/sys<br/>这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。<br/>除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载，  其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，  就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：<br/>/etc：配置文件<br/>/bin：重要执行档<br/>/dev：所需要的装置文件<br/>/lib：执行档所需的函式库与核心所需的模块<br/>/sbin：重要的系统执行文件<br/>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 <br/><b>二. /usr 的意义与内容：</b><br/>依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。<br/>/usr不是user的缩写，其实usr是Unix  Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。  FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。<br/>因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows  系统的C:Windows + C:Program files这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。  一般来说，/usr的次目录建议有底下这些：<br/><b>目录</b><br/><b>应放置文件内容</b><br/>/usr/X11R6/ <br/>为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 <br/>/usr/bin/ <br/>绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) <br/>/usr/include/ <br/>c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 <br/>/usr/lib/ <br/>包含各应用软件的函式库、目标文件(object  file)，以及不被一般使用者惯用的执行档或脚本(script)。  某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作，  那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 <br/>/usr/local/ <br/>统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录，  这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版，  此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。  你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib...的次目录 <br/>/usr/sbin/ <br/>非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) <br/>/usr/share/ <br/>放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件<br/>/usr/share/doc：软件杂项的文件说明<br/>/usr/share/zoneinfo：与时区有关的时区文件<br/>/usr/src/ <br/>一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 <br/><b>三. /var 的意义与内容：</b><br/>如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。  因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件，  包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：<br/><b>目录</b><br/><b>应放置文件内容</b><br/>/var/cache/<br/>应用程序本身运作过程中会产生的一些暂存档<br/>/var/lib/<br/>程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去<br/>/var/lock/<br/>某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时，  就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。  举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？  如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁，  第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用<br/>/var/log/<br/>非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。<br/>/var/mail/<br/>放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。<br/>/var/run/<br/>某些程序或者是服务启动后，会将他们的PID放置在这个目录下<br/>/var/spool/<br/>这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。  这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中，  但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中，  等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。<br/>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。<br/><b>四. 目录树(directory tree)</b> <b>:</b><br/>在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：<br/>目录树的启始点为根目录 (/, root)；<br/>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。<br/>每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。<br/>如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-51e916cd73db13a6a7b1a1d85f63064e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"488\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb\" width=\"488\" data-original=\"https://pic3.zhimg.com/v2-51e916cd73db13a6a7b1a1d85f63064e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;488&#39; height=&#39;432&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"488\" data-rawheight=\"432\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"488\" data-original=\"https://pic3.zhimg.com/v2-51e916cd73db13a6a7b1a1d85f63064e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-51e916cd73db13a6a7b1a1d85f63064e_b.jpg\"/></figure><p><br/><b>五. 绝对路径与相对路径</b><br/>除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：<br/><b>绝对路径：</b><br/>由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；<br/><b>相对路径：</b><br/>相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 <a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/home/dmtsai/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/home/dmtsai</span><span class=\"invisible\">/</span><span class=\"ellipsis\"></span></a> 等等。反正开头不是 / 就属于相对路径的写法<br/>而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？<br/>cd /var/log (absolute)<br/>cd ../var/log (relative)<br/>因为你在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的，特别注意这两个特殊的目录：<br/>. ：代表当前的目录，也可以使用 ./ 来表示；<br/>.. ：代表上一层目录，也可以 ../ 来代表。<br/>这个 . 与 .. 目录概念是很重要的，你常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。<br/><b>实例1：如何先进入/var/spool/mail/目录，再进入到/var/spool/cron/目录内？</b><br/><b>命令</b>：<br/>cd /var/spool/mail<br/>cd ../cron<br/><b>说明：</b><br/>由于/var/spool/mail与/var/spool/cron是同样在/var/spool/目录中。如此就不需要在由根目录开始写起了。这个相对路径是非常有帮助的，尤其对于某些软件开发商来说。  一般来说，软件开发商会将数据放置到/usr/local/里面的各相对目录。 但如果用户想要安装到不同目录呢？就得要使用相对路径。<br/><b>实例2：网络文件常常提到类似./run.sh之类的数据，这个指令的意义为何？</b><br/><b>说明：</b><br/>由于指令的执行需要变量的支持，若你的执行文件放置在本目录，并且本目录并非正规的执行文件目录(/bin, /usr/bin等为正规)，此时要执行指令就得要严格指定该执行档。./代表本目录的意思，所以./run.sh代表执行本目录下， 名为run.sh的文件。<br/>转载地址：<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/peida/archive/2012/11/21/2780075.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/peida/archi</span><span class=\"invisible\">ve/2012/11/21/2780075.html</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "Linux 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19610306"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60247477", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "缓存的一些基本常识", 
            "content": "<h2>转载请注明出处哈:<a href=\"https://link.zhihu.com/?target=http%3A//carlosfu.iteye.com/blog/2269678\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">carlosfu.iteye.com/blog</span><span class=\"invisible\">/2269678</span><span class=\"ellipsis\"></span></a></h2><hr/><p><b>一、基本概念</b></p><p>1. Cache(缓存): 从cpu的一级和二级缓存、Internet的DNS、到浏览器缓存都可以看做是一种缓存。</p><p>维基百科: 写道</p><p>a store of things that will be required in the future, and can be retrieved rapidly.</p><p>（存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-29eedac743f0c2899c4a70abab2391a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-29eedac743f0c2899c4a70abab2391a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;285&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-29eedac743f0c2899c4a70abab2391a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-29eedac743f0c2899c4a70abab2391a6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2. Cache hit(缓存命中)（下图左）</p><p>When a data element is requested from cache and the elements exists for the given key.</p><p>3. Cahe miss(缓存未命中): 与Cache hit相反（下图右）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9923a3f5d7a74feb10897557dc6b0efe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9923a3f5d7a74feb10897557dc6b0efe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-9923a3f5d7a74feb10897557dc6b0efe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9923a3f5d7a74feb10897557dc6b0efe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4. 缓存算法：缓存容量超过预设，如何踢掉“无用”的数据。</p><p>例如：LRU（Least Recently Used） FIFO（First Input First Output）Least Frequently Used（LFU） 等等</p><p>5. System-of-Record(真实数据源)： 例如关系型数据库、其他持久性系统等等。</p><p>也有英文书叫做authority data（权威数据）</p><p>6. serialization-and-deserialization(序列化与反序列化)：可以参考：序列化与反序列化（美团工程师写的，非常棒的文章）</p><p>后面也有单独文章去分析。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c1d303591744430fa34b5187b173c4b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-c1d303591744430fa34b5187b173c4b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-c1d303591744430fa34b5187b173c4b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c1d303591744430fa34b5187b173c4b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>6. Scale Up (垂直扩容) 和 Scale out (水平扩容)</p><p>驴拉车，通常不是把一头驴养壮（有极限），而通常是一群驴去拉（当然每个个体也不能太差）。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8ec5b2e59b31f4ab4da87fbe148384c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic4.zhimg.com/v2-8ec5b2e59b31f4ab4da87fbe148384c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;437&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic4.zhimg.com/v2-8ec5b2e59b31f4ab4da87fbe148384c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8ec5b2e59b31f4ab4da87fbe148384c3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>服务器也是一样的道理，至少互联网是这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-414270133f1bd3e93ef9ec8714c9b325_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-414270133f1bd3e93ef9ec8714c9b325_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-414270133f1bd3e93ef9ec8714c9b325_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-414270133f1bd3e93ef9ec8714c9b325_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>7. Write-through 和 write-behind</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4d81c92e0cbdd40fd3b222ecfd6c23be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"207\" data-rawheight=\"300\" class=\"content_image\" width=\"207\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;207&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"207\" data-rawheight=\"300\" class=\"content_image lazy\" width=\"207\" data-actualsrc=\"https://pic3.zhimg.com/v2-4d81c92e0cbdd40fd3b222ecfd6c23be_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-28d71ef49c3ebfca34b4a5ba73915faf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"285\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;285&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"285\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-28d71ef49c3ebfca34b4a5ba73915faf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>8.阿姆而达定律：用于计算缓存加速比</p><p><b>二、缓存的种类或者类型</b></p><p>1. LocalCache(独立式): 例如Ehcache、BigMemory Go</p><p>(1) 缓存和应用在一个JVM中。</p><p>(2) 缓存间是不通信的，独立的。</p><p>(3) 弱一致性。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-43bb74b6d694ee47221f3afd0a58cfbf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-43bb74b6d694ee47221f3afd0a58cfbf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;366&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"366\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-43bb74b6d694ee47221f3afd0a58cfbf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-43bb74b6d694ee47221f3afd0a58cfbf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2. Standalone(单机):</p><p>(1) 缓存和应用是独立部署的。</p><p>(2) 缓存可以是单台。（例如memcache/redis单机等等）</p><p>(3) 强一致性</p><p>(4) 无高可用、无分布式。</p><p>(5) 跨进程、跨网络</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-77893b012f8828f0cee8387e5d0827e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-77893b012f8828f0cee8387e5d0827e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-77893b012f8828f0cee8387e5d0827e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-77893b012f8828f0cee8387e5d0827e3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>3. Distributed(分布式)：例如Redis-Cluster, memcache集群等等</p><p>(1) 缓存和应用是独立部署的。</p><p>(2) 多个实例。（例如memcache/redis等等）</p><p>(3) 强一致性或者最终一致性</p><p>(4) 支持Scale Out、高可用。</p><p>(5) 跨进程、跨网络</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d6c7c8f58c3e250d9e844be571da59e0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d6c7c8f58c3e250d9e844be571da59e0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;514&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"514\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-d6c7c8f58c3e250d9e844be571da59e0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d6c7c8f58c3e250d9e844be571da59e0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>4. Replicated(复制式): 缓存数据时同时存放在多个应用节点的，数据复制和失效的事件以同步或者异步的形式在各个集群节点间传播。（也是弱一致性）</p><p>这种用的不太多。</p><p><b>三、数据层访问速度：（作为开发人员要记住这些量级）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-683fe5f54330041fe2fb025bf1ba88cd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-683fe5f54330041fe2fb025bf1ba88cd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;373&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"373\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-683fe5f54330041fe2fb025bf1ba88cd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-683fe5f54330041fe2fb025bf1ba88cd_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19564998"
                }, 
                {
                    "tag": "浏览器缓存", 
                    "tagLink": "https://api.zhihu.com/topics/19682916"
                }, 
                {
                    "tag": "高速缓存", 
                    "tagLink": "https://api.zhihu.com/topics/20001795"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59830024", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 2, 
            "title": "面试之MySQL数据库部分基础知识", 
            "content": "<p>以下内容来自<b>《PHP程序员面试笔试宝典》</b>如需转载请注明出处。<br/>一、几款开源数据库的对比和介绍<br/><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8f36b5692254f2636ec9fa66917fdd0b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-8f36b5692254f2636ec9fa66917fdd0b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;495&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"495\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-8f36b5692254f2636ec9fa66917fdd0b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8f36b5692254f2636ec9fa66917fdd0b_b.jpg\"/></figure><p><br/><br/></p><hr/><p>二、SQL语言的功能有哪些？<br/>SQL是结构化查询语言（Structured  Query Language）的缩写，其功能包括数据查询、数据操纵、数据定义和数据控制四个部分。  数据查询是数据库中最常见的操作，通过select语句可以得到所需的信息。SQL语言的数据操纵语句（Data Manipulation  Language，DML）主要包括插入数据、修改数据以及删除数据三种语句。SQL语言使用数据定义语言（Data Definition  Language，DDL）实现数据定义功能，可对数据库用户、基本表、视图、索引进行定义与撤销。数据控制语句（Data Control  Language，DCL）用于对数据库进行统一的控制管理，保证数据在多用户共享的情况下能够安全。  基本的SQL语句有select、insert、update、delete、create、drop、grant、revoke等。其具体使用方式见下表。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ff719fd18e73e75a3f1ffd584e7289fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-ff719fd18e73e75a3f1ffd584e7289fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-ff719fd18e73e75a3f1ffd584e7289fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ff719fd18e73e75a3f1ffd584e7289fb_b.jpg\"/></figure><p><br/><br/></p><hr/><p>自己整理了一篇“<b>一二三四范式有何区别？</b>”的文章，关注公众号：“<b>琉忆编程库</b>”，回复：“<b>范式</b>”，我发给你。<br/></p><hr/><p>三、什么是事务？<br/>事务是数据库中一个单独的执行单元（Unit），它通常由高级数据库操作语言（例如SQL）或编程语言（例如C++、Java等）书写的用户程序的执行所引起。当在数据库中更改数据成功时，在事务中更改的数据便会提交，不再改变；否则，事务就取消或者回滚，更改无效。  例如网上购物，其交易过程至少包括以下几个步骤的操作： 1）更新客户所购商品的库存信息。 2）保存客户付款信息。  3）生成订单并且保存到数据库中。 4）更新用户相关信息，如购物数量等。  在正常的情况下，这些操作都将顺利进行，最终交易成功，与交易相关的所有数据库信息也成功地更新。但是，如果遇到突然掉电或是其他意外情况，导致这一系列过程中任何一个环节出了差错，例如在更新商品库存信息时发生异常、顾客银行账户余额不足等，都将导致整个交易过程失败。而一旦交易失败，数据库中所有信息都必须保持交易前的状态不变，例如最后一步更新用户信息时失败而导致交易失败，那么必须保证这笔失败的交易不影响数据库的状态，即原有的库存信息没有被更新、用户也没有付款、订单也没有生成。否则，数据库的信息将会不一致，或者出现更为严重的不可预测的后果，数据库事务正是用来保证这种情况下交易的平稳性和可预测性的技术。   事务必须满足四个属性，即原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability），即ACID四种属性。<br/><b>（1）原子性</b><br/>事务是一个不可分割的整体，为了保证事务的总体目标，事务必须具有原子性，即当数据修改时，要么全执行，要么全都不执行，即不允许事务部分地完成，避免了只执行这些操作的一部分而带来的错误。原子性要求事务必须被完整执行。<br/><b>（2）一致性</b><br/>一个事务执行之前和执行之后数据库数据必须保持一致性状态。数据库的一致性状态应该满足模式锁指定的约束，那么在完整执行该事务后数据库仍然处于一致性状态。为了维护所有数据的完整性，在关系型数据库中，所有的规则必须应用到事务的修改上。数据库的一致性状态由用户来负责，由并发控制机制实现，例如银行转账，转账前后两个账户金额之和应保持不变，由于并发操作带来的数据不一致性包括丢失数据修改、读“脏”数据、不可重复读和产生幽灵数据。<br/><b>（3）隔离性</b><br/>隔离性也被称为独立性，当两个或多个事务并发执行时，为了保证数据的安全性，将一个事物内部的操作与事务的操作隔离起来，不被其他正在进行的事务看到。例如对任何一对事务T1、T2，对T1而言，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行。数据库有四种类型的事务隔离级别：不提交的读、提交的读、可重复的读和串行化。因为隔离性使得每个事务的更新在它被提交之前，对其他事务都是不可见的，所以，实施隔离性是解决临时更新与消除级联回滚问题的一种方式。<br/><b>（4）持久性</b><br/>持久性也被称为永久性，事务完成以后，数据库管理系统（DBMS）保证它对数据库中的数据的修改是永久性的，当系统或介质发生故障时，该修改也永久保持。持久性一般通过数据库备份与恢复来保证。  严格来说，数据库事务属性（ACID）都是由数据库管理系统来进行保证的，在整个应用程序运行过程中应用无须去考虑数据库的ACID实现。  一般情况下，通过执行COMMIT或ROLLBACK语句来终止事务，当执行COMMIT语句时，自从事务启动以来对数据库所做的一切更改就成为永久性的了，即被写入磁盘，而当执行ROLLBACK语句时，自动事务启动以来对数据库所做的一切更改都会被撤销，并且数据库中内容返回到事务开始之前所处的状态。无论什么情况，在事务完成时，都能保证回到一致状态。<br/></p><hr/><p>四、什么是触发器？<br/>触发器是一种特殊类型的存储过程，它由事件触发，而不是程序调用或手工启动，当数据库有特殊的操作时，对这些操作由数据库中的事件来触发，自动完成这些SQL语句。使用触发器可以用来保证数据的有效性和完整性，完成比约束更复杂的数据约束。  具体而言，触发器与存储过程的区别见下表。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7f0a6e369e6bdf85b6ec28cc111e0764_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-7f0a6e369e6bdf85b6ec28cc111e0764_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;139&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"139\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-7f0a6e369e6bdf85b6ec28cc111e0764_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7f0a6e369e6bdf85b6ec28cc111e0764_b.jpg\"/></figure><p><br/><br/>根据SQL语句的不同，触发器可分为两类：DML触发器和DLL触发器。  DML触发器是当数据库服务器发生数据操作语言事件时执行的存储过程，有After和Instead  Of这两种触发器。After触发器被激活触发是在记录改变之后进行的一种触发器。Instead  Of触发器是在记录变更之前，去执行触发器本身所定义的操作，而不是执行原来SQL语句里的操作。DLL触发器是在响应数据定义语言事件时执行的存储过程。  具体而言，触发器的主要作用表现为如下几个方面： 1）增加安全性。  2）利用触发器记录所进行的修改以及相关信息，跟踪用户对数据库的操作，实现审计。  3）维护那些通过创建表时的声明约束不可能实现的复杂的完整性约束以及对数据库中特定事件进行监控与响应。  4）实现复杂的非标准的数据库相关完整性规则、同步实时地复制表中的数据。  5）触发器是自动的，它们在对表的数据做了任何修改之后就会被激活，例如可以自动计算数据值，如果数据的值达到了一定的要求，则进行特定的处理。以某企业财务管理为例，如果企业的资金链出现短缺，并且达到某种程度，则发送警告信息。   下面是一个触发器的例子，该触发器的功能是在每周末进行数据表更新，如果当前用户没有访问WEEKEND_UPDATE_OK表的权限，那么需要重新赋予权限。<br/>CREATE OR REPLACE TRIGGER update_on_weekends_check<br/>BEFORE UPDATE OF sal ON EMP<br/>FOR EACH ROW <br/>DECLARE<br/>my_count number(4);<br/>BEGINSELECT COUNT(u_name) <br/>FROM WEEKEND_UPDATE_OK INTO my_count <br/>WHERE u_name = user_name; <br/>IF my_count=0 THEN <br/>RAISE_APPLICATION_ERROR(20508, &#39;Update not allowed&#39;); <br/>END IF; <br/>END;<br/><br/></p><hr/><p>五、触发器分为事前触发和事后触发，二者有什么区别？语句级触发和行级触发有什么区别？<br/>事前触发发生在事件发生之前验证一些条件或进行一些准备工作；事后触发发生在事件发生之后，做收尾工作，保证事务的完整性。而事前触发可以获得之前和新的字段值。语句级触发器可以在语句执行之前或之后执行，而行级触发在触发器所影响的每一行触发一次。<br/>转载地址：<a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/Bces4Hbr_sLudTjR4P-UIw\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">mp.weixin.qq.com/s/Bces</span><span class=\"invisible\">4Hbr_sLudTjR4P-UIw</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "面试问题", 
                    "tagLink": "https://api.zhihu.com/topics/19591867"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59720083", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 10, 
            "title": "Nginx10m+高并发内核优化详解", 
            "content": "<p>何为高并发<br/></p><ul><li>默认的Linux内核参数考虑的是最通用场景，不符合用于支持高并发访问的Web服务器，所以需要修改Linux内核参数，这样可以让Nginx拥有更高的性能；</li><li>在优化内核时，可以做的事情很多，不过，我们通常会根据业务特点来进行调整，当Nginx作为静态web内容服务器、反向代理或者提供压缩服务器的服务器时，期内核参数的调整都是不同的，这里针对最通用的、使Nginx支持更多并发请求的TCP网络参数做简单的配置；</li><li>这些需要修改/etc/sysctl.conf来更改内核参数。</li><li>配置方法</li></ul><p><b>配置详析</b><br/>#表示单个进程较大可以打开的句柄数；<br/>fs.file-max = 999999<br/><br/>#参数设置为 1 ，表示允许将TIME_WAIT状态的socket重新用于新的TCP链接，这对于服务器来说意义重大，因为总有大量TIME_WAIT状态的链接存在；<br/>net.ipv4.tcp_tw_reuse = 1<br/><br/>#当keepalive启动时，TCP发送keepalive消息的频度；默认是2小时，将其设置为10分钟，可以更快的清理无效链接。<br/>ner.ipv4.tcp_keepalive_time = 600<br/><br/>#当服务器主动关闭链接时，socket保持在FIN_WAIT_2状态的较大时间<br/>net.ipv4.tcp_fin_timeout = 30<br/><br/>#这个参数表示操作系统允许TIME_WAIT套接字数量的较大值，如果超过这个数字，TIME_WAIT套接字将立刻被清除并打印警告信息。<br/>#该参数默认为180000，过多的TIME_WAIT套接字会使Web服务器变慢。<br/>net.ipv4.tcp_max_tw_buckets = 5000<br/><br/>#定义UDP和TCP链接的本地端口的取值范围。<br/>net.ipv4.ip_local_port_range = 1024 65000<br/><br/>#定义了TCP接受缓存的最小值、默认值、较大值。<br/>net.ipv4.tcp_rmem = 10240 87380 12582912<br/><br/>#定义TCP发送缓存的最小值、默认值、较大值。<br/>net.ipv4.tcp_wmem = 10240 87380 12582912<br/><br/>#当网卡接收数据包的速度大于内核处理速度时，会有一个列队保存这些数据包。这个参数表示该列队的较大值。<br/>net.core.netdev_max_backlog = 8096<br/><br/>#表示内核套接字接受缓存区默认大小。<br/>net.core.rmem_default = 6291456<br/><br/>#表示内核套接字发送缓存区默认大小。<br/>net.core.wmem_default = 6291456<br/><br/>#表示内核套接字接受缓存区较大大小。<br/>net.core.rmem_max = 12582912<br/><br/>#表示内核套接字发送缓存区较大大小。<br/>net.core.wmem_max = 12582912<br/><br/><b>注意：以上的四条配置，需要根据业务逻辑和实际的硬件成本来综合考虑；</b><br/>#与性能无关。用于解决TCP的SYN***。<br/>net.ipv4.tcp_syncookies = 1<br/><br/>#这个参数表示TCP三次握手建立阶段接受SYN请求列队的较大长度，默认1024，将其设置的大一些可以使出现Nginx繁忙来不及accept新连接的情况时，Linux不至于丢失客户端发起的链接请求。<br/>net.ipv4.tcp_max_syn_backlog = 8192<br/><br/>#这个参数用于设置启用timewait快速回收。<br/>net.ipv4.tcp_tw_recycle = 1<br/><br/>选项默认值是128，这个参数用于调节系统同时发起的TCP连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此需要结合高并发请求数来调节此值。<br/>net.core.somaxconn=262114<br/><br/>#选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立链接将立即被复位并输出警告信息。这个限制指示为了防止简单的DOS***，不用过分依靠这个限制甚至认为的减小这个值，更多的情况是增加这个值。<br/>net.ipv4.tcp_max_orphans=262114<br/><br/>为了方便使用，下方可以直接复制<br/>net.ipv4.tcp_tw_reuse = 1<br/>fs.file-max = 999999<br/>net.ipv4.tcp_fin_timeout = 30<br/>ner.ipv4.tcp_keepalive_time = 600<br/><br/>来自51CTO博客作者喵来个鱼的原创作品，如需转载，请注明出处，否则将追究法律责任<br/>转载地址：<a href=\"https://link.zhihu.com/?target=https%3A//blog.51cto.com/m51cto/2363354\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.51cto.com/m51cto/2</span><span class=\"invisible\">363354</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Nginx", 
                    "tagLink": "https://api.zhihu.com/topics/19574050"
                }, 
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }, 
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "你确定这样就可以做到C10M？", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "请问单机下nginx可以承受多大的连接数，，这个有限制吗？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "刘柱", 
                            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
                            "content": "<p>这个首先和你的服务器配置有关，以及你的nginx的配置也有关，当然限制是肯定有的，还需要具体业务区分析</p>", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "嗯，，，我们之前出现过ng负载两台机器抗不过来，，然后直接在dns指向到两台机器上，，会这样吗？", 
                            "likes": 0, 
                            "replyToAuthor": "刘柱"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58668128", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 56, 
            "title": "是时候深入了解Linux的系统结构了", 
            "content": "<p>什么是 Linux ？<br/>如果你以前从未接触过Linux,可能就不清楚为什么会有这么多不同的Linux发行版。在查看Linux软件包时,你肯定被发行版、LiveCD和GNU之类的术语搞晕过。初次进入Linux世界会让人觉得不那么得心应手。在开始学习命令和脚本之前,本章将为你稍稍揭开Linux系统的神秘面纱。首先,Linux可划分为以下四部分:<br/></p><ol><li>↪ Linux内核</li><li>↪ GNU工具链</li><li>↪ GUI桌面环境</li><li>↪ 应用软件 ...</li></ol><p>|--------------------------|<br/>| APPS | 应用软件<br/>|--------------------------|<br/>| | GUI桌面环境<br/>| GUI |-------------|<br/>| | GNU | GNU工具链<br/>|--------------------------|<br/>| kernel | Linux内核<br/>|--------------------------|<br/>| hardware | 计算机硬件<br/>----------------------------<br/><br/>1. Linux 内核<br/>Linux系统的核心是内核。内核控制着计算机系统上的所有硬件和软件,在必要时分配硬件,并根据需要执行软件。<br/></p><ol><li>系统内存管理</li><li>应用程序管理</li><li>硬件设备管理</li><li>文件系统管理</li></ol><p>1. 系统内存管理<br/>操作系统内核的主要功能之一就是内存管理。内核不仅管理服务器上的可用物理内存,还可以创建和管理虚拟内存(即实际并不存在的内存)<br/></p><ul><li>内核通过硬盘上的存储空间来实现虚拟内存,这块区域称为交换空间(swap space)。内核不断地在交换空间和实际的物理内存之间反复交换虚拟内存中的内容。这使得系统以为它拥有比物理内存更多的可用内存</li><li>Linux系统内存映射</li></ul><p>|---------| -----------<br/>| | | 物理内存 |<br/>| | /----------<br/>| | ---------<br/>| 虚拟内存 | —— | 内核 |<br/>| | ---------<br/>| | ---------- <br/>| | | 交换空间 |<br/>|---------| -----------<br/><br/>2. 应用程序管理<br/>Linux操作系统将运行中的程序称为进程。进程可以在前台运行,将输出显示在屏幕上,也可以在后台运行,隐藏到幕后。内核控制着Linux系统如何管理运行在系统上的所有进程。<br/></p><ul><li>内核创建了第一个进程(称为init进程)来启动系统上所有其他进程。当内核启动时,它会将init进程加载到虚拟内存中。内核在启动任何其他进程时,都会在虚拟内存中给新进程分配一块专有区域来存储该进程用到的数据和代码。</li><li>Linux操作系统有5个启动运行级</li><li>运行级为1时,只启动基本的系统进程以及一个控制台终端进程。我们称之为单用户模式。单用户模式通常用来在系统有问题时进行紧急的文件系统维护。显然,在这种模式下,仅有一个人(通常是系统管理员)能登录到系统上操作数据。</li><li>标准的启动运行级是3。在这个运行级上,大多数应用软件,比如网络支持程序,都会启动。</li><li>Linux中常见的运行级是5。在这个运行级上系统会启动图形化的X Window系统,允许用户通过图形化桌面窗口登录系统。</li></ul><p>3. 硬件设备管理<br/>内核的另一职责是管理硬件设备。任何Linux系统需要与之通信的设备,都需要在内核代码中加入其驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人,允许内核与设备之间交换数据。在Linux内核中有两种方法用于插入设备驱动代码:<br/></p><ul><li>编译进内核的设备驱动代码</li><li>可插入内核的设备驱动模块</li></ul><p>以前,插入设备驱动代码的唯一途径是重新编译内核。每次给系统添加新设备,都要重新编译一遍内核代码。随着Linux内核支持的硬件设备越来越多,这个过程变得越来越低效。不过好在Linux开发人员设计出了一种更好的将驱动代码插入运行中的内核的方法。<br/>开发人员提出了内核模块的概念。它允许将驱动代码插入到运行中的内核而无需重新编译内核。同时,当设备不再使用时也可将内核模块从内核中移走。这种方式极大地简化和扩展了硬件设备在Linux上的使用。<br/></p><ul><li>Linux系统将硬件设备当成特殊的文件,称为设备文件。设备文件有3种分类:</li><li>字符型设备文件</li><li>字符型设备文件是指处理数据时每次只能处理一个字符的设备。大多数类型的调制解调器和终端都是作为字符型设备文件创建的。</li><li>块设备文件</li><li>块设备文件是指处理数据时每次能处理大块数据的设备,比如硬盘。</li><li>网络设备文件</li><li>网络设备文件是指采用数据包发送和接收数据的设备,包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用常见的网络编程协议同自身通信。</li><li>Linux为系统上的每个设备都创建一种称为节点的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。</li></ul><p>4. 文件系统管理<br/>不同于其他一些操作系统,Linux内核支持通过不同类型的文件系统从硬盘中读写数据。除<br/> 了自有的诸多文件系统外,Linux还支持从其他操作系统(比如Microsoft Windows)采用的文件<br/> 系统中读写数据。内核必须在编译时就加入对所有可能用到的文件系统的支持。表1-1列出了<br/> Linux系统用来读写数据的标准文件系统。<br/>ext | Linux扩展文件系统,最早的Linux文件系统<br/>ext2 | 第二扩展文件系统,在ext的基础上提供了更多的功能<br/>ext3 | 第三扩展文件系统,支持日志功能<br/>ext4 | 第四扩展文件系统,支持高级日志功能<br/>hpfs | OS/2高性能文件系统<br/>jfs | IBM日志文件系统<br/>iso9660 | ISO 9660文件系统(CD-ROM)<br/>minix | MINIX文件系统<br/>msdos | 微软的FAT16<br/>ncp | Netware文件系统<br/>nfs | 网络文件系统<br/>ntfs | 支持Microsoft NT文件系统<br/>proc | 访问系统信息<br/>ReiserFS | 高级Linux文件系统,能提供更好的性能和硬盘恢复功能<br/>smb | 支持网络访问的Samba SMB文件系统<br/>sysv | 较早期的Unix文件系统<br/>ufs | BSD文件系统<br/>umsdos | 建立在msdos上的类Unix文件系统<br/>vfat | Windows 95文件系统(FAT32)<br/>XFS | 高性能64位日志文件系统<br/><br/></p><ul><li>Linux服务器所访问的所有硬盘都必须格式化成表1-1所列文件系统类型中的一种。</li><li>Linux内核采用虚拟文件系统(Virtual File System,VFS)作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统都被挂载和使用时,VFS将信息都缓存在内存中。</li></ul><p>2. GNU工具链<br/>GNU组织(GNU是GNU’s Not Unix的缩写)开发了一套完整的Unix工具,但没有可以运行它们的内核系统。这些工具是在名为开源软件(open source software,OSS)的软件理念下开发的。<br/>开源软件理念允许程序员开发软件,并将其免费发布。任何人都可以使用、修改该软件,或将该软件集成进自己的系统,无需支付任何授权费用。将Linus的Linux内核和GNU操作系统工具整合起来,就产生了一款完整的、功能丰富的免费操作系统。<br/></p><ul><li>尽管通常将Linux内核和GNU工具的结合体称为Linux, 但你也会在互联网上看到一些Linux纯粹主义者将其称为GNU/Linux系统,藉此向GNU组织所作的贡献致意</li></ul><p>核心GNU工具<br/>GNU coreutils软件包由三部分构成:<br/></p><ul><li>用以处理文件的工具</li><li>用以操作文本的工具</li><li>用以管理进程的工具</li></ul><p>Shell<br/>GNU/Linux  shell是一种特殊的交互式工具。它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。  shell的核心是命令行提示符。命令行提示符是shell负责交互的部分。它允许你输入文本命令,然后解释命令,并在内核中执行。<br/></p><ul><li>我们在命令行中输入的命令都是GNU工具链提供，而非Linux内核</li><li>所有Linux发行版默认的shell都是bash shell。bash shell由GNU项目开发,被当作标准Unix shell——Bourne shell(以创建者的名字命名)的替代品。</li><li>Linux中常见的几种不同 shell</li></ul><p>bash | 由GNU项目开发,被当作标准shell<br/>ash | 运行在内存受限环境中简单的轻量级shell,但与bash shell完全兼容<br/>korn | 与Bourne shell兼容的编程shell,但支持如关联数组和浮点运算等一些高级的编程特性<br/>tcsh | 将C语言中的一些元素引入到shell脚本中的shell<br/>zsh | 结合了bash、tcsh和korn的特性,同时提供高级编程特性、共享历史文件和主题化提示符的高级shell<br/><br/>3. Linux 桌面环境<br/>在Linux的早期(20世纪90年代初期),能用的只有一个简单的Linux操作系统文本界面。这个文本界面允许系统管理员运行程序,控制程序的执行,以及在系统中移动文件。<br/>随着Microsoft Windows的普及,电脑用户已经不再满足于对着老式的文本界面工作了。这推动了OSS社区的更多开发活动,Linux图形化桌面环境应运而生。<br/></p><ul><li>X Window系统</li></ul><p>有两个基本要素决定了视频环境:显卡和显示器。要在电脑上显示绚丽的画面,Linux软件就得知道如何与这两者互通。X Window系统是图形显示的核心部分。<br/>X Window系统，是直接和PC上的显卡及显示器打交道的底层程序。它控制着Linux程序如何在电脑上显示出漂亮的窗口和图形<br/></p><ul><li>现在流行的桌面环境有 Unity GNOME Cinnamon Xfce 等</li></ul><hr/><p>Linux 发行版<br/>已经了解了构成完整Linux系统所需要的4个关键部件,那你可能在考虑要怎样才能把它们组成一个Linux系统。幸运的是,已经有人为你做好这些了<br/>核心 Linux 发行版<br/>核心Linux发行版含有内核、一个或多个图形化桌面环境以及预编译好的几乎所有能见到的Linux应用。它提供了一站式的完整Linux安装<br/>Slackware | 最早的Linux发行版中的一员,在Linux极客中比较流行<br/>Redhat | 主要用于Internet服务器的商业发行版<br/>Gentoo | 为高级Linux用户设计的发行版,仅包含Linux源代码<br/>openSUSE | 用于商用和家用的发行版<br/>Debian | 在Linux专家和商用Linux产品中流行的发行版<br/><br/>系统目录<br/>|—— bin # 二进制目录,存放用户级的GNU工具(bash命令)<br/>|—— boot # 启动目录,存放用于系统引导时使用的各种文件<br/>|—— dev # 设备目录,存放硬件设备,创建设备节点<br/>|—— etc # 系统配置文件目录,存放系统管理和配置文件<br/>|—— home # 普通用户的主目录<br/>|—— lib # 库目录,存放系统和应用程序的动态链接库<br/>|—— lost+found # 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件<br/>|—— media # 媒体目录,可移动媒体设备的常用挂载点<br/>|—— mnt # 挂载目录,另一个可移动媒体设备的常用挂载点<br/>|—— opt # 可选目录,常用于存放第三方软件包和数据文件<br/>|—— proc # 进程目录,存放现有硬件及当前进程的相关信息，是系统内存的映射。可直接访问这个目录来获取系统信息<br/>|—— root # 超级用户的主目录<br/>|—— run # 运行目录,存放系统运作时的运行时数据<br/>|—— sbin # 系统二进制目录,存放许多GNU管理员级工具<br/>|—— srv # 服务目录,存放本地服务的相关文件<br/>|—— sys # 系统目录,存放系统硬件信息的相关文件<br/>|—— tmp # 临时目录,可以在该目录中创建和删除临时工作文件,重启后清空<br/>|—— usr # 用户二进制目录,大量用户级的GNU工具和数据文件都存储在这里<br/>| |—— bin # 包含系统安装的可执行程序。通常，这个目录会包含许多程序<br/>| |—— games # <br/>| |—— include # 写程序需要使用到的一些头文件<br/>| |—— lib # 包含由/usr/bin 目录中的程序所用的共享库<br/>| |—— local # 是非系统发行版自带，却打算让系统使用的程序的安装目录。 通常，由源码编译的程序会安装在/usr/local/bin 目录下<br/>| |—— sbin # 包含许多系统管理程序<br/>| |—— share # 存放帮助文档和共享文件<br/>| |—— src # <br/>|—— var # 可变目录,用以存放经常变化的文件,比如日志文件<br/><br/>文件权限-权限符<br/></p><ul><li>命令行执行: ls -l</li></ul><p>drwxr-xr-x<br/># 文件类型 属主权限 成员权限 其他用户权限<br/> d rwx r-x r-x<br/>|—— 文件类型<br/>| |—— - # 文件<br/>| |—— d # 文件夹<br/>| |—— l # 链接<br/>| |—— c # 字符型设备<br/>| |—— b # 块设备<br/>| |—— n # 网络设备<br/>|<br/>|—— r # 可读权限<br/>|—— w # 可写权限<br/>|—— x # 可执行权限<br/><br/>文件系统<br/></p><ul><li>ext</li></ul><p>Linux操作系统中引入的最早的文件系统叫作扩展文件系统 (extended filesystem,简记为ext)。它为Linux提供了一个基本的类Unix文件系统:使用虚拟目录来操作硬件设备,在物理设备上按定长的块来存储数据。<br/>ext文件系统采用名为索引节点的系统来存放虚拟目录中所存储文件的信息。索引节点系统在每个物理设备中创建一个单独的表(称为索引节点表)来存储这些文件的信息。存储在虚拟目录中的每一个文件在索引节点表中都有一个条目。ext文件系统名称中的extended部分来自其跟踪的每个文件的额外数据<br/>- 文件名<br/>- 文件大小<br/>- 文件的属主<br/>- 文件的属组<br/>- 文件的访问权限<br/>- 指向存有文件数据的每个硬盘块的指针<br/><br/>Linux通过唯一的数值(称作索引节点号)来引用索引节点表中的每个索引节点,这个值是创建文件时由文件系统分配的。文件系统通过索引节点号而不是文件全名及路径来标识文件。<br/></p><ul><li>ext2</li></ul><p>最早的ext文件系统有不少限制,比如文件大小不得超过2 GB。在Linux出现后不久,ext文件系统就升级到了第二代扩展文件系统,叫作ext2<br/>日志文件系统<br/>日志文件系统为Linux系统增加了一层安全性。它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法,而是先将文件的更改写入到临时文件(称作日志,journal)中<br/>在数据成功写到存储设备和索引节点表之后,再删除对应的日志条目。如果系统在数据被写入存储设备之前崩溃或断电了,日志文件系统下次会读取日志文件并处理上次留下的未写入的数据<br/></p><ul><li>ext3</li></ul><p>2001年,ext3文件系统被引入Linux内核中,直到最近都是几乎所有Linux发行版默认的文件系统。它采用和ext2文件系统相同的索引节点表结构,但给每个存储设备增加了一个日志文件,以将准备写入存储设备的数据先记入日志。<br/></p><ul><li>ext4</li></ul><p>ext4文件系统在 2008 年受到Linux内核官方支持,现在已是大多数流行的Linux发行版采用的默认文件系统<br/>除了支持数据压缩和加密,ext4文件系统还支持一个称作区段(extent)的特性。区段在存储设备上按块分配空间,但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块,它可以在索引节点表中节省一些空间。<br/>ext4还引入了块预分配技术(block   preallocation)。如果你想在存储设备上给一个你知道要变大的文件预留空间,ext4文件系统可以为文件分配所有需要用到的块,而不仅仅是那些现在已经用到的块。ext4文件系统用  0 填满预留的数据块,不会将它们分配给其他文件<br/>Linux 中的 LVM<br/>Linux LVM是由Heinz Mauelshagen开发的,于1998年发布到了Linux社区。它允许你在Linux上用简单的命令行命令管理一个完整的逻辑卷管理环境<br/></p><ul><li>LVM1</li></ul><p>最初的LVM包于1998年发布,只能用于Linux内核2.4版本。它仅提供了基本的逻<br/></p><ul><li>LVM2</li></ul><p>LVM的更新版本,可用于Linux内核2.6版本。它在标准的LVM1功能外提供了额外的功能。<br/></p><ul><li>快照</li></ul><p>最初的Linux   LVM允许你在逻辑卷在线的状态下将其复制到另一个设备。这个功能叫作快照。在备份由于高可靠性需求而无法锁定的重要数据时,快照功能非常给力。传统的备份方法在将文件复制到备份媒体上时通常要将文件锁定。快照允许你在复制的同时,保证运行关键任务的Web服务器或数据库服务器继续工作。遗憾的是,LVM1只允许你创建只读快照。一旦创建了快照,就不能再写入东西了<br/>LVM2允许你创建在线逻辑卷的可读写快照。有了可读写的快照,就可以删除原先的逻辑卷,然后将快照作为替代挂载上。这个功能对快速故障转移或涉及修改数据的程序试验(如果失败,需要恢复修改过的数据)非常有用。<br/></p><ul><li>条带化</li></ul><p>LVM2提供的另一个引人注目的功能是条带化(striping)。有了条带化,可跨多个物理硬盘创建逻辑卷。当Linux   LVM将文件写入逻辑卷时,文件中的数据块会被分散到多个硬盘上。每个后继数据块会被写到下一个硬盘上。条带化有助于提高硬盘的性能,因为Linux可以将一个文件的多个数据块同时写入多个硬盘,而无需等待单个硬盘移动读写磁头到多个不同位置。这个改进同样适用于读取顺序访问的文件,因为LVM可同时从多个硬盘读取数据。<br/></p><ul><li>镜像</li></ul><p>通过LVM安装文件系统并不意味着文件系统就不会再出问题。和物理分区一样,LVM逻辑卷也容易受到断电和磁盘故障的影响。一旦文件系统损坏,就有可能再也无法恢复。<br/>LVM快照功能提供了一些安慰,你可以随时创建逻辑卷的备份副本,但对有些环境来说可能还不够。对于涉及大量数据变动的系统,比如数据库服务器,自上次快照之后可能要存储成百上千条记录。<br/>这个问题的一个解决办法就是LVM镜像。镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时,LVM会将原始逻辑卷同步到镜像副本中。根据原始逻辑卷的大小,这可能需要一些时间才能完成。<br/>一旦原始同步完成,LVM会为文件系统的每次写操作执行两次写入——一次写入到主逻辑卷,一次写入到镜像副本。可以想到,这个过程会降低系统的写入性能。就算原始逻辑卷因为某些原因损坏了,你手头也已经有了一个完整的最新副本!<br/>小结<br/>在Linux上使用存储设备需要懂一点文件系统的知识。当工作在Linux系统下时,懂得如何在命令行下创建和处理文件系统能帮上你的忙。Linux系统和Windows的不同之处在于前者支持大量不同的存储文件和目录的方法。每个文件系统方法都有不同的特性,使其适用于不同的场景<br/>fdisk   命令用来对存储设备进行分区,以便安装文件系统。在分区存储设备时,必须定义在上面使用什么类型的文件系统。划分完存储设备分区后,你可以为该分区选用一种文件系统。流行的Linux文件系统包括ext3和ext4。两者都提供了日志文件系统功能,降低它们在Linux系统崩溃时遇到错误或问题的几率<br/>在存储设备分区上直接创建文件系统的一个限制因素是,如果硬盘空间用完了,你无法轻易地改变文件系统的大小。但Linux支持逻辑卷管理,这是一种跨多个存储设备创建虚拟分区的方法。这种方法允许你轻松地扩展一个已有文件系统,而不用完全重建。Linux  LVM包提供了跨多个存储设备创建逻辑卷的命令行命令。<br/>如果你还不太了解Linux的命令行命令，欢迎阅读我的下一篇<br/></p><ul><li>你可能还在寻找一款 Linux发行版？</li><li>如果你还不知道如何选择的话</li></ul><p>作者：NET颜同学<br/>链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/2b9f4a6ed1df\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/p/2b9f4a6ed</span><span class=\"invisible\">1df</span><span class=\"ellipsis\"></span></a></p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }
            ], 
            "comments": [
                {
                    "userName": "俞阳", 
                    "userLink": "https://www.zhihu.com/people/a88e3c42618bf6e3e40776d5e9407d13", 
                    "content": "点赞收藏退出一气呵成", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "金大鹏", 
                    "userLink": "https://www.zhihu.com/people/0aa92ea0d45cab47ce980731b203c203", 
                    "content": "<p>不明觉厉</p><a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-ba306425d0a7aee2c7260381f1bf7b97.gif\" data-width=\"\" data-height=\"\">[欢呼]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-db92f653a2ec17ea3ff309d6d56e8507.gif\" data-sticker-id=\"980770591112015872\"> [吃瓜]</a>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "大木亦木", 
                    "userLink": "https://www.zhihu.com/people/8cfade0c87cc4bfcc0bae009c3ada6fb", 
                    "content": "<p>纠正一下哦，GNU的理念是「自由软件」，他们并不提倡「开源」这个说法</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "塘边野草", 
                    "userLink": "https://www.zhihu.com/people/4a98d7a21181aba6a8d77776af0f483d", 
                    "content": "最常用的桌面竟然没KDE[捂脸]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "和尚用飘柔", 
                    "userLink": "https://www.zhihu.com/people/648f047463d176733e65b38b24a8d2ca", 
                    "content": "补充了我的Linux知识，谢谢", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58447588", 
            "userName": "凡猫学院软件测试", 
            "userLink": "https://www.zhihu.com/people/ce9edfb49f5519c6e859296f669f1c7f", 
            "upvote": 0, 
            "title": "测试小白之功能转自动化如何转？接口测试怎么测？大扫盲", 
            "content": "<p>一.什么是接口？</p><p>接口测试主要用于外部系统与系统之间以及内部各个子系统之间的交互点，定义特定的交互点，然后通过这些交互点来，通过一些特殊的规则也就是协议，来进行数据之间的交互。</p><p>二.接口都有哪些类型？</p><p>接口一般分为两种：</p><p>1.程序内部的接口</p><p>2.系统对外的接口</p><p>系统对外的接口：比如你要从别的网站或服务器上获取资源或信息，别人肯定不会把数据库共享给你，他只能给你提供一个他们写好的方法来获取数据，你引用他提供的接口就能使用他写好的方法，从而达到数据共享的目的。</p><p>程序内部的接口：方法与方法之间，模块与模块之间的交互，程序内部抛出的接口，比如bbs系统，有登录模块、发帖模块等等，那你要发帖就必须先登录，那么这两个模块就得有交互，它就会抛出一个接口，供内部系统进行调用。</p><p>接口的分类：</p><p>1.webservice接口 </p><p>2.http api接口</p><p>webService接口是走soap协议通过http传输，请求报文和返回报文都是xml格式的，我们在测试的时候都用通过工具才能进行调用，测试。</p><p>http api接口是走http协议，通过路径来区分调用的方法，请求报文都是key-value形式的，返回报文一般都是json串，有get和post等方法，这也是最常用的两种请求方式。</p><p>json是一种通用的数据类型，所有的语言都认识它。（json的本质是字符串，他与其他语言无关，只是可以经过稍稍加工可以转换成其他语言的数据类型，比如可以转换成Python中的字典，key-value的形式，可以转换成JavaScript中的原生对象，可以转换成java中的类对象等。）</p><p>三.接口的本质及其工作原理是什么？</p><p>接口你可以简单的理解他就是URL，工作原理就会说URL通过get或者post请求像服务器发送一些东西，然后得到一些相应的返回</p><p>值，本质就是数据的传输与接收。</p><p>四.什么是接口测试？</p><p>接口测试是测试系统组件间接口的一种测试。接口测试主要用于检测外部系统与系统之间以及内部各个子系统之间的交互点。测试的重点是要检查数据的交换，传递和控制管理过程，以及系统间的相互逻辑依赖关系等。</p><p>-百度百科</p><p>简答的说就是通过URL像服务器或者其他模块等，传输我们想传输的数据，然后看看他们返回的是不是我们预期想要的。</p><p>五.问什么要做接口测试？</p><p>①.越底层发现bug，它的修复成本是越低的。</p><p>②.前端随便变，接口测好了，后端不用变，前后端是两拨人开发的。</p><p>③.检查系统的安全性、稳定性，前端传参不可信，比如京东购物，前端价格不可能传入-1元，但是通过接口可以传入-1元。</p><p>④.如今的系统复杂度不断上升，传统的测试方法成本急剧增加且测试效率大幅下降，接口测试可以提供这种情况下的解决方案。</p><p>⑤. 接口测试相对容易实现自动化持续集成，且相对UI自动化也比较稳定，可以减少人工回归测试人力成本与时间，缩短测试周期，支持后端快速发版需求。接口持续集成是为什么能低成本高收益的根源。</p><p>⑥.   现在很多系统前后端架构是分离的。</p><p>从安全层面来说：</p><p>(1)、只依赖前端进行限制已经完全不能满足系统的安全要求（绕过前面实在太容易）， 需要后端同样进行控制，在这种情况下就需要从接口层面进行验证。</p><p>(2)、前后端传输、日志打印等信息是否加密传输也是需要验证的，特别是涉及到用户的隐私信息，如身份证，银行卡等。</p><p>六.怎样做接口测试？</p><p>由于我们项目前后端调用主要是基于http协议的接口，所以测试接口时主要是通过工具或代码模拟http请求的发送与接收。工具有很多如：postman、jmeter、soupUI、java+httpclient、robotframework+httplibrary等。</p><p>-也可以用 接口自动化来实现，就是用代码实现，框架和UI自动化差不多，发送请求用断言来判断。</p><p>七.接口测测试点是什么？</p><p>目的：测试接口的正确性和稳定性；</p><p>原理：模拟客户端向服务器发送请求报文，服务器接收请求报文后对相应的报文做处理并向客户端返回应答，客户端接收应答的过程；</p><p>重点：检查数据的交换，传递和控制管理过程，还包括处理的次数；</p><p>核心：持续集成是接口测试的核心；</p><p>优点：为高复杂性的平台带来高效的缺陷监测和质量监督能力，平台越复杂，系统越庞大，接口测试的效果越明显（提高测试效率，提升用户体验，降低研发成本）；</p><p>用例设计重点：通常情况下主要测试最外层的两类接口:数据进入系统接口（调用外部系统的参数为本系统使用）和数据流出系统接口（验证系统处理后的数据是否正常）；</p><p>PS：设计用例时还需要注意外部接口提供给使用这些接口的外部用户什么功能，外部</p><p>用户真正需要什么功能；</p><p>1、基本功能测试：</p><p>由于是针对基本业务功能进行测试，所以这部分是两种测试重合度最高的一块，开发同学通常所指的也主要是这部分的内容。</p><p>2、边界分析测试：</p><p>在基本功能测试的基础上考虑输入输出的边界条件，这部分内容也会有重复的部分（比如业务规则的边界）。</p><p>但是，前端的输入输出很多时候都是提供固守的值让用户选择（如下拉框），在这种情况下测试的边界范围就非常有限，但接口测试就不存在这方面的限制，相对来说接口可以覆盖的范围更广，同样的，接口出现问题的概率也更高。</p><p>3、性能测试：</p><p>这个比较容易区分，虽然都需要做性能测试，但关注点确大不相同。App端性能主要关注与手机相关的特性，如手机cpu、内存、流量、fps等。而接口性能主要关注接口响应时间、并发、服务端资源的使用情况等。两种测试时的策略和方法都有很大区别，所以这部分内容是需要分开单独进行测试的，理论上来说这也是不同的部分。</p><p>综论：</p><p>1、接口测试和app测试的活动有部分重复的内容，主要集中在业务功能测试方面。除此之外，针对各自特性的测试都不一样，需要分别进行有针对性的测试，才能确保整个产品的质量。</p><p>2、接口测试可以关注于服务器逻辑验证，而UI测试可以关注于页面展示逻辑及界面前端与服务器集成验证</p><p>3、接口测试持续集成：</p><p>对接口测试而言，持续集成自动化是核心内容，通过持自动化的手段我们才能做到低成本高收益。目前我们已经实现了接口自动化，主要应用于回归阶段，后续还需要加强自动化的程度。</p><p>包括但不限于下面的内容：</p><p>a) 流程方面：在回归阶段加强接口异常场景的覆盖度，并逐步向系统测试，冒烟测试阶段延伸，最终达到全流程自动化。</p><p>b) 结果展示：更加丰富的结果展示、趋势分析，质量统计和分析等</p><p>c) 问题定位：报错信息、日志更精准，方便问题复现与定位。</p><p>d) 结果校验：加强自动化校验能力，如数据库信息校验。</p><p>e) 代码覆盖率：不断尝试由目前的黑盒向白盒下探，提高代码覆盖率。</p><p>f) 性能需求：完善性能测试体系，通过自动化的手段监控接口性能指标是否正常。</p><p>4、接口测试质量评估标准：</p><p>a) 业务功能覆盖是否完整</p><p>b) 业务规则覆盖是否完整</p><p>c) 参数验证是否达到要求（边界、业务规则）</p><p>d) 接口异常场景覆盖是否完整</p><p>e) 接口覆盖率是否达到要求</p><p>f)  代码覆盖率是否达到要求</p><p>g) 性能指标是否满足要求</p><p>h) 安全指标是否满足要求</p><p>八.接口测试都要掌握哪些知识？</p><p>①了解系统及内部各个组件之间的业务逻辑交互；</p><p>②了解接口的I/O（input/output：输入输出）；</p><p>③了解协议的基本内容，包括：通信原理、三次握手、常用的协议类型、报文构成、数据传输方式、常见的状态码、URL构成等；</p><p>④常用的接口测试工具，比如：jmeter、loadrunner、postman、soapUI等；</p><p>⑤数据库基础操作命令（检查数据入库、提取测试数据等）；</p><p>⑥常见的字符类型，比如：char、varchar、text、int、float、datatime、string等；</p><p>如何学这些技能？</p><p>①系统间业务交互逻辑：通过需求文档、流程图、思维导图、沟通等很多渠道和方式；</p><p>②协议：推荐《图解http》这本书，内容生动，相对算是入门级的书籍，其他的还有《图解tcp、IP》等；</p><p>③接口测试工具：百度这些工具，然后你会发现，好多的教学博客、相关问题解决方案、以及一些基于工具的书籍，当然，选择合适的书很重要；</p><p>④数据库操作命令：学习网站（W3C、菜鸟教程）、教学博客，以及一些数据库相关书籍，入门级推荐：《mysql必知必会》、《oracle PL/SQL必知必会》等</p><p>⑤字符类型：还是百度，有句话这么说：内事不决问百度，外事不决问Google。。。</p><p>如何获取接口相关信息？</p><p>一般的企业，都会由开发或者对应的技术负责人员编写接口文档，里面会注明接口相关的地址、参数类型、方法、输入、输出等信息，如果没有，想办法获取。</p><p>接口文档八要素：</p><p>封面：封面最好是本公司规定的封面，有logo，内容标题，版本号，公司名称，文档产生日期；</p><p>修订历史：表格形式较好些，包括：版本、修订说明、修订日期、修订人、审核时间审核人等；</p><p>接口信息：接口调用方式，常用的GET/POST方式，接口地址；</p><p>功能描述：简洁清晰的描述接口功能，比如：接口获取的信息不包括哪些；</p><p>接口参数说明：每个参数都要和实际中调用的一样，包括大小写；参数的含义言简意赅的说明，格式，是string 还是int 还是long等格式；</p><p>说明部分，说明参数值是需要哪里提供，并详细说明参数怎么生成的，例如时间戳，是哪个时间段的，参数是否必填，一些参数是必须要有的，有些是可选参数等；</p><p>返回值说明：</p><p>①最好有一个模板返回值，并说明每个返回参数的意义；</p><p>②提供一个真实的调用接口，真实的返回值；</p><p>调用限制，安全方面：</p><p>加密方式，或者自己公司一个特殊的加密过程，只要双方采用一致的加密算法就可以调用接口，保证了接口调用的安全性，比如常见的md5；</p><p>文档维护：文档在维护的时候，如有修改一定要写上修改日期，修改人，对大的修改要有版本号变更；</p><p>九.其他相关知识</p><p>get请求，post请求的区别：</p><p>1、GET使用URL或Cookie传参。而POST将数据放在BODY中。</p><p>2、GET的URL会有长度上的限制，则POST的数据则可以非常大。</p><p>3、POST比GET安全，因为数据在地址栏上不可见。</p><p>4、一般get请求用来获取数据，post请求用来发送数据。</p><p>其实上面这几点，只有最后一点说的是比较靠谱的，第一点post请求也可以把数据放到url里面，get请求其实也没长度限制，post请求看起来参数是隐式的，稍微安全那么一些些，但是那只是对于小白用户来说的，就算post请求，你通过抓包也是可以抓到参数的。（唯一区别就是这一点，上面3点区别都是不准确的）</p><p>http状态码：</p><p>1、200 2开头的都表示这个请求发送成功，最常见的就是200，就代表这个请求是ok的，服务器也返回了。</p><p>2、300 3开头的代表重定向，最常见的是302，把这个请求重定向到别的地方了。</p><p>3、400 400代表客户端发送的请求有语法错误，401代表访问的页面没有授权，403表示没有权限访问这个页面，404代表没有这个页面。</p><p>4、500 5开头的代表服务器有异常，500代表服务器内部异常，504代表服务器端超时，没返回结果。</p><p>webservice接口怎么测试：</p><p>它不需要你在拼报文了，会给一个webservice的地址，或者wsdl文件，直接在soapui导入，就可以看到这个webservice里面的所有接口，也有报文，直接填入参数调用，看返回结果就可以了。</p><p>cookie与session的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用cookie。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>将登陆信息等重要信息存放为session</p><p>其他信息如果需要保留，可以放在cookie中</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-57941be72cb40529d8bcd0cdea0cf0f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1005\" data-rawheight=\"1164\" class=\"origin_image zh-lightbox-thumb\" width=\"1005\" data-original=\"https://pic1.zhimg.com/v2-57941be72cb40529d8bcd0cdea0cf0f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1005&#39; height=&#39;1164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1005\" data-rawheight=\"1164\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1005\" data-original=\"https://pic1.zhimg.com/v2-57941be72cb40529d8bcd0cdea0cf0f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-57941be72cb40529d8bcd0cdea0cf0f0_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "接口设计", 
                    "tagLink": "https://api.zhihu.com/topics/19791836"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58210837", 
            "userName": "大力出奇迹", 
            "userLink": "https://www.zhihu.com/people/dae5c8724bc26e184877469ed0882db2", 
            "upvote": 4, 
            "title": "Linux历史&操作系统入门知识", 
            "content": "<p>这是小白文，接受指导，不接受批评。</p><p>裸机是指没有操作系统的机器；那操作系统究竟是啥玩意啊？为啥非得要一个操作系统呢？</p><p>操作系统是人与机器进行交互的一个中介；上古机器语言效率是很低的，所以需要有对底层硬件接口的封装使得使用者不需要去写机器语言，当然也要有上层应用对这些底层封装的调用，操作系统的作用就是这样承上启下。</p><p>1. <b>Linux的起源</b></p><p>1969年，贝尔实验室的ken tompson为了方便玩星际旅行，用汇编写出了unix原型</p><p>1970年，ken tompson用B语言重写了一次</p><p>1972年，同是星际旅行爱好者的Denis Ritche为了解决B语言可移植性差的问题，换一台机器就要重新写一次系统，决定开发C语言来写UNIX</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0742ac2e441018e11afee4ec89d48e7a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"539\" data-original=\"https://pic3.zhimg.com/v2-0742ac2e441018e11afee4ec89d48e7a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;539&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"539\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"539\" data-original=\"https://pic3.zhimg.com/v2-0742ac2e441018e11afee4ec89d48e7a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0742ac2e441018e11afee4ec89d48e7a_b.jpg\"/></figure><p>1973年，基于C语言的Unix内核诞生，这也是正式意义上的具有可移植性的通用操作系统</p><p>1979年，不知怎么的，公司决定终止UNIX的开源</p><p>1987年，一个叫Andrew tanebaun的教授为了方便教学，自主开发了minix</p><p>1991年，为了方便从学校服务器获取相关邮件与资料，Linus基于minix，采用GNU BASH做开发，GCC编译，写出了Linux内核；后经由世界各地开发者的我完善，形成了成熟的LINUX内核</p><p>再后来，为了提高开发效率，诞生了基于开源Linux内核的各式各样的Linux发行版；内核都是一样的，只是预装的基础应用程序不一样而已。</p><p><b>2. Linux操作系统的应用场景</b></p><p>大型网络服务器。Windows server还是很贵的；而且Windows是黑箱，运维都得依赖微软的技术支持。</p><p>嵌入式。不可能一个小设备买一个Windows正版授权吧？而且一个小设备也用不上装个window 10吧？</p><p>移动端。安卓是在Linux基础上衍生出来的。</p><p>PC服务器。轻便高效且易于管理的开发环境；同时有大量开发者的支持；有些开发软件只能在Linux系统上用或是取得最佳性能。</p><p><b>3. 操作系统的作用</b></p><p>操作系统主要有2个作用，一个是直接进行硬件控制，二是提供封装好的硬件调用API。我猜测CPU的资源调度应该跟操作系统是独立的，不然换CPU不就要修改操作系统了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-94f6d25073cc168c80a0d42d3e8757d6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"615\" data-original=\"https://pic3.zhimg.com/v2-94f6d25073cc168c80a0d42d3e8757d6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;615&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"615\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"615\" data-original=\"https://pic3.zhimg.com/v2-94f6d25073cc168c80a0d42d3e8757d6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-94f6d25073cc168c80a0d42d3e8757d6_b.jpg\"/></figure><p>用户输入命令，应用层收到命令，通过操作系统控制硬件完成IO, 内存运算，声卡信号解析等，并将结果返还给用户完成交互。</p><p><b>4. 服务器工作流程</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-131d52f1117373fa9c51bfb8b5b44754_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"892\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"892\" data-original=\"https://pic1.zhimg.com/v2-131d52f1117373fa9c51bfb8b5b44754_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;892&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"892\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"892\" data-original=\"https://pic1.zhimg.com/v2-131d52f1117373fa9c51bfb8b5b44754_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-131d52f1117373fa9c51bfb8b5b44754_b.png\"/></figure><p><b>5. Linux的文件系统结构</b></p><p>在Windows里，由于一般都是单用户场景，因此一般而言都有多个驱动器（也就是C盘D盘E盘等），这样用户就可以分门别类放自己的文件。</p><p>而Linux由于一开始就是针对多用户共用硬件与OS而开发的，因此其文件系统与Windows有所不同。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1d618aca479574a2f9cd4795952e2686_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"810\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb\" width=\"810\" data-original=\"https://pic3.zhimg.com/v2-1d618aca479574a2f9cd4795952e2686_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;810&#39; height=&#39;479&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"810\" data-rawheight=\"479\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"810\" data-original=\"https://pic3.zhimg.com/v2-1d618aca479574a2f9cd4795952e2686_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1d618aca479574a2f9cd4795952e2686_b.jpg\"/></figure><p>登录进去Ubuntu桌面的时候，我们就已经在用户层根目录了;也就是/home/user1</p><p>如果要进桌面，是不是cd destop就可以了？就会变成/home/user1/destop</p><p>但如果要操作系统层文件，例如usr，就必须先：sudo so/sudo root之类的从用户层根目录进入系统层根目录 <b>/ </b>，不然没有权限进行改动。</p><p><b>所以，进入root以后千万不要随便rm全部文件！操作系统内核都被删掉了，电脑能不坏吗？</b></p><p><b>6.待回答疑问</b></p><ul><li>为什么机器语言无法移植？为什么C语言可移植性好？又为什么更高级的语言移植性不如C语言？</li><li>ken tompson玩星际旅行跟开发一个多用户的操作系统有什么关系？</li><li>Linux内核是怎么冷启动的？</li></ul><p>后续有答案了再回来继续！</p>", 
            "topic": [
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "Linux 内核", 
                    "tagLink": "https://api.zhihu.com/topics/19614193"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/55513683", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "怎么玩Flask？自己看，我给你总结了一下", 
            "content": "<p>flask...知道吧</p><p>就是那个当下很流行的那个Python那个语言的一个框架</p><p>玩flask首先你要有一个虚拟环境，也就是你的web运行环境了，当然了我们这次是介绍怎么在windows下面怎么玩，下一节再告诉大家怎么玩Linux</p><p>（1）首先去官网下载python这个知道吧</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.python.org/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">python.org/</span><span class=\"invisible\"></span></a></p><p>（2）点击下一步下一步按照会吧，当然=你要把第二个勾选框选择上面（演示使用，图片来源网上，版本有点低，自行安装高版本），这样呢就能在windows下面直接cmd输入python就能玩了，如果没有选择的话请自行将执行程序放入你的系统path里面</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c61eabe511bafb5bc1b8fd9885737ba2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb\" width=\"428\" data-original=\"https://pic3.zhimg.com/v2-c61eabe511bafb5bc1b8fd9885737ba2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;428&#39; height=&#39;325&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"428\" data-rawheight=\"325\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"428\" data-original=\"https://pic3.zhimg.com/v2-c61eabe511bafb5bc1b8fd9885737ba2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c61eabe511bafb5bc1b8fd9885737ba2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（3）执行下面这个就是安装成功了</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ffca45f168a43e8f80d6b0df2391255e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"40\" class=\"content_image\" width=\"287\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;287&#39; height=&#39;40&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"287\" data-rawheight=\"40\" class=\"content_image lazy\" width=\"287\" data-actualsrc=\"https://pic3.zhimg.com/v2-ffca45f168a43e8f80d6b0df2391255e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（4）接下来我们安装一个虚拟环境，执行</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2b3be24a08ede4a9539bb50903da0ce8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"20\" class=\"content_image\" width=\"407\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;407&#39; height=&#39;20&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"20\" class=\"content_image lazy\" width=\"407\" data-actualsrc=\"https://pic1.zhimg.com/v2-2b3be24a08ede4a9539bb50903da0ce8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>（5）然后在执行pipenv install</p><p>（6）安装flask pipenv install flask</p><p>以上自行在你的计算机上面创建目录进行安装</p><p>接下来就是启动你的环境了</p><p>pipenv shell</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e6cbd168e4ff6a11e9095403a2758510_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-e6cbd168e4ff6a11e9095403a2758510_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;479&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"479\" data-rawheight=\"82\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-e6cbd168e4ff6a11e9095403a2758510_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e6cbd168e4ff6a11e9095403a2758510_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>ok，以上我们已经基本安装完我们的运行环境了，接下来我们就开始编辑我们的代码了</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-24126e6f1136c312af7ae5c5ceccf31c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"911\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb\" width=\"911\" data-original=\"https://pic1.zhimg.com/v2-24126e6f1136c312af7ae5c5ceccf31c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;911&#39; height=&#39;243&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"911\" data-rawheight=\"243\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"911\" data-original=\"https://pic1.zhimg.com/v2-24126e6f1136c312af7ae5c5ceccf31c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-24126e6f1136c312af7ae5c5ceccf31c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们的测试运行代码，就是这么简单，当然我们要注意的是，当你使用PyCharm编辑代码的时候我们要选择我们安装好的那个运行环境</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3cdbf68dd720db061a1aede80b262eb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"304\" data-rawheight=\"282\" class=\"content_image\" width=\"304\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;304&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"304\" data-rawheight=\"282\" class=\"content_image lazy\" width=\"304\" data-actualsrc=\"https://pic2.zhimg.com/v2-3cdbf68dd720db061a1aede80b262eb5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-58f9da9ce7282f95c63b1406d8334d35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-58f9da9ce7282f95c63b1406d8334d35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-58f9da9ce7282f95c63b1406d8334d35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-58f9da9ce7282f95c63b1406d8334d35_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>ok，以上就是一个小入门，接下来就是开始完整flask了，请持续关注，后面不断更新，和我一起玩转flask吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-84e7a1581713af0751fb6a5c03fac4b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"97\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"97\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-84e7a1581713af0751fb6a5c03fac4b2_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "Flask", 
                    "tagLink": "https://api.zhihu.com/topics/19590215"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/53142037", 
            "userName": "皮蛋瘦肉粥", 
            "userLink": "https://www.zhihu.com/people/167d89f54c99f1c01ab20cb7edceed87", 
            "upvote": 0, 
            "title": "php array数组笔记", 
            "content": "<p>在php中数组共有三种：</p><p>   1、 索引数组 带有数字索引的数字</p><p>   2、关联数组 带有指定的键的数组</p><p>   3、多维数组 包含一个或多个数组的数组</p><p class=\"ztext-empty-paragraph\"><br/></p><p>创建一个空数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$new = array();</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>索引数组：</p><div class=\"highlight\"><pre><code class=\"language-php\">array(value1,value2,value3)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>关联数组：</p><div class=\"highlight\"><pre><code class=\"language-php\">array(key=&gt;value,key=&gt;value)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>从php5.4起我们可以用 方括号来代替array创建 数组</p><div class=\"highlight\"><pre><code class=\"language-php\">//索引数组\n$suzhu = [1,2,3,4]\n\n//关联数组\n$suzhu = [&#34;name&#34;=&gt;&#34;jack&#34;,&#34;age&#34;=&gt;10]</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">//声明字符集\nheader(&#39;content-type:text/html;charset=utf-8&#39;);\n\n//创建关联数组\n$suzhu = [&#39;name&#39;=&gt;&#39;xiaoming&#39;,&#39;age&#39;=&gt;20];\n\n//拼接字符串 打印数组内容\necho &#39;我的名字叫&#39;.$suzhu[&#39;name&#39;].&#39;,我今年刚满&#39;.$suzhu[&#39;age&#39;];</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>通过循环打印数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$cars = [1,2,3,4,5,6];\nfor ($i=0;$i<span class=\"p\">&lt;</span><span class=\"nt\">count</span><span class=\"err\">($</span><span class=\"na\">cars</span><span class=\"err\">);$</span><span class=\"na\">i</span><span class=\"err\">++){</span>\n    <span class=\"na\">echo</span> <span class=\"err\">$</span><span class=\"na\">cars</span><span class=\"err\">[$</span><span class=\"na\">i</span><span class=\"err\">];</span>\n    <span class=\"na\">echo</span> <span class=\"err\">&#39;&lt;</span><span class=\"na\">br</span><span class=\"p\">&gt;</span>&#39;;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>遍历打印关联数组的所有值：</p><div class=\"highlight\"><pre><code class=\"language-php\">//关联数组\n$cars = [&#39;name&#39;=&gt;&#39;xiaoming&#39;,&#39;age&#39;=&gt;20,&#39;id&#39;=&gt;1];\n\n// foreach 循环数组\nforeach ($cars as $a=&gt;$b_value){\n    echo &#39;Key=&#39;.$a.&#39;,value:&#39;.$b_value;\n    echo &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>创建多维数组：</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n$suzu = [[&#39;mercedes&#39;,100,200],[&#39;toyota&#39;,60,120],[&#39;honda&#39;,66,66]];\n\necho $suzu[0][0].&#39;历史有&#39;.$suzu[0][1].&#39;年&#39;;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>将数组键名格式化为大写或者小写</p><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：只对关系数组有用</p><p>array_change_key_case($array,0 or 1)</p><p>0代表小写 1 代表大写</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$list = [&#39;aa&#39;=&gt;1,&#39;bb&#39;=&gt;2,&#39;cc&#39;=&gt;3];\n\nprint_r(array_change_key_case($list,1));</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>使用array_change_key_case() 处理数组时 如果有两个键名一样的数组那么最后一个将会覆盖第一个</p><p>我的数组中 创建了两个键名w为&#39;bb&#39; 的键值对 然后我使用array_change_key_case()对它进行大小写转换</p><div class=\"highlight\"><pre><code class=\"language-php\">$list = [&#39;aa&#39;=&gt;1,&#39;bb&#39;=&gt;2,&#39;cc&#39;=&gt;3,&#39;bb&#39;=&gt;4];\n\nprint_r(array_change_key_case($list,1));</code></pre></div><p>结果</p><p>Array ( [AA] =&gt; 1 [BB] =&gt; 4 [CC] =&gt; 3 )</p><p>可以看到最后一个 名叫bb的数组值为4 覆盖了值为2的数组</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_chunk()</p><p>把数组分割成新的数组块,原有的数组不变，所以如果你想分割后进行操作的话就把他放在赋值给其他变量</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$list = [&#39;aa&#39;=&gt;1,&#39;bb&#39;=&gt;2,&#39;cc&#39;=&gt;3,&#39;bb&#39;=&gt;4,&#39;dd&#39;=&gt;5];\n\n$list2 = array_chunk($list,2);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>array_chunk($array,2,true) 括号内一共有三个参数 第一个是你需要切割的数组 第二个是你要把它分成多少个 第三个是是否保留原始数组的键名，关联数组的情况下 一般我们都要填true 不然你的原始键名就没了</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-php\">$list = [&#39;aa&#39;=&gt;1,&#39;bb&#39;=&gt;2,&#39;cc&#39;=&gt;3,&#39;bb&#39;=&gt;4,&#39;dd&#39;=&gt;5];\n\n$list2 = array_chunk($list,2,true);\n\nvar_dump($list2);\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>结果</p><p>array(2) { [0]=&gt; array(2) { [&#34;aa&#34;]=&gt; int(1) [&#34;bb&#34;]=&gt; int(4) } [1]=&gt; array(2) { [&#34;cc&#34;]=&gt; int(3) [&#34;dd&#34;]=&gt; int(5) } }</p><p class=\"ztext-empty-paragraph\"><br/></p><p>同样和 array_change_key_case() 一样 同名数组 取最后一个 所以这里bb里面的2就没了</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_combine()</p><p>将两个数组合并成一个数组，第一个数组为键名，第二个数组为键值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$b = [1,2,3];\n\n$c = array_combine($a,$b);\nprint_r($c);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>注意： 两个数组的元素数量必须相同，如果不同 则函数会返回false。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_count_values() </p><p>对数组的值进行计数</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;a&#39;];\n\nprint_r(array_count_values($a));</code></pre></div><p>结果：</p><p>Array ( [a] =&gt; 2 [b] =&gt; 1 [c] =&gt; 1 )</p><p>这个函数会返回一个数组，数组的键名是原来统计的数组元素，数值是在原来数组中出现的次数</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_diff()</p><p>比较两个数组的值 并返回差集</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;d&#39;=&gt;1,&#39;e&#39;=&gt;2,&#39;f&#39;=&gt;3];\n\n$result = array_diff($a,$b);\nprint_r($result);</code></pre></div><p>结果</p><p>Array ( [g] =&gt; 4 )  array_diff() 只比较键值</p><p>查询差集 结果是查看第一个数组 和第二个数组对比 返回第一个数组不同的值</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_diff_assoc()</p><p>比较键名和键值的差集 </p><p>查询差集 结果是查看第一个数组 和第二个数组对比 返回第一个数组不同的值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_diff_assoc($a,$b);\nprint_r($result);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;e&#39;=&gt;1,&#39;g&#39;=&gt;2,&#39;a&#39;=&gt;3];\n\n$result = array_diff_assoc($a,$b);\nprint_r($result);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;f&#39;=&gt;3];\n$c = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_diff_assoc($a,$b);\nprint_r($result);\n\n//结果\nArray ( [c] =&gt; 3 [g] =&gt; 4 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_diff_key()</p><p>对比键名返回差集</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;a&#39;=&gt;123,&#39;b&#39;=&gt;211,&#39;c&#39;=&gt;388];\n\n$result = array_diff_key($a,$b);\nprint_r($result);\n\n// 结果\nArray ( [g] =&gt; 4 ) \n</code></pre></div><p>对比键名不管键值返回差集</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;g&#39;=&gt;4];\n$b = [&#39;a&#39;=&gt;123,&#39;c&#39;=&gt;211,&#39;b&#39;=&gt;388];\n$c = [&#39;c&#39;=&gt;1,&#39;d&#39;=&gt;5,&#39;f&#39;=&gt;9];\n\n$result = array_diff_key($a,$b,$c);\nprint_r($result);\n\n//结果\nArray ( [b] =&gt; 2 [g] =&gt; 4 )</code></pre></div><p>注意：$a 先和 $b 对比 如果相同就匹配成功 然后在跟 $c 匹配 如果$a 和$b匹配成功后就不会再和$c 匹配</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_diff_uassoc()</p><p>比较两个数组的键名和键值（使用用户自定义函数比较键名），并返回差集</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b)?1:-1;\n}\n\n$a1 = [&#39;a&#39;=&gt;&#39;1&#39;,&#39;b&#39;=&gt;&#39;2&#39;,&#39;c&#39;=&gt;&#39;3&#39;];\n$a2 = [&#39;d&#39;=&gt;&#39;1&#39;,&#39;b&#39;=&gt;&#39;2&#39;,&#39;e&#39;=&gt;&#39;blue&#39;];\n\n$result  = array_diff_uassoc($a1,$a2,&#39;myfunction&#39;);\nprint_r($result);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>比较三个数组的键名和键值 使用用户自定义函数来比较键名 并返回差集</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b)?1:-1;\n}\n\n$a1 = [&#39;a&#39;=&gt;&#39;1&#39;,&#39;b&#39;=&gt;&#39;2&#39;,&#39;c&#39;=&gt;&#39;3&#39;];\n$a2 = [&#39;d&#39;=&gt;&#39;1&#39;,&#39;b&#39;=&gt;&#39;2&#39;,&#39;e&#39;=&gt;&#39;blue&#39;];\n$a3 = [&#39;e&#39;=&gt;&#39;1&#39;,&#39;a&#39;=&gt;&#39;1&#39;,&#39;d&#39;=&gt;&#39;5&#39;];\n\n$result = array_diff_uassoc($a1,$a2,$a3,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果\nArray ( [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_diff_ukey() </p><p>比较数组，返回差集，只比较键名 使用用户自定的键名比较函数</p><p>array_diff_uassoc() &amp; array_diff_ukey() 个人感觉两个方法一样。。。 可能我比较菜 没用处区别。。。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_fill() </p><p>用值填充数组</p><p>array_fill(索引值，创建个数，值)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = array_fill(0,4,&#39;ddd&#39;);\nprint_r($a1);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_fill_keys()</p><p>给定键值填充键名</p><p>array_fill_keys(键名数组，键值)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$keys = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\n$suzhu = array_fill_keys($keys,1);\nprint_r($suzhu);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 1 [c] =&gt; 1 [d] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_filter()</p><p>array_filter() 是用来用回调函数过滤数组中的元素，就是将数组中的每个键值传递给回调函数，回调函数返回true 则把数组中的当前键值返回给函数的返回数组，数组键名保持不变</p><p>array_filter(数组，&#39;函数名&#39;);</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function guolv($var){\n    return ($var &gt; 3);\n}\n\n$var = [0,1,2,3,4,5];\n$suzhu = array_filter($var,&#39;guolv&#39;);\n\nprint_r($suzhu); \n//结果\nArray ( [4] =&gt; 4 [5] =&gt; 5 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_flip()</p><p>交换关系数组中的键与值，键变成值，值变成键</p><p>array_flip(数组)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$b = array_flip($a);\nprint_r($b);</code></pre></div><p>注意：array_flip() 函数返回一个反转后的数组，如果同一值出现了多次 则最后一个键名将会作为他的值， 所有其他键名都会丢失，如果原数组中的值的数据类型不是字符串或整数，函数将会报错</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_intersect()</p><p>比较数组返回交集 （只比较键值）</p><p>$array_intersect(array1,array2....)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;3,&#39;c&#39;=&gt;3];\n$a3 = array_intersect($a1,$a2);\nprint_r($a3);\n\n//结果\nArray ( [a] =&gt; 1 [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;3,&#39;c&#39;=&gt;3];\n$a3 = [&#39;a&#39;=&gt;8,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;6];\n$a4 = array_intersect($a1,$a2,$a3);\nprint_r($a4);\n\n//结果\nArray ( )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_intersect_assoc()</p><p>比较两个数组的键名和键值 并返回交集</p><p>array_intersect_assoc(array1,array2);</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;3,&#39;c&#39;=&gt;5];\n\n$suzhu = array_intersect_assoc($a1,$a2);\nprint_r($suzhu);\n\n//返回结果 只有数组中的 $a1[&#39;a&#39;]\nArray ( [a] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;3,&#39;c&#39;=&gt;5];\n$a3 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;d&#39;=&gt;3];\n$suzhu = array_intersect_assoc($a1,$a2,$a3);\nprint_r($suzhu);\n\n//结果\nArray ( [a] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_intersect_key()</p><p>比较两个数组 键名 返回交集</p><p>array<i>intersect</i>key(array,array2)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;8,&#39;b&#39;=&gt;3,&#39;c&#39;=&gt;5];\n$suzhu = array_intersect_key($a1,$a2);\nprint_r($suzhu);\n\n//结果 由于三个键名都一样 所以都会返回\nArray ( [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;8,&#39;d&#39;=&gt;3,&#39;c&#39;=&gt;5];\n$a3 = [&#39;r&#39;=&gt;88,&#39;k&#39;=&gt;99,&#39;b&#39;=&gt;22];\n$suzhu = array_intersect_key($a1,$a2,$a3);\nprint_r($suzhu);\n\n//结果为空 因为第三个数组键名与前两个数组都不符合\nArray ( )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_intersect_uassoc()</p><p>比较数组的键名和键值 并返回交集 使用用户自己定义的函数来进行比较</p><p>array_intersect_uassoc(array,array2,&#39;自定义函数名&#39;)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n   if($a===$b){\n     return 0;\n  }\n  return ($a&gt;$b) ? 1 : -1;\n;}\n\n$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$b = [&#39;d&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;e&#39;=&gt;3];\n\n$result = array_intersect_uassoc($a,$b,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果\nArray ( [b] =&gt; 2 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>该函数比较两个 或者更多个数组的键名和键值 并返回交集数组 该数组包括了所有在被比较的数组 中 同时也在其他数组中的键名和键值</p><p>array_intersect_uassoc() 函数使用用户自定义的回调函数计算数组的交集，用回调函数比较索引。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b) ? 1:-1;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;d&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;e&#39;=&gt;3];\n$a3 = [&#39;c&#39;=&gt;5,&#39;b&#39;=&gt;1,&#39;e&#39;=&gt;5];\n$result = array_intersect_uassoc($a1,$a2,$a3,&#39;myfunction&#39;);\n\nprint_r($result);\n\n// 结果返回是一个空数组</code></pre></div><p>因为a1的任何一个关系数组都没有和a2,a3的数组同时匹配成功 所以返回空</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_intersect_ukey()</p><p>使用自定义回调函数 比较两个数组的键名  并返回交集</p><p>array_intersect_ukey(array,array2...,&#39;自定义函数名称&#39;);</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b) ? 1 : -1;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;5,&#39;e&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_intersect_ukey($a1,$a2,&#39;myfunction&#39;);\nprint_r($result); \n\n//结果\nArray ( [a] =&gt; 1 [c] =&gt; 3 )</code></pre></div><p>可以看到只要键名相同就会返回键值不同没有关系</p><p>array_intersect_ukey()比较多个数组</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0 ;\n    }\n    return ($a&gt;$b)? 1 : -1;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;5,&#39;e&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a3 = [&#39;a&#39;=&gt;7,&#39;e&#39;=&gt;5,&#39;d&#39;=&gt;9];\n\n$result = array_intersect_ukey($a1,$a2,$a3,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 )</code></pre></div><p>这里$a1数组中 的键名 只有 a和其他数组一样 为交集 所以只返回了 一个数组集合</p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_key_exists()</p><p>检查数组中 是否存在指定的键名</p><p>array_key_exists(&#39;键名&#39;,数组)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n\n$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2];\n\nif(array_key_exists(&#39;a&#39;,$a)){\n    echo &#39;键值存在&#39;;\n}else{\n    echo &#39;键值不存在&#39;;\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_key_exists() 查询索引数组，可以用数组索引号0，1</p><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n\n$a = [&#39;a&#39;,&#39;b&#39;];\n\nif(array_key_exists(0,$a)){\n    echo &#39;键值存在&#39;;\n}else{\n    echo &#39;键值不存在&#39;;\n}\n\n//结果 是存在 表示如果是索引数组我们可以填索引号 代表键名 0== &#39;a&#39;;\n键值存在</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_keys()</p><p>返回包含数组中所有的键名 组成一个新的数组</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子1</p><p>array_keys(&#39;数组&#39;)</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n\n$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_keys($a);\n\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>array_keys(&#39;数组&#39;,value)</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n\n$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_keys($a,3);\n\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; c )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>array_keys(&#39;数组&#39;,value,strict) strict 为 bool值 true false 默认为也为false，为false时不区分字符串和数字 整形类型</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,&#34;1&#34;];\n\n$result = array_keys($a,&#39;1&#39;,false);\n\nprint_r($result);\n\n//结果 不管时字符串 还是 整形类型只要是 1 就会返回 strict 为fasle 时 1 == &#39;1&#39; 返回结果也是两个\nArray ( [0] =&gt; 0 [1] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>array_keys(&#39;数组&#39;,值)  为true</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,&#34;1&#34;];\n\n$result = array_keys($a,&#39;1&#39;,true);\n\nprint_r($result);\n\n//结果 就会区分整型和字符串的区别 1 != &#39;1&#39;; 所以结果只有一个\nArray ( [0] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_map()</p><p>函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数后带来来的新数组</p><p>注意用自定义数组</p><p>array_map(&#39;自定义方法名称&#39;,数组)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v){\n    return ($v+1);\n}\n\n$a = [1,2,3,4,5];\n\n$result = array_map(&#39;myfunction&#39;,$a);\nprint_r($result);\n\n//\nArray ( [0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4 [3] =&gt; 5 [4] =&gt; 6 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>我们用arrat_map操作值的特性来批量的改变他的值</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v){\n    if ($v ==1){\n        return 9;\n    }\n    return $v;\n}\n\n$a = [1,2,3,4,5,1,1,6,1,8];\n\n$result = array_map(&#39;myfunction&#39;,$a);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 9 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 [5] =&gt; 9 [6] =&gt; 9 [7] =&gt; 6 [8] =&gt; 9 [9] =&gt; 8 )</code></pre></div><p>例子3</p><p>array_map(&#39;自定义函数&#39;,array,array2) 对比两个数组的值</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v1,$v2){\n    if($v1===$v2){\n        return $v1;\n    }\n    return 0;\n}\n\n$a = [1,2,3,4,5,1,1,6,1,8];\n$a2 = [3,2,3,4,5,2,8,6,8,8];\n\n$result = array_map(&#39;myfunction&#39;,$a,$a2);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 0 [1] =&gt; 2 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 5 [5] =&gt; 0 [6] =&gt; 0 [7] =&gt; 6 [8] =&gt; 0 [9] =&gt; 8 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>将数组中的值中的字母都改为大写</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v){\n    $v = strtoupper($v);\n    return $v;\n}\n\n$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\n\n$result = array_map(&#39;myfunction&#39;,$a);\nprint_r($result);\n\n//\nArray ( [0] =&gt; A [1] =&gt; B [2] =&gt; C [3] =&gt; D )Array ( [0] =&gt; A [1] =&gt; B [2] =&gt; C [3] =&gt; D )\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子5</p><p>将函数名赋值为null时 并且有两个数组的情况下 将两个数组 合并成一个多维数组</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v){\n    $v = strtoupper($v);\n    return $v;\n}\n\n$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\n$a2 = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;g&#39;];\n$result = array_map(null,$a,$a2);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; Array ( [0] =&gt; a [1] =&gt; a ) [1] =&gt; Array ( [0] =&gt; b [1] =&gt; b ) \n[2] =&gt; Array ( [0] =&gt; c [1] =&gt; c ) [3] =&gt; Array ( [0] =&gt; d [1] =&gt; g ) )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_merga()</p><p>吧把两个数组合并为一个数组</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];\n$a2 = [1,2,3,4,5,6];\n$result = array_merge($a,$a2);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; 1 [5] =&gt; 2 [6] =&gt; 3 [7] =&gt; 4 [8] =&gt; 5 [9] =&gt; 6 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>合并关系数组时如果键名相同 后一个数组会覆盖前一个数组 去除重名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;c&#39;=&gt;1,&#39;b&#39;=&gt;4,&#39;c&#39;=&gt;5];\n\n$result = array_merge($a,$a2);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 4 [c] =&gt; 5 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>如果使用数字为键名 那么 array_merge将会去除键名 用索引号当键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [4=&gt;1,&#39;b&#39;=&gt;2,6=&gt;3];\n\n$result = array_merge($a);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 1 [b] =&gt; 2 [1] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_merge_recursive()</p><p>也是 将两个数组合并为一个数组 不同于 array_merge() 的地方是 如果键名相同的函数 他不会 进行覆盖 二十将键名相同的函数的值组成一个多维数组</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;2,&#39;d&#39;=&gt;5,&#39;c&#39;=&gt;9];\n\n$result = array_merge_recursive($a,$a2);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 ) [b] =&gt; 2 [c] =&gt; Array ( [0] =&gt; 3 [1] =&gt; 9 ) [d] =&gt; 5 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>array_multisort()</p><p>给数组排序 返回一个升序排列的数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;b&#39;,&#39;c&#39;,&#39;a&#39;];\n\narray_multisort($a);\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c )</code></pre></div><p>注意：array_multisort() 直接改变原有数组的顺序</p><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2 </p><p>批量改变数组 array_multisort(array,array2.....)</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;b&#39;,&#39;c&#39;,&#39;a&#39;];\n$b = [&#39;d&#39;,&#39;f&#39;,&#39;a&#39;];\narray_multisort($a,$b);\nprint_r($a);\nprint_r($b);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c ) \nArray ( [0] =&gt; a [1] =&gt; d [2] =&gt; f )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>两个值一样的时候也会往下排序</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;b&#39;,&#39;c&#39;,&#39;a&#39;,&#39;a&#39;];\narray_multisort($a);\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; a [2] =&gt; b [3] =&gt; c )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>合并两个数组，并按数字降序排列</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,4,5,6,7];\n\n$a2 = [5,2,8,9,6,4];\n$result = array_merge($a,$a2);\n\narray_multisort($result,SORT_DESC);\n\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 9 [1] =&gt; 8 [2] =&gt; 7 [3] =&gt; 6 [4] =&gt; 6 [5] =&gt; 5 \n[6] =&gt; 5 [7] =&gt; 4 [8] =&gt; 4 [9] =&gt; 3 [10] =&gt; 2 [11] =&gt; 2 [12] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_pad()</p><p>array_pad(&#39;数组&#39;,5,值) 函数将指定数量的带有指定值的元素插入到数组中</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;];\n$result  = array_pad($a,10,&#39;b&#39;);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; b [3] =&gt; b [4] =&gt; b [5] =&gt; b [6] =&gt; b [7] =&gt; b [8] =&gt; b [9] =&gt; b )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>如果插入的数量为复数 就会从 数组前面插入生成的数值</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;];\n$result  = array_pad($a,-10,&#39;b&#39;);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; b [1] =&gt; b [2] =&gt; b [3] =&gt; b [4] =&gt; b [5] =&gt; b [6] =&gt; b [7] =&gt; b [8] =&gt; a [9] =&gt; b )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_pop()</p><p>删除数组中的最后一个元素</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$result  = array_pop($a);\nprint_r($result);\necho &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\nprint_r($a);\n\n//结果\n删除结果：c\n数组a：Array ( [0] =&gt; a [1] =&gt; b )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_product()</p><p>将数字数组的所有值相乘，并且返回结果</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [5,5,5];\n$result = array_product($a);\nprint_r($result);\n\n//结果\n125</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_push()</p><p>在数组尾部添加一个数组火车多个数组，并且返回新数组的长度</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [5,5,5];\n$result = array_push($a,1,2);\nprint_r($result);\nprint_r($a);\n\n//结果\n5\nArray ( [0] =&gt; 5 [1] =&gt; 5 [2] =&gt; 5 [3] =&gt; 1 [4] =&gt; 2 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>多维数组添加，没有键名的情况下 会用索引号当键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;5,&#39;b&#39;=&gt;5,&#39;c&#39;=&gt;5];\n$result = array_push($a,&#39;dd&#39;,&#39;cc&#39;);\nprint_r($result);\nprint_r($a);\n\n//结果\n5\nArray ( [a] =&gt; 5 [b] =&gt; 5 [c] =&gt; 5 [0] =&gt; dd [1] =&gt; cc )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_rand()</p><p>array_rand() 函数返回数组中的随机键名</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$result = array_rand($a,2);\n\necho $a[$result[0]];\necho $a[$result[1]];\n//结果\na\nc</code></pre></div><p>例子2</p><p>多维数组返回随机键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$result = array_rand($a,1);\n\necho $result;\n\n//结果随机返回键名\nb</code></pre></div><p>例子3</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$result = array_rand($a,2);\n\nprint_r($result);\n\n//随机返回数组</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_reduce()</p><p>array_reduct() 函数像用户自定以函数发送数组中的值，并返回一个字符串</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v1,$v2){\n    return $v1.&#39;*&#39;.$v2;\n}\n\n$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$result =  array_reduce($a,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果\n*a*b*c</code></pre></div><p>例子2</p><p>设置initial 参数</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v1,$v2){\n    return $v1.&#39;*&#39;.$v2;\n}\n\n$a = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$result =  array_reduce($a,&#39;myfunction&#39;,5);\nprint_r($result);\n\n//结果\n5*a*b*c</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>其他用法 将数组值 相加</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($v1,$v2){\n    return $v1+$v2;\n}\n\n$a = [1,2,3];\n$result =  array_reduce($a,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果\n6</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_replace()</p><p>使用其他数组替换第一个数组的值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3];\n$b = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;];\n$result = array_replace($a,$b);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>如果数组1和数组2 中的键名相同 数组2的同名数组 将会替换数组1，不同的就合并</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$b = [&#39;d&#39;=&gt;5,&#39;f&#39;=&gt;8,&#39;c&#39;=&gt;9];\n$result = array_replace($a,$b);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 9 [d] =&gt; 5 [f] =&gt; 8 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>如果数组中一个有键值对 ，一个是索引数组使用replace 返回 会将索引当键组成多维数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;,&#39;c&#39;=&gt;3];\n$b = [&#39;d&#39;=&gt;5,&#39;f&#39;=&gt;8,&#39;c&#39;=&gt;9];\n$result = array_replace($a,$b);\nprint_r($result);\n\n\n//结果数组b索引0</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>使用三个数组 最后一个数组 会覆盖之前的数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;,&#39;c&#39;=&gt;3];\n$b = [&#39;d&#39;=&gt;5,&#39;f&#39;=&gt;8,&#39;c&#39;=&gt;9];\n$c = [&#39;a&#39;=&gt;88,&#39;b&#39;=&gt;66,&#39;c&#39;=&gt;888];\n$result = array_replace($a,$b,$c);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 88 [0] =&gt; b [c] =&gt; 888 [d] =&gt; 5 [f] =&gt; 8 [b] =&gt; 66 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_replace_recursive() 和array_replace()的 区别</p><p>array_replace() 是替换整个数组</p><p>array_replace_recursive() 只替换数组第一个值</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;[&#39;1&#39;],&#39;b&#39;=&gt;[&#39;2&#39;,&#39;3&#39;]];\n$a2 = [&#39;a&#39;=&gt;[&#39;10&#39;],&#39;b&#39;=&gt;[&#39;5&#39;]];\n\n\n$result = array_replace_recursive($a,$a2);\nprint_r($result);\n\necho &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\n\n$result = array_replace($a,$a2);\nprint_r($result);\n\n//结果\narray_replace_recursive() :Array ( [a] =&gt; Array ( [0] =&gt; 10 ) [b] =&gt; Array ( [0] =&gt; 5 [1] =&gt; 3 ) ) \narray_replace() :　Array ( [a] =&gt; Array ( [0] =&gt; 10 ) [b] =&gt; Array ( [0] =&gt; 5 ) )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_reverse()</p><p>array_reverse() 反转整个数组</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,7,3,8,5,8];\n\n$result = array_reverse($a);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 8 [1] =&gt; 5 [2] =&gt; 8 [3] =&gt; 3 [4] =&gt; 7 [5] =&gt; 2 [6] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_search()</p><p>搜索数组中给定的值并返回键名</p><p>如果设置为 true，则在数组中检查给定值的类型，数字 5 和字符串 5 是不同的</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a= [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$result = array_search(1,$a);\nprint_r($result);\n\n//结果\na</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_shift()</p><p>删除 数组z中的第一个元素 并返回被删除的元素值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a= [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$result = array_shift($a);\nprint_r($result);\n\n//结果\n1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>使用索引号当键名的时候 array_shit() 删除后 会重新排列被删除的数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$a= [0=&gt;&#39;a&#39;,1=&gt;&#39;b&#39;,2=&gt;&#39;c&#39;];\n$result = array_shift($a);\nprint_r($result);\necho &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\nprint_r($a);\n\n//结果\na\nArray ( [0] =&gt; b [1] =&gt; c )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_slice()</p><p>array_slice() 根据条件取出数组的值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,4,5,6,7,8,9];\n$result = array_slice($a,2);\nprint_r($result);\n\n//结果 下标从0开始\nArray ( [0] =&gt; 3 [1] =&gt; 4 [2] =&gt; 5 [3] =&gt; 6 [4] =&gt; 7 [5] =&gt; 8 [6] =&gt; 9 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>array_slice(&#39;数组&#39;，开始数，返回多少个)</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,4,5,6,7,8,9];\n$result = array_slice($a,2,2);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 3 [1] =&gt; 4 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>开始数使用负数</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,4,5,6,7,8,9];\n$result = array_slice($a,-4,2);\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 6 [1] =&gt; 7 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子4</p><p>preserve设置true 保留键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;1];\n$result = array_slice($a,1,2,true);\nprint_r($result);\n\n//\nArray ( [b] =&gt; 2 [c] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_splice()</p><p>移除数组中的指定元素并且用新元素代替</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;d&#39;=&gt;4,&#39;e&#39;=&gt;5];\narray_splice($a1,0,2,$a2);\nprint_r($a1);\n\n//结果\nArray ( [0] =&gt; 4 [1] =&gt; 5 [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>length 为0的时候的效果 是插入的效果 没有替换掉任何1 个 而是在指定位置插入</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;d&#39;=&gt;4,&#39;e&#39;=&gt;5];\narray_splice($a1,1,0,$a2);\nprint_r($a1);\n\n//结果\nArray ( [a] =&gt; 1 [0] =&gt; 4 [1] =&gt; 5 [b] =&gt; 2 [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_sum()</p><p>array_sum()函数返回数组中所有值的和</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3];\n$result = array_sum($a);\n\necho $result;\n\n//结果\n6</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>返回数组中所有值的和</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2];\n\n$result = array_sum($a);\n\nprint_r($result);\n\n//结果\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_udiff()</p><p>用自定义函数比较两个或多个数组的键值，返回差集</p><p>array_udiff(array,array2,&#39;回调函数&#39;)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b)?1:-1;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;2,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;4];\n\n$result = array_udiff($a1,$a2,&#39;myfunction&#39;);\n\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [c] =&gt; 3 )</code></pre></div><p>例子2</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0;\n    }\n    return ($a&gt;$b)? 1:-1;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n$a2 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;5,&#39;p&#39;=&gt;8];\n$a3 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;p&#39;=&gt;9];\n\n$result = array_udiff($a1,$a2,$a3,&#39;myfunction&#39;);\nprint_r($result);\n\n//结果 只有&#39;c&#39;和其他两个数组没有交集\nArray ( [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_udiff_assoc()</p><p>array_udiff_assoc()函数用于比较两个 数组或更多数组的键名和键值 返回差集</p><p>使用自定义函数</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a===$b){\n        return 0 ;\n    }\n    return ($a&gt;$b) ? 1 : -1;\n}\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;1];\n$a2 = [&#39;a&#39;=&gt;2,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;5];\n\n$result = array_udiff_assoc($a1,$a2,&#39;myfunction&#39;);\n\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [c] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_udiff_uassoc()</p><p>比较两个数组的键名和键值，并返回差集</p><p>注意 该函数使用两个自定义函数进行比较 第一个函数比较键名，第二个函数比较键值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;1];\n$a2 = [&#39;a&#39;=&gt;2,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;5];\n\n$result = array_udiff_uassoc($a1,$a2,&#39;myfunction_key&#39;,&#39;myfunction_value&#39;);\n\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [c] =&gt; 1 )</code></pre></div><p>array_unique()</p><p>删除数组中的重复值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;1];\n\n$result = array_unique($a);\n\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 2 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_unshift()</p><p>array_unshift() 用于向数组插入新元素 新数组的值将会被插入到数组的最前端</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;1];\n\narray_unshift($a,&#39;cccc&#39;);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; cccc [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>使用数字键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [0=&gt;1,1=&gt;2,2=&gt;1];\n\narray_unshift($a,&#39;cccc&#39;);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; cccc [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_values()</p><p>返回数组中所有的值，不保留键名</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = array_values($a);\n\nprint_r($result);\n\n//结果\nArray ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_walk()</p><p>对 数组中的每个元素应用 用户自定义函数。在函数中 数组的键名和键值是参数</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($value,$key){\n    echo &#34;The key $key has the value $value <span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#34;;\n}\n\n\n$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\narray_walk($a,&#39;myfunction&#39;);\n\n//结果\nThe key a has the value 1 \nThe key b has the value 2 \nThe key c has the value 3 </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>设置一个参数</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($value,$key,$p){\n    echo &#34;$value $p $key <span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#34;;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\narray_walk($a1,&#39;myfunction&#39;,&#39;的键是：&#39;);\n\n//结果\n1 的键是： a \n2 的键是： b \n3 的键是： c </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>我们 可以使用 array_walk()批量更换数组的值或者键</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction(<span class=\"err\">&amp;</span>$value,$key){\n    $value = &#39;yellow&#39;;\n}\n\n$a1 = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\narray_walk($a1,&#39;myfunction&#39;);\n\nprint_r($a1);\n\n//结果\nArray ( [a] =&gt; yellow [b] =&gt; yellow [c] =&gt; yellow )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>array_walk_recursive()</p><p>array_walk_recursive() 对数组中的每个元素应用用户自定义函数，在函数中 数组的键名和键值是参数</p><p>注意 该函数和 array_walk() 不同在于可以操作更深的数组 （多维数组）</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($value,$key)\n{\n    echo &#34;键 $key 的值是 $value 。<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#34;;\n}\n$a1=array(&#34;a&#34;=&gt;&#34;red&#34;,&#34;b&#34;=&gt;&#34;green&#34;);\n$a2=array($a1,&#34;1&#34;=&gt;&#34;blue&#34;,&#34;2&#34;=&gt;&#34;yellow&#34;);\narray_walk_recursive($a2,&#34;myfunction&#34;);\n\n//结果\n键 a 的值是 red 。\n键 b 的值是 green 。\n键 1 的值是 blue 。\n键 2 的值是 yellow 。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>arsort() </p><p>函数对关联数组按照键值进行降序排序 </p><p>注意 asort()对关联数组按照值进行升序排序</p><p>注意 krsort() 对关联数组按照键名进行降序排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;c&#39;=&gt;1,&#39;a&#39;=&gt;3,&#39;b&#39;=&gt;2];\n$result = arsort($a1);\nprint_r($a1);\n\n//结果\nArray ( [a] =&gt; 3 [b] =&gt; 2 [c] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>asort()</p><p>asort() 对关联数组按照值进行 升序排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [&#39;c&#39;=&gt;1,&#39;a&#39;=&gt;3,&#39;b&#39;=&gt;2];\n$result = asort($a1);\nprint_r($a1);\n\n//结果\nArray ( [c] =&gt; 1 [b] =&gt; 2 [a] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>compact()</p><p>compact() 函数创建包含变量名和他们值的数组</p><p>compact(&#39;变量名&#39;...)</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = 1;\n$b = 2 ;\n$c = 3;\n\n$result = compact(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);\nprint_r($result);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>count()</p><p>返回数组中元素的数目</p><p>count(array)数组</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\necho count($a);\n\n//结果\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>对 多维数组行进行计算</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;[1,2],&#39;b&#39;=&gt;[3,4],&#39;c&#39;=&gt;[5,6]];\n\necho count($a,1);\n\n//结果\n9</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>current()</p><p>current() 返回数组中的当前元素的值 其实就是确认当前数组指针的位置</p><p>注意 他不能起到移动指针的作用 只能查出当前指针所在哪里数组里面</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\necho current($a);\n\n//结果\n1</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>结合 指针控制的 next()和 prev()</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\necho current($a);\n\nnext($a);\necho &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\necho current($a);\n\necho &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\n\nnext($a);\n\necho current($a);\n\n//结果\n1\n2\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>end()</p><p>end()将数组内部指针指向最后一个元素 并返回该元素的值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = end($a);\n\nprint_r($result);\n\n//结果\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>extract()  </p><p>extract() 该函数使用数组键名作为变量名，使用键值作为变量值，针对数组中的每个元素</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\nextract($a);\n\necho &#34;$c&#34;;\n\n//结果\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>in_array()</p><p>in_array() 搜索数组中是否存在指定值</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\nif(in_array(1,$a)){\n    echo &#39;存在&#39;;\n}else{\n    echo &#39;不存在&#39;;\n}\n\n//结果\n存在</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>key()</p><p>key()返回数组内部指针指向的键名</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;e&#39;=&gt;&#39;a&#39;];\n\n$result = key($a);\n\nprint_r($result);\n\n//结果\na</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>结合next() prev()</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3,&#39;e&#39;=&gt;&#39;a&#39;];\n\n$result = key($a);\n\nprint_r($result.&#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;);\n\nnext($a);\n\n$result = key($a);\nprint_r($result.&#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;);\n\nnext($a);\n\n$result = key($a);\n\nprint_r($result.&#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;);\n\nprev($a);\n$result =key($a);\nprint_r($result);\n\n//结果\na\nb\nc\nb</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>ksort()</p><p>ksort()数组键名进行升序排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;b&#39;=&gt;2,&#39;a&#39;=&gt;1,&#39;c&#39;=&gt;3,&#39;e&#39;=&gt;&#39;a&#39;];\n\nksort($a);\n\nprint_r($a);\n\n//结果\nArray ( [a] =&gt; 1 [b] =&gt; 2 [c] =&gt; 3 [e] =&gt; a )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>krsort()</p><p>krsort() 对关联数组按照键名进行降序排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;b&#39;=&gt;2,&#39;a&#39;=&gt;1,&#39;c&#39;=&gt;3,&#39;e&#39;=&gt;&#39;a&#39;];\n\nkrsort($a);\n\nprint_r($a);\n\n//结果\nArray ( [e] =&gt; a [c] =&gt; 3 [b] =&gt; 2 [a] =&gt; 1 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>list()</p><p>list() 把数组中的值赋值给一组变量</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [1,2,3,4,5,6];\n\nlist($a,$b,$c,$d,$e)= $a1;\n\nprint_r($a.$b);\n\n\n//结果\n12</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>过滤掉中 间段落的数组</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [1,2,3,4,5,6];\n\nlist($a, ,$c)= $a1;\n\nprint_r($a.$c);\n\n//结果 $a 和 $c 中间有个空格\n13</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>natcasesort()</p><p>natcasesort()函数用自然排序算法对数组进行排序。键值保留他们的原始键名</p><p>索引素组 不会因为排序而变化索引号</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [6,1,2,3,4,5];\n\nnatcasesort($a1);\nprint_r($a1);\n\n//结果\nArray ( [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 [0] =&gt; 6 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>natsort()</p><p>natsort()用自然排序 算法对数组进行排序 键值保留他们原始的键名</p><div class=\"highlight\"><pre><code class=\"language-php\">$a1 = [6,1,2,3,4,5];\n\nnatsort($a1);\nprint_r($a1);\n\n//结果\nArray ( [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 [0] =&gt; 6 )</code></pre></div><p>对数值进行排序，索引号不变</p><p class=\"ztext-empty-paragraph\"><br/></p><p>next()</p><p>将数组中的内部指针向前移动一位</p><p class=\"ztext-empty-paragraph\"><br/></p><p>pos current的别名 也是获取数组当前指针的元素</p><p class=\"ztext-empty-paragraph\"><br/></p><p>prev()指针向后移动一位</p><p class=\"ztext-empty-paragraph\"><br/></p><p>range()</p><p>range(start，end) 创建一个包含指定范围的元素数组</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = range(0,100);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 [6] =&gt; 6 [7] =&gt; 7 [8] =&gt; 8 [9] =&gt; 9 [10] =&gt; 10 [11] =&gt; 11 [12] =&gt; 12 [13] =&gt; 13 [14] =&gt; 14 [15] =&gt; 15 [16] =&gt; 16 [17] =&gt; 17 [18] =&gt; 18 [19] =&gt; 19 [20] =&gt; 20 [21] =&gt; 21 [22] =&gt; 22 [23] =&gt; 23 [24] =&gt; 24 [25] =&gt; 25 [26] =&gt; 26 [27] =&gt; 27 [28] =&gt; 28 [29] =&gt; 29 [30] =&gt; 30 [31] =&gt; 31 [32] =&gt; 32 [33] =&gt; 33 [34] =&gt; 34 [35] =&gt; 35 [36] =&gt; 36 [37] =&gt; 37 [38] =&gt; 38 [39] =&gt; 39 [40] =&gt; 40 [41] =&gt; 41 [42] =&gt; 42 [43] =&gt; 43 [44] =&gt; 44 [45] =&gt; 45 [46] =&gt; 46 [47] =&gt; 47 [48] =&gt; 48 [49] =&gt; 49 [50] =&gt; 50 [51] =&gt; 51 [52] =&gt; 52 [53] =&gt; 53 [54] =&gt; 54 [55] =&gt; 55 [56] =&gt; 56 [57] =&gt; 57 [58] =&gt; 58 [59] =&gt; 59 [60] =&gt; 60 [61] =&gt; 61 [62] =&gt; 62 [63] =&gt; 63 [64] =&gt; 64 [65] =&gt; 65 [66] =&gt; 66 [67] =&gt; 67 [68] =&gt; 68 [69] =&gt; 69 [70] =&gt; 70 [71] =&gt; 71 [72] =&gt; 72 [73] =&gt; 73 [74] =&gt; 74 [75] =&gt; 75 [76] =&gt; 76 [77] =&gt; 77 [78] =&gt; 78 [79] =&gt; 79 [80] =&gt; 80 [81] =&gt; 81 [82] =&gt; 82 [83] =&gt; 83 [84] =&gt; 84 [85] =&gt; 85 [86] =&gt; 86 [87] =&gt; 87 [88] =&gt; 88 [89] =&gt; 89 [90] =&gt; 90 [91] =&gt; 91 [92] =&gt; 92 [93] =&gt; 93 [94] =&gt; 94 [95] =&gt; 95 [96] =&gt; 96 [97] =&gt; 97 [98] =&gt; 98 [99] =&gt; 99 [100] =&gt; 100 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>range(start,end,num) 第三个参数是步进制 默认是 1</p><p>只返回奇数</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = range(1,100,2);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 1 [1] =&gt; 3 [2] =&gt; 5 [3] =&gt; 7 [4] =&gt; 9 [5] =&gt; 11 [6] =&gt; 13 [7] =&gt; 15 [8] =&gt; 17 [9] =&gt; 19 [10] =&gt; 21 [11] =&gt; 23 [12] =&gt; 25 [13] =&gt; 27 [14] =&gt; 29 [15] =&gt; 31 [16] =&gt; 33 [17] =&gt; 35 [18] =&gt; 37 [19] =&gt; 39 [20] =&gt; 41 [21] =&gt; 43 [22] =&gt; 45 [23] =&gt; 47 [24] =&gt; 49 [25] =&gt; 51 [26] =&gt; 53 [27] =&gt; 55 [28] =&gt; 57 [29] =&gt; 59 [30] =&gt; 61 [31] =&gt; 63 [32] =&gt; 65 [33] =&gt; 67 [34] =&gt; 69 [35] =&gt; 71 [36] =&gt; 73 [37] =&gt; 75 [38] =&gt; 77 [39] =&gt; 79 [40] =&gt; 81 [41] =&gt; 83 [42] =&gt; 85 [43] =&gt; 87 [44] =&gt; 89 [45] =&gt; 91 [46] =&gt; 93 [47] =&gt; 95 [48] =&gt; 97 [49] =&gt; 99 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子3</p><p>使用字母 也会返回字母</p><div class=\"highlight\"><pre><code class=\"language-php\">header(&#39;content-type:text/html;charset=utf-8&#39;);\n\n$a = range(&#39;a&#39;,&#39;z&#39;);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; d [4] =&gt; e [5] =&gt; f [6] =&gt; g [7] =&gt; h [8] =&gt; i [9] =&gt; j [10] =&gt; k [11] =&gt; l [12] =&gt; m [13] =&gt; n [14] =&gt; o [15] =&gt; p [16] =&gt; q [17] =&gt; r [18] =&gt; s [19] =&gt; t [20] =&gt; u [21] =&gt; v [22] =&gt; w [23] =&gt; x [24] =&gt; y [25] =&gt; z )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>reset()</p><p>reset()将内部指针指向数组中的第一个元素 就是将指针拨回 到 0</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = range(&#39;a&#39;,&#39;z&#39;);\n\nnext($a);\nnext($a);\n$result = current($a);\nprint_r($result.&#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;);\n\n$b = reset($a);\n\nprint_r($b);\n\n//结果\nc\na</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>rsort()对索引数组进行降序排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,3,325,6,7,2,9,5,9,0];\n\nrsort($a);\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 325 [1] =&gt; 9 [2] =&gt; 9 [3] =&gt; 7 [4] =&gt; 6 [5] =&gt; 5 [6] =&gt; 3 [7] =&gt; 2 [8] =&gt; 1 [9] =&gt; 0 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>sort() 对索引数组进行升序排序 </p><p>和rsort()功能相同 一个升序一个降序</p><p class=\"ztext-empty-paragraph\"><br/></p><p>shuffle()</p><p>shuffle() 将数组打乱</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [1,2,3,4,5,6,7,8];\n\nshuffle($a);\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 8 [1] =&gt; 6 [2] =&gt; 3 [3] =&gt; 4 [4] =&gt; 2 [5] =&gt; 5 [6] =&gt; 1 [7] =&gt; 7 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>例子2</p><p>关系数组， 打乱排序后键名会替换成索引号</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\nshuffle($a);\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 )</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>sizeof()</p><p>sizeof()计算数组个数，count()别名</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">$a = [&#39;a&#39;=&gt;1,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;3];\n\n$result = sizeof($a);\nprint_r($result);\n\n//结果\n3</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>uasort()</p><p>uasort()使用用户自定义的比较函数对数组中的键值进行排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a==$b) return 0;\n    return ($a<span class=\"err\">&lt;</span>$b) ? -1:1;\n}\n\n$a = [&#39;a&#39;=&gt;4,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;8,&#39;d&#39;=&gt;6];\n\nuasort($a,&#39;myfunction&#39;);\n\nforeach ($a as $key=&gt;$value){\n    echo &#34;Key=&#34;.$key.&#34;, Value=&#34;.$value;\n    echo &#39;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#39;;\n}\n//结果\nKey=b, Value=2\nKey=a, Value=4\nKey=d, Value=6\nKey=c, Value=8</code></pre></div><p>注意 return -1 是降序，1是升序</p><p class=\"ztext-empty-paragraph\"><br/></p><p>uksort()</p><p>uksort()通过用于自定义比较函数比较数组按键名排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    if($a==$b) return 0;\n    return ($a<span class=\"err\">&lt;</span>$b) ? 1 : -1;\n}\n\n$a = [&#39;a&#39;=&gt;4,&#39;b&#39;=&gt;2,&#39;c&#39;=&gt;8,&#39;d&#39;=&gt;6];\n\nuasort($a,&#39;myfunction&#39;);\n\nforeach ($a as $key=&gt;$value){\n    echo &#34;key=&#34;.$key.&#34;,value=&#34;.$value;\n    echo &#34;<span class=\"p\">&lt;</span><span class=\"nt\">br</span><span class=\"p\">&gt;</span>&#34;;\n}\n\n//结果\nkey=c,value=8\nkey=d,value=6\nkey=a,value=4\nkey=b,value=2</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>usort()</p><p>usort() 通过用户自定义的比较函数比较函数对数组进行排序</p><p>例子1</p><div class=\"highlight\"><pre><code class=\"language-php\">function myfunction($a,$b){\n    return ($a<span class=\"err\">&lt;</span>$b) ? -1 : 1;\n}\n\n$a = [2,6,8,2,3,5,7,5,2,345,64,76,65];\n\nusort($a,&#39;myfunction&#39;);\n\nprint_r($a);\n\n//结果\nArray ( [0] =&gt; 2 [1] =&gt; 2 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 5 [5] =&gt; 5 [6] =&gt; 6 [7] =&gt; 7 [8] =&gt; 8 [9] =&gt; 64 [10] =&gt; 65 [11] =&gt; 76 [12] =&gt; 345 )</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "PHP 学习", 
                    "tagLink": "https://api.zhihu.com/topics/19626603"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/47250842", 
            "userName": "阿里大君", 
            "userLink": "https://www.zhihu.com/people/cf378dc75018533524f47d3a3dfd1bed", 
            "upvote": 0, 
            "title": "数据迁移到第三方云存储的方法选择", 
            "content": "<p>如果您想将历史数据迁移到用户在OSS的某个目标Bucket上。其中，需要迁移的源数据可能来自于OSS的某个Bucket，也可能来自于本地、第三方云存储（如AWS S3、Azure Blob、腾讯云COS、七牛、百度BOS、又拍云、金山KS3等）、HTTP等。</p><h2><b>主要方法</b></h2><p><b>OssImport</b></p><p>使用Ossimport工具进行迁移，适用于各类数据源的历史数据，批量迁移到OSS，请参考OssImport文档。</p><p><b>镜像回源</b></p><p>适用于客户源站无缝迁移数据到OSS。即服务已经在自己建立的源站或者在其他云产品上运行，需要迁移到OSS上，但是又不能停止服务，此时可利用镜像回源功能实现。在Ossimport完成历史数据迁移后，将新产生的数据迁移过程，请参考镜像回源、无缝迁移到OSS。</p><p><b>OSS跨区域复制</b></p><p>适用于同一账户下，从OSS Bucket A将数据复制到Bucket B，请参考设置跨区域复制。在使用时，需注意设置“同步历史数据”。此外，如果不希望同步BucketA的删除操作，可将同步策略设置为“写同步”。</p><p><b>闪电立方</b></p><p>适用于线下数据中心大规模数据迁移上云,支持TB到PB级别大规模数据上云。具体参考官网产品介绍闪电立方。</p><p><b>OSS API或SDK</b></p><p>使用OSS API或SDK编写代码实现，适用于开发能力较强的客户，请参考Copy Object、Upload Part Copy。</p><h2><b>场景1：将非OSS上的数据迁移到OSS中</b></h2><p>在此场景中，迁往目的地是OSS上的Bucket，而源数据不是存储在OSS上，比如在本地、HTTP、第三方云存储（如AWS S3、Azure Blob等）。</p><p><b>各方法的选择如下：</b></p><p><b>1、OssImport</b></p><p>适用于历史数据批量迁移到OSS，特别适合数据量比较大的情况。数据量大时，使用ossimport分布式版本。</p><p><b>2、镜像回源</b></p><p>适用于源站新的热数据在线迁移到OSS，如满足您对于数据热迁移、特定请求重定向等需求。<b>3、闪电立方</b></p><p>适用于用户本地数据中心，TB到PB级别大规模数据上云</p><p><b>4、OSS API/SDK Copy Object、Upload Part Copy</b></p><p>适用于有特性需求，使用OSS API/SDK 编写代码上传OSS。</p><h2><b>场景2：OSS之间的数据迁移</b></h2><p>此场景是指将OSS源Bucket数据迁移到OSS目标Bucket中。迁移的数据源和迁移目的地都是OSS的Bucket。</p><p><b>各方法的选择如下：</b></p><p><b>1、OSS跨区域复制</b></p><p>源Bucket和目标Bucket属于同一个用户，且分属不同的区域。</p><p>源Bucket、目标Bucket存储类型都不是归档类型：</p><p>说明：如果希望源Bucket历史数据迁移（复制到）目标Bucket后，源Bucket的变更（新增、更新、删除）不再同步到目标Bucket，可以在控制台关闭源Bucket的跨区域复制。</p><p><b>2、OssImport </b></p><p>更适合数据量较大（如大于10TB）历史数据迁移场景。</p><p><b>3、OSS API/SDK Copy Object、Upload Part Copy </b></p><p>建议优先使用ossImport或跨区域复制，除非用户有更细化或特性的需求，且有一定的开发能力。</p>", 
            "topic": [
                {
                    "tag": "云存储", 
                    "tagLink": "https://api.zhihu.com/topics/19552913"
                }, 
                {
                    "tag": "数据", 
                    "tagLink": "https://api.zhihu.com/topics/19554449"
                }, 
                {
                    "tag": "云服务", 
                    "tagLink": "https://api.zhihu.com/topics/19563010"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52526456", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "想要那种有提示声音的网站吗？我教你怎么做！", 
            "content": "<p> 您有新的外卖订单请及时查收！<br/>熟悉不能再熟悉的声音了，今天小编就做了这样一个网站的提示新订单的功能，接下来就教你怎么玩转这个小功能！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c74ad52b29f7eca83e6cc06492cbcd00_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-c74ad52b29f7eca83e6cc06492cbcd00_b.jpg\"/></figure><p><br/>首先我们前端的代码是这样写的：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6d050b20bc107b480d3d1485cfc80b4c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"1225\" data-original=\"https://pic1.zhimg.com/v2-6d050b20bc107b480d3d1485cfc80b4c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1225&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1225\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1225\" data-original=\"https://pic1.zhimg.com/v2-6d050b20bc107b480d3d1485cfc80b4c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6d050b20bc107b480d3d1485cfc80b4c_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\"> var playSound = function () {\n        var borswer = window.navigator.userAgent.toLowerCase();\n        if ( borswer.indexOf( &#34;ie&#34; ) &gt;= 0 )\n        {\n            //IE内核浏览器\n            var strEmbed = &#39;&lt;embed name=&#34;embedPlay&#34; src=&#34;/public/Mp3/newOrder.mp3&#34; autostart=&#34;true&#34; hidden=&#34;true&#34; loop=&#34;false&#34;/&gt;&#39;;\n            if ( $( &#34;body&#34; ).find( &#34;embed&#34; ).length &lt;= 0 ) $( &#34;body&#34; ).append( strEmbed );\n            var embed = document.embedPlay; //浏览器不支持 audion，则使用 embed 播放 embed.volume = 100;\n        } else {\n            //非IE内核浏览器\n            var strAudio = &#34;&lt;audio id=&#39;audioPlay&#39; src=&#39;/public/Mp3/newOrder.mp3&#39; hidden=&#39;true&#39;&gt;&#34;;\n            if($(&#34;#audioPlay&#34;).length&lt;=0){\n                $( &#34;body&#34; ).append( strAudio );\n            }\n            var audio = document.getElementById( &#34;audioPlay&#34; );\n            //浏览器支持 audio\n            audio.play();\n        }\n    }\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8b7c5185528297a3f689f72d81096128_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb\" width=\"856\" data-original=\"https://pic1.zhimg.com/v2-8b7c5185528297a3f689f72d81096128_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;856&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"856\" data-original=\"https://pic1.zhimg.com/v2-8b7c5185528297a3f689f72d81096128_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8b7c5185528297a3f689f72d81096128_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">/**新订单*/\nfunction getNewOrder(){\n    $.post(&#34;{:U(&#39;Msg/newOrder&#39;)}&#34;, {}, function(res) {\n        if (res) {\n            playSound();\n            $.post(&#34;{:U(&#39;Msg/msgDetail&#39;)}&#34;, {id:res.id}, function(res) {});\n        }\n    });\n}\nwindow.setInterval(&#34;getNewOrder()&#34;,3000);\n</code></pre></div><p><br/>以上是做ajax的轮询操作，当然你做成websockt也是可以的，本文就作为一个抛砖引玉的作用吧。<br/>后端的话，可以去数据库查询，也可以在前端做好redis缓存，或者其他缓存，然后从缓存里面获取数据等等都是可以的！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-138f9ddf44e6416a5fa3fc54d6de9eb2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic3.zhimg.com/v2-138f9ddf44e6416a5fa3fc54d6de9eb2_b.jpg\"/></figure><p><br/>是不是很简单，快去尝试一下吧！<br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;850&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/FDji_tDElY3qrZSZ920G\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/FDji_tD</span><span class=\"invisible\">ElY3qrZSZ920G</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "HTML", 
                    "tagLink": "https://api.zhihu.com/topics/19551323"
                }, 
                {
                    "tag": "警告提示", 
                    "tagLink": "https://api.zhihu.com/topics/19727915"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48166395", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "PHP一些好玩但是让你涨知识的题（收藏篇）", 
            "content": "<p><b>1、</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$A=&#34;Hello &#34;;                 \nfunctionprint_A()              \n{\n $A = &#34;phpmysql !!&#34;;\nglobal $A;                                               global    全局变量         函数是独立的模块                  $A外界定义的\necho $A;\n}\necho $A;  //Hello\nprint_A(); //Hello   在你将$A定义为全局变量的时候，并未修改$A的值</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>2、</p><div class=\"highlight\"><pre><code class=\"language-text\">$email = ‘langwan@thizlinux.com.cn’;    \n$str = ___strstr_($email,‘@’);\n$info = __explode__(‘.’,$str);\n___print_r_($info);\n输出结果为：\nArray ([0] =&gt; @thizlinux [1]=&gt;com[2]=&gt;cn)    输出结果是一个数组</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>3、定义一个404跳转</b></p><div class=\"highlight\"><pre><code class=\"language-text\">header(&#34;Http/1.1 404 Not Found&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>5、不用PHP函数实现字符串反转</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Notice: Uninitialized string offset: 7 in D:\\wamp\\www\\phpTest\\test.php on line 7  //数组越界的问题</code></pre></div><p>$str = &#39;abcdefg&#39;;</p><p>$len = strlen($str);</p><p>$return = &#39;&#39;;</p><p>for($i=$len-1;$i&gt;=0;$i--){</p><p>    $return.=$str{$i};</p><p>}</p><p>echo $return;</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>6、写出五种获取.jpg或者jpg的的方法</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$dir = &#39;Uploads/img.upload.jpg&#39;;\nsubstr($str,-3);\n//echo substr($dir,strrpos($dir,&#39;.&#39;));\n\n\n//echo strrchr($dir,&#39;.&#39;);\n\n\n//$arr = explode(&#39;.&#39;,$dir);\n//print_r(array_pop($arr));\n\n\n//$p = pathinfo($dir);\n//print_r($p);\n//print_r($p[&#39;extension&#39;]);\n\n\n//$new_str = strrev($dir);\n//echo $new_str.&#34;\\n&#34;;\n//$a = strrev(substr($new_str,0,strpos($new_str,&#39;.&#39;)));\n//echo $a;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>7、请写一个函数，实现以下功能： 字符串“open_door” 转换成 “OpenDoor”、”make_by_id” 转换成 </b>”MakeById”</p><div class=\"highlight\"><pre><code class=\"language-text\">function o($str){\n    $arr = explode(&#39;_&#39;,$str);\n    $str = &#39;&#39;;\n    foreach($arr as $v){\n        $str.=ucfirst($v);\n    }\n    return $str;\n}\necho o(&#39;make_by_id&#39;);\n\n\n方法2：\nfunction ucfirstTest($str){\n    return ucfirst($str);\n}\nfunction test($str){\n    $arr = explode(&#39;_&#39;,$str);\n    $new_arr = array_map(&#39;ucfirstTest&#39;,$arr);\n    $str = implode(&#39;&#39;,$new_arr);\n    return $str;\n}\n$str = &#39;open_str&#39;;\necho test($str);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>8、用PHP打印出前一天的时间格式是2006-5-10 22:21:21(2分)</b></p><div class=\"highlight\"><pre><code class=\"language-text\">echo date(&#39;Y-m-d H:i:s&#39;,strtotime(&#39;-1 days&#39;));</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>9、mb_substr($str,1,10,&#39;utf-8&#39;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p>10、修改session的生存时间</p><p>session_set_cookie_params</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>11、strpos====这里要注意的就是strpos返回的是0，因为他在第0，所以要用===判断</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$str = &#39;https://www.baidu.com&#39;;\n$str1 = &#39;https://&#39;;\nprint_r(strpos($str,$str1));\nif(strpos($str,$str1) !== false){\n\n\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>12、下面输出是什么，主要考的就是运算符的优先级和++  --的问题</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$x = 5;\necho $x;  5\necho &#34;&lt;br /&gt;&#34;;\necho $x+++$x++;  5+6 = 11\necho &#34;&lt;br /&gt;&#34;;\necho $x; 11\necho &#34;&lt;br /&gt;&#34;;\necho $x---$x--; 7-6 = 1\necho &#34;&lt;br /&gt;&#34;;\necho $x; 5</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>13、<b>array_merge合并的时候，传入的都是数组，如果一个不是数组就会返回null</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>14、<b>$x = true and false; var_dump($x);  true</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>15、<b>PHP的可变变量：$a = c;  $$a = 10; $c = 10;</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;form action=&#34;test.php&#34; method=&#34;post&#34;&gt;\n    &lt;input type=&#34;text&#34; name=&#34;a&#34; id=&#34;&#34;/&gt;\n    &lt;input type=&#34;text&#34; name=&#34;b&#34; id=&#34;&#34;/&gt;\n    &lt;input type=&#34;submit&#34; value=&#34;aa&#34;/&gt;\n&lt;/form&gt;\n\n\nforeach($_POST as $k=&gt;$v){\n    ${$k} = $v;\n}\necho &#39;a&#39;.isset($a)?$a:&#39;&#39;.PHP_EOL;\necho &#39;b&#39;.isset($b)?$b:&#39;&#39;.PHP_EOL;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>16、什么是自连接：无限分类就是自己链接自己查询</p><p class=\"ztext-empty-paragraph\"><br/></p><p>17、html动态生成的节点加点击事件</p><div class=\"highlight\"><pre><code class=\"language-text\">$(&#34;.h3&#34;).on(&#34;click&#34;,&#34;h3&#34;,{foo:&#34;文本:&#34;},function(event){\n　　　　alert(event.data.foo+this.textContent);\n　　});</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>18、$url = &#39;<a href=\"https://link.zhihu.com/?target=http%3A//www.test.com.cn/abc/de/fg.php%3Fid%3D1\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">test.com.cn/abc/de/fg.p</span><span class=\"invisible\">hp?id=1</span><span class=\"ellipsis\"></span></a>&#39;;  获取php或者.php</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$b = parse_url($url);  //php解析url地址，parse_str是解析字符串parse_str($str,$out)\necho &#34;&lt;pre&gt;&#34;;\n/**array(4) {\n[&#34;scheme&#34;]=&gt;\n  string(4) &#34;http&#34;\n  [&#34;host&#34;]=&gt;\n  string(15) &#34;www.test.com.cn&#34;\n  [&#34;path&#34;]=&gt;\n  string(14) &#34;/abc/de/fg.php&#34;\n  [&#34;query&#34;]=&gt;\n  string(4) &#34;id=1&#34;\n}\n */\n$arr = $b[&#39;path&#39;];  ///abc/de/fg.php\necho substr($arr,strpos($arr,&#39;.&#39;));\n$new_arr = explode(&#39;.&#39;,$arr);\necho end($new_arr);\n高效\n$arr = parse_url(&#39;http://www.sina.com.cn/abc/de/fg.php?id=1&#39;);\n$result=pathinfo(arr[&#39;path&#39;]);var_dump($arr);\narray(4) { [&#34;dirname&#34;]=&gt; string(7) &#34;/abc/de&#34; [&#34;basename&#34;]=&gt; string(6) &#34;fg.php&#34; [&#34;extension&#34;]=&gt; string(3) &#34;php&#34; [&#34;filename&#34;]=&gt; string(2) &#34;fg&#34; }\nvar_dump($result[&#39;extension&#39;]);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>19、mkdir和is_dir的使用</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$dir = &#39;./liuzhu/test/&#39;;\nif(is_dir($dir)){  //如果存在就返回true\n    file_put_contents($dir.&#39;1.txt&#39;,$url);\n}else{ //如果不存在就创建，true的这个参数是可以循环创建\n    if(mkdir($dir,0777,true)){\n        file_put_contents($dir.&#39;1.txt&#39;,$url);\n    };\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>20、定义一个字符串，然后获取第一个字符</b></p><p>$str = &#39;abcdef&#39;;    $one = $str[1]  || $str{1} 这两种方式</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>21、下面输出no</b></p><p>$v = 1; $m = 2; $l = 3;  if( $l &gt; $m &gt; $v){     echo &#34;yes&#34;; }else{     echo &#34;no&#34;; }</p><p>首先$l&gt;$m返回的是一个true  然后true&gt;1   就返回了null</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>22、获取图片的信息</b></p><div class=\"highlight\"><pre><code class=\"language-text\">getimagesize () 获取图片的尺寸\nImagesx () 获取图片的宽度\nImagesy () 获取图片的高度</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>23、$_SERVER；</p><div class=\"highlight\"><pre><code class=\"language-text\">$host = $_SERVER[&#39;HTTP_HOST&#39;]; //localhost\n$self = $_SERVER[&#39;PHP_SELF&#39;]; ///phpTest/test.php\necho $host.$self;  //localhost/phpTest/test.php\necho $_SERVER[&#39;REMOTE_ADDR&#39;]; //客户端ip地址\necho $_SERVER[&#39;SERVER_ADDR&#39;]; //服务端ip地址\necho $_SERVER[&#39;REQUEST_URI&#39;]; ///phpTest/test.php</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>24、php.ini 中safe mod关闭 影响哪些函数和参数，至少写6个？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">move_uploaded_file()        exec()\nsystem()                              passthru()\npopen()                              fopen()\nmkdir()                               rmdir()\nrename()                            unlink()\ncopy()                                 chgrp()\nchown()                              chmod()\ntouch()                               symlink()\nlink()                                   parse_ini_file()\nset_time_limit()                  max_execution_time mail()</code></pre></div><p><b>25、isset() 、empty()与is_null的区别</b></p><p>1、当变量未定义时，is_null() 和“参数本身”是不允许作为参数判断的，会报Notice警告错误；</p><p>2、empty , isset首先都会检查变量是否存在，然后对变量值进行检测。而is_null 和 “参数本身”只是直接检查变量值，是否为null，因此如果变量未定义就会出现错误！</p><p>3、isset()：仅当null和未定义，返回false；</p><p>4、empty()：&#34;&#34;、0、&#34;0&#34;、NULL、FALSE、array(),未定义，均返回true；</p><p>5、is_null()：仅判断是否为null，未定义报警告；</p><p>6、变量本身作为参数，与empty()一致，但接受未定义变量时，报警告；</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>26、http_build_query()</b></p><div class=\"highlight\"><pre><code class=\"language-text\">$arr = [\n    &#39;title&#39;=&gt;&#39;nihao&#39;,\n    &#39;content&#39;=&gt;&#39;world&#39;\n];\n$str = http_build_query($arr);\nvar_dump($str);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>27、curl   file_get_contents()  socket三种方式实现提交数据</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>28、var_dump(((bool)&#39;all&#39;)+1);  2       true=1   1+1=2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>29、如果你一个整型integer超出了范围，那么就会被转成float</p><p class=\"ztext-empty-paragraph\"><br/></p><p>30、如果你定义的了一个数组，那么当你unset这个数组的时候，你又定义了一个$a[5] 那么这个键应该是从5开始</p><p class=\"ztext-empty-paragraph\"><br/></p><p>31、如何保证你的api接口的安全性</p><p class=\"ztext-empty-paragraph\"><br/></p><p>32、这个地方考察是先用后加的问题</p><div class=\"highlight\"><pre><code class=\"language-text\">$a = 3;\n$b = 5;\nif($a == 3 || $b == 7){\n    echo $a++;\n    echo $b++;\n}\necho $a.&#39;  &#39;.$b;\n3 5  4 6</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>33、count除去数组和实例化对象  其他的count()都是1    null是0  </p><div class=\"highlight\"><pre><code class=\"language-text\">$a = count([4,5,6])+count(null)+count(false);\nvar_dump($a);</code></pre></div><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "知识", 
                    "tagLink": "https://api.zhihu.com/topics/19553939"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/47991377", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "Laravel5.6关于自定义路由的问题", 
            "content": "<p>1、laravel默认有一个api和一个web的路由文件，如果我们想自定义一个路由文件的时候，我们的操作为:</p><p>（1）打开这文件</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3137e494277b981116a72fd2809c3b63_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"136\" class=\"content_image\" width=\"363\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;363&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"363\" data-rawheight=\"136\" class=\"content_image lazy\" width=\"363\" data-actualsrc=\"https://pic4.zhimg.com/v2-3137e494277b981116a72fd2809c3b63_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07fc95b33a5aef33dfdf4f0cfded5cfa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"712\" data-original=\"https://pic3.zhimg.com/v2-07fc95b33a5aef33dfdf4f0cfded5cfa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;712&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"712\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"712\" data-original=\"https://pic3.zhimg.com/v2-07fc95b33a5aef33dfdf4f0cfded5cfa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-07fc95b33a5aef33dfdf4f0cfded5cfa_b.jpg\"/></figure><p>然后我们在map里面调用一下下面的自定义的方法</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-468555f538d4724fdeda004c57d03a0e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"574\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"574\" data-original=\"https://pic3.zhimg.com/v2-468555f538d4724fdeda004c57d03a0e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;574&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"574\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"574\" data-original=\"https://pic3.zhimg.com/v2-468555f538d4724fdeda004c57d03a0e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-468555f538d4724fdeda004c57d03a0e_b.jpg\"/></figure><p>注意点：middleware  这个是一个中间件，默认的web是有middleware(&#39;web&#39;)这个中间件名称的，因为web在调用的时候会自动的使用一些类，我们可以打开</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-21ebd28a0459f1a65de7a7cd9b4d71e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"319\" data-rawheight=\"165\" class=\"content_image\" width=\"319\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;319&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"319\" data-rawheight=\"165\" class=\"content_image lazy\" width=\"319\" data-actualsrc=\"https://pic3.zhimg.com/v2-21ebd28a0459f1a65de7a7cd9b4d71e6_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-002ed3133c36737cab9f205eb0ec649b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb\" width=\"677\" data-original=\"https://pic4.zhimg.com/v2-002ed3133c36737cab9f205eb0ec649b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;677&#39; height=&#39;457&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"457\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"677\" data-original=\"https://pic4.zhimg.com/v2-002ed3133c36737cab9f205eb0ec649b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-002ed3133c36737cab9f205eb0ec649b_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "路由器", 
                    "tagLink": "https://api.zhihu.com/topics/19561099"
                }, 
                {
                    "tag": "Laravel", 
                    "tagLink": "https://api.zhihu.com/topics/19856963"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/46972358", 
            "userName": "云吞铺子", 
            "userLink": "https://www.zhihu.com/people/97bd830a2079ad8a0ea300db1cb4155e", 
            "upvote": 1, 
            "title": "阿里云ECS服务器安装宝塔BT面板图文教程", 
            "content": "<p>阿里云ECS云服务器安装宝塔面板图文教程：宝塔BT面板支持Linux和Windows系统，本文以Linux系统安装宝塔面板为例，安装宝塔面板教程：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>ECS安装宝塔BT面板图文教程开始：</b></p><h2>一：SSH登录服务器</h2><p>使用命令<code>ssh root@你的服务器公网IP</code>登录linux服务器。新手可以参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.aliyunbaike.com/ecs/685/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何使用SSH登录Linux服务器？</a></p><h2>二：宝塔面板安装命令</h2><p>宝塔面板安装很简单，一条命令即可，本教程以CentOS为例，安装命令为：<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</code></pre></div><p>更多不同版本Linux安装宝塔命令参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.aliyunbaike.com/ecs/687/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Linux服务器安装宝塔面板SSH安装命令</a><br/>运行命令后，宝塔面板会自动安装，期间你需要输入一个<code>y</code>，如下所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">Do you want to install Bt-Panel to the /www directory now?(y/n): y</code></pre></div><p>输入<code>y</code>，然后回车即可。<br/>等待，大概2分钟左右，显示“Complete!”，即安装完毕！显示如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">Complete!\n==================================================================\nCongratulations! Install succeeded!\n==================================================================\nBt-Panel: http://47.104.71.103:8888\nusername: admin\npassword: 66d52887\nWarning:\nIf you cannot access the panel,\nrelease the following port (8888|888|80|443|20|21) in the security group\n==================================================================</code></pre></div><p>安装完毕后会显示登录地址、用户名和密码：<br/>登录地址为：http://你的服务器IP:8888<br/>用户名：admin<br/>密码：随机生成，安装完毕后会有显示</p><h2>三：自定义阿里云安全组，开放宝塔所需端口8888|888|80|443|20|21</h2><p>安装后，你会发现宝塔面板后台无法登陆，这是由于这是由于阿里云安全组导致的，安全起见，阿里云默认关闭了<code>8888号端口</code>和<code>80号端口</code>，所以安装完毕宝塔面板后，需要去控制台开放8888号端口和80号端口，参考：<a href=\"https://link.zhihu.com/?target=https%3A//www.aliyunbaike.com/ecs/368/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">阿里云ECS怎么开放端口自定义安全组规则</a><br/>安全组开放8888号端口后，即可访问后台了！输入账户名和密码，如下图所示：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-345ec99716ca0cfcafd3ed860ff2feaa_b.jpg\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-345ec99716ca0cfcafd3ed860ff2feaa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-345ec99716ca0cfcafd3ed860ff2feaa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-345ec99716ca0cfcafd3ed860ff2feaa_b.jpg\"/><figcaption>登录宝塔Linux面板</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>四：一键安装LNMP或者LAMP环境</h2><p>登录宝塔后台后，会弹出一键安装web环境的界面，我们按照自身需求安装适合自己的LNMP环境或者LAMP环境，推荐安装LNMP web环境。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3d2f1b2e7ae36ae05f83826ebe1024ce_b.jpg\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-3d2f1b2e7ae36ae05f83826ebe1024ce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1000&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1000\" data-rawheight=\"620\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1000\" data-original=\"https://pic3.zhimg.com/v2-3d2f1b2e7ae36ae05f83826ebe1024ce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3d2f1b2e7ae36ae05f83826ebe1024ce_b.jpg\"/><figcaption>宝塔面板一键安装web环境</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>点击“一键安装”后，会弹出消息盒子自动安装，等待即可，如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c3ab0be3f62f37b1ec1fcd4b43712dac_b.jpg\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"665\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-c3ab0be3f62f37b1ec1fcd4b43712dac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;665&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"665\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-c3ab0be3f62f37b1ec1fcd4b43712dac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c3ab0be3f62f37b1ec1fcd4b43712dac_b.jpg\"/><figcaption>宝塔面板消息盒子一键安装web环境</figcaption></figure><p>时间稍微长一些，耐心等待...</p><h2>五：创建站点</h2><p>1. 登录到宝塔面板后台<code>http://你的服务器IP:8888/</code><br/>2. 点击左侧“网站”，“添加站点”，如下图：<br/>我们以<code>aliyunbaike.com</code>为例：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5820ad71eb414e7c9a430053fdc078b3_b.jpg\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"779\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-5820ad71eb414e7c9a430053fdc078b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;779&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"779\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-5820ad71eb414e7c9a430053fdc078b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5820ad71eb414e7c9a430053fdc078b3_b.jpg\"/><figcaption>宝塔面板创建站点</figcaption></figure><p>输入域名后，默认不会自动创建FTP和MySQL数据库，我们可以选择自动创建，方便省事，点击“提交”，创建成功后，会显示你的FTP和MySQL数据信息，例如：</p><blockquote>FTP账号资料<br/>用户：aliyunbaike_com<br/>密码：625GcrKSc3<br/>只要将网站上传至以上FTP即可访问!<br/>数据库账号资料<br/>数据库名：aliyunbaike_com<br/>用户：aliyunbaike_com<br/>密码：e8QZfQDPDT</blockquote><p>将域名解析到服务器IP后，输入域名显示“恭喜, 站点创建成功！”，说明您已经完全配置成功了！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-120ff3e0dfc64d1697d0e21f61eba151_b.jpg\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-120ff3e0dfc64d1697d0e21f61eba151_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-120ff3e0dfc64d1697d0e21f61eba151_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-120ff3e0dfc64d1697d0e21f61eba151_b.jpg\"/><figcaption>宝塔站点安装成功</figcaption></figure><p>至此，阿里云Linux云服务器ECS安装宝塔面板图文教程完毕。</p>", 
            "topic": [
                {
                    "tag": "服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19554575"
                }, 
                {
                    "tag": "云主机", 
                    "tagLink": "https://api.zhihu.com/topics/19615848"
                }, 
                {
                    "tag": "阿里云", 
                    "tagLink": "https://api.zhihu.com/topics/19560108"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "跟选windows 系统有什么差距吗？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/46117707", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "你知道这种开发模式能更好的帮你排错吗？", 
            "content": "<p> 很多时候我们在开发一个项目的时候写着写着sql语句报错了？（这里多指使用框架开发，当然也有原声sql语句），之后有时候会扎耳挠腮，看来看去都感觉自己的sql语句没有问题，其实这往往就降低了我们的开发效率<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cba637331d2107c5a7117ca8bccc8679_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-cba637331d2107c5a7117ca8bccc8679_b.jpg\"/></figure><p><br/>（1）针对原声sql语句当然就比较好解决了，当然有时候我们写程序的时候程序就已经告诉你了sql语句是否有问题，这样当然就更好了，如果不报错的话，我们可以将我们的sql语句粘贴到mysql的管理器中，比如导航猫（相信大家都知道的可视化客户端），还有就是网页版本的phpmyadmin，一执行便知道sql语句的问题了。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7d06099bf3fe671b28e55d1ffb8b958e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"220\" data-rawheight=\"219\" class=\"content_image\" width=\"220\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;220&#39; height=&#39;219&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"220\" data-rawheight=\"219\" class=\"content_image lazy\" width=\"220\" data-actualsrc=\"https://pic3.zhimg.com/v2-7d06099bf3fe671b28e55d1ffb8b958e_b.jpg\"/></figure><p><br/>（2）让人头疼的是在某个框架中，我们使用框架封装好的方法我们去操作数据库，这样在一定程度上我们就不会用编写原声sql语句而头疼了，但是就是这样我们的sql语句出现问题我们排错也是更加困难的，接下来小编就给大家说两种我们在日常开发中常用的两种框架，怎么更好的去解决这个问题：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-af01db809027f3e70ba7496dc01079e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic4.zhimg.com/v2-af01db809027f3e70ba7496dc01079e7_b.jpg\"/></figure><p><br/>1）在web开发神器Laravel里面我们怎么去做呢？分为两种方法，当然如果有更好的方法欢迎一起交流<br/>首先我们执行一个php artisan make:listener SqlListener -e=QueryExecuted<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-22fc01bbaa9869864b1cfd03d795059c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-22fc01bbaa9869864b1cfd03d795059c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;402&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"402\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-22fc01bbaa9869864b1cfd03d795059c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-22fc01bbaa9869864b1cfd03d795059c_b.jpg\"/></figure><p><br/>当然在事件监听的Service里面要加上监听的事件类文件地址<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9e9c8a03ec70ca4e3e17dd7a5c1cc56c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-9e9c8a03ec70ca4e3e17dd7a5c1cc56c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;218&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"218\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-9e9c8a03ec70ca4e3e17dd7a5c1cc56c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9e9c8a03ec70ca4e3e17dd7a5c1cc56c_b.jpg\"/></figure><p><br/>接下来我们就去编写一个记录sql语句的业务逻辑了<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b7f874b26186daad486ea010150435f8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"919\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"919\" data-original=\"https://pic1.zhimg.com/v2-b7f874b26186daad486ea010150435f8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;919&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"919\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"919\" data-original=\"https://pic1.zhimg.com/v2-b7f874b26186daad486ea010150435f8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b7f874b26186daad486ea010150435f8_b.jpg\"/></figure><p><br/>之后我们编写sql处理方法<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-10d6f39f8457dc3becce31e32afd497d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"https://pic2.zhimg.com/v2-10d6f39f8457dc3becce31e32afd497d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;826&#39; height=&#39;142&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"826\" data-original=\"https://pic2.zhimg.com/v2-10d6f39f8457dc3becce31e32afd497d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-10d6f39f8457dc3becce31e32afd497d_b.jpg\"/></figure><p><br/>之后在对应的文件夹下面就出现了一个文件，里面就记录了我们执行的sql语句<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2e8fbf4ec2b9199c18a8181fe1171f52_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1254\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"1254\" data-original=\"https://pic3.zhimg.com/v2-2e8fbf4ec2b9199c18a8181fe1171f52_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1254&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1254\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1254\" data-original=\"https://pic3.zhimg.com/v2-2e8fbf4ec2b9199c18a8181fe1171f52_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2e8fbf4ec2b9199c18a8181fe1171f52_b.jpg\"/></figure><p><br/>2）还有一个简单暴力的方法<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fdbdc916e75f4b89758cc90b4cde6740_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb\" width=\"763\" data-original=\"https://pic1.zhimg.com/v2-fdbdc916e75f4b89758cc90b4cde6740_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;763&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"763\" data-rawheight=\"159\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"763\" data-original=\"https://pic1.zhimg.com/v2-fdbdc916e75f4b89758cc90b4cde6740_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fdbdc916e75f4b89758cc90b4cde6740_b.jpg\"/></figure><p><br/>这样也能打印出sql语句，当然这个sql语句就是一个预处理sql语句<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ca27e14449958165f8ff9850147f2b55_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-ca27e14449958165f8ff9850147f2b55_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1064&#39; height=&#39;161&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1064\" data-rawheight=\"161\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1064\" data-original=\"https://pic2.zhimg.com/v2-ca27e14449958165f8ff9850147f2b55_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ca27e14449958165f8ff9850147f2b55_b.jpg\"/></figure><p><br/>当然还是推荐上面第一种方法<br/>3）接下来我就给大家介绍国产框架ThnkPHP5.0+的方法，当然加简单很多了<br/>$this-&gt;getLastSql();<br/>之后就可以先显示一段最后一次执行的sql语句了<br/>select * from test;<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d55c21ebe7856a0ae8c8e2b3c6f5d347_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic4.zhimg.com/v2-d55c21ebe7856a0ae8c8e2b3c6f5d347_b.jpg\"/></figure><p><br/>以上就是我们开发中最常用的排错以及去优化sql语句具备的基础操作，希望我们在日常开发中遇到sql语句的问题我们完全可以按照上面的操作去打印sql语句然后排错以及进行sql的优化<br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;850&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/FDji_tDElY3qrZSZ920G\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/FDji_tD</span><span class=\"invisible\">ElY3qrZSZ920G</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "开发模式", 
                    "tagLink": "https://api.zhihu.com/topics/19822796"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "PHP 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19581970"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45596619", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "数据结构？是一个又爱又恨的存在！", 
            "content": "<p>数据结构？是一个又爱又恨的存在，不喜欢它的人认为枯燥，乏味，头大。但是喜欢它的人就恰恰相反，小梦也是属于不喜欢之列。如果你把编程看做是一项练就功夫的事情，那么数据结构就是内功，相信很多小伙伴内心多多少少都有一个武侠梦</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-606e1bccbe208549f2683fb939ae45c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"569\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;569&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"569\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic1.zhimg.com/v2-606e1bccbe208549f2683fb939ae45c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>单链表官方定义：单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象)  +  指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。（这不是我说的，是官方说的，但是估计你们看了想骂人）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d2ab031f8f01903b0e02f8ec8986657f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic4.zhimg.com/v2-d2ab031f8f01903b0e02f8ec8986657f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>下面的示例图就是单链表了，尾部指针是一个null，中间部分通过指针相连接</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8ba76af04b527f1d6768166cb6580fb8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8ba76af04b527f1d6768166cb6580fb8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;195&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"195\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-8ba76af04b527f1d6768166cb6580fb8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8ba76af04b527f1d6768166cb6580fb8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们就是用php来模拟一下单链表：上代码-&gt;</p><p>参数说明：以下方法head表示一个链表，hero表示一个英雄的对象，num表示英雄的编号，下方代码将不再重复</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-577add1c6a1025777ce5680af5452cfb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"582\" data-original=\"https://pic4.zhimg.com/v2-577add1c6a1025777ce5680af5452cfb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"582\" data-original=\"https://pic4.zhimg.com/v2-577add1c6a1025777ce5680af5452cfb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-577add1c6a1025777ce5680af5452cfb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4c27d3769fbeb943b6f1391eae0c9134_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic1.zhimg.com/v2-4c27d3769fbeb943b6f1391eae0c9134_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic1.zhimg.com/v2-4c27d3769fbeb943b6f1391eae0c9134_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4c27d3769fbeb943b6f1391eae0c9134_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面代码是我们简单的模拟了一下使用PHP语言怎么去实现单链表，当然上面的方法很笨，我们稍微改造一下</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4b687e3d5563470b0b2d721bf9648057_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"158\" data-rawheight=\"120\" class=\"content_image\" width=\"158\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;158&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"158\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"158\" data-actualsrc=\"https://pic4.zhimg.com/v2-4b687e3d5563470b0b2d721bf9648057_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed3a1adde7617d693c617546476f177a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed3a1adde7617d693c617546476f177a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed3a1adde7617d693c617546476f177a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed3a1adde7617d693c617546476f177a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-52ead588d19edf62607f711c25d12c8a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-52ead588d19edf62607f711c25d12c8a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-52ead588d19edf62607f711c25d12c8a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-52ead588d19edf62607f711c25d12c8a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0ee7ac49dc5de980b038b1767ba9b8a1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0ee7ac49dc5de980b038b1767ba9b8a1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-0ee7ac49dc5de980b038b1767ba9b8a1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0ee7ac49dc5de980b038b1767ba9b8a1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cd849a453fe00dc75748c0536f5467ab_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-cd849a453fe00dc75748c0536f5467ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-cd849a453fe00dc75748c0536f5467ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cd849a453fe00dc75748c0536f5467ab_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-779822ab78b981b8d802d5afc911b9e6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-779822ab78b981b8d802d5afc911b9e6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-779822ab78b981b8d802d5afc911b9e6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-779822ab78b981b8d802d5afc911b9e6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>以下就是上方代码的测试代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed4bdd0ee2a4ec7c4584c8f7308ce956_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed4bdd0ee2a4ec7c4584c8f7308ce956_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;321&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"321\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-ed4bdd0ee2a4ec7c4584c8f7308ce956_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed4bdd0ee2a4ec7c4584c8f7308ce956_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.jpg\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.jpg\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.gif\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;850&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/FDji_tDElY3qrZSZ920G\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/FDji_tD</span><span class=\"invisible\">ElY3qrZSZ920G</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "计算机基础", 
                    "tagLink": "https://api.zhihu.com/topics/19595749"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45596537", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 2, 
            "title": "回答阿里云websocket配置问题", 
            "content": "<p>websocket是一种协议，一种实现了客户端和服务器全双工通信的协议，使得服务器能够主动发送信息给客户端成为现实（轮询除外）！<br/>但是当小伙伴们使用阿里云作为服务器在配置websocket的时候，客户端一直处于连接不成功的状态，反复检查代码没有问题，但是就是死活连接不上，其实是阿里云的配置有问题，接下来就教大家配置一下：<br/>新买的阿里云大家安装完相应的web环境之后满怀期待的输入网址之后却出现了连接超时的界面，那是因为我们没有配置安全组，也就是阿里云后台管理的地方有一个配置安全组的地方，需要我们将相应的需要的端口配置上去<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b5590b24dafe6315fbccc805ebecb3a7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"525\" class=\"content_image\" width=\"203\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;203&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"525\" class=\"content_image lazy\" width=\"203\" data-actualsrc=\"https://pic4.zhimg.com/v2-b5590b24dafe6315fbccc805ebecb3a7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bfaed10f5d3823adff8339987c463841_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-bfaed10f5d3823adff8339987c463841_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-bfaed10f5d3823adff8339987c463841_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bfaed10f5d3823adff8339987c463841_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-859c0bb06b537f09d2be12176db53c3b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-859c0bb06b537f09d2be12176db53c3b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-859c0bb06b537f09d2be12176db53c3b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-859c0bb06b537f09d2be12176db53c3b_b.jpg\"/></figure><p><br/>添加完毕之后就需要防火墙配置了：<br/>1、开启防火墙<br/>systemctl start firewalld<br/>2、设置打开的端口号（永久打开）<br/>firewall-cmd --add-port=8000/tcp --permanent<br/>3、更新一下：在设置好端口后，需要执行<br/>firewall-cmd --reload<br/>4、查看已经打开的端口<br/>firewall-cmd --list-all<br/>配置以上这些之后，代码的书写方面也要注意一些：<br/>（1）首先是客户端：<br/>ws = new WebSocket(&#34;ws://47.97.108.xx:8000&#34;);//连接服务器，公网ip<br/>（2）服务端：<br/>我们就写0.0.0.0也就是你在安全组配置的内网ip，依据你输入的为准<br/>这样就完成了配置的修改，之后就能连接成功了！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;850&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/FDji_tDElY3qrZSZ920G\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/FDji_tD</span><span class=\"invisible\">ElY3qrZSZ920G</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "阿里云", 
                    "tagLink": "https://api.zhihu.com/topics/19560108"
                }, 
                {
                    "tag": "WebSocket", 
                    "tagLink": "https://api.zhihu.com/topics/19657811"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45596494", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "一个查看框架源码，一个查找错误的小工具，你用了吗？", 
            "content": "<p>标题党？无疑了！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-745f5458d07e8f587fd52235d02525ff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"120\" data-rawheight=\"97\" class=\"content_image\" width=\"120\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;120&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"120\" data-rawheight=\"97\" class=\"content_image lazy\" width=\"120\" data-actualsrc=\"https://pic4.zhimg.com/v2-745f5458d07e8f587fd52235d02525ff_b.jpg\"/></figure><p><br/>日常开发中还在一直var_dump?exit()?，是不是很不便捷，很不方便？今天小梦就给大家讲讲在<b>PHP开发中（划重点：PHP开发，当然其他语言开发也是有类似的工具的，比如前端开发，浏览器自带debug，还有开发java的ide编辑器）</b>排错的小工具和帮助我们更好的阅读源码（程序执行流程）<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7bbd3b7480a84f9aa6c1c20ce3f15946_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic3.zhimg.com/v2-7bbd3b7480a84f9aa6c1c20ce3f15946_b.jpg\"/></figure><p><br/>今天给大家讲解的就是在使用开发PHP的ide编辑器里面安装xdebug这个小工具了，听到这里很多小伙伴已经知道了文章的主题，有些人已经悄悄拿起了搬砖，有些人已经悄悄放下了板砖，但是我还是要讲，因为还是有很多小伙伴安装过程中出现这样那样的错误导致迟迟不能安装成功，进而放弃了！<br/>首先需要的工具：Phpstorm（版本随意）/PHP本地/线上（不推荐线上）开发环境/PHP框架一枚（本文选ThinkPHP5）/firefox浏览器一个<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-be55e8d652a7f3773e6c9d349ba75ec0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-be55e8d652a7f3773e6c9d349ba75ec0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-be55e8d652a7f3773e6c9d349ba75ec0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-be55e8d652a7f3773e6c9d349ba75ec0_b.jpg\"/></figure><p><br/>具体操作步骤如下：<br/>1、首先去下载一个xdebug.dell的扩展（当然现在很多的php集成环境都已经有了这个扩展，如果没有，可以直接联系小梦，咱们一对一教你怎么安装扩展，保证一次包治以后所有扩展安装）<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-bb4af115eacf64f29c2752db7f144890_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic1.zhimg.com/v2-bb4af115eacf64f29c2752db7f144890_b.jpg\"/></figure><p><br/>2、php.ini（php的配置文件，这个如果不知道在哪里，不会配置，请回第一步查看后段话）<br/>[xdebug]<br/>zend_extension =&#34;php_xdebug.dll&#34; //扩展地址<br/>xdebug.idekey=&#34;PHPSTORM&#34; //ide的配置和浏览器的配置，后面我再告诉你<br/>xdebug.remote_handler = &#34;dbgp&#34;<br/>xdebug.remote_mode = &#34;req&#34;<br/>xdebug.remote_host=127.0.0.1<br/>xdebug.remote_enable=on<br/>xdebug.remote_port = 9000<br/>xdebug.remote_autostart = no<br/>这个是配置xdebug的选项，然后idekey是你的ide的key，要和你的ide保持一致<br/>使用phpinfo.php查看是否已经被安装成功<br/>3、Phpstorm登场了<br/>打开phpStorm，进入File&gt;Settings&gt;PHP（文件-设置-语言和框架-php），这里要interpreter浏览，自动识别版本（一般会有问题，还是要自己选择）。（或者你自己选wamp/或者你自己的本地php环境、下面php里面的php.exe）<br/>（1）配置客户端的一些操作<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1c77a58d8e8bbdc340a46a8b077c9dd3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1c77a58d8e8bbdc340a46a8b077c9dd3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-1c77a58d8e8bbdc340a46a8b077c9dd3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1c77a58d8e8bbdc340a46a8b077c9dd3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ee7362ee3dbda5bc8ee50fb6c83e9978_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"532\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-ee7362ee3dbda5bc8ee50fb6c83e9978_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;532&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"532\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-ee7362ee3dbda5bc8ee50fb6c83e9978_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ee7362ee3dbda5bc8ee50fb6c83e9978_b.jpg\"/></figure><p><br/>（2）配置服务器端的一些操作<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fa80cb6362732465d29b9503860a5604_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-fa80cb6362732465d29b9503860a5604_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-fa80cb6362732465d29b9503860a5604_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fa80cb6362732465d29b9503860a5604_b.jpg\"/></figure><p><br/>（3）配置端口号9000端口，是不是很熟悉，对就是PHP的执行端口<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3569b480c2404988ef2e7f85a513753b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-3569b480c2404988ef2e7f85a513753b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-3569b480c2404988ef2e7f85a513753b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3569b480c2404988ef2e7f85a513753b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-20e4d171d1a7ac389eeb617b885bd5d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-20e4d171d1a7ac389eeb617b885bd5d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;429&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-20e4d171d1a7ac389eeb617b885bd5d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-20e4d171d1a7ac389eeb617b885bd5d4_b.jpg\"/></figure><p><br/>（4）接下来再一次返回配置Phpstorm<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-12f69ea005db3e3da49387f32dda7d33_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-12f69ea005db3e3da49387f32dda7d33_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;169&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic4.zhimg.com/v2-12f69ea005db3e3da49387f32dda7d33_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-12f69ea005db3e3da49387f32dda7d33_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bc22357002d91d4c593f3033aeb62845_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-bc22357002d91d4c593f3033aeb62845_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;415&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"415\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-bc22357002d91d4c593f3033aeb62845_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-bc22357002d91d4c593f3033aeb62845_b.jpg\"/></figure><p><br/>（5）安装火狐浏览器的插件（这里就不介绍怎么安装了）<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8b93f996327be1da2c2450391e94afbe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic3.zhimg.com/v2-8b93f996327be1da2c2450391e94afbe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic3.zhimg.com/v2-8b93f996327be1da2c2450391e94afbe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8b93f996327be1da2c2450391e94afbe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ebbddf0b455a5299f10e0659a00d12f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"51\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic2.zhimg.com/v2-ebbddf0b455a5299f10e0659a00d12f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;51&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"51\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic2.zhimg.com/v2-ebbddf0b455a5299f10e0659a00d12f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ebbddf0b455a5299f10e0659a00d12f5_b.jpg\"/></figure><p><br/>以上我们就安装完成了Xdebug这个调试器，然后接下来我们就去看看怎么使用<br/>（1）我们进入我们编写的代码<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4a10beaa6d9bc335e03cb3e4bf2f3da7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-4a10beaa6d9bc335e03cb3e4bf2f3da7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;223&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"223\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-4a10beaa6d9bc335e03cb3e4bf2f3da7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4a10beaa6d9bc335e03cb3e4bf2f3da7_b.jpg\"/></figure><p><br/>（2）打开浏览器输入我们的项目访问url<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f1108b8a4e9cdf2771d6f8452ed04be8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-f1108b8a4e9cdf2771d6f8452ed04be8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-f1108b8a4e9cdf2771d6f8452ed04be8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f1108b8a4e9cdf2771d6f8452ed04be8_b.jpg\"/></figure><p><br/>（3）打开（会默认自动跳转）我们的ide<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-81e1cdaea8efdcc19ca1e1245ff7404f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-81e1cdaea8efdcc19ca1e1245ff7404f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-81e1cdaea8efdcc19ca1e1245ff7404f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-81e1cdaea8efdcc19ca1e1245ff7404f_b.jpg\"/></figure><p><br/>这样我们就算是已经完成了安装了<br/>如果我们想阅读框架源码或者查看代码的执行流程那么我们这样操作<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ffad82b22f25501093edb0d0571719d0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb\" width=\"608\" data-original=\"https://pic1.zhimg.com/v2-ffad82b22f25501093edb0d0571719d0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;608&#39; height=&#39;604&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"608\" data-original=\"https://pic1.zhimg.com/v2-ffad82b22f25501093edb0d0571719d0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ffad82b22f25501093edb0d0571719d0_b.jpg\"/></figure><p><br/>以上就是全部内容了，感觉大家的观看</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1700&#39; height=&#39;850&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1700\" data-rawheight=\"850\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1700\" data-original=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-870701bed62983f346b067dd58ec8f05_b.jpg\"/></figure><p><a href=\"https://link.zhihu.com/?target=http%3A//weixin.qq.com/r/FDji_tDElY3qrZSZ920G\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">weixin.qq.com/r/FDji_tD</span><span class=\"invisible\">ElY3qrZSZ920G</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p></p>", 
            "topic": [
                {
                    "tag": "源代码", 
                    "tagLink": "https://api.zhihu.com/topics/19569491"
                }, 
                {
                    "tag": "开源项目", 
                    "tagLink": "https://api.zhihu.com/topics/19565961"
                }, 
                {
                    "tag": "开源", 
                    "tagLink": "https://api.zhihu.com/topics/19562746"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44798784", 
            "userName": "软件测试君", 
            "userLink": "https://www.zhihu.com/people/83ce9995dcd04b7715614d26ead57869", 
            "upvote": 0, 
            "title": "Selenium+Java自动化之如何优雅绕过验证码", 
            "content": "<p><b>前言</b></p><p>验证码问题对于每个ui自动化的同学而言，相信都是个蛋疼的问题，对于验证码的处理我个人不提倡破解，不要去想破解方法，这个验证码本来就是为了防止别人自动化登录的。如果你们公司的验证码很容易被你破解了，那么只能说你们公司验证码级别不高，去建议开发提高验证码级别了。</p><p>对于验证码，要么是让开发把验证码写死（传说中的万能验证码），如：1234，要么就是低调的尽量绕过去。</p><p>下面本文来介绍下如何绕过下图验证码，进入博客园</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5dadb7de68853a42416cde82851db76e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-5dadb7de68853a42416cde82851db76e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-5dadb7de68853a42416cde82851db76e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5dadb7de68853a42416cde82851db76e_b.jpg\"/></figure><p><b>工具</b></p><ul><li>Fiddler.exe</li><li>IDEA/Eclipse</li><li>selenium的cookie操作</li></ul><p><b>一、使用Fiddler抓包</b></p><p>1.一般登陆网站成功后，会生成一个已登录状态的cookie，那么只需要直接把这个值拿到，用selenium进行addCookie操作即可。</p><p>2.可以先手动登录一次，然后抓取这个cookie，这里我们就需要用抓包工具fiddler了</p><p>3.先打开博客园登录界面，手动输入账号和密码（不要点登录按钮）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-29353c2a11eb469fbd605acd8f107e58_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb\" width=\"912\" data-original=\"https://pic1.zhimg.com/v2-29353c2a11eb469fbd605acd8f107e58_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;912&#39; height=&#39;518&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"518\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"912\" data-original=\"https://pic1.zhimg.com/v2-29353c2a11eb469fbd605acd8f107e58_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-29353c2a11eb469fbd605acd8f107e58_b.jpg\"/></figure><p>4.打开fiddler抓包工具，此时再点博客园登录按钮</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9942a4c64c1cb65a10906cea58e64982_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-9942a4c64c1cb65a10906cea58e64982_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;429&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"429\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-9942a4c64c1cb65a10906cea58e64982_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9942a4c64c1cb65a10906cea58e64982_b.jpg\"/></figure><p>5.登录成功后，再查看cookie变化，发现多了两组参数，多的这两组参数就是我们想要的，copy出来，一会有用</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-700228678dcaedd3a26f72907143e68d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-700228678dcaedd3a26f72907143e68d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-700228678dcaedd3a26f72907143e68d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-700228678dcaedd3a26f72907143e68d_b.jpg\"/></figure><p><b>二、cookie操作</b></p><p>1.这里需要添加两个cookie，一个是.CNBlogsCookie，另外一个是.Cnblogs.AspNetCore.Cookies。</p><p>2.我这里打开的网页是博客园子的首页：<a href=\"https://link.zhihu.com/?target=https%3A//home.cnblogs.com/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">home.cnblogs.com/</span><span class=\"invisible\"></span></a>，没进入登录页。</p><p>3.添加cookie后刷新,接下来就是见证奇迹的时刻了。</p><p>4.关于cookie操作，有兴趣的同学可查看官方api</p><p>5.这里我们只使用addCookie这个接口的方法实现</p><p>Cookie cookie=new Cookie(&#34;key&#34;, &#34;value&#34;); driver.manage().addCookie(cookie);</p><p><b>三、参考代码</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package com.test.demo;\n\nimport org.openqa.selenium.Cookie;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.AfterClass;\n\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @author longrong.lang\n * 绕过验证码登陆\n */\npublic class LoginWithCookie {\n\n    WebDriver driver;\n\n    @BeforeClass\n    public void beforeClass() {\n        driver = new ChromeDriver();\n    }\n\n    @Test\n    public void testLoginWithCookie() {\n        driver.get(&#34;https://home.cnblogs.com/&#34;);\n        driver.manage().window().maximize();\n        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        //cookie遍历使用\n        Set&lt;Cookie&gt; cookies = driver.manage().getCookies();\n        for (Cookie cookie : cookies) {\n            System.out.println(cookie.getName() + &#34;\\t&#34; + cookie.getValue());\n        }\n        Cookie cookie = new Cookie(&#34;key&#34;, &#34;value&#34;);\n        //添加cookie操作\n        driver.manage().addCookie(cookie);\n        Cookie cookie1 = new Cookie(&#34;key&#34;, &#34;value&#34;);\n        driver.manage().addCookie(cookie1);\n        Cookie cookie2 = new Cookie(&#34;.key&#34;, &#34;value&#34;);\n        driver.manage().addCookie(cookie2);\n        Cookie cookie3 = new Cookie(&#34;key&#34;, &#34;value&#34;);\n        driver.manage().addCookie(cookie3);\n        driver.manage().window().maximize();\n        //下面是见证奇迹的时候了\n        driver.navigate().refresh();\n    }\n\n    @AfterClass\n    public void afterClass() {\n        //driver.quit();\n    }\n}</code></pre></div><p>效果图：<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f1d85ed3bba88ed0f83ae11b5079e092_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-f1d85ed3bba88ed0f83ae11b5079e092_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-f1d85ed3bba88ed0f83ae11b5079e092_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f1d85ed3bba88ed0f83ae11b5079e092_b.jpg\"/></figure><p>视频效果如下:</p><a class=\"video-box\" href=\"https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1025338632483287040\" target=\"_blank\" data-video-id=\"\" data-video-playable=\"true\" data-name=\"\" data-poster=\"https://pic3.zhimg.com/80/v2-0ea88d4b749cd42b9e348ac8dfa05d7a_b.jpg\" data-lens-id=\"1025338632483287040\"><img class=\"thumbnail\" src=\"https://pic3.zhimg.com/80/v2-0ea88d4b749cd42b9e348ac8dfa05d7a_b.jpg\"/><span class=\"content\"><span class=\"title\"><span class=\"z-ico-extern-gray\"></span><span class=\"z-ico-extern-blue\"></span></span><span class=\"url\"><span class=\"z-ico-video\"></span>https://www.zhihu.com/video/1025338632483287040</span></span></a><p><b>有几点需要注意：</b></p><p>1.登录时候要勾选下次自动登录按钮。</p><p>2.addCookie（）只添加name和value，对于博客园的登录是不成功。</p><p>3.本方法并不适合所有的网站，一般像博客园这种记住登录状态的才会适合。</p><p>4.学习过程中有遇到疑问的，可以加QQ群交流:631646987</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ec9d3e7f95a22917c70d9c56c1f0479f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"32\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-ec9d3e7f95a22917c70d9c56c1f0479f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;32&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"32\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-ec9d3e7f95a22917c70d9c56c1f0479f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ec9d3e7f95a22917c70d9c56c1f0479f_b.jpg\"/></figure><blockquote>作者：脑洞大大的吃货狮子座，喜欢专研技术，勤于总结归纳,用文字结交朋友，擅长与生活相爱相杀，乐于分享的一个技术狂人。</blockquote><p>欢迎关注个人公众号：软 件 测 试 君，给我留言</p><figure data-size=\"small\"><noscript><img src=\"https://pic1.zhimg.com/v2-953ad4981f458c7efff909643f3e7a08_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1080\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-953ad4981f458c7efff909643f3e7a08_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1080&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"1080\" data-rawheight=\"1080\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-953ad4981f458c7efff909643f3e7a08_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-953ad4981f458c7efff909643f3e7a08_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "验证码", 
                    "tagLink": "https://api.zhihu.com/topics/19560490"
                }, 
                {
                    "tag": "Selenium", 
                    "tagLink": "https://api.zhihu.com/topics/19574589"
                }, 
                {
                    "tag": "自动化测试", 
                    "tagLink": "https://api.zhihu.com/topics/19574587"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45426682", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "这些Mysql基础设计思路以及优化思路我都给你总结好了", 
            "content": "<p>1、定长和不定长要区分开</p><p>2、不常用的列和常用的列分开存</p><p>3、增加冗余，反范式化</p><p>4、btree索引，就是用树形结构存储在磁盘上，其中操作是用2分发，找一个中间点，然后把大比这个大的分在一边，小的放在一边，然后当你查询的时候，从数字头开始，大小分开找，这个适合区间查找，不适合一个一个找</p><p>5、hash索引，就是当你存储在硬盘的数据，先给你一个地址，然后你下次来找的时候直接用那个地址找到那个值，这个适合一个值的查找，不适合区间查询，比如where id=1这种</p><p>6、（1）limit 的优化，能用业务逻辑解决的就用业务逻辑解决（比如百度的搜索只是显示76页）</p><p> （2）往索引上靠，比如id&gt;1100这种，你用到了id的hash主键索引（默认）</p><p> （3）inner join</p><p>7、数据库的索引都是以二叉树进行储存的，聚簇索引其实就是树的节点下面包含了这个节点的其他数据项，但是非聚簇索引只是一个标记，然后还要回行到磁盘去找到相应的数据项值，还要聚簇索引的二级索引只是一种引用，也就是二级索引下面存储的是一级索引的id，然后二级索引通过id去树上找到相应的数据项。</p><p>非聚簇索引比如myisam存储引擎，索引和数据是存在不同的地方。找找到索引然后再找到数据.</p><p>聚簇索引就是那个存储数据的节点，及包含索引，然后在索引下面还存有它相应的其他数据---innodb</p><p>8、索引会占据很大的磁盘空间，然后数据的变更也会操作索引</p><p>9、组合索引的核心思想是左半边原则，当你的最后一个条件产生like这种之后就会导致后面的用不到</p><p>select * from test where id = 1 and name = &#34;aa&#34; and text like &#34;%sss&#34; and desc = &#34;1&#34;;</p><p>就会导致你后面的desc就用不到了索引</p><p>10、hash的思想是跳出时间和空间复杂度，但是它需要一个散列度好的函数，空隙正好，然后还不能冲突</p><p>11、innodb即使你插入的数据是乱序的，但是你查出来之后还是整理好的顺序，因为它可以按照数的索引依次返回数据，这也是聚蔟索引的一个优势</p><p>固态硬盘支持随机读取，而不用像传统磁盘那样按照顺序转圈的读取</p>", 
            "topic": [
                {
                    "tag": "SQL", 
                    "tagLink": "https://api.zhihu.com/topics/19553557"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "MySQL DBA", 
                    "tagLink": "https://api.zhihu.com/topics/20075899"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45195174", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "PHP面试常考易错题之变量作用域解析", 
            "content": "<h2>living example one</h2><div class=\"highlight\"><pre><code class=\"language-text\">$A=&#34;Hello &#34;;                 \nfunctionprint_A()              \n{\n $A = &#34;phpmysql !!&#34;;\nglobal $A;                                               \n//global    全局变量         函数是独立的模块                  $A外界定义的\necho $A;\n}\necho $A;  //output Hello\nprint_A(); //out pot Hello \n在你将$A定义为全局变量的时候，并未修改$A的值</code></pre></div><p>考点：<br/>局部变量和全局变量的作用域，函数外部变量为全局变量（本页面以及引入页面），函数内部变量为局部变量</p><p>易错点：<br/>答题者区分不清局部变量和全局变量的概念，导致不能准确写出函数输出结果</p><p>分析：</p><p>1）局部变量只能在函数内部产生作用以及被使用，无论外部怎么修改都将失效，这样也就保证了我们在同一个页<br/>面定义相同名称的变量时候不会出现异常</p><p>2）全局适用于多个函数以及多个页面都需要用到时可声明，这样也就能节省内存空间，但是应用时重复定义被覆<br/>盖导致异常的问题也要注意</p><h2>living example two</h2><div class=\"highlight\"><pre><code class=\"language-text\">function test(){\n    $num = 10;\n    echo $num;\n}\ntest();   //output 10\necho $num;  \n$num = $num+10;\necho $num;</code></pre></div><p>分析：<br/>以上代码会导致一个变量未定义的waring，我们尚且忽略</p><p>1）$num是一个局部变量，那么你在函数内部输出，并且调用函数方法时候会输出10，但是无论你在外面怎么操作<br/>$num这个变量两者都不是同一个变量，因此也不会产生实质性的效果</p>", 
            "topic": [
                {
                    "tag": "数学", 
                    "tagLink": "https://api.zhihu.com/topics/19554091"
                }, 
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "PHP 学习", 
                    "tagLink": "https://api.zhihu.com/topics/19626603"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44724100", 
            "userName": "四喜Clion", 
            "userLink": "https://www.zhihu.com/people/6a10f1af4d971e298ee9a49db84b86f9", 
            "upvote": 2, 
            "title": "PHP当中使用PDO连接操作的数据库", 
            "content": "<p><b>一、使用PDO的好处</b></p><p>1.一套代码可以操作多个数据库，更换数据库即可不用重新写代码</p><p>2.用pdo来操作数据库会高效率，并且执行速度快</p><p>3.安全性能较高</p><p><b>二、如何使用PDO类操作数据库（连接数据库、增删改查）</b></p><p><b>1.准备工作</b></p><p>开启php_pdo_mysql.dll扩展。</p><p>到php.ini中，找到下图中的代码，去掉前面的“;”，保存，重启Apache。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-22763ef23a757d57b31ff060978b4d5f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"54\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;54&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"54\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic4.zhimg.com/v2-22763ef23a757d57b31ff060978b4d5f_b.jpg\"/></figure><p><b>2.创建PDO对象，连接数据库</b></p><p>$pdo = new PDO();</p><p>在new一个PDO类的时候，需要传递dsn，dsn是数据源名称。表示连接数据库的一些信息，主要包括数据库类型、数据库主机、数据库名，也可以包含编码。</p><p>具体到dsn到手册，数据库抽象层--&gt;PDO--&gt;PDO驱动。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bbd0ff0ca2c9cecac076e68965048d93_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"538\" data-original=\"https://pic4.zhimg.com/v2-bbd0ff0ca2c9cecac076e68965048d93_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;538&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"538\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"538\" data-original=\"https://pic4.zhimg.com/v2-bbd0ff0ca2c9cecac076e68965048d93_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bbd0ff0ca2c9cecac076e68965048d93_b.jpg\"/></figure><p><b>连接MySQL数据库的案例：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6a83b2c6ee9c8a7c9bd2f796ab19b48c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1092\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb\" width=\"1092\" data-original=\"https://pic1.zhimg.com/v2-6a83b2c6ee9c8a7c9bd2f796ab19b48c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1092&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1092\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1092\" data-original=\"https://pic1.zhimg.com/v2-6a83b2c6ee9c8a7c9bd2f796ab19b48c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6a83b2c6ee9c8a7c9bd2f796ab19b48c_b.jpg\"/></figure><p><b>3.添加数据</b></p><p>添加成功返回新添加数据的id</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ad96c27f48706d2a329ade3b050883a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"974\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"974\" data-original=\"https://pic1.zhimg.com/v2-ad96c27f48706d2a329ade3b050883a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;974&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"974\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"974\" data-original=\"https://pic1.zhimg.com/v2-ad96c27f48706d2a329ade3b050883a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ad96c27f48706d2a329ade3b050883a4_b.jpg\"/></figure><p><b>4.删除和修改数据</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-095a5d10b53e3f18312207f6661957eb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"897\" data-original=\"https://pic4.zhimg.com/v2-095a5d10b53e3f18312207f6661957eb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;897&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"897\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"897\" data-original=\"https://pic4.zhimg.com/v2-095a5d10b53e3f18312207f6661957eb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-095a5d10b53e3f18312207f6661957eb_b.jpg\"/></figure><p><b>5.查询数据</b></p><p>（1）查询所有行</p><p>使用的是PDO类中的query的方法来查询</p><p>调用query的结果：</p><p>下面来演示一下PDOStatement和PDO的关系：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-005ec74c6e0e33c98632a5dffabc9506_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb\" width=\"884\" data-original=\"https://pic3.zhimg.com/v2-005ec74c6e0e33c98632a5dffabc9506_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;884&#39; height=&#39;464&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"884\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"884\" data-original=\"https://pic3.zhimg.com/v2-005ec74c6e0e33c98632a5dffabc9506_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-005ec74c6e0e33c98632a5dffabc9506_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>真是的PDO和PDOStatement对象的关系：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ad8c4a429d374c8b6241eaf14e11a0fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb\" width=\"834\" data-original=\"https://pic3.zhimg.com/v2-ad8c4a429d374c8b6241eaf14e11a0fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;834&#39; height=&#39;323&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"834\" data-original=\"https://pic3.zhimg.com/v2-ad8c4a429d374c8b6241eaf14e11a0fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ad8c4a429d374c8b6241eaf14e11a0fe_b.jpg\"/></figure><p>具体查询所有行的代码：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-929bc91268d9519e17760b8d7538a42f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"930\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb\" width=\"930\" data-original=\"https://pic4.zhimg.com/v2-929bc91268d9519e17760b8d7538a42f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;930&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"930\" data-rawheight=\"508\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"930\" data-original=\"https://pic4.zhimg.com/v2-929bc91268d9519e17760b8d7538a42f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-929bc91268d9519e17760b8d7538a42f_b.jpg\"/></figure><p>默认查询的结果，类似于使用mysql_fetch_array()得到的结果。是一个二维数组。也可以通过指定fetchAll的参数，来改变结果的格式。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a19d493402c42c358e7585e1c5e13743_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1019\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb\" width=\"1019\" data-original=\"https://pic4.zhimg.com/v2-a19d493402c42c358e7585e1c5e13743_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1019&#39; height=&#39;487&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1019\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1019\" data-original=\"https://pic4.zhimg.com/v2-a19d493402c42c358e7585e1c5e13743_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a19d493402c42c358e7585e1c5e13743_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-063a64c7a0e2fcbac0cdf5d6036b8667_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb\" width=\"952\" data-original=\"https://pic4.zhimg.com/v2-063a64c7a0e2fcbac0cdf5d6036b8667_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;952&#39; height=&#39;434&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"952\" data-rawheight=\"434\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"952\" data-original=\"https://pic4.zhimg.com/v2-063a64c7a0e2fcbac0cdf5d6036b8667_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-063a64c7a0e2fcbac0cdf5d6036b8667_b.jpg\"/></figure><p>以上内容是结合黑马程序员的笔记总结的，如果有侵立马删。</p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": [
                {
                    "userName": "众生皆苦", 
                    "userLink": "https://www.zhihu.com/people/80cc6818bd2c70c80dc46acf777bfefc", 
                    "content": "<p>你是不是传说中的程序员鼓励师？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "四喜Clion", 
                            "userLink": "https://www.zhihu.com/people/6a10f1af4d971e298ee9a49db84b86f9", 
                            "content": "<p>我是你最可爱的小姐姐</p>", 
                            "likes": 0, 
                            "replyToAuthor": "众生皆苦"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44508926", 
            "userName": "四喜Clion", 
            "userLink": "https://www.zhihu.com/people/6a10f1af4d971e298ee9a49db84b86f9", 
            "upvote": 2, 
            "title": "Redis的介绍以及安装启动", 
            "content": "<h2>二、redis介绍</h2><h2>1、概述</h2><p>（1）Redis是Remote Dictionary Server(远程数据服务)的缩写.</p><p>由意大利人antirez(Salvatore Sanfilippo)开发的一款<b>内存</b>高速<b>缓存数据库</b></p><p>（2）该软件使用C语言编写，它的数据模型为key-value</p><p>（3）它支持存储的value类型很多，包括<b>string(字符串)</b>、hash(哈希)、<b>list(链表)</b>、<b>set(集合)、Zset(有序集合)</b>。</p><p>（4）为了保证效率数据都是<b>缓存在内存中</b>，它也可以周<b>期性</b>的把更新的数据<b>写入磁盘</b>或者把修改操作写入追加的记录文件。 </p><h2>2、特点</h2><p>1)高速读取数据(in-memory)</p><p>2)减轻数据库负担</p><p>3)有集合计算功能(优于普通数据库和同类别产品)</p><p>4)多种数据结构支持</p><h2>3、适合场合及其优势</h2><p>1)[Sort Set]排行榜应用，取top n操作，例如sina微博热门话题</p><p>2)[List]获得最新N个数据 或 某个分类的最新数据</p><p>3)计数器应用</p><p>4)[Set]sns(social network site)获得共同好友</p><p>5)[Set]防攻击系统(ip判断)等等</p><h2>4、与memcache比较说明</h2><p>redis与memcache比较</p><p>（1）数据类型:memcache支持的数据类型就是字符串，redis支持的数据类型有字符串，哈希，链表，集合，有序集合。</p><p>（2）持久化：memcache数据是存储到内存里面，一旦断电，或重启，则数据丢失。redis数据也是存储到内存里面的，但是可以持久化，周期性的把数据给保存到硬盘里面，导致重启，或断电不会丢失数据。</p><p>（3）数据量：memcahce一个键存储的数据最大是1M,而redis的一个键值，存储的最大数据量是1G的数据量。</p><h2>二、安装启动</h2><h2>1、安装软件</h2><h2>（1）下载软件，并上传到linux的服务器</h2><p><b>Redis的官方下载站是</b><a href=\"https://link.zhihu.com/?target=http%3A//redis.io/download\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">redis.io/download</span><span class=\"invisible\"></span></a></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fafa3daed3c8dc6610229aa478629fc3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb\" width=\"778\" data-original=\"https://pic4.zhimg.com/v2-fafa3daed3c8dc6610229aa478629fc3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;778&#39; height=&#39;307&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"307\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"778\" data-original=\"https://pic4.zhimg.com/v2-fafa3daed3c8dc6610229aa478629fc3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fafa3daed3c8dc6610229aa478629fc3_b.jpg\"/></figure><h2>（2）解压软件：</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8e7d3982449c0052e4cf217d6e7965a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb\" width=\"582\" data-original=\"https://pic3.zhimg.com/v2-8e7d3982449c0052e4cf217d6e7965a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;83&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"582\" data-original=\"https://pic3.zhimg.com/v2-8e7d3982449c0052e4cf217d6e7965a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8e7d3982449c0052e4cf217d6e7965a2_b.jpg\"/></figure><p>（3）进入解压的目录</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-491dac29bf68655457036d116370e6db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"42\" class=\"origin_image zh-lightbox-thumb\" width=\"859\" data-original=\"https://pic4.zhimg.com/v2-491dac29bf68655457036d116370e6db_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;859&#39; height=&#39;42&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"42\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"859\" data-original=\"https://pic4.zhimg.com/v2-491dac29bf68655457036d116370e6db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-491dac29bf68655457036d116370e6db_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-685540dd7cd8a3414805f85a60f6fe87_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-685540dd7cd8a3414805f85a60f6fe87_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;73&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-685540dd7cd8a3414805f85a60f6fe87_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-685540dd7cd8a3414805f85a60f6fe87_b.jpg\"/></figure><h2>（4）无需配置，直接编译</h2><p>   直接执行make</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-de6a926c1d1d1e57eceb899317a9fece_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"882\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb\" width=\"882\" data-original=\"https://pic3.zhimg.com/v2-de6a926c1d1d1e57eceb899317a9fece_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;882&#39; height=&#39;208&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"882\" data-rawheight=\"208\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"882\" data-original=\"https://pic3.zhimg.com/v2-de6a926c1d1d1e57eceb899317a9fece_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-de6a926c1d1d1e57eceb899317a9fece_b.jpg\"/></figure><p>（5）执行安装</p><p>注意：在安装的时候，制定安装目录</p><p>make PREFIX=/usr/local/redis  install</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a928431662cf7f4cd6537ebb03d67d2c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"838\" data-original=\"https://pic1.zhimg.com/v2-a928431662cf7f4cd6537ebb03d67d2c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;838&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"838\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"838\" data-original=\"https://pic1.zhimg.com/v2-a928431662cf7f4cd6537ebb03d67d2c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a928431662cf7f4cd6537ebb03d67d2c_b.jpg\"/></figure><p>安装完成后，会在redis的 安装目录下面创建一个bin目录，该目录里面有5个文件。</p><p>redis-benchmark命令性能测试命令</p><p>redis-check-aof和redis-check-dump是日志检测工具</p><p><b>redis-server是服务器端启动的命令。</b></p><p><b>redis-cli是客户端连接服务器的命令。</b></p><h2>（6）复制配置文件</h2><p><b>从 redis的解压目录里面把redis.conf配置文件复制到redis的安装目录下面。</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3951c1b0ab261ccb855f563d9397ec1a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"767\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb\" width=\"767\" data-original=\"https://pic3.zhimg.com/v2-3951c1b0ab261ccb855f563d9397ec1a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;767&#39; height=&#39;71&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"767\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"767\" data-original=\"https://pic3.zhimg.com/v2-3951c1b0ab261ccb855f563d9397ec1a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3951c1b0ab261ccb855f563d9397ec1a_b.jpg\"/></figure><h2>2、启动</h2><h2>（1）使用vim打开配置文件redis.conf,修改如下参数：</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-dcd2884749adbb4c82adc25acc7c619c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"748\" data-original=\"https://pic1.zhimg.com/v2-dcd2884749adbb4c82adc25acc7c619c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;748&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"748\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"748\" data-original=\"https://pic1.zhimg.com/v2-dcd2884749adbb4c82adc25acc7c619c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-dcd2884749adbb4c82adc25acc7c619c_b.jpg\"/></figure><h2>（2）启动redis服务</h2><p>语法：命令 配置文件</p><p><b>redis-server(路径)</b> redis.conf（路径）</p><p>注意：此处命令与配置文件，可以写相对路径或绝对路径。</p><p>比如使用绝对路径写法： /usr/local/redis/bin/redis-server /usr/local/redis/redis.conf</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3bce243a0b4916529527e3b5a6e41744_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-3bce243a0b4916529527e3b5a6e41744_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;38&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"38\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic1.zhimg.com/v2-3bce243a0b4916529527e3b5a6e41744_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3bce243a0b4916529527e3b5a6e41744_b.jpg\"/></figure><p>查看是否启动成功：启动成功后，默认的端口是6379</p><p>netstat –tunpl | grep 6379</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b87842fedf0f448d6b30e72be56cfd70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1172\" data-rawheight=\"67\" class=\"origin_image zh-lightbox-thumb\" width=\"1172\" data-original=\"https://pic1.zhimg.com/v2-b87842fedf0f448d6b30e72be56cfd70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1172&#39; height=&#39;67&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1172\" data-rawheight=\"67\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1172\" data-original=\"https://pic1.zhimg.com/v2-b87842fedf0f448d6b30e72be56cfd70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b87842fedf0f448d6b30e72be56cfd70_b.jpg\"/></figure><h2>（3）客户端连接redis服务</h2><p>语法： redis-cli -h 主机ip -p端口号</p><p>如果是连接到本地，则直接输入连接命令即可。</p><p><b>redis-cli是客户端连接服务器的命令</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2ead27b6bdd2ec36c8afeeb6fa94830c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"64\" class=\"origin_image zh-lightbox-thumb\" width=\"855\" data-original=\"https://pic1.zhimg.com/v2-2ead27b6bdd2ec36c8afeeb6fa94830c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;855&#39; height=&#39;64&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"855\" data-rawheight=\"64\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"855\" data-original=\"https://pic1.zhimg.com/v2-2ead27b6bdd2ec36c8afeeb6fa94830c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2ead27b6bdd2ec36c8afeeb6fa94830c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-83d1ff25496f7e90f7c755eae37a2513_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"989\" data-original=\"https://pic4.zhimg.com/v2-83d1ff25496f7e90f7c755eae37a2513_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;989&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"989\" data-original=\"https://pic4.zhimg.com/v2-83d1ff25496f7e90f7c755eae37a2513_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-83d1ff25496f7e90f7c755eae37a2513_b.jpg\"/></figure><h2>（4）关闭redis的服务</h2><p>停止Redis实例 </p><p>我们可以使用/usr/local/redis/bin/redis-cli shutdown</p><p>也可以使用<b>pkill redis-server</b></p><p>killall redis-server</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-fc57eaa472709a2a2a53552e2b75b7c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"687\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb\" width=\"687\" data-original=\"https://pic1.zhimg.com/v2-fc57eaa472709a2a2a53552e2b75b7c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;687&#39; height=&#39;72&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"687\" data-rawheight=\"72\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"687\" data-original=\"https://pic1.zhimg.com/v2-fc57eaa472709a2a2a53552e2b75b7c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-fc57eaa472709a2a2a53552e2b75b7c4_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "分布式系统", 
                    "tagLink": "https://api.zhihu.com/topics/19570823"
                }, 
                {
                    "tag": "Memcached", 
                    "tagLink": "https://api.zhihu.com/topics/19577046"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44205251", 
            "userName": "绿帽佩奇", 
            "userLink": "https://www.zhihu.com/people/029f4ee06ae028e4c1d1a75fd7c13f64", 
            "upvote": 4, 
            "title": "成都Java培训常见问题汇总", 
            "content": "<p>参加成都Java培训，这是很多人转行进入Java开发的一条捷径，但是Java培训是一种付费行为，每个人在选择培训之前肯定都有很多问题，诸如零基础能不能学、多大年龄不能学等等问题，今天小姐姐就来给大家一一解答。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-44a1c51d6d5699cfa2dca434f206a747_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-44a1c51d6d5699cfa2dca434f206a747_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;719&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"719\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic4.zhimg.com/v2-44a1c51d6d5699cfa2dca434f206a747_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-44a1c51d6d5699cfa2dca434f206a747_b.jpg\"/></figure><p><b>一、零基础能不能学Java</b></p><p>成都Java培训机构中的学生主要分为两种：一种是零基础，一种是有基础。可以明确告诉你，培训机构零基础学Java的很多，只是零基础的学员在Java基础部分学起来会相对吃力，相应的学习时间会更长，所以学费也会贵一些。而如果你是有基础的，那么可以在之前的基础上深入学习，能够节约时间和学费。当然，这种有基础可以高起点学习并不是每个Java培训机构都开设的，大家在选择机构时需要注意。</p><p><b>二、年龄问题</b></p><p>以小姐姐的行业经验可以告诉你，18-30岁学Java的学员占90%。正常来说学Java没有任何年龄限制，各种年龄层次的人都可以学，但是成都Java培训机构主要是职业培训，为企业输送Java工程师，培训的目的是为了让同学们找好工作，如果年龄过小，初中生、高中生是不合适的，他们综合知识，学习能力有限，不能很好的掌握Java技术，并且企业招聘有年龄要求，至少十八周岁。如果年龄过大也不适合参加成都Java培训，IT工程师是一个年轻群体，阿里、腾讯这样的大企业开发工程师的平均年龄不超过三十岁，不建议三十以上的人转行参加培训，如果是职业Java工程师在职提升是没有年龄限制的。</p><p><b>三、经济问题</b></p><p>成都Java培训机构以脱产教学为主，培训周期为四到六个月，在这段时间内只有学习Java这一件事情，不能工作，不能赚外快，基本上是没有任何收入的，不仅没有收入，还需承担一万多的学费和几个月的生活费，对一些同学来说有一定的经济负担，如果学费不够，培训机构会提供助学贷款解决学费问题，生活费还是需要自行解决，一切要提前做好准备，以防在培训过程中因经济问题影响学习。当然，在考虑Java培训学费问题时，也应该看下他的收益，目前，本专科学生培训出来，薪资一般6K左右，学得好的或者有工作经验的月薪一万不是什么问题，正常情况下，2-3个月的工资就把学费赚回来了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6ab19d60ebb44be3f7af4a35cd86fe04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb\" width=\"928\" data-original=\"https://pic1.zhimg.com/v2-6ab19d60ebb44be3f7af4a35cd86fe04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;928&#39; height=&#39;591&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"928\" data-rawheight=\"591\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"928\" data-original=\"https://pic1.zhimg.com/v2-6ab19d60ebb44be3f7af4a35cd86fe04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6ab19d60ebb44be3f7af4a35cd86fe04_b.jpg\"/></figure><p><b>四、学历问题</b></p><p>因为程序员薪资高，因此吸引很多人想要转行进入Java开发，而不少高中生也想要转行进入Java开发。但是小姐姐想要给大家泼一盆冷水，经验之谈，培训出去成功就业Java开发的都是高中以上学历，本专科学历者占90%。所以小姐姐建议大家转行Java开发的学历至少得是大专。</p><p>上述就是很多人在选择成都Java培训时关注较多的问题，小姐姐对这些问题进行整理解答，希望能够帮助大家选择到合适的成都Java培训机构。有不清楚的可以私信。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-41c248cb231a1e28224410fb26f21cd4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1053\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"1053\" data-original=\"https://pic1.zhimg.com/v2-41c248cb231a1e28224410fb26f21cd4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1053&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1053\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1053\" data-original=\"https://pic1.zhimg.com/v2-41c248cb231a1e28224410fb26f21cd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-41c248cb231a1e28224410fb26f21cd4_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "IT 培训", 
                    "tagLink": "https://api.zhihu.com/topics/19593700"
                }, 
                {
                    "tag": "软件开发", 
                    "tagLink": "https://api.zhihu.com/topics/19552332"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>非常赞同楼主的观点，忠恳，专业，对学员是一种负责任的态度，祝你们的路越走越宽！</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "绿帽佩奇", 
                            "userLink": "https://www.zhihu.com/people/029f4ee06ae028e4c1d1a75fd7c13f64", 
                            "content": "谢谢", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44144228", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 2, 
            "title": "一个查看框架源码，一个查找错误的小工具，你用了吗？", 
            "content": "<p>                                                       标题党？无疑了！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-87c4247a5b8316ec109d97d6ac47e836_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"120\" data-rawheight=\"97\" class=\"content_image\" width=\"120\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;120&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"120\" data-rawheight=\"97\" class=\"content_image lazy\" width=\"120\" data-actualsrc=\"https://pic3.zhimg.com/v2-87c4247a5b8316ec109d97d6ac47e836_b.jpg\"/></figure><p>　　日常开发中还在一直var_dump?exit()?，是不是很不便捷，很不方便？今天小梦就给大家讲讲在<b>PHP开发中（划重点：PHP开发，当然其他语言开发也是有类似的工具的，比如前端开发，浏览器自带debug，还有开发java的ide编辑器）</b>排错的小工具和帮助我们更好的阅读源码（程序执行流程）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f4ada9c0065911dbfc89356f1af7a2da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic3.zhimg.com/v2-f4ada9c0065911dbfc89356f1af7a2da_b.jpg\"/></figure><p>　　今天给大家讲解的就是在使用开发PHP的ide编辑器里面安装xdebug这个小工具了，听到这里很多小伙伴已经知道了文章的主题，有些人已经悄悄拿起了搬砖，有些人已经悄悄放下了板砖，但是我还是要讲，因为还是有很多小伙伴安装过程中出现这样那样的错误导致迟迟不能安装成功，进而放弃了！</p><p>　　首先需要的工具：Phpstorm（版本随意）/PHP本地/线上（不推荐线上）开发环境/PHP框架一枚（本文选ThinkPHP5）/firefox浏览器一个</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-89c55e7b871f53faf068d5e87003187e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-89c55e7b871f53faf068d5e87003187e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic3.zhimg.com/v2-89c55e7b871f53faf068d5e87003187e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-89c55e7b871f53faf068d5e87003187e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　具体操作步骤如下：</p><p>　　1、首先去下载一个xdebug.dell的扩展（当然现在很多的php集成环境都已经有了这个扩展，如果没有，可以直接联系小梦，咱们一对一教你怎么安装扩展，保证一次包治以后所有扩展安装）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.jpg\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.jpg\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-4113c0778bf932b34a465b0139ed27e7_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　2、php.ini（php的配置文件，这个如果不知道在哪里，不会配置，请回第一步查看后段话）</p><p>　　[xdebug]</p><p>　　zend_extension =&#34;php_xdebug.dll&#34; //扩展地址<br/></p><p>　　xdebug.idekey=&#34;PHPSTORM&#34; //ide的配置和浏览器的配置，后面我再告诉你<br/></p><p>　　xdebug.remote_handler = &#34;dbgp&#34;</p><p>　　xdebug.remote_mode = &#34;req&#34;</p><p>　　xdebug.remote_host=127.0.0.1</p><p>　　xdebug.remote_enable=on</p><p>　　xdebug.remote_port = 9000<br/></p><p>　　xdebug.remote_autostart = no</p><p>　　这个是配置xdebug的选项，然后idekey是你的ide的key，要和你的ide保持一致</p><p>　　使用phpinfo.php查看是否已经被安装成功</p><p>　　3、Phpstorm登场了</p><p>　　打开phpStorm，进入File&gt;Settings&gt;PHP（文件-设置-语言和框架-php），这里要interpreter浏览，自动识别版本（一般会有问题，还是要自己选择）。（或者你自己选wamp/或者你自己的本地php环境、下面php里面的php.exe）</p><p>　　（1）配置客户端的一些操作</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-060cd9b45224aadca696c543f8fd5882_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1036\" data-rawheight=\"710\" class=\"origin_image zh-lightbox-thumb\" width=\"1036\" data-original=\"https://pic3.zhimg.com/v2-060cd9b45224aadca696c543f8fd5882_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1036&#39; height=&#39;710&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1036\" data-rawheight=\"710\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1036\" data-original=\"https://pic3.zhimg.com/v2-060cd9b45224aadca696c543f8fd5882_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-060cd9b45224aadca696c543f8fd5882_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-51f84f1371bdc8fb083bfdd50ae39648_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb\" width=\"823\" data-original=\"https://pic1.zhimg.com/v2-51f84f1371bdc8fb083bfdd50ae39648_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;823&#39; height=&#39;684&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"823\" data-rawheight=\"684\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"823\" data-original=\"https://pic1.zhimg.com/v2-51f84f1371bdc8fb083bfdd50ae39648_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-51f84f1371bdc8fb083bfdd50ae39648_b.jpg\"/></figure><p>　　（2）配置服务器端的一些操作</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a79d096fc53f0f5b5dc27ec0bc4466bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1022\" data-rawheight=\"701\" class=\"origin_image zh-lightbox-thumb\" width=\"1022\" data-original=\"https://pic2.zhimg.com/v2-a79d096fc53f0f5b5dc27ec0bc4466bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1022&#39; height=&#39;701&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1022\" data-rawheight=\"701\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1022\" data-original=\"https://pic2.zhimg.com/v2-a79d096fc53f0f5b5dc27ec0bc4466bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a79d096fc53f0f5b5dc27ec0bc4466bd_b.jpg\"/></figure><p>　　（3）配置端口号9000端口，是不是很熟悉，对就是PHP的执行端口</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5c70d562db03c1bcb89319ae96b7737a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"679\" class=\"origin_image zh-lightbox-thumb\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-5c70d562db03c1bcb89319ae96b7737a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;998&#39; height=&#39;679&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"679\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-5c70d562db03c1bcb89319ae96b7737a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5c70d562db03c1bcb89319ae96b7737a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f8da5ba3c1a7c0434706a2e0aafccf01_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1016\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb\" width=\"1016\" data-original=\"https://pic2.zhimg.com/v2-f8da5ba3c1a7c0434706a2e0aafccf01_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1016&#39; height=&#39;682&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1016\" data-rawheight=\"682\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1016\" data-original=\"https://pic2.zhimg.com/v2-f8da5ba3c1a7c0434706a2e0aafccf01_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f8da5ba3c1a7c0434706a2e0aafccf01_b.jpg\"/></figure><p>　　（4）接下来再一次返回配置Phpstorm</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5501f24eb7f02d6c86abf988b4ed4a2a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-5501f24eb7f02d6c86abf988b4ed4a2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;169&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"650\" data-rawheight=\"169\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic3.zhimg.com/v2-5501f24eb7f02d6c86abf988b4ed4a2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5501f24eb7f02d6c86abf988b4ed4a2a_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a8a1bd8a080f8cbf056f8fb1f94b44cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1017\" data-rawheight=\"659\" class=\"origin_image zh-lightbox-thumb\" width=\"1017\" data-original=\"https://pic4.zhimg.com/v2-a8a1bd8a080f8cbf056f8fb1f94b44cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1017&#39; height=&#39;659&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1017\" data-rawheight=\"659\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1017\" data-original=\"https://pic4.zhimg.com/v2-a8a1bd8a080f8cbf056f8fb1f94b44cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a8a1bd8a080f8cbf056f8fb1f94b44cb_b.jpg\"/></figure><p>　　（5）安装火狐浏览器的插件（这里就不介绍怎么安装了）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e84f03deaced5eb7d2e2c8c59c18fc4c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-e84f03deaced5eb7d2e2c8c59c18fc4c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;609&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"609\" data-rawheight=\"248\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"609\" data-original=\"https://pic1.zhimg.com/v2-e84f03deaced5eb7d2e2c8c59c18fc4c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e84f03deaced5eb7d2e2c8c59c18fc4c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4574383d3545d907fee861ed56cfbc11_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-4574383d3545d907fee861ed56cfbc11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;76&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-4574383d3545d907fee861ed56cfbc11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4574383d3545d907fee861ed56cfbc11_b.jpg\"/></figure><p>　　以上我们就安装完成了Xdebug这个调试器，然后接下来我们就去看看怎么使用</p><p>　　（1）我们进入我们编写的代码</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7bb03af0d5487c3eadb268c3ccd8095e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-7bb03af0d5487c3eadb268c3ccd8095e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;377&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"377\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-7bb03af0d5487c3eadb268c3ccd8095e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7bb03af0d5487c3eadb268c3ccd8095e_b.jpg\"/></figure><p>　　（2）打开浏览器输入我们的项目访问url</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e99f9c1272698741078a4ac66dbbaa25_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-e99f9c1272698741078a4ac66dbbaa25_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;156&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-e99f9c1272698741078a4ac66dbbaa25_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e99f9c1272698741078a4ac66dbbaa25_b.jpg\"/></figure><p>　　（3）打开（会默认自动跳转）我们的ide</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ac1c45d20a4cdac05d6d95b4fbbd78e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"599\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-ac1c45d20a4cdac05d6d95b4fbbd78e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;599&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"599\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-ac1c45d20a4cdac05d6d95b4fbbd78e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ac1c45d20a4cdac05d6d95b4fbbd78e4_b.jpg\"/></figure><p>　　这样我们就算是已经完成了安装了</p><p>　　如果我们想阅读框架源码或者查看代码的执行流程那么我们这样操作</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-434f676b24ec669a013392ddf1ea50c3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb\" width=\"608\" data-original=\"https://pic4.zhimg.com/v2-434f676b24ec669a013392ddf1ea50c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;608&#39; height=&#39;604&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"608\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"608\" data-original=\"https://pic4.zhimg.com/v2-434f676b24ec669a013392ddf1ea50c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-434f676b24ec669a013392ddf1ea50c3_b.jpg\"/></figure><p>　　以上就是全部内容了，感觉大家的观看</p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "PHP 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19581970"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }
            ], 
            "comments": [
                {
                    "userName": "肖旺", 
                    "userLink": "https://www.zhihu.com/people/5292a398c1c04c6ef7da7c164c572836", 
                    "content": "没几个人在本地开发吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "刘柱", 
                            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
                            "content": "<p>额，有时候调试是需要在本地的  当然要看你项目的规模</p>", 
                            "likes": 0, 
                            "replyToAuthor": "肖旺"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/44144123", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "你的Api接口上锁了吗？", 
            "content": "<p>职责单一化，各司其职，后端只负责Api接口编写提供给各种不同类型的客户端去调用，但是客户端和服务器端调用是要有权限限制的，不能任何一个客户端都可以随便调用我们的接口（这里面的缘由相信大家都知道吧，当然我就默认你们都知道），再者我们都知道http是明文传输，被抓包可可以修改相应参数，当然如果你使用了https就相对安全了不少！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a4ecbca73779ce548f8862ff9736cdb9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-a4ecbca73779ce548f8862ff9736cdb9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　举一个很简单的栗子，微信的接口大家都调用过吧，当然肯定有没调用过的，没关系，没有调用过的人也是能明白我接下来要讲的事情：微信会有一个sign的签名，就是思梦php上面所说的权限认证机制了</p><p>　　下面思梦php给大家讲的只是其中的原理，我们可以根据所讲知识继续扩展，完善成为你自己的一套程序。</p><p>　　主要使用的工具：thinkphp5/PHP</p><p>　　（1）首先客户端和提供服务的服务器加密方式要一致AES、MD5都可以</p><p>　　（2）规定好参数</p><p>　　下面的程序是规定了三个参数：version（api的版本）、time（请求时间）、sign（加密好的签名）</p><p>　　当然这些参数我们可以根据你的实际代码业务而定，不一定设置一样，本次程序的参数是设置在header头里面进行传输，为了和body里面的业务参数区分开来，当然这里也可以不一致，根据你的业务而定</p><p>　　注意点：客户端和服务端时间不一致的问题，我们要在服务器提供一个时间的方法来验证时间的有效性</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b3818588d89b85b29a99773745160778_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"598\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"598\" data-original=\"https://pic1.zhimg.com/v2-b3818588d89b85b29a99773745160778_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;598&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"598\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"598\" data-original=\"https://pic1.zhimg.com/v2-b3818588d89b85b29a99773745160778_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b3818588d89b85b29a99773745160778_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　接下来就是我们在一个入口文件里面去定义一个验证的方法，保证我们接口的安全性</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e89cb49fbf2fd50790dc1e7cbe6ba15a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb\" width=\"794\" data-original=\"https://pic3.zhimg.com/v2-e89cb49fbf2fd50790dc1e7cbe6ba15a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;794&#39; height=&#39;439&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"439\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"794\" data-original=\"https://pic3.zhimg.com/v2-e89cb49fbf2fd50790dc1e7cbe6ba15a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e89cb49fbf2fd50790dc1e7cbe6ba15a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-90d66dc3f32e99e4eb354a7f67b8d327_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"623\" data-rawheight=\"176\" class=\"origin_image zh-lightbox-thumb\" width=\"623\" data-original=\"https://pic4.zhimg.com/v2-90d66dc3f32e99e4eb354a7f67b8d327_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;623&#39; height=&#39;176&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"623\" data-rawheight=\"176\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"623\" data-original=\"https://pic4.zhimg.com/v2-90d66dc3f32e99e4eb354a7f67b8d327_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-90d66dc3f32e99e4eb354a7f67b8d327_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>　　以上就是代码的示例：</p><p>　　（1）首先定义了一个BaseController</p><p>　　（2）定义一个构造方法，触发验证机制</p><p>　　（3）在验证方法里面获取header信息，进行加密验证，如果第一次方法将该sign作为键值缓存起来并设置有效期，保证请求的唯一性</p><p>　　（4）之后判断限制请求的时间，如果超时将抛弃此次请求</p><p>　　当然这是在http上面做的一些操作，如果使用了https已经相对安全多了！</p><p>　　以上只是一个抛砖引玉，小伙伴可以自己再去完善</p>", 
            "topic": [
                {
                    "tag": "Google API", 
                    "tagLink": "https://api.zhihu.com/topics/19604352"
                }, 
                {
                    "tag": "API", 
                    "tagLink": "https://api.zhihu.com/topics/19553051"
                }, 
                {
                    "tag": "地图 API", 
                    "tagLink": "https://api.zhihu.com/topics/19649765"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43622809", 
            "userName": "四喜Clion", 
            "userLink": "https://www.zhihu.com/people/6a10f1af4d971e298ee9a49db84b86f9", 
            "upvote": 1, 
            "title": "PHP从入门到高级你要掌握什么？", 
            "content": "<p>首先是PHP网页入门，为了可以满足企业前台建站要求，可以仿制任何的网站页面并且能够实现浏览器的兼容性，PC端与移动端兼容性。直到能够利用目前一线企业最流行的框架ThinkPHP。进行项目快速开发。可以实现主流后台常用的RBAC权限管理功能，代码管理，前台后台的交互，多表链接，数据分析，轮询技术，网站优化技术。你需要掌握什么？</p><p><b>1）Html（掌握）</b></p><p>html文本排版、表格和超级链接、表单和框架</p><p><b>2）CSS</b></p><p>css语法与属性、盒子模型、DIV+CSS布局</p><p><b>3）Html5+Css3（掌握）</b></p><p>html5、css3</p><p><b>4）Bootstrap（重点）</b></p><p>Bootstrap的布署、全局CSS样式、CSS组件</p><p><b>5）Javascript（重点）</b></p><p>JS简介、JS引入方式、JS语法、JS内置对象、BOM模型、DOM模型、事件编程</p><p><b>6）Jquery（重点）</b></p><p>jquery各种选择器、DOM与jquery对象、属性操作、事件操作、jquery特效、文档处理、jquery插件机制</p><p><b>7）PHP环境搭建（掌握）</b></p><p>静态网站与动态网站的区别、WEB程序的访问流程、搭建wamp环境、自定义环境搭建、搭建基于域名的虚拟主机、环境体验-安装discuz论坛</p><p><b>8）PHP核心（重点）</b></p><p>变量和常量、数据类型和运算符、流程控制、函数、文件包含、运算符、字符串、数组</p><p><b>9）Mysql基础（重点）</b></p><p>数据库的基本介绍基础 SQL操作、字符集、列类型与列属性、表关系、高级数据操作、mysql三大查询、数据的备份与还原、mysql用户权限管理、PHP操作Mysql</p><p><b>10）PHP典型技术（重点）</b><br/>http协议、表单传值、文件处理、会话技术、GD图像处理<br/><b>11)项目实战（掌握）</b><br/>bbs论坛后端实现</p><p><b>12）SVN（掌握）</b></p><p>SVN概述及安装、SVN使用详解、配置多仓库与权限控制、SVN服务器配置与管理、钩子程序</p><p><b>13）XML（熟悉）</b> </p><p>XML语法、SimpleXML,XPath、案例-在线词典      </p><p><b>14）Ajax（掌握）  </b></p><p>Ajax快速入门、Ajax对象、发送get、post请求、用XML、JSON传输数据、Ajax跨域请求、Ajax案例-分页，聊天室</p><p><b>15）ThinkPHP（重点）</b></p><p>ThinkPHP快速入门、ThinkPHP控制器、ThinkPHP视图、ThinkPHP模型、ThinkPHP实用项</p><p><b>16）Linux（重点）  </b></p><p>linux安装、shell使用、VI编辑器、用户、组、文件管理、Lamp环境搭建   </p><p><b>17）优化技术（重点）</b></p><p>数据库优化、Sphinx全文索引、Memcache、URL优化</p>", 
            "topic": [
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }, 
                {
                    "tag": "PHP 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052035"
                }, 
                {
                    "tag": "PHP 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19606711"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42274829", 
            "userName": "xtlsoft", 
            "userLink": "https://www.zhihu.com/people/f793ce90a1a3a095d983e84c20c8c459", 
            "upvote": 14, 
            "title": "用 PHP 花两小时自制脚本语言", 
            "content": "<p>用 PHP 花两小时自制脚本语言</p><h2>0. 初步</h2><p>用 PHP 写语言？ 啥？</p><p>相信大家会有这样的疑问，但是今天我就要和大家一起花两个小时使用 PHP 打造一个脚本语言。</p><p>当然这个脚本语言将会十分简单，将不会有很多特性。我们准备参考 Lisp 的语法，最终这个脚本语言将不会比一个模板引擎的实现复杂。</p><p>在实现时，我有一个原则：不使用正则。（用了正则就会变得更加简单）</p><h2>1. 解释器</h2><h2>1.1. 语法的简单介绍</h2><p>对，上来就是解释器，我们忽略掉了词法分析器。</p><p>虽然这么做不太符合惯例，但是也可以实现。并且会减轻工作量。</p><p>首先，我们来简单地看下语法：</p><div class=\"highlight\"><pre><code class=\"language-text\">#| 基本的调用 |#\n(do-some-function)\n#| 字面量用 [] 包裹 |#\n(some-function [&#34;Hello&#34;] [123])\n#| 字面量的 List 支持 |#\n(print [:&#34;Hello&#34;, 123, 345])\n#| 对 lazy-call 的支持 |#\n(@print [&#34;lazy&#34;])\n#| 对无参函数无括号地调用 |#\n(print some-function-without-arguments)</code></pre></div><p>对，在 AST 中，我们只有三种 Node 类型：<code>Root</code>, <code>Calling</code>, <code>Literal</code>。</p><p>想必大家也看出来这是纯函数式的了吧。</p><h2>1.2 对于代码的 clean</h2><p>为了方便解析，我们将实现一个统一的 <code>clean</code> 方法来清除注释、格式化空格。</p><p>废话不多说，直接上代码</p><div class=\"highlight\"><pre><code class=\"language-php\"><span class=\"cp\">&lt;?php</span>\n\n<span class=\"c1\">// 判断是否是空字符\n</span><span class=\"c1\"></span><span class=\"k\">function</span> <span class=\"nf\">isBlankCharacter</span><span class=\"p\">(</span><span class=\"nx\">string</span> <span class=\"nv\">$ch</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">bool</span> <span class=\"p\">{</span>\n    <span class=\"k\">static</span> <span class=\"nv\">$blanks</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39; &#39;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\t</span><span class=\"s2\">&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\n</span><span class=\"s2\">&#34;</span><span class=\"p\">,</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\r</span><span class=\"s2\">&#34;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">];</span> <span class=\"c1\">// 空字符列表\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"nx\">in_array</span><span class=\"p\">(</span><span class=\"nv\">$ch</span><span class=\"p\">,</span> <span class=\"nv\">$blanks</span><span class=\"p\">);</span> <span class=\"c1\">// 使用 in_array 检查\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"k\">function</span> <span class=\"nf\">clean</span><span class=\"p\">(</span><span class=\"nx\">string</span> <span class=\"nv\">$code</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span> <span class=\"p\">{</span>\n    <span class=\"nv\">$codeArr</span> <span class=\"o\">=</span> <span class=\"nx\">str_split</span><span class=\"p\">(</span><span class=\"nx\">trim</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">));</span> <span class=\"c1\">// 使用 str_split 转换为数组，并且进行 trim 。\n</span><span class=\"c1\"></span>    <span class=\"nv\">$quote</span> <span class=\"o\">=</span> <span class=\"k\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 定义一个 quote flag，标记前一个字符是不是空字符\n</span><span class=\"c1\"></span>    <span class=\"nv\">$flag</span> <span class=\"o\">=</span> <span class=\"k\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 定义一个 flag，判断是否在 [] 内（字面量内空字符无需清理）\n</span><span class=\"c1\"></span>    <span class=\"nv\">$rslt</span> <span class=\"o\">=</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">;</span> <span class=\"c1\">// 存储 clean 后结果\n</span><span class=\"c1\"></span>    <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"nv\">$codeArr</span> <span class=\"k\">as</span> <span class=\"nv\">$k</span><span class=\"o\">=&gt;</span><span class=\"nv\">$v</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 遍历 code 字符串\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;[&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"o\">@</span><span class=\"nv\">$codeArr</span><span class=\"p\">[</span><span class=\"nv\">$k</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\\\</span><span class=\"s2\">&#34;</span><span class=\"p\">))</span> <span class=\"nv\">$flag</span> <span class=\"o\">=</span> <span class=\"k\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 当为 [ 时，进入字面量，设置 flag 为 true\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;]&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"p\">(</span><span class=\"o\">@</span><span class=\"nv\">$codeArr</span><span class=\"p\">[</span><span class=\"nv\">$k</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">!=</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\\\</span><span class=\"s2\">&#34;</span><span class=\"p\">))</span> <span class=\"nv\">$flag</span> <span class=\"o\">=</span> <span class=\"k\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 当为 ] 时，结束字面量，设置 flag 为 false\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 当在字面量内时，无需判断空字符\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$flag</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$rslt</span> <span class=\"o\">.=</span> <span class=\"nv\">$v</span><span class=\"p\">;</span>\n            <span class=\"k\">continue</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$quote</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 当前一个字符是空字符，这个字符不是时，设置 quote 为 false。\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">isBlankCharacter</span><span class=\"p\">(</span><span class=\"nv\">$v</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                <span class=\"nv\">$quote</span> <span class=\"o\">=</span> <span class=\"k\">false</span><span class=\"p\">;</span>\n                <span class=\"nv\">$rslt</span> <span class=\"o\">.=</span> <span class=\"nv\">$v</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">isBlankCharacter</span><span class=\"p\">(</span><span class=\"nv\">$v</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 第一个空字符，格式化为空格，并且设置 quote\n</span><span class=\"c1\"></span>                <span class=\"nv\">$quote</span> <span class=\"o\">=</span> <span class=\"k\">true</span><span class=\"p\">;</span>\n                <span class=\"nv\">$rslt</span> <span class=\"o\">.=</span> <span class=\"s2\">&#34; &#34;</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"c1\">// 否则直接向后增加字符\n</span><span class=\"c1\"></span>                <span class=\"nv\">$rslt</span> <span class=\"o\">.=</span> <span class=\"nv\">$v</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nv\">$rslt</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 去除注释\n</span><span class=\"c1\"></span><span class=\"k\">function</span> <span class=\"nf\">parseComment</span><span class=\"p\">(</span><span class=\"nx\">string</span> <span class=\"nv\">$codeStr</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">string</span> <span class=\"p\">{</span>\n    <span class=\"nv\">$code</span> <span class=\"o\">=</span> <span class=\"nx\">str_split</span><span class=\"p\">(</span><span class=\"nv\">$codeStr</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 创建栈，支持嵌套注释用\n</span><span class=\"c1\"></span>    <span class=\"nv\">$commentStack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">\\SplStack</span><span class=\"p\">();</span>\n    <span class=\"nv\">$rslt</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;&#34;</span><span class=\"p\">;</span>\n    <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"nv\">$code</span> <span class=\"k\">as</span> <span class=\"nv\">$k</span><span class=\"o\">=&gt;</span><span class=\"nv\">$v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 是注释，压栈\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;#&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">@</span><span class=\"nv\">$code</span><span class=\"p\">[</span><span class=\"nv\">$k</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;|&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$commentStack</span><span class=\"o\">-&gt;</span><span class=\"na\">push</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">);</span>\n            <span class=\"k\">continue</span><span class=\"p\">;</span>\n        <span class=\"c1\">// 是结束注释\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;#&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nv\">$code</span><span class=\"p\">[</span><span class=\"nv\">$k</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;|&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 当栈空时，抛出异常（多了|#）\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$commentStack</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nx\">\\Pisp\\Exceptions\\ParseException</span><span class=\"p\">(</span><span class=\"s2\">&#34;Comment brackets not matched.&#34;</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n            <span class=\"c1\">// 从栈中 pop\n</span><span class=\"c1\"></span>            <span class=\"nv\">$commentStack</span><span class=\"o\">-&gt;</span><span class=\"na\">pop</span><span class=\"p\">();</span>\n            <span class=\"c1\">// 阻止执行\n</span><span class=\"c1\"></span>            <span class=\"k\">continue</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 栈中不空，在注释内\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nv\">$commentStack</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"k\">continue</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 写入结果\n</span><span class=\"c1\"></span>        <span class=\"nv\">$rslt</span> <span class=\"o\">.=</span> <span class=\"nv\">$v</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nv\">$rslt</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>1.3. 对于代码的类型判断</h2><p>判断是 Calling 或 Literal。</p><p>代码：</p><div class=\"highlight\"><pre><code class=\"language-php\"><span class=\"cp\">&lt;?php</span>\n\n<span class=\"c1\">// Node 是 AST 的 Node，马上会放出定义\n</span><span class=\"c1\"></span><span class=\"k\">function</span> <span class=\"nf\">doParse</span><span class=\"p\">(</span><span class=\"nx\">string</span> <span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"nx\">Node</span> <span class=\"nv\">$parentNode</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"nv\">$code</span> <span class=\"o\">=</span> <span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">cleanCode</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">);</span> <span class=\"c1\">// 清理代码\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$code</span> <span class=\"o\">===</span> <span class=\"s2\">&#34;&#34;</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 代码为空，不做处理\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// 通过括号特征判断是 Calling\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;(&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 去做 Calling 的 parse，下面会介绍\n</span><span class=\"c1\"></span>        <span class=\"nx\">doParseCalling</span><span class=\"p\">(</span><span class=\"nx\">str_split</span><span class=\"p\">(</span><span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)),</span> <span class=\"nv\">$parentNode</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 通过括号特征判断是 Literal\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;[&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"s1\">&#39;]&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 去做 Literal 的 parse，会介绍\n</span><span class=\"c1\"></span>        <span class=\"nx\">doParseLiteral</span><span class=\"p\">(</span><span class=\"nx\">str_split</span><span class=\"p\">(</span><span class=\"nx\">trim</span><span class=\"p\">(</span><span class=\"nx\">substr</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))),</span> <span class=\"nv\">$parentNode</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 或者是直接对无参函数的调用\n</span><span class=\"c1\"></span>    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nx\">str_replace</span><span class=\"p\">([</span><span class=\"s1\">&#39; &#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;(&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;[&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;]&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;;&#39;</span><span class=\"p\">],</span> <span class=\"p\">[</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">,</span> <span class=\"s1\">&#39;&#39;</span><span class=\"p\">],</span> <span class=\"nv\">$code</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"nv\">$code</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">doParseCalling</span><span class=\"p\">(</span><span class=\"nx\">str_split</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">),</span> <span class=\"nv\">$parentNode</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 否则抛出异常\n</span><span class=\"c1\"></span>        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"nx\">ParseException</span><span class=\"p\">(</span><span class=\"s2\">&#34;Parse error: unmatched brackets.&#34;</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>1.4. 定义 AST</h2><p>比较傻瓜，直接上代码：</p><div class=\"highlight\"><pre><code class=\"language-php\"><span class=\"cp\">&lt;?php</span>\n<span class=\"k\">class</span> <span class=\"nc\">Node</span> <span class=\"p\">{</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * The node&#39;s type.\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @var string\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"nv\">$type</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;expr&#34;</span><span class=\"p\">;</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * The name of the node.\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @var string\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"nv\">$name</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;collection&#34;</span><span class=\"p\">;</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * Children of it\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @var Node[]\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"nv\">$children</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * The parent of it\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @var Node\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"nv\">$parent</span> <span class=\"o\">=</span> <span class=\"k\">null</span><span class=\"p\">;</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * The node&#39;s data\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @var mixed\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"nv\">$data</span> <span class=\"o\">=</span> <span class=\"k\">null</span><span class=\"p\">;</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * Add a child\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @param Node $child\n</span><span class=\"sd\">     * @return self\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"k\">function</span> <span class=\"nf\">addChild</span><span class=\"p\">(</span><span class=\"nx\">Node</span> <span class=\"nv\">$child</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">Node</span> <span class=\"p\">{</span>\n        <span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">children</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"nv\">$child</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"nv\">$this</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"sd\">/**\n</span><span class=\"sd\">     * Set the data\n</span><span class=\"sd\">     *\n</span><span class=\"sd\">     * @param mixed $data\n</span><span class=\"sd\">     * @return self\n</span><span class=\"sd\">     */</span>\n    <span class=\"k\">public</span> <span class=\"k\">function</span> <span class=\"nf\">setData</span><span class=\"p\">(</span><span class=\"nv\">$data</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"nx\">Node</span> <span class=\"p\">{</span>\n        <span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">data</span> <span class=\"o\">=</span> <span class=\"nv\">$data</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"nv\">$this</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"p\">}</span>\n</code></pre></div><p>然后创建 CallingNode, LiteralNode 和 Root 继承 Node 即可。</p><h2>1.5. 解析 CallingNode</h2><p>详情说明看注释。</p><div class=\"highlight\"><pre><code class=\"language-php\"><span class=\"cp\">&lt;?php</span>\n\n<span class=\"c1\">// 解析 CallingNode 的函数\n</span><span class=\"c1\"></span><span class=\"k\">function</span> <span class=\"nf\">doParseCalling</span><span class=\"p\">(</span><span class=\"k\">array</span> <span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"nx\">Node</span> <span class=\"nv\">$parentNode</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 创建 CallingNode 节点\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">CallingNode</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 设置父节点\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span><span class=\"o\">-&gt;</span><span class=\"na\">parent</span> <span class=\"o\">=</span> <span class=\"nv\">$parentNode</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 创建栈，用来存储是否在 ( 内\n</span><span class=\"c1\"></span>    <span class=\"nv\">$stack</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">\\SplStack</span><span class=\"p\">();</span>\n    <span class=\"c1\">// 创建栈，用来判断是否在字面量内\n</span><span class=\"c1\"></span>    <span class=\"nv\">$stack2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">\\SplStack</span><span class=\"p\">();</span>\n    <span class=\"c1\">// 创建数组，用来存储分割参数后的代码\n</span><span class=\"c1\"></span>    <span class=\"nv\">$splited</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s2\">&#34;&#34;</span><span class=\"p\">];</span>\n    <span class=\"c1\">// 存储当前的 $splited 的下标\n</span><span class=\"c1\"></span>    <span class=\"nv\">$curr</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 遍历代码\n</span><span class=\"c1\"></span>    <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"nv\">$code</span> <span class=\"k\">as</span> <span class=\"nv\">$k</span><span class=\"o\">=&gt;</span><span class=\"nv\">$v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"c1\">// 当进入一个新的 Calling 的时候\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;(&#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$stack</span><span class=\"o\">-&gt;</span><span class=\"na\">push</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">);</span>\n        <span class=\"c1\">// 当退出一个 Calling 的时候\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;)&#39;</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"nv\">$stack</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 从栈中 pop\n</span><span class=\"c1\"></span>            <span class=\"nv\">$stack</span><span class=\"o\">-&gt;</span><span class=\"na\">pop</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 当进入一个新的字面量时\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;[&#39;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">push</span><span class=\"p\">(</span><span class=\"k\">true</span><span class=\"p\">);</span>\n        <span class=\"c1\">// 当退出一个字面量时\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39;]&#39;</span><span class=\"p\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">pop</span><span class=\"p\">();</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 当在根 CallingNode 时\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$stack</span><span class=\"o\">-&gt;</span><span class=\"na\">count</span><span class=\"p\">()</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"c1\">// 当遇到空格时，分割参数\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"nv\">$v</span> <span class=\"o\">===</span> <span class=\"s1\">&#39; &#39;</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nv\">$stack</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">()</span> <span class=\"o\">&amp;&amp;</span> <span class=\"nv\">$stack2</span><span class=\"o\">-&gt;</span><span class=\"na\">isEmpty</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n                <span class=\"nv\">$curr</span> <span class=\"o\">++</span><span class=\"p\">;</span>\n                <span class=\"nv\">$splited</span><span class=\"p\">[</span><span class=\"nv\">$curr</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;&#34;</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// 最后一个参数的 fix\n</span><span class=\"c1\"></span>        <span class=\"nv\">$splited</span><span class=\"p\">[</span><span class=\"nv\">$curr</span><span class=\"p\">]</span> <span class=\"o\">.=</span> <span class=\"nv\">$v</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// 存储真实参数列表\n</span><span class=\"c1\"></span>    <span class=\"nv\">$real</span> <span class=\"o\">=</span> <span class=\"p\">[];</span>\n    <span class=\"c1\">// 循环去除空参数\n</span><span class=\"c1\"></span>    <span class=\"k\">foreach</span> <span class=\"p\">(</span><span class=\"nv\">$splited</span> <span class=\"k\">as</span> <span class=\"nv\">$v</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"nv\">$this</span><span class=\"o\">-&gt;</span><span class=\"na\">isBlankCharacter</span><span class=\"p\">(</span><span class=\"nv\">$v</span><span class=\"p\">))</span> <span class=\"p\">{</span>\n            <span class=\"nv\">$real</span><span class=\"p\">[]</span> <span class=\"o\">=</span> <span class=\"nx\">trim</span><span class=\"p\">(</span><span class=\"nv\">$v</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// 重新赋值\n</span><span class=\"c1\"></span>    <span class=\"nv\">$splited</span> <span class=\"o\">=</span> <span class=\"nv\">$real</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 获取函数名\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span><span class=\"o\">-&gt;</span><span class=\"na\">name</span> <span class=\"o\">=</span> <span class=\"nv\">$splited</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"c1\">// 添加到父节点\n</span><span class=\"c1\"></span>    <span class=\"nv\">$parentNode</span><span class=\"o\">-&gt;</span><span class=\"na\">addChild</span><span class=\"p\">(</span><span class=\"nv\">$node</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 遍历各个参数，并且将他们一个个 parse\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"nv\">$i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"nv\">$i</span> <span class=\"o\">&lt;</span> <span class=\"nx\">count</span><span class=\"p\">(</span><span class=\"nv\">$splited</span><span class=\"p\">);</span> <span class=\"o\">++</span> <span class=\"nv\">$i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"nv\">$v</span> <span class=\"o\">=</span> <span class=\"nv\">$splited</span><span class=\"p\">[</span><span class=\"nv\">$i</span><span class=\"p\">];</span>\n        <span class=\"nx\">doParse</span><span class=\"p\">(</span><span class=\"nv\">$v</span><span class=\"p\">,</span> <span class=\"nv\">$node</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>1.6. 解析 Literal</h2><p>首先，实现 <code>doParseLiteral</code>。</p><div class=\"highlight\"><pre><code class=\"language-php\"><span class=\"cp\">&lt;?php</span>\n\n<span class=\"k\">function</span> <span class=\"nf\">doParseLiteral</span><span class=\"p\">(</span><span class=\"k\">array</span> <span class=\"nv\">$code</span><span class=\"p\">,</span> <span class=\"nx\">Node</span> <span class=\"nv\">$parentNode</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"c1\">// 创建 Node 实例\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nx\">LiteralNode</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 把锅推给 parseLiteral 函数，解释期就获得真正的值\n</span><span class=\"c1\"></span>    <span class=\"nv\">$data</span> <span class=\"o\">=</span> <span class=\"nx\">parseLiteral</span><span class=\"p\">(</span><span class=\"nv\">$code</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 设置为节点的附属数据\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span><span class=\"o\">-&gt;</span><span class=\"na\">setData</span><span class=\"p\">(</span><span class=\"nv\">$data</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 设置父节点\n</span><span class=\"c1\"></span>    <span class=\"nv\">$node</span><span class=\"o\">-&gt;</span><span class=\"na\">parent</span> <span class=\"o\">=</span> <span class=\"nv\">$parentNode</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 添加到父节点\n</span><span class=\"c1\"></span>    <span class=\"nv\">$parentNode</span><span class=\"o\">-&gt;</span><span class=\"na\">addChild</span><span class=\"p\">(</span><span class=\"nv\">$node</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>然后过来看看主角 <code>parseLiteral</code>。</p><div class=\"highlight\"><pre><code class=\"language-php\">function parseLiteral(array $code) {\n    // 还原 code 为字符串\n    $codeStr = join($code, &#34;&#34;);\n    // 判断是否为字符串\n    if ($code[0] == &#39;&#34;&#39; || $code[0] == &#34;&#39;&#34;) {\n        // 偷懒的做法，直接 substr 获得字符串\n        $data = substr($codeStr, 1, -1);\n    // 如果可以转换为数字\n    } else if (is_numeric($codeStr)) {\n        // 通过某种特殊的方法强制转换为各种 numeric 值，$data = $codeStr + 0 也是一个办法\n        $data = $codeStr * 1;\n    // 如果是个 list\n    } else if ($code[0] == &#39;:&#39;) {\n        // data 就是一个数组\n        $data = [];\n        // 创建一个 flag，用来判断字符串的双引号\n        $flag1 = false;\n        // 创建一个 flag，用来判断字符串的单引号\n        $flag2 = false;\n        // 当前元素的字面量值\n        $curr = &#34;&#34;;\n        // 遍历代码\n        foreach ($code as $k=&gt;$v) {\n            // 当 $k 为 0 也就是指向 &#34;:&#34; 时，跳过\n            if ($k === 0) continue;\n            // 如果是双引号，且不在单引号的字符串内，那么直接取反 $flag1\n            if ($v === &#39;&#34;&#39; <span class=\"err\">&amp;&amp;</span> !$flag2) $flag1 = !$flag1;\n            // 如果是单引号，且不在双引号的字符串内，那么直接取反 $flag2\n            if ($v === &#34;&#39;&#34; <span class=\"err\">&amp;&amp;</span> !$flag1) $flag2 = !$flag2;\n            // 当不在单引号和双引号内且当前是隔开元素的逗号符号\n            if ($v === &#39;,&#39; <span class=\"err\">&amp;&amp;</span> !$flag1 <span class=\"err\">&amp;&amp;</span> !$flag2) {\n                // 解析当前元素的值\n                $data[] = parseLiteral(str_split(trim($curr)));\n                // 转到下一个元素\n                $curr = &#34;&#34;;\n                // 不需要添加 ,\n                continue;\n            }\n            // 添加到当前元素的值\n            $curr .= $v;\n        }\n        // 最后一个值的 hack\n        $data[] = parseLiteral(str_split(trim($curr)));\n    // 不是任何已知type\n    } else {\n        $data = null;\n    }\n    return $data;\n}</code></pre></div><h2>1.7 创建门面</h2><p>对解析所有代码的封装函数。</p><div class=\"highlight\"><pre><code class=\"language-php\">function parse(string $code): Root {\n    // 清理注释\n    $code = $this-&gt;parseComment($code);\n    // 创建根节点\n    $root = new Root;\n    // 进行解析\n    $this-&gt;doParse($code, $root);\n    // 返回根节点\n    return $root;\n}</code></pre></div><h2>2. 创建一个没用的 ASTWalker</h2><p>对，遍历 AST 的小工具，顺便可以测试我们的代码。</p><div class=\"highlight\"><pre><code class=\"language-php\">function walk(Node $ast, Callable $callback) {\n    $callback($ast);\n    foreach ($ast-&gt;children as $child) {\n        walk($child, $callback);\n    }\n}</code></pre></div><p>不解释。</p><h2>3. 运行时 VM</h2><p>说这个算得上一个 VM 的话，可能有点夸张。但是他能使我们的程序跑起来。</p><h2>3.1. 定义和删除 Functions 的方法</h2><p>基本类和定义删除 Functions 的方法，由于太简单，不做赘述。</p><div class=\"highlight\"><pre><code class=\"language-php\">class VM {\n\n    /**\n     * Functions\n     *\n     * @var array\n     */\n    protected $functions = [];\n\n    /**\n     * Define a function\n     *\n     * @param string $name\n     * @param mixed $value\n     * @return self\n     */\n    public function define(string $name, $value): VM {\n        $this-&gt;functions[$name] = $value;\n        return $this;\n    }\n\n    /**\n     * Delete a function\n     *\n     * @param string $name\n     * @return self\n     */\n    public function delete(string $name): VM {\n        unset($this-&gt;functions[$name]);\n        return $this;\n    }\n\n}</code></pre></div><h2>3.2 定义执行 Node 所用的方法</h2><div class=\"highlight\"><pre><code class=\"language-php\">public function runNode(Node $node) {\n    // 是字面量，直接返回数据\n    if ($node instanceof LiteralNode) {\n        return $node-&gt;data;\n    // 是执行函数的节点\n    } else if ($node instanceof CallingNode) {\n        // 取出函数名\n        $name = $node-&gt;name;\n        // 判断是否是 lazy 的\n        if (substr($name, 0, 1) == &#34;@&#34;) {\n            // 是 lazy 的，直接以 AST 作为参数\n            $args = $node-&gt;children;\n            // 将 name 去除 @ 符号\n            $name = substr($name, 1);\n        } else {\n            // 创建参数列表\n            $args = [];\n            // 遍历参数的 AST\n            foreach ($node-&gt;children as $child) {\n                // 执行 AST\n                $args[] = $this-&gt;runNode($child);\n            }\n        }\n        // 执行这个函数\n        return $this-&gt;doFunction($name, $args);\n    // 如果是根节点\n    } else if ($node instanceof Root) {\n        // 执行其中的第 0 个 child\n        return $this-&gt;runNode($node-&gt;children[0]);\n    // 否则抛出异常\n    } else {\n        throw new UnknownNodeException(&#34;Unknown node type: {$node-&gt;type}&#34;);\n    }\n}</code></pre></div><h2>3.3. 定义执行函数的方法</h2><div class=\"highlight\"><pre><code class=\"language-php\">public function doFunction(string $name, array $args) {\n    // 如果没有该函数，抛出异常\n    if (!isset($this-&gt;functions[$name])) {\n        throw new NoFunctionException(&#34;Unknown function: {$name}&#34;);\n        return;\n    }\n    // 获取函数\n    $func = $this-&gt;functions[$name];\n    // 如果是一个合法的回调\n    if (is_callable($func)) {\n        // 就去执行这个回调\n        return $func($args, $this);\n    // 如果是一个合法的 AST 节点\n    } else if ($func instanceof Node) {\n        // 就去执行这个节点\n        return $this-&gt;runNode($func);\n    // 否则是一个变量\n    } else {\n        // 返回它的值\n        return $func;\n    }\n}</code></pre></div><h2>4. 所有代码整合 &amp;&amp; 测试</h2><p>所有代码均发布到了 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/xtlsoft/Pisp\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/xtlsoft/Pisp</span><span class=\"invisible\"></span></a> 。</p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "脚本语言", 
                    "tagLink": "https://api.zhihu.com/topics/19577377"
                }, 
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "这玩的很有新意", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "xtlsoft", 
                            "userLink": "https://www.zhihu.com/people/f793ce90a1a3a095d983e84c20c8c459", 
                            "content": "<p>谢谢支持～</p>", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "xtlsoft", 
                            "userLink": "https://www.zhihu.com/people/f793ce90a1a3a095d983e84c20c8c459", 
                            "content": "<p>谢谢支持～</p>", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "xiumu wu", 
                    "userLink": "https://www.zhihu.com/people/9a337edf0c6d82b31f21b0f8642eb9ae", 
                    "content": "<p>很会玩，不知道哪里能用的上。</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43116283", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "Mysql字段类型设计相关问题！", 
            "content": "<p>Mysql是以文件存储在我们的系统的硬盘上面，那么<br/>（1）当我们读取写入的时候就会有磁盘IO的问题<br/>（2）当我们存储的数据是以页单位存储，而且每页的大小是16K，那么我们要尽可能的让我们的一页数据存放的更多。表结构宽度不要太大，也就是列数不要过多，保存更可能多的行数，那么针对行数存储就会涉及到字段类型选择的问题<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f3efc68e849dbe26841f27f81fb4d9c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-f3efc68e849dbe26841f27f81fb4d9c4_b.jpg\"/></figure><p><br/>以下字节按照utf8来示例，一个中文占3个字节，一个数字和字母是一个字节，而且utf8是变长的，范围在1-6之间<br/>（1）数字比字符串处理的速度要快<br/>（2）当我们需要存储一个固定的长度的值（身份证，手机号）并且长度小于50个字节的时候，那么我们可以选用char(n)<br/>（3）当我们要存储大于50个字节长度的值时候选用varchar(n)<br/>（4）当我们存储时间的时候datatime&gt;int&gt;char&gt;varchar,但是int是有时间范围限制的，只能存到2038年<br/>（5）float和decimal的选择，当我们需要存储一个精度很高的值的时候，那么我们就要存decimal，float只能保存到小数点后7位<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b55a80fbd4273c719a7e09c958943740_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-b55a80fbd4273c719a7e09c958943740_b.jpg\"/></figure><p><br/>下面是类型占用的字节数<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-de539d328740cd9cef14d7d3273b5ae3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-de539d328740cd9cef14d7d3273b5ae3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;349&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-de539d328740cd9cef14d7d3273b5ae3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-de539d328740cd9cef14d7d3273b5ae3_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "设计", 
                    "tagLink": "https://api.zhihu.com/topics/19551557"
                }
            ], 
            "comments": [
                {
                    "userName": "张福来", 
                    "userLink": "https://www.zhihu.com/people/c98780c312fef4825a45a1107c6dd927", 
                    "content": "<p>unix 时间戳 用哪个类型存好啊  </p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "刘柱", 
                            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
                            "content": "<p>首先要明白：Mysql的数据类型int类型是相较其他类型要快的，所以推荐你使用int</p>", 
                            "likes": 0, 
                            "replyToAuthor": "张福来"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43116237", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "部分手机访问https显示空白页", 
            "content": "<p>事情是这样的。。。。。此处省略1000字！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bd18cf56969430c13142e103e7a819db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic4.zhimg.com/v2-bd18cf56969430c13142e103e7a819db_b.jpg\"/></figure><p><br/>突然客服告诉我，众享通赢的消费平台怎么登陆不进去了？？？而且还一直显示空白页？？？，程序员你做了什么了？？？额，，然后我表示一脸懵逼....<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-51abf13c73013e19034a5d5a2b6505fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-51abf13c73013e19034a5d5a2b6505fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b185a5258168d6c70fccdad3009b8ecd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-b185a5258168d6c70fccdad3009b8ecd_b.jpg\"/></figure><p><br/>然后我急忙拿起手机点击了一下众享通赢的消费平台，然后我们这边一切正常，正常。。正常，，，不能再正常！！！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ac7a5e6fea0c994f4352e670c2ac0566_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-ac7a5e6fea0c994f4352e670c2ac0566_b.jpg\"/></figure><p><br/>再接下来我问了一下消费者的电话，怀着忐忑的心里咨询了一下情况，然后拿起某真机测试平台测试，果然打不开？？打不开？？？<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5374d57d904cda21ded236f717c899f1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image\" width=\"80\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;80&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"80\" data-actualsrc=\"https://pic2.zhimg.com/v2-5374d57d904cda21ded236f717c899f1_b.jpg\"/></figure><p><br/>然后我就开始找问题，看服务器日志，看代码，打印代码。。。这还是第一次看到。。难道是环信不兼容这款神一样的oppor7，亦或者自己挖了一个坑，然后发现，居然不访问我们的服务器？这时候还是没有意识到问题的所在，继续检查代码。。直到某个时间，突然意识到，不访问服务器那肯定不是代码的问题（之前一直怀疑，但是不确定），然后想是不是被运营商拦截了？用wifi和流量都不行，排除了！！！最后发现是https不兼容的问题！！！，原来腾讯的https不兼容低版本的Android系统，如果强行访问会显示空白页！！！之后更换了七牛云的https证书等，正常了！！！<br/>最后总结，腾讯免费的https证书配置不兼容Android低版本(4.4.4)，所以小伙伴发现你的网站部分手机显示空白页，要及时更换啊，不知道腾讯什么时候能解决这个bug!!!<br/>I am far from success!!!<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-39948688b0587cefb20536ced696e27f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic4.zhimg.com/v2-39948688b0587cefb20536ced696e27f_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "手机", 
                    "tagLink": "https://api.zhihu.com/topics/19551676"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }, 
                {
                    "tag": "微信开发", 
                    "tagLink": "https://api.zhihu.com/topics/19874339"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43116191", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "每一个程序员需要了解的10个Linux命令", 
            "content": "<p>作为一个程序员，在软件开发职业生涯中或多或少会用到Linux系统，并且可能会使用Linux命令来检索需要的信息。本文将为各位开发者分享10个有用的Linux命令，希望对你会有所帮助。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-50e27010eaf3f78b4f8e5e9fd80ac8d3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"187\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"187\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic4.zhimg.com/v2-50e27010eaf3f78b4f8e5e9fd80ac8d3_b.jpg\"/></figure><p><br/>以下就是今天我们要介绍的Linux命令：<br/>man<br/>touch, cat and less<br/>sort and grep<br/>cut<br/>sed<br/>tar<br/>find<br/>diff<br/>uniq<br/>chmod<br/>接下来让我们逐一来详细介绍。<br/><b>1、man命令</b><br/>第一个你需要知道的Linux命令就是man命令，该命令可以显示指定命令的用法和描述。比如你想知道ls命令的用法和选项，可以在终端执行“man ls”：<br/>语法: man &lt;command name&gt;man lsroot@devopscube:~# man lsLS(1) User Commands LS(1)NAME<br/>ls - list directory contents<br/>SYNOPSIS<br/>ls [OPTION]... [FILE]...DESCRIPTION List information about the FILEs (the current directory by default).<br/>Sort entries alphabetically if none of -cftuvSUX nor --sort is speciâ<br/>fied.<br/>Mandatory arguments to long options are mandatory for short options<br/>too.<br/>-a, --all do not ignore entries starting with .<br/><b>2、touch，cat和less命令</b><br/>touch命令可以在Linux系统中创建大小为0的任意类型文件，作为程序开发者，当你需要在Linux服务器上创建文件时，可以使用touch命令：<br/>语法: touch &lt;filename&gt;touch demo.txt<br/>root@devopscube:~# touch demo.txtroot@devopscube:~# lsdemo.txt<br/>cat命令用来查看文件的内容，但是使用cat命令并不能编辑文件的内容，它仅仅是可以浏览文件内容。cat命令不支持键盘上下键翻页。<br/>语法: cat &lt;filename&gt;cat demo.txt<br/>同样的less命令也可以让你浏览文件，less命令非常快，并且支持上下键查看文件的开头和末尾。然而more命令和它类似，只是more命令只能用enter键实现文件的向前翻页，不支持回退。<br/>语法: less &lt;filename&gt;<br/>more &lt;filename&gt;<br/>less demo.txt<br/>more demo.txt<br/><b>3、sort和grep命令</b><br/>sort命令用来对文件内容进行排序。创建一个名为test.txt的文件，并且把以下内容拷贝到该文件中：<br/>1  mike level intermediate jan10 lucy level beginer mar45 Dave level  expert dec4 dennis start beginner jul7 Megan employee trainee feb58  Mathew Head CEO nov<br/>上面的例子中，第二列是名称，所以如果你想对名称列按字母排序，就可以使用“-k”选项，并标注列号，比如“-k2”：<br/>语法: sort<br/>sort -k2 test.txt<br/>排序结果<br/>root@devopscube:~#  sort -k2 test.txt45 Dave level expert dec4 dennis start beginner jul10  lucy level beginer mar58 Mathew Head CEO nov7 Megan employee trainee  feb1 mike level intermediate jan<br/>第一列是数字，如果你想按数字排序，可以使用“-h”选项。如果数字在不同列上，你可以在“-h”选项后使用“-k”选项：<br/>root@devopscube:~#  sort -h test.txt 1 mike level intermediate jan4 dennis start beginner  jul7 Megan employee trainee feb10 lucy level beginer mar45 Dave level  expert dec58 Mathew Head CEO nov<br/>最后一列是月份，你可以使用“-M”选项来让文件内容按月份排序：<br/>root@devopscube:~#  sort -k5 -M test.txt1 mike level intermediate jan7 Megan employee  trainee feb10 lucy level beginer mar4 dennis start beginner jul58 Mathew  Head CEO nov45 Dave level expert dec<br/>注：如果你想消除重复的行，可以在sort命令后使用“-u”选项。<br/>使用“-r”选项，是文件倒序排列：<br/>root@devopscube:~#  sort -h -r test.txt58 Mathew Head CEO nov45 Dave level expert dec10  lucy level beginer mar7 Megan employee trainee feb4 dennis start  beginner jul1 mike level intermediate jan<br/>Grep命令：<br/>Grep命令非常强大，系统管理员经常会用到它。grep命令可以在文件中搜索指定格式的字符串，同时对其进行标准输出。<br/>语法: grep &#34;&lt;search string&gt;&#34; &lt;filename&gt;<br/>grep &#34;Mathew&#34; test.txt<br/>root@devopscube:~# grep &#34;dennis&#34; test.txt4 dennis start beginner jul<br/>上面命令的输出结果是包含该子字符串的，如果你想检索完整的单词，你需要添加“-i”选项。同时，也可以用grep命令在多个文件中搜索字符串，命令代码如下：<br/>grep &#34;dennis&#34; test1.txt test2.txt test3.txt<br/>当然你也可以用正则表达式来匹配字符串。<br/><b>4、cut命令</b><br/>cut命令可以让你用列或者分隔符提取文件中的指定部分。如果你要列出文件中某列的全部内容，可以使用“-c”选项。例如，下面将从test.txt文件中提取第1、2列的全部内容。<br/>cut -c1-2 test.txtroot@devopscube:~# cut -c1-2 test.txt110454758<br/>如果你希望从文件中提取指定的字符串，那么你可以使用分隔符选项“-d”和“-f”选项选中列。例如，我们可以利用cut命令提取names列：<br/>root@devopscube:~# cut -d&#39; &#39; -f2 test.txtmike<br/>lucyDavedennisMeganMathew<br/>下面的例子从/etc/passd file中提取users列：<br/>cut -d&#39;:&#39; -f1 /etc/passwd<br/><b>5、sed命令</b><br/>sed  是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern  space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有  改变，除非你使用重定向存储输出。<br/>如果你想通过搜索替换文件中的指定内容，你可以使用“s”选项来检索到它然后将它替换。<br/>语法: sed &#39;s/&lt;old-word&gt;/&lt;new-word&gt;/&#39; test.txt<br/>例如，在test.txt文件中用“michael”替换“mike”：<br/>sed  &#39;s/mike/michael/&#39; test.txtroot@devopscube:~# sed &#39;s/mike/michael/&#39;  test.txt1 michael level intermediate jan10 lucy level beginer mar45 Dave  level expert dec4 dennis start beginner jul7 Megan employee trainee  feb58 Mathew Head CEO nov<br/><b>6、tar命令</b><br/>tar命令用来压缩和解压缩文件，其中经常会用到“-cf”和“-xf”选项。<br/>语法: tar &lt;options&gt; &lt;archive-name&gt; &lt;file/folder name&gt;<br/>让我们将test.txt文件打包：<br/>tar -cf test.tar test.txtroot@devopscube:~# tar -cf test.tar test.txtroot@devopscube:~# lstest.tar test.txt<br/>用“-C”选项将刚才打包好的test.tar文件解压缩至“demo”目录：<br/>tar  -xf test.tar -C /root/demo/root@devopscube:~# tar -xf test.tar -C  /root/demo/root@devopscube:~# cd demo/root@devopscube:~/demo# lstest.txt<br/><b>7、find命令</b><br/>find命令用来检索文件，可以用“-name”选项来检索指定名称的文件：<br/>find -name find -name test.txtroot@devopscube:/home/ubuntu# cd ~root@devopscube:~# find -name test.txt./demo/test.txt./test.txt<br/>你也可以用“/ -name”来检索指定名称的文件夹：<br/>find  / -name passwdroot@devopscube:~# find / -name  passwd/etc/cron.daily/passwd/etc/pam.d/passwd/etc/passwd/usr/share/lintian/overrides/passwd<br/><b>8、diff命令</b><br/>diff命令用来找出2个文件的不同点。diff命令通过分析文件内容，然后将不同的行打印出来，下面的例子可以找出两个文件test和test1的不同点：<br/>语法: diff &lt;filename1&gt; &lt;filename2&gt;<br/>diff test.txt test1.txt<br/>root@devopscube:~# diff test.txt test1.txt7c7&lt; 59 sdfsd---&gt; 59 sdfsd CTO dec<br/><b>9、Uniq命令</b><br/>uniq命令用来过滤文件中的重复行：<br/>语法: uniq<br/>uniq test.txt<br/>root@devopscube:~#  uniq test.txt1 mike level intermediate jan10 lucy level beginer mar45  Dave level expert dec4 dennis start beginner jul7 Megan employee trainee  feb58 Mathew Head CEO nov<br/><b>10、chmod命令</b><br/>chmod命令用来改变文件的读/写/执行权限，权限数值如下所示：<br/>4 - read permission2 - write permission1 - execute permission0 - no permission<br/>下面的命令可以给test.txt文件赋最高的权限：<br/>chmod 755 test.txt</p>", 
            "topic": [
                {
                    "tag": "Linux Desktop", 
                    "tagLink": "https://api.zhihu.com/topics/20008195"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }, 
                {
                    "tag": "科技", 
                    "tagLink": "https://api.zhihu.com/topics/19556664"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31904200", 
            "userName": "DealiAxy", 
            "userLink": "https://www.zhihu.com/people/07f7f65a770c89b0d2d5d2cd28a17c51", 
            "upvote": 2, 
            "title": "设计模式之代理模式——PHP例子&实现", 
            "content": "<h2>代理模式</h2><ol><li>在客户端与实体之间建立一个代理对象（proxy），客户端对实体进行操作全部委派给代理对象，<br/>隐藏实体的具体实现细节。</li><li>Proxy还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务。</li></ol><h2>代理模式与父类和接口的异同</h2><ul><li>相同点:代理模式的作用和父类以及接口和组合的作用类似,都是为了聚合共用部分,减少公共部分的代码</li><li>不同点:</li><ul><li>相比起父类,他们的语境不同,父类要表达的含义是 is-a, 而代理要表达的含义更接近于接口, 是 has-a,而且使用代理的话应了一句话”少用继承,多用组合”,要表达的意思其实也就是降低耦合度了</li><li>相比起接口,他们实现的功能又不太一样,语境都是has-a,不过接口是has-a-function,而代理对象时是has-a-object,这个object是has-a-function的object,此外,接口是为了说明这个类拥有什么功能,却没有具体实现,实现了多态,而代理对象不但拥有这个功能,还拥有这个功能的具体实现</li><li>对于组合来说，他比组合更具灵活性，比如我们将代理对象设为private，那么我可以选择只提供一部分的代理功能，例如Printer的某一个或两个方法，又或者在提供Printer的功能的时候加入一些其他的操作，这些都是可以的</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>实现代码</h2><div class=\"highlight\"><pre><code class=\"language-text\">//定义代理接口\ninterface IUserProxy\n{\n    function getUserName($id);\n    function setUserName($id, $name);\n}\n\n//实现代理对象类\nclass Proxy implements IUserProxy\n{\n    function getUserName($id)\n    {\n        $db = Factory::getDatabase(&#39;slave&#39;);\n        $db-&gt;query(&#34;select name from user where id =$id limit 1&#34;);\n    }\n\n    function setUserName($id, $name)\n    {\n        $db = Factory::getDatabase(&#39;master&#39;);\n        $db-&gt;query(&#34;update user set name = $name where id =$id limit 1&#34;);\n    }\n}\n\n//使用代理对象\n$proxy =  new Proxy();\necho $proxy-&gt;getUserName(&#39;1&#39;);\n</code></pre></div><h2>另一个例子</h2><div class=\"highlight\"><pre><code class=\"language-text\">class Printer {    //代理对象,一台打印机\n    public function printSth() {\n        echo &#39;I can print &lt;br&gt;&#39;;\n    }\n\n    // some more function below\n    // ...\n}\n\nclass TextShop {    //这是一个文印处理店,只文印,卖纸,不照相\n    private $printer;\n\n    public function __construct(Printer $printer) {\n        $this-&gt;printer = $printer;\n    }\n\n    public function sellPaper() {    //卖纸\n        echo &#39;give you some paper &lt;br&gt;&#39;;\n    }\n\n    public function __call($method, $args) {    //将代理对象有的功能交给代理对象处理\n        if(method_exists($this-&gt;printer, $method)) {\n            $this-&gt;printer-&gt;$method($args);\n        }\n    }\n}\n\nclass PhotoShop {    //这是一个照相店,只文印,拍照,不卖纸\n    private $printer;\n\n    public function __construct(Printer $printer) {\n        $this-&gt;printer = $printer;\n    }\n\n    public function takePhotos() {    //照相\n        echo &#39;take photos for you &lt;br&gt;&#39;;\n    }\n\n    public function __call($method, $args) {    //将代理对象有的功能交给代理对象处理\n        if(method_exists($this-&gt;printer, $method)) {\n            $this-&gt;printer-&gt;$method($args);\n        }\n    }\n}\n\n$printer = new Printer();\n$textShop = new TextShop($printer);\n$photoShop = new PhotoShop($printer);\n\n$textShop-&gt;printSth();\n$photoShop-&gt;printSth();\n</code></pre></div><p>文印处理店和照相店都具有文印的功能,所以我们可以将文印的功能代理给一台打印机,这里打印机只有一个功能,假如打印机还有n个功能,我们使用<code>__call()</code>方法就能够省去很多重复的代码了</p><p>假如是使用继承,这样语境上就不合理,一个店显然不应该继承一台打印机</p><p>而使用接口,因为我们的功能实现都是一样,也没有必要去重新实现接口的功能</p><p>所以此处使用代理是最佳选择</p><p>其他语言的实现代理模式也大同小异，只不过可能没有PHP的<code>__call()</code>方法,还需要手动声明<code>printSth()</code>方法,然后在方法体里去调用<code>$printer</code>的<code>printSth()</code>方法。</p><hr/><p>博客原文：<a href=\"https://link.zhihu.com/?target=http%3A//blog.deali.cn/1060.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">设计模式之代理模式——PHP例子&amp;实现 （DealiAxy</a>）</p><p>喜欢请关注我的微信公众号：DealiAxy</p>", 
            "topic": [
                {
                    "tag": "设计模式", 
                    "tagLink": "https://api.zhihu.com/topics/19599592"
                }, 
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "Web 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19550516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/40503441", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "PHP模拟单链表的curd操作", 
            "content": "<p>数据结构？是一个又爱又恨的存在，不喜欢它的人认为枯燥，乏味，头大。但是喜欢它的人就恰恰相反，小梦也是属于不喜欢之列。如果你把编程看做是一项练就功夫的事情，那么数据结构就是内功，相信很多小伙伴内心多多少少都有一个武侠梦<br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c4c38f878cf895de16a4776a0eb941f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"569\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;569&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"569\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic3.zhimg.com/v2-c4c38f878cf895de16a4776a0eb941f6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/>\t单链表官方定义：单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象)<br/> + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。（这不是我说的，是官方说的，但是估计你们看了想骂人）<br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c58d106f18f575c7627cfdb36d63f80f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic4.zhimg.com/v2-c58d106f18f575c7627cfdb36d63f80f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/> <br/><br/></p><p><br/>\t下面的示例图就是单链表了，尾部指针是一个null，中间部分通过指针相连接<br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0f2287e88a241da8f04f875cb67b3363_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1538\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb\" width=\"1538\" data-original=\"https://pic4.zhimg.com/v2-0f2287e88a241da8f04f875cb67b3363_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1538&#39; height=&#39;278&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1538\" data-rawheight=\"278\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1538\" data-original=\"https://pic4.zhimg.com/v2-0f2287e88a241da8f04f875cb67b3363_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0f2287e88a241da8f04f875cb67b3363_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/>\t接下来我们就是用php来模拟一下单链表：上代码-&gt;<br/></p><p><br/> <br/><br/></p><p><br/> 参数说明：以下方法head表示一个链表，hero表示一个英雄的对象，num表示英雄的编号，下方代码将不再重复</p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-70dd840ce44d7b1b5c65fd162ab6f6b6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb\" width=\"582\" data-original=\"https://pic3.zhimg.com/v2-70dd840ce44d7b1b5c65fd162ab6f6b6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;582&#39; height=&#39;320&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"582\" data-rawheight=\"320\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"582\" data-original=\"https://pic3.zhimg.com/v2-70dd840ce44d7b1b5c65fd162ab6f6b6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-70dd840ce44d7b1b5c65fd162ab6f6b6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4572fba0c53defcd9737cab7603c7ad3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic4.zhimg.com/v2-4572fba0c53defcd9737cab7603c7ad3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;197&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"197\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic4.zhimg.com/v2-4572fba0c53defcd9737cab7603c7ad3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4572fba0c53defcd9737cab7603c7ad3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/>\t上面代码是我们简单的模拟了一下使用PHP语言怎么去实现单链表，当然上面的方法很笨，我们稍微改造一下<br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d98089ff1c11a0851acc6d24eb8ad6f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"158\" data-rawheight=\"120\" class=\"content_image\" width=\"158\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;158&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"158\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"158\" data-actualsrc=\"https://pic4.zhimg.com/v2-d98089ff1c11a0851acc6d24eb8ad6f7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-93e436c715abd9d71a09a94ab290cdd4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic1.zhimg.com/v2-93e436c715abd9d71a09a94ab290cdd4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;569&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic1.zhimg.com/v2-93e436c715abd9d71a09a94ab290cdd4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-93e436c715abd9d71a09a94ab290cdd4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-aa99e47c94a2418c2623892499184145_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-aa99e47c94a2418c2623892499184145_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-aa99e47c94a2418c2623892499184145_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-aa99e47c94a2418c2623892499184145_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7d8554bba49b805dcee979483b1adb44_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"860\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"860\" data-original=\"https://pic1.zhimg.com/v2-7d8554bba49b805dcee979483b1adb44_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;860&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"860\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"860\" data-original=\"https://pic1.zhimg.com/v2-7d8554bba49b805dcee979483b1adb44_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7d8554bba49b805dcee979483b1adb44_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-aac6b2d4b2901e9b89da284da356a6f5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"806\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb\" width=\"806\" data-original=\"https://pic2.zhimg.com/v2-aac6b2d4b2901e9b89da284da356a6f5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;806&#39; height=&#39;419&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"806\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"806\" data-original=\"https://pic2.zhimg.com/v2-aac6b2d4b2901e9b89da284da356a6f5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-aac6b2d4b2901e9b89da284da356a6f5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-70ef94a30375e9fb10123416ffab570c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-70ef94a30375e9fb10123416ffab570c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;819&#39; height=&#39;403&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"819\" data-rawheight=\"403\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"819\" data-original=\"https://pic1.zhimg.com/v2-70ef94a30375e9fb10123416ffab570c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-70ef94a30375e9fb10123416ffab570c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/>\t以下就是上方代码的测试代码：<br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-aef748724c48d2f8de34252112109669_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-aef748724c48d2f8de34252112109669_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;818&#39; height=&#39;410&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"410\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-aef748724c48d2f8de34252112109669_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-aef748724c48d2f8de34252112109669_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> <br/><br/></p><p><br/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-996ddc03e25be767027c3e1e0e698cf9_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic2.zhimg.com/v2-996ddc03e25be767027c3e1e0e698cf9_b.jpg\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"291\" data-thumbnail=\"https://pic2.zhimg.com/v2-996ddc03e25be767027c3e1e0e698cf9_b.jpg\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic2.zhimg.com/v2-996ddc03e25be767027c3e1e0e698cf9_b.gif\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "PHP 编程", 
                    "tagLink": "https://api.zhihu.com/topics/20052035"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }, 
                {
                    "tag": "PHP 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19606711"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36711882", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "PHP排序的几种方法", 
            "content": "<p> 冒泡排序<br/></p><div class=\"highlight\"><pre><code class=\"language-text\">function BubbleSort($arr) {\n// 获得数组总长度\n$num = count($arr);\n// 正向遍历数组\nfor ($i = 1; $i &lt; $num; $i++) {\n// 反向遍历\nfor ($j = $num - 1; $j &gt;= $i ; $j--) {\n// 相邻两个数比较\nif ($arr[$j] &lt; $arr[$j-1]) {\n// 暂存较小的数\n$iTemp = $arr[$j-1];\n// 把较大的放前面\n$arr[$j-1] = $arr[$j];\n// 较小的放后面\n$arr[$j] = $iTemp;\n}\n}\n}\nreturn $arr;\n}</code></pre></div><p>交换法排序</p><div class=\"highlight\"><pre><code class=\"language-text\">function ExchangeSort($arr){\n$num = count($arr);\n// 遍历数组\nfor ($i = 0;$i &lt; $num - 1; $i++) {\n// 获得当前索引的下一个索引\nfor ($j = $i + 1; $j &lt; $num; $j++) {\n// 比较相邻两个的值大小\nif ($arr[$j] &lt; $arr[$i]) {\n// 暂存较小的数\n$iTemp = $arr[$i];\n// 把较大的放前面\n$arr[$i] = $arr[$j];\n// 较小的放后面\n$arr[$j] = $iTemp;\n}\n}\n}\nreturn $arr;\n}</code></pre></div><p>选择法排序</p><div class=\"highlight\"><pre><code class=\"language-text\">function SelectSort($arr) {\n// 获得数组总长度\n$num = count($arr);\n// 遍历数组\nfor ($i = 0;$i &lt; $num-1; $i++) {\n// 暂存当前值\n$iTemp = $arr[$i];\n// 暂存当前位置\n$iPos = $i;\n// 遍历当前位置以后的数据\nfor ($j = $i + 1;$j &lt; $num; $j++){\n// 如果有小于当前值的\nif ($arr[$j] &lt; $iTemp) {\n// 暂存最小值\n$iTemp = $arr[$j];\n// 暂存位置\n$iPos = $j;\n}\n}</code></pre></div><p>把当前值放到算好的位置</p><div class=\"highlight\"><pre><code class=\"language-text\">$arr[$iPos] = $arr[$i];\n// 把当前值换成算好的值\n$arr[$i] = $iTemp;\n}\nreturn $arr;\n}</code></pre></div><p>插入法排序</p><div class=\"highlight\"><pre><code class=\"language-text\">function InsertSort($arr){\n$num = count($arr);\n// 遍历数组\nfor ($i = 1;$i &lt; $num; $i++) {\n// 获得当前值\n$iTemp = $arr[$i];\n// 获得当前值的前一个位置\n$iPos = $i - 1;\n// 如果当前值小于前一个值切未到数组开始位置\nwhile (($iPos &gt;= 0) &amp;&amp; ($iTemp &lt; $arr[$iPos])) {\n// 把前一个的值往后放一位\n$arr[$iPos + 1] = $arr[$iPos];\n// 位置递减\n$iPos--;\n}\n$arr[$iPos+1] = $iTemp;\n}\nreturn $arr;\n}</code></pre></div><p> 快速排序</p><div class=\"highlight\"><pre><code class=\"language-text\">function QuickSort($arr){\n$num = count($arr);\n$l = $r = 0;\n$left = $right = array();\n// 从索引的第二个开始遍历数组\nfor ($i = 1;$i &lt; $num; $i++) {\n// 如果值小于索引1\nif ($arr[$i] &lt; $arr[0]) {\n// 装入左索引数组(小于索引1的数据)\n$left[] = $arr[$i];\n$l++;\n} else {\n// 否则装入右索引中(大于索引1的数据)\n$right[] = $arr[$i];\n$r++; //\n}\n}\n// 如果左索引有值 则对左索引排序\nif($l &gt; 1) {\n$left = QuickSort($left);\n}\n// 排序后的数组\n$new_arr = $left;\n// 将当前数组第一个放到最后\n$new_arr[] = $arr[0];\n// 如果又索引有值 则对右索引排序\nif ($r &gt; 1) {\n$right = QuickSort($right);\n}\n// 根据右索引的长度再次增加数据\nfor($i = 0;$i &lt; $r; $i++) {\n$new_arr[] = $right[$i];\n}\nreturn $new_arr;\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36052513", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "想玩集群？读写分离？你要先懂这个！", 
            "content": "<p>答案是：Mysql主从同步，集群，读写分离，都会涉及数据的数据同步，所以想玩哪些东西，我们还是要把这个数据同步的基础学会之后我们才能玩其他的，今天呢思梦PHP就给大家带来了这个小案例，亲测，没毛病！<br/></p><p>以下案例是测试案例，当然你线上服务器也是一样的！首先你要保证的你的操作系统的统一，数据库的版本的统一你才能开启数据同步的大门！下面就上步骤了！</p><p>1：首先你需要一个虚拟机，然后上面配置两个系统，当然你的mysql的版本要保持一致</p><p>2：你在你主的mysql里面创建一个你要同步的mysql数据库</p><p>3：Linux目录下的etc/</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2f4624a58c7c2829a061b0a1557dad22_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"589\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb\" width=\"589\" data-original=\"https://pic3.zhimg.com/v2-2f4624a58c7c2829a061b0a1557dad22_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;589&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"589\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"589\" data-original=\"https://pic3.zhimg.com/v2-2f4624a58c7c2829a061b0a1557dad22_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2f4624a58c7c2829a061b0a1557dad22_b.jpg\"/></figure><p>有一个my.cnf的文件</p><p>主服务器的配置</p><p>4：vi /etc/my.cnf</p><p>log-bin=mysql-bin</p><p>binlog_format=mixed</p><p>server-id       = 1</p><p>binlog_do_db = test #指定需要同步的数据库（实际应用中根据实际情况指定）</p><p>binlog_ignore_db = mysql #无需同步的数据库</p><p>binlog_ignore_db = information_schema #无需同步的数据库</p><p>%设置同步之后注意，如果你在主服务器上面创建数据库之后，从服务器也是会创建的，然后他们也是会同步的，所以你还要创建其他的数据库要禁掉不让他们同步</p><p>红线里面的是你要添加的配置</p><p>5：登陆mysql，然后查看master的status，蓟县这个file和position的值，后面从服务要用到</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5b0a818f9e9438a2bb34a91306e87600_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"490\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb\" width=\"490\" data-original=\"https://pic1.zhimg.com/v2-5b0a818f9e9438a2bb34a91306e87600_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;490&#39; height=&#39;101&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"490\" data-rawheight=\"101\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"490\" data-original=\"https://pic1.zhimg.com/v2-5b0a818f9e9438a2bb34a91306e87600_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5b0a818f9e9438a2bb34a91306e87600_b.jpg\"/></figure><p>从服务器的配置：</p><p>1：也是同样找到那个my.cnf的文件</p><p>log-bin=mysql-bin</p><p>binlog_format=mixed</p><p>server-id       = 2  #这里是2  主服务器是1，以下的需要同步的数据库什么配置和主服务器的是一样的</p><p>binlog_do_db = test #指定需要同步的数据库（实际应用中根据实际情况指定）</p><p>binlog_ignore_db = mysql #无需同步的数据库</p><p>binlog_ignore_db = information_schema #无需同步的数据库</p><p>2：进入mysql,执行slave stop</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3e17775afe709b3ff8c4e0a52289e03f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-3e17775afe709b3ff8c4e0a52289e03f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;636&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-3e17775afe709b3ff8c4e0a52289e03f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3e17775afe709b3ff8c4e0a52289e03f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-fd508aea7c41f76726a054777ee2a4b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb\" width=\"573\" data-original=\"https://pic2.zhimg.com/v2-fd508aea7c41f76726a054777ee2a4b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;573&#39; height=&#39;285&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"573\" data-rawheight=\"285\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"573\" data-original=\"https://pic2.zhimg.com/v2-fd508aea7c41f76726a054777ee2a4b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-fd508aea7c41f76726a054777ee2a4b9_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "负载均衡", 
                    "tagLink": "https://api.zhihu.com/topics/19596611"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36052369", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "Memcache基础教程", 
            "content": "<p><b>Memcache是什么</b> </p><p>Memcache是<a href=\"https://link.zhihu.com/?target=http%3A//danga.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">danga.com</span><span class=\"invisible\"></span></a>的一个项目，最早是为 LiveJournal 服务的，目前全世界不少人使用这个缓存项目来构建自己大负载的网站，来分担数据库的压力。</p><p>它可以应对任意多个连接，使用非阻塞的网络IO。由于它的工作机制是在内存中开辟一块空间，然后建立一个HashTable，Memcached自管理这些HashTable。</p><p>Memcache官方网站：<a href=\"https://link.zhihu.com/?target=http%3A//www.danga.com/memcached\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">danga.com/memcached</span><span class=\"invisible\"></span></a>，更多详细的信息可以来这里了解 :)</p><p>为什么会有Memcache和memcached两种名称？</p><p>其实Memcache是这个项目的名称，而memcached是它服务器端的主程序文件名，知道我的意思了把~~~~。一个是项目名称，一个是主程序文件名，在网上看到了很多人不明白，于是混用了。</p><p><b>Memcache的安装</b></p><p>分为两个过程：memcache服务器端的安装和memcached客户端的安装。</p><p>所谓服务器端的安装就是在服务器（一般都是linux系统）上安装Memcache实现数据的存储</p><p>所谓客户端的安装就是指php（或者其他程序，Memcache还有其他不错的api接口提供）去使用服务器端的Memcache提供的函数，需要php添加扩展。</p><p>具体的配置大家可以参考：</p><p>Linux下的Memcache安装：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/257.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/257.html</span><span class=\"invisible\"></span></a></p><p>Windows下的Memcache安装：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/258.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/258.html</span><span class=\"invisible\"></span></a></p><p>Memcache基础教程：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/259.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/259.html</span><span class=\"invisible\"></span></a></p><p>Discuz!的Memcache缓存实现：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/261.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/261.html</span><span class=\"invisible\"></span></a></p><p>Memcache协议中文版：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/306.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/306.html</span><span class=\"invisible\"></span></a></p><p>Memcache分布式部署方案：<a href=\"https://link.zhihu.com/?target=http%3A//www.ccvita.com/395.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">ccvita.com/395.html</span><span class=\"invisible\"></span></a></p><p><b>PHP的Memcache</b></p><p>&lt; ?php</p><p>//连接</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem = new Memcache;\n$mem-&gt;connect(&#34;192.168.0.200&#34;, 12000);</code></pre></div><p>//保存数据</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;set(&#39;key1&#39;, &#39;This is first value&#39;, 0, 60);\n$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val .&#34;\n&#34;;</code></pre></div><p>//替换数据</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;replace(&#39;key1&#39;, &#39;This is replace value&#39;, 0, 60);\n$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val . &#34;\n&#34;;</code></pre></div><p>//保存数组</p><div class=\"highlight\"><pre><code class=\"language-text\">$arr = array(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;);\n$mem-&gt;set(&#39;key2&#39;, $arr, 0, 60);\n$val2 = $mem-&gt;get(&#39;key2&#39;);\necho &#34;Get key2 value: &#34;;\nprint_r($val2);\necho &#34;\n&#34;;</code></pre></div><p>//删除数据</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;delete(&#39;key1&#39;);\n$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val . &#34;\n&#34;;</code></pre></div><p>//清除所有数据</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;flush();\n$val2 = $mem-&gt;get(&#39;key2&#39;);\necho &#34;Get key2 value: &#34;;\nprint_r($val2);\necho &#34;\n&#34;;</code></pre></div><p>//关闭连接</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;close();</code></pre></div><p>?&gt;</p><p>如果正常的话，浏览器将输出：</p><div class=\"highlight\"><pre><code class=\"language-text\">Get key1 value: This is first value\nGet key1 value: This is replace value\nGet key2 value: Array ( [0] =&gt; aaa [1] =&gt; bbb [2] =&gt; ccc [3] =&gt; ddd )\nGet key1 value:\nGet key2 value:</code></pre></div><p><b>程序代码分析</b></p><p>初始化一个Memcache的对象：</p><p>$mem = new Memcache;</p><p>连接到我们的Memcache服务器端，第一个参数是服务器的IP地址，也可以是主机名，第二个参数是Memcache的开放的端口：</p><p>$mem-&gt;connect(&#34;192.168.0.200&#34;, 12000);</p><p>保存一个数据到Memcache服务器上，第一个参数是数据的key，用来定位一个数据，第二个参数是需要保存的数据内容，这里是一个字符串，第三个参数是一个标记，一般设置为0或者MEMCACHE_COMPRESSED就行了，第四个参数是数据的有效期，就是说数据在这个时间内是有效的，如果过去这个时间，那么会被Memcache服务器端清除掉这个数据，单位是秒，如果设置为0，则是永远有效，我们这里设置了60，就是一分钟有效时间：</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;set(&#39;key1&#39;, &#39;This is first value&#39;, 0, 60);</code></pre></div><p>从Memcache服务器端获取一条数据，它只有一个参数，就是需要获取数据的key，我们这里是上一步设置的key1，现在获取这个数据后输出输出：</p><div class=\"highlight\"><pre><code class=\"language-text\">$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val;</code></pre></div><p>现在是使用replace方法来替换掉上面key1的值，replace方法的参数跟set是一样的，不过第一个参数key1是必须是要替换数据内容的key，最后输出了：</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;replace(&#39;key1&#39;, &#39;This is replace value&#39;, 0, 60);\n$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val;</code></pre></div><p>同样的，Memcache也是可以保存数组的，下面是在Memcache上面保存了一个数组，然后获取回来并输出</p><div class=\"highlight\"><pre><code class=\"language-text\">$arr = array(&#39;aaa&#39;, &#39;bbb&#39;, &#39;ccc&#39;, &#39;ddd&#39;);\n$mem-&gt;set(&#39;key2&#39;, $arr, 0, 60);\n$val2 = $mem-&gt;get(&#39;key2&#39;);\nprint_r($val2);</code></pre></div><p>现在删除一个数据，使用delte接口，参数就是一个key，然后就能够把Memcache服务器这个key的数据删除，最后输出的时候没有结果</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;delete(&#39;key1&#39;);\n$val = $mem-&gt;get(&#39;key1&#39;);\necho &#34;Get key1 value: &#34; . $val . &#34;\n&#34;;</code></pre></div><p>最后我们把所有的保存在Memcache服务器上的数据都清除，会发现数据都没有了，最后输出key2的数据为空，最后关闭连接</p><div class=\"highlight\"><pre><code class=\"language-text\">$mem-&gt;flush();\n$val2 = $mem-&gt;get(&#39;key2&#39;);\necho &#34;Get key2 value: &#34;;\nprint_r($val2);\necho &#34;\n&#34;;</code></pre></div><p><b>Memcache的使用</b></p><p>使用Memcache的网站一般流量都是比较大的，为了缓解数据库的压力，让Memcache作为一个缓存区域，把部分信息保存在内存中，在前端能够迅速的进行存取。那么一般的焦点就是集中在如何分担数据库压力和进行分布式，毕竟单台Memcache的内存容量的有限的。我这里简单提出我的个人看法，未经实践，权当参考。</p><p>分布式应用</p><p>Memcache本来支持分布式，我们客户端稍加改造，更好的支持。我们的key可以适当进行有规律的封装，比如以user为主的网站来说，每个用户都有User</p><p>ID，那么可以按照固定的ID来进行提取和存取，比如1开头的用户保存在第一台Memcache服务器上，以2开头的用户的数据保存在第二胎Mecache服务器上，存取数据都先按照User</p><p>ID来进行相应的转换和存取。</p><p>但是这个有缺点，就是需要对User ID进行判断，如果业务不一致，或者其他类型的应用，可能不是那么合适，那么可以根据自己的实际业务来进行考虑，或者去想更合适的方法。</p><p>减少数据库压力</p><p>这个算是比较重要的，所有的数据基本上都是保存在数据库当中的，每次频繁的存取数据库，导致数据库性能极具下降，无法同时服务更多的用户，比如MySQL，特别频繁的锁表，那么让Memcache来分担数据库的压力吧。我们需要一种改动比较小，并且能够不会大规模改变前端的方式来进行改变目前的架构。</p><p>我考虑的一种简单方法：</p><p>后端的数据库操作模块，把所有的Select操作提取出来（update/delete/insert不管），然后把对应的SQL进行相应的hash算法计算得出一个hash数据key（比如MD5或者SHA），然后把这个key去Memcache中查找数据，如果这个数据不存在，说明还没写入到缓存中，那么从数据库把数据提取出来，一个是数组类格式，然后把数据在set到Memcache中，key就是这个SQL的hash值，然后相应的设置一个失效时间，比如一个小时，那么一个小时中的数据都是从缓存中提取的，有效减少数据库的压力。缺点是数据不实时，当数据做了修改以后，无法实时到前端显示，并且还有可能对内存占用比较大，毕竟每次select出来的数据数量可能比较巨大，这个是需要考虑的因素。</p><p><b>Memcache的安全</b></p><p>我们上面的Memcache服务器端都是直接通过客户端连接后直接操作，没有任何的验证过程，这样如果服务器是直接暴露在互联网上的话是比较危险，轻则数据泄露被其他无关人员查看，重则服务器被入侵，因为Mecache是以root权限运行的，况且里面可能存在一些我们未知的bug或者是缓冲区溢出的情况，这些都是我们未知的，所以危险性是可以预见的。为了安全起见，我做两点建议，能够稍微的防止黑客的入侵或者数据的泄露。</p><p>内网访问</p><p>最好把两台服务器之间的访问是内网形态的，一般是Web服务器跟Memcache服务器之间。普遍的服务器都是有两块网卡，一块指向互联网，一块指向内网，那么就让Web服务器通过内网的网卡来访问Memcache服务器，我们Memcache的服务器上启动的时候就监听内网的IP地址和端口，内网间的访问能够有效阻止其他非法的访问。</p><div class=\"highlight\"><pre><code class=\"language-text\"># memcached -d -m 1024 -u root -l 192.168.0.200 -p 11211 -c 1024 -P /tmp/memcached.pid</code></pre></div><p>Memcache服务器端设置监听通过内网的192.168.0.200的ip的11211端口，占用1024MB内存，并且允许最大1024个并发连接设置防火墙</p><p>防火墙是简单有效的方式，如果却是两台服务器都是挂在网的，并且需要通过外网IP来访问Memcache的话，那么可以考虑使用防火墙或者代理程序来过滤非法访问。</p><p>一般我们在Linux下可以使用iptables或者FreeBSD下的ipfw来指定一些规则防止一些非法的访问，比如我们可以设置只允许我们的Web服务器来访问我们Memcache服务器，同时阻止其他的访问。</p><div class=\"highlight\"><pre><code class=\"language-text\"># iptables -F\n# iptables -P INPUT DROP\n# iptables -A INPUT -p tcp -s 192.168.0.2 --dport 11211 -j ACCEPT\n# iptables -A INPUT -p udp -s 192.168.0.2 --dport 11211 -j ACCEPT</code></pre></div><p>上面的iptables规则就是只允许192.168.0.2这台Web服务器对Memcache服务器的访问，能够有效的阻止一些非法访问，相应的也可以增加一些其他的规则来加强安全性，这个可以根据自己的需要来做。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Memcached", 
                    "tagLink": "https://api.zhihu.com/topics/19577046"
                }, 
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36052225", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "PHP操作Redis详解案例", 
            "content": "<p>$redis = new Redis();<br/></p><p>connect, open 链接redis服务</p><p>参数</p><p>host: string，服务地址</p><p>port: int,端口号</p><p>timeout: float,链接时长 (可选, 默认为 0 ，不限链接时间)</p><p>注: 在redis.conf中也有时间，默认为300</p><p>pconnect, popen 不会主动关闭的链接</p><p>参考上面</p><p>setOption 设置redis模式</p><p>getOption 查看redis设置的模式</p><p>ping 查看连接状态</p><p>get 得到某个key的值（string值）</p><p>如果该key不存在，return false</p><p>set 写入key 和 value（string值）</p><p>如果写入成功，return ture</p><p>setex 带生存时间的写入值</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;setex(&#39;key&#39;, 3600, &#39;value&#39;); // sets key → value, with 1h TTL.</code></pre></div><p>setnx 判断是否重复的，写入值</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;setnx(&#39;key&#39;, &#39;value&#39;);\n$redis-&gt;setnx(&#39;key&#39;, &#39;value&#39;);</code></pre></div><p>delete 删除指定key的值</p><p>返回已经删除key的个数（长整数）</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;delete(&#39;key1&#39;, &#39;key2&#39;);\n$redis-&gt;delete(array(&#39;key3&#39;, &#39;key4&#39;, &#39;key5&#39;));</code></pre></div><p>ttl</p><p>得到一个key的生存时间</p><p>persist</p><p>移除生存时间到期的key</p><p>如果key到期 true 如果不到期 false</p><p>mset （redis版本1.1以上才可以用）</p><p>同时给多个key赋值</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;mset(array(&#39;key0&#39; =&gt; &#39;value0&#39;, &#39;key1&#39; =&gt; &#39;value1&#39;));</code></pre></div><p>multi, exec, discard</p><p>进入或者退出事务模式</p><p>参数可选Redis::MULTI或Redis::PIPELINE. 默认是 Redis::MULTI</p><p>Redis::MULTI：将多个操作当成一个事务执行</p><p>Redis::PIPELINE:让（多条）执行命令简单的，更加快速的发送给服务器，但是没有任何原子性的保证</p><p>discard:删除一个事务</p><p>返回值</p><p>multi()，返回一个redis对象，并进入multi-mode模式，一旦进入multi-mode模式，以后调用的所有方法都会返回相同的对象，只到exec(）方法被调用。</p><p>watch, unwatch （代码测试后，不能达到所说的效果）</p><p>监测一个key的值是否被其它的程序更改。如果这个key在watch 和 exec （方法）间被修改，这个 MULTI/EXEC 事务的执行将失败（return false）</p><p>unwatch 取消被这个程序监测的所有key</p><p>参数，一对key的列表</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;watch(&#39;x&#39;);\n$ret = $redis-&gt;multi() -&gt;incr(&#39;x&#39;) -&gt;exec();\nsubscribe *</code></pre></div><p>方法回调。注意，该方法可能在未来里发生改变</p><p>publish *</p><p>发表内容到某一个通道。注意，该方法可能在未来里发生改变</p><p>exists</p><p>判断key是否存在。存在 true 不在 false</p><p>incr, incrBy</p><p>key中的值进行自增1，如果填写了第二个参数，者自增第二个参数所填的值</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;incr(&#39;key1&#39;);\n$redis-&gt;incrBy(&#39;key1&#39;, 10);\ndecr, decrBy</code></pre></div><p>做减法，使用方法同incr</p><p>getMultiple</p><p>传参</p><p>由key组成的数组</p><p>返回参数</p><p>如果key存在返回value，不存在返回false</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;key1&#39;,\n &#39;value1&#39;); $redis-&gt;set(&#39;key2&#39;, &#39;value2&#39;); $redis-&gt;set(&#39;key3&#39;, \n&#39;value3&#39;); $redis-&gt;getMultiple(array(&#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;));\n$redis-&gt;lRem(&#39;key1&#39;, &#39;A&#39;, 2);\n$redis-&gt;lRange(&#39;key1&#39;, 0, -1);</code></pre></div><p>list相关操作</p><p>lPush</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lPush(key, value);</code></pre></div><p>在名称为key的list左边（头）添加一个值为value的 元素</p><p>rPush</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;rPush(key, value);</code></pre></div><p>在名称为key的list右边（尾）添加一个值为value的 元素</p><p>lPushx/rPushx</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lPushx(key, value);</code></pre></div><p>在名称为key的list左边(头)/右边（尾）添加一个值为value的元素,如果value已经存在，则不添加</p><p>lPop/rPop</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lPop(&#39;key&#39;);</code></pre></div><p>输出名称为key的list左(头)起/右（尾）起的第一个元素，删除该元素</p><p>blPop/brPop</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;blPop(&#39;key1&#39;, &#39;key2&#39;, 10);</code></pre></div><p>lpop命令的block版本。即当timeout为0时，若遇到名称为key<b>i</b>的list不存在或该list为空，则命令结束。如果timeout&gt;0，则遇到上述情况时，等待timeout秒，如果问题没有解决，则对key<b>i+1</b>开始的list执行pop操作</p><p>lSize</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lSize(&#39;key&#39;);</code></pre></div><p>返回名称为key的list有多少个元素</p><p>lIndex, lGet</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lGet(&#39;key&#39;, 0);</code></pre></div><p>返回名称为key的list中index位置的元素</p><p>lSet</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lSet(&#39;key&#39;, 0, &#39;X&#39;);</code></pre></div><p>给名称为key的list中index位置的元素赋值为value</p><p>lRange, lGetRange</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lRange(&#39;key1&#39;, 0, -1);</code></pre></div><p>返回名称为key的list中start至end之间的元素（end为 -1 ，返回所有）</p><p>lTrim, listTrim</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lTrim(&#39;key&#39;, start, end);</code></pre></div><p>截取名称为key的list，保留start至end之间的元素</p><p>lRem, lRemove</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;lRem(&#39;key&#39;, &#39;A&#39;, 2);</code></pre></div><p>删除count个名称为key的list中值为value的元素。count为0，删除所有值为value的元素，count&gt;0从头至尾删除count个值为value的元素，count&lt;0从尾到头删除|count|个值为value的元素</p><p>lInsert</p><p>在名称为为key的list中，找到值为pivot<br/> 的value，并根据参数Redis::BEFORE | Redis::AFTER，来确定，newvalue 是放在 pivot <br/>的前面，或者后面。如果key不存在，不会插入，如果 pivot不存在，return -1</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;delete(&#39;key1&#39;);\n $redis-&gt;lInsert(&#39;key1&#39;, Redis::AFTER, &#39;A&#39;, &#39;X&#39;); \n$redis-&gt;lPush(&#39;key1&#39;, &#39;A&#39;); $redis-&gt;lPush(&#39;key1&#39;, &#39;B&#39;); \n$redis-&gt;lPush(&#39;key1&#39;, &#39;C&#39;); $redis-&gt;lInsert(&#39;key1&#39;, Redis::BEFORE,\n &#39;C&#39;, &#39;X&#39;);\n$redis-&gt;lRange(&#39;key1&#39;, 0, -1);\n$redis-&gt;lInsert(&#39;key1&#39;, Redis::AFTER, &#39;C&#39;, &#39;Y&#39;);\n$redis-&gt;lRange(&#39;key1&#39;, 0, -1);\n$redis-&gt;lInsert(&#39;key1&#39;, Redis::AFTER, &#39;W&#39;, &#39;value&#39;);</code></pre></div><p>rpoplpush</p><p>返回并删除名称为srckey的list的尾元素，并将该元素添加到名称为dstkey的list的头部</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;delete(&#39;x&#39;, &#39;y&#39;);\n$redis-&gt;lPush(&#39;x&#39;,\n &#39;abc&#39;); $redis-&gt;lPush(&#39;x&#39;, &#39;def&#39;); $redis-&gt;lPush(&#39;y&#39;, &#39;123&#39;); \n$redis-&gt;lPush(&#39;y&#39;, &#39;456&#39;); // move the last of x to the front of y. \nvar_dump($redis-&gt;rpoplpush(&#39;x&#39;, &#39;y&#39;));\nvar_dump($redis-&gt;lRange(&#39;x&#39;, 0, -1));\nvar_dump($redis-&gt;lRange(&#39;y&#39;, 0, -1));\nstring(3) &#34;abc&#34;\narray(1) { [0]=&gt; string(3) &#34;def&#34; }\narray(3) { [0]=&gt; string(3) &#34;abc&#34; [1]=&gt; string(3) &#34;456&#34; [2]=&gt; string(3) &#34;123&#34; }</code></pre></div><p>SET操作相关</p><p>sAdd</p><p>向名称为key的set中添加元素value,如果value存在，不写入，return false</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;sAdd(key , value);</code></pre></div><p>sRem, sRemove</p><p>删除名称为key的set中的元素value</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;sAdd(&#39;key1&#39; , &#39;set1&#39;);\n$redis-&gt;sAdd(&#39;key1&#39; , &#39;set2&#39;);\n$redis-&gt;sAdd(&#39;key1&#39; , &#39;set3&#39;);\n$redis-&gt;sRem(&#39;key1&#39;, &#39;set2&#39;);</code></pre></div><p>sMove</p><p>将value元素从名称为srckey的集合移到名称为dstkey的集合</p><p>$redis-&gt;sMove(seckey, dstkey, value);</p><p>sIsMember, sContains</p><p>名称为key的集合中查找是否有value元素，有ture 没有 false</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;sIsMember(key, value);</code></pre></div><p>sCard, sSize</p><p>返回名称为key的set的元素个数</p><p>sPop</p><p>随机返回并删除名称为key的set中一个元素</p><p>sRandMember</p><p>随机返回名称为key的set中一个元素，不删除</p><p>sInter</p><p>求交集</p><p>sInterStore</p><p>求交集并将交集保存到output的集合</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;sInterStore(&#39;output&#39;, &#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;)</code></pre></div><p>sUnion</p><p>求并集</p><p>$redis-&gt;sUnion(&#39;s0&#39;, &#39;s1&#39;, &#39;s2&#39;);</p><p>s0,s1,s2 同时求并集</p><p>sUnionStore</p><p>求并集并将并集保存到output的集合</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;sUnionStore(&#39;output&#39;, &#39;key1&#39;, &#39;key2&#39;, &#39;key3&#39;)；</code></pre></div><p>sDiff</p><p>求差集</p><p>sDiffStore</p><p>求差集并将差集保存到output的集合</p><p>sMembers, sGetMembers</p><p>返回名称为key的set的所有元素</p><p>sort</p><p>排序，分页等</p><p>参数</p><div class=\"highlight\"><pre><code class=\"language-text\">&#39;by&#39; =&gt; &#39;some_pattern_*&#39;,\n&#39;limit&#39; =&gt; array(0, 1),\n&#39;get&#39; =&gt; &#39;some_other_pattern_*&#39; or an array of patterns,\n&#39;sort&#39; =&gt; &#39;asc&#39; or &#39;desc&#39;,\n&#39;alpha&#39; =&gt; TRUE,\n&#39;store&#39; =&gt; &#39;external-key&#39;</code></pre></div><p>例子</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;delete(&#39;s&#39;);\n $redis-&gt;sadd(&#39;s&#39;, 5); $redis-&gt;sadd(&#39;s&#39;, 4); $redis-&gt;sadd(&#39;s&#39;, \n2); $redis-&gt;sadd(&#39;s&#39;, 1); $redis-&gt;sadd(&#39;s&#39;, 3);\nvar_dump($redis-&gt;sort(&#39;s&#39;)); // 1,2,3,4,5\nvar_dump($redis-&gt;sort(&#39;s&#39;, array(&#39;sort&#39; =&gt; &#39;desc&#39;))); // 5,4,3,2,1\nvar_dump($redis-&gt;sort(&#39;s&#39;, array(&#39;sort&#39; =&gt; &#39;desc&#39;, &#39;store&#39; =&gt; &#39;out&#39;))); // (int)5</code></pre></div><p>string命令</p><p>getSet</p><p>返回原来key中的值，并将value写入key</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;x&#39;, &#39;42&#39;);\n$exValue = $redis-&gt;getSet(&#39;x&#39;, &#39;lol&#39;); // return &#39;42&#39;, replaces x by &#39;lol&#39;\n$newValue = $redis-&gt;get(&#39;x&#39;)&#39; // return &#39;lol&#39;</code></pre></div><p>append</p><p>string，名称为key的string的值在后面加上value</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;key&#39;, &#39;value1&#39;);\n$redis-&gt;append(&#39;key&#39;, &#39;value2&#39;);\n$redis-&gt;get(&#39;key&#39;);</code></pre></div><p>getRange （方法不存在）</p><p>返回名称为key的string中start至end之间的字符</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;key&#39;, &#39;string value&#39;);\n$redis-&gt;getRange(&#39;key&#39;, 0, 5);\n$redis-&gt;getRange(&#39;key&#39;, -5, -1);</code></pre></div><p>setRange （方法不存在）</p><p>改变key的string中start至end之间的字符为value</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;key&#39;, &#39;Hello world&#39;);\n$redis-&gt;setRange(&#39;key&#39;, 6, &#34;redis&#34;);\n$redis-&gt;get(&#39;key&#39;);</code></pre></div><p>strlen</p><p>得到key的string的长度</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;strlen(&#39;key&#39;);\ngetBit/setBit</code></pre></div><p>返回2进制信息</p><p><b>zset（sorted set）操作相关</b></p><p>zAdd<b>(key, score, member)</b>：向名称为key的zset中添加元素member，score用于排序。如果该元素已经存在，则根据score更新该元素的顺序。</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zAdd(&#39;key&#39;, 1, &#39;val1&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 0, &#39;val0&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 5, &#39;val5&#39;);\n$redis-&gt;zRange(&#39;key&#39;, 0, -1); // array(val0, val1, val5)</code></pre></div><p>zRange<b>(key, start, end,</b>withscores<b>)</b>：返回名称为key的zset（元素已按score从小到大排序）中的index从start到end的所有元素</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zAdd(&#39;key1&#39;, 0, &#39;val0&#39;);\n$redis-&gt;zAdd(&#39;key1&#39;, 2, &#39;val2&#39;);\n$redis-&gt;zAdd(&#39;key1&#39;, 10, &#39;val10&#39;);\n$redis-&gt;zRange(&#39;key1&#39;, 0, -1); // with scores $redis-&gt;zRange(&#39;key1&#39;, 0, -1, true);\nzDelete, zRem</code></pre></div><p>zRem<b>(key, member)</b>：删除名称为key的zset中的元素member</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zAdd(&#39;key&#39;, 0, &#39;val0&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 2, &#39;val2&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 10, &#39;val10&#39;);\n$redis-&gt;zDelete(&#39;key&#39;, &#39;val2&#39;);\n$redis-&gt;zRange(&#39;key&#39;, 0, -1);</code></pre></div><p>zRevRange<b>(key, start, end,</b>withscores<b>)</b>：返回名称为key的zset（元素已按score从大到小排序）中的index从start到end的所有元素.withscores: 是否输出socre的值，默认false，不输出</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zAdd(&#39;key&#39;, 0, &#39;val0&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 2, &#39;val2&#39;);\n$redis-&gt;zAdd(&#39;key&#39;, 10, &#39;val10&#39;);\n$redis-&gt;zRevRange(&#39;key&#39;, 0, -1); // with scores $redis-&gt;zRevRange(&#39;key&#39;, 0, -1, true);\nzRangeByScore, zRevRangeByScore\n$redis-&gt;zRangeByScore(key, star, end, array(withscores， limit ));</code></pre></div><p>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素</p><p>zCount</p><p>$redis-&gt;zCount(key, star, end);</p><p>返回名称为key的zset中score &gt;= star且score &lt;= end的所有元素的个数</p><p>zRemRangeByScore, zDeleteRangeByScore</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zRemRangeByScore(&#39;key&#39;, star, end);</code></pre></div><p>删除名称为key的zset中score &gt;= star且score &lt;= end的所有元素，返回删除个数</p><p>zSize, zCard</p><p>返回名称为key的zset的所有元素的个数</p><p>zScore</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zScore(key, val2);</code></pre></div><p>返回名称为key的zset中元素val2的score</p><p>zRank, zRevRank</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zRevRank(key, val);</code></pre></div><p>返回名称为key的zset（元素已按score从小到大排序）中val元素的rank（即index，从0开始），若没有val元素，返回“null”。zRevRank 是从大到小排序</p><p>zIncrBy</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;zIncrBy(&#39;key&#39;, increment, &#39;member&#39;);</code></pre></div><p>如果在名称为key的zset中已经存在元素member，则该元素的score增加increment；否则向集合中添加该元素，其score的值为increment</p><p>zUnion/zInter</p><p>参数</p><p>keyOutput</p><p>arrayZSetKeys</p><p>arrayWeights</p><p>aggregateFunction Either &#34;SUM&#34;, &#34;MIN&#34;, or &#34;MAX&#34;: defines the behaviour to use on duplicate entries during the zUnion.</p><p>对N个zset求并集和交集，并将最后的集合保存在dstkeyN中。对于集合中每一个元素的score，在进行AGGREGATE运算前，都要乘以对于的WEIGHT参数。如果没有提供WEIGHT，默认为1。默认的AGGREGATE是SUM，即结果集合中元素的score是所有集合对应元素进行SUM运算的值，而MIN和MAX是指，结果集合中元素的score是所有集合对应元素中最小值和最大值。</p><p><b>Hash操作</b></p><p>hSet</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hSet(&#39;h&#39;, &#39;key1&#39;, &#39;hello&#39;);</code></pre></div><p>向名称为h的hash中添加元素key1—&gt;hello</p><p>hGet</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hGet(&#39;h&#39;, &#39;key1&#39;);</code></pre></div><p>返回名称为h的hash中key1对应的value（hello）</p><p>hLen</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hLen(&#39;h&#39;);</code></pre></div><p>返回名称为h的hash中元素个数</p><p>hDel</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hDel(&#39;h&#39;, &#39;key1&#39;);</code></pre></div><p>删除名称为h的hash中键为key1的域</p><p>hKeys</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hKeys(&#39;h&#39;);</code></pre></div><p>返回名称为key的hash中所有键</p><p>hVals</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hVals(&#39;h&#39;)</code></pre></div><p>返回名称为h的hash中所有键对应的value</p><p>hGetAll</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hGetAll(&#39;h&#39;);</code></pre></div><p>返回名称为h的hash中所有的键（field）及其对应的value</p><p>hExists</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hExists(&#39;h&#39;, &#39;a&#39;);</code></pre></div><p>名称为h的hash中是否存在键名字为a的域</p><p>hIncrBy</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hIncrBy(&#39;h&#39;, &#39;x&#39;, 2);</code></pre></div><p>将名称为h的hash中x的value增加2</p><p>hMset</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;hMset(&#39;user:1&#39;, array(&#39;name&#39; =&gt; &#39;Joe&#39;, &#39;salary&#39; =&gt; 2000));</code></pre></div><p>向名称为key的hash中批量添加元素</p><div class=\"highlight\"><pre><code class=\"language-text\">hMGet\n$redis-&gt;hmGet(&#39;h&#39;, array(&#39;field1&#39;, &#39;field2&#39;));</code></pre></div><p>返回名称为h的hash中field1,field2对应的value</p><p>redis 操作相关</p><p>flushDB</p><p>清空当前数据库</p><p>flushAll</p><p>清空所有数据库</p><p>randomKey</p><p>随机返回key空间的一个key</p><div class=\"highlight\"><pre><code class=\"language-text\">$key = $redis-&gt;randomKey();</code></pre></div><p>select</p><p>选择一个数据库</p><p>move</p><p>转移一个key到另外一个数据库</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;select(0); // switch to DB 0\n$redis-&gt;set(&#39;x&#39;, &#39;42&#39;); // write 42 to x\n$redis-&gt;move(&#39;x&#39;, 1); // move to DB 1\n$redis-&gt;select(1); // switch to DB 1\n$redis-&gt;get(&#39;x&#39;); // will return 42</code></pre></div><p>rename, renameKey</p><p>给key重命名</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;set(&#39;x&#39;, &#39;42&#39;);\n$redis-&gt;rename(&#39;x&#39;, &#39;y&#39;);\n$redis-&gt;get(&#39;y&#39;); // → 42\n$redis-&gt;get(&#39;x&#39;); // → `FALSE`</code></pre></div><p>renameNx</p><p>与remane类似，但是，如果重新命名的名字已经存在，不会替换成功</p><p>setTimeout, expire</p><p>设定一个key的活动时间（s）</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;setTimeout(&#39;x&#39;, 3);</code></pre></div><p>expireAt</p><p>key存活到一个unix时间戳时间</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;expireAt(&#39;x&#39;, time() + 3);</code></pre></div><p>keys, getKeys</p><p>返回满足给定pattern的所有key</p><div class=\"highlight\"><pre><code class=\"language-text\">$keyWithUserPrefix = $redis-&gt;keys(&#39;user*&#39;);</code></pre></div><p>dbSize</p><p>查看现在数据库有多少key</p><div class=\"highlight\"><pre><code class=\"language-text\">$count = $redis-&gt;dbSize();</code></pre></div><p>auth</p><p>密码认证</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;auth(&#39;foobared&#39;);</code></pre></div><p>bgrewriteaof</p><p>使用aof来进行数据库持久化</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;bgrewriteaof();</code></pre></div><p>slaveof</p><p>选择从服务器</p><div class=\"highlight\"><pre><code class=\"language-text\">$redis-&gt;slaveof(&#39;10.0.1.7&#39;, 6379);</code></pre></div><p>save</p><p>将数据同步保存到磁盘</p><p>bgsave</p><p>将数据异步保存到磁盘</p><p>lastSave</p><p>返回上次成功将数据保存到磁盘的Unix时戳</p><p>info</p><p>返回redis的版本信息等详情</p><p>type</p><p>返回key的类型值</p><div class=\"highlight\"><pre><code class=\"language-text\">string: Redis::REDIS_STRING\nset: Redis::REDIS_SET\nlist: Redis::REDIS_LIST\nzset: Redis::REDIS_ZSET\nhash: Redis::REDIS_HASH\nother: Redis::REDIS_NOT_FOUND</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }, 
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35864990", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "微信企业付款到个人钱包引发的坑之反思~！", 
            "content": "<p>企业付款到个人钱包也就是用户在微信公众平台提现可以直接打入提现者微信的钱包！但要满足：</p><p>1）企业开通微信支付90天</p><p>2）连续30天有交易才能开通此功能</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-dda542dbdf611a1ba1a077165b8ebd7b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"73\" data-rawheight=\"71\" class=\"content_image\" width=\"73\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;73&#39; height=&#39;71&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"73\" data-rawheight=\"71\" class=\"content_image lazy\" width=\"73\" data-actualsrc=\"https://pic4.zhimg.com/v2-dda542dbdf611a1ba1a077165b8ebd7b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>今天有幸能开发此功能，我只能说我又涨知识了！！！在我编程的这条道路上我又多见到了一些坑！下面就给大家讲一下今天遇到的两个坑！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7b55e3a044b33b2614a53299b16a966c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image\" width=\"80\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;80&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"80\" data-actualsrc=\"https://pic1.zhimg.com/v2-7b55e3a044b33b2614a53299b16a966c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>1）CA证书引入问题，开发过程中遇到了CA证书验证失败的问题，百度之后网上有的说要用绝对路径，有的人说要用相对路径！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-64df78869e04e8c69fed42c9f6047a0e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-64df78869e04e8c69fed42c9f6047a0e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>小梦使用的是Thinkphp3.2框架开发的这个功能，最终我结果告诉我用绝对路径，还要用到PHP的一个函数getcwd()，代码如下</p><div class=\"highlight\"><pre><code class=\"language-text\">curl_setopt($curl,CURLOPT_SSLCERT,getcwd().&#34;/cert/apiclient_cert.pem&#34;);\ncurl_setopt($curl,CURLOPT_SSLKEY,getcwd().&#34;/cert/apiclient_key.pem&#34;);\ncurl_setopt($curl,CURLOPT_CAINFO,getcwd().&#34;/cert/rootca.pem&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fa2bbcd1ec72435022a36943694d8526_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"164\" class=\"content_image\" width=\"174\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;174&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"174\" data-rawheight=\"164\" class=\"content_image lazy\" width=\"174\" data-actualsrc=\"https://pic3.zhimg.com/v2-fa2bbcd1ec72435022a36943694d8526_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2）签名和提交数据的一致性问题：</p><p>微信签名文档上有详细的说明，但是我按照文档操作迟迟都是签名验证失败！最终总结如下注意点：</p><p>（1）key是商户设置的密匙和微信支付统一下单的密匙是一样的</p><p>（2）加密的数据顺序和提交到微信接口参数值的顺序不能改变也就是我们在               传递参数的时候直接讲数组转换成xml提交到微信api，代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">$dataArr=array();\n$dataArr[&#39;amount&#39;]=&#34;金额&#34;;\n$dataArr[&#39;check_name&#39;]=&#34;FORCE_CHECK&#34;;\n$dataArr[&#39;desc&#39;]=&#34;xxxx&#34;;\n$dataArr[&#39;mch_appid&#39;]=&#34;微信公众平台的appid&#34;;\n$dataArr[&#39;mchid&#39;]=&#34;商户号&#34;;\n$dataArr[&#39;nonce_str&#39;]= &#34;随机数&#34;;\n$dataArr[&#39;openid&#39;]=“用户的openid”;\n$dataArr[&#39;partner_trade_no&#39;]=“交易号”;\n$dataArr[&#39;re_user_name&#39;]=“开启验证用户的真实姓名”;\n$dataArr[&#39;spbill_create_ip&#39;]=“ip地址”;\n$sign_obj = WechatSign::getInstance();\n$sign = $sign_obj-&gt;getSign($dataArr);\nWechatSign类文件如下：\n/**\n*  作用：格式化参数，签名过程需要使用\n*/\nfunction formatBizQueryParaMap($paraMap)\n{\n$buff = &#34;&#34;;\nforeach ($paraMap as $k =&gt; $v)\n{\nif($k != &#34;sign&#34; &amp;&amp; $v != &#34;&#34; &amp;&amp; !is_array($v)){\n$buff .= $k . &#34;=&#34; . $v . &#34;&amp;&#34;;\n}\n}\n$buff = trim($buff, &#34;&amp;&#34;);\nreturn $buff;\n}\n/**\n*  作用：生成签名\n*/\nfunction getSign($Obj)\n{\n//签名步骤一：按字典序排序参数\nksort($Obj);\n//dump($Obj);\n$String = $this-&gt;formatBizQueryParaMap($Obj);\n//echo &#39;【string1】&#39;.$String.&#39;\n&#39;;\n//签名步骤二：在string后加入KEY\n$String = $String.&#34;&amp;key=商户密匙&#34;;\n//echo &#34;【string2】&#34;.$String.&#34;\n&#34;;\n//签名步骤三：MD5加密\n$String = md5($String);\n//echo &#34;【string3】 &#34;.$String.&#34;\n&#34;;\n//签名步骤四：所有字符转为大写\n$result_ = strtoupper($String);\n//echo &#34;【result】 &#34;.$result_.&#34;\n&#34;;\nreturn $result_;\n}</code></pre></div><p>之后获取到签名之后我们直接将数组转换成xml传给微信api</p><p>//数组转XML</p><div class=\"highlight\"><pre><code class=\"language-text\">functionarrayToXml($arr)\n{\n$xml= &#34;&#34;;\nforeach($arras$key=&gt;$val){\nif(is_numeric($val)){\n$xml.=&#34;&lt;&#34;.$key.&#34;&gt;&#34;.$val.&#34;&#34;;\n}else{\n$xml.=&#34;&lt;&#34;.$key.&#34;&gt;&#34;;\n}\n}\n$xml.=&#34;&#34;;\nreturn$xml;\n}</code></pre></div><p>就是这样简简单单的几步，因为参数位置顺序以及数据统一问题拜拜浪费了很多时间，希望哪个小伙伴调用这个接口的时候一定要注意，不要和我一样马马虎虎，简单事情复杂化，一定要好好看文档！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0403ba2eb51f3c6b83adb29bacc8506a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-0403ba2eb51f3c6b83adb29bacc8506a_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "微信支付", 
                    "tagLink": "https://api.zhihu.com/topics/19873553"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35864963", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "TCP/IP", 
            "content": "<p>作为互联网时代伟大发明的TCP/IP技术可以说对当今时代产生了深刻的影响。经过近一个月的学习摸索，基本清楚了TCP/IP的面貌。由于TCP/IP在OS中位于内核态，很多细节其实用户无法感知，所以自己对于TCP/IP会有一些疑惑。关于其中几个点经过查阅一些书籍、博客并结合自己的一些理解，在此整理精炼成帖。</p><p><b>疑惑1 — 关于拥塞</b></p><p><b>疑惑一：</b>无论是满启动还是拥塞避免阶段，拥塞窗口都在增加，理论上一定会碰到拥塞点，为什么平时感觉不到拥塞呢？</p><p>看了很多书和文献以后可能的解答如下：</p><p>1、OS中对接收窗口的最大设定多年未动，如windows在不启用“TCP Window Option”情况下，最大接收窗口仅64KB。然而网络进步，很多环境的拥塞点远在64kb以上，即发送窗口永远触碰不到拥塞点</p><p>2、很多应用场景是交互式小数据交换，如聊天等，不会有拥塞的可能</p><p>3、有些应用在传输数据时采用同步方式，可能需要的窗口非常小（如采用了同步方式的NFS写操作，每发一个写请求就停下来等回复，而一个写请求可能仅有4kb）</p><p>4、即便偶尔拥塞，持续时间也不足以长到能感受出来，除非抓包看包交换细节</p><p><b>疑惑2 — 关于超时重传</b></p><p><b>疑惑二：</b>关于超时重传后的ssthresh设置问题的争议</p><p>1、Richard Stevens在《TCP/IP详解》中把临界窗口值定为上次发生拥塞时的发送窗口的一半</p><p>2、RFC5681则认为应是发生拥塞时未被确认的数据量的1/2（又称FlightSize），且不小于2MSS</p><p>3、Westwood/Westwood+算法则这样认为：先推算出有多少包已被送达到接收方（可根据收方回应的ACK来推算），从而精确地估算发生拥塞时的带宽，最后再依据带宽来确认新的拥塞窗口</p><p>4、Vegas算法则这样认为：引入全新的概念，摒弃之前的在丢包后才调节拥塞窗口的做法。其通过监控网络状态来调整发包速度，实现“真正的拥塞避免”。当网络良好时，RTT较稳定，此时可以增加拥塞窗口；当网络繁忙时，RTT增加，此时减小拥塞窗口</p><p>5、Compound算法这样认为：同时维持两个拥塞窗口，一个类似于Vegas，另一个类似于RFC5681，真正起作用的是两者之和（Win7上其默认关闭）</p><p>6、BIC算法/CUBIC算法</p><p>分别是linux2.6.18和linux 2.6.19所采用，目前尚未研究</p><p><b>关于TCP/IP的几点精炼总结：</b></p><p>（1）当无拥塞时，发送窗口越大，性能越好。∴在带宽没有限制的情况下，应尽量增加接受窗口，比如启用Scale Option</p><p>（2）若经常发生拥塞，则限制发送窗口反而可以提高性能，∵即便万分之一的重传对性能的影响都非常大。很多OS上可通过限制接收窗口的方法来发送窗口</p><p>（3）超时重传对于性能影响最大，∵RTO时间内未传输任何数据，而Cwnd会被设成1MSS，应尽量避免</p><p>（4）快速重传对性能影响小一些，∵无等待时间，且Cwnd减幅不大</p><p>（5）SACK和NewReno有利于增加重传效率，增加传输性能</p><p>（6）丢包对极小文件的影响比打文件严重。深层原因是因为读写一个小文件需要的包数很少，∴丢包时往往凑不满三个Dup ACK，只能等待超时重传；而大文件有较大可能触发快速重传</p><p></p>", 
            "topic": [
                {
                    "tag": "TCP/IP", 
                    "tagLink": "https://api.zhihu.com/topics/19614019"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775827", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 2, 
            "title": "Linux下自动化监控内存、存储空间！", 
            "content": "<p>距离上一次更新文章已经过去一段时间了，小编在这段时间因为一些琐事，加上身体生病不能及时更新文章，今天身体逐渐恢复就急忙来更新文章，今天思梦给大家带来的就是如何自动化监控我们的服务器一些基本的配置来保证我们应用能更好的运行以及做好性能瓶颈的预测！<br/></p><p>今天主要内容包含，Linux的基础Shell编程的流程控制语句、cut的使用、grep的使用、以及awk的使用就可以实现我们所说的事情了！</p><p>以下所讲命令配合不同的参数有不同的用处，思梦给大家讲的都是一些为了实现所说功能的基础使用，小伙伴们如果想更好的使用以下命令可以参考文档去尝试配合不同参数来实验！</p><p>1）首先讲一下Shell的流程控制语句if，格式为</p><p>if command;then</p><p>逻辑处理</p><p>else</p><p>逻辑处理</p><p>fi</p><p>以上需要注意的就是<b>if</b>最后的结尾要有一个<b>fi</b>。</p><p>2）cut的基本使用，它可以用一些规律性的分隔符去获取某一行</p><p>for example : a:b 这样一行字符串，我们想获取a，那么我们可以这样写：cut -d &#34;:&#34; -f 1 它的意思为：使用：分割然后获取第一行，-d后面接的就是用什么符号分割，题目上是&#34;<b>:</b>&#34;，当然也能是&#34;<b>;</b>&#34;等等，再后面的-f是我要打印输出的第几列</p><p>3）grep这个命令是强大的文本搜索工具，比如我们在一个文本里面想搜</p><p>for example:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7324d62331485d1a6f1756747c0ae422_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"340\" data-rawheight=\"80\" class=\"content_image\" width=\"340\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;340&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"340\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"340\" data-actualsrc=\"https://pic3.zhimg.com/v2-7324d62331485d1a6f1756747c0ae422_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们先创建一个simengphp.txt，然后我们想获取一下simengphp这个字符串这行，我们可以这样操作</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f3d8bb233be0c2db364e4ba2b5249fea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"30\" class=\"origin_image zh-lightbox-thumb\" width=\"426\" data-original=\"https://pic3.zhimg.com/v2-f3d8bb233be0c2db364e4ba2b5249fea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;426&#39; height=&#39;30&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"426\" data-rawheight=\"30\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"426\" data-original=\"https://pic3.zhimg.com/v2-f3d8bb233be0c2db364e4ba2b5249fea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f3d8bb233be0c2db364e4ba2b5249fea_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样我们就可以获取到了simengphp这行</p><p>4）awk这个命令比较复杂，我们直接讲怎么使用，awk &#39;{print $i}&#39; 意思为默认使用空格（不规则的，cut要规则）或者制表符分割，后面配合例子来给大家讲解</p><p>好了基本的命令给大家讲完了，我们现在需要做的就是动手去写Shell脚本来去实现我们的功能了</p><p>首先第一个我们来写监控内存的脚本，我们还要使用一条命令：free -h</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样我们就看到了第一行内存使用的状况了：那我们想要的是free这列值来进行监控，那么我们就一步一步去获取这行的值</p><p>1）先展示出来所有的，然后我们通过管道以此交给下一条命令去处理</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;75&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"75\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8c10e7e796b19fd53a24eb711454ef15_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2）我们使用grep这个命令获取到我们想要的这样</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1d54f44842214f844628a17960f1d2da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"35\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-1d54f44842214f844628a17960f1d2da_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"35\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-1d54f44842214f844628a17960f1d2da_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1d54f44842214f844628a17960f1d2da_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>3）通过awk命令我们获取到第四列然后并打印出来，$后面跟的是我们要打印的那列，print是和awk配合使用的，linux下print是不能单独使用的</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c2025895e8c346f99f3cf06f731f6da6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic3.zhimg.com/v2-c2025895e8c346f99f3cf06f731f6da6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;39&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"39\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic3.zhimg.com/v2-c2025895e8c346f99f3cf06f731f6da6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c2025895e8c346f99f3cf06f731f6da6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>4）后面再通过cut这个命令使用M来切分值，就能获取到了我们想要的值了</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-08837e65e7851fd25eba95fda5093027_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic4.zhimg.com/v2-08837e65e7851fd25eba95fda5093027_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;71&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic4.zhimg.com/v2-08837e65e7851fd25eba95fda5093027_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-08837e65e7851fd25eba95fda5093027_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上我们只是演示一下怎么获取我们想要的值，后面我们就直接开始写Shell脚本了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-76e4dc0355351fc7fe1f7d8e04617608_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-76e4dc0355351fc7fe1f7d8e04617608_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;635&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"635\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"635\" data-original=\"https://pic1.zhimg.com/v2-76e4dc0355351fc7fe1f7d8e04617608_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-76e4dc0355351fc7fe1f7d8e04617608_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们运行一下返回的是else里面的值，因为我们刚才看到的是204，正好大于200因此没有报警操作！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-179f3c18732e0b3aba43062aa5836b44_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"628\" data-original=\"https://pic1.zhimg.com/v2-179f3c18732e0b3aba43062aa5836b44_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;628&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"628\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"628\" data-original=\"https://pic1.zhimg.com/v2-179f3c18732e0b3aba43062aa5836b44_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-179f3c18732e0b3aba43062aa5836b44_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>那监控内存的功能大家看明白了后面监控硬盘空间的功能也是一样的，我直接给大家上脚本了</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-563c7272aba87de51af1a2a3cf204b48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb\" width=\"632\" data-original=\"https://pic1.zhimg.com/v2-563c7272aba87de51af1a2a3cf204b48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;632&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"632\" data-rawheight=\"143\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"632\" data-original=\"https://pic1.zhimg.com/v2-563c7272aba87de51af1a2a3cf204b48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-563c7272aba87de51af1a2a3cf204b48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>以上就是我们通过Shell脚本来实现自动化监控内存和使用硬盘空间的操作，然后我们通过定时任务去执行相应的脚本就可以了</p><p>脚本很粗糙，还有一些需要改进的地方，希望小伙伴们研究明白之后可以去优化一下然后去监控你们的服务器吧！</p>", 
            "topic": [
                {
                    "tag": "Linux 运维", 
                    "tagLink": "https://api.zhihu.com/topics/19648078"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775773", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "常见sql注入原理详解！", 
            "content": "<p>1、首先我们创建一个mysqli的链接</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ae9b1931011a17239f27413f8aac7881_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-ae9b1931011a17239f27413f8aac7881_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">/**数据库配置*/\n$config = [&#39;hostname&#39;=&gt;&#34;localhost&#34;, &#39;port&#39;=&gt;&#34;3306&#34;, \n&#39;username&#39;=&gt;&#34;root&#34;,&#39;password&#39;=&gt;&#39;&#39;,&#39;db&#39;=&gt;&#39;sql&#39;];\n/**接收参数*/\n$id = $_GET[&#39;id&#39;]?$_GET[&#39;id&#39;]:&#34;&#34;;\nif(empty($id)){\necho &#34;article is not def&#34;\n}\n/**链接数据库*/\n$mysqli = new \\mysqli($config[&#39;hostname&#39;],$config[&#39;username&#39;],\n$config[&#39;password&#39;],$config[&#39;db&#39;]);\n/**设置编码*/\n$mysqli-&gt;set_charset(&#34;utf8&#34;);</code></pre></div><p>url数字注入结果测试</p><p>我们访问url:http://localhost/mysql/index.php?id=1</p><p>结果展示：</p><p>array(size=2)&#39;article_id&#39;=&gt;string&#39;1&#39;(length=1)&#39;title&#39;=&gt;string&#39;思梦php编写：PHP操作Redis详解案例&#39;(length=44)</p><p>(1)/当我们在在url上稍作修改时：</p><p>http://localhost/mysql/index.php?id=1‘   //加一个单引号</p><p>这样你的sql语句就会报错</p><p>(2)我们再次修改url的时候</p><p>http://localhost/mysql/index.php?id=-1 or 1=1//后面参数修改成这样</p><p>结果展示了所有的文章列表</p><p>D:\\wamp\\www\\mysql\\index.php:11:array(size=2)&#39;article_id&#39;=&gt;string&#39;1&#39;(length=1)&#39;title&#39;=&gt;string&#39;思梦php编写：PHP操作Redis详解案例&#39;(length=44)</p><p>D:\\wamp\\www\\mysql\\index.php:11:array(size=2)&#39;article_id&#39;=&gt;string&#39;2&#39;(length=1)&#39;title&#39;=&gt;string&#39;Mysql存储过程从0开始（上）&#39;(length=36)</p><p>D:\\wamp\\www\\mysql\\index.php:11:array(size=2)&#39;article_id&#39;=&gt;string&#39;3&#39;(length=1)&#39;title&#39;=&gt;string&#39;思梦php编写：PHP排序的几种方法&#39;(length=42).............</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2014422c5815ade83d3764ff535b56be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic3.zhimg.com/v2-2014422c5815ade83d3764ff535b56be_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>2、表单注入，主要利用sql语句的注释</p><div class=\"highlight\"><pre><code class=\"language-text\">$username = $_POST[&#39;username&#39;]?$_POST[&#39;username&#39;]:&#34;&#34;;\n$password = $_POST[&#39;password&#39;]?$_POST[&#39;password&#39;]:&#34;&#34;;\n$sql = &#34;select * from tb_member where account=&#39;$username&#39;AND password=&#39;$pass&#39;&#34;;\n$res = $mysqli-&gt;query($sql);\n$row = $res-&gt;fetch_assoc();\nif($row){\necho &#34;登录成功！&#34;;\n}else{\necho &#34;账号密码错误！&#34;;\n}</code></pre></div><p>正常输入</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d000f5929a47cc1a5aee7c183f7c0ee3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"277\" data-rawheight=\"120\" class=\"content_image\" width=\"277\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;277&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"277\" data-rawheight=\"120\" class=\"content_image lazy\" width=\"277\" data-actualsrc=\"https://pic4.zhimg.com/v2-d000f5929a47cc1a5aee7c183f7c0ee3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>打印：登录成功！</p><p>我们简单修改一下</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-56c632ff2341bdc8e930825547c0cd97_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"284\" data-rawheight=\"129\" class=\"content_image\" width=\"284\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;284&#39; height=&#39;129&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"284\" data-rawheight=\"129\" class=\"content_image lazy\" width=\"284\" data-actualsrc=\"https://pic4.zhimg.com/v2-56c632ff2341bdc8e930825547c0cd97_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>打印：登录成功！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e68088a12a6d06b7a4ddec7a68c9ae9d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-e68088a12a6d06b7a4ddec7a68c9ae9d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>原理：首先使用单引号结束sql语句，然后加#注释后面的sql语句</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-562f2e8cef29b7eb4305f38acb222167_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"19\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-562f2e8cef29b7eb4305f38acb222167_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;19&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"19\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-562f2e8cef29b7eb4305f38acb222167_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-562f2e8cef29b7eb4305f38acb222167_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>同理另一种方式为</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2a9d346195d32a8ddb942eb4be4b52ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"126\" class=\"content_image\" width=\"271\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;271&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"271\" data-rawheight=\"126\" class=\"content_image lazy\" width=\"271\" data-actualsrc=\"https://pic3.zhimg.com/v2-2a9d346195d32a8ddb942eb4be4b52ba_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>打印：登录成功！</p><p>原理：首先使用单引号结束sql语句，然后加（-- ）注释后面的sql语句</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f42625eafc037f0d5d1c69fd5c175e72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"19\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f42625eafc037f0d5d1c69fd5c175e72_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;19&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"19\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f42625eafc037f0d5d1c69fd5c175e72_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f42625eafc037f0d5d1c69fd5c175e72_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d099fca7e32ce7c0a408155182c19abf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic4.zhimg.com/v2-d099fca7e32ce7c0a408155182c19abf_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775758", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "Mysql字段类型设计相关问题！", 
            "content": "<p>Mysql是以文件存储在我们的系统的硬盘上面，那么</p><p>（1）当我们读取写入的时候就会有磁盘IO的问题</p><p>（2）当我们存储的数据是以页单位存储，而且每页的大小是16K，那么我们要尽可能的让我们的一页数据存放的更多。表结构宽度不要太大，也就是列数不要过多，保存更可能多的行数，那么针对行数存储就会涉及到字段类型选择的问题</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cbf32b140d774669e1f2746a56014a8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic4.zhimg.com/v2-cbf32b140d774669e1f2746a56014a8f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>以下字节按照utf8来示例，一个中文占3个字节，一个数字和字母是一个字节，而且utf8是变长的，范围在1-6之间</p><p>（1）数字比字符串处理的速度要快</p><p>（2）当我们需要存储一个固定的长度的值（身份证，手机号）并且长度小于50个字节的时候，那么我们可以选用char(n)</p><p>（3）当我们要存储大于50个字节长度的值时候选用varchar(n)</p><p>（4）当我们存储时间的时候datatime&gt;int&gt;char&gt;varchar,但是int是有时间范围限制的，只能存到2038年</p><p>（5）float和decimal的选择，当我们需要存储一个精度很高的值的时候，那么我们就要存decimal，float只能保存到小数点后7位</p><p>下面是类型占用的字节数</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9e8c099cf0c26bcbb98f8ff46fcce4ed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-9e8c099cf0c26bcbb98f8ff46fcce4ed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;349&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"349\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-9e8c099cf0c26bcbb98f8ff46fcce4ed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9e8c099cf0c26bcbb98f8ff46fcce4ed_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }
            ], 
            "comments": [
                {
                    "userName": "ccitt", 
                    "userLink": "https://www.zhihu.com/people/7db39e96c289d24eda4f06620b2a38b4", 
                    "content": "<p>楼主说的“utf8是变长的，范围在1-6之间”是不是有问题。还有下面总结的表5.6+版本已经更新了，建议说明下适用的版本范围，避免误导大家。</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775712", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 0, 
            "title": "部分手机访问https显示空白页", 
            "content": "<p>事情是这样的。。。。。此处省略1000字！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0403ba2eb51f3c6b83adb29bacc8506a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic3.zhimg.com/v2-0403ba2eb51f3c6b83adb29bacc8506a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>突然客服告诉我，众享通赢的消费平台怎么登陆不进去了？？？而且还一直显示空白页？？？，程序员你做了什么了？？？额，，然后我表示一脸懵逼....</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7c17c27eb80d53adf23e72dd17bd0f24_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-7c17c27eb80d53adf23e72dd17bd0f24_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-595cf0d7b341c3b92ee18a278574ed90_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-595cf0d7b341c3b92ee18a278574ed90_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后我急忙拿起手机点击了一下众享通赢的消费平台，然后我们这边一切正常，正常。。正常，，，不能再正常！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-85563a948cc18906b05a4a5149a22b05_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic2.zhimg.com/v2-85563a948cc18906b05a4a5149a22b05_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>再接下来我问了一下消费者的电话，怀着忐忑的心里咨询了一下情况，然后拿起某真机测试平台测试，果然打不开？？打不开？？？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7b55e3a044b33b2614a53299b16a966c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image\" width=\"80\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;80&#39; height=&#39;80&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"80\" data-rawheight=\"80\" class=\"content_image lazy\" width=\"80\" data-actualsrc=\"https://pic1.zhimg.com/v2-7b55e3a044b33b2614a53299b16a966c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后我就开始找问题，看服务器日志，看代码，打印代码。。。这还是第一次看到。。难道是环信不兼容这款神一样的oppor7，亦或者自己挖了一个坑，然后发现，居然不访问我们的服务器？这时候还是没有意识到问题的所在，继续检查代码。。直到某个时间，突然意识到，不访问服务器那肯定不是代码的问题（之前一直怀疑，但是不确定），然后想是不是被运营商拦截了？用wifi和流量都不行，排除了！！！最后发现是https不兼容的问题！！！，原来腾讯的https不兼容低版本的Android系统，如果强行访问会显示空白页！！！之后更换了七牛云的https证书等，正常了！！！</p><p>最后总结，腾讯免费的https证书配置不兼容Android低版本(4.4.4)，所以小伙伴发现你的网站部分手机显示空白页，要及时更换啊，不知道腾讯什么时候能解决这个bug!!!</p><p>I am far from success!!!</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-af07412215d2156d36db909c08b3cda4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-af07412215d2156d36db909c08b3cda4_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "HTTP", 
                    "tagLink": "https://api.zhihu.com/topics/19588535"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775612", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "PHP ob函数的正解使用方法", 
            "content": "<p>提到PHP的内置缓存，我们第一印象应该就是ob_xxx这些函数，的确，php提供非常优秀的内置缓存函数，让我们能够实现页面的静态化编程，提高我们的网站访问速度，让我们网站能够适应更高并发的业务场景！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c3eed0d3069ac25a7df2fb692f635d28_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image\" width=\"110\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;110&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"110\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"110\" data-actualsrc=\"https://pic1.zhimg.com/v2-c3eed0d3069ac25a7df2fb692f635d28_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>1、首先有四个函数</p><div class=\"highlight\"><pre><code class=\"language-text\">ob_start()  开启缓存\nob_get_contents() 获取缓冲区的内容\nob_clean() 删除缓冲区的内容\nob_get_clean()  先获取然后再删除缓冲区内容</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>2、然后我们定义一个函数来生成静态文件</p><div class=\"highlight\"><pre><code class=\"language-text\">/**定义一个缓存文件\n * @author crazy\n * @time 2018-03-14\n */\npublic function createCache(){\n    $action = ACTION_NAME;\n    $c_name = CONTROLLER_NAME;\n    $dir = &#39;./Cache/&#39;.$c_name.&#39;/&#39;.$action.&#39;/&#39;;\n    if(is_dir($dir)){\n        file_put_contents(&#34;$dir$action&#34;.&#39;.shtml&#39;,ob_get_contents());\n    }else{\n        if(mkdir($dir,0777,true)){\n            file_put_contents(&#34;$dir$action&#34;.&#39;.shtml&#39;,ob_get_contents());\n        }\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>3、根据文件目录是否存在然后我们做相应的重定向</p><div class=\"highlight\"><pre><code class=\"language-text\">$action = ACTION_NAME;  //thinkphp的常量，功能是依托thinkphp进行示例\n$c_name = CONTROLLER_NAME;\n$dir = &#39;./Cache/&#39;.$c_name.&#39;/&#39;.$action.&#39;/&#39;.$action.&#39;.shtml&#39;;\nif(file_exists($dir)){\n    header(&#34;Location:http://localhost/simengphp/$dir&#34;);\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>4、局部静态化</p><div class=\"highlight\"><pre><code class=\"language-text\">$.ajax({\n    url:&#39;&#39;,\n    type:&#39;get&#39;,\n    dataType:&#39;json&#39;,\n    error: function () {\n\n    },\n    success:function(data){\n$.each(data.result,function(key,val){\n\n})\n    }\n});</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>我们在我们的模板里面写上这个ajax获取页面内容的方法，然后我们调用这个页面的时候这个方法就会自动的创建了</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p># living example one</p><div class=\"highlight\"><pre><code class=\"language-text\">ob_start();\nfor($i=0;$i&lt;10;$i++){\n\techo $i;\n}\n$output = ob_get_content();\nob_end_clean();\necho $output;\n//output:0123456789</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>考点</p><p>1）ob缓存函数的使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>分析：</p><p> 第一行ob_start 开启缓存缓冲区，  ob_get_contents()获取缓冲区的内容，ob_end_clean(),清除并关闭，这时候在清除之前你已经获取然后并保存在了一个变量里面了，那么将输出0123456789</p><p></p>", 
            "topic": [
                {
                    "tag": "PHP", 
                    "tagLink": "https://api.zhihu.com/topics/19552910"
                }, 
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }, 
                {
                    "tag": "PHP 学习", 
                    "tagLink": "https://api.zhihu.com/topics/19626603"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35775514", 
            "userName": "刘柱", 
            "userLink": "https://www.zhihu.com/people/770124f537b1ad460fff7725ba6580cf", 
            "upvote": 1, 
            "title": "PHP垃圾回收机制", 
            "content": "<p>PHP垃圾回收机制</p><p>1、每一个变量定义时都保存在一个叫zval的容器里面，这里面包含了数量的类型和和值，还包含了一个refcount（理解为存在几个变量个数）和is_ref（理解为是否为引用变量）两个额外信息，当变量被引用一次refcount就会+1，当你unset一下之后这个值就会减1直到为0就会从内存中删除</p><p>2、定义一个变量的时候并不是每次都会扩大预定于值，因为PHP会在内存中先预占用一个空间，等你声明变量的时候就会分配给你，但是当你超出这个预占用空间之后，那么它就会增加空间，但是等你删除变量时候这个空间容量不会立即消失</p><p>3、变量的引用不会单独的多增加内存占用，它会指向zval结构体，只是refcount+1</p><p>4、简单说说，PHP的变量依赖于一个内部实现</p><p>symbol_table 符号表，而符号表的基础实现是 HashTable</p><p>，也就是和PHP数组的基础实现是一致的。真是因为符号表的存在，让我们可以使用global标记全局变量，用如compact等函数直接从当前符号表中拉出变量出来。</p><p>那在谈谈题主说的unset($a)会不会马上释放空间，答案是否定的，unset支持从符号表中把名字为a的这个元素删掉了（只是标记这块空间又可用了，而不是释放空间）。</p><p>再说循环中重复更新$key这种情况，因为更新的是相同名字的变量，所以在符号表中他们是同一个元素，更新时就会更新相同的位置，之前元素的值就马上被覆盖了。</p><p>再说说申明了新的变量内存就会增加这个问题，答案是不确定。这是符号表基于</p><p>HashTable 实现的特性所致， HashTable</p><p>并不是增加一个元素就申请一个元素的内存，而是一次申请多个元素的内存（只是这些位置标记是未使用），而当 HashTable</p><p>被塞满时，再去申请新的多个元素的内存。也就是说，当我们申明或者赋值一个变量时，如果它不在符号表中，PHP会将它加入到符号表里，而如果这时候符号表没满，那会采用符号表中已申请而未使用的内存，如果符号表刚好的满的，则会申请新的内存出来存放，而新的内存不仅仅只有这个变量需要的内存这么小</p><p></p>", 
            "topic": [
                {
                    "tag": "PHP 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19612578"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/simengphp"
}
