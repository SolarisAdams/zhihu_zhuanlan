{
    "title": "氢云", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/xing-gan-de-ma-yi", 
        "https://www.zhihu.com/people/tie-dao-zhuan-jia-zhang-shi-mai", 
        "https://www.zhihu.com/people/1024-75-51", 
        "https://www.zhihu.com/people/eta-100a", 
        "https://www.zhihu.com/people/liu-nai-feng-88", 
        "https://www.zhihu.com/people/ggff-ss", 
        "https://www.zhihu.com/people/7a57a5a743894a0e", 
        "https://www.zhihu.com/people/debug-44", 
        "https://www.zhihu.com/people/you-wei-98", 
        "https://www.zhihu.com/people/xi-shan-zhi-ying", 
        "https://www.zhihu.com/people/xie-tao-47-50", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/zhao-yang-5-91", 
        "https://www.zhihu.com/people/rain-john", 
        "https://www.zhihu.com/people/huang-wei-55", 
        "https://www.zhihu.com/people/pan-peter-71-62", 
        "https://www.zhihu.com/people/josephine-22-53", 
        "https://www.zhihu.com/people/ai-ti-min-gong-26", 
        "https://www.zhihu.com/people/guan-gai-man-jing-hua-53", 
        "https://www.zhihu.com/people/liang-cai-55", 
        "https://www.zhihu.com/people/yang-xun-peng", 
        "https://www.zhihu.com/people/lemonsen", 
        "https://www.zhihu.com/people/o-ye-duan", 
        "https://www.zhihu.com/people/brian-wang-22", 
        "https://www.zhihu.com/people/ran-zhi-hai", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/yu-sui-wu-tong", 
        "https://www.zhihu.com/people/pi-dan-33-7", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/xuyan505", 
        "https://www.zhihu.com/people/guo-zhong-ming-26", 
        "https://www.zhihu.com/people/ybk5471", 
        "https://www.zhihu.com/people/zhu-forrest"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88021315", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 0, 
            "title": "C++使用ffpython嵌入和扩展python（python2和python3）", 
            "content": "<h2>C++使用ffpython嵌入和扩展python（python2和python3）</h2><h2>摘要:</h2><p>在服务器编程中，经常会用到python脚本技术。Python是最流行的脚本之一，并且python拥有定义良好的C API接口，同时又有丰富的文档，与C++结合非常的适合。通常情况下使用C++封装机制，而用python脚本实现策略或者是控制。使用python和C++结合的技术拥有如下优势：</p><ul><li>主体系统使用C++实现，保持系统的高效。</li><li>控制部分使用python，增加开发效率，python的内存垃圾回收，丰富的类库都使C++开发者获益匪浅。</li><li>Python脚本可以运行期重载，可以实现控制部分不停机热更新。</li></ul><p>C++与python的编程范式有很大不同，当使用python C API调用python时，python中的一些特有机制会给C++开发者带来很多困惑。常常使用python C API时需要注意如下几点:</p><ul><li>Python 使用引用计数管理内存，调用python C API时对于返回值返回的是借用的引用还是新的引用，需要根据文档仔细确认。否则轻则出现内存泄露，重则程序崩溃。</li><li>Python中的数据结构与C++的有很大不同。Python常用的有tuple，list，dict。而c++常用的事vector，list，map，并且c++是强类型的。当c++与python进行交互时，C++层希望操作python数据结构就像操作c++ STL一样方便，而在python脚本层，又希望c++传入的参数或返回值都是原生的python数据</li><li>C++中常用的指针传递对象，当嵌入python时，需要把c++对象传递到python中。 ffpython是专门方便C++嵌入python开发的类库，基于ffpython一方面可以轻松的将python集成到C++系统，另一方面，C++对象或接口也可以很容易被python使用，总之ffpython简化了c++与python的交互操作。</li></ul><h2>嵌入python</h2><p>最简单的使用python的方式是把python脚本当作配置，如获取脚本中的一个字符串变量。Python的脚本文件会被python虚拟机import为module，和python的标准库的module实际上是相似的概念。ffpython封装了获取python module中的变量的操作。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;sys.version=%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">get_global_var</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;sys&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;version&#34;</span><span class=\"p\">).</span><span class=\"n\">c_str</span><span class=\"p\">());</span>\n</code></pre></div><p>上面的代码获取python标准库中sys的version变量值，ffpython通过模板函数的自动将python的str类型自动适配到c++的string类型。get_global_var是获取变量的接口，与之对应的是设置变量的借口get_global_var：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">get_global_var</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;global_var&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;OhNice&#34;</span><span class=\"p\">);</span>\n<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest.global_var=%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">get_global_var</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;global_var&#34;</span><span class=\"p\">).</span><span class=\"n\">c_str</span><span class=\"p\">());</span>\n</code></pre></div><p>调用python函数是嵌入python非常常用的操作，ffpython中提供了call接口用于调用python中的module的函数：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;time.asctime=%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;time&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;asctime&#34;</span><span class=\"p\">).</span><span class=\"n\">c_str</span><span class=\"p\">());</span>\n</code></pre></div><p>上面的代码调用time模块的asctime方法，我们也可以使用call接口调用我们自己编写的函数：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">a1</span> <span class=\"o\">=</span> <span class=\"mi\">100</span><span class=\"p\">;</span> <span class=\"kt\">float</span> <span class=\"n\">a2</span> <span class=\"o\">=</span> <span class=\"mf\">3.14f</span><span class=\"p\">;</span> <span class=\"n\">string</span> <span class=\"n\">a3</span> <span class=\"o\">=</span> <span class=\"s\">&#34;OhWell&#34;</span><span class=\"p\">;</span>\n<span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_base&#34;</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">);</span>\n</code></pre></div><p>Call被定义为模版函数，传入的参数会自动适配到python相应的类型。对应的python函数为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"n\">test_base</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span><span class=\"o\">:</span>\n       <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_base</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n       <span class=\"k\">return</span> <span class=\"mi\">0</span>\n</code></pre></div><p>上面的python函数接受三个参数，c++传入了三个标准类型参数，实际上call接口最多支持9个泛型参数，常用的stl 参数是被支持的：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_stl</span><span class=\"p\">(</span><span class=\"n\">ffpython_t</span><span class=\"o\">&amp;</span> <span class=\"n\">ffpython</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">a1</span><span class=\"p\">;</span><span class=\"n\">a1</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">100</span><span class=\"p\">);</span><span class=\"n\">a1</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">200</span><span class=\"p\">);</span>\n    <span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">a2</span><span class=\"p\">;</span> <span class=\"n\">a2</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"s\">&#34;Oh&#34;</span><span class=\"p\">);</span><span class=\"n\">a2</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"s\">&#34;Nice&#34;</span><span class=\"p\">);</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"o\">&gt;</span> <span class=\"n\">a3</span><span class=\"p\">;</span><span class=\"n\">a3</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">a2</span><span class=\"p\">);</span>\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"kt\">bool</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_stl&#34;</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>对应调用的python函数为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"n\">test_stl</span><span class=\"p\">(</span><span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span><span class=\"o\">:</span>\n       <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_stl</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">)</span>\n       <span class=\"k\">return</span> <span class=\"n\">True</span>\n</code></pre></div><p>不但STL泛型被支持，嵌套定义的类似vector &gt; 的结构都是被支持的，vector和list都会转换成python的list结构，而map则转换为dict结构。</p><p>调用call接口必须指定接收的返回值类型，可以使用void忽略返回值，除了可以使用标准类型，stl接口也可以被使用，python中的tuple和list可以转换成vector和list，dict则可以被转换成map。需要注意的是，若类型没有匹配，call函数将会抛出异常。用户可以catch标准异常，what接口返回的字符串包含了异常的traceback信息方便排查错误。示例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">try{\n    ......\n\n       }\n       catch(exception&amp; e)\n       {\n              printf(&#34;exception traceback %s\\n&#34;, e.what());\n       }</code></pre></div><h2>扩展python</h2><p>ffpython 可以注册static函数到python中，全局的C风格的static函数和类中定义的static函数都可以被注册到python中，示例如下： </p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">print_val</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"kt\">float</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">string</span><span class=\"o\">&amp;</span> <span class=\"n\">a3</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">double</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">a4</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s[%d,%f,%s,%d]</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">,</span> <span class=\"n\">a1</span><span class=\"p\">,</span> <span class=\"n\">a2</span><span class=\"p\">,</span> <span class=\"n\">a3</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">(),</span> <span class=\"n\">a4</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"k\">struct</span> <span class=\"n\">ops_t</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">static</span> <span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">return_stl</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ret</span><span class=\"p\">;</span><span class=\"n\">ret</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">1024</span><span class=\"p\">);</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">ret</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n\n<span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">test_reg_function</span><span class=\"p\">(</span><span class=\"n\">ffpython_t</span><span class=\"o\">&amp;</span> <span class=\"n\">ffpython</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">print_val</span><span class=\"p\">,</span> <span class=\"s\">&#34;print_val&#34;</span><span class=\"p\">)</span>\n            <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">ops_t</span><span class=\"o\">::</span><span class=\"n\">return_stl</span><span class=\"p\">,</span> <span class=\"s\">&#34;return_stl&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg_class</span><span class=\"o\">&lt;</span><span class=\"n\">foo_t</span><span class=\"p\">,</span> <span class=\"n\">PYCTOR</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;foo_t&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">foo_t</span><span class=\"o\">::</span><span class=\"n\">get_value</span><span class=\"p\">,</span> <span class=\"s\">&#34;get_value&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">foo_t</span><span class=\"o\">::</span><span class=\"n\">set_value</span><span class=\"p\">,</span> <span class=\"s\">&#34;set_value&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">foo_t</span><span class=\"o\">::</span><span class=\"n\">test_stl</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_stl&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg_property</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">foo_t</span><span class=\"o\">::</span><span class=\"n\">m_value</span><span class=\"p\">,</span> <span class=\"s\">&#34;m_value&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg_class</span><span class=\"o\">&lt;</span><span class=\"n\">dumy_t</span><span class=\"p\">,</span> <span class=\"n\">PYCTOR</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;dumy_t&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;dumy_t class inherit foo_t ctor &lt;int&gt;&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;foo_t&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dumy_t</span><span class=\"o\">::</span><span class=\"n\">dump</span><span class=\"p\">,</span> <span class=\"s\">&#34;dump&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"n\">obj_test</span><span class=\"p\">,</span> <span class=\"s\">&#34;obj_test&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"s\">&#34;cppext&#34;</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>以上代码注册了两个接口给python，然后调用fftest文件中的test_reg_function测试两个接口，fftest.py中定义测试代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"n\">test_reg_function</span><span class=\"p\">()</span><span class=\"o\">:</span>\n    <span class=\"n\">import</span> <span class=\"n\">ext1</span>\n    <span class=\"n\">ext1</span><span class=\"p\">.</span><span class=\"n\">print_val</span><span class=\"p\">(</span><span class=\"mi\">123</span><span class=\"p\">,</span> <span class=\"mf\">45.6</span> <span class=\"p\">,</span> <span class=\"s\">&#34;----789---&#34;</span><span class=\"p\">,</span> <span class=\"p\">[</span><span class=\"mf\">3.14</span><span class=\"p\">])</span>\n    <span class=\"n\">ret</span> <span class=\"o\">=</span> <span class=\"n\">ext1</span><span class=\"p\">.</span><span class=\"n\">return_stl</span><span class=\"p\">()</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_reg_function</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">ret</span><span class=\"p\">)</span>\n</code></pre></div><p>这两个接口虽然简单，但是说明了ffpython注册的接口支持多个参数，参数类型可以是标准C++类型，也可以是STL泛型。同样返回值的类型也是如此。</p><p>使用ffpython 注册C++的对象也很容易，ffpython支持注册c++类的构造函数，成员变量，成员方法到python，示例代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">foo_t</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">foo_t</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">v_</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"n\">m_value</span><span class=\"p\">(</span><span class=\"n\">v_</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">foo_t</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">get_value</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">m_value</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">v_</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">m_value</span> <span class=\"o\">=</span> <span class=\"n\">v_</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">test_stl</span><span class=\"p\">(</span><span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"p\">,</span> <span class=\"n\">list</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&gt;&amp;</span> <span class=\"n\">v_</span><span class=\"p\">)</span> \n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_value</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">dumy_t</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">foo_t</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">dumy_t</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">v_</span><span class=\"p\">)</span><span class=\"o\">:</span><span class=\"n\">foo_t</span><span class=\"p\">(</span><span class=\"n\">v_</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">dumy_t</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">dump</span><span class=\"p\">()</span> \n    <span class=\"p\">{</span>\n        <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n\n<span class=\"k\">static</span> <span class=\"n\">foo_t</span><span class=\"o\">*</span> <span class=\"nf\">obj_test</span><span class=\"p\">(</span><span class=\"n\">dumy_t</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;%s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">__FUNCTION__</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>当c++类型被注册到python中后，python中使用该类型就像python内建的类型一样方便，需要注意的是，如果python中动态的创建了c++对象，那么他是被python的GC管理生命周期的，所以当变量不在被引用时，c++对象的析构函数被调用。对应的fftest.py中测试的脚本代码为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"nf\">test_register_base_class</span><span class=\"p\">()</span><span class=\"o\">:</span>\n    <span class=\"n\">import</span> <span class=\"n\">ext2</span>\n    <span class=\"n\">foo</span> <span class=\"o\">=</span> <span class=\"n\">ext2</span><span class=\"p\">.</span><span class=\"n\">foo_t</span><span class=\"p\">(</span><span class=\"mi\">20130426</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_register_base_class get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">())</span>\n    <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"mi\">778899</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_register_base_class get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">(),</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">m_value</span><span class=\"p\">)</span>\n    <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">test_stl</span><span class=\"p\">({</span><span class=\"s\">&#34;key&#34;</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">33</span><span class=\"p\">]</span> <span class=\"p\">})</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_register_base_class</span> <span class=\"n\">test_register_base_class</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">)</span>\n</code></pre></div><p>同前边所诉的原则相同，支持C++ 标准内建类型和STL 泛型。当这个python函数返回时，foo_t的析构函数会被调用。</p><p>dumy_t是foo_t的子类。使用ffpython可以方便表示两个类型的关系。如果基类已经定义的接口，子类不需要重复定义，比如要注册子类：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg_class</span><span class=\"o\">&lt;</span><span class=\"n\">dumy_t</span><span class=\"p\">,</span> <span class=\"n\">PYCTOR</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;dumy_t&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;dumy_t class inherit foo_t ctor &lt;int&gt;&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;foo_t&#34;</span><span class=\"p\">)</span>\n        <span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">dumy_t</span><span class=\"o\">::</span><span class=\"n\">dump</span><span class=\"p\">,</span> <span class=\"s\">&#34;dump&#34;</span><span class=\"p\">);</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_register_inherit_class</span><span class=\"p\">(</span><span class=\"n\">ffpython_t</span><span class=\"o\">&amp;</span> <span class=\"n\">ffpython</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_register_inherit_class&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>只需要单独注册一下子类特有的接口，其他接口自动从foo_t基类中继承而来，相应的测试python脚本代码为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"nf\">test_register_inherit_class</span><span class=\"p\">()</span><span class=\"o\">:</span>\n    <span class=\"n\">import</span> <span class=\"n\">ext2</span>\n    <span class=\"n\">dumy</span> <span class=\"o\">=</span> <span class=\"n\">ext2</span><span class=\"p\">.</span><span class=\"n\">dumy_t</span><span class=\"p\">(</span><span class=\"mi\">20130426</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_register_inherit_class get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">())</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"mi\">778899</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_register_inherit_class get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">(),</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">m_value</span><span class=\"p\">)</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">test_stl</span><span class=\"p\">({</span><span class=\"s\">&#34;key&#34;</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">33</span><span class=\"p\">]</span> <span class=\"p\">})</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_register_inherit_class</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">)</span>\n</code></pre></div><p>ffpython中一个非常用用的特性是，c++创建的对象可以传递到python中，而python使用起来就像正常的python对象一样，另外python创建的c++对象也可以传递到c++中，简单示例代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">reg</span><span class=\"p\">(</span><span class=\"n\">obj_test</span><span class=\"p\">,</span> <span class=\"s\">&#34;obj_test&#34;</span><span class=\"p\">);</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_cpp_obj_to_py</span><span class=\"p\">(</span><span class=\"n\">ffpython_t</span><span class=\"o\">&amp;</span> <span class=\"n\">ffpython</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">foo_t</span> <span class=\"n\">tmp_foo</span><span class=\"p\">(</span><span class=\"mi\">2013</span><span class=\"p\">);</span>\n    <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_cpp_obj_to_py&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">tmp_foo</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_cpp_obj_py_obj</span><span class=\"p\">(</span><span class=\"n\">ffpython_t</span><span class=\"o\">&amp;</span> <span class=\"n\">ffpython</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">dumy_t</span> <span class=\"n\">tmp_foo</span><span class=\"p\">(</span><span class=\"mi\">2013</span><span class=\"p\">);</span>\n\n    <span class=\"n\">foo_t</span><span class=\"o\">*</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">ffpython</span><span class=\"p\">.</span><span class=\"n\">call</span><span class=\"o\">&lt;</span><span class=\"n\">foo_t</span><span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"s\">&#34;fftest&#34;</span><span class=\"p\">,</span> <span class=\"s\">&#34;test_cpp_obj_py_obj&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">tmp_foo</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>相应的fftest.py中的测试脚本代码为：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">def</span> <span class=\"nf\">test_cpp_obj_to_py</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">)</span><span class=\"o\">:</span>\n    <span class=\"n\">import</span> <span class=\"n\">ext2</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_cpp_obj_to_py get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">())</span>\n    <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"mi\">778899</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_cpp_obj_to_py get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">(),</span> <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">m_value</span><span class=\"p\">)</span>\n    <span class=\"n\">foo</span><span class=\"p\">.</span><span class=\"n\">test_stl</span><span class=\"p\">({</span><span class=\"s\">&#34;key&#34;</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">33</span><span class=\"p\">]</span> <span class=\"p\">})</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_cpp_obj_to_py</span> <span class=\"n\">test_register_base_class</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">foo</span><span class=\"p\">)</span>\n\n<span class=\"n\">def</span> <span class=\"n\">test_cpp_obj_py_obj</span><span class=\"p\">(</span><span class=\"n\">dumy</span><span class=\"p\">)</span><span class=\"o\">:</span>\n    <span class=\"n\">import</span> <span class=\"n\">ext2</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_cpp_obj_py_obj get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">())</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">set_value</span><span class=\"p\">(</span><span class=\"mi\">778899</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">&#34;test_cpp_obj_py_obj get_val:&#34;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">get_value</span><span class=\"p\">(),</span> <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">m_value</span><span class=\"p\">)</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">test_stl</span><span class=\"p\">({</span><span class=\"s\">&#34;key&#34;</span><span class=\"o\">:</span> <span class=\"p\">[</span><span class=\"mi\">11</span><span class=\"p\">,</span><span class=\"mi\">22</span><span class=\"p\">,</span><span class=\"mi\">33</span><span class=\"p\">]</span> <span class=\"p\">})</span>\n    <span class=\"n\">dumy</span><span class=\"p\">.</span><span class=\"n\">dump</span><span class=\"p\">()</span>\n    <span class=\"n\">ext2</span><span class=\"p\">.</span><span class=\"n\">obj_test</span><span class=\"p\">(</span><span class=\"n\">dumy</span><span class=\"p\">)</span>\n    <span class=\"n\">print</span><span class=\"p\">(</span><span class=\"err\">&#39;</span><span class=\"n\">test_cpp_obj_py_obj</span><span class=\"err\">&#39;</span><span class=\"p\">,</span> <span class=\"n\">dumy</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">dumy</span>\n</code></pre></div><h2>总结：</h2><ul><li>ffpython 支持c++调用python函数，获取和设置模块内的变量</li><li>ffpython call接口最多支持9个泛型参数，支持的类型包括c++内建的类型和STL 泛型。以及已经被注册的c++类的指针类型。返回值的类型约束同样如此。c++ STL中的vector和list对应于python的tuple和list，map类型则对应于dict。</li><li>ffpython支持将c++的静态函数注册到python中。</li><li>ffpython支持c++类的注册，并且支持继承。Python中操作c++对象就像操作原生python对象一样。</li><li>ffpython注册的c++类在python中被创建后，将会由python GC负责回收内存。</li><li>ffpython 类库只有一个文件，并且不依赖其他第三方库，非常容易集成到项目中。而且ffpython遵从开源协议。</li><li>ffpython使用c++模板技术，封装了python C API的使用细节，保持精巧和简洁，效率和完全的python C API编写的代码几乎相同。ffpython的实现可以作为非常好的python C API的示例。</li><li>Github项目地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/ffpython\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/ffpyt</span><span class=\"invisible\">hon</span><span class=\"ellipsis\"></span></a>  </li><li>更多文章 <a href=\"https://link.zhihu.com/?target=http%3A//h2cloud.org\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">h2cloud.org</span><span class=\"invisible\"></span></a></li></ul>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "游戏服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19591286"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/79527876", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 0, 
            "title": "朴素贝叶斯python代码实现（西瓜书）", 
            "content": "<h2>朴素贝叶斯python代码实现（西瓜书）</h2><h2>摘要：</h2><p>朴素贝叶斯也是机器学习中一种非常常见的分类方法，对于二分类问题，并且数据集特征为离散型属性的时候， 使用起来非常的方便。原理简单，训练效率高，拟合效果好。</p><h2>朴素贝叶斯</h2><p>贝叶斯公式： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-11c6be98ccc2161fb21e62f372801107_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"302\" data-rawheight=\"95\" class=\"content_image\" width=\"302\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;302&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"302\" data-rawheight=\"95\" class=\"content_image lazy\" width=\"302\" data-actualsrc=\"https://pic4.zhimg.com/v2-11c6be98ccc2161fb21e62f372801107_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>朴素贝叶斯之所以称这为朴素，是因为假设了各个特征是相互独立的，因此假定下公式成立： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2f6a1a80729038dfe15bed1694e7016e_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"483\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"483\" data-original=\"https://pic3.zhimg.com/v2-2f6a1a80729038dfe15bed1694e7016e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;483&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"483\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"483\" data-original=\"https://pic3.zhimg.com/v2-2f6a1a80729038dfe15bed1694e7016e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2f6a1a80729038dfe15bed1694e7016e_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>则朴素贝叶斯算法的计算公式如下： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9677c95550e8d1fe4993bf2f9dd10ecd_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"946\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb\" width=\"946\" data-original=\"https://pic2.zhimg.com/v2-9677c95550e8d1fe4993bf2f9dd10ecd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;946&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"946\" data-rawheight=\"95\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"946\" data-original=\"https://pic2.zhimg.com/v2-9677c95550e8d1fe4993bf2f9dd10ecd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9677c95550e8d1fe4993bf2f9dd10ecd_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在实际计算中，上面的公式会做如下略微改动： 1. 由于某些特征属性的值P(Xi|Ci)可能很小，多个特征的p值连乘后可能被约等于0。可以公式两边取log然后变乘法为加法，避免类乘问题。 2. P(Ci) 和P(Xi|Ci) 一般不直接使用样本的频率计算出来，一般会使用拉普拉斯平滑。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a804b277a3099242463fe4c1d9569867_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"234\" data-rawheight=\"113\" class=\"content_image\" width=\"234\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;234&#39; height=&#39;113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"234\" data-rawheight=\"113\" class=\"content_image lazy\" width=\"234\" data-actualsrc=\"https://pic4.zhimg.com/v2-a804b277a3099242463fe4c1d9569867_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面公式中，Dc为该类别的频数，N表示所有类别的可能数。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a55692f3e20658365e7d6b3f084ec29_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"100\" class=\"content_image\" width=\"283\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;283&#39; height=&#39;100&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"100\" class=\"content_image lazy\" width=\"283\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a55692f3e20658365e7d6b3f084ec29_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面公式中，Dc,xi为该特征对应属性的频数，Dc为该类别的频数，Ni表示该特征的可能的属性数。</p><h2>对应的西瓜书数据集为</h2><div class=\"highlight\"><pre><code class=\"language-text\">色泽  根蒂  敲声  纹理  脐部  触感  好瓜\n青绿  蜷缩  浊响  清晰  凹陷  硬滑  是\n乌黑  蜷缩  沉闷  清晰  凹陷  硬滑  是\n乌黑  蜷缩  浊响  清晰  凹陷  硬滑  是\n青绿  蜷缩  沉闷  清晰  凹陷  硬滑  是\n浅白  蜷缩  浊响  清晰  凹陷  硬滑  是\n青绿  稍蜷  浊响  清晰  稍凹  软粘  是\n乌黑  稍蜷  浊响  稍糊  稍凹  软粘  是\n乌黑  稍蜷  浊响  清晰  稍凹  硬滑  是\n乌黑  稍蜷  沉闷  稍糊  稍凹  硬滑  否\n青绿  硬挺  清脆  清晰  平坦  软粘  否\n浅白  硬挺  清脆  模糊  平坦  硬滑  否\n浅白  蜷缩  浊响  模糊  平坦  软粘  否\n青绿  稍蜷  浊响  稍糊  凹陷  硬滑  否\n浅白  稍蜷  沉闷  稍糊  凹陷  硬滑  否\n乌黑  稍蜷  浊响  清晰  稍凹  软粘  否\n浅白  蜷缩  浊响  模糊  平坦  硬滑  否\n青绿  蜷缩  沉闷  稍糊  稍凹  硬滑  否</code></pre></div><h2>python实现</h2><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\">#encoding:utf-8</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"kn\">as</span> <span class=\"nn\">pd</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span>  <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">NaiveBayes</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"p\">{}</span><span class=\"c1\">#key 为类别名 val 为字典PClass表示该类的该类，PFeature:{}对应对于各个特征的概率</span>\n    <span class=\"k\">def</span> <span class=\"nf\">calEntropy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span> <span class=\"c1\"># 计算熵</span>\n        <span class=\"n\">valRate</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">/</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n        <span class=\"n\">valEntropy</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inner</span><span class=\"p\">(</span><span class=\"n\">valRate</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log2</span><span class=\"p\">(</span><span class=\"n\">valRate</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">valEntropy</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">fit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">xTrain</span><span class=\"p\">,</span> <span class=\"n\">yTrain</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">()):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">yTrain</span><span class=\"o\">.</span><span class=\"n\">empty</span><span class=\"p\">:</span><span class=\"c1\">#如果不传，自动选择最后一列作为分类标签</span>\n            <span class=\"n\">xTrain</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">concat</span><span class=\"p\">([</span><span class=\"n\">xTrain</span><span class=\"p\">,</span> <span class=\"n\">yTrain</span><span class=\"p\">],</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buildNaiveBayes</span><span class=\"p\">(</span><span class=\"n\">xTrain</span><span class=\"p\">)</span> \n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span>\n    <span class=\"k\">def</span> <span class=\"nf\">buildNaiveBayes</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">xTrain</span><span class=\"p\">):</span>\n        <span class=\"n\">yTrain</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[:,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n\n        <span class=\"n\">yTrainCounts</span> <span class=\"o\">=</span> <span class=\"n\">yTrain</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n\n        <span class=\"n\">yTrainCounts</span> <span class=\"o\">=</span> <span class=\"n\">yTrainCounts</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">yTrain</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">yTrainCounts</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">))</span> <span class=\"c1\">#使用了拉普拉斯平滑</span>\n        <span class=\"n\">retModel</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">nameClass</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">yTrainCounts</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">retModel</span><span class=\"p\">[</span><span class=\"n\">nameClass</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"s1\">&#39;PClass&#39;</span><span class=\"p\">:</span> <span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"s1\">&#39;PFeature&#39;</span><span class=\"p\">:{}}</span>\n\n        <span class=\"n\">propNamesAll</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">columns</span><span class=\"p\">[:</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"n\">allPropByFeature</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">nameFeature</span> <span class=\"ow\">in</span> <span class=\"n\">propNamesAll</span><span class=\"p\">:</span>\n            <span class=\"n\">allPropByFeature</span><span class=\"p\">[</span><span class=\"n\">nameFeature</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">list</span><span class=\"p\">(</span><span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">nameFeature</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">)</span>\n        <span class=\"c1\">#print(allPropByFeature)</span>\n        <span class=\"k\">for</span> <span class=\"n\">nameClass</span><span class=\"p\">,</span> <span class=\"n\">group</span> <span class=\"ow\">in</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">groupby</span><span class=\"p\">(</span><span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">columns</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]):</span>\n            <span class=\"k\">for</span> <span class=\"n\">nameFeature</span> <span class=\"ow\">in</span> <span class=\"n\">propNamesAll</span><span class=\"p\">:</span>\n                <span class=\"n\">eachClassPFeature</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n                <span class=\"n\">propDatas</span> <span class=\"o\">=</span> <span class=\"n\">group</span><span class=\"p\">[</span><span class=\"n\">nameFeature</span><span class=\"p\">]</span>\n                <span class=\"n\">propClassSummary</span> <span class=\"o\">=</span> <span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n                <span class=\"k\">for</span> <span class=\"n\">propName</span> <span class=\"ow\">in</span> <span class=\"n\">allPropByFeature</span><span class=\"p\">[</span><span class=\"n\">nameFeature</span><span class=\"p\">]:</span>\n                    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">propClassSummary</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">propName</span><span class=\"p\">):</span>\n                        <span class=\"n\">propClassSummary</span><span class=\"p\">[</span><span class=\"n\">propName</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"c1\">#如果有属性灭有，那么自动补0</span>\n                <span class=\"n\">Ni</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">allPropByFeature</span><span class=\"p\">[</span><span class=\"n\">nameFeature</span><span class=\"p\">])</span>\n                <span class=\"n\">propClassSummary</span> <span class=\"o\">=</span> <span class=\"n\">propClassSummary</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"p\">(</span><span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">+</span> <span class=\"n\">Ni</span><span class=\"p\">))</span><span class=\"c1\">#使用了拉普拉斯平滑</span>\n                <span class=\"k\">for</span> <span class=\"n\">nameFeatureProp</span><span class=\"p\">,</span> <span class=\"n\">valP</span> <span class=\"ow\">in</span> <span class=\"n\">propClassSummary</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                    <span class=\"n\">eachClassPFeature</span><span class=\"p\">[</span><span class=\"n\">nameFeatureProp</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">valP</span>\n                <span class=\"n\">retModel</span><span class=\"p\">[</span><span class=\"n\">nameClass</span><span class=\"p\">][</span><span class=\"s1\">&#39;PFeature&#39;</span><span class=\"p\">][</span><span class=\"n\">nameFeature</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">eachClassPFeature</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">retModel</span>\n    <span class=\"k\">def</span> <span class=\"nf\">predictBySeries</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"n\">curMaxRate</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"n\">curClassSelect</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"k\">for</span> <span class=\"n\">nameClass</span><span class=\"p\">,</span> <span class=\"n\">infoModel</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">rate</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"n\">rate</span> <span class=\"o\">+=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">infoModel</span><span class=\"p\">[</span><span class=\"s1\">&#39;PClass&#39;</span><span class=\"p\">])</span>\n            <span class=\"n\">PFeature</span> <span class=\"o\">=</span> <span class=\"n\">infoModel</span><span class=\"p\">[</span><span class=\"s1\">&#39;PFeature&#39;</span><span class=\"p\">]</span>\n\n            <span class=\"k\">for</span> <span class=\"n\">nameFeature</span><span class=\"p\">,</span> <span class=\"n\">val</span> <span class=\"ow\">in</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"n\">propsRate</span> <span class=\"o\">=</span> <span class=\"n\">PFeature</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">nameFeature</span><span class=\"p\">)</span>\n                <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">propsRate</span><span class=\"p\">:</span>\n                    <span class=\"k\">continue</span>\n                <span class=\"n\">rate</span> <span class=\"o\">+=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log</span><span class=\"p\">(</span><span class=\"n\">propsRate</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">val</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">))</span><span class=\"c1\">#使用log加法避免很小的小数连续乘，接近零</span>\n                <span class=\"c1\">#print(nameFeature, val, propsRate.get(val, 0))</span>\n            <span class=\"c1\">#print(nameClass, rate)</span>\n            <span class=\"k\">if</span> <span class=\"n\">curMaxRate</span> <span class=\"o\">==</span> <span class=\"bp\">None</span> <span class=\"ow\">or</span> <span class=\"n\">rate</span> <span class=\"o\">&gt;</span> <span class=\"n\">curMaxRate</span><span class=\"p\">:</span>\n                <span class=\"n\">curMaxRate</span> <span class=\"o\">=</span> <span class=\"n\">rate</span>\n                <span class=\"n\">curClassSelect</span> <span class=\"o\">=</span> <span class=\"n\">nameClass</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">curClassSelect</span>\n    <span class=\"k\">def</span> <span class=\"nf\">predict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">predictBySeries</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">predictBySeries</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">dataTrain</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s2\">&#34;xiguadata.csv&#34;</span><span class=\"p\">,</span> <span class=\"n\">encoding</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;gbk&#34;</span><span class=\"p\">)</span>\n\n<span class=\"n\">naiveBayes</span> <span class=\"o\">=</span> <span class=\"n\">NaiveBayes</span><span class=\"p\">()</span>\n<span class=\"n\">treeData</span> <span class=\"o\">=</span> <span class=\"n\">naiveBayes</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">dataTrain</span><span class=\"p\">)</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">treeData</span><span class=\"p\">,</span> <span class=\"n\">ensure_ascii</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">))</span>\n\n<span class=\"n\">pd</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span><span class=\"s1\">&#39;预测值&#39;</span><span class=\"p\">:</span><span class=\"n\">naiveBayes</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">dataTrain</span><span class=\"p\">),</span> <span class=\"s1\">&#39;正取值&#39;</span><span class=\"p\">:</span><span class=\"n\">dataTrain</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[:,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]})</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">pd</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"s1\">&#39;正确率:</span><span class=\"si\">%f%%</span><span class=\"s1\">&#39;</span><span class=\"o\">%</span><span class=\"p\">(</span><span class=\"n\">pd</span><span class=\"p\">[</span><span class=\"n\">pd</span><span class=\"p\">[</span><span class=\"s1\">&#39;预测值&#39;</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">pd</span><span class=\"p\">[</span><span class=\"s1\">&#39;正取值&#39;</span><span class=\"p\">]]</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"mf\">100.0</span> <span class=\"o\">/</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))</span></code></pre></div><p>输出</p><div class=\"highlight\"><pre><code class=\"language-text\">{&#34;否&#34;: {&#34;PClass&#34;: 0.5263157894736842, &#34;PFeature&#34;: {&#34;色泽&#34;: {&#34;浅白&#34;: 0.4166666666666667, &#34;青绿&#34;: 0.3333333333333333, &#34;乌 黑&#34;: 0.25}, &#34;根蒂&#34;: {&#34;稍蜷&#34;: 0.4166666666666667, &#34;蜷缩&#34;: 0.3333333333333333, &#34;硬挺&#34;: 0.25}, &#34;敲声&#34;: {&#34;浊响&#34;: 0.4166666666666667, &#34;沉闷&#34;: 0.3333333333333333, &#34;清脆&#34;: 0.25}, &#34;纹理&#34;: {&#34;稍糊&#34;: 0.4166666666666667, &#34;模糊&#34;: 0.3333333333333333, &#34;清晰&#34;: 0.25}, &#34;脐部&#34;: {&#34;平坦&#34;: 0.4166666666666667, &#34;稍凹&#34;: 0.3333333333333333, &#34;凹陷&#34;: 0.25}, &#34;触感&#34;: {&#34;硬滑&#34;: 0.6363636363636364, &#34;软粘&#34;: 0.36363636363636365}}}, &#34;是&#34;: {&#34;PClass&#34;: 0.47368421052631576, &#34;PFeature&#34;: {&#34;色泽&#34;: {&#34;乌黑&#34;: 0.45454545454545453, &#34;青绿&#34;: 0.36363636363636365, &#34;浅白&#34;: 0.18181818181818182}, &#34;根蒂&#34;: {&#34;蜷缩&#34;: 0.5454545454545454, &#34;稍蜷&#34;: 0.36363636363636365, &#34;硬挺&#34;: 0.09090909090909091}, &#34;敲声&#34;: {&#34;浊响&#34;: 0.6363636363636364, &#34;沉闷&#34;: 0.2727272727272727, &#34;清脆&#34;: 0.09090909090909091}, &#34;纹理&#34;: {&#34;清晰&#34;: 0.7272727272727273, &#34;稍糊&#34;: 0.18181818181818182, &#34;模糊&#34;: 0.09090909090909091}, &#34;脐 部&#34;: {&#34;凹陷&#34;: 0.5454545454545454, &#34;稍凹&#34;: 0.36363636363636365, &#34;平坦&#34;: 0.09090909090909091}, &#34;触感&#34;: {&#34;硬滑&#34;: 0.7, &#34;软粘&#34;: 0.3}}}}\n   预测值 正取值\n0    是   是\n1    是   是\n2    是   是\n3    是   是\n4    是   是\n5    是   是\n6    否   是\n7    是   是\n8    否   否\n9    否   否\n10   否   否\n11   否   否\n12   是   否\n13   否   否\n14   是   否\n15   否   否\n16   否   否\n正确率:82.352941%</code></pre></div><h2>总结：</h2><ul><li>贝叶斯分类器是一种生成式模型，不是直接拟合分类结果，而是拟合出后验概率公式计算对应分类的概率。</li><li>本文只介绍了二分类，也可以用来处理多分类问题。</li><li>对于小规模数据集，表现良好。</li><li>建立在特征相互独立的假设上。</li><li>这是我的github主页<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy</span><span class=\"invisible\"></span></a>，有些有意思的分享。</li></ul>", 
            "topic": [
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }, 
                {
                    "tag": "朴素贝叶斯", 
                    "tagLink": "https://api.zhihu.com/topics/20682927"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/78806608", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 1, 
            "title": "决策树ID3原理及R语言python代码实现（西瓜书）", 
            "content": "<h2>决策树ID3原理及R语言python代码实现（西瓜书）</h2><h2>摘要：</h2><p>决策树是机器学习中一种非常常见的分类与回归方法，可以认为是if-else结构的规则。分类决策树是由节点和有向边组成的树形结构，节点表示特征或者属性， 而边表示的是属性值，边指向的叶节点为对应的分类。在对样本的分类过程中，由顶向下，根据特征或属性值选择分支，递归遍历直到叶节点，将实例分到叶节点对应的类别中。 决策树的学习过程就是构造出一个能正取分类（或者误差最小）训练数据集的且有较好泛化能力的树，核心是如何选择特征或属性作为节点， 通常的算法是利用启发式的算法如ID3，C4.5，CART等递归的选择最优特征。选择一个最优特征，然后按照此特征将数据集分割成多个子集，子集再选择最优特征， 直到所有训练数据都被正取分类，这就构造出了决策树。决策树有如下特点： 1. 原理简单, 计算高效；使用基于信息熵相关的理论划分最优特征，原理清晰，计算效率高。 2. 解释性强；决策树的属性结构以及if-else的判断逻辑，非常符合人的决策思维，使用训练数据集构造出一个决策树后，可视化决策树， 可以非常直观的理解决策树的判断逻辑，可读性强。 3. 效果好，应用广泛;其拟合效果一般很好，分类速度快，但也容易过拟合，决策树拥有非常广泛的应用。</p><p>本文主要介绍基于ID3的算法构造决策树。</p><h2>决策树原理</h2><p>训练数据集有多个特征，如何递归选择最优特征呢？信息熵增益提供了一个非常好的也非常符合人们日常逻辑的判断准则，即信息熵增益最大的特征为最优特征。在信息论中，熵是用来度量随机变量不确定性的量纲，熵越大，不确定性越大。熵定义如下:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ebb9feaa9e94ee13e5b5359d567cd780_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"153\" class=\"content_image\" width=\"373\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;373&#39; height=&#39;153&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"373\" data-rawheight=\"153\" class=\"content_image lazy\" width=\"373\" data-actualsrc=\"https://pic1.zhimg.com/v2-ebb9feaa9e94ee13e5b5359d567cd780_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>此处log一般是以2为底，假设一个产品成品率为100%次品率为0%那么熵就为0，如果是成品率次品率各为50%，那么熵就为1，熵越大，说明不确定性越高，非常符合我们人类的思维逻辑。假设分类标记为随机变量Y，那么H(Y)表示随机变量Y的不确定性，我们依次选择可选特征，如果选择一个特征后，随机变量Y的熵减少的最多，表示得知特征X后，使得类Y不确定性减少最多，那么就把此特征选为最优特征。信息熵增益的公式如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-450e5b84711841218b186662286c972a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"105\" class=\"origin_image zh-lightbox-thumb\" width=\"518\" data-original=\"https://pic3.zhimg.com/v2-450e5b84711841218b186662286c972a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;518&#39; height=&#39;105&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"518\" data-rawheight=\"105\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"518\" data-original=\"https://pic3.zhimg.com/v2-450e5b84711841218b186662286c972a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-450e5b84711841218b186662286c972a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>ID3算法</h2><p>决策树基于信息熵增益的ID3算法步骤如下：</p><ol><li>如果数据集类别只有一类，选择这个类别作为，标记为叶节点。</li><li>从数据集的所有特征中，选择信息熵增益最大的作为节点，特征的属性分别作为节点的边。</li><li>选择最优特征后，按照对应的属性，将数据集分成多个，依次将子数据集从第1步递归进行构造子树。</li></ol><h2>python实现</h2><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"c1\">#encoding:utf-8</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">pandas</span> <span class=\"kn\">as</span> <span class=\"nn\">pd</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span>  <span class=\"kn\">as</span> <span class=\"nn\">np</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">DecisionTree</span><span class=\"p\">:</span>\n    <span class=\"k\">def</span> <span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n    <span class=\"k\">def</span> <span class=\"nf\">calEntropy</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">):</span> <span class=\"c1\"># 计算熵</span>\n        <span class=\"n\">valRate</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">/</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n        <span class=\"n\">valEntropy</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">inner</span><span class=\"p\">(</span><span class=\"n\">valRate</span><span class=\"p\">,</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">log2</span><span class=\"p\">(</span><span class=\"n\">valRate</span><span class=\"p\">))</span> <span class=\"o\">*</span> <span class=\"o\">-</span><span class=\"mi\">1</span>\n        <span class=\"k\">return</span> <span class=\"n\">valEntropy</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">fit</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">xTrain</span><span class=\"p\">,</span> <span class=\"n\">yTrain</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">()):</span>\n        <span class=\"k\">if</span> <span class=\"n\">yTrain</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span><span class=\"c1\">#如果不传，自动选择最后一列作为分类标签</span>\n            <span class=\"n\">yTrain</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[:,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n            <span class=\"n\">xTrain</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[:,:</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">columns</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buildDecisionTree</span><span class=\"p\">(</span><span class=\"n\">xTrain</span><span class=\"p\">,</span> <span class=\"n\">yTrain</span><span class=\"p\">)</span> \n        <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span>\n    <span class=\"k\">def</span> <span class=\"nf\">buildDecisionTree</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">xTrain</span><span class=\"p\">,</span> <span class=\"n\">yTrain</span><span class=\"p\">):</span>\n        <span class=\"n\">propNamesAll</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"o\">.</span><span class=\"n\">columns</span>\n        <span class=\"c1\">#print(propNamesAll)</span>\n        <span class=\"n\">yTrainCounts</span> <span class=\"o\">=</span> <span class=\"n\">yTrain</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">yTrainCounts</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n            <span class=\"c1\">#print(&#39;only one class&#39;, yTrainCounts.index[0])</span>\n            <span class=\"k\">return</span> <span class=\"n\">yTrainCounts</span><span class=\"o\">.</span><span class=\"n\">index</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n        <span class=\"n\">entropyD</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">calEntropy</span><span class=\"p\">(</span><span class=\"n\">yTrain</span><span class=\"p\">)</span>\n\n        <span class=\"n\">maxGain</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"n\">maxEntropyPropName</span> <span class=\"o\">=</span> <span class=\"bp\">None</span>\n        <span class=\"k\">for</span> <span class=\"n\">propName</span> <span class=\"ow\">in</span> <span class=\"n\">propNamesAll</span><span class=\"p\">:</span>\n            <span class=\"n\">propDatas</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">propName</span><span class=\"p\">]</span>\n            <span class=\"n\">propClassSummary</span> <span class=\"o\">=</span> <span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">/</span> <span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span><span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n\n            <span class=\"n\">sumEntropyByProp</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n            <span class=\"k\">for</span> <span class=\"n\">propClass</span><span class=\"p\">,</span> <span class=\"n\">dvRate</span> <span class=\"ow\">in</span> <span class=\"n\">propClassSummary</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n                <span class=\"n\">yDataByPropClass</span> <span class=\"o\">=</span> <span class=\"n\">yTrain</span><span class=\"p\">[</span><span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">propName</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">propClass</span><span class=\"p\">]</span>\n                <span class=\"n\">entropyDv</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">calEntropy</span><span class=\"p\">(</span><span class=\"n\">yDataByPropClass</span><span class=\"p\">)</span>\n                <span class=\"n\">sumEntropyByProp</span> <span class=\"o\">+=</span> <span class=\"n\">entropyDv</span> <span class=\"o\">*</span> <span class=\"n\">dvRate</span>\n            <span class=\"n\">gainEach</span> <span class=\"o\">=</span> <span class=\"n\">entropyD</span> <span class=\"o\">-</span> <span class=\"n\">sumEntropyByProp</span>\n            <span class=\"k\">if</span> <span class=\"n\">maxGain</span> <span class=\"o\">==</span> <span class=\"bp\">None</span> <span class=\"ow\">or</span> <span class=\"n\">gainEach</span> <span class=\"o\">&gt;</span> <span class=\"n\">maxGain</span><span class=\"p\">:</span>\n                <span class=\"n\">maxGain</span> <span class=\"o\">=</span> <span class=\"n\">gainEach</span>\n                <span class=\"n\">maxEntropyPropName</span> <span class=\"o\">=</span> <span class=\"n\">propName</span>\n        <span class=\"c1\">#print(&#39;select prop:&#39;, maxEntropyPropName, maxGain)</span>\n        <span class=\"n\">propDatas</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">maxEntropyPropName</span><span class=\"p\">]</span>\n        <span class=\"n\">propClassSummary</span> <span class=\"o\">=</span> <span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">value_counts</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">x</span> <span class=\"p\">:</span> <span class=\"n\">x</span> <span class=\"o\">/</span> <span class=\"n\">propDatas</span><span class=\"o\">.</span><span class=\"n\">size</span><span class=\"p\">)</span><span class=\"c1\"># 频次汇总 得到各个特征对应的概率</span>\n\n        <span class=\"n\">retClassByProp</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">for</span> <span class=\"n\">propClass</span><span class=\"p\">,</span> <span class=\"n\">dvRate</span> <span class=\"ow\">in</span> <span class=\"n\">propClassSummary</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">whichIndex</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">maxEntropyPropName</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">propClass</span>\n            <span class=\"k\">if</span> <span class=\"n\">whichIndex</span><span class=\"o\">.</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n                <span class=\"k\">continue</span>\n            <span class=\"n\">xDataByPropClass</span> <span class=\"o\">=</span> <span class=\"n\">xTrain</span><span class=\"p\">[</span><span class=\"n\">whichIndex</span><span class=\"p\">]</span>\n            <span class=\"n\">yDataByPropClass</span> <span class=\"o\">=</span> <span class=\"n\">yTrain</span><span class=\"p\">[</span><span class=\"n\">whichIndex</span><span class=\"p\">]</span>\n            <span class=\"k\">del</span> <span class=\"n\">xDataByPropClass</span><span class=\"p\">[</span><span class=\"n\">maxEntropyPropName</span><span class=\"p\">]</span><span class=\"c1\">#删除已经选择的属性列</span>\n\n            <span class=\"c1\">#print(propClass)</span>\n            <span class=\"c1\">#print(pd.concat([xDataByPropClass, yDataByPropClass], axis=1))</span>\n\n            <span class=\"n\">retClassByProp</span><span class=\"p\">[</span><span class=\"n\">propClass</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">buildDecisionTree</span><span class=\"p\">(</span><span class=\"n\">xDataByPropClass</span><span class=\"p\">,</span> <span class=\"n\">yDataByPropClass</span><span class=\"p\">)</span>\n\n        <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"s1\">&#39;Node&#39;</span><span class=\"p\">:</span><span class=\"n\">maxEntropyPropName</span><span class=\"p\">,</span> <span class=\"s1\">&#39;Edge&#39;</span><span class=\"p\">:</span><span class=\"n\">retClassByProp</span><span class=\"p\">}</span>\n    <span class=\"k\">def</span> <span class=\"nf\">predictBySeries</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">modelNode</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">modelNode</span><span class=\"p\">,</span> <span class=\"nb\">dict</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"n\">modelNode</span>\n        <span class=\"n\">nodePropName</span> <span class=\"o\">=</span> <span class=\"n\">modelNode</span><span class=\"p\">[</span><span class=\"s1\">&#39;Node&#39;</span><span class=\"p\">]</span>\n        <span class=\"n\">prpVal</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">nodePropName</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span> <span class=\"n\">edge</span><span class=\"p\">,</span> <span class=\"n\">nextNode</span> <span class=\"ow\">in</span> <span class=\"n\">modelNode</span><span class=\"p\">[</span><span class=\"s1\">&#39;Edge&#39;</span><span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">items</span><span class=\"p\">():</span>\n            <span class=\"k\">if</span> <span class=\"n\">prpVal</span> <span class=\"o\">==</span> <span class=\"n\">edge</span><span class=\"p\">:</span>\n                <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">predictBySeries</span><span class=\"p\">(</span><span class=\"n\">nextNode</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"bp\">None</span>\n    <span class=\"k\">def</span> <span class=\"nf\">predict</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"nb\">isinstance</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">Series</span><span class=\"p\">):</span>\n            <span class=\"k\">return</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">predictBySeries</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">data</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">data</span><span class=\"o\">.</span><span class=\"nb\">apply</span><span class=\"p\">(</span><span class=\"k\">lambda</span> <span class=\"n\">d</span><span class=\"p\">:</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">predictBySeries</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">model</span><span class=\"p\">,</span> <span class=\"n\">d</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"n\">dataTrain</span> <span class=\"o\">=</span> <span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">read_csv</span><span class=\"p\">(</span><span class=\"s2\">&#34;xiguadata.csv&#34;</span><span class=\"p\">,</span> <span class=\"n\">encoding</span> <span class=\"o\">=</span> <span class=\"s2\">&#34;gbk&#34;</span><span class=\"p\">)</span>\n\n<span class=\"n\">decisionTree</span> <span class=\"o\">=</span> <span class=\"n\">DecisionTree</span><span class=\"p\">()</span>\n<span class=\"n\">treeData</span> <span class=\"o\">=</span> <span class=\"n\">decisionTree</span><span class=\"o\">.</span><span class=\"n\">fit</span><span class=\"p\">(</span><span class=\"n\">dataTrain</span><span class=\"p\">)</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">pd</span><span class=\"o\">.</span><span class=\"n\">DataFrame</span><span class=\"p\">({</span><span class=\"s1\">&#39;预测值&#39;</span><span class=\"p\">:</span><span class=\"n\">decisionTree</span><span class=\"o\">.</span><span class=\"n\">predict</span><span class=\"p\">(</span><span class=\"n\">dataTrain</span><span class=\"p\">),</span> <span class=\"s1\">&#39;正取值&#39;</span><span class=\"p\">:</span><span class=\"n\">dataTrain</span><span class=\"o\">.</span><span class=\"n\">iloc</span><span class=\"p\">[:,</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]}))</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">json</span>\n<span class=\"k\">print</span><span class=\"p\">(</span><span class=\"n\">json</span><span class=\"o\">.</span><span class=\"n\">dumps</span><span class=\"p\">(</span><span class=\"n\">treeData</span><span class=\"p\">,</span> <span class=\"n\">ensure_ascii</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">))</span></code></pre></div><p>训练结束后，使用一个递归的字典保存决策树模型，使用格式json工具格式化输出后，可以简洁的看到树的结构。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d8a446a76a4817366c8de403142dbe88_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"727\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-d8a446a76a4817366c8de403142dbe88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;727&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"727\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic1.zhimg.com/v2-d8a446a76a4817366c8de403142dbe88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d8a446a76a4817366c8de403142dbe88_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>R语言实现</h2><div class=\"highlight\"><pre><code class=\"language-text\">dataTrain &lt;- read.csv(&#34;xiguadata.csv&#34;, header = TRUE)\n\ntrainDecisionTree &lt;- function(dataTrain){\n    calEntropy &lt;- function(y){ # 计算熵\n\n        values &lt;- table(unlist(y)); # 频次汇总 得到各个特征对应的概率\n\n        valuesRate &lt;- values / sum(values); \n\n        logVal = log2(valuesRate);# log2(0) == infinite\n        logVal[is.infinite(logVal)]=0;\n\n        valuesEntropy &lt;- -1 * t(valuesRate) %*% logVal;\n        if (is.nan(valuesEntropy)){\n            valuesEntropy = 0;\n        }\n        return(valuesEntropy);\n    }\n\n    propNamesAll &lt;- names(dataTrain)\n    propNamesAll &lt;- propNamesAll[length(propNamesAll) * - 1]\n    print(propNamesAll)\n    buildDecisionTree &lt;- function(propNames, dataSet){\n\n\n        classColumn = dataSet[, length(dataSet)]#最后一列是类别标签\n\n        classSummary &lt;- table(unlist(classColumn))# 频次汇总\n\n        defaultRet = c(propNames[1], names(classSummary)[which.max(classSummary)]);\n        if (length(classSummary) == 1){#如果所有的都是同一类别，那么标记为叶节点\n            return(defaultRet);\n        }\n        if (length(propNames) == 1){#如果只剩一种属性了，那么返回样本数量最多的类别作为节点\n            return(defaultRet);\n        }\n        entropyD &lt;- calEntropy(classColumn)\n        propGains = sapply(propNames, function(propName){ # propName 对应的是&#34;色泽&#34; &#34;根蒂&#34; &#34;敲声&#34; &#34;纹理&#34; &#34;脐部&#34; &#34;触感&#34;\n            propDatas &lt;- dataSet[c(propName)]\n\n            propClassSummary &lt;- table(unlist(propDatas))# 频次汇总\n\n            retGain &lt;- sapply(names(propClassSummary), function(propClass){# propClass 对应色泽的种类 如 浅白 青绿 乌黑\n                dataByPropClass &lt;- subset(dataSet, dataSet[c(propName)] == propClass); #筛选出色泽等于 种类 propClass 的数据集\n                entropyDv &lt;- calEntropy(dataByPropClass[, length(dataByPropClass)]) #最后一列是标记是否为好瓜\n                Dv = propClassSummary[c(propClass)][1]\n                return(entropyDv * Dv);# 这里没有直接除|D|,最后累加后再除，等价的\n            });\n\n            return(entropyD - sum(retGain)/sum(propClassSummary));\n        });\n        #print(propGains);\n        maxEntropyProp = propGains[which.max(propGains)];#选择信息熵增益最大的属性\n        propName = names(maxEntropyProp)[1]\n        #print(propName)\n        propDatas &lt;- dataSet[c(propName)]\n\n        propClassSummary &lt;- table(unlist(propDatas))# 频次汇总\n\n        propClassSummary &lt;- propClassSummary[which(propClassSummary &gt; 0)]\n        propClassNames &lt;- names(propClassSummary)\n\n        #propClassNames = c(propClassNames[1])\n        retGain &lt;- sapply(propClassNames, function(propClass){# propClass 对应色泽的种类 如 浅白 青绿 乌黑\n\n            dataByPropClass &lt;- subset(dataSet, dataSet[c(propName)] == propClass); #筛选出色泽等于 种类 propClass 的数据集\n            leftClassNames = propNames[which(propNames==propName) * -1] #去掉这个属性，递归构造决策树\n            ret = buildDecisionTree(leftClassNames, dataByPropClass);\n            return(ret);\n        });\n        #names(retGain) = propClassNames\n        retList = retGain\n        #retList = list()\n        #for (propClass in propClassNames){\n        #    retList[propClass] = retGain[propClass]\n        #}\n        #print(retList)\n\n        #索引1表示选择的属性名称 索引2对应的类别，如果有子树那么就是frame，否则就是类别\n        ret  = list(propName, retList)\n        #ret = data.frame(c(retList))\n        #names(ret) = c(propName)\n        return(ret);\n    }\n    retProp = buildDecisionTree(propNamesAll, dataTrain);\n    return(retProp);\n}\ndecisionTree = trainDecisionTree(dataTrain)\n#print(decisionTree)\n\n\nlibrary(&#34;rpart&#34;)\nlibrary(&#34;rpart.plot&#34;)\ndataTrain &lt;- read.csv(&#34;xiguadata.csv&#34;, header = TRUE)\nprint(dataTrain)\nfit &lt;- rpart(HaoGua~.,data=dataTrain,control = rpart.control(minsplit = 1, minbucket = 1),method=&#34;class&#34;)\nprintcp(fit)\n\nrpart.plot(fit, branch = 1, branch.type = 1, type = 2, extra = 102,shadow.col=&#39;gray&#39;, box.col=&#39;green&#39;,border.col=&#39;blue&#39;, split.col=&#39;red&#39;,main=&#34;DecisionTree&#34;)\n\n#library(jsonlite)\n#dataJson = toJSON(decisionTree)\n#c &lt;- file( &#34;result.txt&#34;, &#34;w&#34; )\n#writeLines(dataJson, c )\n#close( c )   #这里需要主动关闭文件\n\n#for (k in propNames) {\n#    eachData &lt;- dataSet[c(k)]\n#    values &lt;- table(unlist(eachData))# 频次汇总\n#    #print(values)\n#    print(k)\n#    total &lt;- 0\n#    for (m in names(values)) {\n#        #print(m)\n#        #print(values[m][1])\n#        data3 &lt;- subset(dataSet, dataSet[c(k)] == m)\n#        entropyDv &lt;- calEntropy(data3[, length(data3)])\n#        #print(entropyDv)\n#        total = total + entropyDv*values[c(m)][1]\n#    }\n#    GainDv &lt;- entropyD - total /  sum(values);+\n#    print(GainDv)\n#}</code></pre></div><p>R语言代码包含本人自己编写的R语言ID3算法，最后使用R的rpart包训练了一个决策树。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2cc57e911bb764792f4d4c5b9d4438d9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"671\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-2cc57e911bb764792f4d4c5b9d4438d9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;671&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"671\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic2.zhimg.com/v2-2cc57e911bb764792f4d4c5b9d4438d9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2cc57e911bb764792f4d4c5b9d4438d9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结：</h2><ul><li>ID3算法简洁清晰，符合人类思路方式。</li><li>决策树的解释性强，可视化后也方便理解模型和验证正确性。</li><li>ID3算法时候标签类特征的样本，对应具有连续型数值的特征，无法运行此算法。</li><li>有过拟合的风险，要通过剪枝来避免过拟合。</li><li>信息增益有时候偏爱属性很多的特征，C4.5和CART算法可以对此有优化。</li><li>这是我的github主页<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy</span><span class=\"invisible\"></span></a>，有些有意思的分享。</li><li>python相比R语言写起来还是溜多了，主要是遍历和嵌套，python比R要容易很多，R的数据筛选和选择方便一点，这个python版本的id3算法写的还是很清晰简洁的 正是<i>Talk</i> <i>is</i> <i>cheap</i>. <i>Show</i> <i>me</i> <i>the</i> <i>code</i>。这是在网上可以看到原生实现版本中，最精简的版本之一。</li></ul><h2>对应的西瓜书数据集为</h2><div class=\"highlight\"><pre><code class=\"language-text\">色泽  根蒂  敲声  纹理  脐部  触感  HaoGua\n青绿  蜷缩  浊响  清晰  凹陷  硬滑  是\n乌黑  蜷缩  沉闷  清晰  凹陷  硬滑  是\n乌黑  蜷缩  浊响  清晰  凹陷  硬滑  是\n青绿  蜷缩  沉闷  清晰  凹陷  硬滑  是\n浅白  蜷缩  浊响  清晰  凹陷  硬滑  是\n青绿  稍蜷  浊响  清晰  稍凹  软粘  是\n乌黑  稍蜷  浊响  稍糊  稍凹  软粘  是\n乌黑  稍蜷  浊响  清晰  稍凹  硬滑  是\n乌黑  稍蜷  沉闷  稍糊  稍凹  硬滑  否\n青绿  硬挺  清脆  清晰  平坦  软粘  否\n浅白  硬挺  清脆  模糊  平坦  硬滑  否\n浅白  蜷缩  浊响  模糊  平坦  软粘  否\n青绿  稍蜷  浊响  稍糊  凹陷  硬滑  否\n浅白  稍蜷  沉闷  稍糊  凹陷  硬滑  否\n乌黑  稍蜷  浊响  清晰  稍凹  软粘  否\n浅白  蜷缩  浊响  模糊  平坦  硬滑  否\n青绿  蜷缩  沉闷  稍糊  稍凹  硬滑  否</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "决策树", 
                    "tagLink": "https://api.zhihu.com/topics/19569936"
                }, 
                {
                    "tag": "ID3", 
                    "tagLink": "https://api.zhihu.com/topics/19591098"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65283981", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 20, 
            "title": "FFLUA——C++嵌入Lua&扩展Lua利器", 
            "content": "<p><b>摘要:</b></p><p>在使用C++做服务器开发中，经常会使用到脚本技术，Lua是最优秀的嵌入式脚本之一。Lua的轻量、小巧、概念之简单，都使他变得越来越受欢迎。本人也使用过python做嵌入式脚本，二者各有特点，关于python之后会写相关的文章，python对于我而言更喜欢用来编写工具，我前边一些相关的算法也是用python来实现的。今天主要讲Lua相关的开发技术。Lua具有如下特点：</p><ul><li>Lua 拥有虚拟机的概念，而其全部用标准C实现，不依赖任何库即可编译安装，更令人欣喜的是，整个Lua 的实现代码并不算多，可以直接继承到项目中，并且对项目的编译时间几乎没有什么影响</li><li>Lua的虚拟机是线程安全的，这里讲的线程安全级别指得是STL的线程安全级别，即一个lua虚拟机被一个线程访问是安全的，多个lua虚拟机被多个线程分别访问也是安全的，一个lua虚拟机被多个线程访问是不安全的。</li><li>Lua的概念非常少，数据结构只有table，这样当使用Lua作为项目的配置文件时，即使没有编程功底的策划也可以很快上手编写。</li><li>Lua没有原生的对象，没有class的关键字，这也保障了其概念简单，但是仍然是可以使用Lua面向对象编程的。</li><li>Lua尽管小巧，却支持比较先进的编程范式，lua 中的匿名函数和闭包会让代码写起来更加 优雅和高效，如果某人使用的C++ 编译器还比较老套，不支持C++11，那么可以尽快感受一下lua的匿名函数和闭包。</li><li>Lua是最高效的嵌入式脚本之一（如果不能说最的话，目前证据显示是最）。</li><li>Lua的垃圾回收也可以让C++程序收益匪浅，这也是C++结合脚本技术的重要优势之一。</li><li>Lua 的嵌入非常的容易，CAPI 相对比较简洁，而且文档清晰，当然Lua的Capi需要掌握Lua中独特的堆栈的概念，但仍然足够简单。</li><li>Lua的扩展也非常的容易，将C++是对象、函数导入到lua中会涉及到一些技巧，如果纯粹使用lua CAPI会稍显繁杂，幸运的是一些第三方库简化了这些操作，而FFLUA绝对是最好用的之一。</li></ul><p><b>嵌入Lua：</b></p><p>嵌入lua脚本，必须要把lua脚本载入lua虚拟机，lua中的概念称之为dofile，FFLUA中封装了dofile的操作，由于lua文件可能集中放在某个目录，FFLUA中也提供了设置lua脚本目录的接口：</p><div class=\"highlight\"><pre><code class=\"language-text\">int  add_package_path(const string&amp; str_)\nint  load_file(const string&amp; file_name_) throw (lua_exception_t)</code></pre></div><p>load_file就是执行dofile操作，若出错，则throw异常对象，可以使用exception引用目标对象使用what接口输出代码出错的traceback。</p><p>当嵌入lua时，最简单的情况是把lua脚本当成配置使用，那么需要获取lua脚本中的变量和设置lua变量，FFLUA封装了两个接口用于此操作。lua是动态语言，变量可以被赋值为任何lua支持的类型，但C++是强类型的，所以两个接口都是范型的：</p><div class=\"highlight\"><pre><code class=\"language-text\">    template&lt;typenameT&gt;\n    int  get_global_variable(conststring&amp; field_name_, T&amp; ret_);\n    template&lt;typenameT&gt;\n    int  get_global_variable(constchar* field_name_, T&amp; ret_);</code></pre></div><p>有时需要直接执行一些lua语句，lua中有dostring的概念，FFLUA中封装了单独的接口run_string：</p><div class=\"highlight\"><pre><code class=\"language-text\">void run_string(constchar* str_)</code></pre></div><p>嵌入lua时最一般的情况是调用lua中的函数，lua的函数比C++更灵活，可以支持任意多个参数，若未赋值，自动设置为nil，并且可以返回多个返回值。无论如何，从C++角度讲，当你嵌入lua调用lua函数时，你总希望lua的使用方式跟C++越像越好，你不希望繁复的处理调用函数的参数问题，比如C++数据转换成lua能处理的数据，即无趣又容易出错。正也正是FFLUA需要做到，封装调用lua函数的操作，把赋值参数，调用函数，接收返回值的细节做到透明，C++调用者就像调用普通的C++函数一样。使用FFLUA中调用lua函数使用call接口：</p><div class=\"highlight\"><pre><code class=\"language-text\">void call(constchar* func_name_)</code></pre></div><p>当调用出错时，异常信息记录了traceback。实际上，FFLUA重载了9个call函数，以来自动适配调用9个参数的lua函数。</p><div class=\"highlight\"><pre><code class=\"language-text\">    template&lt;typename RET&gt;\n    RET call(const char* func_name_) throw (lua_exception_t);\n    ......\n    template&lt;typename RET, typename ARG1, typename ARG2, typename ARG3, typename ARG4,\n             typename ARG5, typename ARG6, typename ARG7, typename ARG8, typename ARG9&gt;\n    RET call(const char* func_name_, ARG1 arg1_, ARG2 arg2_, ARG3 arg3_,\n             ARG4 arg4_, ARG5 arg5_, ARG6 arg6_, ARG7 arg7_,\n             ARG8 arg8_, ARG9 arg9_) throw (lua_exception_t);</code></pre></div><p>需要注明的是：</p><ul><li>call接口的参数是范型的，自动会使用范型traits机制转换成lua类型，并push到lua堆栈中</li><li>call接口的返回值也是范式的，这就要求使用call时必须提供返回值的类型，如果lua函数不返回值会怎样？lua中有个特性，只有nil和false的布尔值为false，所以当lua函数返回空时，你仍然可以使用bool类型接收参数，只是调用者忽略其返回值就行了。</li><li>call只支持一个返回值，虽然lua可以返回多个值，但是call会忽略其他返回值，这也是为了尽可能像是调用C++函数，若要返回多个值，完全可以用table返回。</li></ul><p><b>扩展LUA：</b></p><p>这也是非常重要的操作，嵌入lua总是和扩展lua相伴相行。lua若要操作C++中的对象或函数，那么必须先把C++对应的接口注册都lua中。Lua CAPI提供了一系列的接口拥有完成此操作，但是关于堆栈的操作总是会稍显头疼，fflua极大的简化了注册C++对象和接口的操作，可以说是最简单的注册方式之一（如果不准说最的话）。首先我们整理一下需要哪些注册操作：</p><ul><li>C++ 静态函数注册为lua中的全局函数，这样在lua中调用C++函数就像是调用C++全局函数</li><li>C++对象注册成Lua中的对象，可以通过new接口在lua中创建C++对象</li><li>C++类中的属性注册到lua，lua访问对象的属性就像是访问table中的属性一样。</li><li>C++类中的函数注册到lua中，lua调用其接口就像是调用talbe中的接口一样。</li></ul><p>FFLUA中提供了一个范型接口，适配于注册C++相关数据, FFLUA中提供了工具类用于生成仿函数中应该完成的注册操作：</p><p>刚才提到的像lua中的所有注册操作，都可以使用def操作完成。 示例如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">//! 注册子类，ctor(int) 为构造函数， foo_t为类型名称， base_t为继承的基类名称\n    fflua_register_t&lt;foo_t, ctor(int)&gt;(ls, &#34;foo_t&#34;, &#34;base_t&#34;)\n                .def(&amp;foo_t::print, &#34;print&#34;)        //! 子类的函数\n                .def(&amp;foo_t::a, &#34;a&#34;);               //! 子类的字段</code></pre></div><p>尤其特别的是，C++中的继承可以在注册到lua中被保持这样注册过基类的接口，子类就不需要重复注册。</p><p><b>高级特性：</b></p><p>通过以上的介绍，也许你已经了解了FFLUA的设计原则，即：当在编写C++代码时，希望使用LUA就像使用C++本地的代码一样，而在lua中操作C++的数据和接口的时候，又希望C++用起来完全跟table一个样。这样可以大大减轻程序开发的工作，从而把精力更多放大设计和逻辑上。那么做到如何lua才算像C++，C++做到如何才算像lua呢？我们知道二者毕竟相差甚远，我们只需要把常见的操作封装成一直即可，不常见操作则特殊处理。常见操作有：</p><ul><li>C++ 调用lua函数，FFLUA已经封装了call函数，保障了调用lua函数就像调用本地C++函数一样方便</li><li>C++注册接口和对象到lua中，lua中操作对象就像操作table一样直接。</li><li>C++中除了自定义对象，STL是用的最多的了，C++希望lua中能够接收STL的参数，或者能够返回STL数据结构</li><li>Lua中只有table数据结构，Lua希望C++的参数的数据结构支持table，并且lua可以直接把table作为返回值。</li><li>C++的指针需要传递到lua中，同时也希望某些操作，lua可以把C++对象指针作为返回值</li></ul><p>以上前两者已经介绍了，而后三者FFLUA也是给予 完美支持。通过范型的C++封装，可以将C++ STL完美的转换成luatable，同时在lua返回table的时候，自动根据返回值类型将lua的table转换成C++ STL。FFLUA中只要被注册过的C++对象，都可以把其指针作为参数赋值给lua，甚至在lua中保存。当我讲述以上特性的时候，都是在保证类型安全的前提下。重要的类型检查有：</p><ul><li>STL转成Luatable时，STL中的类型必须是lua支持的，包括基本类型和已经注册过的C++对象指针。并且STL可以嵌套使用，如vector&lt;list&lt;int&gt; &gt;,  不要惊讶，这是支持的，不管嵌套多少层，都是支持的，使用C++模板的递归机制，该特性得到了完美支持。vector、list、set都会转换成table的数组模式，key从1开始累加。而map类型自动适配为table字典。</li><li>LUA中的table可以被当成返回值转换成C++ STL，转换跟上边刚好是对应的，当然有一个限制，由于C++的STL类型必须是唯一的，如vector&lt;int&gt;的返回值就要求lua中的table所有值都是int。否则FFLUA会返回出错，并提示类型转换失败</li><li>无论死调用lua中使用C++对象指针，还是LuA中返回C++对象指针，该对象必须是lua可以识别的，即已经被注册的，否则FFLUA会提示转换类型失败。</li></ul><p><b>关于重载：</b></p><p>　　关于重载LUA 可以使用lua中内部自己的reload，也可以将fflua对象销毁后，重先创建一个，创建fflua对象的开销和创建lua虚拟机的开销一直，不会有附加开销。</p><p><b>总结：</b></p><ul><li>FFLUA是简化C++嵌入绑定lua脚本的类库</li><li>FFLUA只有三个头文件，不依赖除lua之外的任何的类库，开发者可以非常容易的使用FFLUA</li><li>FFLUA 对于常用的STL数据结构进行了支持</li><li>FFLUA 即使拥有了这么多特性，仍然保持了轻量，只要用过C++，只要用过lua，FFLUA的代码就可以非常清晰的看清其实现，当你了解其内部实现时，你会发现FFLUA已经做到了极简，范型模板展开后的代码就跟你自己原生LUA CAPI 编写的一样直接。</li><li>FFLUA的开源代码：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/fflua\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/fflua</span><span class=\"invisible\"></span></a></li></ul><p><b>完整的C++示例代码：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;assert.h&gt;\nusing namespace std;\n\n#include &#34;lua/fflua.h&#34;\n\nusing namespace ff;\n\nclass base_t\n{\npublic:\n    base_t():v(789){}\n    void dump()\n    {\n        printf(&#34;in %s a:%d\\n&#34;, __FUNCTION__, v);\n    }\n    int v;\n};\nclass foo_t: public base_t\n{\npublic:\n    foo_t(int b):a(b)\n    {\n        printf(&#34;in %s b:%d this=%p\\n&#34;, __FUNCTION__, b, this);\n    }\n    ~foo_t()\n    {\n        printf(&#34;in %s\\n&#34;, __FUNCTION__);\n    }\n    void print(int64_t a, base_t* p) const\n    {\n        printf(&#34;in foo_t::print a:%ld p:%p\\n&#34;, (long)a, p);\n    }\n\n    static void dumy()\n    {\n        printf(&#34;in %s\\n&#34;, __FUNCTION__);\n    }\n    int a;\n};\n\n//! lua talbe 可以自动转换为stl 对象\nvoid dumy(map&lt;string, string&gt; ret, vector&lt;int&gt; a, list&lt;string&gt; b, set&lt;int64_t&gt; c)\n{\n    printf(&#34;in %s begin ------------\\n&#34;, __FUNCTION__);\n    for (map&lt;string, string&gt;::iterator it =  ret.begin(); it != ret.end(); ++it)\n    {\n        printf(&#34;map:%s, val:%s:\\n&#34;, it-&gt;first.c_str(), it-&gt;second.c_str());\n    }\n    printf(&#34;in %s end ------------\\n&#34;, __FUNCTION__);\n}\n\nstatic void lua_reg(lua_State* ls)\n{\n    //! 注册基类函数, ctor() 为构造函数的类型\n    fflua_register_t&lt;base_t, ctor()&gt;(ls, &#34;base_t&#34;)  //! 注册构造函数\n                    .def(&amp;base_t::dump, &#34;dump&#34;)     //! 注册基类的函数\n                    .def(&amp;base_t::v, &#34;v&#34;);          //! 注册基类的属性\n\n    //! 注册子类，ctor(int) 为构造函数， foo_t为类型名称， base_t为继承的基类名称\n    fflua_register_t&lt;foo_t, ctor(int)&gt;(ls, &#34;foo_t&#34;, &#34;base_t&#34;)\n                .def(&amp;foo_t::print, &#34;print&#34;)        //! 子类的函数\n                .def(&amp;foo_t::a, &#34;a&#34;);               //! 子类的字段\n\n    fflua_register_t&lt;&gt;(ls)\n                .def(&amp;dumy, &#34;dumy&#34;);                //! 注册静态函数\n}\n\nint main(int argc, char* argv[])\n{\n\n    fflua_t fflua;\n    try \n    {\n        //! 注册C++ 对象到lua中\n        fflua.reg(lua_reg);\n        \n        //! 载入lua文件\n        fflua.add_package_path(&#34;./&#34;);\n        fflua.load_file(&#34;test.lua&#34;);\n        \n        //! 获取全局变量\n        int var = 0;\n        assert(0 == fflua.get_global_variable(&#34;test_var&#34;, var));\n        //! 设置全局变量\n        assert(0 == fflua.set_global_variable(&#34;test_var&#34;, ++var));\n\n        //! 执行lua 语句\n        fflua.run_string(&#34;print(\\&#34;exe run_string!!\\&#34;)&#34;);\n        \n        //! 调用lua函数, 基本类型作为参数\n        int32_t arg1 = 1;\n        float   arg2 = 2;\n        double  arg3 = 3;\n        string  arg4 = &#34;4&#34;;\n        fflua.call&lt;bool&gt;(&#34;test_func&#34;, arg1, arg2, arg3,  arg4);\n        \n        //! 调用lua函数，stl类型作为参数， 自动转换为lua talbe\n        vector&lt;int&gt; vec;        vec.push_back(100);\n        list&lt;float&gt; lt;         lt.push_back(99.99);\n        set&lt;string&gt; st;         st.insert(&#34;OhNIce&#34;);\n        map&lt;string, int&gt; mp;    mp[&#34;key&#34;] = 200;\n        fflua.call&lt;string&gt;(&#34;test_stl&#34;, vec, lt, st,  mp);\n        \n        //! 调用lua 函数返回 talbe，自动转换为stl结构\n        vec = fflua.call&lt;vector&lt;int&gt; &gt;(&#34;test_return_stl_vector&#34;);\n        lt  = fflua.call&lt;list&lt;float&gt; &gt;(&#34;test_return_stl_list&#34;);\n        st  = fflua.call&lt;set&lt;string&gt; &gt;(&#34;test_return_stl_set&#34;);\n        mp  = fflua.call&lt;map&lt;string, int&gt; &gt;(&#34;test_return_stl_map&#34;);\n        \n        //! 调用lua函数，c++ 对象作为参数, foo_t 必须被注册过\n        foo_t* foo_ptr = new foo_t(456);\n        fflua.call&lt;bool&gt;(&#34;test_object&#34;, foo_ptr);\n        \n        //! 调用lua函数，c++ 对象作为返回值, foo_t 必须被注册过 \n        assert(foo_ptr == fflua.call&lt;foo_t*&gt;(&#34;test_ret_object&#34;, foo_ptr));\n        //! 调用lua函数，c++ 对象作为返回值, 自动转换为基类\n        base_t* base_ptr = fflua.call&lt;base_t*&gt;(&#34;test_ret_base_object&#34;, foo_ptr);\n        assert(base_ptr == foo_ptr);\n \n    }\n    catch (exception&amp; e)\n    {\n        printf(&#34;exception:%s\\n&#34;, e.what());\n    }\n    return 0;\n}</code></pre></div><p> 更多精彩文章 <a href=\"https://link.zhihu.com/?target=http%3A//h2cloud.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://h2cloud.org</a></p><p></p>", 
            "topic": [
                {
                    "tag": "Lua", 
                    "tagLink": "https://api.zhihu.com/topics/19612186"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }, 
                {
                    "tag": "游戏服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19591286"
                }
            ], 
            "comments": [
                {
                    "userName": "徐波", 
                    "userLink": "https://www.zhihu.com/people/08f89e41f7ec82121727bd9a8e040709", 
                    "content": "<p>Lua被单一线程访问安全不叫线程安全, 或者说,这是模块的基本素质(没有全局变量)<br></p><p>Google v8引擎的性能和Lua有的一拼,还有逃逸检测, 这点lua赶不上.</p><p>嵌入的难度, js也比lua低多了, 有node.js加持, 周边生态很好</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63713178", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 54, 
            "title": "WebSocket协议详解与c++&c#实现", 
            "content": "<h2>摘要：</h2><p>随着手机游戏、H5游戏以及微信小游戏的普及，越来越多的客户端-服务器端的通讯采用websocket协议。Websocket协议是全双工的、基于数据帧的、建立在tcp之上的长连接协议。Websocket的协议是头是字符串的兼容http的，而握手之后的数据帧则是紧凑的二进制，所以websocket是紧凑和高效的。现在主流的PC浏览器以及手机浏览器对websocket都实现了非常成熟的支持。Websocket协议有着统一的标准的，所有websocket通讯无论实现的语言如何，无论使用的终端如何，最终都是一致的。 Websocket的有点有： 1.  Websocket有公共的标准，有很多公共的库可以使用，比如web端，各个浏览器都已原生的支持websocket，所以拿来即用，非常的方便。比如cocos2dx就继承了websocket。 2.  比如游戏使用了websocket，那么就可以非常容易的用web调用js发websocket消息，从而模拟客户端的操作。 3.  Websocket相对于http是长连接的，这样就可以实现实时的推送消息。 4.  Websocket既能支持文本格式也可以支持二进制格式，这样无论是js还是c++，都可以适当的选择自己喜欢的数据格式。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-698d77f2a9a1e6e5e94784deb2cf3695_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb\" width=\"834\" data-original=\"https://pic2.zhimg.com/v2-698d77f2a9a1e6e5e94784deb2cf3695_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;834&#39; height=&#39;444&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"834\" data-rawheight=\"444\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"834\" data-original=\"https://pic2.zhimg.com/v2-698d77f2a9a1e6e5e94784deb2cf3695_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-698d77f2a9a1e6e5e94784deb2cf3695_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Websocket可以说完全治好了大家关于长连接使用什么协议的纠结。再游戏行业，服务器一般都是使用C++专门开发的网络程序，常规的一般都是使用比较传统的二进制协议，现在想用websocket的人越来越多，但是可以用于服务器端的websocket库却很少，要不就是库太重量级依赖了太多不需要的模块要不就是绑定了特定的网络接口实现，github上搜了下还websocket库很少。下面介绍一下我的通用websocket解析库，具有如下特点。 1.  轻量，只封装websocket的解析，不依赖任何网络接口，拿来即用。 2.  逻辑清晰，你可以直接看代码，直接能够理解websocket的协议。 3.  One header file only。全部实现就在一个头文件里，集成不能再容易了。 4.  目前提供C++和c#的实现。别的语言我就没空写了，刚兴趣的可以照猫画虎来一个。</p><h2>Websocket消息头：</h2><p>模拟发送websocket非常的容易，我们写一个很简单的html+js就可以实现，当然你可以直接使用我的这个模拟客户端: <a href=\"https://link.zhihu.com/?target=https%3A//fanchy.github.io/client.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">fanchy.github.io/client</span><span class=\"invisible\">.html</span><span class=\"ellipsis\"></span></a>。比如我们输入ip为127.0.0.1端口44000，将会受到这样的文本协议。</p><div class=\"highlight\"><pre><code class=\"language-html\">GET /chat HTTP/1.1\nHost: 127.0.0.1:44000\nConnection: Upgrade\nPragma: no-cache\nCache-Control: no-cache\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36\nUpgrade: websocket\nOrigin: https://fanchy.github.io\nSec-WebSocket-Version: 13\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nSec-WebSocket-Key: 8SIMf+o8pqn1RCe/ivxtPg==\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</code></pre></div><p>关键参数有： <i>   Get /chat 这个是客户端指定的目录，我们做游戏服务器的，基本上根据目录区分服务器，只根据端口区分服务器，所以这个参数实际上可以忽略。 </i>   Upgrade: websocket 这个必须有，这个是兼容http的需要，有这个字段说明这个不是普通的http是一个websocket的连接。 <i>   Sec-WebSocket-Version版本号，可以忽略。 </i>   Sec-WebSocket-Key这个是用作握手的key，具体使用见下文。 Websocket协议的验证 我们游戏服务器可能使用多种协议，比如同时兼容二进制协议和websocket协议。因为有websocket一定是GET开头的，所以我们可以通过验证第一个消息是不是带GET字符串从而判断对方连接是websocket连接还是普通连接。示例代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"n\">cacheRecvData</span><span class=\"p\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">);</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">dictParams</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"nb\">true</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&amp;</span> <span class=\"n\">strRecvData</span> <span class=\"o\">=</span> <span class=\"n\">cacheRecvData</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">3</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;GET&#34;</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;GE&#34;</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;G&#34;</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;</span><span class=\"se\">\\r\\n\\r\\n</span><span class=\"s\">&#34;</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span><span class=\"c1\">//!header data not end\n</span><span class=\"c1\"></span>    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;Upgrade: websocket&#34;</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">statusWebSocketConnection</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">strLines</span><span class=\"p\">;</span>\n    <span class=\"n\">strSplit</span><span class=\"p\">(</span><span class=\"n\">strRecvData</span><span class=\"p\">,</span> <span class=\"n\">strLines</span><span class=\"p\">,</span> <span class=\"s\">&#34;</span><span class=\"se\">\\r\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">strLines</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&amp;</span> <span class=\"n\">line</span> <span class=\"o\">=</span> <span class=\"n\">strLines</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&gt;</span> <span class=\"n\">strParams</span><span class=\"p\">;</span>\n        <span class=\"n\">strSplit</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">,</span> <span class=\"n\">strParams</span><span class=\"p\">,</span> <span class=\"s\">&#34;: &#34;</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strParams</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">dictParams</span><span class=\"p\">[</span><span class=\"n\">strParams</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">strParams</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">strParams</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">strParams</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;GET&#34;</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">::</span><span class=\"n\">npos</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">dictParams</span><span class=\"p\">[</span><span class=\"s\">&#34;PATH&#34;</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">strParams</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n</code></pre></div><h2>Websocket的握手</h2><p>Websocket因为要兼容http，所以会发一个常规的http的协议头，然后进行一次握手从而建立安全连接。Websocket握手的时候也就是建立连接后第一个消息会包含Sec-WebSocket-Key这个字段，服务器接收到这个字段后追加一个固定的guid值&#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;，然后做sha1加密并转base64变成可见字符返回给客户端。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">dictParams</span><span class=\"p\">.</span><span class=\"n\">find</span><span class=\"p\">(</span><span class=\"s\">&#34;Sec-WebSocket-Key&#34;</span><span class=\"p\">)</span> <span class=\"o\">!=</span> <span class=\"n\">dictParams</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">())</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"o\">&amp;</span> <span class=\"n\">Sec_WebSocket_Key</span> <span class=\"o\">=</span> <span class=\"n\">dictParams</span><span class=\"p\">[</span><span class=\"s\">&#34;Sec-WebSocket-Key&#34;</span><span class=\"p\">];</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">strGUID</span> <span class=\"o\">=</span> <span class=\"n\">Sec_WebSocket_Key</span> <span class=\"o\">+</span> <span class=\"s\">&#34;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#34;</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">dataHashed</span> <span class=\"o\">=</span> <span class=\"n\">sha1Encode</span><span class=\"p\">(</span><span class=\"n\">strGUID</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">strHashBase64</span> <span class=\"o\">=</span> <span class=\"n\">base64Encode</span><span class=\"p\">(</span><span class=\"n\">dataHashed</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">(),</span> <span class=\"n\">dataHashed</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">(),</span> <span class=\"nb\">false</span><span class=\"p\">);</span>\n\n    <span class=\"kt\">char</span> <span class=\"n\">buff</span><span class=\"p\">[</span><span class=\"mi\">512</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span>\n    <span class=\"n\">snprintf</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">),</span> <span class=\"s\">&#34;HTTP/1.1 101 Switching Protocols</span><span class=\"se\">\\r\\n</span><span class=\"s\">Upgrade: websocket</span><span class=\"se\">\\r\\n</span><span class=\"s\">Connection: Upgrade</span><span class=\"se\">\\r\\n</span><span class=\"s\">Sec-WebSocket-Accept: %s</span><span class=\"se\">\\r\\n\\r\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">strHashBase64</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">());</span>\n\n    <span class=\"n\">addSendPkg</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>组装成websocket协议头如下： HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: mzjDI+C9Ekz6tc/f5gWv38L5Hu0= 客户端收到服务器的这个应答消息后，握手完成，连接建立完成，开始数据传输。</p><h2>数据帧</h2><p>与tcp的流式数据不同，与http相似，websocket使用帧的方式传输数据，这样解包实际上是方便的，根据长度解析消息包这个最清晰了。 ABNF如下图所示： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bbbe29ee20cd583aecbef07cc97b9257_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb\" width=\"460\" data-original=\"https://pic4.zhimg.com/v2-bbbe29ee20cd583aecbef07cc97b9257_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;460&#39; height=&#39;289&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"460\" data-rawheight=\"289\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"460\" data-original=\"https://pic4.zhimg.com/v2-bbbe29ee20cd583aecbef07cc97b9257_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bbbe29ee20cd583aecbef07cc97b9257_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>FIN：1 bit，如果不是分片，这个就是1，如果是分片，并且不是最后一个片，那么就是0</li><li>RSV1, RSV2, RSV3: 每个1 bit，简单说用不到</li><li>Opcode: 4 bits， 0，1, 2都代表数据，8代表关闭连接，0X9为ping，0XA为pong其他用不到。</li><li>Mask: 1 bit 这个客户端必须是1.</li><li>Payload length: 7 bits, 7+16 bits, 或者 7+64 bits，，如果是小于126就用一个字节表示数据长度，如果等于126，表示后续2字节表示长度，如果是127后续8字节表示长度。</li><li>Masking-key: 0 or 4 bytes 客户端发送的必须有掩码</li><li>Payload data不出意外剩下的就是数据了。</li></ul><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">nFIN</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">cacheRecvData</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x80</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mh\">0x80</span><span class=\"p\">)</span><span class=\"o\">?</span> <span class=\"mi\">1</span><span class=\"o\">:</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nOpcode</span> <span class=\"o\">=</span> <span class=\"n\">cacheRecvData</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x0F</span><span class=\"p\">;</span>\n    <span class=\"c1\">//int nMask = ((cacheRecvData[1] &amp; 0x80) == 0x80) ? 1 : 0; //!this must be 1\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">nPayload_length</span> <span class=\"o\">=</span> <span class=\"n\">cacheRecvData</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&amp;</span> <span class=\"mh\">0x7F</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nPlayLoadLenByteNum</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nPayload_length</span> <span class=\"o\">==</span> <span class=\"mi\">126</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">nPlayLoadLenByteNum</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nMaskingKeyByteNum</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">aMasking_key</span><span class=\"p\">;</span>\n    <span class=\"n\">aMasking_key</span><span class=\"p\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">cacheRecvData</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">nPlayLoadLenByteNum</span><span class=\"p\">,</span> <span class=\"n\">nMaskingKeyByteNum</span><span class=\"p\">);</span>\n    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">aPayload_data</span><span class=\"p\">;</span>\n    <span class=\"n\">aPayload_data</span><span class=\"p\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">cacheRecvData</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">nPlayLoadLenByteNum</span> <span class=\"o\">+</span> <span class=\"n\">nMaskingKeyByteNum</span><span class=\"p\">,</span> <span class=\"n\">nPayload_length</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">nLeftSize</span> <span class=\"o\">=</span> <span class=\"n\">cacheRecvData</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"p\">(</span><span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">nPlayLoadLenByteNum</span> <span class=\"o\">+</span> <span class=\"n\">nMaskingKeyByteNum</span> <span class=\"o\">+</span> <span class=\"n\">nPayload_length</span><span class=\"p\">);</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nLeftSize</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span> <span class=\"n\">leftBytes</span><span class=\"p\">;</span>\n        <span class=\"n\">leftBytes</span><span class=\"p\">.</span><span class=\"n\">assign</span><span class=\"p\">(</span><span class=\"n\">cacheRecvData</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">()</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">+</span> <span class=\"n\">nPlayLoadLenByteNum</span> <span class=\"o\">+</span> <span class=\"n\">nMaskingKeyByteNum</span> <span class=\"o\">+</span> <span class=\"n\">nPayload_length</span><span class=\"p\">,</span> <span class=\"n\">nLeftSize</span><span class=\"p\">);</span>\n        <span class=\"n\">cacheRecvData</span> <span class=\"o\">=</span> <span class=\"n\">leftBytes</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">nPayload_length</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">aPayload_data</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">char</span><span class=\"p\">)(</span><span class=\"n\">aPayload_data</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">^</span> <span class=\"n\">aMasking_key</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">%</span> <span class=\"n\">nMaskingKeyByteNum</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"mi\">8</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">addSendPkg</span><span class=\"p\">(</span><span class=\"n\">buildPkg</span><span class=\"p\">(</span><span class=\"s\">&#34;&#34;</span><span class=\"p\">,</span> <span class=\"n\">nOpcode</span><span class=\"p\">));</span><span class=\"c1\">// close\n</span><span class=\"c1\"></span>        <span class=\"n\">bIsClose</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span> <span class=\"o\">||</span> <span class=\"mi\">1</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span> <span class=\"o\">||</span> <span class=\"mi\">0</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span> <span class=\"o\">||</span> <span class=\"mi\">9</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"mi\">9</span> <span class=\"o\">==</span> <span class=\"n\">nOpcode</span><span class=\"p\">)</span><span class=\"c1\">//!ping\n</span><span class=\"c1\"></span>        <span class=\"p\">{</span>\n            <span class=\"n\">addSendPkg</span><span class=\"p\">(</span><span class=\"n\">buildPkg</span><span class=\"p\">(</span><span class=\"s\">&#34;&#34;</span><span class=\"p\">,</span> <span class=\"mh\">0xA</span><span class=\"p\">));</span><span class=\"c1\">// pong\n</span><span class=\"c1\"></span>        <span class=\"p\">}</span>\n\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nFIN</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">dataFragmentation</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">addRecvPkg</span><span class=\"p\">(</span><span class=\"n\">aPayload_data</span><span class=\"p\">);</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">else</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">dataFragmentation</span> <span class=\"o\">+=</span> <span class=\"n\">aPayload_data</span><span class=\"p\">;</span>\n                <span class=\"n\">addRecvPkg</span><span class=\"p\">(</span><span class=\"n\">dataFragmentation</span><span class=\"p\">);</span>\n                <span class=\"n\">dataFragmentation</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span>\n        <span class=\"p\">{</span>\n            <span class=\"n\">dataFragmentation</span> <span class=\"o\">+=</span> <span class=\"n\">aPayload_data</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n</code></pre></div><h2>Ping/pong/close</h2><p>收到ping就发pong，有可能ping的时候也带着数据，所以要处理下。但是貌似Chrome很长时间不会自动发ping。 服务器收到close消息可以回一个消息应答一下，也可以直接关闭连接。 集成到网络层 在自己的socket里加一个WSProtocol对象，在收到消息的地方一般是HandleRecv函数里加一段WSProtocol判断和处理的代码就可以了，示例如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">handleRecv</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"n\">len</span><span class=\"p\">))</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">waitToSend</span> <span class=\"o\">=</span> <span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">getSendPkg</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">waitToSend</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">sp_</span><span class=\"o\">-&gt;</span><span class=\"n\">sendRaw</span><span class=\"p\">(</span><span class=\"n\">waitToSend</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">clearSendPkg</span><span class=\"p\">();</span>\n\n    <span class=\"k\">const</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">string</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">recvPkg</span> <span class=\"o\">=</span> <span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">getRecvPkg</span><span class=\"p\">();</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">recvPkg</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">const</span> <span class=\"n\">string</span><span class=\"o\">&amp;</span> <span class=\"n\">eachRecvPkg</span> <span class=\"o\">=</span> <span class=\"n\">recvPkg</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">uint16_t</span> <span class=\"n\">nCmd</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"n\">m_message</span><span class=\"p\">.</span><span class=\"n\">getHead</span><span class=\"p\">().</span><span class=\"n\">cmd</span> <span class=\"o\">=</span> <span class=\"n\">nCmd</span><span class=\"p\">;</span>\n        <span class=\"n\">m_message</span><span class=\"p\">.</span><span class=\"n\">appendToBody</span><span class=\"p\">(</span><span class=\"n\">eachRecvPkg</span><span class=\"p\">.</span><span class=\"n\">c_str</span><span class=\"p\">(),</span> <span class=\"n\">eachRecvPkg</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n        <span class=\"n\">m_message</span><span class=\"p\">.</span><span class=\"n\">getHead</span><span class=\"p\">().</span><span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">eachRecvPkg</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"k\">this</span><span class=\"o\">-&gt;</span><span class=\"n\">post_msg</span><span class=\"p\">(</span><span class=\"n\">sp_</span><span class=\"p\">);</span>\n        <span class=\"n\">m_message</span><span class=\"p\">.</span><span class=\"n\">clear</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">clearRecvPkg</span><span class=\"p\">();</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">m_oWSProtocol</span><span class=\"p\">.</span><span class=\"n\">isClose</span><span class=\"p\">())</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">sp_</span><span class=\"o\">-&gt;</span><span class=\"n\">close</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>总结：</h2><ul><li>本文实现的websocket为纯协议解析，不依赖网络层，这样想用老的网络层支持websocket就非常容易啦。</li><li>本实现就一个头文件，依赖OpenSSL（sha1加密）</li><li>Github地址 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/h2engine/tree/master/fflib/net/wsprotocol.h\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/h2eng</span><span class=\"invisible\">ine/tree/master/fflib/net/wsprotocol.h</span><span class=\"ellipsis\"></span></a></li><li>同时提供一个c#的版本<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/h2engine/blob/master/workercs/fflib/wsprotocol.cs\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/h2eng</span><span class=\"invisible\">ine/blob/master/workercs/fflib/wsprotocol.cs</span><span class=\"ellipsis\"></span></a></li><li>归属于项目：h2engine 地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/h2engine\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/h2eng</span><span class=\"invisible\">ine</span><span class=\"ellipsis\"></span></a>，感兴趣的可以star。</li><li>这是我的github主页<a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy</span><span class=\"invisible\"></span></a>，有些有意思的分享。</li></ul>", 
            "topic": [
                {
                    "tag": "WebSocket", 
                    "tagLink": "https://api.zhihu.com/topics/19657811"
                }, 
                {
                    "tag": "Socket", 
                    "tagLink": "https://api.zhihu.com/topics/19604051"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }
            ], 
            "comments": [
                {
                    "userName": "ever", 
                    "userLink": "https://www.zhihu.com/people/e9708acd7a8c0768da1cd6027bf17414", 
                    "content": "那个标题图片是用什么画的呀？", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "龙卷风", 
                            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
                            "content": "[捂脸]不是我画的，网上找的", 
                            "likes": 0, 
                            "replyToAuthor": "ever"
                        }, 
                        {
                            "userName": "Code Hz", 
                            "userLink": "https://www.zhihu.com/people/47e576ec2146043540ced49919387f6d", 
                            "content": "<p>这不是RFC原图么。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "龙卷风"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57413071", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 0, 
            "title": "游戏服务器h2engine架构优化和跨平台设计", 
            "content": "<p>H2engine的GitHub星星不知不觉已经破百了，也没有特意推广过，但是慢慢的关注的人越来越多。因为事情多，好久没有写东西了，前一段时间有了一些想法，把h2engine又更新了一下，感觉h2engine又向前迈了一大步。本文记录一下最近的心得体会，以及做出的相应修改。</p><h2>关于RPC</h2><p>H2engine的rpc部分使用的是原来fflib的ffrpc组件，ffrpc设计的比较强大，但是因为h2engie的架构特点，ffrpc的一些功能用不到，很多网友都询问我关于rpc部分的设计问题，我仔细思考后觉得确实可以把h2engine的rpc部分进行简化，这样对于使用者而言更容易理解。</p><p>先看一下h2engine的架构：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ed9384c272c5cae5ae04a2db6fe334fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1167\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb\" width=\"1167\" data-original=\"https://pic4.zhimg.com/v2-ed9384c272c5cae5ae04a2db6fe334fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1167&#39; height=&#39;468&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1167\" data-rawheight=\"468\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1167\" data-original=\"https://pic4.zhimg.com/v2-ed9384c272c5cae5ae04a2db6fe334fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ed9384c272c5cae5ae04a2db6fe334fb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>H2engine设计的为单gate，单服环境内linux下一个gate完全能够满足性能要求，Apache/nigx都是一个进程不是吗？单gate让分布式的结构大大简化。我们知道一般单服架构都有个loginserver，现在可以省略了，因为单gate，每个服直接配置gate地址。</li><li>H2engine为多进程架构，但是h2engine限定了采用伪分布式的设计，虽然gate和gameserver通过网络通信，但是限定了gate和gameserver在一台机器上。虽然gate和gameserver放在不同机器上也可以通信，但是我们从现实运营的情况出发，很少运维会把gate和gameserver放不同机器上，一般有的时候一台机器上甚至有多个服。所以伪分布式是既能满足需求又能大大简化架构的一个设计。</li><li>采用伪分布式设计后，gameserver之间就可以利用共享内存了，全局的数据比如排行榜、行会、好友、组队等，这些模块都是分布式进程中最费时费力容易出错的，但是在h2engine里变得逻辑清晰，直接操作全局内存就可以了，全同步。</li><li>Rpc模块进行了简化，其实rpc通信分三种，gate调用gameserver接口，gameserver调用gate接口，和gameserver与gameserver之间调用，发现没，所有架构内rpc都需要通过gate，而且h2engine是单gate伪分布式（127.0.0.1速度飞起），那么整个rpc结构就变得非常清晰简单，感兴趣的可以看下gate的broker文件和rpc文件。这两个文件一个是gate端中转，一个是请求端封装，非常简洁。</li><li>网络层进行了升级，原来socket是裸的指针，很多网友还是表达了不知道什么时候应该调用safedelete的问题，所以还是改成了智能指针，不需要关系socket什么时候释放。另外socket的私有数据进行了泛型封装，可以存入任何私有数据类型。</li><li>共享内存示例</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f8d6f3bea899035a9d35f98afd696535_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1099\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb\" width=\"1099\" data-original=\"https://pic2.zhimg.com/v2-f8d6f3bea899035a9d35f98afd696535_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1099&#39; height=&#39;507&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1099\" data-rawheight=\"507\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1099\" data-original=\"https://pic2.zhimg.com/v2-f8d6f3bea899035a9d35f98afd696535_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f8d6f3bea899035a9d35f98afd696535_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>关于跨平台</h2><p>H2engine一直是只支持linux下编译，Windows的移植一直没有时间弄，虽然行业内大部分服务器都是跑linux的，但是如果可以Windows下可以开发调试，那对于提高平常的开发效率来说将会大有裨益。</p><p>H2engine由于一开始是在linux下gcc下开发的，那么在Windows下也用gcc，那么需要修改的跨平台代码将会非常少，本着这个思路，h2engine成功移植到了Windows，并且改动的非常少。</p><ul><li>Windows下的虽然有mingw直接包含了gcc环境，但是想用上cmake等编译工具还是挺麻烦的，所以我找了一个集成mingw且算得上比较流行的一个Windows IDE：CodeBlocks。见了一个CodeBlocks的项目，想要在Windows下运行只要下载一个CodeBlocks，然后双击工程文件就可以了。</li><li>编译h2engine需要依赖openssl、curl、mysql、lua、python2.7，依赖文件都放到windependency文件夹里，包括运行的dll。</li><li>H2workerlua在Windows下用的lua5.1</li><li>H2workerpython在Windows下用的python2.7</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>关于C#</h2><p>H2engine的c#版本正在紧锣密鼓的开发中，大家拭目以待。</p><h2>相关连接</h2><ol><li>文档 <a href=\"https://link.zhihu.com/?target=http%3A//h2cloud.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://h2cloud.org</a></li><li>源码 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/fanchy/h2engine\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/fanchy/h2eng</span><span class=\"invisible\">ine</span><span class=\"ellipsis\"></span></a></li></ol><p></p>", 
            "topic": [
                {
                    "tag": "游戏服务器", 
                    "tagLink": "https://api.zhihu.com/topics/19591286"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45244042", 
            "userName": "龙卷风", 
            "userLink": "https://www.zhihu.com/people/f7a2a552e01d97a56b5edde78307d9a0", 
            "upvote": 0, 
            "title": "logistic逻辑回归公式推导及R语言实现", 
            "content": "<h2>Logistic逻辑回归</h2><h2>Logistic逻辑回归模型</h2><p>线性回归模型简单，对于一些线性可分的场景还是简单易用的。Logistic逻辑回归也可以看成线性回归的变种，虽然名字带回归二字但实际上他主要用来二分类，区别于线性回归直接拟合目标值，Logistic逻辑回归拟合的是正类和负类的对数几率。</p><p>假设有一个二分类问题，输出为y∈{0,1}</p><p>定义sigmoid函数: </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-67b5972f6a59d156f49ebbd574264c6e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"375\" data-rawheight=\"90\" class=\"content_image\" width=\"375\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;375&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"375\" data-rawheight=\"90\" class=\"content_image lazy\" width=\"375\" data-actualsrc=\"https://pic3.zhimg.com/v2-67b5972f6a59d156f49ebbd574264c6e_b.jpg\"/></figure><p> 用sigmoid函数的输出是0，1之间，用来拟合y=1的概率，其函数R语言画图如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">x = seq(-5, 5, 0.1)\ny = 1 / (1 + exp(-1*x))\nplot(x, y, type=&#34;line&#34;)</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51267b4e7c335171b162c8a06dc4d0d1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-51267b4e7c335171b162c8a06dc4d0d1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-51267b4e7c335171b162c8a06dc4d0d1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-51267b4e7c335171b162c8a06dc4d0d1_b.jpg\"/></figure><p> logistic逻辑回归可以拟合因变量为1的概率,最终分类的时候，我们可以一个阈值，比如0.5，大于阈值的都分为正类，向量化公式如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e3e2f92a0f2685b267a7f120c1d26c70_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"520\" data-original=\"https://pic1.zhimg.com/v2-e3e2f92a0f2685b267a7f120c1d26c70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;520&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"520\" data-original=\"https://pic1.zhimg.com/v2-e3e2f92a0f2685b267a7f120c1d26c70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e3e2f92a0f2685b267a7f120c1d26c70_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>还可以换一种方式理解logistic逻辑回归，他是用多元线性函数去拟合因变量为正例与反例的比值的自然对数，推导如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8b5fd9800a443679f24d49d85b32c207_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"627\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb\" width=\"627\" data-original=\"https://pic4.zhimg.com/v2-8b5fd9800a443679f24d49d85b32c207_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;627&#39; height=&#39;78&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"627\" data-rawheight=\"78\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"627\" data-original=\"https://pic4.zhimg.com/v2-8b5fd9800a443679f24d49d85b32c207_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8b5fd9800a443679f24d49d85b32c207_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5d3334f99bd96d330388ef6279f106ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb\" width=\"445\" data-original=\"https://pic3.zhimg.com/v2-5d3334f99bd96d330388ef6279f106ee_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;445&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"445\" data-rawheight=\"89\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"445\" data-original=\"https://pic3.zhimg.com/v2-5d3334f99bd96d330388ef6279f106ee_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5d3334f99bd96d330388ef6279f106ee_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>Logistic逻辑回归算法</h2><ul><li>假设自变量维度为N</li><li>W为自变量的系数，下标0 - N</li><li>X为自变量向量或矩阵，X维度为N,为了能和W0对应，X需要在第一行插入一个全是1的列。</li><li>Y为因变量</li><li>W为未知数待求解</li></ul><h2>最大似然估计法</h2> <h2>梯度下降法迭代公式</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0c8be088e5783de6ec7828e074fd32a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"423\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb\" width=\"423\" data-original=\"https://pic2.zhimg.com/v2-0c8be088e5783de6ec7828e074fd32a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;423&#39; height=&#39;45&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"423\" data-rawheight=\"45\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"423\" data-original=\"https://pic2.zhimg.com/v2-0c8be088e5783de6ec7828e074fd32a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0c8be088e5783de6ec7828e074fd32a5_b.jpg\"/></figure><h2>R语言实现</h2><p>使用iris数据集</p><div class=\"highlight\"><pre><code class=\"language-text\">&gt; head(iris)\n  Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n1          5.1         3.5          1.4         0.2  setosa\n2          4.9         3.0          1.4         0.2  setosa\n3          4.7         3.2          1.3         0.2  setosa\n4          4.6         3.1          1.5         0.2  setosa\n5          5.0         3.6          1.4         0.2  setosa\n6          5.4         3.9          1.7         0.4  setosa</code></pre></div><p>将数据分为训练数据和测试数据</p><p>R语言使用批量梯度下降法迭代求解</p><div class=\"highlight\"><pre><code class=\"language-text\">iris2 = rbind(subset(iris, Species==&#39;setosa&#39;), subset(iris, Species==&#39;versicolor&#39;))\nX &lt;- cbind(rep(1, nrow(iris2)), iris2$Sepal.Length, iris2$Sepal.Width, iris2$Petal.Length, iris2$Petal.Width)\nY &lt;- as.numeric(iris2$Species) - 1\nmaxIterNum &lt;- 2000;\nstep &lt;- 0.05;\nW &lt;- rep(0, ncol(X))\nm = nrow(X)\nsigmoid &lt;- function(z) { 1 / (1 + exp(-z))}\nfor (i in 1:maxIterNum){\n    grad &lt;- t(X) %*% (sigmoid(X %*% W)-Y);\n    if (sqrt(as.numeric(t(grad) %*% grad)) &lt; 1e-8){\n        print(sprintf(&#39;iter times=%d&#39;, i));\n        break;\n    }\n    W &lt;- W - grad * step;\n}\nprint(W);\nhfunc &lt;- function(a) {if (a &gt; 0.5) return(1) else return (0);}\nmyY = apply(sigmoid(X %*% W), 1, hfunc)\nprint(cbind(Y, myY))</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>- 应该增加一部分训练数据，验证模型的正确性</p><p>- 应该增加正则项避免过拟合，比如L2正则</p><p class=\"ztext-empty-paragraph\"><br/></p><p>更多精彩文章 <a href=\"https://link.zhihu.com/?target=http%3A//h2cloud.org/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">h2cloud.org/</span><span class=\"invisible\"></span></a></p>", 
            "topic": [
                {
                    "tag": "R（编程语言）", 
                    "tagLink": "https://api.zhihu.com/topics/19674181"
                }, 
                {
                    "tag": "逻辑回归", 
                    "tagLink": "https://api.zhihu.com/topics/20178024"
                }, 
                {
                    "tag": "机器学习", 
                    "tagLink": "https://api.zhihu.com/topics/19559450"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1019975988704337920"
}
