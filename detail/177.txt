{
    "title": "数据结构和算法", 
    "description": "从头开始学习数据结构和算法，打好基础，需要内功心法，将来再学习任何招式的时候才能得心应手。     qq讨论学习群：772963742", 
    "followers": [
        "https://www.zhihu.com/people/wang-jian-27-8-66", 
        "https://www.zhihu.com/people/jeavenwong", 
        "https://www.zhihu.com/people/lmq-32-76-34", 
        "https://www.zhihu.com/people/jie-jiao-de-guang-ming", 
        "https://www.zhihu.com/people/garbagey", 
        "https://www.zhihu.com/people/tan-xiao-yang-95", 
        "https://www.zhihu.com/people/lalayc", 
        "https://www.zhihu.com/people/he-zheng-e", 
        "https://www.zhihu.com/people/kkkkkkkkk-94", 
        "https://www.zhihu.com/people/zhou-yi-62-17-19", 
        "https://www.zhihu.com/people/xue-wu-zhi-jing-71-93", 
        "https://www.zhihu.com/people/bookbug", 
        "https://www.zhihu.com/people/wang-fei-85-15-47", 
        "https://www.zhihu.com/people/chen-jia-90-42", 
        "https://www.zhihu.com/people/li-ao-59-58", 
        "https://www.zhihu.com/people/stnight", 
        "https://www.zhihu.com/people/fu-qiang-4-81-34", 
        "https://www.zhihu.com/people/lowxiong", 
        "https://www.zhihu.com/people/sha-tian-cai-72", 
        "https://www.zhihu.com/people/zhu-zhu-xia-87-27", 
        "https://www.zhihu.com/people/tang-da-mi-5", 
        "https://www.zhihu.com/people/geng-geng-18-38", 
        "https://www.zhihu.com/people/wei-de-98-76", 
        "https://www.zhihu.com/people/abner-xiao", 
        "https://www.zhihu.com/people/yut2kem", 
        "https://www.zhihu.com/people/qwerty94", 
        "https://www.zhihu.com/people/liu-ye-ye-ye-ye-ye-ye-ye", 
        "https://www.zhihu.com/people/wang-zhi-58-59", 
        "https://www.zhihu.com/people/mu-lu-index", 
        "https://www.zhihu.com/people/fang-dou-dou-fang-73", 
        "https://www.zhihu.com/people/liu-yi-70-9", 
        "https://www.zhihu.com/people/li-yong-49", 
        "https://www.zhihu.com/people/plusaber", 
        "https://www.zhihu.com/people/he-ye-35", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/li-yun-98-80", 
        "https://www.zhihu.com/people/chen-xiao-4-56-81", 
        "https://www.zhihu.com/people/a-nan-35-55", 
        "https://www.zhihu.com/people/miao-hao-yuan-74", 
        "https://www.zhihu.com/people/leonwgc", 
        "https://www.zhihu.com/people/manutd7-44", 
        "https://www.zhihu.com/people/zai-jiang-lai", 
        "https://www.zhihu.com/people/peng-peng-9-27", 
        "https://www.zhihu.com/people/wang-yi-26-71", 
        "https://www.zhihu.com/people/zi-dai-bgmde-nan-zi", 
        "https://www.zhihu.com/people/long-ye-70-57", 
        "https://www.zhihu.com/people/raymond-65-61", 
        "https://www.zhihu.com/people/tang-guo-ting-ting", 
        "https://www.zhihu.com/people/olin-64", 
        "https://www.zhihu.com/people/agoclover", 
        "https://www.zhihu.com/people/midas-64", 
        "https://www.zhihu.com/people/wang-xiang-zhong-5", 
        "https://www.zhihu.com/people/wang-song-77-47", 
        "https://www.zhihu.com/people/gu-feng-yue-ying-92", 
        "https://www.zhihu.com/people/ming-jie-shen-du", 
        "https://www.zhihu.com/people/ga-liao-de-hua-lao", 
        "https://www.zhihu.com/people/wang-meng-15-13", 
        "https://www.zhihu.com/people/li-zheng-cao-94", 
        "https://www.zhihu.com/people/wadejo", 
        "https://www.zhihu.com/people/er-shi-wu-hua-sheng-90", 
        "https://www.zhihu.com/people/jia-xu-yisi-liu", 
        "https://www.zhihu.com/people/peng-zi-93", 
        "https://www.zhihu.com/people/sheng-si-li-jie-62", 
        "https://www.zhihu.com/people/feng-hua-19-31", 
        "https://www.zhihu.com/people/heihu-32", 
        "https://www.zhihu.com/people/lao-chong-43-18", 
        "https://www.zhihu.com/people/feng-yu-piao-yao-40-69", 
        "https://www.zhihu.com/people/yu-yu-46-12-7", 
        "https://www.zhihu.com/people/xuan-ya-shang-shi-tian-kong", 
        "https://www.zhihu.com/people/jzszuishuai", 
        "https://www.zhihu.com/people/jieyouzahuodian", 
        "https://www.zhihu.com/people/nan-shan-xin-xin-zi", 
        "https://www.zhihu.com/people/yi-qi-jue-chen-11", 
        "https://www.zhihu.com/people/hu-bing-36-72"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/76330244", 
            "userName": "zqtao23", 
            "userLink": "https://www.zhihu.com/people/22ff57a58297dae3f47794333ef45a19", 
            "upvote": 0, 
            "title": "05-算法初级--哈希函数及应用-设计RandomPool-布隆过滤器-一致性哈希-并查集-岛问题", 
            "content": "<p><b>年轻即出发</b>...</p><p><b>简书</b>：<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/7110a2ba6f9e\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/u/7110a2ba6</span><span class=\"invisible\">f9e</span><span class=\"ellipsis\"></span></a></p><p><b>知乎</b>：<a href=\"https://www.zhihu.com/people/zqtao23/posts\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/people/zqtao2</span><span class=\"invisible\">3/posts</span><span class=\"ellipsis\"></span></a></p><p><b>GitHub源码</b>：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/zqtao2332\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/zqtao2332</span><span class=\"invisible\"></span></a></p><p><b>个人网站</b>：<a href=\"https://link.zhihu.com/?target=http%3A//www.zqtaotao.cn/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">zqtaotao.cn/</span><span class=\"invisible\"></span></a>  （停止维护更新内容，转移简书）</p><p><b>QQ交流群</b>：606939954</p><p>    咆哮怪兽一枚...嗷嗷嗷...趁你现在还有时间，尽你自己最大的努力。努力做成你最想做的那件事，成为你最想成为的那种人，过着你最想过的那种生活。也许我们始终都只是一个小人物，但这并不妨碍我们选择用什么样的方式活下去，这个世界永远比你想的要更精彩。</p><p>最后：喜欢编程，对生活充满激情</p><hr/><hr/><p><b>本节内容预告</b></p><p>实例1：理解哈希函数和哈希表</p><p>实例2：设计RandomPool结构</p><p>实例3：认识布隆过滤器（处理大数据）</p><p>实例4：认识一致性哈希。</p><p>实例5：并查集</p><p>实例6：岛问题</p><hr/><hr/><p><b>实例1</b></p><p>理解哈希函数和哈希表</p><p>使用一个哈希函数随机得到1000个哈希函数，同时需要相对独立</p><p>做法：通过一个哈希函数，得到一个16字节哈希码，把结果分为两份h1,h2</p><p>前八个字作为h1,后8个字节作为h2.</p><p>h1 + i * h2 = hn</p><p>如</p><p>h1 + 1 * h2  = h3</p><p>h1 + 2 * h2 = h3</p><p>....</p><p>这里就是将一个完全独立的哈希函数切割得到的两个哈希码作为种子。</p><p>因为哈希函数得到的哈希码的16位，每一   位都是相对独立的。</p><p>哈希函数特点：相同输入，导致相同输出，不同输入，导致输出均匀分布。</p><p>哈希表：就是哈希函数的桶，如果桶的效率开始变差，就把整体扩容。其中默认哈希表的增删改查都是O(1)</p><p><b>实例2</b></p><p>设计RandomPool结构 </p><p>【题目】 设计一种结构，在该结构中有如下三个功能： </p><p>insert(key)：将某个key加入到该结构，做到不重复加入。 </p><p>delete(key)：将原本在结构中的某个key移除。</p><p>getRandom()： 等概率随机返回结构中的任何一个key。 </p><p>【要求】 Insert、delete和getRandom方法的时间复杂度都是 O(1)</p><p>思路：准备两个HashMap</p><p>map1</p><p>key：要存储的值</p><p>value：入结构的顺序</p><p>map2</p><p>key：入结构的顺序</p><p>value：要存储的值</p><p>size：记录入RandomPool的数量</p><p>insert(key)：每次新增的同时size++</p><p>getRandom：通过系统的random方法冲size个数中选择一个，通过map2返回。</p><p>delete(key)：例如删除c,则找到2号位，删除，同时将2号位替换为map2中的最后一个999所对应的元素，同时更新map1。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-440221cbe498817ff93af8d599164882_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"627\" class=\"origin_image zh-lightbox-thumb\" width=\"764\" data-original=\"https://pic3.zhimg.com/v2-440221cbe498817ff93af8d599164882_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;764&#39; height=&#39;627&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"764\" data-rawheight=\"627\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"764\" data-original=\"https://pic3.zhimg.com/v2-440221cbe498817ff93af8d599164882_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-440221cbe498817ff93af8d599164882_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.HashMap;\n\n/**\n * @description:\n *\n * @version: 1.0\n */\npublic class Code_32_RandomPool {\n    public static class RandomPool&lt;K&gt;{\n        private HashMap&lt;K, Integer&gt; key_index;\n        private HashMap&lt;Integer, K&gt; index_key;\n        private int size;\n\n        public RandomPool(){\n            this.key_index = new HashMap&lt;&gt;();\n            this.index_key = new HashMap&lt;&gt;();\n            size = 0;\n        }\n\n        public void insert(K key){\n            if (!this.key_index.containsKey(key))\n            this.key_index.put(key, this.size);\n            this.index_key.put(this.size++, key);\n        }\n\n        public K getRandom(){\n            if (this.size == 0){\n                return null;\n            }\n            int key = (int) (Math.random() * this.size);\n            return this.index_key.get(key);\n        }\n\n        public void delete(K key) {\n            if (this.key_index.containsKey(key)){\n                int deleteIndex = this.key_index.get(key);\n                int lastIndex = --this.size;\n                K lastKey = this.index_key.get(lastIndex);\n                this.key_index.put(lastKey, deleteIndex);\n                this.index_key.put(deleteIndex, lastKey);\n                this.key_index.remove(key);\n                this.index_key.remove(lastIndex);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        RandomPool&lt;String&gt; pool = new RandomPool&lt;&gt;();\n        pool.insert(&#34;test&#34;);\n        pool.insert(&#34;fuck&#34;);\n        pool.insert(&#34;code&#34;);\n        System.out.println(pool.getRandom());\n        System.out.println(pool.getRandom());\n        System.out.println(pool.getRandom());\n        System.out.println(pool.getRandom());\n        System.out.println(pool.getRandom());\n        System.out.println(pool.getRandom());\n\n    }\n}</code></pre></div><p><b>实例3</b></p><p>认识布隆过滤器（处理大数据）</p><p><b>先看一个经典的问题</b></p><p>100亿的URL黑名单，当你搜索这些黑名单的时候，不想给你显示这个URL的内容。 假设每一个黑名单（URL）都是64字节，当用户搜索某一个URL在黑名单的时候，对它进行过滤。</p><p>简单说了就是给你一个URL，在黑名单，返回true，不在返回false。</p><p><b>分析存储</b></p><p>如果使用一个哈希表存储，需要多大的空间？ 这里哈希表只需要存key,可以使用 HashSet</p><p>不算索引空间等其他空间占用，就单单100亿URL，最少需要64 * 100亿 个字节才能把所有的数据存储下， 差不多需要640G内存，这个设计需要花费巨大的代价。</p><p><b>换一种存储结构？</b></p><p>这里考虑能不能使用另一种结构来存储数据，它能够将使用空间极度的减小， 让我们用一台机器就足以支撑？</p><p>再次之前先了解一下布隆过滤器的概念。</p><p><b>布隆过滤器</b></p><p>布隆过滤器就是某种类型的集合，概率型数据结构，但是它是有<b>失误率</b>的。 布隆过滤器失误率：如URL<b>不在里面，但是返回在里面</b>，这种失误不是另一种情况：URL在，返回false；</p><p>布隆过滤器可以理解为：比特类型的Map。</p><p><b>面试过程</b></p><p>先了解一下面试过程：</p><p>面试官：。。。上诉题。。100亿的黑名单URL。。。 应聘者：首先想到的是哈希的分流，分给不同的机器，每一台机器处理一部分，让整个集群来支撑处理这100亿的数据； 面试官：这样做是不是太浪费空间了，你能不能在想想办法？ 应聘者：（这时候你可以问一下面试官）你们这个系统允许有很低的失误率吗？ 面试官：（这时候一般都会微笑一下，小伙子很上道）可以！ 应聘者：可以使用布隆过滤器。</p><p>这里根据面试过程对话，我们了解到，面试时，先和面试官讨论的是一般情况的处理方式：<b>利用哈希函数分流</b></p><p>但是这样做代价很高！所以很自然的引到了<b>布隆过滤器</b>。</p><p><b>举例子</b>：怎么做出长度为0~m-1的比特类型的数组？？？</p><p>假设一个数组（0，m-1），每一个位置上不是整数、字符串，这个数组的每一个位置上， 它是<b>比特</b>，即每一个位置上只有两种状态<b>0和1</b>。</p><ul><li>int[]  int 类型4个字节，32个比特</li><li>一个整数可以表示32个比特</li><li>如果声明一个长度1000的数组，它其实可以表示1000 * 32 个比特位</li></ul><p><b>下面是一个长度为1000的数组，30000需要进入那个比特位？</b>的存储过程。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-86dcfcbd9642e11dc66207960b9da0a4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-86dcfcbd9642e11dc66207960b9da0a4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-86dcfcbd9642e11dc66207960b9da0a4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-86dcfcbd9642e11dc66207960b9da0a4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">int[]  int 类型4个字节，32个比特\n一个整数可以表示32个比特\n如果声明一个长度1000的数组，它其实可以表示1000 * 32 个比特位\n\n\nint[] arr = new int[1000]; // 可以表示32000个比特位，每一个arr[i] 表示一个大桶,一个大桶表示有32个比特位\n\nint index = 30000; // 想要把30000位描黑\n\nint intIndex = index / 32; // 计算30000在哪个大桶;intIndex = \n\nint bitIndex = index % 32; // 计算30000具体在某个大桶里面哪一个比特位\n\nSystem.out.println(intIndex); // 937\nSystem.out.println(bitIndex); //16\n这里总结就是：30000比特位在937号桶的16号比特位，这个位置需要被描黑\n 1 &lt;&lt; 16  0000 0000 0000 0001 0000 0000 0000 0000 // 表示将第16号位置置为1，其他为0\narr[intIndex] = (arr[intIndex] | (1 &lt;&lt; bitIndex));</code></pre></div><p><b>做一个比特数组</b></p><div class=\"highlight\"><pre><code class=\"language-text\">做比特类型的数组\n（拿基础类型拼，这里用int，32位，当然如果你想要省空间可以使用long类型，64位）\n如果还嫌空间大，可以使用矩阵\n\n\nlong[][] map = new long[1000][1000]\nmap 可以表示的比特位64 * 1000 * 1000</code></pre></div><p>前面了解了如何去做一个比特数组。问题来了，有了比特数组，<b>黑名单问题该怎么设计呢？</b></p><p><b>插入100亿URL过程：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">准备一个 (0 , m-1) 的比特数组\n进入一个URL，处理过程\nURL \n--&gt; 哈希函数 \n--&gt; code  \n--&gt; code % m \n--&gt;  得到 (0, m-1) 中的一个比特位置 \n--&gt; 描黑\n\n准备k 个哈希函数  \n---&gt;  重复URL算比特位置   \n---&gt; 描黑（有可能两个哈希函数会达到同一个位置，都描黑）  \n--&gt; 到这里，这个URL算是进入到了比特数组了</code></pre></div><p>图解URL插入过程</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ed5a52a51d409cfdd9ba8cfed1a91245_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-ed5a52a51d409cfdd9ba8cfed1a91245_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-ed5a52a51d409cfdd9ba8cfed1a91245_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ed5a52a51d409cfdd9ba8cfed1a91245_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>查URL是否是黑名单过程：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">URL \n--&gt;  依然经过 k 个哈希函数  \n--&gt;  哈希出k 个位置  \n--&gt;  如果k 个位置都是描黑过的，则URL在黑名单里。\n\n注意：这个比特数组要大一些，不然100亿个URL进入到比特数组，数组都满了，还查个屁，都黑了，不是说明任意一个URL进来都是黑名单了吗？</code></pre></div><p><b>问题：比特数组开多大跟哪些因素有关？</b></p><p>两个因素：样本量和预期失误率</p><p><b>1、样本量有关</b>     和具体的单个样本字节无关，有关的是样本种类。这里本题指的就是URL的种类 <b>2、预期的失误率有关</b>      如果100亿数据，样本的失误率只要求做到1/100，那么数组的长度就无需太长。      哈希函数比特类型的数组长度  m = - ((N*lnp) / ((ln2)^2))</p><ul><li>N：样本量</li><li> p：失误率<br/> 实际用计算器计算一下：N=100亿，p=0.0001, m=(131,571,428,572)（比特）  实际需要的内存空间:   m / 8（字节）=22.3G<br/> </li></ul><p>所以原来需要640G内存的空间，现在只需要22.3G</p><p><b>布隆过滤器的大小m公式</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7355b757121fd3fa3d0902b240e8aba7_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"190\" data-rawheight=\"107\" class=\"content_image\" width=\"190\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;190&#39; height=&#39;107&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"190\" data-rawheight=\"107\" class=\"content_image lazy\" width=\"190\" data-actualsrc=\"https://pic4.zhimg.com/v2-7355b757121fd3fa3d0902b240e8aba7_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>哈希函数的个数k公式</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9d8948579475e7c6c882bdac0847b122_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"100\" class=\"content_image\" width=\"279\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;279&#39; height=&#39;100&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"100\" class=\"content_image lazy\" width=\"279\" data-actualsrc=\"https://pic3.zhimg.com/v2-9d8948579475e7c6c882bdac0847b122_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>布隆过滤器真实失误率p公式</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-53dfb95d13507cedb170fd1455984824_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"160\" data-rawheight=\"94\" class=\"content_image\" width=\"160\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;160&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"160\" data-rawheight=\"94\" class=\"content_image lazy\" width=\"160\" data-actualsrc=\"https://pic1.zhimg.com/v2-53dfb95d13507cedb170fd1455984824_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>这里可以根据实际情况来进行优化，较低失误率！！！</b></p><p>为什么用 k 个哈希函数？     实际过程中需要k 函数个数：     k = ln2<i>(m/n) = 0.7</i>(m/n) = 12.7       k 向上取整 <b>约13</b>     当k 向上取整时，布隆过滤器的真实失误率p会和预期值不一样     一个结论：如果想要做到万分之一的失误率</p><ul><li>m 内存22.3 ---&gt; 24G </li><li>k   12.7 ---&gt; 13</li><li>算的真实p:约 6/10万  十万分之六</li></ul><p><b>优化总结</b>：基本求值做完后，在面试官允许的范围内可以适当的增大 m（比如这题，他给你32G内存，你算完了，只需要22.3G，可以提升到24） ,带入k 计算公式，计算出k 后向上取整（比如这道题原来计算 m = 24k= 12,7，向上取整后13），带入第三个公式求真实的p计算出来的值会变小（比如这道题，m=24，k=13,p=约十万分之六，远小于原来的万分之一）</p><p><b>实例4</b></p><p>认识一致性哈希。</p><p>一致性哈希在集群上使用的特别多，经典哈希服务器相对存在的问题，一致性哈希可以较为有效的解决。</p><p>先说一下经典服务器存在的问题在哪里</p><p>新增新机器，删除新机器代价非常大。</p><p><b>举例：经典服务器的抗压结构</b></p><p>服务操作：查&#34;test&#34; 的 value 是什么？</p><p>前端集群：无差别接收request 后端集群组：3机器编号： 0 1 2</p><p><b>插入数据和查询数据</b>都是一样的。因为哈希函数的性质：同入同出，异入均匀分布。</p><p>前端各自带相同的一个哈希函数  ---&gt;  code    ---&gt; code % 3   ---&gt; 得到哪一台机器</p><p><b>经典负载均衡如图</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e3df98fffd4d0b38b66c64a87736835f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-e3df98fffd4d0b38b66c64a87736835f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-e3df98fffd4d0b38b66c64a87736835f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e3df98fffd4d0b38b66c64a87736835f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>问题来了！！！</p><p>想要<b>增加机器</b>或者是<b>去除机器</b>的时候就完蛋了！！！ 原来有3台机器，哈希码%3 ，现在因为需求增加，需要5台机器，哈希码%5 原来(&#34;zqt&#34;,88) 这个消息 %3 比如在机器2上，现在必须重新 %5来确定数据需要往哪台机器上迁移。这个代价是非常大的。</p><p>这就引出了<b>一致性哈希结构</b>，它能够把<b>数据迁移的代价降到很低</b>，同时实现<b>负载均衡</b>。</p><p><b>一致性哈希结构实现负载均衡的实现</b></p><p>假设hash 函数h1,  h1 哈希出来的哈希码 的范围是0 ~ 2^64 ，把这个范围想象成均匀分布的环。</p><p>将3台机器的IP利用哈希函数 h1 计算出来的哈希码对应到环。code0 code1 code2</p><p><b>消息处理</b></p><p>一个request消息 ---&gt;  前端集群（使用同一个哈希函数 h1） ---&gt;  哈希码code（不需要像经典抗压集群一样 模3） ---&gt;  查看在哈希范围环中code 距离3台机器的哈希值（code0、code1、code2）哪一台最近（顺时针），如code2 ---&gt;  将消息发送到code2对应机器2</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-983e9f9ece74d944602f61d27abc450a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1082\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb\" width=\"1082\" data-original=\"https://pic3.zhimg.com/v2-983e9f9ece74d944602f61d27abc450a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1082&#39; height=&#39;565&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1082\" data-rawheight=\"565\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1082\" data-original=\"https://pic3.zhimg.com/v2-983e9f9ece74d944602f61d27abc450a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-983e9f9ece74d944602f61d27abc450a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注意：如图 code1~code2 范围，如图红色区域，消息发送到---&gt; 2号机器 code2~code0 范围，如图黄色区域，消息发送到---&gt; 0号机器 code0~code1 范围，如图绿色区域，消息发送到---&gt; 1号机器</p><p><b>具体实现查找哪一台机器过程？</b></p><p>1、首先IP（也可以是其他的标识机器的属性）进行哈希，将哈希值排序存进数组如：[c2,c0,c1]， 将数组发送到每一台前端集群上的机器。 2、前端集群接收到消息，也进行哈希得到code 3、采用二分法等算法查找数组。这里二分法找到第一个&gt;=code 的哈希位置，如c0</p><p>例如 5台机器哈希排序数组[m0, m1, m2, m3, m4]，这里为了直观看出效果，哈希值使用整数 [22, 65, 132,387,643]</p><p>消息(&#34;zqt&#34;) 计算的哈希码  code = 99</p><p><b>二分法</b>找到第一个大于等于39 的哈希码  65  它对应的机器就是访问机器</p><p><b>新增机器</b></p><p>新增一个机器 3 如图：只需要把code3~code2之间的数据从0机器迁移给3机器就行了，不需要动其他机器的数据 所以一致性哈希集群新增和删除机器代价都是非常小的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3574c848e9649f9d625c90e036b6f12b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-3574c848e9649f9d625c90e036b6f12b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-3574c848e9649f9d625c90e036b6f12b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3574c848e9649f9d625c90e036b6f12b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一致性哈希存在的问题</b>：在机器数量比较少的时候，不能保证机器映射到环是均匀分布的！ 这个问题跟哈希函数的性质有关。哈希函数保证的均分是在<b>样本量多</b>的情况下。</p><p><b>解决方式</b>：虚拟节点技术</p><p>3台机器 m-0:给m-0分配1000个虚拟节点 m-1:  ... m-2:  ...</p><p>增加一张路由表映射 虚拟节点和真实机器 利用这3000 个虚拟节点来消费消息，可以说3个机器消费数据是差不多的。</p><p><b>再看增加新机器3</b> 也是增加了1000个虚拟节点，均匀分布在哈希环上。有人说新增虚拟节点覆盖在老机器的虚拟节点怎么办？ 答案是：给新机器（其实这个概率<b>非常低</b>，哈希取值范围非常大，4000个节点相遇概率实在太低了，所以你就算让新机器和老机器共用也是在容错率范围内的允许的）。 同理，删除一台机器是一样的。</p><p><b>用虚拟节点的数量，以比例来化解一致性哈希集群无法负载均衡的问题。</b></p><p><b>实例5</b></p><p>并查集：并查集类似一棵多枝树，有一个集合代表节点的pre指向自己，其他节点的pre指向上一个节点。</p><p><b>并查集结构</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-36f4aba221f7db825247059e02b94750_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-36f4aba221f7db825247059e02b94750_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;340&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"340\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-36f4aba221f7db825247059e02b94750_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-36f4aba221f7db825247059e02b94750_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>并查集，并查集两个重要作用     1、两个元素是否属于同一个集合。     2、两个元素各自所在的集合，合并他们。</p><p><b>并查集注意事项</b></p><p>并查集在初始化的时候必须先把<b>所有的数据样本</b>给它，不能动态的加载。</p><p><b>查</b> isSameSet(A,B) 查A，B是否属于同一个集合，只需要向上查，查到代表节点止，比较A，B指向的代表节点是否为同一个。 例如：isSameSet(3,4)，如图 3 向上查 3 --&gt;2 --&gt;1  4 向上查 4 --&gt;1 代表节点相同，A，B属于同一个并查 集。</p><p><b>合并</b></p><p>union(A,B)</p><p>合并两个元素所在的集合，合并时查看两个集合长度，短的挂载到长的身上。如图set1 size=4；set2 size=3； set2 挂载到set1的代表节点上</p><p><b>合并过程如图</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4d749864b8a6d626b53b24b18cbf4429_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"924\" data-rawheight=\"449\" class=\"origin_image zh-lightbox-thumb\" width=\"924\" data-original=\"https://pic2.zhimg.com/v2-4d749864b8a6d626b53b24b18cbf4429_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;924&#39; height=&#39;449&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"924\" data-rawheight=\"449\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"924\" data-original=\"https://pic2.zhimg.com/v2-4d749864b8a6d626b53b24b18cbf4429_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4d749864b8a6d626b53b24b18cbf4429_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>优化</b>（并查集唯一可以优化的地方）：扁平化 每一次涉及到查，都将长链打散成短链，挂载到代表节点上：如查7</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f6173101ec3bc8f924e2025b129c4ccb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"531\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-f6173101ec3bc8f924e2025b129c4ccb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;531&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"531\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-f6173101ec3bc8f924e2025b129c4ccb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f6173101ec3bc8f924e2025b129c4ccb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>查询和合并次数，平均时间复杂度O(1)。</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.HashMap;\nimport java.util.List;\n\n/**\n * @description: 并查集\n * @version: 1.0\n */\npublic class Code_34_UnionFind {\n\n    public static class Node {\n        // whatever you like\n    }\n\n    // 并查集结构\n    public static class UnionFindSet {\n        public HashMap&lt;Node, Node&gt; fatherMap; // 存储节点的父节点\n        public HashMap&lt;Node, Integer&gt; sizeMap; // 存储节点所在的集合的节点数size\n\n        public UnionFindSet(List&lt;Node&gt; nodes) { // 并查集在初始化的时候需要一次性给定所有的数据，不能后期动态加载\n            this.fatherMap = new HashMap&lt;&gt;();\n            this.sizeMap = new HashMap&lt;&gt;();\n            this.initSet(nodes);\n        }\n\n        private void initSet(List&lt;Node&gt; nodes) {\n            // 每次初始化先清空原集合\n            this.fatherMap.clear();\n            this.sizeMap.clear();\n\n            for (Node node : nodes) {\n                fatherMap.put(node, node);\n                sizeMap.put(node, 1);// 初始每一个元素，单成一个集合结构\n            }\n        }\n\n        // 递归找父节点，同时扁平化\n        private Node findHead(Node node) {\n            Node father = fatherMap.get(node);\n            if (father != node) { // 不是代表节点\n                father = findHead(father);\n            }\n            fatherMap.put(node, father);// 扁平化，将递归沿途找到的节点都指向代表节点\n            return father;\n        }\n\n        // 两个元素是否属于同一个集合\n        public boolean isSameSet(Node a, Node b) {\n            return findHead(a) == findHead(b);\n        }\n\n        // 合并a b 所在的集合\n        public void union(Node a, Node b) {\n            if (a == null || b == null) return;\n\n            Node headA = findHead(a);\n            Node headB = findHead(b);\n\n            if (headA != headB) {\n                int sizeA = sizeMap.get(headA);\n                int sizeB = sizeMap.get(headB);\n                if (sizeA &lt;= sizeB) {\n                    fatherMap.put(headA, headB);\n                    sizeMap.put(headB, sizeA + sizeB);\n                } else {\n                    fatherMap.put(headB, headA);\n                    sizeMap.put(headA, sizeA + sizeB);\n                }\n            }\n        }\n    }\n}</code></pre></div><p><b>实例6</b></p><p>岛问题 一个矩阵中只有0和1两种值，每个位置都可以和自己的上、下、左、右 四个位置相连，如果有一片1连在一起，这个部分叫做一个岛，求一个 矩阵中有多少个岛？ 举例：</p><p>0 0 1 0 1 0 </p><p>1 1 1 0 1 0 </p><p>1 0 0 1 0 0</p><p>0 0 0 0 0 0</p><p>这个矩阵中有三个岛。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a4a1d1256731309d732fffc13fcb6bc7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"241\" data-rawheight=\"296\" class=\"content_image\" width=\"241\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;241&#39; height=&#39;296&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"241\" data-rawheight=\"296\" class=\"content_image lazy\" width=\"241\" data-actualsrc=\"https://pic4.zhimg.com/v2-a4a1d1256731309d732fffc13fcb6bc7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>思路：病毒感染原理，将 1 上下左右四个区域的 1 都感染为2 ，每感染一次，num++；</p><p>如图思路分解：</p><p>以下是一个岛分布图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-601086cf318d1eaa4f62d1a367b54bc5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"648\" data-original=\"https://pic2.zhimg.com/v2-601086cf318d1eaa4f62d1a367b54bc5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;648&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"648\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"648\" data-original=\"https://pic2.zhimg.com/v2-601086cf318d1eaa4f62d1a367b54bc5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-601086cf318d1eaa4f62d1a367b54bc5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>利用感染函数对连续区域的1 进行感染，扩散形式如图</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3e5c5fd98bd3df9216dd31136ad0bce9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"648\" class=\"origin_image zh-lightbox-thumb\" width=\"1123\" data-original=\"https://pic2.zhimg.com/v2-3e5c5fd98bd3df9216dd31136ad0bce9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1123&#39; height=&#39;648&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1123\" data-rawheight=\"648\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1123\" data-original=\"https://pic2.zhimg.com/v2-3e5c5fd98bd3df9216dd31136ad0bce9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3e5c5fd98bd3df9216dd31136ad0bce9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>具体实现</p><div class=\"highlight\"><pre><code class=\"language-text\">/**\n * @description: 岛问题\n * 一个矩阵中只有0和1两种值，\n * 每个位置都可以和自己的上、下、左、右 四个位置相连，\n * 如果有一片1连在一起，这个部分叫做一个岛，\n *\n * 求一个 矩阵中有多少个岛？\n * 举例：\n *\n * 0 0 1 0 1 0\n *\n * 1 1 1 0 1 0\n *\n * 1 0 0 1 0 0\n *\n * 0 0 0 0 0 0\n *\n * 这个矩阵中有三个岛。\n * @version: 1.0\n */\npublic class Code_35_Islands {\n\n    public static int countIslands(int[][] m){\n        if (m == null || m[0] == null) {\n            return 0;\n        }\n\n        int r = m.length; // 矩阵行数\n        int c = m[0].length; // 矩阵列数\n\n        int res = 0;\n        for (int i = 0; i &lt; r; i++) {\n            for (int j = 0; j &lt; c; j++) {\n                if (m[i][j] == 1){\n                    res++;\n                    infect(m, i, j, r, c);// 感染函数，将每一个感染点置为2\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     * 感染函数，递归感染连续的 1 区域\n     *\n     * 按照当前点的上下左右进行扩散感染\n     *\n     * 终止条件\n     * 1、不要越界\n     * 2、当前点已经被感染 为 2\n     * 3、当前点为 0\n     *\n     * @param m 矩阵\n     * @param i 点横坐标\n     * @param j 点纵坐标\n     * @param r 矩阵行数\n     * @param c 矩阵列数\n     */\n    public static void infect(int[][] m, int i, int j, int r, int c){\n        if (i &lt; 0 || i &gt;= r || j &lt; 0 || j &gt;= c // 坐标不越界\n                || m[i][j] != 1 // 当前点0或2，不是1\n        ){\n            return; // 不需要感染\n        }\n\n        m[i][j] = 2; // 感染当前点\n\n        infect(m, i + 1, j, r, c);\n        infect(m, i - 1, j, r, c);\n        infect(m, i, j + 1, r, c);\n        infect(m, i, j - 1, r, c);\n    }\n\n    public static void main(String[] args) {\n        int[][] m1 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 1, 1, 1, 0, 1, 1, 1, 0 },\n                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },\n                { 0, 1, 1, 0, 0, 0, 0, 0, 0 },\n                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },\n                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };\n        System.out.println(countIslands(m1));\n\n        int[][] m2 = {  { 0, 0, 0, 0, 0, 0, 0, 0, 0 },\n                { 0, 1, 1, 1, 1, 1, 1, 1, 0 },\n                { 0, 1, 1, 1, 0, 0, 0, 1, 0 },\n                { 0, 1, 1, 0, 0, 0, 1, 1, 0 },\n                { 0, 0, 0, 0, 0, 1, 1, 0, 0 },\n                { 0, 0, 0, 0, 1, 1, 1, 0, 0 },\n                { 0, 0, 0, 0, 0, 0, 0, 0, 0 }, };\n        System.out.println(countIslands(m2));\n    }\n}</code></pre></div><p><b>思考</b>：将上述岛问题上升到面试常常考察的大数据问题。当矩形的数据量非常大，单靠一台机器，一个cup已经无法短时间内解决这个求解任务怎么办？</p><p><b>多任务解决岛问题</b> 一个特别大的矩阵，单台机器，单CPU就显得不上道了。</p><p>多任务并行计算</p><p>拆分，合并。</p><p>先看拆分，将原问题分解成子问题，分别在不同机器上求解子问题的解，求解完后再进行结果合并。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6f1777311ce6467e985dfd79626b8e72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-6f1777311ce6467e985dfd79626b8e72_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;571&#39; height=&#39;446&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"571\" data-rawheight=\"446\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"571\" data-original=\"https://pic3.zhimg.com/v2-6f1777311ce6467e985dfd79626b8e72_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-6f1777311ce6467e985dfd79626b8e72_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最重要的是合并过程，容易出现岛的数量计算错误。对于到的合并问题，要处理的就是岛边界。根据岛边界计算两个岛合并时真实存在的岛数量。例如下图一个C形岛，分为两个子问题求解时，两个子问题求得共有3座岛，合并边界不处理好，返回的岛数量将不是1座。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bdc9fd692f5f6596047f42511626b313_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"485\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb\" width=\"485\" data-original=\"https://pic4.zhimg.com/v2-bdc9fd692f5f6596047f42511626b313_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;485&#39; height=&#39;522&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"485\" data-rawheight=\"522\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"485\" data-original=\"https://pic4.zhimg.com/v2-bdc9fd692f5f6596047f42511626b313_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bdc9fd692f5f6596047f42511626b313_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>边界问题</b></p><p>合并过程需要收集边界信息</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ef711829972c7f5987c533cf44432864_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"926\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"926\" data-original=\"https://pic1.zhimg.com/v2-ef711829972c7f5987c533cf44432864_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;926&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"926\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"926\" data-original=\"https://pic1.zhimg.com/v2-ef711829972c7f5987c533cf44432864_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ef711829972c7f5987c533cf44432864_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由同一个扩散点（感染中心）开始扩散感染的点都进行统一的标识， 记住感染中心。所以每一个子问题中都只需要记录岛数量和边界信息（边界信息记录由哪个感染中心扩散的）。</p><p>在使用并查集进行合并不同的子集。</p><p>如图：</p><p>左集合岛数量2，右集合岛数量2，一共4座岛 mergeNum=4</p><p>从边界开始分析</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-12000b00a63d384f038da04f1af712c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"143\" class=\"content_image\" width=\"281\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;281&#39; height=&#39;143&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"281\" data-rawheight=\"143\" class=\"content_image lazy\" width=\"281\" data-actualsrc=\"https://pic3.zhimg.com/v2-12000b00a63d384f038da04f1af712c2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>查A所在的集合和C所在的集合是不是一个，如过不是一个说明之前没有合并过，现在要合并了，岛数量减一1, merge=3，A，C合并（A，C）。 </p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b3c7c367ba0cea4d8e05de7370002874_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"236\" class=\"content_image\" width=\"264\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"264\" data-rawheight=\"236\" class=\"content_image lazy\" width=\"264\" data-actualsrc=\"https://pic1.zhimg.com/v2-b3c7c367ba0cea4d8e05de7370002874_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>重复上述过程，发现A，C已经合并过了,岛数量不变。</p><p>继续查看其他边界点。重复上述过程</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9a16510399fc7321b2aae41845394446_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"520\" class=\"content_image\" width=\"270\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;270&#39; height=&#39;520&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"520\" class=\"content_image lazy\" width=\"270\" data-actualsrc=\"https://pic3.zhimg.com/v2-9a16510399fc7321b2aae41845394446_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最终mergeNum=2。</p><hr/><hr/><p>以上为学习总结</p>", 
            "topic": [
                {
                    "tag": "哈希函数", 
                    "tagLink": "https://api.zhihu.com/topics/19631819"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "布隆过滤器", 
                    "tagLink": "https://api.zhihu.com/topics/20231898"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/74552125", 
            "userName": "zqtao23", 
            "userLink": "https://www.zhihu.com/people/22ff57a58297dae3f47794333ef45a19", 
            "upvote": 0, 
            "title": "01-算法初级-冒泡-选择-插入-归并-对数器-递归时间复杂度-小和-逆序对", 
            "content": "<h2>算法初级-01-时间复杂度</h2><p><b>年轻即出发</b>...</p><p><b>简书</b>：<a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/u/7110a2ba6f9e\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">jianshu.com/u/7110a2ba6</span><span class=\"invisible\">f9e</span><span class=\"ellipsis\"></span></a></p><p><b>知乎</b>：<a href=\"https://www.zhihu.com/people/zqtao23/posts\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/people/zqtao2</span><span class=\"invisible\">3/posts</span><span class=\"ellipsis\"></span></a></p><p><b>GitHub源码</b>：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/zqtao2332\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">github.com/zqtao2332</span><span class=\"invisible\"></span></a></p><p><b>个人网站</b>：<a href=\"https://link.zhihu.com/?target=http%3A//www.zqtaotao.cn/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">zqtaotao.cn/</span><span class=\"invisible\"></span></a>  （停止维护更新内容，转移简书）</p><p>​       咆哮怪兽一枚...嗷嗷嗷...趁你现在还有时间，尽你自己最大的努力。努力做成你最想做的那件事，成为你最想成为的那种人，过着你最想过的那种生活。也许我们始终都只是一个小人物，但这并不妨碍我们选择用什么样的方式活下去，这个世界永远比你想的要更精彩。</p><p>最后：喜欢编程，对生活充满激情</p><hr/><hr/><p><b>本节内容预告</b></p><p>算法时间复杂度评定标准</p><p>实例1：一个简单的理解时间复杂度的例子</p><p>实例2：冒泡排序</p><p>实例3：选择排序</p><p>实例4：插入排序</p><p>实例5：对数器</p><p>实例6：理解递归行为，以及递归行为事件复杂度的估算</p><p>实例7：归并排序</p><p>实例8：小和问题和逆序对问题</p><hr/><hr/><p>算法的评定标准有两个-时间复杂度，空间复杂度</p><p>1、常数时间的操作：一个操作如果和数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。+</p><p>例如：</p><ol><li>加减乘除</li><li>位运算</li><li>数组寻址</li></ol><p><i>这些操作的时间和样本是数据量是没有关系的</i></p><p>时间复杂度是一个算法流程中，评价常数操作数量的指标。</p><p>常用O（读作big O）来表示，具体，在常数操作数量的表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果记为f(N), 那么时间复杂度为O(f(N))。</p><p><b>评价算法流程好坏</b></p><p>评价一个算法流程的好坏，先看时间复杂度的指标，然后在分析不同数据样本下的实际运行时间，也就是常数项时间。</p><p>如：第一种算法流程的时间复杂度指标为N，所以他的算法好一些。（当然数据样本非常小，第二种好一些）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-bcd76ec4c1de70cd0531ad21167b9a6f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-bcd76ec4c1de70cd0531ad21167b9a6f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;541&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"541\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"541\" data-original=\"https://pic4.zhimg.com/v2-bcd76ec4c1de70cd0531ad21167b9a6f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-bcd76ec4c1de70cd0531ad21167b9a6f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>实例1</b></p><p>一个简单的理解时间复杂度的例子 一个有序数组A，另一个无序数组B，请打印B中的所有不在A中的数，A数 组长度为N，B数组长度为M。</p><p>可以使用三种常用的算法流程来解决这个问题：</p><p>算法流程1：对于数组B中的每一个数，都在A中通过遍历的方式找一下； 算法流程2：对于数组B中的每一个数，都在A中通过二分的方式找一下； 算法流程3：先把数组B排序，然后用类似外排的方式打印所有不在A中出现 的数； 三个流程，三种时间复杂度的表达... 如何分析好坏？</p><div class=\"highlight\"><pre><code class=\"language-text\">流程1\n\n时间复杂度：O(N*M)\n\n流程2\n\n二分法：每次排除一半的样本数据\n\n时间复杂度：O(M*logN)\n\nps : logN是以2为底\n\n流程3\n\n先排序 O(M*logM)\n\n外排比较时间复杂度：O(N + M)</code></pre></div><p>总结，流程1性能最差；如果A长，B短，流程2好；如果A短，B长，流程3好；</p><p><b>实例2</b></p><p>冒泡排序</p><div class=\"highlight\"><pre><code class=\"language-text\">每次相邻的两个数进行比较，然后交换（需要时交换），每一趟都找到了当前样本中的最大数\n// 排序\n    public static void bubbleSort(int[] arr) {\n        if (arr == null || arr.length &lt; 2)\n            return;\n        // 每一趟少一个最大元素，固定范围\n        for (int end = arr.length - 1; end &gt; 0; end--) {\n            for (int i = 0; i &lt; end; i++) { // i 不能= end ，不然 i + 1 数组越界\n                if (arr[i] &gt; arr[i + 1])\n                    swap(arr, i, i + 1);\n            }\n        }\n\n        // 打印结果\n        System.out.println(Arrays.toString(arr));\n    }\n\n    // 交换\n    public static void swap(int[] arr, int i, int j) {\n        // 交换时间复杂度：常数时间复杂度\n        // 交换只涉及到了数组元素的寻址操作，这是常数时间操作\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre></div><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p><p><b>实例3</b></p><p>选择排序</p><div class=\"highlight\"><pre><code class=\"language-text\">每次选择一个最小的放在该放的位置上\npublic static void selectionSort(int[] arr) {\n        if (arr == null || arr.length &lt; 2)\n            return;\n\n        /*\n            5 9 4 1 2\n            第一次 i = 0, 循环完毕找到 数1 的下标，交换数，将1 放到 第0 个位置上\n            交换后结果：1 9 4 5 2\n\n            第二次 i = 1, 循环完毕找到 数2 的下标，交换数，将2 放到 第1 个位置上\n            交换后结果：1 2 4 5 9\n\n            依次类推 ...5 个数，需要循环4次\n         */\n        // 外层规定循环范围, 每次找到最小的数，放在第 i 个位置上\n        // N个元素，当前N-1 个位置上的数已经确定，则最后一个也是确定的，所以 i &lt; arr.length - 1\n        for (int i = 0; i &lt; arr.length - 1; i++) {\n\n            // 假设当前 i 位置上的数就是最小数\n            int minIndex = i;\n\n            // 内层寻找最小数下标\n            for (int j = i + 1; j &lt; arr.length; j++) {\n                minIndex = arr[minIndex] &lt; arr[j] ? minIndex : j;\n            }\n\n            swap(arr, i, minIndex);\n        }\n\n        System.out.println(Arrays.toString(arr));\n    }\n\n    public static void swap(int[] arr, int i, int j) {\n        int tmp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = tmp;\n    }</code></pre></div><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p><p><b>实例4</b></p><p>插入排序</p><p>算法时间复杂度</p><p>插入排序和选择排序，冒泡排序不同，它跟数据的状态有关。</p><p>最好情况：数据是有序的如：1 2 3 4 5，O(N)</p><p>最坏情况：数据是反序的如：5 4 3 2 1, 求小到大序，则O(N^2)</p><p>时间复杂度O(N^2)，额外空间复杂度O(1)</p><p><b>实例5</b></p><p>对数器</p><div class=\"highlight\"><pre><code class=\"language-text\">采用对数器来进行验证\n1、一个你想要测试的方法 a\n2、一个绝对正确但是复杂度不好是方法 b\n3、实现一个随机样本产生器\n4、实现对比的方法\n5、把方法a和方法b比对很多次来验证方法a 是否正确\n6、如果有一个样本使得对比出错，打印出样本，分析到底是哪个方法出错\n7、当样本数量很多时比对测试依然正确，可以确定方法a 正确</code></pre></div><p>测试一下插入排序</p><p>模型</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">import</span> <span class=\"nn\">java.util.Arrays</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * @description: 排序随机样本产生器模型\n</span><span class=\"cm\"> * @version: 1.0\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SortModel</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// for test : 一个绝对正确的排序方法 --&gt; 这里使用Java自带方法\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">comparator</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">Arrays</span><span class=\"o\">.</span><span class=\"na\">sort</span><span class=\"o\">(</span><span class=\"n\">arr</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// for test : 随机样本产生器\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">generateRandomArray</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">maxSize</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">maxValue</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\n        <span class=\"c1\">// 随机数组长度，随机长度\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">random</span><span class=\"o\">()</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">maxSize</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">))];</span>\n        <span class=\"c1\">// 随机数据\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 两个随机数相减，可以随机出负数\n</span><span class=\"c1\"></span>            <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">random</span><span class=\"o\">()</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">maxValue</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">))</span> <span class=\"o\">-</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"o\">(</span><span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">random</span><span class=\"o\">()</span> <span class=\"o\">*</span> <span class=\"o\">(</span><span class=\"n\">maxValue</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">));</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">arr</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// for test : 复制数组\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"nf\">copyArray</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">arr</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">];</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n            <span class=\"n\">res</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// for test : 实现一个对比方法\n</span><span class=\"c1\"></span>    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isEqual</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr1</span><span class=\"o\">,</span> <span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">arr2</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 有一个数组为null\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">arr2</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span>\n                <span class=\"o\">||</span> <span class=\"n\">arr1</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">arr2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n            <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 两个数组都为null\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">arr1</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">arr2</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 两个数组的长度不一致\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">arr1</span><span class=\"o\">.</span><span class=\"na\">length</span> <span class=\"o\">!=</span> <span class=\"n\">arr2</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 对比两个数组中的每一个元素\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">arr1</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">arr1</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">arr2</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">])</span>\n                <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n       <span class=\"cm\">/*\n</span><span class=\"cm\">        采用对数器来进行验证\n</span><span class=\"cm\">        1、一个你想要测试的方法 a\n</span><span class=\"cm\">        2、一个绝对正确但是复杂度不好是方法 b\n</span><span class=\"cm\">        3、实现一个随机样本产生器\n</span><span class=\"cm\">        4、实现对比的方法\n</span><span class=\"cm\">        5、把方法a和方法b比对很多次来验证方法a 是否正确\n</span><span class=\"cm\">        6、如果有一个样本使得对比出错，打印出样本，分析到底是哪个方法出错\n</span><span class=\"cm\">        7、当样本数量很多时比对测试依然正确，可以确定方法a 正确\n</span><span class=\"cm\">     */</span>\n<span class=\"o\">}</span></code></pre></div><p>测试</p><div class=\"highlight\"><pre><code class=\"language-text\">import cn.zqtao.learn.model.SortModel;\n\nimport java.util.Arrays;\n\n/**\n * @description: 插入排序（相对工程中使用挺多）\n * &lt;p&gt;\n * 类似插牌\n * &lt;p&gt;\n * 将数据组划分为两块，一块是已经排序好的，一块是待排序的\n * &lt;p&gt;\n * 每一次从待排序数组中取出一个元素，进行插入\n * 插入选择：从排序好的数组的最后一个元素开始进行倒序遍历，寻找它应该存放的位置，进行交换插入\n * @version: 1.0\n */\npublic class Code_02_InsertionSort {\n\n    public static void insertionSort(int[] arr) {\n\n        if (arr == null || arr.length &lt; 2)\n            return;\n\n        // 外层循环控制循环次数, 默认认为第一个元素是已经排序好的\n        for (int i = 1; i &lt; arr.length; i++) {\n            // 对已经排序好的数组进行倒叙遍历，查询新元素的插入下标\n            for (int j = i - 1; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + 1]; j--) {\n                swap(arr, j, j + 1);\n            }\n        }\n\n    }\n\n    // 不需要使用临时变量，进行交换\n    public static void swap(int[] arr, int i, int j) {\n        arr[i] = arr[i] ^ arr[j];\n        arr[j] = arr[i] ^ arr[j];\n        arr[i] = arr[i] ^ arr[j];\n    }\n\n    public static void main(String[] args) {\n        int testTime = 5000;\n        int maxSize = 10;\n        int maxValue = 100;\n\n        for (int i = 0; i &lt; testTime; i++) {\n            int[] randomArr = SortModel.generateRandomArray(maxSize, maxValue);\n            int[] arr1 = SortModel.copyArray(randomArr);\n            int[] arr2 = SortModel.copyArray(randomArr);\n\n            insertionSort(arr1);\n            SortModel.comparator(arr2);\n\n            if (!SortModel.isEqual(arr1, arr2)) {\n                System.out.println(&#34;错误: &#34; + Arrays.toString(randomArr));\n                System.out.println(&#34;待测方法结果：&#34; + Arrays.toString(arr1));\n                System.out.println(&#34;正确方法结果：&#34; + Arrays.toString(arr2));\n                break;\n            }\n        }\n    }\n\n}</code></pre></div><p><b>实例6</b></p><p>理解递归行为，以及递归行为事件复杂度的估算</p><p>master公式的使用</p><p><b>T(N) = a*T(N/b) + O(N^d)</b>   满足master此形式的，都可以使用下面的计算方法计算时间复杂度</p><p>1) log(b,a) &gt; d ---&gt; 复杂度为O(N^log(b,a)) </p><p>2) log(b,a) = d ---&gt; 复杂度为O(N^d * logN)</p><p>3) log(b,a) &lt; d ---&gt; 复杂度为O(N^d)</p><p>ps: log(b, a) 表示以b 为底</p><p>补充阅读：<a href=\"https://link.zhihu.com/?target=http%3A//www.gocalf.com/blog/algorithm-complexity-and-mastertheorem.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">gocalf.com/blog/algorit</span><span class=\"invisible\">hm-complexity-and-mastertheorem.html</span><span class=\"ellipsis\"></span></a></p><p><b>实例7</b></p><p>归并排序</p><p>分治思想</p><p>左边部分排序为有序</p><p>右半部分排序为有序</p><p>采用外排方式，合并两个有序部分到一个临时数组</p><p>复制回写到原数组</p><div class=\"highlight\"><pre><code class=\"language-text\">import cn.zqtao.learn.model.SortModel;\n\nimport java.util.Arrays;\n\n/**\n * @description: 归并排序\n * &lt;p&gt;\n * 分治思想\n * &lt;p&gt;\n * 左半部分排序\n * 右半部分排序\n * &lt;p&gt;\n * 采用外排方式，合并两个有序部分到一个临时数组\n * &lt;p&gt;\n * 复制回原数组\n * @version: 1.0\n */\npublic class Code_03_MergerSort {\n\n    public static void mergerSort(int[] arr) {\n        if (arr == null || arr.length &lt; 2)\n            return;\n        sortProcess(arr, 0, arr.length - 1);\n//        System.out.println(Arrays.toString(arr));\n\n    }\n\n    public static void sortProcess(int[] arr, int L, int R) {\n        if (L == R)\n            return;\n        int mid = L + ((R - L) &gt;&gt; 1); // 等同于 (L + R) / 2\n        sortProcess(arr, L, mid);\n        sortProcess(arr, mid + 1, R);\n\n        merger(arr, L, mid, R); // O(N)\n        // T(N) = 2 T(N/2) + O(N) 符合master公式\n        // 所以时间复杂度： O(N * logN)\n        // 空间复杂度：O(N)  临时辅助数组\n    }\n\n    // 合并两个有序部分\n    private static void merger(int[] arr, int L, int mid, int R) {\n        // 辅助数组\n        int[] help = new int[R - L + 1];\n        int i = 0;\n\n        // 双指针，分别指向第一个有序部分第一个数位置，第二个有序部分第一个数位置\n        int p1 = L;\n        int p2 = mid + 1;\n\n        // 外排方式选填进入临时辅助数组的数, 当两个指针任意一个越界时跳出\n        while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) {\n            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];\n        }\n\n        // 有且只有一个越界\n        while (p1 &lt;= mid)\n            help[i++] = arr[p1++];\n        while (p2 &lt;= R)\n            help[i++] = arr[p2++];\n\n        // 回写到原数组\n        for (int j = 0; j &lt; help.length; j++) {\n            arr[L + j] = help[j];\n        }\n    }\n\n    public static void main(String[] args) {\n        int testTime = 5000;\n        int maxSize = 10;\n        int maxValue = 100;\n\n        for (int i = 0; i &lt; testTime; i++) {\n            int[] randomArr = SortModel.generateRandomArray(maxSize, maxValue);\n            int[] arr1 = SortModel.copyArray(randomArr);\n            int[] arr2 = SortModel.copyArray(randomArr);\n\n            mergerSort(arr1);\n            SortModel.comparator(arr2);\n\n            if (!SortModel.isEqual(arr1, arr2)) {\n                System.out.println(&#34;错误: &#34; + Arrays.toString(randomArr));\n                System.out.println(&#34;待测方法结果：&#34; + Arrays.toString(arr1));\n                System.out.println(&#34;正确方法结果：&#34; + Arrays.toString(arr2));\n                break;\n            }\n        }\n    }\n}\n时间复杂度： O(N * logN)\n空间复杂度：O(N)  临时辅助数组</code></pre></div><p><b>实例8</b></p><p>小和问题和逆序对问题 小和问题 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。 例子： [1,3,4,2,5] 1左边比1小的数，没有； 3左边比3小的数，1； 4左边比4小的数，1、3； 2左边比2小的数，1； 5左边比5小的数，1、3、4、2； 所以小和为1+1+3+1+1+3+4+2=16 逆序对问题 在一个数组中，左边的数如果比右边的数大，则折两个数构成一个逆序对，请打印所有逆序 对。</p><p><b>小和问题</b></p><div class=\"highlight\"><pre><code class=\"language-text\">import cn.zqtao.learn.model.SortModel;\n\nimport java.util.Arrays;\n\n/**\n * @description: 小和问题\n * &lt;p&gt;\n * 小和问题\n * 在一个数组中，每一个数左边比当前数小的数累加起来，叫做这个数组的小和。求一个数组 的小和。\n * 例子：\n * [1,3,4,2,5]\n * 1左边比1小的数，没有；\n * 3左边比3小的数，1；\n * 4左边比4小的数，1、3；\n * 2左边比2小的数，1；\n * 5左边比5小的数，1、3、4、2；\n * 所以小和为1+1+3+1+1+3+4+2=16\n * @version: 1.0\n */\npublic class Code_04_SmallSum {\n\n    public static int smallSum(int[] arr) {\n        if (arr == null || arr.length &lt; 2) return 0;\n        return mergesort(arr, 0, arr.length - 1);\n    }\n\n\n    public static int mergesort(int[] arr, int L, int R) {\n        if (L == R) return 0;\n\n        int mid = L + ((R - L) &gt;&gt; 1);\n        return mergesort(arr, L, mid) +\n                mergesort(arr, mid + 1, R) +\n                merge(arr, L, mid, R);\n        //左边产生的小和+右边产生的小和+合并产生的小和就是整个数组的小和\n    }\n\n    public static int merge(int[] arr, int L, int mid, int R) {\n        // 辅助数组\n        int[] help = new int[R - L + 1];\n        int i = 0;\n\n        // 双指针\n        int p1 = L;\n        int p2 = mid + 1;\n\n        int res = 0;\n        while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) {\n            // 左边小于右边，左边数 * 右边比左边大的数的个数，因为已经使用归并排序进行了排序\n            // 所以右边剩下的数也比左边数大\n            // 如左边  1 3\n            //   右边  2 5 6\n            // 1 &lt; 2 ,此时右边数，5 6 一定都比1大， 则 小和结果是 1 * 3\n\n            res = arr[p1] &lt; arr[p2] ? arr[p1] * (R - p2 + 1) : 0;\n            help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];\n        }\n\n        while (p1 &lt;= mid)\n            help[i++] = arr[p1++];\n        while (p2 &lt;= R)\n            help[i++] = arr[p2++];\n\n        for (i = 0; i &lt; help.length; i++)\n            arr[L + i] = help[i];\n        return res;\n    }\n\n    // for test 写一个实现简单，绝对正确但是时间复杂度高的算法\n    public static int comparator(int[] arr) {\n        if (arr == null || arr.length &lt; 2) {\n            return 0;\n        }\n        int res = 0;\n        for (int i = 1; i &lt; arr.length; i++) {\n            for (int j = 0; j &lt; i; j++) {\n                res += arr[j] &lt; arr[i] ? arr[j] : 0;\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int testTime = 500000;\n        int maxSize = 100;\n        int maxValue = 100;\n        boolean succeed = true;\n        for (int i = 0; i &lt; testTime; i++) {\n            int[] randomArr = SortModel.generateRandomArray(maxSize, maxValue);\n            int[] arr1 = SortModel.copyArray(randomArr);\n            int[] arr2 = SortModel.copyArray(randomArr);\n            if (!SortModel.isEqual(arr1, arr2)) {\n                succeed = false;\n                System.out.println(&#34;错误: &#34; + Arrays.toString(randomArr));\n                System.out.println(&#34;待测方法结果：&#34; + Arrays.toString(arr1));\n                System.out.println(&#34;正确方法结果：&#34; + Arrays.toString(arr2));\n                break;\n            }\n        }\n        System.out.println(succeed ? &#34;Nice!&#34; : &#34;Fucking fucked!&#34;);\n    }\n}</code></pre></div><p>逆序对</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * @description: 逆序对问题\n * 在一个数组中，左边的数如果比右边的数大，则两个数构成一个逆序对，请打印所有逆序对\n * @version: 1.0\n */\npublic class Code_05_InvertedNum {\n\n    public static void invertedNum(int[] arr) {\n        if (arr == null || arr.length &lt; 2) return;\n        mergeSort(arr, 0, arr.length - 1);\n    }\n\n    public static void mergeSort(int[] arr, int L, int R) {\n        if (L == R) return;\n\n        int mid = L + ((R - L) &gt;&gt; 1);\n        // 打印左边逆序对\n        mergeSort(arr, L, mid);\n        // 打印右边逆序对\n        mergeSort(arr, mid + 1, R);\n        // 打印合并后的逆序对\n        merge(arr, L, mid, R);\n    }\n\n    public static void merge(int[] arr, int L, int mid, int R) {\n        // 辅助数组\n        int[] help = new int[R - L + 1];\n        int i = 0;\n\n        int p1 = L;\n        int p2 = mid + 1;\n\n        while (p1 &lt;= mid &amp;&amp; p2 &lt;= R) {\n            if (arr[p1] &gt; arr[p2]) {\n                for (int j = p2; j &lt;= R; j++) {\n                    System.out.println(&#34;逆序对：&#34; + arr[p1] + &#34;--&#34; + arr[j]);\n                }\n            }\n            help[i++] = arr[p1] &gt; arr[p2] ? arr[p1++] : arr[p2++];\n        }\n\n        while (p1 &lt;= mid)\n            help[i++] = arr[p1++];\n        while (p2 &lt;= R)\n            help[i++] = arr[p2++];\n\n        for (i = 0; i &lt; help.length; i++)\n            arr[L + i] = help[i];\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            String[] str = sc.nextLine().split(&#34;,&#34;);\n            int[] num = new int[str.length];\n            for (int i = 0; i &lt; str.length; i++) {\n                num[i] = Integer.parseInt(str[i]);\n            }\n            invertedNum(num);\n        }\n        sc.close();\n    }\n\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "时间复杂度", 
                    "tagLink": "https://api.zhihu.com/topics/19587347"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70477750", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 3, 
            "title": "数据结构与算法——散列表", 
            "content": "<h3>什么是散列表</h3><p>散列表（hash table），我们平时叫它<b>哈希表</b>或者<b>Hash 表</b>，你肯定经常听到它。</p><p>散列表是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p><p>由定义我们可以知道，散列表用的是数组支持下标访问数据的特性，所以散列表是数组的一种扩展，有数组演化而来。</p><h3>举个例子</h3><p>假如我们一共有 50 人参加学校的数学竞赛，然后我们为每个学生分配一个编号，依次是 1 到 50.</p><p>如果我们想要快速知道编号对应学生的信息，我们就可以用一个数组来存放学生的信息，编号为 1 的放到数组下标为 1 的位置，编号为 2 的放到数组下标为 2 的位置，依次类推。</p><p>现在如果我们想知道编号为 20 的学生的信息，我们只需要把数组下标为 20 的元素取出来就可以了，时间复杂度为 O(1)，是不是效率非常高呢。</p><p>但是这些学生肯定来自不同的年级和班级，为了包含更详细的信息，我们在原来编号前边加上年级和班级的信息，比如 030211 ，03 表示年级，02 表示班级，11 原来的编号，这样我们该怎么存储学生的信息，才能够像原来一样使用下标快速查找学生的信息呢？</p><p>思路还是和原来一样，我们通过编号作为下标来储存，但是现在编号多出了年级和班级的信息怎么办呢，我们只需要截取编号的后两位作为数组下标来储存就可以了。</p><p>这个过程就是典型的散列思想。其中，参赛学生的编号我们称之为<b>键</b>（key)，我们用它来标识一个学生。然后我们通过一个方法（比如上边的截取编号最后两位数字）把编号转变为数组下标，这个方法叫做<b>散列函数（哈希函数）</b>，通过散列函数得到的值叫做<b>散列值（哈希值）</b>。</p><h3>散列函数</h3><p>通过上边的例子，我们知道了散列函数的用途，散列函数在整个过程中起着非常关键的作用。</p><p>它本质就是一个函数，我们把它定义为 hash(key)，key 就是元素的键值，通过 hash 函数得到的值就是散列值。</p><p>在上边的例子中，散列函数就是截取编号后两位作为数组的下标，我们通过代码一块来看一下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">hash</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">key</span><span class=\"o\">)</span>\n<span class=\"o\">{</span>\n    <span class=\"n\">String</span> <span class=\"n\">lastTowNum</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">substring</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">()-</span><span class=\"n\">2</span><span class=\"o\">,</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">());</span>\n    <span class=\"kt\">int</span> <span class=\"n\">index</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">parseInt</span><span class=\"o\">(</span><span class=\"n\">lastTowNum</span><span class=\"o\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">index</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>那我们自己在设计散列函数的函数时应该遵循什么规则呢？</p><ol><li>得到的散列值是一个非负整数</li><li>两个相同的键，通过散列函数计算出的散列值也相同</li><li>两个不同的键，计算出的散列值不同</li></ol><p>虽然我们在设计的时候要求满足以上三条要求，但是对于第三条来说，想要找到不同的 key 对应的散列值都不一样的散列函数是不可能的。即使现在非常著名的 <b>MD5</b>、<b>SHA</b>、<b>CRC</b> 哈希算法，也没办法避免这用<b>哈希冲突</b>。而且因为数组的存储空间有限，也会加大这种哈希冲突。</p><h3>哈希冲突</h3><p>既然我们无法避免哈希冲突，那我们应该怎么解决它呢？常用的方法有两种，开放寻址法和链表法。</p><h3>开放寻址法</h3><p>开发寻址法就是但我们遇到了哈希冲突，我们就重新探索一个空闲位置，然后插入。</p><p>我们探索空闲位置有以下几种方法。</p><ul><li>线性探测</li></ul><p>当我们往散列表中插入数据时，经过散列函数发现位置已经被占用了，我们就从当前位置开始，依次往后查找，直到找到空闲位置为止。</p><p>比如一个散列表的大小为 10，一个数据经过散列函数之后，到了下标为 8 的位置，但是发现这个位置已经有数据了，那么就依次往后遍历，如果到了尾部，还是没有找到空闲位置，那么就再从头开始找，直到找到空闲位置。</p><p>查找元素和插入类似，通过散列函数计算出哈希值，然后找到对应位置数据，然后与查找的元素进行比较，如果相等，则它就是我们要找的数据，如果不相等，就依次往后遍历，如果遍历到空闲位置还没找到，就说明元素不在散列表中。</p><p>但是删除的时候稍微有点特别，我们不能直接删除数据，因为我们在查找的时候，如果找到一个空闲位置，就说元素不在散列表中，如果我们直接删除了之后可能会导致某些元素找不到。所以我们将要删除的元素，标记为 deleted，当我们查找的时候，遇到标记为 deleted 的元素，继续往下遍历。</p><p>线性探测法存在很大的问题，当散列表中插入的元素越来越多时，发生散列冲突的概率就越来越大，空闲的位置就越来越少，先行探索的时间就会越来越长，甚至在极端情况下，我们需要遍历整个散列表。</p><ul><li>二次探索</li></ul><p>二次探索，和线性探索原理一样，先行探索每次的步长为 1 ，探索的下标依次为 hash(key)+0，hash(key)+1，hash(key)+2...，二次探索每次的步长变为原来的二次方，所以每次探索的下边为 hash(key)+0，hash(key)+1^2，hash(key)+2^2。</p><ul><li>双重散列</li></ul><p>原来我们使用一个散列函数，双重散列，我们使用多个散列函数，我们先用第一个散列函数，如果计算得到的位置已经被占用，就使用第二个散列函数，以此类推，直到找到空闲时的位置。</p><p>不管用哪个探索方法，当空闲位置变少的时候，散列冲突的概率会变得很高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<b>装载因子</b>来表示空位的多少。 装载因子 = 填入散列表的元素个数 / 散列表的长度</p><h3>链表法</h3><p>链表法是一种更为常用的解决散列冲突的方法，比开放寻址法更加简单。在散列表中每个下标位置对应一个链表，所有经过散列函数得到的散列值相同的元素，我们都放到对应下标位置的链表中。</p><p>插入元素时，经过散列函数得到散列值，然后插入到对应下标位置的链表中即可，时间复杂度为 O(1)。查找和删除同样的对对应位置的链表进行操作，对应的时间复杂度和链表的长度有关系，也就是 O(n)。</p><h3>怎样设计散列函数</h3><p>通过上边介绍，我们知道散列函数在散列表中占非常重要的作用，关系到散列冲突的概率的大小，从而影响散列表的性能。那么怎么来判断一个散列函数的好坏呢？</p><p>首先散列函数不能太复杂，太复杂肯定会消耗更多的时间，从而影响散列表的性能。</p><p>散列函数得到的散列值尽可能随机且均匀分布，这样才能减少散列冲突，即使有冲突，每个位置对应的元素也会比较平均，不会有的特别多，而有的特别少的情况。</p><h3>散列表动态扩容</h3><p>前边我们提到过，当散列表的装载因子过大的时候，散列表的空闲位置变得很少，散列冲突的概率就变得很大，而且插入和查找数据的效率也会变得很低。 这个时候我们就需要对散列表动态扩容，重新申请一个更大的散列表，然后把原有的数据移到新的散列表中。</p><p>如果扩容的时候我们重新申请一个原来散列表两倍大的新散列表，原来的转载因子如果为 0.8，那么重新申请的散列表的装载因子即为 0.4。前边我们讲过数组的动态扩容，数据的迁移比较简单，而散列表数据的迁移就相对比较复杂了，因为散列表的大小变了，那么数据存储的位置也就变了，我们需要通过散列函数重新计算数据的存储的位置。</p><p>我们可以设定一个阈值，当装载因子大于阈值的时候，就需要对散列表动态扩容。</p><p>如果我们内存空间比较紧张，也可以设定另外一个阈值，当散列表的装载因子小于阈值的时候，对散列表进行动态缩容，但这样做散列表的执行效率就会降低。</p><p>所以装载因子的阈值我们要选择得当，根据实际情况来权衡时间、空间复杂度的平衡。如果更在意性能，可以适当的牺牲一些内存空间；如果内存空间紧张，可以牺牲一些性能来换取内存空间。</p><p>当我们插入数据的时候，如果装载因子大于阈值，就需要先扩容，再执行插入操作，如果散列表很大，我们扩容搬迁数据的就会非常慢，所以就导致插入数据变得非常慢。</p><p>为了解决一次性扩容的耗时问题，我们把数据的迁移分批完成，每次插入操作迁移一部分数据。当达到阈值的时候我们只申请新的散列表，然后把新数据放到新的散列表中，当再有新数据插入的时候，我们将新数据插入到新的散列表，并把一部分数据从老的散列表迁移到新的散列表中。然后重复这样的操作，直到所有数据迁移完成。这样就解决了一次性迁移耗时过长的情况。</p><p>数据迁移期间，如果有查询操作，我们首先在新的散列表中进行查找，如果没有，再去老的散列表中查找。</p><hr/><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c3f0d733db3e25b3c7beb86d8a0a7fdd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic2.zhimg.com/v2-c3f0d733db3e25b3c7beb86d8a0a7fdd_b.jpg\"/></figure>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/68516038", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 17, 
            "title": "数据结构与算法——跳表", 
            "content": "<h3><b>什么是跳表</b></h3><p>跳表全称为跳跃列表，它允许快速查询，插入和删除一个有序连续元素的数据链表。跳跃列表的平均查找和插入时间复杂度都是O(logn)。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集（见右边的示意图）。一开始时，算法在最稀疏的层次进行搜索，直至需要查找的元素在该层两个相邻的元素中间。这时，算法将跳转到下一个层次，重复刚才的搜索，直到找到需要查找的元素为止。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-406ac352da4f3c45da01ba5e2c168d9d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2880\" data-rawheight=\"674\" class=\"origin_image zh-lightbox-thumb\" width=\"2880\" data-original=\"https://pic2.zhimg.com/v2-406ac352da4f3c45da01ba5e2c168d9d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2880&#39; height=&#39;674&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2880\" data-rawheight=\"674\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2880\" data-original=\"https://pic2.zhimg.com/v2-406ac352da4f3c45da01ba5e2c168d9d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-406ac352da4f3c45da01ba5e2c168d9d_b.jpg\"/></figure><p>一张跳跃列表的示意图。每个带有箭头的框表示一个指针, 而每行是一个稀疏子序列的链表；底部的编号框（黄色）表示有序的数据序列。查找从顶部最稀疏的子序列向下进行, 直至需要查找的元素在该层两个相邻的元素中间。</p><h3><b>跳表的演化过程</b></h3><p>对于单链表来说，即使数据是已经排好序的，想要查询其中的一个数据，只能从头开始遍历链表，这样效率很低，时间复杂度很高，是 O(n)。<br/>那我们有没有什么办法来提高查询的效率呢？我们可以为链表建立一个“索引”，这样查找起来就会更快，如下图所示，我们在原始链表的基础上，每两个结点提取一个结点建立索引，我们把抽取出来的结点叫做<b>索引层</b>或者<b>索引</b>，down 表示指向原始链表结点的指针。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2fd457402672f19b892930d12545aac0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1938\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"1938\" data-original=\"https://pic1.zhimg.com/v2-2fd457402672f19b892930d12545aac0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1938&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1938\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1938\" data-original=\"https://pic1.zhimg.com/v2-2fd457402672f19b892930d12545aac0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2fd457402672f19b892930d12545aac0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>现在如果我们想查找一个数据，比如说 15，我们首先在索引层遍历，当我们遍历到索引层中值为 14 的结点时，我们发现下一个结点的值为 17，所以我们要找的 15 肯定在这两个结点之间。这时我们就通过 14 结点的 down 指针，回到原始链表，然后继续遍历，这个时候我们只需要再遍历两个结点，就能找到我们想要的数据。好我们从头看一下，整个过程我们一共遍历了 7 个结点就找到我们想要的值，如果没有建立索引层，而是用原始链表的话，我们需要遍历 10 个结点。</p><p>通过这个例子我们可以看出来，通过建立一个索引层，我们查找一个基点需要遍历的次数变少了，也就是查询的效率提高了。</p><p>那么如果我们给索引层再加一层索引呢？遍历的结点会不会更少呢，效率会不会更高呢？我们试试就知道了。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e5efbba6181b40a8468cebc7f99e69d3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1976\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb\" width=\"1976\" data-original=\"https://pic4.zhimg.com/v2-e5efbba6181b40a8468cebc7f99e69d3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1976&#39; height=&#39;698&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1976\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1976\" data-original=\"https://pic4.zhimg.com/v2-e5efbba6181b40a8468cebc7f99e69d3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e5efbba6181b40a8468cebc7f99e69d3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>现在我们再来查找 15，我们从第二级索引开始，最后找到 15，一共遍历了 6 个结点，果然效率更高。</p><p>当然，因为我们举的这个例子数据量很小，所以效率提升的不是特别明显，如果数据量非常大的时候，我们多建立几层索引，效率提升的将会非常的明显，感兴趣的可以自己试一下，这里我们就不举例子了。</p><p>这种通过对链表加多级索引的机构，就是跳表了。</p><h3><b>跳表具体有多快</b></h3><p>通过上边的例子我们知道，跳表的查询效率比链表高，那具体高多少呢？下面我们一起来看一下。</p><p>衡量一个算法的效率我们可以用时间复杂度，这里我们也用时间复杂度来比较一下链表和跳表。前面我们已经讲过了，链表的查询的时间复杂度为 O(n)，那跳表的呢？</p><p>如果一个链表有 n 个结点，如果每两个结点抽取出一个结点建立索引的话，那么第一级索引的结点数大约就是 n/2，第二级索引的结点数大约为 n/4，以此类推第 m 级索引的节点数大约为 n/(2^m)。</p><p>假如一共有 m 级索引，第 m 级的结点数为两个，通过上边我们找到的规律，那么得出 n/(2^m)=2，从而求得 m=log(n)-1。如果加上原始链表，那么整个跳表的高度就是 log(n)。我们在查询跳表的时候，如果每一层都需要遍历 k 个结点，那么最终的时间复杂度就为 O(k*log(n))。</p><p>那这个 k 值为多少呢，按照我们每两个结点提取一个基点建立索引的情况，我们每一级最多需要遍历两个个结点，所以 k=2。为什么每一层最多遍历两个结点呢？</p><p>因为我们是每两个结点提取一个结点建立索引，最高一级索引只有两个结点，然后下一层索引比上一层索引两个结点之间增加了一个结点，也就是上一层索引两结点的中值，看到这里是不是想起来我们前边讲过的二分查找，每次我们只需要判断要找的值在不在当前结点和下一个结点之间即可。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8ff6ab429a349194ecab25e24ecee705_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1478\" data-rawheight=\"638\" class=\"origin_image zh-lightbox-thumb\" width=\"1478\" data-original=\"https://pic2.zhimg.com/v2-8ff6ab429a349194ecab25e24ecee705_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1478&#39; height=&#39;638&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1478\" data-rawheight=\"638\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1478\" data-original=\"https://pic2.zhimg.com/v2-8ff6ab429a349194ecab25e24ecee705_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8ff6ab429a349194ecab25e24ecee705_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如上图所示，我们要查询红色结点，我们查询的路线即黄线表示出的路径查询，每一级最多遍历两个结点即可。</p><p>所以跳表的查询任意数据的时间复杂度为 O(2*log(n))，前边的常数 2 可以忽略，为 O(log(n))。</p><h3><b>跳表是用空间来换时间</b></h3><p>跳表的效率比链表高了，但是跳表需要额外存储多级索引，所以需要的更多的内存空间。</p><p>跳表的空间复杂度分析并不难，如果一个链表有 n 个结点，如果每两个结点抽取出一个结点建立索引的话，那么第一级索引的结点数大约就是 n/2，第二级索引的结点数大约为 n/4，以此类推第 m 级索引的节点数大约为 n/(2^m)，我们可以看出来这是一个等比数列。</p><p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2，所以跳表的空间复杂度为 o(n)。</p><p>那么我们有没有办法减少索引所占的内存空间呢？可以的，我们可以每三个结点抽取一个索引，或者没五个结点抽取一个索引。这样索引结点的数量减少了，所占的空间也就少了。</p><h3><b>跳表的插入和删除</b></h3><p>我们想要为跳表插入或者删除数据，我们首先需要找到插入或者删除的位置，然后执行插入或删除操作，前边我们已经知道了，跳表的查询的时间复杂度为 O(logn），因为找到位置之后插入和删除的时间复杂度很低，为 O(1)，所以最终插入和删除的时间复杂度也为 O(longn)。</p><p>我么通过图看一下插入的过程。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-60a0055f7b5897454ea44047d6fbb1ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1714\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb\" width=\"1714\" data-original=\"https://pic4.zhimg.com/v2-60a0055f7b5897454ea44047d6fbb1ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1714&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1714\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1714\" data-original=\"https://pic4.zhimg.com/v2-60a0055f7b5897454ea44047d6fbb1ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-60a0055f7b5897454ea44047d6fbb1ef_b.jpg\"/></figure><p>删除操作的话，如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p><p>如果我们不停的向跳表中插入元素，就可能会造成两个索引点之间的结点过多的情况。结点过多的话，我们建立索引的优势也就没有了。所以我们需要维护索引与原始链表的大小平衡，也就是结点增多了，索引也相应增加，避免出现两个索引之间结点过多的情况，查找效率降低。</p><p>跳表是通过一个随机函数来维护这个平衡的，当我们向跳表中插入数据的的时候，我们可以选择同时把这个数据插入到索引里，那我们插入到哪一级的索引呢，这就需要随机函数，来决定我们插入到哪一级的索引中。</p><p>这样可以很有效的防止跳表退化，而造成效率变低。</p><h3><b>跳表的代码实现</b></h3><p>最后我们来看一下跳变用代码怎么实现。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kn\">package</span> <span class=\"nn\">skiplist</span><span class=\"o\">;</span>\n\n<span class=\"kn\">import</span> <span class=\"nn\">java.util.Random</span><span class=\"o\">;</span>\n\n<span class=\"cm\">/**\n</span><span class=\"cm\"> * 跳表的一种实现方法。\n</span><span class=\"cm\"> * 跳表中存储的是正整数，并且存储的是不重复的。\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SkipList</span> <span class=\"o\">{</span>\n\n  <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">MAX_LEVEL</span> <span class=\"o\">=</span> <span class=\"n\">16</span><span class=\"o\">;</span>\n\n  <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">levelCount</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\n  <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">();</span>  <span class=\"c1\">// 带头链表\n</span><span class=\"c1\"></span>\n  <span class=\"kd\">private</span> <span class=\"n\">Random</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Random</span><span class=\"o\">();</span>\n\n  <span class=\"kd\">public</span> <span class=\"n\">Node</span> <span class=\"nf\">find</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">levelCount</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">==</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n      <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"n\">randomLevel</span><span class=\"o\">();</span>\n    <span class=\"n\">Node</span> <span class=\"n\">newNode</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">();</span>\n    <span class=\"n\">newNode</span><span class=\"o\">.</span><span class=\"na\">data</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"o\">;</span>\n    <span class=\"n\">newNode</span><span class=\"o\">.</span><span class=\"na\">maxLevel</span> <span class=\"o\">=</span> <span class=\"n\">level</span><span class=\"o\">;</span>\n    <span class=\"n\">Node</span> <span class=\"n\">update</span><span class=\"o\">[]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">[</span><span class=\"n\">level</span><span class=\"o\">];</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">level</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// record every level largest value which smaller than insert value in update[]\n</span><span class=\"c1\"></span>    <span class=\"n\">Node</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">level</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n      <span class=\"o\">}</span>\n      <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span><span class=\"c1\">// use update save node in search path\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// in search path node next node become new node forwords(next)\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">level</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">newNode</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n      <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">newNode</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// update node hight\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">levelCount</span> <span class=\"o\">&lt;</span> <span class=\"n\">level</span><span class=\"o\">)</span> <span class=\"n\">levelCount</span> <span class=\"o\">=</span> <span class=\"n\">level</span><span class=\"o\">;</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">delete</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span><span class=\"o\">[]</span> <span class=\"n\">update</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">[</span><span class=\"n\">levelCount</span><span class=\"o\">];</span>\n    <span class=\"n\">Node</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">levelCount</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n      <span class=\"o\">}</span>\n      <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">==</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">levelCount</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">data</span> <span class=\"o\">==</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n          <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">update</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"o\">}</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"c1\">// 随机 level 次，如果是奇数层数 +1，防止伪随机\n</span><span class=\"c1\"></span> <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">randomLevel</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">level</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">MAX_LEVEL</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span><span class=\"o\">.</span><span class=\"na\">nextInt</span><span class=\"o\">()</span> <span class=\"o\">%</span> <span class=\"n\">2</span> <span class=\"o\">==</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">level</span><span class=\"o\">++;</span>\n      <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">level</span><span class=\"o\">;</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">printAll</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">Node</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n      <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">+</span> <span class=\"s\">&#34; &#34;</span><span class=\"o\">);</span>\n      <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">.</span><span class=\"na\">forwards</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">();</span>\n  <span class=\"o\">}</span>\n\n  <span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Node</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">forwards</span><span class=\"o\">[]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Node</span><span class=\"o\">[</span><span class=\"n\">MAX_LEVEL</span><span class=\"o\">];</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">maxLevel</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"n\">String</span> <span class=\"nf\">toString</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n      <span class=\"n\">StringBuilder</span> <span class=\"n\">builder</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">StringBuilder</span><span class=\"o\">();</span>\n      <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"s\">&#34;{ data: &#34;</span><span class=\"o\">);</span>\n      <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">data</span><span class=\"o\">);</span>\n      <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"s\">&#34;; levels: &#34;</span><span class=\"o\">);</span>\n      <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"n\">maxLevel</span><span class=\"o\">);</span>\n      <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">append</span><span class=\"o\">(</span><span class=\"s\">&#34; }&#34;</span><span class=\"o\">);</span>\n\n      <span class=\"k\">return</span> <span class=\"n\">builder</span><span class=\"o\">.</span><span class=\"na\">toString</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n  <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><hr/><p>欢迎关注公众号：「努力给自己看」</p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "跳表", 
                    "tagLink": "https://api.zhihu.com/topics/19698527"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/66272812", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 0, 
            "title": "数据结构与算法系列——二分查找", 
            "content": "<h3>二分查找算法的简单介绍</h3><p>今天我们来学习一下二分查找算法，也叫做折半查找算法。使用二分查找算法的前提是数据需要是有序的。二分查找的思想非常简单，很容易理解，就是每次取中间位置的数和要找的数作比较，通过判断是大还是小来重新选择中间位置，直到找到。但是在实际的应用中却并不简单，因为我们实际碰到的问题不会像一个排好序的数组，然后让我们找出其中是不是包含某一个数这么简单。</p><h3>简单的例子</h3><p>我们在生活中也会经常遇到二分查找的使用，比如我们应该都玩过猜数字的游戏，我随便写一个 1 到 100 中间的数，然后你来猜我写的是多少，每次你猜之后我会告诉你是大了还是小了，直到你猜中为止。所有人都知道，我们每次都取中间数去猜，然后根据提示大了小了重新选择中间数，直到猜中。这样是速度最快的办法。这里我们用到的就是二分查找算法。</p><p>比如我写的数是 36，使用二分法的步骤就像下图展示的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4da0228ab593f727c7baf1690211450c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1628\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb\" width=\"1628\" data-original=\"https://pic1.zhimg.com/v2-4da0228ab593f727c7baf1690211450c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1628&#39; height=&#39;634&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1628\" data-rawheight=\"634\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1628\" data-original=\"https://pic1.zhimg.com/v2-4da0228ab593f727c7baf1690211450c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4da0228ab593f727c7baf1690211450c_b.jpg\"/></figure><p>7 次就猜出来我写的数，还是很快的是吧。那如果最开始的范围是 1-1000 或者 1-10000 甚至更大的范围需要多少次呢？感兴趣的可以自己试试。</p><h3>时间复杂度</h3><p>我们通过上边简单的例子也了解了二分查找算法的原理和思想，下面我们来分析一下二分查找算法的时间复杂的。</p><p>我们假设数据的大小为 n，每次查找后数据都会变为原来的一半，也就是 n/2，然后直到找到最后要找的值，最坏的情况就是数据中没有我们要找的值，直到查找区间被缩小为空，才停止。</p><p>查找区间的大小变化：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a303951dbdfea15ec7ee21dfc7b89811_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1634\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb\" width=\"1634\" data-original=\"https://pic2.zhimg.com/v2-a303951dbdfea15ec7ee21dfc7b89811_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1634&#39; height=&#39;564&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1634\" data-rawheight=\"564\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1634\" data-original=\"https://pic2.zhimg.com/v2-a303951dbdfea15ec7ee21dfc7b89811_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a303951dbdfea15ec7ee21dfc7b89811_b.jpg\"/></figure><p>最坏的情况就是 n/2^k = 1 的时候，k 就是总共缩小的次数，每次缩小我们只需要比较两个数的大小，所以，一共有 k 次比较，时间复杂度为 O(k)。 通过 n/2^k = 1，我们可以求得 k = log2(n)，所以最后的时间复杂度为O(logn)。</p><p>我们在深入的了解一下 O(logn) 这种时间复杂度。我们首先来看一下 logn 的函数的数学图像。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-20422b318ec85533e2f0789839bf5294_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"856\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-20422b318ec85533e2f0789839bf5294_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;856&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"856\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic1.zhimg.com/v2-20422b318ec85533e2f0789839bf5294_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-20422b318ec85533e2f0789839bf5294_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-8117bb1f2dab05250c5c181a4c0353fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"827\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-8117bb1f2dab05250c5c181a4c0353fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;827&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"827\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-8117bb1f2dab05250c5c181a4c0353fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-8117bb1f2dab05250c5c181a4c0353fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>图1中横坐标的值是从 -1024 到 1024 ，而 y 的值最大也不过才是 10。 图2中横坐标的值时从 -4294967296 到 4294967296，也就是 -2^32 到 2^32 ，y 的最大值是 32 ，可见 x 都大到了四十多亿了，y 的值不过才32。可见二分查找在数据量是如此巨大的时候查找的次数也不过才几十次。所以说二分查找算法是非常高效的。</p><h3>代码实现</h3><p>我们已经了解了二分法的思想和查找过程。下面通过具体的代码来实现二分查找算法。 最简单的情况是<b>已经排好序的没有重复元素的数组</b>，然后我们找出数组中有没有与给定值相等的元素。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">BinarySearch</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">array</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">){</span>\n    <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">low</span><span class=\"o\">&lt;=</span><span class=\"n\">high</span><span class=\"o\">){</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">){</span>\n            <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">array</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">){</span>\n            <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">else</span><span class=\"o\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>当然，我们上边只是最简单一种情况，下面我们稍微增加一点难度。如果数组中有重复的元素的话。我们算法该怎么写呢？ + 查找第一个值等于给定值的元素</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">BinarySearch</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span>  <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">((</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">mid</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">value</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n          <span class=\"k\">else</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>我们判断 array[mid] 与给定值大小关系有大于小于和等于，当大于或小于的时候和最简单没有重复元素时候一样，只需要更新 high 和 low 的值就协议了。但当等于的时候，我们不能立马返回，因为我们不知道这个是不是第一个等于给定值的元素。所以我们要判断，如果 mid 等于 0 的话，是数组的第一个元素，那么肯定是第一个等于给定值的；如果 mid 不等于 0 ，我们查看前一个元素 array[mid-1] 的值如果不等于 value，那么 array[mid] 就是第一个等于 value 的值，如果前一个元素等于 value 的话，我们需要更新 high 的值，因为要找的元素肯定在 [low, mid-1]之间。 + 查找最后一个值等于给定值的元素   上边我们求得是第一个等于给定值的元素，这次我们来找最后一个。只需要将上边的代码稍微改动一下就可以了</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">bsearch</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span>  <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">((</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">mid</span> <span class=\"o\">==</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"n\">value</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>参照上边查找第一个等于给定值的讲解，这个也就很容易理解了。 + 查找第一个大于等于给定值的元素   在数组中，查找第一个大于等于给定值的元素，比如数组 [1,4,4,5,7,9]，查找第一个大于等于 6 的元素，那就是 7。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">bsearch</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span>  <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">((</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;=</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">mid</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">value</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>这个和第一个等于给定值的情况多了大于的条件，所以我们只需要把原来的等于的情况和大于的情况和到一起来判断就可以了 + 查找最后一个小于等于给定值的元素</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">bsearch7</span><span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">low</span> <span class=\"o\">&lt;=</span> <span class=\"n\">high</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span>  <span class=\"n\">low</span> <span class=\"o\">+</span> <span class=\"o\">((</span><span class=\"n\">high</span> <span class=\"o\">-</span> <span class=\"n\">low</span><span class=\"o\">)</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">1</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">high</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">mid</span> <span class=\"o\">==</span> <span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">value</span><span class=\"o\">))</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"o\">;</span>\n            <span class=\"k\">else</span> <span class=\"n\">low</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n    <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>有了上边的做铺垫，这个应该很容易就理解了。这里就不做过多解释了。</p><h3>总结一下</h3><p>通过上边我们的代码的实例，总结出我们写二分查找算法时候需要注意的几个地方。 </p><p>1、终止条件的正确性</p><p>2、区间上下界的更新 </p><p>3、返回值的选择 </p><p>这几个条件后，我们写的算法应该就不容易有 bug 了。 虽然二分查找非常的简单高效，但也有它的局限性。 </p><ul><li>数据结构必须有序 二分查找要求数据是有序的，这样我们才能使用二分查找。</li><li>依赖的是顺序表结构 也就是数组，因为二分查找是通过下标来访问元素的，如果是链表的话，二分查找的时间复杂度就非常高了。</li><li>数据太小不适合 如果数据量很小，完全没必要使用二分法了，顺序遍历比较就可以了。</li><li>数据太大不适合 你上边不是说了二分法很适合用在大数据量的查找吗，而且越大的数据量越能体现二分查找算法的高效吗。为什么又不适合了呢。因为二分查找依赖于想数组这样的顺序表结构，而这种结构为了提供随机访问，要就内存空间是连续的。 也就是如果我们要处理 10G 的数据，我们需要 10G 的连续的内存空间，如果你内存还有很多，可都是不连续的，分散的，同样不能使用二分查找。</li></ul><hr/><p>欢迎关注公众号：「努力给自己看」</p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62327842", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 1, 
            "title": "数据结构与算法系列——递归", 
            "content": "<h3><b>递归的理解</b></h3><p>在学习数据结构和算法的过程中，递归可能是比较难理解的一个知识点，每次都试着用自己的大脑去把一步一步去想清楚，结果最后把自己都绕晕了。</p><p>我们很多人都遇到过这种情况，读源码的时候，我们想弄清楚一个方法的具体实现，然后跟进去发现里边还有一个方法，然后我们又跟到新的方法里边，结果发现里边还有另一个新的方法……这样跟了一层又一层，终于到了最后一层没有再调用其他的方法，然后我们再一层一层返回去，最终弄明白了最初想了解的方法的作用（实际中这种方式是不推荐的，因为嵌套很多层，最后搞得头都大了，却忘记了最初是要干什么）。其实这就是一个递归的过程，通过一层一层的去了解方法的作用，然后到最后再一层一层返回去，明白最初方法的作用。</p><p>到这里，我想大家其实对递归也有一定了解了。其实递归就是可以把原来一个大型复杂的任务，分解成一个或几个与原任务有相类似求解方法的小任务，然后最后有一个终止条件。</p><h3><b>递归的条件</b></h3><p>由此我们可以总结出几个使用递归需要满足的条件：</p><ul><li>一个问题可以分解为一个或几个子问题</li><li>子问题和原来问题的求解方式相同，只是规模比原问题小</li><li>存在终止条件，否则会变成无限循环</li></ul><h3><b>举一个例子</b></h3><p>前几天刷剑指offer题库，碰到了好多题都可以用递归的方法计算。比如其中一个经典的跳台阶问题。</p><h3><b>题目描述</b></h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3><b>解题思路</b></h3><p>每次跳台阶都有两个选择，要么跳1级，要么跳2级。只有1级台阶的时候只有跳1级1种跳法，有2级时有每次1级1级跳两次和直接跳2级两种跳法，当有3级台阶的时候，我们可以从第2级跳1级到第3级，也可以从第1级跳2级到第3级，所以3级台阶的总跳法，就是1级台阶的总跳法和2级台阶的总跳法的总和，由此我们就发现了一个规律从3级之后的算法为 f(n)=f(n-1)+f(n-2)，发现我们要求得结果符合<b>斐波那契数列</b>。所以我们想知道 n 级台阶总共有多少跳法，只要将 n-1 的跳法加上 n-2 的跳法就可以了。</p><h3><b>代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">JumpFloor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">&lt;</span><span class=\"n\">3</span><span class=\"o\">){</span>\n            <span class=\"k\">return</span> <span class=\"n\">target</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">JumpFloor</span><span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">JumpFloor</span><span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3><b>怎么使用递归</b></h3><p>我们现在也对递归有一定的了解了，那递归该怎么用呢？其实在上边例子中其实已经给出了答案。首先，我们要通过规律推导出递归的公式，然后找到递归的终止条件，然后把公式转化为代码就很容易了。就比如上边例子中的解题思路中就是这一过程的实现。</p><p>有人觉得递归难以理解，可能是走入误区，就像我一开始举得读源码的例子。一定要在脑子里把递归展开，一层一层去调用，然后一层层的返回，试图去弄明白每一个过程，这其实就有点钻牛角尖了，尤其是当一个问题分解成好几个子问题，然后嵌套层数比较多的时候，我们的大脑是没办法把每一个过程都能想出来的。相反计算机却很擅长这种重复的事情，所以我们没必要在大脑中去分解每一个步骤，我们只需要找到规律公式和终止条件，剩下的交给计算就行了。</p><h3><b>使用递归需要注意</b></h3><p>在实际程序设计的时候，我们使用递归的时候要注意几个问题。</p><h3><b>栈溢出问题</b></h3><p>我们都知道函数调用时会用栈来保存临时变量，每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行结束才出栈。一般系统栈和虚拟机栈都不是很大，当递归嵌套的次数较多的时候，就会有栈溢出的风险。</p><p>所以如果递归的次数比较小的时候我们可以考虑使用递归，否则我们就要考虑其他的方法。</p><h3><b>重复计算问题</b></h3><p>还是以跳台阶的例子来说明，假如我们要计算 5 级台阶有多少种跳法，我们用我们推导出来公式来计算，f(5)=f(4)+f(3)，然后我们分别要求 f(4)=f(3)+f(2)，f(3)=f(2)+f(1)，我们可以看到在求解 f(5) 的时候我们计算过 f(3)，而在计算 f(4) 的时候我们又计算了一遍 f(3)，同样 f(2) 也被计算了多次，这就是重复计算的问题。</p><p>我们可以用散列表来储存已经计算过的 f(n)，然后在每次计算的时候先去散列表里查有没有被计算过，如果有那么直接使用；如果没有那把计算后的值存到散列表中，这样就能避免重复计算的问题。</p><p>我们按这个办法修改一下上边例子的代码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Solution</span> <span class=\"o\">{</span>\n    <span class=\"n\">Map</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;</span> <span class=\"n\">resultMap</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">HashMap</span><span class=\"o\">&lt;</span><span class=\"n\">Integer</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">&gt;();</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">JumpFloor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">&lt;</span> <span class=\"n\">3</span><span class=\"o\">){</span>\n            <span class=\"k\">return</span> <span class=\"n\">target</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">resultMap</span><span class=\"o\">.</span><span class=\"na\">containsKey</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">)){</span>\n            <span class=\"k\">return</span> <span class=\"n\">resultMap</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">JumpFloor</span><span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">+</span> <span class=\"n\">JumpFloor</span><span class=\"o\">(</span><span class=\"n\">target</span> <span class=\"o\">-</span> <span class=\"n\">2</span><span class=\"o\">);</span>\n        <span class=\"n\">resultMap</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"n\">target</span><span class=\"o\">,</span> <span class=\"n\">result</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3><b>效率问题</b></h3><p>由于多层递归的嵌套，所以会多次调用函数，当次数达到一定数量的时候，就会有很高的时间成本。在空间复杂度上，因为递归每调用一次就会在栈中保存一次现场数据，所以每次都要产生这种额外的开销。</p><p>所以，虽然递归的代码看上去非常简洁，但是也会有很多问题，我们在实际使用的时候一定要注意递归可能会带来的问题。</p>", 
            "topic": [
                {
                    "tag": "递归", 
                    "tagLink": "https://api.zhihu.com/topics/19631498"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60919709", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 1, 
            "title": "数据结构与算法系列——队列", 
            "content": "<h3><b>什么是队列</b></h3><p>队列也是一种操作受限制的线性表，只允许在表的前端进行删除，也就是出队，而在表的后端进行插入，即入队。</p><p>举一个生活中常见的例子，我们经常会遇到排队办事，先来的排在前边先办理，后来的排在后边，不允许插队。<b>先进先出</b>，这就是典型的队列。</p><h3><b>队列的实现</b></h3><p>队列的概念很容易理解，操作也比较简单，很容易掌握。</p><p>跟栈一样，队列也能用数组和链表来实现，用数组实现的队列叫顺序队列，用链表实现的队列叫链式队列。</p><p>下面我们先来看一下用数组的实现方式。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ArrayQueue {\n    private String[] items;\n    private int n = 0;\n    private int head = 0;\n    private int tail = 0;\n\n    public ArrayQueue(int n){\n        items = new String[n];\n        this.n = n;\n    }\n\n    public boolean Enqueue(String item){\n        if(tail == n){\n            return false;\n        }\n        items[tail++] = item;\n        return true;\n    }\n\n    public String Dequeue(){\n        if(head == tail){\n            return null;\n        }\n        String item = items[head++];\n        return item;\n    }\n}\n</code></pre></div><p>队列的数组实现比栈的实现稍微复杂一点点，队列需要两个指针，一个指向队头的 head 指针，一个指向队尾的 tail 指针。同样老办法，我们用画图来更清楚的了解一下这个过程。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5d3b3e05a99af80eaf55ec96ca5fc57b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"306\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-5d3b3e05a99af80eaf55ec96ca5fc57b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;306&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"306\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic4.zhimg.com/v2-5d3b3e05a99af80eaf55ec96ca5fc57b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5d3b3e05a99af80eaf55ec96ca5fc57b_b.jpg\"/></figure><p>如果这个时候我们调用一次出队，那么 head 指针就指向 1 的位置，并把 0 的位置的元素移除出队。如图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9a902598e256188a3af73c14c861e880_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic1.zhimg.com/v2-9a902598e256188a3af73c14c861e880_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic1.zhimg.com/v2-9a902598e256188a3af73c14c861e880_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9a902598e256188a3af73c14c861e880_b.jpg\"/></figure><p>如果这个时候插入一个新的元素，那么 tail 指针就指向 5 的位置，然后把新的元素放到 4 的位置。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1a54b6ca52e105dda89044f7a212fa2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic2.zhimg.com/v2-1a54b6ca52e105dda89044f7a212fa2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic2.zhimg.com/v2-1a54b6ca52e105dda89044f7a212fa2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1a54b6ca52e105dda89044f7a212fa2d_b.jpg\"/></figure><p>我们通过图可以看到，这种实现方法有一个缺点，那就是随着我们不断的入队操作，等到 tail 指向最后一位的时候就没有办法接受新的元素入队了，即使前边有空闲的空间没有元素。所以我们来优化一下我们的代码，当 tail 等于数组的长度 n 的时候，这个时候如果再有新的元素入队，我们就看数组前边是不是有空闲的空间，如果有我们就把队列的元素整体向前移动几个单位。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ArrayQueue {\n    private String[] items;\n    private int n = 0;\n    private int head = 0;\n    private int tail = 0;\n\n    public ArrayQueue(int n){\n        items = new String[n];\n        this.n = n;\n    }\n\n    public boolean Enqueue(String item){\n        if(tail == n){\n            if(head == 0){\n                return false;\n            }\n            for (int i = head; i&lt;tail;i++){\n                items[i-head] = items[I];\n            }\n            tail -= head;\n            head = 0;\n        }\n        items[tail++] = item;\n        return true;\n    }\n\n    public String Dequeue(){\n        if(head == tail){\n            return null;\n        }\n        String item = items[head++];\n        return item;\n    }\n}\n</code></pre></div><p>老办法，画图来展示这一过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9296bc2621dbcd131a15a80c2f0f7e7f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"894\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb\" width=\"894\" data-original=\"https://pic4.zhimg.com/v2-9296bc2621dbcd131a15a80c2f0f7e7f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;894&#39; height=&#39;700&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"894\" data-rawheight=\"700\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"894\" data-original=\"https://pic4.zhimg.com/v2-9296bc2621dbcd131a15a80c2f0f7e7f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9296bc2621dbcd131a15a80c2f0f7e7f_b.jpg\"/></figure><p>这样就不会有空间的浪费了，但是还有个问题就是数组不能动态扩展，数组满了之后就不能再入队新的元素了，我们来再来修改一下让数组支持动态扩展。当数组满了的时候我们重新申请一个新的数组，长度为原数组的两倍，然后把原数组的元素移到新数组里，然后再进行入队操作。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ArrayQueue {\n    private String[] items;\n    private int n = 0;\n    private int head = 0;\n    private int tail = 0;\n    private String[] newItems;\n\n    public ArrayQueue(int n){\n        items = new String[n];\n        this.n = n;\n    }\n\n    public boolean Enqueue(String item){\n        if(tail == n){\n            if(head == 0){\n                newItems = new String[2*n];\n                for (int i=0;i&lt;tail;i++){\n                    newItems[i] = items[I];\n                }\n                items = newItems;\n            }else {\n                for (int i = head; i &lt; tail; i++) {\n                    items[i - head] = items[I];\n                }\n                tail -= head;\n                head = 0;\n            }\n        }\n        items[tail++] = item;\n        return true;\n    }\n\n    public String Dequeue(){\n        if(head == tail){\n            return null;\n        }\n        String item = items[head++];\n        return item;\n    }\n}\n</code></pre></div><p>同样，上图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2451dec1179d29c6b2a776742b1b100e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-2451dec1179d29c6b2a776742b1b100e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;776&#39; height=&#39;588&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"776\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"776\" data-original=\"https://pic3.zhimg.com/v2-2451dec1179d29c6b2a776742b1b100e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2451dec1179d29c6b2a776742b1b100e_b.jpg\"/></figure><p>还有一种特殊的数组实现是循环队列，当 tail == n 的时候我们不迁移数组的元素，而是去看数组下标为 0 的位置为不为空，如果为空的话我们直接入队新的元素，tail 就等于 1 。我们来看一下代码实现。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class CycleArrayQueue {\n    private String[] items;\n    private int n;\n    private int head = 0;\n    private int tail = 0;\n\n    public CycleArrayQueue(int n){\n        items = new String[n];\n        this.n = n;\n    }\n\n    public boolean Enqueue(String item){\n        //数组满了\n        if((tail+1)%n == head)\n            return false;\n\n        items[tail] = item;\n        tail = (tail+1)%n;\n        return true;\n    }\n\n    public String Dequeue(){\n        if(head == tail) return null;\n        String str = items[head];\n        head = (head+1)%n;\n        return str;\n    }\n}\n</code></pre></div><p>下边我们来看一下队列的链表实现，同样我们需要两个指针，head 指向链表第一个结点，tail 指向链表最后一个结点。入队时 tail-&gt;next=new_node，tail=tail-&gt;next。出队时 head=head-&gt;next。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class ListNodeQueue {\n\n    private ListNode head;\n    private ListNode tail;\n\n    public void Enqueue(String val){\n        ListNode node = new ListNode(val, null);\n        if(tail == null){\n            head = node;\n            tail = node;\n        }else {\n            tail.next = node;\n            tail = tail.next;\n        }\n    }\n\n    public String Dequeue(){\n        if(head == null){\n            return null;\n        }\n        String string = head.val;\n        head = head.next;\n        if(head == null){\n            tail = null;\n        }\n        return string;\n    }\n\n    class ListNode{\n        private String val;\n        private ListNode next;\n\n        public ListNode(String x, ListNode next) {\n            val = x;\n            this.next = next;\n        }\n\n        public String GetValue() {\n            return val;\n        }\n    }\n}\n</code></pre></div><h3><b>队列的应用</b></h3><p>前边将的都是一些基本的理论知识，那队列在实际的项目中都在什么情况下使用呢？阻塞队列和并发队列应用的比较广泛。</p><ul><li>阻塞队列<br/>阻塞队列实际就是在队列的基础上加上了阻塞操作，当队列为空时，出队操作就会被阻塞，因为队列里没有数据，直到队列里有数据之后才能返回；当队列满的时候，入队操作就会被阻塞，直到队列中有空闲的空间时再执行入队操作。<br/>我们可以用阻塞队列很容易的实现一个”生产者-消费者“模型，这样我们可以有效的控制生产和消费的速度。当生产者生产的过快时，队列很快就满了，这个时候生产者就阻塞等待，直到消费者消费了，生产者才会被唤醒继续生产。反之消费者消费过快时也同样被阻塞。不仅如此，我们还可以通过调整生产者和消费者的个数，来实现生产和消费的供需平衡。</li><li>并发队列<br/>在多线程应用中，多个线程同时操作队列，就会存在线程安全问题，处理这个问题的队列我们称为并发队列。最简答的方法就是在入队和出队的时候加锁，保证同时只有一个线程执行队列的入队或出队，但是这样以来就会大大降低线程的并发度。<br/>我们可以用上边提到的数组实现的循环队列来解决这个问题，利用 CAS 的原子操作，可以实现非常高效的并发队列。因此，循环队列比链式队列应用的更为广泛。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "队列（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20204697"
                }
            ], 
            "comments": [
                {
                    "userName": "不要做积极的废人", 
                    "userLink": "https://www.zhihu.com/people/a72c0aed5fb02e2d0ee6860052f89dcb", 
                    "content": "棒棒", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60152722", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 6, 
            "title": "数据结构与算法系列--十大排序（附动态图解）", 
            "content": "<blockquote> 本文转自公众号 「程序员私房菜 」<br/> </blockquote><p>一直有写一篇关于排序算法文章的打算，直到我看到了这一篇，我放弃了自己写的打算，因为这篇写的太经典了。这里强烈推荐给大家。</p><hr/><p>之前的一篇 <a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAwMjk5Mjk3Mw%3D%3D%26mid%3D2247484373%26idx%3D1%26sn%3Da0ed7fa40b63eb7c5282ebe9c361b612%26chksm%3D9ac0bdf7adb734e10224a0da460d6528f45473815a12be5701e04af7eb063206259ad572ebc3%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">几张动态图清晰展示常用数据结构及其设计原理</a> 发出来之后反响不错，这次来个<b>动图排序算法大全</b>。数据结构与算法，算是齐了！</p><p><b>本文将采取动态图 + 文字描述 + Java代码实现来讲解以下十大排序算法：</b></p><ol><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>希尔排序</li><li>归并排序</li><li>快速排序</li><li>堆排序</li><li>计数排序</li><li>桶排序</li><li>基数排序</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;528&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_b.jpg\"/></figure><h3><b>0、排序算法说明</b></h3><h3><b>0.1 排序的定义</b></h3><p>对一序列对象根据某个关键字进行排序。</p><p><b>0.2 术语说明</b></p><ul><li><b>稳定</b>：如果a原本在b前面，而a=b，排序之后a仍然在b的前面；</li><li><b>不稳定</b>：如果a原本在b的前面，而a=b，排序之后a可能会出现在b的后面；</li><li><b>内排序</b>：所有排序操作都在内存中完成；</li><li><b>外排序</b>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li><b>时间复杂度：</b> 一个算法执行所耗费的时间。</li><li><b>空间复杂度</b>：运行完一个程序所需内存的大小。</li></ul><h3><b>0.3 算法总结（这张图值得你收藏）</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1a48925406e65655a6c42bcfa28df1cb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"966\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb\" width=\"966\" data-original=\"https://pic4.zhimg.com/v2-1a48925406e65655a6c42bcfa28df1cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;966&#39; height=&#39;588&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"966\" data-rawheight=\"588\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"966\" data-original=\"https://pic4.zhimg.com/v2-1a48925406e65655a6c42bcfa28df1cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1a48925406e65655a6c42bcfa28df1cb_b.jpg\"/></figure><p><b>0.4 图片名词解释：</b></p><ul><li>n: 数据规模</li><li>k: “桶”的个数</li><li>In-place: 占用常数内存，不占用额外内存</li><li>Out-place: 占用额外内存</li></ul><h3><b>0.5 算法分类</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;528&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"528\" data-original=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-209ed2792ef3525714f6d6023a6b4380_b.jpg\"/></figure><h3><b>0.6 比较和非比较的区别</b></h3><p>常见的<b>快速排序、归并排序、堆排序、冒泡排序</b>等属于<b>比较排序</b>。<b>在排序的最终结果里，元素之间的次序依赖于它们之间的比较。每个数都必须和其他数进行比较，才能确定自己的位置。</b></p><p>在<b>冒泡排序</b>之类的排序中，问题规模为n，又因为需要比较n次，所以平均时间复杂度为O(n²)。在<b>归并排序、快速排序</b>之类的排序中，问题规模通过<b>分治法</b>消减为logN次，所以时间复杂度平均<b>O(nlogn)</b>。<br/>比较排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，<b>比较排序适用于一切需要排序的情况。</b></p><p><b>计数排序、基数排序、桶排序</b>则属于<b>非比较排序</b>。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。<br/>非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度<b>O(n)</b>。<br/><b>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</b></p><hr/><p>1、冒泡排序（Bubble Sort）</p><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 </p><h3><b>1.1 算法描述</b></h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤1~3，直到排序完成。</li></ul><p><b>1.2 动图演示</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"257\" data-thumbnail=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;826&#39; height=&#39;257&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"826\" data-rawheight=\"257\" data-thumbnail=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"826\" data-original=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-33a947c71ad62b254cab62e5364d2813_b.gif\"/></figure><h3><b>1.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 冒泡排序\n 3*\n 4* @param array\n 5* @return\n 6*/\n 7public static int[] bubbleSort(int[] array) {\n 8   if (array.length == 0)\n 9       return array;\n10   for (int i = 0; i &lt; array.length; i++)\n11       for (int j = 0; j &lt; array.length - 1 - i; j++)\n12           if (array[j + 1] &lt; array[j]) {\n13               int temp = array[j + 1];\n14               array[j + 1] = array[j];\n15               array[j] = temp;\n16           }\n17   return array;\n18}\n</code></pre></div><h3><b>这段代码还可以继续优化哦，具体可以看这篇文章：<a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAwMjk5Mjk3Mw%3D%3D%26mid%3D2247484405%26idx%3D1%26sn%3Dcb1746c407d8db9ec3c7ee32c6fbbf09%26chksm%3D9ac0bdd7adb734c1d58d03ad2099e4732488f69be635eb7651f5c87c0054b6589b85f713f0f3%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">美团面试，我竟然输给了冒泡排序。。。</a></b></h3><h3><b>1.4 算法分析</b></h3><p><b>最佳情况：T(n) = O(n)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(n2)</b></p><h3><b>2、选择排序（Selection Sort）</b></h3><p>表现<b>最稳定的排序算法之一</b>，因为<b>无论什么数据进去都是O(n2)的时间复杂度</b>，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 </p><h3><b>2.1 算法描述</b></h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为R[1..n]，有序区为空；</li><li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>n-1趟结束，数组有序化了。</li></ul><h3><b>2.2 动图演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"248\" data-thumbnail=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;248&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"248\" data-thumbnail=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c7e20f306ddc02eb4e3a50fa7817ff4_b.gif\"/></figure><p>2.3 代码实现</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 选择排序\n 3* @param array\n 4* @return\n 5*/\n 6public static int[] selectionSort(int[] array) {\n 7   if (array.length == 0)\n 8       return array;\n 9   for (int i = 0; i &lt; array.length; i++) {\n10       int minIndex = i;\n11       for (int j = i; j &lt; array.length; j++) {\n12           if (array[j] &lt; array[minIndex]) //找到最小的数\n13               minIndex = j; //将最小数的索引保存\n14       }\n15       int temp = array[minIndex];\n16       array[minIndex] = array[i];\n17       array[i] = temp;\n18   }\n19   return array;\n20}\n</code></pre></div><h3><b>2.4 算法分析</b></h3><p><b>最佳情况：T(n) = O(n2)  最差情况：T(n) = O(n2)  平均情况：T(n) = O(n2)</b></p><h3><b>3、插入排序（Insertion Sort）</b></h3><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h3><b>3.1 算法描述</b></h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ul><h3><b>3.2 动图演示</b></h3><p>1<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-32e2ede9287f7da530f1821b88ce0157_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"180\" data-thumbnail=\"https://pic4.zhimg.com/v2-32e2ede9287f7da530f1821b88ce0157_b.jpg\" class=\"content_image\" width=\"300\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;300&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"300\" data-rawheight=\"180\" data-thumbnail=\"https://pic4.zhimg.com/v2-32e2ede9287f7da530f1821b88ce0157_b.jpg\" class=\"content_image lazy\" width=\"300\" data-actualsrc=\"https://pic4.zhimg.com/v2-32e2ede9287f7da530f1821b88ce0157_b.gif\"/></figure><p>2.更直观点</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-91b76e8e4dab9b0cad9a017d7dd431e2_b.gif\"/></figure><h3><b>3.2 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 插入排序\n 3* @param array\n 4* @return\n 5*/\n 6public static int[] insertionSort(int[] array) {\n 7   if (array.length == 0)\n 8       return array;\n 9   int current;\n10   for (int i = 0; i &lt; array.length - 1; i++) {\n11       current = array[i + 1];\n12       int preIndex = i;\n13       while (preIndex &gt;= 0 &amp;&amp; current &lt; array[preIndex]) {\n14           array[preIndex + 1] = array[preIndex];\n15           preIndex--;\n16       }\n17       array[preIndex + 1] = current;\n18   }\n19   return array;\n20}\n</code></pre></div><p>3.4 <b>算法分析</b></p><p><b>最佳情况：T(n) = O(n)   最坏情况：T(n) = O(n2)   平均情况：T(n) = O(n2)</b></p><h3><b>4、希尔排序（Shell Sort）</b></h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p><p><b>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</b></p><h3><b>4.1 算法描述</b></h3><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，<b>{n/2,(n/2)/2…1}</b>，称为<b>增量序列</b>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3><b>4.2.1 动图演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3762149d65540cf3e61b5dfaace6dc7b_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"277\" data-rawheight=\"344\" data-thumbnail=\"https://pic4.zhimg.com/v2-3762149d65540cf3e61b5dfaace6dc7b_b.jpg\" class=\"content_image\" width=\"277\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;277&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"277\" data-rawheight=\"344\" data-thumbnail=\"https://pic4.zhimg.com/v2-3762149d65540cf3e61b5dfaace6dc7b_b.jpg\" class=\"content_image lazy\" width=\"277\" data-actualsrc=\"https://pic4.zhimg.com/v2-3762149d65540cf3e61b5dfaace6dc7b_b.gif\"/></figure><h3><b>4.2.2 过程演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9c0b7cda43bb32c4c206d545a3409c80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1126\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9c0b7cda43bb32c4c206d545a3409c80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic1.zhimg.com/v2-9c0b7cda43bb32c4c206d545a3409c80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9c0b7cda43bb32c4c206d545a3409c80_b.jpg\"/></figure><h3><b>4.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 希尔排序\n 3*\n 4* @param array\n 5* @return\n 6*/\n 7public static int[] ShellSort(int[] array) {\n 8   int len = array.length;\n 9   int temp, gap = len / 2;\n10   while (gap &gt; 0) {\n11       for (int i = gap; i &lt; len; i++) {\n12           temp = array[i];\n13           int preIndex = i - gap;\n14           while (preIndex &gt;= 0 &amp;&amp; array[preIndex] &gt; temp) {\n15               array[preIndex + gap] = array[preIndex];\n16               preIndex -= gap;\n17           }\n18           array[preIndex + gap] = temp;\n19       }\n20       gap /= 2;\n21   }\n22   return array;\n23}\n</code></pre></div><h3><b>4.4 算法分析</b></h3><p>**最佳情况：T(n) = O(nlog2 n)  最坏情况：T(n) = O(nlog2 n)  平均情况：T(n) =O(nlog2n)　**</p><h3><b>5、归并排序（Merge Sort）</b></h3><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是O(n log n）的时间复杂度。代价是需要额外的内存空间。</p><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。 </p><h3><b>5.1 算法描述</b></h3><ul><li>把长度为n的输入序列分成两个长度为n/2的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3><b>5.2 动图演示</b></h3><p>1</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-aadc14e74a64a3c53b16d09117561ec8_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"237\" data-thumbnail=\"https://pic1.zhimg.com/v2-aadc14e74a64a3c53b16d09117561ec8_b.jpg\" class=\"content_image\" width=\"280\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;280&#39; height=&#39;237&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"237\" data-thumbnail=\"https://pic1.zhimg.com/v2-aadc14e74a64a3c53b16d09117561ec8_b.jpg\" class=\"content_image lazy\" width=\"280\" data-actualsrc=\"https://pic1.zhimg.com/v2-aadc14e74a64a3c53b16d09117561ec8_b.gif\"/></figure><p>2</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;505&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"505\" data-thumbnail=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cdda3f11c6efbc01577f5c29a9066772_b.gif\"/></figure><h3><b>5.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 归并排序\n 3*\n 4* @param array\n 5* @return\n 6*/\n 7public static int[] MergeSort(int[] array) {\n 8   if (array.length &lt; 2) return array;\n 9   int mid = array.length / 2;\n10   int[] left = Arrays.copyOfRange(array, 0, mid);\n11   int[] right = Arrays.copyOfRange(array, mid, array.length);\n12   return merge(MergeSort(left), MergeSort(right));\n13}\n14/**\n15* 归并排序——将两段排序好的数组结合成一个排序数组\n16*\n17* @param left\n18* @param right\n19* @return\n20*/\n21public static int[] merge(int[] left, int[] right) {\n22   int[] result = new int[left.length + right.length];\n23   for (int index = 0, i = 0, j = 0; index &lt; result.length; index++) {\n24       if (i &gt;= left.length)\n25           result[index] = right[j++];\n26       else if (j &gt;= right.length)\n27           result[index] = left[i++];\n28       else if (left[i] &gt; right[j])\n29           result[index] = right[j++];\n30       else\n31           result[index] = left[i++];\n32   }\n33   return result;\n34}\n</code></pre></div><h3><b>5. 4 算法分析</b></h3><p><b>最佳情况：T(n) = O(n)  最差情况：T(n) = O(nlogn)  平均情况：T(n) = O(nlogn)</b></p><h3><b>6、快速排序（Quick Sort）</b></h3><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h3><b>6.1 算法描述</b></h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<b>pivot</b>）；</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3><b>6.2 动图演示</b></h3><p>1 欢快点的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"214\" data-thumbnail=\"https://pic2.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_b.jpg\" class=\"content_image\" width=\"280\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;280&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"214\" data-thumbnail=\"https://pic2.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_b.jpg\" class=\"content_image lazy\" width=\"280\" data-actualsrc=\"https://pic2.zhimg.com/v2-d4e5d0a778dba725091d8317e6bac939_b.gif\"/></figure><p>2 正经点的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"252\" data-thumbnail=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;811&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"811\" data-rawheight=\"252\" data-thumbnail=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"811\" data-original=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c411339b79f92499dcb7b5f304c826f4_b.gif\"/></figure><h3><b>6.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 快速排序方法\n 3* @param array\n 4* @param start\n 5* @param end\n 6* @return\n 7*/\n 8public static int[] QuickSort(int[] array, int start, int end) {\n 9   if (array.length &lt; 1 || start &lt; 0 || end &gt;= array.length || start &gt; end) return null;\n10   int smallIndex = partition(array, start, end);\n11   if (smallIndex &gt; start)\n12       QuickSort(array, start, smallIndex - 1);\n13   if (smallIndex &lt; end)\n14       QuickSort(array, smallIndex + 1, end);\n15   return array;\n16}\n17/**\n18* 快速排序算法——partition\n19* @param array\n20* @param start\n21* @param end\n22* @return\n23*/\n24public static int partition(int[] array, int start, int end) {\n25   int pivot = (int) (start + Math.random() * (end - start + 1));\n26   int smallIndex = start - 1;\n27   swap(array, pivot, end);\n28   for (int i = start; i &lt;= end; i++)\n29       if (array[i] &lt;= array[end]) {\n30           smallIndex++;\n31           if (i &gt; smallIndex)\n32               swap(array, i, smallIndex);\n33       }\n34   return smallIndex;\n35}\n36\n37/**\n38* 交换数组内两个元素\n39* @param array\n40* @param i\n41* @param j\n42*/\n43public static void swap(int[] array, int i, int j) {\n44   int temp = array[i];\n45   array[i] = array[j];\n46   array[j] = temp;\n47}\n</code></pre></div><h3><b>6.4 算法分析</b></h3><p>**最佳情况：T(n) = O(nlogn)   最差情况：T(n) = O(n2)   平均情况：T(n) = O(nlogn)　**</p><h3><b>7、堆排序（Heap Sort）</b></h3><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3><b>7.1 算法描述</b></h3><ul><li>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</li><li>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</li><li>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</li></ul><h3><b>7.2 动图演示</b></h3><p>1 欢乐点的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"214\" data-thumbnail=\"https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.jpg\" class=\"content_image\" width=\"280\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;280&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"280\" data-rawheight=\"214\" data-thumbnail=\"https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.jpg\" class=\"content_image lazy\" width=\"280\" data-actualsrc=\"https://pic3.zhimg.com/v2-b7907d351809293c60658b0b87053c66_b.gif\"/></figure><p>2 正经点的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"364\" data-thumbnail=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;364&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"364\" data-thumbnail=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7073c729230e1a2c3c3c9207b25f6b43_b.gif\"/></figure><h3><b>7.3 代码实现</b></h3><p>注意：这里用到了完全二叉树的部分性质。</p><div class=\"highlight\"><pre><code class=\"language-text\"> 1//声明全局变量，用于记录数组array的长度；\n 2static int len;\n 3/**\n 4* 堆排序算法\n 5*\n 6* @param array\n 7* @return\n 8*/\n 9public static int[] HeapSort(int[] array) {\n10   len = array.length;\n11   if (len &lt; 1) return array;\n12   //1.构建一个最大堆\n13   buildMaxHeap(array);\n14   //2.循环将堆首位（最大值）与末位交换，然后在重新调整最大堆\n15   while (len &gt; 0) {\n16       swap(array, 0, len - 1);\n17       len--;\n18       adjustHeap(array, 0);\n19   }\n20   return array;\n21}\n22/**\n23* 建立最大堆\n24*\n25* @param array\n26*/\n27public static void buildMaxHeap(int[] array) {\n28   //从最后一个非叶子节点开始向上构造最大堆\n29   for (int i = (len - 1) / 2; i &gt;= 0; i--) {\n30       adjustHeap(array, i);\n31   }\n32}\n33/**\n34* 调整使之成为最大堆\n35*\n36* @param array\n37* @param i\n38*/\n39public static void adjustHeap(int[] array, int i) {\n40   int maxIndex = i;\n41   //如果有左子树，且左子树大于父节点，则将最大指针指向左子树\n42   if (i * 2 &lt; len &amp;&amp; array[i * 2] &gt; array[maxIndex])\n43       maxIndex = i * 2;\n44   //如果有右子树，且右子树大于父节点，则将最大指针指向右子树\n45   if (i * 2 + 1 &lt; len &amp;&amp; array[i * 2 + 1] &gt; array[maxIndex])\n46       maxIndex = i * 2 + 1;\n47   //如果父节点不是最大值，则将父节点与最大值交换，并且递归调整与父节点交换的位置。\n48   if (maxIndex != i) {\n49       swap(array, maxIndex, i);\n50       adjustHeap(array, maxIndex);\n51   }\n52}\n</code></pre></div><h3><b>7.4 算法分析</b></h3><p><b>最佳情况：T(n) = O(nlogn) 最差情况：T(n) = O(nlogn) 平均情况：T(n) = O(nlogn)</b></p><h3><b>8、计数排序（Counting Sort）</b></h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h3><b>8.1 算法描述</b></h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h3><b>8.2 动图演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"557\" data-thumbnail=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1012\" data-original=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1012&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"557\" data-thumbnail=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1012\" data-original=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3c7ddb59df2d21b287e42a7b908409cb_b.gif\"/></figure><h3><b>8.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 计数排序\n 3*\n 4* @param array\n 5* @return\n 6*/\n 7public static int[] CountingSort(int[] array) {\n 8   if (array.length == 0) return array;\n 9   int bias, min = array[0], max = array[0];\n10   for (int i = 1; i &lt; array.length; i++) {\n11       if (array[i] &gt; max)\n12           max = array[i];\n13       if (array[i] &lt; min)\n14           min = array[i];\n15   }\n16   bias = 0 - min;\n17   int[] bucket = new int[max - min + 1];\n18   Arrays.fill(bucket, 0);\n19   for (int i = 0; i &lt; array.length; i++) {\n20       bucket[array[i] + bias]++;\n21   }\n22   int index = 0, i = 0;\n23   while (index &lt; array.length) {\n24       if (bucket[i] != 0) {\n25           array[index] = i - bias;\n26           bucket[i]--;\n27           index++;\n28       } else\n29           i++;\n30   }\n31   return array;\n32}\n</code></pre></div><h3><b>8.4 算法分析</b></h3><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p><b>最佳情况：T(n) = O(n+k)  最差情况：T(n) = O(n+k)  平均情况：T(n) = O(n+k)</b></p><h3><b>9、桶排序（Bucket Sort）</b></h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p><p>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h3><b>9.1 算法描述</b></h3><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。 </li></ul><p><b>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</b></p><h3><b>9.2 图片演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-42b543d66ebd164cf66dbc97cf69eb51_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"596\" class=\"origin_image zh-lightbox-thumb\" width=\"870\" data-original=\"https://pic2.zhimg.com/v2-42b543d66ebd164cf66dbc97cf69eb51_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;870&#39; height=&#39;596&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"870\" data-rawheight=\"596\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"870\" data-original=\"https://pic2.zhimg.com/v2-42b543d66ebd164cf66dbc97cf69eb51_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-42b543d66ebd164cf66dbc97cf69eb51_b.jpg\"/></figure><h3><b>9.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 桶排序\n 3*\n 4* @param array\n 5* @param bucketSize\n 6* @return\n 7*/\n 8public static ArrayList&lt;Integer&gt; BucketSort(ArrayList&lt;Integer&gt; array, int bucketSize) {\n 9   if (array == null || array.size() &lt; 2)\n10       return array;\n11   int max = array.get(0), min = array.get(0);\n12   // 找到最大值最小值\n13   for (int i = 0; i &lt; array.size(); i++) {\n14       if (array.get(i) &gt; max)\n15           max = array.get(i);\n16       if (array.get(i) &lt; min)\n17           min = array.get(i);\n18   }\n19   int bucketCount = (max - min) / bucketSize + 1;\n20   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketArr = new ArrayList&lt;&gt;(bucketCount);\n21   ArrayList&lt;Integer&gt; resultArr = new ArrayList&lt;&gt;();\n22   for (int i = 0; i &lt; bucketCount; i++) {\n23       bucketArr.add(new ArrayList&lt;Integer&gt;());\n24   }\n25   for (int i = 0; i &lt; array.size(); i++) {\n26       bucketArr.get((array.get(i) - min) / bucketSize).add(array.get(i));\n27   }\n28   for (int i = 0; i &lt; bucketCount; i++) {\n29       if (bucketCount == 1)\n30           bucketSize--;\n31       ArrayList&lt;Integer&gt; temp = BucketSort(bucketArr.get(i), bucketSize);\n32       for (int j = 0; j &lt; temp.size(); j++)\n33           resultArr.add(temp.get(j));\n34   }\n35   return resultArr;\n36}\n</code></pre></div><h3><b>9.4 算法分析</b></h3><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。 </p><p>**最佳情况：T(n) = O(n+k)   最差情况：T(n) = O(n+k)   平均情况：T(n) = O(n2)　**</p><h3><b>10、基数排序（Radix Sort）</b></h3><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h3><b>10.1 算法描述</b></h3><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3><b>10.2 动图演示</b></h3><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"574\" data-thumbnail=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1012\" data-original=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1012&#39; height=&#39;574&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1012\" data-rawheight=\"574\" data-thumbnail=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1012\" data-original=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a6f1e5059386523ed941f0d6c3a136e_b.gif\"/></figure><h3><b>10.3 代码实现</b></h3><div class=\"highlight\"><pre><code class=\"language-text\"> 1/**\n 2* 基数排序\n 3* @param array\n 4* @return\n 5*/\n 6public static int[] RadixSort(int[] array) {\n 7   if (array == null || array.length &lt; 2)\n 8       return array;\n 9   // 1.先算出最大数的位数；\n10   int max = array[0];\n11   for (int i = 1; i &lt; array.length; i++) {\n12       max = Math.max(max, array[i]);\n13   }\n14   int maxDigit = 0;\n15   while (max != 0) {\n16       max /= 10;\n17       maxDigit++;\n18   }\n19   int mod = 10, div = 1;\n20   ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n21   for (int i = 0; i &lt; 10; i++)\n22       bucketList.add(new ArrayList&lt;Integer&gt;());\n23   for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) {\n24       for (int j = 0; j &lt; array.length; j++) {\n25           int num = (array[j] % mod) / div;\n26           bucketList.get(num).add(array[j]);\n27       }\n28       int index = 0;\n29       for (int j = 0; j &lt; bucketList.size(); j++) {\n30           for (int k = 0; k &lt; bucketList.get(j).size(); k++)\n31               array[index++] = bucketList.get(j).get(k);\n32           bucketList.get(j).clear();\n33       }\n34   }\n35   return array;\n36}\n</code></pre></div><h3><b>10.4 算法分析</b></h3><p><b>最佳情况：T(n) = O(n * k)   最差情况：T(n) = O(n * k)   平均情况：T(n) = O(n * k)</b></p><p>基数排序有两种方法：</p><p>MSD 从高位开始进行排序 LSD 从低位开始进行排序 </p><p><b>基数排序 vs 计数排序 vs 桶排序</b></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><p>本文参考自： </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/guoyaohua/p/8600214.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/guoyaohua/p</span><span class=\"invisible\">/8600214.html</span><span class=\"ellipsis\"></span></a> </p><p><a href=\"https://link.zhihu.com/?target=http%3A//www.cricode.com/3212.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cricode.com/3212.html</span><span class=\"invisible\"></span></a></p><hr/><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\"/></figure>", 
            "topic": [
                {
                    "tag": "排序算法", 
                    "tagLink": "https://api.zhihu.com/topics/19622354"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>大佬，我想问一下，动图是什么软件制作的呢？</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58797437", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 7, 
            "title": "数据结构与算法系列——栈", 
            "content": "<h2><b>什么是栈</b></h2><p>栈是一种运算受限制的线性表，只允许在表的一端进行插入和删除操作。这一端被称为栈顶，另一端被称为栈底。向一个栈中插入新数据叫做进栈、入栈或者压栈，是把新元素放到栈顶上边，使其成为新的栈顶元素；删除数据叫做出栈或者退栈，就是把栈顶的元素删掉，使其下边的元素称为新的栈顶元素。</p><p>举一个容易理解的例子，就是有一摞盘子，我们用的时候从上往下一个一个取，放的时候都是从下往上一个一个放，一般不从中间取或者放。这种先进后出，后进先出的数据结构就是栈。</p><p>这种操作受限的数据结构在什么情况下用呢，我们为什么不能用操作更为方便的数组或者链表呢。当某个数据只涉及在一端的插入和删除数据，并满足先进后出，后进先出的特点，我们就可以用栈这种数据结构，而数组和链表因为操作的灵活性，有时候会使一些数据不可控，更容易出现错误。</p><h2><b>栈的实现</b></h2><p>从功能上，我们是可以用数组和链表来实现栈，只要实现栈的入栈和出栈的操作，即从栈顶插入新的数据，从栈顶删除数据。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链表栈。下边我们分别看一下用数组和链表实现栈的代码。这里用Java代码实现。</p><ul><li>数组实现</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">//基于数组实现的栈\npublic class ArrayStack{\n\n    //数组\n    private String[] items;\n    //栈的大小\n    private int length;\n    //栈中元素的个数\n    private int count;\n\n\n    public ArrayStack(int len){\n        items = new String[len];\n        length = len;\n        count = 0;\n    }\n\n    //入栈\n    public boolean Push(String x){\n        //数组空间不足\n        if(count == length){\n            return false;\n        }\n        items[count] = x;\n        count++;\n        return true;\n    }\n\n    //出栈\n    public String Pop(){\n        //栈为空\n        if(count == 0){\n            return null;\n        }\n        String tem = items[count-1];\n        count--;\n        return tem;\n    }\n\n}\n</code></pre></div><ul><li>链表实现</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">//基于链表实现的栈\npublic class ListNodeStack {\n\n    private ListNode top;\n\n    //进栈\n    public void Push(int val) {\n        ListNode node = new ListNode(val, null);\n        if (top == null) {\n            top = node;\n        } else {\n            node.next = top;\n            top = node;\n        }\n    }\n\n    //出栈\n    public int Pop() {\n        if (top == null) {\n            return -1;\n        }\n        int val = top.val;\n        top = top.next;\n        return val;\n    }\n\n\n    //链表的结点\n    class ListNode {\n        private int val;\n        private ListNode next;\n\n        public ListNode(int x, ListNode next) {\n            val = x;\n            this.next = next;\n        }\n\n        public int GetValue() {\n            return val;\n        }\n    }\n}\n</code></pre></div><p>上边代码用数组实现的栈是一个固定大小的栈，当栈满了之后就没法办插入新的数据了，那么我们能不能用数组实现一个动态扩容的栈呢？前边我们将数组的时候说过，实现一个动态扩容的数组，是在数组满了的时候，我们重新创建一个大小为原来两倍的数组，然后把原来数组的数据拷贝到新的数组中，所以我们也可以用这个方法来实现一个动态扩容的栈。我们看一下代码实现。</p><div class=\"highlight\"><pre><code class=\"language-text\">//基于数组实现的栈\npublic class ArrayStack {\n\n    //数组\n    private String[] items;\n    //栈的大小\n    private int length;\n    //栈中元素的个数\n    private int count;\n\n\n    public ArrayStack(int len) {\n        items = new String[len];\n        length = len;\n        count = 0;\n    }\n\n    //入栈\n    public void Push(String x) {\n        //数组空间不足\n        if (count == length) {\n            DilatationArray();\n        }\n        items[count] = x;\n        count++;\n    }\n\n    //出栈\n    public String Pop() {\n        //栈为空\n        if (count == 0) {\n            return null;\n        }\n        String tem = items[count - 1];\n        count--;\n        return tem;\n    }\n\n    //数组扩容\n    private void DilatationArray() {\n        String[] newArray = new String[length * 2];\n        for (int i = 0; i &lt; length; i++) {\n            newArray[i] = items[I];\n        }\n        items = newArray;\n    }\n\n}\n</code></pre></div><h2><b>栈的实际应用</b></h2><ol><li>在函数调用中的应用</li></ol><p>在Java的虚拟机中有一个内存区域被称为虚拟机栈。每个方法在执行的时候都会创建一个“栈帧”。用来存储局部变量表（包括参数）、操作栈、动态链接、方法出口等信息。每个方法从调用到结束就会有栈帧在虚拟机栈中入栈和出栈。</p><p>举一个简单的例子。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class AddClass{\n    public int Main(){\n        int a = 0;\n        int b = 5;\n        int c = 0;\n        a = Add(2, 3);\n        c = a + b;\n        return c;\n    }\n\n    public int Add(int x, int y){\n        int sum = 0;\n        sum = x + y;\n        return sum;\n    }\n}\n</code></pre></div><p>从代码中我们看到 Main 方法中首先声明了几个变量，然后调用了 Add 方法，然后经过一些运算，最后返回一个值。我们画图来更直观的看一下这个过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e2176ae544ce2da700849465a454fd33_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1092\" data-rawheight=\"754\" class=\"origin_image zh-lightbox-thumb\" width=\"1092\" data-original=\"https://pic4.zhimg.com/v2-e2176ae544ce2da700849465a454fd33_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1092&#39; height=&#39;754&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1092\" data-rawheight=\"754\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1092\" data-original=\"https://pic4.zhimg.com/v2-e2176ae544ce2da700849465a454fd33_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e2176ae544ce2da700849465a454fd33_b.jpg\"/></figure><ol><li>在表达式求值中的应用</li></ol><p>编辑器的表达式求值的过程，就是用栈来实现的。我们举一个简单的四则运算的表达式的求值过程来看一下。例如：1+2*3-4/2。编辑器是怎么计算来得到最后的值呢。</p><p>这个求值过程，编辑器是用两个栈来实现的，一个保存数字的栈，一个保存运算符号的栈。我们从左向右遍历表达式，当遇到数字的时候把它压入数字栈，当遇到运算符号的时候，就与运算符栈的栈顶的运算符比较，如果比栈顶的运算符优先级高，就直接压入运算符栈，如果比栈顶的运算符优先级低或者相同，那么就从运算符栈取出栈顶运算符号，从数字栈中取出两个数字进行计算，然后把结果压入数字栈，然后继续比较，依次类推，知道最后。</p><p>我们为了更形象的理解，也用画图的方式来展示一下这个过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cc71cbeed467b6b0102e90c4d9e4751b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"828\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-cc71cbeed467b6b0102e90c4d9e4751b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;828&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"828\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic4.zhimg.com/v2-cc71cbeed467b6b0102e90c4d9e4751b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cc71cbeed467b6b0102e90c4d9e4751b_b.jpg\"/></figure><ol><li>在各种前进后退操作中的应用</li></ol><p>我们在各中编辑器的撤销和恢复操作，浏览器中的前进和后退操作，都是用栈来实现的。</p><p>我们用两个栈 A 和 B，当我们执行操作的时候把我们的每一个操作依次压入 A 栈中，当我们执行后退的操作时，依次从 A 栈中取出，然后压入 B 栈中，当执行前进操作的时候，依次从 B 栈中取出，然后压入 A 栈中。</p><p>比如我们依次执行了 a，b，c 操作，我们依次把 a，b，c 压入 A 栈。如图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-de334d2de696df90b0f65a0b49178bc7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-de334d2de696df90b0f65a0b49178bc7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;616&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"616\" data-original=\"https://pic4.zhimg.com/v2-de334d2de696df90b0f65a0b49178bc7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-de334d2de696df90b0f65a0b49178bc7_b.jpg\"/></figure><p>假如我们现在想要撤销 c 和 b 操作。那么它就是这样的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-729d4e419e7f8d60970cd46210fed2e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"602\" data-original=\"https://pic2.zhimg.com/v2-729d4e419e7f8d60970cd46210fed2e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;602&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"602\" data-original=\"https://pic2.zhimg.com/v2-729d4e419e7f8d60970cd46210fed2e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-729d4e419e7f8d60970cd46210fed2e9_b.jpg\"/></figure><p>假如我又想恢复操作 b <br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7bd0782191c30105503557d7c6ded97a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"602\" data-original=\"https://pic3.zhimg.com/v2-7bd0782191c30105503557d7c6ded97a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;602&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"602\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"602\" data-original=\"https://pic3.zhimg.com/v2-7bd0782191c30105503557d7c6ded97a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7bd0782191c30105503557d7c6ded97a_b.jpg\"/></figure><p>这个时候我继续执行新的操作 d，那么无论前进后退我们都无法再回到操作 c 了，所以我们应该清空 B 栈。</p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-95367cac82be8d5cd13130193dd14935_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb\" width=\"596\" data-original=\"https://pic2.zhimg.com/v2-95367cac82be8d5cd13130193dd14935_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;596&#39; height=&#39;428&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"596\" data-rawheight=\"428\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"596\" data-original=\"https://pic2.zhimg.com/v2-95367cac82be8d5cd13130193dd14935_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-95367cac82be8d5cd13130193dd14935_b.jpg\"/></figure></b><p class=\"ztext-empty-paragraph\"><br/></p><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\"/></figure>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }, 
                {
                    "tag": "栈（数据结构）", 
                    "tagLink": "https://api.zhihu.com/topics/20183311"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57251390", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 9, 
            "title": "数据结构与算法系列——时间、空间复杂度", 
            "content": "<p>数据结构和算法本质就是帮我们用最快的时间和最少的空间来执行我们的代码。所以，执行效率是衡量一个算法的非常重要的指标。那如何来计算你的算法代码的执行效率呢？这就需要时间、空间复杂度来分析了。</p><p>有人可能会说，我把代码执行一遍，然后通过统计、监控就能知道执行的时间和需要的内存大小。干嘛还需要时间、空间复杂度来分析呢？我都能得到具体需要的时间和内存了，还需要多此一举吗？</p><p>首先，这种评估算法效率的方法没有问题，我们还给这种方法起了一个名字，叫<b>事后统计法</b>。但是这种方法有很大的局限性。</p><p><b>1. 测试结果受测试环境影响</b></p><p>测试环境的硬件对测试结果有非常大的影响。比如，同样的代码在i7和i5的机器上执行，结果肯定是不同的。还有可能在一台机器上A代码比B代码执行速度要快，我们换另外一台机器却得到相反的结果。</p><p><b>2. 测试结果受数据规模的影响</b></p><p>比如排序算法，原始数据如果有序度不一样，执行的时间就会有很大的差别。原始数据规模的大小不同，也可能会让原来速度快的算法变成速度慢的。</p><p>所以我们就需要一个不需要具体的测试数据来测试，就可以大概估算出执行效率的方法，就是时间、空间复杂度分析方法。</p><h2><b>大O复杂度表示方法</b></h2><p>我们通过度代码，来估算出它执行所需要的时间，下边来看一段具体的代码。</p><div class=\"highlight\"><pre><code class=\"language-text\">public int Function(int n)\n{\n    int sum = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        sum += i;\n    }\n    return sum;\n}\n</code></pre></div><p>这里我们假设每一行代码执行的时间都是相同的为 t，那么第 3 行执行的时间为 t，第 4 和 6 行执行了 n 次，需要时间为 2n<i>t，总的时间为 (1+2n)</i>t，可以看出来总的代码的执行时间 T(n) 与每行代码的执行次数成正比。</p><p>然后我们再来看下边的代码</p><div class=\"highlight\"><pre><code class=\"language-text\">public int Function(int n)\n{\n    int sum = 0;\n    for(int i = 1; i &lt;= n; i++)\n    {\n        for(int j = 1; j &lt;= n; j++\n        {\n            sum += i*j;\n        }\n    }\n    return sum;\n}\n</code></pre></div><p>这段代码中在上边的基础上又套了一层 for 循环，第 6 和 8 行执行了 n^2 次，需要的时间为 2n^2 * t ,总的需要的时间为 T(n)=(2n^2+2n+1) * t </p><p>通过上述两个具体的代码例子我们总结出一个公式：</p><hr/><p>T(n)=O(f(n))</p><hr/><p>T(n) 表示代买执行的时间，n 是数据的大小，f(n) 表示代码执行的总次数，O 表示公式中 T(n) 与 f(n) 成正比。这就是大 O 时间复杂度表示法，它实际上并不表示代码具体执行所需要的时间，它表示随着数据规模的变化代码执行时间的变化趋势。</p><p>当 n 非常大时，低阶、系数、常量对结果的影响就非常小了，所以我们可以把这几项忽略不记，只保留最高阶的就可以了，所以上边两个例子中 O(1+2n) 就可以记为 O(n)，o(2n^2+2n+1) 就可以记为 O(n^2)。</p><p>上边我们知道了怎么用大 O 时间复杂度的表示方法。那么我们如何具体分析一段代码的时间复杂度呢？</p><ul><li>只关注循环次数最多的一段代码</li></ul><p>因为大 O 时间复杂度只表示一种变化的趋势，所以我们只需要关心阶数最高的那部分就可以了，低阶、系数、常量我们都可以忽略。以上边第一段代码为例 O(1+2n)，我们忽略掉系数和常量最后就得到了 O(n)。</p><ul><li>加法法则</li></ul><p>对于顺序执行的长代码，我们把它分成几部分，分别求出其总时间 T(n) ,然后相加得到总的时间，最后同样忽略低阶、系数、常量部分，保留最高阶的部分然后得出最后的时间复杂度大 O。</p><ul><li>乘法法则</li></ul><p>对于逻辑复杂的嵌套代码，我们分别求嵌套内外代码的复杂度，然后相乘得出最终的时间复杂度大 O。</p><h2><b>几种常见的时间复杂度分析</b></h2><p>下边列举出常见的时间复杂度量级</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3e3fa9ee78861c3cae0e998b9f5b26a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1264\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb\" width=\"1264\" data-original=\"https://pic3.zhimg.com/v2-3e3fa9ee78861c3cae0e998b9f5b26a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1264&#39; height=&#39;474&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1264\" data-rawheight=\"474\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1264\" data-original=\"https://pic3.zhimg.com/v2-3e3fa9ee78861c3cae0e998b9f5b26a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3e3fa9ee78861c3cae0e998b9f5b26a6_b.jpg\"/></figure><p>对于非多项式量级的算法会随着数据规模的增大急剧增加，所以分多项式量级的算法是非常低效的，我们不做过多的介绍。主要来介绍几种常见的多项式量级的时间复杂度。</p><ol><li>常数阶 O(1)</li></ol><p>O(1) 只是常量级时间复杂度的表示方式，不是只有一行代码，而是每一段代码的执行时间不随着 n 的数据规模的变大而变长，这样的代码的时间复杂度记为 O(n)。</p><ol><li>对数阶 O(logn) O(nlogn)</li></ol><p>对数阶复杂度很常见，但是分析的时候却不容易，下面我们用一段实际的例子来看看对数阶时间复杂度。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void Function(int n)\n{\n    int i = 1;\n    while(i&lt;=n)\n    {\n        i = i*2;\n    }\n}\n</code></pre></div><p>通过上边我们总结的方法，我们只需要知道 while 循环的次数，就能得到这段代码的复杂度。从代码中可以看出 i 的值从 1 开始，每循环一次乘以 2，直到 i 的值大于 n 的时候结束，我们得到规律然后把结果列出来，<br/>2^0 2^1 2^3 2^4 …… 2^x = n ，然后求得执行的次数 x = logn ,这段代码的时间复杂度就是 O(logn)。</p><ol><li>O(n+m) O(n*m)</li></ol><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模决定，所以我们需要同时考虑两种数据规模对结果的影响，如果是顺序的，那么时间复杂度就为 O(n+m)，如果为嵌套的那么时间复杂度为 O(n*m)。</p><h2><b>空间复杂度分析</b></h2><p>理解了上边的时间复杂度的分析方法，空间复杂度的分析也就很简单了。空间复杂度表示算法的存储空间与数据规模之间的增长关系。</p><p>同样我们通过一段实际的代码来分析一下。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void Function(int n)\n{\n    int i = 0;\n    int[] a = new int[n];\n    for(i;i&lt;n;i++)\n    {\n        a[i] = i*i;\n    }\n}\n</code></pre></div><p>我们看到第 3 行代码，我们申请了一个空间存储变量 i ，但是这个是常数阶的，不会随 n 的变化而变化，所以可以忽略，第 4 行我们申请了一个大小为 n 的 int 类型数组，除此之外其余代码没有占用其他的空间，所以这段代码的空间复杂度为 O(n)。</p><p>我们常见的空间复杂度有 O(1)、O(n)、O(n^2)，对数阶的空间复杂度一般情况下用不到。所以空间复杂度比时间复杂度容易分析的多，我们也只需要掌握常见的几种就可以了。</p><p>最后我们总结一下常见的几种复杂度，执行效率从高到低依次为<br/>O(1)&gt;O(logn)&gt;O(n)&gt;o(nlogn)&gt;O(n^2)</p><hr/><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff069b628ad355958cf3527883ef7016_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff069b628ad355958cf3527883ef7016_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "后端开发", 
                    "userLink": "https://www.zhihu.com/people/865377d985a7d10a61498f624ae0ace6", 
                    "content": "<p><a href=\"http://link.zhihu.com/?target=http%3A//yushiwangzhe.cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">yushiwangzhe.cn</span><span class=\"invisible\"></span></a>大量算法学习资料</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58204626", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 10, 
            "title": "数据结构与算法系列——链表详解", 
            "content": "<p>上次我们简单的对比了一下数组和链表的区别和各自的优缺点，今天我们来详细看一下链表这个结构。<br/>链表的结构五花八门，我们几天主要看一下三种最常用的链表结构：<b>单链表、双向链表和循环列表</b>。</p><ul><li>单链表</li></ul><p>我们首先来看一下最简单、最常用的单链表。前边我们已经知道链表是通过指针将一些分散的内存块连接到一起。其中，我们把每个内存块叫做链表的一个<b>结点</b>。为了将每个结点连接到一起，每个结点不仅存储数据，而且还需要记录下一个结点的地址。我们把这个记录下一个结点的指针称为<b>后继指针next</b>。我们通过下边示意图来更形象的了解一下。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5dba697b504070df3b01c9b9712382de_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-5dba697b504070df3b01c9b9712382de_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-5dba697b504070df3b01c9b9712382de_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5dba697b504070df3b01c9b9712382de_b.jpg\"/></figure><p>从图中我们可以看到，单链表是单方向顺序的一个线性表。其中有两个结点比较特殊，分别是第一个和最后一个结点。我们通常把第一个结点叫做<b>头结点</b>，最后一个结点叫做<b>尾结点</b>，头结点用来记录链表的基地址，这样我们就可以遍历得到整个结点，尾结点是最后一个结点，它的指针指向一个空地址<b>NULL</b>，这样我们通过判断后继指针next是不是NULL来确定某个结点是不是尾结点。<br/>前边我们在<b>数组和链表</b>中已经详细介绍了链表的插入和删除，在这里我们不做过多的描述，而是通过示意图的方式更清楚的了解。针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的时间复杂度为O(1)。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3a42e577405f60a79294ce207dcba53e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-3a42e577405f60a79294ce207dcba53e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;625&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"625\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-3a42e577405f60a79294ce207dcba53e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3a42e577405f60a79294ce207dcba53e_b.jpg\"/></figure><ul><li>双向链表</li></ul><p>单链表只有一个指针，每个结点都只有一个后继指针next指向下一个结点的地址。而双向链表，顾名思义，它有两个方向，所以每个结点不仅有一个指向下一个结点的后继指针next，还有一个指向前一个结点的<b>前驱结点prev</b>。同样我们通过示意图来看一下。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b11736d5b68d173fce14f646d28fa849_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-b11736d5b68d173fce14f646d28fa849_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;217&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic2.zhimg.com/v2-b11736d5b68d173fce14f646d28fa849_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b11736d5b68d173fce14f646d28fa849_b.jpg\"/></figure><p>从图中我们看到，与单链表相比，双向链表的每个结点还需要存储指向前一个结点的指针，所以，同样多的数据，双向链表比单链表需要更多的存储空间。两个指针虽然比较浪费空间，但是双向链表可以双向遍历，灵活性更高。<br/>双向链表在删除、插入结点上更加高效，前边我们讲过单链表的删除和插入操作的时间复杂度为O(1)，但是双向链表的为什么会更高效呢，因为单链表的分析只是理论上得到的，但是实际情况中是不准确的，是需要前提条件的。<br/>下面我们分析一下实际情况中的操作。我们先来看插入操作，实际情况中的插入操作可以分为这两种情况：</p><ol><li>在值等于某个指定值的结点前或者后插入结点</li><li>在给定指针后边插入结点</li></ol><p>对于第一种情况，不管是单链表还是双向链表，都需要从头一个一个遍历直到找到特定值的结点，然后执行插入操作虽然插入的时间复杂度为O(1)，但是遍历的时间复杂度为O(n)，所以在值等于某个指定值的结点前或者后插入结点的时间复杂度为O(n)。<br/>对于第二种情况，我们通过给定指针可以直到插入结点的位置，但是我们需要直到给定指针的前驱结点，如果是单链表，我们依然需要通过从头开始遍历找到前驱结点，需要的时间复杂度为O(n)，但是对于双向链表就简单多了，我们只需要通过前驱结点的指针就能得到前驱结点，需要的时间复杂度为O(1)。<br/>同理，参照我们上边插入操作的分析，删除结点双向链表同样比单链表灵活得多。<br/>还有就是在有序链表中，双向链表的按值查询也比单链表也快一些，因为我们可以记录上次查找的位置x，然后通过比较查询值x的大小来决定向前还是向后，可以比单链表节省时间。<br/>通过上边单链表和双向链表的比较，我们有学习了灵位一个非常重要的知识点，那就是<b>用空间换时间</b>的思想，当内存空间充足时，如果我们对执行效率有更高的要求，可以用牺牲内存而换取效率的办法，也就是选择空间复杂度相对比较高，但是时间复杂度低的算法或者数据结构（实际应用中，缓存就是利用空间换时间的思想）。相反，如果内存比较紧张，我们就可以用时间换空间的算法或数据结构。</p><ul><li>循环链表</li></ul><p>循环链表一种特殊的单链表，与单链表唯一的区别就是，循环链表的最后一个结点的指针指向头结点而不是指向空地址。如下示意图所示。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7dca64e3e17d8068ccfbe04c840c9cc6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-7dca64e3e17d8068ccfbe04c840c9cc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"253\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-7dca64e3e17d8068ccfbe04c840c9cc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7dca64e3e17d8068ccfbe04c840c9cc6_b.jpg\"/></figure><p>和单链表相比，循环列表的优点就是从链尾到链头比较方便。比如需要处理的数据具有环形结构特点时，用循环列表就非常合适。虽然单链表也可以实现，但是循环链表的代码要简洁的多。</p><h2><b>链表的应用</b></h2><p>我们已经学习了三种简单且最常见的链表，那么链表在实际的应用中是怎么用的呢？一个经典的链表使用场景就是<b>LRU缓存淘汰法</b>。<br/>缓存的大小有限，但缓存的空间被用满的时候，我们该把哪些数据清除出去呢？LRU缓存淘汰法就是其中的一种策略，把最近最少用的数据清除出去。<br/>那用链表怎么实现这个算法呢，下边我们来看一下基于单链表的Java实现。</p><div class=\"highlight\"><pre><code class=\"language-text\">package linked.singlelist;\n\n\nimport java.util.Scanner;\n\n/**\n * 基于单链表LRU算法（java）\n *\n */\npublic class LRUBaseLinkedList&lt;T&gt; {\n\n    /**\n     * 头结点\n     */\n    private SNode&lt;T&gt; headNode;\n\n    /**\n     * 链表长度\n     */\n    private Integer length;\n\n    /**\n     * 链表容量\n     */\n    private Integer capacity;\n\n    public LRUBaseLinkedList(Integer capacity) {\n        this.headNode = new SNode&lt;&gt;();\n        this.capacity = capacity;\n        this.length = 0;\n    }\n\n    public void add(T data) {\n        SNode preNode = findPreNode(data);\n\n        // 链表中存在，删除原数据，再插入到链表的头部\n        if (preNode != null) {\n            deleteElemOptim(preNode);\n            intsertElemAtBegin(data);\n        } else {\n            if (length &gt;= this.capacity) {\n                //删除尾结点\n                deleteElemAtEnd();\n            }\n            intsertElemAtBegin(data);\n        }\n    }\n\n    /**\n     * 删除preNode结点下一个元素\n     *\n     * @param preNode\n     */\n    private void deleteElemOptim(SNode preNode) {\n        SNode temp = preNode.getNext();\n        preNode.setNext(temp.getNext());\n        temp = null;\n        length--;\n    }\n\n    /**\n     * 链表头部插入结点\n     *\n     * @param data\n     */\n    private void intsertElemAtBegin(T data) {\n        SNode next = headNode.getNext();\n        headNode.setNext(new SNode(data, next));\n        length++;\n    }\n\n    /**\n     * 获取查找到元素的前一个结点\n     *\n     * @param data\n     * @return\n     */\n    private SNode findPreNode(T data) {\n        SNode node = headNode;\n        while (node.getNext() != null) {\n            if (data.equals(node.getNext().getElement())) {\n                return node;\n            }\n            node = node.getNext();\n        }\n        return null;\n    }\n\n    /**\n     * 删除尾结点\n     */\n    private void deleteElemAtEnd() {\n        SNode ptr = headNode;\n        // 空链表直接返回\n        if (ptr.getNext() == null) {\n            return;\n        }\n\n        // 倒数第二个结点\n        while (ptr.getNext().getNext() != null) {\n            ptr = ptr.getNext();\n        }\n\n        SNode tmp = ptr.getNext();\n        ptr.setNext(null);\n        tmp = null;\n        length--;\n    }\n\n    private void printAll() {\n        SNode node = headNode.getNext();\n        while (node != null) {\n            System.out.print(node.getElement() + &#34;,&#34;);\n            node = node.getNext();\n        }\n        System.out.println();\n    }\n\n    public class SNode&lt;T&gt; {\n\n        private T element;\n\n        private SNode next;\n\n        public SNode(T element) {\n            this.element = element;\n        }\n\n        public SNode(T element, SNode next) {\n            this.element = element;\n            this.next = next;\n        }\n\n        public SNode() {\n            this.next = null;\n        }\n\n        public T getElement() {\n            return element;\n        }\n\n        public void setElement(T element) {\n            this.element = element;\n        }\n\n        public SNode getNext() {\n            return next;\n        }\n\n        public void setNext(SNode next) {\n            this.next = next;\n        }\n    }\n\n    public static void main(String[] args) {\n        LRUBaseLinkedList list = new LRUBaseLinkedList();\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            list.add(sc.nextInt());\n            list.printAll();\n        }\n    }\n}\n</code></pre></div><hr/><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-33e824e7d61bfb35ff60e0fcb81263b3_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "链表", 
                    "tagLink": "https://api.zhihu.com/topics/19649942"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": [
                {
                    "userName": "不要做积极的废人", 
                    "userLink": "https://www.zhihu.com/people/a72c0aed5fb02e2d0ee6860052f89dcb", 
                    "content": "谢谢指教 学长能不能解释一下 循环链表中的尾指针和尾结点的关系呢 总是有点搞不清楚 [捂脸][捂脸][捂脸]", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "KeepUp", 
                            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
                            "content": "<p>尾结点就是最后一个结点，尾结点存储着数据和尾指针，在循环链表里，尾指针指向头结点的内存地址</p>", 
                            "likes": 0, 
                            "replyToAuthor": "不要做积极的废人"
                        }, 
                        {
                            "userName": "不要做积极的废人", 
                            "userLink": "https://www.zhihu.com/people/a72c0aed5fb02e2d0ee6860052f89dcb", 
                            "content": "尾指针难道不是指向尾结点的一个指针吗😓😓😓", 
                            "likes": 0, 
                            "replyToAuthor": "KeepUp"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57453176", 
            "userName": "KeepUp", 
            "userLink": "https://www.zhihu.com/people/64e06cdb82251c928ae30533bf6cacf8", 
            "upvote": 2, 
            "title": "数据结构与算法系列——数组和链表", 
            "content": "<h2><b>数组的介绍</b></h2><p>在每一种编程语言种，基本都有数组这种数据类型，当然它不仅是一种数据类型，还是一种基础、简单的数据结构。<br/>数组的定义是：<b>数组是一种线性表数据结构，他用一组连续的内存空间，来储存一组相同类型的数据</b></p><h2><b>数组的特点</b></h2><p>数组是一种线性表，线性表就是数据像一条线一样，排列成一条有序的队，每个数据只有前和后两个方向。数组在内存中的储存是连续的，声明数组的时候会在内存中找一块连续的空间，来依次储存数组的每个数据。数组需要预留储存空间，在使用前需要先申请内存的大小，很有可能会浪费空间。数组随机访问效率高，因为在内存中是连续的，所以可以直接访问该地址的数据。但是数组因为连续这一特点使得它的的插入和删除效率低，因为需要把插入和删除位置后边的所有数据后挪或者前移。数组不利于动态扩展，数组一旦定义，长度是固定的，扩展起来比较麻烦，需要重新定义数组。</p><h2><b>数组的优点</b></h2><ul><li>随机访问性高</li><li>查找速度快</li></ul><h2><b>数组的缺点</b></h2><ul><li>插入和删除效率低</li><li>不易于扩展</li><li>对内存要求高，需要连续的空间</li><li>有可能造成内存的浪费</li></ul><h2><b>链表的介绍</b></h2><p>链表也是一种基本的数据结构，它有一系列节点组成，每个节点包括一个数据结构（用来存放各类型的数据），还包括一个指向下一个节点的指针。</p><h2><b>链表的特点</b></h2><p>链表和数组一样也是线性表，但是链表在内存中的储存是非连续、非顺序的。每一个数据都保存了一个指针，指向下一个数据的内存地址，这样通过这个指针就可以找到下一个数据，也正是因为是非连续的，所以随机访问和数据的查找比较麻烦，每次都要从头开始依次向后直到找到目标数据为止。但是插入和删除操作比较容易，因为不是连续有序的，所以插入的时候，只需要把前一个数据的指针指向新数据，然后新数据的指针指向后一个数据就可以了，删除的时候只需要把后一个数据告诉前一个数据就可以了，其他的数据都不需要做修改。链表还支持动态扩展，可以随意增加和删除数据。</p><h2><b>链表的优点</b></h2><ul><li>插入、删除速度快</li><li>内存利用率高，不浪费</li><li>易于扩展</li></ul><h2><b>链表的缺点</b></h2><ul><li>不能随机访问，查找效率低</li></ul><p>最后我们用前边学习的时间复杂度来分析数组和链表的操作</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-98240cbfdcddd58bb1b5dd6658b38fc8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1276\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb\" width=\"1276\" data-original=\"https://pic1.zhimg.com/v2-98240cbfdcddd58bb1b5dd6658b38fc8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1276&#39; height=&#39;326&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1276\" data-rawheight=\"326\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1276\" data-original=\"https://pic1.zhimg.com/v2-98240cbfdcddd58bb1b5dd6658b38fc8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-98240cbfdcddd58bb1b5dd6658b38fc8_b.jpg\"/></figure><h2><b>总结</b></h2><p>对于已知大小，并且对数据操作读取较多，插入、删除较少，可以直接用数组。由于链表在有时候不能直接储存基本数据类型，所以性能会有一点点的损耗。<br/>我们在平时业务逻辑的时候可以直接使用像链表这种容器类，虽然有一点点性能损耗，但影响很小。但如果做底层的开发，对性能要求比较高的时候，直接用数组更为合适。</p><hr/><p>欢迎关注公众号：「努力给自己看」</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ff069b628ad355958cf3527883ef7016_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;200&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"200\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic3.zhimg.com/v2-ff069b628ad355958cf3527883ef7016_b.jpg\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数组", 
                    "tagLink": "https://api.zhihu.com/topics/19725906"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "链表", 
                    "tagLink": "https://api.zhihu.com/topics/19649942"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1081866882008760320"
}
