{
    "title": "深度挖掘互联网", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/zen-yao-hua-du-shuo-bu-hao", 
        "https://www.zhihu.com/people/zheng-zai-deng-lu-19", 
        "https://www.zhihu.com/people/seabiscuit-94", 
        "https://www.zhihu.com/people/jiang-yong-hang", 
        "https://www.zhihu.com/people/li-shuai-76-22", 
        "https://www.zhihu.com/people/guan-meng-yuan-41", 
        "https://www.zhihu.com/people/joyina", 
        "https://www.zhihu.com/people/la-mian-guan-16", 
        "https://www.zhihu.com/people/xi-ya-tu-ye-wei-mian-83", 
        "https://www.zhihu.com/people/geng-dong-96", 
        "https://www.zhihu.com/people/zhenghangbo-53", 
        "https://www.zhihu.com/people/ziyanzi-yan-62", 
        "https://www.zhihu.com/people/ephonechan", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/chi-huo-zai-wang-shan-tun-qiao-zi-mu", 
        "https://www.zhihu.com/people/xiao-xiao-521-74", 
        "https://www.zhihu.com/people/tou-wong-64", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/leowin", 
        "https://www.zhihu.com/people/se7en-30-94-61", 
        "https://www.zhihu.com/people/newbee-tree-55", 
        "https://www.zhihu.com/people/xiao-kk-61-28", 
        "https://www.zhihu.com/people/tony2016", 
        "https://www.zhihu.com/people/lao-gan-ma-76-6", 
        "https://www.zhihu.com/people/zhaotiechui", 
        "https://www.zhihu.com/people/lao-cheng-35", 
        "https://www.zhihu.com/people/wang-mu-yuan", 
        "https://www.zhihu.com/people/li-zheng-cao-94", 
        "https://www.zhihu.com/people/dgjk1010", 
        "https://www.zhihu.com/people/wang-xue-fei-62-51", 
        "https://www.zhihu.com/people/UncleCatMySelf", 
        "https://www.zhihu.com/people/feng-xiao-li", 
        "https://www.zhihu.com/people/jian-yu-44-69-90", 
        "https://www.zhihu.com/people/zhang-hai-liang-91", 
        "https://www.zhihu.com/people/unhe", 
        "https://www.zhihu.com/people/mo-mo-8-67-82", 
        "https://www.zhihu.com/people/ri-yue-ming-de-bai-tian", 
        "https://www.zhihu.com/people/hou-hou-hou-hou-37-44", 
        "https://www.zhihu.com/people/sigmaTTT", 
        "https://www.zhihu.com/people/liu-xiao-yang-13-39", 
        "https://www.zhihu.com/people/yaoyao-11-79", 
        "https://www.zhihu.com/people/ou-yang-da-shi-24", 
        "https://www.zhihu.com/people/once-63-53", 
        "https://www.zhihu.com/people/zheng-jian-xiang-78", 
        "https://www.zhihu.com/people/thinkdeep-74", 
        "https://www.zhihu.com/people/zheng-jian-yang-56", 
        "https://www.zhihu.com/people/lin-xi-98-40", 
        "https://www.zhihu.com/people/fei-lin-kuang-wu", 
        "https://www.zhihu.com/people/gua-niu-7-4-4", 
        "https://www.zhihu.com/people/lei-zi-hai", 
        "https://www.zhihu.com/people/kevin-hill", 
        "https://www.zhihu.com/people/qi-yu-hang-94", 
        "https://www.zhihu.com/people/huang-qi-43-37", 
        "https://www.zhihu.com/people/marcus-59", 
        "https://www.zhihu.com/people/luo-si-chai-er-de-8", 
        "https://www.zhihu.com/people/reseted1530576548260", 
        "https://www.zhihu.com/people/chen-zi-cheng-10", 
        "https://www.zhihu.com/people/dislido", 
        "https://www.zhihu.com/people/Zhui_Ming", 
        "https://www.zhihu.com/people/mi-hua-99-14", 
        "https://www.zhihu.com/people/lucillegyl", 
        "https://www.zhihu.com/people/jiu-ye-20-63", 
        "https://www.zhihu.com/people/da-mu-lang"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/65761651", 
            "userName": "左新宇", 
            "userLink": "https://www.zhihu.com/people/0837ff224f2992aa97191f62934f1f46", 
            "upvote": 2, 
            "title": "SolrCloud的搭建", 
            "content": "<p>【80】</p><h2>什么是SolrCloud</h2><p>        SolrCloud(solr 云)是Solr提供的分布式搜索方案，当你需要大规模，容错，分布式索引和检索能力时使用 SolrCloud。当一个系统的索引数据量少的时候是不需要使用SolrCloud的，当索引量很大，搜索请求并发很高，这时需要使用SolrCloud满足这些需求。</p><p>         SolrCloud不同于redis集群自带集群，SolrCloud是基于Solr和Zookeeper的分布式搜索方案，它的主要思想是使用Zookeeper作为集群的配置信息中心。</p><p>它有几个特色功能：</p><p>1）集中式的配置信息</p><p>2）自动容错</p><p>3）近实时搜索</p><p>4）查询时自动负载均衡</p><h2>SolrCloud结构</h2><p>        SolrCloud为了降低单机的处理压力，需要由多台服务器共同来完成索引和搜索任务。实现的思路是将索引数据进行Shard（分片）拆分，每个分片由多台的服务器共同完成，当一个索引或搜索请求过来时会分别从不同的Shard的服务器中操作索引。</p><p>        SolrCloud需要Solr基与zookeeper部署，Zookeeper是一个集群管理软件，由于SolrCloud需要由多台服务器组成，由zookeeper来进行协调管理。</p><p>下图是一个SolrCloud应用的例子：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c1afcacca628231c4ec8773333e67860_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1122\" data-rawheight=\"792\" class=\"origin_image zh-lightbox-thumb\" width=\"1122\" data-original=\"https://pic1.zhimg.com/v2-c1afcacca628231c4ec8773333e67860_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1122&#39; height=&#39;792&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1122\" data-rawheight=\"792\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1122\" data-original=\"https://pic1.zhimg.com/v2-c1afcacca628231c4ec8773333e67860_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c1afcacca628231c4ec8773333e67860_b.jpg\"/></figure><p>物理结构：</p><p>        三个Solr实例（ 每个实例包括两个Core），组成一个SolrCloud。</p><p>逻辑结构：</p><p>        索引集合包括两个Shard（shard1和shard2），shard1和shard2分别由三个Core组成，其中一个Leader两个Replication，Leader是由zookeeper选举产生，zookeeper控制每个shard上三个Core的索引数据一致，解决高可用问题。用户发起索引请求分别从shard1和shard2上获取，解决高并发问题。</p><p>core：</p><p>        每个Core是Solr中一个独立运行单位，提供 索引和搜索服务。一个shard需要由一个Core或多个Core组成。由于collection由多个shard组成所以collection一般由多个core组成。</p><p>Master&amp;Slave：</p><p>        Master是master-slave构中的主结点（通常说主服务器），Slave是master-slave结构中的从结点（通常说从服务器或备服务器）。同一个Shard下master和slave存储的数据是一致的，这是为了达到高可用目的</p><p>SolrCloud搭建</p><p>        因为没有很强劲的电脑，开不了8、9台虚拟机，所以我这里采用伪集群的方式进行安装，如果是真正的生成环境，将伪集群的ip改下就可以了，步骤是一样的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>SolrCloud结构图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f67819511201e47ac9e49b436db38082_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1048\" data-rawheight=\"701\" class=\"origin_image zh-lightbox-thumb\" width=\"1048\" data-original=\"https://pic3.zhimg.com/v2-f67819511201e47ac9e49b436db38082_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1048&#39; height=&#39;701&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1048\" data-rawheight=\"701\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1048\" data-original=\"https://pic3.zhimg.com/v2-f67819511201e47ac9e49b436db38082_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f67819511201e47ac9e49b436db38082_b.jpg\"/></figure><p><b>搭建环境</b></p><ul><li>OS：CentOS 7</li><li>JDK：jdk 1.8.0</li><li>Tomcat：tomcat 7</li><li>zookeeper：zookeeper 3.4.6</li><li>solr：solr 4.10.3</li></ul><p>安装包在对应的官网上都能下载到，jdk和tomcat的安装很简单，在这里就不说了。</p><p>zookeeper集群搭建</p><p>第一步：解压zookeeper，tar -zxvf zookeeper-3.4.6.tar.gz然后将解压得到的zookeeper-3.4.6拷贝到/usr/local/solrcloud下，复制三份分别并将目录名改为zookeeper01、zookeeper02、zookeeper03</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2ba749cad7cae9e5d9ce2927a5575fcc_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"84\" class=\"origin_image zh-lightbox-thumb\" width=\"794\" data-original=\"https://pic1.zhimg.com/v2-2ba749cad7cae9e5d9ce2927a5575fcc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;794&#39; height=&#39;84&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"794\" data-rawheight=\"84\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"794\" data-original=\"https://pic1.zhimg.com/v2-2ba749cad7cae9e5d9ce2927a5575fcc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2ba749cad7cae9e5d9ce2927a5575fcc_b.png\"/></figure><p>第二步：进入zookeeper01文件夹，创建data目录。并在data目录中创建一个myid文件内容为“1”（echo 1 &gt;&gt;data/myid）。然后分别进入02和03文件夹，进行同样的操作，把1换成2和3：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-24c9dfe9bb80257e760e8ad62793837b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic4.zhimg.com/v2-24c9dfe9bb80257e760e8ad62793837b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;156&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"156\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic4.zhimg.com/v2-24c9dfe9bb80257e760e8ad62793837b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-24c9dfe9bb80257e760e8ad62793837b_b.jpg\"/></figure><p>第三步：进入zookeeper01/conf文件夹，复制一份zoo_sample.cfg命名为zoo.cfg</p><p>cp  zoo_sample.cfg  zoo.cfg，在三个zookeeper中都执行这个操作</p><p>第四步：修改zoo.cfg。</p><p>修改：</p><p>dataDir=/usr/local/solrcloud/zookeeper1/data</p><p>clientPort=2181（zookeeper02中为2182、zookeeper03中为2183）</p><p>这个是客户端连接zookeeper的端口，即zookeeper提供服务的端口</p><p>在文件最后添加：</p><div class=\"highlight\"><pre><code class=\"language-text\">server.1=192.168.25.150:2881:3881\nserver.2=192.168.25.150:2882:3882\nserver.3=192.168.25.150:2883:3883</code></pre></div><p>含义：zookeeper节点列表</p><p>server.节点id(myid文件) = 节点ip : zookeeper节点之间进行通信的端口 : 节点之间投票选举的端口</p><p>第五步：启动三个zookeeper</p><div class=\"highlight\"><pre><code class=\"language-text\">/usr/local/solrcloud/zookeeper1/bin/zkServer.shstart\n/usr/local/solrcloud/zookeeper2/bin/zkServer.shstart\n/usr/local/solrcloud/zookeeper3/bin/zkServer.shstart</code></pre></div><p>或者创建批处理文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e30dafe32310e2d17176e4e84f1ac528_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"237\" class=\"content_image\" width=\"395\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;395&#39; height=&#39;237&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"237\" class=\"content_image lazy\" width=\"395\" data-actualsrc=\"https://pic1.zhimg.com/v2-e30dafe32310e2d17176e4e84f1ac528_b.jpg\"/></figure><p><b>chmod  u+x  start-all-zookeeper.sh</b></p><p>执行：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-4549084977a5f7925030de9bc11748fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"234\" class=\"origin_image zh-lightbox-thumb\" width=\"1062\" data-original=\"https://pic2.zhimg.com/v2-4549084977a5f7925030de9bc11748fd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1062&#39; height=&#39;234&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1062\" data-rawheight=\"234\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1062\" data-original=\"https://pic2.zhimg.com/v2-4549084977a5f7925030de9bc11748fd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-4549084977a5f7925030de9bc11748fd_b.jpg\"/></figure><p>查看集群状态：</p><ul><li>/usr/local/solrcloud/zookeeper1/bin/zkServer.shstatus</li><li>/usr/local/solrcloud/zookeeper2/bin/zkServer.shstatus</li><li>/usr/local/solrcloud/zookeeper3/bin/zkServer.shstatus</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-49cdd0aa4863bcdc3d0cbf5e7516f765_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1010\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb\" width=\"1010\" data-original=\"https://pic2.zhimg.com/v2-49cdd0aa4863bcdc3d0cbf5e7516f765_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1010&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1010\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1010\" data-original=\"https://pic2.zhimg.com/v2-49cdd0aa4863bcdc3d0cbf5e7516f765_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-49cdd0aa4863bcdc3d0cbf5e7516f765_b.jpg\"/></figure><p>一个leader，两个follower</p><p>第六步：关闭防火墙，或者开启zookeeper用到的端口，我这里选择的是关闭防火墙，因为端口实在是太多了。</p><p>CentOS 7关闭防火墙：</p><p>systemctl stop firewalld.service             #停止firewall</p><p>systemctl disable firewalld.service        #禁止firewall开机启动</p><p>---------------至此 zookeeper集群搭建完成</p><p>SolrCloud部署</p><p>第一步：新建目录/usr/local/solr-cloud然后复制四分tomcat，并将配置好的单机版solr复制到四台tomcat中（单机版的solr配置参考前面的连接文章）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d336082a62b466646e296ca2640d0b8d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-d336082a62b466646e296ca2640d0b8d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;807&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"807\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"807\" data-original=\"https://pic2.zhimg.com/v2-d336082a62b466646e296ca2640d0b8d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d336082a62b466646e296ca2640d0b8d_b.jpg\"/></figure><p>第二步：修改tomcat的server.xml，vim tomcat01/conf/server.xml 修改内容：</p><p>&lt;Server port=&#34;8105&#34;shutdown=&#34;SHUTDOWN&#34;&gt;</p><p>&lt;Connector port=&#34;8180&#34;protocol=&#34;HTTP/1.1&#34; connectionTimeout=&#34;20000&#34; redirect…….</p><p>&lt;Connector port=&#34;8109&#34; protocol=&#34;AJP/1.3&#34;redirectPort=&#34;8443&#34; /&gt;</p><p>另外三台分别修改为：8205  8280  8209 | 8305  8380  8309 | 8405 8480  8409</p><p>第三步：为每一份solr复制一份solrhome，命名为solrhome01 - solrhome04</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8f2ff3c0ffa92284da7a282aaac43de4_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1411\" data-rawheight=\"157\" class=\"origin_image zh-lightbox-thumb\" width=\"1411\" data-original=\"https://pic1.zhimg.com/v2-8f2ff3c0ffa92284da7a282aaac43de4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1411&#39; height=&#39;157&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1411\" data-rawheight=\"157\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1411\" data-original=\"https://pic1.zhimg.com/v2-8f2ff3c0ffa92284da7a282aaac43de4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8f2ff3c0ffa92284da7a282aaac43de4_b.png\"/></figure><p>截至目前，/usr/local/solr-cloud的目录结构：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-39dabeb183ce2d921677ac67c91725e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1053\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb\" width=\"1053\" data-original=\"https://pic4.zhimg.com/v2-39dabeb183ce2d921677ac67c91725e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1053&#39; height=&#39;462&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1053\" data-rawheight=\"462\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1053\" data-original=\"https://pic4.zhimg.com/v2-39dabeb183ce2d921677ac67c91725e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-39dabeb183ce2d921677ac67c91725e7_b.jpg\"/></figure><p>三台zookeeper组成zookeeper集群；</p><p>四台tomcat上面部署了四分solr；</p><p>四个solrhome对应了四分silr；</p><p>第四步：修改每一份solr的web.xml，指向正确的solrhome地址：</p><p>/usr/local/solr-cloud/tomcat01/webapps/solr/WEB-INF/web.xml</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d2c3e68029c51c8da668b5c0502cbe8d_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb\" width=\"925\" data-original=\"https://pic2.zhimg.com/v2-d2c3e68029c51c8da668b5c0502cbe8d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;925&#39; height=&#39;122&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"925\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"925\" data-original=\"https://pic2.zhimg.com/v2-d2c3e68029c51c8da668b5c0502cbe8d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d2c3e68029c51c8da668b5c0502cbe8d_b.png\"/></figure><p>第五步：修改每一份的solrhome配置：solrhome0*/solr.xml</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1059ecfb1a6ce998d05cc13e42acb32c_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb\" width=\"1066\" data-original=\"https://pic1.zhimg.com/v2-1059ecfb1a6ce998d05cc13e42acb32c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1066&#39; height=&#39;136&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1066\" data-rawheight=\"136\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1066\" data-original=\"https://pic1.zhimg.com/v2-1059ecfb1a6ce998d05cc13e42acb32c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1059ecfb1a6ce998d05cc13e42acb32c_b.png\"/></figure><p>第六步：让每一台solr和zookeeper关联：</p><p>        修改每一份solr的tomcat的bin目录下的catalina.sh文件，加入DzkHost指定zookeeper服务器地址，将zookeeper地址列表作为参数传过去：</p><p>        JAVA_OPTS=&#34;-DzkHost=192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183&#34;</p><p>        注：JAVA_OPTS赋值的位置一定要放在引用该变量之前，可以使用vim查找功能查找到JAVA_OPTS的定义位置，然后添加</p><p>第七步：使用zookeeper统一管理solr配置文件：</p><p>        使用zookeeper统一管理solr的配置文件（主要是schema.xml、solrconfig.xml），solrCloud各各节点使用zookeeper管理的配置文件，由于这里是直接复制的之前单机版配置好的solrhome（添加了一个中文分词器，定义了业务域）所以配置文件就不需要再修改了，直接交给zookeeper管理就好了。</p><p>        进入/root/solr-4.10.3/example/scripts/cloud-scripts/目录下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0a54714bed8c5d9162ad81a7138d1ec1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"906\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb\" width=\"906\" data-original=\"https://pic2.zhimg.com/v2-0a54714bed8c5d9162ad81a7138d1ec1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;906&#39; height=&#39;180&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"906\" data-rawheight=\"180\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"906\" data-original=\"https://pic2.zhimg.com/v2-0a54714bed8c5d9162ad81a7138d1ec1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0a54714bed8c5d9162ad81a7138d1ec1_b.jpg\"/></figure><p>执行命令：./zkcli.sh -zkhost 192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183 -cmd upconfig -confdir /usr/local/solr-cloud/solrhome01/collection1/conf -confname myconf</p><p class=\"ztext-empty-paragraph\"><br/></p><p>        上传任意一个solrhome下的配置文件即可。-zkhost：指定zookeeper的地址列表；upconfig ：上传配置文件；-confdir ：指定配置文件所在目录；-confname：指定上传到zookeeper后的目录名。</p><p>       登录zookeeper服务器检查配置文件是否上传成功：</p><p>        /usr/local/solr-cloud/zookeeper01/bin</p><p>        ./zKCli.sh -server 192.168.25.130:2182</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-68f94561585543908f5d8c24582f828f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"1050\" data-original=\"https://pic4.zhimg.com/v2-68f94561585543908f5d8c24582f828f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1050&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1050\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1050\" data-original=\"https://pic4.zhimg.com/v2-68f94561585543908f5d8c24582f828f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-68f94561585543908f5d8c24582f828f_b.jpg\"/></figure><p>到这里，solr集群就搭建完成了，然后启动所有的solr服务，即启动四台tomcat（启动前需启动zookeeper集群），批处理文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-07cbf8bcf916adc3bf9a0def86bac020_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"653\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb\" width=\"653\" data-original=\"https://pic1.zhimg.com/v2-07cbf8bcf916adc3bf9a0def86bac020_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;653&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"653\" data-rawheight=\"97\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"653\" data-original=\"https://pic1.zhimg.com/v2-07cbf8bcf916adc3bf9a0def86bac020_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-07cbf8bcf916adc3bf9a0def86bac020_b.png\"/></figure><p>查看启动状态：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-36a7fba8da2ec7a57dd0c00a931907ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1118\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb\" width=\"1118\" data-original=\"https://pic3.zhimg.com/v2-36a7fba8da2ec7a57dd0c00a931907ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1118&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1118\" data-rawheight=\"316\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1118\" data-original=\"https://pic3.zhimg.com/v2-36a7fba8da2ec7a57dd0c00a931907ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-36a7fba8da2ec7a57dd0c00a931907ba_b.jpg\"/></figure><h2>访问solrCloud</h2><p>访问集群中的任意一台solr均可，可以看到相较于单机版，多了一个Cloud：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cc6d188de0036f26e2d41eecad81a956_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1111\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb\" width=\"1111\" data-original=\"https://pic3.zhimg.com/v2-cc6d188de0036f26e2d41eecad81a956_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1111&#39; height=&#39;370&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1111\" data-rawheight=\"370\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1111\" data-original=\"https://pic3.zhimg.com/v2-cc6d188de0036f26e2d41eecad81a956_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cc6d188de0036f26e2d41eecad81a956_b.jpg\"/></figure><p>删除不使用的collection：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//192.168.25.130%3A8180/solr/admin/collections%3Faction%3DDELETE%26name%3Dcollection1\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">192.168.25.130:8180/sol</span><span class=\"invisible\">r/admin/collections?action=DELETE&amp;name=collection1</span><span class=\"ellipsis\"></span></a> 执行后原来的collection1删除</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cb0e92fef4c3302ecfedab59cb665a19_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb\" width=\"1087\" data-original=\"https://pic2.zhimg.com/v2-cb0e92fef4c3302ecfedab59cb665a19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1087&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1087\" data-rawheight=\"264\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1087\" data-original=\"https://pic2.zhimg.com/v2-cb0e92fef4c3302ecfedab59cb665a19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cb0e92fef4c3302ecfedab59cb665a19_b.jpg\"/></figure><h2>Java操作solrCloud</h2><p>在java中操作solrCloud和操作solr一样，都是通过solrJ，只不过初始化solrServer对象时有点不同：</p><p><b>简单示例：</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@Test</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">testAddDocument</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n\t<span class=\"c1\">// zkHost：zookeeper的地址列表\n</span><span class=\"c1\"></span>\t<span class=\"n\">String</span> <span class=\"n\">zkHost</span> <span class=\"o\">=</span> <span class=\"s\">&#34;192.168.73.132:2181,192.168.73.132:2182,192.168.73.132:2183&#34;</span><span class=\"o\">;</span>\n\t<span class=\"c1\">// 创建一个集群的连接，应该使用CloudSolrServer创建\n</span><span class=\"c1\"></span>\t<span class=\"n\">CloudSolrServer</span> <span class=\"n\">solrServer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloudSolrServer</span><span class=\"o\">(</span><span class=\"n\">zkHost</span><span class=\"o\">);</span>\n\t<span class=\"c1\">// 设置一个defaultCollection属性\n</span><span class=\"c1\"></span>\t<span class=\"n\">solrServer</span><span class=\"o\">.</span><span class=\"na\">setDefaultCollection</span><span class=\"o\">(</span><span class=\"s\">&#34;collection2&#34;</span><span class=\"o\">);</span>\n\t<span class=\"c1\">// 创建一个文档对象\n</span><span class=\"c1\"></span>\t<span class=\"n\">SolrInputDocument</span> <span class=\"n\">document</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">SolrInputDocument</span><span class=\"o\">();</span>\n\t<span class=\"c1\">// 向文档中添加域\n</span><span class=\"c1\"></span>\t<span class=\"n\">document</span><span class=\"o\">.</span><span class=\"na\">setField</span><span class=\"o\">(</span><span class=\"s\">&#34;id&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;solrCloud01&#34;</span><span class=\"o\">);</span>\n\t<span class=\"n\">document</span><span class=\"o\">.</span><span class=\"na\">setField</span><span class=\"o\">(</span><span class=\"s\">&#34;item_title&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;测试商品01&#34;</span><span class=\"o\">);</span>\n\t<span class=\"n\">document</span><span class=\"o\">.</span><span class=\"na\">setField</span><span class=\"o\">(</span><span class=\"s\">&#34;item_price&#34;</span><span class=\"o\">,</span> <span class=\"n\">123</span><span class=\"o\">);</span>\n\t<span class=\"c1\">// 把文件内容写入索引库\n</span><span class=\"c1\"></span>\t<span class=\"n\">solrServer</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">document</span><span class=\"o\">);</span>\n\t<span class=\"c1\">// 提交\n</span><span class=\"c1\"></span>\t<span class=\"n\">solrServer</span><span class=\"o\">.</span><span class=\"na\">commit</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cc596764784e750dc69afdd31cc5ad2d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1307\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb\" width=\"1307\" data-original=\"https://pic2.zhimg.com/v2-cc596764784e750dc69afdd31cc5ad2d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1307&#39; height=&#39;698&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1307\" data-rawheight=\"698\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1307\" data-original=\"https://pic2.zhimg.com/v2-cc596764784e750dc69afdd31cc5ad2d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cc596764784e750dc69afdd31cc5ad2d_b.jpg\"/></figure><p>如果要在Spring中使用集群版本solr，配置如下：</p><p>该配置和单机版的配置同时只能存在一份，不然会报不唯一异常！</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 集群版solrJ，参数为zookeeper的地址列表 --&gt;\n&lt;bean id=&#34;cloudSolrServer&#34; class=&#34;org.apache.solr.client.solrj.impl.CloudSolrServer&#34;&gt;\n\t&lt;constructor-arg index=&#34;0&#34; value=&#34;192.168.25.130:2181,192.168.25.130:2182,192.168.25.130:2183&#34;/&gt;\n\t&lt;property name=&#34;defaultCollection&#34; value=&#34;collection2&#34;/&gt;\n&lt;/bean&gt;</code></pre></div><p>然后在代码中通过：</p><p> @Autowired</p><p> private SolrServer solrServer;自动注入即可使用</p>", 
            "topic": [
                {
                    "tag": "Solr", 
                    "tagLink": "https://api.zhihu.com/topics/19591379"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65806004", 
            "userName": "里奥ii", 
            "userLink": "https://www.zhihu.com/people/6a210c2bdd9113781bb15fa2777ca0ec", 
            "upvote": 0, 
            "title": "为什么Java开发工程师工资高，却很多人想转行，原因有四点，扎心却很现实", 
            "content": "<p>科技的发展产生了程序员这个职位，从这些年各大互联网公司曝光的一些员工收入水平来看，程序员的工资还是相对比较高的，可是我们在互联网上还听到了另外一种声音，很多程序员想转行，特别是大龄程序员，这可能会令很多人纳闷。为什么工资这么高还想转行呢？其实他们也很无奈，从下面几点可以看得出来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c082b0d1b09c695e1062b6656fd3ea8f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-c082b0d1b09c695e1062b6656fd3ea8f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-c082b0d1b09c695e1062b6656fd3ea8f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c082b0d1b09c695e1062b6656fd3ea8f_b.jpg\"/></figure><p><b>1、程序员加班多，经常熬夜</b><br/>IT行业是一个工作节奏非常快的行业，项目越快上市，就能更快一步抢占商机，为了加快项目的进度，项目的计划时间安排也是相当紧张，所以程序员加班是经常的事，导致加班多还有一些其他的原因，我们设计好项目的需求以后，为了适应用户或者客户的需求，我们设计好的项目详细计划还得中途修改，这样预估的计划时间就不够了，但是为了赶上项目的进度，招人的话，适应工作是来不及了，最方便快捷，也是最有效的方法就是加班解决。所以程序员加班就会多，还经常需要晚上加班。<br/> </p><p><b>2、程序员年纪越来越大，体力跟不上</b><br/>从上面这一条我们就知道程序员加班、熬夜多，所以精力需要很旺盛才行。由于经常处在超负荷工作状态下，随着工作年限的增长，年龄的增长，体能和精力都会下降。年轻人，身体素质好也许没问题，但上点年纪的程序员就会吃力很多，特别是有了家庭的程序员，照顾家庭也会分散自己的精力。所以才有很多人说程序员是一个吃青春饭的职业，虽然不全对，但也是有一定道理的。</p><p><b>3、重复性动作，对工作产生疲劳</b><br/>由于长时间专注一个领域的开发工作，从一个项目到另外一个项目，很多工作是重复的动作。一个技术点长时间去做，虽然会越做越熟练，但是程序员的工作的出了名的工作压力大，任务非常紧张，这样是很容易让程序员产生厌倦的。大多数程序员还是喜欢挑战新技术，开发有创意性价值的功能。但是在繁重的开发任务下，也没有更多的时间了学习新技术。往往很多软件产品要求成熟稳定才是关键。经常听到行业里面的人。工作做得好好的，突然就有了想不想干程序员的想法。这也是一种“职业厌倦”的表现。</p><p><b>4、身体容易出现健康问题</b><br/>程序员经常加班熬夜会让程序员身体处在亚健康状态，熬夜影响身体机能和身体排毒。经常吃饭不规律容易患上肠胃疾病，程序员经常晚上熬夜加班，早上在补个大懒觉，经常就把早餐匆匆解决或者是干脆不吃早餐，中午饭的时候也经常在赶工作，简单解决一下，晚饭经常吃的比较晚。由于比较晚的缘故，肚子比较饿，那就要大吃一顿补回一天的能量，这样的饮食不规律，很容易让肠胃患上疾病的。长时间对着电脑，电脑的辐射对眼睛的伤害是很大的，不仅仅是近视，还能让眼睛各种不适症状。腰椎因为久坐也会劳损。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fa288d9865cfaad473ca06b76d42aa4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-fa288d9865cfaad473ca06b76d42aa4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"400\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-fa288d9865cfaad473ca06b76d42aa4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fa288d9865cfaad473ca06b76d42aa4e_b.jpg\"/></figure><p>总结：程序员虽然相对来说工资会高点，或多或少由于上面这些原因让程序员产生了转行的念头，这是可以理解的，我想说的是，程序员无论转行与否，都应该在工作中关注自己的身体健康，劳逸结合，有了好的体魄，才能更好的去工作。才能有更高的工作效率。我们程序员更要注重在工作中提升自己，技术更新换代非常快，我们要跟上科技发展的脚步。同时做好职业规划，不管转行还是继续深入发展，我们都要提前按自己的计划做准备，这才有备无患。<br/> </p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "程序员修养", 
                    "tagLink": "https://api.zhihu.com/topics/19573884"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/65049747", 
            "userName": "commando", 
            "userLink": "https://www.zhihu.com/people/d47e804d3c5f78eb9be02055bccf6600", 
            "upvote": 5, 
            "title": "解析为什么 Redis 单线程却能支撑高并发？", 
            "content": "<p>Redis是一个开源的使用ANSI <a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/C%25E8%25AF%25AD%25E8%25A8%2580\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E6%2595%25B0%25E6%258D%25AE%25E5%25BA%2593/103728\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库</a>，并提供多种语言的API，首先我们都知道Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 <b>I/O 多路复用</b>就是为了解决这个问题而出现的。</p><p>先来看一下传统的阻塞 I/O 模型到底是如何工作的：当使用 <code>read</code> 或者 <code>write</code> 对某一个<b>文件描述符（File Descriptor 以下简称 FD)</b>进行读写时，如果当前 FD 不可读或不可写，整个 Redis 服务就不会对其它的操作作出响应，导致整个服务不可用。</p><p>这也就是传统意义上的，也就是我们在编程中使用最多的阻塞模型：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3667dd08a475c7d144191af5b97a96b3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-3667dd08a475c7d144191af5b97a96b3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-3667dd08a475c7d144191af5b97a96b3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3667dd08a475c7d144191af5b97a96b3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>阻塞模型虽然开发中非常常见也非常易于理解，但是由于它会影响其他 FD 对应的服务，所以在需要处理多个客户端任务的时候，往往都不会使用阻塞模型。</p><p>I/O 多路复用</p><p>虽然还有很多其它的 I/O 模型，但是在这里都不会具体介绍。</p><p>阻塞式的 I/O 模型并不能满足这里的需求，我们需要一种效率更高的 I/O 模型来支撑 Redis 的多个客户（redis-cli），这里涉及的就是 I/O 多路复用模型了：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-60f8bbf1766b963e145d8f35590fa6e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-60f8bbf1766b963e145d8f35590fa6e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-60f8bbf1766b963e145d8f35590fa6e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-60f8bbf1766b963e145d8f35590fa6e7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在 I/O 多路复用模型中，最重要的函数调用就是 <code>select</code>，该方法的能够同时监控多个文件描述符的可读可写情况，当其中的某些文件描述符可读或者可写时， <code>select</code> 方法就会返回可读以及可写的文件描述符个数。<br/></p><p>关于 <code>select</code> 的具体使用方法，在网络上资料很多，这里就不过多展开介绍了；</p><p>与此同时也有其它的 I/O 多路复用函数 <code>epoll/kqueue/evport</code>，它们相比 <code>select</code> 性能更优秀，同时也能支撑更多的服务。</p><p>Reactor 设计模式</p><p>Redis 服务采用 Reactor 的方式来实现文件事件处理器（每一个网络连接其实都对应一个文件描述符）</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-560b0fc48e1899a3cb491ecf5283fdc2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-560b0fc48e1899a3cb491ecf5283fdc2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;810&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"810\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-560b0fc48e1899a3cb491ecf5283fdc2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-560b0fc48e1899a3cb491ecf5283fdc2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>文件事件处理器使用 I/O 多路复用模块同时监听多个 FD，当 <code>accept</code>、 <code>read</code>、 <code>write</code> 和<code>close</code> 文件事件产生时，文件事件处理器就会回调 FD 绑定的事件处理器。</p><p>虽然整个文件事件处理器是在单线程上运行的，但是通过 I/O 多路复用模块的引入，实现了同时对多个 FD 读写的监控，提高了网络通信模型的性能，同时也可以保证整个 Redis 服务实现的简单。</p><p>I/O 多路复用模块</p><p>I/O 多路复用模块封装了底层的 <code>select</code>、 <code>epoll</code>、 <code>avport</code> 以及 <code>kqueue</code> 这些 I/O 多路复用函数，为上层提供了相同的接口。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6df956eb58fed397a2f25f8318bdd237_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-6df956eb58fed397a2f25f8318bdd237_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;628&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"628\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic4.zhimg.com/v2-6df956eb58fed397a2f25f8318bdd237_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6df956eb58fed397a2f25f8318bdd237_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这里我们简单介绍 Redis 是如何包装 <code>select</code> 和 <code>epoll</code> 的，简要了解该模块的功能，整个 I/O 多路复用模块抹平了不同平台上 I/O 多路复用函数的差异性，提供了相同的接口：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eee0a9c7fe26fcd1db05ef3c117bafd2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-eee0a9c7fe26fcd1db05ef3c117bafd2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic3.zhimg.com/v2-eee0a9c7fe26fcd1db05ef3c117bafd2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-eee0a9c7fe26fcd1db05ef3c117bafd2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>同时，因为各个函数所需要的参数不同，我们在每一个子模块内部通过一个 <code>aeApiState</code> 来存储需要的上下文信息：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-752691a8ef24ff0d20d63387708cdc84_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb\" width=\"674\" data-original=\"https://pic1.zhimg.com/v2-752691a8ef24ff0d20d63387708cdc84_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;674&#39; height=&#39;213&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"674\" data-rawheight=\"213\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"674\" data-original=\"https://pic1.zhimg.com/v2-752691a8ef24ff0d20d63387708cdc84_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-752691a8ef24ff0d20d63387708cdc84_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些上下文信息会存储在 <code>eventLoop</code> 的 <code>void*state</code> 中，不会暴露到上层，只在当前子模块中使用。</p><p>封装 select 函数</p><p><code>select</code> 可以监控 FD 的可读、可写以及出现错误的情况。</p><p>在介绍 I/O 多路复用模块如何对 <code>select</code> 函数封装之前，先来看一下 <code>select</code> 函数使用的大致流程：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-be50b42a31a0904b41f071bab0bd7893_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb\" width=\"675\" data-original=\"https://pic4.zhimg.com/v2-be50b42a31a0904b41f071bab0bd7893_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;675&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"675\" data-rawheight=\"215\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"675\" data-original=\"https://pic4.zhimg.com/v2-be50b42a31a0904b41f071bab0bd7893_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-be50b42a31a0904b41f071bab0bd7893_b.jpg\"/></figure><p>1、初始化一个可读的 <code>fd_set</code> 集合，保存需要监控可读性的 FD；2、使用 <code>FD_SET</code> 将 <code>fd</code> 加入 <code>rfds</code>；3、调用 <code>select</code> 方法监控 <code>rfds</code> 中的 FD 是否可读；4、当 <code>select</code> 返回时，检查 FD 的状态并完成对应的操作。</p><p>而在 Redis 的 <code>ae_select</code> 文件中代码的组织顺序也是差不多的，首先在 <code>aeApiCreate</code> 函数中初始化 <code>rfds</code> 和 <code>wfds</code>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3b9744406cb8c186c53d272eb6c5aed9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"681\" data-rawheight=\"177\" class=\"origin_image zh-lightbox-thumb\" width=\"681\" data-original=\"https://pic2.zhimg.com/v2-3b9744406cb8c186c53d272eb6c5aed9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;681&#39; height=&#39;177&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"681\" data-rawheight=\"177\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"681\" data-original=\"https://pic2.zhimg.com/v2-3b9744406cb8c186c53d272eb6c5aed9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3b9744406cb8c186c53d272eb6c5aed9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>而 <code>aeApiAddEvent</code> 和 <code>aeApiDelEvent</code> 会通过 <code>FD_SET</code> 和 <code>FD_CLR</code> 修改 <code>fd_set</code> 中对应 FD 的标志位：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8290a53c7949a9673c853e206c55a9f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb\" width=\"677\" data-original=\"https://pic1.zhimg.com/v2-8290a53c7949a9673c853e206c55a9f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;677&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"135\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"677\" data-original=\"https://pic1.zhimg.com/v2-8290a53c7949a9673c853e206c55a9f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8290a53c7949a9673c853e206c55a9f0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>整个 <code>ae_select</code> 子模块中最重要的函数就是 <code>aeApiPoll</code>，它是实际调用 <code>select</code> 函数的部分，其作用就是在 I/O 多路复用函数返回时，将对应的 FD 加入 <code>aeEventLoop</code> 的 <code>fired</code> 数组中，并返回事件的个数：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-a31443d5bdb32e6549af9b24ac921c8b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"678\" data-original=\"https://pic4.zhimg.com/v2-a31443d5bdb32e6549af9b24ac921c8b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;678&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"678\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"678\" data-original=\"https://pic4.zhimg.com/v2-a31443d5bdb32e6549af9b24ac921c8b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a31443d5bdb32e6549af9b24ac921c8b_b.jpg\"/></figure><p>封装 epoll 函数</p><p>Redis 对 <code>epoll</code> 的封装其实也是类似的，使用 <code>epoll_create</code> 创建 <code>epoll</code> 中使用的 <code>epfd</code>：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1ef9ceddda89a82c0bde91c7635c3346_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"676\" data-original=\"https://pic3.zhimg.com/v2-1ef9ceddda89a82c0bde91c7635c3346_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;676&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"676\" data-original=\"https://pic3.zhimg.com/v2-1ef9ceddda89a82c0bde91c7635c3346_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1ef9ceddda89a82c0bde91c7635c3346_b.jpg\"/></figure><p>在 <code>aeApiAddEvent</code> 中使用 <code>epoll_ctl</code> 向 <code>epfd</code> 中添加需要监控的 FD 以及监听的事件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-961a20d72571a3dfdb859cbebdf7e7ba_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"676\" data-original=\"https://pic3.zhimg.com/v2-961a20d72571a3dfdb859cbebdf7e7ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;676&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"676\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"676\" data-original=\"https://pic3.zhimg.com/v2-961a20d72571a3dfdb859cbebdf7e7ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-961a20d72571a3dfdb859cbebdf7e7ba_b.jpg\"/></figure><p>由于 <code>epoll</code> 相比 <code>select</code> 机制略有不同，在 <code>epoll_wait</code> 函数返回时并不需要遍历所有的 FD 查看读写情况；在 <code>epoll_wait</code> 函数返回时会提供一个 <code>epoll_event</code> 数组：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-11c78608d66b38a54fe16ef11255a960_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb\" width=\"680\" data-original=\"https://pic1.zhimg.com/v2-11c78608d66b38a54fe16ef11255a960_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;680&#39; height=&#39;217&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"680\" data-rawheight=\"217\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"680\" data-original=\"https://pic1.zhimg.com/v2-11c78608d66b38a54fe16ef11255a960_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-11c78608d66b38a54fe16ef11255a960_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其中保存了发生的 <code>epoll</code> 事件（ <code>EPOLLIN</code>、 <code>EPOLLOUT</code>、 <code>EPOLLERR</code> 和 <code>EPOLLHUP</code>）以及发生该事件的 FD。</p><p><code>aeApiPoll</code> 函数只需要将 <code>epoll_event</code> 数组中存储的信息加入 <code>eventLoop</code> 的 <code>fired</code> 数组中，将信息传递给上层模块：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d7c878a6b739f7c544428647122d6914_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb\" width=\"679\" data-original=\"https://pic1.zhimg.com/v2-d7c878a6b739f7c544428647122d6914_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;679&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"679\" data-rawheight=\"436\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"679\" data-original=\"https://pic1.zhimg.com/v2-d7c878a6b739f7c544428647122d6914_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d7c878a6b739f7c544428647122d6914_b.jpg\"/></figure><p>子模块的选择</p><p>因为 Redis 需要在多个平台上运行，同时为了最大化执行的效率与性能，所以会根据编译平台的不同选择不同的 I/O 多路复用函数作为子模块，提供给上层统一的接口；在 Redis 中，我们通过宏定义的使用，合理的选择不同的子模块：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b692a4fd37111d08f93866fda1fc9823_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb\" width=\"677\" data-original=\"https://pic4.zhimg.com/v2-b692a4fd37111d08f93866fda1fc9823_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;677&#39; height=&#39;277&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"677\" data-rawheight=\"277\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"677\" data-original=\"https://pic4.zhimg.com/v2-b692a4fd37111d08f93866fda1fc9823_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b692a4fd37111d08f93866fda1fc9823_b.jpg\"/></figure><p>因为 <code>select</code> 函数是作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现，所以将其作为保底方案：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-afab33e744d8878db13d65a8dc5db0ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1182\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-afab33e744d8878db13d65a8dc5db0ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;1182&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"1182\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-afab33e744d8878db13d65a8dc5db0ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-afab33e744d8878db13d65a8dc5db0ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Redis 会优先选择时间复杂度为 O(1) 的 I/O 多路复用函数作为底层实现，包括 Solaries 10 中的 <code>evport</code>、Linux 中的 <code>epoll</code> 和 macOS/FreeBSD 中的 <code>kqueue</code>，上述的这些函数都使用了内核内部的结构，并且能够服务几十万的文件描述符。</p><p>但是如果当前编译环境没有上述函数，就会选择 <code>select</code> 作为备选方案，由于其在使用时会扫描全部监听的描述符，所以其时间复杂度较差 O(n)，并且只能同时服务 1024 个文件描述符，所以一般并不会以 <code>select</code> 作为第一方案使用。</p><p></p>", 
            "topic": [
                {
                    "tag": "Redis", 
                    "tagLink": "https://api.zhihu.com/topics/19557280"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64167089", 
            "userName": "Java猫说", 
            "userLink": "https://www.zhihu.com/people/2b6e3966225e27d4147586a830958d71", 
            "upvote": 0, 
            "title": "我每天重复写这个API，没有一次请求状态码是200", 
            "content": "<p></p><blockquote> 本博客 <a href=\"https://link.zhihu.com/?target=https%3A//unclecatmyself.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">猫叔的博客</a>，转载请申明出处</blockquote><p>我是一个普通的比你还普通的代码撰写人员，甚至不敢号称是程序员，我每天起床都接到这样一个任务，我需要去完成一个API，一个普通的API，我可以不用写文档、不用写注释、不用准备思维导图......</p><p>我不知道是谁给我下的命令，不知道是这个API是要给谁调用，不知道要服务于什么，这一切都需要我去设想。</p><p>我的脑袋经常把这件事情给遗忘，生活与工作的各种事情，即使是刷刷手机讯息都可能会排在这件事情的前面，但是每日醒来我还是会意识到这样的一个任务。</p><p>我开始去完成这个模糊的API任务，毕竟很多人都能写出一个漂亮的API。</p><p>在我这边完成的过程中，我遇到了第一个难题：我要选择什么语言？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-33ee98c5364453c66f0aef3a31cfbc85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"916\" data-rawheight=\"761\" class=\"origin_image zh-lightbox-thumb\" width=\"916\" data-original=\"https://pic2.zhimg.com/v2-33ee98c5364453c66f0aef3a31cfbc85_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;916&#39; height=&#39;761&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"916\" data-rawheight=\"761\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"916\" data-original=\"https://pic2.zhimg.com/v2-33ee98c5364453c66f0aef3a31cfbc85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-33ee98c5364453c66f0aef3a31cfbc85_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上了<a href=\"https://link.zhihu.com/?target=http%3A//www.tiobe.com\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">tiobe.com</span><span class=\"invisible\"></span></a>，查看了世界排行，发现我所比较熟悉的Java暂时还是第一，不过看到各种自己完全不熟悉的语言，还是感觉压力山大。</p><p>问了几个比较厉害的朋友，他们也各有说辞，都推荐他们所认可的语言，我像是一滩水，他们就像各种器皿，希望我能进入他们的空间一般。</p><p>好吧，为了这个API我选择进入Java这个器皿中。</p><p>如果可以的话，或许是我不自量力，我更希望进入一个我真心喜欢的器皿中，GC也好、指针也罢，我需要的就存在，我不需要的请给我隐藏，我看到过一个厉害的人，他就自己创造了一门语言。</p><p>接下来，我发现我还需要选择数据存储相关的，厉害的人都叫他们数据库，那些人可以轻易的说出什么是关系型数据库、什么是非关系型数据库，业务逻辑强的时候可以选择MySQL，搜索量大的时候你就加索引，如果有兴趣搭建搜索引擎，你甚至可以使用ElasticSearch；而Mongo DB则适合分布式文件存储，对，还有HBase面向列的存储，他们其中还有一些是开源的，如果你能去贡献一点代码，我想这也足够你吹捧一段时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e86ea2c5d00024003186faf907cb169e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"474\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb\" width=\"474\" data-original=\"https://pic3.zhimg.com/v2-e86ea2c5d00024003186faf907cb169e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;474&#39; height=&#39;315&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"474\" data-rawheight=\"315\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"474\" data-original=\"https://pic3.zhimg.com/v2-e86ea2c5d00024003186faf907cb169e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e86ea2c5d00024003186faf907cb169e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我是一个老实人，我踏踏实实的选择了MySQL，毕竟我的这个API究竟要用在什么业务，我也不清楚。</p><p>听说有多数据源，可以根据业务来动态切换数据源，我想这种好东西，还是有人能帮我写好就行了。</p><p>我没有什么项目经验，不知道接下来的步骤对不对，希望大家可以不要鄙视我，毕竟现在什么职场都有鄙视链了，我是一个腼腆且自尊心强的人，你说一句我可能会想很久。</p><p>我觉得需要去选择一个框架，但是渐渐的，我发现这是一个套路，一个越来越深的套路，我选择了Java、MySQL，那么我需要选择的框架就需要是Java写的快速搭建Web的框架，而且我需要数据映射框架也是对应能接通Java和MySQL的。</p><p>我开始有种被绑手绑脚的感觉，Spring、SpringMVC、SpringBoot、SpringCloud、Spring Data JPA、MyBatis、Hibernate等等。</p><p>我不情愿的选择了可以让我快速完成这个任务的大众系列：SpringBoot+JPA。</p><p>原来jpa其实底层也是Hibernate，难怪有些东西，用起来比较熟悉，我希望接下来没有选择了，可是我还是太大意了。</p><p>我不知道我需要继续完成什么了。</p><p>我很传统的构建了dao、service、controller等包，并针对这个API构建了对应的类，可是构建这些东西，其实IDEA都帮我做好了，我不知道我要写什么...</p><p>我陷入了沉思...一天、两天、一个月、一年...十年...</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b9ee3f50874e04f0b38f0176df7eb515_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"858\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb\" width=\"858\" data-original=\"https://pic2.zhimg.com/v2-b9ee3f50874e04f0b38f0176df7eb515_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;858&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"858\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"858\" data-original=\"https://pic2.zhimg.com/v2-b9ee3f50874e04f0b38f0176df7eb515_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b9ee3f50874e04f0b38f0176df7eb515_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在经过生活与职场冲刷后，我在某个夜里有梦到了有这样的一件事情没有做完，我立马起身，将桌上的烟灰缸清理了一下，放到一侧，然后重新点了一支双喜，打开IDEA，将十年前放在GitHub上的项目clone下来。</p><p>深吸一口烟，“呼········”</p><p>我想我想清楚这个API的完整路径了。</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">https</span><span class=\"o\">:</span><span class=\"c1\">//life/meaning?who=myself   **GET**\n</span></code></pre></div><p>很抱歉，说到这里，本文终了。</p><p>我不能和你说我的业务实现写了什么，而那段代码我也没有push到GitHub上，因为我觉得任何一个读者写出来的都将比我珍贵。</p><p>再和你说一点秘密，在我完成API请求路径后，我在往后的十年、二十年都在不断的修改业务实现的代码，我甚至加入了MQ、Netty等等。</p><p>但是我在梦中却一直请求不成功，从来没有看到一次200。</p><p>我可以和你说得再明白一点，所有人的请求结果都是一样的，但是每个人的实现业务都是不一样的，甚至你选择了C、C#、PHP、Python。</p><p>但是，结果都是一样的，即使你认为是最完美的代码了。</p><p>结果都是...</p><div class=\"highlight\"><pre><code class=\"language-js\"><span class=\"nx\">Just</span> <span class=\"nx\">Do</span> <span class=\"nx\">it</span><span class=\"o\">!</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a8c2a80b0d917abcddf6f969c585df04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1247\" data-rawheight=\"776\" class=\"origin_image zh-lightbox-thumb\" width=\"1247\" data-original=\"https://pic1.zhimg.com/v2-a8c2a80b0d917abcddf6f969c585df04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1247&#39; height=&#39;776&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1247\" data-rawheight=\"776\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1247\" data-original=\"https://pic1.zhimg.com/v2-a8c2a80b0d917abcddf6f969c585df04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a8c2a80b0d917abcddf6f969c585df04_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这是我临终时最后一次运行代码看到的结果，并成为了我的墓志铭，我是一个普通的代码撰写者，你不需要知道我是谁，我只是作者笔下的虚无幻想，但是请你认清，你是谁！？</p><p></p>", 
            "topic": [
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62907501", 
            "userName": "Strive追逐者", 
            "userLink": "https://www.zhihu.com/people/6625ea9b867135ace7c366fcff49009d", 
            "upvote": 1, 
            "title": "oracle的分页查询：", 
            "content": "<div class=\"highlight\"><pre><code class=\"language-text\">---创建Employees\ncreate table Employees(\n       employeeID varchar2(6) primary key,\n       ename varchar2(10) not null,\n       Birthday date not null,\n       sex char(4) not null,\n       address varchar2(20) ,\n       zip varchar2(6),\n       Phonenumber varchar2(12),\n       Emailaddress varchar2(30),\n       departmentID varchar2(3) not null\n); </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">---创建Departments\ncreate table Departments(\n       departmentID varchar2(3) primary key,\n       departmentName varchar2(30) not null,\n       note varchar2(16)\n);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">---创建Salary\ncreate table Salary(\n       employeeID  varchar2(6) primary key,/\n       income number(8,2) not null,\n       outcome number(8,2) not null\n\n);</code></pre></div><hr/><div class=\"highlight\"><pre><code class=\"language-text\">--插入测试数据\ninsert into Employees(Employeeid,ename,Birthday,sex,Departmentid) values(010001,&#39;王平&#39;,to_date(&#39;1981-01-05&#39;,&#39;yyyy-mm-dd&#39;),&#39;女&#39;,&#39;1&#39;);\ninsert into Employees(Employeeid,ename,Birthday,sex,Departmentid) values(010003,&#39;韦严平&#39;,to_date(&#39;1979-11-05&#39;,&#39;yyyy-mm-dd&#39;),&#39;女&#39;,&#39;2&#39;);\ninsert into Employees(Employeeid,ename,Birthday,sex,Departmentid) values(010021,&#39;吴庆红&#39;,to_date(&#39;1984-07-02&#39;,&#39;yyyy-mm-dd&#39;),&#39;女&#39;,&#39;3&#39;);\ninsert into Employees(Employeeid,ename,Birthday,sex,Departmentid) values(010031,&#39;李方&#39;,to_date(&#39;1980-8-4&#39;,&#39;yyyy-mm-dd&#39;),&#39;女&#39;,&#39;4&#39;);\ninsert into Employees(Employeeid,ename,Birthday,sex,Departmentid) values(010005,&#39;李明&#39;,to_date(&#39;1985-02-10&#39;,&#39;yyyy-mm-dd&#39;),&#39;女&#39;,&#39;5&#39;);</code></pre></div><hr/><div class=\"highlight\"><pre><code class=\"language-text\">insert into Departments(departmentID,departmentName)values(1,&#39;办公室&#39;);\ninsert into Departments(departmentID,departmentName)values(2,&#39;人力资源&#39;);\ninsert into Departments(departmentID,departmentName)values(3,&#39;销售部&#39;);\ninsert into Departments(departmentID,departmentName)values(4,&#39;财务部&#39;);\ninsert into Departments(departmentID,departmentName)values(5,&#39;生产部&#39;);</code></pre></div><hr/><div class=\"highlight\"><pre><code class=\"language-text\">insert into Salary values(010001,3000,100);\ninsert into Salary values(010003,3000,50);\ninsert into Salary values(010021,5000,50);\ninsert into Salary values(010031,3000,50);\ninsert into Salary values(010005,2500,50);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">    ---添加外键约束 \n    alter table Employees add constraints fk_e_d_departtmentID foreign key(departmentID) references Departments(departmentID) \n    alter table Employees add constraints ck_sex check(sex=&#39;男&#39; or sex=&#39;女&#39;)---只能选择男或者女\n    alter table Departments add constraints un_departmentName unique(departmentName)</code></pre></div><div class=\"highlight\"><pre><code class=\"language-text\"> ---增加字段\n    alter table Employees add qq number(15)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">    update salary  set  income=2890 where employeeID=010001\n    update  Departments set departmentName=&#39;生产计划部&#39; where departmentName=&#39;生产部&#39;\n    update salary  set  income=income+100</code></pre></div><hr/><div class=\"highlight\"><pre><code class=\"language-text\">-----oracle的分页查询\n   --问题：当一个表中的数据量特别大的时候，如果一次性全部显示给用户，则造成页面过于庞大，体验极差。\n   --解决：使用分页查询\n   --使用：\n      --rownum关键字：oracle对外提供的自动给查询结果编号的关键字，与每行的数据没有关系。\n        --注意：rownum关键字只能做&lt; &lt;=的判断，不能进行&gt; &gt;=的判断\n      select rownum ,e.* from emp e;\n      \n      --查询员工信息的前5条数据 第一页数据\n      select rownum r,e.* from emp e where rownum &lt;=5;\n      select * from (select rownum r,e.* from emp e where rownum &lt;=5) t where r&gt;0;\n      --查询员工信息的6-10条数据 第二页数据\n      select rownum r,e.* from emp e where rownum &lt;=10;\n      select rownum,t.* from (select rownum r,e.* from emp e where rownum &lt;=10) t where r&gt;5;\n      --查询员工信息的11-15条数据 第三页数据\n      select rownum r,e. * from emp e where rownum&lt;=15;\n      select * from (select rownum r,e. * from emp e where rownum&lt;=15) t where r&gt;10;\n      --分页规律总结：每页显示m条数据，查询第n页数据\n      select * from (select rownum r,e. * from 要分页的表 e where rownum&lt;=m*n) t where r&gt;m*n-m ;\n             --要分页的表既可以是真实的表，也可以是一个查询语句\n      --分页查询员工信息按照工资排序\n      select * from (select rownum r,t.* from (select * from emp  order by sal) t where rownum&lt;=10 ) where r&gt;5\n      \n      select * from t\n      \n      select * from emp</code></pre></div>", 
            "topic": [
                {
                    "tag": "Oracle 数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19660156"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63056257", 
            "userName": "Strive追逐者", 
            "userLink": "https://www.zhihu.com/people/6625ea9b867135ace7c366fcff49009d", 
            "upvote": 1, 
            "title": "Java高级入门：Spring框架", 
            "content": "<p><b>spring的概念：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Spring是一个轻量级控制反转(IoC)和面向切面(AOP)的容器框架。\nIoC : Inversion of Control\nAOP : Aspect Oriented Programming</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Spring4具有哪些新特性？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">删除了不常用的废弃的包和方法，支持部分JDK8的新特性，和JAVAEE7.</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>简述SpringIoC程序环境搭建步骤？</b></p><p>1.导入jar包。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5db0a797a21bed1f3caf91cf848bdf80_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-5db0a797a21bed1f3caf91cf848bdf80_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;468&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"468\" data-rawheight=\"158\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"468\" data-original=\"https://pic1.zhimg.com/v2-5db0a797a21bed1f3caf91cf848bdf80_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5db0a797a21bed1f3caf91cf848bdf80_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3dc5fe396d8c1a367b50770e09c5ed16_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"892\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb\" width=\"892\" data-original=\"https://pic3.zhimg.com/v2-3dc5fe396d8c1a367b50770e09c5ed16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;892&#39; height=&#39;816&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"892\" data-rawheight=\"816\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"892\" data-original=\"https://pic3.zhimg.com/v2-3dc5fe396d8c1a367b50770e09c5ed16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3dc5fe396d8c1a367b50770e09c5ed16_b.jpg\"/></figure><p>2.创建Spring配置文件</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7bc7c7536779e68d81c4c72199f3b784_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1278\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb\" width=\"1278\" data-original=\"https://pic1.zhimg.com/v2-7bc7c7536779e68d81c4c72199f3b784_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1278&#39; height=&#39;569&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1278\" data-rawheight=\"569\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1278\" data-original=\"https://pic1.zhimg.com/v2-7bc7c7536779e68d81c4c72199f3b784_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7bc7c7536779e68d81c4c72199f3b784_b.jpg\"/></figure><p>3.bean的注册和定义</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-3e27efbb10e8af39d74877aefbd59c14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1241\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb\" width=\"1241\" data-original=\"https://pic1.zhimg.com/v2-3e27efbb10e8af39d74877aefbd59c14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1241&#39; height=&#39;418&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1241\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1241\" data-original=\"https://pic1.zhimg.com/v2-3e27efbb10e8af39d74877aefbd59c14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-3e27efbb10e8af39d74877aefbd59c14_b.jpg\"/></figure><p><b>4.从是spring容器中获取bean。</b></p><div class=\"highlight\"><pre><code class=\"language-text\">定义一个没有返回值的接口.</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-11c8856ab3b1a704144249d4fc220736_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb\" width=\"580\" data-original=\"https://pic3.zhimg.com/v2-11c8856ab3b1a704144249d4fc220736_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;580&#39; height=&#39;262&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"580\" data-rawheight=\"262\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"580\" data-original=\"https://pic3.zhimg.com/v2-11c8856ab3b1a704144249d4fc220736_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-11c8856ab3b1a704144249d4fc220736_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">定义一个实现类</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-55187355dc80756f53cf7dd443cd97ec_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb\" width=\"785\" data-original=\"https://pic1.zhimg.com/v2-55187355dc80756f53cf7dd443cd97ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;785&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"785\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"785\" data-original=\"https://pic1.zhimg.com/v2-55187355dc80756f53cf7dd443cd97ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-55187355dc80756f53cf7dd443cd97ec_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">写一个测试类</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-53083e4cfd466d3f0b4993baf8dc9f4e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-53083e4cfd466d3f0b4993baf8dc9f4e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;998&#39; height=&#39;478&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"478\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"998\" data-original=\"https://pic3.zhimg.com/v2-53083e4cfd466d3f0b4993baf8dc9f4e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-53083e4cfd466d3f0b4993baf8dc9f4e_b.jpg\"/></figure><hr/><p><b>IOC与DI</b></p><p>IoC</p><div class=\"highlight\"><pre><code class=\"language-text\">控制反转（IoC，Inversion of Control），是一个概念，是一种思想。控制反转就\n是对对象控制权的转移，从程序代码本身反转到了外部容器。把对象的创建、初始化、\n销毁等工作交给spring容器来做。由spring容器控制对象的生命周期。</code></pre></div><p>DI</p><div class=\"highlight\"><pre><code class=\"language-text\">依赖注入：Dependency Injection。依赖注入DI是指程序运行过程中，若需要调用另\n一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创\n建后传递给程序。\n依赖注入是目前最优秀的解耦方式。依赖注入让Spring的Bean之间以配置文件的方式\n组织在一起，而不是以硬编码的方式耦合在一起的。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>IoC与DI的关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">IoC是一个概念，是一种思想，其实现方式多种多样。当前比较流行的实现方式之一\n是DI。</code></pre></div><hr/><h2>Bean的装配：</h2><p>Bean的装配，即Bean对象的创建。</p><div class=\"highlight\"><pre><code class=\"language-text\">1.默认装配方式(构造方式)\n2.动态工厂Bean\n3. 静态工厂Bean\n4.Bean的作用域(单态模式singleton\\原型模式prototype)</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>基于XML的DI</b></p><p>所谓注入，可理解为对象的属性赋值。</p><p>设值注入：</p><div class=\"highlight\"><pre><code class=\"language-text\">1.简单数据类型和引用数据类型注入\n2. 集合属性注入(array、set、list、map、properties)\n3.域属性自动注入（byName\\byType；局部和全局配置）\n4. 空字符串或null的注入</code></pre></div><p>构造注入：</p><p>基于注解的DI</p><div class=\"highlight\"><pre><code class=\"language-text\">1.环境搭建：导入aop包、添加context约束头信息（组件扫描器）\n2.常用注解：@Component、@Scope、@Value、@Resource、\n@Autowired</code></pre></div><h2>附码：</h2><p><b>配置文件的扫描器：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;\n&lt;beans xmlns=&#34;Index of /schema/beans&#34;\n    xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;\n    xmlns:context=&#34;Index of /schema/context&#34; xsi:schemaLocation=&#34;\n        Index of /schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        Index of /schema/context http://www.springframework.org/schema/context/spring-context.xsd&#34;&gt; &lt;!-- bean definitions here --&gt;\n\t\t&lt;!-- 扫描器 --&gt;\n\t\t&lt;context:component-scan base-package=&#34;cn.msk.pojo&#34;&gt;&lt;/context:component-scan&gt;\n&lt;/beans&gt;</code></pre></div><p>实现类：</p><p>Msk实现类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n/**\n * 表示当前类交给Spring容器管理\n * @author Administrator\n *\n */\n@Component(&#34;myname&#34;)\npublic class Fll {\n\t@Value(&#34;爱莫淞凯&#34;)\n\tprivate String name;\n\n\t\n\n\t@Override\n\tpublic String toString() {\n\t\treturn &#34;Fll [name=&#34; + name + &#34;]&#34;;\n\t}\n\t\n}</code></pre></div><p>Fll实现类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.pojo;\n\nimport javax.annotation.Resource;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n/**\n * 表示当前类交给spring容器管理\n * @author Administrator\n *与@Component功能相同的三个注解：\n *\t@Service:该注解添加在Service实现类上\n *\t@Controller:该注解添加在Dao实现类上\n *\t@Repository：该注解添加在Repository类上。\n *\n */\n@Component\n//作用是声明取值的类型。\n@Scope(&#34;prototype&#34;)\npublic class Msk {\n\t//Value是注入简单数据类型的\n\t@Value(&#34;富萝莉&#34;)\n\tprivate String name;\n\t@Value(&#34;20&#34;)\n\tprivate int age;\n\t//@Autowired是注入引用数据类型的，：默认情况下是byType方式注入，spring的注解。\n/*  @Autowired\n\t//如果要使用byName方式，需要联合@Qualifier注解，需要在另外一个实体类的@Component标签后边加上(&#34;名称&#34;)\n\t@Qualifier(&#34;myname&#34;)\n*/\n\t//引用数据类型的第二种注解，通过@Resource也可以实现注入，默认情况下是byName方式注入，只有找不到与名称相匹配的bean时，才会以类型方式注入.jdk的注解\n\t@Resource\n\tprivate Fll fll;\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn &#34;Msk [name=&#34; + name + &#34;, age=&#34; + age + &#34;, fll=&#34; + fll + &#34;]&#34;;\n\t}\n\t\n\t\n}</code></pre></div><p>测试类：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.pojo;\n\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class TestDI {\n\t@Test\n\tpublic void TestDI1() {\n\t\t//创建容器\n\t\tApplicationContext text = new ClassPathXmlApplicationContext(&#34;zhujie.xml&#34;);\n\t\tMsk bean = text.getBean(&#34;msk&#34;, Msk.class);\n\t\tSystem.out.println(bean);\n\t}\n}</code></pre></div><p>jar包和输出：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f3d352d6fa6224e6258527c7563b05bb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1472\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb\" width=\"1472\" data-original=\"https://pic4.zhimg.com/v2-f3d352d6fa6224e6258527c7563b05bb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1472&#39; height=&#39;251&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1472\" data-rawheight=\"251\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1472\" data-original=\"https://pic4.zhimg.com/v2-f3d352d6fa6224e6258527c7563b05bb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f3d352d6fa6224e6258527c7563b05bb_b.jpg\"/></figure><p><b>以上输出纯属意外。</b></p><hr/><p>为什么使用代理？</p><div class=\"highlight\"><pre><code class=\"language-text\">\t1.可以隐藏目标类的具体实现;\n\t2.在不修改目标类代码的情况下能够对其功能进行增强。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代理分类：代理分为静态代理和动态代理</b></p><p><b>静态代理：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">若代理类在程序运行前就已经存在，那么这种代理方式被成为 静态代理 ，\n这种情况下的代理类通常都是我们在Java代码中定义的。 通常情况下， 静\n态代理中的代理类和目标类会实现同一接口或是派生自相同的父类。</code></pre></div><p><b>静态代理的实现（目标类和代理类实现相同接口）</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>动态代理：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情\n况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代\n码中的“指示”动态生成的。</code></pre></div><blockquote>常用的动态代理有两类：JDK动态代理和CGLIB动态代理</blockquote><div class=\"highlight\"><pre><code class=\"language-text\">\t1.如果目标对象实现了接口，采用JDK的动态代理\n\t2.如果目标对象没有实现了接口，必须采用CGLIB动态代理</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">\tJDK动态代理（JDK 提供的代理实现）\n\tCGLIB动态代理（引入cglib的jar包）</code></pre></div><hr/><p><b>Aop介绍：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">面向切面编程，就是将交叉业务逻辑封装成切面，利用AOP的功能将切面织入到主业务逻辑中。所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。\n若不使用AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。\n这样，会使主业务逻辑变的混杂不清。</code></pre></div><p><b>Aop基本术语介绍：</b></p><p><b>切面：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">切面泛指交叉业务逻辑。比如事务处理、日志处理就可以理解为切面。常用的切面\n有通知与顾问。实际就是对主业务逻辑的一种增强。</code></pre></div><p><b>织入：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">织入是指将切面代码插入到目标对象的过程。</code></pre></div><p><b>连接点：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">连接点指切面可以织入的位置。</code></pre></div><p><b>切入点：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">切入点指切面具体织入的位置。</code></pre></div><p><b>通知：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">(Advice通知是切面的一种实现，可以完成简单织入功能（织入功能就是在这里完成的）。\n通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同。</code></pre></div><p><b>顾问(Advisor)：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">顾问是切面的另一种实现，能够将通知以更为复杂的方式织入到目标对象中，是将通知包装为更复杂切面的装配器。 不仅指定了切入时间点,还可以指定具体的切入点</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>AOP编程环境搭建：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">导入两个jar包(aop/aopalliance)\nSpring对AOP的实现（基于Schema-based方式）</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>常用通知分类：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">前置通知(MethodBeforeAdvice)\n后置通知(AfterReturningAdvice)\n环绕通知(MethodInterceptor)\n异常处理通知(ThrowsAdvice)</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "高级Java工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19717704"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63141443", 
            "userName": "Strive追逐者", 
            "userLink": "https://www.zhihu.com/people/6625ea9b867135ace7c366fcff49009d", 
            "upvote": 1, 
            "title": "Java高级入门(2)Spring框架AOP和IOC详解：", 
            "content": "<p><b>AOP的理解：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">面向切面编程，就是将交叉业务逻辑封装成切面，利用AOP的功能将切面织入到主业务逻辑中。\n所谓交叉业务逻辑是指，通用的、与主业务逻辑无关的代码，如安全检查、事务、日志等。</code></pre></div><p><b>使用AOP编程思想的好处：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">若不使用AOP，则会出现代码纠缠，即交叉业务逻辑与主业务逻辑混合在一起。这样，会使主业务逻辑变的混杂不清。\n业务逻辑的增强</code></pre></div><p><b>如何搭建AOP编程环境：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">导入jar包，两个jar包(aop/aopalliance)</code></pre></div><p><b>附码：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;\n&lt;beans xmlns=&#34;Index of /schema/beans&#34;\n    xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;\n    xsi:schemaLocation=&#34;\n        Index of /schema/beans \n        http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;\n        &lt;!-- 定义目标 --&gt;\n       &lt;bean id=&#34;someServiceimpl&#34; class=&#34;cn.msk.service.impl.SomeServiceimpl&#34;&gt;&lt;/bean&gt; \n       &lt;!-- 切面:前置通知 --&gt;\n       &lt;bean id=&#34;mymethodBefor&#34; class=&#34;cn.msk.aspect.MymethodBefor&#34;&gt;&lt;/bean&gt;\n       &lt;!-- 切面:后置通知 --&gt;\n       &lt;bean id=&#34;houzhitouzhi&#34; class=&#34;cn.msk.aspect.houzhitouzhi&#34;&gt;&lt;/bean&gt;\n       &lt;!-- 切面:环绕通知 --&gt;\n       &lt;bean id=&#34;haunrao&#34; class=&#34;cn.msk.aspect.haunrao&#34;&gt;&lt;/bean&gt;\n       &lt;!-- 切面:异常通知 --&gt;\n       &lt;bean id=&#34;myyihcang&#34; class=&#34;cn.msk.aspect.Myyihcang&#34;&gt;&lt;/bean&gt;\n       \n       &lt;!-- 注册切面 --&gt;\n       &lt;bean id=&#34;proxyFactoryBean&#34; class=&#34;org.springframework.aop.framework.ProxyFactoryBean&#34;&gt;\n       \t&lt;!-- 指定目标对象 --&gt;\n       \t&lt;property name=&#34;target&#34; ref=&#34;someServiceimpl&#34;&gt;&lt;/property&gt;\n       \t&lt;!-- 指定目标类实现的所有接口 --&gt;\n       \t&lt;property name=&#34;interfaces&#34; value=&#34;cn.msk.service.SomeService&#34;&gt;&lt;/property&gt;\n       \t&lt;!-- 指定切面 --&gt;\n       \t&lt;property name=&#34;interceptorNames&#34; value=&#34;myyihcang&#34;&gt;&lt;/property&gt;\n       &lt;/bean&gt;\n       \n&lt;/beans&gt;</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3592d0a77ca7fdc604a66a20d743a59f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"895\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb\" width=\"895\" data-original=\"https://pic4.zhimg.com/v2-3592d0a77ca7fdc604a66a20d743a59f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;895&#39; height=&#39;579&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"895\" data-rawheight=\"579\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"895\" data-original=\"https://pic4.zhimg.com/v2-3592d0a77ca7fdc604a66a20d743a59f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3592d0a77ca7fdc604a66a20d743a59f_b.jpg\"/></figure><p><b>业务层：Service</b></p><p><b>里面有：</b></p><p><b>SomeService接口/SomeServiceImpl实现类</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.service;\n\npublic interface SomeService {\n\tvoid doSome();\n\tString doOther();\n}</code></pre></div><p><b>实现类：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.service.impl;\n\nimport cn.msk.service.SomeService;\n\npublic class SomeServiceimpl implements SomeService{\n\n\t@Override\n\tpublic void doSome() {\n\t\tSystem.out.println(&#34;SomeServiceimpl.doSome()&#34;+&#34;方法执行&#34;+1/0);\n\t\t\n\t}\n\n\t@Override\n\tpublic String doOther() {\n\t\tSystem.out.println(&#34;SomeServiceimpl.doOther()&#34;+&#34;方法执行&#34;);\n\t\treturn &#34;Love&#34;;\n\t}\n\n}</code></pre></div><p><b>定义一个切面包（aspect）存放切面方法：</b></p><p>环绕通知：附码</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.aspect;\n\nimport org.aopalliance.intercept.MethodInterceptor;\nimport org.aopalliance.intercept.MethodInvocation;\n\npublic class haunrao implements MethodInterceptor {\n\n\t@Override\n\tpublic Object invoke(MethodInvocation fanhuizhi) throws Throwable {\n\tSystem.out.println(&#34;环绕通知执行前&#34;);\n\t//调用目标方法\n\tObject proceed = fanhuizhi.proceed();\n\tif (proceed != null) {\n\t\tproceed=((String)proceed).toUpperCase();\n\t}\n\tSystem.out.println(&#34;环绕通知执行后&#34;);\n\t\treturn proceed;\n\t}\n\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>后置通知：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.aspect;\n\nimport java.lang.reflect.Method;\n\nimport org.springframework.aop.AfterReturningAdvice;\n\npublic class houzhitouzhi implements AfterReturningAdvice {\n\t/**\n\t * 切面:后置通知\n\t * \n\t * returnValue:目标方法的返回值\n\t */\n\t@Override\n\tpublic void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n\t\tSystem.out.println(&#34;后置方法的返回值&#34;);\n\t\tif (returnValue !=null) {\n\t\t\tSystem.out.println(&#34;如果不为空则输出:&#34;+((String)returnValue).toUpperCase());\n\t\t}\n\t}\n\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>前置通知：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.aspect;\n\nimport java.lang.reflect.Method;\n\nimport org.springframework.aop.MethodBeforeAdvice;\n\npublic class MymethodBefor implements MethodBeforeAdvice {\n\n\t@Override\n\tpublic void before(Method method, Object[] args, Object target) throws Throwable {\n\t\tSystem.out.println(&#34;spring框架，把简单的东西复杂化，让别人看不懂！&#34;);\n\t\t\n\t}\n\n}</code></pre></div><p>异常通知：</p><div class=\"highlight\"><pre><code class=\"language-text\">package cn.msk.aspect;\n\nimport org.springframework.aop.ThrowsAdvice;\n\npublic class Myyihcang implements ThrowsAdvice {\n\tpublic void afterThrowing(Exception ex) {\n\t\tSystem.out.println(&#34;异常通知执行&#34;);\n\t}\n}</code></pre></div><hr/><p><b>Spring、AspectJ和AOP三者之间的关系：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">对于AOP这种编程思想，很多框架都进行了实现。Spring就是其中之一，可以完成面向切面编程。\n然而，AspectJ也实现了AOP的功能，且其实现方式更为简捷，使用更为方便，而且还支持注解式开发。\n所以，Spring又将AspectJ的对于AOP的实现也引入到了自己的框架中。\n在Spring中使用AOP开发时，一般使用AspectJ的实现方式。</code></pre></div><p><b>spectJ支持的常见通知：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">前置通知\n后置通知\n环绕通知\n异常通知\n最终通知</code></pre></div><hr/><h2><b>对spring的详细说明：</b></h2><p><b>Spring是什么？为什么使用Spring?</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。\nSpring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。\nSpring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。\n\nDependency Injection(DI) 方法使得构造器和JavaBean properties文件中的依赖关系一目了然。\n与EJB容器相比较，IoC容器更加趋向于轻量级。\n这样一来IoC容器在有限的内存和CPU资源的情况下进行应用程序的开发和发布就变得十分有利。\nSpring并没有闭门造车，Spring利用了已有的技术比如ORM框架、logging框架、J2EE、Quartz和JDK Timer，以及其他视图技术。\nSpring框架是按照模块的形式来组织的。\n由包和类的编号就可以看出其所属的模块，开发者仅仅需要选用他们需要的模块即可。\n要测试一项用Spring开发的应用程序十分简单，因为测试相关的环境代码都已经囊括在框架中了。\n更加简单的是，利用JavaBean形式的POJO类，可以很方便的利用依赖注入来写入测试数据。\nSpring的Web框架亦是一个精心设计的Web MVC框架，为开发者们在web框架的选择上提供了一个除了主流框架比如Struts、过度设计的、不流行web框架的以外的有力选项。\nSpring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Spring有哪些特性？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">轻量——从大小与开销两方面而言Spring都是轻量的。\n完整的Spring框架可以在一个大小只有1MB多的JAR文件里发布。并且Spring所需的处理开销也是微不足道的。\n此外，Spring是非侵入式的：典型地，Spring应用中的对象不依赖于Spring的特定类。\n\n控制反转——Spring通过一种称作控制反转（IoC）的技术促进了松耦合。\n当应用了IoC，一个对象依赖的其它对象会通过被动的方式传递进来，而不是这个对象自己创建或者查找依赖对象。\n你可以认为IoC与JNDI相反——不是对象从容器中查找依赖，而是容器在对象初始化时不等对象请求就主动将依赖传递给它。\n\n面向切面——Spring提供了面向切面编程的丰富支持，允许通过分离应用的业务逻辑与系统级服务（例如审计（auditing）和事务（transaction）管理）进行内聚性的开发。\n应用对象只实现它们应该做的——完成业务逻辑——仅此而已。它们并不负责（甚至是意识）其它的系统级关注点，例如日志或事务支持。\n\n容器——Spring包含并管理应用对象的配置和生命周期，在这个意义上它是一种容器，你可以配置你的每个bean如何被创建——基于一个可配置原型（prototype），你的bean可以创建一个单独的实例或者每次需要时都生成一个新的实例——以及它们是如何相互关联的。\n然而，Spring不应该被混同于传统的重量级的EJB容器，它们经常是庞大与笨重的，难以使用。\n\n框架——Spring可以将简单的组件配置、组合成为复杂的应用。在Spring中，应用对象被声明式地组合，典型地是在一个XML文件里。\nSpring也提供了很多基础功能（事务管理、持久化框架集成等等），将应用逻辑的开发留给了你。\n所有Spring的这些特征使你能够编写更干净、更可管理、并且更易于测试的代码。\n它们也为Spring中的各种模块提供了基础支持。</code></pre></div><p><b>Spring的重要特征有哪些？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">AOP和IoC</code></pre></div><p><b>Spring的IOC（控制反转），主要的作用是什么，程序中如何体现Spring的控制反转？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Rod Johnson是第一个高度重视以配置文件来管理Java实例的协作关系的人，他给这种方式起了一个名字：控制反转（Inverse of Control，IoC）。\n后来Martine Fowler为这种方式起了另一个名称：依赖注入（Dependency Injection），因此不管是依赖注入，还是控制反转，其含义完全相同。\n当某个Java对象（调用者）需要调用另一个Java对象（被依赖对象）的方法时，在传统模式下通常有两种做法：\n原始做法: 调用者主动创建被依赖对象，然后再调用被依赖对象的方法。\n简单工厂模式: 调用者先找到被依赖对象的工厂，然后主动通过工厂去获取被依赖对象，最后再调用被依赖对象的方法。\n\n注意上面的主动二字，这必然会导致调用者与被依赖对象实现类的硬编码耦合，非常不利于项目升级的维护。\n使用Spring框架之后，调用者无需主动获取被依赖对象，调用者只要被动接受Spring容器为调用者的成员变量赋值即可，由此可见，使用Spring后，调用者获取被依赖对象的方式由原来的主动获取，变成了被动接受——所以Rod Johnson称之为控制反转。\n另外从Spring容器的角度来看，Spring容器负责将被依赖对象赋值给调用者的成员变量——相当于为调用者注入它依赖的实例，因此Martine Fowler称之为依赖注入。</code></pre></div><p><b>bean的作用域有哪些？各有什么不同？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。\nSpring支持如下5种作用域：\nsingleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。\n\nprototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。\n\nrequest：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。\n只有在Web应用中使用Spring时，该作用域才有效。\n\nsession：对于每次HTTP Session，使用session定义的Bean豆浆产生一个新实例，同样只有在Web应用中使用Spring时，该作用域才有效。\n\nglobalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。\n同样只有在Web应用中使用Spring时，该作用域才有效。\n\n其中比较常用的是singleton和prototype两种作用域。\n对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。\n容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。\n在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。\n如果不指定Bean的作用域，Spring默认使用singleton作用域。\nJava在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。\n因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>属性注入方式有哪三种？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">set注入\n构造注入\n工厂注入</code></pre></div><p><b>使用XML装配（xml是最常见的spring应用系统配置源）</b></p><p><b>几种spring容器都支持使用xml装配bean，包括：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">1.XmlBeanFactory:调用InputStream载入上下文定义文件。\n\n2.ClassPathXmlApplicationContext:从类路径载入上下文定义文件。\n\n3.XmlWenApplicationContext:从web应用上下文中载入定义文件。</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Spring中怎样实现自动扫描？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;context:component-scan base-package=&#34;cn.itcast&#34; /&gt;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。\n@Scope注解 作用域\n@Lazy(true) 表示延迟初始化\n\n@Service用于标注业务层组件、 \n\n@Controller用于标注控制层组件（如struts中的action）\n\n@Repository用于标注数据访问组件，即DAO组件。\n\n@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。\n\n@Scope用于指定scope作用域的（用在类上）\n\n@PostConstruct用于指定初始化方法（用在方法上）\n\n@PreDestory用于指定销毁方法（用在方法上）\n\n@Resource 默认按名称装配，当找不到与名称匹配的bean才会按类型装配。\n\n@DependsOn：定义Bean初始化及销毁时的顺序。\n@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常\n@Autowired 默认按类型装配，如果我们想使用按名称装配，\n\n@PostConstruct 初始化注解\n@PreDestroy 摧毁注解默认单例启动就加载</code></pre></div><p><b>静态代理和动态代理的关系</b></p><div class=\"highlight\"><pre><code class=\"language-text\">静态代理通常只代理一个类，动态代理是代理一个接口下的多个实现类。\n\n静态代理事先知道要代理的是什么，而动态代理不知道要代理什么东西，只有在运行时才知道。\n \n动态代理是实现 JDK 里的 InvocationHandler 接口的 invoke 方法，但注意的是代理的是接口，也就是你的\n \n业务类必须要实现接口，通过 Proxy 里的 newProxyInstance 得到代理对象。\n \n还有一种动态代理 CGLIB，代理的是类，不需要业务类继承接口，通过派生的子类来实现代理。通过在运行\n时，动态修改字节码达到修改类的目的。\n \nAOP 编程就是基于动态代理实现的，比如著名的 Spring 框架、 Hibernate 框架等等都是动态代理的使用例子。</code></pre></div><p><b>通知有哪几种类型，运行顺序是什么？</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Before:在目标方法被调用之前做增强处理,@Before只需要指定切入点表达式即可。\nAfterReturning:在目标方法正常完成后做增强,@AfterReturning除了指定切入点表达式后，还可以指定一个返回值形参名returning,代表目标方法的返回值。\nAfterThrowing:主要用来处理程序中未处理的异常,@AfterThrowing除了指定切入点表达式后，还可以指定一个throwing的返回值形参名,可以通过该形参名，\n来访问目标方法中所抛出的异常对象。\nAfter:在目标方法完成之后做增强，无论目标方法时候成功完成。@After可以指定一个切入点表达式。\nAround:环绕通知,在目标方法完成前后做增强处理,环绕通知是最重要的通知类型,像事务,日志等都是环绕通知,注意编程中核心是一个ProceedingJoinPoint</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63191405", 
            "userName": "Strive追逐者", 
            "userLink": "https://www.zhihu.com/people/6625ea9b867135ace7c366fcff49009d", 
            "upvote": 3, 
            "title": "Java EE软件工程师认证考试面试题（一）：", 
            "content": "<h2><b> 第一部分  HTML/CSS/JavaScript：</b></h2><p><b>HTML含义：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Hyper Text Markup Language 超文本标记语言，是一种用来制作“网页”的简单标记语言；用HTML编写的超文本文档称为HTML文档，HTML文档的扩展名是html或者htm\n版本变化：\n1) HTML1.0——在1993年6月作为IETF工作草案发布（并非标准）\n2) HTML 2.0——1995年11月作为RFC 1866发布\n3) HTML 3.2——1997年1月14日，W3C推荐标准\n4) HTML 4.0——1997年12月18日，W3C推荐标准\n5) HTML 4.01（微小改进）——1999年12月24日，W3C推荐标准\n6) HTML 5—2014年10月28日，W3C推荐标准HTML文档结构</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>什么是锚链接：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">锚链接是带有文本的超链接。可以跳转到页面的某个位置，适用于页面内容较多，超过一屏的场合 。分为页面内的锚链接和页面间的锚链接 。\n例如：\n      &lt;a name=”1F”&gt;1F&lt;/a&gt;&lt;a name=”2F”&gt;2F&lt;/a&gt;\n      &lt;a href=”#2F”&gt;跳转到2F标记位置&lt;/a&gt;\n 说明：\n   1.在标记位置利用a标签的name属性设置标记。\n   2.在导航位置通过a标签的href属性用#开头加name属性值即可跳转锚点位置。</code></pre></div><p><b>HTML字符实体的作用及其常用字符实体：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">有些字符，比如说“&lt;”字符，在HTML中有特殊的含义，因此不能在文本中使用。想要在HTML中显示一个小于号“&lt;”，\n需要用到字符实体：&lt;或者&lt;\n字符实体拥有三个部分：一个and符号（&amp;），一个实体名或者一个实体号，最后是一个分号（;）\n常用字符实体：</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-039ace253ab3b35d8ed2cd8fb33eb342_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-039ace253ab3b35d8ed2cd8fb33eb342_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;221&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"221\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic3.zhimg.com/v2-039ace253ab3b35d8ed2cd8fb33eb342_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-039ace253ab3b35d8ed2cd8fb33eb342_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1f92f2c4db3d229cf42c275caa27bb58_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb\" width=\"548\" data-original=\"https://pic1.zhimg.com/v2-1f92f2c4db3d229cf42c275caa27bb58_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;548&#39; height=&#39;187&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"548\" data-rawheight=\"187\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"548\" data-original=\"https://pic1.zhimg.com/v2-1f92f2c4db3d229cf42c275caa27bb58_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1f92f2c4db3d229cf42c275caa27bb58_b.jpg\"/></figure><p><b>HTML表单的作用和常用表单项类型：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">表单的作用：\n      利用表单可以收集客户端提交的有关信息。\n常用表单项类型：</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4a0442e6120995c1dafce881a4e55ae7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"585\" data-original=\"https://pic4.zhimg.com/v2-4a0442e6120995c1dafce881a4e55ae7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;585&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"585\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"585\" data-original=\"https://pic4.zhimg.com/v2-4a0442e6120995c1dafce881a4e55ae7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4a0442e6120995c1dafce881a4e55ae7_b.jpg\"/></figure><p><b>表格、框架、div三种HTML布局方式的特点：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-154b6baa8920f71b4f233f553a446b85_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb\" width=\"607\" data-original=\"https://pic2.zhimg.com/v2-154b6baa8920f71b4f233f553a446b85_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;607&#39; height=&#39;113&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"607\" data-rawheight=\"113\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"607\" data-original=\"https://pic2.zhimg.com/v2-154b6baa8920f71b4f233f553a446b85_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-154b6baa8920f71b4f233f553a446b85_b.jpg\"/></figure><p><b>CSS的定义和作用：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">CSS的定义：CSS是Cascading Style Sheets(层叠样式表)的简称。 \nCSS是一系列格式规则，它们控制网页内容的外观。CSS简单来说就是用来美化网页用的。 \nCSS的具体作用包括： \n1) 使网页丰富多彩，易于控制。\n2) 页面的精确控制，实现精美、复杂页面 。\n3) 样式表能实现内容与样式的分离，方便团队开发。\n4) 样式复用、方便网站的后期维护。</code></pre></div><p><b>CSS2常用选择器类型及其含义：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-75898823a46a594e21f43a9cd696d219_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb\" width=\"622\" data-original=\"https://pic2.zhimg.com/v2-75898823a46a594e21f43a9cd696d219_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;622&#39; height=&#39;675&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"622\" data-rawheight=\"675\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"622\" data-original=\"https://pic2.zhimg.com/v2-75898823a46a594e21f43a9cd696d219_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-75898823a46a594e21f43a9cd696d219_b.jpg\"/></figure><p><b>引入样式的三种方式及其优先级别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">三种引用方式：\n    1. 外部样式表（存放.css文件中）\n不需要style标签\n&lt;link rel=”stylesheet”  href=”引用文件地址” /&gt;\n \n       2. 嵌入式样式表\n&lt;style type=“text/css”&gt;\np{color:red;}\n&lt;/style&gt;\n \n    3.内联样式\n标签属性名为style\n&lt;p style=“color:red;”&gt;&lt;/p&gt;\n \n优先级级别：在一个页面上，自上而下，后定义优先级高。</code></pre></div><p><b>盒子模型：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">盒子模型类似于生活中的盒子，具有4个属性，外边距，内边距，边框，内容。\n 外边距：margin，用于设置元素和其他元素之间的距离。\n 内边距：padding,用于设置元素内容和边框之间的距离。\n 边框：border,用于设置元素边框粗细，颜色，线型。\n 内容：width,height,用于设置元素内容显示的大小。</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1395320086d7933e3fdd89dfcacfc8d4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"308\" class=\"content_image\" width=\"328\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;328&#39; height=&#39;308&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"328\" data-rawheight=\"308\" class=\"content_image lazy\" width=\"328\" data-actualsrc=\"https://pic1.zhimg.com/v2-1395320086d7933e3fdd89dfcacfc8d4_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">例如：\n &lt;style&gt;\n      body{\n    margin: 0;  /*取消body默认的外边距*/\n      }   \n   #img1{\n    width:200px;   /*设置图片的宽度*/\n    border: 2px solid black; /*设置图片边框*/\n    margin: 5px; \n/*设置图片外边距（表示该图片与其他图片的距离为5px）*/\n    padding:10px; /*设置图片与边框之间的距离*/\n   }   \n   #img2{\n    height: 200px; /* 设置图片的高度*/\n    border: 2px solid black; /*设置图片的边框*/\n    margin: 5px; /*设置图片外边距*/\n    padding: 20px; /*设置图片与边框之间的距离*/\n   }\n &lt;/style&gt;\n&lt;img id=&#34;img1&#34; src=&#34;img/2.jpg&#34; /&gt;\n  &lt;img id=&#34;img2&#34; src=&#34;img/lss.jpg&#34; /&gt;</code></pre></div><p><b>JavaScript语言及其特点：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Javascript一种基于对象(object-based)和事件驱动(Event Driven)的简单的并具有安全性能的脚本语言。\n特点：\n1) 解释性： JavaScript不同于一些编译性的程序语言，例如C、C++等，它是一种解释性的程序语言，它的源代码不需要经过编译，而直接在浏览器中运行时被解释。\n2) 基于对象：  JavaScript是一种基于对象的语言。这意味着它能运用自己已经创建的对象。因此，许多功能可以来自于脚本环境中对象的方法与脚本的相互作用。\n3) 事件驱动：JavaScript可以直接对用户或客户输入做出响应，无须经过Web服务程序。它对用户的响应，是以事件驱动的方式进行的。所谓事件驱动，就是指在主页中执行了某种操作所产生的动作，此动作称为“事件”。比如按下鼠标、移动窗口、选择菜单等都可以视为事件。当事件发生后，可能会引起相应的事件响应。\n跨平台:JavaScript依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可正确执行。</code></pre></div><p><b>JavaScript常用数据类型有哪些：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">数值型：整数和浮点数统称为数值。例如85或3.1415926等。\n字符串型：由0个,1个或多个字符组成的序列。在JavaScript中，用双引号或单引号括起来表示，如“您好”、‘学习JavaScript’等。 不区分单引号、双引号。\n逻辑（布尔）型：用true或false来表示。\n空（null）值：表示没有值，用于定义空的或不存在的引用。\n要注意，空值不等同于空字符串&#34;&#34;或0。\n未定义（undefined）值：它也是一个保留字。表示变量虽然已经声明，但却没有赋值。\n除了以上五种基本的数据类型之外，JavaScript还支持复合数据类型，包括对象和数组两种。</code></pre></div><p><b>Javascript的常用对象有哪些：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">常用对象包括日期对象Date，字符串对象String，数组对象Array\n//获取并显示系统当前时间\nfunction testDate(){ \n var date = new Date();\n var fmtDate = date.getFullYear()+&#34;-&#34;+(date.getMonth()+1)+\n  &#34;-&#34;+date.getDate()+&#34;-&#34;+date.getHours()\n  +&#34;:&#34;+date.getMinutes()+&#34;:&#34;+date.getSeconds();\n alert(fmtDate);\n}\n//获取出’sxt’的下标位置\nfunction testString(){\n var str = &#39;welcome to beijingsxt&#39;;\n alert(str.indexOf(&#39;sxt&#39;));\n }\n//遍历数组信息\nfunction testArray(){\n  var arr = new Array(&#39;a&#39;,123,&#39;c&#39;,true,&#39;e&#39;);\n  for(var item in arr){\n     document.write(arr[item]+&#34; &#34;);\n  }\n }</code></pre></div><p><b>DOM和BOM及其关系：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">BOM浏览器对象模型，由一系列对象组成，是访问、控制、修改浏览器的属性的方法。\nDOM文档对象模型，由一系列对象组成，是访问、检索、修改XHTML文档内容与结构的标准方法。</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-35c1bd97c69fd23d2d20f8a05623604c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb\" width=\"542\" data-original=\"https://pic1.zhimg.com/v2-35c1bd97c69fd23d2d20f8a05623604c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;542&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"542\" data-original=\"https://pic1.zhimg.com/v2-35c1bd97c69fd23d2d20f8a05623604c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-35c1bd97c69fd23d2d20f8a05623604c_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">关系：\n– BOM描述了与浏览器进行交互的方法和接口 \n– DOM描述了处理网页内容的方法和接口 \n– DOM属于BOM的一个属性</code></pre></div><p><b>JavaScript中获取某个元素的三种方式：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1) getElementById( ) ：返回一个节点对象 \n2) getElementsByName( )：返回多个（节点数组）\n3) getElementsByTagName( ) ：返回多个（节点数组）</code></pre></div><p><b>JavaScript中的三种弹出式消息提醒命令是什么?</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1) window.alert() 显示一个提示信息 \n2) window.confirm()  显示一个带有提示信息、确定和取消按钮的对话框 \n3) window.prompt()显示可提示用户输入的对话框</code></pre></div><p>s<b>etTimeout与setInterval 的区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">setTimeout和setInterval的语法相同。它们都有两个参数，一个是将要执行的代码字符串，还有一个是以毫秒为单位的时间间隔，当过了那个时间段之后就将执行那段代码。\n不过这两个函数还是有区别的，setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码，而setTimeout只执行一次那段代码。\nwindow.setTimeout(&#34;function&#34;,time)；//设置一个超时对象，只执行一次,无周期 \nwindow.setInterval(&#34;function&#34;,time)；//设置一个超时对象，周期＝&#39;交互时间&#39;</code></pre></div><p><b>JavaScript操作CSS的两种方式：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">第一种方式：操作元素的属性（对象.style.样式名=样式值;）\n //改变直接样式\n    var child2 = document.createElement(&#34;div&#34;);\n    child2.innerHTML = &#34;child2&#34;;\n    child2.style.fontWeight = &#34;bold&#34;;\n    parent.appendChild(child2);\n \n第二种方式：操作元素的类（对象.className=类;）\n 例如：\nvar parent = document.getElementById(&#34;parent&#34;);     \n   //改变className\n   var child0 = document.createElement(&#34;div&#34;); \n   child0.innerHTML = &#34;child0&#34;;\n   child0.className = &#34;newDiv&#34;;\nparent.appendChild(child0);</code></pre></div><hr/><h2><b>第二部分  Servlet/JSP/JSTL-EL：</b></h2><p><b>静态网页和动态网页的联系和区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">联系：\n     1）静态网页是网站建设的基础，静态网页和动态网页都要使用到HTMl语言。\n     2）静态网页是相对于动态网页而言，指没有后台数据库、不含程序和不可交互的网页、是标准的HTML文件，它的文件扩展名是.htm或.html。你编的是什么它显示的就是什么、不会有任何改变。\n     3）静态网页和动态网页之间并不矛盾，为了网站适应搜索引擎检索的需要，动态网站可以采用静动结合的原则，适合采用动态网页的地方用动态网页，如果必要使用静态网页，则可以考虑用静态网页的方法来实现，在同一个网站上，动态网页内容和静态网页内容同时存在也是很常见的事情。\n 区别：\n     1）程序是否在服务器端运行，是重要标志。在服务器端运行的程序、网页、组件，属于动态网页，它们会随不同客户、不同时间，返回不同的网页，例如ASP、PHP、JSP、ASP.net、CGI等。运行于客户端的程序、网页、插件、组件，属于静态网页，例如html页、Flash、javascript、VBscript等等，它们是永远不变的。\n     2）编程技术不同。静态网页和动态网页主要根据网页制作的语言来区分。静态网页使用语言：HTML。 动态网页使用语言：HTML＋ASP 或 HTML＋PHP 或 HTML＋JSP 等其它网站动态语言。\n     3）被搜索引擎收录情况不同。由于编程技术不容，静态网页是纯粹HTML格式的网页，页面内容稳定，不论是网页是否被访问，页面都被保存在网站服务器上，很容易被搜索引擎收录。而动态网页的内容是当用户点击请求时才从数据库中调出返回给用户一个网页的内容，并不是存放在服务器上的独立文件，相比较于静态网页而言，动态网页很难被搜索引擎收录。\n     4）用户访问速度不同。用户访问动态网页时，网页在获得搜索指令后经过数据库的调查匹配，再将与指令相符的内容传递给服务器，通过服务器的编译将网页编译成标准的HTML代码，从而传递给用户浏览器，多个读取过程大大降低了用户的访问速度。而静态网页不同，由于网页内容直接存取在服务器上，省去了服务器的编译过程，用户访问网页速度很快。\n     5）制作和后期维护工作量不同。动态网页的设计以数据库技术为基础，可以实现多种功能，降低了网站维护的工作量。而静态网页由于没有数据库的支持，网页内容更改时需要直接修改代码，在网站内容制作和维护中，所需的工作量更大。\n动态网页与静态网页各有特点，网站设计师在网页设计时，主要根据网站的功能需求和网站内容多少选择不同网页。如，网站包含信息量太大时，就需要选择动态网页，反之，则选择静态网页。</code></pre></div><p><b>JSP/ASP/PHP的比较 ：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">ASP(Active Server Pages),JSP(JavaServer Pages),PHP(Hypertext Preprocessor)是目前主流的三种动态网页语言。\n        ASP是微软（Microsoft）所开发的一种后台脚本语言，它的语法和Visual BASIC类似，可以像SSI（Server Side Include）那样把后台脚本代码内嵌到HTML页面中。虽然ASP简单易用，但是它自身存在着许多缺陷，最重要的就是安全性问题。\n        PHP是一种跨平台的服务器端的嵌入式脚本语言。它大量地借用C,Java和Perl语言的语法, 并耦合PHP自己的特性,使WEB开发者能够快速地写出动态产生页面。它支持目前绝大多数数据库。\n        JSP是一个简化的Servlet，它是由Sun公司倡导、许多公司参与一起建立的一种动态网页技术标准。JSP技术有点类似ASP技术，它是在传统的网页HTML中插入Java程序段和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。 用JSP开发的Web应用是跨平台的，既能在Linux下运行，也能在其他操作系统上运行。 \n    ASP优点:无需编译、易于生成、独立于浏览器、面向对象、与任何ActiveX scripting 语言兼容、源程序码不会外漏。\n 缺点:\n       1） Windows本身的所有问题都会一成不变的也累加到了它的身上。安全性、稳定性、跨平台性都会因为与NT的捆绑而显现出来。\n       2） ASP由于使用了COM组件所以它会变的十分强大，但是这样的强大由于Windows NT系统最初的设计问题而会引发大量的安全问题。只要在这样的组件或是操作中一不注意，那么外部攻击就可以取得相当高的权限而导致网站瘫痪或者数据丢失。\n      3） 还无法完全实现一些企业级的功能：完全的集群、负载均横。\n    PHP优点：\n        1）一种能快速学习、跨平台、有良好数据库交互能力的开发语言。\n        2）简单轻便，易学易用。\n        3) 与Apache及其它扩展库结合紧密。\n缺点：\n   1) 数据库支持的极大变化。\n       2) 不适合应用于大型电子商务站点。\n     JSP优点：\n       1)  一处编写随处运行。\n       2)  系统的多台平支持。\n       3)  强大的的可伸缩性。\n       4)  多样化和功能强大的开发工具支持。\n 缺点：\n        1)  与ASP一样，Java的一些优势正是它致命的问题所在。\n        2)  开发速度慢</code></pre></div><p><b>CGI/Servlet/JSP的比较：</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> CGI(Common Gateway Interface)，通用网关接口,是一种根据请求信息动态产生回应内容的技术。\n通过CGI，Web 服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。\nServlet 是在服务器上运行的小程序。在实际运行的时候Java Servlet与Web服务器会融为一体。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。\n 比较：\n   1）JSP从本质上说就是Servlet。JSP技术产生于Servlet之后，两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。\n   2) 与CGI相比，Servlet效率更高。Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。\n   3）与CGI相比，Servlet更容易使用，功能更强大，具有更好的可移植性，更节省投资。在未来的技术发展过程中，Servlet有可能彻底取代CGI。</code></pre></div><p><b>Tomcat/Jboss/WebSphere/WebLogic的作用和特点：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">作用：\nTomcat：目前应用非常广泛的免费web服务器，支持部分j2ee。 \nJBoss：JBoss是一个管理EJB的容器和服务器，支持EJB 1.1、EJB 2.0和EJB3.0的规范。但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或Jetty绑定使用。\nWebSphere：是IBM集成软件平台。可做web服务器，WebSphere提供了可靠、灵活和健壮的集成软件。   \nWeblogic：是美国bea公司出品的一个基于j2ee架构的中间件。BEA WebLogic是用于开发、集成、部署和管理大型分布式Web应用、网络应用和数据库应用的Java应用服务器。\n特点（区别）：\n  1）价位不同：JBoss与Tomcat的是免费的；WebLogic与WebSphere是收费的，而且价格不菲。\n  2）开源性不同：JBoss与Tomcat的是完全开源的，而其他两个不是。\n  3）对技术的支持：Tomcat不支持EJB，JBoss是实现了EJB容器，再集成了Tomcat。\nWebLogic与WebSphere都是对业内多种标准的全面支持，包括EJB、JSB、JMS、JDBC、XML和WML，使Web应用系统实施更简单，且保护投资，同时也使基于标准的解决方案的开发更加简便。 \n 4）扩展性的不同：WebLogic和WebSphere都是以其高扩展的架构体系闻名于业内，包括客户机连接的共享、资源 pooling以及动态网页和EJB组件群集。\n 5）应用范围的区别：Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。WebLogic和WebSphere是商业软件,功能齐全强大,主要应用于大型企业的大型项目。JBOSS 主要应用于EJB服务的中小型公司。\n 6）安全性问题区别：因为JBoss和Tomcat都是开源的，所以它们的安全性相对来说比较低，万一应用服务器本身有什么漏洞，你是没办法向Apache索赔的。而WebLogic和WebSphere其容错、系统管理和安全性能已经在全球数以千记的关键任务环境中得以验证。</code></pre></div><p><b>B/S和C/S的含义及其区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">C/S结构，即Client/Server(客户机/服务器)结构，通过将任务合理分配到Client端和Server端，降低了系统的通讯开销，可充分利用两端硬件环境优势。早期软件系统多以此作为首选设计标准。\nB/S结构，即Browser/Server(浏览器/服务器)结构，是随着Internet技术的兴起，对C/S结构的一种变化或者改进的结构。在这种结构下，用户界面完全通过WWW浏览器实现，一部分事务逻辑在前端实现，但是主要事务逻辑在服务器端实现，节约了开发成本，便于软件维护。\n区别\n1、C/S是建立在局域网的基础上的。B/S是建立在广域网的基础上的，但并不是说B/S结构不能在局域网上使用。\n2、B/S业务扩展简单方便，通过增加页面即可增加服务器功能。C/S的客户端还需要安装专用的客户端软件，不利于扩展。\n3、B/S维护简单方便。开发、维护等几乎所有工作也都集中在服务器端，当企业对网络应用进行升级时，只需更新服务器端的软件就可以，这减轻了异地用户系统维护与升级的成本。。    \n4、B/S响应速度不及C/S；\n5、B/S用户体验效果不是很理想</code></pre></div><p><b>容器的理解：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">容器也是 java 程序，它的主要作用是为应用程序提供运行环境。\n容器用来接管安全性、并发性、事务处理、交换到辅助存储器和其它服务的责任\n以tomcat为例：Tomcat是一个后台服务进程，其它的servlet（相当于DLL）是在Tomcat容器内运行,Broswer只与Tomcat通迅;  \nTomcat接受browser的请求，经过一系列动作（如果是静态网页，那么装载，按http协议形成响应流;如果是动态的如JSP，那就要调用JDK 中的servlet.jsp接口，解释形成静态网页，按http协议生成响应流发送回browser）后，形成静态网页，返回响应。</code></pre></div><p><b>HTTP协议工作原理及其特点：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">超文本传输协议（HTTP：Hypertext Transport Protocol）是万维网应用层的协议，它通过两个程序实现：一个是客户端程序（各种浏览器），另一个是服务器 （常称Web服务器）。\n这两个通常运行在不同的主机上，通过交换报文来完成网页请求和响应，报文可简单分为请求报文和响应报文。\n工作原理（流程）：\n客户机与服务器建立连接后，浏览器可以向web服务器发送请求并显示收到的网页，当用户在浏览器地址栏中输入一个URL或点击一个超连接时，浏览器就向服务器发出了HTTP请求，请求方式的格式为：统一资源标识符、协议版本号，后边是MIME（Multipurpose Internet Mail Extensions）信息包括请求修饰符、客户机信息和可能的内容。该请求被送往由URL指定的WEB服务器，WEB服务器接收到请求后，进行相应反映，其格式为：一个状态行包括信息的协议版本号、一个成功或错误的代码，后边服务器信息、实体信息和可能的内容。即以HTTP规定的格式送回所要求的文件或其他相关信息，再由用户计算机上的浏览器负责解释和显示。\n特点：\n 1）支持客户/服务器模式。\n 2）简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。\n 3）灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。\n 4）无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。\n 5）无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</code></pre></div><p><b>get和post的区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1) Get是不安全的，因为在传输过程，数据被放在请求的URL中；Post的所有操作对用户来说都是不可见的。\n2) Get传送的数据量较小，这主要是因为受URL长度限制；Post传送的数据量较大，一般被默认为不受限制。\n3) Get限制Form表单的数据集的值必须为ASCII字符；而Post支持整个ISO10646字符集。\nGet执行效率却比Post方法好。Get是form提交的默认方法。</code></pre></div><p><b>如何解决表单提交的中文乱码问题：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1）设置页面编码，若是jsp页面，需编写代码\n      &lt;%@page language=&#34;java&#34; pageEncoding=&#34;UTF-8&#34; contentType=&#34;text/html;charset=UTF-8&#34; %&gt;  \n 若是html页面，在网页头部（&lt;head&gt;&lt;/head&gt;）中添加下面这段代码\n      &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34; /&gt;\n   2）将form表单提交方式变为post方式，即添加method=&#34;post&#34;；）在Servlet类中编写代码request.setCharacterEncoding(&#34;UTF-8&#34;)，而且必须写在第一行。\n  3）如果是get请求，在Servlet类中编写代码\nbyte [] bytes = str.getBytes(&#34;iso-8859-1&#34;);\nString  cstr =  new String(bytes,&#34;utf-8&#34;);\n或者直接修改Tomcat服务器配置文件server.xml增加内容：\n URIEncoding=&#34;utf-8&#34;</code></pre></div><p><b>绝对路径、根路径、相对路径的含义及其区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">绝对路径指对站点的根目录而言某文件的位置，相对路径指以当前文件所处目录而言某文件的位置,相对路径-以引用文件之网页所在位置为参考基础，而建立出的目录路径。绝对路径-以Web站点根目录为参考基础的目录路径。\n 先给出一个网站结构图做实例加深理解，A网站（域名为http://www.a.com）：/include/a-test.html，/img/a-next.jpg；B网站（域名为http://www.b.com）：/include/b-test.html，/img/b-next.jpg。\n相对路径是从引用的网页文件本身开始构建的，如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt;img src=&#34;../img/a-next.jpg&#34; /&gt;，重点是img前面的../，表示从html处于的include开始起步，输入一个../表示回到上面一级父文件夹下，然后再接着img/表示又从父级文件夹下的img文件开始了，最后定位img下面的next.jpg。\n根路径是从网站的最底层开始起，一般的网站的根目录就是域名下对应的文件夹，就如D盘是一个网站，双击D盘进入到D盘看到的就是网站的根目录，这种路径的链接样式是这样的：如果在A网站中的a-test.html中要插入图片a-next.jpg，可以这样做:&lt;img src=&#34;/img/a-next.jpg&#34; &gt;，以/开头表示从网站根目录算起，找到根目录下面的img文件夹下的next.jpg。\n 绝对路径就很好理解了，这种路径一般带有网站的域名，如果在A网站中的a-test.html中要插入图片a-next.jpg，需要这样这样写:&lt;img src=&#34;http://www.a.com/img/a-next.jpg&#34; &gt;，将图片路径上带有了域名信息，再打个比方：如果在A网站中的a-test.html中要插入B网站的图片b-next.jpg，就需要这样写：&lt;img src=&#34;http://www.b.com/img/b-next.jpg&#34; &gt;，这种方法适用与在不同网站之间插入外部网站的图片。</code></pre></div><p><b>如实现servlet的单线程模式：</b></p><div class=\"highlight\"><pre><code class=\"language-text\"> 实现servlet的单线程的jsp命令是： &lt;%@ page isThreadSafe=”false”%&gt;。默认isThreadSafe值为true。 \n 属性isThreadSafe=false模式表示它是以Singleton模式运行，该模式implements了接口SingleThreadMode, 该模式同一时刻只有一个实例，不会出现信息同步与否的概念。若多个用户同时访问一个这种模式的页面，那么先访问者完全执行完该页面后，后访问者才开始执行。 \n 属性isThreadSafe=true模式表示它以多线程方式运行。该模式的信息同步，需访问同步方法(用synchronized标记的)来实现。 一般格式如下： </code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-676f2282f22e0df25dfb9f9f18bb27c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"152\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;152&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"152\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic1.zhimg.com/v2-676f2282f22e0df25dfb9f9f18bb27c0_b.jpg\"/></figure><p><b>Servlet的生命周期：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1) 加载：在下列时刻加载 Servlet：（1）如果已配置自动加载选项，则在启动服务器时自动加载 (web.xml中设置&lt;load-on-start&gt;)；（2）在服务器启动后，客户机首次向 Servlet 发出请求时;（3）重新加载 Servlet 时（只执行一次）\n2) 实例化：加载 Servlet 后，服务器创建一个 Servlet 实例。（只执行一次）\n3) 初始化：调用 Servlet 的 init() 方法。在初始化阶段，Servlet 初始化参数被传递给 Servlet 配置对象ServletConfig。 （只执行一次）\n4) 请求处理：对于到达服务器的客户机请求，服务器创建针对此次请求的一个“请求”对象和一个“响应”对象。服务器调用 Servlet 的 service() 方法，该方法用于传递“请求”和“响应”对象。service() 方法从“请求”对象获得请求信息、处理该请求并用“响应”对象的方法以将响应传回客户机。service() 方法可以调用其它方法来处理请求，例如 doGet()、doPost() 或其它的方法。（每次请求都执行该步骤）\n5) 销毁：当服务器不再需要 Servlet, 或重新装入 Servlet 的新实例时，服务器会调用 Servlet 的 destroy() 方法。（只执行一次）</code></pre></div><p><b>session和cookie的区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">1) 联系\nhttp是无状态的协议，客户每次读取web页面时，服务器都打开新的会话，而且服务器也不会自动维护客户的上下文信息，那么要怎么才能在多次请求之间共享信息呢（比如实现网上商店中的购物车）？session和cookie就是为了解决HTTP协议的无状态而采用的两种解决方案。\n2) 原理（通过比喻形象说明，真正原理自己总结）\na) Cookie：发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 【卡上记录所有信息，而店家只认卡不认人。】\nb) Session：发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 【只记用户ID，而ID的详细记录放在店家的数据库里；每次凭ID检索服务器的记录。】\n3) 区别\na) cookie数据存放在客户的浏览器上，session数据放在服务器上（sessionid可以通过cookie保存在客户端，也可以使用URL重写方式）。\nb) cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session\nc) session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE\nd) 单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。\ne) 个人建议：将登陆信息等重要信息存放为SESSION；其他信息如需保留，可放在COOKIE</code></pre></div><p><b>转发和重定向的区别：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">转发是在服务端直接做的事情，是对客户端的同一个request进行传递，浏览器并不知道。重定向是由浏览器来做的事情。重定向时，服务端返回一个response，里面包含了跳转的地址，由浏览器获得后，自动发送一个新request。转发像呼叫转移或者110报警中心，重定向似114查号台。</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5f39c47f22c1a74a640f7c30b0e58056_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"179\" class=\"origin_image zh-lightbox-thumb\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-5f39c47f22c1a74a640f7c30b0e58056_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;556&#39; height=&#39;179&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"556\" data-rawheight=\"179\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"556\" data-original=\"https://pic3.zhimg.com/v2-5f39c47f22c1a74a640f7c30b0e58056_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5f39c47f22c1a74a640f7c30b0e58056_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">a) 区别1:跳转效率的不同 \n转发效率相对高；重定向效率相对低\nb) 区别2:实现语句不同 \n转发 request.getRequestDispatcher(&#34;xxxx&#34;).forward(request,response) ;\n重定向 response.sendRedirect(&#34;xxxx&#34;)\nc) 区别3:是否共有同一个request的数据\n转发源组件与目标组件共有同一个request数据\n重定向源组件与目标组件不共有同一个request数据（可使用session共有数据） \nd) 区别4:浏览器URL地址的不同 \n转发后浏览器URL地址保持不变（源组件地址） \n重定向后浏览器URL地址改变为重定向后的地址（目标组件地址） \ne) 区别5:&#34;/&#34;路径的含义不同 \n转发时&#34;/&#34;代表当前项目的根路径 ；重定向时&#34;/&#34;代表当前服务器的根路径 \nf) 区别6:跳转范围的不同 \n只能转发到同一应用中的URL（默认） ；可以重定向任何服务器、任何应用的URL\ng) 区别7:刷新是否导致重复提交 \n转发会导致重复提交(可以通过同步令牌解决)；重定向不会导致重复提交\nh) 区别8:是否经过过滤器 \n转发不经过过滤器（默认情况）；重定向经过过滤器</code></pre></div><p><b>JSP的执行过程：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">在JSP运行过程中，首先由客户端发出请求，Web服务器接收到请求后，如果是第一次访问某个jsp页面，Web服务器对它进行以下3个操作。\n1) 翻译：由.jsp变为.java,由JSP引擎实现。\n2) 编译：由.java变为.class,由 Java编译器实现。\n3) 执行：由.class变为.html,用Java虚拟机执行编译文件,然后将执行结果返回给Web服务器，并最终返回给客户端\n如果不是第一次访问某个JSP页面，则只执行第三步。所以第一次访问JSP较慢。</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java EE", 
                    "tagLink": "https://api.zhihu.com/topics/19620553"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63284202", 
            "userName": "蛤蛤", 
            "userLink": "https://www.zhihu.com/people/0833f55987b5375a3ac129db230a365c", 
            "upvote": 3, 
            "title": "微软实习期的我，纠正了一位高级开发人员的错误", 
            "content": "<p>二十岁时，我获得了微软软件开发的实习机会。虽然没有做好准备，但又不甘心放弃这样难得的机会，于是我还是硬着头皮进去了。后来，我纠正了一位高级开发人员的代码错误，这为我的整个职业生涯上了最重要的一课。<br/><b>事件回顾</b><br/>去微软实习之前，我在一家公司负责过编写工具软件，工厂的工作人员使用这个软件进行固件安装、设备配置和运行自动化测试，以确保设备正常工作。软件开发团队只有3个人，总的代码量大约10,000 - 50,000行——这是我在微软工作之前的所有编程经验。<br/>刚刚进入微软时，当时微软的项目主要使用 C++ 编写，因此我首先需要熟悉这些项目，以及了解 C++ 这门编程语言。C++ 是一种相对低级的编程语言，它需要你了解很多复杂的概念，比如内存分配与释放、指针的合理运用等。这些是其他大多数编程语言中并不需要担心的事情。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-51394953ab51cf6bf00028504e22a1e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-51394953ab51cf6bf00028504e22a1e9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-51394953ab51cf6bf00028504e22a1e9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-51394953ab51cf6bf00028504e22a1e9_b.jpg\"/></figure><p><br/>2008年时我在微软的集体照，高亮的两人分别是 Ray Ozzie（微软的前CTO）和我（一个不太重要的员工）<br/><b>微软实习的第一天</b><br/>首先，我花了几个小时的时间用我不太熟悉的编程语言编写了一些测试项目。之后，公司的高级开发人员 Ransom，即我的上级，为我展示了项目的源代码，大概有1000 万行代码，差不多 70 或 80 位开发人员共同开发。<br/>在一些简单的项目中，如果更改了代码，只需要3-4秒就能进行测试。但在微软，对代码的任何小改动都需要8-10分钟的时间来进行测试。另外，整个项目的全部重建需要4-5个小时，而且开发人员通常在下班之前进行重建。<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3745f89ca6ec6317b1796615ff1cdd16_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb\" width=\"463\" data-original=\"https://pic3.zhimg.com/v2-3745f89ca6ec6317b1796615ff1cdd16_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;463&#39; height=&#39;379&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"463\" data-rawheight=\"379\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"463\" data-original=\"https://pic3.zhimg.com/v2-3745f89ca6ec6317b1796615ff1cdd16_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3745f89ca6ec6317b1796615ff1cdd16_b.jpg\"/></figure><p><br/>在6个月的实习期间，我一直怀疑自己是否能够真正为公司带来价值。另外，我还是一名在校大学生，这意味着我还得担心毕业后的工作问题。况且，其他的开发者估计也并不希望我继续待在这。<br/>我能够独立编译、运行和启动应用程序，并建立我的开发环境。Ransom 给了我一个简短的源代码，他的工作内容则是接下来我将要涉及到的产品。<br/><b>我负责的是微软的 Groove 产品</b><br/>Groove 是一个针对企业的点对点共享系统，当时我们正在加紧与 SharePoint 的紧密集成，一是在 SharePoint 之上提供点对点同步功能，二是需要提供一个客户端，使人们可以更轻松地同步工作内容。<br/>我所在的团队被称为“存储和同步”团队，团队中的一名成员建立了项目的数据库和文件存储系统，另一位成员构建了与 SharePoint API 的集成。总体而言，我们负责点对点同步技术。<br/>点对点同步相当复杂，比如：<br/></p><ul><li>人员1添加文件并断开连接。</li><li>人员2同步第一个文件，断开连接并离线更改。</li><li>人员1对文件进行其他更改。</li><li>人员3添加了一个新的文件。</li></ul><p>当三个人中的任何一个连接到中央 SharePoint 站点时，同步引擎需要整理系统的状态。<br/>Ransom 是这个产品的专家，他的工作是让我在 6 个月时间内，从一个没有经验的开发人员变成一个有能力、有影响力的团队成员。<br/><b>Ransom 分配给我的第一个任务</b><br/>我们对同步引擎进行了一些内部自动化测试。他说：“我希望你来改进我们同步引擎的内部测试，虽然目前还不能达到一些测试的边缘情况，但是最终目标是能够执行这种特定类型的测试。”<br/>对 Ransom 来说，完成这项任务可能用不到一天，但我花费了整整一个月的时间。以下是我的工作流程：<br/></p><ul><li>我用三天时间进行构思，然后清理代码，让编写测试变得容易，使它更接近于我在 C++ 书籍上阅读的代码格式。</li><li>Ransom 要看我写的代码。</li><li>虽然我感觉自己还没有做好准备，但还是硬着头皮向他展示了代码。</li><li>他逐行阅读我的代码，并指出了其中的每一项错误。</li><li>Ransom 指出了错误的具体原因。</li></ul><p>我按照 Ransom 的意见修改代码。他告诉我有很多人都出现了和我类似的问题，因此我毫不犹豫地修改了代码。<br/><b>多次修改代码</b><br/>我内心暗下决心不再犯同样的错误。之后我继续工作了一些时日，然后我将我的新代码展示给 Ransom，他表扬了我代码中的一些优点，这让我感觉非常有成就感。<br/>然而，他又指出了我的一些错误。代码还得修改，我依然按照他的指引更改，因为他确实说得很有道理。<br/>我再次回顾了这段时间的工作。在此过程中，我也拉取了同事近期新增和修改的代码。通过对比，我觉得自己可能不擅长编写代码。我唯一觉得自己擅长的事情就是不断修改错误代码。<br/>那段时间，我被介绍给另一位名叫 Dana 的开发者。Dana 也是高级开发者，并且非常聪明。<br/>我想做出点成绩让 Ransom 刮目相看，所以我不想从他那里得到太多的帮助。但是我逐渐发现，独立工作老是出错，不得不多次推翻重来。于是我开始向 Dana 请教。甚至有些问题可能是非常愚蠢的，但是为了自己少走弯路，我硬着头皮也要问。<br/><b>我每天都会向 Dana 请教一两个看似愚蠢的问题</b><br/>面对我提出的问题，她会花费一两个小时耐心解答，以便我真正理解。事情总是比我想象的更复杂，但我开始变得更加自如。通过对这些愚蠢问题的了解，我逐渐开始对自己从事的开发工作有了深入理解。<br/>几天之后，我再一次与 Ransom 一起浏览我的代码。他依然非常细心，逐行阅读，依然发现了很多问题。但这一次我的代码可以运行了！虽然距离完美很遥远，但我感觉自己已经走上了一条正确的道路。<br/>最后，我对项目的自动化测试系统进行了一些小的改进。当然它还是有问题的：<br/></p><ul><li><b>我的代码在产品中的重要性很低。</b></li><li><b>老员工需要花费大量的时间来回答我的问题，实际上如果让他们开发这套系统，那么花费的时间比回答我的问题的时间更少。</b></li></ul><p>我很高兴自己的代码有资格正式加入到主代码库中，但是我仍然觉得自己没有为公司增加太多价值，我仍然只是遵循上级的指示编写代码。<br/>在接下来的几个月里，我开始研究测试系统之外的事情，并且接触了项目的真实代码。我的经理给了我几个非常简单的 bug 让我修复，每一个花费的时间都比我想象的要长。<br/>我承担的工作量慢慢地增加，但我仍然不觉得自己给公司带来了很多价值。我觉得任何人都可以做我正在做的事情，只是他们没有时间而已。<br/>当比我有经验的人会告诉我怎么做时，我会按照他们说的做。毕竟，他们比我有经验。<br/><b>直到一件事情改变了一切</b><br/>我还记得弹出的内存泄漏窗口。<br/>我们使用了一个工具，用来告诉我们是否可能存在内存泄漏，内存泄漏问题在 C ++ 中是非常糟糕但却很常见的问题。<br/>当时，我很困惑为什么这个工具触发了通知窗口。<br/>过去我没有接触过内存泄漏的问题，主要是因为我仅仅只是遵循团队提出的想法进行工作，缺乏自己的思考。窗口上弹出了一些我正在编写的代码，我询问如何调试这类问题之后得到了一些宏观的调试建议，然后就开始着手解决这个问题。<br/>几天之后，我找到了问题的根源，这是由于其他的开发人员在方法签名中写了一个指针而不是智能指针的方法。这意味着内存释放将不会像我们的代码中的其他地方一样工作。在这种情况下，代码导致智能指针不再操作。最终，内存永远不会被释放。这是一个糟糕的问题。<br/>我被这些代码搞糊涂了，于是我去查看代码的历史，发现它是由另一个团队的开发人员编写的。不久之后，我发现这位开发人员实际上很高级，而他恰巧在一个离我很近的办公室里工作。我小心翼翼地敲开了他的门然后问道：<br/>“嘿，我可以问你一些关于你写的代码的问题吗？我对你的一些代码比较好奇。“<br/>我向他展示了我使用他的代码的方法，同时展示了我认为可能有问题的地方。根据我过去的努力，我期望得到一个相当详细的答案，说明为什么另一种方法行不通。但他的回应真的让我非常振奋：<br/>“确实，你是对的，它应该是另一种方式。如果你愿意的话，我可以把它切换出来，但是你来做的话可能会比较容易，因为你正在使用它。“<br/>此时此刻，我非常激动，感觉一瞬间一切都变了。我不再觉得自己像一个没有经验的实习生，不再因为他们比我有经验而老老实实遵循他们的指示。事实上，此刻我意识到自己可以做出比上级更好的事情。而这正是我能够以别人无法做到的方式为公司带来价值的原因。<br/>我可以在代码中发现一个问题，找出一个解决方案对代码进行改进，这个问题可能是高级开发人员、代码审查人员或者其他使用该代码的人员疏忽的。这是一种很酷的感觉，我希望自己能够再次体验到。<br/>我花了大约3个月的时间才得到这种体验。但一旦发生一次，就会越来越频繁地发生。不久之后，我觉得几乎每一天都有这种感觉。<br/><b>新人将有经验者奉若神灵是正常的</b><br/>你不好意思去询问那些看起来很愚蠢的问题，而是乖乖地按照指示行事。当你陷入这个循环时，就感觉自己仿佛是按照 Google 地图的导航来工作。你盲目遵循而不思考事情的原因和本质。如果你这样做，你可能觉得自己像机器中的齿轮，你不清楚如何让自己变得对公司有价值。<br/>但是如果你开始批判性地思考和提问，并在一些很酷的工作中错误并总结，所有的事情都开始改变。你开始意识到，你前面的人并不完美。事实上，他们负责的事情有很多，其中的一些可以做得更好。通过将你所学到的东西与你自己独特的视角相结合，你可以比你的上司做得更好。这就是你真正增值的地方。<br/>永远不要怀疑自己，相信自己可以比上级做得更好。这一点是唯一可以让自己真正为公司增值的方法。<br/>当我离开微软时，我已经修改了核心产品中的数千行代码。我对后端、文件系统、同步和 SharePoint 集成等代码进行了更改。这些事情最初看起来是遥不可及的，但事实上我最终还是做到了。而这一切都始于我大胆纠正了以为微软高级开发人员的错误。</p><p>微信公众号：程序员巴卫</p><p><b>创一个小群，供大家学习交流聊天</b></p><p><b>如果有对学C++方面有什么疑惑问题的，或者有什么想说的想聊的大家可以一起交流学习一起进步呀。</b></p><p><b>我偶尔也会直播给大家手把手编程</b></p><p><b>也希望大家对学C++能够持之以恒</b></p><p><b>如果你想要学好C++最好加入一个组织，这样大家学习的话就比较方便，还能够共同交流和分享资料，给你推荐一个学习的组织：</b><a href=\"https://link.zhihu.com/?target=https%3A//jq.qq.com/%3F_wv%3D1027%26k%3D5Nb3viO\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">大牛小白C++组织 可以点击编程二字，可以直达</a></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "StaFight", 
                    "userLink": "https://www.zhihu.com/people/4a3468e5347b17d44ddae0120f51be79", 
                    "content": "<p>很励志</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63342585", 
            "userName": "Strive追逐者", 
            "userLink": "https://www.zhihu.com/people/6625ea9b867135ace7c366fcff49009d", 
            "upvote": 15, 
            "title": "JAVA高级SpringMVC入门：", 
            "content": "<p><b>1.springMvc是spring组织出品的一个表现层框架, 和struts2属于同类型的框架.</b></p><p><b>2. springMvc作用:</b></p><div class=\"highlight\"><pre><code class=\"language-text\">a. 接收请求和从请求中接收参数\nb. 将处理好的数据返回给页面, 并在页面展示</code></pre></div><p><b>3.springMvc三大组件: </b></p><div class=\"highlight\"><pre><code class=\"language-text\">处理器映射器, 处理器适配器, 视图解析器。\nspringMVC中需要我们写的有哪些: 处理器也就是我们写的controller, 视图view也就是我们写的页面。</code></pre></div><p><b>4. 如果在springMvc中没有配置处理器映射器, 处理器适配器也可以使用, 但是系统性能会降低。</b></p><div class=\"highlight\"><pre><code class=\"language-text\">如果没有在springMvc.xml中配置处理器映射器和处理器适配器, 默认每次请求都会去找DispatcherServlet.properties\n配置文件, 去里面的处理器映射器列表和处理器适配器列表中, 逐个匹配, 找到对应类型的执行.如果在springMvc.xml\n中显示的配置了处理器映射器和处理器适配器就会直接执行不会去找DispatcherServlet.properties配置文件, 就会\n增强系统的运行速度。</code></pre></div><p><br/><br/><b>5. 注解驱动: </b></p><div class=\"highlight\"><pre><code class=\"language-text\">作用就是配置这个注解就相当于显示的配置了最新版的注解形式的处理器映射器和处理器适配器, 会加强系统运行速度 。</code></pre></div><p><br/><b>6. 注解驱动和注解扫描, 是否需要都配置为什么, 有什么区别?</b><br/>   </p><div class=\"highlight\"><pre><code class=\"language-text\">必须都配置, 注解驱动和注解扫描, 作用不一样, \n注解扫描, 是使用@Controller注解生效\n注解驱动相当于显示配置最新版处理器映射器和处理器适配器, 加快系统运行速度。</code></pre></div><hr/><p><b>springMVC入门案例：</b></p><p><b>本教程使用环境：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Jdk：jdk1.7.0_72\nEclipse：mars\nTomcat：apache-tomcat-7.0.53\nSpringmvc：4.1.3</code></pre></div><p></p><ol><li><b>创建一个javaweb工程</b></li><li><b>导入jar包</b></li><li><b>创建itemList.jsp</b></li><li><b>把参考资料中的itemList.jsp复制到工程的/WEB-INF/jsp目录下</b></li><li><b>创建controller</b></li></ol><div class=\"highlight\"><pre><code class=\"language-text\">@Controller\n \npublic class ItemController {\n \n \n \n@RequestMapping(&#34;/itemList&#34;)\n \npublic ModelAndView itemList() throws Exception {\n \n \n \nList&lt;Items&gt; itemList = new ArrayList&lt;&gt;();\n \n \n \n//商品列表\n \nItems items_1 = new Items();\n \nitems_1.setName(&#34;我是谁&#34;);\n \nitems_1.setPrice(6000f);\n \nitems_1.setDetail(&#34;这是测试数据&#34;);\n \nitemList.add(items_1);\n \n \n \n//创建modelandView对象\n \nModelAndView modelAndView = new ModelAndView();\n \n//添加model\n \nmodelAndView.addObject(&#34;itemList&#34;, itemList);\n \n//添加视图\n \nmodelAndView.setViewName(&#34;/WEB-INF/jsp/itemList.jsp&#34;);\n \n// modelAndView.setViewName(&#34;itemsList&#34;);\n \nreturn modelAndView;\n \n}\n}</code></pre></div><p><b>创建springmvc.xml</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;\n&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;\nxmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; \nxmlns:p=&#34;http://www.springframework.org/schema/p&#34;\nxmlns:context=&#34;http://www.springframework.org/schema/context&#34;\nxmlns:dubbo=&#34;http://code.alibabatech.com/schema/dubbo&#34; \nxmlns:mvc=&#34;http://www.springframework.org/schema/mvc&#34;\nxsi:schemaLocation=&#34;http://www.springframework.org/schema/beans \nhttp://www.springframework.org/schema/beans/spring-beans-4.0.xsd\n        http://www.springframework.org/schema/mvc \n        http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd\n        http://code.alibabatech.com/schema/dubbo \n        http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n        http://www.springframework.org/schema/context \n        http://www.springframework.org/schema/context/spring-context-4.0.xsd&#34;&gt;\n \n&lt;context:component-scan base-package=&#34;cn.kingdee.springmvc.controller&#34;/&gt;\n \n&lt;/beans&gt;</code></pre></div><p><b>配置前端控制器</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;!-- 前端控制器 --&gt;\n \n  &lt;servlet&gt;\n \n   &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n \n   &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;\n \n   &lt;init-param&gt;\n \n   &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;\n \n   &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;\n \n   &lt;/init-param&gt;\n \n  &lt;/servlet&gt;\n \n  &lt;servlet-mapping&gt;\n \n   &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;\n \n   &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;\n \n  &lt;/servlet-mapping&gt;</code></pre></div><p><b>开始测试</b><br/></p><div class=\"highlight\"><pre><code class=\"language-text\"> 　　备注：参数绑定\n　a)Springmvc默认支持的类型:\n        httpServletRequest, HttpServletResponse, HttpSession, Model\n        默认支持的参数就是在需要的时候可以加上, 不需要就可以不加, 随意使用.\n\n    b)简单数据类型(string, double, long, boolean等)\n        springMvc可以直接接收这些简单类型的参数, 并且可以进行自动的类型转换,\n        要求接收的变量名称必须等于页面上input框的name属性值\n        如果想要接收的变量名称随意起名可以使用@RequestParam注解, 一般不使用\n        @RequestParam(&#34;id&#34;)Integer idddddd, \n\n    c)Pojo类型:\n        要求: 接收的pojo的属性名称必须等于页面上input框的name属性值\n\n    d)Pojo包装类型:\n        要求: 页面的input框的name属性值必须等于接受的pojo的属性.属性.属性.....\n\n    e)自定义参数绑定:\n        默认springMvc只能够自动转换简单类型的参数, 对于date日期无法进行自动类型转换,\n        所以需要我们手动编写自定义转换器进行转换.</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "Spring MVC", 
                    "tagLink": "https://api.zhihu.com/topics/20033636"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63379831", 
            "userName": "秃头母猿", 
            "userLink": "https://www.zhihu.com/people/40837f47fdbb0ab8d67eee105cbe948c", 
            "upvote": 1, 
            "title": "Java大神进阶之路！", 
            "content": "<p>既然励志在java路上走的更远，那就必须了解java的路径。先看图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9706bb568519b480b0ad71fd306bf066_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"499\" data-rawheight=\"757\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-9706bb568519b480b0ad71fd306bf066_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;757&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"499\" data-rawheight=\"757\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-9706bb568519b480b0ad71fd306bf066_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9706bb568519b480b0ad71fd306bf066_b.jpg\"/></figure><p>更加细化的细节如下</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一： 编程基础</p><p class=\"ztext-empty-paragraph\"><br/></p><p>不管是C还是C++，不管是Java还是PHP，想成为一名合格的程序员，基本的数据结构和算法基础还是要有的。下面几篇文章从思想到实现，为你梳理出常用的数据结构和经典算法。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>1-1 常用数据结构</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数组、链表、堆、栈、队列、Hash表、二叉树等</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1-2 算法思想</p><p class=\"ztext-empty-paragraph\"><br/></p><p>算法时间复杂度和空间复杂度的分析计算</p><p class=\"ztext-empty-paragraph\"><br/></p><p>算法思想：递推、递归、穷举、贪心、分治、动态规划、迭代、分枝界限</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1-3 经典算法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>经典排序：插入排序、冒泡排序、快排（分划交换排序）、直接选择排序、堆排序、合并排序</p><p class=\"ztext-empty-paragraph\"><br/></p><p>经典查找：顺序查找、二分查找、二叉排序树查找</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1-4 高级数据结构</p><p class=\"ztext-empty-paragraph\"><br/></p><p>B+/B-数、红黑树、图等</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1-5 高级算法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>图的深度优先搜索、图的广度优先搜索、拓扑排序、Dijkstra算法（单源最短路径）、霍夫曼编码、辗转相除法、最小生成树等</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>二：Java语言基础</p><p class=\"ztext-empty-paragraph\"><br/></p><p>诞生不过二十余年的Java语言凭借其跨平台、面向对象、适合于分布式计算的特性，广泛应用于Web网站、移动设备、桌面应用中，并且已经连续多年稳居TOBIE编程语言排行榜前列，最近更是登上冠军宝座。Java有哪些优秀而又与众不同的地方首先一定要清楚。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-1 基础语法</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Java语法格式，常量和变量，变量的作用域，方法和方法的重载，运算符，程序流程控制，各种基本数据类型及包装类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-2 重要：集合类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Collection以及各种List、Set、Queue、Map的实现以及集成关系，实现原理</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Collections和Arrays </p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-3 其他JavaAPI</p><p class=\"ztext-empty-paragraph\"><br/></p><p>String和StringBuffer，System和Runtime类，Date和DateFomat类</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.lang包</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.util包（集合类体系、规则表达式、zip，以及时间、随机数、属性、资源和Timer等）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.math包</p><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=http%3A//java.net\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">java.net</span><span class=\"invisible\"></span></a>包</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.text包（各种格式化类等）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>java.security包</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-4 面向对象、面向接口</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对象的三大特性：封装、继承和多态，优缺点</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何设计类，类的设计原则</p><p class=\"ztext-empty-paragraph\"><br/></p><p>this关键字，final关键字，static关键字</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对象的实例化过程</p><p class=\"ztext-empty-paragraph\"><br/></p><p>方法的重写和重载；方法和方法的参数传递过程</p><p class=\"ztext-empty-paragraph\"><br/></p><p>构造函数</p><p class=\"ztext-empty-paragraph\"><br/></p><p>内部类，抽象类，接口</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对象的多态性（子类和父类之间的转换、父类纸箱子类的引用），抽象类和接口在多态中的应用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-5 JVM内存模型、垃圾回收</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-6 关于异常</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Throwable/Error/Exception，Checked Exception vs. Unchecked Exception，异常的捕捉和抛出，异常捕捉的原则，finally的使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-7 多线程</p><p class=\"ztext-empty-paragraph\"><br/></p><p>线程和进程的概念</p><p class=\"ztext-empty-paragraph\"><br/></p><p>如何在程序中创建多线程，线程安全问题，线程之间的通讯</p><p class=\"ztext-empty-paragraph\"><br/></p><p>线程的同步</p><p class=\"ztext-empty-paragraph\"><br/></p><p>死锁问题的剖析</p><p class=\"ztext-empty-paragraph\"><br/></p><p>线程池</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-8 IO</p><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=http%3A//java.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">java.io</span><span class=\"invisible\"></span></a>包，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>File及相关类，字节流InputStream和OutputStream，字符流Reader和Writer，以及相应缓冲流和管道流，字节和字符的转化流，包装流，以及常用包装类使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>分析IO性能</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-9XML</p><p class=\"ztext-empty-paragraph\"><br/></p><p>熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理；这几种解析方法的原理</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-10 一些高级特性</p><p class=\"ztext-empty-paragraph\"><br/></p><p>反射、代理、泛型、枚举、Java正则表达式</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-11 网络编程</p><p class=\"ztext-empty-paragraph\"><br/></p><p>网络通信协议原理及适用场景，Socket编程，WEB服务器的工作原理</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2-11 JDK1.5、JDK1.6、JDK1.7、JDK1.8每个版本都比前面一个版本添加了哪些新特性，进行了哪些提升</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>三：数据库相关</p><p class=\"ztext-empty-paragraph\"><br/></p><p>前面说到了数据结构，数据库简单来说就像是电子化的档案柜，是按照一定的数据结构来组织、存储和管理数据的仓库。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-1理论基础</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据库设计原则和范式</p><p class=\"ztext-empty-paragraph\"><br/></p><p>事务（ACID、工作原理、事务的隔离级别、锁、事务的传播机制）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-2 各种数据库优缺点、使用场景分析</p><p class=\"ztext-empty-paragraph\"><br/></p><p>MySQL/SQLServer/Oracle以及各种NoSQL(Redis、MongoDB、Memcached、HBase、CouchDB等)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-2 SQL语句</p><p class=\"ztext-empty-paragraph\"><br/></p><p>数据库创建，权限分配，表的创建，增删改查，连接，子查询</p><p class=\"ztext-empty-paragraph\"><br/></p><p>触发器、存储过程、事务控制</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-3 优化</p><p class=\"ztext-empty-paragraph\"><br/></p><p>索引原理及适用，大表查询优化，多表连接查询优化，子查询优化等</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-4 分库、分表、备份、迁移</p><p class=\"ztext-empty-paragraph\"><br/></p><p>导入、导出，分库、分表，冷备热备，主从备份、双机热备、纵向扩展、横向扩展</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3-5 JDBC</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JDBC Connection、Statement、PreparedStatement、CallableStatement、ResultSet等不同类的使用</p><p class=\"ztext-empty-paragraph\"><br/></p><p>连接池（配置使用、实现原理）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>ORM，DAO</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>四：JavaWeb核心技术（包括部分前端）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Html5/Css/JS原生/jQuery</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Ajax（跨域等）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JSP/JavaBean/Servlet/EL/JSTL/TabLib</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JSF</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JSON</p><p class=\"ztext-empty-paragraph\"><br/></p><p>EJB</p><p class=\"ztext-empty-paragraph\"><br/></p><p>序列化和反序列化</p><p class=\"ztext-empty-paragraph\"><br/></p><p>规则引擎</p><p class=\"ztext-empty-paragraph\"><br/></p><p>搜索引擎</p><p class=\"ztext-empty-paragraph\"><br/></p><p>模板引擎</p><p class=\"ztext-empty-paragraph\"><br/></p><p>缓存</p><p class=\"ztext-empty-paragraph\"><br/></p><p>身份认证</p><p class=\"ztext-empty-paragraph\"><br/></p><p>测试</p><p class=\"ztext-empty-paragraph\"><br/></p><p>集群</p><p class=\"ztext-empty-paragraph\"><br/></p><p>持久化</p><p class=\"ztext-empty-paragraph\"><br/></p><p>生成静态页技术</p><p class=\"ztext-empty-paragraph\"><br/></p><p>高性能</p><p class=\"ztext-empty-paragraph\"><br/></p><p>安全</p><p class=\"ztext-empty-paragraph\"><br/></p><p>事务JTA</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其他需要了解的，如：管理JMX、安全JCCA/JAAS、集成JCA、通信JNDI/JMS/JavaMain/JAF、SSI技术</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>五、主流框架及工具</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Struts1/Struts2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Spring（IoC、AOP等），SpringMVC</p><p class=\"ztext-empty-paragraph\"><br/></p><p>持久化：Hibernate/MyBatis</p><p class=\"ztext-empty-paragraph\"><br/></p><p>日志：Log4j</p><p class=\"ztext-empty-paragraph\"><br/></p><p>单元测试：JUnit</p><p class=\"ztext-empty-paragraph\"><br/></p><p>消息队列：ActiveMQ、RabbitMQ等</p><p class=\"ztext-empty-paragraph\"><br/></p><p>负载均衡：Nginx/HaProxy</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Web服务器：Tomcat、JBoss、Jetty、Resin、WebLogic、WebSphere等</p><p class=\"ztext-empty-paragraph\"><br/></p><p>通信：WebService(cxf的soap、restful协议)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>缓存：Redis、Memcached</p><p class=\"ztext-empty-paragraph\"><br/></p><p>工作流：Activity、JBPM</p><p class=\"ztext-empty-paragraph\"><br/></p><p>搜索引擎：lucene，基于lucene封装的solr </p><p class=\"ztext-empty-paragraph\"><br/></p><p>模板引擎：Velocity、FreeMaker</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大数据：Hadoop（HDFS和MapReduce）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>构建工具：Ant/Maven</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>六、JavaWeb系统设计与架构</p><p class=\"ztext-empty-paragraph\"><br/></p><p>Java设计模式</p><p class=\"ztext-empty-paragraph\"><br/></p><p>JAVA与UML建模</p><p class=\"ztext-empty-paragraph\"><br/></p><p>面向服务架构：SOA/SCA/ESB/OSGI/EAI，微服务</p><p class=\"ztext-empty-paragraph\"><br/></p><p>面向资源架构：ROA/REST</p><p class=\"ztext-empty-paragraph\"><br/></p><p>面向云架构：COA/Saas/云计算</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大型网站负载均衡、系统调优等</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>七、More</p><p class=\"ztext-empty-paragraph\"><br/></p><p>排错能力：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>应该可以根据异常信息比较快速的定位问题的原因和大致位置</p><p class=\"ztext-empty-paragraph\"><br/></p><p>优化能力</p><p class=\"ztext-empty-paragraph\"><br/></p><p>代码规范、代码管理：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>有自己的代码规范体系，代码可读性好</p><p class=\"ztext-empty-paragraph\"><br/></p><p>知识面广：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>懂各种网络产品及特性，懂各种中间件，能够知道坑在哪儿，深谙各种技术方案的优缺点，懂整合各种资源并达到最优....了解各种技术及应用场景，有足够的工作经验解决集成中遇到的各种奇葩问题</p><p class=\"ztext-empty-paragraph\"><br/></p><p>技术管理/技术总监：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>产品管理、项目管理、团队建设、团队提升</p><p class=\"ztext-empty-paragraph\"><br/></p><p>CTO：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>发展战略</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结：目前的我和我的目标还有很大的差距，希望每当过一段时间就来看看这些东西，看看自己是否又前进了一步。java大神任而道远，路在脚下，加油。</p><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64353891", 
            "userName": "秃头母猿", 
            "userLink": "https://www.zhihu.com/people/40837f47fdbb0ab8d67eee105cbe948c", 
            "upvote": 9, 
            "title": "Java 日志从入门到实战", 
            "content": "<p>日志和异常处理结合得当的话，会给项目维护带来非常大的价值。</p><ul><li><b>日志：</b>就是介绍一个过程和经历的详细记录。</li><li><b>项目日志：</b>就是项目开发过程的详细记录，一般由项目经理记录。</li><li><b>代码里的日志：</b>就是程序员记录某个开发过程的详细情况，这是项目里每个程序员需要做的工作。</li></ul><p>代码里的日志在项目中扮演着非常重要的角色，日志记录的详细程度决定系统是否容易维护，Java 项目中日志记录的框架有很多，在项目中如何选型也必将困惑。</p><p>我们这场 chat 讨论的主题就是：<b>Java代码里的日志</b>，主要是写给 Java 程序员看的，本篇 Chat 从以下六个方面对 Java 日志进行阐述：</p><ul><li>一、日志在项目中的作用</li><li>二、Java 日志使用的困惑</li><li>三、Java 日志演化历史</li><li>四、使用不同框架的 Java 日志示例说明</li><li>五、项目中日志记录遵守哪些原则</li><li>六、一个推荐的项目 Java 日志实例</li></ul><p>以期通过本场 Chat 的学习，能使大家在编码过程中，对日志的处理过程加深认识、统一规范、得到收获，从零开始轻松掌握 Java 日志处理，并且可以运用到实际项目中。</p><h3>一、日志在项目中的作用</h3><p>Log 日志，主要用于记录程序运行的情况，以便于程序在部署之后的排错调试等，也有利于将这些信息进行持久化（如果不将日志信息保存到文件或数据库，则信息便会丢失）。</p><h3>1. 查看程序当前运行状态</h3><p>如果想了解程序当前的运行情况，我们通过实时查看应用日志的输出，就能进行分析。</p><p>比如，你在浏览器里输入一个 action 地址，该 url 负责执行一些批量处理，action 运行后，假设处理比较耗时，你再浏览器里无法直接看到程序的执行结果，此时，你可以打开系统日志，通过从日志输出信息就能轻松地分析该 url 的执行情况。</p><h3>2. 查看程序历史运行轨迹</h3><p>如果想了解历时程序的运行情况，我们通过查看应用历时日志的输出，就能进行分析。</p><p>比如，你想了解下上周周末用户访问量，你可以打开系统上周周末的日志记录，进行分析。你想了解昨天的某个定时任务是否正常执行，你可以打开昨天的系统日志，精确查找该定时任务的输出信息，从而判断定时任务是否执行。</p><h3>3. 排查系统问题</h3><p>排查系统问题是程序员最熟悉的味道了，在项目维护过程中，出了任何问题，都需要程序员去进行排查。此时，如果没有清楚明了的日志记录，想要核查出问题的原因，难于上青天。</p><p>一个优秀的程序员一定是个日志记录高手，如果日志记录的好，处理得当，排查问题则易如反掌。</p><p>大家有没有遇到一种场景，一个问题发生了，有的人能迅速定位问题并解决，有的人搞了半天，还没发现问题的产生原因。</p><p>其实快速定位问题的人一定记录了详细的日志，因此当问题发生的时候，通过核查问题发生时候的日志，就能快速的找出问题产生的原因。</p><h3>4. 优化系统性能</h3><p>通过记录程序运行的时间，就能判断程序从执行开始到执行结束消耗的时间，从而判断系统性能是否达标，为系统性能优化提供判断依据。</p><h3>5. 安全审计的基石</h3><p>网络安全越来越受到大家的关注，所以系统安全目前是项目过程非常重要的一个环节，安全审计也是系统中非常重要的部分。</p><p>通过系统日志分析，可以判断一些非法攻击，非法调用，以及系统处理过程中的安全隐患。</p><p>比如，大家平时都在做运营系统，其中运营人员在通过界面处理一些数据的时候，如果没有清楚的日志操作记录，一条数据被删除或者修改，你是无法找到是谁操作的，但是如果你做了相应的记录，该数据被谁删除或者修改就会一目了然。</p><p><b>通过以上 5 点说明了日志在项目维护过程中的重要作用</b></p><p>一个系统是否容易维护，很大程度上是基于程序员在程序开发过程中的代码日志是怎么记录的。</p><p>日志记录的越清楚，维护起来就越容易，有的程序员没有日志记录意识，或者对日志记录认识不清，或者是不知道日志该如何记录，这势必会给项目后期的维护带来一个个大坑。</p><p>当项目经理让你解决一个线上问题的时候，正好遇到了一个没有日志记录习惯的人写的代码，你就能体会到那种痛苦，不由地想要爆粗口。</p><p>因此，作为一个程序员来说，掌握代码日志的记录方法，是程序员生涯的一项基本功。写代码时做好日志记录是“即利人又利己”的做法，不写日志记录就是“损人不利己”的做法。</p><h3>二、Java 日志使用的困惑</h3><p>大多数的程序员都能认识到日志在项目中的重要性，可是对日志记录具体要怎么做，做到什么程度，日志记录用什么工具，会有很多困惑。</p><h3>1. 工具困惑</h3><p>作为 Java 程序员，幸运的是，Java 拥有功能和性能都非常强大的日志库；不幸的是，这样的日志库有不止一个，相信每个人都会对JUL(Java Util Log)、JCL(Commons Logging)、Log4j、SLF4J、Logback、Log4j2 等等的日志工具，到底使用什么产生感到困扰。</p><p>下面的第三节：“Java 日志演化历史”，第四节：“使用不同框架的 Java 日志示例说明”，为大家解惑 Java 日志框架的使用问题。</p><h3>2. 使用困惑</h3><p>有的程序员即使知道写 Java 程序用什么日志工具，可能对日志记录具体应该怎么写，写什么东西，什么情况下要写，这些仁者见仁智者见智的东西也会产生困扰。</p><p>下面的第五节：“项目中日志记录遵守哪些原则”，为大家解惑日志记录要遵守哪些原则。</p><p>有的程序员知道了该用哪个 Java 框架，也知道了日志记录的原则，可能还会对具体在项目中到底该如何操作产生困惑。</p><h3>3. 实战困惑</h3><p>下面的第六节：“一个推荐的项目 Java 日志实例”，为大家展示在具体项目过程中的应用示例。</p><h3>三、Java 日志演化历史</h3><p>最先出现的是 Apache 开源社区的 Log4j，这个日志确实是应用最广泛的日志工具，成为了 Java 日志的事实上的标准。</p><p>然而，当时 Java 的开发主体 Sun 公司认为自己才是正统，在 Jdk1.4中增加了 JUL（在java.util.logging包下）日志实现，企图对抗 Log4j，但是却造成了 Java 目前开发者记录日志局面的混乱，迄今为止仍饱受诟病。</p><p>当然也有其他日志工具的出现，基本都是各自为政，这些日志系统互相没有关联。</p><p><b>为什么 JUL 的出现会导致开发局面混乱呢？</b></p><p>想象下你的项目应用使用 Log4j，然后使用了一个第三方库，而第三方库使用了 JUL，那么，你的应用就得同时使用 Log4j 和JUL两个日志工具了，然后又有需要使用另外一个第三方库，但是这个第三方库使用了 Log4j 和 JUL 之外的 simplelog。这个时候你的应用里各种 log 工具满天飞，这势必会使你的程序员感到崩溃。因为这些日志工具互相没有关联，替换和统一日志工具也就变成了比较棘手的一件事情。</p><blockquote>如果你遇到了这种问题，你该如何解决呢？<br/>解决这个问题，我们会用到一个设计模式——“适配器模式”，即把这个问题进行抽象，抽象出一个接口层，对每个日志实现都进行适配，这样这些提供给别人的库都直接使用抽象的接口层即可。</blockquote><p>为了搞定这个日常开发中比较棘手的问题，Apache 开源社区提供了一个日志框架作为日志的抽象，叫 commons-logging，也被称为 JCL(java common logging)，JCL 对各种日志接口进行抽象，抽象出一个接口层，对每个日志实现都进行适配，这样这些提供给别人的库都直接使用抽象层即可，确实出色地完成了兼容主流的日志实现（Log4j、JUL、simplelog 等），较好的解决了上述问题，基本一统江湖，就连顶顶大名的 spring 也是依赖了 JCL。</p><p>但是美好的日子并不长，作为元老级日志 Log4j 的作者 (Ceki Gülcü)，他觉得 JCL 不够优秀，所以他再度出山，搞出了一套更优雅的日志框架 SLF4J（这个也是抽象层），即简单日志门面（Simple Logging Facade for Java），并为 SLF4J 实现了一个亲儿子——logback，确实更加优雅了。</p><p>最后，Ceki Gülcü 觉得还是得照顾下自己的 “大儿子”——Log4j，又把 Log4j 进行了改造，就是所谓的 Log4j2，同时支持 JCL 以及 SLF4J。</p><p>SLF4J 的出现，又使 Java 日志体系变得混乱起来。</p><p>下面是一张目前 Java 日志体系的示意图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1d6add0536d2266211f2569a84a681ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb\" width=\"822\" data-original=\"https://pic3.zhimg.com/v2-1d6add0536d2266211f2569a84a681ae_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;822&#39; height=&#39;418&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"822\" data-rawheight=\"418\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"822\" data-original=\"https://pic3.zhimg.com/v2-1d6add0536d2266211f2569a84a681ae_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1d6add0536d2266211f2569a84a681ae_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>日志库 Log4j，JUL，logback 是互相不兼容的，没有共同的 Interface，所以 commons-logging、SLF4J 通过适配器模式，抽象出来一个共同的接口，然后根据使用的具体日志框架来实现日志。</p><p>java common logging 和 SLF4J 都是日志的接口，供用户使用，而没有提供实现，Log4j，JUL，logback 等等才是日志的真正实现。</p><p>当我们调用日志接口时，接口会自动寻找恰当的实现，返回一个合适的实例给我们服务。这些过程都是透明化的，用户不需要进行任何操作。</p><p>工具官方网站Log4j<a href=\"https://link.zhihu.com/?target=http%3A//logging.apache.org/log4j/1.2\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">logging.apache.org/log4</span><span class=\"invisible\">j/1.2</span><span class=\"ellipsis\"></span></a>JCL<a href=\"https://link.zhihu.com/?target=http%3A//commons.apache.org/proper/commons-logging/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">commons.apache.org/prop</span><span class=\"invisible\">er/commons-logging/</span><span class=\"ellipsis\"></span></a>SLF4J<a href=\"https://link.zhihu.com/?target=http%3A//www.slf4j.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://www.slf4j.org</a>logback<a href=\"https://link.zhihu.com/?target=http%3A//logback.qos.ch/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">http://logback.qos.ch</a>Log4j2<a href=\"https://link.zhihu.com/?target=https%3A//logging.apache.org/log4j/2.x/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">logging.apache.org/log4</span><span class=\"invisible\">j/2.x/</span><span class=\"ellipsis\"></span></a></p><h3>四、使用不同框架的 Java 日志示例说明</h3><h3>1. Log4j</h3><h3><b>Log4j 介绍</b></h3><p>Log4j（log for java）是 Apache 的一个开源项目，通过使用 Log4j，我们可以控制日志信息输出到日志文件、也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。这些可以通过一个配置文件来灵活地进行配置，而不需要修改应用程序的代码。</p><h3><b>Log4j 使用步骤说明</b></h3><p><b>（1）选择 jar 包</b></p><p>加入 log4j-1.2.17.jar 到 Libraries 下，如果使用 maven 项目，也可以选择在 pom.xml 中新增依赖如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dependency&gt;\n        &lt;groupId&gt;log4j&lt;/groupId&gt;\n        &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n        &lt;version&gt;1.2.17&lt;/version&gt;\n    &lt;/dependency&gt;</code></pre></div><p><b>（2）log4j.properties 配置</b></p><p>Log4j 有三个主要组件：记录器， appender 和布局。这三种类型的组件协同工作，使开发人员能够根据消息类型和级别记录消息，并在运行时控制这些消息的格式和报告位置。</p><p>Log4j 建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。</p><p>比如定义了 INFO 级别，只有等于及高于这个级别的才进行处理，则应用程序中所有 DEBUG 级别的日志信息将不被打印出来。ALL，打印所有的日志；OFF，关闭所有的日志输出。</p><p>appenderName，就是指定日志信息输出到哪个地方。可同时指定多个输出目的地。</p><p>在 src 根目录下建立 log4j.properties，根据自己的需求，相应的修改其中的配置，其内容如下所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">#配置根Logger\n    #改代码表示输输出info级别以上的日志，文件分别输出，一个是file，一个是error\n    log4j.rootLogger=info,file,error\n\n    #配置file日志信息输出目的地Appender\n    #定义名为file的输出端是每天产生一个日志文件\n    log4j.appender.file=org.apache.log4j.DailyRollingFileAppender\n    #指定日志信息的最低输出级别位INFO，默认为DEBUG。\n    log4j.appender.file.Threshold=INFO\n    #指定当前消息输出到jpm/log4j/log.log文件中\n    log4j.appender.file.File=/jpm/log4j/log.log\n    #指定按天来滚动日志文件\n    log4j.appender.file.DatePattern=yyyy-MM-dd\n    #配置日志信息的格式（布局）Layout是可以灵活地指定布局模式\n    log4j.appender.file.layout=org.apache.log4j.PatternLayout\n    #格式化日志，Log4j采用类似C语言中的printf函数的打印格式格式化日志信息\n    log4j.appender.file.layout.ConversionPattern=[%d{yyyy-MM-ddHH:mm:ss}][%-5p][jpm-%c{1}-%M(%L)]-%m%n\n    #指定输出信息的编码\n    log4j.appender.file.encoding=UTF-8\n\n    #配置error日志信息输出目的地Appender\n    #定义名为error的输出端是每天产生一个日志文件\n    log4j.appender.error=org.apache.log4j.DailyRollingFileAppender\n    #指定日志信息的最低输出级别位ERROR，默认为DEBUG。\n    log4j.appender.error.Threshold=ERROR\n    #指定当前消息输出到jpm/log4j/error.log文件中\n    log4j.appender.error.File=/jpm/log4j/error.log\n    #指定按月来滚动日志文件\n    log4j.appender.error.DatePattern=yyyy-MM\n    #配置日志信息的格式（布局）Layout是可以灵活地指定布局模式\n    log4j.appender.error.layout=org.apache.log4j.PatternLayout\n    #格式化日志，Log4j采用类似C语言中的printf函数的打印格式格式化日志信息\n    log4j.appender.error.layout.ConversionPattern=[%d{yyyy-MM-ddHH:mm:ss}][%-5p][jpm-%c{1}-%M(%L)]-%m%n\n    #指定输出信息的编码\n    log4j.appender.error.encoding=UTF-8\n\n    #使某个功能的日志单独输出到指定的日志文件\n    log4j.logger.saveUserLog=INFO,saveUserLog\n    #该配置就是让job的日志只输出到自己指定的日志文件中,表示Logger不会在父Logger的appender里输出，默认为true。\n    log4j.additivity.saveUserLog=false\n    log4j.appender.saveUserLog=org.apache.log4j.DailyRollingFileAppender\n    log4j.appender.saveUserLog.File=/jpm/log4j/saveUserLog.log\n    log4j.appender.saveUserLog.DatePattern=yyyy-MM-dd\n    log4j.appender.saveUserLog.Append=true\n    log4j.appender.saveUserLog.layout=org.apache.log4j.PatternLayout\n    log4j.appender.saveUserLog.layout.ConversionPattern=%m%n\n    log4j.appender.error.encoding=UTF-8</code></pre></div><p><b>（3）输出日志的代码示例</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package jpm;\n\n    import org.apache.log4j.Logger;\n\n    public class TestLog4j {\n\n        public static void main(String[] args) {\n            final Logger logger = Logger.getLogger(TestLog4j.class);\n            final Logger saveUserLog = Logger.getLogger(&#34;saveUserLog&#34;);\n\n            if (logger.isDebugEnabled()) {\n                logger.debug(&#34;debug&#34;);\n            }\n\n            logger.info(&#34;info&#34;);\n            logger.error(&#34;error&#34;);\n\n            saveUserLog.info(&#34;张三,男,26岁,北京大学,2018-05-19,学霸&#34;);\n\n        }\n\n    }</code></pre></div><p><b>（4）以上代码示例生成的日志文件及日志详情</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a8903ca4a3d5f97a1d696998fc00e150_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"73\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;73&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"73\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic1.zhimg.com/v2-a8903ca4a3d5f97a1d696998fc00e150_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-28c0f94b7a08b1d3526714e7f53f83c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-28c0f94b7a08b1d3526714e7f53f83c4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;108&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-28c0f94b7a08b1d3526714e7f53f83c4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-28c0f94b7a08b1d3526714e7f53f83c4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>2. JUL（在 java.util.logging 包下）使用示例</h3><h3><b>JUL 介绍</b></h3><p>Java Logging API 是 Sun 公司于 2002 年 5 月正式发布的。它是自 J2SE 1.4 版本开始提供的一个新的应用程序接口，需 JDK1.4 版本以上才能支持，java.util.logging.* 包是 JDK 的日志记录 API。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-66266d98c49b4d310d53694cfdc74b01_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1104\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb\" width=\"1104\" data-original=\"https://pic2.zhimg.com/v2-66266d98c49b4d310d53694cfdc74b01_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1104&#39; height=&#39;484&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1104\" data-rawheight=\"484\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1104\" data-original=\"https://pic2.zhimg.com/v2-66266d98c49b4d310d53694cfdc74b01_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-66266d98c49b4d310d53694cfdc74b01_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>强烈不推荐使用 java.util.logging 记录日志，因此这里不提供对应示例给大家。</b></p><h3>3. java common logging 介绍</h3><p>commons-logging 提供的是一个日志接口，是为那些需要建立在不同环境下使用不同日志架构的组件或库的开发者创建的，其中包括 log4j 以及 Java log 的日志架构。commons-logging 有两个基本的抽象类：Log(基本记录器) 和 LogFactory(负责创建 Log 实例)。把日志信息抽象成 commons-logging 的 Log 接口，并由 commons-logging 在运行时决定使用哪种日志架构。因为 Log4j 的强大功能，commons-logging 一般会和 Log4j 一起使用，这几乎成为了 Java 日志的标准工具。</p><h3>4. SLF4J介绍</h3><p>SLF4J 全称为 Simple Logging Facade for JAVA，即 java 简单日志门面。 和 commons-loging 一样也是对不同日志框架提供的一个门面封装，可以在部署的时候不修改任何配置即可接入一种日志实现方案，能支持多个参数，并通过 {} 占位符进行替换。</p><p><b>看这个 Log4J 示例：</b></p><div class=\"highlight\"><pre><code class=\"language-text\">Logger.debug(&#34;Hello &#34; + name);</code></pre></div><p>由于字符串拼接的问题（注：上述语句会先拼接字符串，再根据当前级别是否低于 debug 决定是否输出本条日志，即使不输出日志，字符串拼接操作也会执行），因此许多公司一般强制使用下面的语句，这样只有当前处于DEBUG级别时才会执行字符串拼接：</p><div class=\"highlight\"><pre><code class=\"language-text\">if (logger.isDebugEnabled()) {\n        LOGGER.debug(“Hello ” + name);\n    }</code></pre></div><p>它避免了字符串拼接问题，可是有点太繁琐了。而 SLF4J 提供下面这样简单的语法:</p><div class=\"highlight\"><pre><code class=\"language-text\">LOGGER.debug(&#34;Hello {}&#34;, name);</code></pre></div><p>它的形式类似第一条示例，但是又没有字符串拼接问题，也不像第二条那样繁琐。</p><p>正是因为 SLF4J 的这个占位符功能，使得人们越来越多的使用 SLF4J 这个接口用到实际开发项目中。</p><p><b>为什么需要日志接口，直接使用具体的实现不就行了吗？</b></p><p>接口用于定制规范，可以有多个实现，使用时是面向接口的（导入的包都是 SLF4J 的包或者是 JCL 的包，而不是具体某个日志框架中的包），即直接和接口交互，不直接使用实现，所以当需要更换实现的时候，直接更换实就可以了，而不用更改代码中的日志相关代码。</p><p>比如：SLF4J 定义了一套日志接口，项目中使用的日志框架是 log4j，开发中调用的所有接口都是 SLF4J 的，不直接使用 log4j，项目应用调用 SLF4J 的接口，SLF4J 的接口去调用 log4j 的实现，整个应用程序并没有直接使用 log4j，当项目需要更换更加优秀的日志框架时（如 logback）只需要引入 logback 的 jar 和 logback 对应的配置文件即可，完全不用更改 Java 代码中的日志相关的代码 <a href=\"https://link.zhihu.com/?target=http%3A//logger.info\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">logger.info</span><span class=\"invisible\"></span></a>(“hello world”)，也不用修改日志相关的类的导入的包（import org.slf4j.Logger; import org.slf4j.LoggerFactory;）。</p><p>因此日志门面的使用，为后续具体日志系统的实现更换带来了方便。</p><h3>5. logback 使用示例</h3><h3><b>LogBack 介绍</b></h3><p>LogBack 和 Log4j 都是开源日记工具库，LogBack 是 Log4j 的改良版本，比 Log4j 拥有更多的特性，同时也带来很大性能提升。LogBack 官方建议配合 Slf4j 使用，这样可以灵活地替换底层日志框架。</p><p>Logback 主要由三个模块组成：</p><ul><li>logback-core</li><li>logback-classic</li><li>logback-access</li></ul><p>其中 logback-core 提供了 LogBack 的核心功能，是另外两个组件的基础。logback-classic 的地位和作用等同于 Log4J，它也被认为是 Log4J 的一个改进版，并且它实现了简单日志门面 SLF4J，所以当想配合 SLF4J 使用时，需要将 logback-classic 加入 classpath；而 logback-access 主要作为一个与 Servlet 容器交互的模块，比如说 tomcat 或者 jetty，提供一些与 HTTP 访问相关的功能。</p><h3><b>logback 使用步骤说明</b></h3><p><b>（1）选择 jar 包</b></p><p>想在 Java 程序中使用 Logback，需要依赖三个 jar 包，分别是 slf4j-api，logback-core，logback-classic。其中 slf4j-api 并不是 Logback 的一部分，建议将 SLF4J 与 Logback 结合使用。</p><p><b>pom.xml</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n                &lt;version&gt;1.7.25&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n                &lt;artifactId&gt;logback-core&lt;/artifactId&gt;\n                &lt;version&gt;1.2.3&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n                &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;\n                &lt;version&gt;1.2.3&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;\n                &lt;artifactId&gt;logback-access&lt;/artifactId&gt;\n                &lt;version&gt;1.2.3&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre></div><p><b>（2）logback.xml</b></p><p>在 src 根目录下建立 logback.xml，根据自己的需求，相应的修改其中的配置，其内容如下所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;\n    &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;\n    &lt;!-- status用来指定log4j本身的打印日志的级别 --&gt;\n    &lt;!--monitorInterval：Log4j能够自动检测修改配置文件和重新配置本身，设置间隔秒数 --&gt;\n    &lt;configuration status=&#34;WARN&#34; monitorInterval=&#34;30&#34;&gt;\n        &lt;!--先定义所有的appender --&gt;\n        &lt;appenders&gt;\n            &lt;!--这个输出控制台的配置 --&gt;\n            &lt;console name=&#34;Console&#34; target=&#34;SYSTEM_OUT&#34;&gt;\n                &lt;!--输出日志的格式 --&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n            &lt;/console&gt;\n\n            &lt;!--定义输出到指定位置的文件 --&gt;\n            &lt;File name=&#34;log&#34; fileName=&#34;/jpm/log4j2/logs/log.log&#34; append=&#34;true&#34;&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n            &lt;/File&gt;\n\n            &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;\n            &lt;RollingFile name=&#34;RollingFileInfo&#34; fileName=&#34;/jpm/log4j2/logs/info.log&#34;\n                filePattern=&#34;/jpm/log4j2/logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log&#34;&gt;\n                &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;\n                &lt;!-- DENY，日志将立即被抛弃不再经过其他过滤器； NEUTRAL，有序列表里的下个过滤器过接着处理日志； ACCEPT，日志会被立即处理，不再经过剩余过滤器。 --&gt;\n                &lt;ThresholdFilter level=&#34;error&#34; onMatch=&#34;DENY&#34;\n                    onMismatch=&#34;ACCEPT&#34; /&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n                &lt;Policies&gt;\n                    &lt;TimeBasedTriggeringPolicy /&gt;\n                    &lt;SizeBasedTriggeringPolicy size=&#34;100 MB&#34; /&gt;\n                &lt;/Policies&gt;\n                &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了30 --&gt;\n                &lt;DefaultRolloverStrategy max=&#34;30&#34; /&gt;\n            &lt;/RollingFile&gt;\n\n            &lt;RollingFile name=&#34;RollingFileError&#34; fileName=&#34;/jpm/log4j2/logs/error.log&#34;\n                filePattern=&#34;/jpm/log4j2/logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log&#34;&gt;\n                &lt;ThresholdFilter level=&#34;ERROR&#34; onMatch=&#34;ACCEPT&#34;\n                    onMismatch=&#34;DENY&#34; /&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n                &lt;Policies&gt;\n                    &lt;TimeBasedTriggeringPolicy /&gt;\n                    &lt;SizeBasedTriggeringPolicy size=&#34;100 MB&#34; /&gt;\n                &lt;/Policies&gt;\n            &lt;/RollingFile&gt;\n        &lt;/appenders&gt;\n\n        &lt;!--只有定义了logger并引入的appender，appender才会生效 --&gt;\n        &lt;loggers&gt;\n            &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息 --&gt;\n            &lt;logger name=&#34;org.springframework&#34; level=&#34;INFO&#34;&gt;&lt;/logger&gt;\n            &lt;logger name=&#34;org.mybatis&#34; level=&#34;INFO&#34;&gt;&lt;/logger&gt;\n            &lt;root level=&#34;INFO&#34;&gt;\n                &lt;appender-ref ref=&#34;Console&#34; /&gt;\n                &lt;appender-ref ref=&#34;log&#34; /&gt;\n                &lt;appender-ref ref=&#34;RollingFileInfo&#34; /&gt;\n                &lt;appender-ref ref=&#34;RollingFileError&#34; /&gt;\n            &lt;/root&gt;\n        &lt;/loggers&gt;\n\n    &lt;/configuration&gt;</code></pre></div><p><b>（3）输出日志的代码示例</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package jpm.logback;\n\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n\n    public class TestLogback {\n\n        public static void main(String[] args) {\n            final Logger LOGGER = LoggerFactory.getLogger(TestLogback.class);\n            LOGGER.debug(&#34;print debug log.&#34;);\n            LOGGER.info(&#34;print info log.&#34;);\n            LOGGER.error(&#34;print error log.&#34;);\n        }\n    }</code></pre></div><p><b>（4）打印日志结果</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e5cf7e342e2821235428d3f1c33a7cd2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"338\" data-rawheight=\"255\" class=\"content_image\" width=\"338\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;338&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"338\" data-rawheight=\"255\" class=\"content_image lazy\" width=\"338\" data-actualsrc=\"https://pic3.zhimg.com/v2-e5cf7e342e2821235428d3f1c33a7cd2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9c2ceb4f73b1771b0fde829117e9d33a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb\" width=\"1168\" data-original=\"https://pic3.zhimg.com/v2-9c2ceb4f73b1771b0fde829117e9d33a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1168&#39; height=&#39;314&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1168\" data-rawheight=\"314\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1168\" data-original=\"https://pic3.zhimg.com/v2-9c2ceb4f73b1771b0fde829117e9d33a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9c2ceb4f73b1771b0fde829117e9d33a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>上例使用 SLF4J 做日志接口， logback 做日志实现的日志示例</b></p><h3>6. Log4j2 使用示例</h3><h3><b>Log4j2 介绍</b></h3><p>Apache Log4j 2 是对 Log4j 的升级，与其前身 Log4j 1.x 相比有了显着的改进，并提供了许多 Logback 可用的改进，同时支持 JCL 以及 SLF4J。</p><h3><b>Log4j2 使用步骤说明</b></h3><p><b>（1）选择 jar 包</b></p><p>引入 Log4j2 必要的包：log4j-api、log4j-core。</p><p><b>pom.xml 配置</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dependency&gt;\n                &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n                &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;\n                &lt;version&gt;2.8.2&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;\n                &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;\n                &lt;version&gt;2.8.2&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre></div><p><b>（2）log2j 配置文件：log4j2.xml</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;\n    &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;\n    &lt;!-- status用来指定Log4j本身的打印日志的级别 --&gt;\n    &lt;!--monitorInterval：Log4j能够自动检测修改配置文件和重新配置本身，设置间隔秒数 --&gt;\n    &lt;configuration status=&#34;WARN&#34; monitorInterval=&#34;30&#34;&gt;\n        &lt;!--先定义所有的appender --&gt;\n        &lt;appenders&gt;\n            &lt;!--这个输出控制台的配置 --&gt;\n            &lt;console name=&#34;Console&#34; target=&#34;SYSTEM_OUT&#34;&gt;\n                &lt;!--输出日志的格式 --&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n            &lt;/console&gt;\n\n            &lt;!--定义输出到指定位置的文件 --&gt;\n            &lt;File name=&#34;log&#34; fileName=&#34;/jpm/log4j2/logs/log.log&#34; append=&#34;true&#34;&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n            &lt;/File&gt;\n\n            &lt;!-- 这个会打印出所有的info及以下级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;\n            &lt;RollingFile name=&#34;RollingFileInfo&#34; fileName=&#34;/jpm/log4j2/logs/info.log&#34;\n                filePattern=&#34;/jpm/log4j2/logs/$${date:yyyy-MM}/info-%d{yyyy-MM-dd}-%i.log&#34;&gt;\n                &lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;\n                &lt;ThresholdFilter level=&#34;info&#34; onMatch=&#34;ACCEPT&#34;\n                    onMismatch=&#34;DENY&#34; /&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n                &lt;Policies&gt;\n                    &lt;TimeBasedTriggeringPolicy /&gt;\n                    &lt;SizeBasedTriggeringPolicy size=&#34;100 MB&#34; /&gt;\n                &lt;/Policies&gt;\n                &lt;!-- DefaultRolloverStrategy属性如不设置，则默认为最多同一文件夹下7个文件，这里设置了30 --&gt;\n                &lt;DefaultRolloverStrategy max=&#34;30&#34; /&gt;\n            &lt;/RollingFile&gt;\n\n            &lt;RollingFile name=&#34;RollingFileError&#34; fileName=&#34;/jpm/log4j2/logs/error.log&#34;\n                filePattern=&#34;/jpm/log4j2/logs/$${date:yyyy-MM}/error-%d{yyyy-MM-dd}-%i.log&#34;&gt;\n                &lt;ThresholdFilter level=&#34;error&#34; onMatch=&#34;ACCEPT&#34;\n                    onMismatch=&#34;DENY&#34; /&gt;\n                &lt;PatternLayout\n                    pattern=&#34;[%d{yyyy-MM-dd HH:mm:ss.SSS}] [%-5level] %l %logger{36} - %msg%n&#34; /&gt;\n                &lt;Policies&gt;\n                    &lt;TimeBasedTriggeringPolicy /&gt;\n                    &lt;SizeBasedTriggeringPolicy size=&#34;100 MB&#34; /&gt;\n                &lt;/Policies&gt;\n            &lt;/RollingFile&gt;\n        &lt;/appenders&gt;\n\n        &lt;!--只有定义了logger并引入的appender，appender才会生效 --&gt;\n        &lt;loggers&gt;\n            &lt;!--过滤掉spring和mybatis的一些无用的DEBUG信息 --&gt;\n            &lt;logger name=&#34;org.springframework&#34; level=&#34;INFO&#34;&gt;&lt;/logger&gt;\n            &lt;logger name=&#34;org.mybatis&#34; level=&#34;INFO&#34;&gt;&lt;/logger&gt;\n            &lt;root level=&#34;INFO&#34;&gt;\n                &lt;appender-ref ref=&#34;Console&#34; /&gt;\n                &lt;appender-ref ref=&#34;log&#34; /&gt;\n                &lt;appender-ref ref=&#34;RollingFileInfo&#34; /&gt;\n                &lt;appender-ref ref=&#34;RollingFileError&#34; /&gt;\n            &lt;/root&gt;\n        &lt;/loggers&gt;\n\n    &lt;/configuration&gt;</code></pre></div><p><b>（3）输出日志的代码示例</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package jpm.log4j2;\n\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n\n    public class TestLog4j2 {\n\n        public static void main(String[] args) {\n            final Logger LOGGER = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);\n            LOGGER.debug(&#34;TestLog4j2 debug log.&#34;);\n            LOGGER.info(&#34;TestLog4j2 info log.&#34;);\n            LOGGER.error(&#34;TestLog4j2 error log.&#34;);\n        }\n\n    }</code></pre></div><p><b>（4）打印日志结果</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-be11d8203d8c529c9a9020a05967bdf8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"366\" data-rawheight=\"171\" class=\"content_image\" width=\"366\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;366&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"366\" data-rawheight=\"171\" class=\"content_image lazy\" width=\"366\" data-actualsrc=\"https://pic1.zhimg.com/v2-be11d8203d8c529c9a9020a05967bdf8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2f11d92ede4c1418d88ca05e481cf044_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1179\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb\" width=\"1179\" data-original=\"https://pic1.zhimg.com/v2-2f11d92ede4c1418d88ca05e481cf044_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1179&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1179\" data-rawheight=\"343\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1179\" data-original=\"https://pic1.zhimg.com/v2-2f11d92ede4c1418d88ca05e481cf044_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2f11d92ede4c1418d88ca05e481cf044_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（5）关于日志 level</b></p><p>共有 8 个级别，按照从低到高为：All &lt; Trace &lt; Debug &lt; Info &lt; Warn &lt; Error &lt; Fatal &lt; OFF。</p><ul><li><b>All：</b>最低等级的，用于打开所有日志记录</li><li><b>Trace：</b>是追踪，就是程序推进以下，你就可以写个 trace 输出，所以 trace 应该会特别多，不过没关系，我们可以设置最低日志级别不让他输出</li><li><b>Debug：</b>指出细粒度信息事件对调试应用程序是非常有帮助的</li><li><b>Info：</b>消息在粗粒度级别上突出强调应用程序的运行过程</li><li><b>Warn：</b>输出警告及 warn 以下级别的日志</li><li><b>Error：</b>输出错误信息日志</li><li><b>Fatal：</b>输出每个严重的错误事件将会导致应用程序的退出的日志</li><li><b>OFF：</b>最高等级的，用于关闭所有日志记录</li></ul><p>程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少。</p><h3>7. JCL(java common logging) + Log4j 使用示例</h3><h3><b>JCL(java common logging) + Log4j 介绍</b></h3><p>使用 commons-logging 的 Log 接口，并由 commons-logging 在运行时决定使用哪种日志架构（如 Log4j）。现在，Apache 通用日志工具 commons-logging 和 Log4j 已经成为 Java 日志的标准工具，这个组合是比较常用的一个日志框架组合。</p><h3><b>JCL(java common logging) + Log4j 使用步骤说明</b></h3><p><b>（1）选择 jar 包</b></p><div class=\"highlight\"><pre><code class=\"language-text\">commons-logging-1.2 + log4j1.2.17</code></pre></div><p><b>pom.xml</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dependency&gt;\n                &lt;groupId&gt;commons-logging&lt;/groupId&gt;\n                &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;\n                &lt;version&gt;1.2&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;log4j&lt;/groupId&gt;\n                &lt;artifactId&gt;log4j&lt;/artifactId&gt;\n                &lt;version&gt;1.2.17&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre></div><p><b>（2）配置 common-logging.properties 文件</b></p><p>只需要一行即可，放在 classpath 下，如果是 Maven 中就在 src/resources 下，不过如果没有 common-logging.properties 文件，但是 src 下有 log4j.properties 配置也可以正常的输出 Log4j 设置的日志。</p><div class=\"highlight\"><pre><code class=\"language-text\">org.apache.commons.logging.Log=org.apache.commons.logging.impl.Log4JLogger</code></pre></div><p><b>（3）log4j.properties 配置</b></p><p>参考《Log4j 使用步骤说明》</p><p><b>（4）输出日志的代码示例</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package jpm.jcllog4j;\n\n    import org.apache.commons.logging.Log;\n    import org.apache.commons.logging.LogFactory;\n\n    public class TestJclAndLog4j {\n\n        public static void main(String[] args) {\n            final Log LOGGER = LogFactory.getLog(TestJclAndLog4j.class);\n            LOGGER.debug(&#34;TestJclAndLog4j debug log.&#34;);\n            LOGGER.info(&#34;TestJclAndLog4j info log.&#34;);\n            LOGGER.error(&#34;TestJclAndLog4j error log.&#34;);\n        }\n    }</code></pre></div><p><b>（5）打印日志结果</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-953e2376a2fac3d9af730ceb2ca40a81_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"354\" data-rawheight=\"162\" class=\"content_image\" width=\"354\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;354&#39; height=&#39;162&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"354\" data-rawheight=\"162\" class=\"content_image lazy\" width=\"354\" data-actualsrc=\"https://pic2.zhimg.com/v2-953e2376a2fac3d9af730ceb2ca40a81_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f3927da8d2998d641730acb45ca0cf0c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https://pic1.zhimg.com/v2-f3927da8d2998d641730acb45ca0cf0c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;701&#39; height=&#39;309&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"309\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"701\" data-original=\"https://pic1.zhimg.com/v2-f3927da8d2998d641730acb45ca0cf0c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f3927da8d2998d641730acb45ca0cf0c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>8. SLF4J + Log4j 使用示例</h3><h3><b>SLF4J + Log4j 介绍</b></h3><p>SLF4j+Log4j 与 JCL+Log4J 的使用方式差不多，主要差异就在 SLF4J 用 用绑定包（slf4j-Log4j12.jar）来告知用哪种日志实现，而 JCL 是通过配置文件来获得该选择哪个日志实现。</p><h3><b>SLF4J + Log4j使用步骤说明</b></h3><p><b>（1）选择jar包</b></p><div class=\"highlight\"><pre><code class=\"language-text\">slf4j-api.jar + slf4j-log4j12.jar</code></pre></div><p><b>pom.xml</b></p><div class=\"highlight\"><pre><code class=\"language-text\">&lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;\n                &lt;version&gt;1.7.25&lt;/version&gt;\n            &lt;/dependency&gt;\n\n            &lt;dependency&gt;\n                &lt;groupId&gt;org.slf4j&lt;/groupId&gt;\n                &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;\n                &lt;version&gt;1.7.25&lt;/version&gt;\n            &lt;/dependency&gt;</code></pre></div><p><b>（2）log4j.properties 配置文件</b></p><p>参考《Log4j 使用步骤说明》</p><p><b>（3）输出日志的代码示例</b></p><div class=\"highlight\"><pre><code class=\"language-text\">package jpm.slf4jlog4j;\n\n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n\n    public class TestSlf4jAndLog4j {\n\n        public static void main(String[] args) {\n            final Logger LOGGER = LoggerFactory.getLogger(TestSlf4jAndLog4j.class);\n            LOGGER.debug(&#34;TestSlf4jAndLog4j debug log：{}&#34;, &#34;debug&#34;);\n            LOGGER.info(&#34;TestSlf4jAndLog4j info log：{}&#34;, &#34;info&#34;);\n            LOGGER.error(&#34;TestSlf4jAndLog4j error log：{}&#34;, &#34;error&#34;);\n        }\n\n    }</code></pre></div><p><b>（4）打印日志结果</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-990aca0df5ebd71d0a29ebad5a5d6858_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"362\" data-rawheight=\"140\" class=\"content_image\" width=\"362\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;362&#39; height=&#39;140&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"362\" data-rawheight=\"140\" class=\"content_image lazy\" width=\"362\" data-actualsrc=\"https://pic1.zhimg.com/v2-990aca0df5ebd71d0a29ebad5a5d6858_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-25cbbac94a5b4ad99c08b6ebc3cc12f0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb\" width=\"804\" data-original=\"https://pic1.zhimg.com/v2-25cbbac94a5b4ad99c08b6ebc3cc12f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;804&#39; height=&#39;165&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"165\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"804\" data-original=\"https://pic1.zhimg.com/v2-25cbbac94a5b4ad99c08b6ebc3cc12f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-25cbbac94a5b4ad99c08b6ebc3cc12f0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>五、项目中日志记录遵守哪些原则</h3><h3>1. 阿里巴巴 Java 开发手册的日志规约</h3><p>大家可以参考去年 10 月份阿里推出的《阿里巴巴 Java 开发手册（终极版）.pdf》里的第二章第二节“日志规约”部分的内容。</p><h3>2. 个人经验总结</h3><p>记录项目日志要注意以下几点：</p><ol><li>注意日志级别，尤其是 info 和 error 不能用混。</li><li>注意记录信息的准确性，切记日志表达不清楚。</li><li>注意不同的代码段日志说明不能重复。</li><li>捕获异常后，要及时记录异常详细信息，并把异常传递到外部。</li><li>时刻铭记，日志的记录是为了后期查询问题带来方便，因此重要的代码务必要记录日志。</li></ol><h3>六、一个推荐的项目 Java 日志实例</h3><p>经过以上代码的分析，我们项目中使用的日志一般会选用一个日志接口和一个具体的日志实现。</p><p>那么日志接口是选 JCL 呢，还是选 SLF4J 呢？下面我们把他俩做个对比，具体日志实现为 Log4j，如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-d80377fa8f2af3220eb3574ec4bbe8b2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"783\" data-rawheight=\"471\" class=\"origin_image zh-lightbox-thumb\" width=\"783\" data-original=\"https://pic3.zhimg.com/v2-d80377fa8f2af3220eb3574ec4bbe8b2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;783&#39; height=&#39;471&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"783\" data-rawheight=\"471\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"783\" data-original=\"https://pic3.zhimg.com/v2-d80377fa8f2af3220eb3574ec4bbe8b2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d80377fa8f2af3220eb3574ec4bbe8b2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图可以看出，用 slf4j 作为日志接口，对项目来说更好一些。</p><p>所以，在实际项目中，我一般建议使用 SLF4J+Log4j 或者 slf4j+logback。</p><p><b>配置文件参见第四节</b></p><p><b>推荐程序片段如下</b></p><div class=\"highlight\"><pre><code class=\"language-text\">try {\n                LOGGER.info(&#34;根据用户编码查询用户信息-开始，userId：{}&#34; , userId);\n                User user = userService.getUserById(userId);\n                LOGGER.info(&#34;根据用户编码查询用户信息-结束，userId：{}&#34; , userId);\n            } catch (CustomException e) {\n                LOGGER.error(&#34;根据用户编码查询用户信息-自定义异常:{}&#34; , e.getMessage());\n                throw new CustomException(&#34;根据用户编码查询用户信息-自定义异常{}&#34; , e.getMessage(), e);\n            } catch (Exception e) {\n                LOGGER.error(&#34;根据用户编码查询用户信息-捕获异常:{}&#34; , e.toString());\n                throw new ServiceException(根据用户编码查询用户信息-捕获异常:{}&#34; , e.toString(), e);\n            }\n</code></pre></div><p>到此，Java 日志从入门到实战  就结束了，咱们下次再见，谢谢。</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>总结得深入浅出了,赞</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "林伟明", 
                    "userLink": "https://www.zhihu.com/people/8ae1703c9f463ab864b672344609343e", 
                    "content": "总结的很不错，收益良多", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "总结的很好，感谢！！", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64644900", 
            "userName": "Java猫说", 
            "userLink": "https://www.zhihu.com/people/2b6e3966225e27d4147586a830958d71", 
            "upvote": 0, 
            "title": "如何在VMware12安装Centos7.6最新版", 
            "content": "<p></p><blockquote> 本博客 <a href=\"https://link.zhihu.com/?target=https%3A//unclecatmyself.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">猫叔的博客</a>，转载请申明出处<br/> 本系列教程为<a href=\"https://link.zhihu.com/?target=https%3A//github.com/UncleCatMySelf/HMStrange\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HMStrange项目</a>附带。</blockquote><h2>ISO镜像下载</h2><p><a href=\"https://link.zhihu.com/?target=http%3A//59.80.44.49/http%3A//isoredirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">59.80.44.49/http://isor</span><span class=\"invisible\">edirect.centos.org/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-1810.iso</span><span class=\"ellipsis\"></span></a></p><p>直接点击下载，或者进入下载地址，我这边选择的是第一个。</p><h2>安装流程</h2><ul><li>1、选择典型安装模式即可</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6bc92d70b28f6649be4c56b9c9b4cabc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-6bc92d70b28f6649be4c56b9c9b4cabc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-6bc92d70b28f6649be4c56b9c9b4cabc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6bc92d70b28f6649be4c56b9c9b4cabc_b.jpg\"/></figure><p> * 2、选择安装的ISO文件地址，我选择的就是开头的链接地址</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-639a643a1ca7d53b38f20c6578064ef8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-639a643a1ca7d53b38f20c6578064ef8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-639a643a1ca7d53b38f20c6578064ef8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-639a643a1ca7d53b38f20c6578064ef8_b.jpg\"/></figure><p> * 3、你可以修改名字或者修改存放位置</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-da3f9480c3a92e19608c5f247224f8a8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-da3f9480c3a92e19608c5f247224f8a8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-da3f9480c3a92e19608c5f247224f8a8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-da3f9480c3a92e19608c5f247224f8a8_b.jpg\"/></figure><p> * 4、容量这一块看情况，我这边直接默认的</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9ddec98e48a3e5f98873b3c2900c8250_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-9ddec98e48a3e5f98873b3c2900c8250_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;503&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"503\" data-rawheight=\"430\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"503\" data-original=\"https://pic1.zhimg.com/v2-9ddec98e48a3e5f98873b3c2900c8250_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9ddec98e48a3e5f98873b3c2900c8250_b.jpg\"/></figure><p> * 5、直接点击创建即可，一开始启动的时候需要默认配置，语言选择中文简体，因人而异。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ff2c32712d4fac82a1bed576c74371f3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-ff2c32712d4fac82a1bed576c74371f3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-ff2c32712d4fac82a1bed576c74371f3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ff2c32712d4fac82a1bed576c74371f3_b.jpg\"/></figure><p> * 6、接下来你会看到这个界面，你需要配置两个东西，一个是位置、一个是网络。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-9d4118a3fb59bf043459545d9d2054b1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-9d4118a3fb59bf043459545d9d2054b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-9d4118a3fb59bf043459545d9d2054b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-9d4118a3fb59bf043459545d9d2054b1_b.jpg\"/></figure><p> * 7、选择安装位置，这一块点进来就好，它会默认设定一次</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a8b4c3edcbf42d911190a66174228fd1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-a8b4c3edcbf42d911190a66174228fd1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-a8b4c3edcbf42d911190a66174228fd1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a8b4c3edcbf42d911190a66174228fd1_b.jpg\"/></figure><p> * 8、设置网络，修改主机名、选择应用、打开以太网，点击配置</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6469b2ff9a03371ebe463537e77e1048_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-6469b2ff9a03371ebe463537e77e1048_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-6469b2ff9a03371ebe463537e77e1048_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6469b2ff9a03371ebe463537e77e1048_b.jpg\"/></figure><p> * 9、网络配置，选择常规，然后勾选第一个“可用时自动链接到这个网络”</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-21d39f49832d482a569c284b3f859c03_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-21d39f49832d482a569c284b3f859c03_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic4.zhimg.com/v2-21d39f49832d482a569c284b3f859c03_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-21d39f49832d482a569c284b3f859c03_b.jpg\"/></figure><p> * 10、最后保存，在安装界面设定root的密码</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ea1a67360aba0c20db0dbc4302f36a1d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-ea1a67360aba0c20db0dbc4302f36a1d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-ea1a67360aba0c20db0dbc4302f36a1d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ea1a67360aba0c20db0dbc4302f36a1d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>安装成功！</p><p>进入界面后，大家可以输入</p><div class=\"highlight\"><pre><code class=\"language-text\">ip addr</code></pre></div><p>查看网络ip，一般可以看到两个lo、ens33的信息。</p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "程序", 
                    "tagLink": "https://api.zhihu.com/topics/19565652"
                }, 
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/51228042", 
            "userName": "栗子球", 
            "userLink": "https://www.zhihu.com/people/d8aa4fde3e0562e7054d532bac40e969", 
            "upvote": 1, 
            "title": "SVN被锁定的几种解决方法", 
            "content": "<p> 用SVN经常出现被锁定而无法提交的问题，选择解锁又提示没有文件被锁定，很是头疼。<br/>这里整理了一下SVN 被锁定的几种解决方法：</p><p>1.出现这个问题后使用“清理”即&#34;Clean up&#34;功能，如果还不行，就直接到上一级目录，再执行“清理”，然后再“更新”。</p><p>2.有时候如果看到某个包里面的文件夹没有SVN的标志，直接用“Ctrl+Delete”手工删除，然后“清理”，最后“更新”或“提交”。</p><p>3.有时候有的文件死活无法提交和更新，有lock字样的提示，：首先点击该文件，然后getLock,再选中stealLock,然后release lock即可</p><p>4.教大家最狠的一招，在项目中如果是出现某个文件死锁的情况无法解决的情况下，叫开发中所有的人把文件上传了解锁了，清空版本库地址：安装目录:SvnTracsvnprojectsdblocks这个文件夹路径里面的全部内容。一切ok!</p><p>提示：</p><p>Subversion1.3.2，开启匿名访问的同时利用authz功能限制匿名访问，则会出现check out 时提示被LOCK的现象</p>", 
            "topic": [
                {
                    "tag": "版本控制", 
                    "tagLink": "https://api.zhihu.com/topics/19738222"
                }, 
                {
                    "tag": "SVN(Subversion)", 
                    "tagLink": "https://api.zhihu.com/topics/19607465"
                }, 
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57053649", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 3, 
            "title": "程序员如何避免“滴滴式裁员”悲剧？", 
            "content": "<p>相信这几天大家的朋友圈已经被滴滴裁员刷屏了，第一次见这种自爆“我要裁员，裁掉2000！”的公司啊，勇气可嘉。想跳槽的、不想跳槽的，这下估计都挺颤抖的，不会正好就选中了自己吧，还是早早做准备。</p><p>看了下滴滴公开的2019年组织升级计划，有几个关键信息：非主业关停并转，绩效不达标员工减员，加起来裁员15%近2000人。安全技术、产品、运营等新增2500新人。</p><p>其实已经说得很明白了，怎么判断你在这个公司稳不稳定，下面总结了3个重点。</p><p><b><i>1、核心部门</i></b></p><p>拿滴滴和美团举例，两家公司最先遭殃的就是那些非核心的边缘业务，比如滴滴的外卖，美团的打车，靠烧钱大量补贴的方法已经远没有那么奏效了，用户可能只是想薅个羊毛，真正能留住他们的还是底层的强大建设，未来产品体验可能会更看重服务，消费并没有降级。比如打车的司乘安全，外卖的供应链强大，都是核心要素。</p><p>而一个企业核心的业务才是它最初升起和持续走下去的重点，也就是最初的商业模式，边缘的业务和部门好滑水，靠着主流业务活下去，一旦危机来了，核心业务也得活命啊，缩减开支就从非主业开始，要么并入其他部门，要么直接撤掉。</p><p>所以，核心部门核心岗位很重要，是一剂强心针！</p><p><b><i>2、不可替代性高</i></b></p><p>说人话就是“这个工作换了别人不是不行，但成本太大，新人从上手到熟悉可能需要几个月”，那公司大概率就不会动你，会先从那些好上手的工作开始，你对业务的理解程度、工作的熟悉程度都是决定你去留的关键。</p><p>别说程序员只懂技术就行，但你要向上走当leader的话，还是得懂业务，懂为什么这样开发，怎样和产品经理更好地交流。</p><p><b><i>3、技术硬实力</i></b></p><p>这是成为一个优秀程序员最基本的，各位都知道，新人在公司晋升职级的速度、年终奖的多少，大多时候看的还是你的有效产出，聪明人很多，愿意走苦路的人很少，在技术的世界里没有投机取巧，也不是几张ppt就能保你职业生涯稳定。</p><p>那些比他人晋升快的程序员，都是经常奋战到深夜的，周末也依然坚持学习，这才是高绩效背后的原因。我身边有很多程序员都非常的拼命，裁员潮对他们并没有影响，反而逆势而上，升职加薪，这就是最好的证明！</p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "裁员", 
                    "tagLink": "https://api.zhihu.com/topics/19596680"
                }, 
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57120563", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 2, 
            "title": "Hadoop计数器的应用以及数据清洗", 
            "content": "<p><b>计数器作用</b><br/>作用： 在运行MR时，作为一个统计数据！参考数据，推测程序的运行效果！作为一个调试手段！<br/>使用： JobContext.getCounter(&#34;计算器所在的组名&#34;,&#34;当前计数器的名称&#34;).increcment(1);<br/>查看计算器打印的结果： job.watiForCompletion(boolean verbose);<br/>verbose传入true，才能可以查看计数器的打印结果！<br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-cefe49063d8c1c56430bd74fcf6084ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cefe49063d8c1c56430bd74fcf6084ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-cefe49063d8c1c56430bd74fcf6084ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cefe49063d8c1c56430bd74fcf6084ad_b.jpg\"/></figure><p><br/><b>数据清洗（ETL）</b><br/>在运行核心业务MapReduce程序之前，往往要先对数据进行清洗，清理掉不符合用户要求的数据。清理的过程往往只需要运行Mapper程序，不需要运行Reduce程序。<br/>1．需求<br/>去除日志中字段长度小于等于11的日志。<br/>（1）输入数据<br/>web.log<br/>（2）期望输出数据<br/>每行字段长度都大于11<br/>2．需求分析<br/>需要在Map阶段对输入的数据根据规则进行过滤清洗。<br/>3．实现代码<br/>（1）编写LogMapper类<br/>package com.demo.mapreduce.weblog;<br/>import java.io.IOException;<br/>import org.apache.hadoop.io.LongWritable;<br/>import org.apache.hadoop.io.NullWritable;<br/>import org.apache.hadoop.io.Text;<br/>import org.apache.hadoop.mapreduce.Mapper;<br/>public class LogMapper extends Mapper&lt;LongWritable, Text, Text, NullWritable&gt;{<br/>Text k = new Text();<br/>@Override<br/>protected void map(LongWritable key, Text value, Context context) throws IOException, InterruptedException {<br/>// 1 获取1行数据<br/>String line = value.toString();<br/>// 2 解析日志<br/>boolean result = parseLog(line,context);<br/>// 3 日志不合法退出<br/>if (!result) {<br/>return;<br/>}<br/>// 4 设置key<br/>k.set(line);<br/>// 5 写出数据<br/>context.write(k, NullWritable.get());<br/>}<br/>// 2 解析日志<br/>private boolean parseLog(String line, Context context) {<br/>// 1 截取<br/>String[] fields = line.split(&#34; &#34;);<br/>// 2 日志长度大于11的为合法<br/>if (fields.length &gt; 11) {<br/>// 系统计数器<br/>context.getCounter(&#34;map&#34;, &#34;true&#34;).increment(1);<br/>return true;<br/>}else {<br/>context.getCounter(&#34;map&#34;, &#34;false&#34;).increment(1);<br/>return false;<br/>}<br/>}<br/>}<br/>（2）编写LogDriver类<br/>package com.demo.mapreduce.weblog;<br/>import org.apache.hadoop.conf.Configuration;<br/>import org.apache.hadoop.fs.Path;<br/>import org.apache.hadoop.io.NullWritable;<br/>import org.apache.hadoop.io.Text;<br/>import org.apache.hadoop.mapreduce.Job;<br/>import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;<br/>import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;<br/>public class LogDriver {<br/>public static void main(String[] args) throws Exception {<br/>// 输入输出路径需要根据自己电脑上实际的输入输出路径设置<br/>args = new String[] { &#34;e:/input/inputlog&#34;, &#34;e:/output1&#34; };<br/>// 1 获取job信息<br/>Configuration conf = new Configuration();<br/>Job job = Job.getInstance(conf);<br/>// 2 加载jar包<br/>job.setJarByClass(LogDriver.class);<br/>// 3 关联map<br/>job.setMapperClass(LogMapper.class);<br/>// 4 设置最终输出类型<br/>job.setOutputKeyClass(Text.class);<br/>job.setOutputValueClass(NullWritable.class);<br/>// 设置reducetask个数为0<br/>job.setNumReduceTasks(0);<br/>// 5 设置输入和输出路径<br/>FileInputFormat.setInputPaths(job, new Path(args[0]));<br/>FileOutputFormat.setOutputPath(job, new Path(args[1]));<br/>// 6 提交<br/>job.waitForCompletion(true);<br/>}<br/>}</p><p>【想要了解更多的好文，请关注作者哦】</p>", 
            "topic": [
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }, 
                {
                    "tag": "数据分析", 
                    "tagLink": "https://api.zhihu.com/topics/19559424"
                }, 
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57160217", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 17, 
            "title": "面试最让你手足无措的一个问题：你的系统如何支撑高并发？", 
            "content": "<p>这篇文章，我们聊聊大量同学问我的一个问题，面试的时候被问到一个让人特别手足无措的问题：你的系统如何支撑高并发？</p><p>大多数同学被问到这个问题压根儿没什么思路去回答，不知道从什么地方说起，其实本质就是没经历过一些真正有高并发系统的锤炼罢了。</p><p>因为没有过相关的项目经历，所以就没法从真实的自身体会和经验中提炼出一套回答，然后系统的阐述出来自己复杂过的系统如何支撑高并发的。</p><p>所以，这篇文章就从这个角度切入来简单说说这个问题，用一个最简单的思路来回答，大致如何应对。</p><p>当然这里首先说清楚一个前提：高并发系统各不相同。比如每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统。</p><p>他们在应对高并发的时候，因为系统各自自身特点的不同，所以应对架构都是不一样的。</p><p>另外，比如电商平台中的订单系统、商品系统、库存系统，在高并发场景下的架构设计也是不同的，因为背后的业务场景什么的都不一样。</p><p>所以，这篇文章主要是给大家提供一个回答这类问题的思路，不涉及任何复杂架构设计，让你不至于在面试中被问到这个问题时，跟面试官大眼瞪小眼。</p><p>具体要真能在面试的时候回答好这个问题，建议各位参考一下本文思路，然后对你自己手头负责的系统多去思考一下，最好做一些相关的架构实践。</p><p><b>（2）先考虑一个最简单的系统架构</b></p><p>假设刚刚开始你的系统就部署在一台机器上，背后就连接了一台数据库，数据库部署在一台服务器上。</p><p>我们甚至可以再现实点，给个例子，你的系统部署的机器是4核8G，数据库服务器是16核32G。</p><p>此时假设你的系统用户量总共就10万，用户量很少，日活用户按照不同系统的场景有区别，我们取一个较为客观的比例，10%吧，每天活跃的用户就1万。</p><p>按照28法则，每天高峰期算他4个小时，高峰期活跃的用户占比达到80%，就是8000人活跃在4小时内。</p><p>然后每个人对你的系统发起的请求，我们算他每天是20次吧。那么高峰期8000人发起的请求也才16万次，平均到4小时内的每秒（14400秒），每秒也就10次请求。</p><p>好吧！完全跟高并发搭不上边，对不对？</p><p>然后系统层面每秒是10次请求，对数据库的调用每次请求都会好几次数据库操作的，比如做做crud之类的。</p><p>那么我们取一个一次请求对应3次数据库请求吧，那这样的话，数据库层每秒也就30次请求，对不对？</p><p>按照这台数据库服务器的配置，支撑是绝对没问题的。</p><p>上述描述的系统，用一张图表示，就是下面这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-51644242812b6fea6606a01660c405fc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"435\" class=\"content_image\" width=\"180\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;180&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"180\" data-rawheight=\"435\" class=\"content_image lazy\" width=\"180\" data-actualsrc=\"https://pic1.zhimg.com/v2-51644242812b6fea6606a01660c405fc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（3）系统集群化部署</b></p><p>假设此时你的用户数开始快速增长，比如注册用户量增长了50倍，上升到了500万。</p><p>此时日活用户是50万，高峰期对系统每秒请求是500/s。然后对数据库的每秒请求数量是1500/s，这个时候会怎么样呢？</p><p>按照上述的机器配置来说，如果你的系统内处理的是较为复杂的一些业务逻辑，是那种重业务逻辑的系统的话，是比较耗费CPU的。</p><p>此时，4核8G的机器每秒请求达到500/s的时候，很可能你会发现你的机器CPU负载较高了。</p><p>然后数据库层面，以上述的配置而言，其实基本上1500/s的高峰请求压力的话，还算可以接受。</p><p>这个主要是要观察数据库所在机器的磁盘负载、网络负载、CPU负载、内存负载，按照我们的线上经验而言，那个配置的数据库在1500/s请求压力下是没问题的。</p><p>所以此时你需要做的一个事情，首先就是要支持你的系统集群化部署。</p><p>你可以在前面挂一个负载均衡层，把请求均匀打到系统层面，让系统可以用多台机器集群化支撑更高的并发压力。</p><p>比如说这里假设给系统增加部署一台机器，那么每台机器就只有250/s的请求了。</p><p>这样一来，两台机器的CPU负载都会明显降低，这个初步的“高并发”不就先cover住了吗？</p><p>要是连这个都不做，那单台机器负载越来越高的时候，极端情况下是可能出现机器上部署的系统无法有足够的资源响应请求了，然后出现请求卡死，甚至系统宕机之类的问题。</p><p>所以，简单小结，第一步要做的：</p><p>添加负载均衡层，将请求均匀打到系统层。 系统层采用集群化部署多台机器，扛住初步的并发压力。</p><p>此时的架构图变成下面的样子：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7c4167bcd5775cc1c75ed11aec979ba5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"558\" class=\"content_image\" width=\"407\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;407&#39; height=&#39;558&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"407\" data-rawheight=\"558\" class=\"content_image lazy\" width=\"407\" data-actualsrc=\"https://pic2.zhimg.com/v2-7c4167bcd5775cc1c75ed11aec979ba5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（4）数据库分库分表 + 读写分离</b></p><p>假设此时用户量继续增长，达到了1000万注册用户，然后每天日活用户是100万。</p><p>那么此时对系统层面的请求量会达到每秒1000/s，系统层面，你可以继续通过集群化的方式来扩容，反正前面的负载均衡层会均匀分散流量过去的。</p><p>但是，这时数据库层面接受的请求量会达到3000/s，这个就有点问题了。</p><p>此时数据库层面的并发请求翻了一倍，你一定会发现线上的数据库负载越来越高。</p><p>每次到了高峰期，磁盘IO、网络IO、内存消耗、CPU负载的压力都会很高，大家很担心数据库服务器能否抗住。</p><p>没错，一般来说，对那种普通配置的线上数据库，建议就是读写并发加起来，按照上述我们举例的那个配置，不要超过3000/s。</p><p>因为数据库压力过大，首先一个问题就是高峰期系统性能可能会降低，因为数据库负载过高对性能会有影响。</p><p>另外一个，压力过大把你的数据库给搞挂了怎么办？</p><p>所以此时你必须得对系统做分库分表 + 读写分离，也就是把一个库拆分为多个库，部署在多个数据库服务上，这是作为主库承载写入请求的。</p><p>然后每个主库都挂载至少一个从库，由从库来承载读请求。</p><p>此时假设对数据库层面的读写并发是3000/s，其中写并发占到了1000/s，读并发占到了2000/s。</p><p>那么一旦分库分表之后，采用两台数据库服务器上部署主库来支撑写请求，每台服务器承载的写并发就是500/s。每台主库挂载一个服务器部署从库，那么2个从库每个从库支撑的读并发就是1000/s。</p><p>简单总结，并发量继续增长时，我们就需要focus在数据库层面：分库分表、读写分离。</p><p>此时的架构图如下所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-acaa6d10e5afc523f067cf39377a9c0e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-acaa6d10e5afc523f067cf39377a9c0e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;594&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"594\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic3.zhimg.com/v2-acaa6d10e5afc523f067cf39377a9c0e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-acaa6d10e5afc523f067cf39377a9c0e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（5）缓存集群引入</b></p><p>接着就好办了，如果你的注册用户量越来越大，此时你可以不停的加机器，比如说系统层面不停加机器，就可以承载更高的并发请求。</p><p>然后数据库层面如果写入并发越来越高，就扩容加数据库服务器，通过分库分表是可以支持扩容机器的，如果数据库层面的读并发越来越高，就扩容加更多的从库。</p><p>但是这里有一个很大的问题：数据库其实本身不是用来承载高并发请求的，所以通常来说，数据库单机每秒承载的并发就在几千的数量级，而且数据库使用的机器都是比较高配置，比较昂贵的机器，成本很高。</p><p>如果你就是简单的不停的加机器，其实是不对的。</p><p>所以在高并发架构里通常都有缓存这个环节，缓存系统的设计就是为了承载高并发而生。</p><p>所以单机承载的并发量都在每秒几万，甚至每秒数十万，对高并发的承载能力比数据库系统要高出一到两个数量级。</p><p>所以你完全可以根据系统的业务特性，对那种写少读多的请求，引入缓存集群。</p><p>具体来说，就是在写数据库的时候同时写一份数据到缓存集群里，然后用缓存集群来承载大部分的读请求。</p><p>这样的话，通过缓存集群，就可以用更少的机器资源承载更高的并发。</p><p>比如说上面那个图里，读请求目前是每秒2000/s，两个从库各自抗了1000/s读请求，但是其中可能每秒1800次的读请求都是可以直接读缓存里的不怎么变化的数据的。</p><p>那么此时你一旦引入缓存集群，就可以抗下来这1800/s读请求，落到数据库层面的读请求就200/s。</p><p>同样，给大家来一张架构图，一起来感受一下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b48f3902f375b2fd8a7192a97d8c1920_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"683\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-b48f3902f375b2fd8a7192a97d8c1920_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;683&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"683\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic1.zhimg.com/v2-b48f3902f375b2fd8a7192a97d8c1920_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b48f3902f375b2fd8a7192a97d8c1920_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>按照上述架构，他的好处是什么呢？</p><p>可能未来你的系统读请求每秒都几万次了，但是可能80%~90%都是通过缓存集群来读的，而缓存集群里的机器可能单机每秒都可以支撑几万读请求，所以耗费机器资源很少，可能就两三台机器就够了。</p><p>你要是换成是数据库来试一下，可能就要不停的加从库到10台、20台机器才能抗住每秒几万的读并发，那个成本是极高的。</p><p>好了，我们再来简单小结，承载高并发需要考虑的第三个点：</p><p>不要盲目进行数据库扩容，数据库服务器成本昂贵，且本身就不是用来承载高并发的 针对写少读多的请求，引入缓存集群，用缓存集群抗住大量的读请求</p><p><b>（6）引入消息中间件集群</b></p><p>接着再来看看数据库写这块的压力，其实是跟读类似的。</p><p>假如说你所有写请求全部都落地数据库的主库层，当然是没问题的，但是写压力要是越来越大了呢？</p><p>比如每秒要写几万条数据，此时难道也是不停的给主库加机器吗？</p><p>可以当然也可以，但是同理，你耗费的机器资源是很大的，这个就是数据库系统的特点所决定的。</p><p>相同的资源下，数据库系统太重太复杂，所以并发承载能力就在几千/s的量级，所以此时你需要引入别的一些技术。</p><p>比如说消息中间件技术，也就是MQ集群，他是非常好的做写请求异步化处理，实现削峰填谷的效果。</p><p>假如说，你现在每秒是1000/s次写请求，其中比如500次请求是必须请求过来立马写入数据库中的，但是另外500次写请求是可以允许异步化等待个几十秒，甚至几分钟后才落入数据库内的。</p><p>那么此时你完全可以引入消息中间件集群，把允许异步化的每秒500次请求写入MQ，然后基于MQ做一个削峰填谷。比如就以平稳的100/s的速度消费出来然后落入数据库中即可，此时就会大幅度降低数据库的写入压力。</p><p>ps：关于MQ削峰填谷的概念，在公众号之前讲消息中间件的文章中已详细阐述，如果大伙儿忘记了，可以回顾一下。</p><p>此时，架构图变成了下面这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-beb83a1f189404f90b013f6368ca555f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb\" width=\"550\" data-original=\"https://pic4.zhimg.com/v2-beb83a1f189404f90b013f6368ca555f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;550&#39; height=&#39;538&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"550\" data-rawheight=\"538\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"550\" data-original=\"https://pic4.zhimg.com/v2-beb83a1f189404f90b013f6368ca555f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-beb83a1f189404f90b013f6368ca555f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>大家看上面的架构图，首先消息中间件系统本身也是为高并发而生，所以通常单机都是支撑几万甚至十万级的并发请求的。</p><p>所以，他本身也跟缓存系统一样，可以用很少的资源支撑很高的并发请求，用他来支撑部分允许异步化的高并发写入是没问题的，比使用数据库直接支撑那部分高并发请求要减少很多的机器使用量。</p><p>而且经过消息中间件的削峰填谷之后，比如就用稳定的100/s的速度写数据库，那么数据库层面接收的写请求压力，不就成了500/s + 100/s = 600/s了么？</p><p>大家看看，是不是发现减轻了数据库的压力？</p><p>到目前为止，通过下面的手段，我们已经可以让系统架构尽可能用最小的机器资源抗住了最大的请求压力，减轻了数据库的负担。</p><p>系统集群化 数据库层面的分库分表+读写分离 针对读多写少的请求，引入缓存集群 针对高写入的压力，引入消息中间件集群，</p><p>初步来说，简单的一个高并发系统的阐述是说完了。</p><p>但是，其实故事到这里还远远没有结束。</p><p><b>（7）现在能hold住高并发面试题了吗？</b></p><p>看完了这篇文章，你觉得自己能回答好面试里的高并发问题了吗？</p><p>很遗憾，答案是不能。而且我觉得单单凭借几篇文章是绝对不可能真的让你完全回答好这个问题的，这里有很多原因在里面。</p><p>首先，高并发这个话题本身是非常复杂的，远远不是一些文章可以说的清楚的，他的本质就在于，真实的支撑复杂业务场景的高并发系统架构其实是非常复杂的。</p><p>比如说每秒百万并发的中间件系统、每日百亿请求的网关系统、瞬时每秒几十万请求的秒杀大促系统、支撑几亿用户的大规模高并发电商平台架构，等等。</p><p>为了支撑高并发请求，在系统架构的设计时，会结合具体的业务场景和特点，设计出各种复杂的架构，这需要大量底层技术支撑，需要精妙的架构和机制设计的能力。</p><p>最终，各种复杂系统呈现出来的架构复杂度会远远超出大部分没接触过的同学的想象。</p><p>如果大家想要看一下有一定发复杂度的系统的架构设计和演进过程，可以看一下之前写的一个系列专栏 <b><i>《亿级流量系统架构演进》</i></b> 。</p><p>但是那么复杂的系统架构，通过一些文章是很难说的清楚里面的各种细节以及落地生产的过程的。</p><p>其次，高并发这话题本身包含的内容也远远不止本文说的这么几个topic：分库分表、缓存、消息。</p><p>一个完整而复杂的高并发系统架构中，一定会包含各种复杂的自研基础架构系统、各种精妙的架构设计（比如热点缓存架构设计、多优先级高吞吐MQ架构设计、系统全链路并发性能优化设计，等等）、还有各种复杂系统组合而成的高并发架构整体技术方案、还有NoSQL（Elasticsearch等）/负载均衡/Web服务器等相关技术。</p><p>所以大家切记要对技术保持敬畏之心，这些东西都很难通过一些文章来表述清楚。</p><p>最后，真正在生产落地的时候，高并发场景下你的系统会出现大量的技术问题。</p><p>比如说消息中间件吞吐量上不去需要优化、磁盘写压力过大性能太差、内存消耗过大容易撑爆、分库分表中间件不知道为什么丢了数据，等等吧。</p><p>诸如此类的问题非常多，这些也不可能通过文章给全部说清楚。</p><p><b>（8）本文能带给你什么启发？</b></p><p>其实本文的定位，就是对高并发这个面试topic做一个扫盲，因为我发现大部分来问我这个问题的同学，连本文阐述的最最基本的高并发架构演进思路可能都没理解。</p><p>当然，也是因为毕竟没真的做过高并发系统，没相关经验，确实很难理解好这个问题。</p><p>所以本文就是让很多没接触过的同学有一个初步的感知，这个高并发到底是怎么回事儿，到底对系统哪里有压力，要在系统架构里引入什么东西，才可以比较好的支撑住较高的并发压力。</p><p>而且你可以顺着本文的思路继续思考下去，结合你自己熟悉和知道的一些技术继续思考。</p><p>比如说，你熟悉Elasticsearch技术，那么你就可以思考，唉？在高并发的架构之下，是不是可以通过分布式架构的ES技术支撑高并发的搜索？</p><p>上面所说，权当抛砖引玉。大家自己平时一定要多思考，自己多画图，盘点盘点自己手头系统的请求压力。计算一下分散到各个中间件层面的请求压力，到底应该如何利用最少的机器资源最好的支撑更高的并发请求。</p><p>这才是一个好的高并发架构设计思路。</p><p>如果起到这个效果，本文就成功了。剩下的，还是建议各位同学，对高并发这个话题，结合自己手头负责的系统多做思考。</p><p>比如当前业务场景下，你的系统有多大的请求压力？如果请求压力增长10倍你的架构如何支撑？如果请求压力增长100倍，你的架构如何支撑？如果请求压力增长1000倍，你的架构如何支撑？</p><p>平时一定多给自己设置一些技术挑战，敦促自己去思考自己的系统，最好多做写架构上的演练、落地和实践，自己实际操作一下，才有更好的感知。</p><p>然后在面试的时候，起码自己做过一定深度的思考，结合自己负责的系统做过一些实践，可以跟面试官有一个较为清晰和系统的阐述。</p><p>虽然大部分同学可能没机会经历那种真正大规模超高并发的系统架构的设计，但是本文如果能让大家平时对自己的项目多一些思考。在面试的时候，有一些系统性的思路和阐述，那么也就达到本文的目的了。</p>", 
            "topic": [
                {
                    "tag": "程序员面试", 
                    "tagLink": "https://api.zhihu.com/topics/19579066"
                }, 
                {
                    "tag": "高并发", 
                    "tagLink": "https://api.zhihu.com/topics/19596218"
                }, 
                {
                    "tag": "系统", 
                    "tagLink": "https://api.zhihu.com/topics/19560883"
                }
            ], 
            "comments": [
                {
                    "userName": "鱼香肉丝盖饭", 
                    "userLink": "https://www.zhihu.com/people/56b2390d9748143484b4b92c06668f74", 
                    "content": "谢谢。", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "15196638082", 
                    "userLink": "https://www.zhihu.com/people/02167c053005953b902b5de9bffe9e40", 
                    "content": "很好👍", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "是不我与", 
                    "userLink": "https://www.zhihu.com/people/19d49a10a622029da6382644c4ce3edb", 
                    "content": "<p>谢谢</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57247258", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 5, 
            "title": "大数据如此火爆 如何看待大数据行业发展趋势", 
            "content": "<h2>如今的大数据不再是一个流行术语，在大数据行业火热的发展下，大数据几乎涉及到所有行业的发展。国家相继出台的一系列政策更是加快了大数据产业的落地，预计未来几年大数据产业将会蓬勃发展。下面一起看看未来大数据行业发展趋势有哪些?<br/></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6307e5960f8033b4b500aa83e9e8f574_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-6307e5960f8033b4b500aa83e9e8f574_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;500&#39; height=&#39;303&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"500\" data-rawheight=\"303\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"500\" data-original=\"https://pic1.zhimg.com/v2-6307e5960f8033b4b500aa83e9e8f574_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6307e5960f8033b4b500aa83e9e8f574_b.jpg\"/></figure><p><br/>　　未来大数据产业发展的趋势之一：与云计算、人工智能等前沿创新技术深度融合。大数据、云计算、人工智能等前沿技术的产生和发展均来自社会生产方式的进步和信息技术产业的发展。而前沿技术的彼此融合将能实现超大规模计算、智能化自动化和海量数据的分析，在短时间内完成复杂度较高、精密度较高的信息处理。比如阿里巴巴的电子商务交易平台能在双 11 当天完成每秒钟 17.5 万笔订单交易和每秒钟 12 万笔的订单支付，主要归功于融合了云计算和大数据的“飞天平台”。百度大脑也结合了云计算、大数据、人工智能等多种技术，配合实现强大性能。<br/>　　未来大数据行业发展趋势之二：针对制造业的大数据解决方案不断升级，助力智能制造。制造业产品的全生命周期从市场规划、设计、制造、销售、维护等过程都会产生大量的结构化和非结构化数据，形成了制造业大数据。除此以外，制造业大数据还具多源异构、多尺度、不确定、高噪声等特征。在《智能制造发展规划 2016-2020》中，明确提出 2025 年前，推进智能制造实施“两步走”战略：“第一步，到 2020 年，智能制造发展基础和支撑能力明显增强，传统制造业重点领域基本实现数字化制造，有条件、有基础的重点产业智能转型取得明显进展;第二步，到 2025 年，智能制造支撑体系基本建立，重点产业初步实现智能转型” 。而在大数据细分市场中行业解决方案占比最高达 34.3%，将在智能制造产业发展中起到重要作用。<br/>　　未来大数据产业前景一片大好，如果你也想加入大数据行业，可以进行专业系统的学习，还可以查看最新的大数据学习路线，做到心中有数，还有大量的免费大数据学习资料帮助学员快速入门。大数据指不用随机分析法这样捷径，而采用所有数据进行分析处理的方法。互联网时代每个企业每天都要产生庞大的数据，对数据进行储存，对有效的数据进行挖掘分析并应用需要依赖于大数据开发.<br/>互联网科技发展蓬勃兴起，人工智能时代来临，抓住下一个风口。为帮助那些往想互联网方向转行想学习，却因为时间不够，资源不足而放弃的人。我自己整理的一份最新的大数据进阶资料和高级开发教程，大数据学习群：714加上【526】最后加上711就可以找到组织学习  欢迎进阶中和进想深入大数据的小伙伴加入。</p>", 
            "topic": [
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57569549", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 9, 
            "title": "MySQL数据库切分架构实践 - 用户中心", 
            "content": "<p>在实际的互联网项目中，往往数据量到了一定的量级，就必须进行分库分表。那么究竟如何分库分表才是合理的。本文将结合实际的应用场景进行分析。</p><h2>应用场景：用户中心数据库切分架构实践</h2><p>用户中心是作为一个常见的业务系统，包含注册、登录、用户信息查询基础服务。</p><p>用户的核心元数据为：</p><p><b>User(uid,mobile,nickname,password)</b></p><p>在业务初期，往往单库就能满足需求：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7f6203d6b8849f6d706eaeba1ae58483_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7f6203d6b8849f6d706eaeba1ae58483_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;356&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"356\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-7f6203d6b8849f6d706eaeba1ae58483_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7f6203d6b8849f6d706eaeba1ae58483_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当数据量越来越大时，需要对数据库进行水平切分。</p><p>切分的方式通常有两种：range和hash。</p><p>我们通常采取<b>哈希取模</b>的方式进行切分，以用户中心的业务uid为划分依据，将数据水平切分到n个数据库实例上去：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1495719952bfa2081036ef56e4be9cd0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"511\" data-original=\"https://pic1.zhimg.com/v2-1495719952bfa2081036ef56e4be9cd0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;511&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"511\" data-original=\"https://pic1.zhimg.com/v2-1495719952bfa2081036ef56e4be9cd0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1495719952bfa2081036ef56e4be9cd0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>哈希取模的优点：</b></p><p><b>1.</b> 切分方式简单，能够快速定位到数据存放在拿个数据库中；</p><p><b>2.</b> 数据量均衡：数据在各个库上的均衡分布，能极大提升整体查询效率</p><p><b>哈希取模的不足：</b></p><p>扩容时需要进行部分数据迁移，所以最好一开始就预估好数据量。</p><h2>问题一：如何hash能最大程度减少扩容时需要迁移的数据库数量？</h2><p>这个问题比较简单，留给读者思考。</p><h2>问题二：假如要根据nickname进行查询数据，这个时候应该怎么办？</h2><p>针对这个问题，较为常见的有两种解决方案。</p><p><b>方案一：</b>建立nickname至uid反向索引表</p><p><b>不足之处：</b>增加存储空间，同时需要多出一次查询。</p><p><b>方案二：</b>将nickname作为因子融入uid中。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-811142092d2af6c69c30624ec8a79149_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"591\" data-original=\"https://pic2.zhimg.com/v2-811142092d2af6c69c30624ec8a79149_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;591&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"591\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"591\" data-original=\"https://pic2.zhimg.com/v2-811142092d2af6c69c30624ec8a79149_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-811142092d2af6c69c30624ec8a79149_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>具体做法：</b></p><p><b>1.</b> 在用户注册时，设计函数gene=f(nickname)</p><p><b>2.</b> 生成60位的全局唯一id，作为用户的标识</p><p><b>3.</b> 把4位的gene也作为uid的一部分</p><p><b>4.</b> 生成64位的uid，由id和gene拼装而成，利用gene分库插入数据</p><p><b>5.</b> 用nickname来访问时，先通过f(nickname)再次复原gene</p><h2>问题三：运营侧复杂的数据查询怎么解决？</h2><p>通常我们的做法是写入数据时同步一份数据供运营后台单独使用，独立部署MySQL实例，尽量不进行分库分表，以满足复杂的数据查询需求。</p>", 
            "topic": [
                {
                    "tag": "MySQL", 
                    "tagLink": "https://api.zhihu.com/topics/19554128"
                }, 
                {
                    "tag": "架构", 
                    "tagLink": "https://api.zhihu.com/topics/19556226"
                }, 
                {
                    "tag": "以用户为中心的设计", 
                    "tagLink": "https://api.zhihu.com/topics/19554821"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57570239", 
            "userName": "于斯", 
            "userLink": "https://www.zhihu.com/people/ac2b90a216470cd7cc3d927699aadf2b", 
            "upvote": 6, 
            "title": "优秀Java程序员应该知道的20个实用开源库", 
            "content": "<p>一个优秀且经验丰富的Java开发人员的特点之一是对API的广泛了解，包括JDK和第三方库。我花了很多时间学习API，特别是在阅读<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Faax-us-east.amazon-adsystem.com%252Fx%252Fc%252FQiEVOnoAPbRiw8pQE27SyOsAAAFhfgAmrwEAAAFKATAIA8Q%252Fhttps%253A%252F%252Fassoc-redirect.amazon.com%252Fg%252Fr%252Fhttps%253A%252F%252Fwww.amazon.com%252FEffective-Java-3rd-Joshua-Bloch%252Fdp%252F0134685997%252Fref%253Das_at%253FcreativeASIN%253D0134685997%2526linkCode%253Dw61%2526imprToken%253DL23Xt39kqcM1CoKVaUWJ5Q%2526slotNum%253D0%2526tag%253Djavamysqlanta-20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Effective Java 3rd Edition之后</a>，Joshua Bloch建议如何使用现有的API进行开发，而不是为常用的东西写新的代码。</p><p>在本文中，我将分享一些Java开发人员应该熟悉的最有用和最重要的库和API。但是，我没有包含框架，例如<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2017%252F11%252Ftop-5-free-core-spring-mvc-courses-learn-online.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Spring</a>和<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2016%252F12%252Ftop-5-spring-and-hibernate-training-courses-java-jee-programmers.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hibernate</a>，因为它们非常有名且具有特定功能。</p><p>总的来说，我在日常项目包含了有用的库，包括Log4j日志库，Jackson JSON解析库，以及JUnit和Mockito等单元测试API。如果需要在项目中使用，则在项目的classpath包含这些JAR，也可以使用<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2017%252F06%252F10-maven-tips-java-developer-should-know.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Maven</a>进行依赖管理。</p><p>当你使用Maven进行依赖管理时，它会自动下载这些库，包括它们所依赖的库，称为传递依赖。</p><p>例如，如果你下载Spring Framework，它还将下载Spring所依赖的所有其他JAR，例如Log4j。</p><p>你可能没注意到，但有正确版本的JAR是一个令人头疼的问题。如果是错误的JAR版本，那么你将遇到 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2012%252F12%252Fnoclassdeffounderror-vs-classnotfoundexception-java.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">ClassNotFoundException</a>， <a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz53N3GQp9l\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NoClassDefFoundError</a>或 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2015%252F08%252Fhow-to-solve-unsupported-majorminor-version-51-java.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">UnsupportedClassVersionError</a>。</p><p>这是我收集的一些有用的第三方库，Java开发可以使用它们在应用中来完成许多有用的功能。要使用这些库，Java开发人员应该熟悉它，这就是本文的重点。如果你觉得有用，你可以研究该库并使用它。</p><h2>1.日志库</h2><p>日志库非常常见，因为在每个项目中都需要它们。它们是服务器端应用最重要的东西，因为日志只放在可以看到应用程序当前运行时情况的地方。尽管JDK附带了自己的日志库，但还有更好的替代方案，例如Log4j，SLF4j和LogBack。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0885b85ebb9e9a9c5849e612d16ecb76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"214\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"214\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/v2-0885b85ebb9e9a9c5849e612d16ecb76_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Java开发人员应该熟悉日志库的优缺点，并且知道 <a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz53OYtIChK\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">为什么使用SLF4j比普通Log4j更好</a>。</p><h2>2. JSON解析库</h2><p>在当今的Web服务和物联网领域，JSON已成为将信息从客户端传送到服务器的首选协议。他们已经替换XML成为在独立平台间传输信息的最佳方式。</p><p>遗憾的是，JDK没有<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz5Bxv7wony\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSON库</a>。但是，有许多优秀的第三方库允许你解析和创建JSON消息，如Jackson和Gson。</p><p>Java Web开发人员应该熟悉这些库中的至少一个。如果你想了解有关Jackson和JSON的更多信息，我建议你看看 Udemy的课程<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Flearn-json-with-java-apis-jquery-and-rest%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSON with the Java API</a>。</p><h2>3.单元测试库</h2><p>单元测试是将普通开发人员与优秀开发人员区分开来的最重要的事情。程序员经常有理由不写单元测试，但逃避写单元测试的最常见的<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2017%252F01%252FTop-10-excuses-programmers-gives-to-avoid-unit-testing.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">借口</a>是缺乏常用单元测试库的经验和知识，包括JUnit，Mockito和PowerMock。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-990eeb68cdabbd5f13ba4e72dcbd22be_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"344\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"344\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/v2-990eeb68cdabbd5f13ba4e72dcbd22be_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我在2018年有一个目标就是提高我对单元测试和集成测试库的了解，比如JUnit 5，Cucumber，Robot框架和一些其他的。</p><p>我还在<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fjunitandmockitocrashcourse%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Udemy</a>注册了 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fjunitandmockitocrashcourse%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JUnit and Mockito Crash Course</a> 。即使你了解JUnit和单元测试的基础知识，可能也希望更新并进阶自己的知识。</p><h2>4.通用库</h2><p>Java开发人员可以使用几个很好的通用第三方库，比如Apache Commons和Google Guava。我总是在我的项目中包含这些库，因为它们简化了很多功能。</p><p>正如Joshua Bloch在<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Faax-us-east.amazon-adsystem.com%252Fx%252Fc%252FQiEVOnoAPbRiw8pQE27SyOsAAAFhfgAmrwEAAAFKATAIA8Q%252Fhttps%253A%252F%252Fassoc-redirect.amazon.com%252Fg%252Fr%252Fhttps%253A%252F%252Fwww.amazon.com%252FEffective-Java-3rd-Joshua-Bloch%252Fdp%252F0134685997%252Fref%253Das_at%253FcreativeASIN%253D0134685997%2526linkCode%253Dw61%2526imprToken%253DL23Xt39kqcM1CoKVaUWJ5Q%2526slotNum%253D1%2526tag%253Djavamysqlanta-20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Effective Java中</a>所说的那样，重复造轮子是没有意义的。我们应该更偏向于使用久经考验的库而不是时不时自己来实现。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-54c0ce4a2d51878bd4d0cb3e09027281_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"288\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;288&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"288\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic2.zhimg.com/v2-54c0ce4a2d51878bd4d0cb3e09027281_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对Java开发人员来说，熟悉Google Guava和Apache Commons库是件好事。</p><h2>5. HTTP库</h2><p>我不喜欢JDK的一点是他们对HTTP支持的缺乏。虽然你可以使用<a href=\"https://link.zhihu.com/?target=http%3A//java.net\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">java.net</span><span class=\"invisible\"></span></a>包中的类建立HTTP连接 ，但使用开源的第三方库（如Apache HttpClient和HttpCore）并不容易或不能无缝结合。</p><p>虽然JDK 9带来了HTTP 2.0的支持和更好的HTTP支持，但我强烈建议所有Java开发人员熟悉流行的HTTP客户端库，包括HttpClient和HttpCore。</p><p>你还可以查看此文章<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fwhats-new-in-java-9%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What&#39;s New in Java 9 - Modules and More</a>以了解有关JDK 9对HTTP 2支持的更多信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6283999a548d29e70c3d7be5b14fd557_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"343\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;343&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"343\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-6283999a548d29e70c3d7be5b14fd557_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>6. XML解析库</h2><p>有许多XML解析库，包括Xerces，JAXB，JAXP，Dom4j和Xstream。Xerces2是Apache Xerces下一高性能版本，完全兼容的XML解析器。这个新版本的Xerces引入了Xerces Native Interface（XNI），这是一个完整的框架，用于构建非常模块化且易于编程的解析器组件和配置。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3d90fbc2f7a387f7defe53fdcba44739_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"302\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"302\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic2.zhimg.com/v2-3d90fbc2f7a387f7defe53fdcba44739_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Apache Xerces2解析器是XNI的参考实现，但是其他解析器组件，配置和解析器可以使用Xerces Native Interface编写。Dom4j是另一个适用于Java应用程序的灵活XML框架。如果你想了解有关Java中XML解析的更多信息，建议你查看Udemy 上的 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fjava-web-services-and-xmloracle-exam-preparation%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java Web Services and XML</a> 在线课程。</p><h2>7. Excel库</h2><p>信不信由你 - 所有现实世界的应用程序都必须以某种形式与Microsoft Office进行交互。许多应用程序需要提供在Excel中导出数据的功能，如果必须从Java应用程序执行相同操作，则需要Apache POI API。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-869081907275b5bdaecaf0060425857f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"286\" data-rawheight=\"176\" class=\"content_image\" width=\"286\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;286&#39; height=&#39;176&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"286\" data-rawheight=\"176\" class=\"content_image lazy\" width=\"286\" data-actualsrc=\"https://pic4.zhimg.com/v2-869081907275b5bdaecaf0060425857f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这是一个非常丰富的库，允许你 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2014%252F09%252Fhow-to-read-write-xlsx-file-in-java-apache-poi-example.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从Java程序读取和写入XLS文件</a>。你可以看到该链接（<a href=\"https://link.zhihu.com/?target=http%3A//www.java67.com/2014/09/how-to-read-write-xlsx-file-in-java-apache-poi-example.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">java67.com/2014/09/how-</span><span class=\"invisible\">to-read-write-xlsx-file-in-java-apache-poi-example.html</span><span class=\"ellipsis\"></span></a>），以获取在核心Java应用程序中读取Excel文件的工作示例。</p><h2>8.字节码库</h2><p>如果你正在编写生成代码或与字节码交互的框架，那么你需要一个字节码库。</p><p>它们允许你读取和修改应用程序生成的字节码。Java世界中一些流行的字节码库是javassist和Cglib Nodep。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-28c9127f3cda338a0a765e3172c5a390_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"300\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;300&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"300\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic1.zhimg.com/v2-28c9127f3cda338a0a765e3172c5a390_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>Javassist（Java programming assistant）使Java字节码操作变得非常简单。它是一个用于在Java中编辑字节码的类库。ASM是另一个有用的字节码编辑库。如果你不熟悉字节码，我建议你查看<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fintroduction-to-java-programming%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Introduction to Java Programmers</a>以了解有关它的更多信息。</p><h2>9.数据库连接池库</h2><p>如果你正在从Java应用程序与数据库交互但不使用<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2012%252F06%252Fjdbc-database-connection-pool-in-spring.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库连接</a>池库，那么你将丢失一些内容。</p><p>由于在运行时创建数据库连接需要花费时间并使请求处理速度变慢，因此始终建议使用数据库连接库。一些流行的是Commons Pool和<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz4xXID0bk3\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DBCP</a>。</p><p>在Web应用程序中，它的Web服务器通常提供这些功能，但在核心Java应用程序中，你需要将这些连接池库包含在类路径中以使用数据库连接池。</p><p>如果你想了解有关JDBC和Web应用程序中的连接池的更多信息，我建议你查看Udemy 中的<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fclick.linksynergy.com%252Ffs-bin%252Fclick%253Fid%253DJVFxdTr9V80%2526subid%253D0%2526offerid%253D323058.1%2526type%253D10%2526tmpid%253D14538%2526RD_PARM1%253Dhttps%253A%252F%252Fwww.udemy.com%252Fjsp-tutorial%252F\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSP, Servlet, and JDBC for Beginners</a>课程。</p><h2>10.消息传递库</h2><p>与日志记录和数据库连接类似，消息传递也是许多现实世界Java应用程序的常见功能。</p><p>Java提供的<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz5Bxv7wony\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JMS</a>，Java Messaging Service不属于JDK。对于此组件，你需要包含一个单独的组件 jms.jar。</p><p>同样，如果你正在使用第三方消息传递协议（如Tibco RV），则需要使用第三方JAR tibrv.jar 放在应用程序<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2011%252F01%252Fhow-classpath-work-in-java.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">类路径中</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-16b5c1d0e8f01ce256d519db77ae78b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"344\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"344\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic1.zhimg.com/v2-16b5c1d0e8f01ce256d519db77ae78b4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>11. PDF库</h2><p>与Microsoft Excel类似，PDF库是另一种普遍存在的格式。如果你需要在应用程序中支持PDF功能，例如 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2014%252F05%252Fopen-source-java-PDF-File-libraries-Apache-FOP-vs-iText.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">导出数据到PDF文件</a>，则可以使用iText和Apache FOP库。</p><p>两者都提供有用的PDF相关功能，但iText更丰富，更好。请参阅<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttps%253A%252F%252Fwww.amazon.com%252FiText-Action-Covers-5%252Fdp%252F1935182617%253Ftag%253Djavamysqlanta-20\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">此处</a>以了解有关iText的更多信息。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-eec3a439098eddde4bcc5ed02ef92f36_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"253\" data-rawheight=\"199\" class=\"content_image\" width=\"253\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;253&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"253\" data-rawheight=\"199\" class=\"content_image lazy\" width=\"253\" data-actualsrc=\"https://pic3.zhimg.com/v2-eec3a439098eddde4bcc5ed02ef92f36_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>12.日期和时间库</h2><p>在Java 8之前，JDK的数据和时间库有很多缺陷，因为它们不是<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz5BxtJPSi9\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">线程安全的</a>，<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2018%252F02%252Fjava-9-example-factory-methods-for-collections-immutable-list-set-map.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">不可变的</a>，并且容易出错。许多Java开发人员依靠JodaTime来实现他们的日期和时间要求。</p><p>从JDK 8开始，没有理由使用Joda，因为你在JDK 8的<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2015%252F03%252F20-examples-of-date-and-time-api-from-Java8.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">新日期和时间API中</a>获得了所有功能，但如果你使用的是较旧的Java版本，那么JodaTime是一个值得学习的库。</p><p>如果你想了解有关新的日期和时间API的更多信息，我建议你查看Udemy上的<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fbit.ly%252F2qcj3uV\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">What&#39;s new in Java 8</a>课程。它提供了Java 8所有重要功能的精彩概述，包括日期和时间API。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-324c6d8ddf0919cc86336a63a3d94701_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-324c6d8ddf0919cc86336a63a3d94701_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;454&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"454\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-324c6d8ddf0919cc86336a63a3d94701_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-324c6d8ddf0919cc86336a63a3d94701_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>13.Collection库</h2><p>尽管JDK拥有丰富的集合库，但仍有一些第三方库提供了更多选项，例如Apache Commons集合，Goldman Sachs集合，Google集合和Trove。</p><p>Trove库特别有用，因为它为Java提供了高速的常规和原始集合。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3f8d2e73ec23758e8f831060c7b4edff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"283\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;283&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"283\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-3f8d2e73ec23758e8f831060c7b4edff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>FastUtil是另一个类似的API。它通过提供特定类型的映射，集合，列表和优先级队列来扩展Java集合框架，较小的内存占用，快速访问和插入; 它还提供大型（64位）<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2015%252F07%252Farray-concepts-interview-questions-answers-java.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数组</a>，<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz53n9YK0Mb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">集</a>和<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2015%252F07%252Fjava-arraylist-tutorial.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">列表</a>，以及用于二进制和文本文件快速实用的I / O类。</p><h2>14.Email API</h2><p>javax.mail和Apache Commons Email都提供了一个用于<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2014%252F08%252Fhow-to-send-email-from-java-program-example.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从Java发送电子邮件</a>的API 。它建立在JavaMail API的基础之上，旨在简化它。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-aa041dc32ebbfdc2b114f3b802a6ee2f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"166\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;166&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"166\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-aa041dc32ebbfdc2b114f3b802a6ee2f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>15. HTML解析库</h2><p>与<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz5BxtJPSi9\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSON</a>和<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2012%252F09%252Fdom-vs-sax-parser-in-java-xml-parsing.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XML</a>类似，HMTL是我们许多人必须处理的另一种常见格式。值得庆幸的是，我们有JSoup，它极大地简化了在Java应用程序中使用HTML的过程。</p><p>你不仅可以使用<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2014%252F09%252Fhow-to-parse-html-file-in-java-jsoup-example.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JSoup</a>解析HTML，还可以创建HTML文档</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0582ef60de892205d9213b86b5bfb2dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"284\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;284&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"284\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic1.zhimg.com/v2-0582ef60de892205d9213b86b5bfb2dc_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>它提供了一个非常方便的API，用于提取和操作数据，使用<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2011%252F12%252Fdifference-between-dom-and-sax-parsers.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DOM</a>，CSS和类似jquery的方法。JSoup实现了WHATWG HTML5规范，并将<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2018%252F02%252F5-free-html-and-css-courses-to-learn-web-development.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">HTML</a>解析到同一个DOM，就像现代浏览器一样。</p><h2>16.Cryptographic库</h2><p>Apache Commons Codec软件包包含各种格式的简单编码器和解码器，如<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2016%252F10%252Fbase64-encoding-example-in-java-8.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Base64</a>和Hexadecimal。</p><p>除了这些广泛使用的编码器和解码器之外，编解码器包还维护一组语音编码实用程序。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f91452cf1a51767540dffe8fa8f71feb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"219\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;219&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"219\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-f91452cf1a51767540dffe8fa8f71feb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>17.Embedded SQL Database库</h2><p>我真的很喜欢像H2这样的内存数据库，你可以将它嵌入你的Java应用程序中。它们非常适合测试SQL脚本和运行需要数据库的单元测试。但是，H2并不是唯一的DB，你也可以选择Apache Derby和HSQL。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-17fc1966812fd7eaacae66cdda9110e9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"202\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;202&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"202\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic2.zhimg.com/v2-17fc1966812fd7eaacae66cdda9110e9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>18. JDBC问题排查库</h2><p>存在一些很好的JDBC扩展库，可以使调试更容易，比如P6spy。</p><p>这是一个库，可以无缝地拦截和记录数据库数据，而无需对应用程序进行代码更改。你可以使用它们来记录SQL查询及其计时。</p><p>例如，如果你在代码中使用<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz53n9YK0Mb\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">PreparedStatment</a>和<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2013%252F01%252Fjdbc-batch-insert-and-update-example-java-prepared-statement.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CallableStatement</a>，则这些库可以记录一次完全调用的参数和执行所花费的时间。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-30fc1bd71d24a4bf2fb5a05f4b9f13cf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"253\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;253&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"253\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-30fc1bd71d24a4bf2fb5a05f4b9f13cf_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果你想了解有关JDBC的更多信息，可以查看<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fbit.ly%252F2Dbyl7J\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">JDBC for Beginners</a>。</p><h2>19.序列化库</h2><p>Google Protocol Buffers是一种以高效可扩展的格式编码结构化数据的方法。它是<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fjavarevisited.blogspot.sg%252F2016%252F09%252Fhow-to-serialize-object-in-java-serialization-example.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java序列化</a>的更丰富，更好的替代品。我强烈建议有经验的Java开发人员学习Google Protobuf。你可以查看此文章以了解有关<a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz4tUeeQOAU\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Google协议缓冲区的</a>更多信息 <a href=\"https://link.zhihu.com/?target=https%3A//www.toutiao.com/a6661355180732187139/%23axzz4tUeeQOAU\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">。</a></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-07e62ad3b3d7a1cd4de32643576dbecb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"242\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"242\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic4.zhimg.com/v2-07e62ad3b3d7a1cd4de32643576dbecb_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>20.网络库</h2><p>一些有用的网络库是Netty和Apache MINA。如果你正在编写需要执行底层网络任务的应用程序，请考虑使用这些库。如果你想了解有关Java网络编程的更多信息，请查看 <a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fbit.ly%252F2qrXsie\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java Network Programming - TCP/IP Socket Programming</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-03b17e95882f73f30316ea09843b4008_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-03b17e95882f73f30316ea09843b4008_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic1.zhimg.com/v2-03b17e95882f73f30316ea09843b4008_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-03b17e95882f73f30316ea09843b4008_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>这些就是对于每个Java开发人员都应该使用的</b>一些<b>有用的库</b>。Java的世界是浩瀚无穷的，你会发现数不胜数的库用于做不同的事情。</p><p>如果你想用Java做任何事情，很可能你会找到一个如何实现的库。与往常一样，Google是你找到有用的<a href=\"https://link.zhihu.com/?target=https%3A//link.juejin.im/%3Ftarget%3Dhttp%253A%252F%252Fwww.java67.com%252F2018%252F02%252Ftop-10-open-source-frameworks-and-libraries-java-web-developers.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Java库的</a>最好朋友，但你也可以查看Maven中央存储库，找到适合你手头任务的一些有用的库。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "开源", 
                    "tagLink": "https://api.zhihu.com/topics/19562746"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59189465", 
            "userName": "Kent Zhang", 
            "userLink": "https://www.zhihu.com/people/e9938ca9bde94442985575310e10869d", 
            "upvote": 8, 
            "title": "时间规划在OptaPlanner上的实现", 
            "content": "<p>　　在与诸位交流中，使用较多的生产计划和路线规划场景中，大家最为关注的焦点是关于时间的处理问题。确实，时间这一维度具有一定的特殊性。因为时间是一维的，体现为通过图形表示时，它仅可以通过一条有向直线来表达它的时刻和方向。相对而言，空间则可以存在多维，例如二维坐标，三维空间等，甚至在生产计划的规划场景中，各种资源可以表示为多个维度。因此，时间的一维特性，决定了在规划过程中，需要处理它的方法也具有一定的特殊性和局限性。本文将讨论通过OptaPlanner实现规划过程中，对于时间方面的处理方式。<br/>在众多规划优化场景中，可以归纳为两种情况的规划，分别是单一维的空间维度规划，和同时存在空间与时间两个维度进行规划。<br/>其中第一种情况，仅对一个维度进行规划的场景，我们可以把这一维归纳为，仅对空间维度的规划。例如八王后(N Qeen)问题，其规划的目标是为每个王后找个适当的位置，位置就是一个最为直观的空间概念，因此它是一个很明确直观的空间规划问题。而另外一些从直接字面意义上可能跟空间并没有直接的关系，但其实也可以将它视作仅有一个空间维度的规划。这类规划的一个特点规划目标与目标之间没有时序关系，即时间维度是不考虑的，例如。有一些存在时间概念的问题，其实也可以转化为唯一空间维度的规划，从而将问题简化。例如排班过程中，将每个人员安排到指定的班次，虽然班次是一个时间上概念的概念，但实际对这个问题进行排班设计的时候，我们可以将时间转化为类似空间的形式处理。更直观的说法，将班次分布在时间轴上，按时间轴来看，各个班次就是时间轴上不同位置的区间，从而令问题简化。因此，这类规则更严格地说，可以理解为无论是空间还是时间上的规划，都可以转化、展开为单一唯度的规划问题，通过使用空间规划的方法进行规划建模求解；即使是时间规划（例如排班）也不例外。<br/>　　另外一种规划，则需要同时考虑空间与时间两个维度协同规划。如生产计划、带时间窗口的车辆路线规划等问题，就是其中的典型。以生产计划为例，在空间维度，需要将一个任务分配到合理的机台，即是空间上的规划。然而，生产计划问题的另一个需求是，确定了机台后，还要确定到底这个任务应该在什么时候开始，什么时候结束；哪个任务需要在哪个任何完成后才能开始等等。这些时序逻辑相关的引出的问题，均属于时间规划问题。时间维度可以与空间维度一起，确定一个活动的时空坐标。此坐标是一个逻辑上抽象的概念。以生产计划为例，两个维度均通过平面图形来表示时，可以把计划中的每个任务，分配在指定机台的指定时间区间上，通过下图可以看到，这个示意图的水平轴（X轴）表示时间，从这个方向可以看出一个任务哪个时刻开始，持续多久，哪个时刻结束。以及与该任务同处于一个空间（机台，或产线，或车间）上的前后任务的接续关系。垂直轴（Y轴）表示空间，表示它被分配到哪个机台上执行。如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-18deee4cb455c13577679bda6a840ec2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-18deee4cb455c13577679bda6a840ec2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;936&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"936\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"936\" data-original=\"https://pic3.zhimg.com/v2-18deee4cb455c13577679bda6a840ec2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-18deee4cb455c13577679bda6a840ec2_b.jpg\"/></figure><p> 针对不同的时间规划要求，OptaPlanner提供了3常用的规划模式，分别是时间槽模式- Time Slot Pattern，时间粒模式 - Time Grain Pattern, 和时间链模式 - Chained Through Time Pattern.下面分别对这三种模式的特征，适用场景和使用方法进行详细介绍。因为翻译准确度原因（对自己的英文水平缺乏自信:P), 下文介绍中均直接使用Time Slot, Time Grain 和 Chained Through Time.以避免本文件的翻译不当造成误解。<br/> <br/><b>时间槽模式 - Time slot</b></p><p><br/>    Time Slot在应用时有一些适用条件,满足以下所有条件，才适用：</p><ol><li>规划实体中的规划变量是一个时间区间；</li><li>一个规划变量的取值最多仅可分配一个时间区间；</li><li>规划变量对应的时间区间是等长的。</li></ol><p> 　　对于规划值范围各个时间段，将其转换为空间上的概念更为直观。将时间用一个水平轴表示，在轴上划分大小固定的区间，这些区间则可以作为规划过程中的取值范围；在设计时，把这些区间定义成ValueRange。适用于Time slot模式情况，有制定中小学课程表、考试安排等问题。因为大学或公开课程的计划安排，除了排定时间外，可能还需要确定具体的地点，也就是空间维度的规划。此类问题通常需要将时间和空间分开来考虑，但其中的时间纬可以通过Time slot模式转化为与空间规划一样的问题，从而令问题简化。引用OptaPlanner开发手册的一张图可以清楚地看到，每一个规划实体只需要一个时间区间，且区间长短是相同的，(如下图）。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-016dc52e47c099b45b99580c53ebec1b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb\" width=\"762\" data-original=\"https://pic4.zhimg.com/v2-016dc52e47c099b45b99580c53ebec1b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;762&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"762\" data-rawheight=\"199\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"762\" data-original=\"https://pic4.zhimg.com/v2-016dc52e47c099b45b99580c53ebec1b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-016dc52e47c099b45b99580c53ebec1b_b.jpg\"/></figure><p>  　　从图中可以看出，每门课所需的时间都是固定一小时。具体到这个模式的应用,因为其原理、结构和实现起来都相当简单，本文不通过示例详细讲解了。可参考示例包中的Course timetabling中的设计和代码。</p><p><b>时间粒模式 - Time Grain</b></p><p> 在相当多运筹优化场景中，需要规划的时间长短是不固定的，不同的任务其所需的时间有长短之分。这种需求下，若使用Time slot模式就无法实现时间上的精确规划。那些就要使用更灵活，时间粒度更小的Time Grain模式。从Time Grain模式的名称中的Grain可以推测到，此模式是将时间细分成一个一个颗粒并应用于规划。例如可以设定为每1分钟，5分钟，30分钟，1小时等固定的长度，为一个Grain的长度。<br/>Time Grain模式适用条件：</p><ol><li>规划变量是时间区间；</li><li>业务上对应于规划变量的时间区间可以不等长，但必须是Grain的倍数。</li></ol><p> 　　例如通过Outlook的日历功能创建会议时，默认情况下每个会议的时间，是0.5小时的倍数，也就是一个会议至少是0.5小时，或者是1小时，或1.5小时如此类推。当然如果你不使用Outlook的默认时间精度，也可以将时间精度定到分钟，那么也就表示，会议的时间是1分钟的倍数。只不过针对人的日常活动在时间上的精度，以分钟作为精确度其意义不太大。就如9:01分开会跟9:00开会，对于人类的活动能力来说，正常情况下不存在任何区别。因为你从办公室去到会议室，都可能需要花费1分钟了；所以outlook里默认的是半小时。那么这个最小的时候单位 - 半小时，在Time Grain模式中，就被称为一个Time Grain，以下简称Grain。可以先从开发手册的图中看到Time Grain模式所表达的意义，如下图。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-20517a4e6fbae4b2fdd893e0abec6202_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-20517a4e6fbae4b2fdd893e0abec6202_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;765&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"203\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-20517a4e6fbae4b2fdd893e0abec6202_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-20517a4e6fbae4b2fdd893e0abec6202_b.jpg\"/></figure><p> 从上图可以看到，每个会议所需的时间长度是不相等的，但是其长度必然是一个Time Grain的倍数，从图中上方的时间刻度可以比划出一个TimeGrain应该是15分钟。例如Sales meeting占用了4个Time Grain，即时长1小时。Time Grain模式的使用会相对Time Slot更灵活，适用范围会更广。通过设置可知，其实适用于Time Slot模型的情形，是完全可以通过TimeGrain模式实现的，只是实现起来会更复杂一些。那么Time Grain模式的设计要点在哪里呢？要了解其设计原理，就得先掌握Time Grain的结构及其对时间的提供方法。<br/> Time Grain中的重点在于一个Grain的设计，与Time Slot中的slot一样，Time Grain中的Grain表示的也是一个时间区间，只不过它所表达的意义不仅在于一个Time Grain的时间区间内，每个Grain的序号也是关键因素，当一个Grain被分配到一个规划变量时，Grain的序号决定了它与时间轴的映射位置。在生产计划中，若一个Grain被分配到一个任务时，表示任务起止于这个Grain的开始时刻。 即该任务的开始时间是哪个Grain内对应的时间区间内，那么这个Grain的开始时间，就是这个任务的开始时间；通过这个任务的长度，推算出它需要占用多少个Grain, 进而推算出它的结束时间会在哪个Grain内，那么这个Grain的结束时间，即是这个任务的结束时间。<br/>还是以上图为例，其中的Sales meeting,它的起始是在grain0内，grain0的起始时间是8:00，那么这个会议的起始时间就是8:00。这个会议的长度是1小时，所以它占用了4个Grain,因此，第4个Grain的结束时间就是会议的结束时间，也就是图中Grain3的结束时间 - 9:00，是这个会议的结束时间。进一步分析也知，若这个会议时长是1:10, 那么它的结束时间将会落于gran4内（第5个grain), 那么它的结束时间就是grain4的结束时间 - 9:15. 因此，总结起来，我们在实现这个模式的时候有以下要点在设计时需要注意：</p><ol><li>设计好每个Grain的粒度，也就是时间长度。并不是粒度越细越好，例如以1秒钟作为一个粒度，是不是就可以将任务的时间精度控制在1级呢？理论上是可以的，但日常使用中不太可行。因为这样的设计会产生过量的Grain,Grain就是Value Range，当可选值的数量过多时，整个规划问题的规模就会增大，其时间复杂度就会指数级上升，从而令优化效果降低。</li><li>定义好每个Grain与绝对时间的映射关系。这个模式中的Time Grain其时间上是相对的。如何理解呢？就是说，这个模式在运行的时候，会把初始化出来的Grain对象列表，以Index（Grain的序号）为序形成一个连接的时间粒的序列。列表中每一个具体的Grain对应的绝对时间是什么时候呢？是以第一个Grain作为参照推算出来的。例如上图中的第一个Grain - grain0它的起始时间是8:00, 那么第6个grain - grain5的起始时间就是9:30，这个时间是通过grain0加上6个grain的时长推算出来的，也就是8:00加上1.5小时，因此得到的是9:30。因此，当你设定Time Grain与绝对时间的对应关系时，就需要从业务上考虑，grain0的起始是什么时刻；它决定了后续所有任务的时间。</li></ol><p>　　为了防止同一空间上，存两个任务时间重叠的问题，可以根据其分配的Grain进行判断。如示例Meeting scheduling中关于时间重叠的判断，可以参考MeetingAssignment类中的calculateOverlap方法，见以下代码。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">calculateOverlap</span><span class=\"o\">(</span><span class=\"n\">MeetingAssignment</span> <span class=\"n\">other</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n　　<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">startingTimeGrain</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"na\">getStartingTimeGrain</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n　　　　<span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n　　<span class=\"o\">}</span>\n\n　　<span class=\"kt\">int</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">startingTimeGrain</span><span class=\"o\">.</span><span class=\"na\">getGrainIndex</span><span class=\"o\">();</span>\n　　<span class=\"kt\">int</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">start</span> <span class=\"o\">+</span> <span class=\"n\">meeting</span><span class=\"o\">.</span><span class=\"na\">getDurationInGrains</span><span class=\"o\">();</span>\n　　<span class=\"kt\">int</span> <span class=\"n\">otherStart</span> <span class=\"o\">=</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"na\">startingTimeGrain</span><span class=\"o\">.</span><span class=\"na\">getGrainIndex</span><span class=\"o\">();</span>\n　　<span class=\"kt\">int</span> <span class=\"n\">otherEnd</span> <span class=\"o\">=</span> <span class=\"n\">otherStart</span> <span class=\"o\">+</span> <span class=\"n\">other</span><span class=\"o\">.</span><span class=\"na\">meeting</span><span class=\"o\">.</span><span class=\"na\">getDurationInGrains</span><span class=\"o\">();</span>\n \n　　<span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">end</span> <span class=\"o\">&lt;</span> <span class=\"n\">otherStart</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n　　　　<span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n　　<span class=\"o\">}</span> <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">otherEnd</span> <span class=\"o\">&lt;</span> <span class=\"n\">start</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n　　　　<span class=\"k\">return</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n　　<span class=\"o\">}</span>\n　　<span class=\"k\">return</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">min</span><span class=\"o\">(</span><span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">otherEnd</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">Math</span><span class=\"o\">.</span><span class=\"na\">max</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">otherStart</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n</code></pre></div><h2>  上述代码是判断两个会议的TIme Grain, 若存在重叠，则返回重叠量，供引擎的评分机制来判断各个solution的优劣。<br/> <br/><b>时间链模式 - Chained Through Time </b></h2><p> 前面提出的两种时间模式，其实有较多的相似之处，都是将时间段划分为单个个体，再将这些个体作为规划变量的取值范围，从而实现与空间规划一致的规划模式。但更复杂的场景下，将时间转化为“空间”的做法，未必能行得通。例如带时间窗口的路径规划，多工序多资源生产计划等问题，其时间维度是难以通过Time Slot或Time Grain模式实现的。我增尝试将Time Grain模式应用于多工序多资源条件下的生产计划规划；其原理上是可行的，但仍然会到到一些相当难解决的问题。其中之一就是Time Grain的粒度大小问题，若需要实现精确到分钟的计划，当编排一个时间跨度较大的计划时，就会引起问题规模过大的问题，从而论引擎效率骤降。另外就是实现相邻任务的重叠和先后次序判断时，会遇到一些难以解决的，问题需要花费较多的精力去处理。因此，OptaPlanner引入了第三种时间规划模式 - 时间链模式（同样是翻译问题，下称Chained Through Time模式)。<br/>Chained Through Time模式顾名思义就是应用了链状结构的特性，来实现时间的规划。它的设计思想是，规划变量并不是普通的时间或空间上的值, 而是另外一个规划实体；从而形成一个由各个首尾相接的规划实体链，即Value Range的范围就是规划实集合本身。通过规划实体间的链状关系，来推算各个实体的起止时间。事实上，OptaPlanner中将规划实体环环相扣形成链的特性，其主要目的并非为了实现时间规划，而是为了解类似TSP，VRP等问题而提供的。这些问题需要规划的，是各个节点之间形成的连通关系；在约定规则下，求解最佳连通方案。根据不同的场景要求，所求的目标有“最短路径”，“最小重复节点”，“最在连接效率”等。在时间规划的功能方面，其实现方式与上两种模式类似。以生产计划的例子来说，通过Chained Through Time模式获得各任务的连接关系与次序后，就可以根据链中首个任务的开始时间，结合各任务的持续时间，推算出各个任务精确的起止时间了，甚至可以精确到秒。所以此模式用于时间规划，只是它的一个“副业”，引擎使用Chained Through Time模式时，并不是直接对时间进行规划优化，而是在优化规划实体之间的连接关系；时间作为这个规划实体中的一个影子变量（Shadow variable）进行计算，最终通过评分机制对这个影子变量进行约束限制，从而得到时间优化的方案。与Time Slot和Time Grain相比，Chained Through Time最大的特性是通过次序来推导时间，而另外两种模式则是需要通过时间来反映任务之间的先后关系。<br/> 虽然Chained Through Time模式的作用相当巨大且广泛，但该模式的设计与实现难度又是三个模式中最高的，实现起来相对复杂。下面来进一步对其进行深入讨论。<br/> </p><p><b>Chained Through Time模式的意义</b></p><p>　　Chained Through Time模式通过对正在进行规划的所有规划实体建立链状关系，来实现时间推导，其推导结果示意图如下。从图中可以看到，分配给Ann有两个任务(FR taxes和SP taxes),其中第一个任务FR taxes的开始时刻是固定为本次计划的最早时间，而第二个任务SP taxes的开始时刻，则是根据第一个任务推导出来的 - 等于第一个任务的开始时刻加上其持续时间。因此，需要在约束的限制下，引擎过过各种约束分数的判断，生成一个相对最合理的实体连接方案，再在这个方案的基础上来推导时间，或将时间纳入作为约束条件，实现对连接方案的影响，从而实现了时间维度的规划优化。 <br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9d265e89a989e07007ad3ef3cfc6a027_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"767\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb\" width=\"767\" data-original=\"https://pic4.zhimg.com/v2-9d265e89a989e07007ad3ef3cfc6a027_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;767&#39; height=&#39;227&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"767\" data-rawheight=\"227\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"767\" data-original=\"https://pic4.zhimg.com/v2-9d265e89a989e07007ad3ef3cfc6a027_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9d265e89a989e07007ad3ef3cfc6a027_b.jpg\"/></figure><h2><b>Chained Through Time的内存模型</b></h2><p>　　规划实体形成的链是由引擎自动生成的，每生成的一个方案都是由各规划实体之间的相对位置变化而成的。在创建的这些规划实体构成的链中，它会遵循以下原则：</p><ol><li>一条链由一个Anchor(锚),和零或，或1个，或多个Entity(实体，其实就是规划实体)构成；</li><li>一条链必须有且仅有一个Anchor(锚）；</li><li>一条链中的Entity或Anchor之间是一对一的关系，不可出现合流或分流结构；</li><li>一条链中的Entity或Anchor不可出现循环。</li></ol><p>如下图 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-71267a17fd8880761505e7060f16b392_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-71267a17fd8880761505e7060f16b392_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic3.zhimg.com/v2-71267a17fd8880761505e7060f16b392_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-71267a17fd8880761505e7060f16b392_b.jpg\"/></figure><h2><b>Chained Through Time模式的设计实现</b></h2><p> 通过上面的链结构，我们了解到，一条链中将会存在两种对象，一种是Anchor, 一种是Entity.对么它们分别代表现实场景中的什么业务实体呢？其实Entity是其常容易理解，如果是生产计划案例中，它代表的是每个任务；在车辆路线规划案例中，它代表的是每个车辆需要途径的派件/揽件客户。而Anchor则表未任务所在的机台，及各个投/揽方案中的每一车辆。因此，这两种不同的对象，在内容中会形成依赖关系，即一个Entity的前一步可以是另外一个Entiy, 也可以是一个Anchor。以生产计划的业务场景来描述，则表示一个任务的前一个任务，可以是另外一个任务(Entity)，也可以是一个机台(Anchor,当这个任务是这个机台的首个任务时）。因此，在我们设计它的时候需要把这两种不同的业务实体抽象为同一类才有办法实现它们之间的依赖,事实上这种抽象关系，在面向对象的原则，在业务意义上来说，是不成立的，仅仅是为了满足它们形成同一链的要求才作出的计划。如下是一个任务与机台的类设计图。可以看到，我从Taskg与Machine抽象了一个父类Step（这是我想到的最合适类名了）,那么每一个任务的前一个Step有可能是另外一个任务，也有可能是一个机台。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-512a21f89b9f9c749f97e869ac19c7ea_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"357\" data-rawheight=\"283\" class=\"content_image\" width=\"357\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;357&#39; height=&#39;283&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"357\" data-rawheight=\"283\" class=\"content_image lazy\" width=\"357\" data-actualsrc=\"https://pic3.zhimg.com/v2-512a21f89b9f9c749f97e869ac19c7ea_b.jpg\"/></figure><h2><b>时间推算方法</b></h2><p><br/>　　Chained Through Time模式与其两种时间规划模式不同，本质上它并不对时间进行规划，只对实体之间的关系进行规划优化。因此，在引擎每一个原子操作中需要通过对VariableListener接口的实现，来对时间进行推算，并在完成推算后，由引擎通过评分机制进行约束评分。一个Move有可能对应多个原子操作，一个Move的操作种类，可以参见开发 手册中关于<a href=\"https://link.zhihu.com/?target=https%3A//docs.optaplanner.org/7.18.0.Final/optaplanner-docs/html_single/index.html%23whatIsAMoveSelector\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Move Selector</a>一章，在以后对引擎行为进行深入分析的文章中，我将会写一篇关于Move Seletor的文件，来揭示引擎的运行原理。在需要进行时间推算时，可以通过实现接口的afterVariableChanged方法，对当前所处理的规划实体的时间进行更新。因为Chained Through Timea模式下，所有已初始化的规划实体都处在一条链上；因此，当一个规划实体的时间被更新后，跟随着它的后一个规划实体的时间也需要被更新，如此类推，直到链上最后一个实体，或出现一个时间正好不需要更新的规划实体，即该规划实体前面的所有实体的时间出现更新后，其时间不用变化，那么链上从它往后的规划实体的时候也无需更新。<br/>　　以下是VariableListener接口的afterVariableChanged及其处理方法。 </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 实现VariableListener的类\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">StartTimeUpdatingVariableListener</span> <span class=\"kd\">implements</span> <span class=\"n\">VariableListener</span><span class=\"o\">&lt;</span><span class=\"n\">Task</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\n    <span class=\"c1\">// 实现afterVariableChanged方法\n</span><span class=\"c1\"></span>    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">afterVariableChanged</span><span class=\"o\">(</span><span class=\"n\">ScoreDirector</span> <span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">Task</span> <span class=\"n\">task</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">updateStartTime</span><span class=\"o\">(</span><span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">beforeEntityAdded</span><span class=\"o\">(</span><span class=\"n\">ScoreDirector</span> <span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">Task</span> <span class=\"n\">task</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// Do nothing\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"nd\">@Override</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">afterEntityAdded</span><span class=\"o\">(</span><span class=\"n\">ScoreDirector</span> <span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">Task</span> <span class=\"n\">task</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">updateStartTime</span><span class=\"o\">(</span><span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"o\">.</span>\n    <span class=\"o\">.</span>\n    <span class=\"o\">.</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//当一个任务的时候被更新时，顺着链将它后面所有任务的时候都更新\n</span><span class=\"c1\"></span><span class=\"kd\">protected</span> <span class=\"kt\">void</span> <span class=\"nf\">updateStartTime</span><span class=\"o\">(</span><span class=\"n\">ScoreDirector</span> <span class=\"n\">scoreDirector</span><span class=\"o\">,</span> <span class=\"n\">Task</span> <span class=\"n\">sourceTask</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n     <span class=\"n\">Step</span> <span class=\"n\">previous</span> <span class=\"o\">=</span> <span class=\"n\">sourceTask</span><span class=\"o\">.</span><span class=\"na\">getPreviousStep</span><span class=\"o\">();</span>\n     <span class=\"n\">Task</span> <span class=\"n\">shadowTask</span> <span class=\"o\">=</span> <span class=\"n\">sourceTask</span><span class=\"o\">;</span>\n     <span class=\"n\">Integer</span> <span class=\"n\">previousEndTime</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">previous</span> <span class=\"o\">==</span> <span class=\"kc\">null</span> <span class=\"o\">?</span> <span class=\"kc\">null</span> <span class=\"o\">:</span> <span class=\"n\">previous</span><span class=\"o\">.</span><span class=\"na\">getEndTime</span><span class=\"o\">());</span>\n     <span class=\"n\">Integer</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">calculateStartTime</span><span class=\"o\">(</span><span class=\"n\">shadowTask</span><span class=\"o\">,</span> <span class=\"n\">previousEndTime</span><span class=\"o\">);</span>\n     <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">shadowTask</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span><span class=\"n\">Objects</span><span class=\"o\">.</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">shadowTask</span><span class=\"o\">.</span><span class=\"na\">getStartTime</span><span class=\"o\">(),</span> <span class=\"n\">startTime</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n          <span class=\"n\">scoreDirector</span><span class=\"o\">.</span><span class=\"na\">beforeVariableChanged</span><span class=\"o\">(</span><span class=\"n\">shadowTask</span><span class=\"o\">,</span> <span class=\"s\">&#34;startTime&#34;</span><span class=\"o\">);</span>\n          <span class=\"n\">shadowTask</span><span class=\"o\">.</span><span class=\"na\">setStartTime</span><span class=\"o\">(</span><span class=\"n\">startTime</span><span class=\"o\">);</span>\n          <span class=\"n\">scoreDirector</span><span class=\"o\">.</span><span class=\"na\">afterVariableChanged</span><span class=\"o\">(</span><span class=\"n\">shadowTask</span><span class=\"o\">,</span> <span class=\"s\">&#34;startTime&#34;</span><span class=\"o\">);</span>\n          <span class=\"n\">previousEndTime</span> <span class=\"o\">=</span> <span class=\"n\">shadowTask</span><span class=\"o\">.</span><span class=\"na\">getEndTime</span><span class=\"o\">();</span>\n          <span class=\"n\">shadowTask</span> <span class=\"o\">=</span> <span class=\"n\">shadowTask</span><span class=\"o\">.</span><span class=\"na\">getNextTask</span><span class=\"o\">();</span>\n          <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">calculateStartTime</span><span class=\"o\">(</span><span class=\"n\">shadowTask</span><span class=\"o\">,</span> <span class=\"n\">previousEndTime</span><span class=\"o\">);</span> \n     <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2><br/><b>规划实体的设计</b></h2><p>　　上一步我们介绍了如何通过链在引擎的运行过程中进行时间推算，那么如何设定才能让引擎可以执行VariableListener中的方法呢，这就需要在规划实体的设计过程中，反映出Chained Through Time的特性了。我们以上面的类图为例，理解下面其设计要求，在此示例中，把Task作为规划实体(Planning Entity), 那么在Task类中需要定义一个Planning Variable(genuine planning variable), 它的类型是Step,它表示当前Task的上一个步骤（可能是另一个Task，也可能是一Machine). 此外，在 @PlanningVariable注解中，添加graphType = PlanningVariableGraphType.CHAINED说明。如下代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// Planning variables: changes during planning, between score calculations.\n</span><span class=\"c1\"></span>    <span class=\"nd\">@PlanningVariable</span><span class=\"o\">(</span><span class=\"n\">valueRangeProviderRefs</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"s\">&#34;machineRange&#34;</span><span class=\"o\">,</span> <span class=\"s\">&#34;taskRange&#34;</span><span class=\"o\">},</span>\n            <span class=\"n\">graphType</span> <span class=\"o\">=</span> <span class=\"n\">PlanningVariableGraphType</span><span class=\"o\">.</span><span class=\"na\">CHAINED</span><span class=\"o\">)</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Step</span> <span class=\"n\">previousStep</span><span class=\"o\">;</span></code></pre></div><p><br/>　　以上代码说明，规划实体(Task)的genuine planning variable名为previousStep, 它的Value Range有两个来源，分别是机台列表（machineRange)和任务列表(taskRange),并且添加了属性grapType=planningVariableGraphType.CHAINED, 表明将应用Chained Through Time模式运行。<br/>　　有了genuine planning variable, 还需要Shadow variable, 所谓的Shadow variable，在Chained Through Time模式下有两种作用，分别是：<br/>　　1. 用于建立两个对象（Entity或Anchor)之间的双向依赖关系；即示例中的Machine与Task, 相邻的两个Task。<br/>　　2. 用于指定当genuine planning variable的值在规划运算过程产生变化时，需要更改哪个变量；即上面提到的开始时间。<br/></p><p>对于第一个作用，其代码体现如下，在规划实体（Task)中，以@AnchorShadowVariable注解，并在该注解的sourceVariableName中指定该Shadow Variable在链上的前一个对象指向的是哪个变量。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"c1\">// Shadow variables\n</span><span class=\"c1\"></span>    <span class=\"c1\">// Task nextTask inherited from superclass\n</span><span class=\"c1\"></span>    <span class=\"nd\">@AnchorShadowVariable</span><span class=\"o\">(</span><span class=\"n\">sourceVariableName</span> <span class=\"o\">=</span> <span class=\"s\">&#34;previousStep&#34;</span><span class=\"o\">)</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Machine</span> <span class=\"n\">machine</span><span class=\"o\">;</span></code></pre></div><p><br/>　　上述代码说明成员machine是一个Anchor Shadow Variable, 在链上，它连接的前一个实体是实体类的一个成员 - previousStep.<br/>　　Chained Through Time中的链需要形成双向关系(bi-directional)，下图是路线规划示例中。一个客户与上一个停靠点之间的双向关系。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3d397b4eff7c466458964890f105a486_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"778\" data-original=\"https://pic3.zhimg.com/v2-3d397b4eff7c466458964890f105a486_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;778&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"778\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"778\" data-original=\"https://pic3.zhimg.com/v2-3d397b4eff7c466458964890f105a486_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3d397b4eff7c466458964890f105a486_b.jpg\"/></figure><p>　　　在规划实体(Task)中我们已经定义了前一个Step，并以@AnchorShadowVariable注解标识。而双向关系中的另一方，则需要在相邻节点中的前一个节点定义。通过链的内存模型，我们可以知道，在生产计划示例中，一个实体的前一个节点的类型可能是另一个Task, 也要能是一个Machine, 因此，前一个节点指向后一个节点的规划变量，只能在Task与Machine的共同父类中定义，也就是需要在Step中实现。因此，在Step类中需要定义另一个Shadow Variable, 因为相对于Task中的Anchor Shadow variable, 它是反现的，因此，它需要通过@InverseRelationShadowVariable注解，说明它在链上起到反向连接作用，即它是指向后一个节点的。代码如下：<br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"nd\">@PlanningEntity</span>\n<span class=\"kd\">public</span> <span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">Step</span><span class=\"o\">{</span>\n\n    <span class=\"c1\">// Shadow variables\n</span><span class=\"c1\"></span>    <span class=\"nd\">@InverseRelationShadowVariable</span><span class=\"o\">(</span><span class=\"n\">sourceVariableName</span> <span class=\"o\">=</span> <span class=\"s\">&#34;previousStep&#34;</span><span class=\"o\">)</span>\n    <span class=\"kd\">protected</span> <span class=\"n\">Task</span> <span class=\"n\">nextTask</span><span class=\"o\">;</span>\n    <span class=\"o\">.</span>\n    <span class=\"o\">.</span>\n    <span class=\"o\">.</span>\n<span class=\"o\">}</span></code></pre></div><p><br/>　　可以从代码中看到，Step类也是一个规划实体.其中的一个成员nextTask, 它的类型是Task,它表示在链中指向后面的Entity. 大家可以想一下，为什么它可以是一个Task, 而无需是一个Step。<br/>　　通过上述设计，已经实现了Chained Through Time的基本模式，可能大家还会问，上面我们实现了VariableListener, 引擎是如何触发它的呢。这就需要用到另外一种Shadow Variable了，这种Shadow Varible是用于实现在运算过程中执行额外处理的，因此称为Custom Shadow Variable.<br/></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 自定义Shadow Variable, 它表示当 genuine被引擎改变时，需要处理哪个变量。 \n</span><span class=\"c1\"></span><span class=\"nd\">@CustomShadowVariable</span><span class=\"o\">(</span><span class=\"n\">variableListenerClass</span> <span class=\"o\">=</span> <span class=\"n\">StartTimeUpdatingVariableListener</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">,</span>\n            <span class=\"n\">sources</span> <span class=\"o\">=</span> <span class=\"o\">{</span><span class=\"nd\">@PlanningVariableReference</span><span class=\"o\">(</span><span class=\"n\">variableName</span> <span class=\"o\">=</span> <span class=\"s\">&#34;previousStep&#34;</span><span class=\"o\">)})</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Integer</span> <span class=\"n\">startTime</span><span class=\"o\">;</span> <span class=\"o\">//</span> <span class=\"n\">因为时间在规划过程中以相对值进行运算</span><span class=\"err\">，</span><span class=\"n\">因此以整数表示</span><span class=\"err\">。</span> </code></pre></div><p>　　上面的代码通过@CustomShadowVariable注解，说明了Task的成员startTime是一个自定义的Shadow Variable. 同时在注解中添加了variableListenerClass属性，其值指定为刚才我们定义的，实现了VariableListener接口的类 - StartTimeUpdatingVariableListener，同时，能冠军sources属性指定，当前Custom Shadow Variable是跟随着genuine variable - previousStep的变化而变化的。<br/>　　至此，关于Chained Through Time中的关键要点已全部设计实现，具体的使用可以参照示例包中有用到此模式的代码。</p><h2><b> 总结</b></h2><p>　　关于时间的规划，在实际的系统开发时，并不只本文描述的那么简单，关于最为复杂的Chained Through Time模式，大家可以通过本文了解其概念、结构和要点，再结合示例包中的代码进来理解，才能掌握其要领。且现实项目中也有许许多多的个性规则和要求，需要通过大家的技巧来实现；但万变不离其宗，所有处理特殊情况的技巧，都需要甚至OptaPlanner这些既有特性。因此，大家可以先通过示例包中的代码将这些特性掌握，再进行更复杂情况下的设计开如。未来若时间允许，我将分享我在项目中遇到的一些特殊，甚至是苛刻的规则要求，及其处理办法。<br/> <br/><b>如需了解更多关于OptaPlanner的应用，请发电邮致：<a href=\"mailto:kentbill@gmail.com\">kentbill@gmail.com</a></b><br/><b>或到讨论组发表你的意见：<a href=\"https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">groups.google.com/forum</span><span class=\"invisible\">/#!forum/optaplanner-cn</span><span class=\"ellipsis\"></span></a></b><br/><b>若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)</b></p><p></p>", 
            "topic": [
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "生产计划", 
                    "tagLink": "https://api.zhihu.com/topics/19739797"
                }, 
                {
                    "tag": "ERP", 
                    "tagLink": "https://api.zhihu.com/topics/19557683"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35522528", 
            "userName": "Kent Zhang", 
            "userLink": "https://www.zhihu.com/people/e9938ca9bde94442985575310e10869d", 
            "upvote": 4, 
            "title": "探究OptaPlanner示例，初步认识规划引擎的运行步骤", 
            "content": "<p>       上一篇我们成功以把Opotaplanner规划引擎下载回来，并把它的示例运行起来，简单解析了一下它的Cloud balance示例。这一篇我们这些示例的源代码导入到Eclipse中，看看它在后台是怎么运行的。</p><h2>一、推荐使用Maven</h2><p>　　在上一篇，我们已经从OptaPlanner的官网下载了它的压缩包，它里面几乎包含了OptaPlanner的所有东西，基本上有了这个包，我们离线都可以做一个应用Optaplanner规划引擎程序出来了。但是如果我们直接使用里面的核心包来做Java Project是很不明智的；因为：1.这些包有很多在特殊的场景才会用到，并不是每个项目都会用到，引入太多浪费空间。2. 如果OptaPlanner引擎有版本更新了，你又想使用的话，那只能重新下载、配置。所以，现在OptaPlanner官网通常都是推荐通过Maven的方式来建议项目。关于Maven的用法，大家可以去看一下相关的文章，其实也不复杂的，就是有一些公共的库帮你管理好了这些你用到的包，你只需要在你的项目里配置好你需要使用的包，剩下的就是Maven自己把需要的包括下载到你本地，并自动匹配版本了，当有OptaPlanner有版本更新的时候，你所使用的包也可以更新为最新版本，而无需人工下载。所以，在这里，我们都是以Maven项目的方式来建立OptaPlanner的示例源码，在以后的OptaPlanner相关的演示中（稍后会有一篇文章会编写一个最基本的Hello world程序，也会通过Maven项目实现）.</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>二、OptaPlanner的Hello word　</h2><p>　　这一篇里面我们就从OptaPlanner所有示例程序中的“Hello word”开始，因为OptaPlanner面对的是规则问题，所以并没办法像学习一门新语言的入门教程一下，以打印一个Hello world信息出来作为第一个程序，毕竟它是个规划引擎，是用来对一系列对像进行规划的。所以我们就从它的说明文档里最简单的一个示例Cloud Banacing开始。关于这个示例的说明，在上一篇文章里，我们把它的所有示例程序跑起来的时候，重点讲解过它，这里就概述一下，让大家对这个示例有个大概的了解。大家可以打开<a href=\"https://zhuanlan.zhihu.com/p/35369689\" class=\"internal\">《OptaPlanner - 把example运行起来（运行并浅析Cloud balancing）》</a>这篇文里看它在程序里的具体呈现方式。简而言之，Cloud banacing就是模拟在云端有很多任务，需要根据CPU, 内存及带宽的要求，分配到不同的计算机上去执行，在满足了每个任务的基础上，还需要实现最省计算机资源的原则。这就是典型的资源规则问题了，大家可以扩展到供应链各个环节中的场景，例如APS（Advanced Planning and Scheduling, 高级计划与排程）中，如何将任务按一定的要求分配到指定的车间、产线甚至机台、工位上，并实现成本最低，或效率最高，或资源平衡等要求。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>三、导入示例源码并试运行</h2><p>　　接下来我们就一步步把源代码都导进Eclipse里慢慢分析一下，如果要实现一个规则程序，至少需要用到OptaPlanner哪里功能，需要建议哪些对象和规则。在一上篇里，我们已经下载了OptaPlanner的发布包了，它里面包含了OptaPlanner引擎的所有东西，包括可以直接使用的字节码程序，源代码，用户手册（包括所有API的Java Doc）,所有示例程序和所有示例程序的源代码.这里，我们就以Mavin Project为基础，把这个发布包里的示例程序的源代码导进来，然后再从这些源代码里去看看它的基本运行步骤和所需的对象和规则。</p><h2>1. 创建workspace</h2><p>　　　　创建一个文件夹作为这些试验的workspace.接下来我们的所有示例源码都放在这个文件中进行导入、运行、调度并修改。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d247927e06a1776817e3867060adf36b_b.jpg\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-d247927e06a1776817e3867060adf36b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;636&#39; height=&#39;330&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"330\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-d247927e06a1776817e3867060adf36b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d247927e06a1776817e3867060adf36b_b.jpg\"/><figcaption>创建一个文件夹作伙workspace</figcaption></figure><h2>2. 解压示例源码</h2><p>　　　　把示例源代码解压到workspace文件夹中，以便下一步把它作为maven项目导入，注意，需要将optaplanner-distribution-7.6.0.Final\\examples\\sources整个文件夹解压到workspace文件夹中去，因为这个文件夹里包含了示例源代码，用于运行示例用的数据文件,还有一些资源文件。source文件夹下面有个pom,xml文件，表示它是一个maven项目。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b3aef0fa6422b9a68b5972b58f5f1f54_b.jpg\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"845\" data-original=\"https://pic1.zhimg.com/v2-b3aef0fa6422b9a68b5972b58f5f1f54_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;845&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"845\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"845\" data-original=\"https://pic1.zhimg.com/v2-b3aef0fa6422b9a68b5972b58f5f1f54_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b3aef0fa6422b9a68b5972b58f5f1f54_b.jpg\"/><figcaption>将示例源代码(sources文件夹)解压到workspace文件中</figcaption></figure><h2>3. 导入示例源代码</h2><p>　　　　在eclipse中，选择菜单File -&gt; Import, 在弹出的Import对话框中，选择&#34;Existing Maven Projects&#34;,(可以在Select an import wizard下面的文档框中输入maven来快速定位你们导入的项目，输入maven，就会过滤出maven相关的项目），选择“Existing Maven Projects”，点击&#34;Next&#34;, 在&#34;Import Maven Projects&#34;对话框中，通过&#34;Browser&#34;按钮定位到刚才解压的sources文件夹去，Root Directory即会显示该位置，并在下面的Projects列表中，显示该文件夹下的pom.xml文件，选中该pom.xml文件，并选中“add projects(s) to working set”，点击Finish。eclipse即会把程序导入,并在sources文件夹(即与pom.xml文件同一个地方)中生成.project文件。即表示项目导入成功。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-395c06afc571a4143de30662af5c63f0_b.jpg\" data-size=\"normal\" data-rawwidth=\"427\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb\" width=\"427\" data-original=\"https://pic1.zhimg.com/v2-395c06afc571a4143de30662af5c63f0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;427&#39; height=&#39;424&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"427\" data-rawheight=\"424\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"427\" data-original=\"https://pic1.zhimg.com/v2-395c06afc571a4143de30662af5c63f0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-395c06afc571a4143de30662af5c63f0_b.jpg\"/><figcaption>导入</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d05e5a6bec964900f0c513ca764bc6ec_b.jpg\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"524\" class=\"origin_image zh-lightbox-thumb\" width=\"520\" data-original=\"https://pic1.zhimg.com/v2-d05e5a6bec964900f0c513ca764bc6ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;520&#39; height=&#39;524&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"520\" data-rawheight=\"524\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"520\" data-original=\"https://pic1.zhimg.com/v2-d05e5a6bec964900f0c513ca764bc6ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d05e5a6bec964900f0c513ca764bc6ec_b.jpg\"/><figcaption>选择导入已有的Maven项目</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b0c6ad307b0cbf06265c0a8e81a843cb_b.jpg\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"639\" class=\"origin_image zh-lightbox-thumb\" width=\"654\" data-original=\"https://pic4.zhimg.com/v2-b0c6ad307b0cbf06265c0a8e81a843cb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;654&#39; height=&#39;639&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"654\" data-rawheight=\"639\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"654\" data-original=\"https://pic4.zhimg.com/v2-b0c6ad307b0cbf06265c0a8e81a843cb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b0c6ad307b0cbf06265c0a8e81a843cb_b.jpg\"/><figcaption>定位到前述步骤解压的soures文件夹，将自动识别出mave项目的pom.xml文件</figcaption></figure><h2>　　4. 更新依赖包。</h2><p>　　　　项目导入后，通常eclipse会自己检测项目中依赖的包是否都存在，若不存在会自己下载。如果eclipse没有自动下载（通常几秒钟后会检查到并下载），就点选一下菜单File -&gt; Refresh 刷新一下。你们的电脑如果是第一次导入OptaPlanner的项目，将会有一个比较长的下载依赖包过程，视下载速率而定。通常会显示更新进度。完成依赖包下载后，eclipse还会原始的项目信息，为源创建好各种包。即恢复原来的包信息.</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-daabcdac6234f337127392cfbadc615a_b.jpg\" data-size=\"normal\" data-rawwidth=\"996\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"996\" data-original=\"https://pic3.zhimg.com/v2-daabcdac6234f337127392cfbadc615a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;996&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"996\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"996\" data-original=\"https://pic3.zhimg.com/v2-daabcdac6234f337127392cfbadc615a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-daabcdac6234f337127392cfbadc615a_b.jpg\"/><figcaption>eclipse会自动根据pom.xml中的依赖项更新依赖包，若没有自动更新，点一下文件菜单中的刷新菜单项</figcaption></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-523f34b7df8b4ba3425f72e297d6dd27_b.jpg\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb\" width=\"830\" data-original=\"https://pic4.zhimg.com/v2-523f34b7df8b4ba3425f72e297d6dd27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;830&#39; height=&#39;520&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"830\" data-rawheight=\"520\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"830\" data-original=\"https://pic4.zhimg.com/v2-523f34b7df8b4ba3425f72e297d6dd27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-523f34b7df8b4ba3425f72e297d6dd27_b.jpg\"/><figcaption>依赖项更新完成后，示例代码的原始包信息都会被应用，自动创建好包结构。</figcaption></figure><hr/><h2>　　5.试运行</h2><p>　　　　我们先试一下，看看我们的导入的源代码是否都已经正确，所需的依赖包是否都已经完成下载并更新。找到整个示例的入口类 - OptaPlannerExamplesApp.java. 右击它，在弹出菜单中，选择Run As -&gt; 2 Java Application. 稍等片刻，程序就会跑起来了，效果跟上一篇我们直接通过批处理文件运行起来的效果一样，那么就表示我们已经成功把OptaPlanner的所有示例成功导进eclipse了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-214013580645b40056f9255e4e1bd8d4_b.jpg\" data-size=\"normal\" data-rawwidth=\"857\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"857\" data-original=\"https://pic1.zhimg.com/v2-214013580645b40056f9255e4e1bd8d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;857&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"857\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"857\" data-original=\"https://pic1.zhimg.com/v2-214013580645b40056f9255e4e1bd8d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-214013580645b40056f9255e4e1bd8d4_b.jpg\"/><figcaption>找出Clould Balancing示例的Hello world示例入口运行。</figcaption></figure><h2>四、分析Hello world源码</h2><p>　　　　下面，我们着重分析一下它的Cloud Balancing示例，它的，在包org.optaplanner.examples.cloudbalancing.app下，有一个CloudBalancingHelloWorld.java类。这个就是Optaplanner最基本的入门示例了。我们直接看它的代码，可以看到要使用OptaPlanner需要最基本的三个步骤，分别是创建Solver对象, 创建被规划的对象，启动solve()方法，solver方法的返回值就是一个已经规划好的方案了.代码如下： </p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">1</span>  <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n<span class=\"n\">2</span>        <span class=\"c1\">// Build the Solver\n</span><span class=\"c1\"></span><span class=\"n\">3</span>        <span class=\"n\">SolverFactory</span><span class=\"o\">&lt;</span><span class=\"n\">CloudBalance</span><span class=\"o\">&gt;</span> <span class=\"n\">solverFactory</span> <span class=\"o\">=</span> <span class=\"n\">SolverFactory</span><span class=\"o\">.</span><span class=\"na\">createFromXmlResource</span><span class=\"o\">(</span>\n<span class=\"n\">4</span>                <span class=\"s\">&#34;org/optaplanner/examples/cloudbalancing/solver/cloudBalancingSolverConfig.xml&#34;</span><span class=\"o\">);</span>\n<span class=\"n\">5</span>        <span class=\"n\">Solver</span><span class=\"o\">&lt;</span><span class=\"n\">CloudBalance</span><span class=\"o\">&gt;</span> <span class=\"n\">solver</span> <span class=\"o\">=</span> <span class=\"n\">solverFactory</span><span class=\"o\">.</span><span class=\"na\">buildSolver</span><span class=\"o\">();</span>\n<span class=\"n\">6</span>\n<span class=\"n\">7</span>        <span class=\"c1\">// Load a problem with 400 computers and 1200 processes\n</span><span class=\"c1\"></span><span class=\"n\">8</span>        <span class=\"n\">CloudBalance</span> <span class=\"n\">unsolvedCloudBalance</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">CloudBalancingGenerator</span><span class=\"o\">().</span><span class=\"na\">createCloudBalance</span><span class=\"o\">(</span><span class=\"n\">400</span><span class=\"o\">,</span> <span class=\"n\">1200</span><span class=\"o\">);</span>\n<span class=\"n\">9</span>\n<span class=\"n\">10</span>        <span class=\"c1\">// Solve the problem\n</span><span class=\"c1\"></span><span class=\"n\">11</span>        <span class=\"n\">CloudBalance</span> <span class=\"n\">solvedCloudBalance</span> <span class=\"o\">=</span> <span class=\"n\">solver</span><span class=\"o\">.</span><span class=\"na\">solve</span><span class=\"o\">(</span><span class=\"n\">unsolvedCloudBalance</span><span class=\"o\">);</span>\n<span class=\"n\">12</span>\n<span class=\"n\">13</span>        <span class=\"c1\">// Display the result\n</span><span class=\"c1\"></span><span class=\"n\">14</span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;\\nSolved cloudBalance with 400 computers and 1200 processes:\\n&#34;</span>\n<span class=\"n\">15</span>                <span class=\"o\">+</span> <span class=\"n\">toDisplayString</span><span class=\"o\">(</span><span class=\"n\">solvedCloudBalance</span><span class=\"o\">));</span>\n<span class=\"n\">16</span>    <span class=\"o\">}</span>\n</code></pre></div><p><b>    第一步：</b>生成Solver对象，代码的第3行创建一个SolverFactory&lt;CloudBanace&gt;对象，其实   也就是它使用了工厂模式，并使用了泛型了。其中CloudBalance是一个由我们定义的Planning Problem对象，被规则的对象都会作为Planning Problem对象的属性列表而传进引擎中，它是OpaPlanner的几大基本对象之一，在这个示例中，第8行就是创建了一个Planning Problem对象，大家可以导航进去看到，创建它的时候，是否为它的两个列表(Computer和Process列表)初始化了一些对象。在关于这些基本对象的文章中，将会有详细的说明.在这一步主要是创建一个Solver对象出来，这个对象是指OptaPlanner引擎将会使用什么算法,以什么参数，引用哪些规则对Planning Problem进行规划运算的，在规划运算过程中，基于什么原则进行退出等等设置。而这些设置全部可以写进一个XML文件中，也就是上面代码中的cloudBalancingSolverConfig.xml了。</p><p><b>    第二步：</b>创建将要被规划的对象，就是上面提到的Planning Problem对象了，在代码中的第8行实现。</p><p><b>　  第三步：</b>通过Solver对象的solve方法，对上面创建的Planning Problem进行规划。这个过程有可能需要一个很长的时间，也有可能是实时规划的，也可能7 * 24小时都在线（实时规划）。而对于前一种（非实时规划），当规划运算完成后（通常在cloudBalancingSolverConfig.xml文件中会设置规划的完成条件），会返回一个已经完成了规划的Planning Problem对象，读取这个对象里的规划实体列表（例如本例中的规划实体就是Process对象），就得到规划好的方案了。</p><p>　以下是这个示例在规划过程中的Log输出，它清楚以显示了每一个规划步骤，引擎对规划实体进行了什么操作。</p><div class=\"highlight\"><pre><code class=\"language-text\">20:00:47.447 [main        ] DEBUG     LS step (20378), time spent (14822), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/2), picked move (CloudProcess-21 {CloudComputer-182 -&gt; CloudComputer-74}).\n20:00:47.447 [main        ] DEBUG     LS step (20379), time spent (14822), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/1), picked move (CloudProcess-1191 {CloudComputer-164} &lt;-&gt; CloudProcess-674 {CloudComputer-375}).\n20:00:47.447 [main        ] DEBUG     LS step (20380), time spent (14822), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/3), picked move (CloudProcess-696 {CloudComputer-360} &lt;-&gt; CloudProcess-945 {CloudComputer-286}).\n20:00:47.447 [main        ] DEBUG     LS step (20381), time spent (14822), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/1), picked move (CloudProcess-490 {CloudComputer-298} &lt;-&gt; CloudProcess-1196 {CloudComputer-258}).\n20:00:47.447 [main        ] DEBUG     LS step (20382), time spent (14822), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/10), picked move (CloudProcess-204 {CloudComputer-375 -&gt; CloudComputer-159}).\n20:00:47.448 [main        ] DEBUG     LS step (20383), time spent (14823), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/1), picked move (CloudProcess-465 {CloudComputer-136} &lt;-&gt; CloudProcess-621 {CloudComputer-0}).\n20:00:47.448 [main        ] DEBUG     LS step (20384), time spent (14823), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/1), picked move (CloudProcess-860 {CloudComputer-393} &lt;-&gt; CloudProcess-29 {CloudComputer-216}).\n20:00:47.449 [main        ] DEBUG     LS step (20385), time spent (14824), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/5), picked move (CloudProcess-57 {CloudComputer-323} &lt;-&gt; CloudProcess-768 {CloudComputer-36}).\n20:00:47.449 [main        ] DEBUG     LS step (20386), time spent (14824), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/3), picked move (CloudProcess-934 {CloudComputer-324 -&gt; CloudComputer-246}).\n20:00:47.449 [main        ] DEBUG     LS step (20387), time spent (14824), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/2), picked move (CloudProcess-812 {CloudComputer-198} &lt;-&gt; CloudProcess-1085 {CloudComputer-112}).\n20:00:47.449 [main        ] DEBUG     LS step (20388), time spent (14824), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/1), picked move (CloudProcess-883 {CloudComputer-41} &lt;-&gt; CloudProcess-1180 {CloudComputer-237}).\n20:00:47.450 [main        ] DEBUG     LS step (20389), time spent (14825), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/6), picked move (CloudProcess-477 {CloudComputer-376} &lt;-&gt; CloudProcess-713 {CloudComputer-197}).\n20:00:47.450 [main        ] DEBUG     LS step (20390), time spent (14825), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/3), picked move (CloudProcess-693 {CloudComputer-311 -&gt; CloudComputer-342}).\n20:00:47.450 [main        ] DEBUG     LS step (20391), time spent (14825), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/3), picked move (CloudProcess-328 {CloudComputer-186} &lt;-&gt; CloudProcess-520 {CloudComputer-59}).\n20:00:47.453 [main        ] DEBUG     LS step (20392), time spent (14828), score (0hard/-519420soft),     best score (0hard/-518110soft), accepted/selected move count (1/3), picked move (CloudProcess-203 {CloudComputer-103} &lt;-&gt; CloudProcess-745 {CloudComputer-112}).</code></pre></div><p>　　至此，我们已把OptaPlanner的示例程序全部导入到eclipse并跑起来了，也简单地介绍过一下它的hello world示例，可能大家还是会有些疑问，到底它是怎么执行得的，它做了些什么，要理解这些问题，就真的需要从需求开始，再理解一下OptaPlanner的规划模型，最后结合一些示例才能说得清楚了。在接下来的文章中，我将会以一个个自己想出来的简单示例，逐步对上述的问题进行讲述。过程不再一次过写太长的内容了，会在每篇文章里介绍几个相关的概念。好让大家更容易理解，更容易上手。</p><p><b>PS:</b> 其实在导入并试运行过程中，使用7.6.0.Final版本的代码会出现一个异常的，刚好今天发现有7.7.0.Final发布了（好快喔），就下了最新的源码，那个异常消失了。大家可以注意一下，下载7.6.0.Final的示例源码不一定能跑成功喔，</p><p>End.</p><a href=\"https://link.zhihu.com/?target=https%3A//www.optaplanner.org/localized/zh/index.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-b8bfd44299e21d015908c830a2fae24a_ipico.jpg\" data-image-width=\"256\" data-image-height=\"256\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">约束求解器 (Java ™, Open Source)</a><p class=\"ztext-empty-paragraph\"><br/></p><p><b>本系列文章在公众号不定时连载，请关注公众号（搜“让APS成为可能”或扫以下QR Code）及时接收,二维码：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b5be1dcef8f861e65b2ad8325990d19e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"378\" data-rawheight=\"384\" class=\"content_image\" width=\"378\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;378&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"378\" data-rawheight=\"384\" class=\"content_image lazy\" width=\"378\" data-actualsrc=\"https://pic3.zhimg.com/v2-b5be1dcef8f861e65b2ad8325990d19e_b.jpg\"/></figure><p><b>如需了解更多关于OptaPlanner的应用，请发电邮致：<a href=\"mailto:kentbill@gmail.com\">kentbill@gmail.com</a></b><br/><b>或到讨论组发表你的意见：</b><i><a href=\"https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">groups.google.com/forum</span><span class=\"invisible\">/#!forum/optaplanner-cn</span><span class=\"ellipsis\"></span></a></i><br/><b>若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)</b></p>", 
            "topic": [
                {
                    "tag": "开源软件", 
                    "tagLink": "https://api.zhihu.com/topics/19552811"
                }, 
                {
                    "tag": "企业信息化", 
                    "tagLink": "https://api.zhihu.com/topics/19701845"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48959675", 
            "userName": "Kent Zhang", 
            "userLink": "https://www.zhihu.com/people/e9938ca9bde94442985575310e10869d", 
            "upvote": 4, 
            "title": "【译】OptaPlanner开发手册本地化: (0) - 前言及概念", 
            "content": "<p>　　在此之前，针对APS写了一些理论性的文章；而对于OptaPlanner也写了一些介绍性质，几少量入门级的帮助初学者走近OptaPlanner。在此以后，老农将会按照OptaPlanner官方的用户手册的结构，按章节地对其进行翻译，并成型一系列的操作说明文章。在文章中，为了降低对原文的理解难度，有些地方我不会直接按原文档的字面翻译，而是有可能加入一些我自己的理解，或添一些解释性的内容。毕竟英语环境下的思维和语言表达方式，跟中文或多或少会有差别的，所以如果全部按字面翻译，内容就非常生硬，可读性差，理解难度较大。我认为应该在理解了作者原意的基础上，再进一步以中文方式的表达，才算是真的的本地化。记得老农还是少农时，学习开发技术，需要阅读一些外国书箱的翻译本时，印象最深的是候捷老师的书，尽管《深入浅出MFC》，砖头厚度的书，硬是被我翻散了线，MFC尽管真的晦涩难懂，但候老却能把Windows的消息机制及MFC中整个个宏体系，系统地通俗地描述出来，令读者不需要花费太多精力去理解猜测书中字面的意义，大大降低的VC++中MFC的学习门槛。但老农毕竟只是一个一线开发人员，不是专业的技术资料翻译人才，不可能有候老师的专业水平，因此，我也只可尽我所能把内容尽量描述得通俗一些，让读者尽量容易理解，花费更少的时间掌握这些知道要点。</p><p><i>本文以OptaPlanner 7.10.0 Final版本的开发手册作为基础进行翻译。</i></p><hr/><h2><b>1. OptaPlanner 介绍</b></h2><h2><b>1.1. 什么是OptaPlanner?</b></h2><p> 　　每个组织都需要面对规划、排程问题：在有限的资源约束下提供服务与产品（例如人员，资产，时间及资本等限制）。OptaPlanner可以优化这类规划、排程问题，令到使用它的组织可以用更少的资源做更多的事（尽可能的花少钱办大事）。这就是著名的的约束满足规划，它属于运筹学的一部分。</p><p><a href=\"https://link.zhihu.com/?target=https%3A//www.optaplanner.org/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">OptaPlanner</a>是一个轻量的、可嵌入的，可以对规划问题进行优化的约束满足引擎，它可以解决案例有：</p><ul><li><b>员工排班</b>：为护士、维修工等人员制定上班时间表。</li><li><b>方程安排</b>：安排会议、约见、维修工作、广告时间等。</li><li><b>教育领域的时间安排</b>：安排课程、课堂、考试、会议讲座等。</li><li><b>规划车辆运动路线</b>：通过已知的地图工具，为货运、客运（货车、火车、轮船、航班等）规划交通工具多目标的运行路线。</li><li><b>装箱问题</b>：向容器、货车、轮船和仓库装载货物，同时可以规划电脑的资源加载利用，例如云计算的资源分配问题。</li><li><b>车间生产安排</b>：规划汽车组装生产线，机器队规划，劳动任务的规则等。</li><li><b>下料问题</b>：在下料分割的时候，实现最小的浪费，例如切割纸张、钢铁、地毯等。</li><li><b>运动赛事安排</b>：规划比赛和训练，例如安排足球联赛、棒球联赛等。</li><li><b>金融优化</b>：投资组合优化、实现风险分散等。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b0f20259ebe1ebf8432cf3020cadcab0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-b0f20259ebe1ebf8432cf3020cadcab0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic1.zhimg.com/v2-b0f20259ebe1ebf8432cf3020cadcab0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b0f20259ebe1ebf8432cf3020cadcab0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>1.2. 什么是规划问题？</b></h2><b><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6f82c7c2b33e7703807a1cc4e6de1cb5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-6f82c7c2b33e7703807a1cc4e6de1cb5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;800&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"800\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"800\" data-original=\"https://pic2.zhimg.com/v2-6f82c7c2b33e7703807a1cc4e6de1cb5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6f82c7c2b33e7703807a1cc4e6de1cb5_b.jpg\"/></figure></b><p class=\"ztext-empty-paragraph\"><br/></p><p>　一个规划问题，基于有限的资源和指定的约束，有一个优化目标。优化目标可以是多种事物，例如：<br/></p><ul><li>利润最大化 - 优化目标得出的结果是尽可以高的利润。</li><li>最小化生态足迹（即尽可能减少对生态的影响） - 优化目标是对环境产生尽可能小的影响。</li><li>最大化员工或客户的满足度 - 优化目标重视员工与客户的需要。</li></ul><p>实现这些目标的能力依赖于可用资料的数量，例如：<br/></p><ul><li>人员数量</li><li>时间</li><li>预算</li><li>特殊资产，例如机台，车辆，计算机，建筑物等。</li></ul><p>与这此资源相关的约束也必然计算在内，例如，一个人的工作小时数， 他们可使用（操作）的机台数量，设备之间的兼容性等。<br/>OptaPlanner可以帮助Java程序员有效地解决约束满足问题， 在OptaPlanner引擎中，对每个有效的约束分数计算中，组合了启发式和元启发式算法。 </p><h2><b> 1.2.1 规划问题属于NP-Complete问题或NP-hard问题</b></h2><p>　　上述所有的案例或许都属于<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/NP-completeness\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">NP-complete/NP-hard问题</a>，（什么是NP-Complete/NP-hard问题呢？），在外行人看来，它的定义是：</p><p>　　对于一个问题：</p><ul><li>在合理时间内可以容易地验证一个给定的解。</li><li>在合理时间内，目前尚没有行之有效的解法，能找到其绝对最优解(注1)。</li></ul><p>　　(注1)：至少，到目前为止，仍未有一个世界上最聪明的计算机科学家能找到此方法。可是一旦他们找到对其中一个NP-Complete问题的有效解法，那么这个方法对所有NP-Complete问题都是可行办法。事实上，如果任何人只需证明是<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/P_%253D_NP_problem\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这种解法的存在与否</a>，即可获得100万美元的奖励。</p><p>　　其实这其含义是相当悲观的：要解决这些问题或许比你预想中更困难，因为目前针对这种问题的常见两种技术是未足够解决此类问题的。这两种方法是：</p><ul><li>暴力算法(尽管是一些优化过，相对聪明的暴力算法变种), 但获得其解所需的时间非常长(译者：主要原因是时间复杂度非常高)。</li><li>快速算法，例如在Bin packing问题中，先装入最大项；但得到的解离绝对最优解仍存在相当大距离的。</li></ul><p>通过使用一些更高级的算法，OptaPlanner可以在合理的时间内，对这些规划问题找到相对较优解。</p><h2><b> 1.2.2 规划问题存在约束（包括硬约束与软件约束)</b></h2><p>　　通常来说，一个规划问题至少包括两个层次的约束：</p><ul><li>(负面)硬约束，不可被违反。例如：一个教师在同节的时间内不能同时上两门课。</li><li>(负面)软件约束，若可避免，它不应该被违反。例如：教师都不太喜欢在周五下午上课。</li></ul><p>　　也有些问题存在一些正面的约束：</p><ul><li>正面分数在可能情况下应该实现。例如：教师B喜欢在周一上午上课。</li></ul><p>　　一些比较基础的规划问题(例如8王后问题)，只存在硬约束；有一些规划问题则存在超3层，甚至更多层次的约束。例如：硬约束，中间约束和软约束。</p><p>　　这些约束会被定义在规划问题的Score calculation里(也称为适应度函数)里。规划问题里的每一个解的优劣，都可以通过分数来评价。在OptaPlanner中，分数约束是通过面向对象语文编写的，例如Java代码或通过Drools脚本实现的rules. 这些代码相当容易编写，灵活且易于扩展。</p><h2><b> 1.2.3 规划问题存在巨大的搜索空间</b></h2><p>　　一个规划问题存在非常多的解，这些解可以分为以下数种：</p><ul><li><b>可能解</b>：规划问题的任意一个解都称作可能解，无论这个解是否违反了约束，或违反了多少约束。规划问题往往存在令人难以至信的巨量可能解，这里面很多解是毫无价值的。</li><li><b>可行解</b>：规划问题的可行解是指没有违反任何（负面）硬约束的解。一个规划问题的可行解的数量，与其可能解相关。有时也不存在可行解，一个规划问题的每一个可行解，都是该问题的一个可能解。</li><li><b>绝对最优解</b>:绝对最优解是这个规则问题获得约束分最高的那个解。规划问题通常只有1个或少量数个绝对最优解。通常存在至少1个绝对最优解，尽管当这个规划问题不存在可行解，它也存在绝对最优解，这时候绝对最优解就是非可行解。</li><li><b>相对最优解</b>:相对最优解是指规划问题在一定的求解时间内得到评分最高的解。相对最优解通常是可行解，只要有足够的运行时间，找到的相对最优解就是绝对最优。</li></ul><p>　　此外，尽管基于一个较小的数据集描述的一个规划问题，其可能解的数量通常是非常巨大的（如果计算正确的话）。正如你从示例中可以看到，大多数情况下，一个规划问题的可能解数量，对目前已知宇宙的原子数量还要多(10的80次方)。因为目前还没有直接的办法找出规划问题的绝对最优解，一些求解实现方法是通过暴力穷举的方法，至少可以穷举所有可能解中的一个子集。</p><p>　　OptaPlanner支持多种优化算法，以有效地涉足大量可能解，根据不同使用场景的情况，一些优化算法的性能比其它算法更佳，但哪个更佳是无法预先告知的（译者：需要通过Benchmark等功能测定）。在OptaPlanner里，很容易能过修改几行XML内容或Java code，来更改求解器的配置，从而切换不同的优化算法。</p><p>【未完，待续...】<br/> <br/><b>原创不易，如果觉得文章对你有帮助，欢迎点赞、评论。文章有疏漏之处，欢迎批评指正。</b><br/></p><hr/><p><b>本系列文章在公众号不定时连载，请关注公众号（让APS成为可能）及时接收,二维码：</b><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ece8f48f45bb8a2a69bf8925efb6791e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image\" width=\"400\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;400&#39; height=&#39;400&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"400\" data-rawheight=\"400\" class=\"content_image lazy\" width=\"400\" data-actualsrc=\"https://pic3.zhimg.com/v2-ece8f48f45bb8a2a69bf8925efb6791e_b.jpg\"/></figure><p><br/><b>如需了解更多关于OptaPlanner的应用，请发电邮致：<a href=\"mailto:kentbill@gmail.com\">kentbill@gmail.com</a></b><br/><b>或到讨论组发表你的意见：<a href=\"https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">groups.google.com/forum</span><span class=\"invisible\">/#!forum/optaplanner-cn</span><span class=\"ellipsis\"></span></a></b><br/><b>若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)</b><br/> </p>", 
            "topic": [
                {
                    "tag": "开源软件", 
                    "tagLink": "https://api.zhihu.com/topics/19552811"
                }, 
                {
                    "tag": "企业信息化", 
                    "tagLink": "https://api.zhihu.com/topics/19701845"
                }, 
                {
                    "tag": "ERP", 
                    "tagLink": "https://api.zhihu.com/topics/19557683"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35369689", 
            "userName": "Kent Zhang", 
            "userLink": "https://www.zhihu.com/people/e9938ca9bde94442985575310e10869d", 
            "upvote": 8, 
            "title": "OptaPlanner - 把example运行起来", 
            "content": "<p>      经过上面篇长篇大论的理论之后，在开始讲解Optaplanner相关基本概念及用法之前，我们先把他们提供的示例运行起来，好先让大家看看它是如何工作的。OptaPlanner的优点不仅仅是提供详细丰富的文档 ，还为各种应用场景提供丰富的示例，它的文档里都是以几个简单经典的例子来说明各种功能特征和深层次概念的，例如Solver, Phase及Move等，以下我们就先把这些示例运行起来，先看看整体的情况，下一篇我们再把示例的源码导进Eclipse，拿一个简单经典的示例，讲解一下Optaplanner规划引擎工作时需要哪些要素，它是如何工作的。</p><p><b>1.下载：</b></p><p>　　首先得把示例下载回来，大家到Optaplanner的官网就可以看到一个<a href=\"https://link.zhihu.com/?target=https%3A//download.jboss.org/optaplanner/release/7.6.0.Final/optaplanner-distribution-7.6.0.Final.zip\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">绿色的按钮</a>（见下图），点击它就可以下载了。它的版本更新非常快，我们就基于7.6.0Final进行讲解。  </p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-723f1c1ff7c0c1ee54f4951f79844556_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb\" width=\"604\" data-original=\"https://pic3.zhimg.com/v2-723f1c1ff7c0c1ee54f4951f79844556_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;604&#39; height=&#39;401&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"604\" data-rawheight=\"401\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"604\" data-original=\"https://pic3.zhimg.com/v2-723f1c1ff7c0c1ee54f4951f79844556_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-723f1c1ff7c0c1ee54f4951f79844556_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>2. 解压：</b></h2><p>     下载回来的压缩包“optaplanner-distribution-7.6.0.Final.zip”包含了Optaplanner的源码、各种包（引擎自己的核心包及其依赖包）、说明文件和示例及其源码。其中示例包括两个版本，一个是基础Swing的，也就是Java的Windows程序；另一个是基于Web的，以War包提供，需要自己部署Tomcat等App服务器来运行。我们着重讨论Swing版本的，因为它不需要我们部署App服务器。如果以后大家有需要，我可以另写一篇专门部署Web版本示例的文章详细讲解。打开压缩包，里面的文件夹结构如下图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-aee3a8e0c94159620b78d62fa33b85a0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"695\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb\" width=\"695\" data-original=\"https://pic1.zhimg.com/v2-aee3a8e0c94159620b78d62fa33b85a0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;695&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"695\" data-rawheight=\"282\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"695\" data-original=\"https://pic1.zhimg.com/v2-aee3a8e0c94159620b78d62fa33b85a0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-aee3a8e0c94159620b78d62fa33b85a0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>3. 试运行示例：</b></h2><p>      因为压缩包中除了提供源码，还提供了已编译的包，只要在你系统中安装好Java环境，就可以运行起来，先看个究竟了。ps:java要1.8以上。</p><ul><li><b>3.1： 解压示例文件：</b></li></ul><p>         你会看到一个包文件夹(binaries),一个源码文件夹(sources),一个windows批处理命令文件(runExamples.bat)和一个Linux下运行示例的Shell文件　　　　　　(runExamples.sh). 因为我是在Windows环境下运行的，所以把binaries和runExamples.bat解压出来放在同一文件夹即可，examples子文件夹中的目录结构如下图。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-48de2ca569e80b4e4cdcd7ab9bb5b8e4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"265\" class=\"origin_image zh-lightbox-thumb\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-48de2ca569e80b4e4cdcd7ab9bb5b8e4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;685&#39; height=&#39;265&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"685\" data-rawheight=\"265\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"685\" data-original=\"https://pic1.zhimg.com/v2-48de2ca569e80b4e4cdcd7ab9bb5b8e4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-48de2ca569e80b4e4cdcd7ab9bb5b8e4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li><b>3.2 运行示例:</b></li></ul><p>          如果windows下使用cmd不太熟悉的话，就按我下面的步骤操作.完成之后就可以看到它示例的真容了。示例程序是基于Swing做的，理论上通过里面的批处理文件就可以运行起来，其实里面就是一些运行jar包的命令,只不过它会有更多的功能，例如检查当前系统的JRE等等。不过中间有点小插曲，我使用7.6.0的示例运行的时候，它报了一个slf4j找不到的异常，应该是一个日志组件缺少了，我要看看它这个版本的更新记录，看是否有相关的提示，否则我得联系一下他们项目组的人才行。后来我用7.5.0Final的示例可以正常运行起来了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9d12d3fdd0fbd020daaabdc0135a4d8a_b.jpg\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb\" width=\"542\" data-original=\"https://pic3.zhimg.com/v2-9d12d3fdd0fbd020daaabdc0135a4d8a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;542&#39; height=&#39;486&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"486\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"542\" data-original=\"https://pic3.zhimg.com/v2-9d12d3fdd0fbd020daaabdc0135a4d8a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9d12d3fdd0fbd020daaabdc0135a4d8a_b.jpg\"/><figcaption>通过鼠标右键调出CMD</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9ecb0fcf99ed8543a5a10d0ecbdec617_b.jpg\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"95\" class=\"content_image\" width=\"380\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;380&#39; height=&#39;95&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"380\" data-rawheight=\"95\" class=\"content_image lazy\" width=\"380\" data-actualsrc=\"https://pic4.zhimg.com/v2-9ecb0fcf99ed8543a5a10d0ecbdec617_b.jpg\"/><figcaption>运行示例批处理文件</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b7bd4c98b8bb0ab3ab01d477a7536d9d_b.jpg\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"832\" class=\"origin_image zh-lightbox-thumb\" width=\"910\" data-original=\"https://pic2.zhimg.com/v2-b7bd4c98b8bb0ab3ab01d477a7536d9d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;910&#39; height=&#39;832&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"910\" data-rawheight=\"832\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"910\" data-original=\"https://pic2.zhimg.com/v2-b7bd4c98b8bb0ab3ab01d477a7536d9d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b7bd4c98b8bb0ab3ab01d477a7536d9d_b.jpg\"/><figcaption>多达18个示例，最简单的N王后问题，到复杂的车辆路线规划问题.</figcaption></figure><p>       7.5.0版本提供了18个示例，已经 包含了几乎所有Optaplanner规划引擎具有的特性及应用模式。但其实在他们的Github中提供了更多的示例，有兴趣的同学可以关注一下Github上optaplanner项目的leader Geoffrey De Smit，他现在是Optaplanner项目的头儿，也是Optaplanner的作者，10多年前他开发了Optaplanner，前些年他把它贡献给了JBoss开源社区，任这个项目的头儿。我在使用Optaplanner做项目的时候，他们的讨论组上向他提过一些问题，他为人相当nice且有耐心，给我解答了不少问题。</p><ul><li><b>3.3 运行示例：</b></li></ul><p>    　我们选择一个比较经典的Cloud balancing示例运行一下看看。</p><p>        先说明一下这个示例，这个示例是模拟在云端进行进程管理（或称进程调度，或称任务调度吧），也就是进程分配到不同的计算资源（也就是计算机）的方案，演示Optaplanner规划引擎是如何在保证每个进程都满足运行要求的情况下，以最节省成本的方式分配计算机资源的。</p><p>        示例中有两个主要实体概念 - 进程(Process，下面跟着官方文档称Process吧, 可以理解为我们的程序，或任务)和Computer(也就是我们理解的计算机、服务器了)。每个Process有CPU速度,内存大小和网络带宽三大要求。对应地，每台Computer也有一个固定的参数，表明该Computer可提供的CPU速度、内存大小和带宽；Computer另外还有一个属性就是成本。也就是这台电脑一但被使用了，就需要花费成本去维护。这个示例的目标是：给出一些Process和一些Computer，Optaplanner规划引擎在对这些实体进行对比运算，将所有Process分配到指定的一台Computer, 这个分配方案有两个要求：</p><p><b>1.硬性要求</b>： Process所分配到的Computer必然满足CPU，内存和带宽三大要求要求。ps:当多个Process被分配到同一个Computer时，它的CPU，内存和带宽资源占用是累加的，也就是说，当台Computer只有2G内存，若已经有一个内存需求是1G的Process被分配在它上面，那后面可以再分配给它的Process，其内存要求必然是1G以下的，因为这这台Computer还只剩下1G内存了，CPU和带宽也是同样的分配规则。</p><p><b>2. 软性要求</b>：任何一台Computer一旦有任务分配进去，即表示该Computer被占用，需计算这台Computer的成本。Optaplanner规划引擎需要找找出一个方案，在满足了第1点的硬性要求的前提下，令到这所有被占用的Computer的成本加起来尽量小(为什么不能说最小呢？因为这是一个NPC问题，不一定可以找到成本最小的，也就是 说不一定能找到最佳方案的，详情参考本系列文章中，关于规则问题与NP, NPC问题的篇章).</p><p>　　下图是我进入这个示例后，选择了9个Processes分配到3台Computers上的示例。Optaplanner的示例程序都提供这些示例的相关数据，只要选择就可以了，所以还是比较贴心的，但我们自己做项目过程中，去生成、处理这些数据的工作量，就占了系统的不少比例了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-74c20371bd190c56232b3483eafa4ee3_b.jpg\" data-size=\"normal\" data-rawwidth=\"1147\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"1147\" data-original=\"https://pic4.zhimg.com/v2-74c20371bd190c56232b3483eafa4ee3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1147&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1147\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1147\" data-original=\"https://pic4.zhimg.com/v2-74c20371bd190c56232b3483eafa4ee3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-74c20371bd190c56232b3483eafa4ee3_b.jpg\"/><figcaption>Cloud balancing示例中Process与Computer信息</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-db6dc54a92c8bcdffd1db9a6816c113d_b.jpg\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-db6dc54a92c8bcdffd1db9a6816c113d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;818&#39; height=&#39;499&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"818\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"818\" data-original=\"https://pic2.zhimg.com/v2-db6dc54a92c8bcdffd1db9a6816c113d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-db6dc54a92c8bcdffd1db9a6816c113d_b.jpg\"/><figcaption>每个Process对计算资源的要求</figcaption></figure><ul><li><b>3.4. 运行并解读示例：</b></li></ul><p>         点击顶端的Solve按钮，引擎就开始工作，它会不断尝试不同的组合方案（这是一个非常复杂的过程，涉及到各种搜索算法Tabu，模拟退火等），找到既满足Process对CPU、内存和带宽的要求，且所使用的所有Computer中，成本加起来尽量小。下面就是运行了一段时间之后，9个Process分配到了两个Computer的情况。所得的方案的好坏，是通过评分来实现的，关于评分，可以查看后面Optaplanner规划引擎关于分数方面的文章。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f6b90e28abf17b534b9fb9017d38ae30_b.jpg\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb\" width=\"1023\" data-original=\"https://pic1.zhimg.com/v2-f6b90e28abf17b534b9fb9017d38ae30_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1023&#39; height=&#39;437&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"1023\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1023\" data-original=\"https://pic1.zhimg.com/v2-f6b90e28abf17b534b9fb9017d38ae30_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f6b90e28abf17b534b9fb9017d38ae30_b.jpg\"/><figcaption>运行结果，以硬分数(反映资源敏合度)和软分数(反映成本)组成。</figcaption></figure><p>　　好了，到目前为止我们已经成功能运行起了它的示例，大家也可以尝试一下其它示例，各个示例的背景，可以到<a href=\"https://link.zhihu.com/?target=https%3A//docs.optaplanner.org/7.6.0.Final/optaplanner-docs/html_single/index.html%23useCasesAndExamples\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Optaplanner官网关于示例的章节</a>中查看。我在后面的文章中，也会找几个具代表性的示例进行翻译。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>     在下一篇，我们就要用这个示例的源码生成Eclipse中项目，好让大家可以更深入具体了解Optaplanner的实现。</p><p>谢谢。</p><p>End.</p><a href=\"https://link.zhihu.com/?target=https%3A//www.optaplanner.org/localized/zh/index.html\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-b8bfd44299e21d015908c830a2fae24a_ipico.jpg\" data-image-width=\"256\" data-image-height=\"256\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">约束求解器 (Java ™, Open Source)</a><p><b>本系列文章在公众号不定时连载，请关注公众号（搜“让APS成为可能”或扫以下QR Code）及时接收,二维码：</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b5be1dcef8f861e65b2ad8325990d19e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"378\" data-rawheight=\"384\" class=\"content_image\" width=\"378\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;378&#39; height=&#39;384&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"378\" data-rawheight=\"384\" class=\"content_image lazy\" width=\"378\" data-actualsrc=\"https://pic3.zhimg.com/v2-b5be1dcef8f861e65b2ad8325990d19e_b.jpg\"/></figure><p><b>如需了解更多关于Optaplanner的应用，请发电邮致：<a href=\"mailto:kentbill@gmail.com\">kentbill@gmail.com</a></b><br/><b>或到讨论组发表你的意见：</b><i><a href=\"https://link.zhihu.com/?target=https%3A//groups.google.com/forum/%23%21forum/optaplanner-cn\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">groups.google.com/forum</span><span class=\"invisible\">/#!forum/optaplanner-cn</span><span class=\"ellipsis\"></span></a></i><br/><b>若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)</b></p>", 
            "topic": [
                {
                    "tag": "开源软件", 
                    "tagLink": "https://api.zhihu.com/topics/19552811"
                }, 
                {
                    "tag": "人工智能", 
                    "tagLink": "https://api.zhihu.com/topics/19551275"
                }, 
                {
                    "tag": "运筹学", 
                    "tagLink": "https://api.zhihu.com/topics/19634329"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/52688959", 
            "userName": "winstartgd", 
            "userLink": "https://www.zhihu.com/people/52d34e887ba97a0ebb8fb2367fe899cf", 
            "upvote": 1, 
            "title": "如何选入户智能锁？", 
            "content": "<p>指纹密码锁由于具有安全、便利、快捷等优点，使其越来越受到业主欢迎。那么一把合格或者说及格的入户门锁的标准是什么呢？当然就是安全防盗了，就是这最简单的标准市面上部分厂家并没有达标，所以如何选购高品质的指纹密码锁就成了一个难题，下面和你分享选购指纹密码锁的秘诀。</p><p><b>一、安全性</b></p><p>无论是什么锁，第一要务就是防盗。智能锁的目的决不能偏离于此。目前一些厂商试图抛弃传统机械锁芯，改用全自动的开关。这样的做法并不值得提倡。我们永远无法预测电子功能的会在什么时候失效，机械锁芯是给紧急情况一个应急保护，但是应急锁安全级别不够高，就会被小偷从应急锁直接技术开启，你的指纹和密码就是个摆设。</p><p> 那么我们来看一把入户门锁的及格标准线（按重要程度）。</p><p><b>1、锁芯：</b>锁芯（或者说钥匙）是检验一把入户门锁是否及格的最明显的部分。现在公安部标准有A/B二种级别,现在网络和部分实体商家在宣传上喜欢用超B级甚至C级标准这一概念，这只是商家对自己产品远远超出国标的一种自我标榜行为。</p><p>锁芯的精密度结构决定了锁芯的安全性能，福维尔FULL WELL智能锁机械部分所用锁芯全部来自奥地利原装进口EVVA锁芯，品牌创建于1919年，拥有欧洲顶级防盗技术水平，EVVA高级别锁芯的高精密度，配合高精加工的钥匙等硬部件，具有防暴力、防技术开启、钥匙不可复制等特点。</p><p><b>2、锁体：</b>锁体相当于人的心脏，是最核心的部分，每天开关门锁体摩擦非常厉害，坚固耐磨防撬才是标准的锁体，福维尔FULL WELL指纹密码锁锁体采用的是国家最好6068标准锁体，304不锈钢锁舍具有防锈、防撬的作用，具备公安部出具的防盗检测报告，有防火、防盗、双快逃生的功能，适用各种入户门。</p><p><b>3、底板：</b>底板分为门内门外两部分组合而成，如果太薄容易被工具暴力开启，福维尔FULL WELL智能锁防撬底板采用16MnCr5材料制成，并通过真空热处理方式使其达到洛氏硬度53至55度，能够抵御金刚钻头的破坏，有效防止锁具被暴力破坏，此设计获得了国家专利证书，专利号为:ZL201620643768.5。</p><p><b>4、保护盖：</b>锁芯保护盖能将锁芯完好无缺地包在盖内，防止锁芯上的钥匙孔被异物塞入等有效防止暴力工具接触，福维尔FULL WELL智能锁有自适应可浮动调节的5MM范围锁芯保护盖，能适用于不同厚度的门，兼容性强，此设计获得了国家专利证书，专利号为:ZL201620641632.0。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p><b>二、外观</b></p><p>指纹密码锁的制作材料主要分为三种，分别是锌合金、铜、不锈钢。其中，锌合金的耐用性、防火、防锈、防爆性能最差，铜次之，不锈钢最佳。福维尔指纹密码锁选的是不锈钢材质，用户最好选择不锈钢指纹密码锁，且需记住“一看，二敲，三掂”的选购字诀。</p><p>一看：看外表。三种材质的智能锁在外表看来几乎没有多大的差别，这得益于现代高超的电镀技术，将不同的材质电镀得外观几乎和金属相似。锌合金的表面较为光滑，色泽艳丽，而铜稍微粗糙和亚色一点，不锈钢材质较为均匀，不锈钢以304不锈钢为标准。</p><p>二敲：如果很难“看“出智能锁材质，我们可以用“敲“加以判断。用手指轻轻敲锁体的侧边(正面由于触摸屏等不同材质的构件不好判断)，铜合金声音比较清亮，铜硬度小，敲击的声音相对沉闷一些，不锈钢智能锁敲击起来声音比较尖锐集中，没有太大的扩散感，穿透力比较好。</p><p>三掂：不锈钢门锁、锌合金门锁、都没有全铜制造的重，能从手感上明显感受出来，但是铜中含有铅，不锈钢最环保。</p><p><b>三、便利性</b></p><p>现众多品牌，声称很多的功能特点，重要是那些功能与方便、稳定相关度并不大，很多功能未有统一的标准，锁具的首要作用是具备足够的防护性能以保证个人和财产的安全，而锁具走向信息化、智能化的最终目的，是提供给消费者更为人性化的便捷服务，我们的智能锁设有经过一次解锁解除电子锁止部分，再通过把手带动锁栓联动实现二次解锁，能够降低锁具开启所需耗能，电源耐用性更持久；指纹识别设置L型把手的转轴部位，以便于手掌握持的把柄部，使用正常开门的手势，大拇指贴合锁轴就能直接实现识别指纹，此设计已获得国家专利证书。</p><p>1、测试指纹：测试开锁的反应速度及精准度，分辨率越高，辨识越精准，反应越快，安全性也越好。我们的智能锁采用的是华为P9的3D指纹识别技术，能从四个不同的维度捕捉指纹特征，可以有效的鉴别假指纹，保障用户指纹锁安全，跟普通指纹识别比起来，准确率更高，速度也更快，安全系数更加高。</p><p>2、密码功能：主要看支持的密码长度是多少（太短容易破解太长容易忘记），以及支不支持智能密码编排（可以输入一长串数字，只要其中包含有密码就可以开锁）等“防窥视”功能。</p><p>3、安装方面：通用性应当适用国内大部分的防盗门（符合2008版防盗门国家标准），更换原有门的门锁，改装工作应尽量少。好的指纹锁安装时间应不高于30分钟。否则用户一般难以自己完成安装与维护。我们的锁能适配市面上95%的门，可私人定制，免费上门测量安装，常用的有入户防盗不锈钢门、木门、别墅门等。</p><p>总结，智能锁不是越贵越好，也不是功能越多越好，真正在买智能锁的时候，适合需求为目的，应该重点关注“安全性、稳定性、实用性和智能性”。</p>", 
            "topic": [
                {
                    "tag": "智能锁", 
                    "tagLink": "https://api.zhihu.com/topics/19668468"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/50481894", 
            "userName": "亿网管家", 
            "userLink": "https://www.zhihu.com/people/637151f0c96fe33bade577a65278bf36", 
            "upvote": 2, 
            "title": "怎样建设适合自己企业网站", 
            "content": "<p>近些年来很多创业者 都在通过联网平台 开辟自己道路，怎样才能让更多人知道您发展道路呢，现在很多人首先选择网站开发，建立自己企业形象，让更多人通过网站形式展示公司，展示企业发展前景和未来发展道路。。。</p><p>  首先创业考虑资金问题 在前期资金紧张、人力缺乏的情况下，很难去建设一个高速、稳定、美观的产品网站。现在很多创业者选择了模板建站或是原有现成系统上改进 把自己企业文化和需求编辑到现有程序里面 这样大大减少成本控制 而且在技术方面不用有太多顾虑，原有系统已经运营很长时间 系统已经经历市场磨合有些BUG都已经解决掉了 省去新建网站带来不必要问题。。</p><p>传统网站建设,我们来说说：</p><p>在搭建网站的过程中我们会遇到各种各样问题，首先客户企业文化，了解企业文化才能根据企业性质设计界面，图片设计颜色等。。企业需要哪些功能，在功能方面根据市场需求做改变，</p><p><b>项目介绍</b></p><p>2017年某一天 我接网站搭建单，这个不是普通企业展示网站，客户想做相亲交友网站，功能型而且还有个性加美观 客户稍要求很高，他为这个交友网 也是很认真的对同行业网站考察很久，怎么说很久呢 ，在聊天过程他说 对这个交友行业了解5年时间了  当时我一听 觉得老兄肯定只是 还没有下定决心要做这块呀，说实在的 真的要做事的人 肯定不会考察那么久迟迟不行动  我对着单子很是怀疑，不过我还是很专业跟他进行长时间沟通，把他需求整理一遍，做了方案和思维导图，在这个设计过程中 这个客户在网站修改方面真是不断改进 不断变化 有时候晚上很晚还会跟我交流，在接下来一周左右我们改了很多次，他想法很多，他想把很多功能都实现，我问他咱们预算多少  首先 我们建议都是从简再根据市场需求增加功能模块，基本上遇到很多客户都会遇到这样问题 想法很多 网站做的很丰满什么功能都齐全了 结果真正上线运行了才知道很多功能其实用不到的，网站承载量大 运行成本肯定高，不必要增加网站成本，我建议客户，初创业企业先根据市场需求 ，搭建核心功能，待企业运行好了，再根据市场需求增加功能模块，这样避免不必要费用支出..最终这个单子我谈下来了。</p><p> 这个客户给了我很多启发 很多初创业客户或者是资金紧张客户 他们也在运行着现有网站在使用 但是大家知道，网站这个东西 会跟着互联网时代发展也要不断变化才....</p><a href=\"https://link.zhihu.com/?target=http%3A//bottlecms.ewgj.cn\" data-draft-node=\"block\" data-draft-type=\"link-card\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">瓶子（BottleCMS）</a><p>瓶子交友系统（BottleCMS）是一套基于PHP+MYSQL为核心开发、免费 + 开源的专业交友系统。系统具执行效率高、模板自由切换、后台管理功能灵活等诸多优秀特点</p><p>1.100%开源 源码全部开发，二次开发无障碍。</p><p>2.可定制 一种尺寸无法匹配所有人！定制您专属的功能。</p><p>3.模块按需组合 插件模块按需下载，任意组合</p><p>4.安全更新轻松及时更新，而无需投入高昂的成本。</p><p>5.丰富的模板 提供多套模版，任何审美观总有一款适合你</p><p>6.Laravel框架 基于laravel框架开发安全高效！</p><p>免费体验,演示:</p><p><a href=\"https://link.zhihu.com/?target=http%3A//jy.demo.bottlecms.ewgj.cn/m\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">jy.demo.bottlecms.ewgj.cn</span><span class=\"invisible\">/m</span><span class=\"ellipsis\"></span></a> (二维码自动识别)</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><br/> </p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "企业", 
                    "tagLink": "https://api.zhihu.com/topics/19559687"
                }, 
                {
                    "tag": "企业管理", 
                    "tagLink": "https://api.zhihu.com/topics/19559804"
                }, 
                {
                    "tag": "CMS", 
                    "tagLink": "https://api.zhihu.com/topics/19571403"
                }
            ], 
            "comments": [
                {
                    "userName": "陈曦", 
                    "userLink": "https://www.zhihu.com/people/e6feca022ecb6ab69adddabab88b318c", 
                    "content": "刚刚看到写的不错 ，期待与您学习😊", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/48425966", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 3, 
            "title": "软件开发工程师必经之路~软件代码的合理性、健壮性、可扩展性、兼容性", 
            "content": "<p>当一个软件开发工程师在拿着需求去编写代码的时候，只关注代码接口是否自测可通，达到基本满足的需求就完事了，那这样的软件开发工程师是不合格的，也可以说还没真正入门软件开发大军。真的的软件工程师在编写他的代码时会想清楚几个问题，那就是今天要讲的主题，代码是否合理性，健壮性，可扩展性，接下来我会一一阐述这些观点重要性！</p><p>合理性，这个对于需求来讲，并不冲突！他主要分两种情况:</p><p>第一种情况:</p><p>就是需求本身的不合理性。在需求设计的时候没有评估好，跟实际业务场景有出入！到后面又去推翻！这是常有的事，在随着项目进度和深度的推进，这是正常的，因为人不可能一开始就把需求一步分析到位！</p><p>第二种情况:</p><p>有时候需求在代码里实现了，也能正常跑通，但是到复杂的情况没考虑到。这个也跟实际场景有关，因为有些场景不好模拟和复现(在测试的过程中)。打个比方，有人用分页去把list集合从数据库拿出来封装成page对象，那么这个页数和页尺寸需要自己合理设计，设计过大影响性能，你会发现前端运行很久，还不一定出数据，这是对通用查询方法分页弊端一个阐述，有时候我们需要查询到所有数据，再按一定规则排序组合，这时候这种方法真不好用，它只返回分页内的数据，其他的给省略掉了，虽然他能提高大数据中搜索查询数据的性能，但也只是随机的！它的应用场景主要是查询条件多，而且某些条件属性具有唯一性，或者说具有这个属性的数据不是很多条！所以通用查询是针对有条件的查询，条件越充分，越有利于查询到数据！所以实际场景要求不同，就要考虑到这个代码层次的方法是不是可行！</p><p>健壮性，这个话题有的说了，我就说说一些比较常见的列子！</p><p>1、有些代码、接口、模块功能，可能在少数用户需求的时候，用起来可能不会出啥问题，一旦用户多起来，使用的频率高了，刚好很多人在同一时间都去访问同一模块或者接口，这时候有个问题就是访问连接资源有限，不可能同时分给那么多人，这时候高并发考验接口的时候就到了！在开发的时候就没想到后面会有很多用户去访问这个接口的时候，那是不完善的代码！这是代码层面！</p><p>2、接下来说的是需求方面的健壮性，有些需求可能在代码开发的时候，没有出现，也跟当时的业务场景有关，等到时机成熟，有些需求慢慢觉得需要了，应该考虑进代码里，这时候怎样让自己代码在尽可能少的改动或者不改动(让前端去添加一些页面元素)，就可以让这个需求兼容进来，这种健壮性代码极大的减少后期的成本！当然这也是代码里最难实现的一点，有时候在当时情况下，根据业务需求，就事论事是好的，可能想出的一些其他兼容需求后期用不到，但是代码又冗余了(情况差的话，后面可能要返工)，所以要合理取舍，不要一味地去追求代码健壮性！适度最可，就像我中华五千年的一句经典语录&#34;中庸者佳&#34;就是不要往两极端走，保持中间是最好的了！</p><p>可扩展性这个简单说下，因为跟健壮性有交叉的地方！</p><p>常常我们听到行业开发人员总是说的一句话就是，&#34;这个人的代码写死了，不好去改&#34;，这种困扰涉及到各行各业的开发，既然存在，那就是合理的，既然当时写死，那是因为当时的业务场景只容许他这样做。后面条件充足了，由你开发的时候这块代码有更好的实现途径，你肯定这么说了！世事无绝对啊！</p><p>接下来说说兼容性！</p><p>典型的列子就是手机应用端app的兼容，不像网页版，手机app要考虑老系统和新系统，有的用户去应用市场下载的app，后面经过几次更新版本，那个就是老版本了，但是又不能强制要求用户去更新版本，这时候代码更新或者动接口参数就要考虑兼容性了，不然和前端协商代码更改，这次新的版本是可以正常使用，但是老版本访问你后台接口就会报异常(因为后台代码不分版本，只有前端app打包分版本)，它这个情况不像网页，用户没下载，只是要去访问的时候打开网页去输入网址访问，我一修改，他后面访问肯定是我修改的！所以前后兼容要考虑到！</p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/45423151", 
            "userName": "劳累的前端程序员", 
            "userLink": "https://www.zhihu.com/people/d122a2c7f2725621743d7438a30ec629", 
            "upvote": 1, 
            "title": "微服务进展缓慢的 5 个难点", 
            "content": "<h2><b>前言</b></h2><p>笔者从2013年加入ThoughtWorks至今共4年时间。在这4年时间里，我分别以开发人员、DevOps工程师、DevOps咨询师、微服务架构师以及微服务咨询师的角色参与了共计7个产品和项目的微服务咨询和实施。其中有成功，有失败，有反思，更多的是学习和总结。以下是我这些年来在微服务咨询上的经验总结，希望能给陷入微服务实施困境的人带来一些帮助。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1df861c24669d4065e284ab1a179f1fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"680\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-1df861c24669d4065e284ab1a179f1fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;680&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"680\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-1df861c24669d4065e284ab1a179f1fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1df861c24669d4065e284ab1a179f1fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>难点1：“一步到位”的认知错觉</b></h2><p>这些年微服务大红大紫，但是真正能够拿出来做为可实践案例的少之又少。大部分的微服务案例只能看到微服务架构的“演进结果”，但是看不到其“演进过程”。这就像每个人可以看到一个架构的高峰，却看不到攀登高峰的路径。</p><p>这就造成了一个假象：微服务的架构是通过能力极高的架构师一步到位设计出来的。</p><p>这和很多团队自上而下的架构设计感受很相似。于是架构师们蜂拥而至，各种分析方法论层出不穷，讨论和分享络绎不绝。然而真正落地实施的却很少，使得微服务在网络上慢慢变成了一种“玄学”：微服务的实施一直在“理论研究”的阶段。</p><p>这违反了软件架构的最基本规律：架构是通过解决当前的需求和痛点而演进的，无法根据没有出现的问题和痛点进行设计。因此，一步到位的、整体的微服务架构设计完全没有必要。况且一个集中化的设计，很难体现微服务的轻量级优势。</p><p>我相信技术一定是向不断降低成本的方向发展的。如果新技术没有降低成本反而提升了成本，要么这个新技术有问题，要么是姿势不对、走错了路。</p><p>因此，准备实施微服务一定要有一个长期的思想准备。不过跨过了最初的门槛之后，剩下的工作可以被复制、而且速度会越来越快。</p><h2><b>难点2：“架构师精英主义”</b></h2><p>很多产品对架构师的依赖很大，即“架构师精英主义”：认为只有这个组织的“技术精英”——架构师才可以完成该产品的架构，而团队其它成员只需要实现架构师的设计就可以。这是大型企业和大型系统的常见问题，来源于长期以来重量级企业级架构的习惯。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eacb14cf3c20671fb34661d9b53892a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic4.zhimg.com/v2-eacb14cf3c20671fb34661d9b53892a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;602&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"602\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic4.zhimg.com/v2-eacb14cf3c20671fb34661d9b53892a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eacb14cf3c20671fb34661d9b53892a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>而微服务则类似于一种“敏捷边际革命”：即由一个不超过2~8个人的小团队就可以完成的轻量级架构。而且对于这种规模的团队而言，即使把整个微服务团队从产品团队移除也不会对整体产品的研发进度产生影响。因此，即使失败了也不会带来太多的损失。不过，当第一个微服务改造成功，那么成功经验的复制带来的乘数效应却能带来很大的收益。</p><p>从架构改造投资的风险收益比来看，这是非常划算的。</p><p>因此，微服务团队完全没必要大张旗鼓，只需要两三个人就可以动工。但是，谁也没有微服务的实践经验啊，万一失败了怎么办？</p><p>这就带来了下一个难点。</p><h2><b>难点3：缺乏一个信任并鼓励创新的环境</b></h2><p>面对未知的领域，失败再所难免。而处在这个不确定性频发的世界，成功和失败已经不再重要：也许今天的失败，明天再看就是成功，反之亦然。</p><p>成功只是表明结果符合自己的假设预期，而失败仅仅意味着结果不符合自己的假设预期。但是无论成败，我们都能在行动的过程中有所学习和反思，而这样的经验才是研发活动中最有价值的。</p><p>然而，很多组织，尤其“精英主义”的产品团队，责任和压力往往从上至下分解。由于组织庞大，金字塔的结构往往会构建一种以“不信任”为基础的制度。这种制度营造了一种“宁可不作为，也不能犯错”的文化。由于上层需要对失败负责，使得所有创新只能停留在上层，难以落实推进。在这种情况下，组织的长期合作形成了稳定的工作习惯和思维定势，并形成了利益平衡，这会使得整个组织在面对创新的时候“卡壳”。</p><p>当微服务以一种政治任务从上而下派发的时候，为了避免失败，团队内部会相互推诿。通过不断的分析讨论和设计来论证这个事情的难度。在我看来，只要想搞，就一定能找到办法，而不是先设想出一堆还没有遇到的问题和责任。在行进中解决问题是比设计和讨论更加有效率的方法。</p><p>而组织解决“卡壳”的办法就是引入“背锅侠”：例如新聘请的架构师或外部咨询师，来完成这个事情。出了问题就不用自己来承担责任了。这样虽然是解决问题的一种折中办法，可以让事情毫无风险的执行下去。但这是一种短期效应，无法解决组织本身的创新窘境，长期依赖外部力量来解决最有价值的问题不会让自己提升，反而形成了对外部力量的依赖。对于凝聚组织来说不是一件好事。</p><p>只有打破当前的工作习惯和思维定势，充分认识到创新的困难、风险以及价值，才可以占领创新的高点，吸引人才。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-fd3bed7d468a8843e12c636596dcc5c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-fd3bed7d468a8843e12c636596dcc5c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;592&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"592\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic3.zhimg.com/v2-fd3bed7d468a8843e12c636596dcc5c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-fd3bed7d468a8843e12c636596dcc5c6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>难点4：微服务技术栈的“选择困难症”</b></h2><p>由于“精英主义”的架构师需要担负很大的责任和压力。他们必须要为微服务架构谨慎的选择技术栈。因此会在不同的技术栈之间不断尝试。对于习惯了在大型研发组织里“精心设计，加班生产 ”的架构师而言。“长设计，慢反馈”节奏似乎是理所应当的。</p><p>微服务开源社区的快速发展滋长了“架构师焦虑”：如果采用落后的技术会被同行鄙视，被不懂技术的老板鄙视，甚至被下属鄙视。因此架构师们疲于在各种新型的技术栈之间比较和学习。此外，不熟悉技术往往会增大风险，架构师就需要更多的时间研究。带着“一步到位”的架构幻想对微服务技术栈精挑细选，而不会采用现有低成本的方案快速迭代的解决问题。</p><p>微服务的核心在于采用“小规模，快反馈”的机制降低软件系统的复杂性并通过虚拟和自动化技术分散风险，从而及时应对市场变化带来的各种挑战、进行快速销售创新，获得市场的反馈。而不仅仅是利用到了时下新兴的语言，编程框架或工具。</p><p>学习和实践是相辅相成的过程，在实践中学习，并把学习到的知识应用到实践中。这不同于准备一场考试：先停下来学习，准备好了再全力以赴。</p><p>以上四点会让大型组织在微服务实施中“卡壳”，这往往会导致微服务实施忽略最重要一点，也是我认为也是核心的一点。</p><h2><b>难点5：对微服务的技术变革预估过高，而对微服务带来的组织变革预估不足</b></h2><p>作为架构师，永远要不要低估康威定理的威力：“设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。”</p><p>从制度经济学角度来讲，软件产品本身就是企业内部组织（员工）和外部组织（用户）沟通制度的计算机程序表达。这个制度一定会朝着缩短组织内外部沟通成本的方向发展。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-057dfec4d37e85cf61dd287cf8432308_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"663\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-057dfec4d37e85cf61dd287cf8432308_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1024&#39; height=&#39;663&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1024\" data-rawheight=\"663\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1024\" data-original=\"https://pic1.zhimg.com/v2-057dfec4d37e85cf61dd287cf8432308_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-057dfec4d37e85cf61dd287cf8432308_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，系统架构一定是和组织架构相吻合的，如果不吻合，势必会阻碍组织的渐进。</p><p>这就引出了一个推论：如果企业组织的架构不是唯一的，那么微服务的架构方案也不是唯一的。</p><p>当架构和组织结构相一致的时候，一切都会很顺畅。反之，就会出现各种问题。</p><p>这个关系就像鞋和脚的关系，只有穿上合适的鞋，走起路来才会舒服。过大过小的鞋都无法让你加快前进的步伐。当然，你可以选择买鞋（引入产品），虽然并不是很合脚，但还可以凑合穿，只是在换鞋的时候你不得不停下来试。你也可以花高价为自己定制一套，这个不会让你在短时间内走得更快，只会越来越合脚。</p><p>如果所有人穿上了新鞋，都能跑得很快，只有你不能，那么这就不是鞋的问题，而是你脚的问题，这就不是换鞋能解决的了。你得先把脚的问题解决了，然后再看鞋的问题。当然，也可以通过鞋来矫正脚，只不过会花些功夫，但一定会比不停的换鞋更加有效。</p><p>很不幸，大多数的组织并没有准备好迎接微服务架构带来的组织变化。仍然把“系统架构问题”和“组织问题”割裂成两个不同领域的问题：微服务是技术问题，组织问题是管理问题。</p><p>有竞争力的组织，是能够通过融合优势达到1+1&gt;2效果的组织。而不是把优势割裂开，让1+1&lt;=2的组织。因此，技术问题和管理问题并不是两个问题，而是同一个问题的两个侧面。</p><p>因此，如果你的组织结构是去中心化的小团队结构，那么不用担心，你的应用架构会朝组织架构的方向演进。反之，如果你不是一个去中心化的小团队结构，那么微服务的架构会和组织架构格格不入。</p><h2><b>如何解决这些问题？</b></h2><p>作为微服务的实践者，对微服务不应该是“叶公好龙”，仅仅停留在研讨的层面。而应该采用敏捷和精益的方式迅速开始，在行进中解决碰到的问题。每个组织的组织结构和业务结构都有所不同，微服务实施所面对的挑战也截然不同。在实施的过程中快速学习并改进，没有必要进行周期较长的总体设计。</p>", 
            "topic": [
                {
                    "tag": "微服务架构", 
                    "tagLink": "https://api.zhihu.com/topics/20023491"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/43029393", 
            "userName": "彳亍的骆驼", 
            "userLink": "https://www.zhihu.com/people/06ebdad76e0fb623fd89b4af86839f45", 
            "upvote": 1, 
            "title": "关于Git的一些读书笔记", 
            "content": "<p>git基础操作</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>建立本地库</h2><p>//建立本地仓库文件夹toolRepository</p><div class=\"highlight\"><pre><code class=\"language-text\">$mkdir toolRepository</code></pre></div><p>//进入文件夹运行初始化命令</p><div class=\"highlight\"><pre><code class=\"language-text\">$ cd toolRepository\n$ git init</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>Initialized empty Git repository in /Users/michael/learngit/.git/</p><p>注：当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，不要手动修改这个目录里面的文件。</p><h2>添加文件至本地库</h2><p>仓库建立好后，先本地库中添加文件，在toolRepository目录中新建文件或者将要添加的文件复制到目录下。</p><p>文件两步提交法</p><p>1.执行git命令将文件添加到本地库中</p><div class=\"highlight\"><pre><code class=\"language-text\">$ git add readme.txt</code></pre></div><p>2.将文件提交到本地库中</p><div class=\"highlight\"><pre><code class=\"language-text\">$ git commit -m &#34;wrote a readme file&#34;     </code></pre></div><p>   -m后面输入的是本次提交的说明，可以输入任意内容</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么Git添加文件需要add，commit一共两步呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>       因为commit可以一次提交很多文件，所以你可以多次add不同的文件</p><p> 例如：</p><div class=\"highlight\"><pre><code class=\"language-text\">               $ git add file1.txt\n               $ git add file2.txt file3.txt\n               $ git commit -m &#34;add 3 files.&#34;</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>辅助命令</b></p><div class=\"highlight\"><pre><code class=\"language-text\">       git status</code></pre></div><p>                       命令可以让我们时刻掌握仓库当前的状态。</p><div class=\"highlight\"><pre><code class=\"language-text\">       git diff</code></pre></div><p>                       显示文件中修改位置。注意：默认比较的时本地工作区和暂存区内容。</p><div class=\"highlight\"><pre><code class=\"language-text\">       git diff HEAD</code></pre></div><p>                       如果想工作区和版本库内容比较，可以使用</p><div class=\"highlight\"><pre><code class=\"language-text\">       git diff --cached</code></pre></div><p>                               暂存区和版本库内容比较</p><p>       两个命令配合使用，如果git status告诉你有文件被修改过，用git diff可以查看修改内容</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>回滚工作区</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">       git checkout -- fileName 或   git checkout .</code></pre></div><p>使用暂存区文件替换工作区文件。撤销工作区中没有提交的修改【危险】</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>回滚暂存区文件</b></p><div class=\"highlight\"><pre><code class=\"language-text\">      git rm --cached  errorfileName</code></pre></div><p>      git reset HEAD 暂存区会被版本库覆盖，但是工作区不受影响。可以用作回滚暂存区操作，等价与git add fileName反向操作</p><p class=\"ztext-empty-paragraph\"><br/></p><p>      git reset HEAD^ 工作区不改变，暂存区会回退到上一次提交之前，引用也回退一次。比上面命令比，暂存区向后退了一步</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>回滚工作区和暂存区</b></p><p>      git checkout HEAD . 或者 git checkout HEAD fileName 使用版本库中所有文件或指定文件替换暂存区和工作区文件【危险】</p><p>      git checkout branch -- fileName</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>修改提交说明</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>1.修改最新提交说明：</p><div class=\"highlight\"><pre><code class=\"language-text\">       git commit --amend   //进入编辑页面，修改提交说明，直到满意为止</code></pre></div><p>2.修改某历史提交说明</p><div class=\"highlight\"><pre><code class=\"language-text\">       git rebase -i &lt;commit-id&gt;~\n        git rebase -i</code></pre></div><p>可以合并commit提交</p><div class=\"highlight\"><pre><code class=\"language-text\">        git rebase -i HEAD^3 //合并最近3次提交注释， 忽略那个提交，将那个pick改为s</code></pre></div><p>注：</p><p>reword：可以编辑commit message，它会在执行的时候跳出一个界面让你编辑信息，当你退出的时候，会继续执行命令</p><p>edit：麻烦点，cherry-pick同时 ，会停止，让你编辑信息，完了后，你要用git rebase –continue命令继续执行，相对上面来说有点麻烦</p><p>squash：合并此条记录到前一个记录中，并把commit message也合并进去 。</p><p>fixup：合并此条记录到前一个记录中，但是忽略此条commit message （并将前一个记录改为r，退出后重新rename message）</p><h2>版本回退</h2><p>       git log 命令显示从最近到最远的提交日志</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1、回退到上个版本</p><p>               在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">               $ git reset --hard HEAD^                将文件回退到上个版本中，工作区和暂存区，都回到上个版本</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>2、指定回到过去的某个版本</p><p>               $ git reset --hard 3628164</p><p class=\"ztext-empty-paragraph\"><br/></p><p>               版本号（git log可以查询）没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3、回到未来版本</p><p>               要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本</p><p>4、撤销修改</p><p>       命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销：</p><p>               一种是readme.txt自修改后还没有被放到暂存区（git add 添加到暂存区），现在，撤销修改就回到和版本库一模一样的状态；</p><p>               一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>       总之，就是让这个文件回到最近一次git commit或git add时的状态</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>我想撤销在缓存区（git add）的修改怎么办</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">       git reset HEAD file                可以把暂存区的修改撤销掉（unstage），重新放回工作区</code></pre></div><p> 然后在撤销工作区修改</p><div class=\"highlight\"><pre><code class=\"language-text\">       git checkout -- readme.txt</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作。</p><p></p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }, 
                {
                    "tag": "版本管理", 
                    "tagLink": "https://api.zhihu.com/topics/19566741"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42692742", 
            "userName": "Java高级架构狮", 
            "userLink": "https://www.zhihu.com/people/f0855b72f233c5230635cb9ea69c1bb6", 
            "upvote": 5, 
            "title": "一线互联网常见的14个Java面试题，你颤抖了吗程序员", 
            "content": "<p>跳槽不算频繁，但参加过不少面试（电话面试、face to face面试），面过大/小公司、互联网/传统软件公司，面糊过（眼高手低，缺乏实战经验，挂掉），也面过人，所幸未因失败而气馁，在此过程中不断查缺补漏，养成了踏实、追本溯源、持续改进的习惯，特此将自己经历过、构思过的一些面试题记录下来，如果答案有问题，欢迎拍砖讨论，希望能对找工作或者感兴趣的同学有所帮助，陆续整理中。</p><p><b>1. synchronized和reentrantlock异同</b></p><p>相同点</p><ul><li>都实现了多线程同步和内存可见性语义</li><li>都是可重入锁</li></ul><p>不同点</p><ul><li>实现机制不同 synchronized通过java对象头锁标记和Monitor对象实现 reentrantlock通过CAS、ASQ（AbstractQueuedSynchronizer）和locksupport（用于阻塞和解除阻塞）实现 synchronized依赖jvm内存模型保证包含共享变量的多线程内存可见性 reentrantlock通过ASQ的volatile state保证包含共享变量的多线程内存可见性</li><li>使用方式不同 synchronized可以修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、代码块（显示指定锁对象） reentrantlock显示调用trylock()/lock()方法，需要在finally块中释放锁</li><li>功能丰富程度不同 reentrantlock提供有限时间等候锁（设置过期时间）、可中断锁（lockInterruptibly）、condition（提供await、signal等方法）等丰富语义 reentrantlock提供公平锁和非公平锁实现 synchronized不可设置等待时间、不可被中断（interrupted）</li></ul><p><b>2. concurrenthashmap为何读不用加锁</b></p><ul><li>jdk1.7</li><li>1）HashEntry中的key、hash、next 均为final 型，只能表头插入、删除结点</li><li>2）HashEntry类的value域被声明为volatile型</li><li>3）不允许用null作为键和值，当读线程读到某个HashEntry的 value域的值为null时，便知道产生了冲突——发生了重排序现象（put设置新value对象的字节码指令重排序），需要加锁后重新读入这个value值</li><li>4）volatile变量count协调读写线程之间的内存可见性，写操作后修改count，读操作先读count，根据happen-before传递性原则写操作的修改读操作能够看到</li><li>jdk1.8</li><li>1）Node的val和next均为volatile型</li><li>2）tabAt和casTabAt对应的unsafe操作实现了volatile语义</li></ul><p><b>3. ContextClassLoader（线程上下文类加载器）的作用</b></p><ul><li>越过类加载器的双亲委派机制去加载类，如serviceloader实现</li><li>使用线程上下文类加载器加载类，要注意保证多个需要通信的线程间的类加载器应该是同一个，防止因为不同的类加载器导致类型转换异常(ClassCastException)</li></ul><p><b>4. tomcat 类加载机制</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-da4d6479ddac750878ec203abc255fc3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-da4d6479ddac750878ec203abc255fc3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;503&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"503\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-da4d6479ddac750878ec203abc255fc3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-da4d6479ddac750878ec203abc255fc3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>不同应用使用不同的 webapp类加载器，实现应用隔离的效果，webapp类加载器下面是jsp类加载器</li><li>不同应用共享的jar包可以放到Shared类加载器/shared目录下</li></ul><p><b>5. osgi类加载机制</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a436c7502ae236130b546e203d984216_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-a436c7502ae236130b546e203d984216_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"443\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-a436c7502ae236130b546e203d984216_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a436c7502ae236130b546e203d984216_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>osgi类加载模型是网状的，可以在模块（Bundle）间互相委托</li><li>osgi实现模块化热部署的关键是自定义类加载器机制的实现，每个Bundle都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换</li><li>当收到类加载请求时，osgi将按照下面的顺序进行类搜索：</li><li>1）将以java.*开头的类委派给父类加载器加载</li><li>2）否则，将委派列表名单（配置文件org.osgi.framework.bootdelegation中定义）内的类委派给父类加载器加载</li><li>3）否则，检查是否在Import-Package中声明，如果是，则委派给Export这个类的Bundle的类加载器加载</li><li>4）否则，检查是否在Require-Bundle中声明，如果是，则将类加载请求委托给required bundle的类加载器</li><li>5）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载</li><li>6）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载</li><li>7）否则，查找Dynamic Import-Package（Dynamic Import只有在真正用到此Package的时候才进行加载）的Bundle，委派给对应Bundle的类加载器加载</li><li>8）否则，类查找失败</li></ul><p><b>6. 如何结束一个一直运行的线程</b></p><ul><li>使用退出标志，这个flag变量要多线程可见</li><li>使用interrupt，结合isInterrupted()使用</li></ul><p><b>7. threadlocal使用场景及问题</b></p><ul><li>threadlocal并不能解决多线程共享变量的问题，同一个 threadlocal所包含的对象，在不同的thread中有不同的副本，互不干扰</li><li>用于存放线程上下文变量，方便同一线程对变量的前后多次读取，如事务、数据库connection连接，在web编程中使用的更多</li><li><b>问题：</b> 注意线程池场景使用threadlocal，因为实际变量值存放在了thread的threadlocalmap类型变量中，如果该值没有remove，也没有先set的话，可能会得到以前的旧值</li><li><b>问题：</b> 注意线程池场景下的内存泄露，虽然threadlocal的get/set会清除key（key为threadlocal的弱引用，value是强引用，导致value不释放）为null的entry，但是最好remove</li></ul><p><b>8. 线程池从启动到工作的流程</b></p><ul><li>刚创建时，里面没有线程</li><li>调用 execute() 添加任务时：</li><li>1）如果正在运行的线程数量小于核心参数corePoolSize，继续创建线程运行这个任务</li><li>2）否则，如果正在运行的线程数量大于或等于corePoolSize，将任务加入到阻塞队列中</li><li>3）否则，如果队列已满，同时正在运行的线程数量小于核心参数maximumPoolSize，继续创建线程运行这个任务</li><li>4）否则，如果队列已满，同时正在运行的线程数量大于或等于 maximumPoolSize，根据设置的拒绝策略处理</li><li>5）完成一个任务，继续取下一个任务处理</li><li>6）没有任务继续处理，线程被中断或者线程池被关闭时，线程退出执行，如果线程池被关闭，线程结束</li><li>7）否则，判断线程池正在运行的线程数量是否大于核心线程数，如果是，线程结束，否则线程阻塞。因此线程池任务全部执行完成后，继续留存的线程池大小为corePoolSize</li></ul><p><b>9. 阻塞队列BlockingQueue take和poll区别</b></p><ul><li>poll(time)：取走BlockingQueue里排在首位的对象,若不能立即取出，则可以等time参数规定的时间，取不到时返回null</li><li>take()：取走BlockingQueue里排在首位的对象，若BlockingQueue为空，阻塞直到BlockingQueue有新的对象被加入</li></ul><p><b>10. 如何从FutureTask不阻塞获取结果</b></p><ul><li>get(long timeout,TimeUnit unit)，超时则返回</li><li>轮询，先通过isDone()判断是否结束，然后调用get()</li></ul><p><b>11. blockingqueue如果存放了比较关键的数据，系统宕机该如何处理</b></p><ul><li>开放性问题，欢迎讨论</li><li>将队列持久化，比较麻烦，需要将生产数据持久化到磁盘，持久化成功才返回，消费者线程从磁盘加载数据到内存阻塞队列中，维护消费offset，启动时，根据消费offset从磁盘加载数据</li><li>加入消息队列，保证消息不丢失，生成序列号，消费幂等，根据消费进程决定系统重启后的生产状态</li></ul><p><b>12. NIO与传统I/O的区别</b></p><ul><li>节约线程，NIO由原来的每个线程都需要阻塞读写变成了由单线程（即Selector）负责处理多个channel注册（register）的兴趣事件（SelectionKey）集合（底层借助操作系统提供的epoll()），netty bossgroup处理accept连接（<b>没看明白为什么bossgroup设置多个thread的必要性</b>），workergroup处理具体业务流程和数据读写</li><li>NIO提供非阻塞操作</li><li>传统I/O 以流的方式处理数据，而 NIO 以块的方式处理数据，NIO提供bytebuffer，分为堆内和堆外缓冲区，读写时均先放到该缓冲区中，然后由内核通过channel传输到对端，堆外缓冲区不走内核，提升了性能</li></ul><p><b>13. list中存放可重复字符串，如何删除某个字符串</b></p><ul><li>调用iterator相关方法删除</li><li>倒删，防止正序删除导致的数组重排，index跳过数组元素问题</li></ul><p><b>14. 有哪些GC ROOTS（跟日常开发比较相关的是和此相关的内存泄露）</b></p><ul><li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用，因此用不到的对象及时置null，提升内存回收效率</li><li>静态变量引用的对象，因此减少静态变量特别是静态集合变量的大小，集合存放的对象覆写euqls()和hashcode()，防止持续增长</li><li>本地方法JNI引用的对象</li><li>方法区中的常量引用的对象，因此减少在长字符串上调用String.intern()</li><li>classloader加载的class对象，因此自定义classloader无效时及时置null并且注意类加载器加载对象之间的隔离</li><li>jvm里的一些静态数据结构里指向GC堆里的对象的引用</li><li>…</li></ul>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "互联网", 
                    "tagLink": "https://api.zhihu.com/topics/19550517"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42598175", 
            "userName": "Java高级架构狮", 
            "userLink": "https://www.zhihu.com/people/f0855b72f233c5230635cb9ea69c1bb6", 
            "upvote": 6, 
            "title": "Spring框架和Spring boot有啥区别？", 
            "content": "<p>首先看看Spring, 它是一个IOC框架，或者称依赖注入DI框架，又是一个AOP框架。这里就不多讲这些特性了，spring框架还有更多其他特性，有二十个模块，能解决很多问题:</p><p>Spring JDBC</p><p>Spring MVC</p><p>Spring AOP</p><p>Spring ORM</p><p>Spring JMS</p><p>Spring Test</p><p>Spring Expression Language (SpEL)</p><p>spring框架虽然没有自己的ORM，但是很好地集成了 Hibernate, Apache iBATIS等等。</p><p>Spring MVC提供了界面的MVC实现，使得WEB开发非常方便。</p><p>既然Spring解决了这么多问题，那么为什么我们还需要 Spring Boot?</p><p>我们看看实际中开发具有所有功能的完整Spring应用程序时所面临的问题, 设置Hibernate Datasource、实体管理器、会话工厂和事务管理有很多困难。对于一个开发人员来说，使用SpringMVC建立一个基本项目需要花费大量的时间，而且实现的功能最少。</p><p><br/> &lt;bean<br/> <b>class</b>=&#34;org.springframework.web.servlet.view.InternalResourceViewResolver&#34;&gt;<br/> &lt;property name=&#34;prefix&#34;&gt;<br/> &lt;value&gt;/WEB-INF/views/&lt;/value&gt;<br/> &lt;/property&gt;<br/> &lt;property name=&#34;suffix&#34;&gt;<br/> &lt;value&gt;.jsp&lt;/value&gt;<br/> &lt;/property&gt;<br/> &lt;/bean&gt;<br/> &lt;mvc:resources mapping=&#34;/webjars/**&#34; location=&#34;/webjars/&#34;/&gt;<br/>&lt;servlet&gt;<br/> &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;<br/> &lt;servlet-<b>class</b>&gt;<br/>            org.springframework.web.servlet.DispatcherServlet<br/> &lt;/servlet-<b>class</b>&gt;<br/> &lt;init-param&gt;<br/> &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br/> &lt;param-value&gt;/WEB-INF/my-servlet.xml&lt;/param-value&gt;<br/> &lt;/init-param&gt;<br/> &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br/> &lt;/servlet&gt;<br/> &lt;servlet-mapping&gt;<br/> &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;<br/> &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br/> &lt;/servlet-mapping&gt;<br/><br/></p><p>当我们使用 Hibernate, 需要配置 datasource, EntityManager等:</p><p><br/>&lt;bean id=&#34;dataSource&#34; <b>class</b>=&#34;com.mchange.v2.c3p0.ComboPooledDataSource&#34;<br/> destroy-method=&#34;close&#34;&gt;<br/> &lt;property name=&#34;driverClass&#34; value=&#34;${db.driver}&#34; /&gt;<br/> &lt;property name=&#34;jdbcUrl&#34; value=&#34;${db.url}&#34; /&gt;<br/> &lt;property name=&#34;user&#34; value=&#34;${db.username}&#34; /&gt;<br/> &lt;property name=&#34;password&#34; value=&#34;${db.password}&#34; /&gt;<br/> &lt;/bean&gt;<br/> &lt;jdbc:initialize-database data-source=&#34;dataSource&#34;&gt;<br/> &lt;jdbc:script location=&#34;classpath:config/schema.sql&#34; /&gt;<br/> &lt;jdbc:script location=&#34;classpath:config/data.sql&#34; /&gt;<br/> &lt;/jdbc:initialize-database&gt;<br/> &lt;bean<br/> <b>class</b>=&#34;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&#34;<br/> id=&#34;entityManagerFactory&#34;&gt;<br/> &lt;property name=&#34;persistenceUnitName&#34; value=&#34;hsql_pu&#34; /&gt;<br/> &lt;property name=&#34;dataSource&#34; ref=&#34;dataSource&#34; /&gt;<br/> &lt;/bean&gt;<br/> &lt;bean id=&#34;transactionManager&#34; <b>class</b>=&#34;org.springframework.orm.jpa.JpaTransactionManager&#34;&gt;<br/> &lt;property name=&#34;entityManagerFactory&#34; ref=&#34;entityManagerFactory&#34; /&gt;<br/> &lt;property name=&#34;dataSource&#34; ref=&#34;dataSource&#34; /&gt;<br/> &lt;/bean&gt;<br/> &lt;tx:annotation-driven transaction-manager=&#34;transactionManager&#34;/&gt;<br/> <br/></p><p>SpringBoot如何解决这个问题？</p><p>Spring Boot自动配置所需的所有内部依赖关系，我们只要运行应用程序即可。</p><p>1.如果spring的jar包在类路径classpath中，SpringBoot将自动配置Dispatcher servlet。如果Hibernate的jar包在类路径，它将自动配置数据源。</p><p>2.SpringBoot为我们提供了一组预先配置好的启动项目，这些项目将作为依赖项添加到我们的项目中。</p><p>在web应用程序开发过程中，我们需要使用JAR包，并确定要使用的JAR版本，以及如何将它们连接在一起。所有Web应用程序都有类似的需求，例如SpringMVC、JacksonDatabind、Hibernate核心和Log4j(用于日志记录)。因此，我们不得不保持所有这些JAR版本兼容。</p><p>spring boot为了降低这些复杂性，引入了 Spring Boot Starter</p><p>starter是一组方便的依赖项，可以在SpringBoot应用程序中包含这些依赖项。为了使用Spring和Hibernate，我们只需在项目中包含Spring-boot-starter-data-jpa依赖项。</p><p>下面是启动spring web项的配置，可以实现RESTful风格API。</p><p>&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; </p><p>下图显示了这一个依赖加入的所有依赖包:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7288a768a5f70a4075d7f44bd6754f4f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"578\" class=\"origin_image zh-lightbox-thumb\" width=\"545\" data-original=\"https://pic4.zhimg.com/v2-7288a768a5f70a4075d7f44bd6754f4f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;545&#39; height=&#39;578&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"578\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"545\" data-original=\"https://pic4.zhimg.com/v2-7288a768a5f70a4075d7f44bd6754f4f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7288a768a5f70a4075d7f44bd6754f4f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>一旦所需的这些依赖包加入maven的配置pom.xml，作为开发人员，我们就不需要担心这些依赖项及其版本兼容性问题。</p><p>下面是常用的starter项目依赖包，如果你要使用相应功能，只要加入相应的starter名称到pom.xml中即可，如果需要使用到配置或数据库连接，也只要在项目的application.properties或yaml中配置即可，项目启动时会自动在类路径中发现这两个配置文件并读取配置内容注入相应的类中。</p><p>spring-boot-starter-web-services: SOAP Web Services</p><p>spring-boot-starter-web: Web 和 RESTful 应用，这是默认常用的</p><p>spring-boot-starter-test:单元测试和集成测试，默认引用。</p><p>spring-boot-starter-jdbc: 传统 JDBC</p><p>spring-boot-starter-hateoas: 增加 HATEOAS 特性到服务。</p><p>spring-boot-starter-security: 使用spring安全实现验证和授权。</p><p>spring-boot-starter-data-jpa: Spring Data JPA with Hibernate</p><p>spring-boot-starter-cache: 激活 Spring Framework的缓存支持</p><p>spring-boot-starter-data-rest: 使用 Spring Data REST暴露简单的 REST 服务，</p>", 
            "topic": [
                {
                    "tag": "Spring", 
                    "tagLink": "https://api.zhihu.com/topics/19599516"
                }, 
                {
                    "tag": "Spring Boot", 
                    "tagLink": "https://api.zhihu.com/topics/20044714"
                }, 
                {
                    "tag": "Spring MVC", 
                    "tagLink": "https://api.zhihu.com/topics/20033636"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42812069", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "GIT中将本地修改代码提交再回退方法", 
            "content": "平常团队开发中，我们经常会碰到用git去做分布式版本控制管理，特别是最近几年，企业用git的特别多，以前还会用svn，但是在后期的实践过程中，发现svn很多缺点，所以git还是占据主潮流的地位！<br/>接下来，我要讲解的就是平常我们用git的一个使用小技巧，之所以记录下来，因为自己实践的时候是可以使用的，为了以后自己不记得，所以写下来，以后可以翻来看看，再者是给知乎的那些还不知道这个技能点的知友门普及普及，解解惑！<br/>当我们在本地修改代码，并将提交的代码提交后，发现提交的代码，又不想要了，不想修改了，那这个时候怎么办呢！我们找到team，点击show in history，然后会出现你提交的记录，这时候在Git history界面小窗口，点击你提交的这次分支记录，它会显示出如下图:<br/><br/>橘黄色的线圈记的是commit id，就是你提交所生成的一个id号，你拿着这个id号再去使用以下命令就可以回退了！<br/>git  reset  --hard  commit_id；<br/>把上面的commit_id替换成你实际的id就可以回到你那个状态了，把此次提交删除<br/>好了，以上就是我给大家分享的精彩内容，希望大家能学习git到这个技能！", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/42527146", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 3, 
            "title": "JAVA开发行业面试小结", 
            "content": "作为一名JAVA开发工程师，摸爬滚打几年，我分享下我自己对这个行业的理解！纯属个人经验所著，如果不对还请海涵！<br/>先给出BAT公司之一的阿里招聘面试题，让大家看看阿里面试JAVA开发人员，到底是怎么问得，可以说阿里作为当下互联网公司巨头，他们的出的面试题在整个行业内可以说是标杆，很多公司都纷纷效仿！<br/><figure><noscript><img src=\"https://pic2.zhimg.com/v2-cca7f1510affaf6603b968bab57cc115_b.jpg\" data-rawwidth=\"1159\" data-rawheight=\"774\" class=\"origin_image zh-lightbox-thumb\" width=\"1159\" data-original=\"https://pic2.zhimg.com/v2-cca7f1510affaf6603b968bab57cc115_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1159&#39; height=&#39;774&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1159\" data-rawheight=\"774\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1159\" data-original=\"https://pic2.zhimg.com/v2-cca7f1510affaf6603b968bab57cc115_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-cca7f1510affaf6603b968bab57cc115_b.jpg\"/></figure>以上只是拿出几个比较典型的面试题来继续我们今天的话题！从上图中一个个问题看下来，你问问自己到底会几道，如果让你回答，你怎么回答，会回答的让自己满意吗？如果你很有信心的回答有，那么恭喜您，你可以去阿里面试一波！<br/>上面有些问题问得很基础，也很经典，就看你是否在平时的工作中，善于思考，举一反三，像list底层实现，hashmap低层原理，这些都是平常工作中用的最多的！往往面试的时候，很多人被问的稀里糊涂，对这几个问题回答的很不满意，只知道用，但是就是不知道它的低层实现原理！这就是行业内说的典型的不动脑子，只知道复制粘贴完事，不会更深层次去了解这个东西为啥可以这样用，除了这样的表现，我还可以把它用在哪些问题上，以解决问题！（当然这需要实践，所以实践很重要）像多线程及应用这个面试题，很多人如果呆在小公司，可能一年到头，让你码代码实现多线程的机会少之又少！这必须需要实践得出真理，我记得我之前工作的时候，因为多线程一般被认为是比较算的上JAVA突出的一个技术点，有些地方需要面对高并发，多线程用的地方很多！但是一般公司任务分配的时候很少会让没有经验的同学去完成关于多线程的任务！只会要有经验的同事去干这活！但是，我们私下里可以自己试着学！动手实践创demo。<br/>像真正有点难度的就是&#34;A系统给B系统100元钱怎么实现&#34;这个问题，如果给我这个问题，我会想到两个系统产生了支付交易行为，那么我最应该想到的就是，我不可能让A系统给钱给错了，不然就出大事了，本来只要转100，却因为网络堵塞，造成支付失效，重复发起支付行为，那这时是相当有考究的！这时候高潮来了，大家把耳朵竖起来了，相信很多人都没听过这个词，那就是对于上面重复交易的行为进行&#34;幂等性&#34;，正在阅览此文章的你，是否此前从没听过？听过的就算了，我主要给没听过的普及下，哈哈！一般在做接口的时候，跟第三方对接，如果存在上面因为重复发起请求的问题，这时候接口做幂等性处理，会让接口对于重复的请求，会屏蔽，只认第一次有效的请求，并记录第一次有效的状态，当后面相同的请求发起时，只要去查阅本地数据库的那个状态字位，就可以知道到底是否对该次请求处理完毕！<br/>接下来我们要讨论的话题就是，你在工作中用到过的框架以及项目，这两个可以穿插结合讲！因为项目离不开框架，并且根据你所做的不同项目，基于它具体的实际需求，要对框架做不同层次的改动，有的框架不仅做后台管理，也要做app的接入，供app调取接口，这时候框架可以并行的开发，控制层开发自己独立的一套，app的接口一套，后台系统一套，但是他们的业务逻辑层，持久层，后台数据都是用的一套，减少了代码！提高了代码的复用性！<br/>不同的项目它又会用到不同的封装的持久层，像mybatis(ibatis发展而来)，herbinert，spring data jpa等！他们的操作方法又体现出很多种，我自己在工作开发中就碰到很多表现形式，但是他们的低层原理是一样的，所以，如果有兴趣的同学是可以把这些源码剖析出来，进行对比，这样以后不管碰到啥样的，都可以应付，并且自己也可以跟着具体的需求更改！（这就是最牛逼的地方）有的小伙伴竟然自己写了一遍这些持久层的底层代码，凭借自己的理解！<br/>好了今天的面试题分享会到这，感谢大家的观看，我们下期再见！<br/><br/><figure><noscript><img src=\"https://pic4.zhimg.com/v2-3fc50cfe31fc1527d2becc97758174c3_b.jpg\" data-rawwidth=\"1194\" data-rawheight=\"775\" class=\"origin_image zh-lightbox-thumb\" width=\"1194\" data-original=\"https://pic4.zhimg.com/v2-3fc50cfe31fc1527d2becc97758174c3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1194&#39; height=&#39;775&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1194\" data-rawheight=\"775\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1194\" data-original=\"https://pic4.zhimg.com/v2-3fc50cfe31fc1527d2becc97758174c3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3fc50cfe31fc1527d2becc97758174c3_b.jpg\"/></figure>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/41966845", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 2, 
            "title": "编程式事物——提高千倍性能问题——阿里面试题", 
            "content": "<p>经常遇到的并发编程问题，有些操作数据库的代码需要加上事物，这就使得每使用一次事物就要占用一个连接，如果设置的链接池最大连接数有限，那么当并发数超过此连接数就会使得其他的操作就会宕机，报500的错误，显示超过最大连接数！其实占用连接的时间很短，因为要进行数据库操作的时间很快！所以在高并发的情况下，提高性能，那就必须使得该用事物的就用，不该用的不用，这样就会减少连接资源占用的时间！如果连接数较大，一个多占用那么多时间，加起来就会很多，其实这些时间可以释放出来连接池以供其他操作正常进行！以下图片来源大牛！非常珍贵！</p><p>​</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4c8acb3ea0ff34a7a4252a071e75a1e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb\" width=\"804\" data-original=\"https://pic3.zhimg.com/v2-4c8acb3ea0ff34a7a4252a071e75a1e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;804&#39; height=&#39;535&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"804\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"804\" data-original=\"https://pic3.zhimg.com/v2-4c8acb3ea0ff34a7a4252a071e75a1e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4c8acb3ea0ff34a7a4252a071e75a1e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a19622bf483cfc66893ad5c79ef3aee1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"796\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb\" width=\"796\" data-original=\"https://pic2.zhimg.com/v2-a19622bf483cfc66893ad5c79ef3aee1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;796&#39; height=&#39;365&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"796\" data-rawheight=\"365\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"796\" data-original=\"https://pic2.zhimg.com/v2-a19622bf483cfc66893ad5c79ef3aee1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a19622bf483cfc66893ad5c79ef3aee1_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-88a9b3531e44ad8280c2ffc49e85cee7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"793\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"793\" data-original=\"https://pic4.zhimg.com/v2-88a9b3531e44ad8280c2ffc49e85cee7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;793&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"793\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"793\" data-original=\"https://pic4.zhimg.com/v2-88a9b3531e44ad8280c2ffc49e85cee7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-88a9b3531e44ad8280c2ffc49e85cee7_b.jpg\"/></figure><p>下面看他控制层代码：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-951f122826e55f793d170804d5041281_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb\" width=\"797\" data-original=\"https://pic2.zhimg.com/v2-951f122826e55f793d170804d5041281_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;797&#39; height=&#39;533&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"797\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"797\" data-original=\"https://pic2.zhimg.com/v2-951f122826e55f793d170804d5041281_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-951f122826e55f793d170804d5041281_b.jpg\"/></figure><p>​​</p>", 
            "topic": [
                {
                    "tag": "编程", 
                    "tagLink": "https://api.zhihu.com/topics/19554298"
                }, 
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35957027", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "ajax跨域带cookie问题的解决", 
            "content": "<p>一般要支持ajax跨域带cookie的话需要加上以下语句</p><p>xhr.withCredentials = true; //支持跨域发送cookies </p><p>具体编码的时候这样就行：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-bdc0036189184936f34864fe955e0d32_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-bdc0036189184936f34864fe955e0d32_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;467&#39; height=&#39;367&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"467\" data-rawheight=\"367\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"467\" data-original=\"https://pic3.zhimg.com/v2-bdc0036189184936f34864fe955e0d32_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bdc0036189184936f34864fe955e0d32_b.jpg\"/></figure><p>有时开发人员发现请求过去可以，返回却报错，问题如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-905abf010245f74925c81bf440dc99fd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1128\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"1128\" data-original=\"https://pic2.zhimg.com/v2-905abf010245f74925c81bf440dc99fd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1128&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1128\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1128\" data-original=\"https://pic2.zhimg.com/v2-905abf010245f74925c81bf440dc99fd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-905abf010245f74925c81bf440dc99fd_b.jpg\"/></figure><p>从错误的字面意思上理解，是报origin的数不能容许为空！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-10a65aec81060947ccc220a8504bc41a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-10a65aec81060947ccc220a8504bc41a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;731&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"731\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"731\" data-original=\"https://pic3.zhimg.com/v2-10a65aec81060947ccc220a8504bc41a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-10a65aec81060947ccc220a8504bc41a_b.jpg\"/></figure><p>然而这在谷歌的浏览器上报的错误，而在用其他浏览器的时候，没出现此错误！</p><p>最终证实谷歌浏览器不支持，并且 ie11下的浏览器以及个别浏览器也不支持跨域带cookie！</p>", 
            "topic": [
                {
                    "tag": "Ajax", 
                    "tagLink": "https://api.zhihu.com/topics/19555867"
                }, 
                {
                    "tag": "跨域", 
                    "tagLink": "https://api.zhihu.com/topics/19612046"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "报错是因为你java代码里设置origin为*", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33694915", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 0, 
            "title": "The constructor ActionEnter(HttpServletRequest, String) is undefined", 
            "content": "<p>平常我们在用ueditor的时候，导入ueditor文件夹或者从别人那里扒拉来的代码，发现会报以下的错误，其错误如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">The constructor ActionEnter(HttpServletRequest, String) is undefined  </code></pre></div><p>当我们按住ctrl键进入的时候，进入到ActionEnter.class文件中，你会发现问题所在，这在我碰到这样的问题时，去网上搜索解决办法的时候，都在问，但是很多人都出的馊主意，问题的真正根源在于以下代码（我从ActionEnter.class源码里截取的关键代码部分）如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">public ActionEnter(HttpServletRequest request, String rootPath, String configFileName)  \n/*     */   {  \n/*  67 */     this.request = request;  \n/*  68 */     this.rootPath = rootPath;  \n/*  69 */     actionType = request.getParameter(&#34;action&#34;);  \n/*  70 */     configManager = ConfigManager.getInstance(this.rootPath, configFileName);  \n/*     */   }  </code></pre></div><p>细心的你会发现，参数不匹配，后面缺少一个configFileName字符串参数，但是它报出的错误却不是这个不匹配的意思，只是说不匹配，这很有趣味性！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-94cc42b7b4d9b1abb5d12c763a8638ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1312\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb\" width=\"1312\" data-original=\"https://pic4.zhimg.com/v2-94cc42b7b4d9b1abb5d12c763a8638ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1312&#39; height=&#39;600&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1312\" data-rawheight=\"600\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1312\" data-original=\"https://pic4.zhimg.com/v2-94cc42b7b4d9b1abb5d12c763a8638ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-94cc42b7b4d9b1abb5d12c763a8638ef_b.jpg\"/></figure><p>以上就是解决办法的最直接手段，简单有效！</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33694807", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "maven项目的分支状态显示NO-HEAD的问题解决", 
            "content": "<p>一般在本地创建maven项目后，自己想要让这个项目运用git分布式版本管理工具进行开发，但是当我用git工具去项目目录去切分支时候，发现找不到分支或者显示没有创建仓库。这时候我找到eclipse中的项目，按住项目点击鼠标右键，在下拉框中找到team,如果git连接管理此项目，就会有很多版本控制按钮像push、commit等等，但是断开连接的话，那就是只出现两个列表选项，这时选择share project,出现如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-64c4b52d0bf227037a17eba65390c84a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb\" width=\"756\" data-original=\"https://pic3.zhimg.com/v2-64c4b52d0bf227037a17eba65390c84a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;756&#39; height=&#39;442&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"756\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"756\" data-original=\"https://pic3.zhimg.com/v2-64c4b52d0bf227037a17eba65390c84a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-64c4b52d0bf227037a17eba65390c84a_b.jpg\"/></figure><p>这时候很方便的进行下一步的操作，中间还有一些操作，自己按条件选择，最后点击完成finished，但是此时问题来啦，如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-8f79179a11ceb752232bf2560330475b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1345\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb\" width=\"1345\" data-original=\"https://pic4.zhimg.com/v2-8f79179a11ceb752232bf2560330475b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1345&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1345\" data-rawheight=\"245\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1345\" data-original=\"https://pic4.zhimg.com/v2-8f79179a11ceb752232bf2560330475b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-8f79179a11ceb752232bf2560330475b_b.jpg\"/></figure><p>会看见上面显示NO-HEAD，而不是像其他git项目那样，显示状态，这时查到解决办法，如下图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-562a969069e2c4d24c708b1c4ed30432_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"753\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb\" width=\"753\" data-original=\"https://pic3.zhimg.com/v2-562a969069e2c4d24c708b1c4ed30432_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;753&#39; height=&#39;419&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"753\" data-rawheight=\"419\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"753\" data-original=\"https://pic3.zhimg.com/v2-562a969069e2c4d24c708b1c4ed30432_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-562a969069e2c4d24c708b1c4ed30432_b.jpg\"/></figure><p>但是在中文的网站上从来没有看到（不仅仅是这个问题，我用博客百度很久，发现资深的中国技术人员很少有很好的精品技术文章出现），不知道是中国人不知道，还是中国人像外国人说的那样，每个搞技术的人都是不把技术外露，生怕别人学到自己的技术，哈哈哈！这只是题外话。。。有点跑题了！</p><p>上面那段英文的解释，就是说项目一经push或者commit就会把问题解决！</p>", 
            "topic": [
                {
                    "tag": "Maven", 
                    "tagLink": "https://api.zhihu.com/topics/19629084"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33694677", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 0, 
            "title": "..\\target\\m2e-wtp\\web-resources\\META-INF\\MANIFEST.MF (系统找不到指定的路径）解决办法", 
            "content": "<p>最近总是发现我的eclipse里面的maven项目总是报错误，然后我自己更新一下maven项目，这个错误又消失了，错误如下：</p><p>G:\\Users\\Administrator\\workspace\\pfcase\\target\\m2e-wtp\\web-resources\\META-INF\\MANIFEST.MF (系统找不到指定的路径。)<br/></p><p>以上这个问题其实很好解决，操作如图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-941e097952dd6cecfe41c05534a67bff_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"984\" data-rawheight=\"697\" class=\"origin_image zh-lightbox-thumb\" width=\"984\" data-original=\"https://pic4.zhimg.com/v2-941e097952dd6cecfe41c05534a67bff_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;984&#39; height=&#39;697&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"984\" data-rawheight=\"697\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"984\" data-original=\"https://pic4.zhimg.com/v2-941e097952dd6cecfe41c05534a67bff_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-941e097952dd6cecfe41c05534a67bff_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>根据以上的步骤操作就好了！</p><p>对于这个问题发生的根本原因，我觉得有必要探讨一下：</p><p>1、先找到问题报错的地方，发现在pom.xml文件头部的地方，其具体代码是这样的，如下：</p><p>&lt;project xmlns=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/POM/4.0.0\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/POM/4.</span><span class=\"invisible\">0.0</span><span class=\"ellipsis\"></span></a>&#34; xmlns:xsi=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/2001/XMLSchema-instance\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/2001/XMLSchema-i</span><span class=\"invisible\">nstance</span><span class=\"ellipsis\"></span></a>&#34; xsi:schemaLocation=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/POM/4.0.0\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/POM/4.</span><span class=\"invisible\">0.0</span><span class=\"ellipsis\"></span></a> <a href=\"https://link.zhihu.com/?target=http%3A//maven.apache.org/xsd/maven-4.0.0.xsd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">maven.apache.org/xsd/ma</span><span class=\"invisible\">ven-4.0.0.xsd</span><span class=\"ellipsis\"></span></a>&#34;&gt;<br/></p><p>2、我们可以看问题指定的没找到的路径，发现在eclipse的指定项目里面是找的到的，那么只有一个可能指定的路径配置错误，一般这种系统路径都是tomcat容器默认设置的，我们开发的时候很少去碰到，这时印尼更改想到项目所运行的环境！</p><p>好啦，分享到此！嘻嘻！</p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33455724", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "shell命令打war包的那些事", 
            "content": "<p>今天开发的时候，拿到自动代码构建编译的shell脚本进行war包的拉取，以前在公司里都是把项目git拉下来，然后把相应的shell脚本放到此项目的盘符进行点击运行！但是今天情况变了下，我把shell脚本放到其他盘，跟项目不在一个盘符里，这时我在编译的时候，总是发现要么是在项目下创建war包存放文件，要么在shell脚本目录创建存放war包文件，这时候多测试了几下，对比了下，发现../（代表上一级目录）和./这种符号默认的只在本盘符（也就是本根目录下）进行搜索切换！这是一个问题，以此写下来，记录！</p><div class=\"highlight\"><pre><code class=\"language-text\">cd G:/Users/Administrator/workspace/bugCatcher  \n#git pull  \nmvn clean install -Dmaven.test.skip=true -U  \n  \ncd E:/study-document/shell  \nmkdir pfcase  \ncd G:/Users/Administrator/workspace/bugCatcher  \ncp ../bugCatcher/target/pfcase.war  E:/study-document/shell/pfcase/  \n  \necho done  </code></pre></div><p>从上面看出我使用的盘符分别为G盘和E盘，如果不想这么麻烦，那最好将自己的shell脚本放到项目所在的根目录下，这样是最好的，当我们的shell在根目录下移动时，无需去改路径了！</p><p>当然，上面的shell脚本还是不太完美，还有另一种实现办法，那就是在shell脚本的开头采取特定文件指定路径，这样下面引用其路径就好了！如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">project_path=G:/Users/Administrator/workspace/bugCatcher \nshell_path=E:/study-document/shell  \ncd $project_path\n#git pull  \nmvn clean install -Dmaven.test.skip=true -U  \n  \ncd $shell_path  \nmkdir pfcase  \ncd $project_path  \ncp ../bugCatcher/target/pfcase.war $shell_path/pfcase/  \n  \necho done  </code></pre></div><p>这样每次移动文件位置，就只要修改头部路径！</p>", 
            "topic": [
                {
                    "tag": "shell 脚本", 
                    "tagLink": "https://api.zhihu.com/topics/19617864"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33284096", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "Cannot run program \"cmd.exe\" 和CreateProcess error=740", 
            "content": "<p>今天解决了一个大bug，很开心，哈哈哈，bug如下:</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"n\">BUILD</span> <span class=\"n\">FAILURE</span>\n<span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"o\">------------------------------------------------------------------------</span>\n<span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"n\">Total</span> <span class=\"nl\">time:</span> <span class=\"n\">1</span><span class=\"o\">.</span><span class=\"na\">665</span> <span class=\"n\">s</span>\n<span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"n\">Finished</span> <span class=\"nl\">at:</span> <span class=\"n\">2018</span><span class=\"o\">-</span><span class=\"n\">01</span><span class=\"o\">-</span><span class=\"nl\">25T14:32:</span><span class=\"n\">43</span><span class=\"o\">+</span><span class=\"nl\">08:</span><span class=\"n\">00</span>\n<span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"n\">Final</span> <span class=\"nl\">Memory:</span> <span class=\"n\">17M</span><span class=\"o\">/</span><span class=\"n\">189M</span>\n<span class=\"o\">[</span><span class=\"n\">INFO</span><span class=\"o\">]</span> <span class=\"o\">------------------------------------------------------------------------</span>\n<span class=\"o\">[</span><span class=\"n\">ERROR</span><span class=\"o\">]</span> <span class=\"n\">Failed</span> <span class=\"n\">to</span> <span class=\"n\">execute</span> <span class=\"n\">goal</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugins</span><span class=\"o\">:</span><span class=\"n\">maven</span><span class=\"o\">-</span><span class=\"n\">surefire</span><span class=\"o\">-</span><span class=\"nl\">plugin:</span><span class=\"n\">2</span><span class=\"o\">.</span><span class=\"na\">12</span><span class=\"o\">:</span><span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"k\">default</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"o\">)</span> <span class=\"n\">on</span> <span class=\"n\">project</span> <span class=\"nl\">pfcase:</span> <span class=\"n\">Error</span> <span class=\"k\">while</span> <span class=\"n\">executing</span> <span class=\"n\">forked</span> <span class=\"n\">tests</span><span class=\"o\">.;</span> <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">is</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">Cannot</span> <span class=\"n\">run</span> <span class=\"n\">program</span> <span class=\"s\">&#34;cmd.exe&#34;</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"n\">directory</span> <span class=\"s\">&#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;</span><span class=\"o\">):</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span> <span class=\"o\">-&gt;</span> <span class=\"o\">[</span><span class=\"n\">Help</span> <span class=\"n\">1</span><span class=\"o\">]</span>\n<span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">LifecycleExecutionException</span><span class=\"o\">:</span> <span class=\"n\">Failed</span> <span class=\"n\">to</span> <span class=\"n\">execute</span> <span class=\"n\">goal</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugins</span><span class=\"o\">:</span><span class=\"n\">maven</span><span class=\"o\">-</span><span class=\"n\">surefire</span><span class=\"o\">-</span><span class=\"nl\">plugin:</span><span class=\"n\">2</span><span class=\"o\">.</span><span class=\"na\">12</span><span class=\"o\">:</span><span class=\"n\">test</span> <span class=\"o\">(</span><span class=\"k\">default</span><span class=\"o\">-</span><span class=\"n\">test</span><span class=\"o\">)</span> <span class=\"n\">on</span> <span class=\"n\">project</span> <span class=\"nl\">pfcase:</span> <span class=\"n\">Error</span> <span class=\"k\">while</span> <span class=\"n\">executing</span> <span class=\"n\">forked</span> <span class=\"n\">tests</span><span class=\"o\">.;</span> <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">is</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">Cannot</span> <span class=\"n\">run</span> <span class=\"n\">program</span> <span class=\"s\">&#34;cmd.exe&#34;</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"n\">directory</span> <span class=\"s\">&#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;</span><span class=\"o\">):</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">216</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">153</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">145</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">LifecycleModuleBuilder</span><span class=\"o\">.</span><span class=\"na\">buildProject</span><span class=\"o\">(</span><span class=\"n\">LifecycleModuleBuilder</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">116</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">LifecycleModuleBuilder</span><span class=\"o\">.</span><span class=\"na\">buildProject</span><span class=\"o\">(</span><span class=\"n\">LifecycleModuleBuilder</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">80</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">builder</span><span class=\"o\">.</span><span class=\"na\">singlethreaded</span><span class=\"o\">.</span><span class=\"na\">SingleThreadedBuilder</span><span class=\"o\">.</span><span class=\"na\">build</span><span class=\"o\">(</span><span class=\"n\">SingleThreadedBuilder</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">51</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">LifecycleStarter</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">LifecycleStarter</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">120</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">DefaultMaven</span><span class=\"o\">.</span><span class=\"na\">doExecute</span><span class=\"o\">(</span><span class=\"n\">DefaultMaven</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">355</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">DefaultMaven</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">DefaultMaven</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">155</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">584</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">doMain</span><span class=\"o\">(</span><span class=\"n\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">216</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">main</span><span class=\"o\">(</span><span class=\"n\">MavenCli</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">160</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">reflect</span><span class=\"o\">.</span><span class=\"na\">NativeMethodAccessorImpl</span><span class=\"o\">.</span><span class=\"na\">invoke0</span><span class=\"o\">(</span><span class=\"n\">Native</span> <span class=\"n\">Method</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">reflect</span><span class=\"o\">.</span><span class=\"na\">NativeMethodAccessorImpl</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"n\">NativeMethodAccessorImpl</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">62</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">sun</span><span class=\"o\">.</span><span class=\"na\">reflect</span><span class=\"o\">.</span><span class=\"na\">DelegatingMethodAccessorImpl</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"n\">DelegatingMethodAccessorImpl</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">43</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">reflect</span><span class=\"o\">.</span><span class=\"na\">Method</span><span class=\"o\">.</span><span class=\"na\">invoke</span><span class=\"o\">(</span><span class=\"n\">Method</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">498</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">classworlds</span><span class=\"o\">.</span><span class=\"na\">launcher</span><span class=\"o\">.</span><span class=\"na\">Launcher</span><span class=\"o\">.</span><span class=\"na\">launchEnhanced</span><span class=\"o\">(</span><span class=\"n\">Launcher</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">289</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">classworlds</span><span class=\"o\">.</span><span class=\"na\">launcher</span><span class=\"o\">.</span><span class=\"na\">Launcher</span><span class=\"o\">.</span><span class=\"na\">launch</span><span class=\"o\">(</span><span class=\"n\">Launcher</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">229</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">classworlds</span><span class=\"o\">.</span><span class=\"na\">launcher</span><span class=\"o\">.</span><span class=\"na\">Launcher</span><span class=\"o\">.</span><span class=\"na\">mainWithExitCode</span><span class=\"o\">(</span><span class=\"n\">Launcher</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">415</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">classworlds</span><span class=\"o\">.</span><span class=\"na\">launcher</span><span class=\"o\">.</span><span class=\"na\">Launcher</span><span class=\"o\">.</span><span class=\"na\">main</span><span class=\"o\">(</span><span class=\"n\">Launcher</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">356</span><span class=\"o\">)</span>\n<span class=\"n\">Caused</span> <span class=\"nl\">by:</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">MojoExecutionException</span><span class=\"o\">:</span> <span class=\"n\">Error</span> <span class=\"k\">while</span> <span class=\"n\">executing</span> <span class=\"n\">forked</span> <span class=\"n\">tests</span><span class=\"o\">.;</span> <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">is</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">Cannot</span> <span class=\"n\">run</span> <span class=\"n\">program</span> <span class=\"s\">&#34;cmd.exe&#34;</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"n\">directory</span> <span class=\"s\">&#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;</span><span class=\"o\">):</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">SurefirePlugin</span><span class=\"o\">.</span><span class=\"na\">assertNoException</span><span class=\"o\">(</span><span class=\"n\">SurefirePlugin</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">656</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">SurefirePlugin</span><span class=\"o\">.</span><span class=\"na\">handleSummary</span><span class=\"o\">(</span><span class=\"n\">SurefirePlugin</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">645</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">executeAfterPreconditionsChecked</span><span class=\"o\">(</span><span class=\"n\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">137</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">98</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">DefaultBuildPluginManager</span><span class=\"o\">.</span><span class=\"na\">executeMojo</span><span class=\"o\">(</span><span class=\"n\">DefaultBuildPluginManager</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">132</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">lifecycle</span><span class=\"o\">.</span><span class=\"na\">internal</span><span class=\"o\">.</span><span class=\"na\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">MojoExecutor</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">208</span><span class=\"o\">)</span>\n\t<span class=\"o\">...</span> <span class=\"n\">19</span> <span class=\"n\">more</span>\n<span class=\"n\">Caused</span> <span class=\"nl\">by:</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">booter</span><span class=\"o\">.</span><span class=\"na\">SurefireBooterForkException</span><span class=\"o\">:</span> <span class=\"n\">Error</span> <span class=\"k\">while</span> <span class=\"n\">executing</span> <span class=\"n\">forked</span> <span class=\"n\">tests</span><span class=\"o\">.;</span> <span class=\"n\">nested</span> <span class=\"n\">exception</span> <span class=\"n\">is</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">Cannot</span> <span class=\"n\">run</span> <span class=\"n\">program</span> <span class=\"s\">&#34;cmd.exe&#34;</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"n\">directory</span> <span class=\"s\">&#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;</span><span class=\"o\">):</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">booterclient</span><span class=\"o\">.</span><span class=\"na\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">(</span><span class=\"n\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">294</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">booterclient</span><span class=\"o\">.</span><span class=\"na\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">(</span><span class=\"n\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">113</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">executeProvider</span><span class=\"o\">(</span><span class=\"n\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">199</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">executeAllProviders</span><span class=\"o\">(</span><span class=\"n\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">176</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">executeAfterPreconditionsChecked</span><span class=\"o\">(</span><span class=\"n\">AbstractSurefireMojo</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">135</span><span class=\"o\">)</span>\n\t<span class=\"o\">...</span> <span class=\"n\">22</span> <span class=\"n\">more</span>\n<span class=\"n\">Caused</span> <span class=\"nl\">by:</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">Cannot</span> <span class=\"n\">run</span> <span class=\"n\">program</span> <span class=\"s\">&#34;cmd.exe&#34;</span> <span class=\"o\">(</span><span class=\"n\">in</span> <span class=\"n\">directory</span> <span class=\"s\">&#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;</span><span class=\"o\">):</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ProcessBuilder</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">(</span><span class=\"n\">ProcessBuilder</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">1048</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">Runtime</span><span class=\"o\">.</span><span class=\"na\">exec</span><span class=\"o\">(</span><span class=\"n\">Runtime</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">620</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">Commandline</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">Commandline</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">651</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">executeCommandLineAsCallable</span><span class=\"o\">(</span><span class=\"n\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">140</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">executeCommandLine</span><span class=\"o\">(</span><span class=\"n\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">111</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">codehaus</span><span class=\"o\">.</span><span class=\"na\">plexus</span><span class=\"o\">.</span><span class=\"na\">util</span><span class=\"o\">.</span><span class=\"na\">cli</span><span class=\"o\">.</span><span class=\"na\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">executeCommandLine</span><span class=\"o\">(</span><span class=\"n\">CommandLineUtils</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">86</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">org</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">maven</span><span class=\"o\">.</span><span class=\"na\">plugin</span><span class=\"o\">.</span><span class=\"na\">surefire</span><span class=\"o\">.</span><span class=\"na\">booterclient</span><span class=\"o\">.</span><span class=\"na\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">(</span><span class=\"n\">ForkStarter</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">276</span><span class=\"o\">)</span>\n\t<span class=\"o\">...</span> <span class=\"n\">26</span> <span class=\"n\">more</span>\n<span class=\"n\">Caused</span> <span class=\"nl\">by:</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">io</span><span class=\"o\">.</span><span class=\"na\">IOException</span><span class=\"o\">:</span> <span class=\"n\">CreateProcess</span> <span class=\"n\">error</span><span class=\"o\">=</span><span class=\"n\">740</span><span class=\"o\">,</span> <span class=\"n\">请求的操作需要提升</span><span class=\"err\">。</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ProcessImpl</span><span class=\"o\">.</span><span class=\"na\">create</span><span class=\"o\">(</span><span class=\"n\">Native</span> <span class=\"n\">Method</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ProcessImpl</span><span class=\"o\">.&lt;</span><span class=\"n\">init</span><span class=\"o\">&gt;(</span><span class=\"n\">ProcessImpl</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">386</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ProcessImpl</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">(</span><span class=\"n\">ProcessImpl</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">137</span><span class=\"o\">)</span>\n\t<span class=\"n\">at</span> <span class=\"n\">java</span><span class=\"o\">.</span><span class=\"na\">lang</span><span class=\"o\">.</span><span class=\"na\">ProcessBuilder</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">(</span><span class=\"n\">ProcessBuilder</span><span class=\"o\">.</span><span class=\"na\">java</span><span class=\"o\">:</span><span class=\"n\">1029</span><span class=\"o\">)</span>\n\t<span class=\"o\">...</span> <span class=\"n\">32</span> <span class=\"n\">more</span>\n<span class=\"o\">[</span><span class=\"n\">ERROR</span><span class=\"o\">]</span> \n<span class=\"o\">[</span><span class=\"n\">ERROR</span><span class=\"o\">]</span> \n<span class=\"o\">[</span><span class=\"n\">ERROR</span><span class=\"o\">]</span> <span class=\"n\">For</span> <span class=\"n\">more</span> <span class=\"n\">information</span> <span class=\"n\">about</span> <span class=\"n\">the</span> <span class=\"n\">errors</span> <span class=\"n\">and</span> <span class=\"n\">possible</span> <span class=\"n\">solutions</span><span class=\"o\">,</span> <span class=\"n\">please</span> <span class=\"n\">read</span> <span class=\"n\">the</span> <span class=\"n\">following</span> <span class=\"nl\">articles:</span>\n<span class=\"o\">[</span><span class=\"n\">ERROR</span><span class=\"o\">]</span> <span class=\"o\">[</span><span class=\"n\">Help</span> <span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"nl\">http:</span><span class=\"o\">//</span><span class=\"n\">cwiki</span><span class=\"o\">.</span><span class=\"na\">apache</span><span class=\"o\">.</span><span class=\"na\">org</span><span class=\"o\">/</span><span class=\"n\">confluence</span><span class=\"o\">/</span><span class=\"n\">display</span><span class=\"o\">/</span><span class=\"n\">MAVEN</span><span class=\"o\">/</span><span class=\"n\">MojoExecutionException</span></code></pre></div><p>当我遇到这个问题的时候，先是在网上查询bug的相关问题，但是都没有解决我的问题，不知道是他们没发现还是我细心！到最后我都查到stackoverflow上了，那个外国人的解答感觉接近我的答案，但是还不是直接解决办法。</p><p>最后我点击我的pom.xml文件中的那个关于maven-surefire-plugin的地方，它显示如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b737a121dc785853fe6e16f2c5e94336_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb\" width=\"1248\" data-original=\"https://pic3.zhimg.com/v2-b737a121dc785853fe6e16f2c5e94336_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1248&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1248\" data-rawheight=\"363\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1248\" data-original=\"https://pic3.zhimg.com/v2-b737a121dc785853fe6e16f2c5e94336_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b737a121dc785853fe6e16f2c5e94336_b.jpg\"/></figure><p>看到上面显示的是2.12，然后根据提示jump to location ,到如下图处：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-44c63a0b1ef40fc79b402033d901c5d7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1202\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb\" width=\"1202\" data-original=\"https://pic4.zhimg.com/v2-44c63a0b1ef40fc79b402033d901c5d7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1202&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1202\" data-rawheight=\"50\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1202\" data-original=\"https://pic4.zhimg.com/v2-44c63a0b1ef40fc79b402033d901c5d7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-44c63a0b1ef40fc79b402033d901c5d7_b.jpg\"/></figure><p>它bug中显示的有关这个版本号的地方：</p><p>Failed to execute goal org.apache.maven.plugins:maven-surefire-plugin:<b>2.12</b>:test (default-test) on project pfcase: Error while executing forked tests.; nested exception is java.io.IOException: Cannot run program &#34;cmd.exe&#34; (in directory &#34;G:\\Users\\Administrator\\workspace\\bugCatcher&#34;): CreateProcess error=740, 请求的操作需要提升。 -&gt; [Help 1]</p><p>后面我就去repository中去看这个插件的位置，如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5199af976a410b347a52f1483019e9f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-5199af976a410b347a52f1483019e9f7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;940&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"940\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"940\" data-original=\"https://pic4.zhimg.com/v2-5199af976a410b347a52f1483019e9f7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5199af976a410b347a52f1483019e9f7_b.jpg\"/></figure><p>发现有两个版本号，一个2.12，另一个2.12.4，当时的想法就是会不会我用的2.12在2.12.4高版本的情况下不兼容（也或者这个2.12.4是maven版本自带的插件版本号），后来果断用2.12.4，如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8acc9add430facadda4810bbc90a439d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb\" width=\"846\" data-original=\"https://pic2.zhimg.com/v2-8acc9add430facadda4810bbc90a439d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;846&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"846\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"846\" data-original=\"https://pic2.zhimg.com/v2-8acc9add430facadda4810bbc90a439d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8acc9add430facadda4810bbc90a439d_b.jpg\"/></figure><p>再次构建maven项目，ok，问题解决！</p><p>总结：这个问题就是版本的不兼容导致的，所以报maven-surefire-plugin:<b>2.12</b>:test (default-test) on project pfcase，在测试这个插件的时候报错，最终导致 Cannot run program &#34;cmd.exe&#34; 和CreateProcess error=740, 请求的操作需要提升。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/33098950", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "Java职业路上的阶段性总结和反思", 
            "content": "<p>今天，偶尔翻翻李刚的软件编程书，看到他写的一篇献给广大软件开发者的文章——如何学习Java。我很受感动，觉得他说的一些内容震撼到我，我有必要在读完他的文章后，进行反思和总结，结合我自身的软件学习和从业经历，问问自己内心，到底有没有达到应有的水平，到底我自己对于软件开发整个最基础的东西有没有完全掌握。接下来根据他的文章，进行反思。</p><p>往往很多软件开发者，刚开始很有兴趣投入代码的学习，久而久之，大部分常见问题都问遍了，最后也可以从事一些重复性开发，但一旦遇到新的问题，又将束手无策。</p><p>针对上面的现象，我认为很有必要总结一下自己，我觉得我需要加强这方面的能力，面对新的技术难题，可以通过自己查阅资料，弄懂原理，总结技术。当然这方面我做的挺好，但是还要加强，尽量减少解决新问题的时间，其实这方面也有技巧，只有不断熟练整个流程就好了，像有些人在这过程中会养成去stackoverflow寻求解决办法，那上面毕竟来自世界各地的软件技术大咖，说不定你哪个问题就被软件之父啥的瞄到，帮你解决了呢！当然还有很多人会注册啥啥之类的，上面有专门的、详细的技术文档供查阅等。这些途径我都觉得很好，以后遇到不懂的技术专词，不管中文还是英文，先用笔记下来，后面慢慢学习了解！</p><p>要想知道，企业招聘一个软件员，不是让你去复制粘贴，每天机械的搬运代码，像这样的情况是非常糟糕的，只懂基本原理，搬运代码，去公司干活，薪资肯定会打折的，这是毋庸置疑的，要想自己把自己技术提高到牛逼的境界，那是需要自身有不断的探索和学习的能力，面对新的事物要迎难而上！知其所以然，还能再玩出其他花样，那就是创新！</p><p>我之前的一个公司同事小刘（化名），在公司开发的地位处于中间级别，工作了大概2年时间，工资大概8000~10000的样子。记得有一次跟他去吃饭，便问了下他关于软件开发的见解，毕竟别人是前辈嘛，那当然需要谦虚请教下了！谁知道，他给我回了一句“Java开发没啥技术含量的，到最后就是赋值粘贴，如果不赶任务（有些功能需求急着生产上线啊等），每天的工作很傻瓜似的”。我当时听到这句话，顿时懵逼了一会儿，然而再问道；“那你觉得啥职业更有技术含量些，对于我们这个大专业来说？”接下来就是他一顿海说！但是当时那个公司牛逼的架构师的表现就反驳了他这点，由于架构师也担任我们的副主管，基本上所有的事情都是他管！每次一解决问题，别人问他问题所在，不管跟这个专业相不相关，他都答得有条有理，很有说服力！感觉他啥都懂！</p><p>还有一个人也佐证了小刘的想法是不对的，那就是我的带领人（公司产品研发经理），说起他就很是佩服了，解决问题的能力那是没得说，不管专业上的啥技术问题，他都懂的很深，原理啥的，他把握的非常清楚，玩eclipse玩的飞的起，速度非常快，英文问题也是如此！这是为啥，肯定是非常懂得它熟悉它，才会这么快嘛！所以他的工资就是杠杠的（仅次于架构师），每次别人都要寻求他的帮助，可以称得上真正的大神，感觉他很多技术他都深入专研过，提供的技术方案，说的别人不得不服，这是很值得学习的地方！并且他们回家都有一个习惯就是专研技术问题！（这是我需要学习的地方）</p><p>最简单的问题，李刚老师也提出来了，就是我们所用的框架，知道为啥要用，这个是很重要的！还有一个，他说的很好“我们的程序员把Java当成一种脚本，而不是一门面向对象的语言。他们习惯了在jsp脚本中使用Java，但从不去想jsp如何运行，web服务器里的网络通信、多线程机制，为何一个jsp页面能同时向多个请求者提供服务？更不会想如何开发web服务器；他们像代码机器一样编写spring bean代码，但从不去理解spring容器的作用，更不会想如何开发spring容器”。这是许多程序员的弊病！有点像拿来主意。</p><p>原理的深究，肯定是耐人寻味的，不要怕麻烦，要经得起枯燥乏味的过称，当达到我上面那个带领人的水平，你回过头来，你一定会很欣慰自己当初的表现，至少没有白混过，过的还是挺充实的，最起码对的起我们这个职业，这份工作！</p><p>我现在遇到许多不懂的地方，都会去分析查阅文献，翻看博客网站！直到弄懂它，不管它有多基础，我都会学会去分析它，这是我觉得至今以来，我做的对的一点！当然还有很多需要学习和挖掘的东西等待着我去探索！</p><p>在此做个总结，一个是为了激励自己，二个是为了以后专业技术的提高做个总结，把握正确的方向！秉承“不浮躁”的态度，对待技术！</p>", 
            "topic": [
                {
                    "tag": "Java 程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19629329"
                }, 
                {
                    "tag": "总结", 
                    "tagLink": "https://api.zhihu.com/topics/19572201"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/32847441", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "bshare分享插件的使用", 
            "content": "<p>bshare分享插件很强大，使用它只需引入两个js链接:</p><p>&lt;script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;<br/>src=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//static.bshare.cn/b/buttonLite.js%23style%3D-1%26uuid%3D%26pophcol%3D2%26lang%3Dzh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">static.bshare.cn/b/butt</span><span class=\"invisible\">onLite.js#style=-1&amp;uuid=&amp;pophcol=2&amp;lang=zh</span><span class=\"ellipsis\"></span></a>&#34;&gt;&lt;/script&gt;<br/>&lt;script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34;  src=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//static.bshare.cn/b/bshareC0.js\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">static.bshare.cn/b/bsha</span><span class=\"invisible\">reC0.js</span><span class=\"ellipsis\"></span></a>&#34;&gt;&lt;/script&gt;</p><p>以上是使用bshare分享插件前提！</p><p>实现代码很简单，以下为新浪新闻网站的源代码里拔出来的</p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>&lt;%@ page language=&#34;java&#34; contentType=&#34;text/html; charset=utf-8&#34; </li><li>pageEncoding=&#34;utf-8&#34;%&gt; </li><li>&lt;!DOCTYPE html PUBLIC &#34;-//W3C//DTD HTML 4.01 Transitional//EN&#34; &#34;<a href=\"https://link.zhihu.com/?target=http%3A//www.w3.org/TR/html4/loose.dtd\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">w3.org/TR/html4/loose.d</span><span class=\"invisible\">td</span><span class=\"ellipsis\"></span></a>&#34;&gt; </li><li>&lt;html&gt; </li><li>&lt;head&gt; </li><li>&lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=utf-8&#34;&gt; </li><li>&lt;title&gt;Insert title here&lt;/title&gt; </li><li>&lt;/head&gt; </li><li>&lt;body&gt; </li><li>&lt;div class=&#34;content_line&#34;&gt;&lt;/div&gt; </li><li>&lt;span style=&#34;white-space:pre;&#34;&gt; &lt;/span&gt;&lt;div class=&#34;content_print content-tools-wrap&#34;&gt; </li><li>&lt;!-- 分享功能 begin --&gt; </li><li>&lt;div class=&#34;content-tools-share  bshare-custom icon-medium&#34; data-sudaclick=&#34;content_share&#34;&gt; </li><li>&lt;span class=&#34;content-tools-share-label&#34; class=&#34;shareto_normaltxt&#34;&gt;分享到:&lt;/span&gt; </li><li>&lt;div class=&#34;bsPromo bsPromo2&#34;&gt;&lt;/div&gt; </li><li>&lt;a title=&#34;分享到新浪微博&#34; class=&#34;bshare-sinaminiblog&#34;&gt;&lt;/a&gt; </li><li>&lt;a title=&#34;分享到QQ空间&#34; class=&#34;bshare-qzone&#34; href=&#34;javascript:void(0);&#34;&gt;&lt;/a&gt; </li><li>&lt;a title=&#34;分享到微信&#34; class=&#34;bshare-weixin&#34; href=&#34;javascript:void(0);&#34;&gt;&lt;/a&gt; </li><li>&lt;a title=&#34;分享到人人网&#34; class=&#34;bshare-renren&#34;&gt;&lt;/a&gt; </li><li>&lt;a title=&#34;分享到网易微博&#34; class=&#34;bshare-neteasemb&#34;&gt;&lt;/a&gt; </li><li>&lt;a title=&#34;更多平台&#34; class=&#34;bshare-more bshare-more-icon more-style-addthis&#34;&gt;&lt;/a&gt; </li><li>&lt;span class=&#34;BSHARE_COUNT bshare-share-count&#34; style=&#34;float: none;&#34;&gt;0&lt;/span&gt; </li><li>&lt;/div&gt; </li><li>&lt;span style=&#34;color:#ff0000;&#34;&gt;&lt;script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34; &lt;span style=&#34;white-space:pre;&#34;&gt; &lt;/span&gt;src=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//static.bshare.cn/b/buttonLite.js%23style%3D-1%26uuid%3D%26pophcol%3D2%26lang%3Dzh\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">static.bshare.cn/b/butt</span><span class=\"invisible\">onLite.js#style=-1&amp;uuid=&amp;pophcol=2&amp;lang=zh</span><span class=\"ellipsis\"></span></a>&#34;&gt;&lt;/script&gt; </li><li>&lt;script type=&#34;text/javascript&#34; charset=&#34;utf-8&#34; src=&#34;<a href=\"https://link.zhihu.com/?target=http%3A//static.bshare.cn/b/bshareC0.js\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">static.bshare.cn/b/bsha</span><span class=\"invisible\">reC0.js</span><span class=\"ellipsis\"></span></a>&#34;&gt;&lt;span style=&#34;white-space:pre;&#34;&gt; &lt;/span&gt; &lt;/script&gt;&lt;/span&gt; </li><li>&lt;!-- 划词分享 --&gt; </li><li>&lt;!-- 分享功能 end --&gt; </li><li>&lt;/div&gt; </li><li>&lt;div class=&#34;content_line&#34;&gt;&lt;/div&gt; </li><li>&lt;/body&gt; </li><li>&lt;/html&gt; </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>又有人反应在ajax动态加载的时候，采用bshare增加分享功能的时候，出现不是重复绑定事件，就是会丢失事件，异步加载的原因让开发者很为难，但是在剥新浪的网页消息的源代码的时候，其实已经为我们做好啦js异步加载，以下就是：</p><ol><li>//js异步加载管理 v1.1.0  </li><li>eval(function(p,a,c,k,e,r){e=function(c){return(c&lt;62?&#39;&#39;:e(parseInt(c/62)))+((c=c%62)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(&#39;0&#39;.replace(0,e)==0){while(c--)r[e(c)]=k[c];k=[function(e){return r[e]||e}];e=function(){return&#39;[4-9abfgj-vx-zA-R]&#39;};c=1};while(c--)if(k[c])p=p.replace(new RegExp(&#39;\\\\b&#39;+e(c)+&#39;\\\\b&#39;,&#39;g&#39;),k[c]);return p}(&#39;(9(){b w=g,d=document,u=\\&#39;1.1.0\\&#39;,7={},j=0,cbkLen=0;5(w.k){5(w.k.u&gt;=u){o};7=w.k.K();j=7.j};b addEvent=9(x,B,C){5(x.L){x.L(&#34;on&#34;+B,C)}m{x.addEventListener(B,C,false)}};9 M(a,D,s){b l=d.createElement(&#34;script&#34;);l.type=&#34;text/javascript&#34;;5(s){l.s=s};l.N=l.y=9(){5(!g.E||g.E==&#34;loaded&#34;||g.E==&#34;complete&#34;){5(D){D()};l.N=l.y=null;l.parentNode.removeChild(l)}};l.src=a;b h=d.getElementsByTagName(&#34;head&#34;)[0];h.insertBefore(l,h.firstChild)};b v=9(4,a){g.4=4;g.a=a;g.6=[]};v.prototype={f:\\&#39;O\\&#39;,y:9(){g.f=\\&#39;F\\&#39;;b z=[];P(b i=0;i&lt;g.6.j;i++){5(n g.6[i]==\\&#39;9\\&#39;){try{g.6[i]()}catch(e){z.A(e)}}};g.6=[];5(z.j!=0){throw z[0]}}};b k=9(q,t){b 8={};5(p.j==3){8.4=p[0];8.a=p[1];8.6=p[2]}m 5(n q===\\&#39;Q\\&#39;){8.a=q;5(n t===\\&#39;9\\&#39;){8.6=t}}m{8=q};b a=8.a||&#34;&#34;,4=8.4||&#34;&#34;,6=8.6||&#34;&#34;,s=8.s||&#34;&#34;;b r={4:4,k:9(q,t){b agms=p;b 8={};5(p.j==3){8.4=p[0];8.a=p[1];8.6=p[2]}m 5(n q===\\&#39;Q\\&#39;){8.a=q;5(n t===\\&#39;9\\&#39;){8.6=t}}m{8=q};5(!8.4){8.4=\\&#39;R\\&#39;+j;j++};b c=k({4:g.4,6:9(){k(8)}});c.4=8.4;o c}};5(4){5(!7[4]){5(!a){7[4]=G v(4);7[4].f=\\&#39;H\\&#39;}m{7[4]=G v(4,a)};j++}m 5(7[4].f==\\&#39;H\\&#39;&amp;&amp;a){7[4].f=\\&#39;O\\&#39;};5(8.f){7[4].f=8.f};5(7[4].f==\\&#39;I\\&#39;||7[4].f==\\&#39;H\\&#39;){5(n 6==\\&#39;9\\&#39;){7[4].6.A(6)};o r}m 5(7[4].f==\\&#39;F\\&#39;){5(n 6==\\&#39;9\\&#39;){6()};o r}}m{5(!a){o r};P(b J in 7){5(7[J].a==a){4=J;break}};5(!4){4=\\&#39;R\\&#39;+j;7[4]=G v(4,a);j++};r.4=4;5(7[4].f==\\&#39;I\\&#39;){5(n 6==\\&#39;9\\&#39;){7[4].6.A(6)};o r}m 5(7[4].f==\\&#39;F\\&#39;){5(n 6==\\&#39;9\\&#39;){6()};o r}};5(n 6==\\&#39;9\\&#39;){7[4].6.A(6)};M(a,9(){7[4].y()},s);7[4].f=\\&#39;I\\&#39;;o r};w.k=k;w.k.u=u;w.k.K=9(){o 7}})();&#39;,[],54,&#39;||||name|if|callback|data|cfg|function|url|var||||status|this|||length|jsLoader|scriptNode|else|typeof|return|arguments|op|chain|charset|fn|version|JsObj||obj|onload|errors|push|eventType|func|dispose|readyState|ok|new|waiting|loading|item|getData|attachEvent|getScript|onreadystatechange|init|for|string|noname&#39;.split(&#39;|&#39;),0,{}))  </li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>其中还有一个要说的就是uuid的获取，把自己的网站在bshare后台添加，就可以追踪分享数据了！</p><p>uuid    自己的UUID（Publisher UUID）。如果要追踪分享数据则必须提供此选项，在bShare后台添加网站即可得到UUID。  </p>", 
            "topic": [
                {
                    "tag": "bShare", 
                    "tagLink": "https://api.zhihu.com/topics/19593934"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31538534", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 0, 
            "title": "<s:iterator>标签遍历动态数组<泛型>：ArrayList<对象>，怎样批量修改数据并一起提交到后台", 
            "content": "<p>这个&lt;s:iterator&gt;标签属于一个迭代器，用于将集合迭代输出，刚开始我把它应用于实战的时候，发现很多疑惑，这在很多网上的文章中都没有提到过，而且大家都是照搬理论知识往自己博客一帖完事，但是真正的实际问题还是不能得到解决，这个标签在用之前，自己先翻了书籍看了struts标签&lt;s:iterator&gt;这章,将基础的理论知识梳理了一遍，然后摸索着去解决掉！</p><p>在用之前可能遇到的问题，我可能开发经验有限，所以对这种标签“从无到一”熟练过程中，有过很多疑惑，希望把这些问题写下来给后者的开发人员提供一点帮助！</p><p>以下是我当时的疑惑：</p><p>1、这个标签在遍历集合的时候，对象被迭代遍历出来，然后供每个字段输出的input标签其中的name属性只有一个名字，也就是每个对象的相同字段name是一样的，那我修改提交后的name属性数据代表的是第一个对象的还是最后一个对象的？</p><p>&lt;s:iterator value=&#34;bookList&#34; status=&#34;st&#34; id=&#34;a&#34;&gt;<br/>&lt;input type=&#34;text&#34; id=&#34;bookList&#34; value=&#34;&lt;s:property value=&#34;bookList&#34;/&gt;&#34; style=&#34;display: none&#34;&gt;<br/>&lt;s:set name=&#34;zz&#34; value=&#34;#a.size()&#34;&gt;&lt;/s:set&gt;<br/>&lt;tr&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;s:property value=&#34;#a.name&#34;/&gt;&lt;/td&gt;<br/>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;bookValue&#34;</b>  id=&#34;bookValue&lt;s:property value=&#34;#st.count&#34;/&gt;&#34; value=&#34;&lt;s:property value  =&#34;#a.bookValue&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;bookPrice&#34;</b> id=&#34;bookPrice&lt;s:property value=&#34;#st.count&#34;/&gt;&#34; value=&#34;&lt;s:property value = &#34;#a.bookPrice&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;bookTitle&#34;</b> id=&#34;bookTitle&lt;s:property value=&#34;#st.count&#34;/&gt;&#34; value=&#34;&lt;s:property value = &#34;#a.bookTitle&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;bookMes&#34;</b>  id=&#34;bookMes&lt;s:property value=&#34;#st.count&#34;/&gt;&#34; value=&#34;&lt;s:property value =&#34;#a.bookMes&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;value&#34;</b> id=&#34;value&lt;s:property value=&#34;#st.count&#34;/&gt;&#34; value=&#34;&lt;s:property value = &#34;#a.value&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;td rowspan=&#34;&lt;s:property value=&#34;#zz&#34;/&gt;&#34; style=&#34;display: none&#34;&gt;&lt;input type=&#34;text&#34; <b>name=&#34;bookListId&#34;</b> value=&#34;&lt;s:property value = &#34;#a.id&#34;/&gt;&#34;&gt;&lt;/td&gt;</p><p>&lt;/tr&gt;</p><p>&lt;/s:iterator&gt;</p><p>从上面代码看的话，我刚开始以为后面的数据会覆盖前面的数据，但是转折点在我测试的时候，仔细看了下报出的错误，里有表示我的bookValue、bookPrice、bookTitle等这些是集合并且后面集合中出现的数据就是我提交的数据，并且提示不能匹配，看到这里我兴奋了，因为问题终于弄明白了，我需要在后台，把每个字段的name属性名以一个集合的形式去getter和setter,如：</p><p>private ArrayList bookValue;<br/>private ArrayList bookPrice;<br/>private ArrayList bookTitle;<br/>private ArrayList bookMes;<br/>private ArrayList value;</p><p>private ArrayList bookListId;<br/></p><p>之后就是getter和setter。</p><p>把数据提交到后台之后就进行数据的修改操作就是了！</p>", 
            "topic": [
                {
                    "tag": "Struts", 
                    "tagLink": "https://api.zhihu.com/topics/19568296"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31339859", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "form表单提交问题，name属性的getter\\setter", 
            "content": "<p>问题出现背景：</p><p>当时在实际项目中，我是没注意到我有两个input标签的name属性变量同名了，于是在提交的时候总是报Can not find action ,并提示没定义这个文件路径，也就是form中action匹配不到struts.xml文件中定义的逻辑视图路径！</p><p>解决问题步骤：</p><p>刚开始我很看到那个错误的第一反应就是更改路径，让其匹配成功，谁知道各种路径方式都试过了，而且还和之前的有form标签的jsp文件进行对照，发觉我的路径问题没问题，提交还是报同样的错误，这个时候内心是非常烦躁的，我于是只能用出杀手锏了，一个页面也就那么多行代码，我就先只留form表单标签，并在后台相对应的action方法中直接给return success,然后提交，它是通过的！然后往中间一步步取出隐藏的块代码！再试的过程中，你还别说，有重大发现，于是就发现我的两个input标签的name属性变量名称相同，当我改完之后，问题解决！</p><p>错误分析：</p><p>我们都知道，往往name属性再提交的时候，都是以一个变量或对象中某个字段变量来提交的，之后action（Controller里有此对象字段变量或变量的getter和setter方法）获取值。当我唯独以变量的方式去提交的时候，获取的过程出现问题，它堆栈追踪就报获取不到路径问题！在form提交的时候，相同的两个变量名称各自换一下变成唯一，jsp就可以提交了，然后我到我后台action，发现有定义原先那个相同的变量名，并且设置了 getter和setter方法；于是我又试着用对象的两个相同字段变量测试了下，发现是提交通过的（而且我这个对象在action里面也是有getter和setter方法的），这时候引发我想对源码的分析，想知道到底底层源码在form提交之后，其页面的属性值是怎样去被action页面的getter和setter方法获取的！问题的出现和底层源码setter和getter具体实现过程是怎样的一个关系！</p><p>源码分析：</p><p>针对上面的问题，接下来就是源码的解剖了，（说到这里来句题外话，其实程序员做到最后，跟医生差不多，解剖知悉原理，应用于临床更加有经验，哈哈），言归正传！其实问题的根源就是：对象和变量getter和setter的区别</p><p>大家知道，内省是 Java 语言对 Bean 类属性、事件的一种处理方法（也就是说给定一个javabean对象，我们就可以得到/调用它的所有的get/set方法）。例如类 A 中有属性 name, 那我们可以通过 getName,setName 来得到其值或者设置新的值。通过 getName/setName 来访问 name 属性，这就是默认的规则。 Java 中提供了一套 API 用来访问某个属性的 getter/setter 方法，通过这些 API 可以使你不需要了解这个规则，这些 API 存放于包 java.beans 中。然而，我们单个属性去设置getter和setter的话，那么提交的时候，相当于同时setter两次，这时肯定会出错了，但是对象就不同了，查看源码和资料知道，通过类 Introspector 来获取某个对象的 BeanInfo 信息，然后通过 BeanInfo 来获取属性的描述器（ PropertyDescriptor ），通过这个属性描述器就可以获取某个属性对应的 getter/setter 方法，然后我们就可以通过反射机制来调用这些方法。如果对象的name相同，但是它在action是以类的setter和getter，而且先获取类在通过类Introspector来获取类中属性信息，如果有此类属性字段就获取，无此类属性字段就不获取，所以真相解开！</p><p>总结：在stutrs2开发中jsp的设计，name属性值最好是对象.属性格式！好处理，规范化！</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/30375974", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "Java实战有感01", 
            "content": "<p>在开始拿起书本学习struts2之前，对struts2理论掌握不是很全面，只在实践中做过一些struts2的项目，以及在进入新公司，前辈带领下，又是一种struts编程风格（很实用，高效），又学到了很多！在将近半个月的struts2学习中，我先学习了轻量级Java ee企业应用实战（第四版），之后又学习struts2技术内幕！</p><p>通过这次的学习，对以前我做过的相关struts2项目和现在公司项目有了一个清楚的把握，知道为什么这么做，这样做的理由，和这样做的好处，把来龙去脉都掳了一遍！轻量级那本书说的很繁琐，知识点很多，但是又没完全深入，刚好技术内幕这本书填补了它的那个空缺！struts2框架在典型的三层结构的开发模式中被视为表示层得解决方案，最为核心的内容就是和web容器打交道，帮助我们处理http请求！</p><p>在轻量级这本书中，前辈教我的那些规范，这本书里面都有提及到，都有详细的解释和例子，有些地方会说明这样做的缘由。在web.xml中struts2过滤器的配置和在struts2.xml文件中的action配置，拦截器的设置，以及逻辑视图名和物理资源之间的映射，还有关于action充当业务控制器，strutsPrepareAndExecuteFilter充当核心控制器等的原理都熟悉了一下。jsp中OGNL表达式的使用（当然也可以访问静态成员）。redirect和redirectAction都是重新生成请求，请求参数和请求属性和前一个action的处理结果都会丢失。书中也扩展了一些其他重要知识，比如在标签内指定var属性（相当于id），在拼接集合时很有效，只需用OGNL表达式进行输出，同时value取值时在前面加#。当指定var属性，那么意味着标签内的集合或者javabean等都会放到stackContext,如果不在标签内，也可以通过var属性来访问该javabean或集合。struts2使用标准的context来进行OGNL表达式的语言求值，OGNL的顶级对象是stack Context(map类型-数据结构)，其根对象就是valueStack（当系统创建action实例后，该Action实例已经保存到valueStack中），不过在标签的标签体内，位于valueStack临时生成的集合在标签结束时是会移出valueStack。说到这里,不得不提及最常用的property标签，它属性value值不指定的时候，默认输出valueStack栈顶的值，其实很多标签都是这样，默认输出valueStack栈顶值。struts2标签，其实还蛮强大的，非常丰富，拼接、迭代、排序、控制、数据等。但不得不提的是，对于表单标签而言，name和value属性之间存在一个特殊的关系，因为每个表单元素会映射成action属性，所以如果某个表单对应的Action已经被实例化（该表单提交过）、且其属性有值时，则该Action对应表单里的表单元素会显示出该属性的值，这个值将是表单的value值；name属性设置表单元素的名字，表单元素的名字实际上封装着一个请求参数，而请求参数是被封装到Action属性的。</p><p>通过以前项目（用的servlet）和现在的公司项目（用action）,引发我对这两者的深入思考，最后发现struts2与servlet的关系：在struts2中，可以通过ServletActionContext.getRequest()获取request对象，在action的方法中return一个字符串也就是逻辑视图名，该字符串对应struts2.xml中的result标签的name，result标签中包含的就是跳转页面，其中实现原理在我刚开始也是朦胧的，因为前面用的servlet,现在突然用的是action，还这么简捷，高效的运行起来。在写项目的时候，我就有发现根本使用不来servlet,原因是页面的请求都被struts2给拦截了，根本访问不了servlet! 其原理经过查阅资料后得知：struts2对servlet进行了封装，并结合filter配合使用。其原理步骤如下：</p><p>一、客户端提起一个（HttpServletRequest）请求，像在浏览器中输入的</p><p>url；</p><p>二、请求被提交到mvc模型的过滤器filter中，如ActionContextCleanUp</p><p>、StrutsPrepareAndExecuteFilter；</p><p>三、 StrutsPrepareAndExecuteFilter是控制器的核心，将它初始化并启用核心doFilter;</p><p>四、StrutsPrepareAndExecuteFilter询问ActionMapper（判断它是否为空）是否需要调用某个Action来处理这个（request或response）请求,最终会去访问valueStack并取值！如果ActionMapper需要调用某个Action，StrutsPrepareAndExecuteFilter把请求的处理交给ActionProxy ;</p><p>五、ActionProxy通过询问框架的配置文件struts2.xml，找到需要调用的Action类;</p><p>六、ActionProxy创建一个ActionInvocation的实例，ActionInvocation会根据配置文件加载Action相关的Interceptor(拦截器)，然后ActionInvocation通过代理模式调用Action 。</p><p>总体上来说，比直接使用servlet方便很多，最起码的一点就是维护起来挺好的。</p><p>在了解了valueStack、ActionContext、stackContext之后，又有疑惑，他们之间的具体联系，以及是怎么表现的，于是我又查阅了下，其定义如下：</p><p>1、valueStack:里面存放的是Action类中通过set方法设置的属性值（表单传 </p><p>过来的值等），由OGNL框架实现；</p><p>2、stackContext:也是用来存值的，stack上下文，它包含一些列对象，包括request/session/attr/application map等；</p><p>3、actionContext:是action的上下文，可以得到request和session、application等。</p><p>这三者在jsp中被访问时也是有所不同的，我们在jsp页面中访问valueStack的内容时，是不用加#，如果访问stack context 的其他对象则要加上#。对于ActionContext，它在一个线程（执行http请求）只有一个，生命周期是一次请求，作用在一次HTTP请求范围内！这跟valueStack是一样的！只不过valueStack是值栈，而actionContext是Map类型-映射结构。需要注意的是，只有运行在request线程中的代码才能调ActionContext.getContext()，否则返回的是null 。</p><p>以前对这些框架只知道用，但不知道为啥要用。不同的框架有不同的特点，有各自领域的优势，想起上家公司的框架，我这才猛然觉醒，他们那些框架为啥要那样搭载。我对struts2技术内幕书本有句话印象很深刻，那就是：框架是一组程序的集合，包含了一系列的最佳实践，作用是解决某个领域的问题，不同的框架，只是为了解决不同领域的问题。</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/30375813", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 0, 
            "title": "实战Java有感02", 
            "content": "<p>在做完那三个模块后，觉得有必要写一篇总结，来记录自己的优点和缺点，这样使我在以后的工作生涯中，不断进步！这次任务总共涉及三个模块，总表配置、实验具体配置、房间配置；在接到任务的时候，我也是很有方案的，结合数据文档，我又在纸上画了一遍整个程序的流程，把思路理清才动手码代码！但是最后实现的过程中，发觉好多步骤设计都不按我原先的计划执行，最初的实施策略还是有所欠缺的！这个问题只有多实战才能解决掉！</p><p>其中遇到的几个问题，第一个问题：集合的集合与对象的集合的区别。开始我在传ajax的时候，发现取得集合的集合不能用对象去接收，我当时还调试了很久，一直显示报错，即使我加了强制转换也无济于事，后来被师傅调试，才发现问题所在。其主要问题是：当你把拿出来的数据以集合的集合形式存取的时候，取出的时候那也是集合的集合，也不能强制用对象去接收；我调试debug没发现这个问题的根本原因是：我想的是用最原始方法取出数据一个个往对象里面插入，但是这个工作量很繁琐，当时大部分小伙伴都会选择这种方式；但没从问题的根源处去寻找解决办法，既然这数据涉及到取出和对象的匹配，那么数据库那块是不是可以找到更好的解决方法，在数据库取出数据的时候就用class对象去接收的话，那么问题就迎刃而解了！这告诉我一个道理，“为有源头活水来”，要想知道这水从哪里来的，那么就必须熟悉源头，最起码你也知道有多少个源头（多少种解决办法）。这也让我意识到底层的源码重要性，所以以后工作中遇到类似的问题时，要懂的把问题延伸到源码的思考上，遇到代码这样写不行，这时要思考源码是不是还会提供其他我们所不知道的方法呢！</p><p>第二个问题：ajax在传值的时候，要在action中写明传值的方式；ajax所在的action方法里所需获取的参数必须通过配置文件去拦截jsp的请求，然后创建action容器，之后看是否存在这个名为**的action等等；所以使用ajax的时候，xml配置文件必须配置，最要提醒的是，ajax传送数据的方式，也要在配置文件中体现出来，不然就会出现异常！</p><p>第三个问题：数据库建表的时候，刚开始想的很简单，随着计划任务的实施，我渐渐的觉得建立中间表，这样会更好跨表取数据，当然这是个误区，因为后面我发觉有这张中间表和没这张中间表一回事，就是多余了！我当时还是听了网上的一些说法，觉得这样做怎样，但是这种也要分情况，像明显不要的就不必强制画蛇添足了！</p><p>对于整个阶段，我还是有一些优点的，普遍的语法是没有问题，简单一句话概括就是：哪些代码该放在哪，我心里有把称！当然很多缺点需要改，还得每天努力更加深入的代码学习和问题的总结，然后代码优化是个漫长而坚持的行动，因为随着自己实战的经历增多，那么自己就更加有经验，写的代码那当然是更加有序了，大的思路在嘛！</p>", 
            "topic": [
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28978153", 
            "userName": "李亮", 
            "userLink": "https://www.zhihu.com/people/80c32c1881f1ac539d35fddbd83a8be2", 
            "upvote": 1, 
            "title": "了解大数据，与时俱进", 
            "content": "<p>今天我想要讲的话题是大数据，平常生活中，我们都有接触，但是为啥很多人就觉得很陌生，甚至有的人觉得很高大上。其实，等你做足一番功课后，你就不会那么惊讶于它的神奇了！</p><p>前几天，在办公室休息聊天的时候，我旁边的小陈（公司行政人员），在接到一个公司电话后，那边是家翻译公司，咨询我们公司是否还需要翻译这方面的服务。我同事当时很纳闷，因为，以前他们就只找过当地一家公司做过翻译，但此时那边资讯的电话人员确是一个外省的不见经传的公司。于是接下来，发生了很尴尬的瞬间，我同事嘴巴对我说了一句：“我以前都没找过这家公司做翻译，他们咋知道我们公司的联系方式，那家本地翻译的公司把我们卖了吧”！</p><p>其实，这种隐私问题，现在生活上出现很多，当然也有出现在本人身上，有几次我很纳闷，就问了对方，为啥他们会知道我的联系方式，他们说是从大数据库里按条件搜寻出来的，当时我就猛然以一种专业的角度去看待这个问题了。因为，毕竟我自己也是IT的从业人员，多多少少会了解一些！有时候，你责怪别人家的时候，可能就被时代给out了，所以，今天特写此篇，来给大家说一下，大数据的基本常识问题！</p><p>从问题出发，分析问题，普及一些见解！</p><p>现在这种隐私问题的发生，也是人们苦恼的，有可能一天需要接上很多个推销的电话，这会让人很逃避，在这方面，确实是大数据带来的问题，由于大数据的概念出现不太久，所以，相对应的数据管理方面的欠缺、不完善也是情由可原。但是，不要被它的缺点蒙蔽了双眼，其实它的利益还是很大的。既然，都能从数据库中取出你的信息，说明你之前可能直接或者间接的在网络系统中（某软件注册过啊，或者公司系统里备案过啊）输入过你的信息；如果往另一方面想，这么多的信息都能获取到，这样是不是就可以知道大部分人的需求！而市场主要是由千千万万人民的需求决定方向的，这在一定程度上会减少社会的资源分配的浪费，可以在生产上有效规避一些不利的情况，引导整个市场向正确的方向发展。我一说起上面这一句话，可能很多人都懵逼了，大数据跟市场扯上啥关系，接下来听我为你慢慢道来。</p><p>打个比方，一个公司注册成立之前，他都会进行调研，看公司的产品是否是人们所需求的，在整个市场是不是具有潜在的发展前景。这时候，有两种方案供他们选择去进行调研，第一个是雇佣大批人在公司要发展的地方（市场）进行挨家挨户的问卷调查，有时候还要考虑其他的因素——可能某个问卷员长相丑陋，别人搪塞回答你的问题等等这些，都会造成数据的很大程度上的不可靠！第二个方法就是花点钱，去大数据服务商进行购买数据（这些服务商公司大多有盈利服务器产品），然后他帮你分地域的给你把信息查出来并卖给你，这时候就会设计“大数据分析”这个词语，有这方面的人给你分析你这个公司营销的这种东西市场上是否需要，在什么时候需要（有的冬天销量大啊或者其他），其实这种大数据分析师很多都存在这种公司，大家都知道连带服务（服务一条龙）。相比第一种方法，第二种直接就是人们平常生活积累的需求习惯在网络中的体现，这是不是更有说服力啊！虽然第二种花费跟第一种差不多或者更高，但是第二种更加准确！因为大的数据是从群众中来的啊，你的公司卖产品，主要是回到群众中去啊，这是不是一个市场的供需关系啊！哈哈。。</p><p>在打个比方，比如你去淘宝上买款必需品——衣服，对吧！当这款衣服在这个季节显示的销售量大的时候，同比其他衣服更加热销，那是不是表示这个类型的衣服是不是有大的市场需求啊！这些信息大数据都会获取到。前一段时间，突然发现淘宝上的搜索栏和推荐栏都是和自己曾经点过的或者搜索过的产品有关，其实它也是根据大数据进行一个算法过程，在进行表现出来这些现象。其实，这里又涉及一个词语“大数据算法”为了更好的高效应用这些大数据信息，优化的算法可以带来事半功倍的效果！</p><p>以上就是我对整个的大数据的一个基础的介绍，以后有补充的相继会推出来！</p><p></p>", 
            "topic": [
                {
                    "tag": "大数据", 
                    "tagLink": "https://api.zhihu.com/topics/19740929"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_123624235"
}
