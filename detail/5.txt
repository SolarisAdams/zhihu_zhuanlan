{
    "title": "编程杂记", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/tan-ding-17", 
        "https://www.zhihu.com/people/zui-chu-de-meng-xiang-63-95", 
        "https://www.zhihu.com/people/hai-zhi-ai-qu", 
        "https://www.zhihu.com/people/chen-xiao-ling-51-72", 
        "https://www.zhihu.com/people/ying-luo-4-62", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/naw-87", 
        "https://www.zhihu.com/people/czw-13-94", 
        "https://www.zhihu.com/people/ssfldsh-61", 
        "https://www.zhihu.com/people/xiao-yu-xiao-yu-43-74", 
        "https://www.zhihu.com/people/zhang-jian-hu", 
        "https://www.zhihu.com/people/stars-31-8-98", 
        "https://www.zhihu.com/people/mi-ni-77-82", 
        "https://www.zhihu.com/people/yangge-97", 
        "https://www.zhihu.com/people/zai-yu-zhong-lang", 
        "https://www.zhihu.com/people/ben-xiu-xian-sheng", 
        "https://www.zhihu.com/people/yuxiameng", 
        "https://www.zhihu.com/people/liu-xing-yu-44-93", 
        "https://www.zhihu.com/people/sean-x-94", 
        "https://www.zhihu.com/people/wuyi-heng", 
        "https://www.zhihu.com/people/nao-dong-bi-tian-da-11", 
        "https://www.zhihu.com/people/sha-yue-zhi-ye-83", 
        "https://www.zhihu.com/people/788605", 
        "https://www.zhihu.com/people/bai-si-huang", 
        "https://www.zhihu.com/people/chui-yan-76-11", 
        "https://www.zhihu.com/people/ai-wen-86-36", 
        "https://www.zhihu.com/people/xiong-a-a-a-30", 
        "https://www.zhihu.com/people/wang-hong-peng-49", 
        "https://www.zhihu.com/people/hu-ren-zong-guan-jun-33-26", 
        "https://www.zhihu.com/people/er-san-3-96-98", 
        "https://www.zhihu.com/people/lang-dang-cheng-xing-jian-shang", 
        "https://www.zhihu.com/people/xie-qing-yan-32-19", 
        "https://www.zhihu.com/people/zhi-meng-66-60", 
        "https://www.zhihu.com/people/zhou-yi-xuan-67-55", 
        "https://www.zhihu.com/people/zhang-lei-37-58-12", 
        "https://www.zhihu.com/people/shi-hong-64-94", 
        "https://www.zhihu.com/people/zhou-chun-ming", 
        "https://www.zhihu.com/people/dong-dong-46-64", 
        "https://www.zhihu.com/people/sheng-shi-suo-yuan-17", 
        "https://www.zhihu.com/people/kong-du-59", 
        "https://www.zhihu.com/people/li-lu-52-25", 
        "https://www.zhihu.com/people/fan-sheng-jie", 
        "https://www.zhihu.com/people/ku-li-c-15", 
        "https://www.zhihu.com/people/du-gu-yu-shen", 
        "https://www.zhihu.com/people/an-xue-chen-44", 
        "https://www.zhihu.com/people/chi-gua-de-lu-ren-bing-45", 
        "https://www.zhihu.com/people/tian-xia-94-70-20", 
        "https://www.zhihu.com/people/mu-hou-zhi-ren-70", 
        "https://www.zhihu.com/people/zhang-yang-95-96-67", 
        "https://www.zhihu.com/people/jiang-yong-85-23", 
        "https://www.zhihu.com/people/itriecheung", 
        "https://www.zhihu.com/people/cao-ni-ma-19-19", 
        "https://www.zhihu.com/people/you-xi-ren-huan", 
        "https://www.zhihu.com/people/yin-shang-mo", 
        "https://www.zhihu.com/people/bu-le-11", 
        "https://www.zhihu.com/people/yu-shen-zhu-92", 
        "https://www.zhihu.com/people/fff-82-35", 
        "https://www.zhihu.com/people/ceng-wen-tao-2", 
        "https://www.zhihu.com/people/yang-fan-52-59", 
        "https://www.zhihu.com/people/miko-98-50", 
        "https://www.zhihu.com/people/chun-huo-61-48", 
        "https://www.zhihu.com/people/ma-jun-99", 
        "https://www.zhihu.com/people/sjsjjxjx", 
        "https://www.zhihu.com/people/li-zhi-jun-12", 
        "https://www.zhihu.com/people/yu-zhang-59-82", 
        "https://www.zhihu.com/people/li-dan-96-29-50", 
        "https://www.zhihu.com/people/hkcs", 
        "https://www.zhihu.com/people/shi-ai-nian-hua", 
        "https://www.zhihu.com/people/zheng-run-ze-89", 
        "https://www.zhihu.com/people/chen-se-se-39-47", 
        "https://www.zhihu.com/people/wang-xing-48-61", 
        "https://www.zhihu.com/people/yi-ge-49-67", 
        "https://www.zhihu.com/people/reed-84-49", 
        "https://www.zhihu.com/people/george-78-5", 
        "https://www.zhihu.com/people/ze-ze-83-75", 
        "https://www.zhihu.com/people/jie-gua-26", 
        "https://www.zhihu.com/people/aiy-71-54", 
        "https://www.zhihu.com/people/lu-yu-27-53", 
        "https://www.zhihu.com/people/shuang-ri-tian", 
        "https://www.zhihu.com/people/lingzhi_song", 
        "https://www.zhihu.com/people/zhang-yu-kang-34", 
        "https://www.zhihu.com/people/lue-lue-lue-lue-lue-65-51", 
        "https://www.zhihu.com/people/wang-liao-3-35", 
        "https://www.zhihu.com/people/lao-yao-63-13", 
        "https://www.zhihu.com/people/li-zi-hu-93", 
        "https://www.zhihu.com/people/malloc-41", 
        "https://www.zhihu.com/people/jian-xiao-jian-13", 
        "https://www.zhihu.com/people/ming-tian-hui-geng-hao-85-14", 
        "https://www.zhihu.com/people/pppttt2011", 
        "https://www.zhihu.com/people/jiang-zhi-er-47", 
        "https://www.zhihu.com/people/wu-wen-dong-21", 
        "https://www.zhihu.com/people/ni-yan-ye", 
        "https://www.zhihu.com/people/ai-sheng-huo-12", 
        "https://www.zhihu.com/people/tulufan", 
        "https://www.zhihu.com/people/zhou-mou-52", 
        "https://www.zhihu.com/people/mllong-teng-mo-li", 
        "https://www.zhihu.com/people/4637", 
        "https://www.zhihu.com/people/yiqiexiangqiankan-76", 
        "https://www.zhihu.com/people/shi-kong-han-wei-zhe-8hao", 
        "https://www.zhihu.com/people/yu-feng-zhu-12", 
        "https://www.zhihu.com/people/read-ox", 
        "https://www.zhihu.com/people/Mithril", 
        "https://www.zhihu.com/people/ni-man-wo-man-52-82", 
        "https://www.zhihu.com/people/dong-ge-45-99", 
        "https://www.zhihu.com/people/zheng-le-jun", 
        "https://www.zhihu.com/people/blue-blood-4", 
        "https://www.zhihu.com/people/yan-hang-yu-7", 
        "https://www.zhihu.com/people/wang-hai-tao-17-58", 
        "https://www.zhihu.com/people/xgwclyz", 
        "https://www.zhihu.com/people/shi-ran-87-63", 
        "https://www.zhihu.com/people/wei-xiao-de-hua-jia", 
        "https://www.zhihu.com/people/a560pi5d3", 
        "https://www.zhihu.com/people/jiangfan1991", 
        "https://www.zhihu.com/people/bu-qing-yun-59", 
        "https://www.zhihu.com/people/ye-huan-bu-cuo-19", 
        "https://www.zhihu.com/people/wu-yan-86-83", 
        "https://www.zhihu.com/people/gebierge", 
        "https://www.zhihu.com/people/wen-zi-76-72-81", 
        "https://www.zhihu.com/people/wang-jun-22-94", 
        "https://www.zhihu.com/people/forever-young-59-65", 
        "https://www.zhihu.com/people/duan-cheng-feng-83", 
        "https://www.zhihu.com/people/niubilitycruise", 
        "https://www.zhihu.com/people/may-99-52-4", 
        "https://www.zhihu.com/people/zhang-hao-34-44", 
        "https://www.zhihu.com/people/lan-ling-86-17", 
        "https://www.zhihu.com/people/hao-zi-da-da-44", 
        "https://www.zhihu.com/people/wu-suijian", 
        "https://www.zhihu.com/people/yang-tao-hua", 
        "https://www.zhihu.com/people/chi-kai-feng-86", 
        "https://www.zhihu.com/people/uchiha-zhangtang", 
        "https://www.zhihu.com/people/pa-la-jia-ge-si", 
        "https://www.zhihu.com/people/effort-80", 
        "https://www.zhihu.com/people/mayuyu326", 
        "https://www.zhihu.com/people/qi-yue-57-54", 
        "https://www.zhihu.com/people/dandongsoft", 
        "https://www.zhihu.com/people/yuanyuanss501", 
        "https://www.zhihu.com/people/ma-le-28-27", 
        "https://www.zhihu.com/people/sinnvoll", 
        "https://www.zhihu.com/people/fling-36", 
        "https://www.zhihu.com/people/acm-1", 
        "https://www.zhihu.com/people/allenharris", 
        "https://www.zhihu.com/people/tao-yan-qi-ming-ge-xian-v-50", 
        "https://www.zhihu.com/people/chen-ming-er-99", 
        "https://www.zhihu.com/people/changliwei", 
        "https://www.zhihu.com/people/lu-hao-18", 
        "https://www.zhihu.com/people/a-mao-seprina", 
        "https://www.zhihu.com/people/chi-dao-wen-xue", 
        "https://www.zhihu.com/people/li-rong-rong-41", 
        "https://www.zhihu.com/people/wang-mou-ren-38-54", 
        "https://www.zhihu.com/people/huang-xiu-zhu-1-1", 
        "https://www.zhihu.com/people/li-pu-man-81", 
        "https://www.zhihu.com/people/guan-jiang-yi-15", 
        "https://www.zhihu.com/people/zhonghao-liao-920711", 
        "https://www.zhihu.com/people/zui-ai-wo-jia-xiao-peng-you", 
        "https://www.zhihu.com/people/hu-qian-63-41", 
        "https://www.zhihu.com/people/zyz-76-85", 
        "https://www.zhihu.com/people/mou-mou-mou-31-29", 
        "https://www.zhihu.com/people/tian-gao-ren-yu-fei-42", 
        "https://www.zhihu.com/people/xxw-69-83", 
        "https://www.zhihu.com/people/yan-xiao-you-ran", 
        "https://www.zhihu.com/people/zhui-zhu-xing-fu-de-hou-zi", 
        "https://www.zhihu.com/people/a-mao-91-3-87", 
        "https://www.zhihu.com/people/liu-chun-73-41", 
        "https://www.zhihu.com/people/zhou-ru-xin-19", 
        "https://www.zhihu.com/people/di-yi-59-37", 
        "https://www.zhihu.com/people/wu-qi-79-93", 
        "https://www.zhihu.com/people/calvin-22-81", 
        "https://www.zhihu.com/people/wu-jin-shui-nuan", 
        "https://www.zhihu.com/people/anice-monster", 
        "https://www.zhihu.com/people/hai-mian-bao-bao-59-78", 
        "https://www.zhihu.com/people/risky781", 
        "https://www.zhihu.com/people/winston-chan-15-92", 
        "https://www.zhihu.com/people/liu-yang-32-75-40", 
        "https://www.zhihu.com/people/meng-shang-55-87", 
        "https://www.zhihu.com/people/ban-meng-ban-xing-de-gan-xian-sen", 
        "https://www.zhihu.com/people/Lucky_lucy", 
        "https://www.zhihu.com/people/yang-wang-86-75-88", 
        "https://www.zhihu.com/people/ran-du-3", 
        "https://www.zhihu.com/people/thegodzn", 
        "https://www.zhihu.com/people/xiao-li-yu-15-72", 
        "https://www.zhihu.com/people/shenyindd", 
        "https://www.zhihu.com/people/bei-pao-qi-de-ji-yi", 
        "https://www.zhihu.com/people/elliott-zhang-29", 
        "https://www.zhihu.com/people/ke-ke-mu-92", 
        "https://www.zhihu.com/people/fei-li-13", 
        "https://www.zhihu.com/people/wang-cheng-zi-55-12", 
        "https://www.zhihu.com/people/zy-wang-95", 
        "https://www.zhihu.com/people/he-tao-92-24", 
        "https://www.zhihu.com/people/zhui-zhu-wei-da", 
        "https://www.zhihu.com/people/zhi-hu-zhe-ye-32-42-18", 
        "https://www.zhihu.com/people/bu-ke-si-yi-mao", 
        "https://www.zhihu.com/people/snbqg", 
        "https://www.zhihu.com/people/quan-qing-34", 
        "https://www.zhihu.com/people/pan-jia-jie-8", 
        "https://www.zhihu.com/people/linux-73-20", 
        "https://www.zhihu.com/people/lu-zi-49-93-63", 
        "https://www.zhihu.com/people/xiao-lu-72-84", 
        "https://www.zhihu.com/people/hei-lei-40", 
        "https://www.zhihu.com/people/da-zhi-hui-54", 
        "https://www.zhihu.com/people/fang-chen-69", 
        "https://www.zhihu.com/people/pie-yaya", 
        "https://www.zhihu.com/people/shanli-81", 
        "https://www.zhihu.com/people/guang-tou-xiao-qiang", 
        "https://www.zhihu.com/people/qiao-feng-60", 
        "https://www.zhihu.com/people/dong-xin-xiu", 
        "https://www.zhihu.com/people/mr-right-50-82", 
        "https://www.zhihu.com/people/bei-chen-85-27", 
        "https://www.zhihu.com/people/wang-chang-sheng-69", 
        "https://www.zhihu.com/people/cai-yue-pei", 
        "https://www.zhihu.com/people/AlphaZen", 
        "https://www.zhihu.com/people/qian-yi-58-55", 
        "https://www.zhihu.com/people/mu-tou-ren-79-22-44", 
        "https://www.zhihu.com/people/ao-te-man-de-xiao-yi", 
        "https://www.zhihu.com/people/2016_05_08", 
        "https://www.zhihu.com/people/nuo-ya-46", 
        "https://www.zhihu.com/people/gui-zhen-xuan", 
        "https://www.zhihu.com/people/ji-zi-1-15", 
        "https://www.zhihu.com/people/nan-mo-74-95", 
        "https://www.zhihu.com/people/Q-21-21", 
        "https://www.zhihu.com/people/tian-zhen-huan-shi-wu-xie", 
        "https://www.zhihu.com/people/cong-cong-a", 
        "https://www.zhihu.com/people/dreamer-xie-72", 
        "https://www.zhihu.com/people/qian-yi-zhu-53", 
        "https://www.zhihu.com/people/15510752602", 
        "https://www.zhihu.com/people/ilonger", 
        "https://www.zhihu.com/people/qi-miao-zhong-de-ji-yi-48-59", 
        "https://www.zhihu.com/people/yao-yao-da-60-24", 
        "https://www.zhihu.com/people/xu-xu-zhao", 
        "https://www.zhihu.com/people/karlond", 
        "https://www.zhihu.com/people/Misa-zu", 
        "https://www.zhihu.com/people/mo-yu-13-19", 
        "https://www.zhihu.com/people/firetaker", 
        "https://www.zhihu.com/people/ming-ming-53-86-74", 
        "https://www.zhihu.com/people/zai-shan-jiao-zai-hai-bian-de-xiao-ren-wu", 
        "https://www.zhihu.com/people/33241355y", 
        "https://www.zhihu.com/people/camark", 
        "https://www.zhihu.com/people/xhtc", 
        "https://www.zhihu.com/people/dai-ma-xiao-tui-che", 
        "https://www.zhihu.com/people/wang-xi-30-49", 
        "https://www.zhihu.com/people/yeu-yang", 
        "https://www.zhihu.com/people/pang-pang-bang-bang"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/79793246", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 1, 
            "title": "使用frp服务在外网中实现对内网机器的远程连接", 
            "content": "<h2>为何要用 </h2><p>我们并不是每天都会接触到实验室内网环境。当不在学校时，如何访问内网的资源成了一个头疼的问题。本文旨在提出一种内网穿透解决方案，在外网环境下优雅的访问到内网的任何端口。即使身离学校也可以方便的修改内网模型，访问内网计算资源。 </p><h2>优势一一相比Teamviewer</h2><ul><li>不需要访问图形界面，节约带宽。</li><li>掉线自动重连。只要目的主机不down，即使有断网情况,网络恢复后会自动重连。无需人工干预。</li><li>如果将启动脚本设置为开机自启动，可实现无人工干预的永久不掉线。</li><li>常用场景：转发内网机的22端口。可以像在本机一样的使用远程bash。</li><li>配置简单。</li><li>数据传输安全：可选加密，公网机只做解析，实际数据并不直接经过外网机器。</li></ul><h2>特殊需要 </h2><ul><li>一台公网机（有公网ip的vps， 比如阿里云服务器）</li><li>frp 端口转发软件 </li><li>screen 或 tmux </li></ul><h2>配置方法——客户端</h2><ol><li>内网机中没有 <code>screen</code> 或 <code>tmux</code> 命令的，使用包管理软件进行安装。下例为常用的 centos 和 Ubuntu 的安装方法：</li></ol><div class=\"highlight\"><pre><code class=\"language-bash\">$ sudo yum install screen \n$ sudo apt-get install screen </code></pre></div><p>2. 到 GitHub 项目： <a href=\"https://link.zhihu.com/?target=https%3A//github.com/fatedier/frp\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">frp项目地址</a> 中，根据自己的平台下载最新的 release 包。例：在 Linux 环境下选择后缀为 <code>linux_amd64.tar.gz</code> 。 </p><p>3. 将下载文件传入待穿透的内网机器中。</p><p>4. 使用 <code>cd</code> 方法访问到 frp 项目文件的根目录，将会看到如下结构： </p><div class=\"highlight\"><pre><code class=\"language-bash\">$ <span class=\"nb\">cd</span> frp_0.16.0_linux_amd64/\n$ ls\nfrpc frpc_full.ini frpc.ini frps frps_full.ini frps.ini LICENSE </code></pre></div><p>5. 编辑 <code>frpc.ini</code> 文件为想要的配置并保存，简单的配置文件介绍如下： </p><div class=\"highlight\"><pre><code class=\"language-text\"># 必选项，这里填入公网服务端的端口信息\n# 下文为测试用公网 frp 服务器参数\n[common] \nserver_addr = 58.222.39.48    # 公网服务器 ip，可填入域名\nserver_port = 10000           # 公网 frp 服务的端口号\n\n# 这里是配置要装发的端口，本例为内网 SSH 端口\n[titan-ssh]                   # frp 服务器上的识别名，此名要求在 frp 服务器上唯一\ntype = tcp                    # 要装发的服务连接类型，默认为 tcp，也可省略不写\nlocal_ip = 127.0.0.1          # 要转发的内网服务 IP，可以填写其他能在内网访问的服务器 IP\nlocal_port = 22               # 要转发的内网服务端口，可以为 22（SSH）、6006（tensorboard）等\nremote_port = 2022            # 在 frp 服务器上的访问端口，在外网访问时，使用外网 IP + 这个外网端口即可访问内网对应服务，该端口要求在 frp 服务器上未使用。\n\n# 如需一个配置中装发多个端口，可以复制上面的 titan-ssh 端口的配置，来重复配置其他端口，如下：\n[titan-board]                 # 本例定义为内网机的 tensorboard 服务端口\nlocal_ip = 127.0.0.1   \nlocal_port = 6006 \nremote_port = 6006 \n\n# 下面是其他的端口配置，你可以随意增加\n[titan-visdom]                # 本例定义为内网机的 pytorch-visdom 服务端口\nlocal_ip = 127.0.0.1\nlocal_port = 8097\nremote_port = 8097\n\n[titan-web]\nlocal_ip = 127.0.0.1          # 本例定义为内网机的 http web 服务端口\nlocal_port = 80\nremote_port = 8000</code></pre></div><p>6. 在后台开启运行 frp 服务</p><div class=\"highlight\"><pre><code class=\"language-bash\">$ nohup ./frpc -c frpc.ini &gt;/dev/null <span class=\"m\">2</span>&gt;<span class=\"p\">&amp;</span><span class=\"m\">1</span> <span class=\"p\">&amp;</span></code></pre></div><blockquote>说明：<code>&gt;/dev/null 2&gt;&amp;1 &amp;</code>，表示丢弃。</blockquote><h2>配置方法——服务端</h2><p>1. 同客户端的配置一样，先在公网服务器中解压已经下载好的 frp 压缩包。</p><p>2. 按下例配置 <code>frps.ini</code> 文件</p><div class=\"highlight\"><pre><code class=\"language-text\">[common]                    # 此项为设定客户端访问 frp 服务在公共 ip 中的端口\nbind_port = 10000           # 公网 frp 服务的端口号， 要同客户端配置的相同</code></pre></div><p>3.  在后台开启运行 frp 服务</p><div class=\"highlight\"><pre><code class=\"language-text\">nohup ./frps -c frps.ini &gt;/dev/null 2&gt;&amp;1 &amp; </code></pre></div><h2>frp 服务的使用</h2><blockquote>注意：如果你使用了阿里云或者相似的其他云主机，云服务提供商默认会开启相应的防火墙，你需要手动先去你的云服务器的管理平台的防火墙设置页面中开启这些端口。</blockquote><p>此时，你就可以通过你的外网 IP + 远程端口号来实现对内网相关服务的访问了。如，你先访问内网的 ssh 服务，你已经配置了外网的 2022 端口与内网 ssh 服务的 22 端口连接，就可以使用外网 IP （举个例子为：<code>58.221.37.41</code>，或者为 IP 绑定了相应的域名，如：<code>test.com</code>），那么你就可以使用 <code>58.221.37.41:2022</code> 和 <code>test.com:2022</code> 来实现对内网的 ssh 服务的访问。</p><h2>使用推荐</h2><p>推荐将 teamviewer 和 frp 转发同时使用，若遇到 frp 偶尔失效的情况可以使用 teamviewer 或者其他端口转发正常的机器作为跳板机，登录重新开启服务。</p>", 
            "topic": [
                {
                    "tag": "端口转发", 
                    "tagLink": "https://api.zhihu.com/topics/20024244"
                }, 
                {
                    "tag": "内网通讯", 
                    "tagLink": "https://api.zhihu.com/topics/19847883"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80254967", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 0, 
            "title": "Laravel mix 加载 CSS 404报错解决方案", 
            "content": "<h2>实验环境</h2><ul><li>系统：Win10（但该方法对其余平台 Linux 同样有效）</li><li>PHP环境：XAMPP </li></ul><h2>问题描述</h2><p>在对 webpack.mix.js 添加了 version()，同时也修改视图，引入｛{ mix(&#39;css/app.css&#39;) }｝可是一直加载不成功。在浏览器页面上显示的一直是无 CSS 效果的纯 html 样式。</p><p>通过打开 chrome 的网页检查功能，观察报错内容如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a7d21a733bcaba3f032a1c26fc14699_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"635\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-2a7d21a733bcaba3f032a1c26fc14699_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;635&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"635\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-2a7d21a733bcaba3f032a1c26fc14699_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a7d21a733bcaba3f032a1c26fc14699_b.jpg\"/></figure><p>在浏览器中，我们的 mix 工具帮我们从 <code>http://localhost/css/app.css</code> 路径对 CSS 文件进行了索引。</p><p>但是我们的工程建立在网站根目录下面的 weibo 子路径下的。我们的项目根目录并不是 <code>http://localhost/</code> 而是 <code>http://localhost/weibo/</code>。我们通过 laravel-mix 加载得到的 css 文件的保存路径是 <code>http://localhost/weibo/public/css/app.css</code>。</p><p>但是，我们的浏览器却从 <code>http://localhost/css/app.css</code>  进行了加载，路径错误，当然是 404 error 了。</p><h2>解决方法</h2><p>在明白了问题以后，我们就需要对我们的 apache 服务器的网站根目录进行修改。</p><p>打开 <code>httpd.conf</code> 文件。这个文件在 <code>XAMPP</code> 安装目录下面的 <code>apache\\conf</code> 文件夹中。（我本人的 <code>httpd.conf</code> 文件目录在：<code>D:\\xampp\\apache\\conf\\httpd.conf</code>）。</p><p>在 <code>httpd.conf</code> 文件中，找到如下两行代码，并进行修改。（我本人网站原始根目录为：<code>D:\\xampp\\htdocs</code>）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-178515b4b3c4b0193aebcea964d5d276_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb\" width=\"672\" data-original=\"https://pic3.zhimg.com/v2-178515b4b3c4b0193aebcea964d5d276_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;672&#39; height=&#39;210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"672\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"672\" data-original=\"https://pic3.zhimg.com/v2-178515b4b3c4b0193aebcea964d5d276_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-178515b4b3c4b0193aebcea964d5d276_b.jpg\"/></figure><p>将两个目录更改为你所希望的新的网站根目录即可，如我修改如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6fc19c5e8c841494467f983ad9861694_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb\" width=\"668\" data-original=\"https://pic1.zhimg.com/v2-6fc19c5e8c841494467f983ad9861694_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;668&#39; height=&#39;192&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"668\" data-rawheight=\"192\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"668\" data-original=\"https://pic1.zhimg.com/v2-6fc19c5e8c841494467f983ad9861694_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6fc19c5e8c841494467f983ad9861694_b.jpg\"/></figure><p>即将网站根目录修改为我的 Laravel 项目 public 文件所在的根目录。</p><h2>观察结果</h2><p>在 XAMPP 控制台中重启 apache 服务。</p><p>需要注意的是，我们此时的 localhost 域名对应的是新的网站根目录地址，即 <code>D:/xampp/htdocs/weibo/public</code> ，所以要打开 Laravel 项目只需要输入 <code>localhost</code> 即可，而不需要再输入 <code>localhost/weibo/public</code> 。 </p><p>观察浏览器显示结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-944a890e5a6ab752013609cd47b00de3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"738\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic4.zhimg.com/v2-944a890e5a6ab752013609cd47b00de3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;738&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"738\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic4.zhimg.com/v2-944a890e5a6ab752013609cd47b00de3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-944a890e5a6ab752013609cd47b00de3_b.jpg\"/></figure><p>用 chrome 检查工具观察，原来的 404 error 也已经消失：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-965bfbcbc16a0b113173b6f89af0160a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"738\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic3.zhimg.com/v2-965bfbcbc16a0b113173b6f89af0160a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;738&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"738\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic3.zhimg.com/v2-965bfbcbc16a0b113173b6f89af0160a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-965bfbcbc16a0b113173b6f89af0160a_b.jpg\"/></figure><p>解决完成。</p><hr/><p>参考链接：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/qq_33867131/article/details/97920564\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Laravel前端资源加载出错{{ mix (&#39;CSS/app.css&#39;) }}</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/tao_sun/article/details/8682048\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">XAMPP中Apache的网站根目录修改方法</a> </li></ul>", 
            "topic": [
                {
                    "tag": "Laravel", 
                    "tagLink": "https://api.zhihu.com/topics/19856963"
                }, 
                {
                    "tag": "Laravel Mix", 
                    "tagLink": "https://api.zhihu.com/topics/20225275"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/39431062", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 1, 
            "title": "Regex Golf 正则表达式练习", 
            "content": "<h2><b>Warmup：存在 foo 格式的子串</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-963b0bc09d27a79d257577c84b031e28_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb\" width=\"861\" data-original=\"https://pic1.zhimg.com/v2-963b0bc09d27a79d257577c84b031e28_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;861&#39; height=&#39;644&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"861\" data-original=\"https://pic1.zhimg.com/v2-963b0bc09d27a79d257577c84b031e28_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-963b0bc09d27a79d257577c84b031e28_b.jpg\"/></figure><h2><b>Anchors：以 ick 结尾</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d0a07fb902d79b22b6cc7a537ec5d11_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb\" width=\"861\" data-original=\"https://pic2.zhimg.com/v2-1d0a07fb902d79b22b6cc7a537ec5d11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;861&#39; height=&#39;644&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"644\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"861\" data-original=\"https://pic2.zhimg.com/v2-1d0a07fb902d79b22b6cc7a537ec5d11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d0a07fb902d79b22b6cc7a537ec5d11_b.jpg\"/></figure><h2><b>It never ends：fu 之后不能够匹配到单词字符</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-85c19f259b4ca5415ee2590eda52b491_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"860\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb\" width=\"860\" data-original=\"https://pic2.zhimg.com/v2-85c19f259b4ca5415ee2590eda52b491_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;860&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"860\" data-rawheight=\"302\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"860\" data-original=\"https://pic2.zhimg.com/v2-85c19f259b4ca5415ee2590eda52b491_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-85c19f259b4ca5415ee2590eda52b491_b.jpg\"/></figure><h2><b>Ranges：由 [a-f] 这几个字符组成的 4~6 位的字符串</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-acbf718cdae9f37e8b00d128b040e605_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"643\" class=\"origin_image zh-lightbox-thumb\" width=\"856\" data-original=\"https://pic2.zhimg.com/v2-acbf718cdae9f37e8b00d128b040e605_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;856&#39; height=&#39;643&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"856\" data-rawheight=\"643\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"856\" data-original=\"https://pic2.zhimg.com/v2-acbf718cdae9f37e8b00d128b040e605_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-acbf718cdae9f37e8b00d128b040e605_b.jpg\"/></figure><h2><b>Backrefs：存在一个长度为3的重复的子串</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8d16c016386a63783e2789855828bdb4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"648\" class=\"origin_image zh-lightbox-thumb\" width=\"861\" data-original=\"https://pic1.zhimg.com/v2-8d16c016386a63783e2789855828bdb4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;861&#39; height=&#39;648&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"861\" data-rawheight=\"648\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"861\" data-original=\"https://pic1.zhimg.com/v2-8d16c016386a63783e2789855828bdb4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8d16c016386a63783e2789855828bdb4_b.jpg\"/></figure><h2><b>Abba：整个字符串不存在 abba 结构的子串</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-29a5059775503d9ac0daed125b2b3000_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"866\" data-rawheight=\"662\" class=\"origin_image zh-lightbox-thumb\" width=\"866\" data-original=\"https://pic1.zhimg.com/v2-29a5059775503d9ac0daed125b2b3000_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;866&#39; height=&#39;662&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"866\" data-rawheight=\"662\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"866\" data-original=\"https://pic1.zhimg.com/v2-29a5059775503d9ac0daed125b2b3000_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-29a5059775503d9ac0daed125b2b3000_b.jpg\"/></figure><h2><b>A man, a plan：从第一个字符开始字符串结构为 ab...ba 结构</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5b89410872e3baa4bcd4d335ca2611fa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb\" width=\"859\" data-original=\"https://pic3.zhimg.com/v2-5b89410872e3baa4bcd4d335ca2611fa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;859&#39; height=&#39;650&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"859\" data-rawheight=\"650\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"859\" data-original=\"https://pic3.zhimg.com/v2-5b89410872e3baa4bcd4d335ca2611fa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-5b89410872e3baa4bcd4d335ca2611fa_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由于本人才疏学浅，不能够全部解决 Regex Golf 的题目，特提供一个在网上找打的大神博主的文章分享给大家：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/njyr21/article/details/79600217\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Regex Golf 正则表达式练习（持续更新）</a></p><hr/><p>推荐阅读：</p><ul><li><a href=\"http://zhuanlan.zhihu.com/p/35310372\" class=\"internal\">正则表达式语法</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//alf.nu/RegexGolf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Regex Golf</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/njyr21/article/details/79600217\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Regex Golf 正则表达式练习（持续更新）</a></li></ul><p></p>", 
            "topic": [
                {
                    "tag": "正则表达式", 
                    "tagLink": "https://api.zhihu.com/topics/19577832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38853178", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 24, 
            "title": "树莓派串口通信设置", 
            "content": "<h2><b>实验环境</b></h2><ul><li>树莓派 3B 开发板</li><li>2018-06-27-raspbian-stretch 树莓派操作系统</li><li>使用 Windows 10 通过网线连接远程登陆访问方式控制树莓派</li></ul><h2><b>实验目的</b></h2><p>为了将树莓派构建成一个智能家居的数据中心，我们需要在树莓派上连接 ZigBee 无线通信模块，实现与传感器的一对多通信。</p><p>由于 ZigBee 使用的是串口通信方式，所以我们需要打开树莓派的串口功能。由于 3 代的树莓派板载集成了很多以串口作为通信接口的模块，如蓝牙模块、低速 WiFi 模块、GPS 模块、GPRS 模块等。由于板载了蓝牙模块，而这个蓝牙模块占用了我们板子上的硬件串口，所以使得我们的 3 代树莓派在串口的设置上较为麻烦。</p><h2><b>3代树莓派串口存在的主要问题</b></h2><p>树莓派从大的方向来说一共出了3代，每一代的CPU外设基本相同，但内核不同，外设里面一共包含两个串口，一个称之为硬件串口（<b>/dev/ttyAMA0</b>），一个称之为mini串口（<b>/dev/ttyS0</b>）。硬件串口由硬件实现，有单独的波特率时钟源，性能高、可靠，mini串口性能低，功能也简单，并且没有波特率专用的时钟源而是由CPU内核时钟提供，因此mini串口有个致命的弱点是：波特率受到内核时钟的影响。内核若在智能调整功耗降低主频时，相应的这个mini串口的波特率便受到牵连了，虽然你可以固定内核的时钟频率，但这显然不符合低碳、节能的口号。在所有的树莓派板卡中都通过排针将一个串口引出来了，目前除了树莓派3代以外 ，引出的串口默认是CPU的那个硬件串口。而在树莓派3代中，由于板载蓝牙模块，因此这个硬件串口被默认分配给与蓝牙模块通信了，而把那个mini串口默认分配给了排针引出的GPIO Tx Rx，下图是树莓派3的接口图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e647145651f3dff8abbc4a10d2f66abf_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic4.zhimg.com/v2-e647145651f3dff8abbc4a10d2f66abf_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;473&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic4.zhimg.com/v2-e647145651f3dff8abbc4a10d2f66abf_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e647145651f3dff8abbc4a10d2f66abf_b.jpg\"/></figure><p>其中红框中就是引出的串口IO，如果我们需要通过UART外接模块，默认情况下必须得使用性能很低的mini串口了，而且随着内核主频的变化，还会造成波特率的变化导致通信的失败，几乎很难使用。所以我们希望恢复硬件串口与GPIO 14/15的映射关系，使得我们能够通过GPIO使用高性能的硬件串口来连接我们的串口设备。</p><h2>确保串口功能已经激活</h2><p>在进行串口模式的修改之前，我们想要确保串口的功能已经激活，在 /boot/config.txt 文件中进行查看，是否存在如下语句：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-58de330f8fb90cf7785746ba3c0994b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"85\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic2.zhimg.com/v2-58de330f8fb90cf7785746ba3c0994b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;85&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"85\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic2.zhimg.com/v2-58de330f8fb90cf7785746ba3c0994b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-58de330f8fb90cf7785746ba3c0994b9_b.jpg\"/></figure><p>没有的话，就手动在最后一行添加：</p><div class=\"highlight\"><pre><code class=\"language-text\">enable_uart=1</code></pre></div><p>重启设备，生效。</p><h2><b>查看串口别名和硬件串口与mini串口交换的解决方案</b></h2><p>树莓派可以配置文件来修改设备树，我的理解是可以通过配置文件来修改管脚的映射关系，这在许多Cortex-M3内核的单片机中也很常见，可以将同一个串口映射到不同的管脚上，以方便PCB的布线。</p><p>为了在树莓派3中通过GPIO使用高性能的硬件串口，我们必须将分配给蓝牙使用的硬件串口与分配给IO排针的mini串口进行对换，这必然会使得蓝牙模块的功能受到影响，但还好，蓝牙并不是必须的。</p><p>在树莓派系统的 /boot/overlays/ 目录下，提供了一个 <b>pi3-miniuart-bt.dtbo </b>文件。其文件作用可以在当前目录下的 README 文件中进行查看：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d5abbe475f4cff87ce68f3bc96cc4e17_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-d5abbe475f4cff87ce68f3bc96cc4e17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;656&#39; height=&#39;259&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"656\" data-rawheight=\"259\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"656\" data-original=\"https://pic4.zhimg.com/v2-d5abbe475f4cff87ce68f3bc96cc4e17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-d5abbe475f4cff87ce68f3bc96cc4e17_b.jpg\"/></figure><p>README文件中说明了这个文件的功能是将树莓派3的蓝牙切换到mini串口（ttyS0），并且恢复硬件串口（ttyAMA0）到GPIO 14&amp;15脚中。并且给出了载入的方法。</p><p>首先在树莓派命令终端中通过命令查看树莓派3当前的串口映射关系：</p><div class=\"highlight\"><pre><code class=\"language-bash\">ls -l /dev </code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c643017f8fd18a5d2a3e67e14fb5598d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic2.zhimg.com/v2-c643017f8fd18a5d2a3e67e14fb5598d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;134&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"134\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic2.zhimg.com/v2-c643017f8fd18a5d2a3e67e14fb5598d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c643017f8fd18a5d2a3e67e14fb5598d_b.jpg\"/></figure><p>红色框中体现的应该是一种映射关系，此处暂时没有做深究，简单理解 serial0 就是GPIO映射的串口，此时GPIO映射的串口是默认的 <b>/dev/ttyS0 </b>这个mini串口。</p><h2><b>禁用串口的控制台功能</b></h2><p>前面的步骤已经交换了硬件串口与mini串口的映射关系，但现在想使用树莓派外接串口模块进行通信还不行，因为树莓派IO引出的串口默认是用来做控制台使用的，它的初衷是为了在没有网络接口时，通过串口对树莓派进行相关的配置。因此需要禁用这个默认功能，使得串口为我们自由使用。</p><p>在树莓派命令窗口中分别通过如下两个命令停止和禁用串口的控制台功能：</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo systemctl stop serial-getty@ttyAMA0.service\nsudo systemctl disable serial-getty@ttyAMA0.service</code></pre></div><p>然后通过下列指令编辑 cmdline.txt 文件：</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo vim /boot/cmdline.txt</code></pre></div><p>然后看到里面类似如下的内容：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-89f975922939d055ddff0153f2572b23_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic4.zhimg.com/v2-89f975922939d055ddff0153f2572b23_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;104&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"652\" data-rawheight=\"104\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic4.zhimg.com/v2-89f975922939d055ddff0153f2572b23_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-89f975922939d055ddff0153f2572b23_b.jpg\"/></figure><p>然后，我们把红色方框框起来的那部分删除即可，得到如下结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c2340f0e3a0333baf3f29c536e9d4ac1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"49\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c2340f0e3a0333baf3f29c536e9d4ac1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;49&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"49\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-c2340f0e3a0333baf3f29c536e9d4ac1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c2340f0e3a0333baf3f29c536e9d4ac1_b.jpg\"/></figure><p>重启设备，生效。</p><h2><b>将树莓派的硬件串口与mini串口默认映射对换</b></h2><p>使用下面这条指令编辑 /boot/config.txt 文件</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo vim /boot/config.txt</code></pre></div><p>根据之前在 README 文件中得到指示内容在该文件中增加一行代码：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nv\">dtoverlay</span><span class=\"o\">=</span>pi3-miniuart-bt</code></pre></div><p>然后保存文件，<b>重启</b>树莓派使之生效。</p><p>再通过 ls -l /dev 命令查看修改后的映射关系：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-69d083278dbc154402b955c94cda5006_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic3.zhimg.com/v2-69d083278dbc154402b955c94cda5006_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;167&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"167\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic3.zhimg.com/v2-69d083278dbc154402b955c94cda5006_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-69d083278dbc154402b955c94cda5006_b.jpg\"/></figure><p>此时，ttyAMA0串口可以正常用于串口通信，ttyS0则无法被用于串口通信，蓝牙功能失效。</p><h2><b>编写一个简单的串口程序</b></h2><p>wiringPi 实际上不只提供了基本的IO口的读写函数，还提供了串口操作库函数，引用 &#34;wiringSerial.h&#34; 即可使用，仍然使用前面的工程，参考 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/WiringPi/WiringPi/blob/master/examples/serialRead.c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wiringpi的串口例程</a> ，写了如下代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;errno.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;wiringPi.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;wiringSerial.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdio&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;cstdlib&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"kt\">char</span> <span class=\"n\">UartBuff</span><span class=\"p\">[</span><span class=\"mi\">100</span><span class=\"p\">];</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">fd</span><span class=\"p\">;</span>\n\t<span class=\"k\">if</span> <span class=\"p\">((</span><span class=\"n\">fd</span> <span class=\"o\">=</span> <span class=\"n\">serialOpen</span><span class=\"p\">(</span><span class=\"s\">&#34;/dev/ttyAMA0&#34;</span><span class=\"p\">,</span> <span class=\"mi\">115200</span><span class=\"p\">))</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">fprintf</span><span class=\"p\">(</span><span class=\"n\">stderr</span><span class=\"p\">,</span> <span class=\"s\">&#34;Unable to open serial device: %s</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">strerror</span><span class=\"p\">(</span><span class=\"n\">errno</span><span class=\"p\">));</span>\n\t\t<span class=\"k\">return</span> <span class=\"mi\">1</span> <span class=\"p\">;</span>\n\t<span class=\"p\">}</span>\n\t<span class=\"n\">serialPuts</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span> <span class=\"s\">&#34;uart send test, just by launcher</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">);</span>\n\t\n\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n\t\t<span class=\"n\">UartBuff</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">serialGetchar</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">);</span>\n\t\t<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">UartBuff</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n\t\t<span class=\"p\">{</span>\n\t\t\t<span class=\"n\">putchar</span><span class=\"p\">(</span><span class=\"n\">UartBuff</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\t\n\t\t\t<span class=\"n\">serialPutchar</span><span class=\"p\">(</span><span class=\"n\">fd</span><span class=\"p\">,</span><span class=\"n\">UartBuff</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n\t\t<span class=\"p\">}</span>\n\t\t\n\t<span class=\"p\">}</span>\n\t<span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>使用 USB 转 TTL 串口模块，USB 端接电脑，TTL 端接树莓派的 IO 口，实物连接图如下：</p><figure data-size=\"small\"><noscript><img src=\"https://pic3.zhimg.com/v2-650724fd80cd495e511b0b8dddb62fde_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"3088\" data-rawheight=\"2447\" class=\"origin_image zh-lightbox-thumb\" width=\"3088\" data-original=\"https://pic3.zhimg.com/v2-650724fd80cd495e511b0b8dddb62fde_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3088&#39; height=&#39;2447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"3088\" data-rawheight=\"2447\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3088\" data-original=\"https://pic3.zhimg.com/v2-650724fd80cd495e511b0b8dddb62fde_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-650724fd80cd495e511b0b8dddb62fde_b.jpg\"/></figure><p>运行在树莓派上编写完成的串口接收和发送程序，我们在 Windows 电脑端的串口调试助手接收到如下数据：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-b7cf67b93747a9989aa112e2f53eb4c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb\" width=\"707\" data-original=\"https://pic2.zhimg.com/v2-b7cf67b93747a9989aa112e2f53eb4c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;707&#39; height=&#39;555&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"707\" data-rawheight=\"555\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"707\" data-original=\"https://pic2.zhimg.com/v2-b7cf67b93747a9989aa112e2f53eb4c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b7cf67b93747a9989aa112e2f53eb4c5_b.jpg\"/></figure><p>接着，从串口助手发送“hello world!”给树莓派，树莓派接收到如下数据，并打印出来：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0fdf31f17378ead37f171ed6a1b0fd04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"33\" class=\"origin_image zh-lightbox-thumb\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-0fdf31f17378ead37f171ed6a1b0fd04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;639&#39; height=&#39;33&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"639\" data-rawheight=\"33\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"639\" data-original=\"https://pic1.zhimg.com/v2-0fdf31f17378ead37f171ed6a1b0fd04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0fdf31f17378ead37f171ed6a1b0fd04_b.jpg\"/></figure><p>串口助手也同时接收到如下信息：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5e99f0105ebfaa02b19ff01d95784ca3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"521\" data-rawheight=\"32\" class=\"origin_image zh-lightbox-thumb\" width=\"521\" data-original=\"https://pic4.zhimg.com/v2-5e99f0105ebfaa02b19ff01d95784ca3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;521&#39; height=&#39;32&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"521\" data-rawheight=\"32\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"521\" data-original=\"https://pic4.zhimg.com/v2-5e99f0105ebfaa02b19ff01d95784ca3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5e99f0105ebfaa02b19ff01d95784ca3_b.jpg\"/></figure><p>至此，证明我们的树莓派串口设置成功。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后，再给出一份使用 Python2 写的串口通信代码，提供给大家参考，毕竟使用 Python 再树莓派上进行数据处理的人相对会比较多一些：</p><div class=\"highlight\"><pre><code class=\"language-python\"><span class=\"kn\">import</span> <span class=\"nn\">serial</span>\n<span class=\"kn\">import</span> <span class=\"nn\">time</span>\n\n<span class=\"n\">ser</span> <span class=\"o\">=</span> <span class=\"n\">serial</span><span class=\"o\">.</span><span class=\"n\">Serial</span><span class=\"p\">(</span><span class=\"s2\">&#34;/dev/ttyAMA0&#34;</span><span class=\"p\">,</span> <span class=\"mi\">115200</span><span class=\"p\">)</span>\n\n\n<span class=\"k\">def</span> <span class=\"nf\">main</span><span class=\"p\">():</span>\n    <span class=\"k\">while</span> <span class=\"bp\">True</span><span class=\"p\">:</span>\n        <span class=\"n\">recv</span> <span class=\"o\">=</span> <span class=\"n\">get_recv</span><span class=\"p\">()</span>\n        <span class=\"k\">if</span> <span class=\"n\">recv</span> <span class=\"o\">!=</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"k\">print</span> <span class=\"n\">recv</span>\n            <span class=\"n\">ser</span><span class=\"o\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">recv</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"s2\">&#34;</span><span class=\"se\">\\n</span><span class=\"s2\">&#34;</span><span class=\"p\">)</span>\n        <span class=\"n\">time</span><span class=\"o\">.</span><span class=\"n\">sleep</span><span class=\"p\">(</span><span class=\"mf\">0.1</span><span class=\"p\">)</span>\n    \n            \n<span class=\"k\">def</span> <span class=\"nf\">get_recv</span><span class=\"p\">():</span>\n    <span class=\"n\">cout</span> <span class=\"o\">=</span> <span class=\"n\">ser</span><span class=\"o\">.</span><span class=\"n\">inWaiting</span><span class=\"p\">()</span>\n    <span class=\"k\">if</span> <span class=\"n\">cout</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">line</span> <span class=\"o\">=</span> <span class=\"n\">ser</span><span class=\"o\">.</span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">cout</span><span class=\"p\">)</span>\n        <span class=\"n\">recv</span> <span class=\"o\">=</span> <span class=\"nb\">str</span><span class=\"o\">.</span><span class=\"n\">split</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"p\">)</span>\n        <span class=\"n\">ser</span><span class=\"o\">.</span><span class=\"n\">reset_input_buffer</span><span class=\"p\">()</span>\n        <span class=\"k\">return</span> <span class=\"n\">recv</span>\n \n   \n<span class=\"k\">if</span> <span class=\"vm\">__name__</span> <span class=\"o\">==</span> <span class=\"s2\">&#34;__main__&#34;</span><span class=\"p\">:</span>\n    <span class=\"k\">try</span><span class=\"p\">:</span>\n        <span class=\"n\">main</span><span class=\"p\">()</span>\n    <span class=\"k\">except</span> <span class=\"ne\">KeyboardInterrupt</span><span class=\"p\">:</span>\n        <span class=\"k\">if</span> <span class=\"n\">ser</span> <span class=\"o\">!=</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">ser</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span></code></pre></div><hr/><p>参考资料：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//etrd.org/2017/01/29/%25E6%25A0%2591%25E8%258E%2593%25E6%25B4%25BE3%25E7%25A1%25AC%25E4%25BB%25B6%25E4%25B8%25B2%25E5%258F%25A3%25E7%259A%2584%25E4%25BD%25BF%25E7%2594%25A8%25E5%258F%258A%25E7%25BC%2596%25E7%25A8%258B/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">树莓派3硬件串口的使用及编程</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/26409ddf6a9b\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">激活树莓派3B串口通信能力</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wren1997/article/details/79273477\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">树莓派3b uart串口通信问题解决方案</a> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//jingyan.eeboard.com/article/76063\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何使用C语言控制树莓派3B的串口？ - 爱板网经验频道 - Eeboard爱板网</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/song527730241/article/details/51161879\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">使用ZigBee模块实现PC机与树莓派的无线通信 - CSDN博客</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wbrg593/article/details/50993286\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">树莓派瞎玩~6~控制GPIO之C语言 - CSDN博客</a></li><li><a href=\"https://zhuanlan.zhihu.com/p/37764566\" class=\"internal\">使用树莓派操纵模型小车</a> </li></ul>", 
            "topic": [
                {
                    "tag": "树莓派（Raspberry Pi）", 
                    "tagLink": "https://api.zhihu.com/topics/19737690"
                }
            ], 
            "comments": [
                {
                    "userName": "山葵", 
                    "userLink": "https://www.zhihu.com/people/81dd9de98fc766807a03abe1f83a0df0", 
                    "content": "晚上回去试试", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "fengchuangjie", 
                    "userLink": "https://www.zhihu.com/people/bbae374723a11514a4d60bd93bd7e6ef", 
                    "content": "<p>大赞，特意注册账号，表达感谢，比其他教程简明清晰多了，解决了困扰我两天的问题</p>", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "比心", 
                            "likes": 1, 
                            "replyToAuthor": "fengchuangjie"
                        }
                    ]
                }, 
                {
                    "userName": "裴梓辰", 
                    "userLink": "https://www.zhihu.com/people/dc764323519c89fac98ee4c6b0530ff6", 
                    "content": "<p>写的很清晰👍还想问下lz，树莓派的USB口转串口的效果和AMA0比怎么样呢？谢谢😁</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "<p>不太清楚了🤦‍♀️，太久之前了，以前做项目突击学的树莓派，已经好久没碰了。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "裴梓辰"
                        }, 
                        {
                            "userName": "裴梓辰", 
                            "userLink": "https://www.zhihu.com/people/dc764323519c89fac98ee4c6b0530ff6", 
                            "content": "<p>hhh谢谢楼主啦，现在毕设顺利结束了，和树莓派说拜拜了</p>", 
                            "likes": 0, 
                            "replyToAuthor": "晒月亮的孩子"
                        }
                    ]
                }, 
                {
                    "userName": "yepzhang", 
                    "userLink": "https://www.zhihu.com/people/5845b47f0159360e71bb890384ef6f27", 
                    "content": "<p>wiringPi 楼主编的这个代码是怎么执行的？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "<p>就是gcc或者python</p>", 
                            "likes": 1, 
                            "replyToAuthor": "yepzhang"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38532674", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 16, 
            "title": "云计算知识点梳理", 
            "content": "<h2><b>第一章：大数据与云计算</b></h2><h2>1. 分辨出软件是属于 Iass，Paas, Saas 的哪一类？</h2><p>将云计算按照服务类型可以分为三类：Iaas,Paas,Saas。</p><p><b>Iaas ：将基础设施作为服务，将硬件设备等基础资源封装成服务供用户使用。</b></p><ul><ul><li>Amazon EC2 弹性云计算服务</li><li>Amazon S3 简单存储服务</li><li>Amazon Web Services</li><li>（如上，都是底层的硬件环境，提供的只是基本硬件环境，云计算或者存储所需要的高性能CPU计算和大容量硬盘。）</li></ul></ul><p><b>Paas：将平台作为服务，提供用户应用程序的运行环境。</b></p><ul><ul><li>Google App Engine </li><li>Microsoft Windows Azure</li><li>Amazon MapReduce （仿 Google MapReduce）</li><li>Amazon SimpleDB（仿 Goggle BigTable）</li><li>（如上，都是基本的操作系统平台、引擎、数据库系统，类似于一个空白的 IDE ）</li></ul></ul><p><b>Saas：将软件作为服务，只提供某些专门用途的服务供应用调用。</b></p><ul><ul><li>Salesforce online CRM 在线客户关系管理服务</li><li>Amazon FPS 电子商务服务</li><li>Amazon DevPay </li><li>Amazon Alexa Web 网站访问统计服务</li><li>（如上，提供的都是专门的针对某一服务的特定制作的应用解决方案，类似于 App）</li></ul></ul><h2>2. 云计算的发展历史以及在云计算技术出现之前和之后出现的计算机技术了解。</h2><p>云计算的概念最先由Google在2006年提出，同年Google，Amazon，Microsoft相继提出云计算服务。</p><p><b>云计算领域的代表：</b></p><ul><ul><li>国外：Amazon，Google，Microsoft，VMware，Salesforce，Facebook，YouTube，Myspace </li><li>国内：阿里云、腾讯、七牛云、UCloud</li></ul></ul><p><b>云计算的特点：</b></p><ul><ul><li>超大规模</li><li>虚拟化</li><li>高可靠性</li><li>通用型</li><li>高可伸缩性</li><li>按需服务</li><li>极其廉价</li></ul></ul><h2>3. 云计算的发展重点是什么？</h2><p><b>云计算的优势：</b></p><ul><ul><li>在于它的技术特征和规模效应所带来的压倒性的性能价格比优势。</li></ul></ul><p><b>云计算的定义：</b></p><ul><ul><li>通过网络提供可动态伸缩的廉价的计算和存储能力。</li></ul></ul><p><b>云计算的主要特征：</b></p><ul><ul><li>对资源的整合和动态配置。</li></ul></ul><h2><b>第二章：Google 云计算原理与应用</b></h2><h2>1. Google 云计算三大件（GFS，MapReduce，BigTable）的了解。</h2><p><b>Google云计算技术包括：</b></p><ul><ul><li><b>Google文件系统GFS</b></li><li><b>分布式计算编程模型 MapReduce</b></li><li>分布式锁服务 Chubby</li><li><b>分布式结构化数据表 Bigtable</b></li><li>分布式存储系统 Megastore</li><li>分布式监控系统 Dapper</li><li>海量数据的交互式分析工具 Dreme</li><li>内存大数据分析系统 PowerDrill</li><li>Google应用程序引擎</li></ul></ul><h2>2. GFS 的存储方式是什么？它有什么特点，它是如何提高可靠性的？</h2><p>Google文件系统（ Google File System，GFS）是一个闭源的大型分布式文件系统。它为 Google云计算提供海量存储，处于所有核心技术的底层。</p><p><b>GPS 的系统结构：</b></p><ul><ul><li>GFS将整个系统的节点分为三类角色: Client（客户端）、 Master（主服务器）和 Chunk Server（数据块服务器）。 </li><li>Client是GFS提供给应用程序的访问接口，以库文件的形式提供应用程序直接调用这些库函数，并与该库链接在一起。 </li><li>Master是GFS的管理节点，在逻辑上只有一个，它保存系统的元数据，负责整个文件系统的管理，是GFS文件系统中的“大脑”。 </li><li>Chunk Server负责具体的存储工作。<b>数据以文件的形式存储 </b>在 Chunk Server上， Chunk Server的个数可以有多个，它的数目直接决定了GFS的规模。<b>GFS将文件按照固定大小进行分块</b>，默认是64MB，每一块称为一个 Chunk（数据块），每个 Chunk都有一个对应的索引号。</li></ul></ul><p><b>GFS 的存储方式：</b></p><ul><ul><li>在 GFS 中，数据存储在 Chunk Server（数据块服务器）中，GFS 将文件以块的形式存储在 Chunk Server 上，在 Chunk Server 内部，数据又以文件的形式进行存储。</li></ul></ul><p><b>GFS 的特点：</b></p><ul><ul><li><b>采用中心服务器模式</b>：使用 Master 管理分布式文件系统中的所有元文件。便于增加新的 Chunk Server，但是也使得 Master 成为了 GFS 的主要瓶颈。</li><li><b>不缓存数据</b>：对于需要频繁读取的数据直接保存到内存中，而不是进行缓存。避免了缓存与实际数据不一致的问题，减少了缓存对系统资源的耗费。提高了操作的效率。</li><li><b>在用户态下表现</b>：提高了通用性和稳定性。</li><li><b>只提供专用接口</b>：主要面向 Google 自身的应用程序提供服务，所以使用专业接口，可以降低实现难度、对某些应用提供特殊支持、提高效率。</li></ul></ul><p><b>GPS 可靠性的保证：</b></p><ul><ul><li>Master 容错机制：</li><ul><li>对 GFS 的 命名空间 和 Chunk与文件名的映射表，GFS 通过操作日志来提供容错功能。</li><li>对于 GFS 的 Chunk副本的位置信息，则一式三份直接保存到各个 Chunk Server 上。（所以，当 Master 故障时，可以迅速恢复这些数据。）</li><li>Chunk Server 容错机制：每一个 Chunk 有多个存储副本，分布存储在不同的 Chunk Server 上。当某个相应的副本受损时， Master 自动将该副本复制到其他 Chunk Server  上。</li></ul></ul></ul><h2>3. MapReduce 是什么？它如何对中间结果进行合并？</h2><p>MapReduce 是 Google 提出的一个软件架构，是一种处理海量数据的并行编程模式，用于大规模数据集的并行运算。其主要思想是 Map(映射) 和 Reduce(化简)。它具有函数式编程语言和矢量编程语言的共性，非常适合于非结构化和结构化的大数据运算环境（搜索、挖掘、分析、机器学习）。</p><p><b>MapReduce 的编程模型：</b></p><ul><ul><li>一个 Map 函数对应一部分原始数据，对这部分的原始数据进行映射操作。</li><li>Map 之间是互相独立的，使得它们可以充分并行化。</li><li>一个 Reduce 操作是对每个 Map 所产生的一部分的中间结果进行合并操作。</li><li>Reduce 之间是互相独立的，其产生过的最终结果简单的连接就形成了完成的结果集。</li></ul></ul><h2>4. BigTable 是并行运算软件架构还是软件模式？它是干什么的？它与其他传统的数据库有什么区别？</h2><p>BigTable 是一个 Google 开发的基于 GFS 和 Chuuy 的结构化的分布式存储系统。</p><p><b>BigTable 的基本目标：</b></p><ul><ul><li>广泛的适应性。</li><li>很强的可扩展性。</li><li>高可用性。</li><li>简单性。</li></ul></ul><p><b>BigTable 的数据模型：</b></p><ul><ul><li>BigTable 是一个分布式多维映射表，表中的数据通过一个行关键字、列关键字以及一个时间戳进行索引。 </li></ul></ul><p><b>BigTable 与传统数据库之间的区别：</b></p><ul><ul><li>从系统架构的角度来说，互联网应用更加看重<b>系统性能</b>以及<b>伸缩性</b>，而传统企业级应用都是比较看重<b>数据完整性</b>和<b>数据安全性</b>。</li><li>传统数据库是面向行存储的，适合于事务性要求严格场合。但是云计算的数据库 BigTable，HBase 等都是面向列存储的，可以实现高性能的并发读写操作，有较好的水平伸缩性。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第三章：Amazon 云计算 AWS</b></h2><h2>1. EC2 了解</h2><p>EC2 是亚马逊的弹性计算云服务，它可以提供大小可调节的计算容量。具有低成本、灵活性、安全性、易用性和容错性的特征。用户可以借助 EC2 在不需要硬件投入的情况下，快速开发和部署应用开发，并方便的配置和管理。</p><p>EC2\t的基本架构主要包括了 <b>Amazon机器映像（AMI）</b>，<b>实例</b>，<b>存储模块 </b>等组成部分，并能够与 S3 等其他 Amazon 云计算服务结合使用。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2f09886f592a0f9bb222a76f134fb2d5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2719\" data-rawheight=\"2242\" class=\"origin_image zh-lightbox-thumb\" width=\"2719\" data-original=\"https://pic2.zhimg.com/v2-2f09886f592a0f9bb222a76f134fb2d5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2719&#39; height=&#39;2242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2719\" data-rawheight=\"2242\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2719\" data-original=\"https://pic2.zhimg.com/v2-2f09886f592a0f9bb222a76f134fb2d5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2f09886f592a0f9bb222a76f134fb2d5_b.jpg\"/></figure><p><b>EC2 的关键技术：</b></p><ul><ul><li><b>地域区域和可用区域</b>：地域区域是按照实际的地理位置进行划分的，目前亚马逊总共划分了10个地理区域；可用区域是地理区域的一个个更细划分的子集，是根据有没有独立的供电系统和冷却系统进行划分的。</li><li><b>EC2 的通信机制</b>：EC2 中的 IP 地址总共有三大类：<b>公共 IP 地址</b>、<b>私有 IP 地址 </b>和 <b>弹性 IP 地址</b>。</li><li><b>弹性负载平衡</b>：弹性负载平衡可以识别出应用实例的状态，当一个应用运行不佳时，它会自动将流量路由到状态较好的实例资源上，当前者恢复正常后才会重新分配流量到其实例上。</li><li>监控服务</li><li>自动缩放：用户可以自定义 EC2 的计算能力。</li><li>服务管理控制台：它是一种基于 Web 的控制环境，可用于启动、管理 EC2 实例和提供各种管理工具和 API 接口。</li></ul></ul><p><b>EC2 的安全及容错机制：</b></p><ul><ul><li><b>安全组技术</b>：在保障用户可以随时更新实例的基础上，对实例能够接受的网络流量进行过滤。</li><li>使用<b> SSH 密钥</b>实现用户的登陆服务。</li><li>使用<b>弹性 IP</b> ，使用户在实例发生故障时可以快速的新实例进行连接。</li></ul></ul><h2>2. S3 了解</h2><p>S3 是亚马逊的基于 Dynamo 基础存储架构的简单存储服务，它可以用于提供任意类型文件的临时或永久性存储。S3 具有可靠、易用和低成本的特征。</p><p><b>S3 的基本概念：</b></p><ul><ul><li><b>桶</b>：桶是用于存储<b>对象</b>的容器（但是不能像文件夹一样进行嵌套的建立），其名称在整个 Amazon S3 服务器中是唯一的。</li><li><b>对象</b>：对象是 S3 的基本存储单元，由 <b>数据</b> 和 <b>元数据</b> 组成。每个对象在桶中有唯一的 <b>键</b> ，一但建立后便不能再修改。</li><li><b>数据</b>可以是任意类型的，但大小受到对象最大容量的限制。</li><li><b>元数据</b>是数据内容的附加描述信息，通过 <b>名称-值</b> 集合的方式定义。</li></ul></ul><figure data-size=\"small\"><noscript><img src=\"https://pic1.zhimg.com/v2-568b76ca6c38d7e63b0fbbfce1884088_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"2387\" data-rawheight=\"2087\" class=\"origin_image zh-lightbox-thumb\" width=\"2387\" data-original=\"https://pic1.zhimg.com/v2-568b76ca6c38d7e63b0fbbfce1884088_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2387&#39; height=&#39;2087&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"2387\" data-rawheight=\"2087\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2387\" data-original=\"https://pic1.zhimg.com/v2-568b76ca6c38d7e63b0fbbfce1884088_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-568b76ca6c38d7e63b0fbbfce1884088_b.jpg\"/></figure><p><b>S3 的基本操作：</b></p><ul><ul><li>S3 支持对桶和对象的操作，主要包括 Get 、 Put 、 List （对象不支持）、 Delete 、Head（桶不支持）。</li></ul></ul><p><b>S3 的安全措施：</b></p><ul><ul><li><b>身份认证</b></li><li><b>访问控制列表</b>：访问控制列表规定了 S3 的三大授权用户（所有者、个人授权用户、组授权用户）</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第五章\\第六章：Hadoop2.0</b></h2><h2>1. Hadoop 概念了解</h2><p><b>分布式存储：</b></p><ul><ul><li>使用 <b>客户-服务器模式</b> ，master 负责进行统一管理各个 slave 的存储空间，slaves 负责存储真实的数据。这样，就能够将多台机器硬盘结合在一起，扩大整机的存储容量。</li></ul></ul><p><b>分布式计算：</b></p><ul><ul><li>Google 在 MapReduce 中给出观点 “移动计算比移动数据更划算”，因为数据量很大（几 T），而计算代码很小（几 K）。</li><li>分布式移动计算的步骤大致可以分为三步：<b>Map（本地计算）</b>、<b>Shuffle（洗牌）</b>、<b>Reduce（合并再计算）</b>。</li><ul><li>Map：在各个 slave 中分别独立进行本地计算，将生成了 KV 对保存在本地。</li><li>Shuffle：将各个 slave 中 Key 值相同的 KV 对通过网络发往同一台机器。</li><li>Reduce：将每台机器各自的 KV 对中的 value 连成链表，进行合并相加。</li></ul></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ba70868853756e000504461565b3709c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3148\" data-rawheight=\"1500\" class=\"origin_image zh-lightbox-thumb\" width=\"3148\" data-original=\"https://pic1.zhimg.com/v2-ba70868853756e000504461565b3709c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3148&#39; height=&#39;1500&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3148\" data-rawheight=\"1500\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3148\" data-original=\"https://pic1.zhimg.com/v2-ba70868853756e000504461565b3709c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ba70868853756e000504461565b3709c_b.jpg\"/></figure><p><b>冗余存储：</b></p><ul><ul><li>将 slave1 中的 file1 重复存储在 slave3 中，实现冗余存储，防止一台 slave 宕机导致的数据的丢失。</li><li>通过冗余存储，不仅提高了分布式存储可靠性，还提高了分布式计算的可靠性。</li></ul></ul><p><b>冗余计算：</b></p><ul><ul><li>对保存有 file1 的 slave1 和 slave3 同时计算，如果都没有丢失数据，就取最先计算结束的那台机子的计算结果。如果一台丢失，可以使用另一台的。</li></ul></ul><p><b>HDFS 的内部特征：</b></p><ul><ul><li>冗余备份：HDFS 以块的方式对文件进行存储。文件的所有数据块都会有副本。且文件每次都是一次性写入的，在任何时候都只能拥有一个写用户。</li><li>副本存放：使用机架感知的策略来改进数据的可靠性、可用性和网络带宽的利用率。</li><li>副本选择：HDFS 尽量选择离程序最近的副本，从而减少总带宽的消耗和读延时。</li><li>心跳检测：namenode  周期性地接收每个 datanode 发送来的心跳包和数据块，如果 namenode 没有接收到 datanode 的心跳包，就说明 datanode 已经宕机了，不对它发送任何 IO 请求。 </li><li>数据完整性检测：当客户端接收到文件后，会检测从 datanode 获得的数据块的校验和是否和隐藏文件中的相同。</li><li>。。。</li></ul></ul><p><b>分布式操作系统 Yarn</b></p><ul><ul><li>Yarn 除了像一般的操作系统功能一样管理整个集群的计算资源（CPU、内存等），还提供用户程序访问系统资源的 API。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第七章：虚拟化技术</b></h2><h2>1. 虚拟化的特征</h2><p><b>虚拟化技术的核心思想是里利用软件或固件管理程序构建虚拟化层，把物理资源映射为虚拟资源。在虚拟资源上可以安装或部署多个虚拟机，实现多用户共享物理资源。</b></p><p><b>数据中心的虚拟化可以实现资源的动态分配和调度，提高现有资源的利用率和服务可靠性</b>；可以提供自动化的服务开通能力，降低运维成本；具有有效的安全机制和可靠性机制，满足公众客户和企业客户的安全需求；同时也可以方便系统升级、迁移和改造。</p><h2>2. 虚拟化的实现</h2><p>数据中心的虚拟化是通过 <b>服务器虚拟化</b> 、 <b>存储虚拟化</b> 、 <b>网络虚拟化</b> 来实现的。</p><ul><li><b>服务器虚拟化</b>：采用云计算虚拟架构相比于传统单台服务器部署单一应用方式的另外一个好处是，可以充分满足不同应用对系统资源的不同要求，如有的应用只需要一个3.0 GHz CPU，512MB的内存就可以很好的运行，而有的高访问率、高吞吐量的应用则需要2个甚至是4个双核的CPU，8GB的内存才能保证稳定的运行，在传统方式下，往往不可能针对每一种应用来采购服务器，而是用一种或几种标准配置的服务器来统一采购，这样，势必会造成某些应用资源富裕，而另一些应用面临资源紧张的情况，且应用之间不能互相调配资源。采用虚拟架构后，由于每个虚拟机所需使用的系统资源都是由虚拟架构软件统一调配，这种调配可以在虚拟机运行过程中在线的发挥作用，使得任何一个应用都可以有充分保证的资源来稳定运行，同时，该应用在此时用不到的资源又可以被其他更需要资源的应用临时借用过去，最大限度的提高了整体系统的资源利用率。</li><li><b>存储虚拟化</b>：区域弹性存储可以根据客户的需求实时划分存储空间，并通过高速局域网络挂载到本区域内任意指定的虚拟机，在虚拟机上可以将磁盘格式化为ext2/ext3/FAT/NTFS等文件系统。在需要的时候，也可以随时将存储卸载，并挂载到其它虚拟机上。</li><li><b>网络虚拟化</b>：提供了可选的分布式网络交换功能，可以从一个集中式界面为整个数据中心设置虚拟机网络连接，从而简化网络管理，可在虚拟机跨多个物理机移动时使其保持网络运行时状态，从而实现线内监视和集中式防火墙服务。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b> 第八章：OpenStack 开源虚拟化平台</b></h2><h2>1. OpenStack 的组件有哪些？</h2><p>OpenStack 是一个管理 <b>计算</b> 、 <b>存储</b> 和 <b>网络资源</b> 的数据中心云计算开放平台。<b>易于构建虚拟计算或存储服务的云</b>，既可以为公有云、私有云，也可以为大云、小云提供可扩展、灵活的云计算。</p><p>OpenStack 有三个主要的成员：<b>Nova（计算服务）</b>、<b>Swift（存储服务）</b>、<b>Glance（镜像服务）</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第十一章：中国云计算技术 </b></h2><h2>1. 国内云计算现状</h2><p>BAT、UCloud、华为、曙光、云创。。。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>第十二章：总结和展望</b></h2><h2>1. 主流商业云计算解决方案与开源方案之间的比较</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4e2c68e02dff35da4a57e02b4b99c50b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2770\" data-rawheight=\"1676\" class=\"origin_image zh-lightbox-thumb\" width=\"2770\" data-original=\"https://pic4.zhimg.com/v2-4e2c68e02dff35da4a57e02b4b99c50b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2770&#39; height=&#39;1676&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2770\" data-rawheight=\"1676\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2770\" data-original=\"https://pic4.zhimg.com/v2-4e2c68e02dff35da4a57e02b4b99c50b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4e2c68e02dff35da4a57e02b4b99c50b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>全书总结</b></h2><h2>1. 主流商业三巨头（Google、Amazon、Microsoft）产品比较（共同点、方案区别）？</h2><p><b>三家公司云计算体系架构的共同点：</b></p><ul><ul><li>整个云计算平台对外提供统一的 Web 接口。</li><li>后台实现的细节对用户透明。</li></ul></ul><p><b>主要的区别：</b></p><ul><ul><li>Amazon 、 微软 的云计算服务都是由多种服务组成，需要为不同的服务提供不同的入口。Google 的云计算服务实现相对简单，没有实现多个服务的单独入口。</li><li>微软的云计算服务不仅支持云端应用程序，还支持本地的应用程序，这是微软云计算和其他三种方案的最大不同之一，反应了微软的 “云+端” 的策略。</li></ul></ul><h2>2. 云计算的核心算法 Paxos 的计算</h2><p class=\"ztext-empty-paragraph\"><br/></p><h2>3. 传统数据库在云计算下横向拓展表现较差的原因？</h2><p>传统的关系型数据库中都存在着扩展问题和性能问题。可扩展性主要表现在表空间不足的问题，<b>如果要对表空间进行扩容，这需要新增机器，需要将这些数据库中的数据同步等问题。支持的关系数据库服务器数量有限；只能向上扩展不能横向扩展。</b></p><p>（参考资料：<a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/michaelzhou224/article/details/16885391\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">传统数据库缺陷</a> ）</p><h2>4. 虚拟机迁移如何实现</h2><p>虚拟机迁移是将虚拟机实例从源宿主机迁移到目标宿主机，并且在目标宿主机上能够将虚拟机运行状态恢复到其在迁移前相同的状态，以便能够继续完成应用程序的任务。</p><p><b>虚拟机迁移主要包括：</b></p><ul><ul><li>P2V（物理机到虚拟机的迁移）</li><li>V2V（虚拟机到虚拟机的迁移）</li><li>V2P（虚拟机到物理机的迁移）</li></ul></ul><p><b>迁移的步骤：</b></p><ul><ul><li><b>预迁移</b>：选择一个目的计算机作为 VM 的新主机</li><li><b>预定资源</b>：对 B 发送迁移请求，确认 B 是否有需要的资源。</li><li><b>预复制</b>：A 以迭代的方式将内存页复制到 B 中，每次迭代只复制前一轮复制之后被修改的内容。</li><li><b>停机复制</b>：对 A 停机，将它的<b>网络连接</b>重定向到 B ，将<b> CPU 状态</b>和上一轮复制后被修改过的页都传送到 B 。</li><li><b>提交</b>：B 通知 A 已经成功接收了 VM 的映像，A 确认之后，就可以销毁自己和它上面的 VM 。</li><li><b>启动</b>：启动 B 上的 VM，并使用目的计算机的设备驱动，广播新的 IP 地址。</li></ul></ul><p><b>迁移的内容：</b></p><ul><ul><li>内存的迁移</li><li>网络资源的迁移</li><li>存储设备的迁移</li></ul></ul><p><b>内存的迁移的三个阶段：</b></p><ul><ul><li>Push 阶段：预复制</li><li>Stop and Copy：停机复制</li><li>Pull：在新的 VM 运行的时候，如果访问到未复制过的页，就从原来的 VM 中去复制过来。</li></ul></ul><p><b>网络资源的迁移：</b></p><ul><ul><li>在局域网内，通过发送 ARP 重定向包，将 VM 的 IP 地址与目的主机的 MAC 地址相绑定，之后的所有包就可以发送到目的机器上。</li></ul></ul><p><b>存储设备的迁移：</b></p><ul><ul><li>在局域网中通过 NFS（Network File System）方式进行共享，而非真正的迁移。</li></ul></ul><h2>5. 云数据中心的虚拟机管理程序了解</h2><p class=\"ztext-empty-paragraph\"><br/></p><h2>6. MapReduce 的主要工作原理</h2><p>（见第二章和第五章整理）</p><h2>7. 云计算发展趋势、产业现状</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c729f94798ecd39778bebf71d3fa064_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2891\" data-rawheight=\"2244\" class=\"origin_image zh-lightbox-thumb\" width=\"2891\" data-original=\"https://pic1.zhimg.com/v2-1c729f94798ecd39778bebf71d3fa064_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2891&#39; height=&#39;2244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2891\" data-rawheight=\"2244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2891\" data-original=\"https://pic1.zhimg.com/v2-1c729f94798ecd39778bebf71d3fa064_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c729f94798ecd39778bebf71d3fa064_b.jpg\"/></figure><p><b>云计算目前的缺点：</b></p><ul><ul><li>平台角度：没有统一的标准</li><li>计算角度：对于不容易分解为众多互相独立子任务的紧耦合型计算任务，效率较低</li><li>数据角度：目前云计算征集数据的方式过于原始，没有结合网络技术，直接从网络中获取数据。</li><li>资源集成角度：将各类资源和应用迁移到云计算平台的成本过高。</li><li>信息安全角度：失去了绝对控制权。</li></ul></ul><p><b>云计算的发展方向：</b></p><ul><ul><li>使用云格技术，将云计算与网络技术相结合，网络技术解决分布在不同机构的各种信息资源的共享问题，云计算解决计算力和存储空间的集中使用问题。</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>注：笔者也是刚刚开始学习的小白，如有问题请指正，谢谢。</p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//book.douban.com/subject/26598073/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《云计算（第三版）》刘鹏著</a></li></ul>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }
            ], 
            "comments": [
                {
                    "userName": "pho", 
                    "userLink": "https://www.zhihu.com/people/029262d2d2f43499b16be46c8c6c3513", 
                    "content": "云计算巨头居然没有VMware的吗？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38410243", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 2, 
            "title": "经典编程语言的发明时间表", 
            "content": "<p>我们一个统计出来256种编程语言，当然，这么多的语言中只有一些是常用的或实用的：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%E5%8F%91%E6%98%8E%E6%97%B6%E9%97%B4+%26+%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B+%5C%5C+%5Chline+1951+%26+Regional+Assembly+Language+%5C%5C+%5Chline+1952+%26+Autocode+%5C%5C+%5Chline+1954+%26+IPL%EF%BC%88LISP%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89%5C%5C+%5Chline+1955+%26+FLOW-MATIC%EF%BC%88COBOL%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1957+%26+FORTRAN%EF%BC%88%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%9E%8B%E8%AF%AD%E8%A8%80%EF%BC%89+%5C%5C+%5Chline+1957+%26+COMTRAN%EF%BC%88COBOL%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1958+%26+LISP+%5C%5C+%5Chline+1958+%26+ALGOL+58+%5C%5C+%5Chline+1959+%26+FACT%EF%BC%88COBOL%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1959+%26+COBOL+%5C%5C+%5Chline+1959+%26+RPG+%5C%5C+%5Chline+1962+%26+APL+%5C%5C+%5Chline+1962+%26+Simula+%5C%5C+%5Chline+1962+%26+SNOBOL+%5C%5C+%5Chline+1963+%26+CPL%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1964+%26+BASIC+%5C%5C+%5Chline+1964+%26+PL%2FI+%5C%5C+%5Chline+1966+%26+JOSS+%5C%5C+%5Chline+1967+%26+BCPL%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1968+%26+Logo+%5C%5C+%5Chline+1969+%26+B%EF%BC%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A5%96%E5%85%88%EF%BC%89+%5C%5C+%5Chline+1970+%26+Pascal+%5C%5C+%5Chline+1970+%26+Forth+%5C%5C+%5Chline+1972+%26+C+%5C%5C+%5Chline+1972+%26+Smalltalk+%5C%5C+%5Chline+1972+%26+Prolog+%5C%5C+%5Chline+1973+%26+ML+%5C%5C+%5Chline+1975+%26+Scheme+%5C%5C+%5Chline+1978+%26+SQL+%5C%5C+%5Chline+1980+%26+C%2B%2B%EF%BC%88%E6%97%A2%E6%9C%89%E7%B1%BB%E7%9A%84C%E8%AF%AD%E8%A8%80%EF%BC%8C%E6%9B%B4%E5%90%8D%E4%BA%8E1983%E5%B9%B47%E6%9C%88%EF%BC%89+%5C%5C+%5Chline+1983+%26+Ada+%5C%5C+%5Chline+1984+%26+Common+Lisp+%5C%5C+%5Chline+1984+%26+MATLAB+%5C%5C+%5Chline+1985+%26+Eiffel+%5C%5C+%5Chline+1986+%26+Objective-C+%5C%5C+%5Chline+1986+%26+Erlang+%5C%5C+%5Chline+1987+%26+Perl+%5C%5C+%5Chline+1988+%26+Tcl+%5C%5C+%5Chline+1988+%26+Mathematica+%5C%5C+%5Chline+1989+%26+FL+%5C%5C+%5Chline+1990+%26+Haskell+%5C%5C+%5Chline+1991+%26+Python+%5C%5C+%5Chline+1991+%26+Visual+Basic+%5C%5C+%5Chline+1993+%26+Ruby+%5C%5C+%5Chline+1993+%26+Lua+%5C%5C+%5Chline+1994+%26+CLOS%EF%BC%88ANSI+Common+Lisp%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%89+%5C%5C+%5Chline+1995+%26+Java+%5C%5C+%5Chline+1995+%26+Delphi%EF%BC%88Object+Pascal%EF%BC%89+%5C%5C+%5Chline+1995+%26+JavaScript+%5C%5C+%5Chline+1995+%26+PHP+%5C%5C+%5Chline+1996+%26+WebDNA+%5C%5C+%5Chline+1997+%26+Rebol+%5C%5C+%5Chline+1999+%26+D+%5C%5C+%5Chline+2000+%26+ActionScript+%5C%5C+%5Chline+2001+%26+C%5C%23+%5C%5C+%5Chline+2001+%26+Visual+Basic+.NET+%5C%5C+%5Chline+2002+%26+F%5C%23+%5C%5C+%5Chline+2003+%26+Groovy+%5C%5C+%5Chline+2003+%26+Scala+%5C%5C+%5Chline+2007+%26+Clojure+%5C%5C+%5Chline+2009+%26+Go+%5C%5C+%5Chline+2011+%26+Dart+%5C%5C+%5Chline+%5Cend%7Barray%7D\" alt=\"\\begin{array}{|c|c|} \\hline 发明时间 &amp; 语言类型 \\\\ \\hline 1951 &amp; Regional Assembly Language \\\\ \\hline 1952 &amp; Autocode \\\\ \\hline 1954 &amp; IPL（LISP语言的祖先）\\\\ \\hline 1955 &amp; FLOW-MATIC（COBOL语言的祖先） \\\\ \\hline 1957 &amp; FORTRAN（第一个编译型语言） \\\\ \\hline 1957 &amp; COMTRAN（COBOL语言的祖先） \\\\ \\hline 1958 &amp; LISP \\\\ \\hline 1958 &amp; ALGOL 58 \\\\ \\hline 1959 &amp; FACT（COBOL语言的祖先） \\\\ \\hline 1959 &amp; COBOL \\\\ \\hline 1959 &amp; RPG \\\\ \\hline 1962 &amp; APL \\\\ \\hline 1962 &amp; Simula \\\\ \\hline 1962 &amp; SNOBOL \\\\ \\hline 1963 &amp; CPL（C语言的祖先） \\\\ \\hline 1964 &amp; BASIC \\\\ \\hline 1964 &amp; PL/I \\\\ \\hline 1966 &amp; JOSS \\\\ \\hline 1967 &amp; BCPL（C语言的祖先） \\\\ \\hline 1968 &amp; Logo \\\\ \\hline 1969 &amp; B（C语言的祖先） \\\\ \\hline 1970 &amp; Pascal \\\\ \\hline 1970 &amp; Forth \\\\ \\hline 1972 &amp; C \\\\ \\hline 1972 &amp; Smalltalk \\\\ \\hline 1972 &amp; Prolog \\\\ \\hline 1973 &amp; ML \\\\ \\hline 1975 &amp; Scheme \\\\ \\hline 1978 &amp; SQL \\\\ \\hline 1980 &amp; C++（既有类的C语言，更名于1983年7月） \\\\ \\hline 1983 &amp; Ada \\\\ \\hline 1984 &amp; Common Lisp \\\\ \\hline 1984 &amp; MATLAB \\\\ \\hline 1985 &amp; Eiffel \\\\ \\hline 1986 &amp; Objective-C \\\\ \\hline 1986 &amp; Erlang \\\\ \\hline 1987 &amp; Perl \\\\ \\hline 1988 &amp; Tcl \\\\ \\hline 1988 &amp; Mathematica \\\\ \\hline 1989 &amp; FL \\\\ \\hline 1990 &amp; Haskell \\\\ \\hline 1991 &amp; Python \\\\ \\hline 1991 &amp; Visual Basic \\\\ \\hline 1993 &amp; Ruby \\\\ \\hline 1993 &amp; Lua \\\\ \\hline 1994 &amp; CLOS（ANSI Common Lisp的一部分） \\\\ \\hline 1995 &amp; Java \\\\ \\hline 1995 &amp; Delphi（Object Pascal） \\\\ \\hline 1995 &amp; JavaScript \\\\ \\hline 1995 &amp; PHP \\\\ \\hline 1996 &amp; WebDNA \\\\ \\hline 1997 &amp; Rebol \\\\ \\hline 1999 &amp; D \\\\ \\hline 2000 &amp; ActionScript \\\\ \\hline 2001 &amp; C\\# \\\\ \\hline 2001 &amp; Visual Basic .NET \\\\ \\hline 2002 &amp; F\\# \\\\ \\hline 2003 &amp; Groovy \\\\ \\hline 2003 &amp; Scala \\\\ \\hline 2007 &amp; Clojure \\\\ \\hline 2009 &amp; Go \\\\ \\hline 2011 &amp; Dart \\\\ \\hline \\end{array}\" eeimg=\"1\"/> </p><p>从1951年至今，人类一共发明了256种编程语言，每一种语言的出现都带有某些新特征。编程语言不断的在革新，很快就会有超出这个清单的新编程语言出现。 </p><hr/><p>原文链接：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/sarck3/article/details/17383751\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">blog.csdn.net/sarck3/ar</span><span class=\"invisible\">ticle/details/17383751</span><span class=\"ellipsis\"></span></a></li></ul>", 
            "topic": [
                {
                    "tag": "编程语言", 
                    "tagLink": "https://api.zhihu.com/topics/19552826"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38409620", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 5, 
            "title": "开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别", 
            "content": "<p>首先借用有心人士的一张相当直观清晰的图来划分各种协议：开源许可证GPL、BSD、MIT、Mozilla、Apache和LGPL的区别：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-199ddf45ef6b7ee2d7b01ed3c3032b50_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-199ddf45ef6b7ee2d7b01ed3c3032b50_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;690&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"690\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"690\" data-original=\"https://pic1.zhimg.com/v2-199ddf45ef6b7ee2d7b01ed3c3032b50_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-199ddf45ef6b7ee2d7b01ed3c3032b50_b.jpg\"/></figure><p>以下是上述协议的简单介绍：</p><h2><b>BSD开源协议 </b></h2><p>BSD开源协议是一个给于使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><p>但”为所欲为”的前提当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p><ul><li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li><li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li><li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li></ul><p>BSD 代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p><h2><b>Apache Licence 2.0</b></h2><p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和尊重原作者的著作权，同样允许代码修改，再发布（作为开源或商业软件）。需要满足的条件也和BSD类似：</p><ul><li>需要给代码的用户一份Apache Licence</li><li>如果你修改了代码，需要再被修改的文件中说明。</li><li>在延伸的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li><li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以在Notice中增加自己的许可，但不可以表现为对Apache Licence构成更改。</li></ul><p>Apache Licence也是对商业应用友好的许可。使用者也可以在需要的时候修改代码来满足需要并作为开源或商业产品发布/销售。</p><h2><b>GPL</b></h2><p>我们很熟悉的Linux就是采用了GPL。GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p><p>GPL协议的主要内容是只要在一个软件中使用(”使用”指类库引用，修改后的代码或者衍生代码)GPL 协议的产品，则该软件产品必须也采用GPL协议，既必须也是开源和免费。这就是所谓的”传染性”。GPL协议的产品作为一个单独的产品使用没有任何问题，还可以享受免费的优势。</p><p>由于GPL严格要求使用了GPL类库的软件产品必须使用GPL协议，对于使用GPL协议的开源代码，商业软件或者对代码有保密要求的部门就不适合集成/采用作为类库和二次开发的基础。</p><p>其它细节如再发布的时候需要伴随GPL协议等和BSD/Apache等类似。</p><h2><b>LGPL</b></h2><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL 允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p><p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p><p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品</p><h2><b>MIT</b></h2><p>MIT是和BSD一样宽范的许可协议,作者只想保留版权,而无任何其他了限制.也就是说,你必须在你的发行版里包含原许可协议的声明,无论你是以二进制发布的还是以源代码发布的.</p><h2><b>MPL</b></h2><p>MPL是The Mozilla Public License的简写，是1998年初Netscape的 Mozilla小组为其开源软件项目设计的软件许可证。MPL许可证出现的最重要原因就是，Netscape公司认为GPL许可证没有很好地平衡开发者对源代码的需求和他们利用源代码获得的利益。同著名的GPL许可证和BSD许可证相比，MPL在许多权利与义务的约定方面与它们相同（因为都是符合OSIA 认定的开源软件许可证）。但是，相比而言MPL还有以下几个显著的不同之处:</p><ul><li>MPL虽然要求对于经MPL许可证发布的源代码的修改也要以MPL许可证的方式再许可出来，以保证其他人可以在MPL的条款下共享源代码。但是，在MPL 许可证中对“发布”的定义是“以源代码方式发布的文件”，这就意味着MPL允许一个企业在自己已有的源代码库上加一个接口，除了接口程序的源代码以MPL 许可证的形式对外许可外，源代码库中的源代码就可以不用MPL许可证的方式强制对外许可。这些，就为借鉴别人的源代码用做自己商业软件开发的行为留了一个豁口。</li><li>MPL许可证第三条第7款中允许被许可人将经过MPL许可证获得的源代码同自己其他类型的代码混合得到自己的软件程序。</li><li>对软件专利的态度，MPL许可证不像GPL许可证那样明确表示反对软件专利，但是却明确要求源代码的提供者不能提供已经受专利保护的源代码（除非他本人是专利权人，并书面向公众免费许可这些源代码），也不能在将这些源代码以开放源代码许可证形式许可后再去申请与这些源代码有关的专利。</li><li>对源代码的定义：而在MPL（1.1版本）许可证中，对源代码的定义是:“源代码指的是对作品进行修改最优先择取的形式，它包括:所有模块的所有源程序，加上有关的接口的定义，加上控制可执行作品的安装和编译的‘原本’（原文为‘Script’），或者不是与初始源代码显著不同的源代码就是被源代码贡献者选择的从公共领域可以得到的程序代码。”</li><li>MPL许可证第3条有专门的一款是关于对源代码修改进行描述的规定，就是要求所有再发布者都得有一个专门的文件就对源代码程序修改的时间和修改的方式有描述。</li></ul><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.mozilla.org/MPL/MPL-1.1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Mozilla Public License version 1.1</a></li></ul>", 
            "topic": [
                {
                    "tag": "开源许可证", 
                    "tagLink": "https://api.zhihu.com/topics/19563734"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38010497", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 9, 
            "title": "软件工程常用作图方法", 
            "content": "<h2><b>一、数据流图</b></h2><h2><b>简介:</b></h2><p>数据流图是结构化分析方法中使用的工具,它以图形的方式描绘数据在系统中流动和处理的过程，由于它只反映系统必须完成的逻辑功能，所以它是一种功能模型</p><h2><b>数据流程图中有以下几种主要元素：</b></h2><ul><li><b>→</b>：数据流。数据流是数据在系统内传播的路径,因此由一组成分固定的数据组成.如订票单由旅客姓名、年龄、单位、身份证号、日期、目的地等数据项组成.由于数据流是流动中的数据,所以必须有流向,除了与数据存储之间的数据流不用命名外,数据流应该用名词或名词短语命名</li><li><b>□</b>：数据源（终点）.代表系统之外的实体,可以是人、物或其他软件系统</li><li><b>○</b>：对数据的加工（处理）.加工是对数据进行处理的单元,它接收一定的数据输入,对其进行处理,并产生输出</li><li><b>〓</b>：数据存储.表示信息的静态存储,可以代表文件、文件的一部分、数据库的元素等</li></ul><h2><b>例子:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f1c367c7f9a25244348fccf5d67e95ee_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"415\" data-rawheight=\"436\" class=\"content_image\" width=\"415\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;415&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"415\" data-rawheight=\"436\" class=\"content_image lazy\" width=\"415\" data-actualsrc=\"https://pic3.zhimg.com/v2-f1c367c7f9a25244348fccf5d67e95ee_b.jpg\"/></figure><hr/><h2><b>二、实体-联系图(ER图)</b></h2><h2><b>目的:</b></h2><p>为了把用户的数据要求清楚准确地描述起来系统分析员通常建立一个概念性的数据模型</p><h2><b>要素:</b></h2><ul><li>实体型：用矩形表示，矩形框内写明实体名；</li><li>属性：用椭圆形或圆角矩形表示，并用无向边将其与相应的实体连接起来；多值属性由双线连接；主属性名称下加下划线；</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型</li></ul><h2><b>在E-R图中要明确表明1对多关系，1对1关系和多对多关系:</b></h2><ul><li>1对1关系在两个实体连线方向写1;</li><li>1对多关系在1的一方写1，多的一方写N</li><li>多对多关系则是在两个实体连线方向各写N,M</li></ul><h2><b>例子:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a0a4f983d5e96ac99c4828cf55f0d014_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-a0a4f983d5e96ac99c4828cf55f0d014_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;293&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"293\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-a0a4f983d5e96ac99c4828cf55f0d014_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a0a4f983d5e96ac99c4828cf55f0d014_b.jpg\"/></figure><hr/><h2><b>三、层次方框图</b></h2><h2><b>概述:</b></h2><p>层次方框图用树形结构的一系列多层次的矩形描述数据的层次结构.树形结构的顶层是一个单独的矩形框,它代表完整的数据结构,下面的各层矩形框代表这个数据的子集,最底层的各个框代表组成这个数据的实际数据元素(不能再分割的元素)</p><h2><b>例子:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-23bae3c6e78093219405c118dd7213f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb\" width=\"555\" data-original=\"https://pic4.zhimg.com/v2-23bae3c6e78093219405c118dd7213f7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;555&#39; height=&#39;345&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"345\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"555\" data-original=\"https://pic4.zhimg.com/v2-23bae3c6e78093219405c118dd7213f7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-23bae3c6e78093219405c118dd7213f7_b.jpg\"/></figure><hr/><h2><b>四、状态转换图</b></h2><h2><b>概述:</b></h2><p>通过描绘系统的状态及引起系统状态转换的事件,来表示系统的行为.此外状态转换图还指明了作为特定事件的结果系统将做那些动作（例如，处理数据）.因此状态转换图提供了行为建模机制</p><p>在状态转换图中,每一个节点代表一个状态,其中双圈是终结状态</p><h2><b>例子:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ae8c531d4adde16f2cfcbc19a298e4fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"361\" class=\"origin_image zh-lightbox-thumb\" width=\"555\" data-original=\"https://pic4.zhimg.com/v2-ae8c531d4adde16f2cfcbc19a298e4fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;555&#39; height=&#39;361&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"555\" data-rawheight=\"361\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"555\" data-original=\"https://pic4.zhimg.com/v2-ae8c531d4adde16f2cfcbc19a298e4fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ae8c531d4adde16f2cfcbc19a298e4fb_b.jpg\"/></figure><hr/><h2><b>五、判定树</b></h2><h2><b>概要:</b></h2><p>判定树又称决策树，是一种描述加工的图形工具，适合描述问题处理中具有多个判断，而且每个决策与若干条件有关。使用判定树进行描述时，应该从问题的文字描述中分清哪些是判定条件，哪些是判定的决策，根据描述材料中的联结词找出判定条件的从属关系、并列关系、选择关系，根据它们构造判定树</p><h2><b>例子:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d9377f4098d0baa72eeac10e26b122f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-d9377f4098d0baa72eeac10e26b122f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;210&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"210\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-d9377f4098d0baa72eeac10e26b122f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d9377f4098d0baa72eeac10e26b122f4_b.jpg\"/></figure><hr/><h2><b>六、盒图(N-S图)</b></h2><h2><b>简介:</b></h2><p>流程图由一些特定意义的图形、流程线及简要的文字说明构成,它能清晰明确地表示程序的运行过程.在使用过程中,人们发现流程线不一定是必需的,为此,人们设计了一种新的流程图,它把整个程序写在一个大框图内,这个大框图由若干个小的基本框图构成,这种流程图简称N-S图</p><h2><b>N-S图的特点:</b></h2><ul><li>功能域明确</li><li>很容易确定局部和全局数据的作用域</li><li>不可能任意转移控制</li><li>很容易表示嵌套关系及模块的层次关系</li></ul><h2><b>几种基本程序结构的N-S图:</b></h2><p><b>1、顺序结构N-S图:</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4c589627241ce35aaa5fb8a1e3d65c14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"59\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"59\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic1.zhimg.com/v2-4c589627241ce35aaa5fb8a1e3d65c14_b.jpg\"/></figure><p><b>2、选择结构N-S图:</b></p><p>① if条件:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4a8ca255ba19b8aeea5e38745f64f6a0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"255\" data-rawheight=\"107\" class=\"content_image\" width=\"255\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;255&#39; height=&#39;107&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"255\" data-rawheight=\"107\" class=\"content_image lazy\" width=\"255\" data-actualsrc=\"https://pic1.zhimg.com/v2-4a8ca255ba19b8aeea5e38745f64f6a0_b.jpg\"/></figure><p>② 多分支：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-673b56871b05b52c8bea75da3df6c026_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"248\" data-rawheight=\"236\" class=\"content_image\" width=\"248\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;248&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"248\" data-rawheight=\"236\" class=\"content_image lazy\" width=\"248\" data-actualsrc=\"https://pic3.zhimg.com/v2-673b56871b05b52c8bea75da3df6c026_b.jpg\"/></figure><p><b>3、循环结构N-S图:</b></p><p><b>① </b>当型循环:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-54c09e91b5517df63502a4aec46345da_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"234\" data-rawheight=\"89\" class=\"content_image\" width=\"234\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;234&#39; height=&#39;89&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"234\" data-rawheight=\"89\" class=\"content_image lazy\" width=\"234\" data-actualsrc=\"https://pic3.zhimg.com/v2-54c09e91b5517df63502a4aec46345da_b.jpg\"/></figure><p>② 直到型循环:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-73439db9a1dfba114879d994a7dc5c89_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"278\" data-rawheight=\"96\" class=\"content_image\" width=\"278\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;278&#39; height=&#39;96&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"278\" data-rawheight=\"96\" class=\"content_image lazy\" width=\"278\" data-actualsrc=\"https://pic2.zhimg.com/v2-73439db9a1dfba114879d994a7dc5c89_b.jpg\"/></figure><h2><b>例子：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-95be3ef03d590a9756ed5cd50fc02fc8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"316\" class=\"content_image\" width=\"325\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;325&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"325\" data-rawheight=\"316\" class=\"content_image lazy\" width=\"325\" data-actualsrc=\"https://pic1.zhimg.com/v2-95be3ef03d590a9756ed5cd50fc02fc8_b.jpg\"/></figure><hr/><h2><b>七、PAD图</b></h2><h2><b>定义:</b></h2><p>PAD是问题分析图（Problem Analysis Diagram）的英文缩写，自1973年由日本日立公司发明以来，已经得到一定程度的推广。它用二维数形结构的图表示程序的控制流，将这种图转换为程序代码比较容易</p><p><b>优点:</b></p><ul><li>使用表示结构优化控制结构的PAD符号所设计出来的程序必然是程序化程序</li><li>PAD图所描述的程序结构十分清晰.图中最左边的竖线是程序的主线,即第一层控制结构。随着程序层次的增加,PAD图逐渐向右延伸,每增加一个层次,图形向右扩展一条竖线.PAD图中竖线的总条数就是程序的层次数</li><li>用PAD图表现程序逻辑,易读、易懂、易记.PAD图是二维数型结构的图形,程序从图中最左边上端的结点开始执行,自上而下,从左到右顺序执行</li><li>很容易将PDA图转换成高级程序语言源程序,这种转换可由软件工具自动完成,从而可省去人工编码的工作,有利于提高软件可靠性和软件生产率</li><li>可用于表示程序逻辑,也可用于描述数据结构</li><li>PAD图的符号支持自顶向下、逐步求精方法的使用.开始时设计者可以定义一个抽象程序,随着设计工作的深入而使用“def”符号逐步增加细节,直至完成详细设计</li></ul><h2><b>流图含义:</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7cc4af0482334d2838a6e29547d27ee5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-7cc4af0482334d2838a6e29547d27ee5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;506&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"506\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-7cc4af0482334d2838a6e29547d27ee5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7cc4af0482334d2838a6e29547d27ee5_b.jpg\"/></figure><h2><b>例子：</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7a034cb3996748d2ff5aabb87f999cc2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"488\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"488\" data-original=\"https://pic3.zhimg.com/v2-7a034cb3996748d2ff5aabb87f999cc2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;488&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"488\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"488\" data-original=\"https://pic3.zhimg.com/v2-7a034cb3996748d2ff5aabb87f999cc2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7a034cb3996748d2ff5aabb87f999cc2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/kzloser/archive/2012/07/05/2577432.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">软件工程 --软件工程用图 - kzangv - 博客园</a></li></ul>", 
            "topic": [
                {
                    "tag": "软件工程", 
                    "tagLink": "https://api.zhihu.com/topics/19557552"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38007214", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 9, 
            "title": "软件工程考试重点", 
            "content": "<h2><b>第一章 软件工程学概述</b></h2><h2><b>一、概念</b></h2><h2><b>软件</b></h2><p>软件是计算机系统中与硬件相互依存的另一部分，它包括程序、数据及相关文档的完整集合。其中，程序是按事先设计的功能和性能要求执行的指令序列；数据是使程序能正常操纵信息的数据结构；文档是与程序开发、维护和使用有关的图文材料。</p><h2><b>软件危机</b></h2><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。</p><h2><b>软件工程</b></h2><p>软件工程是采用工程的概念、原理、技术和方法来指导软件开发和维护的工程学科。</p><h2><b>生命周期方法学</b></h2><p>生命周期方法学是软件工程的传统途径。<br/>从时间角度对软件开发和维护的复杂问题进行分解，划分为若干个阶段，每个阶段有相对独立的任务，是在阶段结束时进行技术审查和管理复审，最后产生相应的文档资料。</p><h2><b>二、软件危机</b></h2><h2><b>软件危机产生的原因</b></h2><ol><li>与软件自身的特点有关：<br/>逻辑实体、手工开发、复杂度高、成本昂贵。</li><li>与开发、维护方法不正确有关：<br/>忽视用户需求，轻视软件维护。</li></ol><h2><b>消除软件危机的途径</b></h2><ol><li>技术措施：方法和工具</li><li>组织管理措施：从管理角度进行审查、控制。</li></ol><p>软件工程正是从技术和管理两方面研究如何更好地开发和维护计算机软件的一门新兴学科。</p><h2><b>三、软件生命周期</b></h2><h2><b>三个时期</b></h2><ul><li>软件定义</li><li>软件开发</li><li>软件维护</li></ul><h2><b>八个阶段</b></h2><ul><li>问题定义</li><li>可行性研究</li><li>需求分析</li><li>概要设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li><li>软件维护</li></ul><h2><b>四、软件过程模型</b></h2><h2><b>软件过程模型的种类</b></h2><ul><li>瀑布模型</li><li>原型模型</li><li>螺旋模型</li><li>喷泉模型</li><li>智能模型</li></ul><h2><b>瀑布模型</b></h2><p>瀑布模型：系统的生命周期方法学用瀑布模型来进行模拟。</p><ul><li>各阶段间具有顺序性和依赖性</li><ul><li>前阶段结束—&gt;后阶段开始。</li><li>前阶段输出文档—&gt;后阶段输入文档。</li></ul><li>推迟实现的观点：设置系统分析与设计、推迟物理实现。</li><li>质量保证的观点：</li><ul><li>每个阶段必须完成规定的文档</li><li>每个阶段结束前要对文档评审，以便尽早发现问题，改正错误。</li></ul></ul><hr/><h2><b>第二章 可行性研究</b></h2><h2><b>一、可行性研究任务</b></h2><p>根本任务：对以后的行动方针提出建议</p><h2><b>二、可行性研究过程</b></h2><ul><li>复查系统规模和目标</li><li>研究目前正在使用的系统</li><li>导出新系统的高层逻辑模型</li><li>重新定义问题</li><li>导出和评价供选择的解法</li><li>推荐行动方针</li><li>草拟开发计划</li><li>书写文档并提交审查</li></ul><h2><b>三、数据流程图</b></h2><h2><b>符号</b></h2><p>P25</p><h2><b>指导规则</b></h2><ul><li>第一层DFD应当是基本系统模型</li><li>注意父图和子图的平衡，维护信息的连续性</li><li>区分局部文件和局部外部项</li><li>掌握分解的速度，上快下慢</li><li>遵守加工编号原则</li></ul><h2><b>用途</b></h2><p>数据流图（DFD）是软件系统逻辑模型的一种图形表示，是从数据传递和加工的角度，以图形的方式刻画数据流从输入到输出的移动变换过程的工具。</p><h2><b>应用（需求陈述 -&gt; 建模）</b></h2><h2><b>四、数据字典</b></h2><h2><b>符号</b></h2><p>P26</p><h2><b>规则</b></h2><h2><b>用途</b></h2><p>数据字典是关于数据的信息的集合，是对DFD中的所有元素定义的集合。</p><h2><b>应用（需求陈述 -&gt; 建模）</b></h2><h2><b>五、成本/效益分析</b></h2><h2><b>货币的时间价值计算</b></h2><p>设年利率为 i  ，现已存入 p 元，则 n 年后所得： <img src=\"https://www.zhihu.com/equation?tex=F%3DP%2A%281%2Bi%29%5En\" alt=\"F=P*(1+i)^n\" eeimg=\"1\"/> ，即为 P 元钱在 n 年后的价值。反之，若 n 年后能收入 F 元，则其在现在的价值为： <img src=\"https://www.zhihu.com/equation?tex=P+%3D+F+%2F+%281%2Bi%29%5En\" alt=\"P = F / (1+i)^n\" eeimg=\"1\"/> 。</p><hr/><h2><b>第三章 需求分析</b></h2><h2><b>一、需求分析的任务</b></h2><h2><b>基本任务</b></h2><p>回答“系统必须做什么”？确定目标系统功能和性能。</p><h2><b>具体任务</b></h2><ul><li>确定对系统的综合要求：功能要求；性能要求；运行要求；将来可能提出的要求。</li><li>分析系统的数据要求：E-R图（概念模型） 。</li><li>导出系统的逻辑模型：数据流图，数据字典，加工处理说明书等。</li><li>修正系统开发计划。</li><li>开发原型系统：使用户对目标系统有一个更直接、更具体的概念，从而能更准确提出用户需求。（关键的困难在于成本）</li></ul><h2><b>二、需求分析的原则</b></h2><ul><li>必须能够表达和理解问题的数据域和功能域</li><li>必须按自顶向下，逐层分解的方式对问题进行分解和不断细化。（细化数据流图）</li><li>要给出系统的逻辑视图和物理视图。</li></ul><h2><b>三、数据分析和建模</b></h2><h2><b>实体-联系图ER模型</b></h2><p>P29</p><h2><b>数据规范化</b></h2><p>?</p><h2><b>状态转换图</b></h2><p>?</p><h2><b>四、数据流图案例</b></h2><p>P31</p><h2><b>五、E-R 图案例</b></h2><p>P30</p><h2><b>六、加工说明（需求规格说明）</b></h2><h2><b>定义</b></h2><p>是对DFD中的加工所做的描述，包括：输入数据、加工逻辑、输出数据等。</p><h2><b>内容</b></h2><ul><li>加工名称</li><li>加工编号</li><li>输入数据流</li><li>输出数据流</li><li>加工逻辑</li><li>执行次数</li></ul><h2><b>描述方法</b></h2><ul><li>结构化语言（PDL）</li><li>判定表</li><li>判定树</li></ul><h2><b>七、验证软件需求</b></h2><ul><li><b>一致性</b>：所有需求必须一致，不能互相矛盾。</li><li><b>完整性</b>：需求必须完整，包含用户需要的所有功能和性能。</li><li><b>现实性</b>：指定需求用现有的软、硬件技术基本上可以实现。</li><li><b>有效性</b>：必须证明需求是正确有效的，确实能解决用户面对的问题。</li></ul><hr/><h2><b>第五章 总体设计</b></h2><h2><b>一、概念</b></h2><h2><b>模块化</b></h2><p>模块化是把程序划分成若干个模块，每个模块完成一个子功能，把这些模块集中起来组成一个整体，可以完成指定的功能，满足问题的要求。</p><h2><b>模块独立性</b></h2><p>模块具有独立功能，且和其他模块之间没有过多的相互作用。即每个模块完成一个相对独立的特定子功能，且和其他模块之间的关系很简单。是软件划分模块时要遵守的准则，也是判断模块构造是否合理的标准。</p><h2><b>内聚</b></h2><p>是模块功能强度（即一个模块内部各个元素彼此结合的紧密程度）的度量。模块内部各元素之间联系越紧密，内聚性越强。</p><h2><b>耦合</b></h2><p>是模块之间相对独立性（即互相连接的紧密程度）的度量。模块间连接越紧密，联系越多，耦合性越强。</p><h2><b>扇入</b></h2><p>调用（或控制）一个给定模块的模块数目。</p><h2><b>扇出</b></h2><p>一个模块直接调用（或控制）的其他模块数目。</p><h2><b>二、设计原理与启发规则</b></h2><h2><b>模块独立性的衡量标准</b></h2><p><b>内聚、耦合</b><br/>模块的独立性越高，其块内联系越紧密（内聚性强），块间联系越弱（耦合性越弱）。</p><h2><b>模块的作用域和控制域</b></h2><p>？</p><h2><b>三、面向数据流的控制方法</b></h2><h2><b>不同类型的数据流图“映射”软件结构的方法、步骤</b></h2><p>P42</p><h2><b>第六章 详细设计</b></h2><h2><b>一、概念</b></h2><h2><b>结构化程序设计</b></h2><p>是一种设计程序的技术，它采用自定向下，逐步求精的设计方法和单入口，单出口的控制结构。</p><h2><b>人机界面设计</b></h2><p>？</p><h2><b>二、人机界面设计和过程设计工具</b></h2><h2><b>程序流程图</b></h2><p>是流程程序分析过程最基本工具，它是人们对解决问题的方法，思路式算法的一种描述。<br/>P55</p><h2><b>N-S 图</b></h2><p>P56</p><h2><b>PAD 图</b></h2><p>P57</p><h2><b>判定表</b></h2><p>采用表格化的形式，适于表达含有复杂判断的加工逻辑。<br/>实例：（书：P86）</p><h2><b>判定树</b></h2><p>是判定表的图形表示，其适用场合与判定表相同。<br/>实例：（书：P87）</p><h2><b>结构化语言（伪码PDL）</b></h2><p>又称过程设计语言，伪码；它是一种介于自然语言与程序设计语言之间的语言，即具有结构化程序的清晰易读的优点，又具有自然语言的灵活性，不受程序设计语言那样严格的语法约束。</p><h2><b>三、面向数据结构的设计方法</b></h2><h2><b>Jackson 方法</b></h2><p>P60</p><h2><b>四、程序复杂度的定量度量</b></h2><h2><b>概念和计算方法</b></h2><p>P62</p><hr/><h2><b>第七章 实现</b></h2><h2><b>一、概念</b></h2><h2><b>编码风格</b></h2><p>即程序设计风格，就是指作家、画家和程序员在创作中喜欢和习惯使用的表达自己作品题材的方式。</p><h2><b>测试</b></h2><p>是为了发现错误而执行程序的过程，即根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例，并利用这些测试用例去运行程序，以发现程序错误的过程。</p><h2><b>测试方法</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a14335ef861f7fa9e5323971c3a2c4dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3461\" data-rawheight=\"1561\" class=\"origin_image zh-lightbox-thumb\" width=\"3461\" data-original=\"https://pic1.zhimg.com/v2-a14335ef861f7fa9e5323971c3a2c4dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3461&#39; height=&#39;1561&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"3461\" data-rawheight=\"1561\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3461\" data-original=\"https://pic1.zhimg.com/v2-a14335ef861f7fa9e5323971c3a2c4dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a14335ef861f7fa9e5323971c3a2c4dc_b.jpg\"/></figure><h2><b>测试步骤</b></h2><p>单元测试，综合测试，确认测试、系统测试</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-31ee62b4057a12d83ec1184eab9ff208_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"337\" class=\"origin_image zh-lightbox-thumb\" width=\"517\" data-original=\"https://pic1.zhimg.com/v2-31ee62b4057a12d83ec1184eab9ff208_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;517&#39; height=&#39;337&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"517\" data-rawheight=\"337\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"517\" data-original=\"https://pic1.zhimg.com/v2-31ee62b4057a12d83ec1184eab9ff208_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-31ee62b4057a12d83ec1184eab9ff208_b.jpg\"/></figure><p><b>测试用例</b></p><p>是以发现错误为目的而精心设计的一组测试数据，测试用例＝{输入数据＋期望结构}</p><h2><b>回归测试</b></h2><p>？</p><h2><b>调试（纠错）</b></h2><p>是为了确定错误的性质，并且加以纠正。</p><h2><b>软件可靠性</b></h2><p>？</p><h2><b>软件可用性</b></h2><p>?</p><h2><b>二、集成测试策略</b></h2><h2><b>渐增式测试（自顶向下测试）</b></h2><p>测试时从顶层模块开始，沿被测程序的结构图逐步下移，每次只增加一个新的模块。</p><h2><b>非渐增式测试</b></h2><p>一次就把通过了单元测试的所有模块组装起来，进行全程序的测试，出了问题很难进行错误定位。</p><h2><b>渐增式的自顶向下</b></h2><p>测试时从顶层模块开始，沿被测程序的结构图逐步下移，每次只增加一个新的模块</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f39eb1f07449801a2fab7e098e08b6fb_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"248\" data-rawheight=\"270\" class=\"content_image\" width=\"248\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;248&#39; height=&#39;270&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"248\" data-rawheight=\"270\" class=\"content_image lazy\" width=\"248\" data-actualsrc=\"https://pic4.zhimg.com/v2-f39eb1f07449801a2fab7e098e08b6fb_b.jpg\"/></figure><h2><b>渐增式的自底向上</b></h2><p>模块组装顺序采取由下向上的路线。</p><h2><b>三、白盒测试（结构测试）技术</b></h2><p>以程序的内部逻辑作为依据</p><h2><b>测试过程分类</b></h2><ul><li>语句覆盖：使被测试程序的每条语句至少执行一次。</li><li>判定覆盖：使被测试程序的每一分支都至少执行一次。</li><li>条件覆盖：要求判定中的每个条件都按“真”“假”两种结果至少执行一次。</li><li>判定/条件覆盖：要求判定中的每个条件都取到各种可能的值，而且每个判定表达式也都要取到各种可能的结果。</li><li>条件组合覆盖：要求判定中每个条件的各种可能组合都至少出现一次。</li></ul><h2><b>测试用例设计</b></h2><p>P78</p><h2><b>四、黑盒测试（功能测试）技术</b></h2><h2><b>等价分类法</b></h2><p>把被测程序的输入域划分为若干各等价类，每个测试用例都代表一类与它等价的其他例子。</p><h2><b>边界值分析</b></h2><p>在等价分类法中，将代表一个类的测试数据选在等价类的边界上。（如：X&lt;=400）。</p><h2><b>测试用例设计</b></h2><p>P73</p><hr/><h2><b>第八章 维护</b></h2><h2><b>一、概念</b></h2><h2><b>软件维护</b></h2><p>是在软件已经交付使用之后，为了改正错误或满足新的需要而修改软件的过程。</p><h2><b>软件可维护性</b></h2><p>是指纠正软件系统出现的错误或缺陷，以及为满足新的要求进行修改，扩充或压缩的容易程度，即衡量维护容易程度的一种属性。</p><h2><b>二、软件维护的几种类型</b></h2><ul><li><b>完善性维护</b>：在软件使用过程中，为了满足用户对软件的功能与性能提出新的需求而进行的维护。(50%)</li><li><b>适应性维护</b>：使软件适应运行环境(包括软，硬件环境及数据环境)的变化而进行的维护。(25%)</li><li><b>纠错性维护</b>：为纠正在开发期间未能发现的错误而进行的维护。(21%)</li><li>其他维护：（如：<b>预防性维护</b>）为改善软件的可维护性，可靠性等，以减少今后对其进行维护所需的工作量的工作而进行的维护。(4%)</li></ul><h2><b>三、软件维护过程</b></h2><ul><li>维护组织</li><li>维护报告</li><li>维护事件流</li><li>保存维护记录</li><li>评价维护活动</li></ul><h2><b>四、软件的可维护性</b></h2><h2><b>决定软件可维护性的因素</b></h2><ul><li>可理解性：指人们通过阅读源代码和相关文档。了解程序功能及如何运行的容易程度。</li><li>可修改性：指程序容易修改的程序，可修改性好的程序，在修改时出错的概率也小一些。</li><li>可测试性：指程序容易被测试的程序。</li></ul><p></p><p></p>", 
            "topic": [
                {
                    "tag": "软件工程", 
                    "tagLink": "https://api.zhihu.com/topics/19557552"
                }
            ], 
            "comments": [
                {
                    "userName": "远航", 
                    "userLink": "https://www.zhihu.com/people/fbbeae0c1908b9f3671f1f2eee3cfd84", 
                    "content": "楼主，您好，我是数学跨考软件工程，快要复试了，软件工程还是一头雾水[大哭]，请问我该怎么抓重点啊。背东西背的我自己都不知道在背啥", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "我也不知道，好久了，早忘记了，不好意思。😂", 
                            "likes": 0, 
                            "replyToAuthor": "远航"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/38007104", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 10, 
            "title": "软件工程必背考点", 
            "content": "<h2><b>一、概述</b></h2><h2><b>软件的定义</b></h2><p>软件是计算机系统中与硬件相互依存的另一部分，它包括程序、数据及相关文档的完整集合。其中，程序是按事先设计的功能和性能要求执行的指令序列；数据是使程序能正常操纵信息的数据结构；文档是与程序开发、维护和使用有关的图文材料。</p><h2><b>软件的分类</b></h2><ul><li>按功能分：系统软件、支撑软件、应用软件</li><li>按规模分：大型、中型、小型</li><li>按工作方式分：实时/分时、交互/批处理</li><li>按服务对象分：定制软件、产品软件</li><li>按销售方式分：定单软件、非定单软件</li></ul><h2><b>软件危机的定义</b></h2><p>软件危机是指在计算机软件的开发和维护过程中所遇到的一系列严重问题。这些问题绝不仅仅是不能正常运行的软件才具有的，实际上，几乎所有软件都不同程度地存在这些问题。</p><h2><b>软件危机包含的问题</b></h2><ul><li>如何开发软件，以满足对软件日益增长的需求；</li><li>如何维护数量不断膨胀的已有软件。</li></ul><h2><b>软件危机的典型表现</b></h2><ul><li>对软件开发的进度和成本无法估计</li><li>用户对已经开发完成的软件的满意度非常低</li><li>软件质量无法保证</li><li>软件开发后的维护工作很难进行</li><li>软件通常没有合适的文档资料</li><li>软件成本在系统总成本中所占的比例越来越高</li><li>软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。</li></ul><h2><b>软件危机产生的原因</b></h2><ul><li>一方面与软件本身的特点有关。</li><li>另一方面也和软件开发与维护的方法不正确有关。</li></ul><h2><b>软件危机的解决途径</b></h2><p>为了解决软件危机，既要有技术措施(方法和工具)，又要有必要的组织管理措施。软件工程正是从管理和技术两方面研究如何更好地开发和维护计算机软件的一门新兴学科。</p><h2><b>软件工程的意义</b></h2><p>软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。</p><h2><b>软件工程的7条基本原则</b></h2><ul><li>用分阶段的生命周期计划严格管理。</li><li>坚持进行阶段评审。</li><li>实行严格的产品控制。</li><li>采用现代的程序设计技术。</li><li>结果应能清楚地审查。</li><li>开发小组的人员应该少而精。</li><li>承认不断改进软件工程实践的必要性。</li></ul><h2><b>软件生命的3个周期</b></h2><ul><li>软件定义</li><li>软件开发</li><li>运行维护（软件维护）</li></ul><h2><b>软件生命的8个阶段</b></h2><ul><li>问题定义</li><li>可行性研究</li><li>需求分析</li><li>总体设计</li><li>详细设计</li><li>编码和单元测试</li><li>综合测试</li><li>软件维护</li></ul><h2><b>软件过程模型的种类</b></h2><ul><li>瀑布模型</li><li>原型（迭代）模型</li><li>喷泉模型</li><li>增量模型</li><li>螺旋模型</li><li>构件组装模型</li></ul><h2><b>瀑布模型</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-edb201e00f05d44eda62ef39fe1ba76d_b.jpg\" data-rawwidth=\"771\" data-rawheight=\"435\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"771\" data-original=\"https://pic2.zhimg.com/v2-edb201e00f05d44eda62ef39fe1ba76d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;771&#39; height=&#39;435&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"771\" data-rawheight=\"435\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"771\" data-original=\"https://pic2.zhimg.com/v2-edb201e00f05d44eda62ef39fe1ba76d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-edb201e00f05d44eda62ef39fe1ba76d_b.jpg\"/></figure><h2><b>瀑布模型的优点</b></h2><ul><li>从上一项活动中接受该项活动的工作成果（工作产品），作为输入。</li><li>强调开发的阶段性；</li><li>强调早期计划及需求调查；</li><li>强调产品测试。</li></ul><p><b>瀑布模型的缺点</b></p><ul><li>从认识论角度看，人的认识是一个多次反复循环的过程，不可能一次完成。但瀑布模型中划分的几个阶段，没有反映出这种认识过程的反复性。特别是瀑布模型过于依赖早期进行的唯一一次需求调查，不能适应需求的变化；</li><li>软件开发是一个知识密集型的开发活动，需要相互合作完成，但瀑布模型没有体现这一点。特别是由于瀑布模型是单一流程，开发中的经验教训不能反馈应用于本产品的过程。</li></ul><h2><b>原型模型</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e8d5f2c847638ef23181e8ed7b17422d_b.jpg\" data-rawwidth=\"763\" data-rawheight=\"334\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"763\" data-original=\"https://pic2.zhimg.com/v2-e8d5f2c847638ef23181e8ed7b17422d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;763&#39; height=&#39;334&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"763\" data-rawheight=\"334\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"763\" data-original=\"https://pic2.zhimg.com/v2-e8d5f2c847638ef23181e8ed7b17422d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e8d5f2c847638ef23181e8ed7b17422d_b.jpg\"/></figure><p><b>项目的定义</b></p><p>项目是一个特殊的、将被完成的有限任务，它是在一定时间内，满足一系列特定目标的多项相关工作的总称。</p><h2><b>项目管理的定义</b></h2><p>项目管理就是以项目为对象的系统管理方法，通过一个临时性的、专门的柔性组织，运用相关的知识、技术和手段，对项目进行高效率的计划、组织、指导和控制，以实现项目全过程的动态管理和项目目标实现过程的综合协调与优化。</p><h2><b>项目管理的四层含义</b></h2><ul><li>项目管理的对象——项目</li><li>项目管理的组织特点——临时性、富有柔性</li><li>项目管理的手段——计划、组织、指导和控制</li><li>项目管理的目标——实现项目全过程的动态管理及项目目标实现过程的综合协调与优化</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二、可行性研究</b></h2><p><b>问题定义阶段的工作目标</b></p><ul><li>理解根本问题——问题背后的问题</li><li>确定涉众和用户</li><li>定义解决方案系统的边界</li><li>确定问题解决方案的约束条件</li><li>在根本问题的定义与理解上与用户达成共识</li></ul><h2><b>可行性研究的定义</b></h2><p>所谓可行性研究，就是按照各种有效的方法和工作程序，对拟建系统项目在技术上的先进性、适用性，经济上的合理性、盈利性，以及项目的实施的可能性等方面进行深入的系统分析。</p><h2><b>可行性研究的目的</b></h2><p>可行性研究的目的就是用<b>最小的代价</b>在<b>尽可能短的时间</b>内确定问题<b>是否能够解决</b>，是否有必要去解决。<br/>判断需求是否合理</p><h2><b>可行性研究的内容</b></h2><ul><li>技术上的可行性</li><li>经济上的可行性</li><li>操作可行性</li><li>时间可行性</li><li>组织和管理上可行性</li><li>社会、政策允许的可行性</li></ul><h2><b>技术上的可行性</b></h2><p>使用现有的技术能实现这个系统吗？即分析现有的技术条件实现系统的可能性。包括我们已经掌握或目前市场上可以获得的的计算机硬件、网络、平台软件和开发工具技术条件。</p><h2><b>经济上的可行性</b></h2><ul><li>这个系统的经济效益能超过它的开发成本吗？</li><li>经济上的可行性包括两个方面：一是初步估算开发系统所需的投资，目前资金有无落实；二是估计系统开发成本与能带来的效益（包括直接效益、间接效益）。</li></ul><h2><b>操作可行性</b></h2><ul><li>系统的操作方式在这个用户组织内行得通吗？</li></ul><h2><b>可行性研究的结论</b></h2><ul><li>项目可以立即开始进行</li><li>需要增加资源才能开始，例如增加投资或人力。</li><li>需要推迟到某些条件具备后才能开始，例如组织机构的调整。</li><li>需要对系统目标作某些修改才能开始。</li><li>不能或没有必要进行，例如经济上不合理，投资相差太大。</li></ul>", 
            "topic": [
                {
                    "tag": "软件工程", 
                    "tagLink": "https://api.zhihu.com/topics/19557552"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37908790", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 51, 
            "title": "C语言中32个关键字详解", 
            "content": "<p>由ANSI标准定义的C语言关键字共32个:</p><p> auto double int struct break else long switch</p><p> case enum register typedef char extern return union</p><p> const float short unsigned continue for signed void</p><p> default goto sizeof volatile do if while static</p><p> 根据关键字的作用，可以将关键字分为数据类型关键字和流程控制关键字两大类。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一、数据类型关键字</b></h2><p><b>A基本数据类型（5个）</b></p><ul><li>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</li><li>char：字符型类型数据，属于整型数据的一种</li><li>int：整型数据，通常为编译器指定的机器字长</li><li>float：单精度浮点型数据，属于浮点数据的一种</li><li>double：双精度浮点型数据，属于浮点数据的一种</li></ul><p><b>B类型修饰关键字（4个）</b></p><ul><li>short：修饰int，短整型数据，可省略被修饰的int。</li><li>long：修饰int，长整形数据，可省略被修饰的int。</li><li>signed：修饰整型数据，有符号数据类型</li><li>unsigned：修饰整型数据，无符号数据类型</li></ul><p><b>C复杂类型关键字（5个）</b></p><ul><li>struct：结构体声明</li><li>union：共用体声明</li><li>enum：枚举声明</li><li>typedef：声明类型别名</li><li>sizeof：得到特定类型或特定类型变量的大小</li></ul><p><b>D存储级别关键字（6个）</b></p><ul><li>auto：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</li><li>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</li><li>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</li><li>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“</li><li>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</li><li>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</li></ul><h2><b>二、流程控制关键字</b></h2><p><b>A跳转结构（4个）</b></p><ul><li>return：用在函数体中，返回特定值（或者是void值，即不返回值）</li><li>continue：结束当前循环，开始下一轮循环</li><li>break：跳出当前循环或switch结构</li><li>goto：无条件跳转语句</li></ul><p><b>B分支结构（5个）</b></p><ul><li>if：条件语句</li><li>else：条件语句否定分支（与if连用）</li><li>switch：开关语句（多重分支语句）</li><li>case：开关语句中的分支标记</li><li>default：开关语句中的“其他”分治，可选。</li></ul><p><b>C循环结构（3个）</b></p><ul><li>for：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2...循环，其中2为循环条件</li><li>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1...循环，2为循环条件</li><li>while：while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1...循环，1为循环条件</li></ul><p>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p><hr/><p>补充：</p><p>C语言中没有 string ，要想在C语言中使用字符串，就要在头文件里定义#include&lt;string.h&gt;（引用）而字符串在c++里的定义是#include&lt;string&gt;；在C/C++中使用字符串也就是定义时不一样，其他的都一样。string 是字符串，char是单个的字符。string相当于一个容器，char可以放在里面。string有结束符，char是没有的。string是c++里的，不是c里的。用string存储字符串时，不用设定字符串的长度，而char要设定。还有就是，string有很强很方便的功能，比如可以方便的赋值，方便的比较大小。</p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/35308881\" class=\"internal\">C语言运算符优先级</a></li></ul>", 
            "topic": [
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": [
                {
                    "userName": "当初说给风听", 
                    "userLink": "https://www.zhihu.com/people/8c4496a804706df4a62f484666e59e6b", 
                    "content": "受教了 谢谢！", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "于大丶", 
                    "userLink": "https://www.zhihu.com/people/e10714b697ba68b123770ada1e31b820", 
                    "content": "谢谢", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "九九", 
                    "userLink": "https://www.zhihu.com/people/a1e9ac4ab869c18862fef3a8b04d2e8d", 
                    "content": "谢谢，有用", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "格四条", 
                    "userLink": "https://www.zhihu.com/people/b1254ca3ad3b0d5dc86354d95e659d0a", 
                    "content": "extern那里是真的秀", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "龙舞陌", 
                    "userLink": "https://www.zhihu.com/people/78befaae71239e53d6c70a1e3656f26f", 
                    "content": "不懂", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "master", 
                    "userLink": "https://www.zhihu.com/people/de077385ab29dfb372450dca694cb2ec", 
                    "content": "谢谢", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37873947", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 44, 
            "title": "计算机组成原理知识梳理", 
            "content": "<h2><b>一、考纲</b></h2><h2><b>1、浮点数的规格化表示</b></h2><ul><li>原码的尾数，规格化表示应该是 ×.1×……×</li><li>补码的尾数，规格化表示应该是 0.1×……× 或 1.0×……× ， 即符号位(MS)和最高有效位(M1)相异。</li></ul><h2><b>2、数制之间的转换</b></h2><h2><b>3、浮点数的加法</b></h2><ul><li>例题：解：[X]浮 = 00，001   11.0110101     [Y]浮 = 11，110   00.1100101</li><ul><li>（1）对阶 ΔE=EX-EY=[EX]补+[-EY]补 = 00，001+00，010 = 00，011 ΔE=3&gt;0，将MY右移3位，EY加3： [Y]浮 = 00，001   00.0001100 （101）</li><li>（2）尾数相加：   [MZ]补 = 11.1000001（101）</li><li>（3）结果规格化：左规一位，无溢出： [MZ]补 = 11.0000011（01） [EZ]补 = 00，001 + 11，111= 00，000</li><li>（4）舍入：按照0舍1入法，尾数多余位舍去 结果为：[Z]浮 = 0，000   1.0000011</li></ul></ul><h2><b>4、微程序的流程图</b></h2><ul><li>例：ADD 和 JMP 指令：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7cb4f9ab5f12182d92ff363dc9bf6b49_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"313\" data-rawheight=\"532\" class=\"content_image\" width=\"313\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;313&#39; height=&#39;532&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"313\" data-rawheight=\"532\" class=\"content_image lazy\" width=\"313\" data-actualsrc=\"https://pic2.zhimg.com/v2-7cb4f9ab5f12182d92ff363dc9bf6b49_b.jpg\"/></figure><ul><ul><li>看指令有几个字节，就看有多少个 PC+1</li></ul></ul><h2><b>5、程序代码所在地址的计算，和跳转程序的偏移量的计算。</b></h2><ul><li><b>指令寻址：</b></li><ul><li>顺序寻址方式：PC + 1， 自动取下一条指令。</li><li>跳跃寻址方式：由该条转移指令的地址码字段得到新指令地址，然后将其置入PC中。</li></ul><li><b>数据寻址：</b></li><ul><li>指令的地址码字段，通常都不代表操作数的真实地址，把它称作形式地址，记为A。操作数的真实地址称为有效地址，记作EA，它是由寻址方式和形式地址共同来确定的。</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-535cb066c58a514d00c6d21e8daad11e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"369\" data-rawheight=\"70\" class=\"content_image\" width=\"369\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;369&#39; height=&#39;70&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"369\" data-rawheight=\"70\" class=\"content_image lazy\" width=\"369\" data-actualsrc=\"https://pic3.zhimg.com/v2-535cb066c58a514d00c6d21e8daad11e_b.jpg\"/></figure><ul><ul><li><b>立即寻址</b>：操作数在指令的地址码字段，即： DATA＝A </li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-af18e70d79d1a5fa0efee912ba9e5ac4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"295\" data-rawheight=\"166\" class=\"content_image\" width=\"295\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;295&#39; height=&#39;166&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"295\" data-rawheight=\"166\" class=\"content_image lazy\" width=\"295\" data-actualsrc=\"https://pic1.zhimg.com/v2-af18e70d79d1a5fa0efee912ba9e5ac4_b.jpg\"/></figure><ul><ul><li><b>直接寻址</b>：操作数位于存储器中，操作数所在的存储器单元的地址存放在指令的地址字段A中，即： DATA＝（EA）     EA=A</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b421483cc8a8660b9ad9c60180f90f12_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb\" width=\"484\" data-original=\"https://pic3.zhimg.com/v2-b421483cc8a8660b9ad9c60180f90f12_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;484&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"484\" data-original=\"https://pic3.zhimg.com/v2-b421483cc8a8660b9ad9c60180f90f12_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b421483cc8a8660b9ad9c60180f90f12_b.jpg\"/></figure><ul><ul><li><b>间接寻址</b>：操作数位于存储器中，操作数所在的存储器单元地址也存放在存储器中，该存储器地址则存放在指令的地址字段中，即： DATA＝（EA）     EA=（A）</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ce5fd3f23219225d0eaff3c5d8af6592_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"530\" data-original=\"https://pic3.zhimg.com/v2-ce5fd3f23219225d0eaff3c5d8af6592_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;530&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"530\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"530\" data-original=\"https://pic3.zhimg.com/v2-ce5fd3f23219225d0eaff3c5d8af6592_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ce5fd3f23219225d0eaff3c5d8af6592_b.jpg\"/></figure><ul><ul><li><b>寄存器寻址</b>：操作数位于寄存器中，操作数所在的寄存器编号存放在指令的地址字段A中，即： DATA＝（Ri）</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c1892544f6f326c71f99eba6db5d74f6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic3.zhimg.com/v2-c1892544f6f326c71f99eba6db5d74f6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic3.zhimg.com/v2-c1892544f6f326c71f99eba6db5d74f6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c1892544f6f326c71f99eba6db5d74f6_b.jpg\"/></figure><ul><ul><li><b>寄存器间接寻址</b>：操作数位于存储器中，操作数所在的存储器地址存放在寄存器中，而该寄存器编号存放在指令的地址字段A中，即： DATA＝（EA）     EA＝（Ri）</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-42f406b1c7fe4e24e977eecf360f95a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb\" width=\"590\" data-original=\"https://pic3.zhimg.com/v2-42f406b1c7fe4e24e977eecf360f95a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;590&#39; height=&#39;258&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"590\" data-rawheight=\"258\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"590\" data-original=\"https://pic3.zhimg.com/v2-42f406b1c7fe4e24e977eecf360f95a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-42f406b1c7fe4e24e977eecf360f95a2_b.jpg\"/></figure><ul><ul><li><b>变址寻址</b>：操作数位于存储器中，操作数所在的存储器地址EA由变址寄存器RI和指令的地址字段A指出： DATA＝（EA）     EA＝（RI）＋A</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f1ffa240b16ee8ae43924776fb68786d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-f1ffa240b16ee8ae43924776fb68786d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;726&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-f1ffa240b16ee8ae43924776fb68786d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f1ffa240b16ee8ae43924776fb68786d_b.jpg\"/></figure><ul><ul><li><b>基址寻址</b>：操作数位于存储器中，操作数所在的存储器地址EA由基址寄存器Rb和指令的地址字段A指出： DATA＝（EA）     EA＝（Rb）＋A</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7b69970b9d56c93b6e3c0892a407f8e7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"711\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"711\" data-original=\"https://pic4.zhimg.com/v2-7b69970b9d56c93b6e3c0892a407f8e7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;711&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"711\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"711\" data-original=\"https://pic4.zhimg.com/v2-7b69970b9d56c93b6e3c0892a407f8e7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7b69970b9d56c93b6e3c0892a407f8e7_b.jpg\"/></figure><ul><ul><li><b>基址变址寻址</b>：</li><li><b>相对寻址</b>：</li><li><b>堆栈寻址</b>：</li></ul></ul><h2><b>6、根据模型机的指令格式，写出某条指令编码的二进制代码。</b></h2><h2><b>7、结合指令的格式，根据内存中存放的内容，写出内存中的各条指令。</b></h2><h2><b>8、根据模型机的结构，写出微程序各个字段的值和控存的容量。</b></h2><ul><li>令微指令的字长为n，下址字段为 a 位，则控存容量为 2^a * n 位。          </li></ul><h2><b>9、控制器的组成和功能。</b></h2><ul><li>程序计数器 PC：①当指令顺序执行时，由PC+1产生下一条指令的地址 ；②当遇到转移指令时，转移地址 -&gt; PC作为下一条指令的地址。 </li><li>指令寄存器  IR：</li><li>地址寄存器 AR：</li><li>数据寄存器 DR：</li><li>指令译码器：</li><li>操作控制信号形成部件：①采用硬布线设计的操作控制信号形成部件；② 采用微程序设计的操作控制信号形成部件 。</li><li>时序信号产生器：</li></ul><h2><b>10、计算二级存储体系的命中率和访问时间，以及访问效率。</b></h2><ul><li>在一个程序执行期间，设Nc表示Cache完成存取的总次数，Nm表示主存完成存取的总次数，则命中率：h = Nc / ( Nc + Nm)</li><li>若tc表示Cache的访问时间，tm表示主存的访问时间，则Cache/主存系统的平均访问时间ta为：ta = htc + ( 1 - h ) * ( tm + tc ) 或 ta = htc + ( 1- h ) * tm</li><li>Cache/主存系统的访问效率e：e = tc / ta</li></ul><h2><b>11、组相联方式下各个字段的位数，以及某个地址位于那一组。</b></h2><ul><li>主存字块标记 t+r 位，组地址 c-r 位， 块内地址 b 位。</li><li>j = ( i mod 2^(c -r) ) * 2^r + k , 0 &lt;= k &lt;= 2^r - 1</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_b.jpg\"/></figure><h2><b>12、在主存采用多体交叉方式时，计算访问时间。</b></h2><ul><li>每个存储体的字长都等于数据总线宽度，存储体存取一个字的存储周期为T，总线传送周期为τ，存储器的交叉存储体数为M，为了实现流水线方式存取，应当满足 T=Mτ</li><li>T/τ称为交叉存取度，当交叉存储体数大于或等于T/τ时，可以保证启动某模块后经Mτ时间再次启动该模块时，它的上次存取操作已经完成。这样，连续读取M个字所需的时间为t=T+（M-1）τ</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-20deedc2786cb7262408ffe47c94d40c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"522\" data-original=\"https://pic1.zhimg.com/v2-20deedc2786cb7262408ffe47c94d40c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;522&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"522\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"522\" data-original=\"https://pic1.zhimg.com/v2-20deedc2786cb7262408ffe47c94d40c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-20deedc2786cb7262408ffe47c94d40c_b.jpg\"/></figure><h2><b>13、计算汉字的内码和字形码占用的字节数。</b></h2><ul><li>汉字内码是用于汉字信息的存储、交换、检索等操作的机内代码，一般采用两个字节表示。</li><li>机内码等于汉字国标码加上8080H。即两个字节的最高位均设为“1”。</li><li>英文字符的机内代码是七位的ASCII码，当用一个字节表示时，最高位为“0”。</li><li>汉字字形码是将汉字字形经过点阵数字化后形成的一串二进制数，用于汉字的显示和打印。根据汉字输出的要求不同，点阵有以下几种：</li><ul><li>简易型汉字：16×16， 32字节/汉字</li><li>普通型汉字：24×24， 72字节/汉字</li><li>提高型汉字：32×32，128字节/汉字。</li><li>即汉字的字形码的字节数等于字节的点阵大小的平方 / 8。</li></ul></ul><h2><b>14、深入了解MIPS处理器的结构图。</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f07ab1f86a06ac803f436da1bd4d2ee9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb\" width=\"779\" data-original=\"https://pic2.zhimg.com/v2-f07ab1f86a06ac803f436da1bd4d2ee9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;779&#39; height=&#39;476&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"779\" data-rawheight=\"476\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"779\" data-original=\"https://pic2.zhimg.com/v2-f07ab1f86a06ac803f436da1bd4d2ee9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f07ab1f86a06ac803f436da1bd4d2ee9_b.jpg\"/></figure><h2><b>15、看懂MIPS书写的条件循环控制程序。</b></h2><h2><b>16、将 MIPS I 型指令扩展到 IO  设备输入输出的情况。</b></h2><ul><li>扩展前：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6bf5b9098750743d48a38edd2e995d2f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"606\" class=\"origin_image zh-lightbox-thumb\" width=\"730\" data-original=\"https://pic4.zhimg.com/v2-6bf5b9098750743d48a38edd2e995d2f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;730&#39; height=&#39;606&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"730\" data-rawheight=\"606\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"730\" data-original=\"https://pic4.zhimg.com/v2-6bf5b9098750743d48a38edd2e995d2f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6bf5b9098750743d48a38edd2e995d2f_b.jpg\"/></figure><ul><li>扩展后：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-83e2103c01cf3cd7fd7277597c1a1572_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-83e2103c01cf3cd7fd7277597c1a1572_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;533&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"742\" data-rawheight=\"533\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic3.zhimg.com/v2-83e2103c01cf3cd7fd7277597c1a1572_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-83e2103c01cf3cd7fd7277597c1a1572_b.jpg\"/></figure><h2><b> 17、操作码的分配原则。</b></h2><ul><li>操作码的扩展</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f01ce94f2cc3429add7c39fe126d0a5d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"35\" class=\"content_image\" width=\"297\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;297&#39; height=&#39;35&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"35\" class=\"content_image lazy\" width=\"297\" data-actualsrc=\"https://pic2.zhimg.com/v2-f01ce94f2cc3429add7c39fe126d0a5d_b.jpg\"/></figure><ul><ul><li>4位操作码,15条三地址指令</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-906f307adb0784595260bbb164b7fffa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"106\" class=\"content_image\" width=\"297\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;297&#39; height=&#39;106&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"106\" class=\"content_image lazy\" width=\"297\" data-actualsrc=\"https://pic3.zhimg.com/v2-906f307adb0784595260bbb164b7fffa_b.jpg\"/></figure><ul><ul><li>8位操作码,15条二地址指令 </li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e4b1b5c87e8ff74a2023ce37ceb38c72_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"92\" class=\"content_image\" width=\"297\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;297&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"92\" class=\"content_image lazy\" width=\"297\" data-actualsrc=\"https://pic3.zhimg.com/v2-e4b1b5c87e8ff74a2023ce37ceb38c72_b.jpg\"/></figure><ul><ul><li>12位操作码,15条一地址指令</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3c7892553df12c124b5917811e0d3e66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"92\" class=\"content_image\" width=\"297\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;297&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"297\" data-rawheight=\"92\" class=\"content_image lazy\" width=\"297\" data-actualsrc=\"https://pic3.zhimg.com/v2-3c7892553df12c124b5917811e0d3e66_b.jpg\"/></figure><ul><ul><li>16位操作码</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b06ede6c32a59fe0ee38a967450d8a4c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"298\" data-rawheight=\"88\" class=\"content_image\" width=\"298\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;298&#39; height=&#39;88&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"298\" data-rawheight=\"88\" class=\"content_image lazy\" width=\"298\" data-actualsrc=\"https://pic1.zhimg.com/v2-b06ede6c32a59fe0ee38a967450d8a4c_b.jpg\"/></figure><h2><b>18、集中式刷新刷新一遍的时间的计算。</b></h2><ul><li>例：64K×1位DRAM芯片中，存储电路由4个独立的128×128的存储矩阵组成。设存储器存储周期为500ns，单元刷新间隔是2ms。</li><li>则在2ms单元刷新间隔时间内，集中对128行刷新一遍，所需时间128×500ns=64μs，其余时间则用于访问操作。</li><li>在内部刷新时间（64μs）内，不允许访存，这段时间被称为死时间。</li><li>集中式刷新缺点：访问访存“死区”的时间比较长，降低了计算机系统的效率。</li></ul><h2><b>19、存储器的地址分配和连接。</b></h2><ul><li><b>位扩展</b></li><ul><li>扩展前容量为：1K × 4  位</li><li>扩展后容量为：1K × 8 位</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6ea7964563b55ad58ba1a9ce0cbc7db3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-6ea7964563b55ad58ba1a9ce0cbc7db3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;552&#39; height=&#39;437&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"552\" data-rawheight=\"437\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"552\" data-original=\"https://pic4.zhimg.com/v2-6ea7964563b55ad58ba1a9ce0cbc7db3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6ea7964563b55ad58ba1a9ce0cbc7db3_b.jpg\"/></figure><ul><li><b>字扩展</b></li><ul><li>扩展前容量为：1K×８位</li><li>扩展后容量为：2K × 8 位</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7e90e911e0a4367bf72d015ad7489dfe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"531\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb\" width=\"531\" data-original=\"https://pic3.zhimg.com/v2-7e90e911e0a4367bf72d015ad7489dfe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;531&#39; height=&#39;409&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"531\" data-rawheight=\"409\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"531\" data-original=\"https://pic3.zhimg.com/v2-7e90e911e0a4367bf72d015ad7489dfe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7e90e911e0a4367bf72d015ad7489dfe_b.jpg\"/></figure><hr/><h2><b>二、知识点总结</b></h2><h2><b>1、CISC和RISC的优缺点：</b></h2><ul><li>CISC：</li><ul><li>优点：指令越多功能越强，强调代码效率，容易和高级语言接轨。可以对存储器直接操作，实现从存储器到存储器的数据转移，可加入DSP指令。</li><li>缺点：指令太多不易记忆；CPU内部结构复杂造成频率不高；指令执行速度慢。</li></ul><li>RISC：</li><ul><li>优点：指令少容易记忆，尽量将操作码和操作数用1个16位数或32位数表示，指令整齐。CPU时钟频率可以做得很高，指令执行速度快。</li><li>缺点：同样功能的程序，产生的代码量比较大；不能对存储器直接访问，不能实现存储器到存储器的数据转移。</li></ul></ul><h2><b>2、存储器分类：</b></h2><ul><li><b>按存储介质分：</b></li><ul><li>半导体存储器</li><li>磁存储器</li><li>纸带存储器</li><li>光存储器</li></ul><li><b>按存取方式分</b>：</li><ul><li>随机读写存储器（RAM）：断电不保存。-&gt; 主存储器</li><li>只读存储器（ROM）：断电保存。有掩膜式只读存储器（MROM）、可编程只读存储器（PROM）、可擦除可编程只读存储器（EPROM）、电可擦除可编程只读存储器（EEPROM）、闪存（Flash）。</li><li>相联存储器（CAM）：在这种存储器中访问一个字是通过它的部分内容而不是地址进行检索的。</li><li>顺序存储器（SAS）：存取时间和存储单元的物理位置有关。 -&gt; 磁带</li><li>直接存取存储器（DAS）：先根据部分地址信息找到大致范围，再在此范围内顺序检索，找到目标。 -&gt; 磁盘、磁鼓存储器等大容量的辅助存储器。</li></ul><li><b>按信息的可保存性分：</b></li><ul><li>永久记忆存储器 -&gt; 磁盘、光盘、U盘</li><li>非永久记忆存储器 -&gt; RAM</li></ul><li><b>按在计算机系统中的作用分：</b></li><ul><li>寄存器</li><li>主存储器</li><li>辅助存储器</li><li>高速缓冲存储器（Cache）</li></ul></ul><h2><b>3、微程序控制器和硬布线控制的划分依据：</b></h2><p>根据微操作控制信号的产生方式（也可以说是根据操作控制信号形成部件的电路结构）区分的，微程序控制器中，微操作控制信号从控制存储器读出，而硬布线控制器由组合逻辑电路即时产生。</p><h2><b>4、微程序控制器和硬布线控制的优缺点：</b></h2><p>微程序控制器中，指令的修改和扩充比较容易；</p><p>硬布线控制器的执行速度比较快。</p><h2><b>5、主存与Cache的地址映射方式：</b></h2><ul><li><b>直接映射</b>：</li><ul><li>高位标记 t 位，字块位置 c 位，块内地址 b 位。</li><li>Cache中的行号 j 和主存的块号 i 间的函数关系： j = i mod 2^c</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ee2f4bbc8142bc173c65b2a35986abef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"494\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic4.zhimg.com/v2-ee2f4bbc8142bc173c65b2a35986abef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;494&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"494\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic4.zhimg.com/v2-ee2f4bbc8142bc173c65b2a35986abef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ee2f4bbc8142bc173c65b2a35986abef_b.jpg\"/></figure><ul><li><b>全相联映射</b>：</li><ul><li>高位位置 m 位，块内地址 b 位。</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f42d65c9a85e06509812ad052e5e1b1b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb\" width=\"817\" data-original=\"https://pic4.zhimg.com/v2-f42d65c9a85e06509812ad052e5e1b1b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;817&#39; height=&#39;537&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"537\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"817\" data-original=\"https://pic4.zhimg.com/v2-f42d65c9a85e06509812ad052e5e1b1b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f42d65c9a85e06509812ad052e5e1b1b_b.jpg\"/></figure><ul><li><b>组相联映射</b>：</li><ul><li>主存字块标记 t+r 位，组地址 c-r 位， 块内地址 b 位。</li><li>j = ( i mod 2^(c -r) ) * 2^r + k , 0 &lt;= k &lt;= 2^r - 1</li></ul></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;802&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"802\" data-rawheight=\"553\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"802\" data-original=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dbadb5c5592b0ef725d7054b630d884d_b.jpg\"/></figure><h2><b>6、单周期MIPS的R、I、J三种类型指令的格式、意义和执行过程：</b></h2><ul><li><b>指令格式</b>：</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f30b3a955d2617bb2b04104fdc2596ef_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb\" width=\"852\" data-original=\"https://pic4.zhimg.com/v2-f30b3a955d2617bb2b04104fdc2596ef_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;852&#39; height=&#39;395&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"395\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"852\" data-original=\"https://pic4.zhimg.com/v2-f30b3a955d2617bb2b04104fdc2596ef_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f30b3a955d2617bb2b04104fdc2596ef_b.jpg\"/></figure><ul><li><b>在R型指令中：</b></li><ul><li>OP：操作码</li><li>rs：第一个源操作数寄存器</li><li>rt：第二个源操作数寄存器（单目源数据）</li><li>rd：结果寄存器</li><li>shamt：移位操作时的位移量，非移位操作时为0</li><li>func：功能码</li><li>例：R[rd] ← R[rs] + R[rt]</li></ul><li><b>在I型指令（立即数型指令）中：</b></li><ul><li>rs：源操作数寄存器</li><li>rt：结果寄存器</li><li>例：R[rt] ← R[rs]</li></ul><li><b>在J型指令（无条件转移指令）中：</b></li><ul><li>address：直接地址</li></ul></ul><hr/><h2><b>三、重点题型</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f957deefda1dc3ee60bb4beecc57fbf5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1952\" data-rawheight=\"2880\" class=\"origin_image zh-lightbox-thumb\" width=\"1952\" data-original=\"https://pic2.zhimg.com/v2-f957deefda1dc3ee60bb4beecc57fbf5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1952&#39; height=&#39;2880&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1952\" data-rawheight=\"2880\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1952\" data-original=\"https://pic2.zhimg.com/v2-f957deefda1dc3ee60bb4beecc57fbf5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f957deefda1dc3ee60bb4beecc57fbf5_b.jpg\"/></figure><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "计算机组成原理", 
                    "tagLink": "https://api.zhihu.com/topics/19782988"
                }
            ], 
            "comments": [
                {
                    "userName": "鹏鹏", 
                    "userLink": "https://www.zhihu.com/people/b17a4f62204c15a2082b174ee3dca19f", 
                    "content": "<p>这是啥么鬼 这东西弄出来大概就只是为了做人的分层筛选吧,, 并不起到教学作用...</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37829101", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 5, 
            "title": "CloudSimExample1 示例分析", 
            "content": "<p>CloudExample1这个程序实现的创建含有一台主机的数据中心，并在上面运行了一个云任务。</p><h2><b>CloudSim 体系结构</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-88ab7d6d08bc038aeedebb8b6152dfb7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb\" width=\"840\" data-original=\"https://pic4.zhimg.com/v2-88ab7d6d08bc038aeedebb8b6152dfb7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;840&#39; height=&#39;535&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"535\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"840\" data-original=\"https://pic4.zhimg.com/v2-88ab7d6d08bc038aeedebb8b6152dfb7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-88ab7d6d08bc038aeedebb8b6152dfb7_b.jpg\"/></figure><p>上图是 CloudSim 的体系结构，在进行代码的分析之前先对其体系结构进行预览有助于我们对代码的更好理解。</p><h2><b>CloudSimExample1 示例代码分析</b></h2><p>接下来，我将在本文中对该程序进行分析，写出了它的大致的仿真过程，并对其代码进行了相应的注释，见下。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>其大致仿真步骤如下：</p><ul><li>（1）初始化CloudSim包</li><li>（2）创建数据中心</li><ul><li>（a）创建主机列表</li><li>（b）创建PE列表</li><li>（c）创建PE并将其添加到上一步创建的PE列表中，可对其ID和MIPS进行设置</li><li>（d）创建主机，并将其添加到主机列表中，主机的配置参数有ID、内存、带宽、存储、PE及虚拟机分配策略（时间或空间共享）</li><li>（e）创建数据中心特征对象，用来存储数据中心的属性，包含体系结构、操作系统、机器列表、分配策略（时间、空间共享）、时区以及各项费用（内存、外存、带宽和处理器资源的费用）</li><li>（f）最后，创建一个数据中心对象，它的主要参数有名称、特征对象、虚拟机分配策略、用于数据仿真的存储列表以及调度间隔</li></ul><li>（3）创建数据中心代理：数据中心代理负责在云计算中根据用户的QoS 要求协调用户及服务供应商和部署服务任务</li><li>（4）创建虚拟机：对虚拟机的参数进行设置，主要包括ID、用户ID、MIPS、CPU数量、内存、带宽、外存、虚拟机监控器、调度策略，并提交给任务代理</li><li>（5）创建云任务：创建指定参数的云任务，设定任务的用户ID，并提交给任务代理。在这一步可以设置需要创建的云任务数量以及任务长度等信息</li><li>（6）在这一步调用自定义的任务调度策略，分配任务到虚拟机</li><li>（7）启动仿真</li><li>（8）在仿真结束后统计结果</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（1）初始化CloudSim包</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">num_user</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// number of cloud users\n</span><span class=\"c1\"></span><span class=\"n\">Calendar</span> <span class=\"n\">calendar</span> <span class=\"o\">=</span> <span class=\"n\">Calendar</span><span class=\"o\">.</span><span class=\"na\">getInstance</span><span class=\"o\">();</span> <span class=\"c1\">// Calendar whose fields have been initialized with the current date and time.\n</span><span class=\"c1\"></span><span class=\"kt\">boolean</span> <span class=\"n\">trace_flag</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span> <span class=\"c1\">// trace events\n</span><span class=\"c1\"></span>\n<span class=\"n\">CloudSim</span><span class=\"o\">.</span><span class=\"na\">init</span><span class=\"o\">(</span><span class=\"n\">num_user</span><span class=\"o\">,</span> <span class=\"n\">calendar</span><span class=\"o\">,</span> <span class=\"n\">trace_flag</span><span class=\"o\">);</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（2）创建数据中心</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 此处通过调用 createDatacenter 子方法来实现。\n</span><span class=\"c1\"></span><span class=\"n\">Datacenter</span> <span class=\"n\">datacenter0</span> <span class=\"o\">=</span> <span class=\"n\">createDatacenter</span><span class=\"o\">(</span><span class=\"s\">&#34;Datacenter_0&#34;</span><span class=\"o\">);</span>\n\n<span class=\"c1\">// createDatacenter 子方法：\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">Datacenter</span> <span class=\"nf\">createDatacenter</span><span class=\"o\">(</span><span class=\"n\">String</span> <span class=\"n\">name</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// （a）创建主机列表\n</span><span class=\"c1\"></span>    <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Host</span><span class=\"o\">&gt;</span> <span class=\"n\">hostList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Host</span><span class=\"o\">&gt;();</span>\n\n    <span class=\"c1\">// （b）创建PE列表，只有一个 CPU 核心\n</span><span class=\"c1\"></span>    <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Pe</span><span class=\"o\">&gt;</span> <span class=\"n\">peList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Pe</span><span class=\"o\">&gt;();</span>\n\n    <span class=\"c1\">// （c）创建PE并将其添加到上一步创建的PE列表中，可对其ID和MIPS进行设置，ID 为 0， MIPS 为 1000。\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">mips</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n    <span class=\"n\">peList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Pe</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">PeProvisionerSimple</span><span class=\"o\">(</span><span class=\"n\">mips</span><span class=\"o\">)));</span> <span class=\"c1\">// need to store Pe id and MIPS Rating\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">//（d）创建主机，并将其添加到主机列表中，主机的配置参数有ID、内存、带宽、存储、PE及虚拟机分配策略（时间或空间共享）\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 此处设置的主机ID为0，内存为2048MB，存储容量为1000000，带宽为10000\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">hostId</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">ram</span> <span class=\"o\">=</span> <span class=\"n\">2048</span><span class=\"o\">;</span> <span class=\"c1\">// host memory (MB)\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"n\">storage</span> <span class=\"o\">=</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"c1\">// host storage\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"n\">10000</span><span class=\"o\">;</span>\n\n    <span class=\"n\">hostList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span>\n        <span class=\"k\">new</span> <span class=\"n\">Host</span><span class=\"o\">(</span>\n            <span class=\"n\">hostId</span><span class=\"o\">,</span>\n            <span class=\"k\">new</span> <span class=\"n\">RamProvisionerSimple</span><span class=\"o\">(</span><span class=\"n\">ram</span><span class=\"o\">),</span>\n            <span class=\"k\">new</span> <span class=\"n\">BwProvisionerSimple</span><span class=\"o\">(</span><span class=\"n\">bw</span><span class=\"o\">),</span>\n            <span class=\"n\">storage</span><span class=\"o\">,</span>\n            <span class=\"n\">peList</span><span class=\"o\">,</span>\n            <span class=\"k\">new</span> <span class=\"n\">VmSchedulerTimeShared</span><span class=\"o\">(</span><span class=\"n\">peList</span><span class=\"o\">)</span>\n        <span class=\"o\">)</span>\n    <span class=\"o\">);</span> <span class=\"c1\">// This is our machine\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">//（e）创建数据中心特征对象，用来存储数据中心的属性，包含体系结构、操作系统、机器列表、分配策略（时间、空间共享）、时区以及各项费用（内存、外存、带宽和处理器资源的费用）\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 此处它的系统架构为x86，操作系统为linux，名称为Xen，时区为10.0\n</span><span class=\"c1\"></span>    <span class=\"n\">String</span> <span class=\"n\">arch</span> <span class=\"o\">=</span> <span class=\"s\">&#34;x86&#34;</span><span class=\"o\">;</span> <span class=\"c1\">// system architecture\n</span><span class=\"c1\"></span>    <span class=\"n\">String</span> <span class=\"n\">os</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Linux&#34;</span><span class=\"o\">;</span> <span class=\"c1\">// operating system\n</span><span class=\"c1\"></span>    <span class=\"n\">String</span> <span class=\"n\">vmm</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Xen&#34;</span><span class=\"o\">;</span>\n    <span class=\"kt\">double</span> <span class=\"n\">time_zone</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">.</span><span class=\"na\">0</span><span class=\"o\">;</span> <span class=\"c1\">// time zone this resource located\n</span><span class=\"c1\"></span>    <span class=\"kt\">double</span> <span class=\"n\">cost</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">.</span><span class=\"na\">0</span><span class=\"o\">;</span> <span class=\"c1\">// the cost of using processing in this resource\n</span><span class=\"c1\"></span>    <span class=\"kt\">double</span> <span class=\"n\">costPerMem</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">05</span><span class=\"o\">;</span> <span class=\"c1\">// the cost of using memory in this resource\n</span><span class=\"c1\"></span>    <span class=\"kt\">double</span> <span class=\"n\">costPerStorage</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">001</span><span class=\"o\">;</span> <span class=\"c1\">// the cost of using storage in this\n</span><span class=\"c1\"></span>                                    <span class=\"c1\">// resource\n</span><span class=\"c1\"></span>    <span class=\"kt\">double</span> <span class=\"n\">costPerBw</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">.</span><span class=\"na\">0</span><span class=\"o\">;</span> <span class=\"c1\">// the cost of using bw in this resource\n</span><span class=\"c1\"></span>    <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">Storage</span><span class=\"o\">&gt;</span> <span class=\"n\">storageList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">LinkedList</span><span class=\"o\">&lt;</span><span class=\"n\">Storage</span><span class=\"o\">&gt;();</span> <span class=\"c1\">// we are not adding SAN\n</span><span class=\"c1\"></span>                                                <span class=\"c1\">// devices by now\n</span><span class=\"c1\"></span>\n    <span class=\"n\">DatacenterCharacteristics</span> <span class=\"n\">characteristics</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">DatacenterCharacteristics</span><span class=\"o\">(</span>\n            <span class=\"n\">arch</span><span class=\"o\">,</span> <span class=\"n\">os</span><span class=\"o\">,</span> <span class=\"n\">vmm</span><span class=\"o\">,</span> <span class=\"n\">hostList</span><span class=\"o\">,</span> <span class=\"n\">time_zone</span><span class=\"o\">,</span> <span class=\"n\">cost</span><span class=\"o\">,</span> <span class=\"n\">costPerMem</span><span class=\"o\">,</span>\n            <span class=\"n\">costPerStorage</span><span class=\"o\">,</span> <span class=\"n\">costPerBw</span><span class=\"o\">);</span>\n\n    <span class=\"c1\">//（f）最后，创建一个数据中心对象，它的主要参数有名称、特征对象、虚拟机分配策略、用于数据仿真的存储列表以及调度间隔\n</span><span class=\"c1\"></span>    <span class=\"c1\">//  此处名称为 Xen\n</span><span class=\"c1\"></span>    <span class=\"n\">Datacenter</span> <span class=\"n\">datacenter</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"n\">datacenter</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Datacenter</span><span class=\"o\">(</span><span class=\"n\">name</span><span class=\"o\">,</span> <span class=\"n\">characteristics</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">VmAllocationPolicySimple</span><span class=\"o\">(</span><span class=\"n\">hostList</span><span class=\"o\">),</span> <span class=\"n\">storageList</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">datacenter</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（3）创建数据中心代理</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">DatacenterBroker</span> <span class=\"n\">broker</span> <span class=\"o\">=</span> <span class=\"n\">createBroker</span><span class=\"o\">();</span>\n<span class=\"kt\">int</span> <span class=\"n\">brokerId</span> <span class=\"o\">=</span> <span class=\"n\">broker</span><span class=\"o\">.</span><span class=\"na\">getId</span><span class=\"o\">();</span></code></pre></div><p>数据中心代理负责在云计算中根据用户的QoS 要求协调用户及服务供应商和部署服务任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（4）创建虚拟机</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 创建虚拟机列表\n</span><span class=\"c1\"></span><span class=\"n\">vmlist</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Vm</span><span class=\"o\">&gt;();</span>\n\n<span class=\"c1\">// 对虚拟机的参数进行设置，主要包括ID、用户ID、MIPS、CPU数量、内存、带宽、外存、虚拟机监控器、调度策略。\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">vmid</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">mips</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n<span class=\"kt\">long</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">10000</span><span class=\"o\">;</span> <span class=\"c1\">// image size (MB)\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">ram</span> <span class=\"o\">=</span> <span class=\"n\">512</span><span class=\"o\">;</span> <span class=\"c1\">// vm memory (MB)\n</span><span class=\"c1\"></span><span class=\"kt\">long</span> <span class=\"n\">bw</span> <span class=\"o\">=</span> <span class=\"n\">1000</span><span class=\"o\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">pesNumber</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"c1\">// number of cpus\n</span><span class=\"c1\"></span><span class=\"n\">String</span> <span class=\"n\">vmm</span> <span class=\"o\">=</span> <span class=\"s\">&#34;Xen&#34;</span><span class=\"o\">;</span> <span class=\"c1\">// VMM name\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 创建虚拟机\n</span><span class=\"c1\"></span><span class=\"n\">Vm</span> <span class=\"n\">vm</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Vm</span><span class=\"o\">(</span><span class=\"n\">vmid</span><span class=\"o\">,</span> <span class=\"n\">brokerId</span><span class=\"o\">,</span> <span class=\"n\">mips</span><span class=\"o\">,</span> <span class=\"n\">pesNumber</span><span class=\"o\">,</span> <span class=\"n\">ram</span><span class=\"o\">,</span> <span class=\"n\">bw</span><span class=\"o\">,</span> <span class=\"n\">size</span><span class=\"o\">,</span> <span class=\"n\">vmm</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">CloudletSchedulerTimeShared</span><span class=\"o\">());</span>\n\n<span class=\"c1\">// 将创建的虚拟机挂载在虚拟机列表中\n</span><span class=\"c1\"></span><span class=\"n\">vmlist</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">vm</span><span class=\"o\">);</span>\n\n<span class=\"c1\">// 将虚拟机提交给任务代理\n</span><span class=\"c1\"></span><span class=\"n\">broker</span><span class=\"o\">.</span><span class=\"na\">submitVmList</span><span class=\"o\">(</span><span class=\"n\">vmlist</span><span class=\"o\">);</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（5）创建云任务</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 创建一个云计算列表\n</span><span class=\"c1\"></span><span class=\"n\">cloudletList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;</span><span class=\"n\">Cloudlet</span><span class=\"o\">&gt;();</span>\n\n<span class=\"c1\">// 创建指定参数的云任务，设定任务的用户ID，云任务数量以及任务长度等信息。\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">id</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"kt\">long</span> <span class=\"n\">length</span> <span class=\"o\">=</span> <span class=\"n\">400000</span><span class=\"o\">;</span>\n<span class=\"kt\">long</span> <span class=\"n\">fileSize</span> <span class=\"o\">=</span> <span class=\"n\">300</span><span class=\"o\">;</span>\n<span class=\"kt\">long</span> <span class=\"n\">outputSize</span> <span class=\"o\">=</span> <span class=\"n\">300</span><span class=\"o\">;</span>\n<span class=\"n\">UtilizationModel</span> <span class=\"n\">utilizationModel</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">UtilizationModelFull</span><span class=\"o\">();</span>\n\n<span class=\"n\">Cloudlet</span> <span class=\"n\">cloudlet</span> <span class=\"o\">=</span> \n                             <span class=\"k\">new</span> <span class=\"n\">Cloudlet</span><span class=\"o\">(</span><span class=\"n\">id</span><span class=\"o\">,</span> <span class=\"n\">length</span><span class=\"o\">,</span> <span class=\"n\">pesNumber</span><span class=\"o\">,</span> <span class=\"n\">fileSize</span><span class=\"o\">,</span> \n                                     <span class=\"n\">outputSize</span><span class=\"o\">,</span> <span class=\"n\">utilizationModel</span><span class=\"o\">,</span> <span class=\"n\">utilizationModel</span><span class=\"o\">,</span> \n                                     <span class=\"n\">utilizationModel</span><span class=\"o\">);</span>\n<span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">setUserId</span><span class=\"o\">(</span><span class=\"n\">brokerId</span><span class=\"o\">);</span>\n<span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">setVmId</span><span class=\"o\">(</span><span class=\"n\">vmid</span><span class=\"o\">);</span>\n\n<span class=\"c1\">// add the cloudlet to the list\n</span><span class=\"c1\"></span><span class=\"n\">cloudletList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">cloudlet</span><span class=\"o\">);</span>\n\n<span class=\"c1\">// 将创建好的云任务提交给任务代理\n</span><span class=\"c1\"></span><span class=\"n\">broker</span><span class=\"o\">.</span><span class=\"na\">submitCloudletList</span><span class=\"o\">(</span><span class=\"n\">cloudletList</span><span class=\"o\">);</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（6）启动仿真</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">CloudSim</span><span class=\"o\">.</span><span class=\"na\">startSimulation</span><span class=\"o\">();</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（7）在仿真结束后统计结果</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">CloudSim</span><span class=\"o\">.</span><span class=\"na\">stopSimulation</span><span class=\"o\">();</span>\n\n<span class=\"c1\">//仿真结束后打印统计结果 \n</span><span class=\"c1\"></span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Cloudlet</span><span class=\"o\">&gt;</span> <span class=\"n\">newList</span> <span class=\"o\">=</span> <span class=\"n\">broker</span><span class=\"o\">.</span><span class=\"na\">getCloudletReceivedList</span><span class=\"o\">();</span>\n<span class=\"n\">printCloudletList</span><span class=\"o\">(</span><span class=\"n\">newList</span><span class=\"o\">);</span> <span class=\"c1\">// 此处调用了printCloudletList()子方法\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// printCloudletList() 子方法\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">printCloudletList</span><span class=\"o\">(</span><span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Cloudlet</span><span class=\"o\">&gt;</span> <span class=\"n\">list</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">size</span> <span class=\"o\">=</span> <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">size</span><span class=\"o\">();</span>\n    <span class=\"n\">Cloudlet</span> <span class=\"n\">cloudlet</span><span class=\"o\">;</span>\n\n    <span class=\"n\">String</span> <span class=\"n\">indent</span> <span class=\"o\">=</span> <span class=\"s\">&#34;    &#34;</span><span class=\"o\">;</span>\n    <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">printLine</span><span class=\"o\">();</span>\n    <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">printLine</span><span class=\"o\">(</span><span class=\"s\">&#34;========== OUTPUT ==========&#34;</span><span class=\"o\">);</span>\n    <span class=\"c1\">// 打印出云应用服务的ID，虚拟机的ID，运行的时间以及运行开始和结束的时刻。\n</span><span class=\"c1\"></span>    <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">printLine</span><span class=\"o\">(</span><span class=\"s\">&#34;Cloudlet ID&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"s\">&#34;STATUS&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span>\n            <span class=\"o\">+</span> <span class=\"s\">&#34;Data center ID&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"s\">&#34;VM ID&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"s\">&#34;Time&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span>\n            <span class=\"o\">+</span> <span class=\"s\">&#34;Start Time&#34;</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"s\">&#34;Finish Time&#34;</span><span class=\"o\">);</span>\n\n    <span class=\"n\">DecimalFormat</span> <span class=\"n\">dft</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">DecimalFormat</span><span class=\"o\">(</span><span class=\"s\">&#34;###.##&#34;</span><span class=\"o\">);</span>\n    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">size</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n        <span class=\"n\">cloudlet</span> <span class=\"o\">=</span> <span class=\"n\">list</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">);</span>\n        <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getCloudletId</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span><span class=\"o\">);</span>\n\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getCloudletStatus</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">Cloudlet</span><span class=\"o\">.</span><span class=\"na\">SUCCESS</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">print</span><span class=\"o\">(</span><span class=\"s\">&#34;SUCCESS&#34;</span><span class=\"o\">);</span>\n\n            <span class=\"n\">Log</span><span class=\"o\">.</span><span class=\"na\">printLine</span><span class=\"o\">(</span><span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getResourceId</span><span class=\"o\">()</span>\n                    <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getVmId</span><span class=\"o\">()</span>\n                    <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span>\n                    <span class=\"o\">+</span> <span class=\"n\">dft</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getActualCPUTime</span><span class=\"o\">())</span> <span class=\"o\">+</span> <span class=\"n\">indent</span>\n                    <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">dft</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getExecStartTime</span><span class=\"o\">())</span>\n                    <span class=\"o\">+</span> <span class=\"n\">indent</span> <span class=\"o\">+</span> <span class=\"n\">indent</span>\n                    <span class=\"o\">+</span> <span class=\"n\">dft</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"n\">cloudlet</span><span class=\"o\">.</span><span class=\"na\">getFinishTime</span><span class=\"o\">()));</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>打印结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7dd8eb4a8d2133087133a34ecf9ce2c5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"697\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb\" width=\"697\" data-original=\"https://pic2.zhimg.com/v2-7dd8eb4a8d2133087133a34ecf9ce2c5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;697&#39; height=&#39;475&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"697\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"697\" data-original=\"https://pic2.zhimg.com/v2-7dd8eb4a8d2133087133a34ecf9ce2c5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7dd8eb4a8d2133087133a34ecf9ce2c5_b.jpg\"/></figure><p>在这个程序中，我们没有运行什么特定的云任务，主要是完成了数据中心的创建。所以直接打印出结果，我们的云任务的ID 为2，使</p><p>用的数据中心的ID为2，虚拟机的ID为0，同我们自己设置的一样。</p><h2><b>CloudSim云模拟器的类设计图</b></h2><p>对在本例程中数据中心的创建过程进行梳理，我们可以得到CloudSim云模拟器的类设计图如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-885c18cddf807b98aad21842aedb058a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"472\" class=\"origin_image zh-lightbox-thumb\" width=\"912\" data-original=\"https://pic3.zhimg.com/v2-885c18cddf807b98aad21842aedb058a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;912&#39; height=&#39;472&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"472\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"912\" data-original=\"https://pic3.zhimg.com/v2-885c18cddf807b98aad21842aedb058a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-885c18cddf807b98aad21842aedb058a_b.jpg\"/></figure><p><b>1）BwProvisioner</b></p><p>用于模拟虚拟机的带宽分配策略。可以通过扩展这个类反映其应用需求的变化，实现自己的策略（基于优先级或服务质量）</p><p><b>2）CloudCoordinator</b></p><p>整合了云数据中心，负责周期性地监控数据中心资源的内部状态和执行动态负载均衡的决策</p><p><b>3）Cloudlet</b></p><p>模拟了云应用服务（如内容分发、社区网络和业务工作流等）。每一个应用服务都会拥有一个预分配的指令长度和其生命周期内所需的数据传输开销</p><p><b>4）CloudletScheduler</b></p><p>扩展实现了多种策略，用于决定虚拟机内的应用服务如何共享处理器能力。支持两种调度策略：空间共享（CloudletSchedulerSpaceShared）和时间共享（CloudletSchedulerTimeShared）策略</p><p><b>5）Datacenter</b></p><p>模拟了云提供商提供的核心基础设施级服务（硬件）。它封装了一系列的主机，且这些主机都支持同构和异构的资源（内存、内核、容量和存储）配置<br/><b>6）DatacenterBroker</b></p><p>模拟了一个代理，负责根据服务质量需求协调SaaS提供商和云提供商。该代理代表SaaS提供商，它通过查询云信息服务（Cloud Information Service）找到合适的云服务提供者，并根据服务质量的需求在线协商资源和服务的分配策略 </p><p><b>7）DatacenterCharacteristics</b></p><p>包含了数据中心资源的配置信息</p><p><b>8）Host</b></p><p>模拟如计算机、存储服务器等物理资源。它封装了一些重要信息，如内存/存储器的容量、处理器内核列表及类型（多核机器）、虚</p><p>拟机之间共享处理能力的分配策略、为虚拟机分配内存和带宽的策略等</p><p><b>9）NetworkTopology</b></p><p>包含模拟网络行为（延时）的信息。它里面保存了网络拓扑信息，该信息由BRITE拓扑生成器生成</p><p><b>10）RamProvisioner</b></p><p>代表为虚拟机分配主存的策略</p><p><b>11）SanStorage</b></p><p>模拟了云数据中心的存储区域网，主要用于存储大量数据，类似于Amazon S3、Azure blob storage等</p><p><b>12）Sensor</b></p><p>该接口的实现必须通过实例化一个能够被云协调器使用的传感器组件，用于监控特定的性能参数（能量消耗、资源利用）。该接口定义了如下方法：</p><p>（1）为性能参数设置最小值和最大值。</p><p>（2）周期性地更新测量值。</p><p>（3）该类能够用于模拟由主流云提供商提供的真实服务</p><p><b>13）Vm</b></p><p>模拟由主机组件托管和管理的虚拟机</p><p><b>14）VmAllocationPolicy</b></p><p>代表虚拟机监视器使用的调度策略，该策略用于将虚拟机分配给主机</p><p><b>15）VmSheduler</b></p><p>由一个主机组件实现，模拟为虚拟机分配处理核所用的策略（空间共享和时间共享）</p><h2><b>CloudSim技术实现</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-537f4b2668bae42c98e00933a1436f76_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb\" width=\"912\" data-original=\"https://pic3.zhimg.com/v2-537f4b2668bae42c98e00933a1436f76_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;912&#39; height=&#39;368&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"912\" data-rawheight=\"368\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"912\" data-original=\"https://pic3.zhimg.com/v2-537f4b2668bae42c98e00933a1436f76_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-537f4b2668bae42c98e00933a1436f76_b.jpg\"/></figure><hr/><p>推荐阅读：</p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/37782648\" class=\"internal\">Ubuntu下CloudSim4.0云计算仿真平台</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/33fd468e5022aaea998f0f9a.html%3Ffrom%3Dsearch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">【图文】云计算及其仿真环境CloudSim_百度文库</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/ec4c232db4daa58da0114a74.html%3Ffrom%3Dsearch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例1</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/594041fb0242a8956bece475\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例2</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/e0b5ce8fa0116c175f0e4874\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例3</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/3b78340c7cd184254b353574\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例4</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/25beef274b35eefdc8d33374\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例5</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/105a85ffc8d376eeaeaa3174\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例6</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/2881c5a8d1f34693daef3e74\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例7</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//wenku.baidu.com/view/b19c2d91daef5ef7ba0d3c74\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">cloudsim 学习笔记 实例8</a>   </li></ul><p></p>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37782648", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 8, 
            "title": "Ubuntu下CloudSim4.0云计算仿真平台", 
            "content": "<p>CloudSim是一个由Java语言编写的云计算仿真平台软件，提供给研究人员做仿真实验，由于本文主要介绍如何从0开始部署该平台软件，故此处不对CloudSim做详细介绍，如需对该平台进一步了解，请访问 <a href=\"https://link.zhihu.com/?target=http%3A//www.cloudbus.org/cloudsim/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CloudSim官网</a> 。</p><h2><b>实验环境</b></h2><ul><li>本机操作系统：Windows 10</li><li>虚拟机软件：VMware Workstation Pro 14</li><li>虚拟机系统：Ubuntu 16.04</li></ul><h2><b>准备工作</b></h2><ul><li>安装好虚拟机软件 VMware。</li><li>在虚拟机软件中将建立一个虚拟机，运行 Ubuntu 操作系统。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>由于CloudSim是基于Java进行编写的，所以JDK的环境配置是必不可少的。</p><h2><b>JDK 安装</b></h2><p>Java的安装非常简单，我们直接从 <a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/technetwork/java/javase/downloads/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Oracle 的官网</a> 随便选择一个 JDK 版本就行，我这里选择的 8u171，选择 Ubuntu 对应的 .tar.gz 后缀的版本下载即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-71461689d6e83345a7c4074e18672c02_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-71461689d6e83345a7c4074e18672c02_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;545&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-71461689d6e83345a7c4074e18672c02_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-71461689d6e83345a7c4074e18672c02_b.jpg\"/></figure><p>下载完成中，解压对相应的地址下。我这里打算把 JDK 安装到用户主目录下，所以就将 extract 后的结果移动到这个地址下面：</p><div class=\"highlight\"><pre><code class=\"language-text\">mv jdk1.8.0_171/ ~/java</code></pre></div><p>这样，我解压后的 JDK 地址就是 ~/java 了。</p><p>然后，我就要设置 JDK 的环境变量，在 /etc/profile 最后加上：</p><div class=\"highlight\"><pre><code class=\"language-text\">export JAVA_HOME=/home/fangn/java\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH</code></pre></div><p>使用 source /etc/profile 命令来执行修改。</p><p>最终通过 java -version 来验证我们的 JDK 环境是否设置正确，如果正确应像下图一样显示 JDK 的版本信息：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3af22e5f056400647ee4c62dacf49142_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb\" width=\"610\" data-original=\"https://pic3.zhimg.com/v2-3af22e5f056400647ee4c62dacf49142_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;610&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"610\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"610\" data-original=\"https://pic3.zhimg.com/v2-3af22e5f056400647ee4c62dacf49142_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3af22e5f056400647ee4c62dacf49142_b.jpg\"/></figure><h2><b>CloudSim 安装</b></h2><p>在完成了 JDK 的环境配置之后，我们就要正式开始对 CloudSim 的安装了。</p><p>CloudSim 的下载地址为： <a href=\"https://link.zhihu.com/?target=http%3A//www.cloudbus.org/cloudsim/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CloudSim: A Framework For Modeling And Simulation Of Cloud Computing Infrastructures And Services</a> 。</p><p>我这里最新的是 CloudSim 4.0 版本，于是我就下载了 4.0 版本的 CloudSim。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-100008774bff95260c9fa2608728ec12_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"792\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb\" width=\"792\" data-original=\"https://pic3.zhimg.com/v2-100008774bff95260c9fa2608728ec12_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;792&#39; height=&#39;286&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"792\" data-rawheight=\"286\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"792\" data-original=\"https://pic3.zhimg.com/v2-100008774bff95260c9fa2608728ec12_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-100008774bff95260c9fa2608728ec12_b.jpg\"/></figure><p>下载完成后，为了方便起见我同样把他解压到用户主目录下。</p><p>正如你所看到的，CloudSim文件夹内没有 makefile 或 install 文件，所以不需要编译。稍后，如果您要删除 CloudSim ，只需删除整个&#39;cloudsim-4.0&#39;目录即可。</p><p>在 cloudsim-4.0/jars 里面我们可以看到两个 .jar 的压缩文件，我们首先将他们解压缩。</p><p>在 cloudsim-4.0 文件下有一个 examples.txt 文件，我们可以看到如下内容（我这里截取了一部分有关的）：</p><div class=\"highlight\"><pre><code class=\"language-text\">Running the CloudSim examples\n-----------------------------\n\nTo run the CloudSim examples you need to do the following steps.\n\nIn Unix/Linux:\n\n1. cd &lt;PATH TO CLOUDSIM PACKAGE&gt;/jars\n2. java -classpath cloudsim-&lt;VERSION&gt;.jar:cloudsim-examples-&lt;VERSION&gt;.jar org.cloudbus.cloudsim.examples.CloudSimExample&lt;EXAMPLE NUMBER&gt;\n\nWhere you need to replace:\n\n&lt;PATH TO CLOUDSIM PACKAGE&gt; - by the path to a directory where you have unpacked the CloudSim package\n&lt;VERSION&gt; - by the version of the downloaded CloudSim package\n&lt;EXAMPLE NUMBER&gt; - by the of number of the example you want to run</code></pre></div><p>这是一份教我们如何运行 CloudSim 的示例的说明，</p><p>在这里我们的 &lt;PATH TO CLOUDSIM PACKAGE&gt; 是 /home/cloudsim-4.0</p><p>&lt;VERSION&gt; 是 4.0</p><p>&lt;EXAMPLE NUMBER&gt; 这个可以在进入这个地址后进行查看。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a4e318ecc0dc91ce54d661a7ab0e723a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"695\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"695\" data-original=\"https://pic3.zhimg.com/v2-a4e318ecc0dc91ce54d661a7ab0e723a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;695&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"695\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"695\" data-original=\"https://pic3.zhimg.com/v2-a4e318ecc0dc91ce54d661a7ab0e723a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a4e318ecc0dc91ce54d661a7ab0e723a_b.jpg\"/></figure><p>可以看到，有8个基本的 CloudSimExample，我们随便的选取其中一个进行运行，我这里选择 CloudSimExample1，得到如下结果：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a866cc82a2c9221976df1870232a7eac_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"697\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb\" width=\"697\" data-original=\"https://pic1.zhimg.com/v2-a866cc82a2c9221976df1870232a7eac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;697&#39; height=&#39;475&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"697\" data-rawheight=\"475\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"697\" data-original=\"https://pic1.zhimg.com/v2-a866cc82a2c9221976df1870232a7eac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a866cc82a2c9221976df1870232a7eac_b.jpg\"/></figure><p>证明，我们的CloudSim的配置和安装已经完成。</p><p>(o゜▽゜)o☆[BINGO!]</p><p class=\"ztext-empty-paragraph\"><br/></p><p>另外，关于CloudSim Examples的详细说明可以查考： <a href=\"https://link.zhihu.com/?target=http%3A//www.cloudbus.org/cloudsim/examples.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CloudSim Examples</a> 。</p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/36388351\" class=\"internal\">运用虚拟机搭建本地Hadoop环境</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/lhakuma/article/details/78754957\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从零开始部署CloudSim4.0云计算仿真平台</a> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//installwithme.blogspot.com/2014/10/how-to-install-cloudsim-in-ubuntu.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">how-to-install-cloudsim-in-ubuntu</a> </li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.cloudbus.org/cloudsim/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CloudSim: A Framework For Modeling And Simulation Of Cloud Computing Infrastructures And Services</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//www.cloudbus.org/cloudsim/examples.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">CloudSim Examples</a></li></ul>", 
            "topic": [
                {
                    "tag": "云计算", 
                    "tagLink": "https://api.zhihu.com/topics/19550358"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37764566", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 4, 
            "title": "使用树莓派操纵模型小车", 
            "content": "<p></p><figure data-size=\"small\"><noscript><img src=\"https://pic2.zhimg.com/v2-142192429ceb063fd453c4a3189d8865_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"3264\" data-rawheight=\"2448\" class=\"origin_image zh-lightbox-thumb\" width=\"3264\" data-original=\"https://pic2.zhimg.com/v2-142192429ceb063fd453c4a3189d8865_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;3264&#39; height=&#39;2448&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"3264\" data-rawheight=\"2448\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"3264\" data-original=\"https://pic2.zhimg.com/v2-142192429ceb063fd453c4a3189d8865_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-142192429ceb063fd453c4a3189d8865_b.jpg\"/></figure><p>之前一直使用32、PIC之类的单片机来作为嵌入式设备的控制模型。最近由于在学习树莓派的GPIO，看书看的无聊，而且正好手头一个之前用32做的模型小车。于是就想着将树莓派加到这个小车上，用树莓派来作为控制设备，在实践中进一步掌握树莓派的GPIO控制方式。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>一、连接</b></h2><p>树莓派+USB电源线+网络数据线</p><p>注：网线的连接方式见：<a href=\"https://zhuanlan.zhihu.com/p/37761024\" class=\"internal\">树莓派使用网线直连电脑的方法</a> </p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>二、了解 GPIO</b></h2><p>如果玩过32单片机应该对GPIO有一个基本的概念。</p><p>在树莓派中，我们可以使用如下指令来查看树莓派的GPIO设置：</p><div class=\"highlight\"><pre><code class=\"language-bash\">gpio  readall</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ef0e9c66a215e7deb619887edcc23f77_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-ef0e9c66a215e7deb619887edcc23f77_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;688&#39; height=&#39;487&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"688\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"688\" data-original=\"https://pic4.zhimg.com/v2-ef0e9c66a215e7deb619887edcc23f77_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ef0e9c66a215e7deb619887edcc23f77_b.jpg\"/></figure><p>在给出的这个表中 Physical 表示物理引脚，在板子上体现的样子如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7edabf0c8c851e3d8d2fbc03ae0d0596_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"660\" class=\"origin_image zh-lightbox-thumb\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-7edabf0c8c851e3d8d2fbc03ae0d0596_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;465&#39; height=&#39;660&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"660\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-7edabf0c8c851e3d8d2fbc03ae0d0596_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7edabf0c8c851e3d8d2fbc03ae0d0596_b.jpg\"/></figure><p>其中蓝色的即为所有的GPIO引脚接口。红框框起来的“J8”字符所在位置表示的是第一个引脚所在的位置。单号在内侧，双号在外侧。</p><p>Name 是引脚对应的功能描述。</p><p>wPi 是编程时需要使用的数字引脚：</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>三、引脚的输入输出方式</b></h2><p>和32编程一样，我们需要使用C语言进行硬件编程。我们可以使用 wiringPi(wPi) GPIO库进行引脚控制。</p><p>wPi使用手册可以从这个链接进行下载：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/TrafficLight-Obstacle-Avoidance-Car/blob/master/wiringPi%25E7%2594%25A8%25E6%2588%25B7%25E6%2589%258B%25E5%2586%258CV001.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wiringPi用户手册V001</a> 。</p><p>基本输入输出所需要使用到的函数如下：</p><ul><li>配置引脚功能</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span> <span class=\"c1\">//输出\n</span><span class=\"c1\"></span><span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">INPUT</span><span class=\"p\">);</span> <span class=\"o\">//</span><span class=\"err\">输入</span></code></pre></div><ul><li>输出高低电平，或者读取电平值</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n<span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span></code></pre></div><p>延时行数</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">);</span> <span class=\"o\">//</span><span class=\"mi\">1000</span><span class=\"n\">ms</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>四、LED控制实现代码测试</b></h2><p>这里我们使用的含有8颗灯珠的RGB三色LED灯条。</p><p>其对应的IO口功能如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7BLED%7D+%26+%5Ctext%7B%E5%8A%9F%E8%83%BD%7D+%5C%5C+%5Chline+%7BD_0%5C+D_1%5C+...%5C+D_7%7D+%26+8%E9%A2%97%E7%81%AF%E7%8F%A0%E7%9A%84%E4%BD%8D%E9%80%89%5C%5C+%5Chline+R%5C+G%5C+B+%26+%E9%A2%9C%E8%89%B2%E6%8E%A7%E5%88%B6%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|} \\hline \\text{LED} &amp; \\text{功能} \\\\ \\hline {D_0\\ D_1\\ ...\\ D_7} &amp; 8颗灯珠的位选\\\\ \\hline R\\ G\\ B &amp; 颜色控制\\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><p>这是我们使用到的引脚为：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%E5%BC%95%E8%84%9A+%26+%E5%9C%A8LED%E6%A8%A1%E5%9D%97%E4%B8%8A%E7%9A%84%E5%BC%95%E8%84%9A%E4%BD%8D%E7%BD%AE+%26+%E8%BF%9E%E6%8E%A5%E5%88%B0%E7%9A%84%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E7%9A%84IO%E5%8F%A3%E5%9C%B0%E5%9D%80+%5C%5C+%5Chline+VCC+%26+3.3V+%5C%5C+%5Chline+D0+%26+3+%26+8+%5C%5C+%5Chline+R+%26+5+%26+9+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C+\" alt=\"\\begin{array}{|c|c|} \\hline 引脚 &amp; 在LED模块上的引脚位置 &amp; 连接到的树莓派上的IO口地址 \\\\ \\hline VCC &amp; 3.3V \\\\ \\hline D0 &amp; 3 &amp; 8 \\\\ \\hline R &amp; 5 &amp; 9 \\\\ \\hline \\end{array}\\\\ \" eeimg=\"1\"/> </p><p>C语言的实现代码如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;stdio.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;wiringPi.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\n    <span class=\"n\">wiringPiSetup</span><span class=\"p\">();</span>\n    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">){</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n        <span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">);</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n        <span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>五、如何进行编译、运行</b></h2><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80+%26+%E7%BC%96%E8%AF%91%28%E7%BC%96%E8%AF%91%E5%99%A8%29+%26+%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80%280%2F1%29+%5C%5C+%5Chline+a.c+%26+gcc+%26+%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6+%5C%5C+%5Chline+b.cpp+%26+g%2B%2B+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|} \\hline 高级语言 &amp; 编译(编译器) &amp; 机器语言(0/1) \\\\ \\hline a.c &amp; gcc &amp; 可执行文件 \\\\ \\hline b.cpp &amp; g++ \\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><p>对于上面写好的LED文件，我们的编译操作为：</p><div class=\"highlight\"><pre><code class=\"language-text\">g++ led.cpp -o led -lwiringPi(链接库)</code></pre></div><p>运行操作为：</p><div class=\"highlight\"><pre><code class=\"language-text\">sudo  ./led </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>六、超声波的控制实现</b></p><p>超声波模块通常用来实现距离墙体的距离的测量。运用声音在空气中传播的距离与时间相关这一特性进行计算。</p><p>用 t1，t2 分别表示 开始传播声波时间点 和 收到传播声波时间点。</p><p>则距离 dis = (t2-t1) *  340 m/s  / 2</p><p class=\"ztext-empty-paragraph\"><br/></p><p>超声波模块使用的IO口如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%E8%B6%85%E5%A3%B0%E6%B3%A2%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E5%BC%95%E8%84%9A+%26+%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AF%B9%E5%BA%94%E7%9A%84%E7%89%A9%E7%90%86%E8%BF%9E%E6%8E%A5%E5%BC%95%E8%84%9A+%26+%E7%89%A9%E7%90%86%E5%BC%95%E8%84%9A%E5%AF%B9%E5%BA%94%E7%9A%84wPi+%5C%5C+%5Chline+VCC+%26+4+%5C%5C+%5Chline+GND+%26+6+%5C%5C+%5Chline+Trig%EF%BC%88%E8%A7%A6%E5%8F%91%EF%BC%89%26+8%EF%BC%88OUTPUT%EF%BC%89+%26+15+%5C%5C+%5Chline+Echo%EF%BC%88%E5%8F%8D%E5%B0%84%EF%BC%89%26+10%EF%BC%88INPUT%EF%BC%89%26+16+%5C%5C+%5Chline+%5Cend%7Barray%7D\" alt=\"\\begin{array}{|c|c|} \\hline 超声波传感器的引脚 &amp; 树莓派上对应的物理连接引脚 &amp; 物理引脚对应的wPi \\\\ \\hline VCC &amp; 4 \\\\ \\hline GND &amp; 6 \\\\ \\hline Trig（触发）&amp; 8（OUTPUT） &amp; 15 \\\\ \\hline Echo（反射）&amp; 10（INPUT）&amp; 16 \\\\ \\hline \\end{array}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于超声波发射的触发方式如下，我们通过编码控制 Trig，给它时序，触发传感器发射一次超声波信号。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n<span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n<span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">);</span>  </code></pre></div><p>其实现的完整代码如下：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;stdio.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;wiringPi.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;sys/time.h&#34;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(){</span>\n\t<span class=\"n\">wiringPiSetup</span><span class=\"p\">();</span>\t\t<span class=\"c1\">//initial\n</span><span class=\"c1\"></span>\t<span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\t<span class=\"c1\">//set GPIO mode\n</span><span class=\"c1\"></span>\t<span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">,</span> <span class=\"n\">INPUT</span><span class=\"p\">);</span>\n\t<span class=\"k\">struct</span> <span class=\"n\">timeval</span> <span class=\"n\">t1</span><span class=\"p\">;</span>\t\t<span class=\"c1\">//(tv_sec, tv_usec)\n</span><span class=\"c1\"></span>\t<span class=\"k\">struct</span> <span class=\"n\">timeval</span> <span class=\"n\">t2</span><span class=\"p\">;</span>\n\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">){</span>\n\t\t<span class=\"c1\">// 触发超声波的发射\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n\t\t<span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n\t\t<span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n\t\t<span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">);</span>\n\t\t<span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">15</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \t\t<span class=\"c1\">// 第二次发射\n</span><span class=\"c1\"></span>\t\t\n\t\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">digitalRead</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">));</span>\n\t\t<span class=\"n\">gettimeofday</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">t1</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n\t\t<span class=\"c1\">//get t1\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">while</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"p\">(</span><span class=\"n\">digitalRead</span><span class=\"p\">(</span><span class=\"mi\">16</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">));</span>\n\t\t<span class=\"n\">gettimeofday</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">t2</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n                <span class=\"c1\">//get t2\n</span><span class=\"c1\"></span>\t\t\n\t\t<span class=\"kt\">long</span> <span class=\"n\">start</span> <span class=\"o\">=</span> <span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">*</span> <span class=\"mi\">1000000</span> <span class=\"o\">+</span> <span class=\"n\">t1</span><span class=\"p\">.</span><span class=\"n\">tv_usec</span><span class=\"p\">;</span>\n\t\t<span class=\"kt\">long</span> <span class=\"n\">end</span> <span class=\"o\">=</span> <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">tv_sec</span> <span class=\"o\">*</span> <span class=\"mi\">1000000</span> <span class=\"o\">+</span> <span class=\"n\">t2</span><span class=\"p\">.</span><span class=\"n\">tv_usec</span><span class=\"p\">;</span>\n\t\t<span class=\"kt\">float</span> <span class=\"n\">dis</span> <span class=\"o\">=</span> <span class=\"mf\">1.0</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"n\">end</span> <span class=\"o\">-</span> <span class=\"n\">start</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mf\">1000000.0</span> <span class=\"o\">*</span> <span class=\"mf\">34000.0</span> <span class=\"o\">/</span> <span class=\"mf\">2.0</span><span class=\"p\">;</span>   <span class=\"c1\">//cm\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;distance - %fcm</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">dis</span><span class=\"p\">);</span>\n\t\t\n\t\t<span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">2000</span><span class=\"p\">);</span>\n\t<span class=\"p\">}</span>\n<span class=\"p\">}</span>\t</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>七、小车控制</b></h2><p>对于四轮小车的话，我们需要使用四个直流电机来控制四个轮子。</p><p>一般我们需要使用树莓派通过电机驱动器L298N，来控制小车的四个直流电机。如果直接使用主控对电机进行控制，不使用电机驱动器，会导致电器不稳定。使用一个L298N，马达A控制左边两个轮子 ，马达B控制右边两个轮子。</p><figure data-size=\"small\"><noscript><img src=\"https://pic4.zhimg.com/v2-95d9f1eef6730a111af34c8328dbd0a3_b.jpg\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"696\" data-rawheight=\"669\" class=\"origin_image zh-lightbox-thumb\" width=\"696\" data-original=\"https://pic4.zhimg.com/v2-95d9f1eef6730a111af34c8328dbd0a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;696&#39; height=&#39;669&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"small\" data-rawwidth=\"696\" data-rawheight=\"669\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"696\" data-original=\"https://pic4.zhimg.com/v2-95d9f1eef6730a111af34c8328dbd0a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-95d9f1eef6730a111af34c8328dbd0a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>其对应的IO口和操作方式如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7C%7D+%5Chline+%26+Pin1+%26+Pin2+%5C%5C+%5Chline+%E5%90%91%E5%89%8D+%26+HIGH+%26+LOW+%5C%5C+%5Chline+%E5%85%88%E5%90%8E+%26+LOW+%26+HIGH+%5C%5C+%5Chline+%E5%81%9C%E6%AD%A2+%26+LOW+%26+LOW+%5C%5C+%5Chline+%5Cend%7Barray%7D\" alt=\"\\begin{array}{|c|c|c|} \\hline &amp; Pin1 &amp; Pin2 \\\\ \\hline 向前 &amp; HIGH &amp; LOW \\\\ \\hline 先后 &amp; LOW &amp; HIGH \\\\ \\hline 停止 &amp; LOW &amp; LOW \\\\ \\hline \\end{array}\" eeimg=\"1\"/> <br/></p><p>L298N的单片机IO对应控制如下：</p><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%E9%A9%AC%E8%BE%BE+%26+L298N%E5%BC%95%E8%84%9A+%26+%E6%A0%91%E8%8E%93%E6%B4%BE%E7%89%A9%E7%90%86IO+%26+%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%BB%E8%BE%91IO+%5C%5C+%5Chline+%E9%A9%AC%E8%BE%BEA+%26+IN1+%26+3+%26+8+%5C%5C+%5Chline+%E9%A9%AC%E8%BE%BEA+%26+IN2+%26+5+%26+9+%5C%5C+%5Chline+%E9%A9%AC%E8%BE%BEB+%26+IN3+%26+7+%26+7+%5C%5C+%5Chline+%E9%A9%AC%E8%BE%BEB+%26+IN4+%26+11+%26+0+%5C%5C+%5Chline+%5Cend%7Barray%7D\" alt=\"\\begin{array}{|c|c|} \\hline 马达 &amp; L298N引脚 &amp; 树莓派物理IO &amp; 树莓派逻辑IO \\\\ \\hline 马达A &amp; IN1 &amp; 3 &amp; 8 \\\\ \\hline 马达A &amp; IN2 &amp; 5 &amp; 9 \\\\ \\hline 马达B &amp; IN3 &amp; 7 &amp; 7 \\\\ \\hline 马达B &amp; IN4 &amp; 11 &amp; 0 \\\\ \\hline \\end{array}\" eeimg=\"1\"/> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>速度控制（L298N的PWM调节）</p><ul><li>ENA （wP2）</li><ul><li>pin1 , pin2 短接-&gt;全速运行</li><li>拔出跳线帽， 使用PWM控制两个引脚</li></ul><li>ENB（wP3）</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>驱动电源</p><ul><ul><li>12V输入 -&gt; 锂电池正极</li><li>电源地    -&gt; 锂电池负极， 并连接树莓派地线， 实现共地</li></ul></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>八、初步调试</b></h2><p>写一个速度函数函数：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">changespeed</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">pin</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">speed</span><span class=\"p\">)</span>  \n<span class=\"p\">{</span>\t\t\t\t<span class=\"c1\">// 2 3     0~1000\t\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">&lt;</span><span class=\"mi\">20</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>  <span class=\"c1\">//  x/1000\n</span><span class=\"c1\"></span>        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"n\">pin</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n        <span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"n\">speed</span><span class=\"p\">);</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"n\">pin</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n\t<span class=\"n\">delayMicroseconds</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"o\">-</span><span class=\"n\">speed</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\t</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>编写主函数--先测试一边的轮子：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\t<span class=\"c1\">//  8 9 7 0 2 3 \n</span><span class=\"c1\"></span>    <span class=\"n\">wiringPiSetup</span><span class=\"p\">();</span>\n    <span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"n\">SIGINT</span><span class=\"p\">,</span> <span class=\"n\">exit_handler</span><span class=\"p\">);</span>  <span class=\"c1\">// ctrl+c\n</span><span class=\"c1\"></span>    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"c1\">//小车前进测试\n</span><span class=\"c1\"></span>    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n\t<span class=\"n\">forward</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 前进的函数\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">forward</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n<span class=\"p\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>增加信号处理--在程序关闭瞬间，先把小车恢复到0</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"cp\">#include</span> <span class=\"cpf\">&#34;signal.h&#34;</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>如果在终端输入 ctrl + c， 给小车运行程序发送一个SIGINT中断，</p><p>我们要捕捉，在收到信号的瞬间，调用exit_handler函数， 停止小车，并退出程序。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"nf\">exit_handler</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">signo</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">stop</span><span class=\"p\">();</span>\n    <span class=\"n\">exit</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\t\t</code></pre></div><p>在main函数中，需要去注册：</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"n\">SIGINT</span><span class=\"p\">,</span> <span class=\"n\">exit_handler</span><span class=\"p\">);</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>如要查看信号，在终端输入 kill -l</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>九、进一步调试</b></h2><p>再完成了对小车前进函数 forward() 的调试后，我们需要进一步对是四个轮子进行控制，测试：</p><ul><li>速度函数</li><li>停止函数</li><li>前进、后退</li><li>左转、右转</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"c1\">// 前进函数\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">forward</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 后退\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">backward</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 左转\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">turnleft</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n    <span class=\"c1\">//changespeed(3, 900);\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"c1\">// 右转\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">turnright</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n\t\n    <span class=\"c1\">//changespeed(2, 900);\n</span><span class=\"c1\"></span>    <span class=\"n\">changespeed</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">900</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 停止\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">stop</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">8</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">9</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">7</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span> \n<span class=\"p\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>十、实现键盘控制方向</b></h2><p>完成了基本功能的调试后，就要进一步的加强我们的基本功能，使用键盘输入来实现小车的转向（前进、后退、左转、右转）。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">int</span> <span class=\"n\">dir</span><span class=\"p\">;</span> <span class=\"c1\">//方向 0 1 2 3 4\n</span><span class=\"c1\"></span><span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">scanf</span><span class=\"p\">(</span><span class=\"s\">&#34;%d&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">dir</span><span class=\"p\">);</span> <span class=\"c1\">//用户输入方向\n</span><span class=\"c1\"></span>\t<span class=\"c1\">//阻塞函数\n</span><span class=\"c1\"></span>    <span class=\"k\">switch</span><span class=\"p\">(</span><span class=\"n\">dir</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">case</span> <span class=\"mi\">1</span><span class=\"o\">:</span>\n  \t    <span class=\"k\">for</span><span class=\"p\">()</span>\n\t\t<span class=\"n\">forward</span><span class=\"p\">();</span>\n\t    <span class=\"k\">break</span><span class=\"p\">;</span>\n\t\n         <span class=\"k\">case</span> <span class=\"p\">...</span>\t\t\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>十一、并发处理/多线程</b></h2><p>小车的控制流程是多进程、多线程的。我们需要进行多线程处理,把小车的运行也改为一个独立线程。</p><ul><li>创建一个线程函数 routline ： 独立的代码执行流程</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"nf\">keyboard</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t\t\n<span class=\"p\">}</span>\n\t\t\n<span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"nf\">carrun</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">arg</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n\t\t\n<span class=\"p\">}</span></code></pre></div><ul><li>命名线程号：pthread_t tid1, tid2; //线程ID号</li><li>创建线程： 运行线程</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">pthread</span> <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tid</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">keyboard</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n<span class=\"n\">pthread</span> <span class=\"nf\">create</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">tid</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">carrun</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span></code></pre></div><ul><li>等待线程结束</li></ul><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"n\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">tid1</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span>\n<span class=\"n\">pthread_join</span><span class=\"p\">(</span><span class=\"n\">tid2</span><span class=\"p\">,</span> <span class=\"nb\">NULL</span><span class=\"p\">);</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>十二、输入优化</b></p><p>目前的输入过程，每一次输入完成之后都需要按回车来进行确认输入。</p><p>于是我们构建了一个 user_command() 函数。来代替 scanf(&#34;%d&#34;, &amp;dir); 的输入形式，这样子就不用每次输入完成都要按回车了。</p><div class=\"highlight\"><pre><code class=\"language-c\"><span class=\"k\">enum</span> <span class=\"n\">command</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">STOP</span><span class=\"p\">,</span>   <span class=\"c1\">// 0\n</span><span class=\"c1\"></span>    <span class=\"n\">UP</span><span class=\"p\">,</span>\t<span class=\"c1\">//1\n</span><span class=\"c1\"></span>    <span class=\"n\">DOWN</span><span class=\"p\">,</span>\t<span class=\"c1\">//2\n</span><span class=\"c1\"></span>    <span class=\"n\">LEFT</span><span class=\"p\">,</span>\t<span class=\"c1\">//\n</span><span class=\"c1\"></span>    <span class=\"n\">RIGHT</span><span class=\"p\">,</span>\t<span class=\"c1\">//4\n</span><span class=\"c1\"></span>    <span class=\"n\">ADD</span><span class=\"p\">,</span>\t<span class=\"c1\">//5\n</span><span class=\"c1\"></span>    <span class=\"n\">DEL</span><span class=\"p\">,</span>\t<span class=\"c1\">//6\n</span><span class=\"c1\"></span>    <span class=\"n\">UNKOWN</span><span class=\"p\">,</span>\t<span class=\"c1\">//7\n</span><span class=\"c1\"></span>    <span class=\"n\">INVALID</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">char</span> <span class=\"nf\">my_getch</span><span class=\"p\">()</span> \n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"kt\">int</span> <span class=\"n\">res</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">struct</span> <span class=\"n\">termios</span> <span class=\"n\">org_opts</span><span class=\"p\">,</span> <span class=\"n\">new_opts</span><span class=\"p\">;</span>\n   \n    <span class=\"n\">res</span><span class=\"o\">=</span><span class=\"n\">tcgetattr</span><span class=\"p\">(</span><span class=\"n\">STDIN_FILENO</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">org_opts</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n    <span class=\"n\">memcpy</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">new_opts</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">org_opts</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">new_opts</span><span class=\"p\">));</span>\n    <span class=\"n\">new_opts</span><span class=\"p\">.</span><span class=\"n\">c_lflag</span> <span class=\"o\">&amp;=</span> <span class=\"o\">~</span><span class=\"p\">(</span><span class=\"n\">ICANON</span> <span class=\"o\">|</span> <span class=\"n\">ECHO</span> <span class=\"o\">|</span> <span class=\"n\">ECHOE</span> <span class=\"o\">|</span> <span class=\"n\">ECHOK</span> <span class=\"o\">|</span> <span class=\"n\">ECHONL</span> <span class=\"o\">|</span> <span class=\"n\">ECHOPRT</span> <span class=\"o\">|</span> <span class=\"n\">ECHOKE</span> <span class=\"o\">|</span> <span class=\"n\">ICRNL</span><span class=\"p\">);</span>\n    <span class=\"n\">tcsetattr</span><span class=\"p\">(</span><span class=\"n\">STDIN_FILENO</span><span class=\"p\">,</span> <span class=\"n\">TCSANOW</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">new_opts</span><span class=\"p\">);</span>\n    <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"n\">getchar</span><span class=\"p\">();</span>\n\n    <span class=\"n\">res</span><span class=\"o\">=</span><span class=\"n\">tcsetattr</span><span class=\"p\">(</span><span class=\"n\">STDIN_FILENO</span><span class=\"p\">,</span> <span class=\"n\">TCSANOW</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">org_opts</span><span class=\"p\">);</span>\n    <span class=\"n\">assert</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"o\">==</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"n\">c</span><span class=\"p\">;</span> \n<span class=\"p\">}</span>\n\n<span class=\"k\">enum</span> <span class=\"n\">command</span> <span class=\"nf\">user_command</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">enum</span> <span class=\"n\">command</span> <span class=\"n\">dir</span><span class=\"p\">;</span>\n    <span class=\"kt\">char</span> <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">my_getch</span><span class=\"p\">();</span>\n    <span class=\"c1\">// printf(&#34;--&gt;%d\\n&#34;, ch);\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">27</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">my_getch</span><span class=\"p\">();</span>\n      \t<span class=\"c1\">// printf(&#34;--&gt;%d\\n&#34;, ch);\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">91</span><span class=\"p\">)</span>\n\t<span class=\"p\">{</span>\n            <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">my_getch</span><span class=\"p\">();</span>\n\t    <span class=\"c1\">// printf(&#34;--&gt;%d\\n&#34;, ch);\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">65</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">UP</span><span class=\"p\">;</span>\n\t    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">66</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">DOWN</span><span class=\"p\">;</span>\n\t    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">67</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">RIGHT</span><span class=\"p\">;</span>\n\t    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">68</span><span class=\"p\">)</span>\n\t\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">LEFT</span><span class=\"p\">;</span>\n\t    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">53</span><span class=\"p\">)</span>\n\t    <span class=\"p\">{</span>\n\t\t<span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">my_getch</span><span class=\"p\">();</span>\n\t        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">126</span><span class=\"p\">)</span>\n\t\t    <span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">ADD</span><span class=\"p\">;</span>\n\t\t<span class=\"c1\">// printf(&#34;--&gt;%d\\n&#34;, ch);\n</span><span class=\"c1\"></span>\t    <span class=\"p\">}</span>\n\t    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">54</span><span class=\"p\">)</span>\n\t    <span class=\"p\">{</span>\n\t        <span class=\"n\">ch</span> <span class=\"o\">=</span> <span class=\"n\">my_getch</span><span class=\"p\">();</span>\n\t\t<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"mi\">126</span><span class=\"p\">)</span>\n\t\t    <span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">DEL</span><span class=\"p\">;</span>\n\t\t    <span class=\"c1\">//printf(&#34;--&gt;%d\\n&#34;, ch);\n</span><span class=\"c1\"></span>\t    <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">ch</span> <span class=\"o\">==</span> <span class=\"sc\">&#39;\\n&#39;</span><span class=\"p\">)</span>\n\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">STOP</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span>\n\t<span class=\"n\">dir</span> <span class=\"o\">=</span> <span class=\"n\">INVALID</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">dir</span><span class=\"p\">;</span>\n<span class=\"p\">}</span></code></pre></div><p>此时编译时应该为：</p><div class=\"highlight\"><pre><code class=\"language-text\">g++ run.cpp termios_control.cpp -o run -lwiringPi -lphthread</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>十三、支持键盘输入调速</b></h2><p>在keyboard流程中修改，将gspeed定义为全局变量</p><div class=\"highlight\"><pre><code class=\"language-text\">while(1)\n{\n    dir = user_command();  \n    //这里 dir返回  0 1 2 3 4 5 6 \n\t\t停止 前进 后退 左转 右转 加速 减速\n    if(dir == 5)\n\tgspeed += 100;\n    else if( dir == 6)\n\tgspeed -= 100;\t\t\n}</code></pre></div><p>调试运行发现，改速度后，小车没法继续运行了！</p><p>因为修改速度，dir就是5或者6，当然没法是1,2,3,4  表示转向了，所以要备份小车之前的状态，修改如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">int backdir;\nwhile(1)\n{\n    dir = user_command();  \n    //这里 dir返回  0 1 2 3 4 5 6 \n\t\t\t停止 前进 后退 左转 右转 加速 减速\n    if(dir == 5){\n\tgspeed += 100;\n    }\n    else if( dir == 6)\n\tgspeed -= 100;\t\t\t\t\t\n}</code></pre></div><p>在调试后，发现这样的问题</p><p>应该同时给2,3 使用pwm，而不是分开，所以这个函数需要修改：</p><div class=\"highlight\"><pre><code class=\"language-text\">void changespeed(int pin, int speed)  \n{\t\t\t\t// 2 3     0~1000\t\n    int i;\n    for(i=0; i&lt;20; i++)\n    {  //  x/1000\n\tdigitalWrite(pin, HIGH);\n\tdelayMicroseconds(speed);\n\tdigitalWrite(pin, LOW);\n\tdelayMicroseconds(1000-speed);\n    }\n}\t\n\t\nvoid changespeed(int speed)  \n{\t\t\t\t// 2 3     0~1000\t\n    int i;\n    for(i=0; i&lt;20; i++)\n    {  //  x/1000\n\tdigitalWrite(2, HIGH);\n\tdigitalWrite(3, HIGH);\n\tdelayMicroseconds(speed);\n\tdigitalWrite(2, LOW);\n\tdigitalWrite(3, LOW);\n\tdelayMicroseconds(1000-speed);\n    }\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>十四、加入摄像头，实现对红绿灯的识别</b></h2><p>红绿灯检测算法 ：</p><ul><li>颜色空间 RGB –GRAY –HSV</li><ul><li>一个字节表示基本颜色， 0~255， 灰度图</li><li>三个字节表示颜色， R 0~255，G 0~255，B 0~255</li></ul><li>HSV， 表示色调、饱和度、亮度</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>实现步骤：</p><ul><li>求出红色的色调范围，绿色的色调范围。</li><li>采集一张图像，在图像中找颜色。</li><ul><li>Mat(矩阵 二维数组 像素点值 0~255)</li></ul><li>找出所有红色的区域、蓝色区域。</li><li>二值化操作，比较像素值。</li><ul><li>redmin &lt; pixValue &lt; redmax; pixValue := 255;</li><li>else; pixValue := 0;</li><li>至留下红色区域，或者绿色区域</li></ul><li>轮廓检测</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>本次项目的全部代码已经上传到GitHub上：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/TrafficLight-Obstacle-Avoidance-Car\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">shaonianruntu/TrafficLight-Obstacle-Avoidance-Car</a></p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/lulipro/p/5992172.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">树莓派wiringPi库详解 - lulipro - 博客园</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/TrafficLight-Obstacle-Avoidance-Car/blob/master/wiringPi%25E7%2594%25A8%25E6%2588%25B7%25E6%2589%258B%25E5%2586%258CV001.pdf\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">wiringPi用户手册V001.pdf</a> </li><li><a href=\"https://zhuanlan.zhihu.com/p/38853178\" class=\"internal\">树莓派串口通信设置</a></li></ul><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "树莓派（Raspberry Pi）", 
                    "tagLink": "https://api.zhihu.com/topics/19737690"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37761024", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 12, 
            "title": "树莓派使用网线直连电脑的方法", 
            "content": "<h2><b>前言</b></h2><p>在阅读这篇文章之前，我希望大家已经阅读了我的这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/35161674\" class=\"internal\">树莓派3B无显示屏安装系统及远程登录</a> 。对树莓派的基本连接知识有了了解。</p><p>那么这这两篇文章直接的区别是什么呢？</p><p>在 <a href=\"https://zhuanlan.zhihu.com/p/35161674\" class=\"internal\">树莓派3B无显示屏安装系统及远程登录</a> 文章中，我们的网络连接方式，是通过将树莓派挂载在我们的路由器下面，对于不需要怎么移动树莓派设备，经常进行远程访问的人来说，比较友好。但是，很多时候，我们需要随身带着我们的树莓派走，或者在学校实验室里面使用校园网，手头并没有路由器使用，怎么办呢？那么就应该使用本文将要介绍的方法。讲树莓派直接与笔记本电脑连接，网线的一端连接树莓派，一端连接电脑网线接口。这里只是需要修改网线的连接方式，其余方式同 <a href=\"https://zhuanlan.zhihu.com/p/35161674\" class=\"internal\">树莓派3B无显示屏安装系统及远程登录</a> 此文中所述。</p><h2><b> 查看网络连接状况</b></h2><p>为了使树莓派能够通过以太网连接到我们的本机网络中。我们需要选择共享我们的本机网络。对于本机网络，我们在计算机的【控制面板-&gt;网络和Internet-&gt;网络和共享中心-&gt;查看网络状态和任务-&gt;更改适配器设置】 (Win10可以直接从【设置-&gt;网络和Internet-&gt;状态-&gt;更改适配器设置】进入）可以看到，我们的本地网络连接方式有 WLAN无线连接 和 以太网有线连接 两种方式。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-8b5db6cd49f9fd9bc0720aa153f54e69_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"817\" data-original=\"https://pic2.zhimg.com/v2-8b5db6cd49f9fd9bc0720aa153f54e69_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;817&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"817\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"817\" data-original=\"https://pic2.zhimg.com/v2-8b5db6cd49f9fd9bc0720aa153f54e69_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-8b5db6cd49f9fd9bc0720aa153f54e69_b.jpg\"/></figure><p>因为，平时我们都是使用无线连接的，为了保证我们的树莓派在无论是否已经连接无线网络的环境下都能够通过以太网连接到我们的PC。所以我们需要讲我们的WLAN网络进行共享。</p><p>在共享之前，还需要做一件事情，就是记录当前我们的网络连接状况。在终端中运行如下指令，进行查看：</p><div class=\"highlight\"><pre><code class=\"language-bash\">arp -a </code></pre></div><p>得到的结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-62955a64893a1bb922ad5c9205f22580_b.jpg\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"511\" data-original=\"https://pic1.zhimg.com/v2-62955a64893a1bb922ad5c9205f22580_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;511&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"511\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"511\" data-original=\"https://pic1.zhimg.com/v2-62955a64893a1bb922ad5c9205f22580_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-62955a64893a1bb922ad5c9205f22580_b.jpg\"/><figcaption>共享以太网给树莓派前的网络连接状况</figcaption></figure><p>可以看到，我们最上方的一项是 192.168.1.103，记住这个接口地址。</p><h2><b>共享WLAN网络给以太网</b></h2><p>这一步就是在刚才打开的 更改适配器设置 界面中选择修改 WLAN 属性。选择共享，设置共享网络给以太网。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f11f2b7e8dc52c6242e6aa208f44870a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"421\" data-rawheight=\"598\" class=\"origin_image zh-lightbox-thumb\" width=\"421\" data-original=\"https://pic3.zhimg.com/v2-f11f2b7e8dc52c6242e6aa208f44870a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;421&#39; height=&#39;598&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"421\" data-rawheight=\"598\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"421\" data-original=\"https://pic3.zhimg.com/v2-f11f2b7e8dc52c6242e6aa208f44870a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f11f2b7e8dc52c6242e6aa208f44870a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>查询树莓派的IP地址</b></h2><p>还记得直接查询网络连接的方法吗，在将树莓派的网线插到笔记本的PC端口后再查询一次。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-ed64cb8e16613badaa35c538356139ba_b.jpg\" data-size=\"normal\" data-rawwidth=\"464\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb\" width=\"464\" data-original=\"https://pic3.zhimg.com/v2-ed64cb8e16613badaa35c538356139ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;464&#39; height=&#39;480&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"464\" data-rawheight=\"480\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"464\" data-original=\"https://pic3.zhimg.com/v2-ed64cb8e16613badaa35c538356139ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-ed64cb8e16613badaa35c538356139ba_b.jpg\"/><figcaption>共享以太网给树莓派后的网络连接状况</figcaption></figure><p>可以看到，在我们之前记的第一项接口地址之前又多了一项，也就是现在用红框框出来的。期中黄色框框出来的就是通过以太网形式连接到我们的共享网络中的设备的 IP 地址，也就是我们树莓派的 IP。</p><h2><b>远程登陆树莓派</b></h2><p>连接完成之后的操作又同<a href=\"https://zhuanlan.zhihu.com/p/35161674\" class=\"internal\">树莓派3B无显示屏安装系统及远程登录</a> 文中所述，在通过 PuTTY 设置好树莓派后。我们就可以使用 Windows 的远程登陆程序来远程登陆我们的树莓派了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-58c2ce7c285ab43190bd5081abdcf788_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"601\" class=\"origin_image zh-lightbox-thumb\" width=\"786\" data-original=\"https://pic1.zhimg.com/v2-58c2ce7c285ab43190bd5081abdcf788_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;786&#39; height=&#39;601&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"786\" data-rawheight=\"601\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"786\" data-original=\"https://pic1.zhimg.com/v2-58c2ce7c285ab43190bd5081abdcf788_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-58c2ce7c285ab43190bd5081abdcf788_b.jpg\"/></figure><p>(o゜▽゜)o☆[BINGO!]</p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/35161674\" class=\"internal\">树莓派3B无显示屏安装系统及远程登录</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/u013151320/article/details/51059328\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">树莓派网线直连笔记本电脑</a></li></ul>", 
            "topic": [
                {
                    "tag": "树莓派（Raspberry Pi）", 
                    "tagLink": "https://api.zhihu.com/topics/19737690"
                }
            ], 
            "comments": [
                {
                    "userName": "冰河的鱼", 
                    "userLink": "https://www.zhihu.com/people/d965d93c8626e0ce96b76dfb3d33318d", 
                    "content": "做法和你的一样呀。可是还是没有树莓派的IP地址出来，是什么问题呢", 
                    "likes": 1, 
                    "childComments": []
                }, 
                {
                    "userName": "秋风知我意", 
                    "userLink": "https://www.zhihu.com/people/a98ea90317f676f37e2abe78ba8579ab", 
                    "content": "我那个共享后，网络是未识别，putty之后好像是找不到", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "fluing", 
                            "userLink": "https://www.zhihu.com/people/61e0dcb4ca5f5b5301c6290862e34971", 
                            "content": "一样啊，老哥怎么解决", 
                            "likes": 0, 
                            "replyToAuthor": "秋风知我意"
                        }, 
                        {
                            "userName": "秋风知我意", 
                            "userLink": "https://www.zhihu.com/people/a98ea90317f676f37e2abe78ba8579ab", 
                            "content": "我用手机开热点，让树莓派连然后电脑也连我手机，貌似就可以，不过需要一个WIFI的配置文件", 
                            "likes": 0, 
                            "replyToAuthor": "fluing"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37459552", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 2, 
            "title": "代码是如何控制硬件的？", 
            "content": "<h2><b>代码</b></h2><p>代码是我们是用电脑的键盘来输入的指令，每一个指令都对应一个ASCII码，而这里的ASCII码就是有序的电压的高低（或电流的有无，下面只提电压的高低），即我们输入的是电压的高低，你所看到代码是这些电压的高低控制显示器所显示的图像，其实电脑也不知道它是什么，只知道这样显示。</p><p><b>结论：代码其实就是存储在存储器（内存、硬盘或者闪存等等）中有序的电压的高低。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>编译</b></h2><p>编译是一个有序的电压的高低向另一种有序的电压高低的一种转换过程，下面以52单片机为例，我们编译是从表示ASCII码的那种有序电压高低转换为52单片机能够识别的另一种规定好的有序电压高低，即表示HEX文件的电压高低。</p><p><b>结论：编译出的结果还是电脑中存储的有序电压高低。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>到单片机烧录</b></h2><p>接下俩就是烧录，理解了上面两点就很容易理解下面的内容，烧录就是电脑中的有序电压高低通过数据线传输到单片机中的ROM中。接下来ROM就可以释放其中的电压来控制外围的电路。</p><p><b>总结：从代码的编辑到最后对电路的控制都是电压在起作用，只是为了方面我们而给我们展现的形式不一样而已，而其本质都是电压，这样也就不存在转换。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>理解这句话</b>：世界上没有软件，软件只是对硬件的一种反映，就像意识是对世界的一种反映是一样的！相信这样就很容易理解了。</p><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>参考资料：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/R9Gr9bzT2QhA-ReHGNnAFQ\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">代码是如何控制硬件的？</a></li></ul>", 
            "topic": [
                {
                    "tag": "编码", 
                    "tagLink": "https://api.zhihu.com/topics/19590100"
                }
            ], 
            "comments": [
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/94b2fb0c2d5410ed578a752dac486648", 
                    "content": "我又来啦⊙ω⊙", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37440093", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 9, 
            "title": "数据结构知识梳理", 
            "content": "<h2><b>复习重点</b></h2><ul><li>邻接矩阵</li><li>最小生成树</li><li>折半排序</li><li>B-树</li><li>二叉排序树</li><li>平衡二叉树</li><li>快速排序</li><li>二叉树的遍历</li></ul><h2><b>知识点</b></h2><ul><li>数据结构通常有如下四种基本数据类型：集合、线性结构、树形结构、图形结构（网状结构）</li><li>广义表的表元素有广义表和原子。</li><li>递归函数的执行是通过栈来实现的。实际上，借助栈也可以将一个递归算法（函数）改写为一个非递归算法（函数）。</li><li>邻接多重表只可以存储无向图，不可以存储有向图。</li><li>二叉树不是树的原因：</li></ul><ol><li>二叉树可以为空，但树不能为空</li><li>二叉树中每个元素都恰好有两棵子树（其中一个或者两种可能为空）。而树中每个元素可有若干子树</li><li>二叉树中每个元素的子树都是有序的，也就是说，可以用左、右子数来区别。（不是树的根本原因）</li></ol><ul><li>树、森林、二叉树各种遍历方式的对应情况：</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7B%E6%A0%91%7D+%26+%7B%E6%A3%AE%E6%9E%97%7D+%26+%7B%E4%BA%8C%E5%8F%89%E6%A0%91%7D%5C%5C+%5Chline+%E5%85%88%E6%A0%B9%E9%81%8D%E5%8E%86+%26+%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86+%26+%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86+%5C%5C+%5Chline+%E5%90%8E%E6%A0%B9%E6%8E%92%E5%BA%8F+%26+%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%26+%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|c|c|} \\hline \\text{树} &amp; {森林} &amp; {二叉树}\\\\ \\hline 先根遍历 &amp; 先序遍历 &amp; 先序遍历 \\\\ \\hline 后根排序 &amp; 中序遍历&amp; 中序遍历 \\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3fcae78635bbcf3d0daf946e602fb8dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-3fcae78635bbcf3d0daf946e602fb8dd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic2.zhimg.com/v2-3fcae78635bbcf3d0daf946e602fb8dd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3fcae78635bbcf3d0daf946e602fb8dd_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-382d7cc62f7f677fa72004f4c9865733_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic4.zhimg.com/v2-382d7cc62f7f677fa72004f4c9865733_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic4.zhimg.com/v2-382d7cc62f7f677fa72004f4c9865733_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-382d7cc62f7f677fa72004f4c9865733_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>二叉树的性质：</li></ul><ol><li>在二叉树的第i层上至多有 <img src=\"https://www.zhihu.com/equation?tex=2%5E%7B%28i-1%29%7D\" alt=\"2^{(i-1)}\" eeimg=\"1\"/> 个节点( <img src=\"https://www.zhihu.com/equation?tex=i%5Cgeq1\" alt=\"i\\geq1\" eeimg=\"1\"/> )。</li><li>深度为k的二叉树至多有 <img src=\"https://www.zhihu.com/equation?tex=2%5Ek-1\" alt=\"2^k-1\" eeimg=\"1\"/> 个节点( <img src=\"https://www.zhihu.com/equation?tex=k%5Cgeq1\" alt=\"k\\geq1\" eeimg=\"1\"/> )。</li><li>对任何一颗二叉树T，如果其终端节点数为 <img src=\"https://www.zhihu.com/equation?tex=n_0\" alt=\"n_0\" eeimg=\"1\"/> ，度为2的节点数为 <img src=\"https://www.zhihu.com/equation?tex=n_2+\" alt=\"n_2 \" eeimg=\"1\"/> ，则 <img src=\"https://www.zhihu.com/equation?tex=n_0%3Dn_2%2B1+\" alt=\"n_0=n_2+1 \" eeimg=\"1\"/> 。</li><li>具有n个结点的完全二叉树的深度为 <img src=\"https://www.zhihu.com/equation?tex=%5Clfloor+log_2n+%5Crfloor+%2B+1\" alt=\"\\lfloor log_2n \\rfloor + 1\" eeimg=\"1\"/> 。</li><li>如果对一颗有n个结点的完全二叉树（其深度为 <img src=\"https://www.zhihu.com/equation?tex=%5Clfloor+log_2n+%5Crfloor+%2B+1+\" alt=\"\\lfloor log_2n \\rfloor + 1 \" eeimg=\"1\"/> ）的结点按层序编号（从第1层到第 <img src=\"https://www.zhihu.com/equation?tex=%5Clfloor+log_2n+%5Crfloor+%2B+1\" alt=\"\\lfloor log_2n \\rfloor + 1\" eeimg=\"1\"/> 层，每层从左到右），则对任一结点i( <img src=\"https://www.zhihu.com/equation?tex=1%5Cleq+i+%5Cleq+n\" alt=\"1\\leq i \\leq n\" eeimg=\"1\"/> )，有：</li></ol><ul><li>如果i=1，则结点i是二叉树的根，无双亲；如果 i&gt;1，则其双亲时结点 <img src=\"https://www.zhihu.com/equation?tex=%5Clfloor+%5Cfrac%7Bi%7D%7B2%7D+%5Crfloor\" alt=\"\\lfloor \\frac{i}{2} \\rfloor\" eeimg=\"1\"/> 。</li><li>如果2i&gt;n，则结点i无左孩子（结点i为叶子结点）；否则其左孩子是结点2i。</li><li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1。</li><li>十字链表是有向图的一种存储方法，它实际上是邻接表与逆邻接表的结合，即把每一条边的边结点分别组织到以弧尾顶点为头结点的链表和以弧头顶点为头顶点的链表中。</li><li>含有 n 个结点的二叉链表中有 n+1 个空链域。</li><li>二叉排序树的查找性能：</li></ul><ol><li>最好情况，二叉排序树的深度同折半查找的判定树，ASL＝ <img src=\"https://www.zhihu.com/equation?tex=log_2%28n%2B1%29-1\" alt=\"log_2(n+1)-1\" eeimg=\"1\"/> （树的深度）。</li><li>最坏情况，就相当于是顺序查找， ASL = <img src=\"https://www.zhihu.com/equation?tex=%5Cfrac%7Bn%2B1%7D%7B2%7D\" alt=\"\\frac{n+1}{2}\" eeimg=\"1\"/> </li><li>随机情况， ASL＝O(logn)</li></ol><ul><li>折半查找的效率比顺序查找高，但是折半查找只适用于有序表，且限于顺序存储结构（对线性链表无法有效地进行折半查找）。</li><li>排序算法的效率</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7B%E7%AE%97%E6%B3%95%7D+%26+%7B%E6%9C%80%E5%9D%8F%E6%83%85%E5%86%B5%E4%B8%8B%7D+%26+%7B%E5%B9%B3%E5%9D%87%E6%83%85%E5%86%B5%E4%B8%8B%7D%5C%5C+%5Chline+%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F+%26+O%28n%5E2%29+%26+O%28n%5E2%29+%5C%5C+%5Chline+%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F+%26+O%28n%5E2%29+%26+O%28n%5E2%29+%5C%5C+%5Chline+%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F+%26+O%28n%5E2%29+%26+O%28nlogn%29+%5C%5C+%5Chline+%E5%A0%86%E6%8E%92%E5%BA%8F+%26+O%28nlogn%29+%26+O%28nlogn%29+%5C%5C+%5Chline+%E4%BA%8C%E5%88%86%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F+%26+O%28nlogn%29+%26+O%28nlogn%29+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|c|c|} \\hline \\text{算法} &amp; {最坏情况下} &amp; {平均情况下}\\\\ \\hline 插入排序 &amp; O(n^2) &amp; O(n^2) \\\\ \\hline 冒泡排序 &amp; O(n^2) &amp; O(n^2) \\\\ \\hline 快速排序 &amp; O(n^2) &amp; O(nlogn) \\\\ \\hline 堆排序 &amp; O(nlogn) &amp; O(nlogn) \\\\ \\hline 二分归并排序 &amp; O(nlogn) &amp; O(nlogn) \\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><ul><li>深度优先遍历图使用了数据结构栈，广度优先遍历图使用了数据结构队列。</li><li>关键路径是指在只有一个源点和汇点的有向无环图中源点至汇点的权值之和最大的路径。</li><li>哈希表的查找效率取决于①哈希函数；②处理冲突的方法；③哈希表的装填因子。</li><li>哈希表中处理冲突的方法有直接定址法、数字分析法、平方取中法、折叠法、除留余数法、随机数法。</li><li>图的存储结构有数组表示法、邻接表、十字链表、邻接多重表。</li></ul><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }
            ], 
            "comments": [
                {
                    "userName": "爱笑的橙子", 
                    "userLink": "https://www.zhihu.com/people/0f3e2cd715ce02f2dab3e4cc43cdaffb", 
                    "content": "应对期末考试还有点用处", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37437390", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 5, 
            "title": "JAVA知识梳理", 
            "content": "<h2><b>第一章 概述</b></h2><p><b>1.2 Java语言的特点</b></p><ol><li>简单性：摒弃了C++中的头文件、指针、结构、多继承等特性，并且引入“垃圾回收站”机制自动进行内存管理。更易于学习。</li><li>面向对象：除了基本数据类型以外，一切都是对象。</li><li>分布性：可以处理TCP/IP协议，支持网络编程。</li><li>解释性：源程序经过编译后生成的类文件，由字节码组成。而字节码是一种虚拟的机器指令代码，不针对特定的机器。运行时，使用JAVA解释程序（JVM）负责把字节码解释成本地机器指令代码。</li><li>健壮性：JAVA摒弃了C++中的指针数据类型，不允许对内存进行直接操作。并加入了内存自动管理机制，防止了程序员对内存进行管理时出现错误。</li><li>安全性：JAVA语言设计了多层安全机制。</li><li>体系结构中独立：JAVA源程序编译后生成的类文件与平台无关。</li><li>可移植性：由于体系结构中独立性，使得JAVA在不同的平台下的语言文本完全统一，数据类型所占空间大小完全一样。且JAVA标准类库可以访问不同的操作系统。</li><li>高效性：JAVA语言比典型的解释性语言和脚本语言运行速度快。</li><li>多线程：程序中多个任务并发执行。</li><li>动态性：类文件只有在必要时，才被加载，便于新文件的增添。</li></ol><p><b>1.3 Java语言与面向对象编程</b></p><ol><li>封装：使用类作为数据及其相关操作的封装体。用户在是使用一个已定义类的对象时，无需了解其内部的实际工作流程。</li><li>继承：通过继承接口对原有类添加新类，提高了代码的重用性。</li><li>多态：通过类继承过程中的方法覆盖、接口实现以及方法调用时的动态绑定来实现多态，使相同的消息被不同的对象接收处理。</li></ol><p><b>1.6.1 编辑、编译和运行Java应用程序</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-278c954a3d07a8fd6b9309a334fc9c23_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"407\" class=\"content_image\" width=\"200\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;200&#39; height=&#39;407&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"200\" data-rawheight=\"407\" class=\"content_image lazy\" width=\"200\" data-actualsrc=\"https://pic4.zhimg.com/v2-278c954a3d07a8fd6b9309a334fc9c23_b.jpg\"/></figure><h2><b>第二章 Java语言编程基础</b></h2><p><b>2.2 基本数据类型</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-a5b17b9084ab8a14739467c2eb9c5686_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1024\" class=\"origin_image zh-lightbox-thumb\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-a5b17b9084ab8a14739467c2eb9c5686_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2560&#39; height=&#39;1024&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2560\" data-rawheight=\"1024\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2560\" data-original=\"https://pic3.zhimg.com/v2-a5b17b9084ab8a14739467c2eb9c5686_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-a5b17b9084ab8a14739467c2eb9c5686_b.jpg\"/></figure><p><b>第三章 方法</b></p><p><b>3.1 定义方法</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">修饰符</span> <span class=\"n\">返回类型</span> <span class=\"nf\">方法名</span><span class=\"o\">(</span><span class=\"n\">形式参数表</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">方法体</span>\n<span class=\"o\">}</span> </code></pre></div><ul><li>访问控制修饰符：</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7B%E4%BF%AE%E9%A5%B0%E7%AC%A6%7D+%26+%7B%E8%A7%A3%E9%87%8A%7D+%26+%7B%E5%BD%93%E5%89%8D%E7%B1%BB%7D+%26+%7B%E5%90%8C%E4%B8%80%E5%8C%85%E5%86%85%7D+%26+%7B%E5%AD%90%E5%AD%99%E7%B1%BB%7D+%26+%7B%E5%85%B6%E4%BB%96%E5%8C%85%7D%5C%5C+%5Chline+default+%26+%E9%BB%98%E8%AE%A4%E7%B1%BB+%26+Y+%26+Y+%26+N+%26+N%5C%5C+%5Chline+private+%26+%E7%A7%81%E6%9C%89%E7%B1%BB+%26+Y+%26+N+%26+N+%26+N%5C%5C+%5Chline+%5Chline+public+%26+%E5%85%B1%E6%9C%89%E7%B1%BB+%26+Y+%26+Y+%26+Y+%26+Y%5C%5C+%5Chline+protected+%26+%E5%8F%97%E4%BF%9D%E6%8A%A4%E7%B1%BB+%26+Y+%26+Y+%26+Y+%26+N+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|c|c|c|} \\hline \\text{修饰符} &amp; {解释} &amp; {当前类} &amp; {同一包内} &amp; {子孙类} &amp; {其他包}\\\\ \\hline default &amp; 默认类 &amp; Y &amp; Y &amp; N &amp; N\\\\ \\hline private &amp; 私有类 &amp; Y &amp; N &amp; N &amp; N\\\\ \\hline \\hline public &amp; 共有类 &amp; Y &amp; Y &amp; Y &amp; Y\\\\ \\hline protected &amp; 受保护类 &amp; Y &amp; Y &amp; Y &amp; N \\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><ul><li>每个源文件中最多只能有一个public 接口或类（包含枚举类型，枚举类型是一种特殊的类），且该共有类的名字要和源文件的文件名一致。</li><li>private变量并不是不可以改变的，可以通过不是private的类方法接口对它进行修改。要想使一个类变成不可变类就必须将所有数据成员声明为私有化，并且设置所有除了构造方法外的方法不能对数据成员值进行修改。</li><li>非访问修饰符</li></ul><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7B%E4%BF%AE%E9%A5%B0%E7%AC%A6%7D+%26+%7B%E8%A7%A3%E9%87%8A%7D+%26+%7B%E8%AF%B4%E6%98%8E%7D%5C%5C+%5Chline+static+%26+%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B+%26+%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E3%80%82%5C%5C+%5Chline+final+%26+%E5%B8%B8%E9%87%8F%E7%B1%BB%E5%9E%8B+%26+final%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%B1%BB%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%EF%BC%8C%E4%BF%AE%E9%A5%B0%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8D%E8%83%BD%E8%A2%AB%E7%BB%A7%E6%89%BF%E7%B1%BB%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BF%AE%E9%A5%B0%E7%9A%84%E5%8F%98%E9%87%8F%E4%B8%BA%E5%B8%B8%E9%87%8F%EF%BC%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E4%BF%AE%E6%94%B9%E3%80%82%5C%5C+%5Chline+abstract+%26+%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9E%8B+%26+%E7%94%A8%E6%9D%A5%E5%88%9B%E5%BB%BA%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E3%80%82%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|c|c|} \\hline \\text{修饰符} &amp; {解释} &amp; {说明}\\\\ \\hline static &amp; 静态类型 &amp; 用来创建静态变量和静态方法。\\\\ \\hline final &amp; 常量类型 &amp; final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不能被修改。\\\\ \\hline abstract &amp; 抽象类型 &amp; 用来创建抽象类和抽象方法。\\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><p><b>3.2 调用方法</b></p><ul><li>通过 方法名(实际参数表) 的形式来调用方法。</li></ul><p><b>3.3 参数传递</b></p><ul><li>Java只有值传递，没有引用传递。不能在子方法中通过对形参的改变改变相应的实参。</li></ul><p><b>3.5 方法重载</b></p><ul><li>举个例子</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Overload</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">){</span>\n        <span class=\"kt\">short</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"sc\">&#39;a&#39;</span><span class=\"o\">;</span>\n        <span class=\"kt\">byte</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">4</span><span class=\"o\">;</span>\n        <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span> <span class=\"c1\">//输出: in method(short)\n</span><span class=\"c1\"></span>        <span class=\"n\">method</span><span class=\"o\">(</span><span class=\"n\">b</span><span class=\"o\">);</span> <span class=\"c1\">//输出: in method(byte)\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">method</span><span class=\"o\">(</span><span class=\"kt\">short</span> <span class=\"n\">x</span><span class=\"o\">){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;in method(short)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">method</span><span class=\"o\">(</span><span class=\"kt\">byte</span> <span class=\"n\">x</span><span class=\"o\">){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;in method(byte)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>　　</code></pre></div><h2><b>第四章 类和对象（考1道大题）</b></h2><p><b>4.2 类和对象的定义</b></p><ul><li>类的定义</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">类型</span> <span class=\"o\">{</span>\n    <span class=\"n\">类体</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>对象的定义有如下两种方法</li></ul><p>第一种方法：</p><p>1、先定义一个类 </p><div class=\"highlight\"><pre><code class=\"language-text\">类名 对象名</code></pre></div><p>2、再创建这个类的对象</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">new</span> <span class=\"n\">类名</span><span class=\"o\">()</span></code></pre></div><p>第二种方法：</p><div class=\"highlight\"><pre><code class=\"language-text\">类名 对象名 = new 类名()</code></pre></div><p>对象创建完后，通过 <b>对象名.成员</b> 的方式来访问对象。</p><p><b>4.3 对象与基本数据类型变量的区别</b></p><ul><li>对于对象的赋值，是对对象所指向的内存单元的指针的赋值。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-0b8a5dc0c63c528c8c5c6f66e392bc60_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2048\" data-rawheight=\"1088\" class=\"origin_image zh-lightbox-thumb\" width=\"2048\" data-original=\"https://pic1.zhimg.com/v2-0b8a5dc0c63c528c8c5c6f66e392bc60_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2048&#39; height=&#39;1088&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2048\" data-rawheight=\"1088\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2048\" data-original=\"https://pic1.zhimg.com/v2-0b8a5dc0c63c528c8c5c6f66e392bc60_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-0b8a5dc0c63c528c8c5c6f66e392bc60_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>同样，与基本数据类型变量不同，传递对象不是将对象本身的值传递给形参，而是将对对象的引用值传递给形参。即在方法体内对形参进行修改也会影响实参的值。类似于引用传递。</li></ul><p><b>4.4 静态变量和静态方法</b></p><ul><li>对于静态变量的声明是应该出现在类里而不是类的函数里。</li><li>静态成员（变量）属于整个类，而不是局限于该类的特定对象。</li><li>静态变量可以直接通过类名访问，即使没有创建该类的任何对象。举个例子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">StaticVariable</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">){</span>\n        <span class=\"n\">B</span> <span class=\"n\">b1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n        <span class=\"n\">B</span> <span class=\"n\">b2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">B</span><span class=\"o\">();</span>\n        <span class=\"n\">B</span><span class=\"o\">.</span><span class=\"na\">i</span><span class=\"o\">++;</span> <span class=\"c1\">// B.i = 21\n</span><span class=\"c1\"></span>        <span class=\"n\">b1</span><span class=\"o\">.</span><span class=\"na\">i</span><span class=\"o\">++;</span> <span class=\"c1\">// b1.i = 22; b2.i = 22;\n</span><span class=\"c1\"></span>        <span class=\"n\">b1</span><span class=\"o\">.</span><span class=\"na\">j</span><span class=\"o\">++;</span> <span class=\"c1\">// b1.j = 31; b2.j = 30;\n</span><span class=\"c1\"></span>        <span class=\"c1\">//依次输出各次操作后i的值。\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n\n    <span class=\"kd\">class</span> <span class=\"nc\">B</span><span class=\"o\">{</span>\n        <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">20</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">30</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>方法体和初始化块内声明的变量（也就是局部变量）不能使用 static 关键字修饰。</li><li>与静态变量一样，对于静态方法的使用也可以在未创建该类的任何对对象的条件下，直接通过类名进行访问。举个例子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">StaticMethod</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">){</span>\n        <span class=\"n\">Cat</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Cat</span><span class=\"o\">.</span><span class=\"na\">birthCat</span><span class=\"o\">();</span>\n        <span class=\"n\">Cat</span><span class=\"o\">.</span><span class=\"na\">getCat</span><span class=\"o\">().</span><span class=\"na\">age</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;CAT1 age =&#34;</span> <span class=\"o\">+</span> <span class=\"n\">c</span><span class=\"o\">.</span><span class=\"na\">age</span><span class=\"o\">);</span>    <span class=\"c1\">//输出 CAT1 age = 0\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;CAT2 age =&#34;</span> <span class=\"o\">+</span> <span class=\"n\">Cat</span><span class=\"o\">.</span><span class=\"na\">getCat</span><span class=\"o\">().</span><span class=\"na\">age</span><span class=\"o\">);</span>    <span class=\"c1\">//输出: CAT2 age = 1\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"kd\">class</span> <span class=\"nc\">Cat</span><span class=\"o\">{</span>\n        <span class=\"kd\">static</span> <span class=\"n\">Cat</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">nee</span> <span class=\"nf\">Cat</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">age</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"kd\">static</span> <span class=\"n\">Cat</span> <span class=\"nf\">birthCat</span><span class=\"o\">(){</span>\n            <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n        <span class=\"kd\">static</span> <span class=\"n\">Cat</span> <span class=\"nf\">getCat</span><span class=\"o\">(){</span>\n            <span class=\"k\">return</span> <span class=\"n\">c</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>与非静态方法（实例方法）一样，静态方法可以创建和访问其所属类的对象。</li></ul><p><b>4.5 数据成员的初始化</b></p><ul><li>在方法体或者初始化块内声明的变量是局部变量。</li><li>Java没有为局部变量提供默认值，所以局部变量必须先声明后使用。</li><li>静态变量可以写在操作语句的后面进行声明，因为静态变量的构造是首先执行的。如下情况就是正确的：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">j</span><span class=\"o\">);</span>\n    <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">5</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">f</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">x</span><span class=\"o\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">x</span> <span class=\"o\">*</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>构造方法的方法名必须与类名一致，并且不能有返回类型（包括void）。如果某个方法名与类名一样，但是拥有返回类型，那么它就是一个普通方法，不是构造方法。</p><ul><li>不带任何参数的构造方法（无参构造方法）叫做默认构造方法。</li><li>初始化静态变量的语句只会在第一次使用该类的时候执行，并且静态变量的初始化作为该类的优先执行语句，要比普通变量优先执行。</li><li>Java不允许定义静态构造方法，而是使用静态初始化块的方式来执行。但静态初始化块不能出现在任何方法体内。 举个例子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">StaticInitBlock</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;main()&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">Tools</span><span class=\"o\">.</span><span class=\"na\">t1</span><span class=\"o\">.</span><span class=\"na\">f</span><span class=\"o\">(</span><span class=\"n\">4</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">static</span> <span class=\"n\">Tools</span> <span class=\"n\">ts</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tools</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Tools</span><span class=\"o\">{</span>\n    <span class=\"kd\">static</span> <span class=\"n\">Tool</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tool</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"kd\">static</span><span class=\"o\">{</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;进入静态初始化块&#34;</span><span class=\"o\">);</span>\n        <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tool</span><span class=\"o\">(</span><span class=\"n\">11</span><span class=\"o\">);</span>\n        <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tool</span><span class=\"o\">(</span><span class=\"n\">22</span><span class=\"o\">);</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;退出静态初始化块&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">static</span> <span class=\"n\">Tool</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tool</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n    <span class=\"n\">Tools</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Tools()&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Tool</span><span class=\"o\">{</span>\n    <span class=\"n\">Tool</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Tool(&#34;</span> <span class=\"o\">+</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"s\">&#34;)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;f(&#34;</span> <span class=\"o\">+</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"s\">&#34;)&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"c1\">//输出：\n</span><span class=\"c1\">//Tool(1)\n</span><span class=\"c1\">//进入静态初始化块\n</span><span class=\"c1\">//Tool(11)\n</span><span class=\"c1\">//Tool(22)\n</span><span class=\"c1\">//退出静态初始化块\n</span><span class=\"c1\">//Tool(2)\n</span><span class=\"c1\">//Tools()\n</span><span class=\"c1\">//main()\n</span><span class=\"c1\"></span><span class=\"o\">//</span><span class=\"n\">f</span><span class=\"o\">(</span><span class=\"n\">4</span><span class=\"o\">)</span></code></pre></div><p>如果初始化块定义在某个数据成员变量之前，那么在该初始化块中这个数据成员除了能用作左操作数被赋值外，不能用作其他用途，不能出现在赋值符号的右边。</p><ul><li>添加包的方法，是在文件的起始位置使用 package 语句（包声明语句），语法形式为： package packagename；</li><li>Java默认包是 java.lang，提供利用 Java 编程语言进行程序设计的基础类。</li><li>使用关键字 this 在一个构造方法中调用其所属类的另一个构造方法时，传递的参数不能是关键字 this 或当前对象的实例成员，因为此时当前的对象并没有完成创建。举个例子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">A</span><span class=\"o\">(){</span>\n        <span class=\"k\">this</span><span class=\"o\">();</span>    <span class=\"c1\">//错误，参数不能时当前对象的示例成员\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">A</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"o\">){</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2><b>第五章 继承和多态</b></h2><p><b>5.1 继承简介</b></p><ul><li>Java语言处于安全、可靠性方面考虑，仅支持单继承，要实现多继承通过需要接口等间接实现。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-18296287c8e00afcbb76103cbb27a19b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2368\" data-rawheight=\"1152\" class=\"origin_image zh-lightbox-thumb\" width=\"2368\" data-original=\"https://pic4.zhimg.com/v2-18296287c8e00afcbb76103cbb27a19b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2368&#39; height=&#39;1152&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2368\" data-rawheight=\"1152\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2368\" data-original=\"https://pic4.zhimg.com/v2-18296287c8e00afcbb76103cbb27a19b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-18296287c8e00afcbb76103cbb27a19b_b.jpg\"/></figure><p><b>5.2 继承和子类</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">子类名</span> <span class=\"kd\">extends</span> <span class=\"n\">父类名</span><span class=\"o\">{</span>\n    <span class=\"n\">定义子类新成员</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>派生时，子类自动获取父类的所有成员，但是构造方法除外，构造方法不能被子类继承。</li><li>当子类和父类不在同一个包中时，父类成员被子类继承时，父类的私有成员和具有包访问权限的成员不能在子类中访问。</li><li>实际编程时，我们通常把数据成员声明为私有的，方法声明为公有的。</li><li>虽然子类覆盖了父类的构造方法（注意：构造方法不能被继承），但是在创建子类对象时，系统还是会先调用父类的构造方法，以初始化从父类继承过来的数据成员，再调用子类的构造方法。</li><li>当子类没有显示定义构造方法时， 系统会自动生成一个默认构造方法，并在其中调用父类的默认构造方法。当父类没有默认构造方法时，我们需要在子类中通过 super(参数) 的形式手动显示调用父类的构造方法。</li><li>与关键字 this 相同，使用 super 调用父类构造方法时传递的参数不能是关键字 this 或当前对象的示例对象，因为此时当前的对象并没有完成创建（因为构造方法会优先执行）。</li></ul><p><b>5.6 多态与动态绑定</b></p><ul><li>Java的多态性通过动态绑定来实现（多态也称为动态绑定），通过使用方法覆盖可以在具有继承关系的多个类中定义名称相同但是操作不同的多个方法。举个例子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Polymorphism</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">){</span>\n        <span class=\"n\">Cat</span> <span class=\"n\">cat</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"o\">();</span>\n        <span class=\"n\">Dog</span> <span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"o\">();</span>\n        <span class=\"n\">makeSpeak</span><span class=\"o\">(</span><span class=\"n\">cat</span><span class=\"o\">);</span>\n        <span class=\"n\">makeSpeak</span><span class=\"o\">(</span><span class=\"n\">Dog</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">makeSpeak</span><span class=\"o\">(</span><span class=\"n\">Animal</span> <span class=\"n\">animal</span><span class=\"o\">){</span>\n        <span class=\"n\">animal</span><span class=\"o\">.</span><span class=\"na\">speak</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Dog</span> <span class=\"kd\">extends</span> <span class=\"n\">Animal</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">speak</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">prinltn</span><span class=\"o\">(</span><span class=\"s\">&#34;Woo&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Cat</span> <span class=\"kd\">extends</span> <span class=\"n\">Animal</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">speak</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Miao&#34;</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">Animal</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">speak</span><span class=\"o\">(){</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Animal speak&#34;</span><span class=\"o\">)</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>进行方法覆盖时，不能降低其访问权限，即子类中该方法的访问权限不能比父类低。</li></ul><p><b>5.7 抽象类和抽象方法</b></p><ul><li>抽象类的定义，举个列子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">abstract</span> <span class=\"kd\">class</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">fun</span><span class=\"o\">(){}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>抽象方法的定义：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">abstract</span> <span class=\"n\">返回类型</span> <span class=\"nf\">方法名</span><span class=\"o\">(</span><span class=\"n\">形式参数表</span><span class=\"o\">);</span></code></pre></div><ul><li>抽象类只能被用来做继承，不能使用 new 关键字来创建其对象。 </li><li>静态方法和用 final 关键字修饰的方法不能使用 abstract 关键字修饰。</li><li>如果一个子类继承了一个抽象类作为父类，那么他必须是实现抽象父类中的所有抽象方法，或者将它自己也声明为抽象类。</li></ul><p><b>5.8 接口</b></p><ul><li>为了是Java实现多继承的效果，需要使用接口来实现。</li><li>接口中的方法都是公共抽象方法，数据成员都是公共静态常量，接口中不能包含构造方法。定义接口时必须使用关键字 interface ,不能用 class。举个列子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">interface</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">NUM</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>    <span class=\"c1\">//公用静态常量，关键字 public, static, final 一般省略。\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"nf\">fun</span><span class=\"o\">();</span>     <span class=\"c1\">//公用抽象方法，关键字 public, abstract 一般省略。\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><ul><li>接口中的所有方法都是抽象的，要实现一个接口，必须使用关键字 implements。如果没有实行按该接口中的全部方法，该类就要声明为抽象类，用 abstract 关键字修饰。</li><li>由于接口中的方法都是公用的，所以在继承类中实现它们时，必须用  public 修饰， 否则就相当于降低了访问权限，导致错误。举个列子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">interface</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"o\">();</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">g</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">abstract</span> <span class=\"n\">B</span> <span class=\"kd\">implements</span> <span class=\"n\">A</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"o\">(){}</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>多继承的方式，举个列子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">class</span> <span class=\"nc\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span> <span class=\"kd\">implements</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">{</span>\n    <span class=\"o\">...</span>\n<span class=\"o\">}</span></code></pre></div><ul><li>多继承时类的重载，举个列子：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">interface</span> <span class=\"nc\">A</span><span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">NUM</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"o\">();</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">interface</span> <span class=\"nc\">B</span><span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">NUM</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">f</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">C</span><span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"o\">(){}</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">class</span> <span class=\"nc\">D</span> <span class=\"kd\">extends</span> <span class=\"n\">C</span> <span class=\"kd\">implements</span> <span class=\"n\">A</span><span class=\"o\">,</span> <span class=\"n\">B</span><span class=\"o\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">A</span><span class=\"o\">.</span><span class=\"na\">NUM</span><span class=\"o\">;</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">f</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">){</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> \n<span class=\"o\">}</span></code></pre></div><p>在此方法中，接口B 和接口A 的 f( ) 方法的参数列表都不相同，是一个重载方法， D的操作时正确的。 但是当两个接口中定义的方法仅仅只是返回类型不同，参数列表时相同的时候，就不是重载了（重载是指在一个类里面，方法名相同，参数不同，与返回类型无关）。D 中就不能只定义一个类来实现这两个接口了。</p><p><b>5.9 类Object</b></p><ul><li>方法 equals 用来比较两个对象应用是否应用同一个对象，相当于 == 号，调用方法如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">object1.equals(object2)</code></pre></div><ul><li>方法 toString 返回一个代表当前对象本身信息的字符串。默认情况下返回的时该对象所属类名、@符号和该对象哈希码的无符号十六进制表示组成。另外也可以在类内对 toString 方法进行覆盖。</li><li>当把某个对象用于字符串相加或者使用输出函数方法时，系统都会自动调用该对象的 toString 方法将其转换为字符串。</li></ul><h2><b>第六章 数组</b></h2><p><b>6.1 声明和创建数组</b></p><ul><li>数组的声明格式有两种：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">① 数据类型[] 数组名\n② 数组类型 数组名[]</code></pre></div><ul><li>但是一般都使用第一种方法， 如 int[ ] arr；</li><li>另外，在声明数组时，不能指定数组元素的个数，只有在创建数组时才可以声明个数。</li><li>创建数组的格式如下：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">数组名 = new 数组类型[数组元素个数]</code></pre></div><ul><li>另外数组的声明和创建也可以整合到一条语句中：</li></ul><div class=\"highlight\"><pre><code class=\"language-text\">Integer[] intArr = new Integer[5];</code></pre></div><ul><li>数组的初始化操作</li></ul><p><b>6.2 多维数组</b></p><ul><li>多维数组的数组对象可以含有不同数目的元素，即不一定要是“矩形”形状，如下为锯齿数组：</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span><span class=\"o\">[][]</span> <span class=\"n\">arr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">3</span><span class=\"o\">][];</span>\n<span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">0</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">];</span>\n<span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">1</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">2</span><span class=\"o\">];</span>\n<span class=\"n\">arr</span><span class=\"o\">[</span><span class=\"n\">2</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"o\">[</span><span class=\"n\">3</span><span class=\"o\">];</span></code></pre></div><p>6.4 数组与方法</p><h2><b>第七章 字符串</b></h2><ul><li>7.1 类 String</li><li>7.3 </li></ul><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//book.douban.com/subject/6129730/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《Java程序设计（第二版）》刘慧宁 著</a></li></ul><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "小小心", 
                    "userLink": "https://www.zhihu.com/people/f76a9bd7339a824a54c5c9f6c514c114", 
                    "content": "3.3容易对新人完成误解，如果形参是一个实体对象，那么在方法内可以改变对象内的值的", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "小小心", 
                            "userLink": "https://www.zhihu.com/people/f76a9bd7339a824a54c5c9f6c514c114", 
                            "content": "需要看一下jvm里的方法栈，理解变量引用，变量名，抓住这两点就很容易理解了", 
                            "likes": 0, 
                            "replyToAuthor": "小小心"
                        }, 
                        {
                            "userName": "小小心", 
                            "userLink": "https://www.zhihu.com/people/f76a9bd7339a824a54c5c9f6c514c114", 
                            "content": "在方法内操作的是形参的变量名，这个变量和你外部的同名变量不是同一个(注意局部变量的概念以及方法栈概念)，但是如果变量是一个实体对象的话，他们的地址引用是相同的，如果直接操作地址引用指向的堆内存对象，是能够起作用的，但是你把方法内变量的地址指向其他的引用，对方法外的同名变量是没有效果的", 
                            "likes": 0, 
                            "replyToAuthor": "小小心"
                        }
                    ]
                }, 
                {
                    "userName": "小小心", 
                    "userLink": "https://www.zhihu.com/people/f76a9bd7339a824a54c5c9f6c514c114", 
                    "content": "4.4.4.5结合jvm类加载触发的六种条件就很好理解", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/37435149", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 88, 
            "title": "数据库原理知识梳理", 
            "content": "<h2><b>一、DBS系统构成</b></h2><p><b>1、DB的概念与特点：</b></p><ul><li>数据库（DB）是存储在计算机系统内的有结构的数据集合，是相关数据的集合，数据由数据库管理系统统一管理和维护。</li><li>数据（Data）指的是可观察的客观事实，并且有隐含的含义。</li><li>在数据库中，数据与数据的含义（数据名称及说明）同时存储。</li><li>数据的最小存取单位是构成记录的、有名称的、有含义的最小数据单位——数据项。</li><li>定义数据库时，必须定义数据项的逻辑结构。</li><li>在使用数据库时，以数据项名存储数据、更新数据以及查询和使用数据。</li><li>在数据库中，不仅包含数据本身，还包含了数据结构和约束的完整性定义或者描述。这些定义存储在DBMS的目录中，称为数据库的<b>元数据</b>或者<b>数据字典</b>。</li><li>任何合法用户都可以在元数据的帮助下，利用数据项名方面的访问数据库中的数据以及他们的逻辑定义，并使用这些数据，亦即数据可高度共享。</li><li>数据库是存储在计算机系统内的有结构的数据的集合，数据是由数据库管理系统管理的。</li></ul><p><b>2、DBS特点与组成要素：</b></p><ul><li>DBS是指在计算机系统中引入数据库后的数据构成，由计算机硬件、操作系统、DBMS、DB、应用程序和用户以及数据库开发和管理人员等组成。</li><li>数据库系统区别于传统文件处理系统的最重要特征是引入了数据库这个概念，以及产生数据库管理系统。</li><li>与文件系统相比，DBS有如下四个主要特点：</li><ul><li><b>整体数据结构化</b>：数据库中的任何数据都是公开的，不属于任何应用，结构是全面的。</li><li><b>数据的共享度高</b>：在显示数据的同时可以显示数据的逻辑结构；整个组织的整体数据被综合考虑，整体数据结构化。可以方面的使用数据和扩充新的应用。</li><li><b>数据的独立性高</b>：数据与数据的结构存储在数据库中，应用程序既不存储数据也不存储数据的逻辑结构。数据与程序相对独立。</li><li><b>高度的数据控制能力</b>：具有较高的数据安全性；较好的数据完整性；较强的并发控制能力；较强的数据恢复能力。</li></ul></ul><p><b>3、DBMS的功能：</b></p><ul><li>数据库管理系统是专门用来实现和维护数据库而建立的通用软件。</li><li>DBMS是操作系统支持下工作的数据管理软件，是支持用户创建和维护数据库的一组程序包。对内负责管理数据库，对外向用户提供一整套命令。用户可以通过命令来创建数据库，定义数据，对数据库中的数据进行各种合法的操作。</li><li>DBMS有如下六种基本功能：</li><ul><li><b>数据定义</b>：用户可以利用数据定义语言（DDL）来方便地定义数据库中数据的逻辑结构。</li><li><b>数据操纵</b>：用户可以利用数据操纵语言（DML）来实现对数据库对数据库中数据的插入、查找、修改或者删除操作。</li><li><b>完整性约束检查</b>：检查数据时候符合一定的规定。</li><li><b>访问控制</b>：通过数据控制语言（DCL）来实现对不同级别用户的访问控制功能。</li><li><b>并发控制</b>：通过只用并发控制功能，可以确保试图更新同一数据的多个用户能够以一种受控的方式完成各自的工作，即避免并发操作时可能带来的数据不一致性。</li><li><b>数据恢复</b>：恢复数据库。</li></ul></ul><p><b>4、DBA的职责</b></p><ul><li>数据库管理员的主要职责有：</li><ul><li>在用户与数据库开发人员之间进行沟通和协调。</li><li>参与数据库设计工作。</li><li>决定数据的完整性约束和不同用户的存取权限。</li><li>保证数据库的正常运行，进行数据库的维护工作。</li><li>提出数据库的重构计划。</li></ul></ul><h2><b>二、DB的三级模式与关系数据模型的实例</b></h2><ul><li>数据的三级模式结构包括<b>外模式</b>、<b>模式</b>和<b>内模式</b>。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5a996779426e404566b1da36d2d16259_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2336\" data-rawheight=\"1184\" class=\"origin_image zh-lightbox-thumb\" width=\"2336\" data-original=\"https://pic2.zhimg.com/v2-5a996779426e404566b1da36d2d16259_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2336&#39; height=&#39;1184&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2336\" data-rawheight=\"1184\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2336\" data-original=\"https://pic2.zhimg.com/v2-5a996779426e404566b1da36d2d16259_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5a996779426e404566b1da36d2d16259_b.jpg\"/></figure><ul><li>模式：也成逻辑模式，是数据库中全体数据在逻辑上的视图。逻辑结构包括数据记录的名称，数据项的名称、类型、域值。通过模式DDL来进行模式的定义。</li><li>数据库中存储的是数据及数据之间的联系。</li><li>Transaction：事务</li><li>数据库是在计算机系统中按照一定的数据模型组织、存储和应用的数据的集合。</li><li>关系数据操作语言（DML）的特点是：操作对象与结果均是 关系、操作的非过程性强 、语言一体化，并且是建立在数学理论的基础上的。</li></ul><h2><b>三、SQL语言的特点</b></h2><ol><li>一体化</li><li>面向集合的操作方式。</li><li>高度非过程化</li><li>两种使用方式，统一的语法结构。</li><li>语言简洁，易学易用。</li></ol><h2><b>四、视图的定义</b></h2><p>视图是从一个或多个关系（基本表或已存在的视图）导出的关系。是数据库系统的一个重要机制。</p><h2><b>五、视图与基本表的区别与联系</b></h2><ol><li>视图是虚表，在一般情况下不建立索引。</li><li>sql一般也不提供修改视图定义的语句。</li><li>对视图中数据进行更新是有限制的。</li></ol><h2><b>六、数据模型的三要素</b></h2><ol><li>数据结构</li><li>数据操作</li><li>完整性约束</li></ol><h2><b>七、事务</b></h2><ul><li>事务是数据库操作的最小逻辑工作单元，是一系列SQL操作的集合。</li><li>事务必须具有的四个性质(ACID特性)是：原子性、一致性、隔离性和持久性。</li><li>提交(commit transaction)：使事务成功地结束。所执行事务对数据库的所有更新将永远存在。</li><li>回滚(rollback transaction)：即在事务的运行过程中发生了某种故障，事务不能继续运行，影响该事务的SQL语句所造成的任何改变必须全部作废，回滚到事务开始前的状态。</li></ul><h2><b>八、并发操作的三类问题</b></h2><ol><li>丢失更新：写写冲突，加排它锁X</li><li>读“脏”数据：写读冲突，加共享锁S</li><li>不可重复读：读写冲突</li></ol><h2><b>九、数据库系统的基本特点</b></h2><ol><li>整体数据结构化</li><li>数据的共享度高</li><li>数据的独立性高</li><li>高度的数据控制能力。</li></ol><h2><b>十、数据库的基本特点</b></h2><ol><li>数据可以共享</li><li>数据独立性</li><li>数据冗余小，易扩充</li><li>统一管理和控制。</li></ol><h2><b>十一、自然连接与等值连接的区别</b></h2><ol><li>自然连接要求相等的分量必须有共同的属性；等值连接就不需要。</li><li>自然连接要求把结果中的所有重复属性名都去掉一个；等值连接却不这样。</li></ol><h2><b>十二、SQL语言分类</b></h2><ol><li>DDL数据定义语言：负责创建、修改、删除表、索引和视图等对象，由动词 create, alter, drop 组成。</li><li>DML数据操作语言：负责数据库中数据的插入、修改、查询和删除操作，由动词 insert, update, select, delete 组成。</li><li>DCL数据控制语言：用来授予和撤销用户对数据的操作权限，由动词 grant, revoke 组成。</li></ol><h2><b>十三、SQL数据类型</b></h2><ul><li>int/integer：全字长整数型</li><li>smallint：半字长整数型</li><li>decimal(p[,q])：精确数值型，共p位，小数点后有q位。</li><li>float：双字长浮点数</li><li>char(n)：长度为n的定长字符串</li><li>varchar(n)：最大长度为n的变长字符串。</li><li>datetime：日期时间型，格式可以设置</li></ul><h2><b>十四、数据完整性约束</b></h2><ul><li>not null：不为空</li><li>null：可以为空</li><li>unique：不能有相同的值</li></ul><h2><b>十五、集函数</b></h2><ul><li>count(distinct/all *)：统计结果中元组个数</li><li>count(distinct/all&lt;列名&gt;)：统计结果中某列值的个数</li><li>max(&lt;列名&gt;)：给出一列上的最大值</li><li>min(&lt;列名&gt;)：给出一列上的最小值</li><li>sum(distinct/all&lt;列名&gt;)：给出一列上值的总和</li><li>avg(distinct/all&lt;列名&gt;)：给出一列上值的平均</li></ul><h2><b>十六、特殊运算符</b></h2><p><img src=\"https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7B%7Cc%7Cc%7C%7D+%5Chline+%5Ctext%7B%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%B7%7D+%26+%5Ctext%7B%E5%90%AB%E4%B9%89%7D%5C%5C+%5Chline+in%2C+not%5C+in+%26+%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%A4%9F%E5%B1%9E%E4%BA%8E%E4%B8%80%E7%BB%84%E5%80%BC%E4%B9%8B%E4%B8%80%5C%5C+%5Chline+between%E2%80%A6and%E2%80%A6%2C+not%5C+between%E2%80%A6and%E2%80%A6+%26+%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%90%A6%E5%B1%9E%E4%BA%8E%E6%9F%90%E4%B8%AA%E8%8C%83%E5%9B%B4+%5C%5C+%5Chline+is%5C+null%2C+is%5C+not%5C+null+%26+%E6%A3%80%E6%9F%A5%E5%B1%9E%E6%80%A7%E5%80%BC%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA+%5C%5C+%5Chline+like%2C+not%5C+like+%26+%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%2C%22%5C%25%22%E8%A1%A8%E7%A4%BA%E4%BB%BB%E6%84%8F%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%28%E5%8F%AF%E4%BB%A5%E4%B8%BA0%2C0%29%2C%22+%5C_%22%E8%A1%A8%E7%A4%BA%E5%8D%95%E4%B8%AA%E5%AD%97%E7%AC%A6+%5C%5C+%5Chline+%5Cend%7Barray%7D%5C%5C\" alt=\"\\begin{array}{|c|c|} \\hline \\text{运算符号} &amp; \\text{含义}\\\\ \\hline in, not\\ in &amp; 检查属性值是够属于一组值之一\\\\ \\hline between…and…, not\\ between…and… &amp; 检查属性值是否属于某个范围 \\\\ \\hline is\\ null, is\\ not\\ null &amp; 检查属性值是否为空 \\\\ \\hline like, not\\ like &amp; 字符串匹配,&#34;\\%&#34;表示任意长度的字符串(可以为0,0),&#34; \\_&#34;表示单个字符 \\\\ \\hline \\end{array}\\\\\" eeimg=\"1\"/> </p><h2><b>十七、查询方式</b></h2><p><b>1、分组查询</b></p><ul><li>where子句作用于基表或者视图，从中选择满足条件的元组；having子句作用于分组后的组，从中选择满足条件的组。</li></ul><p><b>2、排序查询</b></p><ul><li>用 order by 进行默认升序排序</li><li>在列名后面添加 desc 进行降序排序</li></ul><p><b>3、多关系连接查询</b></p><ol><li>交叉连接： cross join ，两表之间没有任何联系</li></ol><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">select</span> <span class=\"p\">[</span><span class=\"k\">distinct</span><span class=\"o\">/</span><span class=\"k\">all</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span><span class=\"err\">目标列清单</span><span class=\"o\">&gt;</span>\n<span class=\"k\">from</span> <span class=\"o\">&lt;</span><span class=\"err\">关系名</span><span class=\"p\">[</span><span class=\"err\">别名</span><span class=\"p\">]</span><span class=\"err\">清单</span><span class=\"o\">&gt;</span></code></pre></div><p>2.内部连接： inner join ，两表之间具有共同性质的属性。</p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">select</span> <span class=\"p\">[</span><span class=\"k\">distinct</span><span class=\"o\">/</span><span class=\"k\">all</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span><span class=\"err\">目标清单</span><span class=\"o\">&gt;</span>\n<span class=\"k\">from</span> <span class=\"o\">&lt;</span><span class=\"err\">关系名</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span> <span class=\"k\">inner</span> <span class=\"k\">join</span> <span class=\"o\">&lt;</span><span class=\"err\">关系名</span><span class=\"mi\">2</span><span class=\"o\">&gt;</span>\n<span class=\"k\">on</span> <span class=\"o\">&lt;</span><span class=\"err\">连接条件</span><span class=\"o\">&gt;</span></code></pre></div><p>3.外连接： outer join</p><p>4.自身连接： self join</p><p><b>4、嵌套查询</b></p><ul><li>如果子查询的返回结果总是单个值，那么可以用“=”来代替“in”。</li><li>在嵌套查询中可以使用比较运算符来构成它的连接词。如 &lt; , &gt; , = , &lt;= , &gt;= , &lt;&gt;</li><li>在比较运算符的后面可以加上 any 后者 all ， any 只需其中的一个即可， all 表示必须全部满足。</li><li>在使用嵌套语句时也可以结合 between…and…</li></ul><h2><b>十八、select语句的集合操作</b></h2><ul><li>集合操作主要包括并（union），交（intersect），差（except/minus）</li><li>select默认保留重复的元素，除非使用 distinct 进行指明。但是select语句的集合操作，在默认情况是消除重复元组的，要想保留，需要在集合操作的关键字后面加上 all。</li></ul><h2><b>十九、视图操作</b></h2><p><b>1、定义视图</b></p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">create</span> <span class=\"k\">view</span> <span class=\"o\">&lt;</span><span class=\"err\">视图名</span><span class=\"o\">&gt;</span>\n<span class=\"k\">as</span> <span class=\"o\">&lt;</span><span class=\"err\">子查询</span><span class=\"o\">&gt;</span>\n<span class=\"p\">[</span><span class=\"k\">with</span> <span class=\"k\">check</span> <span class=\"k\">option</span><span class=\"p\">]</span></code></pre></div><ul><li>若有 with check option ，则今后在对此视图，进行 insert, update, delete 操作时，会自动检查是否符合原定义视图子查询中的&lt;条件表达式&gt;。</li><li>视图是数据库中数据的物理独立性和逻辑独立性的重要支柱。</li></ul><p><b>2、删除视图</b></p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"k\">drop</span> <span class=\"k\">view</span></code></pre></div><h2><b>二十、参照完整性约束的实现策略</b></h2><ol><li>限制策略： no action</li><li>级联策略： cascade</li><li>置空策略</li></ol><h2><b>二十一、完整性约束</b></h2><ol><li>实体完整性：通过主码定义来完成</li><li>参照完整性：外部码约束references 和参照完整性约束</li><li>用户自定义完整性：基于属性和元组的check约束</li></ol><h2><b>二十二、触发器的基本概念</b></h2><ul><li>触发器，就是一类由数据库操作实践（插入、删除、修改）驱动的特殊过程，一旦由某个用户定义，任何用户对该触发器指定的数据进行增、删或改操作时，系统将会自动激活相应的触发动作，在数据库服务器上进行集中的完整性控制。</li><li>tigger</li></ul><h2><b>二十三、访问控制</b></h2><ul><li>授予权限 grant</li><li>收回权限 revoke</li></ul><h2><b>二十四、规范化</b></h2><p><b>1、未规范化的数据存在的问题</b></p><ul><li>数据冗余度大，主要由于属性之间的约束关系太强导致。</li><li>修改异常。</li><li>插入与删除异常。</li></ul><p><b>2、规范化后的数据的好处</b></p><ul><li>数据量减少</li><li>表达能力增强</li><li>修改方便</li></ul><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"err\">找出所有没有选修</span><span class=\"mi\">1</span><span class=\"err\">号课程的学生姓名；</span>\n<span class=\"k\">select</span> <span class=\"n\">sname</span>\n<span class=\"k\">from</span> <span class=\"n\">student</span>\n<span class=\"k\">where</span> <span class=\"n\">sno</span> <span class=\"k\">not</span> <span class=\"k\">in</span> <span class=\"c1\">--“ not in ”等同于“ &lt;&gt; all ”\n</span><span class=\"c1\"></span><span class=\"p\">(</span><span class=\"k\">select</span> <span class=\"n\">sno</span>\n<span class=\"k\">from</span> <span class=\"n\">grade</span>\n<span class=\"k\">where</span> <span class=\"n\">cno</span><span class=\"o\">=</span><span class=\"s1\">&#39;1&#39;</span><span class=\"p\">)</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-sql\"><span class=\"err\">找出选修了全部课程的学生姓名。</span>\n<span class=\"c1\">--（提示：可找出这样的学生，没有一门课程是他不选修的。）\n</span><span class=\"c1\"></span><span class=\"k\">Select</span> <span class=\"n\">sname</span> <span class=\"k\">from</span> <span class=\"n\">student</span>\n<span class=\"k\">Where</span> <span class=\"k\">not</span> <span class=\"k\">exists</span> <span class=\"p\">(</span> <span class=\"k\">select</span> <span class=\"n\">cno</span> <span class=\"k\">from</span> <span class=\"n\">course</span>\n<span class=\"k\">Except</span>\n<span class=\"k\">Select</span> <span class=\"n\">cno</span> <span class=\"k\">from</span> <span class=\"n\">grade</span> <span class=\"k\">where</span> <span class=\"n\">grade</span><span class=\"p\">.</span><span class=\"n\">sno</span><span class=\"o\">=</span><span class=\"n\">student</span><span class=\"p\">.</span><span class=\"n\">sno</span> <span class=\"p\">)</span></code></pre></div><hr/><h2><b>数据库范式1NF 2NF 3NF BCNF(实例）</b></h2><p>设计范式（范式,数据库设计范式,数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、第四范式（4NF）、第五范式（5NF）和第六范式（6NF）。满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。下面我们举例介绍第一范式（1NF）、第二范式（2NF）和第三范式（3NF）。</p><p> 在创建一个数据库的过程中，范化是将其转化为一些表的过程，这种方法可以使从数据库得到的结果更加明确。这样可能使数据库产生重复数据，从而导致创建多余的表。范化是在识别数据库中的数据元素、关系，以及定义所需的表和各表中的项目这些初始工作之后的一个细化的过程。</p><p>下面是范化的一个例子：</p><div class=\"highlight\"><pre><code class=\"language-text\">Customer    ; Item purchased ; Purchase price \nThomas      ; Shirt          ; $40 \nMaria Tennis; shoes          ; $35 \nEvelyn      ; Shirt          ; $40 \nPajaro      ; Trousers       ; $25</code></pre></div><p>如果上面这个表用于保存物品的价格，而你想要删除其中的一个顾客，这时你就必须同时删除一个价格。范化就是要解决这个问题，你可以将这个表化为两个表，一个用于存储每个顾客和他所买物品的信息，另一个用于存储每件产品和其价格的信息，这样对其中一个表做添加或删除操作就不会影响另一个表。</p><h2><b>关系数据库的几种设计范式介绍</b></h2><p><b>1、第一范式（1NF）</b></p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。</p><p>所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。例如，对于图3-2 中的员工信息表，不能将员工信息都放在一列中显示，也不能将其中的两列或多列在一列中显示；员工信息表的每一行只表示一个员工的信息，一个员工的信息在表中只出现一次。简而言之，第一范式就是无重复的列。</p><p><b>2、第二范式（2NF）</b></p><p>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。如图3-2 员工信息表中加上了员工编号（emp_id）列，因为每个员工的员工编号是惟一的，因此每个员工可以被惟一区分。这个惟一属性列被称为主关键字或主键、主码。</p><p>第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。简而言之，第二范式就是非主属性非部分依赖于主关键字。</p><p><b>3、第三范式（3NF）</b></p><p>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在图3-2的员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余。简而言之，第三范式就是属性不依赖于其它非主属性。</p><h2><b>数据库设计三大范式应用实例剖析</b></h2><p>数据库的设计范式是数据库设计所需要满足的规范，满足这些规范的数据库是简洁的、结构明晰的，同时，不会发生插入（insert）、删除（delete）和更新（update）操作异常。反之则是乱七八糟，不仅给数据库的编程人员制造麻烦，而且面目可憎，可能存储了大量不需要的冗余信息。</p><p>设计范式是不是很难懂呢？非也，大学教材上给我们一堆数学公式我们当然看不懂，也记不住。所以我们很多人就根本不按照范式来设计数据库。</p><p>实质上，设计范式用很形象、很简洁的话语就能说清楚，道明白。本文将对范式进行通俗地说明，并以笔者曾经设计的一个简单论坛的数据库为例来讲解怎样将这些范式应用于实际工程。</p><h2><b>范式说明</b></h2><p><b>第一范式（1NF）</b>：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。</p><p>例如，如下的数据库表是符合第一范式的：</p><div class=\"highlight\"><pre><code class=\"language-text\">字段1  字段2  字段3  字段4 </code></pre></div><p>而这样的数据库表是不符合第一范式的：</p><div class=\"highlight\"><pre><code class=\"language-text\">字段1  字段2  字段3  字段4 \n　　  　 字段3.1  字段3.2  　　 </code></pre></div><p>很显然，在当前的任何关系数据库管理系统（DBMS）中，傻瓜也不可能做出不符合第一范式的数据库，因为这些DBMS不允许你把数据库表的一列再分成二列或多列。因此，你想在现有的DBMS中设计出不符合第一范式的数据库都是不可能的。</p><p><b>第二范式（2NF）</b>：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。</p><p>假定选课关系表为SelectCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，关键字为组合关键字(学号, 课程名称)，因为存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(学号, 课程名称) → (姓名, 年龄, 成绩, 学分)</code></pre></div><p> 这个数据库表不满足第二范式，因为存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(课程名称) → (学分)\n(学号) → (姓名, 年龄)</code></pre></div><p>即存在组合关键字中的字段决定非关键字的情况。</p><p>由于不符合2NF，这个选课关系表会存在如下问题：</p><p>(1) <b>数据冗余</b>：同一门课程由n个学生选修，&#34;学分&#34;就重复n-1次；同一个学生选修了m门课程，姓名和年龄就重复了m-1次。</p><p>(2) <b>更新异常</b>：若调整了某门课程的学分，数据表中所有行的&#34;学分&#34;值都要更新，否则会出现同一门课程学分不同的情况。</p><p>(3) <b>插入异常</b>：假设要开设一门新的课程，暂时还没有人选修。这样，由于还没有&#34;学号&#34;关键字，课程名称和学分也无法记录入数据库。</p><p>(4) <b>删除异常</b>：假设一批学生已经完成课程的选修，这些选修记录就应该从数据库表中删除。但是，与此同时，课程名称和学分信息也被删除了。很显然，这也会导致插入异常。</p><p>把选课关系表SelectCourse改为如下三个表：</p><div class=\"highlight\"><pre><code class=\"language-text\">学生：Student(学号, 姓名, 年龄)；\n课程：Course(课程名称, 学分)；\n选课关系：SelectCourse(学号, 课程名称, 成绩)。</code></pre></div><p>这样的数据库表是符合第二范式的， 消除了数据冗余、更新异常、插入异常和删除异常。</p><p>另外，所有单关键字的数据库表都符合第二范式，因为不可能存在组合关键字。</p><p><b>第三范式（3NF）</b>：在第二范式的基础上，数据表中如果不存在非关键字段对任一候选关键字段的传递函数依赖则符合第三范式。所谓传递函数依赖，指的是如果存在&#34;A → B → C&#34;的决定关系，则C传递函数依赖于A。因此，满足第三范式的数据库表应该不存在如下依赖关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">关键字段 → 非关键字段x → 非关键字段y</code></pre></div><p>假定学生关系表为Student(学号, 姓名, 年龄, 所在学院, 学院地点, 学院电话)，关键字为单一关键字&#34;学号&#34;，因为存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话)</code></pre></div><p>这个数据库是符合2NF的，但是不符合3NF，因为存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(学号) → (所在学院) → (学院地点, 学院电话)</code></pre></div><p>即存在非关键字段&#34;学院地点&#34;、&#34;学院电话&#34;对关键字段&#34;学号&#34;的传递函数依赖。</p><p>它也会存在数据冗余、更新异常、插入异常和删除异常的情况，读者可自行分析得知。</p><p>把学生关系表分为如下两个表：</p><div class=\"highlight\"><pre><code class=\"language-text\">学生：(学号, 姓名, 年龄, 所在学院)；\n学院：(学院, 地点, 电话)。</code></pre></div><p>这样的数据库表是符合第三范式的，消除了数据冗余、更新异常、插入异常和删除异常。</p><p><b>鲍依斯-科得范式（BCNF）</b>：在第三范式的基础上，数据库表中如果不存在任何字段对任一候选关键字段的传递函数依赖则符合第三范式。</p><p>假设仓库管理关系表为StorehouseManage(仓库ID, 存储物品ID, 管理员ID, 数量)，且有一个管理员只在一个仓库工作；一个仓库可以存储多种物品。这个数据库表中存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(仓库ID, 存储物品ID) → (管理员ID, 数量)\n(管理员ID, 存储物品ID) → (仓库ID, 数量)</code></pre></div><p>所以，(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是StorehouseManage的候选关键字，表中的唯一非关键字段为数量，它是符合第三范式的。但是，由于存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(仓库ID) → (管理员ID)\n(管理员ID) → (仓库ID)</code></pre></div><p>即存在关键字段决定关键字段的情况，所以其不符合BCNF范式。它会出现如下异常情况：</p><p>(1) <b>删除异常</b>：当仓库被清空后，所有&#34;存储物品ID&#34;和&#34;数量&#34;信息被删除的同时，&#34;仓库ID&#34;和&#34;管理员ID&#34;信息也被删除了。</p><p>(2) <b>插入异常</b>：当仓库没有存储任何物品时，无法给仓库分配管理员。</p><p>(3) <b>更新异常</b>：如果仓库换了管理员，则表中所有行的管理员ID都要修改。</p><p>把仓库管理关系表分解为二个关系表：</p><div class=\"highlight\"><pre><code class=\"language-text\">仓库管理：StorehouseManage(仓库ID, 管理员ID)；\n仓库：Storehouse(仓库ID, 存储物品ID, 数量)。</code></pre></div><p>这样的数据库表是符合BCNF范式的，消除了删除异常、插入异常和更新异常。</p><h2><b>范式应用</b></h2><p>我们来逐步搞定一个论坛的数据库，有如下信息：</p><div class=\"highlight\"><pre><code class=\"language-text\">（1） 用户：用户名，email，主页，电话，联系地址\n（2） 帖子：发帖标题，发帖内容，回复标题，回复内容</code></pre></div><p>第一次我们将数据库设计为仅仅存在表：</p><div class=\"highlight\"><pre><code class=\"language-text\">用户名  email  主页  电话  联系地址  发帖标题  发帖内容  回复标题  回复内容 </code></pre></div><p>这个数据库表符合第一范式，但是没有任何一组候选关键字能决定数据库表的整行，唯一的关键字段用户名也不能完全决定整个元组。我们需要增加&#34;发帖ID&#34;、&#34;回复ID&#34;字段，即将表修改为：</p><div class=\"highlight\"><pre><code class=\"language-text\">用户名  email  主页  电话  联系地址  发帖ID  发帖标题  发帖内容  回复ID  回复标题  回复内容 </code></pre></div><p>这样数据表中的关键字(用户名，发帖ID，回复ID)能决定整行：</p><div class=\"highlight\"><pre><code class=\"language-text\">(用户名,发帖ID,回复ID) → (email,主页,电话,联系地址,发帖标题,发帖内容,回复标题,回复内容)</code></pre></div><p>但是，这样的设计不符合第二范式，因为存在如下决定关系：</p><div class=\"highlight\"><pre><code class=\"language-text\">(用户名) → (email,主页,电话,联系地址)\n(发帖ID) → (发帖标题,发帖内容)\n(回复ID) → (回复标题,回复内容)</code></pre></div><p>即非关键字段部分函数依赖于候选关键字段，很明显，这个设计会导致大量的数据冗余和操作异常。</p><p>我们将数据库表分解为（带下划线的为关键字）：</p><div class=\"highlight\"><pre><code class=\"language-text\">（1） 用户信息：用户名，email，主页，电话，联系地址\n（2） 帖子信息：发帖ID，标题，内容\n（3） 回复信息：回复ID，标题，内容\n（4） 发贴：用户名，发帖ID\n（5） 回复：发帖ID，回复ID</code></pre></div><p>这样的设计是满足第1、2、3范式和BCNF范式要求的，但是这样的设计是不是最好的呢？</p><p>不一定。观察可知，第4项&#34;发帖&#34;中的&#34;用户名&#34;和&#34;发帖ID&#34;之间是1：N的关系，因此我们可以把&#34;发帖&#34;合并到第2项的&#34;帖子信息&#34;中；第5项&#34;回复&#34;中的&#34;发帖ID&#34;和&#34;回复ID&#34;之间也是1：N的关系，因此我们可以把&#34;回复&#34;合并到第3项的&#34;回复信息&#34;中。这样可以一定量地减少数据冗余，新的设计为：</p><div class=\"highlight\"><pre><code class=\"language-text\">（1） 用户信息：用户名，email，主页，电话，联系地址\n（2） 帖子信息：用户名，发帖ID，标题，内容\n（3） 回复信息：发帖ID，回复ID，标题，内容</code></pre></div><p>数据库表1显然满足所有范式的要求；</p><p>数据库表2中存在非关键字段&#34;标题&#34;、&#34;内容&#34;对关键字段&#34;发帖ID&#34;的部分函数依赖，即不满足第二范式的要求，但是这一设计并不会导致数据冗余和操作异常；</p><p>数据库表3中也存在非关键字段&#34;标题&#34;、&#34;内容&#34;对关键字段&#34;回复ID&#34;的部分函数依赖，也不满足第二范式的要求，但是与数据库表2相似，这一设计也不会导致数据冗余和操作异常。</p><p>由此可以看出，并不一定要强行满足范式的要求，对于1：N关系，当1的一边合并到N的那边后，N的那边就不再满足第二范式了，但是这种设计反而比较好！</p><p>对于M：N的关系，不能将M一边或N一边合并到另一边去，这样会导致不符合范式要求，同时导致操作异常和数据冗余。</p><p>对于1：1的关系，我们可以将左边的1或者右边的1合并到另一边去，设计导致不符合范式要求，但是并不会导致操作异常和数据冗余。</p><h2><b>结论</b></h2><p>满足范式要求的数据库设计是结构清晰的，同时可避免数据冗余和操作异常。这并意味着不符合范式要求的设计一定是错误的，在数据库表中存在1：1或1：N关系这种较特殊的情况下，合并导致的不符合范式要求反而是合理的。</p><p>在我们设计数据库的时候，一定要时刻考虑范式的要求。</p><hr/><p>参考资料：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//blog.renren.com/share/229990753/2576242237\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库：怎样判断关系是第几范式~~看完懂了~~ - 【人人分享-人人网】</a></li></ul><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p><p></p>", 
            "topic": [
                {
                    "tag": "数据库原理", 
                    "tagLink": "https://api.zhihu.com/topics/19617529"
                }
            ], 
            "comments": [
                {
                    "userName": "White spider", 
                    "userLink": "https://www.zhihu.com/people/958eb381187e186c94bc060e046dfe31", 
                    "content": "感谢", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/36388351", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 6, 
            "title": "运用虚拟机搭建本地Hadoop环境", 
            "content": "<h2>实验环境</h2><ul><li>本机操作系统：Windows 10 </li><li>虚拟机软件：VMware Workstation Pro 14</li><li>虚拟机系统：Ubuntu 16.04</li></ul><h2>准备工作</h2><ul><li>安装好虚拟机软件 VMware。</li><li>在虚拟机软件中将建立一个虚拟机，运行 Ubuntu 操作系统。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>建房子当然需要先打好地基，同样配置我们的 Hadoop 环境也是。最基本的当然是虚拟机软件的安装，我这里使用的是 VMware Workstation Pro 14。紧接着自然而然的就是安装 Linux 操作系统，我这里使用的是 Ubuntu 16.04 LTS，可以直接使用 VMware 提供的建议安装一键安装就行了。另外，建立安装 Ubuntu 的时候内存最好分配 2G 及以上，否则会比较卡。</p><p>在完成了操作系统的安装之后就要安装基本的Hadoop语言环境了。由于Hadoop是一个基于Java开发的一个大数据平台，自然少不了Java运行环境的安装了，当然使用hadoop不一定需要java语言，hadoop的开发支持很多种语言。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>JDK安装</h2><p>Java的安装非常简单，我们直接从 <a href=\"https://link.zhihu.com/?target=http%3A//www.oracle.com/technetwork/java/javase/downloads/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Oracle 的官网</a> 随便选择一个 JDK 版本就行，我这里选择的 8u171，选择 Ubuntu 对应的 .tar.gz 后缀的版本下载即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-06c5ecd2cdfce24b15aa87c9a77421c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-06c5ecd2cdfce24b15aa87c9a77421c2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;545&#39; height=&#39;294&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"294\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"545\" data-original=\"https://pic3.zhimg.com/v2-06c5ecd2cdfce24b15aa87c9a77421c2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-06c5ecd2cdfce24b15aa87c9a77421c2_b.jpg\"/></figure><p>下载完成中，解压对相应的地址下。我这里打算把 JDK 安装到用户主目录下，所以就将 extract 后的结果移动到这个地址下面：</p><div class=\"highlight\"><pre><code class=\"language-bash\">mv jdk1.8.0_171/ ~/java</code></pre></div><p>这样，我解压后的 JDK 地址就是 ~/java 了。</p><p>然后，我就要设置 JDK 的环境变量，在 /etc/profile 最后加上：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">export</span> <span class=\"nv\">JAVA_HOME</span><span class=\"o\">=</span>/home/hadoop/java\n<span class=\"nb\">export</span> <span class=\"nv\">JRE_HOME</span><span class=\"o\">=</span><span class=\"si\">${</span><span class=\"nv\">JAVA_HOME</span><span class=\"si\">}</span>/jre\n<span class=\"nb\">export</span> <span class=\"nv\">CLASSPATH</span><span class=\"o\">=</span>.:<span class=\"si\">${</span><span class=\"nv\">JAVA_HOME</span><span class=\"si\">}</span>/lib:<span class=\"si\">${</span><span class=\"nv\">JRE_HOME</span><span class=\"si\">}</span>/lib\n<span class=\"nb\">export</span> <span class=\"nv\">PATH</span><span class=\"o\">=</span><span class=\"si\">${</span><span class=\"nv\">JAVA_HOME</span><span class=\"si\">}</span>/bin:<span class=\"nv\">$PATH</span></code></pre></div><p>使用 source /etc/profile 命令来执行修改。</p><p>最终通过 java -version 来验证我们的 JDK 环境是否设置正确，如果正确应像下图一样显示 JDK 的版本信息：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-05958d2cd1db286b8c742fa0fe6742e3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb\" width=\"587\" data-original=\"https://pic4.zhimg.com/v2-05958d2cd1db286b8c742fa0fe6742e3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;587&#39; height=&#39;68&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"587\" data-rawheight=\"68\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"587\" data-original=\"https://pic4.zhimg.com/v2-05958d2cd1db286b8c742fa0fe6742e3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-05958d2cd1db286b8c742fa0fe6742e3_b.jpg\"/></figure><h2>Hadoop安装</h2><p>安装 JDK 的目的当然是为了安装我们的 Hadoop 。所以安装完 JDK 就要安装 Hadoop 了。</p><p>Hadoop 下载地址：<a href=\"https://link.zhihu.com/?target=http%3A//mirrors.hust.edu.cn/apache/hadoop/common/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">mirrors.hust.edu.cn/apa</span><span class=\"invisible\">che/hadoop/common/</span><span class=\"ellipsis\"></span></a></p><p>我这里下载的是 Hadoop 2.7.6 版本。我为什么不用 3.0 版本呢？因为 3.0 以后版本目前的网络资源太少，我怕踩坑，而且老师让我们用的是 2.0 版本的。QAQ</p><p>其安装步骤和 JDK 的安装是一样的，下载 .tag.gz 版本的压缩包，加压后，我们提取到用户主目录下即可。</p><div class=\"highlight\"><pre><code class=\"language-bash\">mv hadoop-2.7.6/ ~/hadoop</code></pre></div><p>同样在 /etc/profile 中配置其环境变量：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">export</span> <span class=\"nv\">HADOOP_INSTALL</span><span class=\"o\">=</span>/home/hadoop/hadoop\n<span class=\"nb\">export</span> <span class=\"nv\">PATH</span><span class=\"o\">=</span><span class=\"si\">${</span><span class=\"nv\">HADOOP_INSTALL</span><span class=\"si\">}</span>/bin:<span class=\"si\">${</span><span class=\"nv\">HADOOP_INSTALL</span><span class=\"si\">}</span>/sbin:<span class=\"nv\">$PATH</span></code></pre></div><p>接着通过使用 source 命令使其修改生效。</p><p>然后可以通过 hadoop version 来进行查看。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0e610434db92bb3535570e649d4cfe02_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-0e610434db92bb3535570e649d4cfe02_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;153&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"153\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic3.zhimg.com/v2-0e610434db92bb3535570e649d4cfe02_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0e610434db92bb3535570e649d4cfe02_b.jpg\"/></figure><p>能够正确显示版本信息，说明安装正确了。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Hadoop配置之运行账户创建</h2><p>首先，我们需要创建一个用户组，并添加一个管理员用户到这个用户组中。 <br/>这里，我们建立一个名叫 hadoop 的用户组，然后设定一个用户同样叫做 hadoop。 <br/>1、添加 hadoop用户组：</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo groupadd hadoop</code></pre></div><p>2 、添加名叫 hadoop 的用户，并添加到 hadoop 组中。</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo useradd -s /bin/bash -d /home/hadoop/ -m hadoop -g hadoop</code></pre></div><p>3、赋予 hadoop 用户管理员权限</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo adduser hadoop sudo</code></pre></div><p>4、最后，切换登陆帐户到刚才设定的 hadoop 账户中：</p><div class=\"highlight\"><pre><code class=\"language-bash\">su hadoop</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><h2>Hadoop配置之伪分布式配置</h2><p>我们主要有以下这么5个文件需要进行配置：</p><p>主要有这4个文件需要修改：</p><div class=\"highlight\"><pre><code class=\"language-text\">***/etc/hadoop/hadoop-env.sh\n***/etc/hadoop/core-site.xml\n***/etc/hadoop/hdfs-site.xml\n***/etc/hadoop/mapred-site.xml\n***/etc/hadoop/slaves</code></pre></div><p>这里，我用 \\*\\*\\* 来代替了 hadoop 文件的地址，在我的设置中 \\*\\*\\* 表示的是 /home/hadoop 。</p><p>首先需要修改 <b>hadoop-env.sh</b>，添加java安装的地址，保存退出即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-be702ac380652055a15c61f72f2e3fbe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"288\" class=\"origin_image zh-lightbox-thumb\" width=\"510\" data-original=\"https://pic3.zhimg.com/v2-be702ac380652055a15c61f72f2e3fbe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;510&#39; height=&#39;288&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"510\" data-rawheight=\"288\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"510\" data-original=\"https://pic3.zhimg.com/v2-be702ac380652055a15c61f72f2e3fbe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-be702ac380652055a15c61f72f2e3fbe_b.jpg\"/></figure><p>其次，需要修改的是 <b>core-site.cml</b> ，修改如下：</p><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"nt\">&lt;configuration&gt;</span>\n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>fs.default.name<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>hdfs://master:9000<span class=\"nt\">&lt;/value&gt;</span>\n                <span class=\"nt\">&lt;final&gt;</span>true<span class=\"nt\">&lt;/final&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n\n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>hadoop.tmp.dir<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>/home/hadoop/hadoop/tmp/<span class=\"nt\">&lt;/value&gt;</span>\n                <span class=\"nt\">&lt;description&gt;</span>A base for other temporary directories<span class=\"nt\">&lt;/description&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n<span class=\"nt\">&lt;/configuration&gt;</span></code></pre></div><p>在这里，第一个 fs.default.name 设置 master 机为 namenode 。第二个 hadoop.tmp.dir配置 Hadoop 的一个临时目录，用来存放每次运行的作业的信息。</p><p>修改后的效果如下，只有在 <code>&lt;configuration\\&gt;</code> 和 <code>&lt;/configuration\\&gt;</code> 之间进行修改即可，后面的修改也是一样的。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f8d3f277c1d804fefae3748242e01a67_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-f8d3f277c1d804fefae3748242e01a67_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;487&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic4.zhimg.com/v2-f8d3f277c1d804fefae3748242e01a67_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f8d3f277c1d804fefae3748242e01a67_b.jpg\"/></figure><p>然后，就是 <b>hdfs-site.xml </b>的修改：</p><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"nt\">&lt;configuration&gt;</span>\n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>dfs.name.dir<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>/home/hadoop/hadoop/name<span class=\"nt\">&lt;/value&gt;</span>\n                <span class=\"nt\">&lt;final&gt;</span>true<span class=\"nt\">&lt;/final&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n\n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>dfs.data.dir<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>/home/hadoop/hadoop/data<span class=\"nt\">&lt;/value&gt;</span>\n                <span class=\"nt\">&lt;final&gt;</span>true<span class=\"nt\">&lt;/final&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n                \n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>dfs.replication<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>2<span class=\"nt\">&lt;/value&gt;</span>\n                <span class=\"nt\">&lt;final&gt;</span>true<span class=\"nt\">&lt;/final&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n        \n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>dfs.permissions<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>false<span class=\"nt\">&lt;/value&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n<span class=\"nt\">&lt;/configuration&gt;</span></code></pre></div><p>其中，dfs.name.dir 是 namenode 存储永久性的元数据的目录列表。这个目录会创建在master机上。dfs.data.dir 是 datanode 存放数据块的目录列表，这个目录在 slave1 和slave2 机都会创建。 dfs.replication 设置文件副本数，这里两个 datanode ，所以设置副本数为2。</p><p>接下来需要修改的是 <b>mapred-site.xml </b>：</p><div class=\"highlight\"><pre><code class=\"language-xml\"><span class=\"nt\">&lt;configuration&gt;</span>\n        <span class=\"nt\">&lt;property&gt;</span>\n                <span class=\"nt\">&lt;name&gt;</span>mapred.job.tracker<span class=\"nt\">&lt;/name&gt;</span>\n                <span class=\"nt\">&lt;value&gt;</span>master:9001<span class=\"nt\">&lt;/value&gt;</span>\n        <span class=\"nt\">&lt;/property&gt;</span>\n<span class=\"nt\">&lt;/configuration&gt;</span></code></pre></div><p>这里设置的是运行 jobtracker 的服务器主机名和端口，也就是作业将在 master 主机的9001端口执行。</p><p>最后需要修改的就是 slaves 文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1719e172c52d19d22c08c47e8c99de90_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"381\" data-rawheight=\"125\" class=\"content_image\" width=\"381\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;381&#39; height=&#39;125&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"381\" data-rawheight=\"125\" class=\"content_image lazy\" width=\"381\" data-actualsrc=\"https://pic1.zhimg.com/v2-1719e172c52d19d22c08c47e8c99de90_b.jpg\"/></figure><p>这里将两台从主机的主机名node1和node2加进去就可以了。</p><p>关于主机的名的修改和设定，我之后会讲，这里你需要做的就是先取号两个 datanode 从机的名字就行了。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>创建从机</h2><p>在对主机完成 Hadoop 的基本配置之后，我们就要创建两个 datanode 从机了，创建的方式非常简单，就是只用使用 VMware 的克隆功能就行了。</p><p>克隆完成后，我们需要对三个机子的主机名都进行修改，修改的方式很简单，指令如下：</p><div class=\"highlight\"><pre><code class=\"language-bash\">vim /etc/hostname</code></pre></div><p>在里面设定你的主机名即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4c878ab448e6826e4bce1fabf718de78_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"421\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb\" width=\"421\" data-original=\"https://pic1.zhimg.com/v2-4c878ab448e6826e4bce1fabf718de78_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;421&#39; height=&#39;76&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"421\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"421\" data-original=\"https://pic1.zhimg.com/v2-4c878ab448e6826e4bce1fabf718de78_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4c878ab448e6826e4bce1fabf718de78_b.jpg\"/></figure><p>比如，在这里我设定的我的主机名是 master ，两个从机名分别为 slave1 和 slave2。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>SSH配置及免密登陆</h2><p>在进行SSH操作前，首先要对三台虚拟机的IP地址进行记录，可以通过 ifconfig 指令来进行查询，其中的 inet addr就是这台虚拟机的ip地址。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c9046f1e7491059e8ebd65b4089cb976_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"734\" data-original=\"https://pic3.zhimg.com/v2-c9046f1e7491059e8ebd65b4089cb976_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;734&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"734\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"734\" data-original=\"https://pic3.zhimg.com/v2-c9046f1e7491059e8ebd65b4089cb976_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-c9046f1e7491059e8ebd65b4089cb976_b.jpg\"/></figure><p>同样记录，两台从机的IP地址。然后对三台主机的 hosts 文件都进行修改：</p><div class=\"highlight\"><pre><code class=\"language-bash\">vim /etc/hosts</code></pre></div><p>在这里添加三台主机的IP地址和主机名就行了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1af5c39843df463437199d4f348ae064_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-1af5c39843df463437199d4f348ae064_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-1af5c39843df463437199d4f348ae064_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1af5c39843df463437199d4f348ae064_b.jpg\"/></figure><p>要记住的是，要在三台主机下都进行修改。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后进行ssh的配置，但要先确保三台机器都装了ssh。</p><p>输入以下命令查看安装的ssh：</p><div class=\"highlight\"><pre><code class=\"language-bash\">dpkg --list<span class=\"p\">|</span>grep ssh</code></pre></div><p>如果已经安装了就会显示这样的6个条目：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6e0d27ae88b59b5225d28b76b10a3dcc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb\" width=\"616\" data-original=\"https://pic1.zhimg.com/v2-6e0d27ae88b59b5225d28b76b10a3dcc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;616&#39; height=&#39;274&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"616\" data-rawheight=\"274\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"616\" data-original=\"https://pic1.zhimg.com/v2-6e0d27ae88b59b5225d28b76b10a3dcc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6e0d27ae88b59b5225d28b76b10a3dcc_b.jpg\"/></figure><p>如果没有安装 ssh 就可以通过如下指令进行安装：</p><div class=\"highlight\"><pre><code class=\"language-bash\">sudo apt-get install openssh-server</code></pre></div><p>安装完毕之后开始配置 ssh。</p><p>1、首先，我们需要在 master 主机上输入以下命令，生成master机的一对公钥和私钥：</p><div class=\"highlight\"><pre><code class=\"language-bash\">ssh-keygen -t rsa -P <span class=\"s1\">&#39;&#39;</span> -f ~/.ssh/id_rsa</code></pre></div><p>以下命令进入认证目录可以看到，  id\\_rsa 和 id\\_rsa.pub 这两个文件，就是我们刚刚生成的公钥和私钥。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1d994a8fcb1cce3b8aa6d8a3f6e2e089_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb\" width=\"469\" data-original=\"https://pic2.zhimg.com/v2-1d994a8fcb1cce3b8aa6d8a3f6e2e089_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;469&#39; height=&#39;52&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"469\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"469\" data-original=\"https://pic2.zhimg.com/v2-1d994a8fcb1cce3b8aa6d8a3f6e2e089_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1d994a8fcb1cce3b8aa6d8a3f6e2e089_b.jpg\"/></figure><p>然后，下面的命令将公钥加入到已认证的 key 中：</p><div class=\"highlight\"><pre><code class=\"language-bash\">cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre></div><p>再次进入生成目录，可以看到多出authorized_keys这个文件。由于我之前已经操作过了，所以我前面的截图中已经包含了该文件了。</p><p>然后输入<code>ssh localhost</code>登录本机命令，第一次提示输入密码，输入<code>exit</code>退出，再次输入<code>ssh localhost</code>不用输入密码就可以登录本机成功，则本机ssh免密码登录已经成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-eafa094f5701c780416357af7ceb0c17_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb\" width=\"605\" data-original=\"https://pic4.zhimg.com/v2-eafa094f5701c780416357af7ceb0c17_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;605&#39; height=&#39;186&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"605\" data-rawheight=\"186\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"605\" data-original=\"https://pic4.zhimg.com/v2-eafa094f5701c780416357af7ceb0c17_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-eafa094f5701c780416357af7ceb0c17_b.jpg\"/></figure><p>2 、之后，我们就要在两个从机上进行操作了。首先是 slave1 这个从机。</p><p>将 master 主机上的 is_rsa.pub复制到slave1 主机上，命名为 slave1_rsa.pub。slave2主机进行同样的操作。</p><div class=\"highlight\"><pre><code class=\"language-bash\">scp hadoop@master:~/.ssh/id_rsa.pub ~/.ssh/slave1_rsa.pub</code></pre></div><p>同样需要将该公钥加入到已认证的 key 中：</p><div class=\"highlight\"><pre><code class=\"language-bash\">cat ~/.ssh/slave1_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</code></pre></div><p>之后，我们需要回到 master 主机进行验证。同样第一次需要密码，之后 exit 退出，再 ssh slave1 就不需要密码登录成功，说明 ssh 免密码登录配置成功！</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ad84acaae245936694ba3b04e9061a74_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb\" width=\"728\" data-original=\"https://pic1.zhimg.com/v2-ad84acaae245936694ba3b04e9061a74_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;728&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"728\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"728\" data-original=\"https://pic1.zhimg.com/v2-ad84acaae245936694ba3b04e9061a74_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ad84acaae245936694ba3b04e9061a74_b.jpg\"/></figure><p>要记住的是，要对 slave2 同样进行该操作，不要遗忘了 slave2 。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>格式化及启动集群</h2><p>接下来需要格式化 namenode ，注意只需要在 master 主机上进行格式化。格式化命令如下：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hdfs namenode -format</code></pre></div><p>没有看到 ERROR 应该就没有问题了。</p><p>接下来启动集群：</p><div class=\"highlight\"><pre><code class=\"language-text\">start-dfs.sh</code></pre></div><p>启动完毕，使用  jps 命令检查下启动情况： master 主机看到四个开启的进程，slave1 和slave2 看到三个开启的进程表示启动成功。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-354c9bf747af0e40a31b5b6b5f9ce199_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"292\" data-rawheight=\"85\" class=\"content_image\" width=\"292\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;292&#39; height=&#39;85&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"292\" data-rawheight=\"85\" class=\"content_image lazy\" width=\"292\" data-actualsrc=\"https://pic2.zhimg.com/v2-354c9bf747af0e40a31b5b6b5f9ce199_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-d2b039334fb2448ee2bac288d4993657_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"67\" class=\"content_image\" width=\"256\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;256&#39; height=&#39;67&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"67\" class=\"content_image lazy\" width=\"256\" data-actualsrc=\"https://pic4.zhimg.com/v2-d2b039334fb2448ee2bac288d4993657_b.jpg\"/></figure><p>然后在浏览器中输入 <a href=\"https://link.zhihu.com/?target=http%3A//localhost%3A50070\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">localhost:50070</span><span class=\"invisible\"></span></a>，通过 Web UI 查看相关信息，截图如下，可以看到我已经连接了从机的2个 datanode：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-31c3537329767978e7ed4939a7e38521_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1164\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb\" width=\"1164\" data-original=\"https://pic2.zhimg.com/v2-31c3537329767978e7ed4939a7e38521_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1164&#39; height=&#39;546&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1164\" data-rawheight=\"546\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1164\" data-original=\"https://pic2.zhimg.com/v2-31c3537329767978e7ed4939a7e38521_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-31c3537329767978e7ed4939a7e38521_b.jpg\"/></figure><p>此时的存储空间也已经变成三台设备的空闲存储空间之和：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c6b12b3423dab1a1b59ef839a90a6484_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb\" width=\"998\" data-original=\"https://pic1.zhimg.com/v2-c6b12b3423dab1a1b59ef839a90a6484_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;998&#39; height=&#39;492&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"998\" data-rawheight=\"492\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"998\" data-original=\"https://pic1.zhimg.com/v2-c6b12b3423dab1a1b59ef839a90a6484_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c6b12b3423dab1a1b59ef839a90a6484_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>运行 WordCount 示例</h2><p>在我们的 hadoop 安装目录下有一个 LINCENSE.txt 文件，我们可以之间用这个文件作为我们的测试用例。</p><p>就在我们的 hadoop 安装目录下，输入命令来创建一个 input 目录：</p><div class=\"highlight\"><pre><code class=\"language-text\">hadoop fs -mkdir /input </code></pre></div><p>然后将 LICENSE.txt 放到 input 目录下：</p><div class=\"highlight\"><pre><code class=\"language-text\">hadoop fs -put LICENSE.txt /input </code></pre></div><p>可以通过命令看到 license.txt 已经存在 input 目录下了：</p><div class=\"highlight\"><pre><code class=\"language-text\">hadoop fs -ls /input</code></pre></div><p>如图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e91466fa1e3670f155768675ee33df35_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb\" width=\"721\" data-original=\"https://pic2.zhimg.com/v2-e91466fa1e3670f155768675ee33df35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;721&#39; height=&#39;52&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"721\" data-rawheight=\"52\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"721\" data-original=\"https://pic2.zhimg.com/v2-e91466fa1e3670f155768675ee33df35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e91466fa1e3670f155768675ee33df35_b.jpg\"/></figure><p>接下来只需要将 /input 通过 hadoop 自带示例程序 wordcount 计算出其中各字母出现的次数便可，命令为：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hadoop jar /home/hadoop/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.7.6.jar wordcount /input /output</code></pre></div><p>这部分不同的 hadoop 版本和 hadoop 安装目录命令可能不一样。</p><p>然后我们可以通过<code>$hadoop fs -ls /</code>命令看到 HDFS 系统下多了个/output 目录。在 /output 目录下有两个文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-939aae76a40b37994fa3936c19fb3c27_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb\" width=\"740\" data-original=\"https://pic4.zhimg.com/v2-939aae76a40b37994fa3936c19fb3c27_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;740&#39; height=&#39;71&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"740\" data-rawheight=\"71\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"740\" data-original=\"https://pic4.zhimg.com/v2-939aae76a40b37994fa3936c19fb3c27_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-939aae76a40b37994fa3936c19fb3c27_b.jpg\"/></figure><p>这说明已经运行成功了，直接打开 part-r-00000 就可以查看结果了：</p><div class=\"highlight\"><pre><code class=\"language-text\">hadoop fs -cat /output/part-r-00000</code></pre></div><p>结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-490c47bbf4ef7f056f906fa0198678c6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb\" width=\"572\" data-original=\"https://pic3.zhimg.com/v2-490c47bbf4ef7f056f906fa0198678c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;572&#39; height=&#39;333&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"572\" data-rawheight=\"333\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"572\" data-original=\"https://pic3.zhimg.com/v2-490c47bbf4ef7f056f906fa0198678c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-490c47bbf4ef7f056f906fa0198678c6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//www.aboutyun.com/thread-6843-1-1.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hadoop学习通过虚拟机安装hadoop完全分布式集群-大数据学习-about云开发-活到老 学到老</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/caiyisen/p/7373512.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hadoop分布式集群搭建hadoop2.6+Ubuntu16.04 - Easen.Cai - 博客园</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/wangjia55/article/details/53160679\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">第一篇：Ubuntu下安装Hadoop(2.7.3)详解 - CSDN博客</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/lighten/p/6106891.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Ubuntu16.04+hadoop2.7.3环境搭建 - dark_saber - 博客园</a> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//blog.csdn.net/xiakexiaohu/article/details/54580971\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">hadoop自带示例wordcount - CSDN博客</a> </li></ul><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Hadoop", 
                    "tagLink": "https://api.zhihu.com/topics/19563390"
                }, 
                {
                    "tag": "Linux", 
                    "tagLink": "https://api.zhihu.com/topics/19554300"
                }
            ], 
            "comments": [
                {
                    "userName": "哈哈哈", 
                    "userLink": "https://www.zhihu.com/people/6007734e9dbc7fe288e86623c34e740b", 
                    "content": "在虚拟机的浏览器hadoop下载完成之后，再去执行命令一直出错，但双击也能看到文件里面完好无损，卡了好几天了，大佬求解答", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31917751", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 2, 
            "title": "在Github上搭建个人博客", 
            "content": "<h2>环境搭建</h2><p><b>系统环境配置</b></p><ul><li><a href=\"https://zhuanlan.zhihu.com/p/31904974\" class=\"internal\">Git安装</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//nodejs.org/zh-cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Node.js 安装</a>， 推荐使用LTS版本</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><h2>环境配置</h2><p><b>Git配置</b></p><p>（1）Github 账户配置</p><p>打开Git Bash，输入以下两条命令(name替换成你的github用户名，email替换成你注册github时用的邮箱):</p><div class=\"highlight\"><pre><code class=\"language-bash\">git config --global user.name <span class=\"s2\">&#34;name&#34;</span>\ngit config --global user.email <span class=\"s2\">&#34;email&#34;</span></code></pre></div><p>配置完成后，你可以通过 <code>git config --list</code> 命令来查看当前的配置信息，可以看到user.name 和 user.email 已经出现在了最后两行:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-63dc4fe6d08dcb3e08660b11ea07e488_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"592\" data-original=\"https://pic1.zhimg.com/v2-63dc4fe6d08dcb3e08660b11ea07e488_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;592&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"592\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"592\" data-original=\"https://pic1.zhimg.com/v2-63dc4fe6d08dcb3e08660b11ea07e488_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-63dc4fe6d08dcb3e08660b11ea07e488_b.jpg\"/></figure><p>如果你发现信息输入有误，重新执行上面两条命令即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）SSH密钥配置</p><p>打开 Git Bash，确保当前位置是用户工作目录，也就是:~ 这个位置，执行下面的命令来生成ssh密钥文件：</p><div class=\"highlight\"><pre><code class=\"language-bash\">ssh-keygen -t rsa -C <span class=\"s2\">&#34;email&#34;</span></code></pre></div><p>将email替换成你注册github时用的邮箱。</p><p>一路回车，过程中让你输入东西的时候不要输入，直接回车，使用默认即可，完后当前目录</p><p>会多出一个名叫.ssh的文件夹，我们使用 cd .ssh 命令进入这个文件夹，里面有两个密钥文件：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0900fc9192e8ad301ab75442156001aa_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-0900fc9192e8ad301ab75442156001aa_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;570&#39; height=&#39;73&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"570\" data-rawheight=\"73\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"570\" data-original=\"https://pic3.zhimg.com/v2-0900fc9192e8ad301ab75442156001aa_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0900fc9192e8ad301ab75442156001aa_b.jpg\"/></figure><p>不带.pub后缀的是私钥，带.pub后缀的是公钥，私钥我们要自己保存好，不要泄露出去，公钥是可以公开分享的。</p><p>然后我们把公钥里面的内容全部复制出来，可以使用cat命令使密钥内容显示出来再复制，也可以使用文本编辑器（不推荐使用记事本）打开再复制：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7ac79630a5c07dbe3811185a03e87451_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb\" width=\"666\" data-original=\"https://pic2.zhimg.com/v2-7ac79630a5c07dbe3811185a03e87451_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;666&#39; height=&#39;108&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"666\" data-rawheight=\"108\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"666\" data-original=\"https://pic2.zhimg.com/v2-7ac79630a5c07dbe3811185a03e87451_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7ac79630a5c07dbe3811185a03e87451_b.jpg\"/></figure><p>再然后登陆我们前面注册的github账号，点击头像，进入 Settings，找到 SSH and GPG keys，点击右侧的 New SSH key：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-96a961fff86c25af9dd57921a5f25f66_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb\" width=\"989\" data-original=\"https://pic3.zhimg.com/v2-96a961fff86c25af9dd57921a5f25f66_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;989&#39; height=&#39;499&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"989\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"989\" data-original=\"https://pic3.zhimg.com/v2-96a961fff86c25af9dd57921a5f25f66_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-96a961fff86c25af9dd57921a5f25f66_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>最后测试一下SSH</p><p>命令行执行：</p><div class=\"highlight\"><pre><code class=\"language-bash\">ssh -T git@github.com</code></pre></div><p>第一次执行这个命令的话程序会问你是否要继续进行连接，输入 <code>yes</code> 回车就好。</p><p>然后控制台输出：</p><p>Hi shaonianruntu! You’ve successfully authenticated, but GitHub does not provide shell access.</p><p>说明SSH密钥配置成功！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>创建本地 Git 仓库</b></p><p>我这里把它建在了F盘，所有文件夹名字都是可以自定义的。打开Git Bash:</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">cd</span> <span class=\"se\">\\f</span>:\nmkdir git_repository</code></pre></div><p>创建我们的博客文件夹：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">cd</span> git_repository\nmkdir blog</code></pre></div><p>进入blog文件夹：</p><div class=\"highlight\"><pre><code class=\"language-bash\"><span class=\"nb\">cd</span> blog</code></pre></div><p>这是我电脑上的blog文件夹全路径: /f/git_repository/blog</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Hexo 部署</h2><p><b>Hexo 安装</b></p><p>打开Git Bash，执行下面的命令:</p><div class=\"highlight\"><pre><code class=\"language-bash\">npm install -g hexo-cli</code></pre></div><p>稍等一会儿，不要着急，会开始自动下载安装。</p><p>安装按成后，可能会出现这样的两个警告，不需要理会：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-813ffd89adb1ae38f90ea2399d7910e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-813ffd89adb1ae38f90ea2399d7910e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;76&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"76\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic2.zhimg.com/v2-813ffd89adb1ae38f90ea2399d7910e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-813ffd89adb1ae38f90ea2399d7910e1_b.jpg\"/></figure><p>可以使用 hexo -v 命令测试是否安装成功:</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-72c70580ca9d2d020684556e30a5ddd6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"282\" data-rawheight=\"215\" class=\"content_image\" width=\"282\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;282&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"282\" data-rawheight=\"215\" class=\"content_image lazy\" width=\"282\" data-actualsrc=\"https://pic3.zhimg.com/v2-72c70580ca9d2d020684556e30a5ddd6_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>Hexo 初始化</b></p><p>进入blog文件夹，空白处鼠标右键，点击Git Bash Here进入命令窗口，执行初始化命令：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo init</code></pre></div><p>等待初始化完成，最后会有一句:</p><p>INFO  Start blogging with Hexo!</p><p>然后执行：</p><div class=\"highlight\"><pre><code class=\"language-bash\">npm install</code></pre></div><p>等待执行结束，无需理会警告。</p><p>初始化成功！现在就已经可以开始使用Hexo了!!!</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一些插件安装</b></p><div class=\"highlight\"><pre><code class=\"language-text\">索引生成器：npm install hexo-generator-index --save\n归档生成器：npm install hexo-generator-archive --save\n分类生成器：npm install hexo-generator-category --save\n标签生成器：npm install hexo-generator-tag --save\n本地搜索: npm install hexo-generator-search --save\n本地化服务：npm install hexo-server --save\nGit部署功能：npm install hexo-deployer-git --save\n渲染器：npm install hexo-renderer-marked --save\n渲染器：npm install hexo-renderer-stylus --save\n置顶功能：npm install hexo-helper-post-top --save\nLatex语法支持： npm install hexo-math --save</code></pre></div><p>为了方便大家直接复制，我这里把这些指令整合如下：</p><div class=\"highlight\"><pre><code class=\"language-bash\">npm install hexo-generator-index --save\nnpm install hexo-generator-archive --save\nnpm install hexo-generator-category --save\nnpm install hexo-generator-tag --save\nnpm install hexo-generator-search --save\nnpm install hexo-server --save\nnpm install hexo-deployer-git --save\nnpm install hexo-renderer-marked --save\nnpm install hexo-renderer-stylus --save\nnpm install hexo-helper-post-top --save\t\nnpm install hexo-math --save</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>安装完成</b></p><p>初始化完成后的文件夹结构是这样的:</p><p>关于该目录下的文件及文件夹说明，可以查看 <a href=\"https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/setup.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hexo官方文档</a>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Hexo 配置</h2><p>配置文件 _config.yml，具体的配置信息还是去 hexo 官方文档看吧。</p><p>建议用专业的文本编辑器编辑该文件，不要用 Win 自带的记事本。我用的是 Visual Studio Code。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>开始写作</h2><p><a href=\"https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/writing.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hexo官方文档</a> 里有对于写作的详细介绍。</p><p>你可以执行下列命令来创建一篇新文章。</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo new <span class=\"o\">[</span>layout<span class=\"o\">]</span> &lt;title&gt;</code></pre></div><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。一般使用默认，也就不需要加上 [layout]。</p><p>比如，我们可以使用如下命令，来创建一个名为 <b>hello</b> 的文章：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo new <span class=\"s2\">&#34;hello&#34;</span></code></pre></div><p>之后，进入存放我们文章的文件夹(\\blog\\source_posts)，可以看到我们的hello.md已经在这了，另外还有一个hello-world.md文件，这是hexo初次安装完成后自动生成的示例文件，这里面写的是一些常用hexo命令，可以删掉这个文件。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c7aead8a34e39bae6765941bc026c8c7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-c7aead8a34e39bae6765941bc026c8c7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;704&#39; height=&#39;114&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"704\" data-rawheight=\"114\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"704\" data-original=\"https://pic4.zhimg.com/v2-c7aead8a34e39bae6765941bc026c8c7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-c7aead8a34e39bae6765941bc026c8c7_b.jpg\"/></figure><p>用文本编辑器或者Markdown编辑器打开helloHexo.md就可以写文章啦~~</p><p>我正在用的Markdown编辑器是：<a href=\"https://link.zhihu.com/?target=https%3A//ivarptr.github.io/yu-writer.site/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Yu Writer - 跨平台的 Markdown 文本编辑器</a></p><p>打开文件后，会看见这里已经有一些模版内容了：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cf7bce640c1c457dc9fbc2602eaa24ca_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb\" width=\"494\" data-original=\"https://pic3.zhimg.com/v2-cf7bce640c1c457dc9fbc2602eaa24ca_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;494&#39; height=&#39;335&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"494\" data-rawheight=\"335\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"494\" data-original=\"https://pic3.zhimg.com/v2-cf7bce640c1c457dc9fbc2602eaa24ca_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cf7bce640c1c457dc9fbc2602eaa24ca_b.jpg\"/></figure><p>这一部分内容官方称为 <a href=\"https://link.zhihu.com/?target=https%3A//hexo.io/zh-cn/docs/front-matter.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Front-matter</a>，可以参考官方文档补充这一部分的内容。</p><p>文章写完后，可以在写作软件上预览一下效果，减少我们修改的次数。</p><p>觉得可以后，可已经我们之前已经安装好的 server 插件，将文章上传到本地服务器进行预览：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo server</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-e5634783f2d06bcfe928b1634d2c4179_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"569\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"569\" data-original=\"https://pic2.zhimg.com/v2-e5634783f2d06bcfe928b1634d2c4179_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;569&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"569\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"569\" data-original=\"https://pic2.zhimg.com/v2-e5634783f2d06bcfe928b1634d2c4179_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-e5634783f2d06bcfe928b1634d2c4179_b.jpg\"/></figure><p>根据提示，在浏览器中输入:</p><div class=\"highlight\"><pre><code class=\"language-text\">http://localhost:4000/</code></pre></div><p>就可以看到最原始状态的博客啦~</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1e3c3b5e11781fb1dd374d2419688e79_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"666\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-1e3c3b5e11781fb1dd374d2419688e79_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;666&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"666\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-1e3c3b5e11781fb1dd374d2419688e79_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1e3c3b5e11781fb1dd374d2419688e79_b.jpg\"/></figure><p>说明：同样的Markdown语法在不同的网站上可能会显示出不同的效果，不过没关系，只要能在Github上显示出我们想要的效果就行了，因为我们的目的就是把博客部署在Github上！</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Hexo 主题设置</h2><p>你是否觉得默认的主题有点丑，你可以在 <a href=\"https://link.zhihu.com/?target=https%3A//hexo.io/themes/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Hexo官方主题商店</a> 或者 Github 上搜索 <code>hexo theme</code> 发掘你中意的主题。</p><p>我使用的是 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/stkevintan/hexo-theme-material-flow\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">MaterialFlow</a> 主题。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>部署博客到 Github 上</h2><p><b>创建 Github 仓库</b></p><p>仓库名字一定要是：{github username}.<a href=\"https://link.zhihu.com/?target=http%3A//github.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.io</span><span class=\"invisible\"></span></a></p><p>比如我的 github 用户名是 shaonianruntu，则仓库名字为：<a href=\"https://link.zhihu.com/?target=http%3A//shaonianruntu.github.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">shaonianruntu.github.io</span><span class=\"invisible\"></span></a></p><p>用户名即是Owner那里的用户名</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0163adb23c8cbb2121b13c44ca20730d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb\" width=\"732\" data-original=\"https://pic2.zhimg.com/v2-0163adb23c8cbb2121b13c44ca20730d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;732&#39; height=&#39;604&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"732\" data-rawheight=\"604\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"732\" data-original=\"https://pic2.zhimg.com/v2-0163adb23c8cbb2121b13c44ca20730d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0163adb23c8cbb2121b13c44ca20730d_b.jpg\"/></figure><p>我这里因为已经创建过了，所以显示了仓库名显示报错，你们初次创建的时候是不会有报错的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>部署配置</b></p><p>配置 _config.yml 文件。</p><p>翻到最下面找到 deploy 这一项，填写：</p><div class=\"highlight\"><pre><code class=\"language-text\">type: git\nrepo: git@github.com:{username}/{username}.github.io.git\nbranch: master</code></pre></div><p>举个例子，如我这里填写的就是：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-94c6e0450d2c5e32b5b5ba7e2dd0a95c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb\" width=\"561\" data-original=\"https://pic1.zhimg.com/v2-94c6e0450d2c5e32b5b5ba7e2dd0a95c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;561&#39; height=&#39;120&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"561\" data-rawheight=\"120\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"561\" data-original=\"https://pic1.zhimg.com/v2-94c6e0450d2c5e32b5b5ba7e2dd0a95c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-94c6e0450d2c5e32b5b5ba7e2dd0a95c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>发布博客</b></p><p>命令行执行：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo g</code></pre></div><p>然后执行：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo d</code></pre></div><p>当控制台输出：INFO Deploy done: git 的时候，说明项目已经成功的发布到github上，耐心等待一会儿，就可以通过访问 {username}.<a href=\"https://link.zhihu.com/?target=http%3A//github.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.io</span><span class=\"invisible\"></span></a> 来访问博客了~~</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>更新博客</b></p><p>hexo new &#34;name&#34; 或者直接在(/source/_posts/)里面新建.md文件</p><p>写完Markdown文章后，执行：</p><div class=\"highlight\"><pre><code class=\"language-bash\">hexo g -d</code></pre></div><p>即可一键部署。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>个人域名配置</h2><p><b>域名注册</b></p><p>既然网站已经建好了，那么一个个性的域名是免不了的，否则使用 {username}.<a href=\"https://link.zhihu.com/?target=http%3A//github.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.io</span><span class=\"invisible\"></span></a> 未免显得太过寒碜。</p><p>至于域名的注册，有很多方法，你可以在 <a href=\"https://link.zhihu.com/?target=https%3A//dnspod.qcloud.com/%3Ffrom%3DqcloudHpHeaderDnspod\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">腾讯云</a>，<a href=\"https://link.zhihu.com/?target=https%3A//wanwang.aliyun.com/domain/%3Fspm%3D5176.8142029.388261.445.23896dfa43KNEx\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">阿里云</a>，<a href=\"https://link.zhihu.com/?target=https%3A//sg.godaddy.com/zh/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">GoDaddy</a> 等网站购买。</p><p>我使用的腾讯云。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>DNS 设置</b></p><p>建议使用 <a href=\"https://link.zhihu.com/?target=https%3A//www.dnspod.cn/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">DNSPod</a> 来进行设置。</p><p>在 DNSPod 中进入个人控制台，选择 <b>域名解析</b>， <b>添加域名</b>，将上面注册好的个人域名添加进去，然后点击 <b>添加记录 </b>添加如下3条记录：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-28441bab6dec8561068bc935fcdedca2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"808\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"808\" data-original=\"https://pic3.zhimg.com/v2-28441bab6dec8561068bc935fcdedca2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;808&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"808\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"808\" data-original=\"https://pic3.zhimg.com/v2-28441bab6dec8561068bc935fcdedca2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-28441bab6dec8561068bc935fcdedca2_b.jpg\"/></figure><p>两条A记录指向的IP分别是：</p><ul><li>192.30.252.153</li><li>192.30.252.154<br/>CNAME记录指向的是你的原博客地址:{username}.<a href=\"https://link.zhihu.com/?target=http%3A//github.io\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">github.io</span><span class=\"invisible\"></span></a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>域名服务器配置</b></p><p>如果你是在腾讯云上购买的域名，那么腾讯云已经自动帮你设置好了DNS。</p><p>如果你在别的网站上购买的域名，那么你需要手动修改DNS，我这里已腾讯云为例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-36d102999cfc9833449951ff6681f94d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"613\" class=\"origin_image zh-lightbox-thumb\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-36d102999cfc9833449951ff6681f94d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1366&#39; height=&#39;613&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1366\" data-rawheight=\"613\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1366\" data-original=\"https://pic2.zhimg.com/v2-36d102999cfc9833449951ff6681f94d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-36d102999cfc9833449951ff6681f94d_b.jpg\"/></figure><p>点击 <b>DNS修改</b>，将域名服务器修改为 DNSPod提供的域名服务器。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-99b6729acfdf22926506f8688a2d989e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-99b6729acfdf22926506f8688a2d989e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;122&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"122\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic3.zhimg.com/v2-99b6729acfdf22926506f8688a2d989e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-99b6729acfdf22926506f8688a2d989e_b.jpg\"/></figure><p>修改完成后显示如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-32fc6fa15fb58b229a9c88ffb5490b14_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb\" width=\"663\" data-original=\"https://pic1.zhimg.com/v2-32fc6fa15fb58b229a9c88ffb5490b14_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;663&#39; height=&#39;504&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"663\" data-rawheight=\"504\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"663\" data-original=\"https://pic1.zhimg.com/v2-32fc6fa15fb58b229a9c88ffb5490b14_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-32fc6fa15fb58b229a9c88ffb5490b14_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>博客内设置</b></p><p>在博客source目录下，新建一个CNAME文件。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-f446442d0d70dbe578a4c785e43de80f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"542\" data-original=\"https://pic4.zhimg.com/v2-f446442d0d70dbe578a4c785e43de80f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;542&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"542\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"542\" data-original=\"https://pic4.zhimg.com/v2-f446442d0d70dbe578a4c785e43de80f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-f446442d0d70dbe578a4c785e43de80f_b.jpg\"/></figure><p>编辑此文件，将你的新域名输入进去：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-773041dfb0acc6b47547422942b77473_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"403\" data-rawheight=\"87\" class=\"content_image\" width=\"403\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;403&#39; height=&#39;87&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"403\" data-rawheight=\"87\" class=\"content_image lazy\" width=\"403\" data-actualsrc=\"https://pic4.zhimg.com/v2-773041dfb0acc6b47547422942b77473_b.jpg\"/></figure><p>然后执行 hexo g -d 重新部署。</p><p>等待一段时间后，你就可以用新域名访问你的博客了。</p><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=http%3A//staroon.pro/2017/07/30/HexoInstall/index.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">利用GitHub Pages + Hexo框架搭建个人博客</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">手把手教你使用Hexo + Github Pages搭建个人独立博客</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//fsh0524.github.io/2016/03/03/LaTeX-in-Hexo/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">LaTeX 在 Hexo 中的使用</a></li><li><a href=\"https://link.zhihu.com/?target=http%3A//wuchong.me/blog/2014/03/14/use-latex-in-blog/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在博客上写LaTex数学公式</a></li></ul>", 
            "topic": [
                {
                    "tag": "Hexo", 
                    "tagLink": "https://api.zhihu.com/topics/19851557"
                }, 
                {
                    "tag": "Github Pages", 
                    "tagLink": "https://api.zhihu.com/topics/19792731"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/31904974", 
            "userName": "晒月亮的孩子", 
            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
            "upvote": 20, 
            "title": "Git安装及控制台美化", 
            "content": "<h2>Git 下载</h2><p>Git for Windows 国内直接从官网下载比较困难，需要翻墙。这里提供一个国内的下载站：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/git-for-win\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">shaonianruntu/git-for-win</a> 。（据知友评论，现在在 VScode 安装时选择附带安装的 git 不翻墙是可行的，大家也可以自己测试一下能否直接从官网下载。如果不行，可以考虑这个 GitHub 地址。）</p><p>大家可以选择自己想要的版本进行下载。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Git 安装</h2><p>第一步，是组件的选择，基本的必要组件都已经默认勾选好了。但是，为了之后的开发方便，能能够实现像在 Linux 一下，在一个文件目录下通过鼠标右键菜单直接调出 Bash 窗口，建议勾选 <b>Git Bash Here</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fce76b7034db188e2b2ea23759e22587_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic4.zhimg.com/v2-fce76b7034db188e2b2ea23759e22587_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic4.zhimg.com/v2-fce76b7034db188e2b2ea23759e22587_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-fce76b7034db188e2b2ea23759e22587_b.jpg\"/></figure><p>第二步，设置调出 Git 的环境变量，我个人安装 Git 的一个很大目的就是能够在 Windows 下使用 Unix 工具，能够将 Windows 的控制台打造的和 Bash 一模一样，所以我选择了第三个选项，同时添加 Git 和 Unix 工具包来代替我的部分 Windows 命令格式。如果你只是想要单纯的使用 Git Bash，可以选择第一个选项。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-35f819149e0c5c4e5985f5b0dc6cb345_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic2.zhimg.com/v2-35f819149e0c5c4e5985f5b0dc6cb345_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic2.zhimg.com/v2-35f819149e0c5c4e5985f5b0dc6cb345_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-35f819149e0c5c4e5985f5b0dc6cb345_b.jpg\"/></figure><p>第三步，选择 HTTPS 的传输后端，默认就好。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-700864885e14b002495357231c1e6470_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic1.zhimg.com/v2-700864885e14b002495357231c1e6470_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic1.zhimg.com/v2-700864885e14b002495357231c1e6470_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-700864885e14b002495357231c1e6470_b.jpg\"/></figure><p>第四步，换行符的处理。在 GitHub 中公开的代码大部分都是以 Mac 或者 Linux 中的 LF(Line Feed)换行。然而，由于 Windows 中是以 CRLF(Carriage Return + Line Feed)换行的，所以在非对应的编辑器中将不能正常显示。在 Git 中可以通过设置自动转换这些换行符，使用 Windows 环境的我们，最好的就是选择第一个选项“Checkout Windows-style, commit Unix-style line endings”。这样，换行符在签出的时候会自动转换为 CRLF，在提交时则会自动转换为 LF 。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f90053ff9274ccc0fb0fd46760301c4c_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic1.zhimg.com/v2-f90053ff9274ccc0fb0fd46760301c4c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic1.zhimg.com/v2-f90053ff9274ccc0fb0fd46760301c4c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f90053ff9274ccc0fb0fd46760301c4c_b.jpg\"/></figure><p>第五步，选择你想要运行 Git Bash 的仿真器。你可以使用单独的 Git GUI 窗口进行运行，也可以在 Windows 的 CMD 终端中使用 Git Bash。我为了使用的方面，选择了第二个，在 CMD 中直接使用 Git Bash。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-242a9eb6bf4c6856f8d595283aa447c6_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-242a9eb6bf4c6856f8d595283aa447c6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-242a9eb6bf4c6856f8d595283aa447c6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-242a9eb6bf4c6856f8d595283aa447c6_b.jpg\"/></figure><p>第六步，选择额外的工具。反正不懂，就全选或者默认就好了。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3387016087b46a1845a3a2fedf606f7e_b.jpg\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-3387016087b46a1845a3a2fedf606f7e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;499&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"499\" data-rawheight=\"387\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"499\" data-original=\"https://pic3.zhimg.com/v2-3387016087b46a1845a3a2fedf606f7e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3387016087b46a1845a3a2fedf606f7e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>控制台格式美化</h2><p><b>下载必要的文件</b></p><ul><li>将 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/Git-setting\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">git-completion.bash</a> 保存在你的主目录（home）中（文件名为 git-completion.bash）。</li><li>将 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/Git-setting\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">git-prompt.sh</a> 保存在你的主目录中（文件名为 git-prompt.sh）。</li><li>下载 bash_profile_course 文件，<a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/Git-setting\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">bash_profile_course</a>。</li><li>如果你的主目录中已有一个名为 .bash_profile 的文件，则将 bash_profile_course 中的内容复制并粘贴到 .bash_profile 的底部。如果没有，将 bash_profile_course 移到你的主目录中，然后将其重命名为 .bash_profile。（可以使用 mv 指令）</li></ul><p><b>重新启动Git Bash</b></p><p>必须关闭 Git Bash，然后重新打开它，这样所有更改才会生效。重新打开后，你将会看到：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-053efe0f57e424bb5eaae71dc934e7d6_b.jpg\" data-rawwidth=\"659\" data-rawheight=\"553\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-053efe0f57e424bb5eaae71dc934e7d6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;553&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"659\" data-rawheight=\"553\" data-caption=\"\" data-size=\"normal\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic3.zhimg.com/v2-053efe0f57e424bb5eaae71dc934e7d6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-053efe0f57e424bb5eaae71dc934e7d6_b.jpg\"/></figure><p>是不是跟我们 Linux 环境下的 Bash 格式很像呢 &gt;.&lt;</p><h2>控制台字体美化</h2><p><b>雅黑Consolas混合字体下载</b></p><p>这是一个 Yahei 和 Consolas 的混合字体，相当漂亮，很适合在Windows平台下编程使用。下面提供 Github 下载地址：<a href=\"https://link.zhihu.com/?target=https%3A//github.com/shaonianruntu/YaHei-Consolas-Hybrid-1.12\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">shaonianruntu/YaHei-Consolas-Hybrid-1.12</a> 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>注册表配置</b></p><ul><li>Win+R 输入 regedit 命令打开注册表。</li><li>在 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Console\\TrueTypeFont] 设置：</li><ul><li>“936”=”YaHei Consolas Hybrid”</li></ul></ul><hr/><p>推荐阅读：</p><ul><li><a href=\"https://link.zhihu.com/?target=https%3A//book.douban.com/subject/26462816/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">《GitHub入门与实践》大塚弘记 著</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//classroom.udacity.com/courses/ud775/lessons/2980038599/concepts/33417185870923\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">在 Windows 上设置你的工作空间</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//www.windows10.pro/win10-open-the-registry-editor-regedit/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Windows 如何打开注册表编辑器</a></li><li><a href=\"https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000004235728\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Windows 下的控制台环境配置</a> </li></ul><p></p>", 
            "topic": [
                {
                    "tag": "Git", 
                    "tagLink": "https://api.zhihu.com/topics/19557710"
                }, 
                {
                    "tag": "命令提示符 (cmd)", 
                    "tagLink": "https://api.zhihu.com/topics/19613320"
                }
            ], 
            "comments": [
                {
                    "userName": "15510752602", 
                    "userLink": "https://www.zhihu.com/people/563fcb4b96dddfe13c83ef6c0a764d19", 
                    "content": "<p>请问下那个控制条美化下边放入主目录的文件是指的Windows平台主目录吗</p><p><br></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "是的，就是Windows下的个人文件夹", 
                            "likes": 0, 
                            "replyToAuthor": "15510752602"
                        }
                    ]
                }, 
                {
                    "userName": "城府", 
                    "userLink": "https://www.zhihu.com/people/c770e85bbc8e9318cc55d872503f6c48", 
                    "content": "<p>请问下为什么复制过后cmd是黑色背景？</p><p></p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "cmd默认就是黑背景，白色。你需要自己设置一下默认值，可以改为白背景，黑字。", 
                            "likes": 1, 
                            "replyToAuthor": "城府"
                        }
                    ]
                }, 
                {
                    "userName": "gatlin", 
                    "userLink": "https://www.zhihu.com/people/3e54811ff794f229a3029358d240e1ad", 
                    "content": "前两天装了vs code，然后要求安装git。<br>没有挂梯子，正常下载安装的。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "晒月亮的孩子", 
                            "userLink": "https://www.zhihu.com/people/3b85799a3ac9e6907de19bd147c9a32b", 
                            "content": "哦哦，好的。我更正一下文章。", 
                            "likes": 0, 
                            "replyToAuthor": "gatlin"
                        }
                    ]
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_147801350"
}
