{
    "title": "cpp幕后故事", 
    "description": "一直以来对C++的各种神奇套路感到非常的好奇，也为之所倾倒，所以我借助《深入探索C++对象模型》这本书，配合自己的浅薄的认识，在VS2013下剖析各种原理。", 
    "followers": [
        "https://www.zhihu.com/people/zda-x", 
        "https://www.zhihu.com/people/liaoer", 
        "https://www.zhihu.com/people/jassy_cauc", 
        "https://www.zhihu.com/people/bu-ke-zhi-lun-de-zhong-shi-tui-chong-zhe", 
        "https://www.zhihu.com/people/zhou-shi-wen-7-59", 
        "https://www.zhihu.com/people/dong-neng-san-jun", 
        "https://www.zhihu.com/people/choligeetu", 
        "https://www.zhihu.com/people/yang-guang-75-68-56", 
        "https://www.zhihu.com/people/katerinabox", 
        "https://www.zhihu.com/people/next-29", 
        "https://www.zhihu.com/people/sheng-lai-zi-you-81", 
        "https://www.zhihu.com/people/kai-yan-54", 
        "https://www.zhihu.com/people/raymon-96", 
        "https://www.zhihu.com/people/xiao-que-97-40", 
        "https://www.zhihu.com/people/liu-yue-yang-620", 
        "https://www.zhihu.com/people/hu-luo-bu-36-27", 
        "https://www.zhihu.com/people/new-dragon", 
        "https://www.zhihu.com/people/zhou-xiang-56-47", 
        "https://www.zhihu.com/people/dianyu-zhu", 
        "https://www.zhihu.com/people/wang-wj-83", 
        "https://www.zhihu.com/people/ricesleep", 
        "https://www.zhihu.com/people/xing-han", 
        "https://www.zhihu.com/people/sunwenqi0713", 
        "https://www.zhihu.com/people/HangFu", 
        "https://www.zhihu.com/people/yes2n", 
        "https://www.zhihu.com/people/wang-yi-41", 
        "https://www.zhihu.com/people/chang-zheng-62", 
        "https://www.zhihu.com/people/silentsummer1024", 
        "https://www.zhihu.com/people/fu-za-ren-zhi-xin-nian-de-hu-li", 
        "https://www.zhihu.com/people/gu-jin-qi", 
        "https://www.zhihu.com/people/lai-kan-25-81", 
        "https://www.zhihu.com/people/yiqiu-3", 
        "https://www.zhihu.com/people/damon307", 
        "https://www.zhihu.com/people/fu-wu-jia-93", 
        "https://www.zhihu.com/people/ci-jian-chen-yuan", 
        "https://www.zhihu.com/people/qing-feng-60-46", 
        "https://www.zhihu.com/people/he-san-14", 
        "https://www.zhihu.com/people/chen-you-13-25", 
        "https://www.zhihu.com/people/20ge-ying-wen-zi-fu", 
        "https://www.zhihu.com/people/he-he-26-96-74", 
        "https://www.zhihu.com/people/jian-dao-shou-a-ming", 
        "https://www.zhihu.com/people/liu-yang-42-25", 
        "https://www.zhihu.com/people/hangcui", 
        "https://www.zhihu.com/people/ou-yang-cai-qing", 
        "https://www.zhihu.com/people/mi-yang-36-53", 
        "https://www.zhihu.com/people/viridis-setaria", 
        "https://www.zhihu.com/people/maxim-luo", 
        "https://www.zhihu.com/people/wang-xiao-wei-75-48", 
        "https://www.zhihu.com/people/akoon", 
        "https://www.zhihu.com/people/opba-qi", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/wang-hua-yu-75", 
        "https://www.zhihu.com/people/yi-yue-97-35", 
        "https://www.zhihu.com/people/chen-xiao-52-69-70", 
        "https://www.zhihu.com/people/huang-yi-68-68", 
        "https://www.zhihu.com/people/tu-su-65-34", 
        "https://www.zhihu.com/people/liubang-10", 
        "https://www.zhihu.com/people/knox007", 
        "https://www.zhihu.com/people/wang-xiao-lin-91", 
        "https://www.zhihu.com/people/huang-han-tao-54", 
        "https://www.zhihu.com/people/stone-27-11", 
        "https://www.zhihu.com/people/tianrui007", 
        "https://www.zhihu.com/people/ping-liu-47-52", 
        "https://www.zhihu.com/people/xie-fa-18", 
        "https://www.zhihu.com/people/liu-feng-kuang-5", 
        "https://www.zhihu.com/people/xin-yuan-98-47", 
        "https://www.zhihu.com/people/qu-na-wan-er", 
        "https://www.zhihu.com/people/bai-zhi-wei", 
        "https://www.zhihu.com/people/shen-shui-57-31", 
        "https://www.zhihu.com/people/smallwinds", 
        "https://www.zhihu.com/people/shang-ying-zhi-30", 
        "https://www.zhihu.com/people/lu-bo-40-95", 
        "https://www.zhihu.com/people/ji-xiao-mi-16", 
        "https://www.zhihu.com/people/askmayday", 
        "https://www.zhihu.com/people/jiong-gu-33", 
        "https://www.zhihu.com/people/rong-qiao-23", 
        "https://www.zhihu.com/people/Alex_ZH", 
        "https://www.zhihu.com/people/rui-wen-56-50", 
        "https://www.zhihu.com/people/JackyWu", 
        "https://www.zhihu.com/people/buddy0807", 
        "https://www.zhihu.com/people/sun-hao-tian-20", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/ban-juan-shu-82", 
        "https://www.zhihu.com/people/shu-zhang-18", 
        "https://www.zhihu.com/people/wu-xiao-er-32-70", 
        "https://www.zhihu.com/people/Struggler_lr", 
        "https://www.zhihu.com/people/zuo-cang-qian-dai-52", 
        "https://www.zhihu.com/people/yuboya", 
        "https://www.zhihu.com/people/ma-ma-91-85", 
        "https://www.zhihu.com/people/han-lu-34-27", 
        "https://www.zhihu.com/people/jaywoody", 
        "https://www.zhihu.com/people/huang-xin-wei-52", 
        "https://www.zhihu.com/people/xu-ming-ming-78-15", 
        "https://www.zhihu.com/people/wang-ya-zhou-1", 
        "https://www.zhihu.com/people/qi-ri-qia-nong", 
        "https://www.zhihu.com/people/zhang-xiao-mao-10-53", 
        "https://www.zhihu.com/people/fei-shou-shou-45", 
        "https://www.zhihu.com/people/heylypp", 
        "https://www.zhihu.com/people/bobzongrong", 
        "https://www.zhihu.com/people/zhi-ye-fei-ren", 
        "https://www.zhihu.com/people/shen-you-tai-bao", 
        "https://www.zhihu.com/people/who-lee", 
        "https://www.zhihu.com/people/liao-bu-qi-de-yan-ke-xia", 
        "https://www.zhihu.com/people/jelly-31-14", 
        "https://www.zhihu.com/people/liqiong", 
        "https://www.zhihu.com/people/fish-rain", 
        "https://www.zhihu.com/people/liuxin-8035", 
        "https://www.zhihu.com/people/pang-zi-66-36", 
        "https://www.zhihu.com/people/qi-yi-ke-97", 
        "https://www.zhihu.com/people/cang-hai-qu-zhu", 
        "https://www.zhihu.com/people/what-so-", 
        "https://www.zhihu.com/people/doeljh", 
        "https://www.zhihu.com/people/cha-zhu-6", 
        "https://www.zhihu.com/people/chen-gao-shuang", 
        "https://www.zhihu.com/people/ba-ba-ba-14-23", 
        "https://www.zhihu.com/people/zwq-37-6", 
        "https://www.zhihu.com/people/lee-87-75", 
        "https://www.zhihu.com/people/carrymore", 
        "https://www.zhihu.com/people/chen-qi-22-14-47", 
        "https://www.zhihu.com/people/enigmawl", 
        "https://www.zhihu.com/people/yuan-xin-82", 
        "https://www.zhihu.com/people/mei-xi-91-32", 
        "https://www.zhihu.com/people/zhu-zhu-71-86", 
        "https://www.zhihu.com/people/deng-yu-55", 
        "https://www.zhihu.com/people/ldh137", 
        "https://www.zhihu.com/people/chen-long-56-23", 
        "https://www.zhihu.com/people/anubis627", 
        "https://www.zhihu.com/people/robin-pony", 
        "https://www.zhihu.com/people/liu-hao-77-3", 
        "https://www.zhihu.com/people/sun-qing-yang-55", 
        "https://www.zhihu.com/people/liu-yong-qiang-95", 
        "https://www.zhihu.com/people/man-22-1", 
        "https://www.zhihu.com/people/ai-yang-50-40", 
        "https://www.zhihu.com/people/luoweisong", 
        "https://www.zhihu.com/people/lan-ye-ming-yi-56", 
        "https://www.zhihu.com/people/bmw-gss", 
        "https://www.zhihu.com/people/qi-jin-mu-88", 
        "https://www.zhihu.com/people/su-zhu-95-16", 
        "https://www.zhihu.com/people/struct-78", 
        "https://www.zhihu.com/people/shen-shui-10-11", 
        "https://www.zhihu.com/people/forest-monk", 
        "https://www.zhihu.com/people/zhao-guang-32-42", 
        "https://www.zhihu.com/people/ding-kun-1-63", 
        "https://www.zhihu.com/people/sweedy-56", 
        "https://www.zhihu.com/people/tony-xian-6", 
        "https://www.zhihu.com/people/123456abcdef-51", 
        "https://www.zhihu.com/people/zhao-guang-65", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/allen-77-98", 
        "https://www.zhihu.com/people/wen-yi-62-84", 
        "https://www.zhihu.com/people/herakles-86", 
        "https://www.zhihu.com/people/jia-ming-94-27", 
        "https://www.zhihu.com/people/oliver-kahn-60", 
        "https://www.zhihu.com/people/god-thanra", 
        "https://www.zhihu.com/people/jin-xiao-71-98", 
        "https://www.zhihu.com/people/arslan-27-67", 
        "https://www.zhihu.com/people/qiu-tian-25-59-81", 
        "https://www.zhihu.com/people/buerse", 
        "https://www.zhihu.com/people/yang-wen-16-42", 
        "https://www.zhihu.com/people/meng-xian-peng-89", 
        "https://www.zhihu.com/people/tang-xin-miao-44", 
        "https://www.zhihu.com/people/da-guo-13", 
        "https://www.zhihu.com/people/luo-xiao-qi-39", 
        "https://www.zhihu.com/people/wangpp-42", 
        "https://www.zhihu.com/people/ni-wa-wa-26-54", 
        "https://www.zhihu.com/people/cugtyt", 
        "https://www.zhihu.com/people/zhou-li-peng-27", 
        "https://www.zhihu.com/people/cooldtp-skin", 
        "https://www.zhihu.com/people/li-ke-te-43", 
        "https://www.zhihu.com/people/mefattiger", 
        "https://www.zhihu.com/people/tianbao-zhang", 
        "https://www.zhihu.com/people/xia-tian-de-feng-9-40", 
        "https://www.zhihu.com/people/li-li-4-91-98", 
        "https://www.zhihu.com/people/eiilpux17", 
        "https://www.zhihu.com/people/gaogaihetao", 
        "https://www.zhihu.com/people/zi-fei-yu-76-10", 
        "https://www.zhihu.com/people/i-believe-57", 
        "https://www.zhihu.com/people/dougpuob", 
        "https://www.zhihu.com/people/spongebob-53-24", 
        "https://www.zhihu.com/people/xu-rui-96-23", 
        "https://www.zhihu.com/people/xuhaibin-36", 
        "https://www.zhihu.com/people/tong-yu-lll-7", 
        "https://www.zhihu.com/people/yao-yuan-de-xin-hu", 
        "https://www.zhihu.com/people/17368080695", 
        "https://www.zhihu.com/people/chang-shi-yao", 
        "https://www.zhihu.com/people/zhi-san-25", 
        "https://www.zhihu.com/people/yotta", 
        "https://www.zhihu.com/people/lzueclipse", 
        "https://www.zhihu.com/people/datacracker", 
        "https://www.zhihu.com/people/yu-sagood", 
        "https://www.zhihu.com/people/goon-king-24", 
        "https://www.zhihu.com/people/AIBottle", 
        "https://www.zhihu.com/people/zhao-han-81-42", 
        "https://www.zhihu.com/people/lukopy", 
        "https://www.zhihu.com/people/qing-sheng-xian-sen-1", 
        "https://www.zhihu.com/people/liu-yu-long-52", 
        "https://www.zhihu.com/people/qiu-xie-71-24-69", 
        "https://www.zhihu.com/people/tian-ti-yun-xing-lun", 
        "https://www.zhihu.com/people/gq-zhou-63", 
        "https://www.zhihu.com/people/hao_yuan", 
        "https://www.zhihu.com/people/chen-kai-7-76", 
        "https://www.zhihu.com/people/yu-hai-long-22", 
        "https://www.zhihu.com/people/Jiantao-Xu", 
        "https://www.zhihu.com/people/hello-27-14-13", 
        "https://www.zhihu.com/people/james732", 
        "https://www.zhihu.com/people/ma-xiang-bin", 
        "https://www.zhihu.com/people/wang-nan-36-86-31", 
        "https://www.zhihu.com/people/jiang-wen-ming-15", 
        "https://www.zhihu.com/people/luo-dun-lang-64", 
        "https://www.zhihu.com/people/wo-huan-xiang-ta-59-39", 
        "https://www.zhihu.com/people/cai-qin-yi", 
        "https://www.zhihu.com/people/youle-wu", 
        "https://www.zhihu.com/people/osblow", 
        "https://www.zhihu.com/people/liu-fei-94-95", 
        "https://www.zhihu.com/people/hum-75", 
        "https://www.zhihu.com/people/converseart", 
        "https://www.zhihu.com/people/sfzhao", 
        "https://www.zhihu.com/people/gangbj-gangbj"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/88808026", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 0, 
            "title": "C++幕后故事（十）--对象离我们而去", 
            "content": "<p>读者如果觉得我文章还不错的，，希望可以多多支持下我，文章可以转发，但是必须保留原出处和原作者署名。<b>为了获取更好的阅读体验请关注微信公众号</b>。更多内容请关注我的微信公众号：<b>cpp手艺人</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p>三国演义里面说过一句话：天下大事，合久必分，分久必合。有相聚，就有分离的时候。今天我们主要聊聊operator delete的故事</p><p>今天我们主要学习知识点：</p><blockquote> 1.delete的调用流程。 2.我们重载了delete之后能干啥。 3.placement delete有啥用。<br/> </blockquote><h2>1. operator delete操作符的原理</h2><h3>1.1 operator delete 调用流程</h3><p>测试代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/****************************************************************************\n</span><span class=\"cm\">**\n</span><span class=\"cm\">** Copyright (C) 2019 635672377@qq.com\n</span><span class=\"cm\">** All rights reserved.\n</span><span class=\"cm\">**\n</span><span class=\"cm\">****************************************************************************/</span>\n\n<span class=\"cm\">/*\n</span><span class=\"cm\">    测试对象的new、delete，在VS2017更容易观察\n</span><span class=\"cm\">*/</span>\n<span class=\"cp\">#ifndef obj_new_delete_h\n</span><span class=\"cp\">#define obj_new_delete_h\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;new&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;memory&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"p\">;</span> \n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n<span class=\"k\">namespace</span> <span class=\"n\">obj_new_delete</span> \n<span class=\"p\">{</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Obj</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Obj</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Obj ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">Obj</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Obj dtor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_new_obj</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"k\">delete</span> <span class=\"n\">obj</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// obj_new_delete_h\n</span></code></pre></div><p>老规矩，我们转到反汇编的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">00287340  mov         eax,dword ptr [obj]  \n          ; delete obj\n00287343  mov         dword ptr [ebp-104h],eax  \n00287349  mov         ecx,dword ptr [ebp-104h]  \n0028734F  mov         dword ptr [ebp-0F8h],ecx  \n          ; 如果ecx为0，不用调用operator delete和析构函数\n00287355  cmp         dword ptr [ebp-0F8h],0  \n0028735C  je          obj_new_delete::test_delete_obj+0D3h (0287373h)  \n0028735E  push        1  \n00287360  mov         ecx,dword ptr [ebp-0F8h]\n          ; 析构代理函数\n00287366  call        obj_new_delete::Obj::`scalar deleting destructor&#39; (0281212h)  \n0028736B  mov         dword ptr [ebp-10Ch],eax  \n00287371  jmp         obj_new_delete::test_delete_obj+0DDh (028737Dh)  \n00287373  mov         dword ptr [ebp-10Ch],0 \n\nobj_new_delete::Obj::`scalar deleting destructor&#39;:\n00281212  jmp         obj_new_delete::Obj::`scalar deleting destructor&#39; (0282820h) \n\n00282840  mov         dword ptr [this],ecx  \n00282843  mov         ecx,dword ptr [this]  \n          ; 调用对象的析构函数\n00282846  call        obj_new_delete::Obj::~Obj (02814C4h)  \n0028284B  mov         eax,dword ptr [ebp+8] \n          ; 需要释放内存\n0028284E  and         eax,1  \n00282851  je          obj_new_delete::Obj::`scalar deleting destructor&#39;+41h (0282861h)  \n\n00282853  push        4  \n00282855  mov         eax,dword ptr [this]  \n          ; 传递对象的首地址放到eax寄存器中\n00282858  push        eax\n          ; 调用局部的operator delete，第一参数为首地址，第二个参数为对象的大小\n00282859  call        operator delete (0281325h)  \n0028285E  add         esp,8  \n00282861  mov         eax,dword ptr [this]  \n\noperator delete:\n00281325  jmp         operator delete (02832E0h) \n\n; 调用全局的operator delete，只有一个参数为首地址\noperator delete:\n002811B3  jmp         operator delete (02840C0h)</code></pre></div><p>这里我顺便把operator delete的源码贴出来</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 局部operator delete源码\n</span><span class=\"c1\"></span><span class=\"n\">_CRT_SECURITYCRITICAL_ATTRIBUTE</span>\n<span class=\"kt\">void</span> <span class=\"n\">__CRTDECL</span> <span class=\"k\">operator</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"k\">const</span> <span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"n\">size_t</span> <span class=\"k\">const</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">);</span> \n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 全局operator delete源码\n</span><span class=\"c1\"></span><span class=\"n\">_CRT_SECURITYCRITICAL_ATTRIBUTE</span>\n<span class=\"kt\">void</span> <span class=\"n\">__CRTDECL</span> <span class=\"k\">operator</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"k\">const</span> <span class=\"n\">block</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span>\n<span class=\"p\">{</span>\n    <span class=\"cp\">#ifdef _DEBUG\n</span><span class=\"cp\"></span>    <span class=\"n\">_free_dbg</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">,</span> <span class=\"n\">_UNKNOWN_BLOCK</span><span class=\"p\">);</span> \n    <span class=\"cp\">#else\n</span><span class=\"cp\"></span>    <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">block</span><span class=\"p\">);</span>\n    <span class=\"cp\">#endif\n</span><span class=\"cp\"></span><span class=\"p\">}</span>\n</code></pre></div><p>根据这汇编代码我画出流程图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-724b42b6f8ca51be39100562f7c879bd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"435\" data-rawheight=\"491\" class=\"origin_image zh-lightbox-thumb\" width=\"435\" data-original=\"https://pic2.zhimg.com/v2-724b42b6f8ca51be39100562f7c879bd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;435&#39; height=&#39;491&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"435\" data-rawheight=\"491\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"435\" data-original=\"https://pic2.zhimg.com/v2-724b42b6f8ca51be39100562f7c879bd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-724b42b6f8ca51be39100562f7c879bd_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>看到了这张流程图，你一定对图中○1,○2有几点有疑问。</p><p>1.什么析构代理函数？</p><blockquote> 从名字中就可以看出就是个代理函数，它从中不仅调用我们自己写的析构函数，还做点其他幕后事情，比如流程图中的是否需要释放内存<br/> </blockquote><p>2.为什么在流程图中还有个是否需要释放内存的判断？</p><p>大家请看这段代码，是否会释放内存。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_delete_obj</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"n\">obj</span><span class=\"o\">-&gt;~</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>如果我们自己手动调用了析构函数，这时系统是不会帮我们释放内存的。</p><p>我把上面的代码反汇编看下：</p><div class=\"highlight\"><pre><code class=\"language-text\">; obj-&gt;~Obj()\n00EF7340  push        0  \n00EF7342  mov         ecx,dword ptr [obj]  \n00EF7345  call        obj_new_delete::Obj::`scalar deleting destructor&#39; (0EF1212h)</code></pre></div><p>可以看到这里首先push 0作为一个参数，push 0就表示仅仅调用析构函数，并不会释放内存。仔细看operator delete反汇编代码，这里push 1作为参数，表示需要释放内存，我在上面也做了注释。</p><ol><li>为什么NULL指针，可以被delete多次。</li></ol><blockquote> 因为C++运行时系统在delete就已经判断了，如果指针为空则不会调用delete。<br/> </blockquote><p>最后我们需要注意下：</p><ol><li>我们代码调用的析构函数，其实不是我们自己写的析构函数，而是编译器写的析构代理函数。</li><li>析构代理函数里面又做了其他的事，比如是否需要释放内存，再比如对象数组又是怎么释放内存。</li></ol><h3>1.2 重载delete操作符</h3><p>只要我们重载了operator new，就应该对应的重载operator delete，他们两个是一一对应的东西。具体怎么重载的，在《我们来new个对象》中已经贴出代码了。</p><h2>2. placement delete</h2><h3>2.1 什么是placement delete?</h3><blockquote> 与placement new是个对应，前者是为了在原有内存上再次构造对象。后者是为了在异常负责回收内存。<br/> </blockquote><h3>2.2 placement delete作用</h3><blockquote> 在一般情况下，其实placement delete起不到作用的。只有在异常情况下，才会被C++运行时系统调用，用来释放内存。<br/> </blockquote><h3>2.3 placement delete重载</h3><p>具体怎么重载的，就不在多说了，在《我们来new个对象》中已经贴出代码了。</p><h3>2.4 一窥系统的placement delete源码</h3><p>这个源码在vcruntime_new.h中</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kr\">inline</span> <span class=\"kt\">void</span> <span class=\"n\">__CRTDECL</span> <span class=\"k\">operator</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">*</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>恐怕会让你有点失望，在vs2017的版本中，这个什么里面都没有做的。搞的我也是摸不着头脑。</p><h2>3.总结</h2><p>这节我们知道了operator delete调用流程，对对象的消失有了更深入的理解。同时知道了析构代理函数存在以及作用。 placement delete作用也是不容我们忽视的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3937138ea53e007df4655ad5470b3907_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"486\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb\" width=\"486\" data-original=\"https://pic4.zhimg.com/v2-3937138ea53e007df4655ad5470b3907_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;486&#39; height=&#39;412&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"486\" data-rawheight=\"412\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"486\" data-original=\"https://pic4.zhimg.com/v2-3937138ea53e007df4655ad5470b3907_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-3937138ea53e007df4655ad5470b3907_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "深度探索C++对象模型（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20126432"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/87760996", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 5, 
            "title": "C++幕后故事（九）--我们来new个对象", 
            "content": "<p>读者如果觉得我文章还不错的，，希望可以多多支持下我，文章可以转发，但是必须保留原出处和原作者署名。<b>为了获取更好的阅读体验请关注微信公众号</b>。更多内容请关注我的微信公众号：<b>cpp手艺人</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c6555306acafbf884f59301aa869feed_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"774\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"774\" data-original=\"https://pic2.zhimg.com/v2-c6555306acafbf884f59301aa869feed_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;774&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"774\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"774\" data-original=\"https://pic2.zhimg.com/v2-c6555306acafbf884f59301aa869feed_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c6555306acafbf884f59301aa869feed_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>今天我们主要学习知识点：</p><blockquote>1.new的调用流程。<br/>2.我们重载了new之后能干啥。<br/>3.placement new干啥的。<br/>4.set_new_handler是什么。</blockquote><h2>1. operator new操作符的原理</h2><h2>1.1 operator new 调用流程</h2><p>测试代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/****************************************************************************\n</span><span class=\"cm\">**\n</span><span class=\"cm\">** Copyright (C) 2019 635672377@qq.com\n</span><span class=\"cm\">** All rights reserved.\n</span><span class=\"cm\">**\n</span><span class=\"cm\">****************************************************************************/</span>\n\n<span class=\"cm\">/*\n</span><span class=\"cm\">    测试对象的new、delete，在VS2017更容易观察\n</span><span class=\"cm\">*/</span>\n<span class=\"cp\">#ifndef obj_new_delete_h\n</span><span class=\"cp\">#define obj_new_delete_h\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;new&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;memory&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"p\">;</span> \n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n<span class=\"k\">namespace</span> <span class=\"n\">obj_new_delete</span> \n<span class=\"p\">{</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Obj</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Obj</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Obj ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">Obj</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Obj dtor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_new_obj</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"k\">delete</span> <span class=\"n\">obj</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// obj_new_delete_h\n</span></code></pre></div><p>我们在Obj *obj = new Obj();处下个断点，再打开反汇编窗口，我摘取主要的代码。 markdown的汇编代码不能高亮，看的很难受啊，还是前往公众号可以获取更好的阅读体验。</p><div class=\"highlight\"><pre><code class=\"language-text\">; Obj *obj = new Obj();\n00DE2C47  push        4  \n00DE2C49  call        operator new (0DE141Ah)  \n00DE2C4E  add         esp,4  \n00DE2C51  mov         dword ptr [ebp-0ECh],eax  \n00DE2C57  mov         dword ptr [ebp-4],0  \n00DE2C5E  cmp         dword ptr [ebp-0ECh],0  \n00DE2C65  je          obj_new_delete::test_new_obj+7Ah (0DE2C7Ah)  \n00DE2C67  mov         ecx,dword ptr [ebp-0ECh]  \n; 调用对象的构造函数\n00DE2C6D  call        obj_new_delete::Obj::Obj (0DE1456h)</code></pre></div><p>我在::operator new的汇编代码处，点击菜单“转到源代码”，就可以还原为C++代码，这个代码的源文件叫做new_scalar.cpp：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">__CRTDECL</span> <span class=\"k\">operator</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"k\">const</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">for</span> <span class=\"p\">(;;)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 这个有个小技巧，控制变量的作用域，没必要让其他对象见到这个变量的作用域\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"k\">const</span> <span class=\"n\">block</span> <span class=\"o\">=</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">))</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">return</span> <span class=\"n\">block</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// _callnew内部会调用new_handler，\n</span><span class=\"c1\">// 返回值为0表示new_handler类型函数为null，这样就不会调用new_handler类型函数，\n</span><span class=\"c1\">// 抛出两个其中一个的异常，大小异常，内存分配异常。\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 否则就会调用设置的new_handler类型函数\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">_callnewh</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"p\">{</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">size</span> <span class=\"o\">==</span> <span class=\"n\">SIZE_MAX</span><span class=\"p\">)</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">__scrt_throw_std_bad_array_new_length</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">else</span>\n            <span class=\"p\">{</span>\n                <span class=\"n\">__scrt_throw_std_bad_alloc</span><span class=\"p\">();</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"c1\">// The new handler was successful; try to allocate again...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>到这里，我们基本上能够知道operator new调用过程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6454d952395133e7000f98ea13bdbfc3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"862\" data-rawheight=\"987\" class=\"origin_image zh-lightbox-thumb\" width=\"862\" data-original=\"https://pic4.zhimg.com/v2-6454d952395133e7000f98ea13bdbfc3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;862&#39; height=&#39;987&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"862\" data-rawheight=\"987\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"862\" data-original=\"https://pic4.zhimg.com/v2-6454d952395133e7000f98ea13bdbfc3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-6454d952395133e7000f98ea13bdbfc3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从代码上看operator new做了两件事：</p><blockquote>1.获取到新的内存。<br/>2.调用对象的构造函数（从汇编代码看，这一步是编译器插入的，但是很多书上把这一步归为operator new。）</blockquote><h2>1.2 重载new操作符</h2><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 重载global new\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"o\">*</span> <span class=\"k\">operator</span> <span class=\"nf\">new</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"k\">const</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 重载global delete\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"k\">operator</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Obj</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Obj</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Obj ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">Obj</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Obj dtor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 重载局部 new\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"k\">operator</span> <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"k\">const</span> <span class=\"n\">size</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">Obj</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// 重载局部delete\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">::</span><span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"n\">head</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>其实重载operator new的代码很简单。</p><blockquote> 重载局部operator new，只需要将operator new作为类的普通成员变量就可以 重载全局operator new，只要在全局位置声明::operator new的实现函数</blockquote><h2>1.3 重载operator new有啥用？</h2><p>实话说，这个重载的作用非常之大。 说一个自己经历过的项目bug。因为项目着急上线，准备发包的前夕，测试反馈说测试大量数据时，软件发生偶然性的崩溃，时间不固定。当时都准备收拾书包回家了，听到有bug，心中真的有万马奔腾感觉。没办法，只好查看生成dump文件，windbg挂上。发现是在多线程下野指针的问题，不知道谁释放了资源，又进行了二次释放。当时在晚上思维都有点迟缓了，调到了后半夜都没有解决的思路。最后想到了一招，就是重载了operator new和operator delete，在这两个函数里面记录一些标志性的信息，最后定位问题的所在。那一夜，我见到了上海5点钟的软件园灯火闪烁。</p><ol><li>可以用来检测运用上的错误</li><li>可以提高效率，节省不必要的内存，提高回收和分配的速度（比如针对某一对象的内存池）</li><li>可以收集对内存使用的数据统计。</li></ol><p>tips:</p><blockquote>1.malloc(0)会返回一个正常的地址，但是这个地址不能存储任何东西。 </blockquote><h2>2. placement new</h2><h2>2.1.什么是placement new?</h2><blockquote>1.  在用户指定的内存上构建对象，这个过程不会申请新的内存，只会调用对象的构造函数即可。</blockquote><p>看代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_placement_new</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">buff</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Obj</span><span class=\"p\">)];</span>\n    <span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">ojb</span> <span class=\"o\">=</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">)</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>老套路，在VS 2017下转到反汇编的窗口。</p><div class=\"highlight\"><pre><code class=\"language-text\">; char *buff = new char[sizeof(Obj)];\n00892558  push        4  \n0089255A  call         operator new[] (0891118h)  \n0089255F  add         esp,4  \n          ; eax中保存了new char返回的首地址\n00892562  mov         dword ptr [ebp-0E0h],eax  \n00892568  mov         eax,dword ptr [ebp-0E0h]  \n0089256E  mov         dword ptr [buff],eax  \n          ; Obj *ojb = new(buff)Obj();\n          ; 将eax中的首地址作为参数传递进去\n00892571  mov         eax,dword ptr [buff]\n00892574  push         eax  \n          ; Obj对象的大小\n00892575  push        4  \n00892577  call          operator new (0891550h)  \n0089257C  add         esp,8  \n0089257F  mov         dword ptr [ebp-0ECh],eax  \n00892585  mov         ecx,dword ptr [ebp-0ECh]  \n          ; 调用Obj的构造函数\n0089258B  call          obj_new_delete::Obj::Obj (0891456h)  \n00892590  mov         dword ptr [ojb],eax</code></pre></div><p>再调用operator new，我单步调试进去发现调用的operator new函数原型如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">_Ret_notnull_</span> <span class=\"nf\">_Post_writable_byte_size_</span><span class=\"p\">(</span><span class=\"n\">_Size</span><span class=\"p\">)</span> <span class=\"n\">_Post_satisfies_</span><span class=\"p\">(</span><span class=\"k\">return</span> <span class=\"o\">==</span> <span class=\"n\">_Where</span><span class=\"p\">)</span>\n<span class=\"kr\">inline</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">__CRTDECL</span> <span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">_Size</span><span class=\"p\">,</span> <span class=\"n\">_Writable_bytes_</span><span class=\"p\">(</span><span class=\"n\">_Size</span><span class=\"p\">)</span> <span class=\"kt\">void</span><span class=\"o\">*</span> <span class=\"n\">_Where</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span>\n<span class=\"p\">{</span>\n    <span class=\"p\">(</span><span class=\"kt\">void</span><span class=\"p\">)</span><span class=\"n\">_Size</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">_Where</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><blockquote> 1. 函数原型为：inline void<i> __CRTDECL operator new(size_t _Size, void</i> _Where) noexcept，返回用户传入的地址。<br/>2. 调用类的构造函数（从汇编角度看，构造函数代码是编译器插入的，但是很多书上把这一步归为placement new）。</blockquote><h2>2.2 placement new作用</h2><p>以前刚学到这个语法的时候，我觉得这个能有啥用，谁这么无聊在同一块内存捯饬个不停。直到有天我看到vector的实现源码，才知道当年的自己想法还是很白开水的。 在STL容器中vector在申请内存的时候为了提高效率，每次申请的内存都是比实际需要的大2倍。但是这跟placement new有什么关系。</p><p>我举个例子说明：</p><p>你向vector中push了2个元素，此时vector的实际内存是为4个的。这是你再向vector中push一个元素，因为vector还有2个未用的空间，所以不需要申请内存。这样就可以在原来那块已经分配好的内存中调用元素的构造函数就可以了。而这里就恰恰用到了placement new了。</p><p>我摘抄SGI STL 3.0版本的里面的源代码供大家参考下</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">T1</span><span class=\"p\">,</span> <span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">T2</span><span class=\"o\">&gt;</span>\n<span class=\"kr\">inline</span> <span class=\"kt\">void</span> <span class=\"n\">construct</span><span class=\"p\">(</span><span class=\"n\">T1</span><span class=\"o\">*</span> <span class=\"n\">p</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">T2</span><span class=\"o\">&amp;</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">T1</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// vector push_back函数\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">finish</span> <span class=\"o\">!=</span> <span class=\"n\">end_of_storage</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">construct</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">);</span>         \n      <span class=\"o\">++</span><span class=\"n\">finish</span><span class=\"p\">;</span>                             \n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span>                               \n      <span class=\"n\">insert_aux</span><span class=\"p\">(</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"n\">x</span><span class=\"p\">);</span>         \n<span class=\"p\">}</span>\n</code></pre></div><h2>2.3 placement new重载</h2><p>代码如下：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Obj</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Obj</span><span class=\"p\">()</span><span class=\"o\">:</span><span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Obj ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">Obj</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Obj dtor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 重载内置版本placement new\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">address</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;void *operator new(size_t size, void *address) version&#34;</span> \n             <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">address</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 重载内置版本placement delete\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">address</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">::</span><span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"n\">address</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"c1\">// 重载placement new\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">size_t</span> <span class=\"n\">size</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"kt\">long</span> <span class=\"n\">extra</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;void *operator new(size_t size, void *address, long extra) &#34;</span>\n                <span class=\"s\">&#34; version&#34;</span> \n             <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34; extra:&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">extra</span> <span class=\"o\">&lt;&lt;</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span> <span class=\"n\">address</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n    <span class=\"c1\">// 重载placement delete\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"n\">address</span><span class=\"p\">,</span> <span class=\"kt\">long</span> <span class=\"n\">extra</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">::</span><span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"n\">address</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_placement_new</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">buff</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">char</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Obj</span><span class=\"p\">)];</span>\n    <span class=\"c1\">// Obj *ojb = new(std::cerr)Obj();\n</span><span class=\"c1\"></span>    <span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">obj</span> <span class=\"o\">=</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">)</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n    <span class=\"n\">obj</span><span class=\"o\">-&gt;~</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n<span class=\"n\">Obj</span> <span class=\"o\">*</span><span class=\"n\">obj_1</span> <span class=\"o\">=</span> <span class=\"k\">new</span><span class=\"p\">(</span><span class=\"n\">buff</span><span class=\"p\">,</span> <span class=\"mi\">123456</span><span class=\"p\">)</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n    <span class=\"n\">obj_1</span><span class=\"o\">-&gt;~</span><span class=\"n\">Obj</span><span class=\"p\">();</span>\n\n<span class=\"k\">delete</span> <span class=\"n\">buff</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 打印结果\n</span><span class=\"c1\"></span>    <span class=\"c1\">// void *operator new(size_t size, void *address) version\n</span><span class=\"c1\"></span>    <span class=\"c1\">// Obj ctor\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~Obj ctor\n</span><span class=\"c1\"></span>    <span class=\"c1\">// void *operator new(size_t size, void *address, long extra) version extra:123456 \n</span><span class=\"c1\"></span>    <span class=\"c1\">// Obj ctor\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~Obj ctor\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h2>2.4 placement new注意事项</h2><blockquote>1.如果你重载了placement new，那么一定要重载对应的placement delete。因为在对象的构造函数抛出异常时，C++运行时系统需要找到对应的placement delete去释放内存。否则可能有内存泄露的风险。<br/>2.重载了placement new会隐藏正常operator new导致编译语法错误。如何避免后面我有机会写出完整的代码。<br/>3.使用了placement new，需要对内存的释放要注意，并不能直接delete。因为这块内存并不是你来申请的，你应该直接调用你自己对象的析构函数。</blockquote><h2>3.set_new_handler</h2><h2>3.1 .set_new_handler是什么？</h2><blockquote> 首先它是个位于std命名空间的全局函数，参数类型为函数指针 void (*new_hander)()</blockquote><h2>3.2 set_new_handler有什么用？</h2><blockquote> 当用户使用operator new无法返回正确的内存地址，这时C++编译器就会调用一个客户指定的错误处理函数。这个错误处理函数就是通过set_new_handler来指定的。</blockquote><h2>3.3 new_handler函数注意事项</h2><blockquote>1.new_handler让更多内存可以被使用<br/>2.如果不能获取到更多有用的内存抛出异常或者直接终止程序运行。（必须要这样做，因为new包含是死循环操作）</blockquote><p>写一个实例代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">new_exception_handler</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;memory cout...&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"n\">abort</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_new_obj</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 测试new_set_handler\n</span><span class=\"c1\"></span>    <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">new_handler</span> <span class=\"n\">old_handler</span> <span class=\"o\">=</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">set_new_handler</span><span class=\"p\">(</span><span class=\"n\">new_exception_handler</span><span class=\"p\">);</span>\n\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">new</span> <span class=\"kt\">int</span><span class=\"p\">[</span><span class=\"mi\">100000000ul</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;end...&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"c1\">// memory cout...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h2>4.总结</h2><p>看到operator new的源代码，会发现原理很简单，本质上是对malloc的封装。从汇编代码看，operator new其实返回malloc返回的内存，而构造函数的代码其实编译器插入的。当调用operator new发生异常时，C++运行时系统会负责回收内存。</p><p>operator new重载作用非常的大，其中最重要的也是最常见的就是内存池实现。 placement new在某一些场景还是非常有用的。如果重载了placement new，那么必须也需要重载placement delete。</p><p>set_new_handler就是设置一个全局的回调函数，在operator new异常情况下就会调用我们设置的new_handler类型函数。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e143dbcc183d8a79aa1b1566c3e672db_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-e143dbcc183d8a79aa1b1566c3e672db_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;242&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"902\" data-rawheight=\"242\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic4.zhimg.com/v2-e143dbcc183d8a79aa1b1566c3e672db_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e143dbcc183d8a79aa1b1566c3e672db_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }, 
                {
                    "tag": "C++11", 
                    "tagLink": "https://api.zhihu.com/topics/19726035"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85617605", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 2, 
            "title": "C++幕后故事（八）--给我来一打对象", 
            "content": "<p>读者如果觉得我文章还不错的，希望可以多多支持下我，文章可以随便转发，保留原出处就可以了。或者关注我的微信公众号：<b>cpp手艺人</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p>这节我们的知识点就两个：</p><p>1.对象数组是如何构造的。</p><p>2.对象数组是如何析构的。</p><p>在C++幕后故事（七）中我们详细的解析了一个对象的生与死，在了解了一个对象的生与死的过程中基础上，这一次我们要一次性搞清楚多个对象的是如何构造和析构的。</p><h2>1.对象数组是怎么构造</h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">int</span> <span class=\"n\">g_number</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ObjClass</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">explicit</span> <span class=\"n\">ObjClass</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"n\">g_number</span><span class=\"o\">++</span><span class=\"p\">)</span> \n    <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ObjClass ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n    <span class=\"o\">~</span><span class=\"n\">ObjClass</span><span class=\"p\">()</span> \n    <span class=\"p\">{</span> \n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~ObjClass ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> \n        <span class=\"n\">mCount</span> <span class=\"o\">=</span> <span class=\"n\">g_number</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_object_array_ctor_dtor</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">ObjClass</span> <span class=\"o\">*</span><span class=\"n\">objarr</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ObjClass</span><span class=\"p\">[</span><span class=\"mi\">12</span><span class=\"p\">];</span>\n    <span class=\"c1\">// 0x001D59CC ObjClass ctor:0\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D0 ObjClass ctor:1\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D4 ObjClass ctor:2\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D8 ObjClass ctor:3\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59DC ObjClass ctor:4\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E0 ObjClass ctor:5\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E4 ObjClass ctor:6\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E8 ObjClass ctor:7\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59EC ObjClass ctor:8\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59F0 ObjClass ctor:9\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59F4 ObjClass ctor:a\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59F8 ObjClass ctor:b \n</span><span class=\"c1\"></span>  \n    <span class=\"k\">delete</span><span class=\"p\">[]</span> <span class=\"n\">objarr</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 0x001D59F8 ~ObjClass ctor:c\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59F4 ~ObjClass ctor:d\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59F0 ~ObjClass ctor:e\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59EC ~ObjClass ctor:f\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E8 ~ObjClass ctor:10\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E4 ~ObjClass ctor:11\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59E0 ~ObjClass ctor:12\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59DC ~ObjClass ctor:13\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D8 ~ObjClass ctor:14\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D4 ~ObjClass ctor:15\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59D0 ~ObjClass ctor:16\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 0x001D59CC ~ObjClass ctor:17\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>从打印的结果可以看出来，构造的时候地址都在<b>递增</b>的过程。但是析构的过程却是<b>递减</b>的过程。构造的时候是从第一个对象到最后一个对象，但是析构的却是从最后一个对象开始析构再到第一个对象。这个过程是不是十分像出栈和入栈一样。同时我又联想到存在继承关系对象的构造和析构也是这样的过程（先是构造父类，在构造自己。析构时先是析构自己，再去析构父类）。感觉栈的概念在整个计算机中真的是随处可见。</p><p>好，我们看下汇编代码一窥究竟。</p><p>我节选下重要的代码我们一起学习下。</p><div class=\"highlight\"><pre><code class=\"language-text\">; 申请分配的内存大小\n00DE309D  push      34h  \n00DE309F  call        operator new[] (0DD145Bh)  \n\n; 设置多少个对象\n00DE30D3  push        0Ch  \n; 设置每个对象的大小\n00DE30D5  push        4  \n00DE30D7  mov         ecx,dword ptr [ebp-0F8h]\n; 跳过前四个字节\n00DE30DD  add         ecx,4  \n00DE30E0  push        ecx  \n00DE30E1  call        `eh vector constructor iterator&#39; (0DD1780h)  \n    00DD1780  jmp         `eh vector constructor iterator&#39; (0DE4B90h)  \n        00DE4BD7  mov         eax,dword ptr [i]  \n        00DE4BDA  add         eax,1  \n        00DE4BDD  mov         dword ptr [i],eax  \n        00DE4BE0  mov         ecx,dword ptr [i]  \n        00DE4BE3  cmp         ecx,dword ptr [count]  \n        ; 大于[count]跳出循环\n        00DE4BE6  jge         `eh vector constructor iterator&#39;+69h (0DE4BF9h)  \n        00DE4BE8  mov         ecx,dword ptr [ptr]  \n        ; 调用ObjClass构造函数\n        00DE4BEB  call        dword ptr [pCtor]  \n        00DE4BEE  mov         edx,dword ptr [ptr]\n        ; 将指针指向下一个对象的首地址\n        00DE4BF1  add         edx,dword ptr [size]  \n        00DE4BF4  mov         dword ptr [ptr],edx  \n        ; 循环构造对象\n        00DE4BF7  jmp         `eh vector constructor iterator&#39;+47h (0DE4BD7h) </code></pre></div><p>这个看起来还是有点不直观，我翻译成C++伪代码看看。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"p\">;</span> <span class=\"err\">分配内存</span>\n<span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">reinterpret_cast</span> <span class=\"o\">&lt;</span><span class=\"kt\">char</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">[](</span><span class=\"mh\">0x34</span><span class=\"p\">));</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">))</span> <span class=\"o\">=</span> <span class=\"mh\">0x0C</span><span class=\"p\">;</span>\n    <span class=\"p\">;</span> <span class=\"err\">跳过前</span><span class=\"mi\">4</span><span class=\"err\">个字节</span>\n<span class=\"n\">ptr</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n<span class=\"p\">;</span> <span class=\"err\">循环调用构造函数</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">12</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">ObjClass</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">))).</span><span class=\"n\">ObjClass</span><span class=\"o\">::</span><span class=\"n\">ObjClass</span><span class=\"p\">();</span>\n        <span class=\"n\">ptr</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> \n<span class=\"p\">}</span>\n</code></pre></div><p>翻译成伪代码就好看多了，就顺便解决了我们的几个小疑问。</p><p>1.原来对象的大小在编译期间就已经确定了，所以我们知道了第一个对象的地址就能够知道后面的对象的地址，比如上面的对象是4byte，上面的汇编代码push 4。</p><p>2.构造多少个对象的，也是编译期间确定的，比如上面的初始化12个对象，上面的汇编代码push 0Ch。</p><p>3.还有个疑问就是为什么我申请的对象数组大小应该为4*12=48byte，但是实际上却0x34=52字节。</p><p>打开VS的内存视图，会看到如下的所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7557ff4b1a0e39b7d32080526cb7424c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb\" width=\"985\" data-original=\"https://pic1.zhimg.com/v2-7557ff4b1a0e39b7d32080526cb7424c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;985&#39; height=&#39;271&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"985\" data-rawheight=\"271\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"985\" data-original=\"https://pic1.zhimg.com/v2-7557ff4b1a0e39b7d32080526cb7424c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7557ff4b1a0e39b7d32080526cb7424c_b.jpg\"/></figure><p>红色部分就是对象真实占用的内存。仔细再看黄色框的地方一个地址为0x00EC59C8对应的值是0x0000000C，这时候我大概明白了怎么回事。</p><p>原来编译器背后帮我们多分配了4字节，这4个字节是为了保存了对象的个数（这里为12）,这样做编译器就知道需要调用多少次构造函数。</p><p>其实在分配内存不仅仅分配我们需要的内存，还会额外分配更多的内存，用来保存这块内存的基本信息，比如上面的有个0x00000034标志这块内存的大小。</p><h2>2.对象数组是怎么析构</h2><p>我们接着上面的代码，接着看反汇编的代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">01352F83  call        object_ctor_dtor_copy_semantic::ObjClass::`vector deleting destructor&#39; (01341BC2h) \n    01341BC2  jmp    object_ctor_dtor_copy_semantic::ObjClass::`vector deleting destructor&#39; (013435E0h)\n        ; 数组的首地址\n        01343616  push        ecx  \n        ; 对象的大小\n        01343617  push        4  \n        01343619  mov         edx,dword ptr [this]  \n        0134361C  push        edx  \n        0134361D  call        `eh vector destructor iterator&#39; (01341B77h) \n            01341B77  jmp         `eh vector destructor iterator&#39; (01354C70h) \n                ; 这里size就是对象的大小为4byte，\n                ; 下面的三行代码就是数组指针移动最后一个对象地址的末尾\n                01354CA7  mov         eax,dword ptr [size]  \n                01354CAA  imul        eax,dword ptr [count]  \n                01354CAE  add         eax,dword ptr [ptr]  \n                ; 对象的个数，这里为12\n                01354CBB  mov         ecx,dword ptr [count]  \n                ; 每循环一次ecx减一\n                01354CBE  sub         ecx,1  \n                01354CC1  mov         dword ptr [count],ecx  \n                ; ecx小于0结束跳出循环\n                01354CC4  js          `eh vector destructor iterator&#39;+67h (01354CD7h)  \n                01354CC6  mov         edx,dword ptr [ptr]  \n                ; 因为是从末尾处开始析构的，所以每次循环地址-4表示移动下一个对象的地址\n                01354CC9  sub         edx,dword ptr [size]  \n                01354CCC  mov         dword ptr [ptr],edx  \n                ; 传递每个对象对应的地址\n                01354CCF  mov         ecx,dword ptr [ptr]  \n                ; 调用对象的析构函数\n                01354CD2  call        dword ptr [pDtor]  \n                ; 循环跳转到0x01354CBB\n                01354CD5  jmp         `eh vector destructor iterator&#39;+4Bh (01354CBBh)  \n; 经过循环之后this指针指向的是第一个对象的地址      \n0134362A  mov         eax,dword ptr [this]  \n; 需要-4调整到保存0x0C的地址\n0134362D  sub         eax,4  \n01343630  push        eax  \n; 最后释放内存\n01343631  call        operator delete[] (0134113Bh) </code></pre></div><p>好，老规矩翻译成伪代码我们再看看。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 对象数组析构伪代码\n</span><span class=\"c1\"></span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">delete_ptr</span> <span class=\"o\">=</span> <span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">operator</span> <span class=\"k\">new</span><span class=\"p\">[](</span><span class=\"mh\">0x34</span><span class=\"p\">));</span>\n<span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">delete_ptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">tempptr</span> <span class=\"o\">=</span> <span class=\"n\">delete_ptr</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 跳过前面保存数组大小的4byte\n</span><span class=\"c1\"></span>    <span class=\"n\">tempptr</span> <span class=\"o\">+=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 移动最后一个对象的位置\n</span><span class=\"c1\"></span>    <span class=\"n\">tempptr</span> <span class=\"o\">+=</span> <span class=\"mh\">0x30</span><span class=\"p\">;</span> \n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">12</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"o\">--</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"n\">ObjClass</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">tempptr</span><span class=\"p\">))).</span><span class=\"n\">ObjClass</span><span class=\"o\">::~</span><span class=\"n\">ObjClass</span><span class=\"p\">();</span>\n        <span class=\"n\">tempptr</span> <span class=\"o\">-=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"c1\">// 注意这里是我们自己的模拟过程，直接这样调用会造成崩溃，毕竟内存模型和真正的\n</span><span class=\"c1\"></span>    <span class=\"c1\">// operatr new[]是不一样的\n</span><span class=\"c1\"></span>    <span class=\"k\">operator</span> <span class=\"k\">delete</span><span class=\"p\">[](</span><span class=\"n\">delete_ptr</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>我们再看下VS的内存视图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2d07a85290c4e7ab650428f18b717dfd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"973\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb\" width=\"973\" data-original=\"https://pic2.zhimg.com/v2-2d07a85290c4e7ab650428f18b717dfd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;973&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"973\" data-rawheight=\"254\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"973\" data-original=\"https://pic2.zhimg.com/v2-2d07a85290c4e7ab650428f18b717dfd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2d07a85290c4e7ab650428f18b717dfd_b.jpg\"/></figure><p>在内存释放的过程中，远远不止52个字节被释放，实际分配的内存比我们预计的还要多。</p><h2>3.总结</h2><p>在对象数组构造时，先是<b>分配内存</b>，然后再去循环调用每个对象的<b>构造函数</b>。</p><p>在对象数组析构时，先是调用<b>最后一个</b>对象的析构函数直到<b>第一个</b>对象的析构函数，最后再去<b>释放内存</b>。</p><p>这里画一张简陋点的内存图，这个章节关于内存的分配我就浅尝辄止，后面有机会我在详细的写写内存分配的内容。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-539da28e21c87eb151137325f71e1109_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-539da28e21c87eb151137325f71e1109_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;626&#39; height=&#39;408&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"626\" data-rawheight=\"408\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"626\" data-original=\"https://pic2.zhimg.com/v2-539da28e21c87eb151137325f71e1109_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-539da28e21c87eb151137325f71e1109_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "C / C++", 
                    "tagLink": "https://api.zhihu.com/topics/19601705"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/84695244", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 3, 
            "title": "C++幕后故事（七）--一个对象的生与死", 
            "content": "<h3>马上就是国庆节了，先提前祝大家国庆节快乐。</h3><p>读者如果觉得我文章还不错的，希望可以多多支持下我，文章可以随便转发，保留原出处就可以了。或者关注我的微信公众号：cpp手艺人。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-rawwidth=\"2800\" data-rawheight=\"800\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"2800\" data-rawheight=\"800\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p>这节里面我们会学习到以下四点：</p><p>1.对象的生成时机</p><p>2.对象构造过程和POD类型</p><p>3.对象的复制语意</p><p>4.析构语意</p><h2><b>1.对象生成的时机</b></h2><p>根据对象的控制力度不同，对象的生成时机也是不一样的。</p><p>我们可以把它分为两类：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-186d7ade3ddc3bffc3bf4a4e4b8bbe19_b.jpg\" data-rawwidth=\"650\" data-rawheight=\"199\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-186d7ade3ddc3bffc3bf4a4e4b8bbe19_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;650&#39; height=&#39;199&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"650\" data-rawheight=\"199\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"650\" data-original=\"https://pic2.zhimg.com/v2-186d7ade3ddc3bffc3bf4a4e4b8bbe19_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-186d7ade3ddc3bffc3bf4a4e4b8bbe19_b.jpg\"/></figure><p>1.new操作符用户手动控制时机，随时new，随时生成。</p><p>2.编译器控制下也是有细微的差别，请看下面的表格。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4e67866705630c805629f2aa5ecc6dbc_b.png\" data-rawwidth=\"670\" data-rawheight=\"82\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"670\" data-original=\"https://pic1.zhimg.com/v2-4e67866705630c805629f2aa5ecc6dbc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;670&#39; height=&#39;82&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"670\" data-rawheight=\"82\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"670\" data-original=\"https://pic1.zhimg.com/v2-4e67866705630c805629f2aa5ecc6dbc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4e67866705630c805629f2aa5ecc6dbc_b.png\"/></figure><p>编译器为VS2013 x86，下面是代码验证：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/*\n</span><span class=\"cm\">    测试：对象的构造、析构、拷贝语意\n</span><span class=\"cm\">*/</span>\n<span class=\"k\">namespace</span> <span class=\"n\">object_ctor_dtor_copy_semantic</span>\n<span class=\"p\">{</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Cat</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">explicit</span> <span class=\"n\">Cat</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">string</span> <span class=\"o\">&amp;</span><span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">mName</span><span class=\"p\">(</span><span class=\"n\">name</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">mName</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"o\">~</span><span class=\"n\">Cat</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">mName</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"n\">string</span> <span class=\"n\">mName</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// 全局对象\n</span><span class=\"c1\"></span><span class=\"n\">Cat</span> <span class=\"nf\">g_Cat</span><span class=\"p\">(</span><span class=\"s\">&#34;global cat&#34;</span><span class=\"p\">);</span>\n<span class=\"c1\">// 全局静态对象\n</span><span class=\"c1\"></span><span class=\"n\">Cat</span> <span class=\"nf\">g_s_Cat</span><span class=\"p\">(</span><span class=\"s\">&#34;global static cat&#34;</span><span class=\"p\">);</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_obj_ctor</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 局部变量\n</span><span class=\"c1\"></span>    <span class=\"n\">Cat</span> <span class=\"n\">local_cat</span><span class=\"p\">(</span><span class=\"s\">&#34;local cat&#34;</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// 局部静态对象\n</span><span class=\"c1\"></span>    <span class=\"k\">static</span> <span class=\"n\">Cat</span> <span class=\"n\">local_s_cat</span><span class=\"p\">(</span><span class=\"s\">&#34;local static cat&#34;</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">argc</span><span class=\"p\">,</span> <span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">argv</span><span class=\"p\">[])</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;------------start main------------&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"n\">object_ctor_dtor_copy_semantic</span><span class=\"o\">::</span><span class=\"n\">test_obj_ctor</span><span class=\"p\">();</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;------------end main------------&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 打印的结果\n</span><span class=\"c1\">// global cat\n</span><span class=\"c1\">// global static cat\n</span><span class=\"c1\">// ------------start main------------\n</span><span class=\"c1\">// local cat\n</span><span class=\"c1\">// local static cat\n</span><span class=\"c1\">// ~local cat\n</span><span class=\"c1\">// ------------end main------------\n</span><span class=\"c1\">// ~local static cat\n</span><span class=\"c1\">// ~global static cat\n</span><span class=\"c1\">// ~global cat\n</span></code></pre></div><p>关于局部对象这里有个小技巧跟大家分享下：类的实例只有在真正需要的时候再初始化</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_local_useless</span><span class=\"p\">(</span><span class=\"kt\">bool</span> <span class=\"n\">find</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Dog</span> <span class=\"n\">dog</span><span class=\"p\">;</span>\n    \n    <span class=\"c1\">// 返回操作，而这里初始化的dog对象没有任何的作用，平白无故的增加dog的构造函数调用降低效率\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">find</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"k\">return</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"c1\">// 应该将对象的初始化延迟到真正需要的时候在初始化\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 对dog的一系列操作\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ...\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><h2>2.对象构造</h2><h3>2.1 构造函数做了什么？</h3><p>我们已经知道对象在什么时候生成，但是对象在生成过程除了我们自己写的构造函数里面的动作，编译器在幕后也帮我们做了很多的工作，这节我们就要搞清楚编译器做了什么。</p><p>这一节既然要分析，我们就来分析最复杂的模型，虚继承+虚函数模型。因为最难的搞懂了，那简单的还不是毛毛雨。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-131b3a5212fadacb0acfd5932d5a9fea_b.jpg\" data-rawwidth=\"669\" data-rawheight=\"614\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"669\" data-original=\"https://pic3.zhimg.com/v2-131b3a5212fadacb0acfd5932d5a9fea_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;669&#39; height=&#39;614&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"669\" data-rawheight=\"614\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"669\" data-original=\"https://pic3.zhimg.com/v2-131b3a5212fadacb0acfd5932d5a9fea_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-131b3a5212fadacb0acfd5932d5a9fea_b.jpg\"/></figure><p>看如下代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Point</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Point</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">mX</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">mY</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;point&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Point</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~point&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mX</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mY</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Point3D</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"k\">virtual</span> <span class=\"n\">Point</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>    \n    <span class=\"n\">Point3D</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">mZ</span><span class=\"p\">(</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;point3d&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Point3D</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~point3d&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">VirFun1</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~VirFun1&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    \n<span class=\"k\">protected</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mZ</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Vertex</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"k\">virtual</span> <span class=\"n\">Point</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Vertex</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">mAngle</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;vertex&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Vertex</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~vertex&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">VirFun2</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~VirFun2&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    \n<span class=\"k\">protected</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mAngle</span><span class=\"p\">;</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Vertex3D</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Point3D</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Vertex</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Vertex3D</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;vertex3D&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Vertex3D</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~vertex3D&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">VirFun3</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~VirFun3&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">PVertex</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Vertex3D</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">PVertex</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">mCount</span><span class=\"p\">(</span><span class=\"mi\">5</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;PVertex3D&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">PVertex</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~PVertex3D&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">VirFun4</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~VirFun4&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"n\">setvalue</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">mY</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n\n<span class=\"k\">protected</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mCount</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_virtual_inherit_ctor</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">PVertex</span> <span class=\"n\">pvertex</span><span class=\"p\">;</span>\n    <span class=\"c1\">// pvertex.PVertex::~PVertex();\n</span><span class=\"c1\"></span>    <span class=\"c1\">// pvertex.setvalue(10);\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 露出海面的表象\n</span><span class=\"c1\"></span>    <span class=\"c1\">// point\n</span><span class=\"c1\"></span>    <span class=\"c1\">// point3d\n</span><span class=\"c1\"></span>    <span class=\"c1\">// vertex\n</span><span class=\"c1\"></span>    <span class=\"c1\">// vertex3D\n</span><span class=\"c1\"></span>    <span class=\"c1\">// PVertex3D\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~PVertex3D\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~vertex3D\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~vertex\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~point3d\n</span><span class=\"c1\"></span>    <span class=\"c1\">// ~point\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">test_virtual_inherit_ctor</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>调用函数，打印的结果如上面代码中注释的那样，其实那只是冰山一角。我们先看看PVertex布局是啥样的。老规矩将上面的代码保存为main.cpp。</p><p>1.借助VS2013开发人员命令提示，进入到main.cpp所在目录。</p><p>2.运行命令cl /d1 reportSingleClassLayout<b>PVertex</b> main.cpp</p><p>3.拿出重要的部分我们看看的</p><div class=\"highlight\"><pre><code class=\"language-text\">class PVertex   size(40):\n        +---\n        | +--- (base class Vertex3D)\n        | | +--- (base class Point3D)\n 0      | | | {vfptr}\n 4      | | | {vbptr}\n 8      | | | mZ\n        | | +---\n        | | +--- (base class Vertex)\n12      | | | {vfptr}\n16      | | | {vbptr}\n20      | | | mAngle\n        | | +---\n        | +---\n24      | mCount\n        +---\n        +--- (virtual base Point)\n28      | {vfptr}\n32      | mX\n36      | mY\n        +---\n\nPVertex::$vftable@Point3D@:\n        | &amp;PVertex_meta\n        |  0\n 0      | &amp;Point3D::VirFun1\n 1      | &amp;Vertex3D::VirFun3\n 2      | &amp;PVertex::VirFun4\n\nPVertex::$vftable@Vertex@:\n        | -12\n 0      | &amp;Vertex::VirFun2\n\nPVertex::$vbtable@Point3D@:\n 0      | -4\n 1      | 24 (PVertexd(Point3D+4)Point)\n\nPVertex::$vbtable@Vertex@:\n 0      | -4\n 1      | 12 (PVertexd(Vertex+4)Point)\n\nPVertex::$vftable@Point@:\n        | -28\n 0      | &amp;PVertex::{dtor}</code></pre></div><p>从导出的结构中看出，这个内存模型真是相当复杂，看着都有点头晕目眩。当对象之间的关系复杂之后，甚至连对象的大小都有膨胀的感觉。</p><p>我们关系整理下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-779e67e3bee0a269f5afcc32b4d52147_b.jpg\" data-rawwidth=\"900\" data-rawheight=\"625\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic4.zhimg.com/v2-779e67e3bee0a269f5afcc32b4d52147_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;625&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"900\" data-rawheight=\"625\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic4.zhimg.com/v2-779e67e3bee0a269f5afcc32b4d52147_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-779e67e3bee0a269f5afcc32b4d52147_b.jpg\"/></figure><p>从上面可以看出，PVertex虚函数（除了虚析构函数）是追加在<b>Point3D vfptr</b>表中，而析构函数则是放在<b>Point vfptr</b>表中。</p><p>我们把内存模型搞清楚了，剩下的简单多了，我们下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ada31e36c424835259c0be9968186893_b.jpg\" data-rawwidth=\"518\" data-rawheight=\"827\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"518\" data-original=\"https://pic4.zhimg.com/v2-ada31e36c424835259c0be9968186893_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;518&#39; height=&#39;827&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"518\" data-rawheight=\"827\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"518\" data-original=\"https://pic4.zhimg.com/v2-ada31e36c424835259c0be9968186893_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ada31e36c424835259c0be9968186893_b.jpg\"/></figure><p>看了半天发现，其实还是很复杂，复杂到一页word装不下。整个的调用流程，感觉都是在不断的设置虚表，设置虚基类表，不断的重复。而我们写的代码只是其中的一小部分。</p><p>好，我们再简化下这张图。（红色的线表示调用过程，蓝色线表示回溯过程）</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2313d8bb7c5db5936cc358046ac10299_b.jpg\" data-rawwidth=\"510\" data-rawheight=\"443\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"510\" data-original=\"https://pic2.zhimg.com/v2-2313d8bb7c5db5936cc358046ac10299_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;510&#39; height=&#39;443&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"510\" data-rawheight=\"443\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"510\" data-original=\"https://pic2.zhimg.com/v2-2313d8bb7c5db5936cc358046ac10299_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2313d8bb7c5db5936cc358046ac10299_b.jpg\"/></figure><p>这样看就简洁多了，整个调用的流程也是一目了然。</p><p>问题1：但是是不是觉得有点奇怪，PVertex怎么直接调用Point构造函数，不是应该下面这样图？</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4fae3d27d191067c37a90ed38a6ef3a6_b.jpg\" data-rawwidth=\"565\" data-rawheight=\"485\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-4fae3d27d191067c37a90ed38a6ef3a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;565&#39; height=&#39;485&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"565\" data-rawheight=\"485\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"565\" data-original=\"https://pic3.zhimg.com/v2-4fae3d27d191067c37a90ed38a6ef3a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4fae3d27d191067c37a90ed38a6ef3a6_b.jpg\"/></figure><p>但是这样的调用流程会造成将Point构造两次，大大的降低效率。所以编译器会决定由谁构造Point。关于virtual base class constructor如何被调用有着明确的定义：只有当一个完成的class object被定义出来（PVertex）时，它才会被调用；如果object只是某个完整object的subobject（Point3D），它就不会被调用（摘自《深入探索C++对象模型》）。</p><p>举个例子：</p><p>1.我们定义了一个Vertex3D对象，这时Point3D就是Vertex3D是个subobject对象，所以此时Point3D就不会调用Point构造函数。</p><p>2.定义了一个Point3D，它就是个完整的object，所以会直接调用Point构造函数。</p><p>问题2：在构造函数调用链中，我们发现整个过程都是在不断的设置虚表地址和虚基类表地址。为什么要来回不断的设置呢，在最开始的时候一次性搞定不就行了。</p><p>举个例子：</p><p>在不同的对象域中不停的修改虚表和虚基类表地址做法我称之为<b>入乡随俗</b>。</p><p>我们在构造PVertex时，PVertex先去构造Point。此时Point对象已经构造完毕是个完整的对象，但是PVertex还是残缺对象。如果这个时候我们Point虚表地址还是PVertex的虚表地址。此时我们在Point构造函数间接调用到PVertex虚函数，而此时PVertex还未完全构造完毕（比如一些成员变量还未初始化），这时调用PVertex虚函数就存在安全风险。说的简单点，在父类构造函数中就要把虚表地址设置为父类自己的而不是子类的。虚基类表也是同样的道理。同时会联想到在对象析构的时候也是类似的。</p><p>如果感兴趣的同学可以再看下汇编代码，其实这里的汇编代码的思路就是非常的清晰，就是如何把内存给填满的。我把代码就放在最后面了。附录1.1汇编代码填充内存结构。</p><h3>2.2 POD类型</h3><p>所谓的POD全称是Plain Old Data。基本数据类型、指针、union、数组、构造函数是 trivial 的 struct 或者 class。其实C的struct极其的相似。</p><p>看下面代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Dog</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mSize</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mAge</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_pod_type</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 1.没有加上括号，注意这里的成员值都是随机值\n</span><span class=\"c1\"></span>    <span class=\"n\">Dog</span> <span class=\"o\">*</span><span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"p\">;</span>\n\n    <span class=\"c1\">// 2.加上括号，注意这里的成员值都为0\n</span><span class=\"c1\"></span>    <span class=\"n\">Dog</span> <span class=\"o\">*</span><span class=\"n\">dog1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>但是结果却大不相同。加上括号初始化，会将对象中的成员变量做初始化。但是没有加上括号的对象中成员变量却是个随机值。</p><p>但是如果<b>Dog有构造函数，但是里面什么都不做</b>。上面的两行初始化的结果却是一样的，对象中成员变量的值都是随机值。</p><p>针对上面的代码，做个表格更直观点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-23e944ec161dd0f490096f89428ed3ab_b.png\" data-rawwidth=\"784\" data-rawheight=\"97\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"784\" data-original=\"https://pic4.zhimg.com/v2-23e944ec161dd0f490096f89428ed3ab_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;784&#39; height=&#39;97&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"784\" data-rawheight=\"97\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"784\" data-original=\"https://pic4.zhimg.com/v2-23e944ec161dd0f490096f89428ed3ab_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-23e944ec161dd0f490096f89428ed3ab_b.png\"/></figure><p>所以最佳的实践方式：给类<b>加上构造函数</b>同时给类中的<b>成员变量赋初值</b>，在构造对象的时候采用正规的做法<b>加上括号</b>。</p><h2>3.对象的复制语意</h2><p>一说到复制语意，我就想到了build设计模式，当然这两者没有强相关性，硬要说关联那就是它们都是和对象的构造有关。</p><p>对象的复制语意分为两种，一种就是<b>拷贝构造</b>，还有一种就是<b>赋值构造(operator=)</b>。但是有的同学，这两种方式不能很好的区分。其实很简单，拷贝构造是<b>从无到有</b>的过程，赋值构造<b>重新赋值</b>过程，用已经存在的对象去重新赋值另外一个已经存在的对象。（这里不提及std::move构造）。</p><p>在复制过程中，编译器也会为我们提供默认的复制构造语意，我们把编译器提供的叫做<b>浅拷贝</b>（bitwise copy）。在拷贝的时候，每个对象都拥有自己独立的一份资源而不是共享资源，这种方式叫做<b>深拷贝</b>（memberwise copy）。</p><p>为什么会有两种方式？</p><p>编译器提供两种方式，是因为两种方式各有优缺点。浅拷贝效率略高于深拷贝，但是存在资源释放问题。深拷贝是把资源也会对应的拷贝一份，这样就会造成效率的下降。当类中不含有任何的资源，那么编译器提供的浅拷贝就已经胜任任务。</p><p>最后如果我们不想要复制语意，可以将拷贝构造函数或者operator=设置为private属性。还可以使用c++11 delete语法禁止复制语意。</p><h2>4.析构语意</h2><p>对象的析构可以看成对象构造的逆向过程。对象的析构函数是个非常重要的函数，因为在对象消失的那一刻对释放资源，做一些清理的工作。</p><p>我们接着第二节对象构造里面的代码，画下析构的流程。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0abf76a389c4857c091facbeae98a91d_b.jpg\" data-rawwidth=\"528\" data-rawheight=\"448\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"528\" data-original=\"https://pic2.zhimg.com/v2-0abf76a389c4857c091facbeae98a91d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;528&#39; height=&#39;448&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"528\" data-rawheight=\"448\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"528\" data-original=\"https://pic2.zhimg.com/v2-0abf76a389c4857c091facbeae98a91d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0abf76a389c4857c091facbeae98a91d_b.jpg\"/></figure><p>这里我就画了简易的示意图，其实它里面设置虚表和虚基类表地址的套路和它的构造流程是十分的相似，我就不再重复了。</p><h2>5.总结</h2><p>这一节提到的拷贝构造，赋值构造，析构函数被称为C++的big three，这三个函数十分的重要一定要时刻小心。看一个人写的类文件，首先就要看从这三个函数开始，写了也不能代表水平很高，但是不写水平肯定不高。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4d42e7d150f7bd80a9593547f0d29a82_b.jpg\" data-rawwidth=\"917\" data-rawheight=\"310\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"917\" data-original=\"https://pic3.zhimg.com/v2-4d42e7d150f7bd80a9593547f0d29a82_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;917&#39; height=&#39;310&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"917\" data-rawheight=\"310\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"917\" data-original=\"https://pic3.zhimg.com/v2-4d42e7d150f7bd80a9593547f0d29a82_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4d42e7d150f7bd80a9593547f0d29a82_b.jpg\"/></figure><h2>附录1：</h2><h3>1.汇编代码填充内存结构</h3><div class=\"highlight\"><pre><code class=\"language-text\">; 调用PVertex的构造函数\n00983181  lea         ecx,[pvertex]  \n00983184  call        object_ctor_dtor_copy_semantic::PVertex::PVertex (09712CBh)  \n\n; 设置Point3D域的虚基类表\n009767D2  mov         eax,dword ptr [this]  \n009767D5  mov         dword ptr [eax+4],98D7D4h  \n; 设置Vertex域的虚基类表\n009767DC  mov         eax,dword ptr [this]  \n009767DF  mov         dword ptr [eax+10h],98D7E4h  \n    ; 调整this指针，指向Point域\n    009767E9  add         ecx,1Ch  \n    ; 调用Point够着函数\n    009767EC  call        object_ctor_dtor_copy_semantic::Point::Point (097193Dh) \n\n        ; 设置point虚表地址\n        00976D33  mov         eax,dword ptr [this]  \n        00976D36  mov         dword ptr [eax],98D68Ch  \n        ; 初始化成员变量的值\n        00976D3C  mov         eax,dword ptr [this]  \n        00976D3F  mov         dword ptr [eax+4],1  \n        00976D46  mov         eax,dword ptr [this]  \n        00976D49  mov         dword ptr [eax+8],2 \n        ; 再将this指针调回为pvertex的首地址\n        00976809  mov         ecx,dword ptr [this]  \n        ; 调用Vertex3D\n        0097680C  call        object_ctor_dtor_copy_semantic::Vertex3D::Vertex3D (09713B1h) \n            00976F29  mov         ecx,dword ptr [this]  \n            00976F2C  call        object_ctor_dtor_copy_semantic::Point3D::Point3D (0971311h) \n                ; 设置Point3D虚表\n                00976C5D  mov         eax,dword ptr [this]  \n                00976C60  mov         dword ptr [eax],98D6B8h\n                ; 根据虚基类表找到偏移值\n                00976C66  mov         eax,dword ptr [this]  \n                00976C69  mov         ecx,dword ptr [eax+4]  \n                00976C6C  mov         edx,dword ptr [ecx+4]  \n                00976C6F  mov         eax,dword ptr [this]  \n                ; 设置析构函数的虚表地址\n                00976C72  mov         dword ptr [eax+edx+4],98D6C0h  \n                ; 根据上面找到的偏移值，初始化成员变量\n                00976C7A  mov         eax,dword ptr [this]  \n                00976C7D  mov         dword ptr [eax+8],3  \n            ; 调整this指针，指向Vertex的首地址\n            00976F3A  mov         ecx,dword ptr [this]  \n            00976F3D  add         ecx,0Ch  \n            00976F40  call        object_ctor_dtor_copy_semantic::Vertex::Vertex (0971429h) \n                ; 设置Vertex虚表\n                0097707D  mov         eax,dword ptr [this]  \n                00977080  mov         dword ptr [eax],98D6F8h  \n                ; 根据虚基类表找到偏移值\n                00977086  mov         eax,dword ptr [this]  \n                00977089  mov         ecx,dword ptr [eax+4]  \n                0097708C  mov         edx,dword ptr [ecx+4]  \n                0097708F  mov         eax,dword ptr [this]  \n                ; 设置析构函数的虚表地址\n                00977092  mov         dword ptr [eax+edx+4],98D704h  \n                ; 根据上面找到的偏移值，初始化成员变量\n                0097709A  mov         eax,dword ptr [this]  \n                0097709D  mov         dword ptr [eax+8],4  \n        ; 设置Vertex3D虚表地址\n        00976F49  mov         eax,dword ptr [this]  \n        00976F4C  mov         dword ptr [eax],98D73Ch  \n        00976F52  mov         eax,dword ptr [this]  \n        ; 设置Vertex3D虚基类表地址\n        00976F55  mov         dword ptr [eax+0Ch],98D748h  \n        00976F5C  mov         eax,dword ptr [this]  \n        00976F5F  mov         ecx,dword ptr [eax+4]  \n        00976F62  mov         edx,dword ptr [ecx+4]  \n        00976F65  mov         eax,dword ptr [this]  \n        ; 设置Vertex3D析构函数的虚表地址\n        00976F68  mov         dword ptr [eax+edx+4],98D754h \n\n; 设置PVertex继承Point3D的虚表地址\n00976818  mov         eax,dword ptr [this]  \n0097681B  mov         dword ptr [eax],98D7A0h  \n; 设置PVertex继承的Vertex的虚表地址\n00976821  mov         eax,dword ptr [this]  \n00976824  mov         dword ptr [eax+0Ch],98D7B0h  \n; 设置PVertex继承的Point的虚表地址\n0097682B  mov         eax,dword ptr [this]  \n0097682E  mov         ecx,dword ptr [eax+4]  \n00976831  mov         edx,dword ptr [ecx+4]  \n00976834  mov         eax,dword ptr [this]  \n00976837  mov         dword ptr [eax+edx+4],98D7C4h  \n; 成员变量的初始化\n0097683F  mov         eax,dword ptr [this]  \n00976842  mov         dword ptr [eax+18h],5   </code></pre></div>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/83208125", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 5, 
            "title": "C++幕后故事（六）--函数我来调你了", 
            "content": "<p>这个章节我们会学到以下3个知识点：</p><p>1.不同的类型函数是怎么调用的。</p><p>2.成员函数指针各个模型实现的原理是什么以及各个指针的效率如何。</p><p>3.inline函数的注意事项。</p><h2>1.普通成员调用</h2><p>看下面的代码，这里面我分别调用了类成员和全局函数</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">NormalCall</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">void</span> <span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">number</span><span class=\"o\">+</span><span class=\"n\">m_add</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"n\">ClassStatic</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ClassStatic&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">ClassVirutal</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ClassVirutal&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_add</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">Add</span><span class=\"p\">(</span><span class=\"n\">NormalCall</span> <span class=\"o\">*</span><span class=\"n\">nc</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">number</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">nc</span><span class=\"o\">-&gt;</span><span class=\"n\">m_add</span> <span class=\"o\">+</span> <span class=\"n\">number</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_normal_call</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">NormalCall</span> <span class=\"n\">nc</span><span class=\"p\">;</span>\n    <span class=\"n\">nc</span><span class=\"p\">.</span><span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 其实被编译器转成__ZN6NormalCall6AddEi(&amp;nc, 1)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 编译器在调用类的普通成员函数时，会在函数的参数中隐式添加了一个this指针，这个指针\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 就是当前生成对象的首地址。同时对普通成员变量的存取也是通过this指针\n</span><span class=\"c1\"></span>    <span class=\"n\">Add</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">nc</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>     <span class=\"c1\">// 调用全局函数\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>把上面的源代码保存文件main.cpp，然后在linux平台上用g++ -Wall –g main.cpp –o main，再用nm main，就会导出main里面的符号等等其他东西。我把重要的东西拿出来看下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5425c9d0b45ed7a85397ceb2beacb7ec_b.jpg\" data-rawwidth=\"869\" data-rawheight=\"297\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"869\" data-original=\"https://pic1.zhimg.com/v2-5425c9d0b45ed7a85397ceb2beacb7ec_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;869&#39; height=&#39;297&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"869\" data-rawheight=\"297\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"869\" data-original=\"https://pic1.zhimg.com/v2-5425c9d0b45ed7a85397ceb2beacb7ec_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5425c9d0b45ed7a85397ceb2beacb7ec_b.jpg\"/></figure><p>从这里我们这里可以看出，我们写代码的时候名字就是Add，但是编译完之后名称全变了。<b>_Z3AddP10NormalCalli</b>我们可以猜测下就是我们写的Add(NormalCall, int)原型。<b>_ZN10NormalCall3AddEi</b>应该就是我们的NormalCall成员函数Add(int)原型。你可能会奇怪，为什么C++编译器编译出来的名称都变了，这种做法叫做name mangling（命名粉碎），其实是为了支持C++另外一个特性，就是函数重载的特性。同时，也是C++确保调用普通成员函数，和调用全局函数的在效率上是一致的。</p><h2>2.静态成员函数调用</h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"n\">test</span> <span class=\"nf\">_static_call</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">NormalCall</span> <span class=\"o\">*</span><span class=\"n\">pNC</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">NormalCall</span><span class=\"p\">();</span>\n    <span class=\"n\">pNC</span><span class=\"o\">-&gt;</span><span class=\"n\">ClassVirutal</span><span class=\"p\">();</span>\n\n    <span class=\"n\">NormalCall</span> <span class=\"n\">NC</span><span class=\"p\">;</span>\n    <span class=\"n\">NC</span><span class=\"p\">.</span><span class=\"n\">ClassStatic</span><span class=\"p\">();</span>\n\n    <span class=\"n\">pNC</span><span class=\"o\">-&gt;</span><span class=\"n\">ClassStatic</span><span class=\"p\">();</span>\n    <span class=\"n\">NormalCall</span><span class=\"o\">::</span><span class=\"n\">ClassStatic</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">; 上面三种调用static函数的生成的反汇编代码是一致的。\n0022C7D4  call        NormalCall::ClassStatic (0221550h)  \n0022C7D9  call        NormalCall::ClassStatic (0221550h)  \n0022C7DE  call        NormalCall::ClassStatic (0221550h) </code></pre></div><p>总结：</p><p>1.静态成员函数，没有this指针。</p><p>2.无法直接存取类中普通的非静态成员变量。</p><p>3.调用方式可以向类中普通的成员函数，也可以用ClassName::StaticFunction。</p><p>4.可以将静态的成员函数在某些环境下当做回调函数使用。</p><p>5.静态的成员函数不能够被声明为const、volatile和virtual。</p><h2>3.虚函数调用</h2><p>关于虚函数在第四章做了专门的介绍，这里就不在啰嗦了。</p><h2>4.成员函数指针</h2><p>从字面意思看，有两点内容。1.是个指针。2.指向的类的成员函数。接下来我们是从三个角度来看这个问题。</p><h3>4.1普通成员函数指针</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Car</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">void</span> <span class=\"n\">Run</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Car run&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">static</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;lexus&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_function_pointer</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// void (Car::*fRun)() = &amp;Car::Run;\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 可以将成员函数指针分成四步看\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span>        <span class=\"c1\">// 1.返回值\n</span><span class=\"c1\"></span>    <span class=\"p\">(</span><span class=\"n\">Car</span><span class=\"o\">::*</span>      <span class=\"c1\">// 2.哪个类的成员函数指针\n</span><span class=\"c1\"></span>    <span class=\"n\">fRun</span><span class=\"p\">)</span>       <span class=\"c1\">// 3.函数指针名称\n</span><span class=\"c1\"></span>    <span class=\"p\">()</span>           <span class=\"c1\">// 4.参数列表\n</span><span class=\"c1\"></span>    <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Car</span><span class=\"o\">::</span><span class=\"n\">Run</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Car</span> <span class=\"n\">car</span><span class=\"p\">;</span>\n    <span class=\"p\">(</span><span class=\"n\">car</span><span class=\"p\">.</span><span class=\"o\">*</span><span class=\"n\">fRun</span><span class=\"p\">)();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>从上面的代码中看出，定义一个成员函数指针，只需要注意四步就行:</p><p>1.返回值。</p><p>2.哪个类的成员函数指针。</p><p>3.函数指针名称。</p><p>4.参数列表。</p><p>在注意调用的方式(car.*fRun)()，它比平常调用car.Run()时候多了个*。</p><p>这个背后实现的原理：</p><p>每个成员函数都一个固定的地址，把普通成员函数的地址赋值给一个函数指针，然后在调用函数指针的时候再把this指针当做参数传递进去。这个就和普通成员函数调用的原理是一致的。</p><h3>4.2 静态成员函数指针</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_function_pointer</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Car</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n    <span class=\"n\">fName</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>注意到没有我们在定义静态成员函数时，没有加上类名Car。这是因为静态函数里面没有this指针，所以就造成了不需要加上类名Car，同时也造成静态成员函数不能直接使用类的普通成员变量和函数。你可能发现类的静态成员函数，和全局函数非常类似，其实本质上是一样的，都是一个可调用的地址。 </p><h3>4.3 虚拟成员函数指针</h3><p>上面的两节，我们看了普通成员函数指针和静态成员函数指针，觉得比较简单。接下来的重头戏虚拟成员函数指针，这里的套路更深也更难理解，且听我一步步道来。</p><h3>4.3.1 单继承模型下调用</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Animal</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Animal&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Animal&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Cat</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Cat</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Cat&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Cat Cat&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Dog</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Dog</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Dog&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Run</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Dog Run&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Dog Dog&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_virtual_fucntion_pointer</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Animal</span> <span class=\"o\">*</span><span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"p\">();</span>\n    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">Animal</span><span class=\"o\">::*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Animal</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;fName address %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">fName</span><span class=\"p\">);</span>\n    <span class=\"c1\">// fName address 00FD1802\n</span><span class=\"c1\"></span>    <span class=\"p\">(</span><span class=\"n\">animal</span><span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n    <span class=\"c1\">// Cat Cat\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 打印Cat的虚表中的Name地址\n</span><span class=\"c1\"></span>    <span class=\"n\">Cat</span> <span class=\"o\">*</span><span class=\"n\">cat</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"p\">();</span>\n    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">vtable_address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"n\">cat</span><span class=\"p\">)));</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;virtual Name address %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">vtable_address</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n    <span class=\"c1\">// virtual Name address 00FD1429\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 编译器在语法层面阻止我们获取析构函数地址\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 但是我们知道的在虚函数章节里面，我们可以通过虚表的地址间接获取析构函数地址\n</span><span class=\"c1\"></span>    <span class=\"c1\">// void (Animal::*Dtor)() = &amp;Animal::~Animal;\n</span><span class=\"c1\"></span>    <span class=\"c1\">// (animal-&gt;*Dtor)();\n</span><span class=\"c1\"></span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;fName address %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">fName</span><span class=\"p\">);</span>\n    <span class=\"c1\">// fName address 00FD1802\n</span><span class=\"c1\"></span>    <span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"p\">();</span>\n    <span class=\"p\">(</span><span class=\"n\">animal</span> <span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n    <span class=\"c1\">// Dog Dog\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 打印Dog的虚表中的Name地址\n</span><span class=\"c1\"></span>    <span class=\"n\">Dog</span> <span class=\"o\">*</span><span class=\"n\">dog</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"p\">();</span>\n    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">dog_vtable_address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"p\">((</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"n\">dog</span><span class=\"p\">)));</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;virtual Name address %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">dog_vtable_address</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n    <span class=\"c1\">// virtual Name address 00FD1672\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>在代码中我们定义了一个变量fName。</p><p>void (Animal::*fName)() = &amp;Animal::Name;</p><p>并赋值为&amp;Animal:Name；我们再打印出Name的地址0x009F1802。</p><p>我们先思考这个地址到底指向谁？</p><p>这个地址就是虚函数的地址？如果是，那么它的地址是父类的？还是子类，如果那么编译器又是怎么我指向的是哪个虚函数地址？如果不是，那么又是个什么地址？接下里我们一步步的通过汇编代码验证猜想。</p><p>我们在VS的调试模式下，将鼠标移动fName变量上就会显示一串信息。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c1f71381a28d8b8f20f892532bb97c7d_b.png\" data-rawwidth=\"784\" data-rawheight=\"64\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"784\" data-original=\"https://pic2.zhimg.com/v2-c1f71381a28d8b8f20f892532bb97c7d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;784&#39; height=&#39;64&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"784\" data-rawheight=\"64\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"784\" data-original=\"https://pic2.zhimg.com/v2-c1f71381a28d8b8f20f892532bb97c7d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-c1f71381a28d8b8f20f892532bb97c7d_b.png\"/></figure><p>显示的什么thunk，vcall{4…}，都是什么玩意看不懂。反汇编走一遍，到底是个什么锤子。</p><p>以下是关键的汇编代码：</p><div class=\"highlight\"><pre><code class=\"language-text\">    (animal-&gt;*fName)();\n00FDD66F  mov         esi,esp \n; 是不是条件反射了，将this指针地址放到ecx中\n00FDD671  mov         ecx,dword ptr [animal]  \n00FDD674  call        dword ptr [fName]  \n\nfunction_semantic::Animal::`vcall&#39;{4}&#39;:\n00FD1802  jmp         function_semantic::Animal::`vcall&#39;{4}&#39; (0FD73BCh) \n\n; 拿到虚表首地址\n00FD73BC  mov         eax,dword ptr [ecx]  \n; 偏移地址，找到正确的虚函数地址\n00FD73BE  jmp         dword ptr [eax+4] \n\nfunction_semantic::Cat::Name:\n; 真正的虚函数地址\n00FD1429  jmp         function_semantic::Cat::Name (0FD8FB0h)  </code></pre></div><p>画了一张图解释下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9443ac9e51deb28d448444e0a8f1b1dc_b.jpg\" data-rawwidth=\"862\" data-rawheight=\"646\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"862\" data-original=\"https://pic1.zhimg.com/v2-9443ac9e51deb28d448444e0a8f1b1dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;862&#39; height=&#39;646&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"862\" data-rawheight=\"646\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"862\" data-original=\"https://pic1.zhimg.com/v2-9443ac9e51deb28d448444e0a8f1b1dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9443ac9e51deb28d448444e0a8f1b1dc_b.jpg\"/></figure><p>首先，我们不看蓝色虚线的部分。此时并不是直接找到虚函数地址，而是通过一个中间层（黑色虚框部分）去找到。这种技术，在microsoft编译器中被包装了一个高大上的名词叫做thunk。</p><p>我们再看整张图，你会发现和以前调用虚函数的方式（蓝色虚线箭头）相比，是不是就是多了一个thunk的调用过程。但是为啥要多个中间层，那不意味着效率又降低了？首先引入thunk是为了寻找虚函数地址增加强大的灵活性。其次需要承认的是效率的确下降了，但是没有下降的那么厉害，这几行代码都是汇编级别的代码，所以执行的效率还是很高。</p><p>接下来我详细解释下是如何增加灵活性，仔细观察上面的黄色高亮的代码块，为了方便查看我摘抄下来。第一次看到下面的代码，总觉得非常的别扭。声明的类型是父类的成员函数指针，最后调用的却是子类重写的虚函数打印的结果分别是Cat Cat，Dog Dog，很是神奇，而且fName是个变量在这个过程是不变化的，这是怎么做到的。这背后就是thunk的功劳了。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">Animal</span> <span class=\"o\">*</span><span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Cat</span><span class=\"p\">();</span>\n<span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">Animal</span><span class=\"o\">::*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Animal</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n\n<span class=\"p\">(</span><span class=\"n\">animal</span><span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n<span class=\"c1\">// Cat Cat\n</span><span class=\"c1\"></span>\n<span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Dog</span><span class=\"p\">();</span>\n<span class=\"p\">(</span><span class=\"n\">animal</span> <span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n<span class=\"c1\">// Dog Dog\n</span></code></pre></div><p>那么thunk到底什么？</p><p>从汇编层看，thunk就是那么几行代码。干了一件很简单的事，就是根据传递过来的ecx指针，找到虚表地址，在根据偏移量（这里偏移为4byte）找到正确的虚函数地址。所以ecx里面就是保存了对象的首地址（也就是包括了vptr），根据不同的虚表就能找到不同的虚函数。</p><h3>4.3.2 多继承模型下调用</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Fly</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Fly</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Fly&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">CanFly</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Fly&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">Distance</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Fly distance&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Fish</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Animal</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Fly</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Fish</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Fish&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Fish&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">CanFly</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Fish Fly&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_mult_inherit_vir_fun_pointer</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">Animal</span><span class=\"o\">::*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Animal</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n    \n    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">Fly</span><span class=\"o\">::*</span><span class=\"n\">fFly</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Fly</span><span class=\"o\">::</span><span class=\"n\">CanFly</span><span class=\"p\">;</span>\n    <span class=\"n\">Fish</span> <span class=\"o\">*</span><span class=\"n\">fish</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Fish</span><span class=\"p\">();</span>\n    <span class=\"n\">Fly</span> <span class=\"o\">*</span><span class=\"n\">fishfly</span> <span class=\"o\">=</span> <span class=\"n\">fish</span><span class=\"p\">;</span> \n    <span class=\"p\">(</span><span class=\"n\">fishfly</span><span class=\"o\">-&gt;*</span><span class=\"n\">fFly</span><span class=\"p\">)();</span>\n\n    <span class=\"n\">Animal</span> <span class=\"o\">*</span><span class=\"n\">animal</span> <span class=\"o\">=</span> <span class=\"n\">fish</span><span class=\"p\">;</span>\n    <span class=\"p\">(</span><span class=\"n\">animal</span><span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这里从反汇编的角度看，在单继承下面都是调用thunk方法，和上面的没啥区别。</p><h3>4.3.3 虚拟继承模型下调用</h3><p>提前预警，这里的模型更复杂了，大家一定要耐心看下去。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Animal</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Animal&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Animal&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">Size</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Animal Size&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">BigTiger</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"k\">virtual</span> <span class=\"n\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">BigTiger</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Big Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Big Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">FatTiger</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"k\">virtual</span> <span class=\"n\">Animal</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">FatTiger</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Fat Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Fat Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Tiger</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">BigTiger</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">FatTiger</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Tiger</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;~Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">Name</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Tiger&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">CanFly</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Tiger Fly&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_virtual_mult_inherit_vir_fun_pointer</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"c1\">// 1.测试代码\n</span><span class=\"c1\"></span>    <span class=\"c1\">// void (Animal::*fName)() = &amp;Animal::Name;\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 下面这句和上面注释的一句是等价的\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">BigTiger</span><span class=\"o\">::*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Animal</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n    <span class=\"n\">Tiger</span> <span class=\"o\">*</span><span class=\"n\">temptiger2</span>   <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tiger</span><span class=\"p\">();</span>\n    <span class=\"n\">BigTiger</span> <span class=\"o\">*</span><span class=\"n\">bigtiger</span>   <span class=\"o\">=</span> <span class=\"n\">temptiger2</span><span class=\"p\">;</span>\n<span class=\"p\">(</span><span class=\"n\">bigtiger</span><span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\n<span class=\"c1\">// 打印出：Tiger\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 2.测试代码\n</span><span class=\"c1\"></span>    <span class=\"c1\">// void (FatTiger::*fFatName)() = &amp;Animal::Name;\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 下面这句和上面注释的一句是等价的\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">FatTiger</span><span class=\"o\">::*</span><span class=\"n\">fFatName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">FatTiger</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n    <span class=\"n\">Tiger</span> <span class=\"o\">*</span><span class=\"n\">temptiger</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tiger</span><span class=\"p\">();</span>\n    <span class=\"n\">FatTiger</span> <span class=\"o\">*</span><span class=\"n\">fattiger</span> <span class=\"o\">=</span> <span class=\"n\">temptiger</span><span class=\"p\">;</span>\n<span class=\"p\">(</span><span class=\"n\">fattiger</span><span class=\"o\">-&gt;*</span><span class=\"n\">fFatName</span><span class=\"p\">)();</span>\n<span class=\"c1\">// 打印出：Tiger\n</span><span class=\"c1\"></span> <span class=\"p\">}</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n   <span class=\"n\">test_virtual_mult_inherit_vir_fun_pointer</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>上述的测试代码，我们先看看Tiger的内存布局是什么样的。</p><p>把代码copy拿出来保存为main.cpp，在vs2013命令行工具中，cd到main.cpp所在的目录，运行指令cl /d1 reportSingleClassLayoutTiger main.cpp。打印出如下内容：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cc44414d796c9f029736eba67b9a9573_b.jpg\" data-rawwidth=\"742\" data-rawheight=\"657\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"742\" data-original=\"https://pic4.zhimg.com/v2-cc44414d796c9f029736eba67b9a9573_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;742&#39; height=&#39;657&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"742\" data-rawheight=\"657\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"742\" data-original=\"https://pic4.zhimg.com/v2-cc44414d796c9f029736eba67b9a9573_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cc44414d796c9f029736eba67b9a9573_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d2599060f0d93d6f83ddf665d73a6b60_b.jpg\" data-rawwidth=\"743\" data-rawheight=\"729\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"743\" data-original=\"https://pic1.zhimg.com/v2-d2599060f0d93d6f83ddf665d73a6b60_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;743&#39; height=&#39;729&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"743\" data-rawheight=\"729\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"743\" data-original=\"https://pic1.zhimg.com/v2-d2599060f0d93d6f83ddf665d73a6b60_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d2599060f0d93d6f83ddf665d73a6b60_b.jpg\"/></figure><p>增加了虚继承之后，内存的模型复杂度立马上升了一个档次。上述表格看的不明显，我花了几张图方便大家观看。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-406f653fa853ab08ee9596e48aab9ed9_b.jpg\" data-rawwidth=\"782\" data-rawheight=\"383\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"782\" data-original=\"https://pic2.zhimg.com/v2-406f653fa853ab08ee9596e48aab9ed9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;782&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"782\" data-rawheight=\"383\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"782\" data-original=\"https://pic2.zhimg.com/v2-406f653fa853ab08ee9596e48aab9ed9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-406f653fa853ab08ee9596e48aab9ed9_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a56fa7909811ed9929c3bda4044b30b0_b.jpg\" data-rawwidth=\"793\" data-rawheight=\"387\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"793\" data-original=\"https://pic1.zhimg.com/v2-a56fa7909811ed9929c3bda4044b30b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;793&#39; height=&#39;387&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"793\" data-rawheight=\"387\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"793\" data-original=\"https://pic1.zhimg.com/v2-a56fa7909811ed9929c3bda4044b30b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a56fa7909811ed9929c3bda4044b30b0_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7d072ae3a82dd5577430b59c0780e829_b.jpg\" data-rawwidth=\"757\" data-rawheight=\"501\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"757\" data-original=\"https://pic2.zhimg.com/v2-7d072ae3a82dd5577430b59c0780e829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;757&#39; height=&#39;501&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"757\" data-rawheight=\"501\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"757\" data-original=\"https://pic2.zhimg.com/v2-7d072ae3a82dd5577430b59c0780e829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-7d072ae3a82dd5577430b59c0780e829_b.jpg\"/></figure><p>好了，我们画图Tiger相关的内存模型图。接下来我们看看这是指向虚成员函数指针是如何实现的。</p><p>我们看下面这段代码的执行流程。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 1.测试代码\n</span><span class=\"c1\">// void (Animal::*fName)() = &amp;Animal::Name;\n</span><span class=\"c1\">// 下面这句和上面注释的一句是等价的\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"n\">BigTiger</span><span class=\"o\">::*</span><span class=\"n\">fName</span><span class=\"p\">)()</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Animal</span><span class=\"o\">::</span><span class=\"n\">Name</span><span class=\"p\">;</span>\n<span class=\"n\">Tiger</span> <span class=\"o\">*</span><span class=\"n\">temptiger2</span>   <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Tiger</span><span class=\"p\">();</span>\n<span class=\"n\">BigTiger</span> <span class=\"o\">*</span><span class=\"n\">bigtiger</span>   <span class=\"o\">=</span> <span class=\"n\">temptiger2</span><span class=\"p\">;</span>\n<span class=\"p\">(</span><span class=\"n\">bigtiger</span><span class=\"o\">-&gt;*</span><span class=\"n\">fName</span><span class=\"p\">)();</span>\t\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3e7c4a91d515c7543bf041e3be8a5ee1_b.jpg\" data-rawwidth=\"902\" data-rawheight=\"534\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"902\" data-original=\"https://pic2.zhimg.com/v2-3e7c4a91d515c7543bf041e3be8a5ee1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;902&#39; height=&#39;534&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"902\" data-rawheight=\"534\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"902\" data-original=\"https://pic2.zhimg.com/v2-3e7c4a91d515c7543bf041e3be8a5ee1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3e7c4a91d515c7543bf041e3be8a5ee1_b.jpg\"/></figure><p>大家可能在第二步调整this指针的时候会很奇怪的，但是根据我debug模式下跟下来，vtordisp for vbase Animal 这个位置的值为0。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-713d27800ca730fb874c6dcc0683f737_b.jpg\" data-rawwidth=\"659\" data-rawheight=\"269\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"659\" data-original=\"https://pic4.zhimg.com/v2-713d27800ca730fb874c6dcc0683f737_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;659&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"659\" data-rawheight=\"269\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"659\" data-original=\"https://pic4.zhimg.com/v2-713d27800ca730fb874c6dcc0683f737_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-713d27800ca730fb874c6dcc0683f737_b.jpg\"/></figure><p>那么ecx = ecx-[ecx-4]等价于ecx=ecx-0还是等于ecx本身，ecx里面就保存了this指针的地址，最后再调用虚函数。这里我也很好奇为什么这里还有个调整this地址的问题。</p><p>还有个关于vtordisp的，我也没有理解，从调试的过程看下来，就知道他参与了最后一次的this指针调整。这里我贴出网上的一个地址讨论这个的<a href=\"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/fanzhidongyzby/archive/2013/01/14/2860015.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">cnblogs.com/fanzhidongy</span><span class=\"invisible\">zby/archive/2013/01/14/2860015.html</span><span class=\"ellipsis\"></span></a>。</p><p>那么上面的调用过程就是：</p><p>1.根据thunk找到正确的虚函数地址。</p><p>2.调整this指针的偏移，再调用第一步找到的虚函数地址。</p><h3>4.4 成员函数指针总结</h3><p>成员函数指针有两种形态：</p><p>1. 和C语言中一样的函数指针。</p><p>2. thunk vcall的技术，就是几行汇编代码:</p><p>    1. 可以调整this的地址。</p><p>    2. 可以协助找到真正的虚函数地址。</p><p>不知道大家有没有感觉，这个thunk非常像桥接模式的思路，将桥的两边变化都隔离开，就是解耦，各自可以随意变化。</p><p>大家可能对学习了这节的成员函数指针觉得没啥用处，其实这节的用处可大了。想想C++11中的functional，bind是怎么实现的。后面有机会的话通过functional重写观察者设计模式，让你感叹这个的强大。</p><p>同时这里面还有其他的模式组合（比如：虚继承普通成员函数），我这里就没有一一的探讨了，希望读者对自己感兴趣的部分动手实践，或者和我讨论也可以。</p><p>最后我们在比较下各种函数指针的效率如何：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a0f712a14e5ff10e33c9df42a27d596c_b.jpg\" data-rawwidth=\"644\" data-rawheight=\"580\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"644\" data-original=\"https://pic1.zhimg.com/v2-a0f712a14e5ff10e33c9df42a27d596c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;644&#39; height=&#39;580&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"644\" data-rawheight=\"580\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"644\" data-original=\"https://pic1.zhimg.com/v2-a0f712a14e5ff10e33c9df42a27d596c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a0f712a14e5ff10e33c9df42a27d596c_b.jpg\"/></figure><h2>5.inline函数调用</h2><p>inline函数调用的过程中，需要注意两点：</p><h3>5.1 函数参数列表：</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kr\">inline</span> <span class=\"kt\">int</span> <span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">left</span> <span class=\"o\">&gt;</span> <span class=\"n\">right</span> <span class=\"o\">?</span> <span class=\"nl\">left</span> <span class=\"p\">:</span> <span class=\"n\">right</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 调用方式\n</span><span class=\"c1\"></span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">foo</span><span class=\"p\">(),</span> <span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n<span class=\"c1\">// inline 被扩展之后\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">t1</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">t2</span><span class=\"p\">;</span>\n<span class=\"n\">maxvale</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">t1</span><span class=\"o\">=</span><span class=\"n\">foo</span><span class=\"p\">()),(</span><span class=\"n\">t2</span><span class=\"o\">=</span><span class=\"n\">bar</span><span class=\"p\">()</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">t1</span> <span class=\"o\">&gt;</span> <span class=\"n\">t2</span> <span class=\"o\">?</span> <span class=\"nl\">t1</span> <span class=\"p\">:</span> <span class=\"n\">t2</span><span class=\"p\">;</span>\n</code></pre></div><p>这样做的话，其实会造成大量的临时对象构造。如果你的对象需要大量的初始化操作，会带来效率问题。</p><h3>5.2 局部变量</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kr\">inline</span> <span class=\"kt\">int</span> <span class=\"nf\">max</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">right</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"c1\">// 添加临时变量max_value\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">max_value</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">&gt;</span> <span class=\"n\">right</span> <span class=\"o\">?</span> <span class=\"nl\">left</span> <span class=\"p\">:</span> <span class=\"n\">right</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">max_value</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 调用方式\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">local_var</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">maxval</span><span class=\"p\">;</span>\n    <span class=\"n\">maxval</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">left</span><span class=\"p\">,</span> <span class=\"n\">right</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// inline 被扩展之后\n</span><span class=\"c1\">// max里面的max_value会被mangling，现在假设为__max_maxval\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">__max_maxval</span><span class=\"p\">;</span>\n<span class=\"n\">maxval</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">__max_maxval</span> <span class=\"o\">=</span> <span class=\"n\">left</span> <span class=\"o\">&gt;</span> <span class=\"n\">right</span> <span class=\"o\">?</span> <span class=\"nl\">left</span> <span class=\"p\">:</span> <span class=\"n\">right</span><span class=\"p\">),</span> <span class=\"n\">__max_maxval</span><span class=\"p\">;</span>\n</code></pre></div><p>在inline函数中增加了临时变量，看到最后inline展开的时候也会临时对象的构造，就和上面的影响是一样的，造成的效率损失。</p><h2>6.总结：</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-52976b8d598986d18c3eec3d9a07b809_b.jpg\" data-rawwidth=\"830\" data-rawheight=\"467\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"830\" data-original=\"https://pic2.zhimg.com/v2-52976b8d598986d18c3eec3d9a07b809_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;830&#39; height=&#39;467&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"830\" data-rawheight=\"467\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"830\" data-original=\"https://pic2.zhimg.com/v2-52976b8d598986d18c3eec3d9a07b809_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-52976b8d598986d18c3eec3d9a07b809_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-rawwidth=\"2800\" data-rawheight=\"800\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"2800\" data-rawheight=\"800\" data-size=\"normal\" data-caption=\"\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++ Primer（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20134009"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82306985", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 2, 
            "title": "C++幕后故事（五）--数据你在哪里？", 
            "content": "<h2>1.数据成员绑定时机</h2><p>大家一看标题可能有点懵了，什么叫数据成员的绑定时机。请随我看段代码，这段代码节选自《深入探索C++对象模型》</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">extern</span> <span class=\"kt\">float</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Point3D</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Point3D</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">,</span> <span class=\"kt\">float</span><span class=\"p\">,</span> <span class=\"kt\">float</span><span class=\"p\">);</span>\n    <span class=\"kt\">float</span> <span class=\"nf\">X</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">X</span><span class=\"p\">(</span><span class=\"kt\">float</span> <span class=\"n\">new_x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">new_x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">float</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>如果我调用了Point3D的X()返回的这个x是Point3D的成员变量值，还是外部定义的x。现在看来的话，很显然返回的Point3D的成员变量值。但是在C++诞生没多久的时代，编译器返回的是外部定义的x。这样的结果对于现在的你来说是不是有点惊讶。所以你现在看到如下的代码风格，请不要惊讶也不要彷徨。注意下面的高亮部分，将成员变量的定义提前，这样就防御了之前的成员绑定问题。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">extern</span> <span class=\"kt\">float</span> <span class=\"n\">x</span><span class=\"p\">;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Point3D</span>\n<span class=\"p\">{</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">float</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">z</span><span class=\"p\">;</span>  \n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"n\">Point3D</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">,</span> <span class=\"kt\">float</span><span class=\"p\">,</span> <span class=\"kt\">float</span><span class=\"p\">);</span>\n<span class=\"kt\">float</span> <span class=\"nf\">X</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">X</span><span class=\"p\">(</span><span class=\"kt\">float</span> <span class=\"n\">new_x</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">new_x</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>可以看出来现代C++编译器，在绑定成员变量时，是延迟到整个类解析完之后才会进行成员变量的绑定。</p><p>但是大家请注意，这里有一个小坑。就是成员函数的参数列表绑定时机。</p><p>看如下的代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;string&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">string</span><span class=\"p\">;</span>\n\n<span class=\"k\">typedef</span> <span class=\"n\">string</span> <span class=\"n\">mytype</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">TestDataAnalyse</span> <span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">Fun</span><span class=\"p\">();</span>\n    <span class=\"c1\">// 对于成员函数参数的解析，编译器是第一次遇到这个类型的mytype类型的时候被决定的\n</span><span class=\"c1\"></span>    <span class=\"c1\">// mytype第一次遇到的时候就看到了type string mytype\n</span><span class=\"c1\"></span>    <span class=\"kt\">void</span> <span class=\"nf\">CopyValue</span><span class=\"p\">(</span><span class=\"n\">mytype</span> <span class=\"n\">value</span><span class=\"p\">);</span>\n<span class=\"k\">private</span><span class=\"o\">:</span>\n<span class=\"kt\">int</span> <span class=\"n\">tempvalue</span><span class=\"p\">;</span>\n<span class=\"k\">typedef</span> <span class=\"kt\">int</span> <span class=\"n\">mytype</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">TestDataAnalyse</span><span class=\"o\">::</span><span class=\"n\">CopyValue</span><span class=\"p\">(</span><span class=\"n\">mytype</span> <span class=\"n\">value</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">tempvalue</span> <span class=\"o\">=</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"n\">test_data_analyse</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">TestDataAnalyse</span> <span class=\"n\">data</span><span class=\"p\">;</span>\n    <span class=\"n\">data</span><span class=\"p\">.</span><span class=\"n\">Fun</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>编译器报错的错误：</p><p>error C2511: “void TestDataAnalyse::CopyValue(TestDataAnalyse::mytype)”:“TestDataAnalyse”中没有找到重载的成员函数</p><p>看到这样的错误，你可能找半天都找不到头绪。mytype我已经定义为int类型的，但是为什么说没有找到重载的成员函数，这和重载函数有什么关系。</p><p>原因就是：成员函数参数的绑定是利用就近原理，当解析到它的时候，它的定义就是最近的定义这个类型的类型。什么意思呢，就是mytype这个类型最近定义这个类型的为string类型（从上往下解析）。CopyValue中将string类型复制给int类型，当然是编译失败。这个时候我们把类中嵌套的定义typedef int mytype，这句话放在类的开始处，就可以避免这个问题，这个时候mytype的类型就为int。</p><p>在这里可以看出成员变量和成员函数参数的绑定时机是不同的。</p><h2>2.数据成员布局</h2><h3>2.1 未继承任何父类</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_layout</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Child</span> <span class=\"n\">child</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_c = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_d = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_d</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_e = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_e</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// m_a = 0x010FFD14\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_b = 0x010FFD18\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_c = 0x010FFD1C\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_d = 0x010FFD20\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_e = 0x010FFD24\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>未继承任何的父类的类，类的成员变量都是按照声明的顺序排列的。根据打印出的地址，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1c111e5dab69d1a5bd7644e26e7644c4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"372\" data-rawheight=\"158\" class=\"content_image\" width=\"372\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;372&#39; height=&#39;158&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"372\" data-rawheight=\"158\" class=\"content_image lazy\" width=\"372\" data-actualsrc=\"https://pic1.zhimg.com/v2-1c111e5dab69d1a5bd7644e26e7644c4_b.jpg\"/></figure><h3>2.2 单继承无虚函数父类</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base_b</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_layout</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Child</span> <span class=\"n\">child</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_base_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_basse_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_c = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_d = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_d</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_e = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_e</span><span class=\"p\">);</span>\n    <span class=\"c1\">// m_base_a = 0x00B3FCDC\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_basse_b = 0x00B3FCE0\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_a = 0x00B3FCE4\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_b = 0x00B3FCE8\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_c = 0x00B3FCEC\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_d = 0x00B3FCF0\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_e = 0x00B3FCF4\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>单继承无虚函数，先是父类声明的先后顺序，再按照子类的声明的先后顺序，根据打印出的地址，如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e0e4126f4505f48074c86726017e1986_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"229\" class=\"content_image\" width=\"408\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;408&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"408\" data-rawheight=\"229\" class=\"content_image lazy\" width=\"408\" data-actualsrc=\"https://pic3.zhimg.com/v2-e0e4126f4505f48074c86726017e1986_b.jpg\"/></figure><h3>2.3 多重继承父类</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base3</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base3_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base3_b</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Base</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Base3</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_layout</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Child</span> <span class=\"n\">child</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_base_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_basse_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_base3_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base3_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_basse3_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_base3_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_a = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_b = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_c = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_d = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_d</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;m_e = 0x%p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">m_e</span><span class=\"p\">);</span>\n\n    <span class=\"c1\">// m_base_a = 0x010FF6B0\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_basse_b = 0x010FF6B4\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_base3_a = 0x010FF6B8\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_basse3_b = 0x010FF6BC\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_a = 0x010FF6C0\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_b = 0x010FF6C4\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_c = 0x010FF6C8\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_d = 0x010FF6CC\n</span><span class=\"c1\"></span>    <span class=\"c1\">// m_e = 0x010FF6D0\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>当类中出现多个继承父类，成员变量的排列顺序，按照继承的先后顺序排列。若下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-33d3fc08337554305199ee2ef6433d88_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb\" width=\"433\" data-original=\"https://pic1.zhimg.com/v2-33d3fc08337554305199ee2ef6433d88_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;433&#39; height=&#39;232&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"433\" data-rawheight=\"232\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"433\" data-original=\"https://pic1.zhimg.com/v2-33d3fc08337554305199ee2ef6433d88_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-33d3fc08337554305199ee2ef6433d88_b.jpg\"/></figure><h3>2.4 多重继承父类+（单/双）虚函数</h3><p>在多继承过程中，父类中一方含有虚函数，另一方没有。或者是两个父类都含有虚函数。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base_b</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Base</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base3</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base3_a</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">m_base3_b</span><span class=\"p\">;</span>\n<span class=\"c1\">// virtual ~Base3() {}\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Base</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Base3</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>将上面的代码保存为member_layout.cpp，我们利用在第四节文章里面的用到的工具，在windows菜单找到vs2013 开发人员命令提示工具，双击进入命令行的界面。</p><p>运行cl /d1 reportSingleClassLayoutChild member_layout.cpp，在不改变继承的顺序下，手动的添加和删除虚析构函数，导出的结果如下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a0eacabbc5f25ee452a82fe835a10bfc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb\" width=\"852\" data-original=\"https://pic1.zhimg.com/v2-a0eacabbc5f25ee452a82fe835a10bfc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;852&#39; height=&#39;632&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"852\" data-rawheight=\"632\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"852\" data-original=\"https://pic1.zhimg.com/v2-a0eacabbc5f25ee452a82fe835a10bfc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a0eacabbc5f25ee452a82fe835a10bfc_b.jpg\"/></figure><p>从表对比可以看出，继承的父类有没有虚函数是会影响子类的成员的布局。</p><p>1.子类继承了多个父类，其中有多个父类有虚函数，会优先排列有虚函数的父类并且按照继承的先后顺序排列，其次再排序无虚函数的父类。</p><p>2.如果继承的父类都是有虚函数或者是都没有虚函数，那么都按照继承的先后顺序排列。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-45c652a44fda1a9b8fb81f3607963ef2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"444\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"444\" data-original=\"https://pic3.zhimg.com/v2-45c652a44fda1a9b8fb81f3607963ef2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;444&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"444\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"444\" data-original=\"https://pic3.zhimg.com/v2-45c652a44fda1a9b8fb81f3607963ef2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-45c652a44fda1a9b8fb81f3607963ef2_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b22438b8b26b670eb7491d6ef9f609ae_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"298\" data-rawheight=\"327\" class=\"content_image\" width=\"298\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;298&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"298\" data-rawheight=\"327\" class=\"content_image lazy\" width=\"298\" data-actualsrc=\"https://pic3.zhimg.com/v2-b22438b8b26b670eb7491d6ef9f609ae_b.jpg\"/></figure><h3>2.5 虚基类继承无虚函数</h3><p>将如下代码保存为member_layout.cpp，注意在这里为了探究内存布局，我删除了父类的所有虚函数，这样的设计不合理的，大家请注意。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Grand</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">G1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">G11</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Parent1</span> <span class=\"o\">:</span> <span class=\"k\">virtual</span> <span class=\"k\">public</span> <span class=\"n\">Grand</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">P1</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Parent2</span><span class=\"o\">:</span> <span class=\"k\">virtual</span> <span class=\"k\">public</span> <span class=\"n\">Grand</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">P2</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child3</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Parent1</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Parent2</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">C3</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>使用vs2013开发人员命令提示工具，定位你自己的member_layout.cpp目录，比如我的：J:\\code\\code_git\\ \\polymorphism_virtual\\source，输入命令：cl /d1 reportSingleClassLayoutChild3 member_layout.cpp，Child3表示你要导出的类布局。</p><p>我截取重要的内容贴出来：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c8e2da9c31f4f54f3b863c6fcef74a04_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"885\" data-rawheight=\"760\" class=\"origin_image zh-lightbox-thumb\" width=\"885\" data-original=\"https://pic1.zhimg.com/v2-c8e2da9c31f4f54f3b863c6fcef74a04_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;885&#39; height=&#39;760&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"885\" data-rawheight=\"760\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"885\" data-original=\"https://pic1.zhimg.com/v2-c8e2da9c31f4f54f3b863c6fcef74a04_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c8e2da9c31f4f54f3b863c6fcef74a04_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-36e3ecd094f973bf4c3a04507a0ea12e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb\" width=\"889\" data-original=\"https://pic3.zhimg.com/v2-36e3ecd094f973bf4c3a04507a0ea12e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;889&#39; height=&#39;175&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"889\" data-rawheight=\"175\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"889\" data-original=\"https://pic3.zhimg.com/v2-36e3ecd094f973bf4c3a04507a0ea12e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-36e3ecd094f973bf4c3a04507a0ea12e_b.jpg\"/></figure><p>从表中我们可以清晰的看出来，Child3虚继承之后的布局。从Child3角度每个父类都会带一个vbptr（虚基类表指针），它指向一个虚基类表。我们先画出内存结构图的</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0a5c0d1f8cffcd09d5abe12edb76d5f7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"126\" class=\"content_image\" width=\"393\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;393&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"393\" data-rawheight=\"126\" class=\"content_image lazy\" width=\"393\" data-actualsrc=\"https://pic4.zhimg.com/v2-0a5c0d1f8cffcd09d5abe12edb76d5f7_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c133e8abf8a362bb6c5c18ae4a458a45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"135\" class=\"content_image\" width=\"418\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;418&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"418\" data-rawheight=\"135\" class=\"content_image lazy\" width=\"418\" data-actualsrc=\"https://pic2.zhimg.com/v2-c133e8abf8a362bb6c5c18ae4a458a45_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-83a617bbaf661220da532ea0e212e78f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-83a617bbaf661220da532ea0e212e78f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;429&#39; height=&#39;142&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"429\" data-rawheight=\"142\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"429\" data-original=\"https://pic4.zhimg.com/v2-83a617bbaf661220da532ea0e212e78f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-83a617bbaf661220da532ea0e212e78f_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-099370f5518b7ec12a28dd36f8e3dda7_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"404\" data-rawheight=\"171\" class=\"content_image\" width=\"404\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;404&#39; height=&#39;171&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"404\" data-rawheight=\"171\" class=\"content_image lazy\" width=\"404\" data-actualsrc=\"https://pic4.zhimg.com/v2-099370f5518b7ec12a28dd36f8e3dda7_b.jpg\"/></figure><p>虚基类表中包含两项，第一项我们先跳过不解释，第二项是什么意思呢？</p><p>我们来写段测试代码看看：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">test_virtual_base_table</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"n\">Child3</span> <span class=\"n\">c3</span><span class=\"p\">;</span>\n<span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">G1</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">G11</span> <span class=\"o\">=</span> <span class=\"mi\">11</span><span class=\"p\">;</span>\n    <span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">P1</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">P2</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">C3</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-ca65\">00C1DF48  push 1  \n00C1DF4A  lea ecx,[c3]  ; 虚基类表指针复制给ecx\n00C1DF4D  call data_semantics::Child3::Child3 (0C11758h)  \n    c3.G1 = 0;\n00C1DF52  mov eax,dword ptr [c3]  ; 通过基类表指针--&gt;找到虚基类表首地址\n    c3.G1 = 0;\n00C1DF55  mov ecx,dword ptr [eax+4]  ; 跳过虚基类表的前4个字节，找到第二项\n00C1DF58  mov dword ptr c3[ecx],0  ; c3+[ecx]偏移，复制给G1所在内存地址为0\n    c3.G11 = 11;\n00C1DF60  mov eax,dword ptr [c3]  ; 通过基类表指针--&gt;找到虚基类表首地址\n00C1DF63  mov ecx,dword ptr [eax+4]  ; 跳过虚基类表的前4个字节，找到第二项\n00C1DF66  mov dword ptr [ebp+ecx-20h],0Bh  ; 复制给G1所在内存地址为0BH,ebp-20h其实为P1的地址\n    c3.P1 = 1;\n00C1DF6E  mov dword ptr [ebp-20h],1  \n    c3.P2 = 2;\n00C1DF75  mov dword ptr [ebp-18h],2  \n    c3.C3 = 3;\n00C1DF7C  mov dword ptr [ebp-14h],3</code></pre></div><p>如果你阅读过《第四章 虚函数的原理》，你会发现这个对虚函数的寻址机制是完全相同的。</p><p>都是根据指针--&gt;虚表--&gt;虚表中的内容，看下图的成员变量的偏移量值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0fef5ddbf4785b4ce5fa8ec93a9ddf79_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"330\" data-rawheight=\"226\" class=\"content_image\" width=\"330\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;330&#39; height=&#39;226&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"330\" data-rawheight=\"226\" class=\"content_image lazy\" width=\"330\" data-actualsrc=\"https://pic2.zhimg.com/v2-0fef5ddbf4785b4ce5fa8ec93a9ddf79_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们看下Child3中G1是怎么寻址的，看下图所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-0658618e2eb56581986840b13f63672f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-0658618e2eb56581986840b13f63672f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;526&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"526\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"526\" data-original=\"https://pic4.zhimg.com/v2-0658618e2eb56581986840b13f63672f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-0658618e2eb56581986840b13f63672f_b.jpg\"/></figure><p>所以可以得出结论，子类虚基类表中的第二项内容其实存储是个偏移量。虚基类中的内容是放到子类的最后面，然后子类根据虚基类表中的偏移找到虚基类成员的位置。</p><p>同样的道理G11也是按照这种原理寻址的。需要注意下<b>mov</b> <b>dword</b> ptr <b>[ebp+ecx-</b>20h<b>]，ebp-20h</b>其实P1的首地址，所以从P1的地址开始（跳过前面的vbptr 4个字节）+20正好就是G11的地址。</p><p>Child3中的Parent1,Parent2中都包含一个vbptr。这和vptr是十分类似的原理，懂了虚函数的原理，那么你搞懂虚基类表也是非常容易的。</p><h3>2.6 虚继承+虚函数继承</h3><p>在2.4中为了探究虚继承的内存布局，我把Grand类中的虚析构函数删除。这样的设计是不合理的，这里我们给Grand加上虚析构函数。关于为什么父类中一定要虚析构函数可以参考《第四章 虚函数原理》。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Grand</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">G1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">G11</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Grand</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>我们再使用工具导出类布局</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-341f5f8467947da74ecbd52401ac05dc_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-341f5f8467947da74ecbd52401ac05dc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;873&#39; height=&#39;768&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"873\" data-rawheight=\"768\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"873\" data-original=\"https://pic1.zhimg.com/v2-341f5f8467947da74ecbd52401ac05dc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-341f5f8467947da74ecbd52401ac05dc_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-e63f1f5a52db5e06647aa16c57647d4b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"881\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb\" width=\"881\" data-original=\"https://pic4.zhimg.com/v2-e63f1f5a52db5e06647aa16c57647d4b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;881&#39; height=&#39;214&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"881\" data-rawheight=\"214\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"881\" data-original=\"https://pic4.zhimg.com/v2-e63f1f5a52db5e06647aa16c57647d4b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-e63f1f5a52db5e06647aa16c57647d4b_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d997d0693ca6da133b7e81038f6d06b8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"430\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb\" width=\"430\" data-original=\"https://pic1.zhimg.com/v2-d997d0693ca6da133b7e81038f6d06b8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;430&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"430\" data-rawheight=\"244\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"430\" data-original=\"https://pic1.zhimg.com/v2-d997d0693ca6da133b7e81038f6d06b8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d997d0693ca6da133b7e81038f6d06b8_b.jpg\"/></figure><p>可以看出Grand中增加一个虚函数，在子类中Child3中的布局中增加了一个vfptr指针，这个指针指向一个表，表中就存储了虚函数的地址，其实就是我们说的虚函数表，vfptr就是相当于我们之前讨论的vptr。</p><p>还剩下的几种情况虚继承+虚函数的情形，都是相同的分析机制。这里我就不再分析了。</p><h2>3.数据成员的读取</h2><p>前面我们详细的分析了各种模式下，类中内存中的布局。既然我们知道了数据在哪里，那么接下来讨论数据是怎么读取的。</p><p>其实，我们已经知道数据在内存的位置，将会非常有利于我们理解对于成员变量的读取，甚至可以说我们已经理解了一半。</p><h3>3.1 数据成员</h3><p>static成员是属于整个类的，并不单独属于某一个实例化的对象。我们接着借用上面的代码Child3类，在里面增加几行代码。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child3</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Parent1</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Parent2</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">C3</span><span class=\"p\">;</span>\n\t<span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">s_Age</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">int</span> <span class=\"n\">Child3</span><span class=\"o\">::</span><span class=\"n\">s_Age</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_call_member</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n\t<span class=\"n\">Child3</span><span class=\"o\">::</span><span class=\"n\">s_Age</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n\t<span class=\"n\">Child3</span> <span class=\"n\">c3</span><span class=\"p\">;</span>\n\t<span class=\"n\">c3</span><span class=\"p\">.</span><span class=\"n\">s_Age</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\t\n\t<span class=\"n\">Child3</span> <span class=\"o\">*</span><span class=\"n\">pc3</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Child3</span><span class=\"p\">();</span>\n\t<span class=\"n\">pc3</span><span class=\"o\">-&gt;</span><span class=\"n\">s_Age</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>接下来我们看下test_call_member反汇编的调用方式有什么不同。</p><div class=\"highlight\"><pre><code class=\"language-ca65\">    Child3::s_Age = 0;\n0092ADC0  mov         dword ptr ds:[93B000h],0  \n    Child3 c3;\n0092ADCA  push        1  \n0092ADCC  lea         ecx,[c3]  \n0092ADCF  call        data_semantics::Child3::Child3 (09217A8h)  \n0092ADD4  mov         dword ptr [ebp-4],0  \n    c3.s_Age = 1;\n0092ADDB  mov         dword ptr ds:[93B000h],1  \nChild3 *pc3 = new Child3(); \n0092AE26  mov         dword ptr ds:[93B000h],2  </code></pre></div><p>从上述代码中我们看出，如果是静态成员，不管你的调用方式如何。其实他们最后的汇编代码都是一样的。从侧面可以看出静态数据是放在全局的数据区，和对象是没有关系的。</p><h3>3.1.2 no static成员</h3><p>前面我们学习了static成员的是怎么找到，但是和实例对象相关的成员我们该怎么定位呢。</p><p>我们看下面的代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child4</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m2</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m3</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m4</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_initialize</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">Child4</span> <span class=\"o\">*</span><span class=\"n\">c5</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Child4</span><span class=\"p\">();</span>\n    <span class=\"n\">c5</span><span class=\"o\">-&gt;</span><span class=\"n\">m1</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span><span class=\"n\">ss</span>\n    <span class=\"n\">c5</span><span class=\"o\">-&gt;</span><span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"o\">-&gt;</span><span class=\"n\">m3</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"o\">-&gt;</span><span class=\"n\">m4</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    \n    <span class=\"n\">Child4</span> <span class=\"n\">c4</span><span class=\"p\">;</span>\n    <span class=\"n\">c4</span><span class=\"p\">.</span><span class=\"n\">m1</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">c4</span><span class=\"p\">.</span><span class=\"n\">m2</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">c4</span><span class=\"p\">.</span><span class=\"n\">m3</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">c4</span><span class=\"p\">.</span><span class=\"n\">m4</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>接下来我们通过反汇编代码看下是如何定位成员变量。</p><div class=\"highlight\"><pre><code class=\"language-ca65\">; 第一段\n    c5-&gt;m1 = 0;\n011AC94F  mov         eax,dword ptr [c5]  \n011AC952  mov         dword ptr [eax],0  \n    c5-&gt;m2 = 1;\n011AC958  mov         eax,dword ptr [c5]  \n011AC95B  mov         dword ptr [eax+4],1  \n    c5-&gt;m3 = 2;\n011AC962  mov         eax,dword ptr [c5]  \n011AC965  mov         dword ptr [eax+8],2  \n    c5-&gt;m4 = 3;\n011AC96C  mov         eax,dword ptr [c5]  \n011AC96F  mov         dword ptr [eax+0Ch],3  \n; 第二段\n    Child4 c4;\n    c4.m1 = 0;\n011AC976  mov         dword ptr [c4],0  \n    c4.m2 = 1;\n011AC97D  mov         dword ptr [ebp-1Ch],1  \n    c4.m3 = 2;\n011AC984  mov         dword ptr [ebp-18h],2  \n    c4.m4 = 3;\n011AC98B  mov         dword ptr [ebp-14h],3  </code></pre></div><p>我们先看第一段汇编代码，首先[c5]中保存对象的首地址给eax，对eax解引用然后赋值0。再对(eax+4)解引用赋值1，再对(eax+8)解引用赋值2，再对(eax+12)解引用赋值3。我就可以看出这里根据对象的首地址+成员变量的偏移，就能找到对应的对象然后进行读取操作。</p><p>这时我们再看第二段的汇编代码，大家可能就奇怪了，为什么第二种的定位方式第一种不同呢。</p><p>其实这里定位的原理是一致的。第一种方式，c5对象是new出来，也就是说它的内存是堆中的，堆区是个非常灵活的区域申请和释放都是自己可以控制的，同时它的增长的方向是从低地址--&gt;高地址。而第二种方式呢，c4是在栈中申请的内存，相比较堆呢，它的可控性就弱了很多，而且它的增长方向是从高地址--&gt;低地址，这一点和堆是完全相反的，记住ebp表示的基址指针寄存器，该指针指向系统栈最上面一个栈<a href=\"https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%25E6%25A0%2588%25E5%25B8%25A7/5662951\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">帧</a>的底部。</p><p>我们做个表格对比下两种：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a26704d002a51b7e5548d5ff564cb50d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb\" width=\"840\" data-original=\"https://pic2.zhimg.com/v2-a26704d002a51b7e5548d5ff564cb50d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;840&#39; height=&#39;354&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"840\" data-rawheight=\"354\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"840\" data-original=\"https://pic2.zhimg.com/v2-a26704d002a51b7e5548d5ff564cb50d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-a26704d002a51b7e5548d5ff564cb50d_b.jpg\"/></figure><p>采用的原理都是一样的，都是利用成员变量的偏移量，只不过它们的增长的方式不一样。堆往上增长，栈是往下增长。</p><h3>3.2 读取的效率</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base6</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base6_a</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Base6</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">s_base6_b</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">int</span> <span class=\"n\">Base6</span><span class=\"o\">::</span><span class=\"n\">s_base6_b</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base4</span> <span class=\"o\">:</span> <span class=\"k\">virtual</span> <span class=\"k\">public</span> <span class=\"n\">Base6</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base4_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base4_b</span><span class=\"p\">;</span>\n    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">s_base4_c</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Base4</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">int</span> <span class=\"n\">Base4</span><span class=\"o\">::</span><span class=\"n\">s_base4_c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base5</span> <span class=\"o\">:</span> <span class=\"k\">virtual</span> <span class=\"k\">public</span> <span class=\"n\">Base6</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base5_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_base5_b</span><span class=\"p\">;</span>\n    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">s_base5_c</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">Base5</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">int</span> <span class=\"n\">Base5</span><span class=\"o\">::</span><span class=\"n\">s_base5_c</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child5</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Base4</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Base5</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_effective</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n<span class=\"n\">Child5</span><span class=\"o\">::</span><span class=\"n\">s_base6_b</span> <span class=\"o\">=</span> <span class=\"mi\">10</span><span class=\"p\">;</span>\n    <span class=\"n\">Child5</span><span class=\"o\">::</span><span class=\"n\">s_base4_c</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">Child5</span><span class=\"o\">::</span><span class=\"n\">s_base5_c</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Child5</span> <span class=\"n\">c5</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"p\">.</span><span class=\"n\">m_a</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"p\">.</span><span class=\"n\">m_base4_a</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"p\">.</span><span class=\"n\">m_base5_a</span> <span class=\"o\">=</span> <span class=\"mi\">5</span><span class=\"p\">;</span>\n    <span class=\"n\">c5</span><span class=\"p\">.</span><span class=\"n\">m_base6_a</span> <span class=\"o\">=</span> <span class=\"mi\">6</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>我们从汇编的角度（debug 模式下）看下他们的效率。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cbeebbb69ad3a5523544208bfa598453_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"865\" data-rawheight=\"332\" class=\"origin_image zh-lightbox-thumb\" width=\"865\" data-original=\"https://pic4.zhimg.com/v2-cbeebbb69ad3a5523544208bfa598453_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;865&#39; height=&#39;332&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"865\" data-rawheight=\"332\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"865\" data-original=\"https://pic4.zhimg.com/v2-cbeebbb69ad3a5523544208bfa598453_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cbeebbb69ad3a5523544208bfa598453_b.jpg\"/></figure><h3>3.3 Data Member指针</h3><p>指向类的成员变量指针，其实不是指针，实际的内容其实是在整个类中的偏移值。举个例子：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Class7</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">VirFunc</span><span class=\"p\">()</span> <span class=\"p\">{}</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_c</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_member_point</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;&amp;Class7::m_a:%x</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">Class7</span><span class=\"o\">::</span><span class=\"n\">m_a</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;&amp;Class7::m_b:%x</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">Class7</span><span class=\"o\">::</span><span class=\"n\">m_b</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;&amp;Class7::m_c:%x</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">Class7</span><span class=\"o\">::</span><span class=\"n\">m_c</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;&amp;Class7::m_d:%x</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">Class7</span><span class=\"o\">::</span><span class=\"n\">m_d</span><span class=\"p\">);</span>\n    <span class=\"c1\">// &amp;Class7::m_a:4\n</span><span class=\"c1\"></span>    <span class=\"c1\">// &amp;Class7::m_b:8\n</span><span class=\"c1\"></span>    <span class=\"c1\">// &amp;Class7::m_c:c\n</span><span class=\"c1\">// &amp;Class7::m_d:10\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 用法\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">Class7</span><span class=\"o\">::*</span><span class=\"n\">cpoint</span> <span class=\"o\">=</span> <span class=\"o\">&amp;</span><span class=\"n\">Class7</span><span class=\"o\">::</span><span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"n\">Class7</span> <span class=\"n\">c7</span><span class=\"p\">;</span>\n    <span class=\"n\">c7</span><span class=\"p\">.</span><span class=\"o\">*</span><span class=\"n\">cpoint</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> \n    <span class=\"c1\">// *(&amp;c7+cpoint) = 1;\n</span><span class=\"c1\"></span><span class=\"p\">}</span>\n</code></pre></div><p>从代码中可以看出来，打印的是成员变量的偏移值。值的注意下就是这里打印的偏移值是从4开始的，因为Class7含有虚函数，存在一个虚表指针。</p><p>我们再看下成员指针的初始化和使用，int Class7::*cpoint = &amp;Class7::m_a; Class7 c7; c7.*cpoint = 1;用法其实很简单，但是困扰我的是这个成员变量指针到底有啥用。我尝试google下也没有发现有价值的资料，从《深入探索C++对象模型》里面提到了这个可以帮我们看出成员变量的偏移位置，但是我觉得这个意义不大的。这个让我很困惑。</p><h2>4.进程内存布局</h2><p>变量在内存是如何分布的，我们借助linux上nm（names）命令看下，代码如下</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\">\n</span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">g1</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">g2</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">g3</span> <span class=\"o\">=</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">g4</span> <span class=\"o\">=</span> <span class=\"mi\">4</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"n\">g5</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">g6</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>  \n\n<span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">gs_7</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">gs_8</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">gs_9</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> \n\n<span class=\"kt\">void</span> <span class=\"nf\">g_func</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">MyClass</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_i</span><span class=\"p\">;</span>\n    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">m_si</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_j</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 声明\n</span><span class=\"c1\"></span>    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">m_sj</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_k</span><span class=\"p\">;</span>\n    <span class=\"k\">static</span> <span class=\"kt\">int</span> <span class=\"n\">m_sk</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"c1\">// 定义\n</span><span class=\"c1\"></span><span class=\"kt\">int</span> <span class=\"n\">MyClass</span><span class=\"o\">::</span><span class=\"n\">m_sj</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">argc</span> <span class=\"p\">,</span><span class=\"kt\">char</span> <span class=\"o\">*</span><span class=\"n\">argv</span><span class=\"p\">[])</span>\n<span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">temp_i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;tempi address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">temp_i</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g1 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g1</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g2 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g2</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g3 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g3</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g4 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g4</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g5 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g5</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g6 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">g6</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;gs_7 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">gs_7</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;gs_8 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">gs_8</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;gs_9 address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"n\">gs_9</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;MyClass::m_sj address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"o\">&amp;</span><span class=\"p\">(</span><span class=\"n\">MyClass</span><span class=\"o\">::</span><span class=\"n\">m_sj</span><span class=\"p\">));</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;g_func() address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">g_func</span><span class=\"p\">);</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">&#34;main() address = %p</span><span class=\"se\">\\n</span><span class=\"s\">&#34;</span><span class=\"p\">,</span> <span class=\"n\">main</span><span class=\"p\">);</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;g_test &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"p\">(</span><span class=\"kt\">void</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">g_test</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>1.使用g++ process_member_layout -o process_memeber_layout</p><p>2.在使用nm process_memeber_layout导出的数据如下所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-41898b34e492234042b023cb35ae83b4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"569\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb\" width=\"569\" data-original=\"https://pic1.zhimg.com/v2-41898b34e492234042b023cb35ae83b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;569&#39; height=&#39;737&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"569\" data-rawheight=\"737\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"569\" data-original=\"https://pic1.zhimg.com/v2-41898b34e492234042b023cb35ae83b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-41898b34e492234042b023cb35ae83b4_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-c8bc4f11497bc9afee3ccfb8169de814_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb\" width=\"644\" data-original=\"https://pic1.zhimg.com/v2-c8bc4f11497bc9afee3ccfb8169de814_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;644&#39; height=&#39;688&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"644\" data-rawheight=\"688\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"644\" data-original=\"https://pic1.zhimg.com/v2-c8bc4f11497bc9afee3ccfb8169de814_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-c8bc4f11497bc9afee3ccfb8169de814_b.jpg\"/></figure><p>我从网上找了张内存映射图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b95c41fa6c96abe72ef197a3396f10ce_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"160\" data-rawheight=\"229\" class=\"content_image\" width=\"160\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;160&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"160\" data-rawheight=\"229\" class=\"content_image lazy\" width=\"160\" data-actualsrc=\"https://pic3.zhimg.com/v2-b95c41fa6c96abe72ef197a3396f10ce_b.png\"/></figure><h2>5.总结</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0986198ac1076577a3401600dcfdf062_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-0986198ac1076577a3401600dcfdf062_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"312\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-0986198ac1076577a3401600dcfdf062_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0986198ac1076577a3401600dcfdf062_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++11", 
                    "tagLink": "https://api.zhihu.com/topics/19726035"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }
            ], 
            "comments": [
                {
                    "userName": "struct", 
                    "userLink": "https://www.zhihu.com/people/edc181ff7250b6ed49314754552982a3", 
                    "content": "写库的都知道函数指针是非常有意义的，尤其成员指针支持父子类间转换，利用这个可以实现很多特性，比如信号槽，tuple的apply，无虚函数多态等等", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "<p>1.首先赞同你的观点函数指针的确有着非常重要的作用。2.其实对于成员变量指针我理解的不深入（没有看到什么重要的作用），也没有看到在其他有什么精妙的用法。如果您知道，请您解惑下。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "struct"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/82138881", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 79, 
            "title": "C++幕后故事（四）-- 虚函数的魅力", 
            "content": "<h2>提出问题：</h2><p>我们讨论前提都是在windows 10 vs2013 debug模式下</p><p>1.虚函数指针和虚表在哪里？</p><p>2.我们如何手动调用虚函数？</p><p>3.为什么只有在子类以父类的引用或者指针的形式才能出现多态？</p><p>4.虚函数的调用为什么效率相比普通的成员函数较低？又具体低了多少？</p><p>5.为什么构造函数和析构函数尽量不要调用虚函数？</p><p>6.纯虚函数到底是什么？为什么禁止我调用？有什么办法可以绕编译器？</p><p>7.看码说话</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">MemsetObj</span> <span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">MemsetObj</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">memset</span><span class=\"p\">(</span><span class=\"k\">this</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">MemsetObj</span><span class=\"p\">));</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;memsetobj ctor&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">test</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;memset obj test&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">virtual_func</span><span class=\"p\">()</span> <span class=\"p\">{</span>  <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;virtual test&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n     <span class=\"c1\">// 1.\n</span><span class=\"c1\"></span>    <span class=\"n\">MemsetObj</span> <span class=\"n\">obj</span><span class=\"p\">;</span>\n    <span class=\"n\">obj</span><span class=\"p\">.</span><span class=\"n\">virtual_func</span><span class=\"p\">();</span>\n     <span class=\"c1\">// 2.\n</span><span class=\"c1\"></span>    <span class=\"n\">MemsetObj</span> <span class=\"o\">*</span><span class=\"n\">pobj</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">MemsetObj</span><span class=\"p\">();</span>\n<span class=\"n\">pobj</span><span class=\"o\">-&gt;</span><span class=\"n\">virtual_func</span><span class=\"p\">();</span>\n<span class=\"c1\">// 这两种方式调用有问题？什么问题？\n</span></code></pre></div><h2>0.基础知识说明</h2><h3>1.VS 调试</h3><p>1.打开内存窗口</p><p>A.先下断点</p><p>B.在VS中启动程序</p><p>C.VS就会你下的断点处停下</p><p>D.在菜单栏--》调试--》窗口--》内存，就会发现4个内存选项随便选择一个就可以</p><p>2.打开反汇编窗口</p><p>同样在调试的状态下，鼠标右键菜单à转到反汇编</p><h3>2.汇编指令</h3><p>这里我解释下常用的和常见的一些指令，更多的需要大家自己课后学习。</p><p>汇编中有些通用的寄存器分别为eax,ebx,ecx,edx,esi,edi,esp,ebp,es,ds,ss,sp等等，类似高级语言中的变量，但是这些变量的数量和名称都是固定的。</p><p>mov ax,bx ; 将bx的内容移动ax中</p><p>lea ax,[obj] ; load effective address 将obj对象的地址移动ax中</p><p>pop,push 就是栈中的压栈和出栈的操作，函数中的参数就是这么传递的。</p><p>在汇编的角度看C++的成员函数调用的方式叫做__thiscall，就是C++中的this指针，是通过ecx指针传递的，所以会经常看到lea ecx,[base] call FunctionName，套路都是固定的。</p><h2>1.虚函数的含义</h2><p>只有用virtual声明类的成员函数，称之为虚函数。</p><h2>2.虚函数的作用</h2><p>就是一句话：实现多态的基石</p><p>实现多态的三大步：</p><p>1.存在继承关系</p><p>2.重写父类的virtual   function</p><p>3.子类以父类的指针或者是引用的身份出现</p><h2>3.虚函数的实现原理</h2><p>相信很多人都能说出来其中实现关键原理，就是两点：虚函数表指针（vptr），虚函数表（vftable）</p><h3>1.虚函数表指针</h3><p>1.什么是虚函数表指针，他在哪里，有什么用？</p><p>我们把对象从首地址开始的4个字节，这个位置我们称之为<b>虚函数表指针</b>（vptr），它里面包含一个地址指向的就是<b>虚函数表</b>（vftable）的地址。</p><h3>2.虚函数表</h3><h3>1.什么是虚函数表，他又在哪里，有什么用？</h3><p>虚函数表说白了就是里面是一组地址的数组（<b>就是函数指针数组</b>），他所在的位置就是虚函数表指针里面所存储的地址，它里面所包含的地址就是我们重写了父类的虚函数的地址（没有重写父类的虚函数那么默认的就是父类的函数地址）。</p><h2>3.探索虚表位置 </h2><h3>3.1 手动探索虚表位置</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base</span> \n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::f()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">g</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::g()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">h</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::h()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"c1\">// virtual ~Base() { cout &lt;&lt; &#34;~Base&#34; &lt;&lt; endl; }\n</span><span class=\"c1\"></span> <span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">BaseOne</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">i</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::i()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">j</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::j()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">k</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::k()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"c1\">// virtual ~ BaseOne () { cout &lt;&lt; &#34;~ BaseOne &#34; &lt;&lt; endl; }\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Derive</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_d</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">g</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Derive::g()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"c1\">// virtual ~ Derive () { cout &lt;&lt; &#34;~ Derive &#34; &lt;&lt; endl; }\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">MultiDerive</span><span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">BaseOne</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">h</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::h()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">k</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::k()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">m</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::m()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"c1\">// virtual ~ MultiDerive () { cout &lt;&lt; &#34;~ MultiDerive &#34; &lt;&lt; endl; }\n</span><span class=\"c1\"></span><span class=\"p\">};</span>\n</code></pre></div><p>如果代码看的累，我们直接看图（这里我没有用UML图表示）：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d0ef74d5d50e39bbb21ecd5a354f3a61_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb\" width=\"545\" data-original=\"https://pic2.zhimg.com/v2-d0ef74d5d50e39bbb21ecd5a354f3a61_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;545&#39; height=&#39;272&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"545\" data-rawheight=\"272\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"545\" data-original=\"https://pic2.zhimg.com/v2-d0ef74d5d50e39bbb21ecd5a354f3a61_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d0ef74d5d50e39bbb21ecd5a354f3a61_b.jpg\"/></figure><p>既然我们知道vptr的位置，我们开始尝试手动调用虚函数</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"nf\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">Fun</span><span class=\"p\">)();</span>\n<span class=\"kt\">void</span> <span class=\"nf\">test_multi_inhert_virtual_fun</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">MultiDerive</span> <span class=\"n\">multiderive</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 从对象的首地址4个字节，获取vptr的地址，x86平台下指针都是4个字节\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">pbaseone_tablepoint</span>      <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">multiderive</span><span class=\"p\">);</span>\n    <span class=\"c1\">// 对vptr指针解引用操作获取vftable的地址\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">baseone_table_address</span>    <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">pbaseone_tablepoint</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">hex</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;0x&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">baseone_table_address</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">baseone_table_address</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))();</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">baseone_table_address</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))();</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">baseone_table_address</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]))();</span>\n    <span class=\"cm\">/* 打印的结果\n</span><span class=\"cm\">    BaseOne::i()\n</span><span class=\"cm\">    BaseOne::j()\n</span><span class=\"cm\">    MultiDerive::k()\n</span><span class=\"cm\">    */</span>\n    <span class=\"c1\">// 获取第二个虚函数表指针的位置，从基址开始的地址+第一个继承对象的大小\n</span><span class=\"c1\"></span>    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">pbase_tablepoint</span> <span class=\"o\">=</span> \n        <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"k\">reinterpret_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">pbaseone_tablepoint</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">BaseOne</span><span class=\"p\">));</span>\n    <span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">base_table_address</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">pbase_tablepoint</span><span class=\"p\">);</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"mi\">4</span><span class=\"p\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">hex</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;0x&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">base_table_address</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">base_table_address</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))();</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">base_table_address</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))();</span>\n    <span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">base_table_address</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]))();</span>\n    <span class=\"cm\">/*打印的结果\n</span><span class=\"cm\">    Base::f()\n</span><span class=\"cm\">    Base::g()\n</span><span class=\"cm\">    MultiDerive::h()\n</span><span class=\"cm\">    */</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>对于不想看代码的同学，我画了一张图</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a918731cba1f83416fd7c8090e0b67c0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-a918731cba1f83416fd7c8090e0b67c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;364&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"364\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-a918731cba1f83416fd7c8090e0b67c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-a918731cba1f83416fd7c8090e0b67c0_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>对于这张图里面的一些强转我做些解释：</p><p>1.x86平台下，指针类型都是4个字节，所用你可以把long *替换为int *没有问题，只要这个指针的步长是4字节的都可以。</p><p>2.获取第二个vftable时，强转为char*类型，因为指针类型做+/-运算有个步长概念，有的称之为比例因子。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-dbcea3cfc9f780bc54ca80f12b5f3c39_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"967\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb\" width=\"967\" data-original=\"https://pic2.zhimg.com/v2-dbcea3cfc9f780bc54ca80f12b5f3c39_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;967&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"967\" data-rawheight=\"252\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"967\" data-original=\"https://pic2.zhimg.com/v2-dbcea3cfc9f780bc54ca80f12b5f3c39_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-dbcea3cfc9f780bc54ca80f12b5f3c39_b.jpg\"/></figure><p>从表中我们可以看出来，其实这个vptr和vftable也没啥神秘的地方，就是一个指针指向装有函数指针的数组。数组里面的内容如果子类没有override，那么默认值就是父类的虚函数地址，否则就是子类自己的函数（表中红色部分）</p><h3>3.2 cl.exe验证虚表的位置</h3><p>我们对类的声明代码稍作修改，做成独立的cpp文件</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/****************************************************************************\n</span><span class=\"cm\">**\n</span><span class=\"cm\">** Copyright (C) 2019 635672377@qq.com\n</span><span class=\"cm\">** All rights reserved.\n</span><span class=\"cm\">**\n</span><span class=\"cm\">****************************************************************************/</span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span><span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">BaseOne</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">i</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::i()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">j</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::j()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">k</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;BaseOne::k()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span> \n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">f</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::f()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">g</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::g()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">h</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Base::h()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">MultiDerive</span> <span class=\"o\">:</span><span class=\"k\">public</span> <span class=\"n\">BaseOne</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">Base</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_e</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">h</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::h()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">k</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::k()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">m</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;MultiDerive::m()&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span> <span class=\"nf\">main</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>   \n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在windows菜单中找到vs2013命令行工具</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-279cfcb6cc254073be134332737e90ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-279cfcb6cc254073be134332737e90ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;188&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"188\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-279cfcb6cc254073be134332737e90ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-279cfcb6cc254073be134332737e90ad_b.jpg\"/></figure><p>cd 到你所在cpp文件的目录中比如我：cd /d j:\\code\\polymorphism_virtual\\source\\</p><p>执行命令 cl /d1 reportSingleClassLayoutMultiDerive analysis_virtual_by_tools.cpp</p><p>注意MultiDerive表示你想导出来的类布局</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-623f0fc94207d0eeb00ea9d70bf9f4b0_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"727\" data-rawheight=\"817\" class=\"origin_image zh-lightbox-thumb\" width=\"727\" data-original=\"https://pic1.zhimg.com/v2-623f0fc94207d0eeb00ea9d70bf9f4b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;727&#39; height=&#39;817&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"727\" data-rawheight=\"817\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"727\" data-original=\"https://pic1.zhimg.com/v2-623f0fc94207d0eeb00ea9d70bf9f4b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-623f0fc94207d0eeb00ea9d70bf9f4b0_b.jpg\"/></figure><p>从导出来的数据中可以看出：</p><p>1.MultiDerive大小、内存布局、以及成员变量的偏移、vftable的寻址</p><p>2.大家可能看到红色标注的-8有点奇怪，这个就是计算第二个vptr的偏移地址，计算方式是首地址-第二个vptr的所在的地址=-8，他们之间的距离就是一个BaseOne的大小。</p><h3>3.3 VS IDE查看虚表位置</h3><p>这种方式比较简答，就是启动VS，下个断点，将鼠标移动到MultiDerive实例上，可以看到详细的信息。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-d53bd27fcae7fb66d479a0d4565a2df8_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"70\" class=\"origin_image zh-lightbox-thumb\" width=\"547\" data-original=\"https://pic1.zhimg.com/v2-d53bd27fcae7fb66d479a0d4565a2df8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;547&#39; height=&#39;70&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"547\" data-rawheight=\"70\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"547\" data-original=\"https://pic1.zhimg.com/v2-d53bd27fcae7fb66d479a0d4565a2df8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-d53bd27fcae7fb66d479a0d4565a2df8_b.png\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f2b6c29b0ac46fc8022a301e8618b708_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb\" width=\"540\" data-original=\"https://pic1.zhimg.com/v2-f2b6c29b0ac46fc8022a301e8618b708_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;540&#39; height=&#39;83&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"540\" data-rawheight=\"83\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"540\" data-original=\"https://pic1.zhimg.com/v2-f2b6c29b0ac46fc8022a301e8618b708_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f2b6c29b0ac46fc8022a301e8618b708_b.png\"/></figure><p>从这里你可能发现一个问题，子类自己的虚函数这里没有体现出来，所以建议cl.exe工具验证虚表。</p><h3>3.4 内存布局图</h3><p>到这里我们可以画图上述代码中类的内存布局图：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2c2d9806e6d8b08cbac82fb8752307ac_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-2c2d9806e6d8b08cbac82fb8752307ac_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-2c2d9806e6d8b08cbac82fb8752307ac_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2c2d9806e6d8b08cbac82fb8752307ac_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-e7e2594c291f128094ebf3cc1534998c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-e7e2594c291f128094ebf3cc1534998c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;236&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"236\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-e7e2594c291f128094ebf3cc1534998c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e7e2594c291f128094ebf3cc1534998c_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-179f34a109e9835b44fce9cc388023a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-179f34a109e9835b44fce9cc388023a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;268&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"268\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-179f34a109e9835b44fce9cc388023a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-179f34a109e9835b44fce9cc388023a2_b.jpg\"/></figure><p>从Derive和MultiDerive内存图我们发现一些规律：</p><p>1.继承的体系越复杂，子类的体积越大。</p><p>2.子类中普通成员顺序按照继承的先后顺序来的。</p><p>3.多重继承，子类中含有多个vptr，分别指向不同的vftable。</p><p>4. vftable中的虚函数地址和在类中声明的顺序一致。</p><p>5.如果子类override父类中虚函数，那么子类vftable中就会替换原来父类的虚函数。</p><p>6.如果子类自己含有额外的虚函数，则会附加到第一个vftable中。</p><p>7. vftable中的最后一个值可能为0x0，有时候并不是为0，上图中红色字部分。</p><p>8.子类有vftable，同时父类也有一份vftable，两个vftable没有关联。每个实例化子类都共享一个vftable，同样父类所有实例化对象也共享一份vftable，非常类似类的静态变量。</p><h3>3.4 虚析构函数用函数指针间接调用会崩溃</h3><p>眼尖的同学可能注意到探索虚表位置的代码，我注释掉了父类中所有的虚析构函数。我本想拿到虚表地址，就拿到了虚析构函数的地址，我用函数指针强制转换就可以调用，但是我一调用就崩溃。好，废话不说，反汇编走起来。</p><p>1.手动调用析构函数的反汇编代码</p><div class=\"highlight\"><pre><code class=\"language-ca65\">;  base.~Base();\n; 传递参数0\n002D99EF  push        0  \n; 传递this到ecx\n002D99F1  lea         ecx,[base]  \n; 调用一个类似析构函数的函数\n002D99F4  call        virtual_fun_table::Base::`scalar deleting destructor&#39; (02D16C2h) </code></pre></div><p>2.动手验证猜想</p><p>看了反汇编代码，会惊讶的发现，居然push 0了，说明编译器帮我们传递一个参数，那我们就自己手动也传递一个，你同时发现了这里并不是直接调用Base的析构函数（代理析构函数）。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">typedef</span> <span class=\"nf\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">DctorFun</span><span class=\"p\">)(</span><span class=\"kt\">int</span><span class=\"p\">);</span>\n<span class=\"n\">Base</span> <span class=\"n\">base</span><span class=\"p\">;</span>\n<span class=\"n\">base</span><span class=\"p\">.</span><span class=\"o\">~</span><span class=\"n\">Base</span><span class=\"p\">();</span>\n<span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">vptr</span>      <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">&amp;</span><span class=\"n\">base</span><span class=\"p\">);</span>\n<span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"n\">vftable</span>   <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"kt\">long</span> <span class=\"o\">*</span><span class=\"p\">)(</span><span class=\"o\">*</span><span class=\"n\">vptr</span><span class=\"p\">);</span>\n<span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">vftable</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]))();</span>\n<span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">vftable</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]))();</span>\n<span class=\"p\">((</span><span class=\"n\">Fun</span><span class=\"p\">)(</span><span class=\"n\">vftable</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]))();</span>\n<span class=\"p\">((</span><span class=\"n\">DctorFun</span><span class=\"p\">)(</span><span class=\"n\">vftable</span><span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">]))(</span><span class=\"mi\">0</span><span class=\"p\">);</span> <span class=\"p\">;</span> <span class=\"err\">调用</span><span class=\"n\">Base的虚析构函数</span>\n</code></pre></div><p>恩，应该没有问题了，开心的跑起来，VS F5跑起来。但还是抛出异常了…</p><p>想不出来啥原因，还是看反汇编吧，不断的跟啊跟啊，发现崩溃在~Base函数里面。</p><div class=\"highlight\"><pre><code class=\"language-ca65\">01276EFF  pop          ecx  \n01276F00  mov         dword ptr [this],ecx  \n01276F03  mov         eax,dword ptr [this]  \n01276F06  mov         dword ptr [eax],1282BD8h</code></pre></div><p>这里拿到ecx，然后又一次赋值虚表地址<b>1282BD8h</b>。但是我们是直接调用虚函数，没有push ecx，所以这里拿到的ecx值是个不确定的值就相当于一个野指针问题。</p><p>我们知道了为什么崩溃的原因，但是仔细想想这里为什么还需要再一次重新赋值虚表地址，在构造函数的时候不是已经初始化好虚表的地址了？</p><p>试想下这样的情形：Derive继承Base，在调用Derive析构函数时，先是调用Derive的析构函数，再Base调用的析构函数。如果在调用Base的析构函数时不重置虚表的话，那么Base中可能出现间接的调用Derive虚函数，而此时Derive的已经执行过析构函数，里面的数据已经是不可靠的，存在安全隐患。</p><p>同时得出结论析构函数和构造函数中调用虚函数并没有多态的特性。</p><p>关于间接的调用虚函数说明：</p><p>我们知道，在构造函数中直接调用虚函数的话，是没有多态的特性，但是如果我们写一个函数，这个函数再去调用虚函数，这个时候生成的汇编代码，会根据虚表找函数地址，就有了多态的特性。有兴趣的同学可以自己反汇编验证下。</p><h2>4.vptr和vftable的初始化问题</h2><h3>4.1 vptr什么时候初始化？</h3><p>1.对象初始化时</p><p>2.拷贝构造调用</p><p>我们从汇编的角度看，在对象初始化时如何设置vftable的地址。</p><p>在vs2013 在调试状态下，右键转到反汇编就可以看到汇编代码</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// c++代码\n</span><span class=\"c1\"></span><span class=\"n\">MultiDerive</span> <span class=\"n\">multiderive</span><span class=\"p\">;</span>\n</code></pre></div><p>这下面三个都是汇编代码</p><div class=\"highlight\"><pre><code class=\"language-ca65\">; MultiDerive multiderive;\n; multiderive的地址放到ecx寄存器中\n00FC9CD8  lea           ecx,[multiderive]\n; 调用MultiDerive构造函数\n00FC9CDB  call          virtual_fun_table::MultiDerive::MultiDerive (0FC12BCh) \n; 跳转到 virtual_fun_table::MultiDerive::MultiDerive:\n00FC12BC  jmp         virtual_fun_table::MultiDerive::MultiDerive (0FC4180h) </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">; 跳转到 virtual_fun_table::MultiDerive::MultiDerive:\n00FC12BC  jmp         virtual_fun_table::MultiDerive::MultiDerive (0FC4180h) </code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">00FC4180  push        ebp  \n00FC4181  mov        ebp,esp  \n00FC4183  sub         esp,0CCh  \n00FC4189  push        ebx  \n00FC418A  push        esi  \n00FC418B  push        edi  \n00FC418C  push        ecx  \n00FC418D  lea          edi,[ebp-0CCh]  \n00FC4193  mov         ecx,33h  \n00FC4198  mov         eax,0CCCCCCCCh  \n00FC419D  rep stos    dword ptr es:[edi]  ; 从00FC4180~00FC419D都是做函数调用过程初始化准备\n00FC419F  pop         ecx                       ; 拿到this指针\n00FC41A0  mov        dword ptr [this],ecx  \n00FC41A3  mov        ecx,dword ptr [this]  \n00FC41A6  call         virtual_fun_table::BaseOne::BaseOne (0FC1235h)  ; 调用BaseOne的构造函数\n00FC41AB  mov        ecx,dword ptr [this]  \n00FC41AE  add         ecx,8                 ; 调整this指针偏移，并将this指针传递给调用Base构造函数\n00FC41B1  call          virtual_fun_table::Base::Base (0FC15D2h)  \n00FC41B6  mov         eax,dword ptr [this]  \n00FC41B9  mov         dword ptr [eax],0FD1B54h  ; 将vftable的地址设置到第一个vptr中\n00FC41BF  mov         eax,dword ptr [this]              \n00FC41C2  mov         dword ptr [eax+8],0FD1B6Ch ;跳过8字节，设置第二个虚表地址放到第二个vptr中\n00FC41C9  mov         eax,dword ptr [this]  \n00FC41CC  mov         dword ptr [eax+10h],0  \n00FC41D3  mov         eax,dword ptr [this]  \n00FC41D6  pop         edi  \n00FC41D7  pop         esi  \n00FC41D8  pop         ebx  \n00FC41D9  add         esp,0CCh  \n00FC41DF  cmp         ebp,esp  \n00FC41E1  call          __RTC_CheckEsp (0FC1488h)  \n00FC41E6  mov         esp,ebp  \n00FC41E8  pop          ebp  \n00FC41E9  ret  </code></pre></div><p>关于这里的汇编代码做下说明：</p><p>1.c++中类成员的函数调用叫做thiscall方式，就是this指针通过ecx寄存器来传递的。</p><p>2.注意看下旁边的注释行文字</p><p>3.代码中红色加粗的两个地址<b>0FD1B54h</b>，<b>0FD1B6Ch</b>就是关键的vftable地址</p><p>4.这里我只带领大家看了构造函数的，那么拷贝构造原理是一样的大家可以自己尝试。</p><p>如果大家的汇编看不懂，就看看下面的这张调用图便于大家的理解：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-530a198f0e59ed1ff886c186b9837236_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-530a198f0e59ed1ff886c186b9837236_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;382&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"382\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-530a198f0e59ed1ff886c186b9837236_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-530a198f0e59ed1ff886c186b9837236_b.jpg\"/></figure><h3>4.2 vftable里面的内容什么时候初始化？</h3><p>这个编译器在编译期间就已经初始化好了，为每个类确定好了虚表里面对应的内容。</p><h2>5.到底是怎么实现多态特性</h2><p>前面，我们详细介绍了虚函数的实现细节，但是子类为什么以父类引用或指针的身份出现就会有多态的特性，总感觉还有一层窗户纸没有捅破。</p><p>上代码，我们看下面的这段代码</p><div class=\"highlight\"><pre><code class=\"language-text\">;  MultiDerive multiderive;  c++代码\n01289FC8  lea         ecx,[multiderive]  \n01289FCB  call        virtual_fun_table::MultiDerive::MultiDerive (012812BCh)  \n ;   multiderive.m(); c++代码\n ; 注意看这里以普通的身份调用虚函数，就两行汇编代码，直接调用传递this指针\n01289FD0  lea         ecx,[multiderive]  \n01289FD3  call        virtual_fun_table::MultiDerive::m (012812F8h)  \n\n; MultiDerive *multiderive2 = new MultiDerive(); c++代码\n; 这里从0x01289FD8~到0x0128A014主要是进行了申请堆内存\n; 申请成功了调用构造函数，申请失败跳过构造函数\n01289FD8  push        14h  \n01289FDA  call         operator new (01281587h)  \n01289FDF  add         esp,4  \n01289FE2  mov         dword ptr [ebp-13Ch],eax  \n01289FE8  cmp         dword ptr [ebp-13Ch],0  \n01289FEF  je            virtual_fun_table::test_multi_inhert_virtual_fun+64h (0128A004h)  \n01289FF1  mov         ecx,dword ptr [ebp-13Ch]  \n01289FF7  call          virtual_fun_table::MultiDerive::MultiDerive (012812BCh)  \n01289FFC  mov         dword ptr [ebp-144h],eax  \n0128A002  jmp         virtual_fun_table::test_multi_inhert_virtual_fun+6Eh (0128A00Eh)  \n0128A004  mov         dword ptr [ebp-144h],0  \n0128A00E  mov         eax,dword ptr [ebp-144h]  \n0128A014  mov         dword ptr [multiderive2],eax  \n; multiderive2-&gt;m(); c++代码\n; 这里是我们需要看的重点内容\n; 将multiderive2的首地址，放到eax寄存器\n0128A017  mov         eax,dword ptr [multiderive2]  \n; eax就是我们之前说的vptr，对vptr解引用获取到vftable地址放到edx\n0128A01A  mov         edx,dword ptr [eax]  \n0128A01C  mov         esi,esp  \n; thiscall方式调用，通过ecx传递this指针地址\n0128A01E  mov          ecx,dword ptr [multiderive2]  \n; edx里面存放了vftable的地址+偏移地址\n; 还原成高级语言就是数组取值 eax = vftable[0CH]，每个函数指针是4个字节，4*3=12byte\n; eax中就是存放了虚函数m的地址\n0128A021  mov         eax,dword ptr [edx+0Ch]  \n0128A024  call          eax  \n0128A026  cmp         esi,esp  \n0128A028  call          __RTC_CheckEsp (01281488h)  </code></pre></div><p>我们简化下来对比下代码</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0d203af10752311b3686213b016e9c45_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"836\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb\" width=\"836\" data-original=\"https://pic2.zhimg.com/v2-0d203af10752311b3686213b016e9c45_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;836&#39; height=&#39;299&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"836\" data-rawheight=\"299\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"836\" data-original=\"https://pic2.zhimg.com/v2-0d203af10752311b3686213b016e9c45_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0d203af10752311b3686213b016e9c45_b.jpg\"/></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d46b059accf5890b9382c7244df0ba29_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-d46b059accf5890b9382c7244df0ba29_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;323&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"323\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-d46b059accf5890b9382c7244df0ba29_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d46b059accf5890b9382c7244df0ba29_b.jpg\"/></figure><h2>6.纯虚函数理解</h2><h3>6.1 含义：</h3><p>如果我们在虚函数原型的后面加上=0（virtual void func()= 0），同时这个函数是没有实现的。</p><h3>6.2作用</h3><p>有纯虚函数的类表示这是一个抽象类，既然是抽象的，那么肯定就是不能实例化。关于抽象类不能实例化可以从逻辑上理解也是合理的，比如说：动物，老虎，狮子，人都是动物。但是你说动物没人能理解你说的动物到底指的是什么东西。</p><p>由纯虚函数的引出了抽象类，抽象类的出现是为了解决什么问题？</p><p>抽象类就是为了被继承的，它为子类实例化提供蓝图。在相关的组织继承层次中，它来提供一个公共的根。其他相关子类都是这里衍生出来。</p><p>它与接口的区别是什么？</p><p>接口是对动作的抽象，抽象类是对根源的抽象。比如说人，有五官，有其他属性。但是吃这个动作应该定义为接口更合适。因为其他动物也有吃的动作。</p><h3>6.3 从汇编角度看纯虚函数特别之处</h3><p>1.间接的查看AbstractBase虚表内容</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// #define test_call_abstract_virtual_fun 1\n</span><span class=\"c1\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">AbstractBase</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"cp\">#ifdef test_call_abstract_virtual_fun\n</span><span class=\"cp\"></span><span class=\"n\">AbstractBase</span><span class=\"p\">()</span>      <span class=\"p\">{</span> <span class=\"n\">CallAbsFunc</span><span class=\"p\">();</span> <span class=\"p\">}</span>\n<span class=\"kt\">void</span> <span class=\"n\">CallAbsFunc</span><span class=\"p\">()</span>  <span class=\"p\">{</span> <span class=\"n\">AbsFunc</span><span class=\"p\">();</span> <span class=\"p\">}</span>\n<span class=\"cp\">#else\n</span><span class=\"cp\"></span>    <span class=\"n\">AbstractBase</span><span class=\"p\">()</span>      <span class=\"p\">{</span> <span class=\"p\">}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// test_call_abstract_virtual_fun\n</span><span class=\"c1\"></span>    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"n\">AbsFunc</span><span class=\"p\">()</span>  <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">virtual</span> <span class=\"kt\">void</span> <span class=\"nf\">AbsFunc2</span><span class=\"p\">()</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">AbstractBase</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Child</span><span class=\"p\">()</span>         <span class=\"p\">{</span> <span class=\"n\">AbsFunc</span><span class=\"p\">();</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">AbsFunc</span><span class=\"p\">()</span>  <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n    <span class=\"kt\">void</span> <span class=\"n\">AbsFunc2</span><span class=\"p\">()</span> <span class=\"p\">{</span> <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;&#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span> <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n<span class=\"kt\">void</span> <span class=\"nf\">test_abstract_virtual_fun</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// 因为抽象类不能直接实例化，通过子类实例化，反汇编找到AbstractBase找到构造函数\n</span><span class=\"c1\"></span>    <span class=\"n\">AbstractBase</span> <span class=\"o\">*</span><span class=\"n\">child</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Child</span><span class=\"p\">();</span>\n    <span class=\"n\">child</span><span class=\"o\">-&gt;</span><span class=\"n\">AbsFunc</span><span class=\"p\">();</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在24行代码处下断点--》启动vs--》右键菜单--》反汇编--》快捷键F11单步调试。</p><p>反汇编的代码比较多，我就挑出重点的代码画图解释下：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-1e6565c31f67b3e39a0b300af006bda1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-1e6565c31f67b3e39a0b300af006bda1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;374&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"374\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-1e6565c31f67b3e39a0b300af006bda1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-1e6565c31f67b3e39a0b300af006bda1_b.jpg\"/></figure><p>在反汇编的时候，我们拿到了虚表的地址<b>0x0F82D98</b>，我们把这个地址放到vs2013中的内存窗口中。根据我们前面的学到的知识，就知道AbstractBase应该有两个虚函数，那么表中应该有两个函数指针，如下图所示。但是你会惊讶的发现表中的两个函数指针都是<b>0x00f714ab</b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-2c56bb0b250242e7d5ad0c6cd986fec6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"100\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-2c56bb0b250242e7d5ad0c6cd986fec6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;100&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"100\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-2c56bb0b250242e7d5ad0c6cd986fec6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-2c56bb0b250242e7d5ad0c6cd986fec6_b.jpg\"/></figure><p>2.纯虚类虚表中不仅有内容还是一样的？</p><p>现在我们很好奇，为什么虚表中的内容的是一样的。还有纯虚类的虚函数都没有任何的实现的，为什么虚表中还有内容。还有这个地址到底是个什么？干啥的？</p><p>那我就在想，如果我可以拿到这个地址直接转成函数指针，通过函数指针调用就可以了。</p><p>1.方案一：在纯虚父类构造函数中，直接调用纯虚函数，编译失败<b>error LNK2019: 无法解析的外部符号</b>（因为纯虚函数没有实现，直接调用没有任何意义）。方案否决。</p><p>2.方案二：尝试拿到纯虚父类的vftable地址，但是发现纯虚父类不能实例化。方案否决。</p><p>3.方案三：尝试在子类构造函数，拿到this指针的，在根据this指针拿到虚表地址。反汇编的代码看编译器的代码先于我的代码执行，就是说等到了执行我的代码时候，这个this指针已经不是纯虚父类的vftable，而是子类的vftable了。</p><p>貌似进入死胡同，没有方案了。</p><p>问题回到刚开始时候，我现在是怎么拿到纯虚父类的vftable。我是实例化了子类，然后反汇编F11一步步跟过去的。就是说我是间接的通过子类去获取纯虚父类的vftable，等等，是不是有思路了。</p><p>4.方案四：在纯虚父类中写一个普通的函数，在构造函数à调用普通的函数à调用纯虚函数</p><p>在上面的代码将宏放开#define test_call_abstract_virtual_fun 1，编译通过ok，接下来可以愉快的玩耍了。</p><p>代码整理好，反汇编走起来。我把重要的调用过程画图表示出来，便于理解。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-4f5a296c83315d03a3f9edb96668257f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb\" width=\"544\" data-original=\"https://pic4.zhimg.com/v2-4f5a296c83315d03a3f9edb96668257f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;544&#39; height=&#39;502&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"544\" data-rawheight=\"502\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"544\" data-original=\"https://pic4.zhimg.com/v2-4f5a296c83315d03a3f9edb96668257f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-4f5a296c83315d03a3f9edb96668257f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从纯虚函数的调用过程来看，调用纯虚函数--》__purecall--》call 0FE51470(19h)--》抛出异常</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-99f2951df4622210811b392d3b3fde99_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"304\" data-rawheight=\"198\" class=\"content_image\" width=\"304\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;304&#39; height=&#39;198&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"304\" data-rawheight=\"198\" class=\"content_image lazy\" width=\"304\" data-actualsrc=\"https://pic2.zhimg.com/v2-99f2951df4622210811b392d3b3fde99_b.jpg\"/></figure><p>现在我们大概的猜一猜上面提出的疑问了：</p><p>1.纯虚函数的确是没有实现的，而虚表的内容时编译器塞进去的。</p><p>2.纯虚函数本来就是不能让我们调用的，我们现在通过某种手段绕过编译器了。如果我们直接调用纯虚函数，编译器能够检查出来，会报错<b>error LNK2019: 无法解析的外部符号</b>。而如果我们间接的调用了纯虚函数，编译器也无能为力，但是编译器还是道高一尺，它知道自己可能在编译期间解析不出来，所以编译器就在虚表中插入__purecall函数，你有几个虚函数我就插入几个__purecall函数，当你在运行时调用，我就让你调用__purecall抛出异常。让你不能调用你就是不能调用，强行调用我就给你shutdown。现在能够解释为什么虚表的内容是一样的。</p><h2>7.虚函数的缺点</h2><p>天使与魔鬼是并存的，虚函数在带来超强的多态特性，但是不可避免的带来了其他缺点。</p><p>1.间接寻址造成的效率慢，在怎么实现多态特性上汇编角度可以看出来，引入时间复杂度。</p><p>2.继承关系带来的强耦合关系，父类动子类可能地动山摇，对象关系复杂度上升。</p><p>3.体积的增加，尤其是多继承时体现的更明显，引入额外的空间复杂。</p><p>但是在软件开发的角度看大大降低软件的开发周期和维护成本，总的来说瑕不掩瑜。与带来的多态特性相比，我觉得还是值得。</p><h3>8.虚函数的外延探索</h3><p>1.在多态中，我们通过对象--》虚表指针--》虚表--》虚函数，最终找到我们想要的函数。简化的看对象--》（中间操作）--》虚函数，对象经过中间的一系列操作得到虚函数。这种思路称为间接思维，当我们想要某种东西的时候，可能没法直接获取或者是直接获取的成本太高，但是通过间接轻松的获取。这种思路随处可见，比如：我要吃饭要通过钱去等价交换，我去公司上班通过地铁过去，计算机中的缓存作用。</p><p>2.关于实现多态的特性，网上还有利用模板的编译期多态的特性，有兴趣同学可以搜一下。</p><p>3.设计模式的里面的套路，就是基于的虚函数多态的特性。</p><h3>9.扩展资料</h3><p>《C++深入理解对象模型》</p><p>《C++反汇编与逆向分析》</p><h2>10.总结</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-b42d05b93de7f7c73ffec751ac7fe904_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-b42d05b93de7f7c73ffec751ac7fe904_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;391&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"391\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-b42d05b93de7f7c73ffec751ac7fe904_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b42d05b93de7f7c73ffec751ac7fe904_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p> 公布答案：</p><p>1.虚函数指针和虚表在哪里？探索虚表的位置</p><p>2.我们如何手动调用虚函数？探索虚表的位置</p><p>3.为什么只有在子类以父类的引用或者指针的形式才能出现多态？实现多态特性</p><p>4.虚函数的调用为什么效率相比普通的成员函数较低？又具体低了多少？实现多态特性</p><p>5.为什么构造函数和析构函数尽量不要调用虚函数？析构函数使用函数指针间接调用</p><p>6.纯虚函数到底是什么？为什么禁止我调用？有什么办法可以绕编译器？纯虚函数理解</p><p>7.看码说话，第一种调用直接调用正常，第二种间接调用直接崩溃 实现多态特性</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }, 
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }
            ], 
            "comments": [
                {
                    "userName": "紫川秀", 
                    "userLink": "https://www.zhihu.com/people/478aed7ac2b14345cce38f5f00a60f95", 
                    "content": "文章写的很好，非常透彻，我提一个小问题啊，为什么多态那个例子中，还是以子类的指针方式去调用函数啊，这不算多态吧。", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "你好，能指出详细的位置？", 
                            "likes": 0, 
                            "replyToAuthor": "紫川秀"
                        }
                    ]
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "说一点吧   虚指针的内存布局 每个编译器都是不同的。还是说明白的好", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "首先谢谢你的提醒，你说的完全正确，关于对象的内存布局，每个编译器都有自己的实现。所以这篇文章开头就限定了讨论的范围在Windows vs2013的环境下。", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }, 
                {
                    "userName": "Sinaean Dean", 
                    "userLink": "https://www.zhihu.com/people/9a732559bf9621e808d38026bbda71a6", 
                    "content": "虚函数以对象指针或引用的方式调用开销很大，如果我这里不需要多态的情况下，我可不可以先解引用，然后以对象的方式调用", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "首先你得做法就已经去掉虚函数的最大的优势。其次关于开销很大，到底都多大，我想这个开销与你后期维护代码的开销比起来其实不算什么。再次如果你不想调用子类虚函数有两种方式，第一种不要让子类已父类的方式出现，第二种父类可以指定调用自己的函数，这两种都是直接调用不走虚表。", 
                            "likes": 0, 
                            "replyToAuthor": "Sinaean Dean"
                        }, 
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "对了，你的方式也是可以的。", 
                            "likes": 0, 
                            "replyToAuthor": "Sinaean Dean"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/81125804", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 1, 
            "title": "C++幕后故事（三）--程序语义转化", 
            "content": "<h2>先来看两段代码执行效率是一样？</h2><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">//oa的一系列操作...\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"nf\">GetOpt</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n    <span class=\"c1\">//oa的一系列操作...\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">GetOpt</span><span class=\"p\">(</span><span class=\"n\">OptimizationA</span> <span class=\"o\">&amp;</span><span class=\"n\">_result</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"c1\">// result的一系列操作...\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>思考：效率是一样的？如果是不一样的，那么又是如何不一样的？那我们如何做效率更好呢？</p><h2>程序语义的转化</h2><p>我们自己写的代码，自己看一回事，但是在编译器的角度来看又是一番风景。所以这次我们换个角度来看待问题，分别从初始化操作、优化、成员列表初始化三个方面探究下编译器会怎么翻译我们的代码。</p><h2>1.初始化操作</h2><h3>A.显式初始化操作</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">OptimizationA</span> <span class=\"n\">oe</span><span class=\"p\">;</span>\n<span class=\"n\">OptimizationA</span> <span class=\"nf\">of</span><span class=\"p\">(</span><span class=\"n\">oe</span><span class=\"p\">);</span>\n<span class=\"n\">OptimizationA</span> <span class=\"n\">og</span> <span class=\"o\">=</span> <span class=\"n\">oe</span><span class=\"p\">;</span>\n<span class=\"n\">OptimizationA</span> <span class=\"n\">oh</span> <span class=\"o\">=</span> <span class=\"n\">OptimizationA</span><span class=\"p\">(</span><span class=\"n\">oe</span><span class=\"p\">);</span>\n<span class=\"c1\">// 编译器的角度看，分成两步走，\n</span><span class=\"c1\">// 第一步：定义变量（不会调用初始化操作），第二步：调用拷贝构造\n</span><span class=\"c1\">// 1.OptimizationA of (注意此时不会调用OptimizationA的默认构造函数)\n</span><span class=\"c1\">// 2.of.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)\n</span><span class=\"c1\">// 3.og.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)\n</span><span class=\"c1\">// 4.oh.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)\n</span></code></pre></div><h3>B.参数初始化</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"kt\">void</span> <span class=\"nf\">Parameter</span><span class=\"p\">(</span><span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n<span class=\"p\">}</span>\n\n<span class=\"p\">{</span>\n<span class=\"n\">OptimizationA</span> <span class=\"n\">tempoa</span><span class=\"p\">;</span>\n<span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">tempoa</span><span class=\"p\">);</span>\n<span class=\"p\">}</span> \n\n<span class=\"c1\">// 编译器生成的代码\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"n\">_tempObj</span><span class=\"p\">;</span>\n<span class=\"c1\">// tempObj调用copy构造\n</span><span class=\"c1\"></span><span class=\"n\">tempObj</span><span class=\"p\">.</span><span class=\"n\">OptimizationA</span><span class=\"o\">::</span><span class=\"n\">OptimizationA</span><span class=\"p\">(</span><span class=\"n\">tempoa</span><span class=\"p\">);</span>\n<span class=\"n\">Parameter</span><span class=\"p\">(</span><span class=\"n\">tempObj</span><span class=\"p\">);</span>\n<span class=\"c1\">// tempObj调用析构函数，销毁对象\n</span><span class=\"c1\"></span><span class=\"n\">tempObj</span><span class=\"p\">.</span><span class=\"n\">OptimizationA</span><span class=\"o\">::~</span><span class=\"n\">OptimizationA</span><span class=\"p\">();</span>\n</code></pre></div><h3>C.返回值初始化</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"n\">OptimizationA</span> <span class=\"nf\">GetOpt</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 此为编译器的生成的函数，分为两步操作\n</span><span class=\"c1\">// 第一步：将上面的函数重写为下面的带引用参数的形式\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">GetOpt</span><span class=\"p\">(</span><span class=\"n\">OptimizationA</span> <span class=\"o\">&amp;</span><span class=\"n\">_result</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n    <span class=\"c1\">//oa的一系列操作。。。。。。\n</span><span class=\"c1\">// 第二步：在return返回之前，调用result的copy 构造函数\n</span><span class=\"c1\"></span>    <span class=\"n\">result</span><span class=\"o\">::</span><span class=\"n\">OptimizationA</span><span class=\"o\">::</span><span class=\"n\">OptimizationA</span><span class=\"p\">(</span><span class=\"n\">oa</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 下面是编译器生成的调用代码\n</span><span class=\"c1\">// 1.形式转换成这样\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"n\">result</span><span class=\"p\">;</span>\n<span class=\"n\">GetOpt</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">);</span>\n\n<span class=\"c1\">// 2.如果用户调用了类成员函数\n</span><span class=\"c1\"></span><span class=\"n\">GetOpt</span><span class=\"p\">().</span><span class=\"n\">GetHello</span><span class=\"p\">();</span>\n<span class=\"c1\">// 编译器则转换成这样\n</span><span class=\"c1\"></span><span class=\"p\">(</span><span class=\"n\">GetOpt</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">),</span> <span class=\"n\">result</span><span class=\"p\">).</span><span class=\"n\">GetHello</span><span class=\"p\">();</span>\n\n<span class=\"c1\">// 3.如果是用户定义了函数指针\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pf</span><span class=\"p\">)();</span>\n<span class=\"n\">pf</span> <span class=\"o\">=</span> <span class=\"n\">GetOpt</span><span class=\"p\">;</span> <span class=\"c1\">// 没有参数\n</span><span class=\"c1\">// 编译器则转换成这样\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">pf</span><span class=\"p\">)(</span><span class=\"n\">OptimizationA</span> <span class=\"o\">&amp;</span><span class=\"p\">);</span>\n<span class=\"p\">(</span><span class=\"n\">pf</span><span class=\"p\">(</span><span class=\"n\">result</span><span class=\"p\">),</span> <span class=\"n\">result</span><span class=\"p\">).</span><span class=\"n\">GetHello</span><span class=\"p\">();</span>\n</code></pre></div><h2>2.优化</h2><h3>A.用户层面优化</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 程序员的未优化\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"nf\">GetOpt</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">T</span> <span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">T</span> <span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">);</span>\n    <span class=\"c1\">// oa其他操作\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 在linux上测试需要关闭优化选项\n</span><span class=\"c1\">// 先是生成了一个临时对象tempobj，然后调用tempobj的拷贝构造函数，将oa的数据拷贝到\n</span><span class=\"c1\">// tempobj中，然后在调用oa的析构函数。\n</span><span class=\"c1\">// 这个过程中消耗了一个tempobj的拷贝构造和析构函数\n</span><span class=\"c1\"></span>\n<span class=\"c1\">// 程序员优化，这样做就少了一个临时对象的生成和销毁\n</span><span class=\"c1\">// 熟悉的同学可能就知道这里运用到了RVO优化\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"nf\">GetOpt</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">T</span> <span class=\"o\">&amp;</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"k\">const</span> <span class=\"n\">T</span> <span class=\"o\">&amp;</span><span class=\"n\">y</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"n\">OptimizationA</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-9d5fdc768a60e6359eb0f77de63c6537_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"987\" data-rawheight=\"623\" class=\"origin_image zh-lightbox-thumb\" width=\"987\" data-original=\"https://pic4.zhimg.com/v2-9d5fdc768a60e6359eb0f77de63c6537_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;987&#39; height=&#39;623&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"987\" data-rawheight=\"623\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"987\" data-original=\"https://pic4.zhimg.com/v2-9d5fdc768a60e6359eb0f77de63c6537_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-9d5fdc768a60e6359eb0f77de63c6537_b.jpg\"/></figure><h3>B.编译器优化</h3><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 程序员写的代码\n</span><span class=\"c1\"></span><span class=\"n\">OptimizationA</span> <span class=\"nf\">GetOpt</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"c1\">// 编译器生成的代码：（named return value (NRV)）\n</span><span class=\"c1\">// 分为两步操作\n</span><span class=\"c1\">// 第一步：将上面的函数重写为下面的带引用参数的形式\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">GetOpt</span><span class=\"p\">(</span><span class=\"n\">OptimizationA</span> <span class=\"o\">&amp;</span><span class=\"n\">_result</span><span class=\"p\">)</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">OptimizationA</span> <span class=\"n\">oa</span><span class=\"p\">;</span>\n    <span class=\"c1\">//oa的一系列操作...\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 第二步：在return返回之前，调用__result的copy 构造函数\n</span><span class=\"c1\"></span>    <span class=\"n\">__result</span><span class=\"o\">::</span><span class=\"n\">OptimizationA</span><span class=\"o\">::</span><span class=\"n\">OptimizationA</span><span class=\"p\">(</span><span class=\"n\">oa</span><span class=\"p\">);</span>\n\n    <span class=\"k\">return</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><h2>3.成员列表初始化</h2><p>先来看段代码：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">InitialzationB</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"c1\">//  InitialzationB()\n</span><span class=\"c1\">//  {}\n</span><span class=\"c1\"></span>\n    <span class=\"n\">InitialzationB</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"p\">)</span><span class=\"o\">:</span>  <span class=\"n\">m_IA</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">),</span> <span class=\"n\">m_a</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">),</span> <span class=\"n\">m_b</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n        <span class=\"cm\">/*\n</span><span class=\"cm\">            放在初始化列中……\n</span><span class=\"cm\">            1.如果是在成员列表初始化，站在编译器的角度看\n</span><span class=\"cm\">            m_IA.InitialzationA::InitialzationA(value)\n</span><span class=\"cm\">        */</span>\n    <span class=\"p\">{</span>\n        <span class=\"cm\">/*\n</span><span class=\"cm\">            放在构造函数中…..\n</span><span class=\"cm\">            m_IA = value;\n</span><span class=\"cm\">            2.如果是在函数内部初始化，站在编译器的角度看\n</span><span class=\"cm\">            A.先是生成一个临时对象\n</span><span class=\"cm\">            InitialzationA oc;\n</span><span class=\"cm\">            oc.InitialzationA::InitialzationA(value);\n</span><span class=\"cm\">            B.在m_IA的copy ctor\n</span><span class=\"cm\">            m_IA.InitialzationA::InitialzationA(oc);    \n</span><span class=\"cm\">            C.临时对象再去销毁\n</span><span class=\"cm\">            oc.InitialzationA::~InitialzationA();\n</span><span class=\"cm\">            所以成员变量初始化会提高效率，但只针对类类型变量，对基本类型无影响。\n</span><span class=\"cm\">            在初始化列表中，不要用类成员变量去初始化另外一个成员变量\n</span><span class=\"cm\">        */</span>\n    <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"n\">InitialzationA</span> <span class=\"n\">m_IA</span><span class=\"p\">;</span> <span class=\"c1\">// 自定义class\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>A.成员列表初始化含义</h3><p>InitialzationB<b>(</b>int value<b>):</b> m_IA<b>(</b>value<b>),</b> m_a<b>(</b>value<b>),</b> m_b<b>(</b>value<b>)</b></p><p><b>这就是初始化列表的调用方法</b></p><h3>B.为什么需要初始化列表，以及初始化列表调用时机</h3><p>简单来说为了初始化对象时的效率。看上面的代码第7行放在初始化列中，从编译器的角度看就是直接调用了InitialzationA的构造函数。但是你如果放在16行，那么在编译器的角度看就是先生成了一个InitialzationA临时对象，在调用m_IA的copy构造函数，然后临时对象的消亡调用析构函数。所以大费周章的构造对象造成效率的下降。</p><p>调用时机：编译器会在构造函数之前会插入一段额外的代码，这就是initialization list。然后在执行用户写的代码。</p><h3>C.注意事项</h3><h3>1.有四种情况必须放到初始化列表中</h3><p>1. 成员变量是个引用</p><p>2. 成员变量是const类型</p><p>3. 成员变量是带参数的构造函数类类型</p><p>4. 基类有带参数的构造函数</p><h3>2.初始化列表的初始化顺序</h3><p>初始化顺序是按照在类中的声明顺序的来决定。所以在类的初始化列表中还是严格按照类中声明的顺序来复制。</p><p>比如：</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">InitialzationB</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n<span class=\"c1\">//  InitialzationB()\n</span><span class=\"c1\">//  {}\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// InitialzationB(int value):  m_IA(value) , m_b(value), m_a(m_b)\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 正宗做法\n</span><span class=\"c1\"></span>    <span class=\"n\">InitialzationB</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"p\">)</span><span class=\"o\">:</span> <span class=\"n\">m_IA</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">),</span> <span class=\"n\">m_a</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">),</span> <span class=\"n\">m_b</span><span class=\"p\">(</span><span class=\"n\">value</span><span class=\"p\">)</span>\n    <span class=\"p\">{</span>\n    <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"n\">InitialzationA</span> <span class=\"n\">m_IA</span><span class=\"p\">;</span> \n<span class=\"kt\">int</span> <span class=\"n\">m_b</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><h3>3.在初始化列表中调用成员函数</h3><p>不要在初始化列表中调用成员函数，因为你不知道这个函数以后会多么的依赖当前的对象。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-38083cfbb9148b6ce632a61ce667ca5a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-38083cfbb9148b6ce632a61ce667ca5a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;126&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"126\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-38083cfbb9148b6ce632a61ce667ca5a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-38083cfbb9148b6ce632a61ce667ca5a_b.jpg\"/></figure><h2>总结：</h2><p>现在我们开始回答上面提出的问题，第一个方法至少消耗了一个ctor，copy ctor, dtor，同时还要考虑编译器的实现，中间可能还会temp object的生成，又会增加一个copy ctor,dtor。反过来再看方法二只消耗了ctor，dtor。效率肯定比方法一高。</p><p>知道了编译器做了什么，和怎么做的。这将有助于对C++语言背后的实现细节更了若指掌，才能写出高效的程序。同时也看出来c++为了追求效率，背后做了很多我们不知道的事情。最后假如我们是编译器，我们会如何生成代码的？这是值得我们思考的地方。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++11", 
                    "tagLink": "https://api.zhihu.com/topics/19726035"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>这篇文章没有考虑有 RVO 还有移动语义等因素存在时的情形。譬如如果 getopt 函数满足触发 RVO 的条件，那么方法二的效率反过来还不如方法一。所以这篇文章得出的结论未免有些偏颇。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "Ha Yoo", 
                            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
                            "content": "<p>1.首先感谢你提出的问题。2.关于RVO这个在文章确实未提出，但是用户层面优化中第二段代码程序员的优化，这个其实就是RVO的优化，不过还是谢谢你的提醒。3.关于std::move是我自己偷了懒，没有提及到，因为我猜测原理可能是一样的（允许我为自己找个接口）。4.最后非常感谢你的提醒。</p>", 
                            "likes": 1, 
                            "replyToAuthor": "知乎用户"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80995818", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 5, 
            "title": "C++幕后故事（二）--合成构造函数时机", 
            "content": "<h3>1.先考虑一个问题为什么c++中有构造函数？</h3><p>这个可以从语言设计的角度来看这个问题。体现一个实例化的对象生命周期的完整性，一个对象在初始化的时候，让使用者有机会做些额外的初始化操作。同样，一个对象是消亡的时候，也要使用者有机会去释放资源。举个例子：吃饭前先洗手（构造函数），吃完饭在擦嘴（析构函数），这是个好习惯。但是你不洗手，不擦嘴，也没关系，只是这不是个好习惯而已（偶尔造成细菌感染，程序异常）。</p><h3>2.编译器何时合成缺省构造函数？</h3><p>好习惯的养成是一个持续的过程，所以有时候编译器会偷偷的帮你洗手擦嘴。</p><p>A. 间接的含有构造函数，比如类成员变量含有构造函数，或者是继承的父类有构造函数。</p><p>B. 直接或者间接的含有virtual function，比如自己含有virtual function或者是类成员变量，或者是继承的父类含有。</p><p>C. 出现虚继承的现象。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-952911ce3ba5f2ef11b95769b80f43a6_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-952911ce3ba5f2ef11b95769b80f43a6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;102&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"102\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-952911ce3ba5f2ef11b95769b80f43a6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-952911ce3ba5f2ef11b95769b80f43a6_b.jpg\"/></figure><h2>3.那么构造函数的兄弟拷贝构造？</h2><p>拷贝构造和缺省的构造也是同样的A,B,C情况下，编译器会合成默认的拷贝构造。当然编译器生成的拷贝构造就是浅拷贝。</p><h2>4.那么析构函数呢？</h2><p>编译器不关心你有没有写析构函数，编译器都会主动生成析构函数。在析构的时候，编译会首先调用你写的析构函数，然后在调用编译器的析构函数，这个过程对于程序员来说是透明的。从反汇编的角度看，编译器会生成一个析构函数，但是这个析构函数没有实质作用，也没有生成汇编代码</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"c1\">// 没有析构函数的类\n</span><span class=\"c1\"></span><span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">NoDctorClass</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_a</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"c1\">// 测试编译器合成析构函数\n</span><span class=\"c1\"></span><span class=\"kt\">void</span> <span class=\"nf\">test_compiler_geneator_def_dctor</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">NoDctorClass</span> <span class=\"n\">no_dctor_class</span><span class=\"p\">;</span>\n    <span class=\"c1\">// 调用析构函数\n</span><span class=\"c1\"></span>    <span class=\"n\">no_dctor_class</span><span class=\"p\">.</span><span class=\"o\">~</span><span class=\"n\">NoDctorClass</span><span class=\"p\">();</span>\n    <span class=\"n\">no_dctor_class</span><span class=\"p\">.</span><span class=\"n\">m_a</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n<span class=\"c1\">// 转到反汇编的代码\n</span><span class=\"c1\">//    NoDctorClass no_dctor_class;\n</span><span class=\"c1\">//    调用析构函数，这里没有生成任何的反汇编代码\n</span><span class=\"c1\">//    no_dctor_class.~NoDctorClass();\n</span><span class=\"c1\">//    no_dctor_class.m_a = 0;\n</span><span class=\"c1\"></span><span class=\"mo\">012</span><span class=\"n\">AA9FE</span>  <span class=\"n\">mov</span>         <span class=\"n\">dword</span> <span class=\"n\">ptr</span> <span class=\"p\">[</span><span class=\"n\">no_dctor_class</span><span class=\"p\">],</span><span class=\"mi\">0</span>  \n</code></pre></div><h2>5.那么编译器为什么帮你合成（拷贝）构造函数？</h2><p>简单一句话，编译器需要插入一些额外的初始化代码，来完成一些语言特性。</p><p>A. 间接的含有缺省构造函数，这时候编译器发现你自己没有写构造函数，但是你又间接含有构造函数。编译器这时候有两种做法，一种是心想算了吧我帮你偷偷的生成一个吧，还有一种做法就是编译器报语法错，让程序员自己解决。所以编译器厂商一商量觉得还是对程序员友好一点，用第一种做法吧。反过来想，如果一门开发语言对程序员不友好，可以说是它的生存期将会非常短。</p><p>B. 直接或者间接的含有virtual function，因为含有virtual function，为了支持多态的特性，那么每个实例对象都会生成指向虚函数表的指针。但是这个指针在什么时候初始化呢？自然是（拷贝）构造函数里面。但是你自己没有写，编译器只好累一点生成（拷贝）构造函数。</p><p>C. 虚继承情况，为了避免子类中含有多余的成员变量，对象在实例化的时候会生成指向虚基类表的指针。自然就会联想到在（拷贝）构造函数的时候生成，同样你自己没有写，编译器管家来替你写。</p><h2>6.如何验证编译器合成了（拷贝）构造函数？</h2><p>1.在你的菜单栏找到如下控制台</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ed98b63e511e26a7f015f43ba2b63f9b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"282\" class=\"content_image\" width=\"270\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;270&#39; height=&#39;282&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"270\" data-rawheight=\"282\" class=\"content_image lazy\" width=\"270\" data-actualsrc=\"https://pic4.zhimg.com/v2-ed98b63e511e26a7f015f43ba2b63f9b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>2.cd到编译生成目录下，找到你生成的obj文件，比如我生成main.obj。</p><p>3.执行 dumpbin.exe /all main.obj &gt;&gt; main.txt，将文件格式翻译为COFF。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ea5f67697ea684ea81b29690b223688c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"144\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-ea5f67697ea684ea81b29690b223688c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;144&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"144\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-ea5f67697ea684ea81b29690b223688c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ea5f67697ea684ea81b29690b223688c_b.jpg\"/></figure><p>4.查看main.txt 找到，如果所示找到1所对应的函数，下面的2就是编译器准备插入的代码，可以看到插入了MatrixA的构造函数。同理，可以验证其他的情况。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b9650acf02726936c05050a993c0e48e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-b9650acf02726936c05050a993c0e48e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;269&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"269\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-b9650acf02726936c05050a993c0e48e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b9650acf02726936c05050a993c0e48e_b.jpg\"/></figure><h2>7.知道编译器在何时合成构造函数那么又怎么样？</h2><p>1.知道编译器背着我们做了那些小动作，让我们可以更加了解这门语言背后实现的细节，做到胸中自有丘壑。</p><p>2.尽量不要依赖编译器的操作。</p><p>3.要站在编译器的角度去看问题。</p><h3>8.总结：</h3><p>构造函数和拷贝构造是你的左膀右臂，建议还是得要好好的利用。尽管有时候你不承认，但是编译器这个管家还是会偷偷摸摸的给你装个左膀右臂。如果说构造函数是你的左膀右臂，那么析构函数就是你的一把强有力的武器用于保护自己，在对象生命结束之后能够确保资源的正常释放。</p><h2>9.代码示例：</h2><div class=\"highlight\"><pre><code class=\"language-text\">/****************************************************************************\n**\n** Copyright (C) 2019 635672377@qq.com\n** All rights reserved.\n**\n****************************************************************************/\n\n/*\n    测试编译器在何种情况会合成默认的构造函数\n    同理可证：在何种情况下编译器会合成默认的拷贝构造函数\n*/\n\n#ifndef default_constrcuctor_h\n#define default_constrcuctor_h\n\n#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nnamespace defualt_constructor\n{\n\n// 含有缺省的构造函数成员类对象\n// #define has_default_ctor_member 1\n\n// 继承含有缺省的构造函数\n// #define has_inherit_ctor_base 1\n\n// 含有虚函数成员函数\n// #define has_virtual_function 1\n\n// 函数virtual函数的成员类对象\n// #define has_virtual_func_member 1\n\n// 父类含有虚函数\n// #define has_inherit_virtual_func_base 1\n\n// MatrixC, MatrixB 虚继承MatrixD\n// #define has_virtual_inherit_base 1\n\n// 类成员变量含有copy ctor\n// #define has_default_copy_ctor_member 1\n\n// 父类含有拷贝构造函数\n#define has_inherit_copy_ctor_base 1\n\n// 含有虚函数成员函数\n// #define has_virtual_function_copy_ctor 1\n\n// 类对象成员含有虚函数\n// #define has_virtual_function_copy_ctor_member 1\n\n// 父类函数虚函数\n// #define has_inherit_virtual_function_copy_ctor_base 1\n\n// 虚继承copy ctor\n// #define has_virtual_inherit_function_copy_ctor_base 1\n\nclass MatrixD\n{\n};\n\n#ifdef  has_virtual_inherit_base\nclass MatrixC : virtual public MatrixD\n#elif has_virtual_inherit_function_copy_ctor_base\nclass MatrixC : virtual public MatrixD\n#else\nclass MatrixC\n#endif // has_virtual_inherit_base\n{\npublic: \n#ifdef has_inherit_ctor_base\n    MatrixC() { cout &lt;&lt; &#34;MatrixC&#34; &lt;&lt; endl; }\n#elif has_inherit_copy_ctor_base\n    MatrixC() {}\n    MatrixC(const MatrixC &amp;rhs) { cout &lt;&lt; &#34;MatrixC copy ctor&#34; &lt;&lt; endl; }\n#elif has_inherit_virtual_function_copy_ctor_base\n    virtual void VirFun() {}\n#elif has_inherit_virtual_func_base\n    virtual void VirFun() {}\n#endif // has_virtual_inherit_base\n};\n\n#ifdef has_virtual_inherit_base\nclass MatrixB : virtual public MatrixD\n#elif has_virtual_inherit_function_copy_ctor_base\nclass MatrixB : virtual public MatrixD\n#else\nclass MatrixB\n#endif // has_virtual_inherit_base\n{\npublic:\n#ifdef has_default_ctor_member\n    MatrixB() { cout &lt;&lt; &#34;MatrixB&#34; &lt;&lt; endl; }\n#elif has_virtual_func_member\n    virtual void VirMatrixB() { cout &lt;&lt; &#34;virtual MatrixB&#34; &lt;&lt; endl; }\n#elif has_default_copy_ctor_member\n    MatrixB() {}\n    MatrixB(const MatrixB &amp;rhs) { cout &lt;&lt; &#34;copy ctor MatrixB&#34; &lt;&lt; endl; }\n#elif has_virtual_function_copy_ctor_member\n    virtual void VirMatrixB() { cout &lt;&lt; &#34;virtual MatrixB&#34; &lt;&lt; endl; }\n#endif // has_default_ctor_member\n\n    int m_high;\n    int m_width;\n};\n\n#ifdef has_default_ctor_member\nclass MatrixA\n#elif has_virtual_function\nclass MatrixA\n#elif has_inherit_ctor_base\nclass MatrixA : public MatrixC\n#elif has_inherit_copy_ctor_base\nclass MatrixA : public MatrixC\n#elif has_virtual_func_member\nclass MatrixA\n#elif has_virtual_inherit_base\nclass MatrixA : public MatrixB, public MatrixC\n#elif has_inherit_virtual_func_base \nclass MatrixA: public MatrixC\n#elif has_inherit_virtual_function_copy_ctor_base\nclass MatrixA : public MatrixC\n#elif has_virtual_inherit_function_copy_ctor_base\nclass MatrixA : public MatrixB, public MatrixC\n#else\nclass MatrixA\n#endif // has_default_ctor_member\n{\npublic:\n    int m_age;\n    int m_score;\n\n#ifdef has_default_ctor_member\n    MatrixB matrixB;\n#elif has_virtual_function\n    virtual void VirFunc() { cout &lt;&lt; &#34;virtual function&#34; &lt;&lt; endl; }\n#elif has_virtual_func_member\n    MatrixB matrixB;\n#elif has_default_copy_ctor_member\n    MatrixA() {}\n    MatrixB matrixB;\n#elif has_inherit_copy_ctor_base\n    MatrixA() {}\n#elif has_virtual_function_copy_ctor\n    virtual void VirFunc() { cout &lt;&lt; &#34;virtual function&#34; &lt;&lt; endl; }\n#elif has_virtual_function_copy_ctor_member\n    MatrixB matrixB;\n#endif // has_default_ctor_member\n\n};\n\nvoid test_compiler_generator_def_ctor()\n{\n    //用dumpbin把.obj文件内容导出成可查看文件my.txt，\n    // 这个my.txt格式，一般被认为是COFF：通用对象文件格式(Common Object File Format);\n\n    MatrixA matrix;\n    matrix.m_age = 0;\n\n    // 编译器会在哪些情况下合成默认的构造函数？\n    // 1.包含一个类成员变量，此成员变量含有默认的缺省构造函数。此时编译器就会\n    // 生成默认的构造函数。在这个合成的构造函数中插入代码调用成员变量的构造函数\n    // 2.继承的父类含有缺省的构造函数，此时编译器也会构造默认的构造函数，在子类合成的构造\n    // 函数中插入代码，调用父类的缺省构造\n    // 3.包含虚函数。不管是子类，父类，还是包含的成员类对象（不包含任何构造函数），只要\n    // 包含了virtual function，编译器都会合成默认的构造函数\n    // 4.含有虚继承现象，grandfather, parent(虚继承grand),child再继承，\n    // 为了在构造函数中生成vbtable，虚基类表\n\n    // 同样的道理，copy constrcutor也和constructor也是在同样的情况下，编译器会合成默认\n    // 的构造函数\n\n    // A.含有默认的构造函数\n    //  1.父类有默认的构造函数\n    //  2.包含类对象的成员变量含有默认构造函数\n\n    // B.虚函数\n    //  1.不管是自己包含虚函数，还是类成员变量有虚函数，还是父类中虚函数\n\n    // C.虚继承\n    //  1.编译器为了在插入vbtable 虚基类表\n}\n\nvoid test_compiler_generator_def_copy_ctor()\n{\n    MatrixA ma;\n\n    MatrixA mb = ma;\n    // 编译器合成默认copy ctor时机和ctor是一样的\n}\n\n}\n\n#endif // default_constrctor_h</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "面向对象编程", 
                    "tagLink": "https://api.zhihu.com/topics/19569910"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/80794001", 
            "userName": "Ha Yoo", 
            "userLink": "https://www.zhihu.com/people/40ac367ab48d4581ce91102c47280135", 
            "upvote": 10, 
            "title": "C++幕后故事(一) --对象模型this指针调整", 
            "content": "<h2>1.什么叫this指针调整？</h2><p>在c++中多继承过程，根据访问不同的父类成员变量或者是成员函数，同一个实例对象会出现不同的基址（对象的地址，类似于你在不同的场合就会有身份的转换，在家的身份，在学校，在公司的等等），这种现象叫做this指针基址调整。</p><h2>2.如何调整？</h2><p>1.如果继承的顺序是A，再B，那么初始化时先A再B，内存布局如下图1所示。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2a0019233201279441825b06230adbfd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb\" width=\"907\" data-original=\"https://pic2.zhimg.com/v2-2a0019233201279441825b06230adbfd_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;907&#39; height=&#39;499&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"907\" data-rawheight=\"499\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"907\" data-original=\"https://pic2.zhimg.com/v2-2a0019233201279441825b06230adbfd_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2a0019233201279441825b06230adbfd_b.jpg\"/></figure><p>2. 如果继承的顺序还是是A，再B，那么初始化时的顺序不变，还是先A再B，但是B存在virtual function，内存布局如下图2所示。</p><p>3. 如果继承的顺序是A，再B，初始化时还是先A再B，但是A,B同时存在virtual function，内存布局还是如图1所示，没有变化。</p><h2>3.思考：</h2><p>1.那具体又是怎么调整的？</p><p>比如说，继承A，又继承B（先不考虑含有virtual fucntion情况）。为了获取B的成员变量。这是this指针需要偏移字节数为sizeof(A)。从图1上来看，要先越过A所占用的大小。</p><p>2.为什么父类中virtual function，内存布局发生了变化？</p><p>因为有了virtual function，类中就需要产生指向一个虚函数表的指针。而虚函数表指针是埋在对象的首地址中。所以B有virtual function，那么B的普通成员变量将会偏移到A的前面。</p><p>3.那么既然内存布局发生了变化，但是我们发现只要继承的顺序不变，那么构造的先后顺序就不会发生变化。说明构造的先后顺序和内存布局没有任何的关系。</p><p>4.既然我们知道了这个this指针的调整，但是有什么用呢？</p><p>A.通过指针位置的偏移不就可以访问了原来编译器层面阻止你不想访问的私有属性。</p><p>B.这种解决了多个父类下访问父类的属性的解决方案，和多态的方案是非常的相似。</p><p>假设在一个家庭中，有你和你爸、你妈。你继承了你爸你妈的所有的财产。</p><p>1.假如，你爸在家里占据中主导地位（类似于你爸包含有虚函数）。那么在你的心目中你爸就在第一位的。</p><p>2.假如，你妈在家里占据中主导地位（类似于你妈包含有虚函数）。那么在你的心目中你妈就在第一位的。</p><p>3.假如，你爸和你妈在家平分秋色（都包含虚函数或者都不包含虚函数）。那么在你的心目中你爸和你妈，你和谁离得近（继承的顺序，谁先继承），谁就在第一位的。</p><p>4.但是不管是谁在第一位，你家的户口本上你爸肯定是在第一页的（构造函数的顺序不变）。</p><p>5.假如，晚上你们一家三口在床上睡觉，你，你爸，你妈这样的顺序。但是假如你想和你妈睡在一起。你是不是要翻过你爸这座大山（类的大小），才能和你妈睡在一起。（this指针如何调整的）。</p><p>6.假如，你想要零花钱，你有两种方式，一种向你妈要，一种是向你爸要。不管是向谁要，是不是都要先找对对象，才能拿到零花钱。在多继承中子类有多个父类，所以访问某个对象的属性（成员变量，函数），则需要先找到基类的地址，为了找到正确的对象都需要进行地址偏移，这就好像你是找你爸还是找你妈要零花钱都必须先找到这个人。这就是为什么需要调整this指针。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span class=\"cm\">/****************************************************************************\n</span><span class=\"cm\">**\n</span><span class=\"cm\">** Copyright (C) 2019 635672377@qq.com\n</span><span class=\"cm\">** All rights reserved.\n</span><span class=\"cm\">**\n</span><span class=\"cm\">****************************************************************************/</span>\n\n<span class=\"cp\">#ifndef objanalyze_h\n</span><span class=\"cp\">#define objanalyze_h\n</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iostream&gt;</span><span class=\"cp\">\n</span><span class=\"cp\"></span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">cout</span><span class=\"p\">;</span>\n<span class=\"k\">using</span> <span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">endl</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#define VIRTUAL_PARENT_A\n</span><span class=\"cp\">#define VIRTUAL_PARENT_B\n</span><span class=\"cp\"></span>\n<span class=\"k\">namespace</span> <span class=\"n\">ObjAnalyze</span>\n<span class=\"p\">{</span>\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ParentA</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ParentA</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;parent0A address &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"cp\">#ifdef VIRTUAL_PARENT_A\n</span><span class=\"cp\"></span>    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">ParentA</span><span class=\"p\">()</span>\n    <span class=\"p\">{}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">// VIRTUAL_PARENT_A\n</span><span class=\"c1\"></span>\n    <span class=\"kt\">void</span> <span class=\"n\">Func0A</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;parent0A Func0A, address &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_age</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_high</span><span class=\"p\">;</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">ParentB</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">ParentB</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;parent0B address &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"cp\">#ifdef VIRTUAL_PARENT_B\n</span><span class=\"cp\"></span>    <span class=\"k\">virtual</span> <span class=\"o\">~</span><span class=\"n\">ParentB</span><span class=\"p\">()</span>\n    <span class=\"p\">{}</span>\n<span class=\"cp\">#endif </span><span class=\"c1\">//  VIRTUAL_PARENT_B\n</span><span class=\"c1\"></span>\n    <span class=\"kt\">void</span> <span class=\"n\">Func0B</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;parent0B Func0B, address &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_grade</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">m_class</span><span class=\"p\">;</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span><span class=\"err\"> </span><span class=\"nc\">Child</span> <span class=\"o\">:</span> <span class=\"k\">public</span> <span class=\"n\">ParentA</span><span class=\"p\">,</span> <span class=\"k\">public</span> <span class=\"n\">ParentB</span>\n<span class=\"p\">{</span>\n<span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"n\">Child</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;child address &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"n\">Func0A</span><span class=\"p\">()</span>\n    <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;child Func0A &#34;</span>  <span class=\"o\">&lt;&lt;</span> <span class=\"k\">this</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n<span class=\"p\">};</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">test_this_point_address</span><span class=\"p\">()</span>\n<span class=\"p\">{</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ParentA size &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ParentA</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;ParentB size &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">ParentB</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"s\">&#34;Child size &#34;</span> <span class=\"o\">&lt;&lt;</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Child</span><span class=\"p\">)</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Child</span> <span class=\"n\">child</span><span class=\"p\">;</span>\n    <span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">Func0A</span><span class=\"p\">();</span>\n    <span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">ParentA</span><span class=\"o\">::</span><span class=\"n\">Func0A</span><span class=\"p\">();</span>\n    <span class=\"n\">child</span><span class=\"p\">.</span><span class=\"n\">Func0B</span><span class=\"p\">();</span>\n    <span class=\"n\">system</span><span class=\"p\">(</span><span class=\"s\">&#34;pause&#34;</span><span class=\"p\">);}</span>\n<span class=\"p\">}</span>\n\n<span class=\"cp\">#endif </span><span class=\"c1\">// objanalyze_h\n</span></code></pre></div><p>打开或者关闭上面的#define VIRTUAL_PARENT_A，#define VIRTUAL_PARENT_B宏，四种结果如下。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-23c74e16176f58938df5575b8c637312_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"721\" class=\"origin_image zh-lightbox-thumb\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-23c74e16176f58938df5575b8c637312_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;956&#39; height=&#39;721&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"956\" data-rawheight=\"721\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"956\" data-original=\"https://pic3.zhimg.com/v2-23c74e16176f58938df5575b8c637312_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-23c74e16176f58938df5575b8c637312_b.jpg\"/></figure><div class=\"highlight\"><pre><code class=\"language-text\">OptimizationA oe;\nOptimizationA of(oe);\nOptimizationA og = oe;\nOptimizationA oh = OptimizationA(oe); \n// 编译器的角度看，分成两步走\n// 1.OptimizationA of (注意此时不会调用OptimizationA的默认构造函数)\n// 2.of.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)\n// 3.og.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)\n// 4.oh.OptimizationA::OptimizationA(oe) (调用拷贝构造函数)</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;2800&#39; height=&#39;800&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"2800\" data-rawheight=\"800\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"2800\" data-original=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-42b0e4be5fe3e2746fcc9aabf1a6001b_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "C++", 
                    "tagLink": "https://api.zhihu.com/topics/19584970"
                }, 
                {
                    "tag": "C++ 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19836485"
                }, 
                {
                    "tag": "C++11", 
                    "tagLink": "https://api.zhihu.com/topics/19726035"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_1150806133101924352"
}
