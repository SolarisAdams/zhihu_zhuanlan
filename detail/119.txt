{
    "title": "算法科学", 
    "description": "无论是你从事业务开发，想要评估代码性能和资源消耗，还是从事架构设计，想要优化设计模式；或者想要快速玩转热门技术，都要先搞定数据结构和算法。因为算法能力即使一个程序员内功的展示。", 
    "followers": [
        "https://www.zhihu.com/people/ablikim-65", 
        "https://www.zhihu.com/people/18883242720", 
        "https://www.zhihu.com/people/aoi-40-1", 
        "https://www.zhihu.com/people/tan-xiao-yang-95", 
        "https://www.zhihu.com/people/hou-hou-hou-63-7", 
        "https://www.zhihu.com/people/zheng-zhi-guo-91", 
        "https://www.zhihu.com/people/zheng-dao-10-47", 
        "https://www.zhihu.com/people/gao-wei-feng-17", 
        "https://www.zhihu.com/people/chen-qi-kun-14", 
        "https://www.zhihu.com/people/wang-hao-92-67-89", 
        "https://www.zhihu.com/people/zhang-xiao-mao-guai", 
        "https://www.zhihu.com/people/dreamer-32-81", 
        "https://www.zhihu.com/people/neko-44-39", 
        "https://www.zhihu.com/people/yiming-wu", 
        "https://www.zhihu.com/people/neko-28-33", 
        "https://www.zhihu.com/people/ha-ha-9-62-79", 
        "https://www.zhihu.com/people/boxer-88", 
        "https://www.zhihu.com/people/qin-tong-xue-27-55", 
        "https://www.zhihu.com/people/xyhp915", 
        "https://www.zhihu.com/people/xing-yun-de-xiao-hui-27", 
        "https://www.zhihu.com/people/zhiliang-feng", 
        "https://www.zhihu.com/people/longlyVV", 
        "https://www.zhihu.com/people/jacky-tang-54", 
        "https://www.zhihu.com/people/song-song-song-31-15", 
        "https://www.zhihu.com/people/Xzavier", 
        "https://www.zhihu.com/people/lqw-78-88", 
        "https://www.zhihu.com/people/youth-59-63", 
        "https://www.zhihu.com/people/xu-jing-di-94", 
        "https://www.zhihu.com/people/feng-qi-yun-yong-19-41", 
        "https://www.zhihu.com/people/lily-27-19-8", 
        "https://www.zhihu.com/people/wen-xu-yang-28", 
        "https://www.zhihu.com/people/huang-da-wu-50", 
        "https://www.zhihu.com/people/minmin4321", 
        "https://www.zhihu.com/people/xiao-wen-55-60", 
        "https://www.zhihu.com/people/zerkei", 
        "https://www.zhihu.com/people/chris314", 
        "https://www.zhihu.com/people/qiu-tian-25-59-81", 
        "https://www.zhihu.com/people/shuxiongwang", 
        "https://www.zhihu.com/people/xiao-tui-shao-nian-88", 
        "https://www.zhihu.com/people/zhou-wen-hui-36", 
        "https://www.zhihu.com/people/chen-xing-61-62", 
        "https://www.zhihu.com/people/mu-dong-chu-qing-37", 
        "https://www.zhihu.com/people/tai-yan-82-63", 
        "https://www.zhihu.com/people/luo-hai-tian-69", 
        "https://www.zhihu.com/people/followme-23-82", 
        "https://www.zhihu.com/people/kangzl", 
        "https://www.zhihu.com/people/song-sheng-27-47", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/zhang-hong-bao-60", 
        "https://www.zhihu.com/people/wang-yan-duo-97-38", 
        "https://www.zhihu.com/people/zxbin2000", 
        "https://www.zhihu.com/people/cai-cai-cai-xiang", 
        "https://www.zhihu.com/people/lin-shi-yu-22", 
        "https://www.zhihu.com/people/dong-shuai-68-28-20", 
        "https://www.zhihu.com/people/bai-yao-wei", 
        "https://www.zhihu.com/people/tang-jian-long-13", 
        "https://www.zhihu.com/people/zhouluyang", 
        "https://www.zhihu.com/people/crush-4-40", 
        "https://www.zhihu.com/people/jian-an-73", 
        "https://www.zhihu.com/people/tao-xian-sheng-92", 
        "https://www.zhihu.com/people/guo-shu-70-70", 
        "https://www.zhihu.com/people/yu-wen-qing-80-94", 
        "https://www.zhihu.com/people/yifang-shi-jie-99", 
        "https://www.zhihu.com/people/edidada", 
        "https://www.zhihu.com/people/arsxht", 
        "https://www.zhihu.com/people/progray", 
        "https://www.zhihu.com/people/yige-you-gu-shi-de-nan-ren-52", 
        "https://www.zhihu.com/people/liu-bo-12-76", 
        "https://www.zhihu.com/people/like881", 
        "https://www.zhihu.com/people/yixinlianghua", 
        "https://www.zhihu.com/people/a-qiao-79-1", 
        "https://www.zhihu.com/people/du-shao-kang-78", 
        "https://www.zhihu.com/people/nan-ke-2", 
        "https://www.zhihu.com/people/huo-yan-66-12", 
        "https://www.zhihu.com/people/jia-si-56-96", 
        "https://www.zhihu.com/people/huc_zhangjingxin", 
        "https://www.zhihu.com/people/gameending", 
        "https://www.zhihu.com/people/xi-feng-yang-74", 
        "https://www.zhihu.com/people/lampour", 
        "https://www.zhihu.com/people/world-hello-74-14", 
        "https://www.zhihu.com/people/mu-hang-80", 
        "https://www.zhihu.com/people/yu-xun-33", 
        "https://www.zhihu.com/people/midas-64", 
        "https://www.zhihu.com/people/dawinia-lo", 
        "https://www.zhihu.com/people/ya-se-xiao-ge-ge", 
        "https://www.zhihu.com/people/bai-cao-quan-yu", 
        "https://www.zhihu.com/people/sun-xiao-fei-75-94", 
        "https://www.zhihu.com/people/lu-jun-long-44", 
        "https://www.zhihu.com/people/insight-jing", 
        "https://www.zhihu.com/people/ye-ling-ye-83", 
        "https://www.zhihu.com/people/dai-mei-lin", 
        "https://www.zhihu.com/people/litarussell", 
        "https://www.zhihu.com/people/an-zi-91-34", 
        "https://www.zhihu.com/people/mu-ke-76-92", 
        "https://www.zhihu.com/people/liu-lin-qi-78", 
        "https://www.zhihu.com/people/advstock", 
        "https://www.zhihu.com/people/cai-xiu-yuan", 
        "https://www.zhihu.com/people/shaoyoujun", 
        "https://www.zhihu.com/people/zhouzhenghui", 
        "https://www.zhihu.com/people/ai-you-di-qiu-ren", 
        "https://www.zhihu.com/people/liu-lei-lei-i", 
        "https://www.zhihu.com/people/lei-jia-rui-36", 
        "https://www.zhihu.com/people/fei-cun-37", 
        "https://www.zhihu.com/people/zealoussnow", 
        "https://www.zhihu.com/people/yongge-89", 
        "https://www.zhihu.com/people/bakerbaba", 
        "https://www.zhihu.com/people/ranjiewen", 
        "https://www.zhihu.com/people/jiu-cheng-38", 
        "https://www.zhihu.com/people/cha-zhu-6", 
        "https://www.zhihu.com/people/guanjunxiao", 
        "https://www.zhihu.com/people/llwanghong", 
        "https://www.zhihu.com/people/wang-lun-35-83", 
        "https://www.zhihu.com/people/chen-xi-41-47-86", 
        "https://www.zhihu.com/people/zheng-rong-8-71", 
        "https://www.zhihu.com/people/zhuo-sun-40", 
        "https://www.zhihu.com/people/wang-chen-91-90", 
        "https://www.zhihu.com/people/woodboy456", 
        "https://www.zhihu.com/people/weichiche", 
        "https://www.zhihu.com/people/shi-yang-73-36", 
        "https://www.zhihu.com/people/peng-peng-9-27", 
        "https://www.zhihu.com/people/wuwo-shi"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/63179968", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 6, 
            "title": "深入理解深度优先搜索", 
            "content": "<p>在了解深度优先搜索之前，我们先来了解一下图的处理算法的设计模式，这个可以帮助我们更好的理解下面的算法，也能为我们自己在思考图的算法时，提供一点有价值的指导。</p><h2>图的处理算法的设计模式：</h2><p>因为我们会讨论大量关于图的算法，所以设计的首要目标是将图的表示和实现<i>分离</i>开来。为此，我们会为每个任务创建一个相应的类，用例可以创建相应的对象来完成任务。类的构造函数一般会在预处理中构造各种数据结构，以有效地相应用例请求。典型的用例程序会构造一幅图，将图传递给实现了某个算法的类（作为构造函数的参数），然后调用用例的方法来获取图的各种性质。</p><hr/><h2>深度优先搜索</h2><p> 探索迷宫而不迷路的一种古老办法（至少可以追溯到忒修斯和米诺陶的传说）叫做<b><i>Tremaux</i></b>搜索，要探索迷宫中的所有通道，我们需要：</p><ul><li>选择一条没有标记过的通道，在你走过的路上铺一条绳子；</li><li>标记所有你第一次路过的路口和通道；</li><li>当来到一个标记过的路口时（用绳子）回退到上个路口；</li><li>当回退到的路口已没有可走的通道时继续回退。</li></ul><p>绳子可以保证你总能找到一条出路，标记则保证你不会两次经过同一条通道或者同一个路口。如下图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-40492807d685500b53073d6eb6006ac6_b.png\" data-size=\"normal\" data-rawwidth=\"126\" data-rawheight=\"492\" class=\"content_image\" width=\"126\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;126&#39; height=&#39;492&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"126\" data-rawheight=\"492\" class=\"content_image lazy\" width=\"126\" data-actualsrc=\"https://pic3.zhimg.com/v2-40492807d685500b53073d6eb6006ac6_b.png\"/><figcaption>Tremaux搜索</figcaption></figure><p>思考与之等价的问题——迷宫，是在思考图的搜索过程中一种有益的方法。用迷宫代替图，通道代替边，路口代替顶点，这么做可以帮助我们直观的认识问题。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-67e0b5d0d9f750b95224b0134f20dd12_b.png\" data-size=\"normal\" data-rawwidth=\"141\" data-rawheight=\"215\" class=\"content_image\" width=\"141\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;141&#39; height=&#39;215&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"141\" data-rawheight=\"215\" class=\"content_image lazy\" width=\"141\" data-actualsrc=\"https://pic3.zhimg.com/v2-67e0b5d0d9f750b95224b0134f20dd12_b.png\"/><figcaption>等价的迷宫模型</figcaption></figure><p><b><i>我们常常通过系统地检查每一个顶点和每一条边来获取图的各种性质。</i></b></p><p>要知道是否完全探索了整个迷宫需要的证明更复杂，只有用图搜索才能更好地处理问题。Tremaux搜索很直接，但它与完全搜索一张图仍然稍有不同，我们可以看看图的搜素方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//深度优先搜索：\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">DepthFirstPaths</span> <span class=\"o\">{</span>\n\t<span class=\"kd\">private</span> <span class=\"kt\">boolean</span><span class=\"o\">[]</span> <span class=\"n\">marked</span><span class=\"o\">;</span>\t\t\t\t\n\t<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\t\t\t\n\t\n\t<span class=\"kd\">public</span> <span class=\"nf\">DepthFirstPaths</span><span class=\"o\">(</span><span class=\"n\">Graph</span> <span class=\"n\">G</span><span class=\"o\">,</span><span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"n\">marked</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"kt\">boolean</span><span class=\"o\">[</span><span class=\"n\">G</span><span class=\"o\">.</span><span class=\"na\">V</span><span class=\"o\">()];</span>\n\t\t<span class=\"n\">dfs</span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">,</span><span class=\"n\">s</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\n\t<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">dfs</span><span class=\"o\">(</span><span class=\"n\">Graph</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">v</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n\t\t<span class=\"n\">count</span><span class=\"o\">++:</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"na\">adj</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">))</span> \n\t\t\t<span class=\"k\">if</span><span class=\"o\">(!</span><span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">])</span> \t<span class=\"n\">dfs</span><span class=\"o\">(</span><span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"n\">w</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t<span class=\"kd\">public</span> <span class=\"kt\">boolean</span> <span class=\"nf\">marked</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">w</span><span class=\"o\">)</span>\n\t<span class=\"o\">{</span> \t<span class=\"k\">return</span> <span class=\"n\">marked</span><span class=\"o\">[</span><span class=\"n\">w</span><span class=\"o\">];</span>\t\t<span class=\"o\">}</span>\n\t<span class=\"kd\">public</span> <span class=\"kt\">int</span> <span class=\"nf\">count</span><span class=\"o\">()</span>\n       <span class=\"o\">{</span>\t<span class=\"k\">return</span> <span class=\"n\">count</span><span class=\"o\">;</span>\t\t\t<span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h2>热热身：</h2><p>搜索连通图的经典递归算法（遍历所有的顶点和边）和Tremaux搜索类似，但描述起来更为简单。要搜索一幅图，只需要一个递归方法来遍历所有顶点。在访问其中一个顶点时：</p><ul><li> 将它标记为已访问</li><li> 递归地访问它的所有没有被标记过的邻居顶点。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6386b7a041bfb18cf07d693d4af1d126_b.jpg\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"288\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;288&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"288\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic3.zhimg.com/v2-6386b7a041bfb18cf07d693d4af1d126_b.jpg\"/><figcaption>已标记和未标记的集合</figcaption></figure><h2>Search API</h2><p>我们可以先来定义一个Search API 。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-00248a677ab894af703216418579cbc6_b.jpg\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-00248a677ab894af703216418579cbc6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"110\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-00248a677ab894af703216418579cbc6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-00248a677ab894af703216418579cbc6_b.jpg\"/><figcaption>Search API </figcaption></figure><p>这种方法称为<b><i>深度优先搜索（DFS）</i></b>。我们很容易就可以想到深度优先搜索标记与起点连通的所有顶点所需的<b><i>时间</i></b>和顶点的<b>度数</b>之和成正比。</p><p>如深度优先搜素算法所示，它使用一个boolean数组来记录和起点连通的所有顶点。递归方法会标记给定的顶点并调用自己来访问该顶点的相邻顶点列表中所有没被标记过的顶点。如果图是连通的，每个邻接链表中的元素都会被检查到。 </p><h2>单向通道</h2><p>代码中方法的调用和返回机制对应迷宫中绳子的作用：当已经处理过依附于一个顶点的所有边时（搜索了路口连接的所有通道），我们就只能“返回“。</p><p>为了更好的与迷宫的Tremaux搜索对应起来，我们可以想象一座完全由单向通道构造的迷宫（每个方向都只有一个通道）。和我们在迷宫中会经过一条通道两次（方向不同）一样。</p><p>在Tremaux搜索中，要么是第一次访问一条边，要么是沿着它从一个被标记过的顶点退回。在无向图的深度优先搜索中，在碰到v-w时，要么进行递归调用（w没有被标记过），要么跳过这条边（w已经被标记过）。第二次从另一个方向w-v遇到这条边时，总是会忽略它，因为它的另一个端点v肯定已经被访问过了。</p><h2>跟踪深度优先搜索</h2><p>理解算法的最好方法之一是在一个简单的例子中跟踪它的行为。我们可以在深度优先算法中进行如此跟踪。</p><p>然而在跟踪它的轨迹时，首先要注意的是，算法遍历边和访问顶点的顺序与图的表示有关，而不只是与图的结构或是算法有关。因为<i>深度优先搜索只会访问和起点连通的顶点</i>， </p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-2ff4102acb8f50925a590ce81b14fa4b_b.png\" data-size=\"normal\" data-rawwidth=\"192\" data-rawheight=\"305\" class=\"content_image\" width=\"192\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;192&#39; height=&#39;305&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"192\" data-rawheight=\"305\" class=\"content_image lazy\" width=\"192\" data-actualsrc=\"https://pic4.zhimg.com/v2-2ff4102acb8f50925a590ce81b14fa4b_b.png\"/><figcaption>一幅连通的无向图</figcaption></figure><p>如图展示了一幅小型连通图，在示例中，顶点2是顶点0之后第一个被访问的顶点，因为它正好是0的邻接表的第一个元素。</p><p>要<b><i>注意</i></b>的第二点是：如之前所述，深度优先搜索的每条边都会被访问两次，且在第二次时总会发现这个顶点已经被标记过。这意味着深度优先搜索的轨迹可能会比想想的长一倍！示例中仅含有8条边，但需要追踪算法在邻接表的16个元素上的操作。</p><h2>深度优先搜索的详细轨迹</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5168c6ef84a10c2f702adf1e64834ca9_b.png\" data-size=\"normal\" data-rawwidth=\"157\" data-rawheight=\"290\" class=\"content_image\" width=\"157\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;157&#39; height=&#39;290&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"157\" data-rawheight=\"290\" class=\"content_image lazy\" width=\"157\" data-actualsrc=\"https://pic2.zhimg.com/v2-5168c6ef84a10c2f702adf1e64834ca9_b.png\"/><figcaption>轨迹图</figcaption></figure><p>如图，显示的是示例中每个顶点被标记后算法使用的数据结构。</p><ul><li>起点为顶点0查找开始于构造函数调用递归的dfs()来标记和访问顶点0。</li><li>因为顶点2是0的邻接表的第一个元素且没有被标记过，dfs()递归调用自己来标记并访问顶点2（效果是系统会将顶点0和0的邻接表的当前位置压入栈中）。</li><li>现在，顶点0是2的邻接表的第一个元素且已经被标记过了，因此dfs()跳过了它，接下来，顶点1是2的邻接表的第二个元素且没有被标记过，dfs()递归调用自己来标记并访问顶点1.</li><li>对于顶点1的访问和前面有所不同：因为它的邻接表中的所有顶点（0和2）都已经被标记过了，因此不需要在进行递归，因此dfs()递归调用自己来标记并访问顶点3.</li><li>顶点5是3是的邻接表的第一个元素且没有被标记，因此dfs()递归调用自己来标记并访问顶点5.</li><li>顶点5的邻接表中的所有顶点（3和0）都已经被标记过了，因此不需要在进行递归。</li><li>顶点4是3的邻接表的下一个元素且没有被标记过，因此dfs()递归调用自己来标记并访问顶点4.这是最后一个需要标记的顶点。</li><li>在顶点4被标记了之后，dfs()会检查它的邻接表，然后再检查3的邻接表，然后是2的邻接表，然后是0的，最后发现不需要再进行任何递归调用，因为所有的顶点都已经被标记过了。</li></ul><p>这种简单的递归模式只是一个开始——深度优先搜索能够有效处理许多和图有关的任务。例如图的<b><i>连通性</i></b>问题、<b><i>单点路径</i></b>问题。</p><h2>寻找路径</h2><p>单点路径问题在图的处理领域中十分重要。我们将会使用下面这个API。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-ec5e2dacf22080fdc9960c5920d83ad4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"98\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-ec5e2dacf22080fdc9960c5920d83ad4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;98&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"98\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-ec5e2dacf22080fdc9960c5920d83ad4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-ec5e2dacf22080fdc9960c5920d83ad4_b.jpg\"/></figure><p>构造函数接受一个起点s作为参数，计算s到与s连通的每个顶点之间的路径。在为起点s创建了Paths对象后，用例可以调用pathTo()实例方法来遍历从s到任意和s连通的顶点的路径上的所有顶点。</p><h3>实现</h3><p>以下算法基于深度优先搜索实现了Paths，在此算法中添加了一个实例变量edgeTo[ ]整型数组来起到Tremaux搜索中绳子的作用。这个数组可以找到从每个与s连通的顶点回到s的路径。它会记录每个顶点到起点的路径，而不是记录当前顶点到起点的路径。为了做到这一点，在由边v-w第一次访问任意w时，将edgeTo[w]设为v来记住这条路径。换句话说，v-w是从s到w的路径上是最后一条已知的边。</p><div class=\"highlight\"><pre><code class=\"language-text\">public class DepthFirstPaths {\n\tprivate boolean[] marked;\t\t//这个顶点是否已经调用过dfs()了？\n\tprivate int[] edgeTo;\t\t\t//从起点到一个顶点的已知路径上的最后一个顶点\n\tprivate final int s;\t\t\t//起点\n\t\n\tpublic DepthFirstPaths(Graph G,int s) {\n\t\tmarked = new boolean[G.V()];\n\t\tedgeTo = new int[G.V()];\n\t\tthis.s = s;\n\t\tdfs(G,s);\n\t}\n\n\tprivate void dfs(Graph G, int v) {\n\t\tmarked[v] = true;\n\t\tfor(int w : G.adj(v)) \n\t\t\tif(!marked[w]) {\n\t\t\t\tedgeTo[w] = v;\n\t\t\t\tdfs(G, w);\n\t\t\t}\n\t}\n\tpublic boolean hasPathTo(int v) {\n\t\treturn marked[v];\n\t}\n\tpublic Iterable&lt;Integer&gt; pathTo(int v){\n\t\tif(!hasPathTo(v))\treturn null;\n\t\tStack&lt;Integer&gt; path = new Stack&lt;Integer&gt;();\n\t\tfor(int x = v; x !=s; x = edgeTo[x])\n\t\t\tpath.push(x);\n\t\tpath.push(s);\n\t\treturn path;\n\t}\n}</code></pre></div><p>这段Graph的用例使用了深度优先搜索，以找出图中从给定的起点s到它连通的所有顶点的路径。为了保存到达每个顶点的已知路径，这段代码使用了一个以顶点编号为索引的数组edgeTo[ ]，edgeTo[w]=v表示v-w是第一次访问w时经过的边。edgeTo[ ]数组是一棵用父链接表示的以s为根且含有所有与s连通的顶点的树。如下图小示例：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-c8798ae626e06f4b40f374a7e897546d_b.jpg\" data-size=\"normal\" data-rawwidth=\"289\" data-rawheight=\"202\" class=\"content_image\" width=\"289\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;289&#39; height=&#39;202&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"289\" data-rawheight=\"202\" class=\"content_image lazy\" width=\"289\" data-actualsrc=\"https://pic2.zhimg.com/v2-c8798ae626e06f4b40f374a7e897546d_b.jpg\"/><figcaption>小示例</figcaption></figure><h2>详细轨迹</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ba86ba160101c8de5d9f303adbc07419_b.jpg\" data-size=\"normal\" data-rawwidth=\"222\" data-rawheight=\"543\" class=\"content_image\" width=\"222\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;222&#39; height=&#39;543&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"222\" data-rawheight=\"543\" class=\"content_image lazy\" width=\"222\" data-actualsrc=\"https://pic2.zhimg.com/v2-ba86ba160101c8de5d9f303adbc07419_b.jpg\"/><figcaption>使用深度优先搜素的轨迹</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "搜索", 
                    "tagLink": "https://api.zhihu.com/topics/19552128"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>请注明原作者是Robert Sedgewick等人，注明来自于他们的书algorithm，谢谢</p>", 
                    "likes": 1, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62410528", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 3, 
            "title": "无向图基础", 
            "content": "<p>无向图是一种最简单的图模型，在这种图模型中，<b><i>边</i></b>仅仅是两个<b><i>顶点</i></b>之间的连接。我们用v-w的记法表示连接v和w的边，而w-v是这条边的另一种表示方法。</p><h3>特殊的图。</h3><ul><li>自环：即一条连接一个顶点和其自身的边；</li><li>连接同一对顶点的两条边称为平行边。</li></ul><hr/><h3>简单术语介绍</h3><p>当两个顶点通过一条边相连时，我们称这两个顶点是<b><i>相邻</i></b>的，并称这条边<b><i>依附</i></b>于这两个顶点。某个顶点的<b><i>度数</i></b>即为依附于它的边的总数。<b><i>子图</i></b>是由一幅图的所有边的一个子集（以及它们所依附的所有顶点）组成的图。</p><p><b><i>路径</i></b>是由边顺序连接的一系列顶点。<b><i>简单路径</i></b>是一条没有重复顶点的路径。<b><i>环</i></b>是一条至少含有一条边且起点和终点相同的路径。<b><i>简单环</i></b>是一条（除了起点和终点必须相同之外）不含有重复顶点和边的环。路径或者环的长度为其中所包含的边数。</p><p>如果从任意一个顶点都存在一条路径到达另一个任意顶点，我们称这幅图是<b><i>连通图</i></b>。一幅非连通的图由若干连通的部分组成，它们都是其极大连通子图。</p><blockquote>树是一幅无环连通图。互不相连的树组成的集合称为森林。连通图的生成树是它的一幅子图，它含有图中的所有顶点且是一棵树。图的生成树森林是它的所有连通子图的生成树的集合。</blockquote><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a0ede4b788344de218caa76e8971d4d0_b.png\" data-size=\"normal\" data-rawwidth=\"188\" data-rawheight=\"207\" class=\"content_image\" width=\"188\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;188&#39; height=&#39;207&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"188\" data-rawheight=\"207\" class=\"content_image lazy\" width=\"188\" data-actualsrc=\"https://pic1.zhimg.com/v2-a0ede4b788344de218caa76e8971d4d0_b.png\"/><figcaption>一棵树</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-a0a47f5e025e8a28afb7d18aca419330_b.png\" data-size=\"normal\" data-rawwidth=\"147\" data-rawheight=\"252\" class=\"content_image\" width=\"147\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;147&#39; height=&#39;252&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"147\" data-rawheight=\"252\" class=\"content_image lazy\" width=\"147\" data-actualsrc=\"https://pic1.zhimg.com/v2-a0a47f5e025e8a28afb7d18aca419330_b.png\"/><figcaption>生成树森林</figcaption></figure><h3>树的数学性质</h3><p>当且仅当一幅含有V个结点的图G满足下列五个条件之一时，它就是一棵树：</p><ul><li>G有V-1条边且不含有环</li><li>G有V-1条边且是连通的</li><li>G是连通的，但删除任意一条边都会使它不再连通</li><li>G是无环图，但添加任意一条边都会产生一条环</li><li>G中的任意一对顶点之间仅存在一条简单路径。</li></ul><p>图的<i><b>密度</b></i>是指已经连接的顶点对占所有被连接的顶点对的比例。在<i><b>稀疏图</b></i>中，被连接的顶点对很少；而在<i><b>稠密图</b></i>中，只有少部分顶点对之间没有边连接。一般来说，如果一幅图中不同的边的数量在顶点总数V的一个<i>小常数倍</i>以内，那么我们就认为这幅图是稀疏的。</p><p><b><i>二分图</i></b>是一种能够将所有结点分为两部分的图，其中图的每条边所连接的两个顶点都分别属于不同的部分。</p><hr/><h3>表示无向图的数据类型</h3><p>要开发处理图问题的各种算法，我们首先来看一份定义了图的基本操作的API</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-58727eb587dfe564bbf67e8b52d6eb31_b.jpg\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"207\" class=\"origin_image zh-lightbox-thumb\" width=\"534\" data-original=\"https://pic2.zhimg.com/v2-58727eb587dfe564bbf67e8b52d6eb31_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;534&#39; height=&#39;207&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"207\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"534\" data-original=\"https://pic2.zhimg.com/v2-58727eb587dfe564bbf67e8b52d6eb31_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-58727eb587dfe564bbf67e8b52d6eb31_b.jpg\"/><figcaption>无向图的API</figcaption></figure><h3>最常用的图处理代码</h3><p>计算v的度数</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"nf\">degree</span><span class=\"o\">(</span><span class=\"n\">Graph</span> <span class=\"n\">G</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">v</span><span class=\"o\">){</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">degree</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\t<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">w</span> <span class=\"o\">:</span> <span class=\"n\">G</span><span class=\"o\">.</span><span class=\"na\">adj</span><span class=\"o\">(</span><span class=\"n\">v</span><span class=\"o\">))</span>\t<span class=\"n\">degree</span><span class=\"o\">++;</span>\n\t<span class=\"k\">return</span> <span class=\"n\">degree</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>计算所有顶点的最大度数</p><div class=\"highlight\"><pre><code class=\"language-text\">public static int maxDegree(Graph G){\n\tint max = 0;\n\tfor (int v = 0; v &lt; G.V(); v++)\n\t\tif (degree(G,v) &gt; max)\n\t\t\tmax = degree(G,v);\n\treturn max;\n}</code></pre></div><p>计算所有顶点的平均度数</p><div class=\"highlight\"><pre><code class=\"language-text\">public static double avgGegree(Graph G){\n\treturn 2.0 * G.E() / G.V();\n}</code></pre></div><p>计算自环的个数</p><div class=\"highlight\"><pre><code class=\"language-text\">public static int numberOfSelfLoops(Graph G){\n\tint count = 0;\n\tfor (int v = 0; v &lt; G.V(); v++)\n\t\tfor(int w : G.adj(v))\n\t\t\tif( v == w)\t\tcount++;\n\treturn count/2;\t\t\t\t//每条边被记录过两次\n}</code></pre></div><p>图的邻接表的字符串表示（Graph的实例方法）</p><div class=\"highlight\"><pre><code class=\"language-text\">public String toString(){\n\tString s = V + &#34;vertices,&#34; + E + &#34; edges\\n&#34;;\n\tfor (int v = 0; v &lt; V; v++){\n\t\ts += v + &#34;: &#34;;\n\t\tfor(int w : this.adj(v))\n\t\t\ts += w + &#34; &#34;;\n\t\ts += &#34;\\n&#34;;\n\t}\n\treturn s;\n}</code></pre></div><h3>图的几种表示方法</h3><p>在这里我们需要面对的问题是用哪种方式（数据结构）来表示图并实现API，这包含以下两个要求。</p><ul><li>它必须为可能在应用中碰到的各种类型的图预留出足够的空间；</li><li>Graph的实例方法的实现一定要快——它们是开发处理图的各种用例的基础。</li></ul><p>这些要求 比较模糊，但它们仍然能够帮助我们在三种图的表示方法中进行选择。</p><ul><li><i><b>邻接矩阵</b></i>。我们可以用一个V乘V的布尔矩阵。当顶点v和顶点w之间有相连接的边时，定义v行w列的元素为true。这种表示方法不符合第一个条件——含有上百万个顶点的图是很常见的，V^2个布尔值所需要的空间是不能满足的。</li><li><b><i>边的数组</i></b>。我们可以使用一个Edge类，它含有两个int实例变量。这种表示方法很简洁但不满足第二个条件——要实现adj()需要检查图的所有边。</li><li><i><b>邻接表数组</b></i>。我们可以使用一个以顶点为索引的列表数组，其中的每个元素都是和该顶点相邻的顶点列表，如图。这种数据结构能够同时满足上面两点。</li></ul><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-3f9ccca7bbb254a5696f3733445857ef_b.jpg\" data-size=\"normal\" data-rawwidth=\"269\" data-rawheight=\"477\" class=\"content_image\" width=\"269\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;269&#39; height=&#39;477&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"269\" data-rawheight=\"477\" class=\"content_image lazy\" width=\"269\" data-actualsrc=\"https://pic4.zhimg.com/v2-3f9ccca7bbb254a5696f3733445857ef_b.jpg\"/><figcaption>邻接表数组示意（无向图）</figcaption></figure><h3>邻接表的数据结构</h3><p>非稠密图的标准表示称为邻接表的数据结构，它将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中。我们使用这个数组就是为了快速访问给定顶点的邻接顶点列表。我们使用Bag这个抽象数据类型来实现这个链表，这样我们就可以在常数时间内添加新的边或遍历任意顶点的所有相邻顶点。</p><p>这种Graph的实现的性能有如下特点：</p><ul><li>使用的空间可V+E成正比</li><li>添加一条边所需要的时间为常数</li><li>遍历顶点v的所有相邻顶点所需要的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数）</li></ul><h2>Graph数据类型</h2><div class=\"highlight\"><pre><code class=\"language-text\">public class Graph {\n\tprivate final int V;\t\t//顶点数目\n\tprivate int E;\t\t\t//边的数目\n\tprivate Bag&lt;Integer&gt;[] adj;\t//邻接表\n\tpublic Graph(int V) {\n\t\tthis.V = V;\tthis.E = 0;\n\t\tadj = (Bag&lt;Integer&gt;[]) new Bag[V];\t\t\t//创建邻接表\n\t\tfor(int v = 0; v &lt; V; v++)\t\t\t\t//将所有链表初始化为空\n\t\t\tadj[v] = new Bag&lt;Integer&gt;();\n\t}\n\tpublic Graph(In in) {\n\t\tthis(in.readInt());\t\t\t\t\t//读取V并将图初始化\n\t\tint E = in.readInt();\t\t\t\t\t//读取E\n\t\tfor(int i = 0; i &lt; E; i++ ) {\n\t\t\t//添加一条边\n\t\t\tint v = in.readInt();\t\t\t\t//读取一个顶点\n\t\t\tint w = in.readInt();\t\t\t\t//读取另一个顶点\n\t\t\taddEdge(v,w);\t\t\t\t\t//添加一条连接他们的边\n\t\t}\n\t}\n\tpublic int V()\t{\treturn V;\t}\n\tpublic int E()\t{\treturn E;\t}\n\tpublic void addEdge(int v, int w) {\n\t\tadj[v].add(w);\n\t\tadj[w].add(v);\n\t\tE++;\n\t}\n\tpublic Iterable&lt;Integer&gt; adj(int v){\n\t\treturn adj[v];\n\t}\n}</code></pre></div><p>这份Graph的实现使用了一个由顶点索引的整数链表数组。每条边都会出现<i>两次</i>，即当存在一条连接v与w的边时，w会出现在v的链表中，v也会出现在w的链表中。第二个构造函数从输入流中读取一幅图，开头是V，然后是E，再然后是一列整数对，大小在0到V-1之间</p><h2>实际操作情况</h2><p>在实际应用中还有一些操作可能是很有用的，例如</p><ul><li>添加一个顶点</li><li>删除一个顶点</li></ul><p>实现这些操作的一种方法是扩展之前的API，使用符号表（ST）来代替由顶点索引构成的数组（这样修改之后就不需要约定定点名必须是整数了）。</p><ul><li>删除一条边</li><li>检查图是否含有边v-w</li></ul><p>要实现这些方法可能需要使用SET来替代Bag来实现邻接表。我们称这种方法为<b><i>邻接集</i></b>。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-46604e7e361f80dbc28df95769ad3829_b.jpg\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"189\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-46604e7e361f80dbc28df95769ad3829_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"189\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-46604e7e361f80dbc28df95769ad3829_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-46604e7e361f80dbc28df95769ad3829_b.jpg\"/><figcaption>典型Graph实现的性能复杂度</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62260018", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 0, 
            "title": "基于线性探索法的散列表", 
            "content": "<p>请先参阅<a href=\"https://zhuanlan.zhihu.com/p/62133064\" class=\"internal\">深入理解散列表</a></p><hr/><h3>散列表的另一种实现</h3><p>用大小为M的数组保存N个键值对，其中<i>M&gt;N</i>。我们需要依靠数组中的空位解决碰撞冲突。基于这种策略的所有方法被统称为<i><b>开放地址</b></i>散列表。</p><p>开放地址散列表中最简单的方法叫做线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检测散列表的下一个位置（将索引加一）。这样的线性探测可能会产生三种情况：</p><ul><li>命中，该位置的键和被查找的键相同；</li><li>未命中，键为空（该位置没有键）；</li><li>继续查找，该位置的键和被查找的键不同</li></ul><p>我们用散列函数找到键在数组中的索引，检查其中的键和被查找的键是否相同。如果不同则继续查找（将索引增大，达到数组结尾时折回数组的开头），直到找到该键或者遇到一个空元素，</p><p>如下图。我们习惯将检查一个数组位置是否含有被查找的键的操作称为探测。在这里它可以等价于我们一直使用的比较，不过有些探测实际上是在探测键是否为空。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-9628da0b5cb1b25dc113d2518bb15dcc_b.jpg\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb\" width=\"533\" data-original=\"https://pic1.zhimg.com/v2-9628da0b5cb1b25dc113d2518bb15dcc_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;533&#39; height=&#39;422&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"533\" data-rawheight=\"422\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"533\" data-original=\"https://pic1.zhimg.com/v2-9628da0b5cb1b25dc113d2518bb15dcc_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-9628da0b5cb1b25dc113d2518bb15dcc_b.jpg\"/><figcaption>标准索引用例使用的基于线性探索的符号表的轨迹</figcaption></figure><h3>核心思想</h3><p>开放地址类的散列表的核心思想是与其将内存用作链表，不如将它们作为在散列表的空元素。这些空元素可以作为查找结束的标志。</p><p>在下面的实现中使用了并行数组，一条保存键，一条保存值，并像前面讨论的那样使用散列函数产生访问数据所需的数组索引。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">LinearProbingHashST</span><span class=\"o\">&lt;</span><span class=\"n\">Key</span><span class=\"o\">,</span> <span class=\"n\">Value</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">INIT_CAPACITY</span> <span class=\"o\">=</span> <span class=\"n\">4</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"o\">;</span>           <span class=\"c1\">// 符号表中键值对的总数\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">m</span><span class=\"o\">;</span>           <span class=\"c1\">// 线性探测表的大小\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">Key</span><span class=\"o\">[]</span> <span class=\"n\">keys</span><span class=\"o\">;</span>      <span class=\"c1\">// 键\n</span><span class=\"c1\"></span>    <span class=\"kd\">private</span> <span class=\"n\">Value</span><span class=\"o\">[]</span> <span class=\"n\">vals</span><span class=\"o\">;</span>    <span class=\"c1\">// 值\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"nf\">LinearProbingHashST</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">m</span> <span class=\"o\">=</span> <span class=\"n\">capacity</span><span class=\"o\">;</span>\n        <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"n\">keys</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">Key</span><span class=\"o\">[])</span>   <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">];</span>\n        <span class=\"n\">vals</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">Value</span><span class=\"o\">[])</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">m</span><span class=\"o\">];</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"nf\">hash</span><span class=\"o\">(</span><span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">.</span><span class=\"na\">hashCode</span><span class=\"o\">()</span> <span class=\"o\">&amp;</span> <span class=\"n\">0x7fffffff</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">m</span><span class=\"o\">;</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">resize</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span>\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Value</span> <span class=\"n\">val</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        \n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">val</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">delete</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 将m加倍\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">n</span> <span class=\"o\">&gt;=</span> <span class=\"n\">m</span><span class=\"o\">/</span><span class=\"n\">2</span><span class=\"o\">)</span> <span class=\"n\">resize</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span> <span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">vals</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n                <span class=\"k\">return</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"o\">;</span>\n        <span class=\"n\">vals</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span>\n        <span class=\"n\">n</span><span class=\"o\">++;</span>\n<span class=\"o\">}</span>\n<span class=\"kd\">public</span> <span class=\"n\">Value</span> <span class=\"nf\">get</span><span class=\"o\">(</span><span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;argument to get() is null&#34;</span><span class=\"o\">);</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span> <span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">)</span> <span class=\"o\">%</span> <span class=\"n\">m</span><span class=\"o\">)</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">keys</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">equals</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span>\n                <span class=\"k\">return</span> <span class=\"n\">vals</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">];</span>\n        <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>这段符号表的实现将键和值分别保存在两个数组中（与BinarySerachST类型中一样），使用空（标记为null）来表示一簇键的结束。</p><p>如果一个新键的散列值是一个空元素，那么就将它保存在那里；如果不是，我们就顺序查找一个空元素来保存它。</p><p>要查找一个键，我们从它的散列值开始顺序查找，如果找到则命中，如果遇到空元素则未命中。</p><h3>删除操作</h3><p>如何从基于线性探索的散列表中删除一个键？我们仔细想一想就会发现，直接将该键所在的位置设为null是不行的，因为这会使得在此位置之后的元素无法被查找。</p><p>我们还可以再看上图，假设在轨迹图的例子中我们需要用这种方法删除键C，然后查找H。H的散列值为4，但它实际存储在这一簇键的结尾，即7号位置。如果我们将5号位置设为null，get()方法将无法找到H。因此我们需要将簇中被删除键的右侧的所有键重新插入散列表。</p><div class=\"highlight\"><pre><code class=\"language-text\">public void delete(Key key) {\n        if (key == null) throw new IllegalArgumentException(&#34;argument to delete() is null&#34;);\n        if (!contains(key)) return;\n\n        // find position i of key\n        int i = hash(key);\n        while (!key.equals(keys[i])) {\n            i = (i + 1) % m;\n        }\n\n        // delete key and associated value\n        keys[i] = null;\n        vals[i] = null;\n\n        // 重新散列所有键\n        i = (i + 1) % m;\n        while (keys[i] != null) {\n            // delete keys[i] an vals[i] and reinsert\n            Key   keyToRehash = keys[i];\n            Value valToRehash = vals[i];\n            keys[i] = null;\n            vals[i] = null;\n            n--;                      //此处应为减减，显示错误\n            put(keyToRehash, valToRehash);\n            i = (i + 1) % m;\n        }\n\n        n- -;                         //此处应为减减，显示错误\n\n        // 减小数组的大小\n        if (n &gt; 0 &amp;&amp; n &lt;= m/8) resize(m/2);\n        assert check();\n}</code></pre></div><p>和拉链法一样，开放地址类的散列表的性能也依赖于</p><div class=\"highlight\"><pre><code class=\"language-text\">α = N/M        //比值，</code></pre></div><p>但意义有所不同。我们将α称为<i>散列表的使用率</i>。</p><ul><li>对于基于拉链法的散列表，α是每条链表的长度，因此一般大于1；</li><li>对于基于线性探测的散列表，α是表中已被占用空间的比例，它是不可能大于1的。</li></ul><p>事实上在LinearProbingHashST中我们不允许α达到1（散列表被沾满），因为此时未命中的查找会导致无限循环。为了保证性能，我们会动态的调整数组的大小来保证使用率在<i>1/8</i>到<i>1/2</i>之间。</p><h3>键簇</h3><p>线性探索的平均成本取决于元素在插入数组后聚集成的一组连续的条目，也叫<b>键簇</b>。例如，在示例中插入键C会产生一个长度为3的键簇（A C S）。这意味着插入H需要探测4次，因为H的散列值为该键簇的第一个位置，显然，短小的键簇才能保证较高的效率。随着插入的键越来越多，这个要求很难满足，较长的键簇会越来越多。</p><h3>调整数组大小</h3><div class=\"highlight\"><pre><code class=\"language-text\">private void resize(int capacity) {\n        LinearProbingHashST&lt;Key, Value&gt; temp = new LinearProbingHashST&lt;Key, Value&gt;(capacity);\n        for (int i = 0; i &lt; m; i++) {\n            if (keys[i] != null) {\n                temp.put(keys[i], vals[i]);\n            }\n        }\n        keys = temp.keys;\n        vals = temp.vals;\n        m    = temp.m;\n}</code></pre></div><p>我们可以通过调整数组的大小来保证散列表的使用率永远不会超过1/2。</p><p>首先，我们的LinearProbingHashST需要一个新的构造函数，它接受一个固定的容量作为参数。然后，我们需要上面的resize()方法。它会创建一个新的给定大小的LinearProbingHashST，保存原表中的keys和values变量，然后将原表中所有的键重新散列并插入到新表中。这样可以使我们的数组长度发生改变。</p><p>put()方法的第一句会调用resize()来保证散列表最多为半满状态。</p><div class=\"highlight\"><pre><code class=\"language-text\">if( n &gt;= m/2 )   resize( 2 * m )</code></pre></div><p>当然在散列表过大时，我们在delete()时也需要</p><div class=\"highlight\"><pre><code class=\"language-text\">if ( n &gt; 0 &amp;&amp; n &lt;= m/8 ) resize( m/2 );</code></pre></div><p>以保证所使用的内存量和表中的键值对数量的比例总在一定范围内。动态调整数组大小可以为我们保证α不大于1/2。</p><hr/><h3>小小总结：</h3><p>拉链法和线性探测法的详细比较取决于实现的细节和用例对空间和时间的要求。即使基于性能考虑，选择拉链法而非线性探索法也不一定是合理的。</p><p>在实践中，两种方法的性能差别主要是因为拉链法为每个键值对都分配了一小块内存而线性探测则为整张表使用了两个很大的数组。对于很大的散列表，这些做法对内存管理系统的要求也很不相同。</p><p>期望散列表能够支持和数组大小无关的常数级别的查找和插入操作时可能的，对于任意的符号表实现，这个期望都是理论上最优性能。</p><p>但散列表并非包治百病，因为：</p><ul><li>每种类型的键都需要一个优秀的散列函数</li><li>性能保证来自于散列函数的质量</li><li>散列函数的计算可能复杂而且昂贵</li><li>难以支持有序性相关的符号表操作。</li></ul>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "哈希函数", 
                    "tagLink": "https://api.zhihu.com/topics/19631819"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62137071", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 1, 
            "title": "基于拉链法的散列表", 
            "content": "<p>请先参考<a href=\"https://zhuanlan.zhihu.com/p/62133064\" class=\"internal\">深入了解散列表</a></p><hr/><h3>什么是基于拉链法的散列表？</h3><p>对于散列算法的碰撞处理，一种直接的办法就是将大小为M的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。</p><p>这种方法称为拉链法，因为发生冲的元素都被存储在链表中。</p><p>这个方法的基本思想就是<b><i>选择足够大的M，使得所有的链表都尽可能的短以保证高效地查找</i></b>。</p><h3>基于拉链法的散列表的查找方法：</h3><ol><li>首先根据散列值找到对应的链表，</li><li>然后沿着链表顺序查找相应的键。</li></ol><h3>拉链法的一种实现方法</h3><ol><li>使用原始的链表数据类型。</li><li>采用一般性的策略（<i>但效率稍低</i>），为M个元素分别构建符号表来保存散列到这里的键。</li></ol><h3>拉链法中链的平均长度</h3><p>因为我们要用M条链表保存N个键，无论键在各个链表中的分布如何，链表的平均长度肯定为</p><div class=\"highlight\"><pre><code class=\"language-text\">N/M</code></pre></div><p>例如，假设所有的键都落在了第一条链表上，所有链表的平均长度仍然</p><div class=\"highlight\"><pre><code class=\"language-text\">（N+0+0+0+…+0）/M  = N/M。</code></pre></div><p>拉链法在实际情况中很有用，因为每条链表确实都大约有N/M个键值对。在一般情况中，我们能够依赖这种高效的查找和插入操作。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-bee4586e8c55dcced87a086a314d3759_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"388\" data-rawheight=\"316\" class=\"content_image\" width=\"388\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;388&#39; height=&#39;316&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"388\" data-rawheight=\"316\" class=\"content_image lazy\" width=\"388\" data-actualsrc=\"https://pic2.zhimg.com/v2-bee4586e8c55dcced87a086a314d3759_b.jpg\"/></figure><hr/><h3>代码实现</h3><div class=\"highlight\"><pre><code class=\"language-text\">public class SeparateChainingHashST&lt;Key, Value&gt; {\n    private static final int INIT_CAPACITY = 4;\n\n    private int n;                                // 键值对的总数\n    private int m;                                // 散列表的大小\n    private SequentialSearchST&lt;Key, Value&gt;[] st;  // 存放链表对象的数组\n\n    public SeparateChainingHashST() {             //无参构造\n        this(997);\n    } \n    public SeparateChainingHashST(int m) {       //有参构造\n        this.m = m;                              //创建M条链表\n        st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m];\n        for (int i = 0; i &lt; m; i++)\n            st[i] = new SequentialSearchST&lt;Key, Value&gt;();\n    } \n\n private int hash(Key key) {                       //获得键的hash值\n        return (key.hashCode() &amp; 0x7fffffff) % m;\n    } \n public Value get(Key key) {                       //获取符号表中的指定键\n        int i = hash(key);\n        return st[i].get(key);\n    } \n public void put(Key key, Value val) {             //存放一个键值对到符号表\n        if (val == null) {\n            delete(key);\n            return;\n        }\n        //如果列表的平均长度&gt;= 2，则将表大小增加一倍\n        if (n &gt;= 10*m) resize(2*m);\n        int i = hash(key);\n        if (!st[i].contains(key)) n++;\n        st[i].put(key, val);\n    } \n public Iterable&lt;Key&gt; keys() {                      //返回符号表中键的迭代器\n        Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();\n        for (int i = 0; i &lt; m; i++) {\n            for (Key key : st[i].keys())\n                queue.enqueue(key);\n        }\n        return queue;\n    } </code></pre></div><p>这段简单的符号表实现维护着一条链表的数组，用散列表来为每个键选择一条链表。简单起见，我们使用了SequentialSearchST。在创建st[]时需要进行类型转换，因为Java不允许泛型的数组。默认的构造函数会使用997条链表，因为对于较大的符号表，这种实现比SequentialSearchST大约快1000倍。当你能够预知需要的符号表大小时，这种短小精悍的方案能够得到不错的性能。</p><p>一种更可靠的方案是动态调整链表数组的大小，这样无论在符号表中有多少键值对都能保证链表较短。</p><h3>散列表的大小</h3><p>在实现基于拉链法的散列表时，我们的目标是选择适当的数组大小M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费大量时间。对于拉链法来说这并不是关键性的选择。</p><p>如果存入的键多余预期，查找所需的时间只会比选择更大的数组稍长；如果少于预期，虽然有些空间浪费但查找会非常快。</p><p>当内存不是很紧张时，可以选择一个足够大的M,使得查找所选要的时间变为常数；当内存紧张时，选择尽量大的M仍然能够将性能提高M倍。</p><h3>删除操作</h3><p>要删除一个键值对，先用散列值找到含有该键的SequentialSearchST对象，然后调用该对象的delete()方法。</p><div class=\"highlight\"><pre><code class=\"language-java\">  <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">delete</span><span class=\"o\">(</span><span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">key</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;argument to delete() is null&#34;</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">hash</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">st</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">contains</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">))</span> <span class=\"n\">n</span><span class=\"o\">--;</span>\n        <span class=\"n\">st</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">].</span><span class=\"na\">delete</span><span class=\"o\">(</span><span class=\"n\">key</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 如果列表的平均长度&lt;= 2，则将表大小减半\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">m</span> <span class=\"o\">&gt;</span> <span class=\"n\">INIT_CAPACITY</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">n</span> <span class=\"o\">&lt;=</span> <span class=\"n\">2</span><span class=\"o\">*</span><span class=\"n\">m</span><span class=\"o\">)</span> <span class=\"n\">resize</span><span class=\"o\">(</span><span class=\"n\">m</span><span class=\"o\">/</span><span class=\"n\">2</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> </code></pre></div><h3>有序性相关操作</h3><p>散列最主要的目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了。如果你需要快速找到最大键或者最小键，或是查找某个范围内的键，散列表都不是合适的选择，因为这些操作的时间都是线性的。</p><hr/><h3>小小总结：</h3><p>基于拉链法的散列表的实现简单。在键的顺序并不重要的应用中。它可能是最快的（也是使用最广泛的）符号表实现。</p>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/62133064", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 0, 
            "title": "深入了解散列表", 
            "content": "<p>本次介绍主要为后面的基于<i><b>拉链法</b></i>和基于<i><b>线性探索法</b></i>的两种散列表做铺垫。谢谢大家！^.^</p><hr/><h2>什么是散列表？</h2><p>如果所有的键都是小整数，我们可以用一个数组来实现无序的符号表，将键作为数组的索引而数组中键i处储存的就是它对应的值。这样我们就能快速访问任意键的值。</p><p>散列表就是这种简易方法的扩展并能够处理更加复杂类型的键。我们需要用算数操作将键转化为数组的索引来访问数组中的键值对。</p><p>使用散列表的查找算法分为两步。</p><ol><li>第一步是用散列函数将被查找的键转化为数组的一个索引。理想情况下，不同的键都能被转化为不同的索引值。当然这只是理想情况，所以我们需要面对两个或者多个键都会散列到相同的索引值的情况。</li><li>因为第一步中存在的碰撞情况。第二步就需要一个处理碰撞冲突的过程，两种解决碰撞的方法：拉链法和线性探索法。</li></ol><p>散列表是算法在<b>时间</b>和<b>空间</b>上作出权衡的经典例子，事实上，我们不必重写代码，只需要调整散列算法的参数就可以在空间和时间是进行取舍。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-75aefbc8593b7f0f4ba4d72ed3a497dc_b.png\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"298\" class=\"content_image\" width=\"198\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;198&#39; height=&#39;298&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"198\" data-rawheight=\"298\" class=\"content_image lazy\" width=\"198\" data-actualsrc=\"https://pic1.zhimg.com/v2-75aefbc8593b7f0f4ba4d72ed3a497dc_b.png\"/><figcaption>散列表的核心问题</figcaption></figure><h3>散列函数</h3><p>我们面临的第一个问题就是散列函数的计算，这个过程会将键转化为数组的索引。</p><p>如果我们有一个能够保存M个键值对的数组，那么我们就需要一个能够将任意键转化为该数组范围内的索引的散列函数。我们要找的散列函数应该易于计算并且能够均匀分布所有的键，即对于所有的键，0到M-1之间的每个整数都有相等的可能性与之对应（与键无关）。</p><hr/><h3>对于求键的散列值，因为键有很多种类型：Integer、String、Double等。我们需要根据键的类型选择合适的求值方法！</h3><h3>键为正整数求散列值</h3><p>将整数散列最常用的方法是<b>除留余数法</b>。</p><p>我们选择大小为素数M的数组，对于任意正整数k，计算k除以M的余数（在Java中为k%M）。如果M不为素数，我们可能无法利用键中包含的所有信息，这将导致我们无法均匀地散列散列值。例如键是十进制数而M为10。那么我们只能利用键的个位进行散列。</p><h3>键为浮点数求散列值</h3><p>如果键是0到1之间的实数，我们可以将它乘以M并四舍五入得到一个0至M-1之间的索引值。</p><p>尽管这个方法容易理解并且容易实现，但它是由缺陷的，因为这种情况下键的高位起的作用更大，低位对散列结果没有影响。修正这个问题的办法是将键表示为二进制数然后使用除留余数法（Java就是如此）。</p><h3>键为字符串求散列值</h3><p>除留余数法也可以处理较长的键，就比如说字符串，我们只需要将它们当作大整数即可。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kt\">int</span> <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">();</span> <span class=\"n\">i</span><span class=\"o\">++)</span>\n    <span class=\"n\">hash</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">R</span> <span class=\"o\">*</span> <span class=\"n\">hash</span> <span class=\"o\">+</span> <span class=\"n\">s</span><span class=\"o\">.</span><span class=\"na\">charAt</span><span class=\"o\">(</span><span class=\"n\">i</span><span class=\"o\">))</span> <span class=\"o\">%</span> <span class=\"n\">M</span><span class=\"o\">;</span></code></pre></div><p>Java的charAt()函数能够返回一个char值，即一个非负16整数。如果R比任何字符的值都大，这种计算相当于将字符串当作一个N位的R进制值，将它除以M取余。</p><p>一种叫做Horner方法的经典算法用N次乘法、加法和取余来计算一个字符串的散列值。只要R足够小，不造成溢出，那么结果就能如我们所愿，落在0至M-1之内。使用一个较小的素数，例如31，可以保证字符串中所有字符都能发挥作用。Java的String的默认实现使用了一个类似的方法。</p><h3>键为组合键求散列值</h3><p>如果键的类型含有多个整型变量，我们可以和String类型一样将它们混合起来。</p><p>例如假如被查找的键的类型是Date，其中含有几个整型域：day（两个数字表示的日），month（两个数字表示的月）和year（4个数字表示的年）。我们可以这样计算它的散列值：</p><div class=\"highlight\"><pre><code class=\"language-text\">int hash = (((day * R + month) % M) * R + year) % M;</code></pre></div><hr/><h3>Java中的约定情况</h3><p>每种数据类型都需要相应的散列值，于是Java令所有的数据类型都继承了一个能够返回一个32比特整数的hashCode()方法。</p><p>每一种数据类型的hashCode()方法都必须和equals()方法一致。这说明如果你要为自定义的数据类型定义散列函数，那么需要同时重写hashCode()和equals()两个方法。默认散列函数会返回内存地址，但这只适用很少的情况。</p><p>将hashCode()的返回值转化为一个数组索引，因为我们需要的是数组的索引值而不是一个32位的整数，我们在实现中会将默认的hashCode()方法和除留余数法结合起来产生一个0到M-1的整数，</p><div class=\"highlight\"><pre><code class=\"language-text\">private int hash(Key key) {\n   return (key.hashCode() &amp; 0x7fffffff) % M;\n}</code></pre></div><p>这段代码会将符号位屏蔽（将一个32位整数变为一个31位非负整数），然后用除留余数法计算它除以M的余数。在使用这样的代码时我们一般会将数组的大小M取为素数以充分利用原散列值的所有位。</p><h3>自定义的hashCode()方法</h3><p>散列表的用例hashCode()方法能够将键平均地散布为所有可能的32位整数。也就是说，对于任意对象x，可以调用x. hashCode()并认为有均等机会得到2^32个不同整数中的任意一个32位整数值。</p><div class=\"highlight\"><pre><code class=\"language-text\">//String实现的hashCode（）\n  public int hashCode() {\n        int h = hash;\n        if (h == 0 &amp;&amp; value.length &gt; 0) {\n            char val[] = value;\n\n            for (int i = 0; i &lt; value.length; i++) {\n                h = 31 * h + val[i];\n            }\n            hash = h;\n        }\n        return h;\n}</code></pre></div><h3>软缓存</h3><p>如果散列值的计算很耗时，那么我们也许可以将每个键的散列值缓存起来，即在每个键中使用一个hash变量来保存它的hashCode()的返回值。第一次调用hashCode()方法时，我们需要计算对象的散列值，但之后对hashCode()方法调用会直接返回hash变量的值。如上Java的String对象的hashCode()方法就使用了这种方法来减少计算量。</p><hr/><h3>小小总结：</h3><p>总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件</p><ul><li><b>一致性 </b>—— 等价的键必然产生相等的散列值</li><li><b>高效性</b> —— 计算简便</li><li><b>均匀性</b> —— 均匀的散列所有的键</li></ul>", 
            "topic": [
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61895842", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 29, 
            "title": "深入理解红黑树（数据结构）", 
            "content": "<p>红黑二叉查找树是一种数据结构，即为实现2-3树而存在。对于之前的2-3树的插入算法并不难理解，下面将介绍红黑二叉查找树的简单数据结构来表达并实现它。实现红黑二叉查找树的意义在于能够二叉查找树中简洁高效的查找方法和2-3树中中高效的平衡插入算法结合起来。</p><h3>1、替换3-结点</h3><p>红黑二叉查找树背后的基本思想使用标准的二叉查找树（完全由2-结点构成）和一些额外的信息（替换3-结点）来表示2-3树。我们将树的链接分为两种类型：红链接将两个2-结点连接起来构成一个3-结点，黑链接则是2-3树中的普通链接。确切的说，我们将3-结点表示为由一条左斜的红色链接相连的两个2-结点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-496fe5165c94850613d00e8a03c4d940_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"229\" class=\"content_image\" width=\"260\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;260&#39; height=&#39;229&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"260\" data-rawheight=\"229\" class=\"content_image lazy\" width=\"260\" data-actualsrc=\"https://pic1.zhimg.com/v2-496fe5165c94850613d00e8a03c4d940_b.jpg\"/></figure><p>这种表示法的一个优点是，我们无需修改就可以直接使用标准二叉查找树的get()方法。</p><p>对于任意的2-3树，只要对结点进行转换，我们都可以立即派生出一棵对应的二叉查找树，我们用这种方式表示2-3树的二叉查找树成为红黑二叉查找树（简称红黑树）。</p><h3>2、一种等价的定义</h3><p>红黑树的另一种定义是含有红黑链接并满足下列条件的二叉查找树：</p><ul><li>红链接均为左链接。</li><li>没有任何一个结点同时和两条红链接相连。</li><li>该树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同。</li></ul><p>满足这样定义的红黑树和相应的2-3树是一一对应的。</p><h3>3、一一对应</h3><p>如果我们将一棵红黑树中的红链接画平，那么所有的空链接到根节点的距离都是相同的。如果我们将由红链接相连的两个2-结点合并，得到的就是一棵2-3树。相反，如果将一棵2-3树中的3-结点画作由红色左链接相连的两个2-结点，那么不会存在能够和两条红链接相连的结点，且树必然是完美黑色平衡的，因为黑链接即为2-3树中的普通链接。</p><h3>4、颜色表示</h3><p>方便起见，因为每个结点都只会有一条指向自己的链接（从它的父节点指向它），我们将链接的颜色保存在表示结点的Node数据类型的布尔变量color中。如果指向它的链接是红色的，那么该变量为true，黑色则为false。如如下代码所示：</p><div class=\"highlight\"><pre><code class=\"language-text\">private static final boolean RED   = true;\nprivate static final boolean BLACK = false;\nprivate class Node {\n        private Key key;           // 值\n        private Value val;         // 相关联的值\n        private Node left, right;  // 左右子树\n        private boolean color;     // 由其父节点指向它链接的颜色\n        private int size;          // 这棵子树中结点总数\n\n        public Node(Key key, Value val, boolean color, int size) {\n            this.key = key;\n            this.val = val;\n            this.color = color;\n            this.size = size;\n        }\n}\nprivate boolean isRed(Node x) {\n        if (x == null) return false;\n        return x.color == RED;\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-eddb38d3b0d24131d7e081342b24ee1d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"307\" data-rawheight=\"339\" class=\"content_image\" width=\"307\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;307&#39; height=&#39;339&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"307\" data-rawheight=\"339\" class=\"content_image lazy\" width=\"307\" data-actualsrc=\"https://pic2.zhimg.com/v2-eddb38d3b0d24131d7e081342b24ee1d_b.jpg\"/></figure><h3>5、旋转（保持平衡的核心）</h3><p>在我们实现的某些操作中可能会出现红色右链接或者连续的红链接，但在操作完成前这些情况都会小心地旋转并修复。旋转操作会改变红链接的指向。</p><p>假设，我们有一条红色的右链接需要被转换为左链接。这个操作叫做左旋转，它对应的方法接受一条指向红黑树中的某个结点的链接作为参数。假设被指向的结点的右链接是红色的，这个方法会对树进行必要的调整并返回一个指向包含同一组键的子树且其左链接为红色的根节点的链接。具体步骤，可以参考下图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-52c58b9a2a6e60ffdbe513a3b50e4aa7_b.jpg\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"436\" class=\"content_image\" width=\"203\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;203&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"436\" class=\"content_image lazy\" width=\"203\" data-actualsrc=\"https://pic4.zhimg.com/v2-52c58b9a2a6e60ffdbe513a3b50e4aa7_b.jpg\"/><figcaption>左旋转</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-fe3887dc55f8149878153f2dc7ad48fb_b.png\" data-size=\"normal\" data-rawwidth=\"197\" data-rawheight=\"430\" class=\"content_image\" width=\"197\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;197&#39; height=&#39;430&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"197\" data-rawheight=\"430\" class=\"content_image lazy\" width=\"197\" data-actualsrc=\"https://pic4.zhimg.com/v2-fe3887dc55f8149878153f2dc7ad48fb_b.png\"/><figcaption>右旋转</figcaption></figure><h3>6、在旋转后重置父节点的链接</h3><p>无论左旋还是右旋，旋转操作都会返回一条链接，我们总是可以用rotateRighr()和rotateLeft()的返回值重置父节点（或是根节点）中相应的链接。通过转换，可能会出现其他情况：比如产生两条连续的红链接。这不用担心，我们的算法会继续用旋转修正这种情况。  </p><h3>7、向单个2-结点中插入新键</h3><p>一棵只含一个键的红黑树只含由一个2-结点，插入另一个键之后，我们马上就需要将它们旋转。</p><p>如果新键小于老键，我们只需要增加一个红色结点即可，新的红黑树和单个3-结点完全等价。</p><p>如果新键大于老键，那么新增的红色结点将会产生一个红色的右链接。我们需要使用 root=rotateLeft(root);来将其旋转为红色左链接并修正根节点链接，插入操作才算完成。</p><h3>8、向树底部的2-结点插入新键</h3><p>用和二叉查找树相同的方式向一棵红黑树中插入一个新键会在树的底部新增一个结点，但总是用红链接将新节点与它的父节点相连。</p><p>如果它的父节点是一个2-结点，那么上面讨论的两种方式仍然有效。</p><p>如果指向新结点的是父节点的左链接，那么父节点就直接成为一个3-结点；</p><p>如果指向新结点的是父节点的右链接，这就是一个错误的3-结点，但一次左旋就可以修正它。</p><h3>9、向一棵双键树（即一个3-结点）中插入新键</h3><p>这种情况下有可分为三种子情况：新键小于树中两键，在两者之间，大于树中两键。</p><ul><li>最简单的情况就是新键大于原树中的两个键，因此它被连接到3-结点的右链接。此时树是平衡的，根结点为中间大小的键，它有两条红链接分别和较小和较大的结点相连。如果我们将两条链接的颜色都由红变黑，那么我们得到一棵由三个结点组成，高度为2的平衡树。</li><li>如果新键小于原树中的两个键，它会被链接到最左边的空链接，这就产生了两条连续的红链接，我们只需将上层的红链接右旋即可得到第一种情况。</li><li>如果新键介于原树中的两个键之间，这又会产生两条连续的红链接，一条红色左链接接一条红色右链接，我们只需下层的红链接左旋即可得到第二种情况。</li></ul><h3>10、颜色转换</h3><p>我们专门用一个方法flipColor()来转换一个结点的两个红色子节点的颜色。除了将子节点的颜色由红变黑之外，我们同时还需要将父结点的颜色由黑变红。这项操作的重要性质在于它和旋转操作一样是局部变换，不会影响整棵树的黑色平衡性。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ed268e5bf6966fac20e9fe6ca97e43dd_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"238\" data-rawheight=\"386\" class=\"content_image\" width=\"238\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;238&#39; height=&#39;386&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"238\" data-rawheight=\"386\" class=\"content_image lazy\" width=\"238\" data-actualsrc=\"https://pic2.zhimg.com/v2-ed268e5bf6966fac20e9fe6ca97e43dd_b.jpg\"/></figure><h3>11、根节点总是黑色的</h3><p>颜色转换会是根节点变为红色。这也可能出现在很大的红黑树中。严格来说，红色的根节点说明根节点是一个3-结点的一部分，但实际情况并不是这样。因此我们在每次插入后都会将根节点颜色设为黑色。</p><div class=\"highlight\"><pre><code class=\"language-text\">//红黑树的插入算法\npublic void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(&#34;first argument to put() is null&#34;);\n        if (val == null) {\n            delete(key);\n            return;\n        }\n\n        root = put(root, key, val);\n        root.color = BLACK;\n        // assert check();\n    }\nprivate Node put(Node h, Key key, Value val) { \n        if (h == null) return new Node(key, val, RED, 1);\n\n        int cmp = key.compareTo(h.key);\n        if      (cmp &lt; 0) h.left  = put(h.left,  key, val); \n        else if (cmp &gt; 0) h.right = put(h.right, key, val); \n        else              h.val   = val;\n\n        // fix-up any right-leaning links\n        if (isRed(h.right) &amp;&amp; !isRed(h.left))      h = rotateLeft(h);\n        if (isRed(h.left)  &amp;&amp;  isRed(h.left.left)) h = rotateRight(h);\n        if (isRed(h.left)  &amp;&amp;  isRed(h.right))     flipColors(h);\n        h.size = size(h.left) + size(h.right) + 1;\n\n        return h;\n}</code></pre></div><h3>删除操作：</h3><p>在了解删除前，我们需要先了解一下<i>2-3-4树的插入算法</i>，2-3-4树中允许出现之前未出现过的4-结点。它的插入算法沿查找路径向下进行变换是为了保证当前结点不是4-结点（这样树底才有空间来插入新的键），沿着路径向上进行变换是为了将之前创建的4-结点配平。</p><p>当删除一个3-结点时，我们可以直接删除。</p><p>而删除2-结点时则不然。当从2-结点删除一个键时会留下一个空结点。 如果我们将它替换为一个空链接，这样的话会破坏树的完美平衡性。</p><p>为了保证我们不会删除一个2-结点，我们沿着左链接向下变换，确保当前结点不是2-结点。首先根节点可能有两种情况。</p><p>如果根是2-结点且它的两个子节点都是2-结点，我们可以直接将这三个结点变成一个4-结点；否则我们需要保证根节点的左子结点不是2-结点，如果有必要可以从它右侧的兄弟结点“借”一个键来。通过如此，我们可以得到一个3-结点或者4-结点，然后我们就可以直接将其删除。</p><h2>性质总结</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3b1c846d0b18dc13927eb2d5f41e2895_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"338\" class=\"origin_image zh-lightbox-thumb\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-3b1c846d0b18dc13927eb2d5f41e2895_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;726&#39; height=&#39;338&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"726\" data-rawheight=\"338\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"726\" data-original=\"https://pic2.zhimg.com/v2-3b1c846d0b18dc13927eb2d5f41e2895_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-3b1c846d0b18dc13927eb2d5f41e2895_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "红黑树", 
                    "tagLink": "https://api.zhihu.com/topics/19648609"
                }, 
                {
                    "tag": "数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19591797"
                }, 
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61631654", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 5, 
            "title": "深入理解平衡查找树", 
            "content": "<p>本次所写的平衡查找树完全是为了后面的红黑树做铺垫。</p><hr/><p>平衡二叉树已经能够更好地用于许多应用程序中，但是在最坏的情况下的性能还是很糟糕</p><p>理想情况下我们希望能够保持二分查找树的平衡性，在一棵含有N个结点的树中，我们希望树的高度为<i>~lgN</i>，这样我们就能保证所有查找都能在<i>~lgN</i>次比较内结束。</p><h2>2-3查找树</h2><p>为了保证查找树的平衡性，我们需要一些灵活性。</p><p>我们将一棵标准二叉树中的结点称为2-结点（含有一个键和两条链接），而现在我们需要加入3-结点，它含有两个键和三条链接。如图所示：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-37198c8d378490fb8c24a56fbb6ba2c2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"148\" class=\"content_image\" width=\"203\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;203&#39; height=&#39;148&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"203\" data-rawheight=\"148\" class=\"content_image lazy\" width=\"203\" data-actualsrc=\"https://pic3.zhimg.com/v2-37198c8d378490fb8c24a56fbb6ba2c2_b.jpg\"/></figure><p>一棵2-3查找树或为一棵空树，或者由以下结点组成：</p><ul><li><b>2-结点</b>，含有一个键（及其对应的值）和两条链接，左链接指向的2-3树中的键都小于该结点，右链接指向的2-3树中的键都大于该结点。</li><li><b>3-结点</b>，含有两个键（及其对应的值）和三条链接，左链接指向的2-3树中的键都小于该结点，中键指向的2-3树种的键都位于该结点的两个键之间，右链接指向的2-3树中的键都大于该结点。</li></ul><p><b><i>一棵完美平衡的2-3查找树中的所有空链接到根结点的距离都应该是相同的。</i></b></p><h3>查找</h3><p>参考二叉查找树，我们可以推算出2-3平衡树的查找算法。要判断一个键是否在树中，我们先将它和根结点中的键比较。如果和其中一个键相等，查找命中。否则我们就根据比较的结果找到指向相应区域的链接，并在其指向的子树中递归的继续查找。如果这是个空链接，查找未命中。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7d7c5c6ebe993bb7065c4bd2ff62e93c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"344\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-7d7c5c6ebe993bb7065c4bd2ff62e93c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;344&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"344\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic1.zhimg.com/v2-7d7c5c6ebe993bb7065c4bd2ff62e93c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7d7c5c6ebe993bb7065c4bd2ff62e93c_b.jpg\"/></figure><h3>向2-结点中插入新键</h3><p>要在2-3树中插入一个新结点，我们可以二叉查找树一样先进行一次未命中的查找，然后把新结点挂在树的底部。但这样的话树无法保持完美平衡性。我们使用2-3树的主要原因就在于它能够在插入后继续保持平衡。如果未命中的查找结束于一个2-结点：那么我们只需要把这个2-结点替换为一个3-结点，将要插入的键保持其中即可。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-39944dcad78f3f4dc16d3952c543e56e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"233\" data-rawheight=\"241\" class=\"content_image\" width=\"233\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;233&#39; height=&#39;241&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"233\" data-rawheight=\"241\" class=\"content_image lazy\" width=\"233\" data-actualsrc=\"https://pic3.zhimg.com/v2-39944dcad78f3f4dc16d3952c543e56e_b.jpg\"/></figure><h3>向一棵只含有一个3-结点的树中插入新键</h3><p>为了新键的插入，我们先临时将新键存入该结点中，使之成为一个4-结点。它很自然地扩展了以前的结点并含有3个键和4条链接。创建一个4-结点很方便。因为很容易将它转换为一棵由3个2-结点组成的2-3树，其中一个结点（根）含有中键，一个结点含有3个键中的最小者（和根结点的左链接相连），一个结点含有3个键中的最大者（和根结点是右链接相连）。插入前树的高度为0，插入后树的高度为1。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1c3119c0da65c4159e7d00a7df0cd772_b.png\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"185\" data-rawheight=\"182\" class=\"content_image\" width=\"185\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;185&#39; height=&#39;182&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"185\" data-rawheight=\"182\" class=\"content_image lazy\" width=\"185\" data-actualsrc=\"https://pic3.zhimg.com/v2-1c3119c0da65c4159e7d00a7df0cd772_b.png\"/></figure><h3>向一个父结点为2-结点的3-结点中插入新键</h3><p>这种情况下我们需要在维持树的完美平衡的前提下为新键腾出空间。我们先像刚才一样构造一个临时的4-结点并将其分解，但此时我们不会为中键创建一个新结点，而是将其中移动至原来的父结点中。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-090c0cd73f14adc80662090d72f92279_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"363\" class=\"content_image\" width=\"283\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;283&#39; height=&#39;363&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"363\" class=\"content_image lazy\" width=\"283\" data-actualsrc=\"https://pic2.zhimg.com/v2-090c0cd73f14adc80662090d72f92279_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>向一个父结点为3-结点的3-结点中插入新键</h3><p>我们再次和刚才一样构造一个临时的4-结点并分解它，然后将它的中键插入它的父结点中。因为父结点也是一个3-结点，因此我们需要再次做如上变换。直至遇到一个2-结点并将它替换成一个不需要继续分解的3-结点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-07d7d68e09d0747cfad2bd7fdd286b62_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"508\" class=\"content_image\" width=\"279\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;279&#39; height=&#39;508&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"279\" data-rawheight=\"508\" class=\"content_image lazy\" width=\"279\" data-actualsrc=\"https://pic3.zhimg.com/v2-07d7d68e09d0747cfad2bd7fdd286b62_b.jpg\"/></figure><h3>分解根结点</h3><p>如果从插入结点到根结点的路径上全都是3-结点，我们的根结点最终变成一个4-结点。我们需要将这个临时的4-结点分解为3个2-结点，使树高加1。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-1ffa48dde3de6334416c2aa1a14c3584_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"210\" data-rawheight=\"436\" class=\"content_image\" width=\"210\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;210&#39; height=&#39;436&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"210\" data-rawheight=\"436\" class=\"content_image lazy\" width=\"210\" data-actualsrc=\"https://pic1.zhimg.com/v2-1ffa48dde3de6334416c2aa1a14c3584_b.jpg\"/></figure><h3>局部变换</h3><p>将一个4-结点分解成一棵2-3树可能有6中情况。算法的根本在于这些变换都是局部的：除了相关的结点和链接之外不必修改或检查树的其他部分。每次变换中，变更的链接数量不会超过一根很小的常数。</p><h3>全局性质</h3><p>局部变换不会影响树的全局有序性和平衡性：任意空链接到根结点的路径长度都是相等的。</p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "平衡二叉树", 
                    "tagLink": "https://api.zhihu.com/topics/20092111"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61605369", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 2, 
            "title": "深入理解二叉查找树", 
            "content": "<p><b><i>二叉查找树</i></b>是一种能够将链表插入的灵活性和有序数组查找的高效性结合起来的符号表实现。即使用每个结点含有两个链接（链表中每个结点之只含有一个链接）的二叉查找树来高效地实现符号表。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-7f417de4f654f7778a9aab5706627e91_b.jpg\" data-size=\"normal\" data-rawwidth=\"223\" data-rawheight=\"189\" class=\"content_image\" width=\"223\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;223&#39; height=&#39;189&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"223\" data-rawheight=\"189\" class=\"content_image lazy\" width=\"223\" data-actualsrc=\"https://pic2.zhimg.com/v2-7f417de4f654f7778a9aab5706627e91_b.jpg\"/><figcaption>详解二叉查找树</figcaption></figure><p>所使用的数据结构由结点组成，结点包含链接可以为空(null)或者指向其他结点。</p><p>一棵二叉查找树(BST)是一棵二叉树，其中每个结点都含有一个Comparable的键（以及相关联的值）且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键。</p><h2>数据表示</h2><p>和链表一样，该数据结构嵌套定义了一个私有类来表示二叉树上的一个结点。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">class</span> <span class=\"nc\">Node</span><span class=\"o\">{</span>\n\t<span class=\"kd\">private</span> <span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">;</span>\t\t\t\t<span class=\"c1\">//键\n</span><span class=\"c1\"></span>\t<span class=\"kd\">private</span> <span class=\"n\">Value</span> <span class=\"n\">val</span><span class=\"o\">;</span>\t\t\t\t<span class=\"c1\">//值\n</span><span class=\"c1\"></span>\t<span class=\"kd\">private</span> <span class=\"n\">Node</span> <span class=\"n\">left</span><span class=\"o\">,</span> <span class=\"n\">right</span><span class=\"o\">;</span>\t\t        <span class=\"c1\">//指向子树的链接\n</span><span class=\"c1\"></span>\t<span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">;</span>\t\t\t\t\t<span class=\"c1\">//以该结点为根的子树中的结点总数。\n</span><span class=\"c1\"></span>\t\t\n\t<span class=\"kd\">public</span> <span class=\"nf\">Node</span><span class=\"o\">(</span><span class=\"n\">Key</span> <span class=\"n\">key</span><span class=\"o\">,</span> <span class=\"n\">Value</span> <span class=\"n\">val</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">)</span> \n\t<span class=\"o\">{</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">key</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"o\">;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">val</span> <span class=\"o\">=</span> <span class=\"n\">val</span><span class=\"o\">;</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">N</span> <span class=\"o\">=</span> <span class=\"n\">N</span><span class=\"o\">;}</span>\n<span class=\"o\">}</span></code></pre></div><p>算法中实现的size()会将空链表N值当作0，因此就能保证以下公式对于二叉树中的任意结点x总是成立的。</p><h3> size(x) = size(x.left) + size(x.right) + 1</h3><p>一棵二叉树代表了一组键（及其相应的值）的集合，而同一个集合可以用多棵二叉树表示。</p><h2>查找</h2><p>二叉查找树的递归算法：如果树为空，则查找未命中。否则就递归地在适当的子树中继续查找，如果被查找的键较小就选择左子树，如果被查找的键较大就选择右子树。</p><p><i><b>基于二叉树的符号表</b></i></p><div class=\"highlight\"><pre><code class=\"language-text\">public class BST &lt;Key extends Comparable&lt;Key&gt;, Value&gt;{\n\tprivate Node root;\n\t\n\tprivate class Node{\n\t\tprivate Key key;\t\t\t\t//键\n\t\tprivate Value val;\t\t\t\t//值\n\t\tprivate Node left, right;\t\t        //指向子树的链接\n\t\tprivate int N;\t\t\t\t\t//以该结点为根的子树中的结点总数。\n\t\t\n\t\tpublic Node(Key key, Value val, int N) \n\t\t{\tthis.key = key; this.val = val; this.N = N;}\n\t}\n\tpublic int size() \n\t{ return size(root);}\n\t\n\tprivate int size(Node x) {\n\t\tif(x == null)\treturn 0;\n\t\telse\t\t\treturn x.N;\n\t}\n\t//二叉查找树的查找和排序方法的实现。\n\tpublic Value get(Key key)\n\n\tpublic void put(Key key, Value val) \n\t\n}</code></pre></div><h2>插入</h2><p>算法中的查找代码几乎和二分查找一样简单，这种简洁性是二叉树的重要特性之一。而二叉查找树的另一个更重要的特征就是插入的实现难度和查找差不多。当查找一个不存在于树中的结点并结束于一条空链接时，我们需要做的是将链接指向一个含有被查找键的新结点。</p><p>  使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于被插入的先后顺序。在最好的情况下，一棵含有N个结点的树是完全平衡的，每条空连接和根结点的距离都为<i>~lgN</i>。在最坏的情况下，搜素路径上可能又N个结点。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a212acc7ba4b20967e5217cc394261f1_b.png\" data-size=\"normal\" data-rawwidth=\"178\" data-rawheight=\"92\" class=\"content_image\" width=\"178\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;178&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"178\" data-rawheight=\"92\" class=\"content_image lazy\" width=\"178\" data-actualsrc=\"https://pic2.zhimg.com/v2-a212acc7ba4b20967e5217cc394261f1_b.png\"/><figcaption>最好情况</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-463347921a14d2eb380d9c9354dbf361_b.png\" data-size=\"normal\" data-rawwidth=\"167\" data-rawheight=\"111\" class=\"content_image\" width=\"167\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;167&#39; height=&#39;111&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"167\" data-rawheight=\"111\" class=\"content_image lazy\" width=\"167\" data-actualsrc=\"https://pic2.zhimg.com/v2-463347921a14d2eb380d9c9354dbf361_b.png\"/><figcaption>一般情况</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-696789895aae2115267e0726379fde06_b.png\" data-size=\"normal\" data-rawwidth=\"151\" data-rawheight=\"135\" class=\"content_image\" width=\"151\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;151&#39; height=&#39;135&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"151\" data-rawheight=\"135\" class=\"content_image lazy\" width=\"151\" data-actualsrc=\"https://pic3.zhimg.com/v2-696789895aae2115267e0726379fde06_b.png\"/><figcaption>最坏情况</figcaption></figure><div class=\"highlight\"><pre><code class=\"language-text\">public Value get(Key key)\n\t{\treturn get(root, key);\t}\nprivate Value get(Node x, Key key) {\n\t//在以x为根结点的子树中查找并返回key所对应的值\n\t//如果找不到则返回null\n\tif(x == null)\treturn null;\n\tint cmp = key.compareTo(x.key);\n\tif\t\t(cmp &lt; 0)\treturn get(x.left, key);\n\telse if        (cmp &gt; 0) \treturn get(x.right, key);\n\telse  \t\t\t\treturn x.val;\n}\npublic void put(Key key, Value val) {\n\t//查找key,找到则更新它的值，否则为他创建一个新的结点\n\troot = put(root, key, val);\n}\nprivate Node put(Node x, Key key, Value val) {\n\t//如果key存在于以x为根结点的子树中则更新它的值;\n\t//否则将以key和val为键值对的新结点插入到该子树中\n\tif(x == null)\treturn new Node(key, val, 1);\n\tint cmp = key.compareTo(x.key);\n\tif\t\t(cmp &lt; 0)\tx.left = put(x.left, key, val);\n\telse if (cmp &gt; 0)\tx.right = put(x.right, key, val);\n\telse\tx.val = val;\n\tx.N = size(x.left) + size(x.right) + 1;\n\treturn x;\n}</code></pre></div><h3>最大键和最小键</h3><p>如果根结点的左链接为空，那么一棵二叉查找树中最小键就是根结点；如果左链接非空，那么树中的最小键就是左子树的最小键。最大键类似。</p><h3>向上取整和向下取整</h3><p>如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键floor(key)一定在根结点的左子树中；如果给定的键key大于二叉树根结点，那么只有当根结点右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树中，否则根节点就是小于等于key的最大键。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-5affc2b5fe54b6e79de785768d783bc4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"490\" class=\"content_image\" width=\"254\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;254&#39; height=&#39;490&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"254\" data-rawheight=\"490\" class=\"content_image lazy\" width=\"254\" data-actualsrc=\"https://pic1.zhimg.com/v2-5affc2b5fe54b6e79de785768d783bc4_b.jpg\"/></figure><p>二叉查找树的其他方法实现</p><div class=\"highlight\"><pre><code class=\"language-text\">public Key min() {\n\t\treturn min(root).key;\n}\nprivate Node min(Node x) {\n\tif(x.left == null)\treturn x;\n\treturn min(x.left);\n}\npublic Key max() {\n\treturn max(root).key;\n}\nprivate Node max(Node x) {\n\tif(x.right == null)\treturn x;\n\treturn max(x.right);\n}\npublic Key floor(Key key) {\n\tNode x = floor(root,key);\n\tif(x == null)\treturn null;\n\treturn x.key;\n}\nprivate Node floor(Node x, Key key) {\n\tif(x == null)\treturn null;\n\tint cmp = key.compareTo(x.key);\n\tif(cmp == 0)\treturn x;\n\tif(cmp &lt; 0)\t\treturn floor(x.left, key);\n\tNode t = floor(x.right, key);\n\tif(t != null) \treturn t;\n\telse\t\t\treturn x;\n}</code></pre></div><h3>排名</h3><p>rank()是select()的逆方法，它会返回给定键的排名。它的实现和select()类似：如果给定的键和根节点的键相等，我们返回左子树中的结点总数t；如果给定的键小于根节点，我们会返回改键在左子树中的排名（递归计算）；如果给定的键大于根节点，我们会返回t+1（根节点）加上他在右子树中的排名（递归计算）</p><div class=\"highlight\"><pre><code class=\"language-text\">//二叉树中select()和rank()方法的实现\npublic Key select(int k) {\n\treturn select(root, k).key;\n}\nprivate Node select(Node x, int k) {\n\t//返回排名为k的节点\n\tif\t(x == null)\t\treturn null;\n\tint t = size(x.left);\n\tif\t\t(t &gt; k)\t\treturn select(x.left, k);\n\telse if  \t(t &gt; k)\t\treturn select(x.right, k);\n\telse\t\t\t\treturn x;\n}\npublic int rank(Key key) {\n\treturn rank(key, root);\n}\nprivate int rank(Key key, Node x) {\n\t//返回以x为根节点的子树中小于x.key的键的数量\n\tif\t(x == null)\t\treturn 0;\n\tint cmp = key.compareTo(x.key);\n\tif\t\t(cmp &lt; 0)\treturn rank(key, x.left);\n\telse if\t(cmp &gt; 0)\treturn 1 + rank(key, x.left) + rank(key, x.right);\n\telse\t\t\t\treturn size(x.left);\n}</code></pre></div><h3>删除最大键和最小键</h3><p>删除可能是二叉树中最难实现的方法了，如何才能删除一个拥有两个子结点的结点？删除之后我们要处理两棵子树，但被删除结点的父结点只有一条空出来的链接。</p><p>T.hibbard在1962年提出解决这个难题的第一个方法。在删除结点x后用它的后继结点填补它的位置。因为x有一个右子节点，因此它的后继结点就是其右子树的最小结点。这样的替换仍然能保证树的有序性，因为x.key和它的后继结点的键之间不存在其他的键。我们可以用以下四个步骤完成x的替换</p><p>a、将指向将被删除的结点链接保存为t</p><p>b、将x指向它的后继结点min(t.right)</p><p>c、将x的右节点（原本指向一棵所有结点都大于x.key的二叉查找树）指向deleteMin(t.right)，也就是在删除后所有结点仍然都大于x.key的子二叉树；</p><p>d、将x的左链接（本为空）设为t.left（其下所有的键都小于被删除的结点和它的后继结点）</p><div class=\"highlight\"><pre><code class=\"language-text\">public void deleteMin(){\t\n\troot = deleteMin(root);\t\n}\nprivate Node deleteMin(Node x) {\n\tif(x.left == null) return x.right;\n\tx.left = deleteMin(x.left);\n\tx.N = size(x.left) + size(x.right) + 1;\n\treturn x;\n}\npublic void delete(Key key) {\n\troot = delete(root, key);\n}\nprivate Node delete(Node x, Key key) {\n\tif\t(x == null)\t\treturn null;\n\tint cmp = key.compareTo(x.key);\n\tif\t\t\t(cmp &lt; 0) \tx.left = delete(x.left, key);\n\telse if\t\t        (cmp &gt; 0)\tx.right = delete(x.right, key);\n\telse {\n\t\tif\t(x.right == null)\treturn x.left;\n\t\tif\t(x.left == null)\treturn x.right;\n\t\tNode t = x;\n\t\tx = min(t.right);\n\t\tx.right = deleteMin(t.right);\n\t\tx.left = t.left;\n\t}\n\tx.N = size(x.left) + size(x.right) + 1;\n\treturn x;\n}</code></pre></div><h3>范围查找</h3><div class=\"highlight\"><pre><code class=\"language-text\">//二叉查找树的范围查找操作\npublic Iterable&lt;Key&gt; keys(){\n\treturn keys(min(), max());\n}\npublic Iterable&lt;Key&gt; keys(Key lo, Key hi){\n\tQueue&lt;Key&gt; queue = new Queue&lt;Key&gt;();\n\tkeys(root, queue, lo, hi);\n\treturn queue;\n}\nprivate void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) {\n\tif\t(x == null) return;\n\tint cmplo = lo.compareTo(x.key);\n\tint cmphi = hi.compareTo(x.key);\n\tif(cmplo &lt; 0)\t                 keys(x.left, queue, lo, hi);\n\tif(cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0)\tqueue.enqueue(x.key);\n\tif(cmphi &gt; 0) \t                 keys(x.right, queue, lo, hi);\n}</code></pre></div><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "二叉排序树", 
                    "tagLink": "https://api.zhihu.com/topics/20092656"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61488756", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 1, 
            "title": "深入理解希尔排序", 
            "content": "<p><i><b>希尔排序</b></i>是一种基于插入排序的算法，相较于插入排序一点一点的移动元素，希尔排序实现了快速移动一大步。</p><p>对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组的一端移动到另一端。假如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需要N-1次移动。希尔排序为了加快速度简单的改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。</p><p>希尔排序的思想是使数组中任意间隔为h的元素都是有序的。这样的数组被称为h有序数组。换句话说，一个h有序的数组就是h个互相独立的有序数组编织在一起组成的一个数组。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-16ee82ec59d1d4d5e166883e22def6a8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"337\" data-rawheight=\"291\" class=\"content_image\" width=\"337\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;337&#39; height=&#39;291&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"337\" data-rawheight=\"291\" class=\"content_image lazy\" width=\"337\" data-actualsrc=\"https://pic1.zhimg.com/v2-16ee82ec59d1d4d5e166883e22def6a8_b.jpg\"/></figure><p>在进行排序的时候，如果h很大，我们就能将元素移动到很远的地方，为实现跟小的h有序创造方便。用这种方式，对于任意以1结尾的h序列，我们都能够将数组排序。这就是希尔排序。</p><p>以下算法实现使用了序列1/2(3^k-1)，从N/3开始递减至1，我们可以称这个序列称为递增序列。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t<span class=\"c1\">//将a[]按升序排列\n</span><span class=\"c1\"></span>\t<span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n\t<span class=\"kt\">int</span> <span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t<span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">/</span><span class=\"n\">3</span><span class=\"o\">)</span>\t<span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">*</span><span class=\"n\">h</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t<span class=\"k\">while</span><span class=\"o\">(</span><span class=\"n\">h</span> <span class=\"o\">&gt;=</span><span class=\"n\">1</span> <span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"c1\">//将数组变为h有序\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">;</span><span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span><span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">//将a[i]插入到a[i-h]，a[i-2*h]，a[i-3h]...之中。\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span><span class=\"n\">j</span> <span class=\"o\">&gt;=</span> <span class=\"n\">h</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">less</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">h</span><span class=\"o\">]);</span> <span class=\"n\">j</span> <span class=\"o\">-=</span> <span class=\"n\">h</span><span class=\"o\">)</span>\n\t\t\t\t<span class=\"n\">exch</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">h</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t\t<span class=\"n\">h</span> <span class=\"o\">=</span> <span class=\"n\">h</span><span class=\"o\">/</span><span class=\"n\">3</span><span class=\"o\">;</span>  <span class=\"c1\">//使间隔逐步变小\n</span><span class=\"c1\"></span>\t<span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>实现希尔排序的另一种方法是对于每个h，用插入排序将h个子数组独立地排序。但因为子数组使相互独立的，一个更简单的方法是在h-子数组中将每个元素交换到比它大的元素之前去（将比它大的元素向右移动一格）。只需要在插入排序的代码中将移动元素的距离由1改为h即可。这样，希尔排序的实现就转化为了一个类似于插入排序但使用不同增量的过程。</p><p>希尔排序更高效的原因使它权衡了子数组的<b>规模</b>和<b>有序性</b>。在排序之初，各个子元素都很短，排序之后子数组都是部分有序的，这两种情况都很适合插入排序。子数组有序的程度取决于递增序列的选择。</p><h3> 如何选择递增序列呢？</h3><p>要回答这个问题并不简单。算法的性能不仅取决于h，还取决于之间的数学性质，比如它们的公因子等。首先递增序列应该是互质的。</p><p> 和选择排序以及插入排序形成对比的是，希尔排序也可以用于大型数组。它对任意排序（不一定是随机的）的数组表现的也很好。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-f994d7298a055951d99d65277ebc2162_b.jpg\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"421\" class=\"content_image\" width=\"267\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;267&#39; height=&#39;421&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"267\" data-rawheight=\"421\" class=\"content_image lazy\" width=\"267\" data-actualsrc=\"https://pic3.zhimg.com/v2-f994d7298a055951d99d65277ebc2162_b.jpg\"/><figcaption>希尔排序详细轨迹</figcaption></figure><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9f0ea8f5a054dad16d259aee5d9030be_b.jpg\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-9f0ea8f5a054dad16d259aee5d9030be_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;438&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"527\" data-rawheight=\"438\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic3.zhimg.com/v2-9f0ea8f5a054dad16d259aee5d9030be_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-9f0ea8f5a054dad16d259aee5d9030be_b.jpg\"/><figcaption>希尔排序可视轨迹</figcaption></figure><p>通过提升速度来解决其他方式无法解决的问题是研究算法设计和性能的主要原因之一</p><p> 有经验的程序员又是会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。它的代码量很小，且不会使用额外的内存空间。</p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61472115", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 2, 
            "title": "简单理解选择排序", 
            "content": "<h2>思路：</h2><p>首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置（如果第一个元素就是最小的元素那么它就和自己交换）。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到整个元素有序。</p><h3><i>它在不断地选择剩余元素的最小者。</i></h3><p>如下算法所示，选择排序的内循环只是在比较当前元素与目前已知的最小元素（以及将当前索引加一和检测是否下标越界），</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t<span class=\"cm\">/*具体算法的实现*/</span>\n\t<span class=\"c1\">//将a[]按升序排列\n</span><span class=\"c1\"></span>\t<span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t<span class=\"c1\">//将a[i]和a[i+1..N]中最小的元素交换\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">j</span><span class=\"o\">++)</span> \n\t\t\t<span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">less</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">min</span><span class=\"o\">]))</span> <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">j</span><span class=\"o\">;</span>\n\t\t<span class=\"n\">exch</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">i</span><span class=\"o\">,</span> <span class=\"n\">min</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>这个算法已经简单到了极点。交换的代码写着内循环之外，每次交换都能排定一个元素，因此交换的总次数为N。所以算法的时间效率取决于比较的次数。</p><h3> 结论：<i>对于长度为N的数组，选择排序需要大约N^2次比较和N次交换。</i></h3><p> 它有两个很鲜明的特点：</p><p><b>运行时间和输入无关</b>。为了找出最小的元素而扫描一边数组并不能为下一次扫描提供什么信息。你会惊奇的发现，一个有序的数组或者主键全部相等的元素和一个元素随机排列的的数组所用的排序时间竟然一样长。</p><p><b>数据移动是最少的</b>。每次交换都会改变两个数组元素的值，因为选择排序用了N次交换——交换次数和数组大小是线性关系。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-78ecaae190f00e6fcef8ddbd11b8fbd3_b.jpg\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"302\" class=\"content_image\" width=\"395\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;395&#39; height=&#39;302&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"395\" data-rawheight=\"302\" class=\"content_image lazy\" width=\"395\" data-actualsrc=\"https://pic4.zhimg.com/v2-78ecaae190f00e6fcef8ddbd11b8fbd3_b.jpg\"/><figcaption>选择排序示意</figcaption></figure><p></p>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61348517", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 5, 
            "title": "深入理解插入排序", 
            "content": "<p>在玩纸牌游戏的时候，为了使手中牌变得有顺序，我们常常需要把随机抽取到的纸牌插入到合适的位置。</p><p>在计算机中为了要给插入的元素腾出空间，需要将其后的元素在插入之前都右移一位，这种算法叫做<i>插入排序</i>。</p><p>插入排序所需要的时间取决于输入中元素的初始顺序。假如，对一个很大且其中元素已经有序（或接近有序）的数组进行排序将会比随机顺序的数组或者逆序的数组排序要快的多。</p><h3>结论一：</h3><p>对于随机排列长度为N的且主键不重复的数组，平均情况下插入排序需要~(N^2)/4次比较以及~(N^2)/4次交换。最坏情况下需要~(N^2)/2次比较和~(N^2)/2次交换，最好情况下需要N-1次比较和0次交换。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Insertion</span> <span class=\"o\">{</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n\t\t<span class=\"cm\">/*具体算法的实现*/</span>\n\t\t<span class=\"c1\">//将a[]按升序排列\n</span><span class=\"c1\"></span>\t\t<span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">;</span>\n\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">N</span><span class=\"o\">;</span> <span class=\"n\">i</span><span class=\"o\">++)</span> <span class=\"o\">{</span>\n\t\t\t<span class=\"c1\">//将a[i]插入到a[i-1]、a[i-2]、a[i-3]...之中\n</span><span class=\"c1\"></span>\t\t\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">less</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">]);</span> <span class=\"n\">j</span><span class=\"o\">--)</span>\n\t\t\t\t<span class=\"n\">exch</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t<span class=\"o\">}</span>\n\t<span class=\"o\">}</span>\n        <span class=\"c1\">//可以自行实现其他功能，例如each等\n</span><span class=\"c1\"></span><span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-435b3c1c49d20ff565b1d92978add50f_b.jpg\" data-size=\"normal\" data-rawwidth=\"390\" data-rawheight=\"281\" class=\"content_image\" width=\"390\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;390&#39; height=&#39;281&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"390\" data-rawheight=\"281\" class=\"content_image lazy\" width=\"390\" data-actualsrc=\"https://pic4.zhimg.com/v2-435b3c1c49d20ff565b1d92978add50f_b.jpg\"/><figcaption>快速排序示意</figcaption></figure><p>我们要考虑的更一般的情况是部分有序的数组，倒置指的是数组中的两个顺序颠倒的元素。</p><p>比如E X A M P L E中有11对倒置：E-A，X-A， X-M， X-P， X-L， X-E， M-L， M-E，   P-L， P-E 以及L-E。</p><p>如果数组中倒置的数量小于数组大小的某个倍数，那么我们说这个数组是部分有序的</p><p><i>下面是几种经典的部分有序的数组：</i></p><p>a、 数组中每个元素距离它的最终位置都不远</p><p>b、 一个有序的大数组接一个小数组</p><p>c、 数组中只有几个元素的位置不确定。</p><h3> 结论二：</h3><p>插入排序需要的交换操作和数组中倒置的数量相同，需要的比较次数大于等于倒置的数量，小于等于倒置的数量加上数组的大小再减一。</p><p> 要大幅提高插入排序的速度并不难，只要在内循环中将较大的元素都向右移动而不总是交换两个元素（这样访问数组的次数就能减半）</p><h2> 总的来说插入排序对于部分有序的数组十分高效，也很适合小规模数组。</h2>", 
            "topic": [
                {
                    "tag": "算法", 
                    "tagLink": "https://api.zhihu.com/topics/19553510"
                }, 
                {
                    "tag": "排序", 
                    "tagLink": "https://api.zhihu.com/topics/19572852"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61232392", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 2, 
            "title": "深入理解归并排序", 
            "content": "<p>声明：图片来自于《算法》第四版。</p><hr/><h2>何为归并？</h2><p>即将两个有序的数组归并成一个更大的有序数组。</p><h2>归并排序：</h2><p>要将一个数组排序，可以先（递归地）将它分成两半分别排序，然后将结果归并起来。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b2ca5df80aa7fb477ad5439c6191a44b_b.jpg\" data-size=\"normal\" data-rawwidth=\"410\" data-rawheight=\"116\" class=\"content_image\" width=\"410\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;410&#39; height=&#39;116&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"410\" data-rawheight=\"116\" class=\"content_image lazy\" width=\"410\" data-actualsrc=\"https://pic4.zhimg.com/v2-b2ca5df80aa7fb477ad5439c6191a44b_b.jpg\"/><figcaption>归并排序示意图</figcaption></figure><h3>优点：</h3><p>它能够保证将任意长度为N的数组排序所需要的时间和NlogN成正比</p><h3>缺点：</h3><p>所需要的额外空间和N成正比。</p><h2>原地归并的抽象方法：</h2><p>实现归并的一种直截了当的办法是将两个不同的有序数组归并到第三个数组中，两个数组中的元素都实现了Comparable接口，实现的方法很简单，创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大放入到这个数组中。</p><p>当用归并将一个大数组排序时，我们需要进行很多次的归并操作。因此每次归并时都创建一个新的数组来存储排序结果会带来问题。</p><h3>原地归并方法：</h3><p>先将前半部分排序，再将后半部分排序，然后在数组中移动元素而不需要额外的空间。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">merge</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">lo</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">hi</span><span class=\"o\">){</span>\n\t<span class=\"c1\">//将a[lo..mid]和a[mid+1..hi]归并\n</span><span class=\"c1\"></span>\t<span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">lo</span><span class=\"o\">,</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">lo</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">&lt;=</span><span class=\"n\">hi</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\t\t\t<span class=\"c1\">//将a[lo..hi]复制到aux[lo..hi]\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">auk</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">];</span>\n\t<span class=\"k\">for</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span> <span class=\"o\">=</span> <span class=\"n\">lo</span><span class=\"o\">;</span> <span class=\"n\">k</span> <span class=\"o\">&lt;=</span><span class=\"n\">hi</span><span class=\"o\">;</span> <span class=\"n\">k</span><span class=\"o\">++)</span>\t\t\t<span class=\"c1\">//归并回到a[lo..hi]\n</span><span class=\"c1\"></span>\t\t<span class=\"k\">if</span>\t<span class=\"o\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"n\">mid</span><span class=\"o\">)</span>\t\t<span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">++];</span>\n\t\t<span class=\"k\">else</span> <span class=\"k\">if</span>\t<span class=\"o\">(</span><span class=\"n\">j</span> <span class=\"o\">&gt;</span> <span class=\"n\">hi</span><span class=\"o\">)</span>\t\t<span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">++];</span>\n\t\t<span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">less</span><span class=\"o\">(</span><span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">],</span><span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">]))</span>\t<span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">j</span><span class=\"o\">++];</span>\n\t\t<span class=\"k\">else</span>\t\t\t        <span class=\"n\">a</span><span class=\"o\">[</span><span class=\"n\">k</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">aux</span><span class=\"o\">[</span><span class=\"n\">i</span><span class=\"o\">++];</span>\n<span class=\"o\">}</span></code></pre></div><h3>注释：</h3><p>此方法会将子数组a[lo..mid]和a[mid+1..hi]归并成一个有序的数组并将结果存放在a[lo..hi]中。</p><p>该方法先将所有元素复制到aux[]中，然后再归并回a[]中，方法在归并时(第二个for循环)进行了四个条件判断：</p><p>a、 左边用尽(取右边的元素)</p><p>b、 右边用尽(取左边的元素)</p><p>c、 右半边的当前元素小于等于左半边的当前元素(取右边的元素)</p><p>d、 右半边的当前元素大于等于左半边的当前元素(取左边的元素)</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-4145e7520e991ac1c30f34631a458ede_b.jpg\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-4145e7520e991ac1c30f34631a458ede_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;324&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"324\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic3.zhimg.com/v2-4145e7520e991ac1c30f34631a458ede_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-4145e7520e991ac1c30f34631a458ede_b.jpg\"/><figcaption>原地归并的抽象方法的轨迹</figcaption></figure><h2>自顶向下的归并排序：</h2><p>如果它能将两个子数组排序，它就能通过归并两个子数组来讲整个数组排序。</p><div class=\"highlight\"><pre><code class=\"language-text\">//自顶向下的归并排序\npublic class Merge{\n\tprivate static Comparable[] aux;\t\t//归并所需要的辅助数组\n\t\n\tpublic static void sort(Comparable[] a){\n\t\taux = new Comparable[a.length];\t//一次性分配空间\n\t\tsort(a,0,a.length - 1);\n\t}\n\t\n\tprivate static void sort(Comparable[] a, int lo, int hi){\t//将数组a[lo..hi]排序\n\t\tif  (hi &lt; lo)  return ;\n\t\tint mid  = lo + (hi - lo)/2;\n\t\tsort(a, lo, mid);\t\t//将左半部分排序\n\t\tsort(a, mid+1,hi);\t\t//将右半部分排序\n\t\tmerger(a, lo, mid, hi)\t;\t//归并结果\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2e43824e5c9f41c6079465ea6c0a6071_b.jpg\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-2e43824e5c9f41c6079465ea6c0a6071_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;297&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"297\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-2e43824e5c9f41c6079465ea6c0a6071_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2e43824e5c9f41c6079465ea6c0a6071_b.jpg\"/><figcaption>自顶向下的归并排序</figcaption></figure><h2>过程：</h2><p>如要将a[0..15]排序，sort会先调用自己将a[0..7]排序，再在其中调用自己将a[0..3]和a[0..1]排序。再将a[0]和a[1]分别排序后，终于才会将a[0]和a[1]归并。第二次归并是a[2]和a[3]，然后是a[0..1]和a[2..3]，以此类推。</p><h2>优化方式：</h2><p>a、 对小规模子数组使用插入排序</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-480607fff09904aca63c4d5be04c4f4a_b.jpg\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"566\" class=\"content_image\" width=\"401\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;401&#39; height=&#39;566&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"401\" data-rawheight=\"566\" class=\"content_image lazy\" width=\"401\" data-actualsrc=\"https://pic3.zhimg.com/v2-480607fff09904aca63c4d5be04c4f4a_b.jpg\"/><figcaption>对小规模子数组使用插入排序示意图</figcaption></figure><p>b、 测试数组是否已经有序</p><p>c、 不将元素复制到辅助数组</p><h2>自底向上的归并排序：</h2><p>先归并那些微型数组，然后再成对归并得到的子数组，如此这般，直到我们将整个数组归并在一起。</p><div class=\"highlight\"><pre><code class=\"language-text\">//自底向上的归并排序\npublic class MergeBU{\n\tprivate static Comparable[] aux;\t\t\t        //归并所需的辅助数组\n\n\tpublic static void sort(Comparable[] a){\t\t\t//进行lgN次两两归并\n\t\tint N = a.length;\n\t\taux = new Comparable[N];\n\t\tfor(int sz = 1; sz &lt; N; sz = sz+sz)\t\t        //sz子数组的大小\n\t\t\tfor(int lo = 0; lo &lt; N-sz; lo += sz+sz)\t        //lo:子数组的索引\n\t\t\t\tmerge(a,lo,lo+sz-1,Math.min(lo+sz+sz-1. N-1));\n\t}\n}\n</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-ea1714434e4cfa714dedd91eed0c0ca1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-ea1714434e4cfa714dedd91eed0c0ca1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;342&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"342\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-ea1714434e4cfa714dedd91eed0c0ca1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-ea1714434e4cfa714dedd91eed0c0ca1_b.jpg\"/></figure><h2><b><i>总结：</i></b></h2><ul><li>对于长度为N的任意数组，自顶向下的归并排序需要1/2NlgN至NlgN次比较。</li><li>对于长度为N的任意数组，自顶向下的归并排序最多需要访问数组6NlgN次。</li><li>对于长度为N的任意数组，自底向上的归并排序需要1/2NlgN至NlgN次比较，最多需要访问数组6NlgN次。</li><li>没有任何基于比较的算法能够保证使用少于lg(N!)~NlgN次比较将长度为N的数组排序。</li><li>归并排序是一种基于渐进最优的基于比较排序的算法。</li></ul>", 
            "topic": [
                {
                    "tag": "归并排序", 
                    "tagLink": "https://api.zhihu.com/topics/20095856"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61105421", 
            "userName": "SeYuFac", 
            "userLink": "https://www.zhihu.com/people/c28857037a7391b4cca68ca216431226", 
            "upvote": 2, 
            "title": "深入理解快速排序", 
            "content": "<p>声明：图片来自于《算法》第四版。本文章需要实际的遇到各种问题，才会体会到里面的内容。希望大家静下心来，好好思考。这对思维会有很大的提示。也可以提高对算法中隐藏缺陷的发现能力有一个很好的提升。</p><hr/><p>快速排序可能是应用最广泛的排序算法了，快速排序流行的原因是它实现简单，适用于各种不同的输入数据且在一般应用中比其他算法都要快的多。</p><h2>快速排序引人注目的三点：</h2><p>1、 原地排序(只需要一个很小的辅助栈)，</p><p>2、 长度为N的数组排序所需要的时间和NlgN成正比。</p><p>3、 快排的内循环比其他大多数排序算法都要短小，这意味着无论是在理论还是实际中都要更快</p><h2>缺点：</h2><p>非常脆弱，要非常小心才能避免低劣的性能。本次讲解也会关注其中错误可能发生的地方。</p><h2>基本算法</h2><p>快速排序是一种分治的排序算法，将一个数组分成两个子数组，将两部分独立地进行排序。</p><p>快速排序和归并排序是互补的：</p><p>a、 归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将数组排序，而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了，</p><p>b、 归并排序递归调用发生在处理整个数组之前；快速排序递归调用发生在处理整个数组之后。</p><p>c、 在归并排序中，一个数组被切分为两半；在快速排序中切分的位置取决于数组的内容。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6aa90425e42b77791ac0cf34c76d3dad_b.jpg\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6aa90425e42b77791ac0cf34c76d3dad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;205&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"205\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-6aa90425e42b77791ac0cf34c76d3dad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6aa90425e42b77791ac0cf34c76d3dad_b.jpg\"/><figcaption>快速排序示意图</figcaption></figure><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">//快速排序\n</span><span class=\"c1\"></span><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">Quick</span><span class=\"o\">{</span>\n\t<span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">){</span>\n\t\t<span class=\"n\">StdRndom</span><span class=\"o\">.</span><span class=\"na\">shuffle</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">);</span>\t\t\t\t<span class=\"c1\">//消除对输入的依赖\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">0</span><span class=\"o\">,</span><span class=\"n\">a</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n\t\n\t<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">sort</span><span class=\"o\">(</span><span class=\"n\">Comparable</span><span class=\"o\">[]</span> <span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">lo</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">hi</span><span class=\"o\">){</span>\n\t\t<span class=\"k\">if</span><span class=\"o\">(</span><span class=\"n\">hi</span> <span class=\"o\">&lt;=</span> <span class=\"n\">lo</span><span class=\"o\">)</span> \t<span class=\"k\">return</span><span class=\"o\">;</span>\n\t\t<span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">partition</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span><span class=\"n\">lo</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"o\">);</span>\t\t\t<span class=\"c1\">//寻找切分点\n</span><span class=\"c1\"></span>\t\t<span class=\"n\">sort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">lo</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">);</span>\n\t\t<span class=\"n\">sort</span><span class=\"o\">(</span><span class=\"n\">a</span><span class=\"o\">,</span> <span class=\"n\">j</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span><span class=\"n\">hi</span><span class=\"o\">);</span>\n\t<span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-0bdb64bed7cf1600d127516b27fa79ad_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-0bdb64bed7cf1600d127516b27fa79ad_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;554&#39; height=&#39;352&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"554\" data-rawheight=\"352\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"554\" data-original=\"https://pic2.zhimg.com/v2-0bdb64bed7cf1600d127516b27fa79ad_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-0bdb64bed7cf1600d127516b27fa79ad_b.jpg\"/></figure><p>该方法的关键在于<i>切分</i>，整个过程使数组满足以下条件</p><p>a、 对于某个j，a[j]已经排定；(j的选择越靠近中央，排序越快)</p><p>b、 a[lo]到a[j-1]中的所有元素都不大于a[j]；</p><p>c、 a[j+1]到a[hi]中的所有元素都不小于a[j]；</p><p>通过递归调用切分来排序。</p><h2>实现切分方法：</h2><p>一般策略是</p><p>a、 随意地取a[lo]作为切分元素。</p><p>b、 然后从数组的左端开始向右扫描直到找到一个大于等于它的元素，</p><p>c、 再从数组的右端开始向左扫描直到找到一个小于等于它的元素，</p><p>d、 交换这两个元素的位置。</p><p>e、 如此继续。</p><p>f、 当两指针相遇时，只需将切分元素a[lo]和左子树的最右侧元素(a[j])交换然后返回j即可。</p><div class=\"highlight\"><pre><code class=\"language-text\">//快速排序的切分\nprivate static int partition(Comparable[] a, int lo, int hi){\t\t//将数组切分为a[lo..i-1],a[i],a[i+1..hi]\n\tint i = lo, j = hi +1;\n\tComparable v = a[lo];\n\twhile(true){\t\t\t\t\t//扫描左右，检查扫描是否结束并交换元素\n\t\twhile   (less(a[++i], v))         if  (i == hi)    break;\n\t\twhile   (less(v,   a[--j]))         if  (j ==lo)     break;\n\t\tif( i &gt;= j)\tbreak;\n\t\teach(a, i, j);\n\t}\n\teach(a, lo , j);\t\t\t\t\t//将v = a[j] 放入正确的位置\n\treturn j;\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-4df6371d8c70806a9a7deeb80f5dbc0c_b.jpg\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"254\" class=\"content_image\" width=\"409\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;409&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"409\" data-rawheight=\"254\" class=\"content_image lazy\" width=\"409\" data-actualsrc=\"https://pic1.zhimg.com/v2-4df6371d8c70806a9a7deeb80f5dbc0c_b.jpg\"/><figcaption>切分轨迹</figcaption></figure><h2>值得注意的几个细节问题</h2><p>a、 原地切分</p><p>如果使用一个辅助数组，我们可以很容易实现切分，但将切分后的数组复制回去的开销也许使我们得不偿失。这回大大降低排序的速度。</p><p>b、 别越界</p><p>如果切分元素是数组中最小或最大的那个元素，我们就要小心别让扫描指针跑出数组的边界partition()实现可进行明确的检测来预防这种情况。测试条件(j == lo)是冗余的，因为切分元素就是a[lo]，它不可能比自己小。数组右端也有相同的情况，它们都是可以去掉的。</p><p>c、 保持随机性</p><p>数组元素的顺序是被打乱的，因为该算法对所有子数组一视同仁，它的所有子数组也都是随机排序的。这对于预测算法的运行时间很重要。</p><p>d、 终止循环</p><p>保证循环结束需要格外小心，正确检测指针是否越界需要一点技巧。</p><p>e、 处理切分元素值有重复的情况</p><p>如算法所示，左侧扫描最好是在遇到大于等于切分元素值的元素停下，右侧扫描则是在遇到小于等于切分元素值的元素停下。尽管这样可能会不必要的将一些等值元素交换（不稳定算法），但是在某些典型应用中它能够避免算法的运行时间变为平方级。</p><p>f、 终止递归</p><p>切分元素正好是数组的最大或最小值时会陷入无限的递归循环中。</p><h2>算法改进：</h2><p>a、 切换到插入排序</p><p>和大多数递归排序算法一样，改进排序性能的一个简单办法基于以下两点：</p><p>对于小数组，快速排序比插入排序慢</p><p>因为递归，快速排序的sort()方法在小数组中也会调用自己。</p><p>b、 三取样切分</p><p>使用子数组的一小部分元素的中位数来切分数组。这样做的切分更好，但代价就是需要计算中位数。人们发现将取样大小设为3并用大小居中的元素切分效果最好。</p><p>c、 熵最优的排序</p><p>针对于数组中还有大量重复元素。</p><p>将数组切分为三部分，分别对应小于，等于和大于切分元素的数组</p><div class=\"highlight\"><pre><code class=\"language-text\">//三向切分的快速排序\npublic class Quick3way{\n\t\n\tprivate static void sort(Comparable[] a, int lo, int hi){\t\t\n\t\tif(hi &lt;= lo)\treturn;\n\t\tint lt = lo, i = lo+1, gt = hi;\n\t\tComparable v = a[lo];\n\t\twhile( i &lt;= gt) {\n\t\t\tint cmp  = a[i].comparaeTo(v);\n\t\t\tif\t(cmp &lt; 0)\t\texch(a, lt++, i++);\n\t\t\telse if\t(cmp &gt; 0)\t\texch(a  ,  i  ,  gt--);\n\t\t\telse\t\t\ti++;\n\t\t}\t//现在a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]成立\n\t\tsort(a, lo, lt - 1);\n\t\tsort(a, gt + 1, hi);\n\t}\n}</code></pre></div><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-9313da9f156b35c103417e16534dfc6a_b.jpg\" data-size=\"normal\" data-rawwidth=\"402\" data-rawheight=\"319\" class=\"content_image\" width=\"402\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;402&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"402\" data-rawheight=\"319\" class=\"content_image lazy\" width=\"402\" data-actualsrc=\"https://pic3.zhimg.com/v2-9313da9f156b35c103417e16534dfc6a_b.jpg\"/><figcaption>三向切分的轨迹</figcaption></figure><p>快速排序是第一批偏爱随机性的算法。</p><p>经过精心调优的快速排序在绝大多数计算机上的绝大多数应用中都会比其他基于比较的排序算法更快。</p>", 
            "topic": [
                {
                    "tag": "快速排序", 
                    "tagLink": "https://api.zhihu.com/topics/19644323"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/yang4algo"
}
