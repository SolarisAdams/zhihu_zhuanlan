{
    "title": "Java", 
    "description": "", 
    "followers": [
        "https://www.zhihu.com/people/526131483", 
        "https://www.zhihu.com/people/j99999999955555", 
        "https://www.zhihu.com/people/ping-tou-ge-62-19", 
        "https://www.zhihu.com/people/gu-liang-shuo-hu-lian-wang", 
        "https://www.zhihu.com/people/rainny-k", 
        "https://www.zhihu.com/people/yang-liu-yi-yi-wayne", 
        "https://www.zhihu.com/people/liao-liao-50-17", 
        "https://www.zhihu.com/people/an-tu-en-jiang-gu-shi", 
        "https://www.zhihu.com/people/zi-mo-wei-yang-bi-hong-liu-li-76", 
        "https://www.zhihu.com/people/zheng-jian-yang-56", 
        "https://www.zhihu.com/people/lan-lan-lan-lan-96-82", 
        "https://www.zhihu.com/people/jack-hou-5", 
        "https://www.zhihu.com/people/wang-shi-chi", 
        "https://www.zhihu.com/people/srs-90"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/35525368", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 2, 
            "title": "【培训】异步调用与回调怎么实现？语言原理是相通的此处以Java为例", 
            "content": "<p><b>模块间调用</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>在一个应用系统中，无论使用何种语言开发，必然存在模块之间的调用，调用的方式分为几种：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（1）同步调用</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-6c0167955ef3fd44141cdd19efdf9e2b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"347\" data-rawheight=\"117\" class=\"content_image\" width=\"347\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;347&#39; height=&#39;117&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"347\" data-rawheight=\"117\" class=\"content_image lazy\" width=\"347\" data-actualsrc=\"https://pic4.zhimg.com/v2-6c0167955ef3fd44141cdd19efdf9e2b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>同步调用是最基本并且最简单的一种调用方式，类A的方法a()调用类B的方法b()，一直等待b()方法执行完毕，a()方法继续往下走。<b>这种调用方式适用于方法b()执行时间不长的情况</b>，因为b()方法执行时间一长或者直接阻塞的话，a()方法的余下代码是无法执行下去的，这样会造成整个流程的阻塞。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（2）异步调用</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-30b5048c6c2f99dc627976b426099238_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"110\" class=\"content_image\" width=\"343\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;343&#39; height=&#39;110&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"343\" data-rawheight=\"110\" class=\"content_image lazy\" width=\"343\" data-actualsrc=\"https://pic1.zhimg.com/v2-30b5048c6c2f99dc627976b426099238_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>异步调用是为了解决同步调用可能出现阻塞，导致整个流程卡住而产生的一种调用方式。<b>类A的方法方法a()通过新起线程的方式调用类B的方法b()，代码接着直接往下执行</b>，这样无论方法b()执行时间多久，都不会阻塞住方法a()的执行。但是这种方式，由于方法a()不等待方法b()的执行完成，在方法a()需要方法b()执行结果的情况下（视具体业务而定，有些业务比如启异步线程发个微信通知、刷新一个缓存这种就没必要），必须通过一定的方式对方法b()的执行结果进行监听。在Java中，可以使用Future+Callable的方式做到这一点，具体做法可以参见我的这篇文章《 Java多线程21：多线程下其他组件之CyclicBarrier、Callable、Future和FutureTask 》<i>（注1）</i>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（3）回调</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-15f27a8e95d58313e151e35a7a7fddf2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb\" width=\"450\" data-original=\"https://pic3.zhimg.com/v2-15f27a8e95d58313e151e35a7a7fddf2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;450&#39; height=&#39;255&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"450\" data-rawheight=\"255\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"450\" data-original=\"https://pic3.zhimg.com/v2-15f27a8e95d58313e151e35a7a7fddf2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-15f27a8e95d58313e151e35a7a7fddf2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后是回调，回调的思想是：</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>类A的a()方法调用类B的b()方法</li><li>类B的b()方法执行完毕主动调用类A的callback()方法</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>这样一种调用方式组成了上图，也就是一种双向的调用方式。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代码示例</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来看一下回调的代码示例，代码模拟的是这样一种场景：老师问学生问题，学生思考完毕回答老师。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先定义一个回调接口，只有一个方法tellAnswer(int answer)，即学生思考完毕告诉老师答案：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>/**<br/>* 回调接口，原文出处<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xrq730/p/6424471.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/xrq730/p/64</span><span class=\"invisible\">24471.html</span><span class=\"ellipsis\"></span></a><br/>*/<br/>public interface Callback {<br/><br/>   public void tellAnswer(int answer);<br/><br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>定义一个老师对象，实现Callback接口：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>/**<br/>* 老师对象，原文出处<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xrq730/p/6424471.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/xrq730/p/64</span><span class=\"invisible\">24471.html</span><span class=\"ellipsis\"></span></a><br/>*/<br/>public class Teacher implements Callback {<br/><br/>   private Student student;<br/><br/>   public Teacher(Student student) {<br/>       this.student = student;<br/>   }<br/><br/>   public void askQuestion() {<br/>       student.resolveQuestion(this);<br/>   }<br/><br/>   @Override<br/>   public void tellAnswer(int answer) {<br/>       System.out.println(&#34;知道了，你的答案是&#34; + answer);<br/>   }<br/><br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>老师对象有两个public方法：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）回调接口tellAnswer(int answer)，即学生回答完毕问题之后，老师要做的事情</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）问问题方法askQuestion()，即向学生问问题</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接着定义一个学生接口，学生当然是解决问题，但是接收一个Callback参数，这样学生就知道解决完毕问题向谁报告：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>/**<br/>* 学生接口，原文出处<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xrq730/p/6424471.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/xrq730/p/64</span><span class=\"invisible\">24471.html</span><span class=\"ellipsis\"></span></a><br/>*/<br/>public interface Student {<br/><br/>   public void resolveQuestion(Callback callback);<br/><br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>最后定义一个具体的学生叫Ricky：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>/**<br/>* 一个名叫Ricky的同学解决老师提出的问题，原文出处<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xrq730/p/6424471.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/xrq730/p/64</span><span class=\"invisible\">24471.html</span><span class=\"ellipsis\"></span></a><br/>*/<br/>public class Ricky implements Student {<br/><br/>   @Override<br/>   public void resolveQuestion(Callback callback) {<br/>       // 模拟解决问题<br/>       try {<br/>           Thread.sleep(3000);<br/>       } catch (InterruptedException e) {<br/><br/>       }<br/><br/>       // 回调，告诉老师作业写了多久<br/>       callback.tellAnswer(3);<br/>   }<br/><br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>在解决完毕问题之后，第16行向老师报告答案。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>写一个测试类，比较简单：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>/**<br/>* 回调测试，原文出处<a href=\"https://link.zhihu.com/?target=http%3A//www.cnblogs.com/xrq730/p/6424471.html\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">cnblogs.com/xrq730/p/64</span><span class=\"invisible\">24471.html</span><span class=\"ellipsis\"></span></a><br/>*/<br/>public class CallbackTest {<br/><br/>   @Test<br/>   public void testCallback() {<br/>       Student student = new Ricky();<br/>       Teacher teacher = new Teacher(student);<br/><br/>       teacher.askQuestion();<br/><br/>   }<br/>}</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>代码运行结果就一行：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>知道了，你的答案是3</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>简单总结、分析一下这个例子就是：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）老师调用学生接口的方法resolveQuestion，向学生提问</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）学生解决完毕问题之后调用老师的回调方法tellAnswer</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这样一套流程，构成了一种双向调用的关系。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代码分析</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>分析一下上面的代码，上面的代码我这里做了两层的抽象：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（1）将老师进行抽象</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>将老师进行抽象之后，对于学生来说，就不需要关心到底是哪位老师询问我问题，只要我根据询问的问题，得出答案，然后告诉提问的老师就可以了，即使老师换了一茬又一茬，对我学生而言都是没有任何影响的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>（2）将学生进行抽象</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>将学生进行抽象之后，对于老师这边来说就非常灵活，因为老师未必对一个学生进行提问，可能同时对Ricky、Jack、Lucy三个学生进行提问，这样就可以将成员变量Student改为List&lt;Student&gt;，这样在提问的时候遍历Student列表进行提问，然后得到每个学生的回答即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个例子是一个典型的体现接口作用的例子，之所以这么说是因为我想到有些朋友可能不太明白接口的好处，不太明白接口好处的朋友可以重点看一下这个例子，多多理解。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>总结起来，<b>回调的核心就是回调方将本身即this传递给调用方</b>，这样调用方就可以在调用完毕之后告诉回调方它想要知道的信息。回调是一种思想、是一种机制，至于具体如何实现，如何通过代码将回调实现得优雅、实现得可扩展性比较高，一看开发者的个人水平，二看开发者对业务的理解程度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>同步回调与异步回调</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>上面的例子，可能有人会提出这样的疑问：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>这个例子需要用什么回调啊，使用同步调用的方式，学生对象回答完毕问题之后直接把回答的答案返回给老师对象不就好了？</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>这个问题的提出没有任何问题，可以从两个角度去理解这个问题。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先，老师不仅仅想要得到学生的答案怎么办？可能这个老师是个更喜欢听学生解题思路的老师，在得到学生的答案之前，老师更想先知道学生姓名和学生的解题思路，当然有些人可以说，那我可以定义一个对象，里面加上学生的姓名和解题思路不就好了。这个说法在我看来有两个问题：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）如果老师想要的数据越来越多，那么返回的对象得越来越大，而使用回调则可以进行数据分离，将一批数据放在回调方法中进行处理，至于哪些数据依具体业务而定，如果需要增加返回参数，直接在回调方法中增加即可</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）无法解决老师希望得到学生姓名、学生解题思路先于学生回答的答案的问题</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此我认为简单的返回某个结果确实没有必要使用回调而可以直接使用同步调用，但是如果<b>有多种数据需要处理且数据有主次之分</b>，使用回调会是一种更加合适的选择，优先处理的数据放在回调方法中先处理掉。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>另外一个理解的角度则更加重要，就是标题说的同步回调和异步回调了。例子是一个同步回调的例子，意思是老师向Ricky问问题，Ricky给出答案，老师问下一个同学，得到答案之后继续问下一个同学，这是一种正常的场景，但是如果我把场景改一下：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>老师并不想One-By-One这样提问，而是同时向Ricky、Mike、Lucy、Bruce、Kate五位同学提问，让同学们自己思考，哪位同学思考好了就直接告诉老师答案即可。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>这种场景相当于是说，同学思考完毕完毕问题要有一个办法告诉老师，有两个解决方案：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（1）使用Future+Callable的方式，等待异步线程执行结果，这相当于就是同步调用的一种变种，因为其本质还是方法返回一个结果，即学生的回答</p><p class=\"ztext-empty-paragraph\"><br/></p><p>（2）使用异步回调，同学回答完毕问题，调用回调接口方法告诉老师答案即可。由于老师对象被抽象成了Callback接口，因此这种做法的扩展性非常好，就像之前说的，即使老师换了换了一茬又一茬，对于同学来说，只关心的是调用Callback接口回传必要的信息即可</p>", 
            "topic": [
                {
                    "tag": "回调函数（Callback）", 
                    "tagLink": "https://api.zhihu.com/topics/19571221"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35346679", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 0, 
            "title": "剑指Offer里最有意思的几道题", 
            "content": "<h2>重建二叉树<a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6%3FtpId%3D13%26tqId%3D11157%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">重建二叉树</a></h2><h2>题目描述</h2><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public class Solution {\n    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {\n        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);\n        return root;\n    }\n    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}\n    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) {\n         \n        if(startPre&gt;endPre||startIn&gt;endIn)\n            return null;\n        TreeNode root=new TreeNode(pre[startPre]);\n         \n        for(int i=startIn;i&lt;=endIn;i++)\n            if(in[i]==pre[startPre]){\n                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);\n                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);\n                      break;\n            }\n                 \n        return root;\n    }\n}\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6%3FtpId%3D13%26tqId%3D11158%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">用两个栈实现队列</a></h2><p class=\"ztext-empty-paragraph\"><br/></p><h2><a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba%3FtpId%3D13%26tqId%3D11159%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">旋转数组的最小数字</a></h2>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35321866", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 6, 
            "title": "leetcode、编程之美、剑指offer 二叉树面试题", 
            "content": "<p>首先给出五道关于二叉树的面试题，题目很简单，这里会给出简单分析，具体代码，这里只给出最优解法。</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>◆找出二叉树中最远结点的距离<br/>◆由前序遍历和中序遍历重建二叉树<br/>◆判断一棵二叉树是否为完全二叉树<br/>◆求二叉树中两个结点的最近公共祖先<br/>◆将二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"50\" data-rawheight=\"50\" data-thumbnail=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.jpg\" class=\"content_image\" width=\"50\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;50&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"50\" data-rawheight=\"50\" data-thumbnail=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.jpg\" class=\"content_image lazy\" width=\"50\" data-actualsrc=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>找出二叉树中最远结点的距离</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先需要考虑一下，二叉树中什么距离是最远距离。以根节点为轴，左右子树的最大深度？当然这只是一部分。准确地说，最大深度是以根节点为轴，左右子树的最大深度之和与以各个子树的根节点为轴左右子树的最大深度之和的较大值。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虽然有点绕，看下图就会明白。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f83d91027844b67acf9915dd64eb6639_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f83d91027844b67acf9915dd64eb6639_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;360&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"640\" data-rawheight=\"360\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f83d91027844b67acf9915dd64eb6639_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f83d91027844b67acf9915dd64eb6639_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>思路一：</b>解决这个问题最直接的方式就是遍历。对每个结点求深度，之后再与保存的最大深度max_depth进行对比，但对于O(n^2)的时间复杂度，我们还是选择能避免就避免，这应该是一种比较糟糕的时间复杂度。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>思路二：</b>针对思路一，可以发现，我们重复了大量的遍历工作。对每一个结点求深度，对最深的一个结点遍历了n^2次，没有线索化过的二叉树遍历，最常用的是递归方法，因此，我们可以仅仅通过一次递归，同时得到该结点的深度和以该节点为根的子树的最大距离。当然，由于深度是相对整个遍历过程的，因此在递归过程中，它应该是以引用的方式进行传递，我们这里不需要将深度也作为一个参数进行传递，原因很简单，深度完全可以在递归的时候用返回值接收，这也解决了对左右子树深度的比较选取的过程中多余创建出的变量。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">int MaxDistance()\n       {             \nif (_root == NULL)                    \nreturn 0;\n             int max = 0;\n             _MaxDistance(_root, max);             \nreturn max;\n       }\n       int _MaxDistance(Node* cur, int&amp; max) // 只返回深度\n       {             \nif (cur == NULL)                    \nreturn 0;\n             int leftDepth = _MaxDistance(cur-&gt;_left, max);\n             int rightDepth = _MaxDistance(cur-&gt;_right, max);             if (leftDepth + rightDepth &gt; max)\n                    max = leftDepth + rightDepth;             \nreturn leftDepth &gt; rightDepth ? leftDepth + 1 : rightDepth + 1;\n       }</code></pre></div><p>代码看上去很简单，这里巧妙之处在于在MaxDistance()函数中，我们没有用它调用的_MaxDistance()函数的返回值，该函数返回值的作用，仅仅是为了提供递归返回使用。我们需要的max_distance是通过传递引用的方式获取的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><b><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"50\" data-rawheight=\"50\" data-thumbnail=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.jpg\" class=\"content_image\" width=\"50\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;50&#39; height=&#39;50&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"50\" data-rawheight=\"50\" data-thumbnail=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.jpg\" class=\"content_image lazy\" width=\"50\" data-actualsrc=\"https://pic2.zhimg.com/v2-a64bce009b774b2bf80c0b8d16e648dd_b.gif\"/></figure></b><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>由前序遍历和中序遍历重建二叉树</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>链接：<a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/questionTerminal/8a19cbe657394eeaac2f6ea9b0f6fcf6\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://www.</span><span class=\"visible\">nowcoder.com/questionTe</span><span class=\"invisible\">rminal/8a19cbe657394eeaac2f6ea9b0f6fcf6</span><span class=\"ellipsis\"></span></a><br/>来源：牛客网</p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这道题应该是网上做烂的题目，这里只是重新提一下，因为它并没有什么建档方法可言。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们需要考虑，前、中、后序遍历三种方式遍历结果有什么特点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>前序遍历：</b>第一个元素必然是根节点，扩展一点将，如果我们从前序遍历的序列中取出的一段属于某个子树的前序遍历段，那么该子序列的第一个结点也将是该子树的根节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>中序遍历：</b>中序遍历由于是先左后根，最后再右的顺序，因此，当我们知道某个结点为跟结点的话，那么它的左右两侧分别是左子树和右子树的中序遍历序列。同上，也扩展一点将，只要可以找到某一段子树中序遍历序列的根节点，那么该序列中，跟结点的左右两侧序列也是该子树的左右子树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>后续遍历：</b>后续遍历的特点是遍历完左右结点之后再遍历跟结点。和前序遍历的区别就在于把根节点放到了最后访问，因此，两种遍历的结果类似，只不过需要从后向前依次取元素。也就是说，最后一个元素，是当前树的根节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>经过上面的分析，我们可以得出一个这样的结论，如果我们想重建二叉树，我们至少需要两种遍历的序列，而且必须要有中序遍历序列。</p><p>前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接下来我们讨论如何利用前序和中序遍历的结果重建二叉树。大致可分为以下四步： </p><p class=\"ztext-empty-paragraph\"><br/></p><p>1、用前序序列的第一个结点作为根结点;  {<b>1</b>,2,4,7,3,5,6,8}</p><p>2、在中序序列中查找根结点的位置，并以此为界将中序序列划分为左、右两个序列(左、右子树);</p><p>     中序遍历序列{4,7,2,  1,   5,3,8,6}</p><p>3、根据左、右子树的中序序列中的结点个数，将前序序列去掉根结点后的序列划分为左、右两个序列，它们分别是左、右子树的前序序列;</p><p>      {2,4,7,    3,5,6,8}  此时原来的根节点 1 ，已经加入了二叉树中。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>4、对左、右子树的前序序列和中序序列递归地实施同样方法，直到所得左、右子树为空。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>举例描述递归过程：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>需要一直注意边界条件。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>  reconstructTree(int[] preOrder, int prestart, int preEnd,  int[] inOrder, int inStart, int inEnd, TreeNode node )   Fuction (1)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>初始化阶段 0</p><p>1、前序遍历 {<b>1</b>,2,4,7,3,5,6,8} [preStart, preEnd] ， 将preOrder[preStart] 作为根节点</p><p>2、在中序遍历   {4,72      5, 3  8 6    }   [inStart, inEnd]  中找到  1  的位置  rootIndex  ，先取 inOrder中 [inStart , rootIndex -1] 一段处理， 再取 [ rootIndex+1, inEnd ]处理</p><p>3、 根据 [iS, rI - 1] 在 pre中找到对应的 [pS + 1,   pS + 1 + rI - 1 - iS] 并传入 Function （1） 递归处理。</p><p>     根据 [rI + 1, iE ]  在pre中找到对应的 [ pS+ rI - iS，pS+ rI - iS + （iE - rI  - 1）  ]  </p><p>能把这个过程描述出来就可以写代码了</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>以下是初始举例过程， 后来抽象化为   int[] preOrder, int prestart, int preEnd,  int[] inOrder, int inStart, int inEnd——</p><p>第一层递归 处理  [preStart, preEnd] = {2,4,7}  he [inStart, inEnd ] = {4,7,2} 的部分</p><p>一、1</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1、前序遍历 [preStart, preEnd] = {2,4,7}</p><p>2、[inStart, inEnd ] = {4,7,   2}   把2取出来插入树中作为左孩子</p><p>3、先根据 inOrder[0, rootIndex - 1] 去找到 preOder[1,rootIndex] 这一段，然后一起配合处理。</p><p>    再处理inOrder[rootIndex, inEnd]  和  preOrder[rootIndex+ 1， preEnd]这一块。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p>第二层递归.2  [preStart, preEnd] = {3 5 6 8}  [inStart, inEnd ] = {5 3 8 6}</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>算法流程框架</b></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-28e6caaa809e831710fdb2ee19a9493e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https://pic3.zhimg.com/v2-28e6caaa809e831710fdb2ee19a9493e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;462&#39; height=&#39;651&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"651\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https://pic3.zhimg.com/v2-28e6caaa809e831710fdb2ee19a9493e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-28e6caaa809e831710fdb2ee19a9493e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><a class=\"member_mention\" href=\"https://www.zhihu.com/people/e3721c007ec41316291548036e1b2454\" data-hash=\"e3721c007ec41316291548036e1b2454\" data-hovercard=\"p$b$e3721c007ec41316291548036e1b2454\">@ProcessOn</a>   ProcessOn Bug有点多诶，连接箭头都画不出来， 清明快乐啦。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这道题笔试现场30分钟是来不及推导出来的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>结合举例过程和流程图，进行编码测试：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下来看另一种输入下的实现代码。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">typedef BinaryTreeNode&lt;char&gt; Node;   \nNode* ReBuildTree(const string preorder, const string inorder)   \n{   \n   if (preorder.empty())   \n       return NULL;   \n   char root_value = preorder[0];   \n   Node* node = new Node(root_value);   \n   size_t index = inorder.find(root_value);   \n   string left_preorder = preorder.substr(1, index);    \n   string left_inorder = inorder.substr(0, 3);   \n   string right_preorder = preorder.substr(index + 1, preorder.size() - index - 1);   \n   string right_inorder = inorder.substr(index + 1, inorder.size() - index - 1);   \n   node-&gt;_left = ReBuildTree(left_preorder, left_inorder);   \n   node-&gt;_right = ReBuildTree(right_preorder, right_inorder);   \n   return node;   \n}   \n\nvoid InOrder(Node* node)   \n{   \n            if (node == NULL)   \n                        return;   \n            InOrder(node-&gt;_left);   \n            cout &lt;&lt; node-&gt;_data &lt;&lt; &#34;  &#34;;   \n            InOrder(node-&gt;_right);   \n}</code></pre></div><p>仔细观察可以发现，这里使用的容器是string，我这里选用string作为容器，是因为string有自带的查找某个元素的功能，同时可以实现部分截取，方便构建子序列，缺点就是每个结点中key的类型只能是字符。当然，这里也可以选用vector等其他容器，只不过vector没有内置的Find函数，因此在中序遍历序列中找根节点的时候需要进行遍历，vector构建子序列时也并不复杂，可以通过迭代器区间直接构造一个vector对象。这里点到为止。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p><b>判断一棵二叉树是否为完全二叉树</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先需要知道的是什么是满二叉树。若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>判断一棵树是不是满二叉树，就不能再像之前那样，递归去遍历，因为递归是在走深度，所以解决这一问题，需要借助queue完成层序遍历。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>我们简单的层序遍历是先将根节点入队列，之后依次访问队列的front结点，访问完成，将front结点pop，同时将左右不为空的子节点入队列，直到队列为空。这一点应该没有太大问题。回想一下，我们在简单层序遍历的时候，注意了什么问题？如果子结点为NULL，则不入队列，防止下次对空结点进行访问 。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>回到我们一开始的问题，判断一棵二叉树是否为满二叉树。这里在简单层序遍历上做一些处理，先不考虑队列的问题，当我们简单地在走层序遍历过程中，当碰到一个结点为NULL时，如果之后都是空结点，那么该二叉树为完全二叉树，否则，不满足完全二叉树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>因此，要实现这个逻辑，就不能只是简单地把非空结点入队列，所有结点都需要入队列，当front变为NULL时，表示读取到了一个空结点，此时，它的子节点之前的所有结点都已经入队列，当队列中还存在空结点，则该树不满足满二叉树。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代码实现如下：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">bool IsFullBinaryTree()   \n            {   \n                        if (_root == NULL)   \n                                    return true;   \n                        queue&lt;Node*&gt; que;   \n                        que.push(_root);   \n                        Node* front = NULL;   \n                        while (front = que.front())   \n                        {   \n                                    que.push(front-&gt;_left);   \n                                    que.push(front-&gt;_right);   \n                                    que.pop();   \n                        }   \n                        while (!que.empty())   \n                        {   \n                                    if (que.front() != NULL)   \n                                                return false;   \n                                    que.pop();   \n                        }   \n                        return true;   \n            }</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p><b>求二叉树中两个结点的最近公共祖先</b> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>第一次看到这道题，感觉无从下手，后来仔细想想，不是废话么，只告诉了要找最近公共祖先，二叉树的特点都不知道，怎么找......没办法，分情况看。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>情况一：搜索二叉树</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这应该是最简单的情况了，搜索二叉树始终满足根结点大于左孩子，小于右孩子。那他们的公共祖先的key值就必然介于两个结点之间。即</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">(root-&gt;_data &gt;= node1-&gt;_data &amp;&amp; root-&gt;_data &lt;= node2-&gt;_data)   \n  ||(root-&gt;_data &gt;= node2-&gt;_data &amp;&amp; root-&gt;_data &lt;= node1-&gt;_data)</code></pre></div><p>因此，这样一来就简单了很多，代码实现如下： </p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">typedef SearchTreeNode&lt;int&gt; Node;   \nNode* FindParent_SearchTree(Node* node1, Node* node2, Node* root)   \n{   \n       if (root == NULL)   \n             return NULL;   \n       if (node1 == NULL)   \n             return node2;   \n       if (node2 == NULL)   \n             return node1;   \n       while (1)   \n       {       \n             if(root === NULL)   \n                 assert(false);   \n             if ((root-&gt;_data &gt;= node1-&gt;_data &amp;&amp; root-&gt;_data &lt;= node2-&gt;_data)   \n                    || (root-&gt;_data &gt;= node2-&gt;_data &amp;&amp; root-&gt;_data &lt;= node1-&gt;_data))   \n             {   \n                    return root;   \n             }   \n             else if (root-&gt;_data &gt; node1-&gt;_data)   \n                    root = root-&gt;_left;   \n             else   \n                    root = root-&gt;_right;   \n       }   \n}</code></pre></div><p>最开始的判断条件是为了防止BUG的出现的。因为这种做法有个缺陷，如果两个结点不再树中呢？但是再想一想，我传递的参数是 Node* ，该结点一定是通过Find()函数或其他可以返回Node* 类型的函数返回的，如果不存在某个结点，这里参数传递一定是NULL，因此这里添加了if判断。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>情况二：带父指针的二叉树 </b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>如果说一个该二叉树结构中有父指针，那么这道题处理起来就应该容易的多。有父指针，意味着我可以从下向上去遍历，沿着父节点的路径直到走到根节点。那问题就转化为求两个单链表的交点CrossNode。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>求解单链表的交点解法有两种，一就是对两个单链表进行遍历并求出长度，然后再重新遍历，第二次遍历时，较长的单链表的指针要先走长度差次，当两个指针相同时，表明相遇，如果走到NULL，则只有一种情况，这两个结点不在一棵树内。第二种方法就是构建环。让根节点的父指针parent指向其中一个结点，以另一个结点为头，判断链表是否带环。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里给出通过找交点找到最近公共结点的代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">Node* NearestParent(Node* Node1, Node* Node2)   \n       {   \n             if (_root == NULL)   \n                    return NULL;   \n             if (Node1 == NULL || Node2 == NULL)   \n                    assert(false);   \n             int length1 = 0;   \n             int length2 = 0;   \n             Node* cur1 = Node1;   \n             Node* cur2 = Node2;   \n             while (cur1 != NULL)   \n             {   \n                    length1++;   \n                    cur1 = cur1-&gt;_parent;   \n             }   \n             while (cur2 != NULL)   \n             {   \n                    length2++;   \n                    cur2 = cur2-&gt;_parent;   \n             }   \n             Node*  long_List = NULL;   \n             Node*  short_List= NULL;   \n             if (length1 &gt; length2)   \n             {   \n                    long_List = Node1;   \n                    short_List = Node2;   \n             }   \n             else // length1 &lt;= length2   \n             {   \n                    long_List = Node2;   \n                    short_List = Node1;   \n             }   \n             int distance = abs(length1 - length2);   \n             while (distance--)   \n             {   \n                    long_List = long_List-&gt;_parent;   \n             }   \n             while (long_List != NULL)   \n             {   \n                    if (long_List == short_List)   \n                           return long_List;   \n                    long_List = long_List-&gt;_parent;   \n                    short_List = short_List-&gt;_parent;   \n             }   \n             return NULL;   \n       }</code></pre></div><p><b>情况三：任意一棵不带父节点的二叉树</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>这种情况应该是最复杂的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这里给出一种新思路，应该很少用过的。在C++里面，有个结构体叫pair，是库里封装好的，提供了两个成员，通过这种方式，我们可以一次返回多个值。给出pair的定义。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">template&lt;classT1,classT2&gt;structpair   \n{typedefT1 first_type;typedefT2 second_type;   \n\n  T1 first;   \n  T2 second;   \n  pair() : first(T1()), second(T2()) {}   \n}</code></pre></div><p>给这个东西有什么用呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>继续回到我们一开始的问题。我们要找两个结点的最近父节点。当然一层嵌套一层地遍历二叉树也有可能得出结果，但效率太低，至少是O(n^2)的时间复杂度。我们得到什么信息的时候，可以确定一个结点是他们的公共祖先？如果我们可以得到信息，在该结点的左右子树中找到了两个结点，那这个结点一定是他们的父节点（先不考虑是否为最近）。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>换句话说，我们需要在一个结点出得到的信息，应该是在它的左右子树中遍历到的两个结点的个数。同时因为要采用的是递归遍历，因此我们需要返回该结点。怎么解决“最近”的问题呢？递归给我们提供了方便，只要在一开始进行一次判断即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>代码实现如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">Node* NearestParent(Node* Node1, Node* Node2)   \n       {   \n             if (_root == NULL)   \n                    return NULL;   \n             if (Node1 == NULL || Node2 == NULL)   \n                    assert(false);   \n             pair&lt;Node*, int&gt; ret = NodeNearestParent(_root, Node1, Node2);   \n             return ret.first;   \n       }   \n\n       pair&lt;Node*, int&gt; NodeNearestParent(Node* root, Node* node1, Node* node2)   \n       {   \n             if (root == NULL)   \n                    return pair&lt;Node*, int&gt;(NULL, 0);   \n             pair&lt;Node*, int&gt; left_pair = NodeNearestParent(root-&gt;_left, node1, node2);   \n             pair&lt;Node*, int&gt; right_pair = NodeNearestParent(root-&gt;_right, node1, node2);   \n             if (left_pair.second == 2)   \n                    return left_pair;   \n             if (right_pair.second == 2)   \n                    return right_pair;   \n             int x = 0;   \n             if (root == node1 || root == node2)   \n                    x = 1;   \n             return pair&lt;Node*, int&gt;(root, left_pair.second + right_pair.second + x);   \n       }</code></pre></div><p>pair结构题中保存的两个对象，第一个是当前结点，另外一个是在它左右子树中找到的两个结点个数，当然包括了它自己。一旦当某次发现，该结点的second为2时，表明该结点就是我们要找的最近父结点。这里采用的依旧是后续遍历的方式。 </p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\" data-caption=\"\" data-size=\"normal\" class=\"content_image\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;0&#39; height=&#39;0&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" class=\"content_image lazy\" data-actualsrc=\"https://pic2.zhimg.com/v2-3c40829a650f96ab57be6975d78f8601_b.jpg\"/></figure><h2><b>将二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p>这道题应该和二叉树的线索化类似，不过有一点不同的是，线索化只是针对空结点而言的，只有当二叉树中某个指针为空，才需要改变它的指向。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>对于二叉搜索树而言，它的中序遍历序列就是有序的，因此，这里依旧采用的是中序遍历来改变它。将二叉树转换为双向链表，其实就是让左孩子指针指向当前结点的前一个结点，右孩子指针指向下一个结点（？？）。因此遍历的时候，需要两个指针，prev和cur。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>还有一点需要注意，转换为双向链表之后，二叉树的结构即不复存在，我们就不能再通过根节点去遍历二叉树，因此这里在将二叉树转换为双向链表之前，首先要做的是保存它的最左结点，因为它的最左结点是双向链表的头结点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>代码实现如下：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">Node* BinaryTreeToList()   \n            {   \n                        if (_root == NULL)   \n                                    return NULL;   \n                        Node* head = _root;   \n                        while (head-&gt;_left != NULL)   \n                        {   \n                                    head = head-&gt;_left;   \n                        }   \n                        Node* prev = NULL;   \n                        _Translate(_root, prev);   \n                        return head;   \n            }   \n            void _Translate(Node* root, Node*&amp; prev) // prev要传递引用   \n            {   \n                        if (root == NULL)   \n                                    return;   \n                        _Translate(root-&gt;_left, prev);   \n                        root-&gt;_left = prev;   \n                        if (prev)   \n                                    prev-&gt;_right = root;   \n                        prev = root;   \n                        _Translate(root-&gt;_right, prev);   \n            }</code></pre></div><p>这就是这五道面试题，解题思路和代码已经给出。可以发现，递归是降低二叉树时间复杂度的有效方式，时间复杂度一般可以用O(n^2)降低到O(n)，缺点就是带来了O(logN)的空间复杂度，logN是非常小的复杂度，相对来说，递归解决二叉树在绝大多数情况下，是一种相对较为优的解法。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>同时，这里加入了一种新的思想，就是pair，如何给pair的两个成员分配合理的类型和功能，这个是需要考虑的问题，但不得不说，有些情况下，pair可以带来意想不到的效果。</p>", 
            "topic": [
                {
                    "tag": "剑指Offer（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20121522"
                }, 
                {
                    "tag": "算法与数据结构", 
                    "tagLink": "https://api.zhihu.com/topics/19625716"
                }
            ], 
            "comments": [
                {
                    "userName": "ProcessOn", 
                    "userLink": "https://www.zhihu.com/people/e3721c007ec41316291548036e1b2454", 
                    "content": "<p>嗨，请问你遇到了什么问题呀，我们网站是可以画箭头哒，快速绘制的话直接按L就可以，而且还能更改箭头形状的。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "知乎用户", 
                            "userLink": "https://www.zhihu.com/people/0", 
                            "content": "<p>是可以画  但是chrome上有bug我改用搜狗浏览器了</p>", 
                            "likes": 0, 
                            "replyToAuthor": "ProcessOn"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35373775", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 0, 
            "title": "PriorityQueue 剖析 - 这篇文章是为了做内部培训的写", 
            "content": "<h2>写在前面 - 搜索建议</h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一般直接源码和注释，其次才是搜索 哈哈，也就是来看我的这篇文章 。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>希望各位搜技术网章不要再百度、csdn了，搜出来的文章质量简直没法看， 建议直接 搜狗微信搜索、简书或知乎。</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>其实PriorityQueue 的Comparator我也不记得具体细节了，我都是有个代码模板库， 直接全项目搜索关键词， 照着敲一下就完事了</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>这篇文章是为了做培训的写</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>PriorityQueue   </b></h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img data-rawheight=\"163\" src=\"https://pic3.zhimg.com/v2-b17b4e4faa1f9059e34c848c33c39b22_b.jpg\" data-size=\"normal\" data-rawwidth=\"473\" class=\"origin_image zh-lightbox-thumb\" width=\"473\" data-original=\"https://pic3.zhimg.com/v2-b17b4e4faa1f9059e34c848c33c39b22_r.jpg\"/></noscript><img data-rawheight=\"163\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;473&#39; height=&#39;163&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"473\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"473\" data-original=\"https://pic3.zhimg.com/v2-b17b4e4faa1f9059e34c848c33c39b22_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b17b4e4faa1f9059e34c848c33c39b22_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>ShiftUp函数可以看到java优先队列对Comare函数的使用</b></p><figure data-size=\"normal\"><noscript><img data-rawheight=\"216\" src=\"https://pic4.zhimg.com/v2-7431015a1a0491d2e7b3f8c42243ae07_b.jpg\" data-size=\"normal\" data-rawwidth=\"375\" class=\"content_image\" width=\"375\"/></noscript><img data-rawheight=\"216\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;375&#39; height=&#39;216&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"375\" class=\"content_image lazy\" width=\"375\" data-actualsrc=\"https://pic4.zhimg.com/v2-7431015a1a0491d2e7b3f8c42243ae07_b.jpg\"/></figure><p>你会发现小的元素排在前面。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>PriorityQueue  基本操作</b></h2><figure data-size=\"normal\"><noscript><img data-rawheight=\"172\" src=\"https://pic2.zhimg.com/v2-1deb8b0ecd78b36f5de30ced39ecffc5_b.jpg\" data-size=\"normal\" data-rawwidth=\"275\" class=\"content_image\" width=\"275\"/></noscript><img data-rawheight=\"172\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;275&#39; height=&#39;172&#39;&gt;&lt;/svg&gt;\" data-size=\"normal\" data-rawwidth=\"275\" class=\"content_image lazy\" width=\"275\" data-actualsrc=\"https://pic2.zhimg.com/v2-1deb8b0ecd78b36f5de30ced39ecffc5_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>增</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>   首先我们看添加一个元素到堆结构中，我们使用add或者offer方法完成新添一个元素到堆结构中。</p><div class=\"highlight\"><pre><code class=\"language-text\">public boolean add(E e) {\n   return offer(e);\n}\n\npublic boolean offer(E e) {\n    if (e == null)\n        throw new NullPointerException();\n    modCount++;\n    int i = size;\n    if (i &gt;= queue.length)\n        grow(i + 1);\n   size = i + 1;\n   if (i == 0)\n        queue[0] = e;\n    else\n        siftUp(i, e);\n    return true;\n}\n</code></pre></div><p>实际上add方法的内部调用的还是offer方法，所以我们主要看看offer是如何实现添加一个元素到堆结构中并维持这种结构不被破坏的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>首先该方法定义了一 变量获取queue中实际存放的元素个数，紧接着一个if判断，如果该数组已经被完全使用了（没有可用空间了），会调用grow方法进行扩容，grow方法会根据具体情况判断，如果原数组较小则会扩大两倍，否则增加50%容量，由于具体代码比较清晰，此处不再赘述。接着判断该完全二叉树是否为空，如果没有任何节点，那么直接将新增节点作为根节即可，否则会调用siftUp添加新元素并调整结构，所以该方法是重点。</p><p>private void siftUp(int k, E x) {<br/>    if (comparator != null)<br/>        siftUpUsingComparator(k, x);<br/>    else<br/>        siftUpComparable(k, x);<br/>}</p><p>此处会根据调用者是否传入比较器而分为两种情况，代码类似，我们只看一种即可。</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">private void siftUpUsingComparator(int k, E x) {\n    while (k &gt; 0) {\n        int parent = (k - 1) &gt;&gt;&gt; 1;\n        Object e = queue[parent];\n        if (comparator.compare(x, (E) e) &gt;= 0)\n            break;\n        queue[k] = e;\n        k = parent;\n    }\n    queue[k] = x;\n}\n\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>该方法首先获取最后一个位置的父节点的索引，然后定义变量接受父节点的值，如果新增的节点值和父节点的值比较之后满足堆结构，则直接break返回，否则循环向上交换，最终完成堆结构调整。具体我们通过一个实例演示整个过程：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>略<br/></p><p><b>删除头部</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>/** 这种抛异常<br/> * Retrieves and removes the head of this queue.  This method differs<br/> * from {<b>@link </b>#poll poll} only in that it throws an exception if this<br/> * queue is empty.<br/> *<br/> * <b>@return </b>the head of this queue<br/> * <b>@throws </b>NoSuchElementException if this queue is empty<br/> */<br/></i>E remove();</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>/**  这种返回null<br/> * Retrieves and removes the head of this queue,<br/></i> * or returns {<b>@code </b>null} if this queue is empty.<i><br/> *<br/> * <b>@return </b>the head of this queue, or {<b>@code </b>null} if this queue is empty<br/> */<br/></i>E poll();</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>获取头部</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>/**  这种返回null<br/> * Retrieves, but does not remove, the head of this queue,<br/> * or returns {<b>@code </b>null} if this queue is empty.<br/> *<br/> * <b>@return </b>the head of this queue, or {<b>@code </b>null} if this queue is empty<br/> */<br/></i>E peek();</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i>/** 这种抛异常<br/> * Retrieves, but does not remove, the head of this queue.  This method<br/> * differs from {<b>@link </b>#peek peek} only in that it throws an exception<br/> * if this queue is empty.<br/> *<br/> * <b>@return </b>the head of this queue<br/> * <b>@throws </b>NoSuchElementException if this queue is empty<br/> */<br/></i>E element();</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>文章作者</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>我 和  times 、 CZJ</b></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>写在后面</b></h2><p class=\"ztext-empty-paragraph\"><br/></p><p><b>你要来加入团队吗？  做起来好处很多，我们先成为大V，就可以认识其他领域大V， 比如你要提问其他领域的话题，可以我来代为发布，会有大V回答</b></p>", 
            "topic": [], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35328661", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 0, 
            "title": "剑指offer leetcode 两个栈实现队列", 
            "content": "<p>数组或链表实现栈或队列。</p><p>拓展问题：两个队列实现栈</p><p class=\"ztext-empty-paragraph\"><br/></p><p>栈的接口有 push、pop、 isEmpty()、peek()   先进后出</p><p class=\"ztext-empty-paragraph\"><br/></p><p>队列的接口有 push() 头部  pop() 尾部   先进先出</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>方案一：定义两个栈，一个专门用来插入，一个专门用来弹出。插入操作只会插入到插入栈。弹出的时候，优先从弹出栈往外弹，如果弹出栈中的内容为空，那么就将插入栈中的数据依次弹出，并压入弹出栈，然后再弹出。</p><p>方案二：定义两个栈，不区分作用，但是有一个原则就是始终要保证其中一个栈为空。每次插入的时候先将待插入数据直接插入到空的栈中，然后再将另外一个栈中的数据依次弹出，并压入这个刚刚插入新数据的栈中。弹出的时候，只要从那个有数据的栈中往外弹数据就可以了。</p><p>无论以上哪种方案，其实根本原理都是和我们小时候玩的汉诺塔游戏差不多。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>使用栈来实现队列</b></h2><p>首先我们来考虑如何使用两个栈来实现队列。队列的特点是先进先出，如果向队列中保存&#34;hollis&#34;的顺序是h、o、l、l、i、s，那么取出元素的数序也应该是h、o、l、l、i、s。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-125476294f4ca20e6f2bc3ba71b5a393_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb\" width=\"568\" data-original=\"https://pic4.zhimg.com/v2-125476294f4ca20e6f2bc3ba71b5a393_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;568&#39; height=&#39;239&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"568\" data-rawheight=\"239\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"568\" data-original=\"https://pic4.zhimg.com/v2-125476294f4ca20e6f2bc3ba71b5a393_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-125476294f4ca20e6f2bc3ba71b5a393_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>而对于栈来说，如果你想要让一个元素能够第一个被弹出，就要保证他永远位于栈的顶部。也就是说，如果你希望出站的顺序是h、o、l、l、i、s，那么入站顺序需要时silloh。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-8e82421fb7465abbcd7c333feafefe48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"275\" data-rawheight=\"323\" class=\"content_image\" width=\"275\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;275&#39; height=&#39;323&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"275\" data-rawheight=\"323\" class=\"content_image lazy\" width=\"275\" data-actualsrc=\"https://pic1.zhimg.com/v2-8e82421fb7465abbcd7c333feafefe48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>我们现在已经有的数据结构是栈，如果按照h、o、l、l、i、s的顺序向一个栈中保存数据的话，这些元素在栈中的顺序应该是s、i、l、l、o、h。也就是他正常的弹出顺序应该是silloh，但是我们想要的弹出顺序是hollis。 那么如何解决这个问题呢，就需要另外一个栈来配合，两个栈互相倒换。具体如何操作呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-1b8896a1eda6770306dfebd307051c42_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-1b8896a1eda6770306dfebd307051c42_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;465&#39; height=&#39;427&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"465\" data-rawheight=\"427\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"465\" data-original=\"https://pic3.zhimg.com/v2-1b8896a1eda6770306dfebd307051c42_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-1b8896a1eda6770306dfebd307051c42_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>有一种方案是这样的：两个栈严格区分开来使用，一个专门用来做插入（插入栈），一个专门用来做弹出（弹出栈）。这样在做插入的时候什么都不需要做，直接调用插入栈的push方法就可以了。但是在弹出的时候就要麻烦一点，先判断在弹出栈中是否包含数据，如果包含，直接从顶部弹出，如果不包含，把插入栈中的元素挨个导入到弹出栈中。然后再从栈顶将第一个元素弹出。</p><p>说起来好像挺绕的，没关系。接着往下看，我们先来定义一下这个队列：</p><div class=\"highlight\"><pre><code class=\"language-text\">class MyQueue {\n       stack&lt;int&gt; in;\n       stack&lt;int&gt; out;\n}</code></pre></div><p>接下来，我们通过一张图来模拟下如何使用两个栈来实现队列的插入操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-cff1ccd344042d4437fcbb8a72e6c022_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-cff1ccd344042d4437fcbb8a72e6c022_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic3.zhimg.com/v2-cff1ccd344042d4437fcbb8a72e6c022_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-cff1ccd344042d4437fcbb8a72e6c022_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上图中可以看出来，插入还是比较简单的，只需要往插入栈中push就可以了，代码实现如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">void push(int x) {\n   in.push(x);\n}</code></pre></div><p>插入的时候简单了，那么弹出的时候可能就要经过一番操作了。再来一张图，看看如何使用两个栈来实现队列的弹出操作。 简单介绍下过程：队列中原有三个数据，插入顺序是HOL，进行以下三个操作：1、弹出H，2、插入L，3、弹出O。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-09ee7e91c3f6c970595c608b54f2e81d_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-09ee7e91c3f6c970595c608b54f2e81d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1080&#39; height=&#39;350&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1080\" data-rawheight=\"350\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1080\" data-original=\"https://pic2.zhimg.com/v2-09ee7e91c3f6c970595c608b54f2e81d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-09ee7e91c3f6c970595c608b54f2e81d_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上面的图中可以看到，当我们尝试弹出H的时候，由于stack-out为空，需要把stack-in栈中的数据pop出来，并push进入stack-out，然后再从stack-out的栈顶就能直接弹出H了。 当我们尝试弹出O的时候，因为stack-out中包含数据，那么就直接从stack-out中往外弹数据就可以了。</p><p>代码实现如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">int pop() {\n   if (!out.empty()) {\n       int temp = out.top();\n       out.pop();\n       return temp;\n   }\n   else {\n       if (in.empty()) {\n           return -1;\n       }\n       else {\n           while (!in.empty()) {\n               out.push(in.top());\n               in.pop();\n           }\n           int temp = out.top();\n           out.pop();\n           return temp;\n       }\n   }\n}</code></pre></div><h2><b>使用队列来实现栈</b></h2><p>使用队列来实现栈的方式其实和通过栈实现队列的方式差不多。用以上方法也是可以的。但是，为了让大家更好的掌握这两种数据结构，再给大家提供另外一种思路。</p><p>上面的队列实现中。插入方法并没有额外的操作，只是在弹出的时候需要做些额度的处理。那么另外一个思路就是在插入的时候做些事情，这样在弹出的时候就可以无须额外操作直接弹出了。同样，还是需要两个队列来实现栈。具体如何操作呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-767ce6b06b55a8f9bdfc759c36caec91_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb\" width=\"484\" data-original=\"https://pic2.zhimg.com/v2-767ce6b06b55a8f9bdfc759c36caec91_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;484&#39; height=&#39;420&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"484\" data-rawheight=\"420\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"484\" data-original=\"https://pic2.zhimg.com/v2-767ce6b06b55a8f9bdfc759c36caec91_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-767ce6b06b55a8f9bdfc759c36caec91_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>先来定义一下这个栈：</p><div class=\"highlight\"><pre><code class=\"language-text\">class MyStack {\n   queue&lt;int&gt; a;\n   queue&lt;int&gt; b;\n}</code></pre></div><p>还是通过一张图，看下使用队列实现的栈是如何进行元素的插入的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-6831ea8a357b154e3d85ff1287c097c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"966\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb\" width=\"966\" data-original=\"https://pic1.zhimg.com/v2-6831ea8a357b154e3d85ff1287c097c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;966&#39; height=&#39;618&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"966\" data-rawheight=\"618\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"966\" data-original=\"https://pic1.zhimg.com/v2-6831ea8a357b154e3d85ff1287c097c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-6831ea8a357b154e3d85ff1287c097c8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图中可以看出，用来实现栈的两个队列是不区分用途的，也就是说两个队列都具备插入和弹出的功能。之所以可以这么做的原因就是，他要保证任何时候都只有一个队列中有元素。</p><p>上图的插入操作，插入H的时候，两个队列都为空，优先选择从queue1插入。 当想要插入O的时候，由于queue1中已经包含了数据，那么就讲O插入queue2中，然后再将queue1中的数据依次插入queue2。实现代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">void push(int x) {\n   if (a.empty() &amp;&amp; b.empty()) {\n       a.push(x);\n       return;\n   }\n   if (a.empty()) {\n       a.push(x);\n       while (!b.empty()) {\n           a.push(b.front());\n           b.pop();\n       }\n   }\n   else {\n       b.push(x);\n       while (!a.empty()) {\n           b.push(a.front());\n           a.pop();\n       }\n   }\n}</code></pre></div><p>再来一张图，看看如何使用两个队列来实现栈的弹出操作。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-7566f807727b2d990e3002c943a8942f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"703\" class=\"origin_image zh-lightbox-thumb\" width=\"1030\" data-original=\"https://pic4.zhimg.com/v2-7566f807727b2d990e3002c943a8942f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1030&#39; height=&#39;703&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1030\" data-rawheight=\"703\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1030\" data-original=\"https://pic4.zhimg.com/v2-7566f807727b2d990e3002c943a8942f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-7566f807727b2d990e3002c943a8942f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>由于我们在插入的时候，保证了两个队列中只有一个队列包含数据，并且数据的顺序已经调整好了（包含数据的那个队列的队列头就是整个栈的栈顶），那么就直接从有数据的那个队列中往外弹数据就可以了。实现代码如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">int pop() {\n   if (a.empty()) {\n       int temp = b.front();\n       b.pop();\n       return temp;\n   }\n   else {\n       int temp = a.front();\n       a.pop();\n       return temp;\n   }\n}</code></pre></div><p>好了，至此，我们已经完成了使用两个栈实现队列和两个队列实现栈的功能的介绍。总结一下，主要有两种方案。拿通过栈来实现队列举例。</p><p>方案一：定义两个栈，一个专门用来插入，一个专门用来弹出。插入操作只会插入到插入栈。弹出的时候，优先从弹出栈往外弹，如果弹出栈中的内容为空，那么就将插入栈中的数据依次弹出，并压入弹出栈，然后再弹出。</p><p>方案二：定义两个栈，不区分作用，但是有一个原则就是始终要保证其中一个栈为空。每次插入的时候先将待插入数据直接插入到空的栈中，然后再将另外一个栈中的数据依次弹出，并压入这个刚刚插入新数据的栈中。弹出的时候，只要从那个有数据的栈中往外弹数据就可以了。</p><p>无论以上哪种方案，其实根本原理都是和我们小时候玩的汉诺塔游戏差不多。</p><p></p>", 
            "topic": [
                {
                    "tag": "剑指Offer（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20121522"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/35297416", 
            "userName": "一路走好", 
            "userLink": "https://www.zhihu.com/people/5a91ea499517aa95ec3af5c72133918f", 
            "upvote": 0, 
            "title": "剑指offer牛客网上的第一道题，也是今年阿里很多同学电话面试被考到的题", 
            "content": "<h2>在行列均内部递增的二维数组中查找目标值</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>题目网址：<a href=\"https://link.zhihu.com/?target=https%3A//www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e%3FtpId%3D13%26tqId%3D11154%26tPage%3D1%26rp%3D1%26ru%3D/ta/coding-interviews%26qru%3D/ta/coding-interviews/question-ranking\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">二维数组中的查找</a></p><p>以下全部为AC代码.</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>方法一、 逐行遍历+行内二分查找的方法， 时间O( nlogm)</h2><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">public  class Solution {\n\n    /**\n\n     *    0   1     2     3\n\n     0 1   2     3     6\n\n     1 9   10   12    13\n\n     2 12  17   23    25\n\n     3 13  21   31    32\n\n     target 是31\n\n     **/\n\n    // binary search , 严格递增数组\n     public int binarySearchBaseWhile( int target, int[] array, int l, int r){\n\n        //\n        int len = array.length;\n\n\n        //judge array is not empty\n\n        // compare target ot the smallest and the biggest\n        l = 0 ;\n        r = len - 1;\n        int mid = ( l + r ) / 2;\n        while(l &lt;= r){\n\n            mid = ( l + r ) / 2;\n\n            if ( array[mid] == target) return mid;\n            else if( array[mid] &lt; target){\n                l = mid + 1;\n            }\n            else {\n                r = mid -1;\n            }\n        }\n        return -1;\n\n    }\n\n    public boolean Find(int target, int [][] array) {\n\n        int width = array.length;\n\n        if( width &lt;= 0) return false;\n\n        int height = array[0].length;\n\n        if( height &lt;= 0) return false;\n\n        for(int i = 0; i &lt; width; i++ ){\n\n            int tmp = binarySearchBaseWhile( target, array[i], 0, array[i].length - 1);\n\n            if( tmp != -1 ) return true;\n\n        }\n\n        return false;\n\n    }\n\n}</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>快来给我的代码格式挑挑毛病！</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2>方法二、从左下角来看，向上数字递减，向右数字递增，用排除法</h2><p>这种方法如果出题人没有把样例数据说清楚，即y轴0的位置是从上面开始还是从下面开始，自己容易在x轴、y轴的问题上搞晕。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>剑指offer书中的（第三题）样例：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-cpp\"> <span class=\"mi\">1</span>    <span class=\"mi\">2</span>     <span class=\"mi\">8</span>     <span class=\"mi\">9</span>\n <span class=\"mi\">2</span>    <span class=\"mi\">4</span>     <span class=\"mi\">9</span>     <span class=\"mi\">12</span>\n <span class=\"mi\">4</span>    <span class=\"mi\">7</span>    <span class=\"mi\">10</span>     <span class=\"mi\">13</span>\n <span class=\"mi\">6</span>    <span class=\"mi\">8</span>    <span class=\"mi\">11</span>     <span class=\"mi\">15</span> \n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>我自己出的样例：</p><div class=\"highlight\"><pre><code class=\"language-text\">*    0   1     2     3\n\n    0 1   2     3     6\n\n    1 9   10   12    13\n\n    2 12  17   23    25\n\n    3 13  21   31    32\n</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p>先找找规律：</p><p>1、一个矩形的右下角一定是其中最大的数   一条在本题方案中没有用的规律~~</p><p>2、右上角数字所在的列的所有数字一定都大于等于右上角。</p><p>（1）如果要查找的数字等于右上角的数字，直接返回。</p><p>（2） 如果要查找的数字小于右上角的（x,y），这一列可以全部排除，不用参与查找, 然后在（x,y）所在行中搜索一遍，看不能不能找到，如找到则返回，不能找到则 x++，y--， 缩小一圈搜索范围。 继续进行（1）、（2）、（3）</p><p>（3） 如国要查找的数字大于右上角的数字（x,y），则( x , y )所在行可以排出，先在这一列中查找，能找到最好；不能找到再把坐标由（x , y）变为（x+1，y-1）。 继续进行（1）、（2）、（3）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>实际上解题可以更简单一些：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1）如果要查找的数字等于右上角的数字，直接返回。</p><p>（2） 如果要查找的数字小于右上角的（x,y），这一列可以全部排除，不用参与查找, x不变，y--，  继续进行（1）、（2）、（3）</p><p>（3） 如国要查找的数字大于右上角的数字（x,y），则( x , y )所在行可以排出，y不变，x++。 继续进行（1）、（2）、（3）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>具体而言找7的路径为下图中加粗的路径：</p><p class=\"ztext-empty-paragraph\"><br/></p><p>1  <b>2</b> <b> 8</b>  <b>9</b></p><p>2<b> 4</b> 9 12</p><p>4 <b>7 </b>10 13</p><p>6 8 11 15</p><p class=\"ztext-empty-paragraph\"><br/></p><p>找工作是需要手写代码的：</p><p class=\"ztext-empty-paragraph\"><br/></p><p><figure><noscript><img data-rawwidth=\"720\" data-rawheight=\"960\" src=\"https://pic1.zhimg.com/v2-5304cfae4b8090a557516f75f733d280_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-5304cfae4b8090a557516f75f733d280_r.jpg\"/></noscript><img data-rawwidth=\"720\" data-rawheight=\"960\" src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;960&#39;&gt;&lt;/svg&gt;\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic1.zhimg.com/v2-5304cfae4b8090a557516f75f733d280_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5304cfae4b8090a557516f75f733d280_b.jpg\"/></figure></p><br/>跟我混，一切就是这么简单 哈哈", 
            "topic": [
                {
                    "tag": "刷题", 
                    "tagLink": "https://api.zhihu.com/topics/20014038"
                }, 
                {
                    "tag": "剑指Offer（书籍）", 
                    "tagLink": "https://api.zhihu.com/topics/20121522"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/c_176615540"
}
