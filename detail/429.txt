{
    "title": "python", 
    "description": "人生苦短,我用 Python", 
    "followers": [
        "https://www.zhihu.com/people/xin-ba-33-19", 
        "https://www.zhihu.com/people/cang-yun-86", 
        "https://www.zhihu.com/people/neo1943", 
        "https://www.zhihu.com/people/christonroad", 
        "https://www.zhihu.com/people/butterflyme", 
        "https://www.zhihu.com/people/yang-qi-wei-78", 
        "https://www.zhihu.com/people/hu-xiao-di-59-3", 
        "https://www.zhihu.com/people/ai-bing-kuai-le-zhao-49", 
        "https://www.zhihu.com/people/xiaomm8341", 
        "https://www.zhihu.com/people/you-yong-xue-yuan-70", 
        "https://www.zhihu.com/people/bi-lie-zhu", 
        "https://www.zhihu.com/people/zhong-wu-mi-fan-xia-wu-mian", 
        "https://www.zhihu.com/people/zampochung", 
        "https://www.zhihu.com/people/tang-jun-64-45", 
        "https://www.zhihu.com/people/yu-ling-41-71", 
        "https://www.zhihu.com/people/yuan-rong-zheng", 
        "https://www.zhihu.com/people/xu-yi-zong-13", 
        "https://www.zhihu.com/people/pu-a-41", 
        "https://www.zhihu.com/people/huan-le-dou-62", 
        "https://www.zhihu.com/people/song-xiang-33", 
        "https://www.zhihu.com/people/yin-tian-chou-81", 
        "https://www.zhihu.com/people/xianjianmin-9", 
        "https://www.zhihu.com/people/volte-zhang", 
        "https://www.zhihu.com/people/liang-wen-quan-7", 
        "https://www.zhihu.com/people/chen-zhi-cong-9-91", 
        "https://www.zhihu.com/people/edward-young", 
        "https://www.zhihu.com/people/xiao-xiao-35-12-93-10", 
        "https://www.zhihu.com/people/che-tui-hou", 
        "https://www.zhihu.com/people/xiao-qiang-94-61", 
        "https://www.zhihu.com/people/bbdb", 
        "https://www.zhihu.com/people/haha71", 
        "https://www.zhihu.com/people/xiong-mo-zhou", 
        "https://www.zhihu.com/people/matthew-chen", 
        "https://www.zhihu.com/people/feng-yu-42-59", 
        "https://www.zhihu.com/people/liang-hao-jun-16-90", 
        "https://www.zhihu.com/people/jianbo-zhang", 
        "https://www.zhihu.com/people/wayne-wayne-87", 
        "https://www.zhihu.com/people/chen-meng-jie-85", 
        "https://www.zhihu.com/people/chen-sheng-12-2", 
        "https://www.zhihu.com/people/tao-tao-30-78-15", 
        "https://www.zhihu.com/people/hao-yu-29-42", 
        "https://www.zhihu.com/people/fucktheholl", 
        "https://www.zhihu.com/people/wo-xihao-xian-sen", 
        "https://www.zhihu.com/people/ao-de-si-nuo", 
        "https://www.zhihu.com/people/nana-zhou-32", 
        "https://www.zhihu.com/people/guan-li-ming-81", 
        "https://www.zhihu.com/people/wj2014-59", 
        "https://www.zhihu.com/people/phoebuschan", 
        "https://www.zhihu.com/people/wei-du-xi-wang", 
        "https://www.zhihu.com/people/hao-jiu-bu-jian-73-22", 
        "https://www.zhihu.com/people/taohua-daozhu", 
        "https://www.zhihu.com/people/dao-xing-di-xia", 
        "https://www.zhihu.com/people/han-feng-99-49", 
        "https://www.zhihu.com/people/tang-da-chui-72-46", 
        "https://www.zhihu.com/people/chang-lin-tao-0309", 
        "https://www.zhihu.com/people/xing-kong-27-40-39", 
        "https://www.zhihu.com/people/mywords", 
        "https://www.zhihu.com/people/cwxing", 
        "https://www.zhihu.com/people/jiu-ye-20-63", 
        "https://www.zhihu.com/people/chsword-70", 
        "https://www.zhihu.com/people/wangchonglie", 
        "https://www.zhihu.com/people/wei-bo-7-68", 
        "https://www.zhihu.com/people/lvrm", 
        "https://www.zhihu.com/people/bu-ru-gui-qu-22-63", 
        "https://www.zhihu.com/people/demo-49-57", 
        "https://www.zhihu.com/people/tang-gao-fei-83", 
        "https://www.zhihu.com/people/fu-chun-76-57", 
        "https://www.zhihu.com/people/zhuzhu-53-20", 
        "https://www.zhihu.com/people/xiong-mao-yan-26-49", 
        "https://www.zhihu.com/people/ma-yue-29-78-58", 
        "https://www.zhihu.com/people/zong-jin-yu", 
        "https://www.zhihu.com/people/jia-yi-ba", 
        "https://www.zhihu.com/people/wu-sheng-quan-12", 
        "https://www.zhihu.com/people/ma-hao-54-69", 
        "https://www.zhihu.com/people/zhang-shu-tao-44-51", 
        "https://www.zhihu.com/people/xiao-gui-nu-3-30", 
        "https://www.zhihu.com/people/yang-yang-he-jia-jia", 
        "https://www.zhihu.com/people/dydra", 
        "https://www.zhihu.com/people/mu-niu-cai-dian-xian", 
        "https://www.zhihu.com/people/yi-wen-7-31", 
        "https://www.zhihu.com/people/timchok", 
        "https://www.zhihu.com/people/sushuangju", 
        "https://www.zhihu.com/people/ji-chuan-qing-90", 
        "https://www.zhihu.com/people/bot-24", 
        "https://www.zhihu.com/people/yun-zhong-yue-14", 
        "https://www.zhihu.com/people/li-wen-qi-14-93", 
        "https://www.zhihu.com/people/yuwenxianglong", 
        "https://www.zhihu.com/people/bocley", 
        "https://www.zhihu.com/people/xu-dong-62-2", 
        "https://www.zhihu.com/people/lao-nan-hai-64", 
        "https://www.zhihu.com/people/deng-deng-89-51", 
        "https://www.zhihu.com/people/banana-45-48", 
        "https://www.zhihu.com/people/yan-ze-yu", 
        "https://www.zhihu.com/people/huo-gu-zi", 
        "https://www.zhihu.com/people/gzydominating", 
        "https://www.zhihu.com/people/hu-yu-78-8", 
        "https://www.zhihu.com/people/yi0921", 
        "https://www.zhihu.com/people/pythonfa-shao-you", 
        "https://www.zhihu.com/people/zl-shen-38", 
        "https://www.zhihu.com/people/feng-tai-ji-3"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/31398854", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 1, 
            "title": "震惊！原来命令行还可以这么玩？！", 
            "content": "<h2><b>引言</b></h2><p>你是否：</p><ul><li>好奇过命令行里那些花里胡哨的进度条是如何实现的？</li><li>好奇过Spring Boot为什么能够打印五颜六色的日志？</li><li>好奇过Python或者PHP等脚本语言的交互式命令行是如何实现的？</li><li>好奇过Vim或者Emacs等在Terminal中的编辑器是怎么实现的？</li></ul><p>如果你曾经好奇过，或者被这段话勾起了你的好奇心，那么你绝对不能错过这篇文章！</p><h2><b>背景</b></h2><p>通过本文你可以学到：</p><ol><li>何为Ansi Escape Codes以及它们能干什么？</li><li>Ansi Escape Codes的一些高级应用。</li><li>JDK9中Jshell的使用。</li></ol><h2><b>环境</b></h2><ul><li>Mac或Linux或者WIn10操作系统。<b>除了Win10之外的Windows系统暂时不支持Ansi Escape Codes。</b></li><li>因为本文采用Jshell作为演示工具，所以大家需要安装最近刚正式发布的JDK9。</li></ul><p>OK！一切准备就绪，让我们开始吧！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c1ca7751036efa517374438db4ded79f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"210\" data-rawheight=\"213\" class=\"content_image\" width=\"210\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;210&#39; height=&#39;213&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"210\" data-rawheight=\"213\" class=\"content_image lazy\" width=\"210\" data-actualsrc=\"https://pic4.zhimg.com/v2-c1ca7751036efa517374438db4ded79f_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>富文本</b></h2><p>Ansi Escape Codes最基础的用途就是让控制台显示的文字以富文本的形式输出，比如设置字体颜色、背景颜色以及各种样式。让我们先来学习如何设置字体颜色，而不用再忍受那枯燥的黑白二色！</p><h2><b>字体颜色</b></h2><p>通过Ansi指令（即Ansi Escape Codes）给控制台的文字上色是最为常见的操作。比如：</p><ul><li>红色：<code>\\u001b[31m</code></li><li>重置：<code>\\u001b[0m</code></li></ul><p>绝大部分Ansi Escape Codes都以<code>\\u001b</code>开头。让我们通过Java代码来输出一段红色的<code>Hello World</code>：</p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[31mHello World&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-d7806e494086e5212bb8d76345e8f275_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"59\" class=\"content_image\" width=\"358\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;358&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"358\" data-rawheight=\"59\" class=\"content_image lazy\" width=\"358\" data-actualsrc=\"https://pic2.zhimg.com/v2-d7806e494086e5212bb8d76345e8f275_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从上图中，我们可以看到，不仅<code>Hello World</code>是变成了红色，而且接下来的<code>jshell&gt;</code>提示符也变成了红色。其实不管你接下来输入什么字符，它们的字体颜色都是红色。直到你输入了其他颜色的Ansi指令，或者输入了重置指令，字体的颜色才会不再是红色。</p><p>让我们尝试输入重置指令来恢复字体的颜色：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">1\nSystem.out.print(&#34;\\u001b[0m&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-74b234008fd362a38817c6340ba6b318_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"94\" class=\"content_image\" width=\"360\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;360&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"360\" data-rawheight=\"94\" class=\"content_image lazy\" width=\"360\" data-actualsrc=\"https://pic1.zhimg.com/v2-74b234008fd362a38817c6340ba6b318_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>很好！<code>jshell&gt;</code>提示符恢复为了白色。所以一个最佳实践就是，最好在所有改变字体颜色或者样式的Ansi Escape Codes的最后加上重置指令，以免造成意想不到的后果。举个例子：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">1\nSystem.out.print(&#34;\\u001b[31mHello World\\u001b[0m&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5bdfe871f7a3189bc0e8d56a70f5ae39_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"419\" data-rawheight=\"61\" class=\"content_image\" width=\"419\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;419&#39; height=&#39;61&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"419\" data-rawheight=\"61\" class=\"content_image lazy\" width=\"419\" data-actualsrc=\"https://pic2.zhimg.com/v2-5bdfe871f7a3189bc0e8d56a70f5ae39_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>当然，重置指令可以被添加在任何位置，比如我们可以将其插在<code>Hello World</code>的中间，使得<code>Hello</code>是红色，但是<code>World</code>是白色：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">1\nSystem.out.print(&#34;\\u001b[31mHello\\u001b[0m World&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-5478c8a5fb4887eac4ae8807c3a627b9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-5478c8a5fb4887eac4ae8807c3a627b9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;422&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"422\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"422\" data-original=\"https://pic2.zhimg.com/v2-5478c8a5fb4887eac4ae8807c3a627b9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5478c8a5fb4887eac4ae8807c3a627b9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>8色</b></h2><p>刚才我们介绍了<code>红色</code>以及<code>重置</code>命令。基本上所有的控制台都支持以下8种颜色：</p><ul><li>黑色：<code>\\u001b[30m</code></li><li>红色：<code>\\u001b[31m</code></li><li>绿色：<code>\\u001b[32m</code></li><li>黄色：<code>\\u001b[33m</code></li><li>蓝色：<code>\\u001b[34m</code></li><li>洋红色：<code>\\u001b[35m</code></li><li>青色：<code>\\u001b[36m</code></li><li>白色：<code>\\u001b[37m</code></li><li>重置：<code>\\u001b[0m</code></li></ul><p>不如将它们都输出看一下：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[30m A \\u001b[31m B \\u001b[32m C \\u001b[33m D \\u001b[0m&#34;);</code></pre></div><p>System.out.print(&#34;\\u001b[34m E \\u001b[35m F \\u001b[36m G \\u001b[37m H \\u001b[0m&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2f51eafc54b3cc3ebe578a7fdef57320_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-2f51eafc54b3cc3ebe578a7fdef57320_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;637&#39; height=&#39;92&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"637\" data-rawheight=\"92\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"637\" data-original=\"https://pic1.zhimg.com/v2-2f51eafc54b3cc3ebe578a7fdef57320_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2f51eafc54b3cc3ebe578a7fdef57320_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>注意，<code>A</code>因为是黑色所以与控制台融为一体了。</p><h2><b>16色</b></h2><p>大多数的控制台，除了支持刚才提到的8色外，还可以输出在此之上更加明亮的8种颜色：</p><ul><li>亮黑色：<code>\\u001b[30;1m</code></li><li>亮红色：<code>\\u001b[31;1m</code></li><li>亮绿色：<code>\\u001b[32;1m</code></li><li>亮黄色：<code>\\u001b[33;1m</code></li><li>亮蓝色：<code>\\u001b[34;1m</code></li><li>亮洋红色：<code>\\u001b[35;1m</code></li><li>亮青色：<code>\\u001b[36;1m</code></li><li>亮白色：<code>\\u001b[37;1m</code></li></ul><p>亮色指令分别在原来对应颜色的指令中间加上<code>;1</code>。我们将所有的16色在控制台打印，方便大家进行比对：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[30m A \\u001b[31m B \\u001b[32m C \\u001b[33m D \\u001b[0m&#34;);</code></pre></div><p>System.out.print(&#34;\\u001b[34m E \\u001b[35m F \\u001b[36m G \\u001b[37m H \\u001b[0m&#34;);</p><p>System.out.print(&#34;\\u001b[30;1m A \\u001b[31;1m B \\u001b[32;1m C \\u001b[33;1m D \\u001b[0m&#34;);</p><p>System.out.print(&#34;\\u001b[34;1m E \\u001b[35;1m F \\u001b[36;1m G \\u001b[37;1m H \\u001b[0m&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f5200fbfc825a6b2a511bca6aefc517c_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-f5200fbfc825a6b2a511bca6aefc517c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;700&#39; height=&#39;164&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"700\" data-rawheight=\"164\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"700\" data-original=\"https://pic1.zhimg.com/v2-f5200fbfc825a6b2a511bca6aefc517c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f5200fbfc825a6b2a511bca6aefc517c_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以清晰地看到，下面的8色比上面的8色显得更加明亮。比如，原来黑色的<code>A</code>，在黑色的控制台背景下，几乎无法看到，但是一旦通过亮黑色输出后，对比度变得更高，变得更好辨识了。</p><h2><b>256色</b></h2><p>最后，除了16色外，某些控制台支持输出256色。指令的形式如下：</p><ul><li><code>\\u001b[38;5;${ID}m</code></li></ul><p>让我们输出256色矩阵：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">for (int i = 0; i &lt; 16; i++) {</code></pre></div><p>for (int j = 0; j &lt; 16; j++) {</p><p>int code = i * 16 + j;</p><p>System.out.printf(&#34;\\u001b[38;5;%dm%-4d&#34;, code, code);</p><p>}</p><p>System.out.println(&#34;\\u001b[0m&#34;);</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-74638638a189bc8b87a4a23b7457f2a3_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"490\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb\" width=\"490\" data-original=\"https://pic4.zhimg.com/v2-74638638a189bc8b87a4a23b7457f2a3_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;490&#39; height=&#39;460&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"490\" data-rawheight=\"460\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"490\" data-original=\"https://pic4.zhimg.com/v2-74638638a189bc8b87a4a23b7457f2a3_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-74638638a189bc8b87a4a23b7457f2a3_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>关于字体颜色我们就介绍到这，接下来我们来介绍背景色。</p><h2><b>背景颜色</b></h2><p>刚才所说的字体颜色可以统称为前景色（foreground color）。那么理所当然，我们可以设置文本的背景颜色：</p><ul><li>黑色背景：<code>\\u001b[40m</code></li><li>红色背景：<code>\\u001b[41m</code></li><li>绿色背景：<code>\\u001b[42m</code></li><li>黄色背景：<code>\\u001b[43m</code></li><li>蓝色背景：<code>\\u001b[44m</code></li><li>洋红色背景：<code>\\u001b[45m</code></li><li>青色背景：<code>\\u001b[46m</code></li><li>白色背景：<code>\\u001b[47m</code></li></ul><p>对应的亮色版本：</p><ul><li>亮黑色背景：<code>\\u001b[40;1m</code></li><li>亮红色背景：<code>\\u001b[41;1m</code></li><li>亮绿色背景：<code>\\u001b[42;1m</code></li><li>亮黄色背景：<code>\\u001b[43;1m</code></li><li>亮蓝色背景：<code>\\u001b[44;1m</code></li><li>亮洋红色背景：<code>\\u001b[45;1m</code></li><li>亮青色背景：<code>\\u001b[46;1m</code></li><li>亮白色背景：<code>\\u001b[47;1m</code></li></ul><p>首先让我们看看16色背景：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[40m A \\u001b[41m B \\u001b[42m C \\u001b[43m D \\u001b[0m&#34;);</code></pre></div><p>System.out.print(&#34;\\u001b[44m A \\u001b[45m B \\u001b[46m C \\u001b[47m D \\u001b[0m&#34;);</p><p>System.out.print(&#34;\\u001b[40;1m A \\u001b[41;1m B \\u001b[42;1m C \\u001b[43;1m D \\u001b[0m&#34;);</p><p>System.out.print(&#34;\\u001b[44;1m A \\u001b[45;1m B \\u001b[46;1m C \\u001b[47;1m D \\u001b[0m&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-de573af782162ce6973436f41c9c8b64_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"698\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb\" width=\"698\" data-original=\"https://pic1.zhimg.com/v2-de573af782162ce6973436f41c9c8b64_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;698&#39; height=&#39;170&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"698\" data-rawheight=\"170\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"698\" data-original=\"https://pic1.zhimg.com/v2-de573af782162ce6973436f41c9c8b64_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-de573af782162ce6973436f41c9c8b64_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>值得注意的是，亮色背景并不是背景颜色显得更加明亮，而是让对应的前景色显得更加明亮。虽然这点有点不太直观，但是实际表现就是如此。</p><p>让我们再来试试256背景色，首先指令如下：</p><ul><li><code>\\u001b[48;5;${ID}m</code></li></ul><p>同样输出256色矩阵：</p><div class=\"highlight\"><pre><code class=\"language-text\">for (int i = 0; i &lt; 16; i++) {</code></pre></div><p>for (int j = 0; j &lt; 16; j++) {</p><p>int code = i * 16 + j;</p><p>System.out.printf(&#34;\\u001b[48;5;%dm%-4d&#34;, code, code);</p><p>}</p><p>System.out.println(&#34;\\u001b[0m&#34;);</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2fb408d6906b0ab54389f71f17e9bbd8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"493\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb\" width=\"493\" data-original=\"https://pic1.zhimg.com/v2-2fb408d6906b0ab54389f71f17e9bbd8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;493&#39; height=&#39;458&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"493\" data-rawheight=\"458\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"493\" data-original=\"https://pic1.zhimg.com/v2-2fb408d6906b0ab54389f71f17e9bbd8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2fb408d6906b0ab54389f71f17e9bbd8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>感觉要被亮瞎眼了呢！至此，颜色设置已经介绍完毕，让我们接着学习样式设置。</p><h2><b>样式</b></h2><p>除了给文本设置颜色之外，我们还可以给文本设置样式：</p><ul><li>粗体：<code>\\u001b[1m</code></li><li>下划线：<code>\\u001b[4m</code></li><li>反色：<code>\\u001b[7m</code></li></ul><p>样式分别使用的效果：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[1m BOLD \\u001b[0m\\u001b[4m Underline \\u001b[0m\\u001b[7m Reversed \\u001b[0m&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-5c759b6a1cd79a8809d00fad85d5e483_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-5c759b6a1cd79a8809d00fad85d5e483_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;720&#39; height=&#39;59&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"720\" data-rawheight=\"59\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"720\" data-original=\"https://pic4.zhimg.com/v2-5c759b6a1cd79a8809d00fad85d5e483_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-5c759b6a1cd79a8809d00fad85d5e483_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>或者结合使用：</p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[1m\\u001b[4m\\u001b[7m BOLD Underline Reversed \\u001b[0m&#34;);</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-b6d45e65501afac93c6ce2d874d80d73_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-b6d45e65501afac93c6ce2d874d80d73_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;636&#39; height=&#39;60&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"636\" data-rawheight=\"60\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"636\" data-original=\"https://pic4.zhimg.com/v2-b6d45e65501afac93c6ce2d874d80d73_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b6d45e65501afac93c6ce2d874d80d73_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>甚至还可以和颜色结合使用：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">System.out.print(&#34;\\u001b[1m\\u001b[31m Red Bold \\u001b[0m&#34;);</code></pre></div><p>System.out.print(&#34;\\u001b[4m\\u001b[44m Blue Background Underline \\u001b[0m&#34;);</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-f22044669197b43c512383a44144c818_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-f22044669197b43c512383a44144c818_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;94&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"600\" data-rawheight=\"94\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-f22044669197b43c512383a44144c818_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-f22044669197b43c512383a44144c818_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>是不是很简单，是不是很酷！学会了这些，我们已经能够写出十分酷炫的命令行脚本了。但是如果要实现更复杂的功能（比如进度条），我们还需要掌握更加牛逼的光标控制指令！</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-7c413125d3cedcdc3341994096c47d8a_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"232\" data-rawheight=\"203\" class=\"content_image\" width=\"232\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;232&#39; height=&#39;203&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"232\" data-rawheight=\"203\" class=\"content_image lazy\" width=\"232\" data-actualsrc=\"https://pic3.zhimg.com/v2-7c413125d3cedcdc3341994096c47d8a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2><b>光标控制</b></h2><p>Ansi Escape Code里更加复杂的指令就是光标控制。通过这些指令，我们可以自由地移动我们的光标至屏幕的任何位置。比如在Vim的命令模式下，我们可以使用<code>H/J/K/L</code>这四个键实现光标的上下左右移动。</p><p>最基础的光标控制指令如下：</p><ul><li>上：<code>\\u001b[{n}A</code></li><li>下：<code>\\u001b[{n}B</code></li><li>右：<code>\\u001b[{n}C</code></li><li>左：<code>\\u001b[{n}D</code></li></ul><p>通过光标控制的特性，我们能够实现大量有趣且酷炫的功能。首先我们来看看怎么实现一个进度条。</p><h2><b>进度数字显示</b></h2><p>作为进度条，怎么可以没有进度数字显示呢？所以我们先来实现进度条进度数字的刷新：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void loading() throws InterruptedException {</code></pre></div><p>System.out.println(&#34;Loading...&#34;);</p><p>for (int i = 1; i &lt;= 100; i++) {</p><p>Thread.sleep(100);</p><p>System.out.print(&#34;\\u001b[1000D&#34; + i + &#34;%&#34;);</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"442\" data-rawheight=\"264\" data-thumbnail=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"442\" data-original=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;442&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"442\" data-rawheight=\"264\" data-thumbnail=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"442\" data-original=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-ce6f615965ac3f6a12d9293b30bfb7fb_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以看到，进度在同一行从1%不停地刷新到100%。为了进度只在同一行显示，我们在代码中使用了<code>System.out.print</code>而不是<code>System.out.println</code>。在打印每个进度之前，我们使用了<code>\\u001b[1000D</code>指令，目的是为了将光标移动到当前行的最左边也就是行首。然后重新打印新的进度，新的进度数字会覆盖刚才的进度数字，循环往复，这就实现了上图的效果。</p><blockquote>PS：<code>\\u001b[1000D</code>表示将光标往左移动1000个字符。这里的1000表示光标移动的距离，只要你能够确保光标能够移动到最左端，随便设置多少比如设置2000都可以。</blockquote><p>为了方便大家更加轻松地理解光标的移动过程，让我们放慢进度条刷新的频率：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void loading() throws InterruptedException {</code></pre></div><p>System.out.println(&#34;Loading...&#34;);</p><p>for (int i = 1; i &lt;= 100; i++) {</p><p>System.out.print(&#34;\\u001b[1000D&#34;);</p><p>Thread.sleep(1000);</p><p>System.out.print(i + &#34;%&#34;);</p><p>Thread.sleep(1000);</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"264\" data-thumbnail=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"440\" data-original=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;440&#39; height=&#39;264&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"440\" data-rawheight=\"264\" data-thumbnail=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"440\" data-original=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f01e9dec588ab9ede44b045743289551_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>现在我们可以清晰地看到：</p><ol><li>从左到右打印进度，光标移至行尾。</li><li>光标移至行首，原进度数字还在。</li><li>从左到右打印新进度，新的数字会覆盖老的数字。光标移至行尾。</li><li>循环往复。</li></ol><h2><b>Ascii进度条</b></h2><p>好了，我们现在已经知道如何通过Ansi Escape Code实现进度数字的显示和刷新，剩下的就是实现进度的读条。废话不多说，我们直接上代码和效果图：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void loading() throws InterruptedException {</code></pre></div><p>System.out.println(&#34;Loading...&#34;);</p><p>for (int i = 1; i &lt;= 100; i++) {</p><p>int width = i / 4;</p><p>String left = &#34;[&#34; + String.join(&#34;&#34;, Collections.nCopies(width, &#34;#&#34;));</p><p>String right = String.join(&#34;&#34;, Collections.nCopies(25 - width, &#34; &#34;)) + &#34;]&#34;;</p><p>System.out.print(&#34;\\u001b[1000D&#34; + left + right);</p><p>Thread.sleep(100);</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>由上图我们可以看到，每次循环过后，读条就会增加。原理和数字的刷新一样，相信大家阅读代码就能理解，这里就不再赘述。</p><p>让我们来点更酷的吧！利用Ansi的光标<b>向上</b>以及<b>向下</b>的指令，我们还可以同时打印出多条进度条：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">void loading(int count) throws InterruptedException {</code></pre></div><p>System.out.print(String.join(&#34;&#34;, Collections.nCopies(count, &#34;\\n&#34;))); // 初始化进度条所占的空间</p><p>List&lt;Integer&gt; allProgress = new ArrayList&lt;&gt;(Collections.nCopies(count, 0));</p><p>while (true) {</p><p>Thread.sleep(10);</p><p>// 随机选择一个进度条，增加进度</p><p>List&lt;Integer&gt; unfinished = new LinkedList&lt;&gt;();</p><p>for (int i = 0; i &lt; allProgress.size(); i++) {</p><p>if (allProgress.get(i) &lt; 100) {</p><p>unfinished.add(i);</p><p>}</p><p>}</p><p>if (unfinished.isEmpty()) {</p><p>break;</p><p>}</p><p>int index = unfinished.get(new Random().nextInt(unfinished.size()));</p><p>allProgress.set(index, allProgress.get(index) + 1); // 进度+1</p><p>// 绘制进度条</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 移动到最左边</p><p>System.out.print(&#34;\\u001b[&#34; + count + &#34;A&#34;); // 往上移动</p><p>for (Integer progress : allProgress) {</p><p>int width = progress / 4;</p><p>String left = &#34;[&#34; + String.join(&#34;&#34;, Collections.nCopies(width, &#34;#&#34;));</p><p>String right = String.join(&#34;&#34;, Collections.nCopies(25 - width, &#34; &#34;)) + &#34;]&#34;;</p><p>System.out.println(left + right);</p><p>}</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>在上述代码中：</p><ul><li>我们首先执行<code>System.out.print(String.join(&#34;&#34;, Collections.nCopies(count, &#34;\\n&#34;)));</code>打印出多个空行，这可以保证我们有足够的空间来打印进度条。</li><li>接下来我们随机增加一个进度条的进度，并且打印出所有进度条。</li><li>最后我们调用<b>向上</b>指令，将光标移回到最上方，继续下一个循环，直到所有进度条都到达100%。</li></ul><p>实际效果如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"620\" data-thumbnail=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;708&#39; height=&#39;620&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"708\" data-rawheight=\"620\" data-thumbnail=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"708\" data-original=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-0aca6dbf2b0fd5c315ae28937b3a1b2a_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>效果真是太棒啦！剩下将读条和数字结合在一起的工作就交给读者啦。学会了这招，当你下次如果要做一个在命令行下载文件的小工具，这时候这些知识就派上用场啦！</p><h2><b>制作命令行</b></h2><p>最后，最为酷炫的事情莫过于利用Ansi<br/> Escape <br/>Codes实现一个个性化的命令行（Command-Line）。我们平常使用的Bash以及一些解释型语言比如Python、Ruby等都有自己的REPL命令行。接下来，让我们揭开他们神秘的面纱，了解他们背后实现的原理。</p><blockquote>PS：由于在Jshell中，方向键、后退键等一些特殊键有自己的作用，所以接下来无法通过Jshell演示。需要自己手动进行编译运行代码才能看到实际效果。</blockquote><h2><b>一个最简单的命令行</b></h2><p>首先，我们来实现一个最简单的命令行，简单到只实现下面两种功能：</p><ul><li>当用户输入一个可打印的字符时，比如abcd等，则在控制台显示。</li><li>当用户输入回车时，另起一行，输出刚才用户输入的所有字符，然后再另起一行，继续接受用户的输入。</li></ul><p>那么这个最简单的命令行的实现代码会长这样：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.io.IOException;</code></pre></div><p>public class CommandLine {</p><p>public static void main(String[] args) throws IOException, InterruptedException {</p><p>// 设置命令行为raw模式，否则会自动解析方向键以及后退键，并且直到按下回车read方法才会返回</p><p>String[] cmd = { &#34;/bin/sh&#34;, &#34;-c&#34;, &#34;stty raw &lt;/dev/tty&#34; };</p><p>Runtime.getRuntime()</p><p>.exec(cmd)</p><p>.waitFor();</p><p>while (true) {</p><p>String input = &#34;&#34;;</p><p>while (true) {</p><p>char ch = (char) System.in.read();</p><p>if (ch == 3) {</p><p>// CTRL-C</p><p>return;</p><p>}</p><p>else if (ch &gt;= 32 &amp;&amp; ch &lt;= 126) {</p><p>// 普通字符</p><p>input += ch;</p><p>}</p><p>else if (ch == 10 || ch == 13) {</p><p>// 回车</p><p>System.out.println();</p><p>System.out.print(&#34;\\u001b[1000D&#34;);</p><p>System.out.println(&#34;echo: &#34; + input);</p><p>input = &#34;&#34;;</p><p>}</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 首先将光标移动到最左侧</p><p>System.out.print(input); // 重新输出input</p><p>System.out.flush();</p><p>}</p><p>}</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>好的，让我们来说明一下代码中的关键点：</p><ol><li>首先最关键的是我们需要将我们的命令行设置为raw模式，这可以避免JVM帮我们解析方向键，回退键以及对用户输入进行缓冲。大家可以试一下不设置raw模式然后看一下效果，就可以理解我说的话了。</li><li>通过<code>System.in.read()</code>方法获取用户输入，然后对其ascii值进行分析。</li><li>如果发现用户输入的是回车的话，我们这时需要打印刚才用户输入的所有字符。但是我们需要注意，由于设置了raw模式，不移动光标直接打印的话，光标的位置不会移到行首，如下图：</li></ol><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-6facadcd6ca497b8b2ace62112961826_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"250\" data-rawheight=\"119\" class=\"content_image\" width=\"250\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;250&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"250\" data-rawheight=\"119\" class=\"content_image lazy\" width=\"250\" data-actualsrc=\"https://pic3.zhimg.com/v2-6facadcd6ca497b8b2ace62112961826_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>所以这里需要再次调用<code>System.out.print(&#34;\\u001b[1000D&#34;);</code>将光标移到行首。</p><p>好了，让我们来看一下效果吧：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c706d5bdf743129b29fb1378053ac69b_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"254\" data-thumbnail=\"https://pic4.zhimg.com/v2-c706d5bdf743129b29fb1378053ac69b_b.jpg\" class=\"content_image\" width=\"322\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;322&#39; height=&#39;254&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"254\" data-thumbnail=\"https://pic4.zhimg.com/v2-c706d5bdf743129b29fb1378053ac69b_b.jpg\" class=\"content_image lazy\" width=\"322\" data-actualsrc=\"https://pic4.zhimg.com/v2-c706d5bdf743129b29fb1378053ac69b_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>成功了！但是有个缺点，那就是命令行并没有解析方向键，反而以<code>[D[A[C[B</code>输出（见动图）。这样我们只能一直往后面写而无法做到将光标移动到前面实现插入的效果。所以接下来就让我们给命令行加上解析方向键的功能吧！</p><h2><b>光标移动</b></h2><p>简单起见，我们仅需实现按下方向键的左右两键时能控制光标左右移动。左右两键对应的ascii码分别为<code>27 91 68</code>和<code>27 91 67</code>。所以我们只要在代码中加上对这两串ascii码的解析即可：</p><div class=\"highlight\"><pre><code class=\"language-text\">import java.io.IOException;</code></pre></div><p>public class CommandLine {</p><p>public static void main(String[] args) throws IOException, InterruptedException {</p><p>// 设置命令行为raw模式，否则会自动解析方向键以及后退键，并且直到按下回车read方法才会返回</p><p>String[] cmd = { &#34;/bin/sh&#34;, &#34;-c&#34;, &#34;stty raw &lt;/dev/tty&#34; };</p><p>Runtime.getRuntime()</p><p>.exec(cmd)</p><p>.waitFor();</p><p>while (true) {</p><p>String input = &#34;&#34;;</p><p>int index = 0;</p><p>while (true) {</p><p>char ch = (char) System.in.read();</p><p>if (ch == 3) {</p><p>// CTRL-C</p><p>return;</p><p>}</p><p>else if (ch &gt;= 32 &amp;&amp; ch &lt;= 126) {</p><p>// 普通字符</p><p>input = input.substring(0, index) + ch + input.substring(index, input.length());</p><p>index++;</p><p>}</p><p>else if (ch == 10 || ch == 13) {</p><p>// 回车</p><p>System.out.println();</p><p>System.out.print(&#34;\\u001b[1000D&#34;);</p><p>System.out.println(&#34;echo: &#34; + input);</p><p>input = &#34;&#34;;</p><p>index = 0;</p><p>}</p><p>else if (ch == 27) {</p><p>// 左右方向键</p><p>char next1 = (char) System.in.read();</p><p>char next2 = (char) System.in.read();</p><p>if (next1 == 91) {</p><p>if (next2 == 68) {</p><p>// 左方向键</p><p>index = Math.max(0, index - 1);</p><p>}</p><p>else if (next2 == 67) {</p><p>// 右方向键</p><p>index = Math.min(input.length(), index + 1);</p><p>}</p><p>}</p><p>}</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 将光标移动到最左侧</p><p>System.out.print(input);</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 再次将光标移动到最左侧</p><p>if (index &gt; 0) {</p><p>System.out.print(&#34;\\u001b[&#34; + index + &#34;C&#34;); // 将光标移动到index处</p><p>}</p><p>System.out.flush();</p><p>}</p><p>}</p><p>}</p><p>}</p><p>效果如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-6fac2e1af422ffbf7ecf07d281101c45_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"184\" data-thumbnail=\"https://pic2.zhimg.com/v2-6fac2e1af422ffbf7ecf07d281101c45_b.jpg\" class=\"content_image\" width=\"322\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;322&#39; height=&#39;184&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"322\" data-rawheight=\"184\" data-thumbnail=\"https://pic2.zhimg.com/v2-6fac2e1af422ffbf7ecf07d281101c45_b.jpg\" class=\"content_image lazy\" width=\"322\" data-actualsrc=\"https://pic2.zhimg.com/v2-6fac2e1af422ffbf7ecf07d281101c45_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>It works！但是这个命令行还不支持删除，我们无法通过<code>Backspace</code>键删去敲错的字符。有了刚才的经验，实现删除功能也十分简单！</p><h2><b>删除</b></h2><p>照着刚才的思路，我们可能会在处理用户输入的地方，加上如下的代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">else if (ch == 127) {</code></pre></div><p>// 删除</p><p>if (index &gt; 0) {</p><p>input = input.substring(0, index - 1) + input.substring(index, input.length());</p><p>index -= 1;</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>但是这段代码存在点问题，让我们看一下效果图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"160\" data-thumbnail=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"514\" data-original=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;514&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"514\" data-rawheight=\"160\" data-thumbnail=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"514\" data-original=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-cf97ea8bfdbb5e86b02f7e9a35e2d26f_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>从图中我们可以看到：</p><ul><li>第一次，当我输入了<code>11234566</code>，然后不停地按下删除键，想要删掉<code>34566</code>，但是只有光标在后退，字符并没有被删掉。然后我再按下回车键，通过echo的字符串我们发现删除实际上已经成功，只是控制台在显示的时候出了点问题。</li><li>第二次，我先输入<code>123456</code>，然后按下删除键，删掉<code>456</code>，光标退到<code>3</code>。然后我再继续不断地输入<code>0</code>，我们发现随着<code>0</code>覆盖了原来的<code>456</code>显示的位置。</li></ul><p>所以删除的确产生了效果，但是我们要解决被删除的字符还在显示的这个bug。为了实现删除的效果，我们先来学习一下Ansi里的删除指令：</p><ul><li>清除屏幕：<code>\\u001b[{n}J</code>为指令。</li><ul><li><code>n=0</code>：清除光标到屏幕末尾的所有字符。</li><li><code>n=1</code>：清除屏幕开头到光标的所有字符。</li><li><code>n=2</code>：清除整个屏幕的字符。</li></ul><li>清除行：<code>\\u001b[{n}K</code>为指令。</li><ul><li><code>n=0</code>：清除光标到当前行末所有的字符。</li><li><code>n=1</code>：清除当前行到光标的所有字符。</li><li><code>n=2</code>：清除当前行。</li></ul></ul><p>所以我们的思路就是不管用户输入了什么，我们先利用<code>System.out.print(&#34;\\u001b[0K&#34;);</code>清除当前行，此时光标回到了行首，这时再输出正确的字符。完整代码如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import java.io.IOException;</code></pre></div><p>public class CommandLine {</p><p>public static void main(String[] args) throws IOException, InterruptedException {</p><p>// 设置命令行为raw模式，否则会自动解析方向键以及后退键，并且直到按下回车read方法才会返回</p><p>String[] cmd = { &#34;/bin/sh&#34;, &#34;-c&#34;, &#34;stty raw &lt;/dev/tty&#34; };</p><p>Runtime.getRuntime()</p><p>.exec(cmd)</p><p>.waitFor();</p><p>while (true) {</p><p>String input = &#34;&#34;;</p><p>int index = 0;</p><p>while (true) {</p><p>char ch = (char) System.in.read();</p><p>if (ch == 3) {</p><p>// CTRL-C</p><p>return;</p><p>}</p><p>else if (ch &gt;= 32 &amp;&amp; ch &lt;= 126) {</p><p>// 普通字符</p><p>input = input.substring(0, index) + ch + input.substring(index, input.length());</p><p>index++;</p><p>}</p><p>else if (ch == 10 || ch == 13) {</p><p>// 回车</p><p>System.out.println();</p><p>System.out.print(&#34;\\u001b[1000D&#34;);</p><p>System.out.println(&#34;echo: &#34; + input);</p><p>input = &#34;&#34;;</p><p>index = 0;</p><p>}</p><p>else if (ch == 27) {</p><p>// 左右方向键</p><p>char next1 = (char) System.in.read();</p><p>char next2 = (char) System.in.read();</p><p>if (next1 == 91) {</p><p>if (next2 == 68) {</p><p>// 左方向键</p><p>index = Math.max(0, index - 1);</p><p>}</p><p>else if (next2 == 67) {</p><p>// 右方向键</p><p>index = Math.min(input.length(), index + 1);</p><p>}</p><p>}</p><p>}</p><p>else if (ch == 127) {</p><p>// 删除</p><p>if (index &gt; 0) {</p><p>input = input.substring(0, index - 1) + input.substring(index, input.length());</p><p>index -= 1;</p><p>}</p><p>}</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 将光标移动到最左侧</p><p>System.out.print(&#34;\\u001b[0K&#34;); // 清除光标所在行的全部内容</p><p>System.out.print(input);</p><p>System.out.print(&#34;\\u001b[1000D&#34;); // 再次将光标移动到最左侧</p><p>if (index &gt; 0) {</p><p>System.out.print(&#34;\\u001b[&#34; + index + &#34;C&#34;); // 将光标移动到index处</p><p>}</p><p>System.out.flush();</p><p>}</p><p>}</p><p>}</p><p>}</p><p class=\"ztext-empty-paragraph\"><br/></p><p>让我们来看一下效果：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"160\" data-thumbnail=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;462&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"462\" data-rawheight=\"160\" data-thumbnail=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_b.jpg\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"462\" data-original=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-56bef8d18a70ea5e849e1457bd6adff1_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>OK，成功了！那么至此为止，我们已经实现了一个最小化的命令行，它能够支持用户进行输入，并且能够左右移动光标以及删除他不想要的字符。但是它还缺失了很多命令行的特性，比如不支持解析像<code>Alt-f</code>、<code>Ctrl-r</code>等常见的快捷键，也不支持输入Unicode字符等等。但是，只要我们掌握了刚才的知识，这些特性都可以方便地实现。比如，我们可以给刚才的命令行加上简单的语法高亮——末尾如果有多余的空格则将这些空格标红，效果如下：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-883bbbcec595be5952963c3b44556c6d_b.gif\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"160\" data-thumbnail=\"https://pic2.zhimg.com/v2-883bbbcec595be5952963c3b44556c6d_b.jpg\" class=\"content_image\" width=\"384\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;384&#39; height=&#39;160&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"384\" data-rawheight=\"160\" data-thumbnail=\"https://pic2.zhimg.com/v2-883bbbcec595be5952963c3b44556c6d_b.jpg\" class=\"content_image lazy\" width=\"384\" data-actualsrc=\"https://pic2.zhimg.com/v2-883bbbcec595be5952963c3b44556c6d_b.gif\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>实现的代码也很简单，可以参考Github项目里的CustomisedCommandLine类。</p><p>最后，再介绍一下其他一些有用的Ansi Escape Codes：</p><ul><li>光标向上移动：<code>\\u001b[{n}A</code>将光标向上移动<code>n</code>格。</li><li>光标向下移动：<code>\\u001b[{n}B</code>将光标向下移动<code>n</code>格。</li><li>光标向右移动：<code>\\u001b[{n}C</code>将光标向右移动<code>n</code>格。</li><li>光标向左移动：<code>\\u001b[{n}D</code>将光标向左移动<code>n</code>格。</li><li>光标按行向下移动：<code>\\u001b[{n}E</code>将光标向下移动<code>n</code>行并且将光标移至行首。</li><li>光标按行向上移动：<code>\\u001b[{n}F</code>将光标向上移动<code>n</code>行并且将光标移至行首。</li><li>设置光标所在列：<code>\\u001b[{n}G</code>将光标移至第<code>n</code>列（行数与当前所在行保持一致）。</li><li>设置光标所在位置：<code>\\u001b[{n};{m}H</code>将光标移至第<code>n</code>行<code>m</code>列，坐标原点从屏幕左上角开始。</li><li>保存光标当前所在位置：<code>\\u001b[{s}</code>。</li><li>读取光标上一次保存的位置：<code>\\u001b[{u}</code>。</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><b>源自：<a href=\"https://link.zhihu.com/?target=http%3A//www.kissyu.org/2017/11/25/\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://www.</span><span class=\"visible\">kissyu.org/2017/11/25/</span><span class=\"invisible\"></span></a>震惊！原来命令行还可</b></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28415434", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 1, 
            "title": "Python+django建站入门篇：Hello world", 
            "content": "<p>第一步，进入命令提示符，切换至Python安装目录下的scripts目录，执行命令pip install django安装django扩展库。</p><p>第二步，使用命令创建网站项目helloworld，进入项目文件夹，创建项目mainsite，如图：</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-e2e46a676cd90a94bb6f4b606970409e_b.png\" data-rawwidth=\"640\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-e2e46a676cd90a94bb6f4b606970409e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;155&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"155\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-e2e46a676cd90a94bb6f4b606970409e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e2e46a676cd90a94bb6f4b606970409e_b.png\"/></figure><p>第三步，打开网站项目helloworld\\mainsite\\views.py文件进行修改，下图中红框内是增加的代码：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-bd45b358ec39d83f3eda5e076b69e3ce_b.png\" data-rawwidth=\"564\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb\" width=\"564\" data-original=\"https://pic3.zhimg.com/v2-bd45b358ec39d83f3eda5e076b69e3ce_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;564&#39; height=&#39;287&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"564\" data-rawheight=\"287\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"564\" data-original=\"https://pic3.zhimg.com/v2-bd45b358ec39d83f3eda5e076b69e3ce_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-bd45b358ec39d83f3eda5e076b69e3ce_b.png\"/></figure><p>第四步，打开网站项目helloworld\\helloworld\\urls.py文件设置url对应关系，下图中红框内是增加的代码，表示访问网站根目录时由mainsite\\views.py中的index()函数来解析和处理。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-6138dc96437d260e614d1339fe66153d_b.png\" data-rawwidth=\"527\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-6138dc96437d260e614d1339fe66153d_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;527&#39; height=&#39;319&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"527\" data-rawheight=\"319\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"527\" data-original=\"https://pic2.zhimg.com/v2-6138dc96437d260e614d1339fe66153d_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-6138dc96437d260e614d1339fe66153d_b.png\"/></figure><p>第五步，在命令提示符环境中进入网站项目文件夹，执行命令启动网站，如图，runserver后面不带参数的话表示默认地址为127.0.0.1:8000，也可以使用参数来制定访问地址。启动后可以放置这个命令提示符窗口不用管，以后修改了网站中任何文件时，django会自动检测和更新。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-b48827079b0ab0de8294dbe52e568f97_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-b48827079b0ab0de8294dbe52e568f97_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;247&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"247\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-b48827079b0ab0de8294dbe52e568f97_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-b48827079b0ab0de8294dbe52e568f97_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>第六步，打开浏览器，访问网站，如图：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-b37d9ff2c736f56c90d5d8b4a987f71c_b.png\" data-rawwidth=\"393\" data-rawheight=\"159\" class=\"content_image\" width=\"393\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;393&#39; height=&#39;159&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"393\" data-rawheight=\"159\" class=\"content_image lazy\" width=\"393\" data-actualsrc=\"https://pic1.zhimg.com/v2-b37d9ff2c736f56c90d5d8b4a987f71c_b.png\"/></figure><p></p><p></p>", 
            "topic": [
                {
                    "tag": "Python教程", 
                    "tagLink": "https://api.zhihu.com/topics/20027689"
                }
            ], 
            "comments": [
                {
                    "userName": "zzz", 
                    "userLink": "https://www.zhihu.com/people/4d5ea153a269cdb45b22980af6efc7e4", 
                    "content": "请问有更详细的吗", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "stormsha", 
                            "userLink": "https://www.zhihu.com/people/9ab412c015ac6e3b618c9d4f19e3b8ff", 
                            "content": "<p>推荐：<a href=\"https://zhuanlan.zhihu.com/p/61156456\" class=\"internal\">快速搭建一个自己喜欢的个人站点</a></p>", 
                            "likes": 0, 
                            "replyToAuthor": "zzz"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28415618", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "使用Python简单模拟Linux系统的tree工具", 
            "content": "<p>Linux系统中有个tree工具可以用比较好看的形式来显示指定文件夹的目录结构。例如下图（来自于网络）：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-5476510af7e4d51f0501e34640a03958_b.png\" data-rawwidth=\"264\" data-rawheight=\"234\" class=\"content_image\" width=\"264\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;264&#39; height=&#39;234&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"264\" data-rawheight=\"234\" class=\"content_image lazy\" width=\"264\" data-actualsrc=\"https://pic1.zhimg.com/v2-5476510af7e4d51f0501e34640a03958_b.png\"/></figure><p>本文代码使用Python对Linux系统的tree命令简单进行了模拟，不过还不是特别像，大家可以在此基础上进行改写或者扩展。</p><p>import os<br/>import os.path</p><p class=\"ztext-empty-paragraph\"><br/></p><p>def tree(path, depth=0):<br/>    if depth == 0:<br/>        print(path)<br/>    items = os.listdir(path)<br/>    for item in items:<br/>        # 输出文件夹中的文件和子文件夹名 print(&#39;|    &#39;*depth, end=&#39;&#39;)<br/>        print(&#39;|----&#39;, item)<br/>        item = os.path.join(path, item)<br/>        if os.path.isdir(item):<br/>            # 递归遍历子目录<br/>            tree(item, depth+1)</p><p class=\"ztext-empty-paragraph\"><br/></p><p>tree(r&#39;g:\\test&#39;)</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>运行结果：</b></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-64f39053dec968761c9790be672a9ae7_b.png\" data-rawwidth=\"303\" data-rawheight=\"244\" class=\"content_image\" width=\"303\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;303&#39; height=&#39;244&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"303\" data-rawheight=\"244\" class=\"content_image lazy\" width=\"303\" data-actualsrc=\"https://pic4.zhimg.com/v2-64f39053dec968761c9790be672a9ae7_b.png\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28415696", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 1, 
            "title": "详解Python项目开发时自定义模块中对象的导入和使用", 
            "content": "<p><b>背景：</b>1）任何一个Python程序文件既可以直接执行，也可以作为模块导入再使用其中的对象；2）对于大型系统开发，一般不会把所有代码放到单个文件中，而是根据功能将其分类并分散多个模块中，在编写小型项目时最好也能养成这样的好习惯。</p><p>本文介绍Python自定义模块中对象的导入和使用。</p><p>假设当前工作目录为C:\\Python36，创建一个子目录child，然后在其中创建一个Python程序文件add.py，其中的代码为：</p><p>def add(x, y):<br/>    return x+y</p><p>这时，文件夹结构如图所示：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_b.png\" data-rawwidth=\"640\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_b.png\"/></figure><p>现在我们启动IDLE交互编程模式，默认工作目录是C:\\Python36，执行下面的代码：</p><p>&gt;&gt;&gt; import child<br/>&gt;&gt;&gt; child.add.add(3,5)<br/>Traceback (most recent call last):<br/>  File &#34;&lt;pyshell#17&gt;&#34;, line 1, in &lt;module&gt;<br/>    child.add.add(3,5)<br/>AttributeError: module &#39;child&#39; has no attribute &#39;add&#39;</p><p>错误提示显示，child模块中没有可用的add，这是因为child文件夹被认为是一个包，而add.py是包中的子模块，并没有随着child一起导入。继续执行下面的代码：</p><p>&gt;&gt;&gt; import child.add<br/>&gt;&gt;&gt; child.add.add(3,5)<br/>8</p><p>自定义模块中的对象成功被导入并能够正常使用，也就是说，<b>如果要使用的对象在子模块中，应该单独使用import来导入子模块</b>。或者使用下面的方法：</p><p>&gt;&gt;&gt; from child import add<br/>&gt;&gt;&gt; add.add(3,5)<br/>8</p><p>接下来在IDLE中单击菜单“Restart Shell”恢复初始状态，然后执行下面的代码：</p><p>&gt;&gt;&gt; from child import *<br/>&gt;&gt;&gt; add.add(3,5)<br/>Traceback (most recent call last):<br/>  File &#34;&lt;pyshell#24&gt;&#34;, line 1, in &lt;module&gt;<br/>    add.add(3,5)<br/>NameError: name &#39;add&#39; is not defined</p><p>错误提示显示并不存在add这样的名字，也就是说命令from child import *并没有导入add模块。现在在child子文件夹中创建一个Python程序文件__init__.py，其中内容为：</p><p>__all__ = [&#39;add&#39;]</p><p>此时文件夹结构变为：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_b.png\" data-rawwidth=\"640\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_b.png\"/></figure><p>然后回到IDLE中执行刚才的代码：</p><p>&gt;&gt;&gt; from child import *<br/>&gt;&gt;&gt; add.add(3,5)<br/>8</p><p>结果正常。原因在于，<b>如果文件夹作为包来使用，并且其中包含__init__.py文件时，__init__.py文件中的特殊列表成员__all__用来指定from ... import *时哪些子模块或对象会被自动导入</b>。</p>", 
            "topic": [
                {
                    "tag": "Python 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19606083"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28415787", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 9, 
            "title": "Python速度虽然慢，但它工作效率高啊！不服？", 
            "content": "<p>因为某个语言速度快而选择其为开发你应用的语言是不成熟优化的一种体现。是的，Python 比较慢，但其牺牲性能可以提升工作效率。看完本文，相信你对 Python 会有一个全新的看法。</p><p> 写在前面 </p><p>让我们来讨论一个我最近一直在思考的问题：Python 的性能。顺便说一下，我是 Python 的忠实拥趸，我在各种情况下都会积极尝试使用 Python 来解决问题。大家对 Python 最大的抱怨就是它的速度慢。有些人甚至因为 Python 的速度不如某个语言而拒绝使用它。本文中我将阐述，即便 Python 这么慢，为什么还值得你对它进行尝试。</p><p>速度不再关键 </p><p>之前，程序的运行时间相当长。CPU 资源和内存资源都十分珍贵，程序的运行时间在这种情况下是一个重要指标。计算机本身十分昂贵，当然还有随之而来昂贵的电力消耗。优化这些资源就十分必要，因为在商业世界有一个永恒的规则：</p><blockquote>优化你最昂贵的资源。<br/></blockquote><p>历史上，程序最昂贵的资源是计算机的运行时间。这也就导致了对计算机科学的研究更专注于不同算法的效率。然而在当下环境中，这已经不再适用，现在硅的价格已经十分便宜了。是真的非常便宜。运行时间不再是你最昂贵的资源。一个公司最昂贵的资源现在是其雇佣的员工的时间。也就是正在看这篇文章的你自己的时间。对现在的公司来说，完成项目比让项目跑得更快更重要。这点非常重要，这里再次强调：</p><blockquote>完成项目比让项目跑得更快更重要。<br/></blockquote><p>你也许会说“我们公司对性能要求很高，我构建的网站应用需要所有的请求在 X 毫秒内返回。”或者“客户认为我们的应用慢而放弃使用我们的应用。”在这里我不是说速度根本不重要，我只是想说明速度不再是最重要的指标，因为它不再是你最昂贵的资源。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-7ab29d8bc2c5cd5815536425a397bff6_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7ab29d8bc2c5cd5815536425a397bff6_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-7ab29d8bc2c5cd5815536425a397bff6_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-7ab29d8bc2c5cd5815536425a397bff6_b.jpg\"/></figure><p> 速度是唯一重要的事情 </p><p>在编程的世界中当你提到速度，一般是指程序的性能，也就是 CPU 周期。而当你的 CEO 提到速度，他通常指的是业务上的速度，其中最重要的是投入市场的时间。你的产品或网络应用有多快并不重要，应用采用哪种语言编写的也不重要，甚至是使项目运行投入了多少资金都不重要。最终，唯一能够让你的公司存活下来的是产品投入市场的时间。</p><p>这里不是指初创公司观念中的盈利时间，而更多是从想法转换到实际消费者手中所花费的时间。在商业世界中能存活下来的唯一方法是比你的竞争对手更快地进行创新。如果你的竞争对手比你更早地发布产品，那么你有再多的好点子也无济于事。你必须成为市场的第一个进入者，或至少要赶上领先的节奏。一旦你掉队了，那么你就大势已去。</p><blockquote>在商业世界中能存活下来的唯一方法是比你竞争对手更快地进行创新。<br/></blockquote><p>微服务的例子 </p><p>亚马逊、谷歌、Netflix 等公司深刻理解速度的重要性。它们创建了一个能快速发展和创新的业务系统。微服务就是这个问题的解决方案。本文并不讨论你是不是应该使用微服务，但最起码亚马逊和谷歌认为它们应采用微服务。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-32737469bf92cfb9ea038a134db6c9ba_b.jpg\" data-rawwidth=\"430\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb\" width=\"430\" data-original=\"https://pic3.zhimg.com/v2-32737469bf92cfb9ea038a134db6c9ba_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;430&#39; height=&#39;327&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"430\" data-rawheight=\"327\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"430\" data-original=\"https://pic3.zhimg.com/v2-32737469bf92cfb9ea038a134db6c9ba_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-32737469bf92cfb9ea038a134db6c9ba_b.jpg\"/></figure><p>微服务天生就很慢。微服务的最基础的概念就是拆分业务边界，并通过网络调用来相互通讯。这也就意味着你需要把一个只占几个 cpu 周期的方法调用转换成网络调用。从性能层面上来说，这简直糟糕透顶。网络调用的速度和 CPU 调用根本不可同日而语。但是那些大公司仍然选择使用微服务。没有比微服务更慢的架构了。</p><p>微服务的最大劣势就是其性能，但是它所带来的最大好处是缩短了投入市场需要的时间。通过构建小型项目和少量代码的团队，公司可以以一个非常快的速度进行迭代与演进。这个例子只是为了展示不仅仅是初创公司，大公司也关注投入市场所需的时间。</p><p>CPU 并非你的瓶颈 </p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-b7a5390495d0a9ba6002157141ad6818_b.jpg\" data-rawwidth=\"350\" data-rawheight=\"245\" class=\"content_image\" width=\"350\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;350&#39; height=&#39;245&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"350\" data-rawheight=\"245\" class=\"content_image lazy\" width=\"350\" data-actualsrc=\"https://pic1.zhimg.com/v2-b7a5390495d0a9ba6002157141ad6818_b.jpg\"/></figure><p>如果你编写像网络服务器上的网络应用，那么 CPU 时间可能并非你应用的瓶颈。当你的网络服务器处理一个请求，它可能会需要调用多个网络调用，例如数据库或 Redis 缓存。这些服务本身速度很快，然而网络调用的过程却很慢。一篇博客很好地描述了各个特定操作速度上的差别。其中，作者将 CPU 时间对应到人们易于理解的时间。如果单个 CPU 周期对应一秒的话，一个从加利福尼亚到纽约的网络调用就大约相当于 4 年。</p><p>对，网络调用就是这么慢。粗略地估计，在同一数据中心内的一个普通的网络调用需要 3 毫秒，这在前面的对应关系下相当于 3 个月。现在假如你的程序是 CPU 密集型的，需要花费 100,000 个 CPU 周期来处理一次调用。按之前的比例来算，这些时间相当于 1 天。那么如果你用一个慢 5 倍的语言，它也就只花费了 5 天。相对于 3 个月的网络调用，4 天的差别就无足轻重了。如果用户在等待一个至少需要 3 个月的包裹，那么 4 天的差别相对来说就不那么重要了。</p><p>说了这么多我只是想说，即便 python 很慢，但这并不重要。语言的速度（也就是 CPU 时间）几乎不会导致问题。谷歌就这个概念做过一个研究，并写了一篇论文。论文中谈论了设计高吞吐量的系统。在结论中这样描述到：</p><blockquote>在一个高吞吐量的环境中使用一个解释型语言看似矛盾，但是我们发现 CPU 时间几乎不是瓶颈因素，表达性强的语言意味着大部分代码是短小的，大多数时间花费在了 I/O 以及原生代码运行时上。此外，解释型的实现所具备的灵活性十分有用，它方便了我们在语言层面上的试验，也方便了我们探索将计算分布到多台机器上的方法。<br/></blockquote><p>简单说来：</p><blockquote>CPU 时间几乎不是瓶颈因素。<br/></blockquote><p>那如果 CPU 时间的确是系统的瓶颈呢？ </p><p>你可能会说“这观点很好，但是我们确实在 CPU 上遇到了瓶颈，造成了我们网络应用的速度缓慢”，或者“在服务器上 X 语言相对 Y 语言需要更少的硬件资源来运行。”这可能都是事实。但网络应用的优势就是你可以几乎无限地进行负载均衡。换而言之，就是使用更多的硬件资源。当然 Python 相较其他语言，如 C 语言，可能需要更多硬件资源。那就使用更多的硬件来解决这个问题。硬件相对于你的人工时间便宜许多。如果你一年内节约了几周的开发时间，这就远胜于你在硬件上所节约下来的花费。</p><p>那么，Python 到底快不快？ </p><p>前面我谈论了最重要的是开发所花费的时间。但是问题还是没有得到回答：Python 的开发时间的确比其他语言快么？经过多方调查，我、谷歌以及许多第三方结论都会告诉你 Python 能提升多大产能。Python 抽象化了诸多内容，可以让你专注于你真正的业务逻辑，而不用关心你是应该使用 vector 还是 array 等底层细节问题。你可能不相信这道听途说的观点，所以让我们看一些经验数据。</p><p>总体来说，争论 python 是否高产，最终讨论的是脚本（或动态语言）与静态类型语言之间的比较。我认为大家都赞同静态类型语言的产量较低，但这里有一篇很好的论文解释了其中的原因。就 Python 而言，曾有研究分析了不同语言编写一个字符串处理程序所花费的时间，并做了很好的总结。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-a2ee731965d363f4acaec4a18b5a3227_b.png\" data-rawwidth=\"523\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb\" width=\"523\" data-original=\"https://pic4.zhimg.com/v2-a2ee731965d363f4acaec4a18b5a3227_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;523&#39; height=&#39;280&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"523\" data-rawheight=\"280\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"523\" data-original=\"https://pic4.zhimg.com/v2-a2ee731965d363f4acaec4a18b5a3227_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-a2ee731965d363f4acaec4a18b5a3227_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在结论中 Python 比 Java 的生产效率高两倍。还有其他诸多研究结果得到类似的结论。Rosetta Code 对不同语言进行了公平而深入地研究。在论文中它们将 Python 和其他脚本 / 解释型语言进行了比较，并认为：</p><blockquote>Python 是其中最精练的，甚至比函数式语言更好（平均短 1.2-1.6 倍）。<br/></blockquote><p>总体看来 Python 代码的行数总是更少。代码行数听上去是一个糟糕的指标，但是多项研究显示（包括之前提及的两个），在各语言中输入每行代码的时间是不相上下的。因此，减少代码行数也就相当于提高了生产效率。就连 C# 程序员 codinghorror 也写了一篇文章阐述 Python 具有更高的产量。</p><p>我认为这已经足够能说明 Python 相较于诸多其他语言更高产。这主要归功于 Python 的开箱即用以及丰富的第三方包。这里有一篇文章简述了 Python 和其他语言的差别。如果你不知道为什么 Python 这么“小”还这么高产，我推荐你学习一下 Python 来亲自体验一下，下面将是你的第一行程序：</p><div class=\"highlight\"><pre><code class=\"language-text\">import __hello__</code></pre></div><p>如果运行速度对你真的很重要？ </p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-0996d72801b1cd5485021fd5ea652f5b_b.jpg\" data-rawwidth=\"401\" data-rawheight=\"299\" class=\"content_image\" width=\"401\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;401&#39; height=&#39;299&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"401\" data-rawheight=\"299\" class=\"content_image lazy\" width=\"401\" data-actualsrc=\"https://pic4.zhimg.com/v2-0996d72801b1cd5485021fd5ea652f5b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上述观点的论调听上去像认为优化和速度根本不重要。但是事实是，许多时候运行时效率至关重要。一个例子是，你的网络应用有一个特定的端点需要相当长的时间来响应请求。同时你知道它需要有多快，也知道它要被优化到什么程度。</p><p>在这个例子中，发生了下面两件事：</p><ol><li>我们关注到某个运行慢的端点。</li><li>我们认为它慢，因为我们了解什么是足够快，并且它没能达到这个指标。</li></ol><p>我们不必在应用中对每个服务进行细节调优。每个服务只需要能“足够快”来满足用户的需求就够了。用户会发现某个端点花费了几秒时间返回，但是他们并不会注意到你把一个 35 毫秒的请求优化到了 25 毫秒。你只需要达到“足够好”就可以了。免责声明：不得不说一些应用，如实时拍卖应用，确实需要细节调优，能提升一毫秒算一毫秒。但是这是一个特例，而不是业界的规则。</p><p>为了弄清如何优化某个端点，第一步你需要对你的代码进行性能分析，并尝试整理出其中的瓶颈。归根到底：</p><blockquote>任何不考虑瓶颈的调优都是幻想。—— Gene Kim<br/></blockquote><p>如果你的优化并不解决瓶颈，那你就是在浪费你的时间，而且还不能解决真正地问题。不解决瓶颈，你就不会在性能上得到显著的提升。如果你尝试着在了解瓶颈前优化，你就像在和你的代码在玩打地鼠的游戏。在排查和确定瓶颈前优化代码也是“不成熟优化”的表现。Donald Knuth 常被引用下面的观点，虽然他本人称这也是从其他人那儿听来的：</p><blockquote>不成熟的优化是万恶之源。<br/></blockquote><p>Donald Knuth 在一次关于维护代码库的讨论中进行了下面的完整描述：</p><p>我们应该忘记那些小的性能提升，这占了 97% 的时间：不成熟的优化是万恶之源。但同时我们也不能放过那至关重要的 3%。</p><p>换句话来说，大部分时间，你不应该关心代码的优化。它们通常已经足够好了。如果没有能达到标准，我们应该只需要改变那 3% 的代码。你并不会因为你的代码使用一个 if 替代了一个方法，得到几毫秒的性能提升而获得任何奖励。只有在分析之后再进行优化。</p><p>不成熟的优化包含盲目调用某个更快的方法，或使用一个特定的数据结构只因为其总体上更快。计算机科学认为两个方法或算法有一样的渐进增长（或时间复杂度），那么就可以认为它们性能是相同的，就算其中之一比另一个慢两倍。计算机的速度太快，算法在计算上的增长，如数据或使用量的增长比算法本身重要得多。</p><p>换而言之，如果你有两个 O(log n) 的方法，一个是另一个速度的两倍，这之间的差别根本无关紧要。随着数据量的增长，它们都会以相同的速度变慢。这也就是为什么不成熟的优化是万恶之源，它会浪费我们的时间，最终却在提升性能上帮不上我们什么忙。</p><p>就时间复杂度而言，你可以认为用任何的语言写你的程序的复杂度都是 O(n) 的，其中 n 是代码的行数或指令个数。同一指令的增长速率都是相同的。所以一个语言或运行时的快慢并不重要，就渐进增长而言，所有语言都是等价的。在这个逻辑下，你可以认为，因为某个语言速度快而选择其为开发你应用的语言是不成熟优化的一种体现。你不应该主观地判断某个语言快而不去进行衡量、不去了解将会遇到的瓶颈。</p><blockquote>因为某个语言速度快而选择其为开发你应用的语言是不成熟优化的一种体现。<br/></blockquote><figure><noscript><img src=\"https://pic4.zhimg.com/v2-784d2d86fc047e9d4d7c30b100c77163_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-784d2d86fc047e9d4d7c30b100c77163_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;394&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"394\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic4.zhimg.com/v2-784d2d86fc047e9d4d7c30b100c77163_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-784d2d86fc047e9d4d7c30b100c77163_b.jpg\"/></figure><p> 优化 Python </p><p>我最喜欢 Python 的一点就是它可以让你一步一步地优化你的代码。比如说你有一个 Python 方法，你发现它是你项目中的瓶颈。你已经对其优化了数次，可能是遵循了这里或这里的意见，现在你确定 Python 本身是你应用的瓶颈所在。</p><p>Python 是能够直接调用 C 代码的，这就意味着你可以用 C 重写这个方法来减少性能问题。你可以一个一个地进行替换。这个过程能让你调用任何最终编译成 C 兼容指令的优化的代码，也让你能在大部分情况下继续使用 Python，而只在真正需要的时候深入底层进行开发。</p><p>有一个叫 Cython 的语言，它是 Python 的超集。几乎是 Python 和 C 的结合体，同时它是渐进的类型化语言。任何 Python 代码都是合法的 Cython 代码，Cython 会将代码编译成 C 代码。有了 Cython，你可以编写模块或方法，渐渐地引入 C 语言的类型和性能。你可以混合使用 C 语言的类型和 Python 的鸭子类型（duck type）。通过 Cython 你可以只在瓶颈处进行调优，而在其他地方仍然使用优美的 Python 语言，两者能完美地结合。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-d406dec06c84d459876ce8d3cc12ca3e_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-d406dec06c84d459876ce8d3cc12ca3e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;375&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"375\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic3.zhimg.com/v2-d406dec06c84d459876ce8d3cc12ca3e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-d406dec06c84d459876ce8d3cc12ca3e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>使用 Python 编写的太空大规模多人在线游戏 EVE Online 的截图</p><p>当你最终遇到了 Python 的性能瓶颈，你不需要将你所有代码移植到其他语言。你总是可以使用 Cython 重写部分方法来满足性能上的需求。这也是游戏 EVE Online 所采用的策略。Eve 是一个大型多人在线电脑游戏，它完全使用 Python 和 Cython 开发。游戏开发人员通过在 C/Cython 中调优瓶颈来达到游戏级的性能要求。如果游戏都能达到性能上的需求，那么大部分情况都应该可以满足。</p><p>此外，还有其他方法来优化你的 Python 程序。例如 PyPy 是一个 Python 的运行时编译执行（JIT）的实现，只需要使用 PyPy 切换默认的 Cython，就可以显著地提升你长时间运行应用的运行时性能，如在网络服务器上。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-f12a33f752f35964a093aa8afef39ef2_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f12a33f752f35964a093aa8afef39ef2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-f12a33f752f35964a093aa8afef39ef2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-f12a33f752f35964a093aa8afef39ef2_b.jpg\"/></figure><p>让我们回顾一下文中的要点：</p><ul><li>优化你最昂贵的资源。也就是你自己，而不是电脑。</li><li>选择可以有助于快速开发的语言、框架、架构，例如 Python。不要只因为运行速度快而选择某个技术。</li><li>当你的应用有性能问题时，找出你应用中性能的瓶颈。</li><li>你的瓶颈通常不是 CPU 或 Python 本身。</li><li>如果你已经优化了算法或其他方面，确定 Python 的确是你项目的瓶颈，那么可以将这个热点移到 Cython/C 中进行改写。</li><li>接下来就坐下来享受快速编码的乐趣吧。</li></ul>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": [
                {
                    "userName": "上官无忌", 
                    "userLink": "https://www.zhihu.com/people/e5fc309baef034bac7bb47a66636ab59", 
                    "content": "其实我是这么想的，C语言是快，但是我是大神，不会将程序优化到极致，可能我写出来的程序还不如现成优化过的python库的代码运行速度快呢，那我为什么不选又好又\"快\"的python呢？", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28353076", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "测试的同学一定要点进来看看", 
            "content": "<p></p><p>       看过我写文章或者在知乎答题的同学都知道，其实我对测试一直是悲观的态度。主要有几个原因，今天再重复下吧(当然，这些都是个人看法，不一定对)！ </p><p class=\"ztext-empty-paragraph\"><br/></p><p>一、第N次吐槽</p><p>1，测试人员碰到最头疼的一个问题大概就是开发人员对自己说:我写了一个bug，为啥你没有测试出来。感觉测试人员就是帮开发人员擦屁股的，而且还要擦干净。这是不是本来就不是一件合理的事情呢？而我又最不喜欢帮别人擦屁股。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2，大家都知道，开发的工作在于深度，而测试在于广度。这样的定位让测试人员更容易达到职业发展的瓶颈，而且容易迷茫。有很多人说事在人为，但是能力差不多的情况下，工作的性质和方向会显得很重要。我身边有很多测试大牛，我认为他们的能力都非常好，如果是做其他岗位的话，空间会大很多。但是因为岗位的原因，一直得不到更好的职业发展机会，部分同学已经开始对职业心灰意冷或者找其他出路。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3，测试的岗位好歹也是一个技术岗位，既然是技术岗位，那么测试的技术能力体现在哪里呢？我们都在抱怨开发写的代码烂，但是其实绝大部分测试人员的代码写的比一般开发还烂(开发人员明显对代码质量要求更高，还有各种约束，而测试基本就是野蛮生长，对质量要求也没有那么高)。下面看看测试人员的能力模型，其实往上走发现还是开发人员的路线，只是路径更长了而已。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-805dc393f68771a490a72e52b512d09a_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-805dc393f68771a490a72e52b512d09a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;442&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"442\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic3.zhimg.com/v2-805dc393f68771a490a72e52b512d09a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-805dc393f68771a490a72e52b512d09a_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>     当然，这些都是相对的，并不是说测试岗位不好，每个岗位都有自己无奈的一面(开发的进度压力就会比较大)。适合自己的才是最好的，而且很多同学也适合做测试。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二、建议</p><p>不管怎样，既然选择了做测试，那么我们还是希望从测试开始，如何获得更好的职业发展吧！具体大家可以看看这篇文章：</p><p><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAwMjcwMTU3OQ%3D%3D%26mid%3D2649730419%26idx%3D1%26sn%3D323966b21f1721db4a76c2cc3b69cf6b%26chksm%3D82dd6d17b5aae4013f9e10e1bab119797e9ab880cdb44646e22e6f4877c577718ade4bbbfac3%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从测试小白到测试大神，你们之间隔着这篇文章</a> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>然后重要的事情说三遍：</p><p>未来三年内，纯手工测试人员一定会失业！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>未来三年内，纯手工测试人员一定会失业！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>未来三年内，纯手工测试人员一定会失业！！！</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>三、测试圈</p><p>在测试圈的同学应该知道前几天小密圈访问不了了(官方说法是技术升级)，然后也有很多同学问我怎么回事，其实我心里比大家还着急。因为当时选择小密圈的时候也犹豫了很久，最后确认看到他发展的比较快，我自己也加入了一些圈子一段时间，发现还不错才会下定决心的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><br/><br/>而且当时给大家的承诺是自己会长期投入精力去运营这个测试圈，除非小密圈倒闭。结果建完圈子一个月左右，就发生了这样的事情，我当时是真的以为小密圈要倒闭了。心想这不是打脸嘛！同时该怎么给那些因为信任而付费的朋友一个交代呢(甚至有同学进圈子不到一天就碰到了这样的事情)？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><br/><br/>大家会发现我最近公众号更新的都比较慢了，真的不是因为我懒，而且一直在想怎么解决这个问题，一边在关注小密圈的消息，一边再看看有没有其他类似的产品(也体验了一些)，但是一直不敢贸然行动(毕竟不能忽悠大家第二次)。当然本来是打算小密圈如果真的倒闭的话，自己通过小程序去自己搭建一个测试圈，这样至少保险一点，而且真的已经在网上学习小程序的开发教程了(除了帅，学习能力强大概就是我最大的优点了)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>        庆幸的是，小密圈昨天居然死而复生了。而且相信大难不死 必有后福。吸取经验教训后，小密圈应该后面会走的更好吧！更重要的是，我可以继续来持续运营这个测试圈了！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>接着说说后面测试圈的运营思路吧！</p><p>       我将测试分为上半场和下班场，上半场主要是当前的一些传统的测试技术，其实已经比较成熟并且都有比较完善的学习方法和教程了。下半场则是随着人工智能和大数据的到来，同时给测试技术必然会带来很多新的突破，而这些也是大家的一个新的机会。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>      首先，石头哥会将上半场的所有测试领域的相关技术学习方法，经验和教程等整理出来，让大家尽量少有弯路，同时节省学习的时间(现在其实测试到了一个比较尴尬的时候，如果你学习的速度赶不上企业对测试技能更高要求的速度时，你就又被淘汰的风险)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>        同时，会邀请每个领域的专家作为嘉宾到圈子里面，大家有什么问题可以一起交流。嗯，反正测试圈是你在测试领域成长的一个资源，怎么用好就看你自己了，多发言，多提问就对了(虽然不能保证你每个问题都得到答案)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>上半场的测试技术分享大概就是这些维度吧！(大家看看有没有要补充的)，同时有这方面的专家欢迎联系我。</p><ul><li>软件测试入门<br/></li><li>功能测试</li><li>web测试</li><li>app测试</li><li>测试设计</li><li>性能测试</li><li>测试开发</li><li>安全测试</li><li>测试分析</li><li>项目管理</li><li>测试技术规划</li><li>测试的职业发展</li></ul><p>这个阶段大概会在1~2个月内完成！</p><p class=\"ztext-empty-paragraph\"><br/></p><p>     完成后，后面会开始关注云计算、大数据、物联网、人工智能和区块链等方面的技术和测试技术，希望给大家带来一些新的思路(保持对新技术的敏感和好奇心总是一件好事吧)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>      同时，可能根据情况将测试的内推直接放到测试圈里面来，让大家获得更好的工作和职业发展机会。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>      总之，只要是对测试的同学职业发展有帮助的事情，都会尝试去做，也希望大家能够一起参与建设(尽管我对测试依然是悲观的态度)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>     虽然世界不那么美好，我们也改变不了。但是我们还是要努力让自己变得更加美好，不是吗？</p>", 
            "topic": [
                {
                    "tag": "测试工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19601358"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28277166", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "详解Python项目开发时自定义模块中对象的导入和使用", 
            "content": "<p><strong>背景：</strong>1）任何一个Python程序文件既可以直接执行，也可以作为模块导入再使用其中的对象；2）对于大型系统开发，一般不会把所有代码放到单个文件中，而是根据功能将其分类并分散多个模块中，在编写小型项目时最好也能养成这样的好习惯。</p><p>本文介绍Python自定义模块中对象的导入和使用。</p><p>假设当前工作目录为C:\\Python36，创建一个子目录child，然后在其中创建一个Python程序文件add.py，其中的代码为：</p><p>def add(x, y):<br/>    return x+y</p><p>这时，文件夹结构如图所示：</p><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_b.png\" data-rawwidth=\"640\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;90&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"90\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-96bf88dd3fe979b4d4531d0bd1b0baf9_b.png\"/></figure></p><p>现在我们启动IDLE交互编程模式，默认工作目录是C:\\Python36，执行下面的代码：</p><p>&gt;&gt;&gt; import child<br/>&gt;&gt;&gt; child.add.add(3,5)<br/>Traceback (most recent call last):<br/>  File &#34;&lt;pyshell#17&gt;&#34;, line 1, in &lt;module&gt;<br/>    child.add.add(3,5)<br/>AttributeError: module &#39;child&#39; has no attribute &#39;add&#39;</p><p>错误提示显示，child模块中没有可用的add，这是因为child文件夹被认为是一个包，而add.py是包中的子模块，并没有随着child一起导入。继续执行下面的代码：</p><p>&gt;&gt;&gt; import child.add<br/>&gt;&gt;&gt; child.add.add(3,5)<br/>8</p><p>自定义模块中的对象成功被导入并能够正常使用，也就是说，<strong>如果要使用的对象在子模块中，应该单独使用import来导入子模块</strong>。或者使用下面的方法：</p><p>&gt;&gt;&gt; from child import add<br/>&gt;&gt;&gt; add.add(3,5)<br/>8</p><p>接下来在IDLE中单击菜单“Restart Shell”恢复初始状态，然后执行下面的代码：</p><p>&gt;&gt;&gt; from child import *<br/>&gt;&gt;&gt; add.add(3,5)<br/>Traceback (most recent call last):<br/>  File &#34;&lt;pyshell#24&gt;&#34;, line 1, in &lt;module&gt;<br/>    add.add(3,5)<br/>NameError: name &#39;add&#39; is not defined</p><p>错误提示显示并不存在add这样的名字，也就是说命令from child import *并没有导入add模块。现在在child子文件夹中创建一个Python程序文件__init__.py，其中内容为：</p><p>__all__ = [&#39;add&#39;]</p><p class=\"ztext-empty-paragraph\"><br/></p><p>此时文件夹结构变为：</p><p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_b.png\" data-rawwidth=\"640\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;119&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"119\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f1193d9b520e283f8204ebf491fb2169_b.png\"/></figure></p><p>然后回到IDLE中执行刚才的代码：</p><p>&gt;&gt;&gt; from child import *<br/>&gt;&gt;&gt; add.add(3,5)<br/>8</p><p class=\"ztext-empty-paragraph\"><br/></p><p>结果正常。原因在于，<strong>如果文件夹作为包来使用，并且其中包含__init__.py文件时，__init__.py文件中的特殊列表成员__all__用来指定from ... import *时哪些子模块或对象会被自动导入</strong>。</p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19606083"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28311111", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 1, 
            "title": "Python随机生成身份证号码！（特别好用）", 
            "content": "<p>今天一个朋友和我聊天说到，昨天去百度面试高级测试工程师。</p><p>面试过程中，有被问到Python相关知识。</p><p>也提了一个Python相关的问题。</p><p>用Python实现随机生成大于18以上的身份证号码。</p><p>很遗憾他没有做出来。但是至少也是一次不错的面试经验。</p><p>上午我就自己动手试了试。</p><p>首先百度了下身份证生成规则。下面大家来一起看一下：</p><p>公民身份号码是由17位数字码和1位校验码组成。排列顺序从左至右分别为：6位地址码，8位出生日期码，3位顺序码和1位校验码。</p><p>地址码（身份证地址码对照表见下面附录）和出生日期码很好理解，顺序码表示在同一地址码所标识的区域范围内，对同年同月同日出生的人编定的顺序号，顺序码的奇数分配给男性，偶数分配给女性。</p><p>身份证最后一位校验码算法如下：</p><ol><li>将身份证号码前17位数分别乘以不同的系数，从第1位到第17位的系数分别为：7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2</li><li>将得到的17个乘积相加。</li><li>将相加后的和除以11并得到余数。</li><li>余数可能为0 1 2 3 4 5 6 7 8 9 10这些个数字，其对应的身份证最后一位校验码为1 0 X 9 8 7 6 5 4 3 2。</li></ol><p>身份证号码解密|身份证尾数校验码算法|ID card information</p><p>身份证地址码对照表。</p><p>以下代码都是在Python3环境下运行，用Python2的请自行修改再运行。</p><p>运行环境：Python3，运行使用的到库：requests，bs4，random，time</p><p>这个网站有点过分了，没登录不让复制，我就直接暴力点，把它爬下来了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-80e53a056374d11582c2199b5be24cd7_b.jpg\" data-rawwidth=\"471\" data-rawheight=\"548\" class=\"origin_image zh-lightbox-thumb\" width=\"471\" data-original=\"https://pic4.zhimg.com/v2-80e53a056374d11582c2199b5be24cd7_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;471&#39; height=&#39;548&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"471\" data-rawheight=\"548\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"471\" data-original=\"https://pic4.zhimg.com/v2-80e53a056374d11582c2199b5be24cd7_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-80e53a056374d11582c2199b5be24cd7_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><div class=\"highlight\"><pre><code class=\"language-text\">import requests</code></pre></div><p>不过大家不要太认真。（我还是比较菜的）</p><p>下面是身份证生成代码。</p><p>问题：</p><p>1：前6位为随便复制了一点地区代码加到列表里面去随机取。</p><p>2：年份直接从1948年开始（百度介绍说身份证是从1948年开始实施的，虽然当时好像是15位吧），结束年份为当前本地时间减去18，这样就避免生成的身份证号码上年龄小于18周岁</p><p>3：日期我没有去考虑每月的日期长度（例如2月份没有30,31号），我直接以1-31</p><p>4：后面四位我没有按照规则去生成。</p><p>PS：有兴趣的可以完善下，让生成的更加符合规律。</p><div class=\"highlight\"><pre><code class=\"language-text\">import randomimport timedef regiun():</code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-b6c3e2a6c22b75717612c16dbb5d7a59_b.jpg\" data-rawwidth=\"640\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-b6c3e2a6c22b75717612c16dbb5d7a59_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;640&#39; height=&#39;389&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"640\" data-rawheight=\"389\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"640\" data-original=\"https://pic2.zhimg.com/v2-b6c3e2a6c22b75717612c16dbb5d7a59_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-b6c3e2a6c22b75717612c16dbb5d7a59_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28306212", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 2, 
            "title": "给所有要找IT工作的应届毕业生", 
            "content": "<p>最近李文星同学的遭遇应该牵动着每一位求职者的心，给本来不好找工作的同学心理造成了更大的压力，我们不禁要问这个世界，到底是怎么了？ </p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么大学毕业出来后找不到工作成为了一个常态？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么很多同学大学毕业后还要被培训机构拉过去剪一次羊毛，而且剪完后依然找不到工作？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么一个专业的招聘平台能够让骗子企业轻易的发布岗位？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>为什么骗子能够轻易的骗到一个大学毕业生？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>IT行业不是被认为当前最火的行业之一吗？为什么这么不好找工作了？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>       是的，一个应届毕业生到底要经历怎样的绝望才能找到一份能够养活自己的工作？(最近很多刚毕业同学找我推荐工作的时候对工资的期望就是能够让自己吃饱就行，有个住的地方就行)。这是怎样的心酸和无奈？那么，到底怪谁呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>也许答案在下面</p><p class=\"ztext-empty-paragraph\"><br/></p><p>一，不好找工作的原因</p><p>1，当前的IT行业确实相比以前更难找工作了，原因还是最近几年大量这方面的人员进入，虽然行业的需求在增加，但是没有跟上人员进入的速度</p><p class=\"ztext-empty-paragraph\"><br/></p><p>2，很多IT同学在大学期间基本就是啥都没有学到，很难给公司一个录取的理由。这个是我参加很多次校园招聘后的一个体验，一般只要有基础的我都会面试下，看看潜力和学习能力怎样(这个其实是应届毕业生的两个很重要的能力)，但是基本上什么都不会的话，怎么去评价这块的能力呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3，因为技能不足，所以去参加培训机构，说实话，如果是希望参加培训机构来获得技能的话，这个还可以接受，但是一个没有基础的人期望在培训机构学习三个月后包装下简历就获得工作机会，这样自欺欺人的行为只能被人欺(被培训机构骗钱了还是找不到工作)，很多面试官(包括我)只要看到简历有培训机构的项目痕迹(其实很容易看出来)，基本直接pass。个人一直觉的培训机构让大家更难找工作了(因为部分企业不容易识别或者被欺骗过，所以直接提高了门槛)。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>二，是不是就找不到工作了</p><p>        现在的工作比以前更难是事实，但是很明显不是完全找不到工作，每年不是还有很多应届毕业生找到工作了吗？而且每年的校招都进行的如火如荼，甚至部分同学拿到了很多offer。找不到工作总是有原因的，也许是能力不够，也许是运气不好，也许是学历不足。还是建议自己思考下，别自己在大学期间什么都没有学习，毕业却抱怨公司不给应届毕业生机会（公司又不是慈善机构，如果你开公司的话，你会怎么做呢？）</p><p class=\"ztext-empty-paragraph\"><br/></p><p>三，如何找到工作</p><p>1，还是先评估自己擅长做什么？如果大学期间没有思考清楚的话，还是建议自己花时间考虑下。这里提供一个简单的判断方法吧！如果看到代码就头疼的话，大学基本对这块不感冒的话，肯定就不用选择做技术了(开发和测试)。如果喜欢和人打交道，并且想去做一些有挑战的事情的话可以考虑做销售和运营。详细的可以看看下面的文章。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><a href=\"https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzAwMjcwMTU3OQ%3D%3D%26mid%3D2649730078%26idx%3D1%26sn%3D3ce52f9627af8102820939bf74eccf27%26scene%3D21%23wechat_redirect\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">如何选择一份自己喜欢的工作（强烈推荐）</a> </p><p class=\"ztext-empty-paragraph\"><br/></p><p>2，搞清楚自己的方向后，如果还有一年时间毕业的话，完全来得及做准备(当然，再不准备就来不及了)。比如，如果确定做技术了就多尝试做一些东西出来(图书馆这样的书一大把，网上也一堆资料和源代码，稍微研究下就容易出成果了)，如果做运营，现在就可以去开多建立一些群，甚至在网上找些这方面的兼职来提高这块的经验。总之就是尽量有些成果可以拿出来写到简历里面去的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>3，剩余的就是多看些相关方面的书籍，必要的理论知识还是要掌握的，再加上自己的一些实践经验，问题就不会太大了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>以上几点不难吧？</b></p><p class=\"ztext-empty-paragraph\"><br/></p><p>4，准备差不多了的话，就开始关注校园招聘吧！对于应届毕业生来说，最好的机会就是秋季的校园招聘，然后是第二年春季的校园招聘（而且不用担心被骗）。真的是过了这个时间，后面再找到合适的工作会难很多。因为大部分公司每年都有应届毕业生的名额(比如招200个)，然后基本上校园招聘的过程中会发超过200个offer，同时会留一些备选的人。企业通过校园招聘将人招满后，他们就不需要应届毕业生了。如果出现人员离职等情况的话就会通过招聘有经验的人来补上了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>       所以，如果可以的话尽量去关注校招吧！不一定是你们学校的(因为大部分公司都是去名校招人)，多关注你们整个城市甚至省份的。如果有心仪的企业的话多去关注他们的官网和招聘的公众平台吧，一般都会查到校园招聘的行程安排，自己要主动点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>5，如果不小心错过了校园招聘，同时以前又没有好好学习，需要出来找工作了怎么办？</p><p class=\"ztext-empty-paragraph\"><br/></p><p>这个时候就一边学习，一边投简历吧！（先学习如何防止被骗，社会比你想象的要凶险，你最需要学习的是如何保护好自己）。至于如何写简历和面试，可以直接在后台回复“简历”和“面试”，来学习下如何更好的写简历和准备面试吧！这样自己面试成功的机会会更大一点。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>      另外，如何在求职中防止被骗，网上总结的虚假招聘的8个显著特征(可以参考下)！遇到这样的“招聘者”一定要多加留心！</p><p>1、招聘单位没有名字，查不到任何信息，只有手机号码和电子邮件的单一联系方式。</p><p>2、收取“服装费、伙食费、体检费、报名费、办卡费、押金、培训费”等各种费用。</p><p>3、告知无需任何条件即可直接面试、上岗。</p><p>4、通知面试职位明显与实际工作岗位不同。</p><p>5、期许薪资明显高于同职位同工种薪资水平。</p><p>6、扣押、或以保管为名索要身份证、毕业证等证件。</p><p>7、公司地址含糊不清，面市场所不正规，类似临时租借来的宾馆等地。</p><p>8、非正常工作时间段预约面试，或面试地点在很偏远的地方。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>最后，希望这样的悲剧不会再发生，大家一起让更多的学弟学妹看到吧！你会的，对吗？</p>", 
            "topic": [
                {
                    "tag": "面试", 
                    "tagLink": "https://api.zhihu.com/topics/19552079"
                }, 
                {
                    "tag": "应届毕业生", 
                    "tagLink": "https://api.zhihu.com/topics/19558008"
                }, 
                {
                    "tag": "找工作交流", 
                    "tagLink": "https://api.zhihu.com/topics/19940165"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28311029", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "python基础-系统操作", 
            "content": "<p>这篇我们介绍下跟操作系统相关的一些内容，<br/> 操作系统的内容比如操作命令等算是我们运维人的基本功了，因为如果连敲命令都吃力的话也提谈不上什么自动化运维了， <br/>在linux里我们经常用的命令比如， cp,  mv, mkdir, <br/>chown,chmod等基本一天下来也就这几个命令反复使用，其实只看这些体现不出来运维的能力，真正体现运维能力的地方是出现问题时如何分析解决，这是难点，这也跟经验有关，<br/><br/>在一个复杂的问题面前，这时候基本功就显得尤为重要，对操作系统理解的深度体现了解决问题的能力差别，如果你想在在操作系统层面理解的更深一点，我推荐你读一下《现代操作系统》这本书，读完这本书你在操作系统层面的认知会有一个比较大的提升，按照运维技术能力的发展，在理解操了操作系统的基础上这个时候我们一般开始接触学习shell编程了，<br/><br/>在这里我说一下做为一个Linux系统管理员，shell是你必须要掌握的技能，虽然Python都能实现，但我仍不建议你跳过shell这个重要阶段，因为如果你做运维，你不可能避免接触shell，就算你不写，你也避免不了去看别人写的shell，还有就是公司不可能就你一个运维，你不用不代表别人不用，你想想如果大家在一个团队里工作，如果都互相看不懂别人的脚本，大家还怎么配合工作？</p><p>搞定上面shell阶段后，出于对自己更高的要求（其实想多挣点钱），了解到了现在公司招聘都需要Python，就开始看书发奋学习，在看过书后，开始上手写一些功能脚本，很快就会发现用python很麻烦，不如用shell直接操作方便，不过这也难不倒我们，一顿搜索之后发现了几个宝贝，os.system()，<br/> os.popen()这几个函数可以直接调用shell命令来执行，从那一刻起就像手中有了亚瑟大宝剑和干将莫邪，所有需要shell执行的部分全部用这几个函数来完成，<br/><br/>等写完某个脚本后感觉非常有成就感，而且感觉自己python水平与日俱增，自我感觉非常良好，但你实际去看写的每个脚本，你发现不到100行的Python代码里有，有一半以上的行都是调用的shell命令，<br/><br/>好好的shell命令硬生生的在外面包了一层python代码，每当我看到这些代码，我都无语，如果你也在写这种脚本，我建议你尽快停掉这种方式吧，因为你即使写一万行这种代码，对你学习python基本没有质的提升，何必呢，看着都累。</p><p>写在最后，因为关于操作系统方面的内容比较基础，我也没准备什么例子去展示，不过为了大家进一步的了解，我列了下一些系统方面的操作供大家参考学习：</p><p>判断目录存在和是否文件：</p><blockquote>if os.path.exists(&#39;conndb.log&#39;):<br/>   with open(&#39;conndb.log&#39;) as f:<br/>       for line in f:<br/>           print line<br/><br/>if os.path.isfile(&#39;conndb.log&#39;):<br/>   with open(&#39;conndb.log&#39;) as f:<br/>       for line in f:<br/>           print line</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>部分常用系统命令：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>shutil.copy(&#39;conndb.log&#39;, &#39;conndb.log.back&#39;)   #拷贝<br/>os.rename(&#39;conndb.log&#39;,&#39;db.log&#39;)               #重命名<br/>os.path.abspath(&#39;conndb.log&#39;)                  #获取绝对路径<br/>os.mkdir(&#39;onedir&#39;)                             #建目录<br/>os.listdir(&#39;/tmp&#39;)                             #列出目录内容<br/>os.chmod()                                     #修改文件权限<br/>os.chown()                                     #修改属主数组</blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>文件匹配，glob模块使用：</p><p class=\"ztext-empty-paragraph\"><br/></p><blockquote>print glob.glob(&#39;sys*&#39;)   #打印以sys开头的文件或目录<br/><br/>print glob.glob(&#39;??&#39;)     #匹配打印2个字符的目录文件<br/><br/>print glob.glob(&#39;c*g&#39;)    #匹配以c开头以g结尾的目录文件<br/><br/>print  glob.glob(&#39;[cs]*log&#39;)  #匹配以c或s开头以log结尾的文件</blockquote>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28277145", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "Python内置函数——getattr", 
            "content": "<p></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-e6cef43181c524598cf937a787c47d70_b.jpg\" data-rawwidth=\"600\" data-rawheight=\"346\" class=\"origin_image zh-lightbox-thumb\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-e6cef43181c524598cf937a787c47d70_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;600&#39; height=&#39;346&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"600\" data-rawheight=\"346\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"600\" data-original=\"https://pic1.zhimg.com/v2-e6cef43181c524598cf937a787c47d70_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-e6cef43181c524598cf937a787c47d70_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p><b>英文文档</b></p><h2>getattr(object, name[, default])</h2><p>Return<br/> the value of the named attribute of object. name must be a string. If <br/>the string is the name of one of the object’s attributes, the result is <br/>the value of that attribute. For example, getattr(x, ‘foobar’) is <br/>equivalent to x.foobar. If the named attribute does not exist, default <br/>is returned if provided, otherwise AttributeError is raised.</p><p><b>说明</b></p><h2><b>函数功能是从对象object中获取名称为name的属性，等效与调用object.name。</b></h2><h2><i>#定义类Student<br/></i>&gt;&gt;&gt; <b>class</b> <b>Student</b>: <b>def</b> <b>__init__</b>(self,name):<br/>        self.name = name<br/><br/>&gt;&gt;&gt; s = Stduent(&#39;Aim&#39;)<br/>&gt;&gt;&gt; getattr(s,&#39;name&#39;) <i>#等效于调用s.name<br/></i>&#39;Aim&#39;<br/>&gt;&gt;&gt; s.name<br/>&#39;Aim&#39;</h2><div class=\"highlight\"><pre><code class=\"language-text\">函数第三个参数default为可选参数，如果object中含义name属性，则返回name属性的值，如果没有name属性，则返回default值，如果default未传入值，则报错。</code></pre></div><h2><i>#定义类Student<br/></i>&gt;&gt;&gt; <b>class</b> <b>Student</b>: <b>def</b> <b>__init__</b>(self,name):<br/>        self.name = name<br/><br/>&gt;&gt;&gt; getattr(s,&#39;name&#39;) <i>#存在属性name<br/></i>&#39;Aim&#39;<br/><br/>&gt;&gt;&gt; getattr(s,&#39;age&#39;,6) <i>#不存在属性age，但提供了默认值，返回默认值<br/>6<br/></i>&gt;&gt;&gt; getattr(s,&#39;age&#39;) <i>#不存在属性age，未提供默认值，调用报错<br/></i>Traceback (most recent call last):<br/>  File &#34;&lt;pyshell#17&gt;&#34;, line 1, <b>in</b> &lt;module&gt;<br/>    getattr(s,&#39;age&#39;)<br/>AttributeError: &#39;Stduent&#39; object has no attribute &#39;age&#39;</h2>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19606083"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28277250", 
            "userName": "python发烧友", 
            "userLink": "https://www.zhihu.com/people/4d3d0e68b47313ac630ca87c2c5e576d", 
            "upvote": 0, 
            "title": "谈 Python 项目的配置管理", 
            "content": "<p>每次开始一个新的 Python 项目，我都会为怎么管理配置文件而头疼。不过在迁移我的博客时，终于有空花了点时间，把这件事想清楚。</p><p>一年多的时间过去了，一切似乎都很顺利，连我在知乎所做的新项目也沿用了该方案，于是决定把解决方案记录下来。 先说说我要解决什么哪些问题吧： </p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>可以区分各种环境。<br/>在开发、测试和生产等环境，都可能用到不同的配置，所以能区分它们是一个很基本的需求。<br/></li><li>可以有通用的配置项。<br/>各种环境的配置中，需要修改的只占一小部分。因此通用的部分应该不需要重复定义，否则会带来维护成本。<br/></li><li>可以分成多个部分/模块。<br/>随着配置项的增多，找起配置来会花大量时间，所以划分它们对维护配置很有帮助。<br/></li><li>可以直接使用 Python 代码。<br/>从文本文件中解析出变量值太麻烦，而且不方便生成批量的数据（例如数组），也不好通过函数调用来生成配置值（例如获取文件路径）。<br/></li><li>可以将公开和私有的配置文件分开管理。<br/>在开源项目中，应只包含公开的配置项，而不包含私有的配置。不过这个需求对私有项目而言，没什么意义。<br/></li></ol><p>工作中我先后使用了几种方式，主要使用的就两种： </p><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>为每个环境分别写一个配置文件，到相应的环境里，将该环境的配置文件软链接到正确的路径。<br/></li><li>使用分布式的配置服务，从远程获取配置。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>前者用起来其实蛮麻烦的，特别是想在本地跑单元测试时，需要替换成单元测试环境的配置文件。所以我又把环境变量给加了进来，检测到指定的环境变量，就加载单元测试的配置。而其他几个需求也能勉强实现，不过并不优雅。</p><p>后者不能直接使用 Python 代码，网络不好时需要降级成使用本地缓存，获取配置服务器的地址需要配置，配置服务器自己也需要配置，而且配置服务器还可能挂掉（知乎内网遇到过全部五台配置服务器都挂掉的情况），所以我用得比较少。 其实仔细想想就能发现，「使用 Python 代码」也就意味着是 Python 源文件，「有通用的配置项」用 Python 实现就是继承，似乎没更好的选择了。</p><p>于是定义一个 Config 类，让其他环境的配置都继承这个类： </p><div class=\"highlight\"><pre><code class=\"language-text\"># config/default.pyclass Config(object):\n    DEBUG_MODE = True\n    PORT = 12345\n    COOKIE_SECRET = &#39;default&#39;\n    REDIS_CONFIG = {&#39;host&#39;: &#39;localhost&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 0}    # ...\n# config/development.pyfrom .default import Configclass DevelopmentConfig(Config):\n    COOKIE_SECRET = &#39;dev&#39;\n# config/unit_testing.pyfrom .default import Configclass UnitTestingConfig(Config):\n    REDIS_CONFIG = {&#39;host&#39;: &#39;localhost&#39;, &#39;port&#39;: 6379, &#39;db&#39;: 1}\n# config/production.pyfrom .default import Configclass ProductionConfig(Config):\n    COOKIE_SECRET = &#39;...&#39;\n    REDIS_CONFIG = {&#39;unix_socket_path&#39;: &#39;/tmp/redis.sock&#39;}</code></pre></div><p>为了让每种环境都只有一个配置生效，还需要加一个策略： </p><div class=\"highlight\"><pre><code class=\"language-text\"># config/__init__.pyimport loggingimport os\n\n\nenv = os.getenv(&#39;ENV&#39;)  # 可以改成其他名字，自己进行设置try:    if env == &#39;PRODUCTION&#39;:        from .production import ProductionConfig as CONFIG\n            logging.info(&#39;Production config loaded.&#39;)    elif env == &#39;TESTING&#39;:        from .testing import TestingConfig as CONFIG\n            logging.info(&#39;Testing config loaded.&#39;)    elif env == &#39;UNIT_TESTING&#39;:        from .unit_testing import UnitTestingConfig as CONFIG\n            logging.info(&#39;Unit testing config loaded.&#39;)    else:  # 默认使用本地开发环境的配置，省去设置环境变量的环节\n        from .development import DevelopmentConfig as CONFIG\n            logging.info(&#39;Development config loaded.&#39;)except ImportError:\n    logging.warning(&#39;Loading config for %s environment failed, use default config instead.&#39;, env or &#39;unspecified&#39;)    from .default import Config as CONFIG</code></pre></div><p>这样只需要在跑应用前，设置不同的环境变量即可。如果是用 Supervisor 维护进程的话，加上一行environment = ENV=&#34;PRODUCTION&#34;配置即可。 当然还可以加其他的规则，例如没环境变量时，再检查机器名等。 现在前两个需求都解决了，再来看分模块的功能。</p><p>这个需求正好对应 Python 的 package，于是把每个配置文件改成一个 package 即可。接着是如何同时满足第二和第三个需求。</p><p>举例来说，有这样的配置： </p><div class=\"highlight\"><pre><code class=\"language-text\"># config/default.pyclass Config(object):\n    ROOT_PATH = &#39;/&#39;\n    LOGIN_PATH = ROOT_PATH + &#39;login&#39;\n    SCHEME = &#39;http&#39;\n    DOMAIN = &#39;localhost&#39;\n    ROOT_URL = &#39;%s://%s%s&#39; % (SCHEME, DOMAIN, ROOT_PATH)\n# config/production.pyfrom .default import Configclass ProductionConfig(Config):\n    ROOT_PATH = &#39;/blog/&#39;\n    LOGIN_PATH = ROOT_PATH + &#39;login&#39;\n    DOMAIN = &#39;www.keakon.net&#39;\n    ROOT_URL = &#39;%s://%s%s&#39; % (Config.SCHEME, DOMAIN, ROOT_PATH)</code></pre></div><p>其中，LOGIN_PATH 和 LOGIN_URL 的设置逻辑其实是一样的，但值却不同，在 ProductionConfig 中重新赋值一次有点不太优雅。</p><p>于是把这些设置提取出来，在基本设置初始化以后，再进行设置： </p><div class=\"highlight\"><pre><code class=\"language-text\">class _AfterMeta(type):\n    def __init__(cls, name, bases, dct):\n        super(_AfterMeta, cls).__init__(name, bases, dct)\n        cls._after()class Config(object):\n    __metaclass__ = _AfterMeta\n\n    ROOT_PATH = &#39;/&#39;\n    SCHEME = &#39;http&#39;\n    DOMAIN = &#39;localhost&#39;    @classmethod\n    def _after(cls):\n        cls.LOGIN_PATH = cls.ROOT_PATH + &#39;login&#39;\n        cls.ROOT_URL = &#39;%s://%s%s&#39; % (cls.SCHEME, cls.DOMAIN, cls.ROOT_PATH)\n# config/production.pyfrom .default import Configclass ProductionConfig(Config):\n    ROOT_PATH = &#39;/blog/&#39;\n    DOMAIN = &#39;www.keakon.net&#39;</code></pre></div><p>所有有依赖的设置项，都在 _after 方法里赋值即可。 不过这样可能导致静态检查和代码提示出问题，而且使得所有子类都重新定义这些属性，即便没有修改父类的属性，或是覆盖掉手动设置的值。所以可以再修改一下： </p><div class=\"highlight\"><pre><code class=\"language-text\">class _AfterMeta(type):\n    def __init__(cls, name, bases, dct):\n        super(_AfterMeta, cls).__init__(name, bases, dct)\n        cls._after(dct)class Config(object):\n    __metaclass__ = _AfterMeta\n\n    ROOT_PATH = &#39;/&#39;\n    LOGIN_PATH = ROOT_PATH + &#39;login&#39;\n    SCHEME = &#39;http&#39;\n    DOMAIN = &#39;localhost&#39;\n    ROOT_URL = &#39;%s://%s%s&#39; % (SCHEME, DOMAIN, ROOT_PATH)    @classmethod\n    def _after(cls, own_attrs):\n        if &#39;LOGIN_PATH&#39; not in own_attrs and &#39;ROOT_PATH&#39; in own_attrs:\n            cls.LOGIN_PATH = cls.ROOT_PATH + &#39;login&#39;\n        if &#39;ROOT_URL&#39; not in own_attrs and (&#39;SCHEME&#39; in own_attrs or &#39;DOMAIN&#39; in own_attrs or &#39;ROOT_PATH&#39; in own_attrs):\n            cls.ROOT_URL = &#39;%s://%s%s&#39; % (cls.SCHEME, cls.DOMAIN, cls.ROOT_PATH)</code></pre></div><p>虽然问题是解决了，不过代码量似乎大了点，写起来很麻烦。只是似乎也没有更好解决办法，所幸这类配置并不多，所以重写一次倒也无妨。 最后只剩下分离公开和私有配置这个需求了。</p><p>既然要有私有配置，很容易想到的就是把私有配置放在另一个仓库里，再 link 到配置文件夹即可： </p><div class=\"highlight\"><pre><code class=\"language-text\">.\n└── config\n    ├── __init__.py\n    ├── default.py\n    ├── development.py -&gt; private/development.py\n    ├── development_sample.py\n    ├── private (cloned from another private repository)\n    │   ├── development.py\n    │   └── production.py\n    ├── production.py -&gt; private/production.py\n    └── production_sample.py</code></pre></div><p>为了避免文件被提交到公共仓库，私有的配置文件可以加到 .gitignore 里。 顺带一提，我的博客数据全存放在 Redis 中，备份时只要备份 rdb 文件即可。不过用另一台服务器来备份显得太奢侈了，所以我在服务器上装了个 Dropbox，然后把 Dropbox 文件夹里的数据文件夹 link 到博客的数据文件夹里，即： </p><div class=\"highlight\"><pre><code class=\"language-text\">doodle\n└── data\n    └── redis -&gt; ~/Dropbox/doodle/redis</code></pre></div><p>这样一旦文件有改动，Dropbox 就会自动进行备份，而且保留了所有的历史版本，简直完美。</p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }, 
                {
                    "tag": "Python教程", 
                    "tagLink": "https://api.zhihu.com/topics/20027689"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28277040", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 1, 
            "title": "Python实战mongodb第4篇: Pymongo复杂查询", 
            "content": "<p>Pymongo复杂查询</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d77a7f0feaeaec049561b309367c6c35_b.png\" data-rawwidth=\"806\" data-rawheight=\"706\" class=\"origin_image zh-lightbox-thumb\" width=\"806\" data-original=\"https://pic2.zhimg.com/v2-d77a7f0feaeaec049561b309367c6c35_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;806&#39; height=&#39;706&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"806\" data-rawheight=\"706\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"806\" data-original=\"https://pic2.zhimg.com/v2-d77a7f0feaeaec049561b309367c6c35_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d77a7f0feaeaec049561b309367c6c35_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-1e190b633441632eabb99792ac84809c_b.png\" data-rawwidth=\"806\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb\" width=\"806\" data-original=\"https://pic1.zhimg.com/v2-1e190b633441632eabb99792ac84809c_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;806&#39; height=&#39;383&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"806\" data-rawheight=\"383\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"806\" data-original=\"https://pic1.zhimg.com/v2-1e190b633441632eabb99792ac84809c_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-1e190b633441632eabb99792ac84809c_b.png\"/></figure><p>好了, 经此4篇, 你应该会使用pymongo了. 有啥问题请给我发邮件, 一起完善这个系列教程. </p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "<p>云师兄 你写一个可以copy的，带点解释的呗，谢谢</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28276886", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 1, 
            "title": "Python实战mongodb第3篇: Pymongo的分页查询", 
            "content": "<h2>Pymongo的分页查询</h2><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-223ad5197138c2fba8dab5642aecbe11_b.png\" data-rawwidth=\"719\" data-rawheight=\"702\" class=\"origin_image zh-lightbox-thumb\" width=\"719\" data-original=\"https://pic2.zhimg.com/v2-223ad5197138c2fba8dab5642aecbe11_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;719&#39; height=&#39;702&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"719\" data-rawheight=\"702\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"719\" data-original=\"https://pic2.zhimg.com/v2-223ad5197138c2fba8dab5642aecbe11_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-223ad5197138c2fba8dab5642aecbe11_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic3.zhimg.com/v2-3541d2fba3942f8f6f7e3d62be04039a_b.png\" data-rawwidth=\"772\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb\" width=\"772\" data-original=\"https://pic3.zhimg.com/v2-3541d2fba3942f8f6f7e3d62be04039a_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;772&#39; height=&#39;336&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"772\" data-rawheight=\"336\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"772\" data-original=\"https://pic3.zhimg.com/v2-3541d2fba3942f8f6f7e3d62be04039a_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3541d2fba3942f8f6f7e3d62be04039a_b.png\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28062881", 
            "userName": "风太极", 
            "userLink": "https://www.zhihu.com/people/356411c1d6aa0d520840e89a983d403d", 
            "upvote": 3, 
            "title": "Python基础——类和实例", 
            "content": "<p>面向对象最重要的概念就是类（Class）和实例（Instance），必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p><p>以Dog类为例，在Python中，定义类是通过class关键字：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-2a6eb98a04961b74c92bd2e17f6a80c0_b.jpg\" data-rawwidth=\"472\" data-rawheight=\"568\" class=\"origin_image zh-lightbox-thumb\" width=\"472\" data-original=\"https://pic1.zhimg.com/v2-2a6eb98a04961b74c92bd2e17f6a80c0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;472&#39; height=&#39;568&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"472\" data-rawheight=\"568\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"472\" data-original=\"https://pic1.zhimg.com/v2-2a6eb98a04961b74c92bd2e17f6a80c0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-2a6eb98a04961b74c92bd2e17f6a80c0_b.jpg\"/></figure></p><p><strong>面对对象编程的三个基本特征</strong><br/></p><p>（一）封装性（二）继承性（三）多态性</p><p><strong>封装性</strong></p><p>封装”就是将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体（即类）；封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，特定的访问权限来使用类的成员。 <br/>与其他以来语言特性来封装类的编程语言不同的是python通过特定的命名规则来表达对数据和方法的用途。（1）任何以双下划线（__）开头的名字属于私有属性或者方法，只能在该类中被调用，不用在外部调用或者继承。同时这个规则也适用于块的定义和模块中函数的定义。</p><p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-2baf2df63176ad107b1f1c7ee704b7fb_b.jpg\" data-rawwidth=\"473\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb\" width=\"473\" data-original=\"https://pic4.zhimg.com/v2-2baf2df63176ad107b1f1c7ee704b7fb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;473&#39; height=&#39;750&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"473\" data-rawheight=\"750\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"473\" data-original=\"https://pic4.zhimg.com/v2-2baf2df63176ad107b1f1c7ee704b7fb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-2baf2df63176ad107b1f1c7ee704b7fb_b.jpg\"/></figure></p><p>但如果一定要访问私有属性也是可以的。使用: 实例名._类名私有属性名（例如： a._A__private ）就可以访问。</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-79660f1e0fc06ce9da23f444eaba12d4_b.jpg\" data-rawwidth=\"479\" data-rawheight=\"703\" class=\"origin_image zh-lightbox-thumb\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-79660f1e0fc06ce9da23f444eaba12d4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;479&#39; height=&#39;703&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"479\" data-rawheight=\"703\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"479\" data-original=\"https://pic1.zhimg.com/v2-79660f1e0fc06ce9da23f444eaba12d4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-79660f1e0fc06ce9da23f444eaba12d4_b.jpg\"/></figure></p><p>同样，私有属性和方法不能被子类继承，也不会被子类覆盖。<br/></p><p><strong>继承性</strong></p><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。比如，我们已经编写了一个名为Animal的class，有一个run()方法可以直接打印：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-4961ce1b7820c986070b7a3d15fc1588_b.png\" data-rawwidth=\"476\" data-rawheight=\"449\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-4961ce1b7820c986070b7a3d15fc1588_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;449&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"476\" data-rawheight=\"449\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-4961ce1b7820c986070b7a3d15fc1588_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-4961ce1b7820c986070b7a3d15fc1588_b.png\"/></figure></p><p>对于Dog来说，Animal就是它的父类，对于Animal来说，Dog就是它的子类。Cat和Dog类似。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于Animial实现了run()方法，因此，Dog和Cat作为它的子类，什么事也没干，就自动拥有了run()方法：</p><p>当然，也可以对子类增加一些方法。</p><p>当子类和父类都存在相同的run()方法时，我们说，子类的run()覆盖了父类的run()，在代码运行的时候，总是会调用子类的run()。这样，我们就获得了继承的另一个好处：多态。</p><p><strong>多态性</strong></p><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个Animal类型的变量：</p><p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-8a1f6e2358429d4fc1769e926e26aeb4_b.png\" data-rawwidth=\"476\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-8a1f6e2358429d4fc1769e926e26aeb4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;476&#39; height=&#39;487&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"476\" data-rawheight=\"487\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"476\" data-original=\"https://pic1.zhimg.com/v2-8a1f6e2358429d4fc1769e926e26aeb4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-8a1f6e2358429d4fc1769e926e26aeb4_b.png\"/></figure></p><p class=\"ztext-empty-paragraph\"><br/></p><p>类方法中的 self 参数</p>self是类方法的一个位置参数，它就是类的实例对象自己。", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": [
                {
                    "userName": "曰归", 
                    "userLink": "https://www.zhihu.com/people/cc98ee145487b3f652f1b87f034191f1", 
                    "content": "往后学越来越难懂了~  文科生不容易- -!", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Danieling", 
                    "userLink": "https://www.zhihu.com/people/79deb62d55862a9812fece2120a79204", 
                    "content": "<p>抄袭廖雪峰python教程，应当标明出处！</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28206792", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 2, 
            "title": "Python实战mongodb第1篇: Python和Mongodb", 
            "content": "<h2>Mongodb 介绍</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>Mongodb是为互联网应用而生的数据库. 什么意思呢? 如果你的项目读的次数远大于写, 那么就适合用mongodb. 例如前台资讯型网站. 大家基本上都是浏览文章, 很少发贴. 这时候就很适合用mongodb. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>以mongodb为代表的nosql数据库, 以牺牲数据库事务性为代价, 提高访问速度. <b>它并不适合订单类应用</b>.  我们以电商项目为例子. 电商项目的主要业务在于展示商品, 用户可以下订单. 对于数据的展示, 可以把商品数据存到mongodb里. 对于用户下单业务, 还是用mysql/oracle处理比较合适. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>那么系统同时存在两个数据库, 是不是就更复杂了呢? 不是. mongodb是schema-free的数据库. <br/>意思就是你完全可以不考虑表结构, 随便写你的业务. 对于开发业务系统而言, 可以做到快速适应需求, 快速上线, 随便折腾. <br/>当然代价就是系统的冗余代码可能增多, 整体风格混乱. 这也没办法, 请找一个强力的架构师来控制好吧. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>因为这篇是入门介绍帖子, 所以不详细介绍在生产环境怎么装. 我的目的只是让你安装, 跑起来, 能够跑我的python代码就行了.  程序的下载路径在这里(记得选3.4版本): <a href=\"https://link.zhihu.com/?target=https%3A//www.mongodb.com/download-center%23community\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">mongodb安装包下载地址</a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下载之后就是一路next, 没什么好说的. 之前说过用mongdb很自由. 装完之后, 并不需要像oracle/mysql 那样做一堆事情. 你直接就可以干活. </p><p class=\"ztext-empty-paragraph\"><br/></p><h2>Pymongo / ming</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>Python访问mongodb的最好第三方包是pymongo. 用pymongo本身已经很简单了. <br/>但你知道python总有更简单的东西.... ming就是这么一个封装了pymongo的orm框架, 它让你能用面向对象的思维来存储数据. <br/>如果你很熟悉java的hibernate, 那么你可以把它理解成hibernate. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>安装ming很简单, 用pip就行了: </p><div class=\"highlight\"><pre><code class=\"language-text\">pip install ming</code></pre></div><p>如果你注意看控制台, 你会看到它自动把pymongo装上了. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>来段程序吧, 说了这么多话, 我写程序的心已经饥渴难耐了: </p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-5aefed8ac06b026ea0ddf0334ce250b0_b.png\" data-rawwidth=\"813\" data-rawheight=\"875\" class=\"origin_image zh-lightbox-thumb\" width=\"813\" data-original=\"https://pic1.zhimg.com/v2-5aefed8ac06b026ea0ddf0334ce250b0_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;813&#39; height=&#39;875&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"813\" data-rawheight=\"875\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"813\" data-original=\"https://pic1.zhimg.com/v2-5aefed8ac06b026ea0ddf0334ce250b0_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-5aefed8ac06b026ea0ddf0334ce250b0_b.png\"/></figure><p>14-15行 引入了一堆mongodb的类库</p><p>18-19行 是创建数据连接的写法, 最终目的是得到一个session类. (g_ 为前缀是我的习惯, 以这样的开头来命名全局变量) </p><p>23-31行 是定义表的开始. 需要继承Document 这个类. class 这段基本照抄, 注意修改name为真正的表名即可. 另外注意28行, 以_id的方式定义了主键id. 29-31定义其他的字段. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>34-40行 演示如何增加数据. 增加数据仿佛新建一个对象那么自然, 只要在最后调用实例.m.<b>save</b>() 这个方法就行了. (第40)行. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>43-46 展示了如何查找数据. 表明.m.<b>find</b>() 表示得到这个表的所有数据. <br/>它会返回一个iterable 对象, 你可以用for来遍历它, 从而访问每一条数据.  值得注意的是46行. 如果要访问数据的主键, <br/>通常用str(对象._id) 来得到(注意id前的_). 为什么不用id而用_id呢? 因为在python里id这个名字实在太危险了, <br/>很多框架都用id. 所以ming为了避免这个潜在的危险, 用_id了.  </p><p class=\"ztext-empty-paragraph\"><br/></p><p>_id是一个ObjectId 对象(见28行), 所以你要用str进行转型, 才会输出字符串. </p><p class=\"ztext-empty-paragraph\"><br/></p><h2>mongodb 客户端</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>好了, 用程序你已经知道, 一个用户数据已经插到数据库了. 如果想用工具访问怎么办? mongodb支持命令行访问, 当然更方便的是用gui工具. 最好用的是robomongo这个客户端, 下载地址在这里:  <a href=\"https://link.zhihu.com/?target=https%3A//robomongo.org/download\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">客户端工具robomongo下载地址</a></p><p class=\"ztext-empty-paragraph\"><br/></p><p>安装连接都很简单, 不再多说. 打开之后是这样: </p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-b10685498ab4473fd255cc57adae42b4_b.png\" data-rawwidth=\"1110\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb\" width=\"1110\" data-original=\"https://pic1.zhimg.com/v2-b10685498ab4473fd255cc57adae42b4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1110&#39; height=&#39;557&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"1110\" data-rawheight=\"557\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1110\" data-original=\"https://pic1.zhimg.com/v2-b10685498ab4473fd255cc57adae42b4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-b10685498ab4473fd255cc57adae42b4_b.png\"/></figure><p>你也许开始懵了. 如果要查找数据, 用什么语言呢? sql数据库用sql, mongodb 用什么? 答案是用key-value 进行查找, <br/>非常像js语法.  再看看下面这个需求: 找出name是test的数据, 那么查询条件是这样: <br/>db.getCollection(&#39;user&#39;).find({&#39;name&#39;:&#39;test&#39;})  , 如下图: </p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-5ed67abdf3ed2457822e9712f3950011_b.png\" data-rawwidth=\"840\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb\" width=\"840\" data-original=\"https://pic2.zhimg.com/v2-5ed67abdf3ed2457822e9712f3950011_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;840&#39; height=&#39;266&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"840\" data-rawheight=\"266\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"840\" data-original=\"https://pic2.zhimg.com/v2-5ed67abdf3ed2457822e9712f3950011_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-5ed67abdf3ed2457822e9712f3950011_b.png\"/></figure><p>是不是很有趣? 哈哈. </p>", 
            "topic": [
                {
                    "tag": "Python 框架", 
                    "tagLink": "https://api.zhihu.com/topics/19606083"
                }, 
                {
                    "tag": "Python教程", 
                    "tagLink": "https://api.zhihu.com/topics/20027689"
                }, 
                {
                    "tag": "Python 库", 
                    "tagLink": "https://api.zhihu.com/topics/19644560"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/28207089", 
            "userName": "会飞的渔", 
            "userLink": "https://www.zhihu.com/people/6c062229a13559757facdc508e6a61ac", 
            "upvote": 2, 
            "title": "Python实战mongodb第2篇: ming的普通查询", 
            "content": "<h2>分拆代码</h2><p class=\"ztext-empty-paragraph\"><br/></p><p>我们会反复使用数据库, 为了方便, 先将数据库的表放到一个独立的模块, 而操作代码放到其他模块. 这样显得逻辑结构清晰. </p><p class=\"ztext-empty-paragraph\"><br/></p><p>先看db_1.py 类</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-34f0b11fb86741f4f45cec68b1a822b1_b.png\" data-rawwidth=\"787\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb\" width=\"787\" data-original=\"https://pic2.zhimg.com/v2-34f0b11fb86741f4f45cec68b1a822b1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;787&#39; height=&#39;525&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"787\" data-rawheight=\"525\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"787\" data-original=\"https://pic2.zhimg.com/v2-34f0b11fb86741f4f45cec68b1a822b1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-34f0b11fb86741f4f45cec68b1a822b1_b.png\"/></figure><p>再独立一个模块 ming_2_1.py 用于创建测试数据. 如下:</p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic4.zhimg.com/v2-927ce88042f5f406d82acb11649c5beb_b.png\" data-rawwidth=\"878\" data-rawheight=\"585\" class=\"origin_image zh-lightbox-thumb\" width=\"878\" data-original=\"https://pic4.zhimg.com/v2-927ce88042f5f406d82acb11649c5beb_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;878&#39; height=&#39;585&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"878\" data-rawheight=\"585\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"878\" data-original=\"https://pic4.zhimg.com/v2-927ce88042f5f406d82acb11649c5beb_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-927ce88042f5f406d82acb11649c5beb_b.png\"/></figure><p>然后再独立一个ming_2_2.py 来进行各种查询. 用法写在注释, 不废话了. </p><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic1.zhimg.com/v2-663566863dba34be7cfeda5a996dd844_b.png\" data-rawwidth=\"652\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-663566863dba34be7cfeda5a996dd844_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;652&#39; height=&#39;587&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"652\" data-rawheight=\"587\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"652\" data-original=\"https://pic1.zhimg.com/v2-663566863dba34be7cfeda5a996dd844_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-663566863dba34be7cfeda5a996dd844_b.png\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><figure><noscript><img src=\"https://pic2.zhimg.com/v2-d78b3c0c5de3c28d4d3f5ccdeada1f51_b.png\" data-rawwidth=\"833\" data-rawheight=\"760\" class=\"origin_image zh-lightbox-thumb\" width=\"833\" data-original=\"https://pic2.zhimg.com/v2-d78b3c0c5de3c28d4d3f5ccdeada1f51_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;833&#39; height=&#39;760&#39;&gt;&lt;/svg&gt;\" data-rawwidth=\"833\" data-rawheight=\"760\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"833\" data-original=\"https://pic2.zhimg.com/v2-d78b3c0c5de3c28d4d3f5ccdeada1f51_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-d78b3c0c5de3c28d4d3f5ccdeada1f51_b.png\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "Python", 
                    "tagLink": "https://api.zhihu.com/topics/19552832"
                }, 
                {
                    "tag": "Python 入门", 
                    "tagLink": "https://api.zhihu.com/topics/19661050"
                }
            ], 
            "comments": []
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/python1"
}
