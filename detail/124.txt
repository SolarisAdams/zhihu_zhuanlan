{
    "title": "Java后端火箭班", 
    "description": "通过深入的实用性知识和由浅入深的案例帮助Java后端开发者轻松闯过从学过到会写、从初级到资深这两道难关，以浅显易懂的方式传播实用性的进阶技术。", 
    "followers": [
        "https://www.zhihu.com/people/shaoweiqu", 
        "https://www.zhihu.com/people/wei-xiao-wei-95-70", 
        "https://www.zhihu.com/people/cao-kong-65", 
        "https://www.zhihu.com/people/nick-wang-95", 
        "https://www.zhihu.com/people/mkek", 
        "https://www.zhihu.com/people/yuan-er-12-77-18", 
        "https://www.zhihu.com/people/wang-zhong-jie-10-41", 
        "https://www.zhihu.com/people/qi-yu-98-69", 
        "https://www.zhihu.com/people/sui-bian-ba-55-86-11", 
        "https://www.zhihu.com/people/eic-75", 
        "https://www.zhihu.com/people/free_fish", 
        "https://www.zhihu.com/people/zh0122", 
        "https://www.zhihu.com/people/yang-tao-46-82", 
        "https://www.zhihu.com/people/tan-xiao-yang-95", 
        "https://www.zhihu.com/people/zhong-da-wang", 
        "https://www.zhihu.com/people/xiao-mei-mao-42", 
        "https://www.zhihu.com/people/zenvo-11-24", 
        "https://www.zhihu.com/people/a-bai-25-32-26", 
        "https://www.zhihu.com/people/tan-xiao-xian-92", 
        "https://www.zhihu.com/people/wo-mei-26", 
        "https://www.zhihu.com/people/fen-nu-de-qing-wa-84", 
        "https://www.zhihu.com/people/caichangyong", 
        "https://www.zhihu.com/people/zlm-71", 
        "https://www.zhihu.com/people/wen-qiang-61-73", 
        "https://www.zhihu.com/people/gemini-5", 
        "https://www.zhihu.com/people/a-lin-41-79", 
        "https://www.zhihu.com/people/ping-guo-de-meng-xiang-36", 
        "https://www.zhihu.com/people/nei-la-zu-rui", 
        "https://www.zhihu.com/people/xia-feng-70-38", 
        "https://www.zhihu.com/people/meng-fan-gang-92", 
        "https://www.zhihu.com/people/hnb-33-56", 
        "https://www.zhihu.com/people/deng-peng-20-59", 
        "https://www.zhihu.com/people/sonysuo", 
        "https://www.zhihu.com/people/life-81-6", 
        "https://www.zhihu.com/people/dan-xing-pang-pang-24", 
        "https://www.zhihu.com/people/lu-ping-65-16", 
        "https://www.zhihu.com/people/ge-yi-hui-77", 
        "https://www.zhihu.com/people/hua-zi-37-92-44", 
        "https://www.zhihu.com/people/cao-jing-17-96", 
        "https://www.zhihu.com/people/can-ci-pin-47", 
        "https://www.zhihu.com/people/lin-shu-34-4-17", 
        "https://www.zhihu.com/people/tie-dao-zhuan-jia-zhang-shi-mai", 
        "https://www.zhihu.com/people/fu1996412", 
        "https://www.zhihu.com/people/wang-yi-cheng-27", 
        "https://www.zhihu.com/people/li-li-34-84-59", 
        "https://www.zhihu.com/people/super-liu-33", 
        "https://www.zhihu.com/people/xiao-meng-a-xin", 
        "https://www.zhihu.com/people/onecopper", 
        "https://www.zhihu.com/people/zhao-jie-92", 
        "https://www.zhihu.com/people/wu-jian-72-15-78", 
        "https://www.zhihu.com/people/chen-lin-87-64-81", 
        "https://www.zhihu.com/people/antred", 
        "https://www.zhihu.com/people/xiao-cai-30-29-11", 
        "https://www.zhihu.com/people/ye-xiao-1-61", 
        "https://www.zhihu.com/people/li-lin-30-36", 
        "https://www.zhihu.com/people/xiao-ren-89-74", 
        "https://www.zhihu.com/people/zhao-xin-tao", 
        "https://www.zhihu.com/people/li-hong-bo-89-40", 
        "https://www.zhihu.com/people/yan-feng-28", 
        "https://www.zhihu.com/people/yao-jie-85", 
        "https://www.zhihu.com/people/zhao-qi-13-21", 
        "https://www.zhihu.com/people/eric-6-75-8", 
        "https://www.zhihu.com/people/er-gou-90-40-63", 
        "https://www.zhihu.com/people/zhou-wen-hui-36", 
        "https://www.zhihu.com/people/galahad-33", 
        "https://www.zhihu.com/people/sheng-dan-jing-mo-chou-53", 
        "https://www.zhihu.com/people/zhou-shuai-chao", 
        "https://www.zhihu.com/people/csp1223", 
        "https://www.zhihu.com/people/start-58-45", 
        "https://www.zhihu.com/people/walter-32", 
        "https://www.zhihu.com/people/rajoy", 
        "https://www.zhihu.com/people/faker-33-8", 
        "https://www.zhihu.com/people/bjmywjt", 
        "https://www.zhihu.com/people/yan-luo-liang-han", 
        "https://www.zhihu.com/people/knmpa-sdfa", 
        "https://www.zhihu.com/people/li-zheng-dao-68", 
        "https://www.zhihu.com/people/liuyanjunbj", 
        "https://www.zhihu.com/people/biao-biao-ni-hen-shuai", 
        "https://www.zhihu.com/people/germin", 
        "https://www.zhihu.com/people/pei-yu-chao", 
        "https://www.zhihu.com/people/meng-tun-49", 
        "https://www.zhihu.com/people/xue-hua-piao-piao-98-84", 
        "https://www.zhihu.com/people/hcsang-67", 
        "https://www.zhihu.com/people/xia-xiao-yu-92-40", 
        "https://www.zhihu.com/people/xie-heng-60", 
        "https://www.zhihu.com/people/du-ke-feng-jia-da-kong", 
        "https://www.zhihu.com/people/yang-run-jia-38", 
        "https://www.zhihu.com/people/tu-zhong-qiu-87", 
        "https://www.zhihu.com/people/qiu-wen-hao-43", 
        "https://www.zhihu.com/people/han-hong-yuan-72", 
        "https://www.zhihu.com/people/di-diao-34-19", 
        "https://www.zhihu.com/people/vi-jolie", 
        "https://www.zhihu.com/people/yi-ji-si-fang", 
        "https://www.zhihu.com/people/relay-20", 
        "https://www.zhihu.com/people/xukaisheng", 
        "https://www.zhihu.com/people/qiao-hai-jun", 
        "https://www.zhihu.com/people/shu-yu-mu-ge", 
        "https://www.zhihu.com/people/ffddddddccccdd", 
        "https://www.zhihu.com/people/wo-men-de-sheng-huo-63-69", 
        "https://www.zhihu.com/people/qian-qian-35-71", 
        "https://www.zhihu.com/people/viggoxia", 
        "https://www.zhihu.com/people/mello-55", 
        "https://www.zhihu.com/people/lan-hun-you-long-11", 
        "https://www.zhihu.com/people/jian-dao-shou-a-ming", 
        "https://www.zhihu.com/people/guan-gai-man-jing-hua-53", 
        "https://www.zhihu.com/people/aidchou", 
        "https://www.zhihu.com/people/xue-jia-wei-49", 
        "https://www.zhihu.com/people/mr-lin-82-68", 
        "https://www.zhihu.com/people/hu-ting", 
        "https://www.zhihu.com/people/shituanjie", 
        "https://www.zhihu.com/people/hua-chuan-90-73", 
        "https://www.zhihu.com/people/zhou-peng-50", 
        "https://www.zhihu.com/people/wei-sheng-zhi-sen", 
        "https://www.zhihu.com/people/jia-bei-92-82", 
        "https://www.zhihu.com/people/yunxi36", 
        "https://www.zhihu.com/people/han-han-han-71", 
        "https://www.zhihu.com/people/zhang-yun-xiao-95", 
        "https://www.zhihu.com/people/alexzhanghc", 
        "https://www.zhihu.com/people/wang-tong-hui", 
        "https://www.zhihu.com/people/xie-yi-jun-86", 
        "https://www.zhihu.com/people/ming-yu-69-3", 
        "https://www.zhihu.com/people/wu-zhi-de-ren-lei-25-71", 
        "https://www.zhihu.com/people/jin-kun-tao", 
        "https://www.zhihu.com/people/dkl187788", 
        "https://www.zhihu.com/people/mo-ban-che-47-70", 
        "https://www.zhihu.com/people/zhui-ming", 
        "https://www.zhihu.com/people/rao-xin-35", 
        "https://www.zhihu.com/people/liang-tian-69", 
        "https://www.zhihu.com/people/luan-xue-dong", 
        "https://www.zhihu.com/people/colorfulzebra", 
        "https://www.zhihu.com/people/jason-chen-94-72", 
        "https://www.zhihu.com/people/zhi-shi-xi-shou", 
        "https://www.zhihu.com/people/bskl-ben-45", 
        "https://www.zhihu.com/people/linary", 
        "https://www.zhihu.com/people/wei-yang-shi", 
        "https://www.zhihu.com/people/zi-you-zi-zai-99-22", 
        "https://www.zhihu.com/people/hao-hao-de-21-19", 
        "https://www.zhihu.com/people/h-liam", 
        "https://www.zhihu.com/people/feng-jia-xing-47-52", 
        "https://www.zhihu.com/people/tian-kai-96", 
        "https://www.zhihu.com/people/shallow-75-50", 
        "https://www.zhihu.com/people/cao-qian-50-81", 
        "https://www.zhihu.com/people/chi-jing-53", 
        "https://www.zhihu.com/people/qia-fu-qia-27-11", 
        "https://www.zhihu.com/people/zhangsan-97-39", 
        "https://www.zhihu.com/people/duo-zhu-c", 
        "https://www.zhihu.com/people/tou-wong-64", 
        "https://www.zhihu.com/people/liang-hao-tian-73", 
        "https://www.zhihu.com/people/lu-si-nan-69", 
        "https://www.zhihu.com/people/chen-si-fan-59", 
        "https://www.zhihu.com/people/keport-77", 
        "https://www.zhihu.com/people/qi-feng-96", 
        "https://www.zhihu.com/people/chen-jian-zhou-65", 
        "https://www.zhihu.com/people/gu-xu-37-50", 
        "https://www.zhihu.com/people/fate-03", 
        "https://www.zhihu.com/people/qin-jy-6", 
        "https://www.zhihu.com/people/qi-zhu-qu-kan-hai-31", 
        "https://www.zhihu.com/people/geogre-wu", 
        "https://www.zhihu.com/people/jie-bao-ming", 
        "https://www.zhihu.com/people/yijiabgchunshui.com", 
        "https://www.zhihu.com/people/jie-luo-mi", 
        "https://www.zhihu.com/people/sunboximeng", 
        "https://www.zhihu.com/people/xu-lei-41-26", 
        "https://www.zhihu.com/people/linuxcpp", 
        "https://www.zhihu.com/people/li-hong-wei-1-72-44", 
        "https://www.zhihu.com/people/zheng-chang-jin-70", 
        "https://www.zhihu.com/people/ya-se-xiao-ge-ge", 
        "https://www.zhihu.com/people/yike-liang-xing-xing", 
        "https://www.zhihu.com/people/han-bin", 
        "https://www.zhihu.com/people/zhang-jia-lin-39-86", 
        "https://www.zhihu.com/people/hu-wen-hua-76", 
        "https://www.zhihu.com/people/a-xu-50-22", 
        "https://www.zhihu.com/people/zhangjianxi", 
        "https://www.zhihu.com/people/bei-ke-71", 
        "https://www.zhihu.com/people/cser-62", 
        "https://www.zhihu.com/people/bob-67", 
        "https://www.zhihu.com/people/stephen-34-51", 
        "https://www.zhihu.com/people/josephine-22-53", 
        "https://www.zhihu.com/people/gagadan", 
        "https://www.zhihu.com/people/hu-wen-xuan", 
        "https://www.zhihu.com/people/yang-kun-5-58", 
        "https://www.zhihu.com/people/liu-jun-yang-90", 
        "https://www.zhihu.com/people/king-80-93", 
        "https://www.zhihu.com/people/ai-jing-de-feng-58", 
        "https://www.zhihu.com/people/ge-dao-12", 
        "https://www.zhihu.com/people/yang-10-80", 
        "https://www.zhihu.com/people/wang-ming-87-50", 
        "https://www.zhihu.com/people/ni-chen-xing-13", 
        "https://www.zhihu.com/people/temptation-57", 
        "https://www.zhihu.com/people/fish-yuls", 
        "https://www.zhihu.com/people/amazing_cat", 
        "https://www.zhihu.com/people/kba977", 
        "https://www.zhihu.com/people/yi-zhi-a-mu-mu-16", 
        "https://www.zhihu.com/people/Ponder", 
        "https://www.zhihu.com/people/raxyao", 
        "https://www.zhihu.com/people/chen-yuan-hui-32-37", 
        "https://www.zhihu.com/people/SummerRCX", 
        "https://www.zhihu.com/people/yan-song-75-55", 
        "https://www.zhihu.com/people/xiang-xian-shi-tuo-xie", 
        "https://www.zhihu.com/people/zou-zhi-hao-38", 
        "https://www.zhihu.com/people/haoyh", 
        "https://www.zhihu.com/people/mrsimple", 
        "https://www.zhihu.com/people/leycau17", 
        "https://www.zhihu.com/people/javaite", 
        "https://www.zhihu.com/people/xu-bo-11-5", 
        "https://www.zhihu.com/people/ray-john", 
        "https://www.zhihu.com/people/allen-gan", 
        "https://www.zhihu.com/people/li-shi-qian-92", 
        "https://www.zhihu.com/people/rain-zhang-65", 
        "https://www.zhihu.com/people/prayinc", 
        "https://www.zhihu.com/people/molisiye", 
        "https://www.zhihu.com/people/edgefree", 
        "https://www.zhihu.com/people/kalman-47-29", 
        "https://www.zhihu.com/people/tuan-chang-ak47", 
        "https://www.zhihu.com/people/wang-xi-wen-51", 
        "https://www.zhihu.com/people/diu-le-jie-cao-de-gen-hao-si", 
        "https://www.zhihu.com/people/qiu-li-bo-90", 
        "https://www.zhihu.com/people/nan-gong-du-ming", 
        "https://www.zhihu.com/people/wo-shi-da-da-lian-mao-83", 
        "https://www.zhihu.com/people/will-chance-62", 
        "https://www.zhihu.com/people/ran-zhao-de-ban-zhi-yan", 
        "https://www.zhihu.com/people/adolphor", 
        "https://www.zhihu.com/people/wang-neng-78-54", 
        "https://www.zhihu.com/people/yang-chang-sheng", 
        "https://www.zhihu.com/people/ykgarfield", 
        "https://www.zhihu.com/people/lang-shaw", 
        "https://www.zhihu.com/people/crazy_shark", 
        "https://www.zhihu.com/people/wang-tian-ma-que", 
        "https://www.zhihu.com/people/wang-qiang-42-71", 
        "https://www.zhihu.com/people/quan-zhi-dao-25", 
        "https://www.zhihu.com/people/zhxh007", 
        "https://www.zhihu.com/people/guzhoutingyue", 
        "https://www.zhihu.com/people/roobin.lij", 
        "https://www.zhihu.com/people/xi-gua-16-77-2", 
        "https://www.zhihu.com/people/nao-nao-bu-yao-nao-87", 
        "https://www.zhihu.com/people/liu-yu-hang-59", 
        "https://www.zhihu.com/people/skyczhao", 
        "https://www.zhihu.com/people/xu-xiao-zhe-44", 
        "https://www.zhihu.com/people/ai-zi-60-70", 
        "https://www.zhihu.com/people/zhou-hang-56", 
        "https://www.zhihu.com/people/who-60-29", 
        "https://www.zhihu.com/people/ai-ke-78", 
        "https://www.zhihu.com/people/shafan-tuan", 
        "https://www.zhihu.com/people/dong-yan-ming-25", 
        "https://www.zhihu.com/people/qing-ye-zui-qing-feng", 
        "https://www.zhihu.com/people/tan-ji-peng", 
        "https://www.zhihu.com/people/wang-jianrong-80-12", 
        "https://www.zhihu.com/people/virgo-25-41", 
        "https://www.zhihu.com/people/da-wei-david", 
        "https://www.zhihu.com/people/wangjinhao1994", 
        "https://www.zhihu.com/people/jack-li-18", 
        "https://www.zhihu.com/people/huang-guo-hang-75", 
        "https://www.zhihu.com/people/tang-ting-22-67", 
        "https://www.zhihu.com/people/da-shen-38-63", 
        "https://www.zhihu.com/people/dong-feng-zao-ji", 
        "https://www.zhihu.com/people/rioer-66", 
        "https://www.zhihu.com/people/hijackjave", 
        "https://www.zhihu.com/people/fei-mao-te-gong-dui", 
        "https://www.zhihu.com/people/game90", 
        "https://www.zhihu.com/people/guo-xin-qi-90", 
        "https://www.zhihu.com/people/xer97", 
        "https://www.zhihu.com/people/lei-jing-77", 
        "https://www.zhihu.com/people/lin-xin-hui-81", 
        "https://www.zhihu.com/people/huang-yu-heng", 
        "https://www.zhihu.com/people/ju-xing-zhu-tou", 
        "https://www.zhihu.com/people/77saaaa", 
        "https://www.zhihu.com/people/liguochun", 
        "https://www.zhihu.com/people/wang-sheng-wei-10", 
        "https://www.zhihu.com/people/kaoshanji", 
        "https://www.zhihu.com/people/neusoft-UASD", 
        "https://www.zhihu.com/people/ning-rain", 
        "https://www.zhihu.com/people/bwhite", 
        "https://www.zhihu.com/people/qqqttt-46", 
        "https://www.zhihu.com/people/mseddl", 
        "https://www.zhihu.com/people/luo-zi-bi", 
        "https://www.zhihu.com/people/Boyan_No1", 
        "https://www.zhihu.com/people/evelymne", 
        "https://www.zhihu.com/people/lao-cheng-35", 
        "https://www.zhihu.com/people/gong-ping-de-shi-jian", 
        "https://www.zhihu.com/people/dl-eric", 
        "https://www.zhihu.com/people/lei-zi-hai", 
        "https://www.zhihu.com/people/roc-xie-gz", 
        "https://www.zhihu.com/people/qi-qian-21-35", 
        "https://www.zhihu.com/people/long-yi-96-21", 
        "https://www.zhihu.com/people/peterchain", 
        "https://www.zhihu.com/people/shi-nian-92-55", 
        "https://www.zhihu.com/people/he-xuesong"
    ], 
    "article": [
        {
            "url": "https://zhuanlan.zhihu.com/p/87804083", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 6, 
            "title": "九个月，我如何转型后端进入支付宝", 
            "content": "<p>我是在2016年6月份从iOS开发转为Java后端开发的，第二年2月份我就开始了我的支付宝面试之路，并且在最后成功入职。在进入支付宝之前，我一直在小公司工作而且只是一个普通三本的毕业生，没有大厂工作经验又没有学历加持的我是如何在短短9个月的时间里成功转型Java后端并进入支付宝的呢？</p><p>前端时间有一个移动端开发同学问了我转型后端的问题，让我萌生了写这篇文章的想法，希望能够帮到不管是想要转型还是直接进入后端开发领域的同学。</p><p>我在成为Java后端开发之前从事了两年的iOS和Mac App开发，虽然已经有了相当程度的开发工作基础，但是前后端的技术栈和思维模式还是有很大的区别的。即使是Android和Java后端同样使用Java语言开发，实质上想要转型也面临一样的困难，反倒是编程语言的差别是最容易解决的。虽然在最后得到了一个让我非常兴奋的结果，但是在我刚刚决定要转后端的时候我甚至连自己能不能在后端开发岗位上站稳脚跟都不知道。在短短9个月的时间里，我至少面临了两次重大的转折。</p><h2>转型Java后端</h2><p>第一次重大转折是我主动从iOS开发转型为了Java后端开发，我当时还没有在工作中真正写过Java后端程序，为了能够有机会转型后端，我差不多提前了1个多月开始学习Java后端常用的SSM框架和MySQL数据库，因为之前还在学校的时候有简单学过一段时间，所以进度会比较快一些。不过这个提前学习也没有起到太多作用，最多也就是达到了常用功能的文档看了一遍、然后自己动手搭了一遍的程度。</p><p>之后我就和当时公司技术部门的领导提了想要转为后端的愿望，小公司在这方面还是比较有优势的，一般只要技术领导同意内部转岗都是比较容易的。不过要让技术领导同意转岗的话其实也并不需要和领导关系搞得特别好，更重要的是让决策人相信自己具备能够胜任或者快速适应新的工作岗位的能力或潜力。</p><p>我认为我当时就得益于自己在平时的开发工作中不会在质量上做出随意的让步，不会因为时间紧、逻辑复杂之类的原因就“节省”代码中的细节优化，并且我在工作中主动将这点表现了出来。当我碰到写出的代码不是特别易读或易可扩展时，会主动找机会和同事分析一下有没有什么办法可以对这部分逻辑进行优化。有时候这些讨论不一定能得到特别好的优化方法，但是讨论的过程本身就表明了我对待工程细节的态度，而且对自己工程能力的提高也会有很大的帮助作用。另一方面我也是基于gitflow形式的code review的倡导者，即使在我没有能力要求其他同事提交merge request来进行code review的时候，我也会主动把自己的代码分模块提交给同事review，既能起到防止出错的作用，还能够展现自己代码中优秀的部分。这些工作中的表现都会促使转岗的决策人认为，我对新岗位是有克服困难去快速适应的能力的。</p><h2>挑战开始</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-f951ce7d1a77272f84cda688db1045f9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-f951ce7d1a77272f84cda688db1045f9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;900&#39; height=&#39;450&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"900\" data-rawheight=\"450\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"900\" data-original=\"https://pic2.zhimg.com/v2-f951ce7d1a77272f84cda688db1045f9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-f951ce7d1a77272f84cda688db1045f9_b.jpg\"/></figure><p>等到正式开始参与后端工作以后，其实挑战才刚刚开始。头一个星期我被分配了个营销活动的页面练练手，不过因为是初次接触过程中也还是出现了不少波折，不过等到第二个项目才真的是给我带来了一个巨大的挑战。当时公司希望开展基金销售业务，虽然底层依赖的是有基金销售资质的第三方提供的接口，但是这些接口只支持单支基金的申购和赎回操作。而我当时被分配到的工作直接就是整个业务中最复杂的基金组合模块。</p><p>独立承担一个复杂的完整业务模块开发工作一下子就暴露出了我后端知识体系中的诸多弱点。我不得不边做边学，比如数据库设计、幂等实现、轮询补偿，我都是现学现卖。在碰到这些不会的知识点时，我会尽量多花时间上网找资料，寻找多种解决方案再对它们进行比较。头几个月在做一个功能时，我常常需要把这个功能的整体流程先理顺，然后把流程中还不明确的点都记录下来，然后再逐个解决。这个过程会花费我不少的时间，让我不得不花更多的时间和精力才能完成工作。但是在这个过程中我积累了很多具体的解决方案，在之后两三年的时间里不管在工作还是面试中我都会持续受益于这些积累下来的解决方案。</p><p>项目刚开始时，我曾经因为任务的难度对我当时的水平来说太困难而一度打起了退堂鼓或者心生抱怨。不过最后想要成为一个后端开发工程师的强烈愿望让我不得不以一个真正的Java后端开发的标准来要求自己。当把这些乱七八糟的情绪通过理性的分析全部屏蔽掉以后，剩下的就只有如何想方设法来让自己能够完成项目中的工作了。两三个月后，当整个业务正式上线运行时，我突然感觉我真正跨入了Java后端开发工程师的大门，之前所有付出的所有努力都有了回报。</p><p>在刚转型为Java后端开发时，我还报了在线的Java后端课程和MySQL数据库工程师课程，一边学习在线课程中的内容，一边在实际工作中进行应用。虽然总感觉每次都匆匆忙忙的，要抓紧在有限的时间里搞清楚知识点再马上应用到工作中。但是到了最后，反而觉得比单纯的“学习”对相关技术掌握得更多更好了。这让我想到我以前在学校里也尝试学过Java后端开发，但是总是在学的时候感觉自己都会了，一到真正要写代码时就傻眼了。反而是在这种边学边用的紧张状况下，我对知识点的掌握都很扎实，对难点的理解也更深入了。</p><h2>目标：支付宝</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-2c07d5050a7a9c1aa7abf9fe29d501a5_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-2c07d5050a7a9c1aa7abf9fe29d501a5_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;720&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"720\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic2.zhimg.com/v2-2c07d5050a7a9c1aa7abf9fe29d501a5_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-2c07d5050a7a9c1aa7abf9fe29d501a5_b.jpg\"/></figure><p>不过我还没高兴多久就被浇了一盆冷水，我的一个朋友在和我聊天时觉得后端开发领域最重要的还是高并发分布式系统的经验，小公司中的工作内容都上手了也只能算是初级开发。虽然我嘴上并不愿意承认这一点，但是心里却不得不承认这个观点很大程度上确实是一个客观规则。当时对于我希望能通过社招进入BAT的想法来讲，这确实就成了一个先有鸡还有先有蛋的问题了：不进入大公司我就没办法拥有高并发分布式系统的实际工作经验，但是没有这些我又很难进入大公司。</p><p>从这时起，我就一直在琢磨如何才能扬长避短，想办法得到一个进入BAT的机会。要想进入BAT，那首先就要有一个面试机会。当时我考虑了某直聘和找朋友内推两个渠道，因为当时我考虑的就是可以直接对接到用人部门的实际招聘需求而不是一个空挂着的职位，这样可以让成功率提高不少。</p><h2>面试准备</h2><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-79695d99fbeb05cccfa58f65c88b2686_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"853\" class=\"origin_image zh-lightbox-thumb\" width=\"1280\" data-original=\"https://pic3.zhimg.com/v2-79695d99fbeb05cccfa58f65c88b2686_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1280&#39; height=&#39;853&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1280\" data-rawheight=\"853\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1280\" data-original=\"https://pic3.zhimg.com/v2-79695d99fbeb05cccfa58f65c88b2686_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-79695d99fbeb05cccfa58f65c88b2686_b.jpg\"/></figure><p>当时因为我也知道自己在高并发分布式这块肯定是很大的弱项，而且确实看了不少资料之后也还是只能停留在理论上，没有实际的实践经验很难把整个思路搞透彻。所以在准备面试时我都是着重突出自己擅长的方面，而且把面试流程中的关键环节都做了相应的准备。</p><p>首先面试中一般都会先介绍一下自己的项目经历，因为我正好做了比较复杂的基金组合交易模块，所以就重新整理了整个模块中的几个关键业务逻辑和关键的技术优化点。因为正好简历投的是金融中台部门，所以对基金交易中的各种关键时间节点和业务处理方法都做了专门的准备。必要的地方还专门给自己画了流程图方便记忆和理解，然后自己推敲了几遍口头上如何表述会比较清晰。</p><p>面试准备这块是我目前接触到的很多面试候选人都存在的问题，常常是一开始上来对自己项目经历的描述就很磕磕绊绊，而且也没有突出关键细节，讲得都比较笼统和模糊。这样的项目经历表述并不能体现自己对业务逻辑的理解和技术水平，也没有引出自己擅长的技术点来让面试官可以继续深入。我们面试中说的话一般都是为了展现自己的优点，所以在每一个环节上重点都应该放在怎么表现出自己的优势上来。如果只是简单描述公司业务、用过的技术，但是没有自己的分析或专长，那对面试官来说其实大部分就是无效信息了。</p><p>然后，我虽然没有高并发分布式系统的经验，但是对多线程并发、数据库中的索引与锁机制这些并发的关联主题是有一定了解的。所以我在项目经历中就会着重引出我在项目中对这两块知识的应用，而且事先也专门强化了这两个方面的知识细节。因为一般高水平的面试中都会不断挖掘主题下的关键技术细节，一直往下追问来判断面试候选人的技术水平。所以对技术知识的细节准备就非常重要了，<b>至少应该要准备2~3个知识点可以一路问到很深的层次</b>。</p><p>如果是自己比较重视的面试，我觉得花一些时间提前准备一下是值得的，特别是对面试整体节奏的把握可以对面试结果带来非常大的正面影响。一般完整的一次技术面试准备至少要准备一个项目或业务的介绍，再加上2到3个技术知识点的全面准备。这样就可以从项目经历的介绍入手，然后在其中引出自己碰到的业务难题和技术难题，这些难题引出的就是对准备好的技术知识点的一系列追问了。因为面试官和候选人重点研究的技术领域一般不会完全重合，所以高水平面试中的面试官一般会尊重候选人的引导，让候选人可以有机会展示自己钻研之后所达到的技术深度。</p><h2><b>最后</b></h2><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-70a64a19cdd2ea4b6c8e3833ec0ce3c8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-70a64a19cdd2ea4b6c8e3833ec0ce3c8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;631&#39; height=&#39;380&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"631\" data-rawheight=\"380\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"631\" data-original=\"https://pic1.zhimg.com/v2-70a64a19cdd2ea4b6c8e3833ec0ce3c8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-70a64a19cdd2ea4b6c8e3833ec0ce3c8_b.jpg\"/></figure><p>最终，在经历了四轮技术面试+一轮代码测验+一轮HR面试之后，我终于拿到了支付宝金融核心中台部门的offer，算是实现了自己职业生涯中的一个小里程碑。可以说我从转型Java后端开始，唯一的优势可能就是之前有客户端的编程经验，最后能得到让自己满意的结果其实主要靠的还是大胆去做、尽力坚持。有时候大胆去追求自己想要的就已经足够了，碰到的困难也都是暂时的，用不了多久就会突然发现这些困难已经都不复存在了。</p><p>虽然最近一直听说Java后端开发岗位寒冬了，不过现在看大部分公司的HC还是后端的最多，而且会比整个大前端的名额都多上非常多。希望这篇文章能够鼓舞正在找工作或者想要跳槽的读者自信地去得到自己期望的结果。</p>", 
            "topic": [
                {
                    "tag": "后端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19686604"
                }, 
                {
                    "tag": "支付宝", 
                    "tagLink": "https://api.zhihu.com/topics/19552417"
                }, 
                {
                    "tag": "iOS 开发", 
                    "tagLink": "https://api.zhihu.com/topics/19555404"
                }
            ], 
            "comments": [
                {
                    "userName": "凌霄", 
                    "userLink": "https://www.zhihu.com/people/f08a59bed489138598a69bff043d0e61", 
                    "content": "谢谢分享", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "ruan ruan", 
                    "userLink": "https://www.zhihu.com/people/f32bb1240714bbca00d9bb259c727d1f", 
                    "content": "<p>谢谢分享！ 感谢！</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Tostrivefor", 
                    "userLink": "https://www.zhihu.com/people/6f3d56cf7798d7bf3e0b93dabfbb46e0", 
                    "content": "<p>知乎太能编了</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>哈哈哈，现在知乎编的是多。我以前在黄龙国际上班，后来Z空间开了以后搬到了黄龙时代。你可以问问认识的朋友是不是真的。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "Tostrivefor"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/85840984", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 1, 
            "title": "阿里钉钉内推机会", 
            "content": "<p>今天给大家带来一个好消息，最近钉钉的社招和校招都在火热进行中，而且正是金九银十的招聘旺季，也许有很多同学都在考虑找一找更好的机会。现在有一个和钉钉的同学直接沟通、获得内推的好机会，参考JD如下图，有意向P6、P7岗位的同学都可以试一试。</p><p class=\"ztext-empty-paragraph\"><br/></p><ul><li>电子邮箱：<a href=\"https://link.zhihu.com/?target=http%3A//yuxiang.xz%40alibaba-inc.com/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">yuxiang.xz@alibaba-inc.com</a></li><li>BOSS直聘地址：<a href=\"https://link.zhihu.com/?target=https%3A//m.zhipin.com/mpa/html/weijd/weijd-job/65efefe15cc8e7020nJ-2Ny1EVo~%3Fdate8%3D20191009%26sid%3Dtosee_jd_df536bd08b2e45de0HV-3Nm9EA~~\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">m.zhipin.com/mpa/html/w</span><span class=\"invisible\">eijd/weijd-job/65efefe15cc8e7020nJ-2Ny1EVo~?date8=20191009&amp;sid=tosee_jd_df536bd08b2e45de0HV-3Nm9EA~~</span><span class=\"ellipsis\"></span></a></li></ul><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-515d9bd82860657ebc6753ac2d69e759_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"795\" data-rawheight=\"824\" class=\"origin_image zh-lightbox-thumb\" width=\"795\" data-original=\"https://pic2.zhimg.com/v2-515d9bd82860657ebc6753ac2d69e759_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;795&#39; height=&#39;824&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"795\" data-rawheight=\"824\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"795\" data-original=\"https://pic2.zhimg.com/v2-515d9bd82860657ebc6753ac2d69e759_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-515d9bd82860657ebc6753ac2d69e759_b.jpg\"/></figure><p></p>", 
            "topic": [
                {
                    "tag": "钉钉", 
                    "tagLink": "https://api.zhihu.com/topics/20013286"
                }, 
                {
                    "tag": "招聘", 
                    "tagLink": "https://api.zhihu.com/topics/19578758"
                }, 
                {
                    "tag": "程序员", 
                    "tagLink": "https://api.zhihu.com/topics/19552330"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70325764", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 7, 
            "title": "多线程编程完全指南", 
            "content": "<p>多线程编程或者说范围更大的并发编程是一种非常复杂且容易出错的编程方式，但是我们为什么还要冒着风险艰辛地学习各种多线程编程技术、解决各种并发问题呢？</p><p>因为并发是整个分布式集群的基础，通过分布式集群不仅可以大大降低同等负载能力的价格，还能使整体可扩展到的负载能力上限大大提升。低廉的服务成本使互联网行业的创意井喷，任何一个人都有能力创建并维持一个服务于成百上千甚至数万人的应用服务；而极高的服务能力上限让无数业务的线上化成为了可能，大大拓宽了互联网技术与业务的边界。</p><p>在这个范围广大的并发技术领域当中多线程编程可以说是基础和核心，大多数抽象并发问题的构思与解决都是基于多线程模型来进行的。而且这些并发问题的本质都是相同的，不管是线程并发、进程并发还是服务器级别的并发都具有类似的特点、面临相似的问题，多线程编程正是我们切入这个领域、学习并发问题解决方案的最好途径。所以，在现在的计算机行业中，多线程编程不仅是Java程序员技术面试、进阶提高的重要知识领域，而且也是后端程序员敲开分布式系统实现大门的入场券。如果不能理解并发程序的特点与问题，那么就难以胜任分布式系统开发的工作。</p><p>这篇文章是一系列文章的总集篇，所以不需要读者有多线程相关的基础。文中会按照合理的顺序循序渐进地介绍Java多线程编程的方方面面，由浅入深地讲解多线程编程的概念、使用、原理与实现。在每一部分都有对相关主题的简单介绍，再搭配上深入讲解的文章链接，建议还不了解相关主题的读者可以深入阅读链接中的文章来进行了解。但如果文章中间的一些内容大家已经非常熟悉了，那么可以略读而过，不用理会链接中的文章，完全可以把这部分内容当做复习提纲来看。</p><p>接下来，我们会在这篇文章中系统地了解Java多线程编程知识体系，从最基础的基本概念、线程的使用开始讲起，一路覆盖多线程的正确性与运行效率相关议题，帮助大家从0到入门再到熟练掌握各种多线程编程技巧。在这之后，文章会渐趋复杂，我们会深入地讨论死锁的解决、事件驱动模型、同步机制的底层实现、线程池源代码解析等高级议题，帮助读者知其然更知其所以然，再也无惧于多线程相关的问题。</p><h2>多线程基础</h2><h3>并发的概念</h3><p>多线程首先是属于一种并发手段，所以我们首先需要了解并发的基本概念。并发就是多个执行器同时执行不同的任务，如果这些任务需要访问同一个数据，那么就会产生<b>数据竞争</b>。如果不能做好并发控制，那么<b>数据竞争</b>问题就有可能会导致程序最终的结果出现错误，也就是我们常说的<b>数据不一致</b>。比如账户A同时要扣三笔钱，那么如果三个线程同时执行扣款操作就有可能因为三个线程都用一开始的账户余额减去一个值计算出三个结果并保存到账户余额中，从而导致扣减结果之间的相互覆盖。除了多线程并发之外还有更重要的分布式并发主题，包括<b>原子性、临界区、互斥、补偿、兜底任务</b>等等专业术语，这些都可以在这篇不纠结于具体技术细节、只通过生活中的例子来讲解并发概念的文章《<a href=\"https://zhuanlan.zhihu.com/p/58316557\" class=\"internal\">当我们在说“并发、多线程”，说的是什么？</a>》中找到答案。</p><h3>多线程编程基础</h3><p>了解了并发的基本概念之后我们就可以具体地在多线程编程领域中来了解具体的技术了。首先我们先要了解，为什么会需要多线程？多线程到底解决的是什么问题？然后，我们就可以开始实际动手写真正的Java多线程编程代码了，一开始，我们会直接使用<code>Thread</code>类来创建并运行线程。马上我们就碰到了多线程所带来的问题，我们必须通过线程同步机制才能保证最后的输出结果正确。</p><p>在《<a href=\"https://zhuanlan.zhihu.com/p/58820656\" class=\"internal\">这一次，让我们完全掌握Java多线程</a>》这篇文章中，我们从多线程使用的场景开始讲起，只有弄明白了多线程到底能发挥什么样的作用我们才能真正地在实践中使用好这门重要的技术。之后我们会使用<code>Thread</code>来创建并运行线程，然后通过最基本的<code>sychronized</code>关键字来实现临界区的互斥访问，实现这一系列文章中的第一个正确的Java多线程程序。</p><h3>线程池的使用</h3><p>但在实际的开发过程中，我们基本不会自己创建<code>Thread</code>类代表的线程然后管理它的执行。相反，我们把任务交给一个线程池，然后让线程池自己管理任务的调度和线程的生命周期。线程池就像一个大管家，我们只要给他设定好规则和预算，他就会自动帮我们处理各种各样的任务。想要使用好线程池，那么你只需要看完《<a href=\"https://zhuanlan.zhihu.com/p/60212693\" class=\"internal\">从0到1玩转线程池</a>》这篇文章就够了！</p><h2>多线程程序所面临的问题</h2><p>多线程程序相比于单线程程序面临更多更复杂的问题，这就像掏蜂窝一样。我们既想要蜂蜜的甘甜，但是又要时刻小心不要被蜇成了满脸包。一般来说，多线程程序会面临三类问题：正确性问题、效率问题、死锁问题。</p><h3>正确性问题</h3><p>正确性是程序的核心，如果一个程序产出的结果可能是错误的，那么这个程序的价值必然大打折扣，甚至直接清零。我们在之前的文章中使用<code>synchronized</code>关键字处理过多线程并发中的数据竞争问题。但是在实际的开发过程中，我们还会碰到更多各式各样的并发正确性问题。《<a href=\"https://zhuanlan.zhihu.com/p/61904135\" class=\"internal\">多线程中那些看不见的陷阱</a>》这篇文章中讲到了<code>synchronized</code>关键字、<code>ReentrantLock</code>显式锁、CAS操作、volatile关键字等一系列的线程同步工具，相信有了这些工具的保驾护航，我们一定可以写出大量正确的多线程程序。</p><h3>效率问题</h3><p>虽然我们可以利用线程同步工具箱中的十八般兵器写出正确的多线程程序，但是如果它执行得太慢甚至还比不上单线程程序的话那就得不偿失了。所以我们不仅要“对”，还要在“对”的前提下更“快”才行。在《<a href=\"https://zhuanlan.zhihu.com/p/70324710\" class=\"internal\">多线程加速指南</a>》这篇文章中，我们可以利用CAS、<code>ForkJoinPool</code>、线程封闭、<code>java.util.concurrent</code>工具包等技术让我们的多线程程序的速度提升10倍、100倍甚至是1000倍。</p><h3>死锁问题</h3><p>死锁问题相对来说比较特殊，因为一旦出现死锁问题就会导致程序完全无法继续执行。它既不会产生错误的结果，又因为程序会完全停止所以已经不止是运行太慢的问题了。在各式各样的并发程序中都会遇到死锁问题，比如数据库、操作系统等等都会有这个问题。如果是我们的个人电脑，那么死机之后重启就可以了，但是线上服务往往是不能中断的，这就需要我们找到更多更好的解决方案来解决不同情况下的死锁问题。相信读完这篇文章《<a href=\"https://zhuanlan.zhihu.com/p/63207814\" class=\"internal\">解决死锁的100种方法</a>》，你会对这个问题有更多的灵感。</p><h2>多线程编程实战（实现一个阻塞队列）</h2><p>讲完了这么多多线程相关的概念、技术与技巧，我们也是时候下场练练手了。阻塞队列不仅是多线程编程中的重要工具，而且还使用了<b>互斥锁、条件变量、并发优化</b>等等一系列重要的知识点来具体实现，这正是我们练手的最佳素材。就让我们跟随《<a href=\"https://zhuanlan.zhihu.com/p/64156753\" class=\"internal\">从0到1实现自己的阻塞队列</a>》的脚步，一起从0到1再到N，完成一个完整的JDK级别的阻塞队列实现。</p><h2>高级主题</h2><p>在看过多线程的基础知识、关键技术，最后又完成了一次练手以后，我们就可以继续深入多线程领域中更深奥的高级主题了。</p><h3>线程池运行模型源码解析</h3><p>在之前的文章中，我们已经掌握了线程池的使用方法，虽然线程池是一个称职的管家，但是如果我们不了解它的脾气就有可能在不自觉的时候越过了一些它的底线，最后被它给狠狠地甩在了地上。那么现在就让我们通过《<a href=\"https://zhuanlan.zhihu.com/p/60214997\" class=\"internal\">线程池运行模型源码全解析</a>》来剖析线程池的运行模型，从源码角度了解线程池到底是怎么运转的。</p><h3>同步机制的底层实现</h3><p>我们已经使用过了这么多的线程同步机制，这些线程同步机制显得那么的神奇，帮助我们躲开一个又一个的陷阱。那么这些这么厉害的东西到底是怎么实现的呢？这时候就要请出我们的幕后英雄<code>AbstractQueuedSynchronizer</code>(简称AQS)了。<code>java.util.concurrent</code>中的大多数线程同步类都是基于AQS实现的，比如常用的就有可重入互斥锁<code>ReentrantLock</code>、闭锁<code>CountDownLatch</code>、可重入读写锁<code>ReentrantReadWriteLock</code>、信号量<code>Semaphore</code>。在《<a href=\"https://zhuanlan.zhihu.com/p/67035482\" class=\"internal\">同步机制的底层实现</a>》中，我们可以一探究竟，看看AQS是如何实现这么多风格迥异的线程同步机制的。</p><h2>总结</h2><p>到这里，我们就完成了整个Java多线程知识体系之旅。在这个过程中，我们首先了解了并发的基本概念和Java多线程编程的基本方法，然后出现了<b>线程池</b>这个优秀的管家为我们打理好了任务执行与线程调度的所有麻烦事。之后我们系统地了解并解决了多线程中的三类主要问题：正确性问题、效率问题和死锁问题。在掌握了这么多Java多线程编程的知识与技巧之后，我们就通过实现一个阻塞队列来了一次大练兵，不仅能检验我们的多线程编程技能，同时也加深了我们对这些知识的理解。最后，我们进入了多线程知识的深水区，通过JDK与Netty的成熟源代码研究了三个更底层的高级主题：事件驱动模型、线程池运行模型、同步机制的底层实现。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/70324710", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 3, 
            "title": "多线程程序加速指南", 
            "content": "<p>虽然对于一个计算机程序来说最重要的是正确性，如果一个程序没办法产出正确的结果，那么这个程序的价值就大打折扣了。但程序性能也是很重要的一个方面，如果程序运行得太慢，那也会影响到程序的适用范围和硬件配置的成本。</p><p>在之前的文章《<a href=\"https://zhuanlan.zhihu.com/p/61904135\" class=\"internal\">4.多线程中那些看不到的陷阱</a>》中，我们了解了线程间的同步机制，这主要是为了保证程序在多线程环境下的正确性。在这篇文章中我们将会深入探究多线程程序的性能瓶颈和多种不同的优化方式，那么我们首先就从对程序性能的测量与分析开始吧。</p><h3>分析多线程程序的性能</h3><p>我们先来看一个使用<code>AtomicLong</code>进行多线程计数的程序，下面的程序中会启动两个线程，每个线程会对静态变量<code>count</code>进行一亿次(10的8次方)的累加操作，这段代码在开始和结束的时候都获取了当前时间，然后通过这两个时间值计算程序的运行耗时。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AtomicIntegerTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">AtomicLong</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicLong</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1e8</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">incrementAndGet</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">endTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;总耗时：%.2fs&#34;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">endTime</span> <span class=\"o\">-</span> <span class=\"n\">startTime</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">1e3</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>在我的电脑上运行这段程序最后输出的结果是2.44s，看起来有点长了，那么我们再看一下如果直接在单个线程中对一个整型变量累加两亿次会是什么结果。下面是一个在单个线程中累加两亿次的程序代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SingleThreadTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">2e8</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">endTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;总耗时：%.2fs&#34;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">endTime</span> <span class=\"o\">-</span> <span class=\"n\">startTime</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">1e3</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>这段代码运行耗时只有0.33s，我们通过两个线程进行累加的代码竟然比单线程的代码还要慢得多，这不是就和我们使用多线程加快程序运行的初衷相违背了吗？</p><p>多线程程序的线程间同步是影响多线程程序性能的关键所在，一方面程序中必须串行化的部分会使系统整体的耗时显著增加，另一方面同步行为本身的开销也比较大，特别是在发生冲突的情况下。在上文的代码中，多线程累加的程序之所以会比单线程还慢得多就是因为在<code>AtomicLong</code>类型的静态变量<code>count</code>上有两个线程同时调用<code>incrementAndGet</code>方法进行累加，这就会导致在这个静态变量上存在很严重的冲突。</p><p>当一个线程成功修改了变量<code>count</code>的值后，另外一个正在修改的线程就会修改失败并且会再次重试累加操作。并且因为<code>AtomicLong</code>类型的对象中是用一个<code>volatile</code>变量来保存实际的整型值的，而我们在之前的文章《<a href=\"https://zhuanlan.zhihu.com/p/61904135\" class=\"internal\">多线程中那些看不到的陷阱</a>》中可以了解到，对<code>volatile</code>变量的修改操作一定要把修改后的数据从高速缓存写回内存当中，这也是用<code>AtomicLong</code>进行累加的耗时比单线程累加版本还要多这么多的主要原因。</p><p>那么我们有没有更好的方法可以解决这个问题呢？</p><h3>使用任务拆分进行优化</h3><p>在上面的例子中，我们需要的只是最终累加的结果，所以为了减小线程间同步的开销，我们可以将累加任务拆分到不同的线程中执行，到最后再把每个线程的结果加在一起就可以得到最终的结果了。在下面的代码中我们就使用了这种方法，t1在count1上累加一亿次，t2在count2上累加一亿次，最后把count1和count2相加得到最终的结果，我们来一起运行一下，看看效果如何。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">TwoThreadTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">long</span> <span class=\"n\">count1</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">long</span> <span class=\"n\">count2</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1e8</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count1</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1e8</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count2</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">});</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">count1</span> <span class=\"o\">+</span> <span class=\"n\">count2</span><span class=\"o\">;</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n\n        <span class=\"kt\">long</span> <span class=\"n\">endTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;总耗时：%.2fs&#34;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">endTime</span> <span class=\"o\">-</span> <span class=\"n\">startTime</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">1e3</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>这段程序在我的电脑上的耗时是0.20s，比之前单线程的0.33s有了不小的提高，更是遥遥领先原先用两个线程累加<code>AtomicLong</code>类型变量版本的2.44s。这说明我们之前的分析是正确的，CAS重试和volatile写回内存两个操作所引起的开销是<code>AtomicLong</code>版本程序性能低下的罪魁祸首。</p><p>但是这个版本的结构还是略显原始了，在应付累加这种简单的需求时可能还比较容易，但是一旦面临复杂的并发任务，那可能就要写很多复杂的代码，并且很容易出现错误了。例如我们如果想把任务拆分到10个线程中运行，那么我们就要首先把两亿次的累加任务拆分为10份，然后还要创建一个包含10个Thread对象的数组让他们分别的对不同范围进行累加，最后还要通过<code>join</code>方法等待这10个线程都执行完成，这个任务听起来就不太容易。没关系，下面我们将会介绍一种目前比较常用的任务拆分与运行框架来解决这个问题，通过这个框架我们可以很容易地写出易于编写和扩展的任务拆分式程序。</p><h3>使用ForkJoinPool进行任务</h3><p>JDK 1.7中引入了一个新的多线程任务执行框架，被称为<code>ForkJoinPool</code>。<code>ForkJoinPool</code>是一个Java类，它实现了代表线程池功能的<code>ExecutorService</code>接口，所以它在使用方法上和常用的线程池类<code>ThreadPoolExecutor</code>相似，但在本节中我们并不需要了解线程池的详细用法，不过感兴趣的读者可以参考这篇文章《<a href=\"https://zhuanlan.zhihu.com/p/60212693\" class=\"internal\">从0到1玩转线程池</a>》来了解一下。</p><p>线程池就是一个线程的集合，其中的线程会一直等待执行任务，所以我们可以把任务以任务对象的形式提交到线程池，然后线程池就会利用其中的线程来执行任务。在<code>ForkJoinPool</code>的使用中，线程池指的就是<code>ForkJoinPool</code>类型的对象，而任务对象指的就是继承自<code>ForkJoinTask</code>的类的对象。在下面的示例代码中，我们使用了自定义的<code>RecursiveTask</code>的子类来作为任务类，<code>RecursiveTask</code>类就继承自<code>ForkJoinTask</code>类。</p><p><code>Recursive</code>的意思是递归，也就是说我们在这个任务类的执行过程中可能会创建新的任务类对象来代表当前任务的子任务，然后通过结合多个子任务的结果来返回当前任务的结果。比如一开始的任务是累加两亿次，但那么我们就可以把它分为两个分别累加一亿次的子任务的结果之和，同样的道理，累加一亿次的子任务也可以再被分为两个累加五千万次的子子任务。这样的拆分会一直持续到我们认为任务规模已经足够小的时候，这时子任务的结果就会被计算，然后再返回给上层任务进行处理之后就得到上层任务的结果了。</p><p>如果前面这一段文字描述看不明白也没关系，我们在代码中找一找答案：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ForkJoinTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">AccumulateTask</span> <span class=\"kd\">extends</span> <span class=\"n\">RecursiveTask</span><span class=\"o\">&lt;</span><span class=\"n\">Long</span><span class=\"o\">&gt;</span> <span class=\"o\">{</span>\n\n        <span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n        <span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n        <span class=\"kd\">private</span> <span class=\"kt\">long</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n\n        <span class=\"cm\">/**\n</span><span class=\"cm\">         * 任务的构造函数\n</span><span class=\"cm\">         *\n</span><span class=\"cm\">         * @param start         任务处理范围的起始点（包含）\n</span><span class=\"cm\">         * @param end           任务处理范围的结束点（不包含）\n</span><span class=\"cm\">         * @param threshold     任务拆分的阈值\n</span><span class=\"cm\">         */</span>\n        <span class=\"kd\">public</span> <span class=\"nf\">AccumulateTask</span><span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"kt\">long</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"kt\">long</span> <span class=\"n\">threshold</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">start</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">end</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">threshold</span> <span class=\"o\">=</span> <span class=\"n\">threshold</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"nd\">@Override</span>\n        <span class=\"kd\">protected</span> <span class=\"n\">Long</span> <span class=\"nf\">compute</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kt\">long</span> <span class=\"n\">left</span> <span class=\"o\">=</span> <span class=\"n\">start</span><span class=\"o\">;</span>\n            <span class=\"kt\">long</span> <span class=\"n\">right</span> <span class=\"o\">=</span> <span class=\"n\">end</span><span class=\"o\">;</span>\n\n            <span class=\"c1\">// 终止条件：如果当前处理的范围小于等于阈值(threshold)，\n</span><span class=\"c1\"></span>            <span class=\"c1\">//                    那么就直接通过循环执行累加操作\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">right</span> <span class=\"o\">-</span> <span class=\"n\">left</span> <span class=\"o\">&lt;=</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">threshold</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"kt\">long</span> <span class=\"n\">result</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">long</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">left</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">right</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">result</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n                <span class=\"k\">return</span> <span class=\"n\">result</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 获取当前处理范围的中心点\n</span><span class=\"c1\"></span>            <span class=\"kt\">long</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">start</span> <span class=\"o\">+</span> <span class=\"n\">end</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n\n            <span class=\"c1\">// 拆分出两个子任务，一个从start到mid，一个从mid到end\n</span><span class=\"c1\"></span>            <span class=\"n\">ForkJoinTask</span><span class=\"o\">&lt;</span><span class=\"n\">Long</span><span class=\"o\">&gt;</span> <span class=\"n\">leftTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AccumulateTask</span><span class=\"o\">(</span><span class=\"n\">start</span><span class=\"o\">,</span> <span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"n\">threshold</span><span class=\"o\">);</span>\n            <span class=\"n\">ForkJoinTask</span><span class=\"o\">&lt;</span><span class=\"n\">Long</span><span class=\"o\">&gt;</span> <span class=\"n\">rightTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AccumulateTask</span><span class=\"o\">(</span><span class=\"n\">mid</span><span class=\"o\">,</span> <span class=\"n\">end</span><span class=\"o\">,</span> <span class=\"n\">threshold</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 通过当前线程池运行两个子任务\n</span><span class=\"c1\"></span>            <span class=\"n\">leftTask</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">();</span>\n            <span class=\"n\">rightTask</span><span class=\"o\">.</span><span class=\"na\">fork</span><span class=\"o\">();</span>\n\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 获取两个子任务的结果并返回\n</span><span class=\"c1\"></span>                <span class=\"k\">return</span> <span class=\"n\">leftTask</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">+</span> <span class=\"n\">rightTask</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"k\">return</span> <span class=\"n\">0L</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"kt\">long</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 创建总任务，范围是从1到两亿(包含)，阈值为10的7次方，所以最终至少会有10个任务进行for循环的累加\n</span><span class=\"c1\"></span>        <span class=\"n\">AccumulateTask</span> <span class=\"n\">forkJoinTask</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AccumulateTask</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"kt\">int</span><span class=\"o\">)</span> <span class=\"n\">2e8</span><span class=\"o\">+</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"kt\">long</span><span class=\"o\">)</span> <span class=\"n\">1e7</span><span class=\"o\">);</span>\n        <span class=\"c1\">// 使用一个新创建的ForkJoinPool任务池运行ForkJoin任务\n</span><span class=\"c1\"></span>        <span class=\"k\">new</span> <span class=\"n\">ForkJoinPool</span><span class=\"o\">().</span><span class=\"na\">submit</span><span class=\"o\">(</span><span class=\"n\">forkJoinTask</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 打印任务结果\n</span><span class=\"c1\"></span>        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">forkJoinTask</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">());</span>\n\n        <span class=\"c1\">// 计算程序耗时并打印\n</span><span class=\"c1\"></span>        <span class=\"kt\">long</span> <span class=\"n\">endTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;总耗时：%.2fs&#34;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">endTime</span> <span class=\"o\">-</span> <span class=\"n\">startTime</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">1e3</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>在上面的代码中，我们会不断创建在指定范围内累加的子任务，直到任务范围小于阈值threshold(在代码中是10的7次方)时才不再拆分子任务，而是通过循环来得到累加结果。之后子任务的返回结果在上层任务中相加并作为上层任务的结果返回。到最后我们就可以得到累加两亿次的结果了。</p><p>在这个程序中，最重要的是对任务对象的三个操作：</p><ol><li>创建任务对象，代码中使用的是<code>new AccumulateTask(start, mid, threshold)</code>和<code>new AccumulateTask(mid, end, threshold)</code>，这两段代码会创建除了范围不同其他逻辑与父任务完全一致的子任务，每个子任务会负责执行父任务范围中的一半；</li><li>执行子任务，通过调用任务对象的<code>fork()</code>方法可以让子任务被提交到当前<code>ForkJoinPool</code>中执行；</li><li>等待子任务返回结果，通过调用子任务任务对象的<code>get()</code>方法，父任务将会等待子任务执行完成并返回结果，然后将两个子任务的结果相加得到父任务的执行结果。</li></ol><p>为什么同样都是线程池，但是<code>ThreadPoolExecutor</code>类就很难实现这样的执行方式呢？细心的读者可能已经发现了，我们在一个任务中会拆分出两个子任务，并且要等待这两个子任务都执行完成才能返回父任务的结果。如果是在<code>ThreadPoolExecutor</code>中，在等待子任务运行完成得到结果时，父任务会一直阻塞并且占用一个线程，这样的话如果父任务太多就会导致子任务没有线程可供使用了，这个运行流程就没办法继续执行下去了。而<code>ForkJoinPool</code>这个特殊的线程池就解决了这个问题，父任务在等待子任务执行时可以让出线程给其他任务，这样就不会导致线程都被阻塞状态的父任务所阻塞了。</p><p>这种将任务拆分为互不依赖的子任务，然后分别在不同的线程上执行，最后再将结果进行逐步合并的方法就被称为Map-Reduce。这种方法在离线大数据技术中被广泛应用，甚至可以说大数据相关技术就是在Map-Reduce思想基础上发展起来的也不为过。</p><h3>线程内变量</h3><p>通过上面的几个例子，我们可以看到，对于多线程程序来说，共享数据就是最大的问题。共享数据不但可能引起数据竞争问题，导致程序出现问题；而且随着引入的线程同步操作又会拉低程序的性能，甚至可能使多线程程序的执行时间比单线程程序还长得多。在上面的例子中，我们通过使用<code>ForkJoinPool</code>拆分并执行了一个累加任务，各个子任务之间基本完全独立，做到了最大程度的并行化。但是在一些情况下，我们可能没办法做到如此理想的方案，在一些情况下还是会留有一定的线程同步操作和对应的代码临界区。</p><p>那么在这些情况下我们如何处理能让程序的性能尽可能高呢？</p><p>假设我们现在要统计一个方法的调用次数，如果可能有多个线程同时调用该方法，那么就需要对多个线程的调用同时计数。这种情况下我们可以考虑在每个线程里各自保留一个整型变量用于保存每个线程内的调用次数，然后在获取总数时只需要把每个线程中的数量加在一起就能计算出来了。而在累加计数时我们只需要修改当前线程对应的变量就可以了，自然就没有了数据竞争问题。<code>java.util.concurrent.atomic</code>包中的累加器<code>LongAdder</code>类采用的就是这样的思路，这种思路也有自己专门的专业术语，被称为<b>“线程封闭”</b>，<b>线程封闭</b>指的就是这种通过线程内变量来避免线程间共享数据的优化方式。</p><p>Java中也有专门的<code>ThreadLocal</code>类可以处理线程内变量，只是因为性能和线程销毁时的数据保存之类的原因一般不会用于多线程累加这样的数据聚合场景，但是在保存和获取数据方面非常的便利，有兴趣的读者可以了解一下。</p><h3>ConcurrentHashMap</h3><p><code>java.util.concurrent</code>包为我们提供了锁、原子类、线程池、ForkJoinPool等一大批并发编程工具。最后，我们来了解一下<code>java.util.concurrent</code>包中为我们提供的一种线程安全数据结构。</p><p>在Java中，我们常用的Map类是<code>HashMap</code>，但是这个类并不是线程安全的，如果我们在多个线程中同时对<code>HashMap</code>对象进行读写，那么就有可能引发一些程序问题。还有一个从JDK 1.0起就已经存在的<code>Hashtable</code>类可以保证线程安全，但是我们打开这个类的源代码可以看到，这个类中的大部分方法上都加上了<code>synchronized</code>标记，其中包括了最常用的<code>get</code>和<code>put</code>方法，这意味着<code>Hashtable</code>类的对象同一时间几乎只能被一个线程所使用，这样的效率相对是比较低的。</p><p>但是其实熟悉HashMap结构的朋友可能会知道，HashMap内部的结构是分为很多的桶的，每个键值对都会根据key值的hashCode值被放到不同的桶中。其实在做修改操作时我们只需要对对应的一个桶加锁就可以了，而在执行读操作时，在大多数情况下是不用加锁的。JDK 1.5中引入的<code>ConcurrentHashMap</code>基本能达到这两点。</p><p>在这个类中，我们通过两种方式来优化了并发的性能：</p><ol><li>通过限制锁保护的代码范围来减少了锁冲突发生的可能性，而且也减少了需要的锁数量，减少了同步产生的开销；</li><li>另一方面因为读取的时候并不需要加锁，而只有写操作才需要加锁，在一些读操作较多但是写操作较少的情况下，我们就能大大降低读操作的成本，从而提高了程序的性能。</li></ol><p>而且<code>ConcurrentHashMap</code>中的大多数方法不仅优化了同步机制的效率，而且提供了很多原子性的类似于CAS的操作方法，下面是<code>ConcurrentHashMap</code>类常用的操作：</p><ul><li><code>V putIfAbsent(K key, V value)</code>，原子性操作，如果map中不包含key，则执行<code>map.put(key, value)</code>并将put方法的返回值返回，否则直接返回<code>map.get(key)</code>的值，即当前值；</li><li><code>boolean remove(Object key, Object value)</code>，原子性操作，如果满足条件 (map中包含key对应的键值对 &amp;&amp; value参数等于键值对中当前的value值) 则移除key对应的键值对并返回true，否则返回false；</li><li><code>boolean replace(K key, V oldValue, V newValue)</code>，原子性操作，当满足 (map中包含key对应的键值对 &amp;&amp; oldValue参数等于键值对中当前的value值)时，将key对应的值改为newValue并返回true，否则返回false。</li></ul><h3>总结</h3><p>我们在这篇文章中从对一个使用<code>AtomicLong</code>进行多线程累加的程序的性能测试开始，通过Map-Reduce思想大大优化了这个程序的性能，在此过程中还涉及到了<code>ForkJoinPool</code>类的使用。之后我们通过线程内变量正式提出了<b>“线程封闭”</b>的概念，如果我们能做到<b>线程封闭</b>，那么因为减少了线程间同步的开销，所以线程的性能一定会有很大的提高。最后我们介绍了<code>java.util.concurrent</code>包中为我们提供的并发安全数据类<code>ConcurrentHashMap</code>。相信通过这篇文章大家能够了解到多种多线程性能优化方法，但最重要的还是要找出多线程程序性能的瓶颈所在，这样才能在实际的实践场景中根据不同的情况因时制宜，使用合适的方法解决不同的瓶颈问题。本文中的观点是多线程程序的瓶颈主要在于共享数据引起的数据竞争问题，如果能够让不同的线程间不存在或者尽可能少地存在共享数据与临界区代码，就能够对多线程程序的性能起到正面的影响。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/67035482", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 8, 
            "title": "Java同步机制的底层实现", 
            "content": "<p>在多线程编程中我们会遇到很多需要使用线程同步机制去解决的并发问题，而这些同步机制就是多线程编程中影响正确性和运行效率的重中之重。这不禁让我感到好奇，这些同步机制是如何实现的呢？好奇心是进步的源泉，就让我们一起来揭开同步机制源码的神秘面纱吧。</p><p>在本文中，我们会从JDK中大多数同步机制的共同基础<code>AbstractQueuedSynchronizer</code>类开始说起，然后通过源码了解我们最常用的两个同步类可重入锁<code>ReentrantLock</code>和闭锁<code>CountDownLatch</code>的具体实现。通过这篇文章我们将可以了解到<code>ReentrantLock</code>和<code>CountDownLatch</code>两个常用同步类的源代码实现，并且掌握阅读其他基于AQS实现的同步工具类源码的能力，甚至可以利用AQS写出自己的同步工具类。</p><p>阅读这篇文章需要了解基本的线程同步机制，有兴趣的读者可以参考一下这篇文章：</p><a href=\"https://zhuanlan.zhihu.com/p/61904135\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-35e750e2772d25418191c9f718e2ac67_180x120.jpg\" data-image-width=\"1200\" data-image-height=\"725\" class=\"internal\">兜里有辣条：多线程中那些看不见的陷阱</a><p class=\"ztext-empty-paragraph\"><br/></p><h2>同步机制的核心——AQS</h2><h3>同步机制源码初探</h3><p><code>ReentrantLock</code>是我们常用的一种可重入互斥锁，是synchronized关键字的一个很好的替代品。互斥指的就是同一时间只能有一个线程获取到这个锁，而可重入是指如果一个线程再次获取一个它已经持有的互斥锁，那么仍然会成功。</p><p>这个类的源码在JDK的<code>java.util.concurrent</code>包下，我们可以在IDE中点击类名跳转到具体的类定义，比如下面就是在我的电脑上跳转之后看到的ReentrantLock类的源代码。在这里我们可以看到在ReentrantLock类中还包含了一个继承自AbstractQueuedSynchronizer类的内部类，而且有一个该内部类<code>Sync</code>类型的字段<code>sync</code>。实际上ReentrantLock类就是通过这个内部类对象来实现线程同步的。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-66fcd4a4d55efc121e698b3d85b935e1_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-66fcd4a4d55efc121e698b3d85b935e1_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;701&#39; height=&#39;355&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"701\" data-rawheight=\"355\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"701\" data-original=\"https://pic2.zhimg.com/v2-66fcd4a4d55efc121e698b3d85b935e1_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-66fcd4a4d55efc121e698b3d85b935e1_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>如果打开<code>CountDownLatch</code>的源代码，我们会发现这个类里也同样有一个继承自AbstractQueuedSynchronizer类的子类Sync，并且也有一个<code>Sync</code>类型的字段<code>sync</code>。在<code>java.util.concurrent</code>包下的大多数同步工具类的底层都是通过在内部定义一个<code>AbstractQueuedSynchronizer</code>类的子类来实现的，包括我们在本文中没提到的许多其他常用类也是如此，比如：读写锁ReentrantReadWriteLock、信号量Semaphore等。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-071db40dd983c1a49e2fc640cc3d4fe4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"955\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb\" width=\"955\" data-original=\"https://pic1.zhimg.com/v2-071db40dd983c1a49e2fc640cc3d4fe4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;955&#39; height=&#39;464&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"955\" data-rawheight=\"464\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"955\" data-original=\"https://pic1.zhimg.com/v2-071db40dd983c1a49e2fc640cc3d4fe4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-071db40dd983c1a49e2fc640cc3d4fe4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h3>AQS是什么？</h3><p>那么这个<code>AbstractQueuedSynchronizer</code>类也就是我们所说的AQS，到底是何方神圣呢？这个类首先像我们上面提到的，是大多数多线程同步工具类的基础。它内部包含了一个对同步器的等待队列，其中包含了所有在等待获取同步器的线程，在这个等待队列中的线程将会在同步器释放时被唤醒。比如一个线程在获取互斥锁失败时就会被放入到等待队列中等待被唤醒，这也就是AQS中的Q——“Queued”的由来。</p><p>而类名中的第一个单词<code>Abstract</code>是因为AQS是一个抽象类，它的使用方法就是实现继承它的子类，然后使用这个子类类型的对象。在这个子类中我们会通过重写下列的五个方法中的一部分或者全部来指定这个同步器的行为策略：</p><ol><li><code>boolean tryAcquire(int arg)</code>，独占式获取同步器，独占式指同一时间只能有一个线程获取到同步器；</li><li><code>boolean tryRelease(int arg)</code>，独占式释放同步器；</li><li><code>boolean isHeldExclusively()</code>，同步器是否被当前线程独占式地持有；</li><li><code>int tryAcquireShared(int arg)</code>，共享式获取同步器，共享式指的是同一时间可能有多个线程同时获取到同步器，但是可能会有数量的限制；</li><li><code>boolean tryReleaseShared(int arg)</code>，共享式释放同步器。</li></ol><p>这五个方法之所以能指定同步器的行为，则是因为AQS中的其他方法就是通过对这五个方法的调用来实现的。比如在下面的acquire方法中就调用了tryAcquire来获取同步器，并且在被调用的<code>acquireQueued</code>方法内部也是通过<code>tryAcquire</code>方法来循环尝试获取同步器的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">acquire</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 1. 调用tryAcquire方法尝试获取锁\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 2. 如果获取失败(tryAcquire返回false)，则调用addWaiter方法将当前线程保存到等待队列中\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 3. 之后调用acquireQueued方法来循环执行“获取同步器 -&gt; 获取失败休眠 -&gt; 被唤醒重新获取”过程\n</span><span class=\"c1\"></span>    <span class=\"c1\">//      直到成功获取到同步器返回false；或者被中断返回true\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">tryAcquire</span><span class=\"o\">(</span><span class=\"n\">arg</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span>\n        <span class=\"n\">acquireQueued</span><span class=\"o\">(</span><span class=\"n\">addWaiter</span><span class=\"o\">(</span><span class=\"n\">Node</span><span class=\"o\">.</span><span class=\"na\">EXCLUSIVE</span><span class=\"o\">),</span> <span class=\"n\">arg</span><span class=\"o\">))</span>\n        <span class=\"c1\">// 如果acquireQueued方法返回true说明线程被中断了\n</span><span class=\"c1\"></span>        <span class=\"c1\">//   所以调用selfInterrupt方法中断当前线程\n</span><span class=\"c1\"></span>        <span class=\"n\">selfInterrupt</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>下面，我们就来看看在<code>ReentrantLock</code>和<code>CountDownLatch</code>两个类中定义的AQS子类到底是如何重写这五个方法的。</p><h2>CountDownLatch的实现</h2><p><code>CountDownLatch</code>是一种典型的闭锁，比如我需要使用四个线程完成四种不同的计算，然后把四个线程的计算结果相加后返回，这种情况下主线程就需要等待四个完成不同任务的工作线程完成之后才能继续执行。那么我们就可以创建一个初始的count值为4的<code>CountDownLatch</code>，然后在每个工作线程完成任务时都对这个<code>CountDownLatch</code>执行一个<code>countDown</code>操作，这样CountDownLatch中的count值就会减1。当count值减到0时，主线程就会从阻塞中恢复，然后将四个任务的结果相加后返回。</p><p>下面是<code>CountDownLath</code>的几个常用方法：</p><ol><li><code>void await()</code>，等待操作，如果count值目前已经是0了，那么就直接返回；否则就进入阻塞状态，等待count值变为0；</li><li><code>void countDown()</code>，减少计数操作，会让count减1。</li></ol><p>调用多次<code>countDown()</code>方法让count值变为0之后，被<code>await()</code>方法阻塞的线程就可以继续执行了。了解了<code>CountDownLatch</code>的基本用法之后我们就来看看这个闭锁到底是怎么实现的，首先，我们来看一下<code>CountDownLatch</code>中AQS的子类，内部类<code>Sync</code>的定义。</p><h3>CountDownLatch的内部Sync类</h3><p>下面的代码是<code>CountDownLatch</code>中AQS的子类<code>Sync</code>的定义，<code>Sync</code>是<code>CountDownLatch</code>类中的一个内部类。在这个类中重写了AQS的<code>tryAcquireShared</code>和<code>tryReleaseShared</code>两个方法，这两个都是共享模式需要重写的方法，因为<code>CountDownLatch</code>在count值为0时可以被任意多个线程同时获取成功，所以应该实现共享模式的方法。</p><p>在<code>CountDownLatch</code>的<code>Sync</code>中使用了AQS的state值用来存放count值，在初始化时会把state值初始化为n。然后在调用<code>tryReleaseShared</code>时会将count值减1，但是因为这个方法可能会被多个线程同时调用，所以要用CAS操作保证更新操作的原子性，就像我们用<code>AtomicInteger</code>一样。在CAS失败时我们需要通过重试来保证把state减1，如果CAS成功时，即使有许多线程同时执行这个操作最后的结果也一定是正确的。在这里，<code>tryReleaseShared</code>方法的返回值表示这个释放操作是否可以让等待中的线程成功获取同步器，所以只有在count为0时才能返回true。</p><p><code>tryAcquireShared</code>方法就比较简单了，直接返回state是否等于0即可，因为只有在<code>CountDownLatch</code>中的count值为0时所有希望获取同步器的线程才能获取成功并继续执行。如果count不为0，那么线程就需要进入阻塞状态，等到count值变为0才能继续执行。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">Sync</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractQueuedSynchronizer</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"n\">serialVersionUID</span> <span class=\"o\">=</span> <span class=\"n\">4982264981922014374L</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// 构造器，初始化count值\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 在这个子类中把count值保存到了AQS的state中\n</span><span class=\"c1\"></span>    <span class=\"n\">Sync</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">setState</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 获取当前的count值\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"nf\">getCount</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">getState</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 获取操作在state为0时会成功，否则失败\n</span><span class=\"c1\"></span>    <span class=\"c1\">// tryAcquireShared失败时，线程会进入阻塞状态等待获取成功\n</span><span class=\"c1\"></span>    <span class=\"kd\">protected</span> <span class=\"kt\">int</span> <span class=\"nf\">tryAcquireShared</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">acquires</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"o\">(</span><span class=\"n\">getState</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">?</span> <span class=\"n\">1</span> <span class=\"o\">:</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 对闭锁执行释放操作减小计数值\n</span><span class=\"c1\"></span>    <span class=\"kd\">protected</span> <span class=\"kt\">boolean</span> <span class=\"nf\">tryReleaseShared</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">releases</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 减小coun值，在count值归零时唤醒等待的线程\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(;;)</span> <span class=\"o\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">getState</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果计数已经归零，则直接释放失败\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n            <span class=\"c1\">// 将计数值减1\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">nextc</span> <span class=\"o\">=</span> <span class=\"n\">c</span><span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n            <span class=\"c1\">// 为了线程安全，以CAS循环尝试更新\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">compareAndSetState</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">nextc</span><span class=\"o\">))</span>\n                <span class=\"k\">return</span> <span class=\"n\">nextc</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>CounDownLatch对Sync类对象的使用</h3><p>看了<code>CountDownLatch</code>中的<code>Sync</code>内部类定义之后，我们再来看看<code>CountDownLatch</code>是如何使用这个内部类的。</p><p>在<code>CountDownLatch</code>的构造器中，初始化<code>CountDownLatch</code>对象时会同时在其内部初始化保存一个<code>Sync</code>类型的对象到<code>sync</code>字段用于之后的同步操作。并且传入<code>Sync</code>类构造器的count一定会大于等于0。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">CountDownLatch</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">(</span><span class=\"s\">&#34;count &lt; 0&#34;</span><span class=\"o\">);</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">sync</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Sync</span><span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>有了Sync类型的对象之后，我们在<code>await()</code>方法里就可以直接调用<code>sync</code>的<code>acquireSharedInterruptibly</code>方法来获取同步器并陷入阻塞，等待count值变为0了。在AQS的<code>acquireSharedInterruptibly</code>方法中会在调用我们重写的<code>tryAcquireShared</code>方法获取失败时进入阻塞状态，直到<code>CountDownLatch</code>的count值变为0时才能成功获取到同步器。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">await</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 调用sync对象的获取方法来进入锁等待\n</span><span class=\"c1\"></span>    <span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"na\">acquireSharedInterruptibly</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>而在<code>CountDownLatch</code>的另一个减少count值的重要方法<code>countDown()</code>中，我们同样是通过调用<code>sync</code>上的方法来实现具体的同步功能。在这里，AQS的<code>releaseShared(1)</code>方法中同样会调用我们在<code>Sync</code>类中重写的<code>tryReleaseShared</code>方法来执行释放操作，并在<code>tryReleaseShared</code>方法返回true时去唤醒等待队列中的阻塞等待线程，让它们在count值为0时能够继续执行。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">countDown</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"na\">releaseShared</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>从上文中可以看出，<code>CoundDownLatch</code>中的各种功能都是通过内部类<code>Sync</code>来实现的，而这个<code>Sync</code>类就是一个继承自AQS的子类。通过在内部类<code>Sync</code>中重写了AQS的<code>tryAcquireShared</code>和<code>tryReleaseShared</code>两个方法，我们就指定了AQS的行为策略，使其能够符合我们对<code>CountDownLatch</code>功能的期望。这就是AQS的使用方法，下面我们来看一个大家可能会更熟悉的例子，来进一步了解AQS在独占模式下的用法。</p><h2>ReentrantLock的实现</h2><p>可重入锁<code>ReentrantLock</code>可以说是我们的老朋友了，从最早的<code>synchronized</code>关键字开始，我们就开始使用类似的功能了。可重入锁的特点主要有两点：</p><ul><li>同一时间只能有一个线程持有</li><ul><li>如果我想保护一段代码同一时间只能被一个线程所访问，比如对一个队列的插入操作。那么如果有一个线程已经获取了锁之后在修改队列了，那么其他也想要修改队列的线程就会陷入阻塞，等待之前的这个线程执行完成。</li></ul><li>同一线程可以对一个锁重复获取成功多次</li><ul><li>而如果一个线程对同一个队列执行了两个插入操作，那么第二次获取锁时仍然会成功，而不会被第一次成功获取到的锁所阻塞。</li></ul></ul><p><code>ReentrantLock</code>类的常用操作主要有三种：</p><ol><li>获取锁，一个线程一旦获取锁成功后就会阻塞其他线程获取同一个锁的操作，所以一旦获取失败，那么当前线程就会被阻塞</li></ol><ul><li>最简单的获取锁方法就是调用<code>public void lock()</code>方法</li></ul><p>2. 释放锁，获取锁之后就要在使用完之后释放它，否则别的线程都将会因无法获取锁而被阻塞，所以我们一般会在finally中进行锁的释放操作</p><ul><ul><li>可以通过调用<code>ReentrantLock</code>对象的<code>unlock</code>方法来释放锁</li></ul></ul><p>3. 获取条件变量，条件变量是和互斥锁搭配使用的一种非常有用的数据结构，有兴趣的读者可以通过<a href=\"https://zhuanlan.zhihu.com/p/64156753\" class=\"internal\">《从0到1实现自己的阻塞队列(上)》</a>这篇文章来了解条件变量具体的使用方法</p><ul><ul><li>我们可以通过<code>Condition newCondition()</code>方法来获取条件变量对象，然后调用条件变量对象上的<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>方法来进行使用</li></ul></ul><h3>ReentrantLock的内部Sync类</h3><p>在<code>ReentrantLock</code>类中存在两种AQS的子类，一个实现了非公平锁，一个实现了公平锁。所谓的“公平”指的就是获取互斥锁成功返回的时间会和获取锁操作发起的时间顺序一致，例如有线程A已经持有了互斥锁，当线程B、C、D按字母顺序获取锁并进入等待，线程A释放锁后一定是线程B被唤醒，线程B释放锁后一定是C先被唤醒。也就是说锁被释放后对等待线程的唤醒顺序和获取锁操作的顺序一致。而且如果在这个过程中，有其他线程发起了获取锁操作，因为等待队列中已经有线程在等待了，那么这个线程一定要排到等待队列最后去，而不能直接抢占刚刚被释放还未被刚刚被唤醒的线程锁持有的锁。</p><p>下面我们同样先看一下<code>ReentrantLock</code>类中定义的AQS子类<code>Sync</code>的具体源代码。下面是上一段说到的非公平Sync类和公平Sync类两个类的共同父类<code>Sync</code>的带注释源代码，里面包含了大部分核心功能的实现。虽然下面包含了该类完整的源代码，但是我们现在只需要关心三个核心操作，也是我们在独占模式下需要重写的三个AQS方法：<code>tryAcquire</code>、<code>tryRelease</code>和<code>isHeldExclusively</code>。建议在看完文章之后再回来回顾该类中其他的方法实现，直接跳过其他的方法当然也是完全没有问题的。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">abstract</span> <span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">Sync</span> <span class=\"kd\">extends</span> <span class=\"n\">AbstractQueuedSynchronizer</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"n\">serialVersionUID</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">5179523762034025860L</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 实现Lock接口的lock方法，子类化的主要原因是为了非公平版本的快速实现         \n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">abstract</span> <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 执行非公平的tryLock。tryAcquire方法在子类中被实现，但是两者都需要非公平版本的trylock方法实现。\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">nonfairTryAcquire</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">acquires</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">final</span> <span class=\"n\">Thread</span> <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">getState</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 如果锁还未被持有\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 通过CAS尝试获取锁\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">compareAndSetState</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">acquires</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 如果锁获取成功则将锁持有者改为当前线程，并返回true\n</span><span class=\"c1\"></span>                <span class=\"n\">setExclusiveOwnerThread</span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 锁已经被持有，则判断锁的持有者是否是当前线程\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">current</span> <span class=\"o\">==</span> <span class=\"n\">getExclusiveOwnerThread</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 可重入锁，如果锁的持有者是当前线程，那就在state上加上新的获取数\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">nextc</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">acquires</span><span class=\"o\">;</span>\n\n            <span class=\"c1\">// 判断新的state值有没有溢出\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nextc</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"c1\">// overflow\n</span><span class=\"c1\"></span>                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">Error</span><span class=\"o\">(</span><span class=\"s\">&#34;Maximum lock count exceeded&#34;</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 将新的state更新为新的值，因为可以进入这段代码的只有一个线程\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 所以不需要线程安全措施\n</span><span class=\"c1\"></span>            <span class=\"n\">setState</span><span class=\"o\">(</span><span class=\"n\">nextc</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 重写了AQS的独占式释放锁方法\n</span><span class=\"c1\"></span>    <span class=\"kd\">protected</span> <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">tryRelease</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">releases</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 计算剩余的锁持有量\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 因为只有当前线程持有该锁的情况下才能执行这个方法，所以不需要做多线程保护\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">getState</span><span class=\"o\">()</span> <span class=\"o\">-</span> <span class=\"n\">releases</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 如果当前线程未持有锁，则直接抛出错误\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">getExclusiveOwnerThread</span><span class=\"o\">())</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalMonitorStateException</span><span class=\"o\">();</span>\n\n        <span class=\"kt\">boolean</span> <span class=\"n\">free</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 如果锁持有数已经减少到0，则释放该锁，并清空锁持有者\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">free</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"n\">setExclusiveOwnerThread</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 更新state值，只有state值被设置为0才是真正地释放了锁\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 所以setState和setExclusiveOwnerThread之间不需要额外的同步措施\n</span><span class=\"c1\"></span>        <span class=\"n\">setState</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">free</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 当前线程是否持有该锁\n</span><span class=\"c1\"></span>    <span class=\"kd\">protected</span> <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isHeldExclusively</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">getExclusiveOwnerThread</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 创建对应的条件变量\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"n\">ConditionObject</span> <span class=\"nf\">newCondition</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ConditionObject</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 从外层传递进来的方法\n</span><span class=\"c1\"></span>\n    <span class=\"c1\">// 获取当前的锁持有者\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"n\">Thread</span> <span class=\"nf\">getOwner</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">getState</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">?</span> <span class=\"kc\">null</span> <span class=\"o\">:</span> <span class=\"n\">getExclusiveOwnerThread</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 获取锁的持有计数\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果当前线程持有了该锁则返回state值，否则返回0\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">getHoldCount</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">isHeldExclusively</span><span class=\"o\">()</span> <span class=\"o\">?</span> <span class=\"n\">getState</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 判断锁是否已经被持有\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">isLocked</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">getState</span><span class=\"o\">()</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>实际的<code>tryAcquire</code>方法将在公平Sync类与非公平Sync类两个子类中实现，但是这两个子类都需要调用父类<code>Sync</code>中的非公平版本的tryAcquire——<code>nonfairTryAcquire</code>方法。在这个方法中，我们主要做两件事：</p><ol><li>当前锁还未被人持有。在<code>ReentrantLock</code>中使用AQS的state来保存锁的状态，state等于0时代表锁没有被任何线程持有，如果state大于0，那么就代表持有者对该锁的重复获取次数</li></ol><ul><li>如果当前锁还未被线程持有，那么就会通过<code>compareAndSetState</code>来原子性地修改state值，修改成功则需要设置当前线程为锁的持有线程并返回true代表获取成功；否则就返回 </li></ul><p>2. 锁已被当前线程持有</p><ul><ul><li>在锁已被当前线程持有的情况下，就需要将state值加1代表持有者线程对锁的重复获取次数。</li></ul></ul><p>而对于独占式释放同步器的<code>tryRelease</code>方法，则在父类<code>Sync</code>中直接实现了，两个公平/非公平子类调用的都是同一段代码。首先，只有锁的持有者才能释放锁，所以如果当前线程不是所有者线程在释放操作中就会抛出异常。如果释放操作会将持有计数清零，那么当前线程就不再是该锁的持有者了，锁会被完全释放，而锁的所有者会被设置为null。最后，<code>Sync</code>会将减掉入参中的释放数之后的新持有计数更新到AQS的state中，并返回锁是否已经被完全释放了。</p><p><code>isHeldExclusively</code>方法比较简单，它只是检查锁的持有者是否是当前线程。</p><h3>非公平Sync类的实现</h3><p><code>Sync</code>的两个公平/非公平子类的实现比较简单，下面是非公平版本子类的源代码。在非公平版本的实现中，调用<code>lock</code>方法首先会尝试通过CAS修改AQS的state值来直接抢占锁，如果抢占成功就直接将持有者设置为当前线程；如果抢占失败就调用<code>acquire</code>方法走正常流程来获取锁。而在<code>acquire</code>方法中就会调用子类中的<code>tryAcquire</code>方法并进一步调用到上文提到的父类中的<code>nonfairTryAcquire</code>方法来完成锁获取操作。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">NonfairSync</span> <span class=\"kd\">extends</span> <span class=\"n\">Sync</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"n\">serialVersionUID</span> <span class=\"o\">=</span> <span class=\"n\">7316153563782823691L</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 执行锁操作。尝试直接抢占，如果失败的话就回到正常的获取流程进行\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 尝试直接抢占\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">compareAndSetState</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">))</span>\n            <span class=\"c1\">// 抢占成功设置锁所有者\n</span><span class=\"c1\"></span>            <span class=\"n\">setExclusiveOwnerThread</span><span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">());</span>\n        <span class=\"k\">else</span>\n            <span class=\"c1\">// 抢占失败走正常获取流程\n</span><span class=\"c1\"></span>            <span class=\"n\">acquire</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 实现AQS方法，使用nonfairTryAcquire实现\n</span><span class=\"c1\"></span>    <span class=\"kd\">protected</span> <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">tryAcquire</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">acquires</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">nonfairTryAcquire</span><span class=\"o\">(</span><span class=\"n\">acquires</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>公平Sync类的实现</h3><p>而在公平版本的Sync子类<code>FairSync</code>中，为了保证成功获取到锁的顺序一定要和发起获取锁操作的顺序一致，所以自然不能在<code>lock</code>方法中进行CAS方式的抢占，只能老老实实调用<code>acquire</code>方法走正式流程。而<code>acquire</code>方法最终就会调用子类中定义的<code>tryAcquire</code>来真正获取锁。</p><p>在<code>tryAcquire</code>方法中，代码主要处理了两种情况：</p><ol><li>当前锁还没有被线程锁持有</li></ol><ul><li>只有在确保等待队列为空的情况下才能尝试用CAS方式直接抢占锁，而在等待队列不为空的情况下，最后返回了false，之后<code>acquire</code>方法中的代码会将当前线程放入到等待队列中阻塞等待锁的释放。这就保证了在获取锁时已经有线程等待的情况下，任何线程都要进入等待队列去等待获取锁，而不能直接对锁进行获取。 </li></ul><p>2. 当前线程已经持有了该锁</p><ul><ul><li>如果当前线程已经是该锁的持有者了，那么就会在state值上加上本次的获取数量来更新锁的重复获取次数，并返回true代表获取锁成功。</li></ul></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kd\">class</span> <span class=\"nc\">FairSync</span> <span class=\"kd\">extends</span> <span class=\"n\">Sync</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">long</span> <span class=\"n\">serialVersionUID</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">3000897897090466540L</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// 直接使用acquire进行获取锁操作\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"n\">acquire</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 公平版本的tryAcquire方法。不要授予访问权限，除非是递归调用或者没有等待线程或者这是第一个调用\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">protected</span> <span class=\"kd\">final</span> <span class=\"kt\">boolean</span> <span class=\"nf\">tryAcquire</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">acquires</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"kd\">final</span> <span class=\"n\">Thread</span> <span class=\"n\">current</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">getState</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 如果锁没有被持有\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 为了实现公平特性，所以只有在等待队列为空的情况下才能直接抢占\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 否则只能进入队列等待\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">hasQueuedPredecessors</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span>\n                <span class=\"n\">compareAndSetState</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">acquires</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n                <span class=\"n\">setExclusiveOwnerThread</span><span class=\"o\">(</span><span class=\"n\">current</span><span class=\"o\">);</span>\n                <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 如果锁已被持有，且当前线程就是持有线程\n</span><span class=\"c1\"></span>        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">current</span> <span class=\"o\">==</span> <span class=\"n\">getExclusiveOwnerThread</span><span class=\"o\">())</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 计算新的state值\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">nextc</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">acquires</span><span class=\"o\">;</span>\n\n            <span class=\"c1\">// 如果锁计数溢出，则抛出异常\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">nextc</span> <span class=\"o\">&lt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n                <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">Error</span><span class=\"o\">(</span><span class=\"s\">&#34;Maximum lock count exceeded&#34;</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 设置state状态值\n</span><span class=\"c1\"></span>            <span class=\"n\">setState</span><span class=\"o\">(</span><span class=\"n\">nextc</span><span class=\"o\">);</span>\n            <span class=\"k\">return</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n        <span class=\"k\">return</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>ReentrantLock对Sync类对象的使用</h3><p>最后，我们来看看ReentrantLock类中的<code>lock()</code>、<code>unlock()</code>、<code>newCondition</code>方法对Sync类对象的使用方式。</p><p>首先是在构造器中，根据入参指定的公平/非公平模式创建不同的内部<code>Sync</code>类对象，如果是公平模式就是用<code>FairSync</code>类，如果是非公平模式就是用<code>NonfairSync</code>类。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">ReentrantLock</span><span class=\"o\">(</span><span class=\"kt\">boolean</span> <span class=\"n\">fair</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">sync</span> <span class=\"o\">=</span> <span class=\"n\">fair</span> <span class=\"o\">?</span> <span class=\"k\">new</span> <span class=\"n\">FairSync</span><span class=\"o\">()</span> <span class=\"o\">:</span> <span class=\"k\">new</span> <span class=\"n\">NonfairSync</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>然后在互斥锁的锁定方法<code>lock()</code>中，<code>ReentrantLock</code>直接使用Sync类中的<code>lock</code>方法来实现了锁的获取功能。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">lock</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 调用sync对象的lock方法实现\n</span><span class=\"c1\"></span>    <span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>在<code>unlock()</code>方法中也是一样的情况，<code>ReentrantLock</code>直接依赖Sync类对象来实现这个功能。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">unlock</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 调用了sync对象的release方法实现\n</span><span class=\"c1\"></span>    <span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"na\">release</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>最后一个创建条件变量的方法则直接依赖于AQS中定义的方法，我们在<code>ReentranctLock</code>的<code>Sync</code>类中并不需要做任务额外的工作，AQS就能为我们做好所有的事情。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"n\">Condition</span> <span class=\"nf\">newCondition</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 调用了sync对象继承自AQS的`newCondition`方法实现\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"n\">sync</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>通过<code>ReentrantLock</code>的例子我们能够更明显地感受到，这些基于AQS实现同步功能的类中并不需要做太多额外的工作，大多数操作都是通过直接调用<code>Sync</code>类对象上的方法来实现的。只要定义好了继承自AQS的子类<code>Sync</code>，并通过<code>Sync</code>类重写几个AQS的关键方法来指定AQS的行为策略，就可以实现风格迥异的各种同步工具类了。</p><h2>总结</h2><p>在这篇文章中，我们从AQS的基本概念说起，简单介绍了AQS的具体用法，然后通过<code>CountDownLatch</code>和<code>ReentrantLock</code>两个常用的多线程同步工具类的源码来具体了解了AQS的使用方式。我们不仅可以完全弄明白这两个线程同步类的实现原理与细节，而且最重要的是找到了AQS这个幕后大BOSS。通过AQS，我们不仅可以更容易地阅读并理解其他同步工具类的使用与实现，而且甚至可以动手开发出我们自己的自定义同步工具类。</p><p>到了这里，这一系列多线程编程相关的技术文章就接近尾声了。后续我还会发布一篇囊括这个系列所有内容的总结性文章，里面会对多线程编程相关的知识脉络做一次全面的梳理，然后将每个知识点链接到具体阐释这个主题的文章中去。让读者可以在宏观和微观两个层面理解多线程编程的原理与技巧，帮助大家建立完整的Java多线程理论与实践知识体系。有兴趣的读者可以关注一下后续的文章，感谢大家的支持。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619468"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64156910", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 15, 
            "title": "从0到1实现自己的阻塞队列(下)", 
            "content": "<p>在上一篇文章《<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5cc5db6051882524f96d0123\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">从0到1实现自己的阻塞队列(上)</a>》中，我们已经实现了一个可以使用的阻塞队列版本。在这篇文章中，我们可以继续我们的冒险之旅，将我们的阻塞队列提升到接近JDK版本的水平上。</p><h2>更进一步优化效率</h2><p>我们一直使用的都是<code>Object.notifyAll()</code>或者<code>condition.signalAll()</code>这样会唤醒所有线程的方法，那么如果只有一个线程能够顺利执行，但是其他线程都要再次回到等待状态继续休眠，那不是非常的浪费吗？比如如果有N个消费者线程在等待队列中出现元素，那么当一个元素被插入以后所有N个消费者线程都被全部唤醒，最后也只会有一个消费者线程能够真正拿到元素并执行完成，其他线程不是都被白白唤醒了吗？我们为什么不用只会唤醒一个线程的<code>Object.notify()</code>和<code>condition.signal()</code>方法呢？</p><h3>拆分条件变量</h3><p>在阻塞队列中，我们可以使用<code>Object.notify()</code>或者<code>condition.signal()</code>这样只唤醒一个线程的方法，但是会有一些前提条件：</p><ol><li>首先，在一个条件变量上等待的线程必须是同一类型的。比如一个条件变量上只有消费者线程在等待，另一个条件变量上只有生产者线程在等待。这么做的目的就是防止发生我们在插入时想唤醒的是消费者线程，但是唤醒了一个生产者线程，这个生产者线程又因为队列已满又进入了等待状态，这样我们需要唤醒的消费者线程就永远不会被唤醒了。</li><li>另外还有一点就是这个条件变量上等待的线程只能互斥执行，如果N个生产者线程可以同时执行，我们也就不需要一个一个唤醒了，这样反而会让效率降低。当然，在我们的阻塞队列当中，不管是插入还是弹出操作同一时间都只能有一个线程在执行，所以自然就满足这个要求了。</li></ol><p>所以，我们只需要满足第一个要求让不同类型的线程在不同的条件变量上等待就可以了。那么具体要怎么做呢？</p><p>首先，我们自然是要把原来的一个条件变量<code>condition</code>给拆分成两个实例变量<code>notFull</code>和<code>notEmpty</code>，这两个条件变量虽然对应于同一互斥锁，但是两个条件变量的等待和唤醒操作是完全隔离的。这两个条件变量分别代表队列未满和队列非空两个条件，消费者线程因为是被队列为空的情况所阻塞的，所以就应该等待队列非空条件得到满足；而生产者线程因为是被队列已满的情况所阻塞的，自然就要等待队列未满条件的成立。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/** 队列未满的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notFull</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 队列非空的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notEmpty</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span></code></pre></div><p>所以在<code>put()</code>和<code>take()</code>方法中，我们就需要把<code>take()</code>方法中原来的<code>condition.await()</code>修改为等待队列非空条件，即<code>notEmpty.await()</code>；而<code>put()</code>方法中的<code>condition.await()</code>自然是要修改为等待队列未满条件成立，即<code>notFull.await()</code>。既然我们把等待条件变量的语句都改了，那么唤醒的语句也要做同样的修改，<code>put()</code>操作要唤醒等待的消费者线程，所以是<code>notEmpty.signal()</code>；<code>take()</code>操作要唤醒的生产者线程，所以是<code>notFull.signal()</code>。修改完成后的代码如下，大家可以参考一下：</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列未满条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 插入元素后唤醒一个等待队列非空条件成立的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列非空条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 弹出元素后唤醒一个等待队列未满条件成立的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><h3>验证程序的效率</h3><p>既然我们对阻塞队列做了效率上的改进，那么就让我们来实际检验一下吧。我们还是之前已经提供的检验程序，但是不同的是，为了明显地看出效率上的变化，我们需要修改一下程序中的两个变量。首先，我们需要把检验程序中运行的线程数<code>threads</code>增加到400，然后我们需要把每个线程执行的次数改为100次，就像下面这样：</p><div class=\"highlight\"><pre><code class=\"language-java\">        <span class=\"c1\">// 创建400个线程\n</span><span class=\"c1\"></span>        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threads</span> <span class=\"o\">=</span> <span class=\"n\">400</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 每个线程执行100次\n</span><span class=\"c1\"></span>        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"n\">100</span><span class=\"o\">;</span></code></pre></div><p>最后我们分别使用改进前和改进后的版本来执行这个这个阻塞队列，在我的电脑上，改进前的版本耗时为7.80s，改进后的版本耗时为1.35s。看起来我们对阻塞队列的效率做了一个非常大的提升，非常好，那我们还有没有办法再加快一点呢？</p><h2>还能不能更快？</h2><p>在上面的阻塞队列实现中，我们主要使用的就是<code>put()</code>和<code>take()</code>两个操作。而因为有互斥锁<code>ReentrantLock</code>的保护，所以这两个方法在同一时间只能有一个线程调用。也就是说，生产者线程在操作队列时同样会阻塞消费者线程。不过从我们的代码中看，实际上<code>put()</code>方法和<code>take()</code>方法之间需要有互斥锁保护的共享数据访问只发生在入队操作<code>enqueue</code>方法和出队操作<code>dequeue</code>方法之中。在这两个方法里，对于<code>putIndex</code>和<code>takeIndex</code>的访问是完全隔离的，<code>enqueue</code>只使用<code>putIndex</code>，而<code>dequeue</code>只使用<code>takeIndex</code>，那么线程间的竞争性数据就只剩下count了。这样的话，如果我们能解决count的更新问题是不是就可以把锁<code>lock</code>拆分为两个互斥锁，分别让生产者线程和消费者线程使用了呢？这样的话生产者线程在操作时就只会阻塞生产者线程而不会阻塞消费者线程了，消费者线程也是一样的道理。</p><h3>拆分锁</h3><p>这时候就要请出我们很熟悉的一种同步工具<code>CAS</code>了，<code>CAS</code>是一个原子操作，它会接收两个参数，一个是当前值，一个是目标值，如果当前值已经发生了改变，那么就会返回失败，而如果当前值没有变化，就会将这个变量修改为目标值。在Java中，我们一般会通过<code>java.util.concurrent</code>中的<code>AtomicInteger</code>来执行CAS操作。在<code>AtomicInteger</code>类上有原子性的增加与减少方法，每次调用都可以保证对指定的对象进行增加或减少，并且即使有多个线程同时执行这些操作，它们的结果也仍然是正确的。</p><p>首先，为了保证入队和出队操作之间的互斥特性移除后两个方法能够并发执行，那么我们就要保证对count的更新是线程安全的。因此，我们首先需要把实例变量<code>count</code>的类型从<code>int</code>修改为<code>AtomicInteger</code>，而<code>AtomicInteger</code>类就提供了我们需要的原子性的增加与减少接口。</p><div class=\"highlight\"><pre><code class=\"language-text\">/** 队列中的元素总数 */\n    private AtomicInteger count = new AtomicInteger(0);</code></pre></div><p>然后对应地，我们需要将入队方法中的<code>count++</code>和出队方法中的<code>count--</code>分别改为<code>Atomic</code>原子性的加1方法<code>getAndIncrement</code>与减1方法<code>getAndDecrement</code>。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 入队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">enqueue</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 将对象e放入putIndex指向的位置\n</span><span class=\"c1\"></span>        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">putIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// putIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">putIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">putIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 增加元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndIncrement</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 出队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Object</span> <span class=\"nf\">dequeue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 取出takeIndex指向位置中的元素\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将该位置清空\n</span><span class=\"c1\"></span>        <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">];</span>\n        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// takeIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">takeIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">takeIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 减少元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndDecrement</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 返回之前代码中取出的元素e\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>到这里，我们就已经解决了<code>put()</code>和<code>take()</code>方法之间的数据竞争问题，两个方法现在就可以分别用两个锁来控制了。虽然相同类型的线程仍然是互斥的，例如生产者和生产者之间同一时间只能有一个生产者线程在操作队列。但是在生产者线程和消费者线程之间将不用再继续互斥，一个生产者线程和一个消费者线程可以在同一时间操作同一阻塞队列了。所以，我们在这里可以将互斥锁<code>lock</code>拆为两个，分别保证生产者线程和消费者线程的互斥性，我们将它们命名为插入锁<code>putLock</code>和弹出锁<code>takeLock</code>。同时，原来的条件变量也要分别对应于不同的互斥锁了，<code>notFull</code>要对应于<code>putLock</code>，因为插入元素的生产者线程需要等待队列未满条件，那么<code>notEmpyt</code>自然就要对应于<code>takeLock</code>了。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/** 插入锁 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">putLock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 队列未满的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notFull</span> <span class=\"o\">=</span> <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 弹出锁 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">takeLock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 队列非空的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notEmpty</span> <span class=\"o\">=</span> <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span></code></pre></div><p>最后我们要对<code>put()</code>和<code>take()</code>方法中的<code>signal()</code>调用做出一些调整。因为在上文中提到的，在使用条件变量时一定要先持有条件变量所对应的互斥锁，而在<code>put()</code>和<code>take()</code>方法中，使用<code>signal()</code>方法唤醒的都是另一种类型的线程，例如生产者线程唤醒消费者，消费者线程唤醒生产者。这样我们调用<code>signal()</code>方法的条件变量就和try语句中持有的锁不一致了，所以我们必须将直接的<code>xxx.signal()</code>调用替换为一个私有方法调用。而在私有方法中，我们会先获取与条件变量对应的锁，然后再调用条件变量的<code>signal()</code>方法。比如在下面的<code>signalNotEmpty()</code>方法中，我们就要先获取<code>takeLock</code>才能调用<code>notEmpty.signal()</code>；而在<code>signalNotFull()</code>方法中，我们就要先获取<code>putLock</code>才能调用<code>notFull.signal()</code>。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 唤醒等待队列非空条件的线程\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">signalNotEmpty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 为了唤醒等待队列非空条件的线程，需要先获取对应的takeLock\n</span><span class=\"c1\"></span>        <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 唤醒一个等待非空条件的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 唤醒等待队列未满条件的线程\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">signalNotFull</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 为了唤醒等待队列未满条件的线程，需要先获取对应的putLock\n</span><span class=\"c1\"></span>        <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 唤醒一个等待队列未满条件的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><h3>解决死锁问题</h3><p>但直接把<code>notFull.signal()</code>换成<code>signalNotFull()</code>，把<code>notEmpty.signal()</code>换成<code>signalNotEmpty()</code>还不够，因为在我们的代码中，原来的<code>notFull.signal()</code>和<code>notEmpty.signal()</code>都是在持有锁的try语句块当中的。一旦我们做了调用私有方法的替换，那么<code>put()</code>和<code>take()</code>方法就会以相反的顺序同时获取<code>putLock</code>和<code>takeLock</code>两个锁。有一些读者可能已经意识到这样会产生死锁问题了，那么我们应该怎么解决它呢？</p><p>最好的方法就是不要同时加两个锁，我们完全可以在释放前一个之后再使用<code>signal()</code>方法来唤醒另一种类型的线程。就像下面的<code>put()</code>与<code>take()</code>方法中所做的一样，我们可以在执行完入队操作之后就释放插入锁<code>putLock</code>，然后才运行<code>signalNotEmpty()</code>方法去获取<code>takeLock</code>并调用与其对应的条件变量<code>notEmpty</code>的<code>signal()</code>方法，在<code>take()</code>方法中也是一样的道理。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列未满条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 唤醒等待队列非空条件的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放putLock之前获取takeLock\n</span><span class=\"c1\"></span>        <span class=\"n\">signalNotEmpty</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列非空条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 唤醒等待队列未满条件的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放takeLock之前获取putLock\n</span><span class=\"c1\"></span>        <span class=\"n\">signalNotFull</span><span class=\"o\">();</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>到了这里我们就顺利地把原来单一的一个<code>lock</code>锁拆分为了插入锁<code>putLock</code>和<code>takeLock</code>，这样生产者线程和消费者线程就可以同时运行了。</p><h3>最后的细节优化——优化唤醒其他线程的效率</h3><p>啊？我们的阻塞队列到了这里还能再继续优化吗？其实我们做的优化已经足够多了，基本上影响比较大的优化我们都做了，但是还有一些细节是可以最后完善一下的。比如说如果队列并没有为空或者已满时，我们插入或者弹出了元素其实都是不需要唤醒任何线程的，多余的唤醒操作需要先获取<code>ReentrantLock</code>锁才能调用对应的条件变量的<code>signal()</code>方法，而获取锁是一个成本比较大的操作。所以我们最好是能在队列真的为空或者已满以后，成功插入或弹出元素时，再去获取锁并唤醒等待的线程。</p><p>也就是说我们会将<code>signalNotEmpty();</code>修改为<code>if (c ==  0) signalNotEmpty();</code>，而把<code>signalNotFull();</code>修改为<code>if (c == items.length) signalNotFull();</code>，也就是只有在必要的时候才去唤醒另一种类型的线程。但是这种修改又会引入另外一种问题，例如有N个消费者线程在等待队列非空，这时有两个生产者线程插入了两个元素，但是这两个插入操作是连续发生的，也就是说只有第一个生产者线程在插入元素之后调用了<code>signalNotEmpty()</code>，第二个线程看到队列原本是非空的就不会调用唤醒方法。在这种情况下，实际就只有一个消费者线程被唤醒了，而实际上队列中还有一个元素可供消费。那么我们如何解决这个问题呢？</p><p>比较简单的一种方法就是，生产者线程和消费者线程不止会唤醒另一种类型的线程，而且也会唤醒同类型的线程。比如在生产者线程中如果插入元素之后发现队列还未满，那么就可以调用<code>notFull.signal()</code>方法来唤醒其他可能存在的等待状态的生产者线程，对于消费者线程所使用的<code>take()</code>方法也是类似的处理方式。相对来说signal方法较低，而互斥锁的lock方法成本较高，而且会影响到另一种类型线程的运行。所以通过这种方式尽可能地少调用<code>signalNotEmpty()</code>和<code>signalNotFull()</code>方法会是一种还不错的优化手段。</p><p>优化后的<code>put()</code>和<code>take()</code>方法如下：</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列未满条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 增加元素总数\n</span><span class=\"c1\"></span>            <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndIncrement</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果在插入后队列仍然没满，则唤醒其他等待插入的线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">1</span> <span class=\"o\">&lt;</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 如果插入之前队列为空，才唤醒等待弹出元素的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放putLock之前获取takeLock\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">signalNotEmpty</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列非空条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 减少元素总数\n</span><span class=\"c1\"></span>            <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndDecrement</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果队列在弹出一个元素后仍然非空，则唤醒其他等待队列非空的线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">-</span> <span class=\"n\">1</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 只有在弹出之前队列已满的情况下才唤醒等待插入元素的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放takeLock之前获取putLock\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">signalNotFull</span><span class=\"o\">();</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><h2>成品出炉！</h2><p>恭喜大家，经过一番漫长的探索，我们终于彻底完成了我们的阻塞队列实现之旅。如果你能坚持到这里，我相信你已经对多线程编程的实践方法有了非常深刻的理解。最后让我们来看一看我们最终完成的成品代码——一个完整的阻塞队列实现吧。</p><h3>完整的阻塞队列代码</h3><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BlockingQueue</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/** 存放元素的数组 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">items</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 弹出元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">takeIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 插入元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">putIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 队列中的元素总数 */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\n    <span class=\"cm\">/** 插入锁 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">putLock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 队列未满的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notFull</span> <span class=\"o\">=</span> <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 弹出锁 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">takeLock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 队列非空的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">notEmpty</span> <span class=\"o\">=</span> <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 指定队列大小的构造器\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param capacity  队列大小\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">BlockingQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">capacity</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">();</span>\n        <span class=\"n\">items</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">capacity</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 入队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">enqueue</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 将对象e放入putIndex指向的位置\n</span><span class=\"c1\"></span>        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">putIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// putIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">putIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">putIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 出队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Object</span> <span class=\"nf\">dequeue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 取出takeIndex指向位置中的元素\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将该位置清空\n</span><span class=\"c1\"></span>        <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">];</span>\n        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// takeIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">takeIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">takeIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 返回之前代码中取出的元素e\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列未满条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 增加元素总数\n</span><span class=\"c1\"></span>            <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndIncrement</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果在插入后队列仍然没满，则唤醒其他等待插入的线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">+</span> <span class=\"n\">1</span> <span class=\"o\">&lt;</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n                <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 如果插入之前队列为空，才唤醒等待弹出元素的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放putLock之前获取takeLock\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"n\">signalNotEmpty</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 唤醒等待队列非空条件的线程\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">signalNotEmpty</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 为了唤醒等待队列非空条件的线程，需要先获取对应的takeLock\n</span><span class=\"c1\"></span>        <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 唤醒一个等待非空条件的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span><span class=\"o\">;</span>\n        <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">()</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 等待队列非空条件得到满足\n</span><span class=\"c1\"></span>                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 减少元素总数\n</span><span class=\"c1\"></span>            <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">getAndDecrement</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果队列在弹出一个元素后仍然非空，则唤醒其他等待队列非空的线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">-</span> <span class=\"n\">1</span> <span class=\"o\">&gt;</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n                <span class=\"n\">notEmpty</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">takeLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 只有在弹出之前队列已满的情况下才唤醒等待插入元素的线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 为了防止死锁，不能在释放takeLock之前获取putLock\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">signalNotFull</span><span class=\"o\">();</span>\n\n        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 唤醒等待队列未满条件的线程\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">signalNotFull</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 为了唤醒等待队列未满条件的线程，需要先获取对应的putLock\n</span><span class=\"c1\"></span>        <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 唤醒一个等待队列未满条件的线程\n</span><span class=\"c1\"></span>            <span class=\"n\">notFull</span><span class=\"o\">.</span><span class=\"na\">signal</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">putLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>有兴趣的读者可以把我们完成的这个阻塞队列类和JDK中的<code>java.util.concurrent.LinkedBlockingQueue</code>类做一个比较，相信大家可以发现这两个类非常的相似，这足以说明我们费劲千辛万苦实现的这个阻塞队列类已经非常接近JDK中的阻塞队列类的质量了。</p><h2>总结</h2><p>恭喜大家终于完整地读完了这篇文章！在这篇文章中，我们从一个最简单的阻塞队列版本开始，一路解决了各种问题，最终得到了一个完整、高质量的阻塞队列实现。我们一起来回忆一下我们解决的问题吧。从最简单的阻塞队列开始，我们首先用互斥锁<code>synchronized</code>关键字解决了并发控制问题，保证了队列在多线程访问情况下的正确性。然后我们用条件变量<code>Object.wati()</code>、<code>Object.notifyAll()</code>解决了休眠唤醒问题，使队列的效率得到了飞跃性地提高。为了保障队列的安全性，不让外部代码可以访问到我们所使用的对象锁和条件变量，所以我们使用了显式锁<code>ReentrantLock</code>，并通过锁对象<code>lock</code>的<code>newCondition()</code>方法创建了与其相对应的条件变量对象。最后，我们对队列中的条件变量和互斥锁分别做了拆分，使队列的效率得到了进一步的提高。当然，最后我们还加上了一点对唤醒操作的有条件调用优化，使整个阻塞队列的实现变得更加完善。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }
            ], 
            "comments": [
                {
                    "userName": "威威虎", 
                    "userLink": "https://www.zhihu.com/people/c9bef399ccbee20faaa40fbb749f3f0b", 
                    "content": "确实很不错", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "Cocan", 
                    "userLink": "https://www.zhihu.com/people/d5becdaf963f1f468a14839620ee6bde", 
                    "content": "<p>ReentrantLock太灵活了，总感觉没synchronized什么事了</p><a class=\"comment_sticker\" href=\"https://pic4.zhimg.com/v2-fa3cb6bc9ec57da84ab53a60f48d0c6f.gif\" data-width=\"\" data-height=\"\">[棒]</a>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/64156753", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 16, 
            "title": "从0到1实现自己的阻塞队列(上)", 
            "content": "<p>阻塞队列不止是一道热门的面试题，同时也是许多并发处理模型的基础，比如常用的线程池类<code>ThreadPoolExecutor</code>内部就使用了阻塞队列来保存等待被处理的任务。而且在大多数经典的多线程编程资料中，阻塞队列都是其中非常重要的一个实践案例。甚至可以说只有自己动手实现了一个阻塞队列才能真正掌握多线程相关的API。</p><p>在这篇文章中，我们会从一个最简单的原型开始一步一步完善为一个类似于JDK中阻塞队列实现的真正实用的阻塞队列。在这个过程中，我们会一路涉及<code>synchronized</code>关键字、条件变量、显式锁<code>ReentrantLock</code>等等多线程编程的关键技术，最终掌握Java多线程编程的完整理论和实践知识。</p><p>阅读本文需要了解基本的多线程编程概念与互斥锁的使用，还不了解的读者可以参考一下这篇文章《<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5cacb4c16fb9a068b36776ed\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">多线程中那些看不见的陷阱</a>》中到ReentrantLock部分为止的内容。</p><h2>什么是阻塞队列？</h2><p><b>阻塞队列</b>是这样的一种数据结构，它是一个队列（类似于一个List），可以存放0到N个元素。我们可以对这个队列执行插入或弹出元素操作，弹出元素操作就是获取队列中的第一个元素，并且将其从队列中移除；而插入操作就是将元素添加到队列的末尾。当队列中没有元素时，对这个队列的弹出操作将会被阻塞，直到有元素被插入时才会被唤醒；当队列已满时，对这个队列的插入操作就会被阻塞，直到有元素被弹出后才会被唤醒。</p><p>在线程池中，往往就会用阻塞队列来保存那些暂时没有空闲线程可以直接执行的任务，等到线程空闲之后再从阻塞队列中弹出任务来执行。一旦队列为空，那么线程就会被阻塞，直到有新任务被插入为止。</p><h2>一个最简单的版本</h2><h3>代码实现</h3><p>我们先来实现一个最简单的队列，在这个队列中我们不会添加任何线程同步措施，而只是实现了最基本的队列与阻塞特性。 那么首先，一个队列可以存放一定量的元素，而且可以执行插入元素和弹出元素的操作。然后因为这个队列还是一个阻塞队列，那么在队列为空时，弹出元素的操作将会被阻塞，直到队列中被插入新的元素可供弹出为止；而在队列已满的情况下，插入元素的操作将会被阻塞，直到队列中有元素被弹出为止。</p><p>下面我们会将这个最初的阻塞队列实现类拆解为独立的几块分别讲解和实现，到最后就能拼装出一个完整的阻塞队列类了。为了在阻塞队列中保存元素，我们首先要定义一个数组来保存元素，也就是下面代码中的<code>items</code>字段了，这是一个Object数组，所以可以保存任意类型的对象。在最后的构造器中，会传入一个<code>capacity</code>参数来指定<code>items</code>数组的大小，这个值也就是我们的阻塞队列的大小了。</p><p>而<code>takeIndex</code>和<code>putIndex</code>就是我们插入和弹出元素的下标位置了，为什么要分别用两个整型来保存这样的位置呢？因为阻塞队列在使用的过程中会不断地被插入和弹出元素，所以可以认为元素在数组中是像贪吃蛇一样一步一步往前移动的，每次弹出的都是队列中的第一个元素，而插入的元素则会被添加到队列的末尾。当下标到达末尾时会被设置为0，从数组的第一个下标位置重新开始向后增长，形成一个不断循环的过程。</p><p>那么如果队列中存储的个数超过<code>items</code>数组的长度时，新插入的元素岂不是会覆盖队列开头还没有被弹出的元素了吗？这时我们的最后一个字段<code>count</code>就能派上用场了，当<code>count</code>等于<code>items.length</code>时，插入操作就会被阻塞，直到队列中有元素被弹出时为止。那么这种阻塞是如何实现的呢？我们接下来来看一下<code>put()</code>方法如何实现。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/** 存放元素的数组 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">items</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 弹出元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">takeIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 插入元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">putIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 队列中的元素总数 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 指定队列大小的构造器\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param capacity  队列大小\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">BlockingQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">capacity</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">();</span>\n        <span class=\"c1\">// putIndex, takeIndex和count都会被默认初始化为0\n</span><span class=\"c1\"></span>        <span class=\"n\">items</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">capacity</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span></code></pre></div><p>下面是<code>put()</code>和<code>take()</code>方法的实现，<code>put()</code>方法向队列末尾添加新元素，而<code>take()</code>方法从队列中弹出最前面的一个元素，我们首先来看一下我们目前最关心的<code>put()</code>方法。在<code>put()</code>方法的开头，我们可以看到有一个判断count是否达到了items.length（队列大小）的if语句，如果count不等于items.length，那么就表示队列还没有满，随后就直接调用了<code>enqueue</code>方法对元素进行了入队。<code>enqueue</code>方法的实现会在稍后介绍，这里我们只需要知道这个入队方法会将元素放入到队列中并对count加1就可以了。在成功插入元素之后我们就会通过<code>break</code>语句跳出最外层的无限while循环，从方法中返回。</p><p>但是如果这时候队列已满，那么count的值就会等于items.length，这将会导致我们调用<code>Thread.sleep(200L)</code>使当前线程休眠200毫秒。当线程从休眠中恢复时，又会进入下一次循环，重新判断条件<code>count != items.length</code>。也就是说，如果队列没有弹出元素使我们可以完成插入操作，那么线程就会一直处于“判断 -&gt; 休眠”的循环而无法从<code>put()</code>方法中返回，也就是进入了“阻塞”状态。</p><p>随后的<code>take()</code>方法也是一样的道理，只有在队列不为空的情况下才能顺利弹出元素完成任务并返回，如果队列一直为空，调用线程就会在循环中一直等待，直到队列中有元素插入为止。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 直到队列未满时才执行入队操作并跳出循环\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>                <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列已满的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 直到队列非空时才继续执行后续的出队操作并返回弹出的元素\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>                <span class=\"k\">return</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列为空的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>在上面的<code>put()</code>和<code>take()</code>方法中分别调用了入队方法<code>enqueue</code>和出队方法<code>dequeue</code>，那么这两个方法到底需要如何实现呢？下面是这两个方法的源代码，我们可以看到，在入队方法<code>enqueue()</code>中，总共有三步操作：</p><ol><li>首先把指定的对象e保存到<code>items[putIndex]</code>中，<code>putIndex</code>指示的就是我们插入元素的位置。</li><li>之后，我们会将putIndex向后移一位，来确定下一次插入元素的下标位置，如果已经到了队列末尾我们就会把<code>putIndex</code>设置为0，回到队列的开头。</li><li>最后，入队操作会将count值加1，让count值和队列中的元素个数一致。</li></ol><p>而出队方法<code>dequeue</code>中执行的操作则与入队方法<code>enqueue</code>相反。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 入队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">enqueue</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 将对象e放入putIndex指向的位置\n</span><span class=\"c1\"></span>        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">putIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// putIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">putIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">putIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 增加元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 出队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Object</span> <span class=\"nf\">dequeue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 取出takeIndex指向位置中的元素\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将该位置清空\n</span><span class=\"c1\"></span>        <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">];</span>\n        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// takeIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">takeIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">takeIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 减少元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">--;</span>\n\n        <span class=\"c1\">// 返回之前代码中取出的元素e\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span></code></pre></div><p>到这里我们就可以将这个三个模块拼接为一个完整的阻塞队列类<code>BlockingQueue</code>了。完整的代码如下，大家可以拷贝到IDE中，或者自己重新实现一遍，然后我们就可以开始上手用一用我们刚刚完成的阻塞队列了。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BlockingQueue</span> <span class=\"o\">{</span>\n\n    <span class=\"cm\">/** 存放元素的数组 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Object</span><span class=\"o\">[]</span> <span class=\"n\">items</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 弹出元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">takeIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 插入元素的位置 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">putIndex</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/** 队列中的元素总数 */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span><span class=\"o\">;</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 指定队列大小的构造器\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param capacity  队列大小\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"nf\">BlockingQueue</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">capacity</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">capacity</span> <span class=\"o\">&lt;=</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">IllegalArgumentException</span><span class=\"o\">();</span>\n        <span class=\"n\">items</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Object</span><span class=\"o\">[</span><span class=\"n\">capacity</span><span class=\"o\">];</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 入队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">enqueue</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 将对象e放入putIndex指向的位置\n</span><span class=\"c1\"></span>        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">putIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// putIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">putIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">putIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 增加元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">++;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 出队操作\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">private</span> <span class=\"n\">Object</span> <span class=\"nf\">dequeue</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 取出takeIndex指向位置中的元素\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将该位置清空\n</span><span class=\"c1\"></span>        <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">];</span>\n        <span class=\"n\">items</span><span class=\"o\">[</span><span class=\"n\">takeIndex</span><span class=\"o\">]</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// takeIndex向后移一位，如果已到末尾则返回队列开头(位置0)\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(++</span><span class=\"n\">takeIndex</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span>\n            <span class=\"n\">takeIndex</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 减少元素总数\n</span><span class=\"c1\"></span>        <span class=\"n\">count</span><span class=\"o\">--;</span>\n\n        <span class=\"c1\">// 返回之前代码中取出的元素e\n</span><span class=\"c1\"></span>        <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 直到队列未满时才执行入队操作并跳出循环\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>                <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n                <span class=\"k\">break</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列已满的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 直到队列非空时才继续执行后续的出队操作并返回弹出的元素\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>                <span class=\"k\">return</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列为空的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><h3>测验阻塞队列实现</h3><p>既然已经有了阻塞队列的实现，那么我们就写一个测试程序来测试一下吧。下面是一个对阻塞队列进行并发的插入和弹出操作的测试程序，在这个程序中，会创建2个生产者线程向阻塞队列中插入数字0~19；同时也会创建2个消费者线程从阻塞队列中弹出20个数字，并打印这些数字。而且在程序中也统计了整个程序的耗时，会在所有子线程执行完成之后打印出程序的总耗时。</p><p>这里我们期望这个测验程序能够以任意顺序输出0~19这20个数字，然后打印出程序的总耗时，那么实际执行情况会如何呢？</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">BlockingQueueTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n\n        <span class=\"c1\">// 创建一个大小为2的阻塞队列\n</span><span class=\"c1\"></span>        <span class=\"kd\">final</span> <span class=\"n\">BlockingQueue</span> <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BlockingQueue</span><span class=\"o\">(</span><span class=\"n\">2</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 创建2个线程\n</span><span class=\"c1\"></span>        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">threads</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 每个线程执行10次\n</span><span class=\"c1\"></span>        <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">times</span> <span class=\"o\">=</span> <span class=\"n\">10</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 线程列表，用于等待所有线程完成\n</span><span class=\"c1\"></span>        <span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">Thread</span><span class=\"o\">&gt;</span> <span class=\"n\">threadList</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ArrayList</span><span class=\"o\">&lt;&gt;(</span><span class=\"n\">threads</span> <span class=\"o\">*</span> <span class=\"n\">2</span><span class=\"o\">);</span>\n        <span class=\"kt\">long</span> <span class=\"n\">startTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 创建2个生产者线程，向队列中并发放入数字0到19，每个线程放入10个数字\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">threads</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">offset</span> <span class=\"o\">=</span> <span class=\"n\">i</span> <span class=\"o\">*</span> <span class=\"n\">times</span><span class=\"o\">;</span>\n            <span class=\"n\">Thread</span> <span class=\"n\">producer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">times</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"na\">put</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Integer</span><span class=\"o\">(</span><span class=\"n\">offset</span> <span class=\"o\">+</span> <span class=\"n\">j</span><span class=\"o\">));</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">});</span>\n\n            <span class=\"n\">threadList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">producer</span><span class=\"o\">);</span>\n            <span class=\"n\">producer</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 创建2个消费者线程，从队列中弹出20次数字并打印弹出的数字\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">threads</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">Thread</span> <span class=\"n\">consumer</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(()</span> <span class=\"o\">-&gt;</span> <span class=\"o\">{</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">times</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">j</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">Integer</span> <span class=\"n\">element</span> <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">Integer</span><span class=\"o\">)</span> <span class=\"n\">q</span><span class=\"o\">.</span><span class=\"na\">take</span><span class=\"o\">();</span>\n                        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">element</span><span class=\"o\">);</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Exception</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">e</span><span class=\"o\">.</span><span class=\"na\">printStackTrace</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">});</span>\n\n            <span class=\"n\">threadList</span><span class=\"o\">.</span><span class=\"na\">add</span><span class=\"o\">(</span><span class=\"n\">consumer</span><span class=\"o\">);</span>\n            <span class=\"n\">consumer</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 等待所有线程执行完成\n</span><span class=\"c1\"></span>        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"n\">Thread</span> <span class=\"n\">thread</span> <span class=\"o\">:</span> <span class=\"n\">threadList</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">thread</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 打印运行耗时\n</span><span class=\"c1\"></span>        <span class=\"kt\">long</span> <span class=\"n\">endTime</span> <span class=\"o\">=</span> <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">currentTimeMillis</span><span class=\"o\">();</span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;总耗时：%.2fs&#34;</span><span class=\"o\">,</span> <span class=\"o\">(</span><span class=\"n\">endTime</span> <span class=\"o\">-</span> <span class=\"n\">startTime</span><span class=\"o\">)</span> <span class=\"o\">/</span> <span class=\"n\">1e3</span><span class=\"o\">));</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>在我的电脑上运行这段程序的输出为：</p><div class=\"highlight\"><pre><code class=\"language-text\">0\n1\n2\n3\n4\n5\nnull\n10\n8\n7\n14\n9\n16\n15\n18\n17\nnull</code></pre></div><p>不仅是打印出了很多个<code>null</code>，而且打印出17行之后就不再打印更多数据，而且程序也就一直没有打印总耗时并结束了。为什么会发生这种情况呢？</p><p>原因就是在我们实现的这个阻塞队列中完全没有线程同步机制，所以同时并发进行的4个线程（2个生产者和2个消费者）会同时执行阻塞队列的<code>put()</code>和<code>take()</code>方法。这就可能会导致各种各样并发执行顺序导致的问题，比如两个生产者同时对阻塞队列进行插入操作，有可能就会在putIndex没更新的情况下对同一下标位置又插入了一次数据，导致了数据还没被消费就被覆盖了；而两个消费者也可能会在takeIndex没更新的情况下又获取了一次已经被清空的位置，导致打印出了<code>null</code>。最后因为这些原因都有可能会导致消费者线程最后还没有弹出20个数字count就已经为0了，这时消费者线程就会一直处于阻塞状态无法退出了。</p><p>那么我们应该如何给阻塞队列加上线程同步措施，使它的运行不会发生错误呢？</p><h2>一个线程安全的版本</h2><h3>使用互斥锁来保护队列操作</h3><p>之前碰到的并发问题的核心就是多个线程同时对阻塞队列进行插入或弹出操作，那么我们有没有办法让同一时间只能有一个线程对阻塞队列进行操作呢？</p><p>也许很多读者已经想到了，我们最常用的一种并发控制方式就是<code>synchronized</code>关键字。通过<code>synchronized</code>，我们可以让一段代码同一时间只能有一个线程进入；如果在同一个对象上通过<code>synchronized</code>加锁，那么<code>put()</code>和<code>take()</code>两个方法可以做到同一时间只能有一个线程调用两个方法中的任意一个。比如如果有一个线程调用了<code>put()</code>方法插入元素，那么其他线程再调用<code>put()</code>方法或者<code>take()</code>就都会被阻塞直到前一个线程完成对<code>put()</code>方法的调用了。</p><p>在这里，我们只修改<code>put()</code>和<code>take()</code>方法，把这两个方法中对<code>enqueue</code>和<code>dequeue</code>的调用都包装到一个<code>synchronized (this) {...}</code>的语句块中，保证了同一时间只能有一个线程进入这两个语句块中的任意一个。如果对<code>synchronized</code>之类的线程同步机制还不熟悉的读者，建议先看一下这篇介绍多线程同步机制的文章《<a href=\"https://zhuanlan.zhihu.com/p/61904135\" class=\"internal\">多线程中那些看不见的陷阱</a>》再继续阅读之后的内容，相信会有事半功倍的效果。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 直到队列未满时才执行入队操作并跳出循环\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>                    <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n                    <span class=\"k\">break</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列已满的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"kc\">true</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 直到队列非空时才继续执行后续的出队操作并返回弹出的元素\n</span><span class=\"c1\"></span>                <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">!=</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>                    <span class=\"k\">return</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 队列为空的情况下休眠200ms\n</span><span class=\"c1\"></span>            <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">sleep</span><span class=\"o\">(</span><span class=\"n\">200L</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><h3>再次测试</h3><p>我们再来试一试这个新的阻塞队列实现，在我的电脑上测试程序的输出如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">0\n1\n2\n3\n10\n11\n4\n5\n6\n12\n13\n14\n15\n7\n8\n9\n16\n17\n18\n19\n总耗时：1.81s</code></pre></div><p>这下看起来结果就对了，而且多跑了几次也都能稳定输出所有0~19的20个数字。看起来非常棒，我们成功了，来给自己鼓个掌吧！</p><p>但是仔细那么一看，好像最后的耗时是不是有一些高了？虽然“1.81秒”也不是太长的时间，但是好像一般计算机程序做这么一点事情只要一眨眼的功夫就能完成才对呀。为什么这个阻塞队列会这么慢呢？</p><h2>一个更快的阻塞队列</h2><p>让我们先来诊断一下之前的阻塞队列中到底是什么导致了效率的降低，因为<code>put()</code>和<code>take()</code>方法是阻塞队列的核心，所以我们自然从这两个方法看起。在这两个方法里，我们都看到了同一段代码<code>Thread.sleep(200L)</code>，这段代码会让<code>put()</code>和<code>take()</code>方法分别在队列已满和队列为空的情况下进入一次固定的200毫秒的休眠，防止线程占用过多的CPU资源。但是如果队列在这200毫秒里发生了变化，那么线程也还是在休眠状态无法马上对变化做出响应。比如如果一个调用<code>put()</code>方法的线程因为队列已满而进入了200毫秒的休眠，那么即使队列已经被消费者线程清空了，它也仍然会忠实地等到200毫秒之后才会重新尝试向队列中插入元素，中间的这些时间就都被浪费了。</p><p>但是如果我们去掉这段休眠的代码，又会导致CPU的使用率过高的问题。那么有没有一种方法可以平衡两者的利弊，同时得到两种情况的好处又没有各自的缺点呢？</p><h3>使用条件变量优化阻塞唤醒</h3><p>为了完成上面这个困难的任务，既要马儿跑又要马儿不吃草。那么我们就需要有一种方法，既让线程进入休眠状态不再占用CPU，但是在队列发生改变时又能及时地被唤醒来重试之前的操作了。既然用了对象锁<code>synchronized</code>，那么我们就找找有没有与之相搭配的同步机制可以实现我们的目标。</p><p>在<code>Object</code>类，也就是所有Java类的基类里，我们找到了三个有意思的方法<code>Object.wait()</code>、<code>Object.notify()</code>、<code>Object.notifyAll()</code>。这三个方法是需要搭配在一起使用的，其功能与操作系统层面的<b>条件变量</b>类似。条件变量是这样的一种线程同步工具：</p><ol><li>每个条件变量都会有一个对应的互斥锁，要调用条件变量的<code>wait()</code>方法，首先需要持有条件变量对应的这个互斥锁。之后，在调用条件变量的<code>wait()</code>方法时，首先会释放已持有的这个互斥锁，然后当前线程进入休眠状态，等待被<code>Object.notify()</code>或者<code>Object.notifyAll()</code>方法唤醒；</li><li>调用<code>Object.notify()</code>或者<code>Object.notifyAll()</code>方法可以唤醒因为<code>Object.wait()</code>进入休眠状态的线程，区别是<code>Object.notify()</code>方法只会唤醒一个线程，而<code>Object.notifyAll()</code>会唤醒所有线程。</li></ol><p>因为我们之前的代码中通过<code>synchronized</code>获取了对应于<code>this引用</code>的对象锁，所以自然也就要用<code>this.wait()</code>、<code>this.notify()</code>、<code>this.notifyAll()</code>方法来使用与这个对象锁对应的条件变量了。下面是使用条件变量改造后的<code>put()</code>与<code>take()</code>方法。还是和之前一样，我们首先以<code>put()</code>方法为例分析具体的改动。首先，我们去掉了最外层的while循环，然后我们把<code>Thread.sleep</code>替换为了<code>this.wait()</code>，以此在队列已满时进入休眠状态，等待队列中的元素被弹出后再继续。在队列满足条件，入队操作成功后，我们通过调用<code>this.notifyAll()</code>唤醒了可能在等待队列非空条件的调用<code>take()</code>的线程。<code>take()</code>方法的实现与<code>put()</code>也基本类似，只是操作相反。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">wait</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 唤醒所有休眠等待的进程\n</span><span class=\"c1\"></span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">notifyAll</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">wait</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 唤醒所有休眠等待的进程\n</span><span class=\"c1\"></span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">notifyAll</span><span class=\"o\">();</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>但是我们在测试程序运行之后发现结果好像又出现了问题，在我电脑上的输出如下：</p><div class=\"highlight\"><pre><code class=\"language-text\">0\n19\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n18\nnull\nnull\nnull\nnull\nnull\nnull\nnull\nnull\n总耗时：0.10s</code></pre></div><p>虽然我们解决了耗时问题，现在的耗时已经只有0.10s了，但是结果中又出现了大量的<code>null</code>，我们的阻塞队列好像又出现了正确性问题。那么问题出在哪呢？建议读者可以先自己尝试分析一下，这样有助于大家积累解决多线程并发问题的能力。</p><h3>while循环判断条件是否满足</h3><p>经过分析，我们看到，在调用<code>this.wait()</code>后，如果线程被<code>this.notifyAll()</code>方法唤醒，那么就会直接开始直接入队/出队操作，而不会再次检查count的值是否满足条件。而在我们的程序中，当队列为空时，可能会有很多消费者线程在等待插入元素。此时，如果有一个生产者线程插入了一个元素并调用了<code>this.notifyAll()</code>，则所有消费者线程都会被唤醒，然后依次执行出队操作，那么第一个消费者线程之后的所有线程拿到的都将是null值。而且同时，在这种情况下，每一个执行完出队操作的消费者线程也同样会调用<code>this.notifyAll()</code>方法，这样即使队列中已经没有元素了，后续进入等待的消费者线程仍然会被自己的同类所唤醒，消费根本不存在的元素，最终只能返回<code>null</code>。</p><p>所以要解决这个问题，核心就是在线程从<code>this.wait()</code>中被唤醒时也仍然要重新检查一遍count值是否满足要求，如果count不满足要求，那么当前线程仍然调用<code>this.wait()</code>回到等待状态当中去继续休眠。而我们是没办法预知程序在第几次判断条件时可以得到满足条件的count值从而继续执行的，所以我们必须让程序循环执行“判断条件 -&gt; 不满足条件继续休眠”这样的流程，直到count满足条件为止。那么我们就可以使用一个while循环来包裹<code>this.wait()</code>调用和对count的条件判断，以此达到这个目的。</p><p>下面是具体的实现代码，我们在其中把count条件（队列未满/非空）作为while条件，然后在count值还不满足要求的情况下调用<code>this.wait()</code>方法使当前线程进入等待状态继续休眠。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">wait</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 唤醒所有休眠等待的进程\n</span><span class=\"c1\"></span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">notifyAll</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">wait</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 唤醒所有休眠等待的进程\n</span><span class=\"c1\"></span>            <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">notifyAll</span><span class=\"o\">();</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>再次运行我们的测试程序，在我的电脑上得到了如下的输出：</p><div class=\"highlight\"><pre><code class=\"language-text\">0\n10\n1\n2\n11\n12\n13\n3\n4\n14\n5\n6\n15\n16\n7\n17\n8\n18\n9\n19\n总耗时：0.11s</code></pre></div><p>耗时只有0.11s，而且结果也是正确的，看来我们得到了一个又快又好的阻塞队列实现。这是一个里程碑式的版本，我们实现了一个真正可以在程序代码中使用的阻塞队列，到这里可以说你已经学会了如何实现一个阻塞队列了，让我们为自己鼓个掌吧。</p><p>当时进度条出卖了我，这篇文章还有不少内容。既然我们已经学会如何实现一个真正可用的阻塞队列了，我们为什么还要继续看这么多内容呢？别慌，虽然我们已经实现了一个真正可用的版本，但是如果我们更进一步的话就可以实现一个JDK级别的高强度版本了，这听起来是不是非常的诱人？让我们继续我们的旅程吧。</p><h2>一个更安全的版本</h2><p>我们之前的版本中使用这些同步机制：<code>synchronized (this)</code>、<code>this.wait()</code>、<code>this.notifyAll()</code>，这些同步机制都和当前对象<code>this</code>有关。因为<code>synchronized (obj)</code>可以使用任意对象对应的对象锁，而<code>Object.wati()</code>和<code>Object.notifyAll()</code>方法又都是public方法。也就是说不止在阻塞队列类内部可以使用这个阻塞队列对象的对象锁及其对应的条件变量，在外部的代码中也可以任意地获取阻塞队列对象上的对象锁和对应的条件变量，那么就有可能发生外部代码滥用阻塞队列对象上的对象锁导致阻塞队列性能下降甚至是发生死锁的情况。那我们有没有什么办法可以让阻塞队列在这方面变得更安全呢？</p><h3>使用显式锁</h3><p>最直接的方式当然是请出JDK在1.5之后引入的代替<code>synchronized</code>关键字的显式锁<code>ReentrantLock</code>类了。<code>ReentrantLock</code>类是一个可重入互斥锁，互斥指的是和<code>synchronized</code>一样，同一时间只能有一个线程持有锁，其他获取锁的线程都必须等待持有锁的线程释放该锁。而可重入指的就是同一个线程可以重复获取同一个锁，如果在获取锁时这个锁已经被当前线程所持有了，那么这个获取锁的操作仍然会直接成功。</p><p>一般我们使用<code>ReentrantLock</code>的方法如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n<span class=\"k\">try</span> <span class=\"o\">{</span>\n    <span class=\"n\">做一些操作</span>\n<span class=\"o\">}</span>\n<span class=\"k\">finally</span> <span class=\"o\">{</span>\n    <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n<span class=\"o\">}</span></code></pre></div><p>上面的<code>lock</code>变量就是一个<code>ReentrantLock</code>类型的对象。在这段代码中，释放锁的操作<code>lock.unlock()</code>被放在了<code>finally</code>块中，这是为了保证线程在获取到锁之后，不论出现异常或者什么特殊情况都能保证正确地释放互斥锁。如果不这么做就可能会导致持有锁的线程异常退出后仍然持有该锁，其他需要获取同一个锁的线程就永远运行不了。</p><p>那么在我们的阻塞队列中应该如何用<code>ReentrantLock</code>类来改写呢？</p><p>首先，我们显然要为我们的阻塞队列类添加一个实例变量<code>lock</code>来保存用于在不同线程间实现互斥访问的<code>ReentrantLock</code>锁。然后我们要将原来的<code>synchronized(this) {...}</code>格式的代码修改为上面使用<code>ReentrantLock</code>进行互斥访问保护的实现形式，也就是<code>lock.lock(); try {...} finally {lock.unlock();}</code>这样的形式。</p><p>但是原来与<code>synchronized</code>所加的对象锁相对应的条件变量使用方法<code>this.wait()</code>和<code>this.notifyAll()</code>应该如何修改呢？<code>ReentrantLock</code>已经为你做好了准备，我们可以直接调用<code>lock.newCondition()</code>方法来创建一个与互斥锁<code>lock</code>相对应的条件变量。然后为了在不同线程中都能访问到这个条件变量，我们同样要新增一个实例变量<code>condition</code>来保存这个新创建的条件变量对象。然后我们原来使用的<code>this.wait()</code>就需要修改为<code>condition.await()</code>，而<code>this.notifyAll()</code>就修改为了<code>condition.signalAll()</code>。</p><div class=\"highlight\"><pre><code class=\"language-java\">    <span class=\"cm\">/** 显式锁 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/** 锁对应的条件变量 */</span>\n    <span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">Condition</span> <span class=\"n\">condition</span> <span class=\"o\">=</span> <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">newCondition</span><span class=\"o\">();</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 将指定元素插入队列\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @param e 待插入的对象\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">put</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">e</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">items</span><span class=\"o\">.</span><span class=\"na\">length</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列已满时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 使用与显式锁对应的条件变量\n</span><span class=\"c1\"></span>                <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行入队操作，将对象e实际放入队列中\n</span><span class=\"c1\"></span>            <span class=\"n\">enqueue</span><span class=\"o\">(</span><span class=\"n\">e</span><span class=\"o\">);</span>\n\n            <span class=\"c1\">// 通过条件变量唤醒休眠线程\n</span><span class=\"c1\"></span>            <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">signalAll</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"cm\">/**\n</span><span class=\"cm\">     * 从队列中弹出一个元素\n</span><span class=\"cm\">     *\n</span><span class=\"cm\">     * @return  被弹出的元素\n</span><span class=\"cm\">     */</span>\n    <span class=\"kd\">public</span> <span class=\"n\">Object</span> <span class=\"nf\">take</span><span class=\"o\">()</span> <span class=\"kd\">throws</span> <span class=\"n\">InterruptedException</span> <span class=\"o\">{</span>\n        <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lockInterruptibly</span><span class=\"o\">();</span>\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 队列为空时进入休眠\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 使用与显式锁对应的条件变量\n</span><span class=\"c1\"></span>                <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">await</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n\n            <span class=\"c1\">// 执行出队操作，将队列中的第一个元素弹出\n</span><span class=\"c1\"></span>            <span class=\"n\">Object</span> <span class=\"n\">e</span> <span class=\"o\">=</span> <span class=\"n\">dequeue</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 通过条件变量唤醒休眠线程\n</span><span class=\"c1\"></span>            <span class=\"n\">condition</span><span class=\"o\">.</span><span class=\"na\">signalAll</span><span class=\"o\">();</span>\n\n            <span class=\"k\">return</span> <span class=\"n\">e</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span></code></pre></div><p>到这里，我们就完成了使用显式锁<code>ReentrantLock</code>所需要做的所有改动了。整个过程中并不涉及任何逻辑的变更，我们只是把<code>synchronized (this) {...}</code>修改为了<code>lock.lock() try {...} finally {lock.unlock();}</code>，把<code>this.wait()</code>修改为了<code>condition.await()</code>，把<code>this.notifyAll()</code>修改为了<code>condition.signalAll()</code>。就这样，我们的锁和条件变量因为是<code>private</code>字段，所以外部的代码就完全无法访问了，这让我们的阻塞队列变得更加安全，是时候可以提供给其他人使用了。</p><p>但是这个版本的阻塞队列仍然还有很大的优化空间，继续阅读下一篇文章，相信你就可以实现出JDK级别的阻塞队列了。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/63207814", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 13, 
            "title": "解决死锁的100种方法", 
            "content": "<p>死锁是多线程编程或者说是并发编程中的一个经典问题，也是我们在实际工作中很可能会碰到的问题。相信大部分读者对“死锁”这个词都是略有耳闻的，但从我对后端开发岗位的面试情况来看很多同学往往对死锁都还没有系统的了解。虽然“死锁”听起来很高深，但是实际上已经被研究得比较透彻，大部分的解决方法都非常成熟和清晰，所以大家完全不用担心这篇文章的难度。</p><p>虽然本文是一篇介绍死锁及其解决方式的文章，但是对于多线程程序中的非死锁问题我们也应该有所了解，这样才能写出正确且高效的多线程程序。多线程程序中的非死锁问题主要分为两类：</p><ol><li>违反原子性问题</li></ol><ul><li>一些语句在底层会被分为多个底层指令运行，所以在多个线程之间这些指令就可能会存在穿插，这样程序的行为就可能会与预期不符造成bug。</li></ul><p>2. 违反执行顺序问题</p><ul><ul><li>一些程序语句可能会因为子线程立即启动早于父线程中的后续代码，或者是多个线程并发执行等情况，造成程序运行顺序和期望不符导致产生bug。</li></ul></ul><p>这两大非死锁多线程问题及其解决方案在之前的文章《<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5cacb4c16fb9a068b36776ed\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">多线程中那些看不到的陷阱</a>》里都有详细的介绍，感兴趣的读者可以了解一下。</p><p>接下来就让我们开始消灭死锁吧！</p><h2>初识死锁</h2><h3>什么是死锁？</h3><p>死锁，顾名思义就是导致线程卡死的锁冲突，例如下面的这种情况：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-21a0971ba7e9fa8f1ed5c1ad5d44212f_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"755\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb\" width=\"755\" data-original=\"https://pic4.zhimg.com/v2-21a0971ba7e9fa8f1ed5c1ad5d44212f_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;755&#39; height=&#39;219&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"755\" data-rawheight=\"219\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"755\" data-original=\"https://pic4.zhimg.com/v2-21a0971ba7e9fa8f1ed5c1ad5d44212f_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-21a0971ba7e9fa8f1ed5c1ad5d44212f_b.jpg\"/></figure><p>可以看出，上面的两个线程已经互相卡死了，线程t1在等待线程t2释放锁B，而线程t2在等待线程t1释放锁A。两个线程互不相让也就没有一个线程可以继续往下执行了。这种情况下就发生了<b>死锁</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>死锁的四个必要条件</h3><p>上面的情况只是死锁的一个例子，我们可以用更精确的方式描述死锁出现的条件：</p><ol><li>互斥。资源被竞争性地访问，这里的资源可以理解为锁；</li><li>持有并等待。线程持有已经分配给他们的资源，同时等待其他的资源；</li><li>不抢占。线程已经获取到的资源不会被其他线程强制抢占；</li><li>环路等待。线程之间存在资源的环形依赖链，每个线程都依赖于链条中的下一个线程释放必要的资源，而链条的末尾又依赖了链条头部的线程，进入了一个循环等待的状态。</li></ol><p>上面这四个都是死锁出现的必要条件，如果其中任何一个条件不满足都不会出现死锁。虽然这四个条件的定义看起来非常的理论和官方，但是在实际的编程实践中，我们正是在死锁的这四个必要条件基础上构建出解决方案的。所以这里不妨思考一下这四个条件各自的含义，想一想如果去掉其中的一个条件死锁是否还能发生，或者为什么不能发生。</p><h2>阻止死锁的发生</h2><p>了解了死锁的概念和四个必要条件之后，我们下面就正式开始解决死锁问题了。对于死锁问题，我们最希望能够达到的当然是完全不发生死锁问题，也就是在死锁发生之前就阻止它。</p><p>那么想要阻止死锁的发生，我们自然是要让死锁无法成立，最直接的方法当然是破坏掉死锁出现的必要条件。只要有任何一个必要条件无法成立，那么死锁也就没办法发生了。</p><h3>破坏环路等待条件</h3><p>实践中最有效也是最常用的一种死锁阻止技术就是<b>锁排序</b>，通过对加锁的操作进行排序我们就能够破坏<b>环路等待条件</b>。例如当我们需要获取数组中某一个位置对应的锁来修改这个位置上保存的值时，如果需要同时获取多个位置对应的锁，那么我们就可以按位置在数组中的排列先后顺序统一从前往后加锁。</p><p>试想一下如果程序中所有需要加锁的代码都按照一个统一的固定顺序加锁，那么我们就可以想象锁被放在了一条不断向前延伸的直线上，而因为加锁的顺序一定是沿着这条线向下走的，所以每条线程都只能向前加锁，而不能再回头获取已经在后面的锁了。这样一来，线程只会向前单向等待锁释放，自然也就无法形成一个环路了。</p><p>其实大部分死锁解决方法不止可以用于多线程编程领域，还可以扩展到更多的并发场景下。比如在数据库操作中，如果我们要对某几行数据执行更新操作，那么就会获取这几行数据所对应的锁，我们同样可以通过对数据库更新语句进行排序来阻止在数据库层面发生的死锁。</p><p>但是这种方案也存在它的缺点，比如在大型系统当中，不同模块直接解耦和隔离得非常彻底，不同模块的研发同学之间都不清楚具体的实现细节，在这样的情况下就很难做到整个系统层面的全局锁排序了。在这种情况下，我们可以对方案进行扩充，例如Linux在内存映射代码就使用了一种锁分组排序的方式来解决这个问题。锁分组排序首先按模块将锁分为了不同的组，每个组之间定义了严格的加锁顺序，然后再在组内对具体的锁按规则进行排序，这样就保证了全局的加锁顺序一致。在Linux的对应的源码顶部，我们可以看到有非常详尽的注释定义了明确的锁排序规则。</p><p>这种解决方案如果规模过大的话即使可以实现也会非常的脆弱，只要有一个加锁操作没有遵守锁排序规则就有可能会引发死锁。不过在像微服务之类解耦比较充分的场景下，只要架构拆分合理，任务模块尽可能小且不会将加锁范围扩大到模块之外，那么锁排序将是一种非常实用和便捷的死锁阻止技术。</p><h3>破坏持有并等待条件</h3><p>想要破坏<b>持有并等待条件</b>，我们可以一次性原子性地获取所有需要的锁，比如通过一个专门的全局锁作为<b>加锁令牌</b>控制加锁操作，只有获取了这个锁才能对其他锁执行加锁操作。这样对于一个线程来说就相当于一次性获取到了所有需要的锁，且除非等待<b>加锁令牌</b>否则在获取其他锁的过程中不会发生锁等待。</p><p>这样的解决方案虽然简单粗暴，但这种简单粗暴也带来了一些问题：</p><ol><li>这种实现会降低系统的并发性，因为所有需要获取锁的线程都要去竞争同一个<b>加锁令牌</b>锁；</li><li>并且因为要在程序的一开始就获取所有需要的锁，这就导致了线程持有锁的时间超出了实际需要，很多锁资源被长时间的持有所浪费，而其他线程只能等待之前的线程执行结束后统一释放所有锁；</li><li>另一方面，现代程序设计理念要求我们提高程序的封装性，不同模块之间的细节要互相隐藏，这就使得在一个统一的位置一次性获取所有锁变得不再可能。</li></ol><h3>破坏不抢占条件</h3><p>如果一个线程已经获取到了一些锁，那么在这个线程释放锁之前这些锁是不会被强制抢占的。但是为了防止死锁的发生，我们可以选择让线程在获取后续的锁失败时主动放弃自己已经持有的锁并在之后重试整个任务，这样其他等待这些锁的线程就可以继续执行了。</p><p>同样的，这个方案也会有自己的缺陷：</p><p>1. 虽然这种方式可以避免死锁，但是如果几个互相存在竞争的线程不断地放弃、重试、放弃，那么就会导致活锁问题（livelock）。在这种情况下，虽然线程没有因为锁冲突被卡死，但是仍然会被阻塞相当长的时间甚至一直处于重试当中。</p><ul><ul><li>这个问题的一种解决方式是给任务重试添加一个随机的延迟时间，这样就能大大降低任务冲突的概率了。在一些接口请求框架中也使用了这种技巧来分散服务高峰期的请求重试操作，防止服务陷入阻塞、崩溃、阻塞的恶性循环。</li></ul></ul><p>2. 还是因为程序的封装性，在一个模块中难以释放其他模块中已经获取到的锁。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>虽然每一个方案都有自己的缺陷，但是在适合它们的场景下，它们都能发挥出巨大的作用。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>破坏互斥条件</h3><p>在之前的文章中，我们已经了解了一种与锁完全不同的同步方式CAS。通过CAS提供的原子性支持，我们可以实现各种无锁数据结构，不仅避免了互斥锁所带来的开销和复杂性，也由此避开了我们一直在讨论的死锁问题。</p><p><code>AtomicInteger</code>类中就大量使用了CAS操作来实现并发安全，例如<code>incrementAndGet()</code>方法就是用<code>Unsafe</code>类中基于CAS的原子累加方法<code>getAndAddInt</code>来实现的。下面是<code>Unsafe</code>类的<code>getAndAddInt</code>方法实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"cm\">/**\n</span><span class=\"cm\"> * 增加指定字段值并返回原值\n</span><span class=\"cm\"> * \n</span><span class=\"cm\"> * @param obj           目标对象\n</span><span class=\"cm\"> * @param valueOffset   目标字段的内存偏移量\n</span><span class=\"cm\"> * @param increment     增加值\n</span><span class=\"cm\"> * @return  字段原值\n</span><span class=\"cm\"> */</span>\n<span class=\"kd\">public</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"nf\">getAndAddInt</span><span class=\"o\">(</span><span class=\"n\">Object</span> <span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"kt\">long</span> <span class=\"n\">valueOffset</span><span class=\"o\">,</span> <span class=\"kt\">int</span> <span class=\"n\">increment</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 保存字段原值的变量\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n    <span class=\"k\">do</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 获取字段原值\n</span><span class=\"c1\"></span>        <span class=\"n\">oldValue</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">getIntVolatile</span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"n\">valueOffset</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// obj和valueOffset唯一指定了目标字段所对应的内存区域\n</span><span class=\"c1\"></span>        <span class=\"c1\">// while条件中不断调用CAS方法来对目标字段值进行增加，并保证字段的值没有被其他线程修改\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 如果在修改过程中其他线程修改了这个字段的值，那么CAS操作失败，循环语句会重试操作\n</span><span class=\"c1\"></span>    <span class=\"o\">}</span> <span class=\"k\">while</span><span class=\"o\">(!</span><span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">compareAndSwapInt</span><span class=\"o\">(</span><span class=\"n\">obj</span><span class=\"o\">,</span> <span class=\"n\">valueOffset</span><span class=\"o\">,</span> <span class=\"n\">oldValue</span><span class=\"o\">,</span> <span class=\"n\">oldValue</span> <span class=\"o\">+</span> <span class=\"n\">increment</span><span class=\"o\">));</span>\n\n    <span class=\"c1\">// 返回字段的原值\n</span><span class=\"c1\"></span>    <span class=\"k\">return</span> <span class=\"n\">oldValue</span><span class=\"o\">;</span>\n<span class=\"o\">}</span></code></pre></div><p>上面代码中的<code>compareAndSwapInt</code>方法就是我们说的CAS操作（Compare And Swap），我们可以看到，CAS在每次执行时不一定会成功。如果执行CAS操作时目标字段的值已经被别的线程修改了，那么这次CAS操作就会失败，循环语句将会在CAS操作失败的情况下不断重试同样的操作。这种不断重试的方式就被称为<b>自旋</b>，在jvm当中对互斥锁的等待也会通过少量的自旋操作来进行优化。</p><p>不过如果一个变量同时被多个线程以CAS方式修改，那么就有可能导致出现活锁，多个线程将会一直不断重试CAS操作。所以CAS操作的成本和数据竞争的激烈程度密切相关，在一些竞争非常激烈的情况下，CAS操作的成本甚至会超过互斥锁。</p><p>除了累加整型值这样的简单场景之外，还有更多更复杂的无锁(lock-free)数据结构，例如<code>java.util.concurrent</code>包中的<code>ConcurrentLinkedDeque</code>双端队列类就是一个无锁的并发安全链表实现，有兴趣的读者可以了解一下。</p><p>这种方法同样可以用在数据库操作上，当我们执行update语句时可以在where子句中添加上一些字段的旧值作为条件，比如<code>update t_xxxx set value = &lt;newValue&gt;, version = version + 1 where id = xxx and version = 10</code>，这样我们就可以通过update语句返回的影响行数是不是0来判断更新操作有没有成功了，这是不是和CAS很相似？</p><h2>其他解决死锁的方法 —— 探测并恢复</h2><p>有时，我们并不需要完全阻止死锁的发生，而是可以通过其他的手段来控制死锁的影响。就像如果新的治疗手段可以使癌症病人继续活七八十年，那么癌症也就没有那么可怕了。</p><p>还有一种解决死锁的方法就是让死锁发生，之后再解决它，就像电脑死机以后直接重启一样。使用这种方法我们可以这么做：如果多个线程出现了死锁的情况，那么我们就杀死足够多的线程使系统恢复到可运行状态。在我们常用的关系型数据库中使用的就是这种方法，数据库会周期性地使用探测器创建<b>资源图</b>，然后检查其中是否存在循环。如果探测到了循环（死锁），那么数据库就会根据估算的执行成本高低杀死可以解决死锁问题的尽可能成本最小的线程。</p><p>数据库在被外部应用调用的过程中是没办法获知外部应用的逻辑细节的，所以自然也就没办法用之前说的种种方法来解决死锁问题，只能通过事后检测并恢复来对死锁问题做最低限度的保障。但是我们可以在我们的应用程序中应用更多的解决方案，从更上层解决死锁问题。</p><h2>总结</h2><p>在这篇文章中，我们从死锁的概念出发，首先介绍了死锁是什么和死锁发生的<b>四个必要条件</b>。然后通过破坏任意一个必要条件产生了四种不同的阻止死锁的解决方案，最后介绍了另外一种死锁解决方法——在死锁发生后再探测并恢复系统运行。相信大家可以在不同的场景中都能找到适合该场景的解决方案，但是锁本质上是容易引入问题的，所以如果不是确有必要，最好不要贸然用锁来进行处理。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "死锁", 
                    "tagLink": "https://api.zhihu.com/topics/20062742"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/61904135", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 3, 
            "title": "多线程中那些看不见的陷阱", 
            "content": "<p>多线程编程就像一个沼泽，中间遍布各种各样的陷阱。大多数开发者绝大部分时间都是在做上层应用的开发，并不需要过多地涉入底层细节。但是在多线程编程或者说是并发编程中，有非常多的陷阱被埋在底层细节当中。如果不知道这些底层知识，可能在编写过程中完全意识不到程序已经出现了漏洞，甚至在漏洞爆发之后也很难排查出具体原因进而解决漏洞。虽然前面提到的漏洞听起来很吓人，但是相信通过我们逐步的抽丝剥茧，在最后一定能掌握大量的实用工具来帮助我们解决这些问题，实现可靠的并发程序。</p><p>阅读本文需要了解并发的基本概念和Java多线程编程基础知识，还不了解的读者可以参考一下下面两篇文章：</p><ol><li>并发的基本概念——<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c7dc48ee51d4542151b8f33\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">当我们在说“并发、多线程”，说的是什么？</a></li><li>Java多线程编程基础——<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c8496b45188257c5b47711c\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">这一次，让我们完全掌握Java多线程</a></li></ol><h2>数据竞争问题</h2><p>为了了解多线程程序有什么隐藏的陷阱，我们先来看一段代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AccumulateWrong</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>这段代码实现的基本功能就是在两个线程中分别对一个整型累加一百万次，那么我们期望的输出应该总共是两百万。但在我的电脑上运行的结果只有1799369，而且每次都不一样，相信在你的电脑上也会运行得到一个不同的结果，但是肯定会达不到两百万。</p><p>这段代码出现问题的原因就在于，我们在执行<code>count += 1;</code>这行代码时，实际在CPU上运行的会是多条指令： </p><ol><li>获取count变量的当前值 </li><li>计算count + 1的值</li><li>将count + 1的结果值存到count变量中</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>所以就有可能会发生下面的执行顺序：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-79ec43817997fa3b6d9a4f2c9f344766_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"417\" data-rawheight=\"295\" class=\"content_image\" width=\"417\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;417&#39; height=&#39;295&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"417\" data-rawheight=\"295\" class=\"content_image lazy\" width=\"417\" data-actualsrc=\"https://pic3.zhimg.com/v2-79ec43817997fa3b6d9a4f2c9f344766_b.jpg\"/></figure><p>这么一轮操作结束之后，虽然我们在两个线程中分别对count累加了一次，总共是两次，但是count的值只变大了1，这时结果就出现了问题。这种在多个线程中对共享数据进行竞争性访问的情况就被称为<b>数据竞争</b>，可以理解为对共享数据的并发访问会导致问题的情况就是<b>数据竞争</b>。</p><p>那么我们如何解决这样的<b>数据竞争</b>问题呢？</p><h3>synchronized关键字</h3><p>相信大多数读者应该都知道<code>synchronized</code>这个关键字，它可以被用在方法定义或者是块结构上，那么它到底能发挥怎样的作用呢？我们把它以块结构的形式把<code>count += 1;</code>语句包围起来看看。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>运行之后可以看到，这次的输出是两百万整了。在这里，<code>synchronized</code>发挥的作用就是让两个线程互斥地执行<code>count += 1;</code>语句。所谓互斥也就是同一时间只能有一个线程执行，如果另一个线程同时也要执行的话则必须等到前一个线程完成操作退出<code>synchronized</code>语句块之后才能进入。</p><p>这种同一时间只能被一个线程访问的代码块就被称为<b>临界区</b>，而<code>synchronized</code>这样的保护临界区同时只能被一个线程进入的机制就被称为<b>互斥锁</b>。当一个线程因为另外一个线程已经获取了锁而陷入等待时，我们可以称该线程被这个锁<b>阻塞</b>了。</p><p>在Java中，<code>synchronized</code>的背后是对象锁，每个不同的对象都会对应一个不同的锁，同一个对象对应同一个锁。只有获取同一个锁才能达到互斥访问的作用，如果两个线程分别获取不同的锁，那么互相就不会影响了。所以在使用<code>synchronized</code>时，区分背后对应的是哪一个对象锁就至关重要了。<code>synchronized</code>关键字可以被用在方法定义和块结构两种情况中，具体对应的锁如下：</p><ol><li>以块结构形式使用<code>synchronized</code>关键字，则获取的就是<code>synchronized</code>关键字后小括号中的对象所对应的锁；</li><li><code>synchronized</code>被标记在实例方法上，则获取的就是this引用指向对象所对应的锁；</li><li><code>synchronized</code>被标记在类方法（静态方法）上时，获取的就是方法所在类的“类对象”所对应的锁，这里的类对象就可以理解为是每个类一个用于存放静态字段和静态方法的对象。</li></ol><p>因为<code>synchronized</code>一定要有一个对应的对象，所以我们自然不能将基本类型的变量传入到<code>synchronized</code>后面的括号中。</p><h3>ReentrantLock</h3><p>在Java 5中JDK引入了<code>java.util.concurrent</code>包，也许大家都或多或少听说过这个包，在这个包中提供了大量使用的并发工具类，例如线程池、锁、原子数据类等等，对Java语言的并发编程易用性和实际效率产生了跨越性的提高。而<code>ReentrantLock</code>就是这个包中的一员。</p><p><code>ReentrantLock</code>发挥的作用与<code>synchronized</code>相同，都是作为互斥锁使用的。下面是把之前的累加代码改为使用<code>ReentrantLock</code>锁的版本：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ReentrantLock</span><span class=\"o\">();</span>\n\n<span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                <span class=\"n\">lock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">};</span></code></pre></div><p>运行之后的结果依然是两百万，说明<code>ReentrantLock</code>确实能起到保障互斥访问临界区的作用。但是既然<code>ReentrantLock</code>和<code>synchronized</code>的作用相同，而且从代码来看使用<code>synchronized</code>还更方便，为什么还要专门定义一个<code>ReentrantLock</code>这样的类呢？</p><p>上面的代码中，虽然使用<code>ReentrantLock</code>还要专门写一个<code>try..finally</code>块来保证锁释放，比较麻烦，但是也能从中看到一个好处就是我们可以决定加锁的位置和释放锁的位置。我们甚至可以在一个方法中加锁，而在另一个方法中解锁，虽然这样做会有风险。相对于传统的<code>synchronized</code>，<code>ReentrantLock</code>还有下面的一些好处：</p><ol><li><code>ReentrantLock</code>可以实现带有超时时间的锁等待，我们可以通过<code>tryLock</code>方法进行加锁，并传入超时时间参数。如果超过了超时时间还么有获得锁的话，那么就<code>tryLock</code>方法就会返回false；</li><li><code>ReentrantLock</code>可以使用公平性机制，让先申请锁的线程先获得锁，防止线程一直等待锁但是获取不到；</li><li><code>ReentrantLock</code>可以实现读写锁等更丰富的类型。</li></ol><h3>更简便的方式——AtomicInteger</h3><p>在<code>java.util.concurrent</code>包中，我们可以找到一个很有趣的子包<code>atomic</code>，在这个包中我们看到有很多以<code>Atomic</code>开头的“包装类型”，这些类会有什么用呢？我们先来看一下前面的累加程序使用<code>AtomicInteger</code>该如何实现。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">AtomicIntegerDemo</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">);</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count</span><span class=\"o\">.</span><span class=\"na\">incrementAndGet</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>运行这个程序，我们也可以得到正确的结果两百万。在这个版本的代码中我们主要改了两处地方，一个是把<code>count</code>变量的类型修改为了<code>AtomicInteger</code>类型，然后把<code>Runnable</code>对象中的累加方式修改为了<code>count.incrementAndGet()</code>。</p><p><code>AtomicInteger</code>提供了原子性的变量值修改方式，原子性保证了整个累加操作可以被看成是一个操作，不会出现更细粒度的操作之间互相穿插导致错误结果的情况。在底层<code>AtomicInteger</code>是基于硬件的CAS原语来实现的，CAS是“Compare and Swap”的缩写，意思是在修改一个变量时会同时指定新值和旧值，只有在旧值等于变量的当前值时，才会把变量的值修改为新值。这个CAS操作在硬件层面是可以保证原子性的。</p><p>我们既可以用<code>Atomic</code>类来实现一些简单的并发修改功能，也可以使用它来对一些关键的控制变量进行控制，起到控制并发过程的目的。线程池类<code>ThreadPoolExecutor</code>中用于控制线程池状态和线程数的控制变量<code>ctl</code>就是一个<code>AtomicInteger</code>类型的字段。</p><h2>内存可见性问题</h2><p>看完了如何解决数据竞争问题，我们再来看一个略显神奇的例子。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">MemoryVisibilityDemo</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">boolean</span> <span class=\"n\">flag</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">10000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n            <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">no</span> <span class=\"o\">=</span> <span class=\"n\">i</span><span class=\"o\">;</span>\n\n            <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"nd\">@Override</span>\n                <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                    <span class=\"n\">flag</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n                    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;No.%d loop, t1 is done.&#34;</span><span class=\"o\">,</span> <span class=\"n\">no</span><span class=\"o\">));</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">});</span>\n\n            <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"nd\">@Override</span>\n                <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                    <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">flag</span><span class=\"o\">)</span> <span class=\"o\">;</span>\n\n                    <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">.</span><span class=\"na\">format</span><span class=\"o\">(</span><span class=\"s\">&#34;No.%d loop, t2 is done.&#34;</span><span class=\"o\">,</span> <span class=\"n\">no</span><span class=\"o\">));</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">});</span>\n\n            <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n            <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n            <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n            <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">join</span><span class=\"o\">();</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n\n<span class=\"o\">}</span></code></pre></div><p>这段程序在我的电脑上输出是这样的：</p><div class=\"highlight\"><pre><code class=\"language-text\">No.0 loop, t2 is done.\nNo.0 loop, t1 is done.\nNo.1 loop, t1 is done.\nNo.1 loop, t2 is done.\nNo.2 loop, t2 is done.\nNo.2 loop, t1 is done.\nNo.3 loop, t2 is done.\nNo.3 loop, t1 is done.\nNo.4 loop, t1 is done.</code></pre></div><p>在上面的程序输出中我们可以看到，代码中的循环是10000次，但是在程序输出结果中到第五次就结束了。而且第五次运行中只有t1执行完了，t2的结束语句一直没输出。这说明程序被卡在了<code>while (!flag) ;</code>上，但是t1明明已经运行结束了，说明此时<code>flag = true</code>已经执行了，为什么t2还会被卡住呢？</p><p>这是因为<b>内存可见性</b>在作祟，在计算机中，我们的存储会分为很多不同的层次，大家比较常见的就是内存和外存，外存就是比如磁盘、SSD这样的持久性存储。其实在内存之上还有多个层次，较完整的计算机存储体系从下到上依次有外存、内存、“L3、L2、L1三层高速缓存”、寄存器这几层。在这个存储体系中从下到上是一个速度从慢到快的结构，越上层速度越快，所以当CPU操作内存数据时会尽量把数据读取到内存之上的高速缓存中再进行读写。</p><p>所以如果程序想要修改一个变量的值，那么系统会先把新值写到L1缓存中，之后在合适的时间才会将缓存中的数据写回内存当中。虽然这样的设置使系统的总体效率得到了提升，但是也带来了一个问题，那就是L1、L2两级高速缓存是核内缓存，也就是说多核处理器的每一个核心都有自己独立的L1、L2高速缓存。那么如果我们在一个核中运行的线程上修改了变量的值而没有写回内存的话，其他核心上运行的线程就看不到这个变量的最新值了。</p><p>结合我们前面的程序例子，因为修改和读取静态变量<code>flag</code>的代码在两个不同的线程中，所以在多核处理器上运行这段程序时，就有可能在两个不同的处理器核心上运行这两段代码。最终就会导致线程t1虽然已经把<code>flag</code>变量的值修改为true了，但是因为这个值还没有写回内存，所以线程t2看到的flag变量的值仍然是false，这就是之前的代码会被卡住的罪魁祸首。</p><p>那么我们如何解决这个问题呢？</p><h3>volatile变量</h3><p>最简单的方式是使用volatile变量，即把<code>flag</code>变量标记为<code>volatile</code>，如下所示：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">volatile</span> <span class=\"kt\">boolean</span> <span class=\"n\">flag</span><span class=\"o\">;</span></code></pre></div><p>这下程序就可以稳定地跑完了，那么<code>volatile</code>做了什么解决了内存可见性问题呢？根据编号为JSR-133的Java语言规范所定义的<b>Java内存模型(JMM)</b>，<code>volatile</code>变量保证了对该变量的写入操作和在其之后的读取操作之间存在同步关系，这个同步关系保证了对volatile变量的读取一定可以获取到该变量的最新值。在底层，对volatile变量的写入会触发高速缓存强制写回内存，该操作会使其他处理器核心中的同一个数据块无效化，必须从内存中重新读取。<b>Java内存模型</b>的具体内容在下一节中会有简单的介绍。</p><p>从上面的内存可见性问题我们可以发现，多线程程序中会出现的一些问题涉及一些非常底层的知识，而且不了解的人是很难事先预防和事后排查的。所以对于希望真正掌握多线程编程的朋友来说，这必然会是一场非常奇妙与漫长的旅程，希望大家都能坚持到最后。</p><h3>Java内存模型</h3><p>Java语言规范中的JSR-133定义了一系列决定不同线程之间指令的逻辑顺序，从而保证了不会出现内存可见性和指令重排序所引发的并发问题，这对完全掌握多线程程序的正确性至关重要。</p><p>在程序中，我们一般会认定程序语句是按代码中的顺序执行的，比如下面这段代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n<span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n<span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">2</span><span class=\"o\">;</span>\n<span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">3</span><span class=\"o\">;</span></code></pre></div><p>我们当然会认为程序的执行顺序是<code>a = 0;</code> -&gt; <code>a = 1;</code> -&gt; <code>b = 2;</code> -&gt; <code>c = 3;</code>，但实际上会有两种情况可能会破坏语句的执行顺序，一是编译器对指令的重排序可能会导致语句的顺序发生改变，二是前面提到的内存可见性。</p><p>对于编译器的指令重排序来说，虽然编译器会保证单个线程内语句的执行效果与顺序执行相同，但是在上面的代码中三个语句之间是没有依赖关系的，任意顺序执行的效果都是相同的，所以编译器是有可能对其中的语句进行重排序的。在单线程程序中这当然没有问题，任意顺序执行上面代码中的语句都是一样的，但是在多线程情况下，问题就复杂了。如果另外一个线程在变量b的值变为2后会打印变量a的值，那么按我们的期望这段程序应该打印出的<code>1</code>。但是如果<code>b = 2;</code>语句被重排序到了<code>a = 1;</code>之前和<code>a = 0;</code>之后，那么我们打印出的值就是<code>0</code>了。</p><p>对于内存可见性，如果<code>b = 2;</code>对变量b的修改结果先于<code>a = 1;</code>写回了内存中。那么在另一个线程中，当看到变量b的值变为2时还不能看到变量a的新值1，这同样会导致程序打印出不符合我们期望的值。</p><p>从上面的介绍我们可以看出，在这个问题中最重要的是语句的执行顺序，在默认情况下，我们可以保证单线程内的执行顺序所产生的结果一定是符合我们的期望的，但一旦进入多线程情况下，我们就不能做出这样的保证了。<b>那么我们如何保证多个线程之间语句的执行顺序关系呢？</b>这就要说到我们之前说到的Java内存模型了。</p><p>Java内存模型中定义了不同线程中的语句的顺序关系，这被称为Happens-Before关系，以下简称HB。这个关系指的是如果“操作A”HB于“操作B”，那么<b>如果“操作A”确实在“操作B”之前已经发生了</b>，那么“操作B”一定会像在“操作A”之后发生一样：看到“操作A”发生后所产生的所有结果，比如变量值的修改。如果“操作A”把变量a的值修改为了2，那么所有“操作B”都一定能看到变量a的值为2，不论是编译器对指令的重排序还是不同处理器核心之间的内存可见性都不能破坏这个结果。</p><p>正是因为这种指令执行先后关系的核心就是看到之前执行指令<b>在内存中体现的结果</b>，所以这个规范才被称为<b>Java内存模型</b>。</p><p><b>常用的Happens-Before关系规则：</b></p><ol><li> 同一个线程中，“先执行的语句” HB于 “之后执行的所有语句”； </li><li>“对volatile变量的写操作” HB于 “对同一个变量的读操作”； </li><li>“对锁的释放操作” HB于 “对同一个锁的加锁操作”； </li><li>“对Thread对象的start操作” HB于 “该线程任务中的第一行语句”； </li><li>“线程任务中的最后一行语句” HB于 “对该线程对应的Thread对象的join操作”；</li><li>传递性规则：如果“操作B” HB于 “操作A”，“操作C” HB于 “操作B”，那么“操作C” 也HB于 “操作A”。</li></ol><p>通过第一条规则我们就确定了单线程内的语句的执行顺序，而通过规则2到规则4，我们就可以线程间确定具体的语句执行顺序了。最后的规则6传递性规则是整个规则体系的补充，利用这条规则我们就可以把规则1中的线程内顺序和规则2到4的线程间规则进行结合，得到最终的完整顺序体系了。</p><p>在下图中，左边一列和右边一列分别是两条不同的线程中执行的语句及其顺序。如果变量c是一个volatile变量，那么根据规则2，我们可以知道操作<code>c = 3</code> HB于 操作<code>print c</code>，下图中用红线标明了这个关系。所以根据JMM的定义，<code>print c</code>将可以看到变量c的值已经被修改为3了，打印结果将是3，如果在<code>print c</code>语句下方继续执行对变量a和b的打印，那么结果必然分别是1和2。</p><p>但是我们不能保证右侧的第一条<code>print b</code>语句一定会打印出2的值，即使它在时间上发生于<code>b = 2</code>之后。因为指令重排序或者内存可见性问题都有可能会使它只能看到变量b在<code>b = 2</code>之前的原值。也就是说HB关系是没办法指定两条线程中在HB关系之前的语句相互之间的顺序关系的，在下图的例子中就是<code>print b</code>并不能保证一定可以打印出值2，也有可能打印出变量b原来的值。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-c4b55b9a0cdcad0f947c98e120d68c96_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"204\" data-rawheight=\"447\" class=\"content_image\" width=\"204\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;204&#39; height=&#39;447&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"204\" data-rawheight=\"447\" class=\"content_image lazy\" width=\"204\" data-actualsrc=\"https://pic3.zhimg.com/v2-c4b55b9a0cdcad0f947c98e120d68c96_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>总结</h2><p>在这篇文章中我们主要介绍了如何保证多线程程序的正确性，使运行过程和结果符合我们的预期。通过对多线程程序正确性问题的探索，我们介绍了<b>三种常用的线程同步方式</b>，分别是锁、CAS与volatile变量。其中，锁有synchronized关键字和<code>ReentrantLock</code>两种实现方式。</p><p>在这个过程中，我们深入到了计算机系统的底层，了解了计算机存储体系结构和<code>volatile</code>对高速缓存与内存的影响。多线程编程是一个非常好的切入口，让我们可以将以前曾经学过的计算机理论知识与编程实践结合起来，这种结合对非常多的高级知识领域都是至关重要的。</p><p>因为错误的程序是没有价值的，所以对一个程序来说最重要的当然是正确性。但是在实现了正确性的前提下，我们也必须要想办法提升程序的性能。因为多线程的目标就是通过多个线程的协作来提升程序的性能，如果达不到这个目标的话我们辛辛苦苦写的多线程代码就没有意义了。在下一篇文章中我们将会具体测试多线程程序的性能，通过发现多线程中那些会让多线程程序运行得比单线程程序更慢的性能陷阱，最终我们将找到解决这些陷阱的性能优化方法。下一篇文章将在下周发布，有兴趣的读者可以关注一下。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60214997", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 6, 
            "title": "线程池运行模型源码全解析", 
            "content": "<p>在上一篇文章<a href=\"https://zhuanlan.zhihu.com/p/60212693\" class=\"internal\">《从0到1玩转线程池》</a>中，我们了解了线程池的使用方法，以及向线程池中提交任务的完整流程和<code>ThreadPoolExecutor.execute</code>方法的源代码。在这篇文章中，我们将会从头阅读线程池<code>ThreadPoolExecutor</code>类的源代码，深入剖析线程池从提交任务到执行任务的完整流程，从而建立起完整的线程池运行模型。</p><h3>查看JDK源码的方式</h3><p>在IDE中，例如IDEA里，我们可以点击我们样例代码里的<code>ThreadPoolExecutor</code>类跳转到JDK中<code>ThreadPoolExecutor</code>类的源代码。在源代码中我们可以看到很多<code>java.util.concurrent</code>包的缔造者大牛“Doug Lea”所留下的各种注释，下面的图片就是该类源代码的一个截图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些注释的内容非常有参考价值，建议有能力的读者朋友可以自己阅读一遍。下面，我们就开始阅读<code>ThreadPoolExecutor</code>的源代码吧。</p><h3>控制变量与线程池生命周期</h3><p>在<code>ThreadPoolExecutor</code>类定义的开头，我们可以看到如下的几行代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 控制变量，前3位表示状态，剩下的数据位表示有效的线程数\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">ctl</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">(</span><span class=\"n\">ctlOf</span><span class=\"o\">(</span><span class=\"n\">RUNNING</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">));</span>\n<span class=\"c1\">// Integer的位数减去3位状态位就是线程数的位数\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">COUNT_BITS</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">SIZE</span> <span class=\"o\">-</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n<span class=\"c1\">// CAPACITY就是线程数的上限（含），即2^COUNT_BITS - 1个\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">CAPACITY</span>   <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p>第一行是一个用来作为控制变量的整型值，即一个Integer。之所以要用<code>AtomicInteger</code>类是因为要保证多线程安全，在本系列之后的文章中会对<code>AtomicInteger</code>进行具体介绍。一个整型一般是32位，但是这里的代码为了保险起见，还是使用了<code>Integer.SIZE</code>来表示整型的总位数。这里的“位”指的是数据位(bit)，在计算机中，8bit = 1字节，1024字节 = 1KB，1024KB = 1MB。每一位都是一个0或1的数字，我们如果把整型想象成一个二进制(0或1)的数组，那么一个Integer就是32个数字的数组。其中，前三个被用来表示状态，那么我们就可以表示2^3 = 8个不同的状态了。剩下的29位二进制数字都会被用于表示当前线程池中有效线程的数量，上限就是(2^29 - 1)个，即常量<code>CAPACITY</code>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>之后的部分列出了线程池的所有状态：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">RUNNING</span>    <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">SHUTDOWN</span>   <span class=\"o\">=</span>  <span class=\"n\">0</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">STOP</span>       <span class=\"o\">=</span>  <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">TIDYING</span>    <span class=\"o\">=</span>  <span class=\"n\">2</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">TERMINATED</span> <span class=\"o\">=</span>  <span class=\"n\">3</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span></code></pre></div><p>在这里可以忽略数字后面的<code>&lt;&lt; COUNT_BITS</code>，可以把状态简单地理解为前面的数字部分，这样的简化基本不影响结论。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>各个状态的解释如下： </p><ul><li>RUNNING，正常运行状态，可以接受新的任务和处理队列中的任务 </li><li>SHUTDOWN，关闭中状态，不能接受新任务，但是可以处理队列中的任务 </li><li>STOP，停止中状态，不能接受新任务，也不处理队列中的任务，会中断进行中的任务 </li><li>TIDYING，待结束状态，所有任务已经结束，线程数归0，进入TIDYING状态后将会运行<code>terminated()</code>方法 </li><li>TERMINATED，结束状态，<code>terminated()</code>方法调用完成后进入</li></ul><p>这几个状态所对应的数字值是按照顺序排列的，也就是说线程池的状态只能从小到大变化，这也方便了通过数字比较来判断状态所在的阶段，这种通过数字大小来比较状态值的方法在<code>ThreadPoolExecutor</code>的源码中会有大量的使用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图是这五个状态之间的变化过程： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;765&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_b.jpg\"/></figure><ol><li>当线程池被创建时会处于<b>RUNNING</b>状态，正常接受和处理任务； </li><li>当<code>shutdown()</code>方法被直接调用，或者在线程池对象被GC回收时通过<code>finalize()</code>方法隐式调用了<code>shutdown()</code>方法时，线程池会进入<b>SHUTDOWN</b>状态。该状态下线程池仍然会继续执行完阻塞队列中的任务，只是不再接受新的任务了。当队列中的任务被执行完后，线程池中的线程也会被回收。当队列和线程都被清空后，线程池将进入<b>TIDYING</b>状态； </li><li>在线程池处于<b>RUNNING</b>或者<b>SHUTDOWN</b>状态时，如果有代码调用了<code>shutdownNow()</code>方法，则线程池会进入<b>STOP</b>状态。在<b>STOP</b>状态下，线程池会直接清空阻塞队列中待执行的任务，然后中断所有正在进行中的任务并回收线程。当线程都被清空以后，线程池就会进入<b>TIDYING</b>状态； </li><li>当线程池进入<b>TIDYING</b>状态时，将会运行<code>terminated()</code>方法，该方法执行完后，线程池就会进入最终的<b>TERMINATED</b>状态，彻底结束。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>到这里我们就已经清楚地了解了线程从刚被创建时的<b>RUNNING</b>状态一直到最终的<b>TERMINATED</b>状态的整个生命周期了。那么当我们要向一个<b>RUNNING</b>状态的线程池提交任务时会发生些什么呢？</p><h3>execute方法的实现</h3><p>我们一般会使用<code>execute</code>方法提交我们的任务，那么线程池在这个过程中做了什么呢？在<code>ThreadPoolExecutor</code>类的<code>execute()</code>方法的源代码中，我们主要做了四件事： </p><ol><li>如果当前线程池中的线程数小于核心线程数<b>corePoolSize</b>，则通过<b>threadFactory</b>创建一个新的线程，并把入参中的任务作为第一个任务传入该线程； </li><li>如果当前线程池中的线程数已经达到了核心线程数<b>corePoolSize</b>，那么就会通过<b>阻塞队列workerQueue</b>的<code>offer</code>方法来将任务添加到队列中保存，并等待线程空闲后进行执行； </li><li>如果线程数已经达到了corePoolSize且阻塞队列中无法插入该任务（比如已满），那么线程池就会再增加一个线程来执行该任务，除非线程数已经达到了最大线程数<b>maximumPoolSize</b>； </li><li>如果确实已经达到了最大线程数，那么就会通过<b>拒绝策略对象handler</b>拒绝这个任务。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>总体上的执行流程如下，下方的黑色同心圆代表流程结束：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1132&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里解释一下阻塞队列的定义，方便大家阅读：</p><blockquote> 线程池中的<b>阻塞队列</b>专门用于存放需要等待线程空闲的待执行任务，而<b>阻塞队列</b>是这样的一种数据结构，它是一个队列（类似于一个List），可以存放0到N个元素。我们可以对这个队列进行插入和弹出元素的操作，弹出操作可以理解为是一个获取并从队列中删除一个元素的操作。当队列中没有元素时，对这个队列的获取操作将会被阻塞，直到有元素被插入时才会被唤醒；当队列已满时，对这个队列的插入操作将会被阻塞，直到有元素被弹出后才会被唤醒。<br/><br/> 这样的一种数据结构非常适合于线程池的场景，当一个工作线程没有任务可处理时就会进入阻塞状态，直到有新任务提交后才被唤醒。</blockquote><p>线程池中常用的阻塞队列一般有三种类型：直连队列、无界队列、有界队列。不同的阻塞队列类型会被线程池的行为产生不同的影响，有兴趣的读者可以在上一篇文章<a href=\"https://zhuanlan.zhihu.com/p/60212693\" class=\"internal\">《从0到1玩转线程池》</a>中找到不同类型阻塞队列的具体解释。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是带有注释的源代码，大家可以和上面的流程对照起来参考一下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">command</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 检查提交的任务是否为空\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// 获取控制变量值\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 检查当前线程数是否达到了核心线程数\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 未达到核心线程数，则创建新线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将传入的任务作为该线程的第一个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">))</span>\n            <span class=\"c1\">// 添加线程成功则直接返回，否则继续执行\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 因为前面调用了耗时操作addWorker方法\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 所以线程池状态有可能发生了改变，重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 判断线程池当前状态是否是运行中\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果是则调用workQueue.offer方法将任务放入阻塞队列\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 因为执行了耗时操作“放入阻塞队列”，所以重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">recheck</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n        <span class=\"c1\">// 如果当前状态不是运行中，则将刚才放入阻塞队列的任务拿出，如果拿出成功，则直接拒绝这个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(!</span> <span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">remove</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span>\n            <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"c1\">// 如果线程池中没有线程了，那就创建一个\n</span><span class=\"c1\"></span>            <span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 如果放入阻塞队列失败（如队列已满），则添加一个线程\n</span><span class=\"c1\"></span>    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">))</span>\n        <span class=\"c1\">// 如果添加线程失败（如已经达到了最大线程数），则拒绝任务\n</span><span class=\"c1\"></span>        <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>从上面的源码中我们可以知道，当一个任务被通过<code>ThreadPoolExecutor</code>的<code>execute</code>方法提交到线程池中执行时，这个任务有可能以两种方式被执行： </p><ol><li>直接在创建一个新的<b>Worker</b>时被作为第一个任务传入，由这个新创建的线程来执行； </li><li>把任务放入一个阻塞队列，等待线程池中的工作线程<b>Worker</b>捞取任务进行执行。</li></ol><p>这里的这个<b>Worker</b>指的就是<code>ThreadPoolExecutor.Worker</code>类，这是一个<code>ThreadPoolExecutor</code>的内部类，用于对基础线程类<code>Thread</code>进行包装和对线程进行管理。那么线程池到底是怎么利用<code>Worker</code>类来实现持续不断地接收提交的任务并执行的呢？接下来，我们通过<code>ThreadPoolExecutor</code>的源代码来一步一步抽丝剥茧，揭开线程池运行模型的神秘面纱。</p><h3>addWorker方法</h3><p>在上文中的<code>execute</code>方法的代码中我们可以看到线程池是通过<code>addWorker</code>方法来向线程池中添加新线程的，那么新的线程又是如何运行起来的呢？</p><p>这里我们暂时跳过<code>addWorker</code>方法的详细源代码，因为虽然这个方法的代码行数较多，但是功能相对比较直接，只是通过<code>new Worker(firstTask)</code>创建了一个代表线程的<code>Worker</code>对象，然后调用了这个对象所包含的<code>Thread</code>对象的<code>start()</code>方法。</p><p>我们知道一旦调用了<code>Thread</code>类的<code>start()</code>方法，则这个线程就会开始执行创建线程时传入的<code>Runnable</code>对象。从下面的<code>Worker</code>类构造器源代码可以看出，<code>Worker</code>类正是把自己(this引用)传入了线程的构造器当中，所以这个线程启动后就会执行<code>Worker</code>类的<code>run()</code>方法了，而在<code>Worker</code>的<code>run()</code>方法中只执行了一行很简单的代码<code>runWorker(this)</code>。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Worker</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">firstTask</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">setState</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span> <span class=\"c1\">// inhibit interrupts until runWorker\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">firstTask</span> <span class=\"o\">=</span> <span class=\"n\">firstTask</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">thread</span> <span class=\"o\">=</span> <span class=\"n\">getThreadFactory</span><span class=\"o\">().</span><span class=\"na\">newThread</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">runWorker</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><h3>runWorker方法的实现</h3><p>我们看到线程池中的线程在启动时会调用对应的<code>Worker</code>类的<code>runWorker</code>方法，而这里就是整个线程池任务执行的核心所在了。<code>runWorker</code>方法中包含有一个类似无限循环的while语句，让worker对象可以一直持续不断地执行提交到线程池中的新任务或者等待下一个新任务的提交。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大家可以配合代码上带有的注释来理解该方法的具体实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">runWorker</span><span class=\"o\">(</span><span class=\"n\">Worker</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">wt</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n    <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">firstTask</span><span class=\"o\">;</span>\n    <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">firstTask</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"c1\">// 将worker的状态重置为正常状态，因为state状态值在构造器中被初始化为-1\n</span><span class=\"c1\"></span>    <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 通过completedAbruptly变量的值判断任务是否正常执行完成\n</span><span class=\"c1\"></span>    <span class=\"kt\">boolean</span> <span class=\"n\">completedAbruptly</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 如果task为null就通过getTask方法获取阻塞队列中的下一个任务\n</span><span class=\"c1\"></span>        <span class=\"c1\">// getTask方法一般不会返回null，所以这个while类似于一个无限循环\n</span><span class=\"c1\"></span>        <span class=\"c1\">// worker对象就通过这个方法的持续运行来不断处理新的任务\n</span><span class=\"c1\"></span>        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">task</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">getTask</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 每一次任务的执行都必须获取锁来保证下方临界区代码的线程安全\n</span><span class=\"c1\"></span>            <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果状态值大于等于STOP（状态值是有序的，即STOP、TIDYING、TERMINATED）\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 且当前线程还没有被中断，则主动中断线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">runStateAtLeast</span><span class=\"o\">(</span><span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(),</span> <span class=\"n\">STOP</span><span class=\"o\">)</span> <span class=\"o\">||</span>\n                 <span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">interrupted</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span>\n                  <span class=\"n\">runStateAtLeast</span><span class=\"o\">(</span><span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(),</span> <span class=\"n\">STOP</span><span class=\"o\">)))</span> <span class=\"o\">&amp;&amp;</span>\n                <span class=\"o\">!</span><span class=\"n\">wt</span><span class=\"o\">.</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span>\n                <span class=\"n\">wt</span><span class=\"o\">.</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 开始\n</span><span class=\"c1\"></span>            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行任务前处理操作，默认是一个空实现\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 在子类中可以通过重写来改变任务执行前的处理行为\n</span><span class=\"c1\"></span>                <span class=\"n\">beforeExecute</span><span class=\"o\">(</span><span class=\"n\">wt</span><span class=\"o\">,</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n\n                <span class=\"c1\">// 通过thrown变量保存任务执行过程中抛出的异常\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 提供给下面finally块中的afterExecute方法使用\n</span><span class=\"c1\"></span>                <span class=\"n\">Throwable</span> <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// *** 重要：实际执行任务的代码\n</span><span class=\"c1\"></span>                    <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">RuntimeException</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Error</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Throwable</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 因为Runnable接口的run方法中不能抛出Throwable对象\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// 所以要包装成Error对象抛出\n</span><span class=\"c1\"></span>                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">Error</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 执行任务后处理操作，默认是一个空实现\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// 在子类中可以通过重写来改变任务执行后的处理行为\n</span><span class=\"c1\"></span>                    <span class=\"n\">afterExecute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">,</span> <span class=\"n\">thrown</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 将循环变量task设置为null，表示已处理完成\n</span><span class=\"c1\"></span>                <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                <span class=\"c1\">// 累加当前worker已经完成的任务数\n</span><span class=\"c1\"></span>                <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">completedTasks</span><span class=\"o\">++;</span>\n                <span class=\"c1\">// 释放while体中第一行获取的锁\n</span><span class=\"c1\"></span>                <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 将completedAbruptly变量设置为false，表示任务正常处理完成\n</span><span class=\"c1\"></span>        <span class=\"n\">completedAbruptly</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 销毁当前的worker对象，并完成一些诸如完成任务数量统计之类的辅助性工作\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 在线程池当前状态小于STOP的情况下会创建一个新的worker来替换被销毁的worker\n</span><span class=\"c1\"></span>        <span class=\"n\">processWorkerExit</span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">completedAbruptly</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>在<code>runWorker</code>方法的源代码中有两个比较重要的方法调用，一个是while条件中对<code>getTask</code>方法的调用，一个是在方法的最后对<code>processWorkerExit</code>方法的调用。下面是对这两个方法更详细的解释。</p><p><code>getTask</code>方法在阻塞队列中有待执行的任务时会从队列中弹出一个任务并返回，如果阻塞队列为空，那么就会阻塞等待新的任务提交到队列中直到超时（在一些配置下会一直等待而不超时），如果在超时之前获取到了新的任务，那么就会将这个任务作为返回值返回。所以一般<code>getTask</code>方法是不会返回null的，只会阻塞等待下一个任务并在之后将这个新任务作为返回值返回。</p><p>当<code>getTask</code>方法返回null时会导致当前Worker退出，当前线程被销毁。在以下情况下<code>getTask</code>方法才会返回null：</p><ol><li>当前线程池中的线程数超过了最大线程数。这是因为运行时通过调用<code>setMaximumPoolSize</code>修改了最大线程数而导致的结果； </li><li>线程池处于STOP状态。这种情况下所有线程都应该被立即回收销毁； </li><li>线程池处于SHUTDOWN状态，且阻塞队列为空。这种情况下已经不会有新的任务被提交到阻塞队列中了，所以线程应该被销毁； </li><li>线程可以被超时回收的情况下等待新任务超时。线程被超时回收一般有以下两种情况：     </li></ol><ul><li>超出核心线程数部分的线程等待任务超时     </li><li>允许核心线程超时（线程池配置）的情况下线程等待任务超时</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><code>processWorkerExit</code>方法会销毁当前线程对应的Worker对象，并执行一些累加总处理任务数等辅助操作，但在线程池当前状态小于STOP的情况下会创建一个新的Worker来替换被销毁的Worker。</p><p>对<code>getTask</code>和<code>processWorkerExit</code>方法源代码感兴趣的读者可以阅读下一节来具体了解一下，不过跳过这一节也是完全可以的。</p><h3>getTask与processWorkerExit方法源代码</h3><p>以下是<code>getTask</code>与<code>processWorkerExit</code>两个方法的带有中文解释的源代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"n\">Runnable</span> <span class=\"nf\">getTask</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 通过timeOut变量表示线程是否空闲时间超时了\n</span><span class=\"c1\"></span>    <span class=\"kt\">boolean</span> <span class=\"n\">timedOut</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n\n    <span class=\"c1\">// 无限循环\n</span><span class=\"c1\"></span>    <span class=\"k\">for</span> <span class=\"o\">(;;)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 获取线程池状态\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">rs</span> <span class=\"o\">=</span> <span class=\"n\">runStateOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// Check if queue empty only if necessary.\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 如果 线程池状态&gt;=STOP\n</span><span class=\"c1\"></span>        <span class=\"c1\">//    或者 (线程池状态==SHUTDOWN &amp;&amp; 阻塞队列为空)\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 则直接减少一个worker计数并返回null（返回null会导致当前worker被销毁）\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">&gt;=</span> <span class=\"n\">SHUTDOWN</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">rs</span> <span class=\"o\">&gt;=</span> <span class=\"n\">STOP</span> <span class=\"o\">||</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()))</span> <span class=\"o\">{</span>\n            <span class=\"n\">decrementWorkerCount</span><span class=\"o\">();</span>\n            <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 获取线程池中的worker计数\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">wc</span> <span class=\"o\">=</span> <span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 判断当前线程是否会被超时销毁\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 会被超时销毁的情况：线程池允许核心线程超时 或 当前线程数大于核心线程数\n</span><span class=\"c1\"></span>        <span class=\"kt\">boolean</span> <span class=\"n\">timed</span> <span class=\"o\">=</span> <span class=\"n\">allowCoreThreadTimeOut</span> <span class=\"o\">||</span> <span class=\"n\">wc</span> <span class=\"o\">&gt;</span> <span class=\"n\">corePoolSize</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 如果 (当前线程数大于最大线程数 或 (允许超时销毁 且 当前发生了空闲时间超时))\n</span><span class=\"c1\"></span>        <span class=\"c1\">//   且 (当前线程数大于1 或 阻塞队列为空) —— 该条件在阻塞队列不为空的情况下保证至少会保留一个线程继续处理任务\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 则 减少worker计数并返回null（返回null会导致当前worker被销毁）\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">wc</span> <span class=\"o\">&gt;</span> <span class=\"n\">maximumPoolSize</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">timed</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">timedOut</span><span class=\"o\">))</span>\n            <span class=\"o\">&amp;&amp;</span> <span class=\"o\">(</span><span class=\"n\">wc</span> <span class=\"o\">&gt;</span> <span class=\"n\">1</span> <span class=\"o\">||</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">()))</span> <span class=\"o\">{</span>\n            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">compareAndDecrementWorkerCount</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">))</span>\n                <span class=\"k\">return</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n            <span class=\"k\">continue</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"k\">try</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 从阻塞队列中取出一个任务（如果队列为空会进入阻塞等待状态）\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 如果允许空闲超时销毁线程的话则带有一个等待的超时时间\n</span><span class=\"c1\"></span>            <span class=\"n\">Runnable</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">timed</span> <span class=\"o\">?</span>\n                <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">poll</span><span class=\"o\">(</span><span class=\"n\">keepAliveTime</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">NANOSECONDS</span><span class=\"o\">)</span> <span class=\"o\">:</span>\n                <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">take</span><span class=\"o\">();</span>\n            <span class=\"c1\">// 如果获取到了任务就直接返回该任务，返回后会开始执行该任务\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">r</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span> <span class=\"n\">r</span><span class=\"o\">;</span>\n            <span class=\"c1\">// 如果任务为null，则说明发生了等待超时，将空闲时间超时标志设置为true\n</span><span class=\"c1\"></span>            <span class=\"n\">timedOut</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">InterruptedException</span> <span class=\"n\">retry</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 如果等待被中断了，那说明空闲时间（等待任务的时间）还没有超时\n</span><span class=\"c1\"></span>            <span class=\"n\">timedOut</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><b>processWorkerExit方法的源代码：</b></p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kt\">void</span> <span class=\"nf\">processWorkerExit</span><span class=\"o\">(</span><span class=\"n\">Worker</span> <span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"kt\">boolean</span> <span class=\"n\">completedAbruptly</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 如果completedAbruptly为true则表示任务执行过程中抛出了未处理的异常\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 所以还没有正确地减少worker计数，这里需要减少一次worker计数\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">completedAbruptly</span><span class=\"o\">)</span>\n        <span class=\"n\">decrementWorkerCount</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// 获取线程池的主锁\n</span><span class=\"c1\"></span>    <span class=\"kd\">final</span> <span class=\"n\">ReentrantLock</span> <span class=\"n\">mainLock</span> <span class=\"o\">=</span> <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">mainLock</span><span class=\"o\">;</span>\n    <span class=\"n\">mainLock</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 把将被销毁的线程已完成的任务数累计到线程池的完成任务总数上\n</span><span class=\"c1\"></span>        <span class=\"n\">completedTaskCount</span> <span class=\"o\">+=</span> <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">completedTasks</span><span class=\"o\">;</span>\n        <span class=\"c1\">// 从worker集合中去掉将会销毁的worker\n</span><span class=\"c1\"></span>        <span class=\"n\">workers</span><span class=\"o\">.</span><span class=\"na\">remove</span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 释放线程池主锁\n</span><span class=\"c1\"></span>        <span class=\"n\">mainLock</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 尝试结束线程池\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 这里是为了在关闭线程池时等到所有worker都被回收后再结束线程池\n</span><span class=\"c1\"></span>    <span class=\"n\">tryTerminate</span><span class=\"o\">();</span>\n\n    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 如果线程池状态 &lt; STOP，即RUNNING或SHUTDOWN\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 则需要考虑创建新线程来代替被销毁的线程\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">runStateLessThan</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">,</span> <span class=\"n\">STOP</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 如果worker是正常执行完的，则要判断一下是否已经满足了最小线程数要求\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 否则直接创建替代线程\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">completedAbruptly</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 如果允许核心线程超时则最小线程数是0，否则最小线程数等于核心线程数\n</span><span class=\"c1\"></span>            <span class=\"kt\">int</span> <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">allowCoreThreadTimeOut</span> <span class=\"o\">?</span> <span class=\"n\">0</span> <span class=\"o\">:</span> <span class=\"n\">corePoolSize</span><span class=\"o\">;</span>\n            <span class=\"c1\">// 如果阻塞队列非空，则至少要有一个线程继续执行剩下的任务\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">min</span> <span class=\"o\">==</span> <span class=\"n\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">!</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">isEmpty</span><span class=\"o\">())</span>\n                <span class=\"n\">min</span> <span class=\"o\">=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n            <span class=\"c1\">// 如果当前线程数已经满足最小线程数要求\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 那么就不创建替代线程了\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&gt;=</span> <span class=\"n\">min</span><span class=\"o\">)</span>\n                <span class=\"k\">return</span><span class=\"o\">;</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 重新创建一个worker来代替被销毁的线程\n</span><span class=\"c1\"></span>        <span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><h3>总结</h3><p>到这里我们的线程池源代码之旅就结束了，在这篇文章中我们首先了解了线程池中的控制变量与状态变换流程，之后我们通过线程池的源代码深入解析了从提交任务到执行任务的全过程，相信通过这些知识我们已经可以在脑海中建立起一套完整的线程池运行模型了。如果大家有一些细节感觉还不是特别清晰的话，建议不妨再返回到文章的开头多读几遍，相信第二遍的阅读能给大家带来不一样的体验，因为我自己也是在第三次读<code>ThreadPoolExecutor</code>类的源代码时才真正打通了其中的一些重要关节的。</p><h3>引子</h3><p>在浏览<code>ThreadPoolExexutor</code>源码的过程中，有几个点我们其实并没有完全说清楚，比如对锁的加锁操作、对控制变量的多次获取、控制变量的AtomicInteger类型。在下一篇文章中，我将会介绍这些以锁、volatile变量、CAS操作、AQS抽象类为代表的一系列线程同步方法，欢迎感兴趣的读者继续关注我后续发布的文章~</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }, 
                {
                    "tag": "Java Web", 
                    "tagLink": "https://api.zhihu.com/topics/19622819"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/60212693", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 23, 
            "title": "从0到1玩转线程池", 
            "content": "<p>我们一般不会选择直接使用线程类<code>Thread</code>进行多线程编程，而是使用更方便的线程池来进行任务的调度和管理。线程池就像共享单车，我们只要在我们有需要的时候去获取就可以了。甚至可以说线程池更棒，我们只需要把任务提交给它，它就会在合适的时候运行了。但是如果直接使用<code>Thread</code>类，我们就需要在每次执行任务时自己创建、运行、等待线程了，而且很难对线程进行整体的管理，这可不是一件轻松的事情。既然我们已经有了线程池，那还是把这些麻烦事交给线程池来处理吧。</p><p>之前一篇介绍线程池使用及其源码的文章篇幅太长了、跨度太大了一些，感觉不是很好理解。所以我把内容重新组织了一下，拆为了两篇文章，并且补充了一些内容，希望能让大家更容易地理解相关内容。</p><p>这篇文章将从线程池的概念与一般使用入手，首先介绍线程池的一般使用。然后详细介绍线程池中常用的可配置项，例如任务队列、拒绝策略等，最后会介绍四种常用的线程池配置。通过这篇文章，大家可以熟练掌握线程池的使用方式，在实践中游刃有余地使用线程池对线程进行灵活的调度。</p><p>阅读本文需要对多线程编程有基本的认识，例如什么是线程、多线程解决的是什么问题等。不了解的读者可以参考一下我之前发布的一篇文章：</p><a href=\"https://zhuanlan.zhihu.com/p/58820656\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-70efb1b760ac7fcf82994f3b8adb421b_180x120.jpg\" data-image-width=\"1280\" data-image-height=\"960\" class=\"internal\">兜里有辣条：这一次，让我们完全掌握Java多线程(2/10)</a><p>一般我们最常用的线程池实现类是<code>ThreadPoolExecutor</code>，我们接下来会介绍这个类的基本使用方法。JDK已经对线程池做了比较好的封装，相信这个过程会非常轻松。</p><p class=\"ztext-empty-paragraph\"><br/></p><h2>线程池的基本使用</h2><h3>创建线程池</h3><p>既然线程池是一个Java类，那么最直接的使用方法一定是new一个<code>ThreadPoolExecutor</code>类的对象，例如<code>ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;() )</code>。那么这个构造器的里每个参数是什么意思呢？我们可以暂时不用关心这些细节，继续完成线程池的使用之旅，稍后再回头来研究这个问题。</p><h3>提交任务</h3><p>当创建了一个线程池之后我们就可以将任务提交到线程池中执行了。提交任务到线程池中相当简单，我们只要把原来传入<code>Thread</code>类构造器的<code>Runnable</code>对象传入线程池的<code>execute</code>方法或者<code>submit</code>方法就可以了。<code>execute</code>方法和<code>submit</code>方法基本没有区别，两者的区别只是<code>submit</code>方法会返回一个<code>Future</code>对象，用于检查异步任务的执行情况和获取执行结果（异步任务完成后）。</p><p>我们可以先试试如何使用比较简单的<code>execute</code>方法，代码例子如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadPoolTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">ThreadPoolTest</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"c1\">// 重要：创建线程池\n</span><span class=\"c1\"></span>        <span class=\"n\">ThreadPoolExecutor</span> <span class=\"n\">threadPool</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0L</span><span class=\"o\">,</span>\n        <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n\n        <span class=\"c1\">// 重要：向线程池提交两个任务\n</span><span class=\"c1\"></span>        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 等待线程池中的所有任务完成\n</span><span class=\"c1\"></span>        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">awaitTermination</span><span class=\"o\">(</span><span class=\"n\">1L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MINUTES</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Not yet. Still waiting for termination&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>运行之后得到的结果是两百万，我们成功实现了第一个使用线程池的程序。那么回到刚才的问题，创建线程池时传入的那些参数有什么作用的呢？</p><h2>深入解析线程池</h2><h3>创建线程池的参数</h3><p>下面是<code>ThreadPoolExecutor</code>的构造器定义：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">,</span>\n                              <span class=\"kt\">int</span> <span class=\"n\">maximumPoolSize</span><span class=\"o\">,</span>\n                              <span class=\"kt\">long</span> <span class=\"n\">keepAliveTime</span><span class=\"o\">,</span>\n                              <span class=\"n\">TimeUnit</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n                              <span class=\"n\">BlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;</span> <span class=\"n\">workQueue</span><span class=\"o\">,</span>\n                              <span class=\"n\">ThreadFactory</span> <span class=\"n\">threadFactory</span><span class=\"o\">,</span>\n                              <span class=\"n\">RejectedExecutionHandler</span> <span class=\"n\">handler</span><span class=\"o\">)</span></code></pre></div><p>各个参数分别表示下面的含义：</p><ol><li> corePoolSize，核心线程池大小，一般线程池会至少保持这么多的线程数量； </li><li>maximumPoolSize，最大线程池大小，也就是线程池最大的线程数量； </li><li>keepAliveTime和unit共同组成了一个超时时间，<code>keepAliveTime</code>是时间数量，<code>unit</code>是时间单位，单位加数量组成了最终的超时时间。这个超时时间表示如果线程池中包含了超过<code>corePoolSize</code>数量的线程，则在有线程空闲的时间超过了超时时间时该线程就会被销毁； </li><li>workQueue是任务的阻塞队列，在没有线程池中没有足够的线程可用的情况下会将任务先放入到这个阻塞队列中等待执行。这里传入的队列类型就决定了线程池在处理这些任务时的策略，具体类型会在下文中介绍； </li><li>threadFactory，线程的工厂对象，线程池通过该对象创建线程。我们可以通过传入自定义的实现了<code>ThreadFactory</code>接口的类来修改线程的创建逻辑，可以不传，默认使用<code>Executors.defaultThreadFactory()</code>作为默认的线程工厂； </li><li>handler，拒绝策略，在线程池无法执行或保存新提交的任务时进行处理的对象，常用的有以下几种策略类：     </li></ol><ul><li><code>ThreadPoolExecutor.AbortPolicy</code>，默认策略，行为是直接抛出<code>RejectedExecutionException</code>异常     </li><li><code>ThreadPoolExecutor.CallerRunsPolicy</code>，用调用者所在的线程来执行任务     </li><li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>，丢弃阻塞队列中最早提交的任务，并重试execute方法    </li><li><code>ThreadPoolExecutor.DiscardPolicy</code>，静默地直接丢弃任务，不返回任何错误</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>看到这里可能大部分读者并不能理解每个参数具体的作用，接下来我们就通过线程池源代码中使用了这些参数配置的代码来深入理解每一个参数的意义。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>execute方法的实现</h3><p>我们一般会使用<code>execute</code>方法提交我们的任务，那么线程池在这个过程中做了什么呢？在<code>ThreadPoolExecutor</code>类的<code>execute()</code>方法的源代码中，我们主要做了四件事： </p><ol><li>如果当前线程池中的线程数小于核心线程数<b>corePoolSize</b>，则通过<b>threadFactory</b>创建一个新的线程，并把入参中的任务作为第一个任务传入该线程； </li><li>如果当前线程池中的线程数已经达到了核心线程数<b>corePoolSize</b>，那么就会通过<b>阻塞队列workerQueue</b>的<code>offer</code>方法来将任务添加到队列中保存，并等待线程空闲后进行执行； </li><li>如果线程数已经达到了corePoolSize且阻塞队列中无法插入该任务（比如已满），那么线程池就会再增加一个线程来执行该任务，除非线程数已经达到了最大线程数<b>maximumPoolSize</b>； </li><li>如果确实已经达到了最大线程数，那么就会通过<b>拒绝策略对象handler</b>拒绝这个任务。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>总体上的执行流程如下，左侧的实心黑点代表流程开始，下方的黑色同心圆代表流程结束： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1132&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上面提到了线程池构造器参数中除了超时时间之外的所有参数的作用，相信大家根据上面的流程已经可以理解每个参数的意义了。但是有一个名词我们还一直没有深入讲解，那就是<b>阻塞队列</b>的含义。</p><p class=\"ztext-empty-paragraph\"><br/></p><h3>线程池中的阻塞队列</h3><p>线程池中的<b>阻塞队列</b>专门用于存放需要等待线程空闲的待执行任务，而<b>阻塞队列</b>是这样的一种数据结构，它是一个队列（类似于一个List），可以存放0到N个元素。我们可以对这个队列进行插入和弹出元素的操作，弹出操作可以理解为是一个获取并从队列中删除一个元素的操作。当队列中没有元素时，对这个队列的获取操作将会被阻塞，直到有元素被插入时才会被唤醒；当队列已满时，对这个队列的插入操作将会被阻塞，直到有元素被弹出后才会被唤醒。</p><p>这样的一种数据结构非常适合于线程池的场景，当一个工作线程没有任务可处理时就会进入阻塞状态，直到有新任务提交后才被唤醒。</p><p>在线程池中，不同的阻塞队列类型会被线程池的行为产生不同的影响，下面是三种我们最常用的阻塞队列类型： </p><ol><li>直连队列，以<code>SynchronousQueue</code>类为代表，队列不会存储任何任务。当有任务提交线程试图向队列中添加待执行任务时会被阻塞，直到有任务处理线程试图从队列中获取待执行任务时会与阻塞状态中的任务提交线程发生直接联系，由任务提交线程把任务直接交给任务执行线程； </li><li>无界队列，以<code>LinkedBlockingQueue</code>类为代表，队列中可以存储无限数量的任务。这种队列永远不会因为队列已满导致任务放入队列失败，所以结合前面介绍的流程我们可以发现，当使用无界队列时，线程池中的线程最多只能达到核心线程数就不会再增长了，最大线程数maximumPoolSize参数不会产生作用； </li><li>有界队列，以<code>ArrayBlockingQueue</code>类为代表，可以保存固定数量的任务。这种队列在实践中比较常用，因为它既不会因为保存太多任务导致资源消耗过多（无界队列），又不会因为任务提交线程被阻塞而影响到系统的性能（直连队列）。总体上来说，有界队列在实际效果上比较均衡。</li></ol><h3>阅读execute方法的源码</h3><p>在IDE中，例如IDEA里，我们可以点击我们样例代码里的<code>ThreadPoolExecutor</code>类跳转到JDK中<code>ThreadPoolExecutor</code>类的源代码。在源代码中我们可以看到很多<code>java.util.concurrent</code>包的缔造者大牛“Doug Lea”所留下的各种注释，下面的图片就是该类源代码的一个截图。 </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些注释的内容非常有参考价值，建议有能力的读者朋友可以自己阅读一遍。下面，我们就一步步地抽丝剥茧，来揭开线程池类<code>ThreadPoolExecutor</code>源代码的神秘面纱。不过这一步并不是必须的，可以跳过。</p><p>下面是<code>ThreadPoolExecutor</code>中<code>execute</code>方法带有中文解释的源代码，有兴趣的朋友可以和上面的流程对照起来参考一下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">command</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 检查提交的任务是否为空\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// 获取控制变量值\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 检查当前线程数是否达到了核心线程数\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 未达到核心线程数，则创建新线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将传入的任务作为该线程的第一个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">))</span>\n            <span class=\"c1\">// 添加线程成功则直接返回，否则继续执行\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 因为前面调用了耗时操作addWorker方法\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 所以线程池状态有可能发生了改变，重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 判断线程池当前状态是否是运行中\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果是则调用workQueue.offer方法将任务放入阻塞队列\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 因为执行了耗时操作“放入阻塞队列”，所以重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">recheck</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n        <span class=\"c1\">// 如果当前状态不是运行中，则将刚才放入阻塞队列的任务拿出，如果拿出成功，则直接拒绝这个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(!</span> <span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">remove</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span>\n            <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"c1\">// 如果线程池中没有线程了，那就创建一个\n</span><span class=\"c1\"></span>            <span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 如果放入阻塞队列失败（如队列已满），则添加一个线程\n</span><span class=\"c1\"></span>    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">))</span>\n        <span class=\"c1\">// 如果添加线程失败（如已经达到了最大线程数），则拒绝任务\n</span><span class=\"c1\"></span>        <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p>在这段源代码中，我们可以看到，线程池是通过<code>addWorker</code>方法来创建线程的，这里的这个Worker指的就是<code>ThreadPoolExecutor</code>类中用来对线程进行包装和管理的<code>Worker</code>类对象。如果想了解<code>Worker</code>类的具体执行流程可以阅读一下下一篇深入剖析线程池的任务执行流程的文章。</p><h3>超时时间</h3><p>那么还有一个我们没有提到的<b>超时时间</b>在这个过程中发挥了什么作用呢？从前面我们可以看出，线程数量被划分为了核心线程数和最大线程数。当线程没有任务可执行时会阻塞在从队列中获取新任务这个操作上，这时我们称这个线程为空闲线程，一旦有新任务被提交，则该线程就会退出阻塞状态并开始执行这个新任务。</p><p>如果当前线程池中的线程总数大于核心线程数，那么只要有线程的空闲时间超过了超时时间，那么这个线程就会被销毁；如果线程池中的线程总数小于等于核心线程数，那么超时线程就不会被销毁了（除了一些特殊情况外）。这也就是超时时间参数所发挥的作用了。</p><h2>其他线程池操作</h2><h3>关闭线程池</h3><p>在之前使用线程池执行任务的代码中为了等待线程池中的所有任务执行完已经使用了<code>shutdown()</code>方法，这是关闭线程池的一种方法。对于<code>ThreadPoolExecutor</code>，关闭线程池的方法主要有两个： </p><ol><li><code>shutdown()</code>，有序关闭线程池，调用后线程池会让已经提交的任务完成执行，但是不会再接受新任务。 </li><li><code>shutdownNow()</code>，直接关闭线程池，线程池中正在运行的任务会被中断，正在等待执行的任务不会再被执行，但是这些还在阻塞队列中等待的任务会被作为返回值返回。</li></ol><h3>监控线程池运行状态</h3><p>我们可以通过调用线程池对象上的一些方法来获取线程池当前的运行信息，常用的方法有： </p><ul><li>getTaskCount，线程池中已完成、执行中、等待执行的任务总数估计值。因为在统计过程中任务会发生动态变化，所以最后的结果并不是一个准确值； </li><li>getCompletedTaskCount，线程池中已完成的任务总数，这同样是一个估计值； </li><li>getLargestPoolSize，线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否充满过，也就是达到过maximumPoolSize； </li><li>getPoolSize，线程池当前的线程数量； </li><li>getActiveCount，当前线程池中正在执行任务的线程数量估计值。</li></ul><h2>四种常用线程池</h2><p>很多情况下我们也不会直接创建<code>ThreadPoolExecutor</code>类的对象，而是根据需要通过<code>Executors</code>的几个静态方法来创建特定用途的线程池。目前常用的线程池有四种： </p><ol><li>可缓存线程池，使用<code>Executors.newCachedThreadPool</code>方法创建 </li><li>定长线程池，使用<code>Executors.newFixedThreadPool</code>方法创建 </li><li>延时任务线程池，使用<code>Executors.newScheduledThreadPool</code>方法创建 </li><li>单线程线程池，使用<code>Executors.newSingleThreadExecutor</code>方法创建</li></ol><p>下面通过这些静态方法的源码来具体了解一下不同类型线程池的特性与适用场景。</p><h3>可缓存线程池</h3><p>JDK中的源码我们通过在IDE中进行跳转可以很方便地进行查看，下面就是<code>Executors.newCachedThreadPool</code>方法中的源代码。从代码中我们可以看到，可缓存线程池其实也是通过直接创建<code>ThreadPoolExecutor</code>类的构造器创建的，只是其中的参数都已经被设置好了，我们可以不用做具体的设置。所以我们要观察的重点就是在这个方法中具体产生了一个怎样配置的<code>ThreadPoolExecutor</code>对象，以及这样的线程池适用于怎样的场景。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>从下面的代码中，我们可以看到，传入<code>ThreadPoolExecutor</code>构造器的值有：     </p><ul><li>corePoolSize核心线程数为0，代表线程池中的线程数可以为0     </li><li>maximumPoolSize最大线程数为Integer.MAX_VALUE，代表线程池中最多可以有无限多个线程     </li><li>超时时间设置为60秒，表示线程池中的线程在空闲60秒后会被回收     </li><li>最后传入的是一个<code>SynchronousQueue</code>类型的阻塞队列，代表每一个新添加的任务都要马上有一个工作线程进行处理</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newCachedThreadPool</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">,</span>\n                                  <span class=\"n\">60L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">,</span>\n                                  <span class=\"k\">new</span> <span class=\"n\">SynchronousQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n<span class=\"o\">}</span></code></pre></div><p>所以可缓存线程池在添加任务时会优先使用空闲的线程，如果没有就创建一个新线程，线程数没有上限，所以每一个任务都会马上被分配到一个工作线程进行执行，不需要在阻塞队列中等待；如果线程池长期闲置，那么其中的所有线程都会被销毁，节约系统资源。</p><ul><li>优点</li><ul><li>任务在添加后可以马上执行，不需要进入阻塞队列等待</li><li>在闲置时不会保留线程，可以节约系统资源</li></ul><li>缺点</li><ul><li>对线程数没有限制，可能会过量消耗系统资源</li></ul><li>适用场景</li><ul><li>适用于大量短耗时任务和对响应时间要求较高的场景</li></ul></ul><h3>定长线程池</h3><p>传入<code>ThreadPoolExecutor</code>构造器的值有: </p><ul><li>corePoolSize核心线程数和maximumPoolSize最大线程数都为固定值<code>nThreads</code>，即线程池中的线程数量会保持在<code>nThreads</code>，所以被称为“定长线程池” </li><li>超时时间被设置为0毫秒，因为线程池中只有核心线程，所以不需要考虑超时释放 </li><li>最后一个参数使用了无界队列，所以在所有线程都在处理任务的情况下，可以无限添加任务到阻塞队列中等待执行</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">nThreads</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">nThreads</span><span class=\"o\">,</span> <span class=\"n\">nThreads</span><span class=\"o\">,</span>\n                                  <span class=\"n\">0L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span>\n                                  <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n<span class=\"o\">}</span></code></pre></div><p>定长线程池中的线程数会逐步增长到nThreads个，并且在之后空闲线程不会被释放，线程数会一直保持在<code>nThreads</code>个。如果添加任务时所有线程都处于忙碌状态，那么就会把任务添加到阻塞队列中等待执行，阻塞队列中任务的总数没有上限。</p><ul><li>优点</li><ul><li>线程数固定，对系统资源的消耗可控</li></ul><li>缺点</li><ul><li>在任务量暴增的情况下线程池不会弹性增长，会导致任务完成时间延迟</li><li>使用了无界队列，在线程数设置过小的情况下可能会导致过多的任务积压，引起任务完成时间过晚和资源被过度消耗的问题</li></ul><li>适用场景</li><ul><li>任务量峰值不会过高，且任务对响应时间要求不高的场景</li></ul></ul><h3>延时任务线程池</h3><p>与之前的两个方法不同，<code>Executors.newScheduledThreadPool</code>返回的是<code>ScheduledExecutorService</code>接口对象，可以提供延时执行、定时执行等功能。在线程池配置上有如下特点： </p><ul><li>maximumPoolSize最大线程数为无限，在任务量较大时可以创建大量新线程执行任务 </li><li>超时时间为0，线程空闲后会被立即销毁 </li><li>使用了延时工作队列，延时工作队列中的元素都有对应的过期时间，只有过期的元素才会被弹出</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ScheduledExecutorService</span> <span class=\"nf\">newScheduledThreadPool</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ScheduledThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">corePoolSize</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">ScheduledThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">corePoolSize</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">NANOSECONDS</span><span class=\"o\">,</span>\n          <span class=\"k\">new</span> <span class=\"n\">DelayedWorkQueue</span><span class=\"o\">());</span>\n<span class=\"o\">}</span></code></pre></div><p>延时任务线程池实现了<code>ScheduledExecutorService</code>接口，主要用于需要延时执行和定时执行的情况。</p><h3>单线程线程池</h3><p>单线程线程池中只有一个工作线程，可以保证添加的任务都以指定顺序执行（先进先出、后进先出、优先级）。但是如果线程池里只有一个线程，为什么我们还要用线程池而不直接用<code>Thread</code>呢？这种情况下主要有两种优点：一是我们可以通过共享的线程池很方便地提交任务进行异步执行，而不用自己管理线程的生命周期；二是我们可以使用任务队列并指定任务的执行顺序，很容易做到任务管理的功能。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newSingleThreadExecutor</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">FinalizableDelegatedExecutorService</span>\n        <span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span>\n                                <span class=\"n\">0L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span>\n                                <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;()));</span>\n<span class=\"o\">}</span></code></pre></div><h2>总结</h2><p>在这篇文章中我们从线程池的概念和基本使用方法说起，通过execute方法的源码深入剖析了任务提交的全过程和各个线程池构造器参数在线程池实际运行过程中所发挥的作用，还真正阅读了线程池类<code>ThreadPoolExecutor</code>的execute方法的源代码。最后，我们介绍了线程池的其他常用操作和四种常用的线程池。</p><p>到这里我们的线程池源代码之旅就结束了，希望大家在看完这篇文章之后能对线程池的使用和运行流程有了一个大概的印象。为什么说只是有了一个大概的印象呢？因为我觉得很多没有相关基础的读者读到这里可能还只是对线程池有了一个自己的认识，对其中的一些细节可能还没有完全捕捉到。所以我建议大家在看完这篇文章后不妨再返回到文章的开头多读几遍，相信第二遍的阅读能给大家带来不一样的体验，因为我自己也是在第三次读<code>ThreadPoolExecutor</code>类的源代码时才真正打通了其中的一些重要关节的。</p><h2>引子</h2><p>在这篇文章中，我们还只是探究了线程池的基本使用方法，以及提交任务方法<code>execute</code>的源代码。那么在任务提交以后是怎么被线程池所执行的呢？在下一篇文章中我们就可以找到答案，在下一篇文章中，我们会深入剖析线程池的任务执行流程。</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": [
                {
                    "userName": "开发者头条", 
                    "userLink": "https://www.zhihu.com/people/274db6a56fae2771a5a22377b0b083d0", 
                    "content": "<p>感谢您的分享！文章已推荐到《开发者头条》首页，欢迎点赞支持！使用开发者头条 App 搜索 394815 即可订阅《Java后端火箭班》</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/59644911", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 13, 
            "title": "Java线程池从使用到阅读源码(3/10)", 
            "content": "<p>我们一般不会选择直接使用线程类<code>Thread</code>进行多线程编程，而是使用更方便的线程池来进行任务的调度和管理。线程池就像共享单车，我们只要在我们有需要的时候去获取就可以了。甚至可以说线程池更棒，我们只需要把任务提交给它，它就会在合适的时候运行了。但是如果直接使用<code>Thread</code>类，我们就需要在每次执行任务时自己创建、运行、等待线程了，而且很难对线程进行整体的管理，这可不是一件轻松的事情。既然我们已经有了线程池，那还是把这些麻烦事交给线程池来处理吧。</p><p>这篇文章将会从线程池的概念与一般使用入手，首先让大家可以了解线程池的基本使用方法，之后会介绍实践中最常用的四种线程池。最后，我们会通过对JDK源代码的剖析深入了解线程池的运行过程和具体设计，真正达到知其然而知其所以然的水平。虽然只要了解了API就可以满足一般的日常使用了，但是只有当我们真正厘清了多线程相关的知识点，才能在面对多线程的实践与面试问题时做到游刃有余、成竹在胸。</p><p>本文是一系列多线程文章中的第三篇，主要讲解了线程池相关的知识，这个系列总共有十篇文章，前五篇暂定结构如下，感兴趣的读者可以关注一下：</p><p> 1. 并发基本概念——<a href=\"https://zhuanlan.zhihu.com/p/58316557\" class=\"internal\">当我们在说“并发、多线程”，说的是什么？</a> </p><p>2. 多线程入门——<a href=\"https://zhuanlan.zhihu.com/p/58316557\" class=\"internal\">这一次，让我们完全掌握Java多线程(2/10)</a> </p><p>3. 线程池使用与原理剖析——本文 </p><p>4. 线程同步机制 </p><p>5. 并发常见问题</p><h2><b>1 线程池的使用方法</b></h2><p>一般我们最常用的线程池实现类是<code>ThreadPoolExecutor</code>，我们接下来会介绍这个类的基本使用方法。JDK已经对线程池做了比较好的封装，相信这个过程会非常轻松。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>1.1 创建线程池</i></b></p><p>既然线程池是一个Java类，那么最直接的使用方法一定是new一个<code>ThreadPoolExecutor</code>类的对象，例如<code>ThreadPoolExecutor threadPool = new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;() )</code>。那么这个构造器的里每个参数是什么意思呢？</p><p>下面就是这个构造器的方法签名：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"nf\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">,</span>\n                              <span class=\"kt\">int</span> <span class=\"n\">maximumPoolSize</span><span class=\"o\">,</span>\n                              <span class=\"kt\">long</span> <span class=\"n\">keepAliveTime</span><span class=\"o\">,</span>\n                              <span class=\"n\">TimeUnit</span> <span class=\"n\">unit</span><span class=\"o\">,</span>\n                              <span class=\"n\">BlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;</span> <span class=\"n\">workQueue</span><span class=\"o\">)</span></code></pre></div><p>各个参数分别表示下面的含义： </p><ol><li>corePoolSize，核心线程池大小，一般线程池会至少保持这么多的线程数量； </li><li>maximumPoolSize，最大线程池大小，也就是线程池最大的线程数量； </li><li>keepAliveTime和unit共同组成了一个超时间，<code>keepAliveTime</code>是时间数量，<code>unit</code>是时间单位，单位加数量组成了最终的超时时间。这个超时时间表示如果线程池中包含了超过<code>corePoolSize</code>数量的线程，则在有线程空闲的时间超过了超时时间时该线程就会被销毁； </li><li>workQueue是任务的阻塞队列，在没有线程池中没有足够的线程可用的情况下会将任务先放入到这个阻塞队列中等待执行。这里传入的队列类型就决定了线程池在处理这些任务时的策略。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>线程池中的阻塞队列专门用于存放待执行的任务，在<code>ThreadPoolExecutor</code>中一个任务可以通过两种方式被执行：第一种是直接在创建一个新的Worker时被作为第一个任务传入，由这个新创建的线程来执行；第二种就是把任务放入一个阻塞队列，等待线程池中的工作线程捞取任务进行执行。</p><p>上面提到的<b>阻塞队列</b>是这样的一种数据结构，它是一个队列（类似于一个List），可以存放0到N个元素。我们可以对这个队列进行插入和弹出元素的操作，弹出操作可以理解为是一个获取并从队列中删除一个元素的操作。当队列中没有元素时，对这个队列的获取操作将会被阻塞，直到有元素被插入时才会被唤醒；当队列已满时，对这个队列的插入操作将会被阻塞，直到有元素被弹出后才会被唤醒。这样的一种数据结构非常适合于线程池的场景，当一个工作线程没有任务可处理时就会进入阻塞状态，直到有新任务提交后才被唤醒。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>1.2 提交任务</i></b></p><p>当创建了一个线程池之后我们就可以将任务提交到线程池中执行了。提交任务到线程池中相当简单，我们只要把原来传入<code>Thread</code>类构造器的<code>Runnable</code>对象传入线程池的<code>execute</code>方法或者<code>submit</code>方法就可以了。<code>execute</code>方法和<code>submit</code>方法基本没有区别，两者的区别只是<code>submit</code>方法会返回一个<code>Future</code>对象，用于检查异步任务的执行情况和获取执行结果（异步任务完成后）。</p><p>我们可以先试试如何使用比较简单的<code>execute</code>方法，代码例子如下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">ThreadPoolTest</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">ThreadPoolTest</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                        <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                    <span class=\"o\">}</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"c1\">// 重要：创建线程池\n</span><span class=\"c1\"></span>        <span class=\"n\">ThreadPoolExecutor</span> <span class=\"n\">threadPool</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">0L</span><span class=\"o\">,</span>\n        <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span> <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n\n        <span class=\"c1\">// 重要：向线程池提交两个任务\n</span><span class=\"c1\"></span>        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">execute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"c1\">// 等待线程池中的所有任务完成\n</span><span class=\"c1\"></span>        <span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">shutdown</span><span class=\"o\">();</span>\n        <span class=\"k\">while</span> <span class=\"o\">(!</span><span class=\"n\">threadPool</span><span class=\"o\">.</span><span class=\"na\">awaitTermination</span><span class=\"o\">(</span><span class=\"n\">1L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MINUTES</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n            <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;Not yet. Still waiting for termination&#34;</span><span class=\"o\">);</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><i><b>1.3 关闭线程池</b></i></p><p>上面的代码中为了等待线程池中的所有任务执行完已经使用了<code>shutdown()</code>方法，关闭线程池的方法主要有两个：</p><ol><li><code>shutdown()</code>，有序关闭线程池，调用后线程池会让已经提交的任务完成执行，但是不会再接受新任务。 </li><li><code>shutdownNow()</code>，直接关闭线程池，线程池中正在运行的任务会被中断，正在等待执行的任务不会再被执行，但是这些还在阻塞队列中等待的任务会被作为返回值返回。</li></ol><p><i><b>1.4 监控线程池运行状态</b></i></p><p>我们可以通过调用线程池对象上的一些方法来获取线程池当前的运行信息，常用的方法有：</p><ul><li>getTaskCount，线程池中已完成、执行中、等待执行的任务总数估计值。因为在统计过程中任务会发生动态变化，所以最后的结果并不是一个准确值； </li><li>getCompletedTaskCount，线程池中已完成的任务总数，这同样是一个估计值； </li><li>getLargestPoolSize，线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否充满过，也就是达到过maximumPoolSize； </li><li>getPoolSize，线程池当前的线程数量； </li><li>getActiveCount，当前线程池中正在执行任务的线程数量估计值。</li></ul><h2><b>2 四种常用线程池</b></h2><p>很多情况下我们也不会直接创建<code>ThreadPoolExecutor</code>类的对象，而是根据需要通过<code>Executors</code>的几个静态方法来创建特定用途的线程池。目前常用的线程池有四种： </p><ol><li>可缓存线程池，使用<code>Executors.newCachedThreadPool</code>方法创建 </li><li>定长线程池，使用<code>Executors.newFixedThreadPool</code>方法创建 </li><li>延时任务线程池，使用<code>Executors.newScheduledThreadPool</code>方法创建 </li><li>单线程线程池，使用<code>Executors.newSingleThreadExecutor</code>方法创建</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>下面通过这些静态方法的源码来具体了解一下不同类型线程池的特性与适用场景。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i><b>2.1 可缓存线程池</b></i></p><p>JDK中的源码我们通过在IDE中进行跳转可以很方便地进行查看，下面就是<code>Executors.newCachedThreadPool</code>方法中的源代码。从代码中我们可以看到，可缓存线程池其实也是通过直接创建<code>ThreadPoolExecutor</code>类的构造器创建的，只是其中的参数都已经被设置好了，我们可以不用做具体的设置。所以我们要观察的重点就是在这个方法中具体产生了一个怎样配置的<code>ThreadPoolExecutor</code>对象，以及这样的线程池适用于怎样的场景。</p><p>从下面的代码中，我们可以看到，传入<code>ThreadPoolExecutor</code>构造器的值有：</p><ul><li>corePoolSize核心线程数为0，代表线程池中的线程数可以为0     </li><li>maximumPoolSize最大线程数为Integer.MAX_VALUE，代表线程池中最多可以有无限多个线程     </li><li>超时时间设置为60秒，表示线程池中的线程在空闲60秒后会被回收     </li><li>最后传入的是一个<code>SynchronousQueue</code>类型的阻塞队列，代表每一个新添加的任务都要马上有一个工作线程进行处理</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newCachedThreadPool</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">,</span>\n                                  <span class=\"n\">60L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">SECONDS</span><span class=\"o\">,</span>\n                                  <span class=\"k\">new</span> <span class=\"n\">SynchronousQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n<span class=\"o\">}</span></code></pre></div><p>所以可缓存线程池在添加任务时会优先使用空闲的线程，如果没有就创建一个新线程，线程数没有上限，所以每一个任务都会马上被分配到一个工作线程进行执行，不需要在阻塞队列中等待；如果线程池长期闲置，那么其中的所有线程都会被销毁，节约系统资源。</p><ul><li>优点</li><ul><li>任务在添加后可以马上执行，不需要进入阻塞队列等待</li><li>在闲置时不会保留线程，可以节约系统资源</li></ul><li>缺点</li><ul><li>对线程数没有限制，可能会过量消耗系统资源</li></ul><li>适用场景</li><ul><li>适用于大量短耗时任务和对响应时间要求较高的场景</li></ul></ul><p><i><b>2.2 定长线程池</b></i></p><p>传入<code>ThreadPoolExecutor</code>构造器的值有: </p><ul><li>corePoolSize核心线程数和maximumPoolSize最大线程数都为固定值<code>nThreads</code>，即线程池中的线程数量会保持在<code>nThreads</code>，所以被称为“定长线程池” </li><li>超时时间被设置为0毫秒，因为线程池中只有核心线程，所以不需要考虑超时释放 </li><li>最后一个参数使用了无界队列，所以在所有线程都在处理任务的情况下，可以无限添加任务到阻塞队列中等待执行</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newFixedThreadPool</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">nThreads</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">nThreads</span><span class=\"o\">,</span> <span class=\"n\">nThreads</span><span class=\"o\">,</span>\n                                  <span class=\"n\">0L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span>\n                                  <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;());</span>\n<span class=\"o\">}</span></code></pre></div><p>定长线程池中的线程数会逐步增长到nThreads个，并且在之后空闲线程不会被释放，线程数会一直保持在<code>nThreads</code>个。如果添加任务时所有线程都处于忙碌状态，那么就会把任务添加到阻塞队列中等待执行，阻塞队列中任务的总数没有上限。</p><ul><li>优点</li><ul><li>线程数固定，对系统资源的消耗可控</li></ul><li>缺点</li><ul><li>在任务量暴增的情况下线程池不会弹性增长，会导致任务完成时间延迟</li><li>使用了无界队列，在线程数设置过小的情况下可能会导致过多的任务积压，引起任务完成时间过晚和资源被过度消耗的问题</li></ul><li>适用场景</li><ul><li>任务量峰值不会过高，且任务对响应时间要求不高的场景</li></ul></ul><p><i><b>2.3 延时任务线程池</b></i></p><p>与之前的两个方法不同，<code>Executors.newScheduledThreadPool</code>返回的是<code>ScheduledExecutorService</code>接口对象，可以提供延时执行、定时执行等功能。在线程池配置上有如下特点： </p><ul><li>maximumPoolSize最大线程数为无限，在任务量较大时可以创建大量新线程执行任务 </li><li>超时时间为0，线程空闲后会被立即销毁 </li><li>使用了延时工作队列，延时工作队列中的元素都有对应的过期时间，只有过期的元素才会被弹出</li></ul><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ScheduledExecutorService</span> <span class=\"nf\">newScheduledThreadPool</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">ScheduledThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">corePoolSize</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"nf\">ScheduledThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"kd\">super</span><span class=\"o\">(</span><span class=\"n\">corePoolSize</span><span class=\"o\">,</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">MAX_VALUE</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">,</span> <span class=\"n\">NANOSECONDS</span><span class=\"o\">,</span>\n          <span class=\"k\">new</span> <span class=\"n\">DelayedWorkQueue</span><span class=\"o\">());</span>\n<span class=\"o\">}</span></code></pre></div><p>延时任务线程池实现了<code>ScheduledExecutorService</code>接口，主要用于需要延时执行和定时执行的情况。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i><b>2.4 单线程线程池</b></i></p><p>单线程线程池中只有一个工作线程，可以保证添加的任务都以指定顺序执行（先进先出、后进先出、优先级）。但是如果线程池里只有一个线程，为什么我们还要用线程池而不直接用<code>Thread</code>呢？这种情况下主要有两种优点：一是我们可以通过共享的线程池很方便地提交任务进行异步执行，而不用自己管理线程的生命周期；二是我们可以使用任务队列并指定任务的执行顺序，很容易做到任务管理的功能。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"n\">ExecutorService</span> <span class=\"nf\">newSingleThreadExecutor</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"k\">return</span> <span class=\"k\">new</span> <span class=\"n\">FinalizableDelegatedExecutorService</span>\n        <span class=\"o\">(</span><span class=\"k\">new</span> <span class=\"n\">ThreadPoolExecutor</span><span class=\"o\">(</span><span class=\"n\">1</span><span class=\"o\">,</span> <span class=\"n\">1</span><span class=\"o\">,</span>\n                                <span class=\"n\">0L</span><span class=\"o\">,</span> <span class=\"n\">TimeUnit</span><span class=\"o\">.</span><span class=\"na\">MILLISECONDS</span><span class=\"o\">,</span>\n                                <span class=\"k\">new</span> <span class=\"n\">LinkedBlockingQueue</span><span class=\"o\">&lt;</span><span class=\"n\">Runnable</span><span class=\"o\">&gt;()));</span>\n<span class=\"o\">}</span></code></pre></div><h2><b>3 线程池的内部实现</b></h2><p>通过前面的内容我们其实已经可以在代码中使用线程池了，但是我们为什么还要去深究线程池的内部实现呢？首先，可能有一个很功利性的目的就是为了面试，在面试时如果能准确地说出一些底层的运行机制与原理那一定可以成为过程中一个重要的亮点。</p><p>但是我认为学习探究线程池的内部实现的作用绝对不仅是如此，只有深入了解并厘清了线程池的具体实现，我们才能解决实践中需要考虑的各种边界条件。因为多线程编程所代表的并发编程并不是一个固定的知识点，而是实践中不断在发展和完善的一个知识门类。我们也许会需要同时考虑多个维度，最后得到一个特定于应用场景的解决方案，这就要求我们具备从细节着手构建出解决方案并做好各个考虑维度之间的取舍的能力。</p><p>而且我相信只要在某一个点上能突破到相当的深度，那么以后从这个点上向外扩展就会容易得多。也许在刚开始我们的探究会碰到非常大的阻力，但是我们要相信，最后我们可以得到的将不止是一个知识点而是一整个知识面。</p><p><i><b>3.1 查看JDK源码的方式</b></i></p><p>在IDE中，例如IDEA里，我们可以点击我们样例代码里的<code>ThreadPoolExecutor</code>类跳转到JDK中<code>ThreadPoolExecutor</code>类的源代码。在源代码中我们可以看到很多<code>java.util.concurrent</code>包的缔造者大牛“Doug Lea”所留下的各种注释，下面的图片就是该类源代码的一个截图。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;724&#39; height=&#39;311&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"724\" data-rawheight=\"311\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"724\" data-original=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-25726843a1537952626ae88f01fb8b86_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这些注释的内容非常有参考价值，建议有能力的读者朋友可以自己阅读一遍。下面，我们就一步步地抽丝剥茧，来揭开线程池类<code>ThreadPoolExecutor</code>源代码的神秘面纱。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><i><b>3.2 控制变量与线程池生命周期</b></i></p><p>在<code>ThreadPoolExecutor</code>类定义的开头，我们可以看到如下的几行代码：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 控制变量，前3位表示状态，剩下的数据位表示有效的线程数\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">final</span> <span class=\"n\">AtomicInteger</span> <span class=\"n\">ctl</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">AtomicInteger</span><span class=\"o\">(</span><span class=\"n\">ctlOf</span><span class=\"o\">(</span><span class=\"n\">RUNNING</span><span class=\"o\">,</span> <span class=\"n\">0</span><span class=\"o\">));</span>\n<span class=\"c1\">// Integer的位数减去3位状态位就是线程数的位数\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">COUNT_BITS</span> <span class=\"o\">=</span> <span class=\"n\">Integer</span><span class=\"o\">.</span><span class=\"na\">SIZE</span> <span class=\"o\">-</span> <span class=\"n\">3</span><span class=\"o\">;</span>\n<span class=\"c1\">// CAPACITY就是线程数的上限（含），即2^COUNT_BITS - 1个\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">CAPACITY</span>   <span class=\"o\">=</span> <span class=\"o\">(</span><span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">)</span> <span class=\"o\">-</span> <span class=\"n\">1</span><span class=\"o\">;</span></code></pre></div><p>第一行是一个用来作为控制变量的整型值，即一个Integer。之所以要用<code>AtomicInteger</code>类是因为要保证多线程安全，在本系列之后的文章中会对<code>AtomicInteger</code>进行具体介绍。一个整型一般是32位，但是这里的代码为了保险起见，还是使用了<code>Integer.SIZE</code>来表示整型的总位数。这里的“位”指的是数据位(bit)，在计算机中，8bit = 1字节，1024字节 = 1KB，1024KB = 1MB。每一位都是一个0或1的数字，我们如果把整型想象成一个二进制(0或1)的数组，那么一个Integer就是32个数字的数组。其中，前三个被用来表示状态，那么我们就可以表示2^3 = 8个不同的状态了。剩下的29位二进制数字都会被用于表示当前线程池中有效线程的数量，上限就是(2^29 - 1)个，即常量<code>CAPACITY</code>。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>之后的部分列出了线程池的所有状态：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">RUNNING</span>    <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">SHUTDOWN</span>   <span class=\"o\">=</span>  <span class=\"n\">0</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">STOP</span>       <span class=\"o\">=</span>  <span class=\"n\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">TIDYING</span>    <span class=\"o\">=</span>  <span class=\"n\">2</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span>\n<span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kd\">final</span> <span class=\"kt\">int</span> <span class=\"n\">TERMINATED</span> <span class=\"o\">=</span>  <span class=\"n\">3</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">COUNT_BITS</span><span class=\"o\">;</span></code></pre></div><p>在这里可以忽略数字后面的<code>&lt;&lt; COUNT_BITS</code>，可以把状态简单地理解为前面的数字部分，这样的简化基本不影响结论。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>各个状态的解释如下： </p><ul><li>RUNNING，正常运行状态，可以接受新的任务和处理队列中的任务 </li><li>SHUTDOWN，关闭中状态，不能接受新任务，但是可以处理队列中的任务 </li><li>STOP，停止中状态，不能接受新任务，也不处理队列中的任务，会中断进行中的任务 </li><li>TIDYING，待结束状态，所有任务已经结束，线程数归0，进入TIDYING状态后将会运行<code>terminated()</code>方法 </li><li>TERMINATED，结束状态，<code>terminated()</code>方法调用完成后进入</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p>这几个状态所对应的数字值是按照顺序排列的，也就是说线程池的状态只能从小到大变化，这也方便了通过数字比较来判断状态所在的阶段，这种通过数字大小来比较状态值的方法在<code>ThreadPoolExecutor</code>的源码中会有大量的使用。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图是这五个状态之间的变化过程： </p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;765&#39; height=&#39;235&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"765\" data-rawheight=\"235\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"765\" data-original=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-e8f2795f32766eb25fb89e9ac915d672_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><ol><li>当线程池被创建时会处于<b>RUNNING</b>状态，正常接受和处理任务；</li><li>当<code>shutdown()</code>方法被直接调用，或者在线程池对象被GC回收时通过<code>finalize()</code>方法隐式调用了<code>shutdown()</code>方法时，线程池会进入<b>SHUTDOWN</b>状态。该状态下线程池仍然会继续执行完阻塞队列中的任务，只是不再接受新的任务了。当队列中的任务被执行完后，线程池中的线程也会被回收。当队列和线程都被清空后，线程池将进入<b>TIDYING</b>状态；</li><li>在线程池处于<b>RUNNING</b>或者<b>SHUTDOWN</b>状态时，如果有代码调用了<code>shutdownNow()</code>方法，则线程池会进入<b>STOP</b>状态。在<b>STOP</b>状态下，线程池会直接清空阻塞队列中待执行的任务，然后中断所有正在进行中的任务并回收线程。当线程都被清空以后，线程池就会进入<b>TIDYING</b>状态；</li><li>当线程池进入<b>TIDYING</b>状态时，将会运行<code>terminated()</code>方法，该方法执行完后，线程池就会进入最终的<b>TERMINATED</b>状态，彻底结束。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>到这里我们就已经清楚地了解了线程从刚被创建时的<b>RUNNING</b>状态一直到最终的<b>TERMINATED</b>状态的整个生命周期了。那么当我们要向一个<b>RUNNING</b>状态的线程池提交任务时会发生些什么呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b><i>3.3 execute方法的实现</i></b></p><p>我们一般会使用<code>execute</code>方法提交我们的任务，那么线程池在这个过程中做了什么呢？在<code>ThreadPoolExecutor</code>类的<code>execute()</code>方法的源代码中，我们主要做了四件事： </p><ol><li>如果当前线程池中的线程数小于核心线程数corePoolSize，则创建一个新的Worker代表一个线程，并把入参中的任务作为第一个任务传入Worker。<code>addWorker</code>方法中的第一个参数是该线程的第一个任务，而第二个参数就是代表是否创建的是核心线程，在<code>execute</code>方法中<code>addWorker</code>总共被调用了三次，其中第一次传入的是true，后两次传入的都是false； </li><li>如果当前线程池中的线程数已经满足了核心线程数corePoolSize，那么就会通过<code>workQueue.offer()</code>方法将任务添加到阻塞队列中等待执行； </li><li>如果线程数已经达到了corePoolSize且阻塞队列中无法插入该任务（比如已满），那么线程池就会再增加一个线程来执行该任务，除非线程数已经达到了最大线程数maximumPoolSize； </li><li>如果确实已经达到了最大线程数，那么就拒绝这个任务。</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>总体上的执行流程如下，下方的黑色同心圆代表流程结束：</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1132&#39; height=&#39;417&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1132\" data-rawheight=\"417\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1132\" data-original=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-296f7ca9dc87041c6bba60001374a1d8_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p> 这里再重复一次阻塞队列的定义，方便大家阅读：</p><blockquote> 线程池中的阻塞队列专门用于存放待执行的任务，在<code>ThreadPoolExecutor</code>中一个任务可以通过两种方式被执行：第一种是直接在创建一个新的Worker时被作为第一个任务传入，由这个新创建的线程来执行；第二种就是把任务放入一个阻塞队列，等待线程池中的工作线程捞取任务进行执行。<br/> 上面提到的<b>阻塞队列</b>是这样的一种数据结构，它是一个队列（类似于一个List），可以存放0到N个元素。我们可以对这个队列进行插入和弹出元素的操作，弹出操作可以理解为是一个获取并从队列中删除一个元素的操作。当队列中没有元素时，对这个队列的获取操作将会被阻塞，直到有元素被插入时才会被唤醒；当队列已满时，对这个队列的插入操作将会被阻塞，直到有元素被弹出后才会被唤醒。这样的一种数据结构非常适合于线程池的场景，当一个工作线程没有任务可处理时就会进入阻塞状态，直到有新任务提交后才被唤醒。<br/> </blockquote><p class=\"ztext-empty-paragraph\"><br/></p><p>下面是带有注释的源代码，大家可以和上面的流程对照起来参考一下：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">execute</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">command</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"c1\">// 检查提交的任务是否为空\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">command</span> <span class=\"o\">==</span> <span class=\"kc\">null</span><span class=\"o\">)</span>\n        <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">NullPointerException</span><span class=\"o\">();</span>\n\n    <span class=\"c1\">// 获取控制变量值\n</span><span class=\"c1\"></span>    <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 检查当前线程数是否达到了核心线程数\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">corePoolSize</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 未达到核心线程数，则创建新线程\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 并将传入的任务作为该线程的第一个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">true</span><span class=\"o\">))</span>\n            <span class=\"c1\">// 添加线程成功则直接返回，否则继续执行\n</span><span class=\"c1\"></span>            <span class=\"k\">return</span><span class=\"o\">;</span>\n\n        <span class=\"c1\">// 因为前面调用了耗时操作addWorker方法\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 所以线程池状态有可能发生了改变，重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n    <span class=\"o\">}</span>\n\n    <span class=\"c1\">// 判断线程池当前状态是否是运行中\n</span><span class=\"c1\"></span>    <span class=\"c1\">// 如果是则调用workQueue.offer方法将任务放入阻塞队列\n</span><span class=\"c1\"></span>    <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">c</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">workQueue</span><span class=\"o\">.</span><span class=\"na\">offer</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 因为执行了耗时操作“放入阻塞队列”，所以重新获取状态值\n</span><span class=\"c1\"></span>        <span class=\"kt\">int</span> <span class=\"n\">recheck</span> <span class=\"o\">=</span> <span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">();</span>\n        <span class=\"c1\">// 如果当前状态不是运行中，则将刚才放入阻塞队列的任务拿出，如果拿出成功，则直接拒绝这个任务\n</span><span class=\"c1\"></span>        <span class=\"k\">if</span> <span class=\"o\">(!</span> <span class=\"n\">isRunning</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">remove</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">))</span>\n            <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(</span><span class=\"n\">workerCountOf</span><span class=\"o\">(</span><span class=\"n\">recheck</span><span class=\"o\">)</span> <span class=\"o\">==</span> <span class=\"n\">0</span><span class=\"o\">)</span>\n            <span class=\"c1\">// 如果线程池中没有线程了，那就创建一个\n</span><span class=\"c1\"></span>            <span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"kc\">null</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n    <span class=\"c1\">// 如果放入阻塞队列失败（如队列已满），则添加一个线程\n</span><span class=\"c1\"></span>    <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"o\">(!</span><span class=\"n\">addWorker</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">,</span> <span class=\"kc\">false</span><span class=\"o\">))</span>\n        <span class=\"c1\">// 如果添加线程失败（如已经达到了最大线程数），则拒绝任务\n</span><span class=\"c1\"></span>        <span class=\"n\">reject</span><span class=\"o\">(</span><span class=\"n\">command</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p class=\"ztext-empty-paragraph\"><br/></p><p><i><b>3.4 addWorker方法</b></i></p><p>在前面<code>execute</code>方法的代码中我们可以看到线程池是通过<code>addWorker</code>方法来向线程池中添加新线程的，那么新的线程又是如何运行起来的呢？</p><p>这里我们暂时跳过<code>addWorker</code>方法的详细源代码，因为虽然这个方法的代码行数较多，但是功能相对比较直接，只是创建一个代表线程的<code>Worker</code>类对象，并调用这个对象所对应线程对象的<code>start()</code>方法。我们知道一旦调用了<code>Thread</code>类的<code>start()</code>方法，则这个线程就会开始调用创建线程时传入的<code>Runnable</code>对象。从下面的<code>Worker</code>类构造器源代码可以看出，<code>Worker</code>类正是把自己(this指针)传入了线程的构造器当中，那么这个线程就会运行<code>Worker</code>类的<code>run()</code>方法了，这个<code>run()</code>方法只执行了一行很简单的代码<code>runWorker(this)</code>。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Worker</span><span class=\"o\">(</span><span class=\"n\">Runnable</span> <span class=\"n\">firstTask</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">setState</span><span class=\"o\">(-</span><span class=\"n\">1</span><span class=\"o\">);</span> <span class=\"c1\">// inhibit interrupts until runWorker\n</span><span class=\"c1\"></span>    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">firstTask</span> <span class=\"o\">=</span> <span class=\"n\">firstTask</span><span class=\"o\">;</span>\n    <span class=\"k\">this</span><span class=\"o\">.</span><span class=\"na\">thread</span> <span class=\"o\">=</span> <span class=\"n\">getThreadFactory</span><span class=\"o\">().</span><span class=\"na\">newThread</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n<span class=\"o\">}</span>\n\n<span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"n\">runWorker</span><span class=\"o\">(</span><span class=\"k\">this</span><span class=\"o\">);</span>\n<span class=\"o\">}</span></code></pre></div><p><i><b>3.5 runWorker方法的实现</b></i></p><p>我们看到线程池中的线程在启动时会调用对应的<code>Worker</code>类的<code>runWorker</code>方法，而这里就是整个线程池任务执行的核心所在了。<code>runWorker</code>方法中包含有一个类似无限循环的while语句，让worker对象可以不断执行提交到线程池中的新任务。</p><p class=\"ztext-empty-paragraph\"><br/></p><p>大家可以配合代码上带有的注释来理解该方法的具体实现：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">final</span> <span class=\"kt\">void</span> <span class=\"nf\">runWorker</span><span class=\"o\">(</span><span class=\"n\">Worker</span> <span class=\"n\">w</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n    <span class=\"n\">Thread</span> <span class=\"n\">wt</span> <span class=\"o\">=</span> <span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">currentThread</span><span class=\"o\">();</span>\n    <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">firstTask</span><span class=\"o\">;</span>\n    <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">firstTask</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n    <span class=\"c1\">// 将worker的状态重置为正常状态，因为state状态值在构造器中被初始化为-1\n</span><span class=\"c1\"></span>    <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n    <span class=\"c1\">// 通过completedAbruptly变量的值判断任务是否正常执行完成\n</span><span class=\"c1\"></span>    <span class=\"kt\">boolean</span> <span class=\"n\">completedAbruptly</span> <span class=\"o\">=</span> <span class=\"kc\">true</span><span class=\"o\">;</span>\n    <span class=\"k\">try</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 如果task为null就通过getTask方法获取阻塞队列中的下一个任务\n</span><span class=\"c1\"></span>        <span class=\"c1\">// getTask方法一般不会返回null，所以这个while类似于一个无限循环\n</span><span class=\"c1\"></span>        <span class=\"c1\">// worker对象就通过这个方法的持续运行来不断处理新的任务\n</span><span class=\"c1\"></span>        <span class=\"k\">while</span> <span class=\"o\">(</span><span class=\"n\">task</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span> <span class=\"o\">||</span> <span class=\"o\">(</span><span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"n\">getTask</span><span class=\"o\">())</span> <span class=\"o\">!=</span> <span class=\"kc\">null</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"c1\">// 每一次任务的执行都必须获取锁来保证下方临界区代码的线程安全\n</span><span class=\"c1\"></span>            <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">lock</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 如果状态值大于等于STOP（状态值是有序的，即STOP、TIDYING、TERMINATED）\n</span><span class=\"c1\"></span>            <span class=\"c1\">// 且当前线程还没有被中断，则主动中断线程\n</span><span class=\"c1\"></span>            <span class=\"k\">if</span> <span class=\"o\">((</span><span class=\"n\">runStateAtLeast</span><span class=\"o\">(</span><span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(),</span> <span class=\"n\">STOP</span><span class=\"o\">)</span> <span class=\"o\">||</span>\n                 <span class=\"o\">(</span><span class=\"n\">Thread</span><span class=\"o\">.</span><span class=\"na\">interrupted</span><span class=\"o\">()</span> <span class=\"o\">&amp;&amp;</span>\n                  <span class=\"n\">runStateAtLeast</span><span class=\"o\">(</span><span class=\"n\">ctl</span><span class=\"o\">.</span><span class=\"na\">get</span><span class=\"o\">(),</span> <span class=\"n\">STOP</span><span class=\"o\">)))</span> <span class=\"o\">&amp;&amp;</span>\n                <span class=\"o\">!</span><span class=\"n\">wt</span><span class=\"o\">.</span><span class=\"na\">isInterrupted</span><span class=\"o\">())</span>\n                <span class=\"n\">wt</span><span class=\"o\">.</span><span class=\"na\">interrupt</span><span class=\"o\">();</span>\n\n            <span class=\"c1\">// 开始\n</span><span class=\"c1\"></span>            <span class=\"k\">try</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 执行任务前处理操作，默认是一个空实现\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 在子类中可以通过重写来改变任务执行前的处理行为\n</span><span class=\"c1\"></span>                <span class=\"n\">beforeExecute</span><span class=\"o\">(</span><span class=\"n\">wt</span><span class=\"o\">,</span> <span class=\"n\">task</span><span class=\"o\">);</span>\n\n                <span class=\"c1\">// 通过thrown变量保存任务执行过程中抛出的异常\n</span><span class=\"c1\"></span>                <span class=\"c1\">// 提供给下面finally块中的afterExecute方法使用\n</span><span class=\"c1\"></span>                <span class=\"n\">Throwable</span> <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                <span class=\"k\">try</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// *** 重要：实际执行任务的代码\n</span><span class=\"c1\"></span>                    <span class=\"n\">task</span><span class=\"o\">.</span><span class=\"na\">run</span><span class=\"o\">();</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">RuntimeException</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Error</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"n\">x</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span> <span class=\"k\">catch</span> <span class=\"o\">(</span><span class=\"n\">Throwable</span> <span class=\"n\">x</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 因为Runnable接口的run方法中不能抛出Throwable对象\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// 所以要包装成Error对象抛出\n</span><span class=\"c1\"></span>                    <span class=\"n\">thrown</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">;</span> <span class=\"k\">throw</span> <span class=\"k\">new</span> <span class=\"n\">Error</span><span class=\"o\">(</span><span class=\"n\">x</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                    <span class=\"c1\">// 执行任务后处理操作，默认是一个空实现\n</span><span class=\"c1\"></span>                    <span class=\"c1\">// 在子类中可以通过重写来改变任务执行后的处理行为\n</span><span class=\"c1\"></span>                    <span class=\"n\">afterExecute</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">,</span> <span class=\"n\">thrown</span><span class=\"o\">);</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n                <span class=\"c1\">// 将循环变量task设置为null，表示已处理完成\n</span><span class=\"c1\"></span>                <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"kc\">null</span><span class=\"o\">;</span>\n                <span class=\"c1\">// 累加当前worker已经完成的任务数\n</span><span class=\"c1\"></span>                <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">completedTasks</span><span class=\"o\">++;</span>\n                <span class=\"c1\">// 释放while体中第一行获取的锁\n</span><span class=\"c1\"></span>                <span class=\"n\">w</span><span class=\"o\">.</span><span class=\"na\">unlock</span><span class=\"o\">();</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n\n        <span class=\"c1\">// 将completedAbruptly变量设置为false，表示任务正常处理完成\n</span><span class=\"c1\"></span>        <span class=\"n\">completedAbruptly</span> <span class=\"o\">=</span> <span class=\"kc\">false</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span> <span class=\"k\">finally</span> <span class=\"o\">{</span>\n        <span class=\"c1\">// 销毁当前的worker对象，并完成一些诸如完成任务数量统计之类的辅助性工作\n</span><span class=\"c1\"></span>        <span class=\"c1\">// 在线程池当前状态小于STOP的情况下会创建一个新的worker来替换被销毁的worker\n</span><span class=\"c1\"></span>        <span class=\"n\">processWorkerExit</span><span class=\"o\">(</span><span class=\"n\">w</span><span class=\"o\">,</span> <span class=\"n\">completedAbruptly</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>在<code>runWorker</code>方法的源代码中有两个比较重要的方法调用，一个是while条件中对<code>getTask</code>方法的调用，一个是在方法的最后对<code>processWorkerExit</code>方法的调用。下面是对这两个方法更详细的解释。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><code>getTask</code>方法在阻塞队列中有待执行的任务时会从队列中弹出一个任务并返回，如果阻塞队列为空，那么就会阻塞等待新的任务提交到队列中直到超时（在一些配置下会一直等待而不超时），如果在超时之前获取到了新的任务，那么就会将这个任务作为返回值返回。</p><p>当<code>getTask</code>方法返回null时会导致当前Worker退出，当前线程被销毁。在以下情况下<code>getTask</code>方法才会返回null： </p><ol><li>当前线程池中的线程数超过了最大线程数。这是因为运行时通过调用<code>setMaximumPoolSize</code>修改了最大线程数而导致的结果；</li><li>线程池处于STOP状态。这种情况下所有线程都应该被立即回收销毁； </li><li>线程池处于SHUTDOWN状态，且阻塞队列为空。这种情况下已经不会有新的任务被提交到阻塞队列中了，所以线程应该被销毁； </li><li>线程可以被超时回收的情况下等待新任务超时。线程被超时回收一般有以下两种情况：     </li></ol><ul><li>超出核心线程数部分的线程等待任务超时     </li><li>允许核心线程超时（线程池配置）的情况下线程等待任务超时</li></ul><p class=\"ztext-empty-paragraph\"><br/></p><p><code>processWorkerExit</code>方法会销毁当前线程对应的Worker对象，并执行一些累加总处理任务数等辅助操作。但在线程池当前状态小于STOP的情况下会创建一个新的Worker来替换被销毁的Worker，有兴趣的读者可以自行参考<code>processWorkerExit</code>方法源代码。</p><h2><b>4 总结</b></h2><p>到这里我们的线程池源代码之旅就结束了，希望大家在看完这篇文章之后能对线程池的使用和运行都有一个大概的印象。为什么说只是有了一个大概的印象呢？因为我觉得很多没有相关基础的读者读到这里可能还只是对线程池有了一个自己的认识，对其中的一些细节可能还没有完全捕捉到。所以我建议大家在看完下面的总结之后不妨再返回到文章的开头多读几遍，相信第二遍的阅读能给大家带来不一样的体验，因为我自己也是在第三次读<code>ThreadPoolExecutor</code>类的源代码时才真正打通了其中的一些重要关节的。</p><p>在这篇文章中我们从线程池的概念和基本使用方法说起，然后介绍了<code>ThreadPoolExecutor</code>的构造器参数和常用的四种具体配置。最后的一大半篇幅我们一起在<code>TheadPoolExecutor</code>类的源代码中畅游了一番，了解了从线程池的创建到任务执行的完整执行模型。</p><h2><b>5 引子</b></h2><p>在浏览<code>ThreadPoolExexutor</code>源码的过程中，有几个点我们其实并没有完全说清楚，比如对锁的加锁操作、对控制变量的多次获取、控制变量的AtomicInteger类型。在下一篇文章中，我将会介绍这些以锁、volatile变量、CAS操作、AQS抽象类为代表的一系列线程同步方法，欢迎感兴趣的读者继续关注我后续发布的文章~</p>", 
            "topic": [
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "Java Web", 
                    "tagLink": "https://api.zhihu.com/topics/19622819"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58820656", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 11, 
            "title": "这一次，让我们完全掌握Java多线程(2/10)", 
            "content": "<p>多线程不仅是Java后端开发面试中非常热门的一个问题，也是各种高级工具、框架与分布式的核心基石。但是这个领域相关的知识点涉及到了线程调度、线程同步，甚至在一些关键点上还涉及到了硬件原语、操作系统等更底层的知识。想要背背面试题很容易，但是如果面试官一追问就很容易露馅，更不用说真正想搞明白这个问题并应用在实际的代码实践中了。</p><p>不用担心！在接下来的一系列文章中将会由浅入深地贯穿这个问题的方方面面，虽然不如一些面试大全来得直接和速成。但是真正搞明白多线程编程不仅能够一劳永逸地解决面试中的尴尬，而且还能打开通往底层知识的大门，不止是搞明白一个孤立的知识点，更是一个将以前曾经了解过的理论知识融会贯通连点成面的好机会。</p><p>虽然阅读本文不需要事先了解并发相关的概念，但是如果已经掌握了一些大概的概念将会大大降低理解的难度。有兴趣的读者可以参考本系列的第一篇文章来了解一下并发相关的基本概念：</p><a href=\"https://zhuanlan.zhihu.com/p/58316557\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-8fa5b8e0bfba986fb224d667eb9965b6_180x120.jpg\" data-image-width=\"750\" data-image-height=\"498\" class=\"internal\">兜里有辣条：当我们在说“并发、多线程”，说的是什么？</a><p class=\"ztext-empty-paragraph\"><br/></p><p>这一系列文章将会包含10篇文章，本文是其中的第二篇，相信只要有耐心看完所有内容一定能轻松地玩转多线程编程，不止是游刃有余地通过面试，更是能熟练掌握多线程编程的实践技巧与并发实践这一Java高级工具与框架的共同核心。</p><p>前五篇包含以下内容，将会在近期发布：</p><p> 1. 并发基本概念——<a href=\"https://zhuanlan.zhihu.com/p/58316557\" class=\"internal\">当我们在说“并发、多线程”，说的是什么？</a></p><p>2. 多线程入门——本文 </p><p>3. 线程池剖析 </p><p>4. 线程同步机制解析 </p><p>5. 并发常见问题</p><h2><b>为什么要有多线程？</b></h2><p>多线程程序和一般的单线程程序相比引入了同步、线程调度、内存可见性等一大堆复杂的问题，大大提高了开发者开发程序的难度，那么为什么现在多线程在各个邻域中还被如此趋之若鹜呢？</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>一种场景</b></p><p>在我大学的时候宿舍边上有一家盖浇饭，也提供炒菜。老板非常地耿直，非要按点菜的顺序一桌一桌地烧，如果前一桌的菜没上完后一桌一个菜都别想吃到。结果就是每天这家店里都是怨声载道，顾客们常常等了半个小时也等不来一个菜填填肚子。你问我为什么还会有人去吃，受这罪，那肯定是因为好吃啊😂。</p><p>不过仔细想想，好像一般的店里好像并没有这种情况，因为大部分饭店都是混合着上的，就算前一桌没上完好歹会给几个菜垫垫肚子。这在程序中也是一样，不同的程序之间可以交替运行，不至于在我们的电脑上打开了开发工具就不能接收微信消息。</p><p>这就是多线程的一个应用场景：通过任务的交替执行使一台计算机上可以同时运行多个程序。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>另一种场景</b></p><p>还是在小饭馆里，一个服务员在给一桌点完菜之后肯定不会等到这桌菜上完了才去给另外一桌点菜。一般都是点完菜就把订单给了厨房，之后就继续给下一桌点菜了。在这里，我们可以把服务员想象成我们的计算机，把厨房想象成远程的服务器。那么在我们的电脑下载音乐的时候同时继续播放音乐，这就能更高效地利用我们的电脑了。</p><p>这种场景可以描述为：在等待网络请求、磁盘I/O等耗时操作完成时，可以用多线程来让CPU继续运转，以达到有效利用CPU资源的目的。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>最后一种场景</b></p><p>然后我们来到了厨房，竟然看到了一个大神，能一个人烧2个灶台。如果这个厨师大神是一个多核处理器，那么两个灶台就是两个线程，如果只给一个灶台，那就浪费他的才能了，这绝对是一种损失。</p><p>这就是多线程应用的最后一种场景：将计算量比较大的任务拆分到两个CPU上执行可以减少执行完成的时间，而多线程就是拆分和执行任务的载体，没有多线程就没办法把任务放到多个CPU上执行了。</p><h2><b>什么是多线程？</b></h2><p>多线程就是很多线程的意思，嗯，是不是很简单？</p><p>线程是操作系统中的一个执行单元，同样的执行单元还有进程，所有的代码都要在进程/线程中执行。线程是从属于进程的，一个进程可以包含多个线程。进程和线程之间还有一个区别就是，每个进程有自己独立的内存空间，互相直接不能直接访问；但是同一个进程中的多个线程都共享进程的内存空间，所以可以直接访问同一块内存，其中最典型的就是Java中的堆。</p><h2><b>初识多线程编程</b></h2><p>了解了这么多理论概念，终于到了实际上手写写代码的时候了。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>创建线程</b></p><p>Java中的线程使用<code>Thread</code>类表示，Thread类的构造器可以传入一个实现了<code>Runnable</code>接口的对象，这个Runnable对象中的<code>void run()</code>方法就代表了线程中会执行的任务。例如如果要创建一个对整型变量进行自增的<code>Runnable</code>任务就可以写为：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"c1\">// 静态变量，用于自增\n</span><span class=\"c1\"></span><span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n<span class=\"c1\">// 创建Runnable对象（匿名内部类对象）\n</span><span class=\"c1\"></span><span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1e6</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>有了<code>Runnable</code>对象代表的待执行任务之后，我们就可以创建两个线程来运行它了。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n<span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span></code></pre></div><p>但是这时候只是创建了线程对象，实际上线程还没有被执行，想要执行线程还需要调用线程对象的<code>start()</code>方法。</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n<span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span></code></pre></div><p>这时候线程就能开始执行了，完整的代码如下所示：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"kd\">public</span> <span class=\"kd\">class</span> <span class=\"nc\">SimpleThread</span> <span class=\"o\">{</span>\n\n    <span class=\"kd\">private</span> <span class=\"kd\">static</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span>\n\n    <span class=\"kd\">public</span> <span class=\"kd\">static</span> <span class=\"kt\">void</span> <span class=\"nf\">main</span><span class=\"o\">(</span><span class=\"n\">String</span><span class=\"o\">[]</span> <span class=\"n\">args</span><span class=\"o\">)</span> <span class=\"kd\">throws</span> <span class=\"n\">Exception</span> <span class=\"o\">{</span>\n        <span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n            <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n                <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                    <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"n\">count</span> <span class=\"o\">+</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n                <span class=\"o\">}</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">};</span>\n\n        <span class=\"n\">Thread</span> <span class=\"n\">t1</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n        <span class=\"n\">Thread</span> <span class=\"n\">t2</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Thread</span><span class=\"o\">(</span><span class=\"n\">task</span><span class=\"o\">);</span>\n\n        <span class=\"n\">t1</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n        <span class=\"n\">t2</span><span class=\"o\">.</span><span class=\"na\">start</span><span class=\"o\">();</span>\n\n        <span class=\"c1\">// 等待t1和t2执行完成\n</span><span class=\"c1\">//        t1.join();\n</span><span class=\"c1\">//        t2.join();\n</span><span class=\"c1\"></span>\n        <span class=\"n\">System</span><span class=\"o\">.</span><span class=\"na\">out</span><span class=\"o\">.</span><span class=\"na\">println</span><span class=\"o\">(</span><span class=\"s\">&#34;count = &#34;</span> <span class=\"o\">+</span> <span class=\"n\">count</span><span class=\"o\">);</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span></code></pre></div><p>最后输出的结果是8251，你执行的时候应该会与这个值不同，但是一样会远远小于一百万。这好像离我们期望的结果有点远，毕竟每个任务都累加了至少一百万次。</p><p>这是因为我们在main方法中创建线程并运行之后并没有等待线程完成，使用<code>t1.join()</code>可以使当前线程等待t1线程执行完成后再继续执行。让我们去掉两个join方法调用前面的双斜杠试一试效果。</p><p class=\"ztext-empty-paragraph\"><br/></p><p><b>线程同步</b></p><p>在我的电脑上执行的结果是1753490，你执行的结果会有不同，但是同样达不到我们所期望的两百万。具体的原因可以从下面的执行顺序图中找到答案。</p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-2b7d9288d308d1070df84cbf2aeb7a68_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"316\" data-rawheight=\"279\" class=\"content_image\" width=\"316\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;316&#39; height=&#39;279&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"316\" data-rawheight=\"279\" class=\"content_image lazy\" width=\"316\" data-actualsrc=\"https://pic1.zhimg.com/v2-2b7d9288d308d1070df84cbf2aeb7a68_b.jpg\"/></figure><p>可以看到，t1和t2两个线程之间的并发运行会导致互相自己的结果覆盖，最后的结果就会在一百万与两百万之间，但是离两百万会有比较大的距离。这样的多线程共同读取并修改同一个共享数据的代码区块就被称为<b>临界区</b>，临界区同一时刻只允许一个线程进入，如果同时有多个线程进入就会导致<b>数据竞争</b>问题。如果有读者对这里提到的<b>临界区</b>和<b>数据竞争</b>概念还不清楚的，可以参考本系列的第一篇介绍并发基本概念的文章：</p><a href=\"https://zhuanlan.zhihu.com/p/58316557\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic3.zhimg.com/v2-8fa5b8e0bfba986fb224d667eb9965b6_180x120.jpg\" data-image-width=\"750\" data-image-height=\"498\" class=\"internal\">兜里有辣条：当我们在说“并发、多线程”，说的是什么？</a><p>在Java 5之前，我们最常用的线程同步方式就是关键字<code>synchronized</code>，这个关键字既可以标在方法上，也可以作为独立的块结构使用。方法声明形式的synchronized关键字可以在方法定义时如此使用：<code>public synchronized static void methodName()</code>。因为我们的累加操作在继承自Runnable接口的<code>run()</code>方法中，所以没办法改变方法的声明，那么就可以使用如下的块结构形式使用<code>synchronized</code>关键字：</p><div class=\"highlight\"><pre><code class=\"language-java\"><span class=\"n\">Runnable</span> <span class=\"n\">task</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">Runnable</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n    <span class=\"kd\">public</span> <span class=\"kt\">void</span> <span class=\"nf\">run</span><span class=\"o\">()</span> <span class=\"o\">{</span>\n        <span class=\"k\">for</span> <span class=\"o\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"n\">0</span><span class=\"o\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">1000000</span><span class=\"o\">;</span> <span class=\"o\">++</span><span class=\"n\">i</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n            <span class=\"kd\">synchronized</span> <span class=\"o\">(</span><span class=\"n\">SimpleThread</span><span class=\"o\">.</span><span class=\"na\">class</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n                <span class=\"n\">count</span> <span class=\"o\">+=</span> <span class=\"n\">1</span><span class=\"o\">;</span>\n            <span class=\"o\">}</span>\n        <span class=\"o\">}</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">};</span></code></pre></div><p>synchronized是一种对象锁，采用的锁和具体的对象有关，如果是同一个对象就是同一个锁；如果是不同的对象则是不同的锁。同一时刻只能有一个线程持有锁，也就意味着其他想要获取同一个锁的线程会被阻塞，直到持有锁的线程释放这个锁为止。这里可以把对象锁对应的对象看做是锁的名称，实现同步的并不是对象本身，而是与对象对应的对象锁。</p><p>在块结构的synchronized关键字后的括号中的就是对象锁所对应的对象，在上面的代码中，我们使用了SimpleThread类的类对象对应的锁作为同步工具。而如果synchronized关键字被用在方法声明中，那么如果是实例方法（非static方法）对应的对象就是this指针所指向的对象，如果是static方法，那么对应的对象就是所处类的类对象。</p><p>这次我们可以看到输出的结果每次都是稳定的两百万了，我们成功完成了我们的第一个完整的多线程程序🎉🎉🎉</p><h2><b>后记</b></h2><p>但是一般在实际编写多线程代码时，我们一般不会直接创建Thread对象，而是使用线程池管理任务的执行。相信读者们也在很多地方看见过“线程池”这个词，如果希望了解线程池相关的使用与具体实现，可以关注一下将会在近期发布的下一篇文章。</p><p>到目前为止，我们都只是涉及了并发与多线程相关的概念和简单的多线程程序实现。接下来我们就会进入更深入与复杂的多线程实现当中了，包括但不限于volatile关键字、CAS、AQS、内存可见性、常用线程池、阻塞队列、死锁、非死锁并发问题、事件驱动模型等等知识点的应用和串联，最后大家都可以逐步实现在各种工具中常用的一系列并发数据结构与程序，例如AtomicInteger、阻塞队列、事件驱动Web服务器。相信大家通过这一系列多线程编程的冒险历程之后一定可以做到对多线程这个话题举重若轻、有条不紊了。</p>", 
            "topic": [
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }, 
                {
                    "tag": "Java 编程", 
                    "tagLink": "https://api.zhihu.com/topics/19582744"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "说得很好！作者加油啊", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "青 争", 
                    "userLink": "https://www.zhihu.com/people/3e32ba955460577d905a3444a7ff75c1", 
                    "content": "<p>大佬，因为我们的累加操作在继承自Runnable接口的run()方法中，所以没办法改变方法的声明？我有点不明白，我给run()方法上加了synchronized，依然能得到正确的结果！</p>", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57359413", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 16, 
            "title": "数据库索引融会贯通", 
            "content": "<p>索引的各种规则纷繁复杂，不了解索引的组织形式就没办法真正地理解数据库索引。通过本文，你可以深入地理解数据库索引在数据库中究竟是如何组织的，从此以后索引的规则对于你将变得清清楚楚、明明白白，再也不需要死记硬背。</p><p>顺畅地阅读这篇文章需要了解<b>索引</b>、<b>联合索引</b>、<b>聚集索引</b>分别都是什么，如果你还不了解，可以通过另一篇文章来轻松理解——<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67be206fb9a049b13ebdbe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引是什么？新华字典来帮你</a>。</p><p>这篇文章是一系列数据库索引文章中的第二篇，这个系列包括了下面四篇文章：</p><ol><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67be206fb9a049b13ebdbe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引是什么？新华字典来帮你</a> —— 理解<br/> </li><li><a href=\"https://zhuanlan.zhihu.com/p/57359413\" class=\"internal\">数据库索引融会贯通</a> —— 深入<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67bf296fb9a049a81fdbde\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">20分钟数据库索引设计实战</a> —— 实战<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67bf756fb9a049e4133cd9\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引为什么用B+树实现？</a> —— 扩展<br/> </li></ol><p>这一系列涵盖了数据库索引从理论到实践的一系列知识，一站式解决了从理解到融会贯通的全过程，相信每一篇文章都可以给你带来更深入的体验。</p><h2>索引的组织形式</h2><p>通过之前的内容，我们已经对数据库索引有了相当程度的抽象了解，那么在数据库中，索引实际是以什么样的形式进行组织的呢？同一张表上的多个索引又是怎样分工合作的呢？</p><p>目前绝大多数情况下使用的数据库索引都是使用B+树实现的，下面就以MySQL的InnoDB为例，介绍一下数据库索引的具体实现。</p><h2>聚集索引</h2><p>下面是一个以<b>B+树</b>形式组织的拼音索引，在B+树中，每一个节点里都有N个按顺序排列的值，且每个值的中间和节点的头尾都有指向下一级节点的指针。在查找过程中，按顺序从头到尾遍历一个节点中的值，当发现要找的目标值恰好在一个指针的前一个值之前、后一个值之后时，就通过这个指针进入下一级节点。当最后到达<b>叶子节点</b>，也就是最下层的节点时，就能够找到自己希望查找的数据记录了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-1cb95a7f1f7c9520e3ddfef6e895444b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb\" width=\"657\" data-original=\"https://pic4.zhimg.com/v2-1cb95a7f1f7c9520e3ddfef6e895444b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;657&#39; height=&#39;372&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"657\" data-rawheight=\"372\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"657\" data-original=\"https://pic4.zhimg.com/v2-1cb95a7f1f7c9520e3ddfef6e895444b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-1cb95a7f1f7c9520e3ddfef6e895444b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在上图中如果希望找到<code>险</code>字，那么我们首先通过拼音首字母在根节点上按顺序查找到了<code>X</code>和<code>Y</code>之间的指针，然后通过这个指针进入了第二级节点<code>···, xia, xian, xiang, ···</code>。之后在该节点上找到了<code>xian</code>和<code>xiang</code>之间的指针，这样就定位到了第519页开始的一个目标数据块，其中就包含了我们想要找到的<code>险</code>字。</p><p>因为拼音索引是聚集索引，所以我们在叶子节点上直接就找到了我们想找的数据。</p><h2>非聚集索引</h2><p>下面是一个模拟部首索引的组织形式。我们由根节点逐级往下查询，但是在最后的叶子节点上并没有找到我们想找的数据，那么在使用这个索引时我们是如何得到最终的结果的呢？回忆之前字典中“检字表”的内容，我们可以看到，在每个字边上都有一个页码，这就相当于下面这一个索引中叶子节点上<code>险</code>字与<code>院</code>字中间的指针，这个指针会告诉我们真正的数据在什么地方。</p><p class=\"ztext-empty-paragraph\"><br/></p><p class=\"ztext-empty-paragraph\"><br/></p><p>下图中，我们把非聚集索引（部首索引）和聚集索引（拼音索引）合在一起就能看出非聚集索引最后到底如何查找到实际数据了。非聚集索引叶子节点上的指针会直接指向聚集索引的叶子节点，因为根据聚集索引的定义，所有数据都是按聚集索引组织存储的，所以所有实际数据都保存在聚集索引的叶子节点中。而从非聚集索引的叶子节点链接到聚集索引的叶子节点查询实际数据的过程就叫做——<b>回表</b>。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-b6e5e17b12813c318df387769b98380e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-b6e5e17b12813c318df387769b98380e_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1240&#39; height=&#39;452&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1240\" data-rawheight=\"452\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1240\" data-original=\"https://pic3.zhimg.com/v2-b6e5e17b12813c318df387769b98380e_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-b6e5e17b12813c318df387769b98380e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><h2>全覆盖索引</h2><p>那么如果我们只是想要验证<code>险</code>字的偏旁是否是<code>双耳旁“阝”</code>呢？这种情况下，我们只要在部首索引中<code>阝</code>下游的叶子节点中找到了<code>险</code>字就足够了。这种在索引中就获取到了SQL语句中需要的所有字段，所以不需要再回表查询的情况中，这个索引就被称为这个SQL语句的<b>全覆盖索引</b>。</p><p>在实际的数据库中，非聚集索引的叶子节点上保存的“指针”就是聚集索引中所有字段的值，要获取一条实际数据，就需要通过这几个聚集索引字段的值重新在聚集索引上执行一遍查询操作。如果数据量不多，这个开销是非常小的；但如果非聚集索引的查询结果中包含了大量数据，那么就会导致<b>回表</b>的开销非常大，甚至超过不走索引的成本。所以<b>全覆盖索引</b>可以节约<b>回表</b>的开销这一点在一些<b>回表</b>开销很大的情况下就非常重要了。</p><h2>范围查询条件</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-347c408b15f194a988910cf49636a6de_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"1220\" data-original=\"https://pic3.zhimg.com/v2-347c408b15f194a988910cf49636a6de_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1220&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1220\" data-original=\"https://pic3.zhimg.com/v2-347c408b15f194a988910cf49636a6de_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-347c408b15f194a988910cf49636a6de_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>上图是一个联合索引<code>idx_eg(col_a, col_b)</code>的结构，如果我们希望查询一条满足条件<code>col_a = 64 and col_b = 128</code>的记录，那么我们可以一路确定地往下找到唯一的下级节点最终找到实际数据。这种情况下，索引上的<code>col_a</code>和<code>col_b</code>两个字段都能被使用。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-3538c4fdc592e5bb26a54004c421d7e2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb\" width=\"1220\" data-original=\"https://pic3.zhimg.com/v2-3538c4fdc592e5bb26a54004c421d7e2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;1220&#39; height=&#39;357&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"1220\" data-rawheight=\"357\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"1220\" data-original=\"https://pic3.zhimg.com/v2-3538c4fdc592e5bb26a54004c421d7e2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-3538c4fdc592e5bb26a54004c421d7e2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>但是如果我们将查询条件改为范围查询<code>col_a &gt; 63 and col_b = 128</code>，那么我们就会需要查找所有符合条件<code>col_a &gt; 63</code>的下级节点指针，最后不得不遍历非常多的节点及其子节点。这样的话对于索引来说就得不偿失了，<b>所以在这种情况下，数据库会选择直接遍历所有满足条件<code>col_a &gt; 63</code>的记录，而不再使用索引上剩下的<code>col_b</code>字段</b>。数据库会从第一条满足<code>col_a &gt; 63</code>的记录开始，横向遍历之后的所有记录，从里面排除掉所有不满足<code>col_b = 128</code>的记录。</p><p>这就是范围条件会终止使用联合索引上的后续字段的原因。</p>", 
            "topic": [
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "数据库设计", 
                    "tagLink": "https://api.zhihu.com/topics/19614808"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57359459", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 35, 
            "title": "数据库索引为什么用B+树实现？", 
            "content": "<p>为什么大多数数据库索引都使用B+树来实现呢？这涉及到数据结构、操作系统、计算机存储层次结构等等复杂的理论知识，但是不用担心，这篇文章20分钟之后就会给你答案。</p><p>这篇文章是一系列数据库索引文章中的最后一篇，这个系列包括了下面四篇文章：</p><ol><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67be206fb9a049b13ebdbe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引是什么？新华字典来帮你</a> —— 理解<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67becf6fb9a049a42f9420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引融会贯通</a> —— 深入<br/> </li><li><a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67bf296fb9a049a81fdbde\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">20分钟数据库索引设计实战</a> —— 实战<br/> </li><li><a href=\"https://zhuanlan.zhihu.com/p/57359459\" class=\"internal\">数据库索引为什么用B+树实现？</a> —— 扩展<br/> </li></ol><p>这一系列涵盖了数据库索引从理论到实践的一系列知识，一站式解决了从理解到融会贯通的全过程，相信每一篇文章都可以给你带来更深入的体验。</p><h2>为什么使用B+树？</h2><p>大家在数学课上一定听说过一个例子，在一堆已经排好序的数字当中找出一个特定的数字的最好办法是一种叫“二分查找”的方式。具体的过程就是先找到这些数字中间的那一个数，然后比较目标数字是大于还是小于这个数；然后根据结果继续在前一半或者后一半数字中继续查找。</p><p>这就类似于数据结构中的<b>二叉树</b>，二叉树就是如下的一种结构，树中的每个节点至多可以有两个子节点，而B+树每个节点则可以有N个子节点。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-157f6f697653e9ee77d2f3471b5804f4_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"535\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb\" width=\"535\" data-original=\"https://pic1.zhimg.com/v2-157f6f697653e9ee77d2f3471b5804f4_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;535&#39; height=&#39;359&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"535\" data-rawheight=\"359\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"535\" data-original=\"https://pic1.zhimg.com/v2-157f6f697653e9ee77d2f3471b5804f4_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-157f6f697653e9ee77d2f3471b5804f4_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这里就不具体展开讲解二叉树了，我们只需要知道，平衡的二叉树是<b>内存</b>中查询效率最高的一种数据结构就可以了。</p><p>但是目前常用的数据库中，绝大多数的索引都是使用B+树实现的。那么为什么明明是二叉树查询效率最高，数据库中却偏偏要使用B+树而不是二叉树来实现索引呢？</p><h2>计算机存储层次结构</h2><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-c6ca8e01c958325b541ccf3004c0a617_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"147\" class=\"content_image\" width=\"283\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;283&#39; height=&#39;147&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"283\" data-rawheight=\"147\" class=\"content_image lazy\" width=\"283\" data-actualsrc=\"https://pic4.zhimg.com/v2-c6ca8e01c958325b541ccf3004c0a617_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>计算机中的存储结构分为好几个部分，从上到下大致可以分为寄存器、高速缓存、主存储器、辅助存储器。其中主存储器，也就是我们常说的内存；辅助存储器也被称为外存，比较常见的就是磁盘、SSD，可以用来保存文件。在这个存储结构中，每一级存储的速度都比上一级慢很多，所以程序访问越上层存储中的数据，速度就会越快。</p><p>有过编程经验的小伙伴都知道，程序运行过程中操作的基本都是内存，对外存中数据的访问往往需要写一些文件的读取和写入代码才能实现。这正是因为CPU的计算速度比存储的I/O速度（输入/输出速度）快很多所做的优化，因为CPU在每次计算完成之后就需要等待下一批的数据进入，这个等待的时间越短，计算机运行得越快。</p><p>所以对于数据库索引来说，因为数据量很大，所以基本都是保存在外存中的，这样的话数据库读取一个索引节点的成本就非常大了。在数据量一样大的情况下，我们可以知道，B+树的单个节点中包含的值个数越多那么树中需要的节点总数就会越少，这样查询一次数据需要访问的节点数就更少了。</p><p>如果你对B+树还不熟悉，可以到这篇文章中找到答案——<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67becf6fb9a049a42f9420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引融会贯通</a> 。</p><p>如果我们把二叉树看做是特殊的B+树（每个节点只有一个值和前后两个指针的B+树），那么就可以得出结论：<b>因为B+树的节点中包含的值个数（多个值）比二叉树（1个值）更多，所以在B+树中查询所需要的节点数就更少。</b>那么如果每次读取的成本是一样的话，因为<code>总成本=读取次数*单次读取成本</code>，我们就可以证明B+树的查询成本就比二叉树小得多了。</p><h2>节点读取成本</h2><p>但是我们知道，读取更多数据肯定会需要更大的成本，那么为什么数据库索引使用B+树还是会比二叉树更好呢？这就需要一些更高深的操作系统知识来解释了。</p><p>在现代的操作系统中，把数据从外存读到内存所使用的单位一般被称为“页”，每次读取数据都需要读入整数个的“页”，而不能读入半页或者0.8页。一页的大小由操作系统决定，常见的页大小一般为4KB=4096字节。所以不管我们是要读取1字节还是2KB，最后都是需要读入一个完整的4KB大小的页的，那么一个节点的读取成本就取决于需要读入的页数。</p><p>在这样的情况下，如果一个节点的大小小于一页的大小，那么就会有一部分时间花在读取我们根本不需要的数据上（节点之外的数据），二叉树在这方面就会浪费很多时间；而如果一个节点的大小大于一页，哪怕是一页的整数倍，那我们也可能在一个节点的中间就找到了我们需要的指针进入了下一级的节点，这样这个指针后面的数据都白白读取了，如果不需要这些数据可能我们就可以少读几页了。</p><p>所以，综上所述，数据库索引使用<b>节点大小恰好等于操作系统一页大小的B+树</b>来实现是效率最高的选择。</p>", 
            "topic": [
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "数据库设计", 
                    "tagLink": "https://api.zhihu.com/topics/19614808"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }
            ], 
            "comments": [
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "还有自平衡二叉树这个特性", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "开发者头条", 
                    "userLink": "https://www.zhihu.com/people/274db6a56fae2771a5a22377b0b083d0", 
                    "content": "<p>感谢您的分享！文章已推荐到《开发者头条》首页，欢迎点赞支持！使用开发者头条 App 搜索 394815 即可订阅《Java后端火箭班》</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "知乎用户", 
                    "userLink": "https://www.zhihu.com/people/0", 
                    "content": "mysql一页不是4k吧", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "会根据操作系统进行调整", 
                            "likes": 0, 
                            "replyToAuthor": "知乎用户"
                        }, 
                        {
                            "userName": "the ash", 
                            "userLink": "https://www.zhihu.com/people/127512b5d139caee7c5ea195a0d7cee9", 
                            "content": "我好像记得是16k", 
                            "likes": 0, 
                            "replyToAuthor": "兜里有辣条"
                        }
                    ]
                }, 
                {
                    "userName": "rong wang", 
                    "userLink": "https://www.zhihu.com/people/4f0aab98b33ea02d6312d1bad854122f", 
                    "content": "<p>我觉得你说了这么多没说到点子上：原因就是B树或B+树每个节点可以存储更多的信息，使整个树结构更“扁平”，从根节点到叶子节点只要3~4次IO即可（一般B+树索引深度也就是3~4层），如果用二叉树则这颗树会非常深。 和4K什么的没太大关系。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>那一个B+树节点应该多大呢？按你的逻辑应该是整个树只有一个节点最好了，因为层次最少。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "rong wang"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57359450", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 10, 
            "title": "20分钟数据库索引设计实战", 
            "content": "<p>在后端开发的工作中如何轻松、高效地设计大量数据库索引呢？通过下面这五步，20分钟后你就再也不会为数据库的索引设计而发愁了。</p><p>顺畅地阅读这篇文章需要了解数据库索引的组织方式，如果你还不熟悉的话，可以通过另一篇文章来快速了解一下——<a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67becf6fb9a049a42f9420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引融会贯通</a>。</p><p>这篇文章是一系列数据库索引文章中的第三篇，这个系列包括了下面四篇文章： </p><p>1. <a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67be206fb9a049b13ebdbe\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引是什么？新华字典来帮你</a> —— 理解 </p><p>2. <a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67becf6fb9a049a42f9420\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引融会贯通</a> —— 深入 </p><p>3. <a href=\"https://zhuanlan.zhihu.com/p/57359450\" class=\"internal\">20分钟数据库索引设计实战</a> —— 实战 </p><p>4. <a href=\"https://link.zhihu.com/?target=https%3A//juejin.im/post/5c67bf756fb9a049e4133cd9\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">数据库索引为什么用B+树实现？</a> —— 扩展</p><p>这一系列涵盖了数据库索引从理论到实践的一系列知识，一站式解决了从理解到融会贯通的全过程，相信每一篇文章都可以给你带来更深入的体验。</p><h2>1. 整理查询条件</h2><p>我们设计索引的目的主要是为了加快查询，所以，设计索引的<b>第一步</b>是整理需要用到的查询条件，也就是我们会在<code>where</code>子句、<code>join</code>连接条件中使用的字段。一般来说会整理程序中除了insert语句之外的所有SQL语句，按不同的表分别整理出每张表上的查询条件。也可以根据对业务的理解添加一些暂时还没有使用到的查询条件。</p><p>对索引的设计一般会逐表进行，所以按数据表收集查询条件可以方便后面步骤的执行。</p><h2>2. 分析字段的可选择性</h2><p>整理出所有查询条件之后，我们需要分析出每个字段的<b>可选择性</b>，那么什么是可选择性呢？</p><p>字段的可选择性指的就是字段的值的区分度，例如一张表中保存了用户的手机号、性别、姓名、年龄这几个字段，且一个手机号只能注册一个用户。在这种情况下，像手机号这种唯一的字段就是可选择性最高的一种情况；而年龄虽然有几十种可能，但是区分度就没有手机号那么大了；性别这样的字段则只有几种可能，所以可选择性最差。所以俺可选择性从高到低排列就是：手机号 &gt; 年龄 &gt; 性别。</p><p>但是不同字段的值分布是不同的，有一些值的数量是大致均匀的，例如性别为男和女的值数量可能就差别不大，但是像年龄超过100岁这样的记录就非常少了。所以对于年龄这个字段，20-30这样的值就是可选择性很小的，因为每一个年龄都有非常多的记录；但是像100这样的值，那它的可选择性就非常高了。</p><p>如果我们在表中添加了一个字段表示用户是否是管理员，那么在查询网站的管理员信息列表时，这个字段的可选择性就非常高。但是如果我们要查询的是非管理员信息列表时，这个字段的可选择性就非常低了。</p><p>从经验上来说，我们会把可选择性高的字段放到前面，可选择性低的字段放在后面，如果可选择性非常低，一般不会把这样的字段放到索引里。</p><h2>3. 考虑是否要加入排序字段</h2><p><code>order by</code>子句中的字段也可以利用索引来进行排序，这样就可以避免数据库进行排序操作的开销了。同样的，利用索引进行排序也需要遵守最左前缀匹配原则，并且还有一些别的限制条件。这些规则包括：</p><ol><li>最左前缀匹配原则。<code>order by</code>中使用的字段需要在索引中是最左前缀，这个和<code>where</code>条件是一样的。不过有一种例外情况，如果在<code>where</code>子句或者<code>join</code>子句中已经将前面的几个字段限制为一个固定的值（比如<code>where a = 1</code>），那么可以从这些值已经确定的字段之后开始应用最左前缀匹配原则。</li><li>索引中字段的顺序和ORDER BY子句中的顺序完全一致，并且排序条件中所有列的排序方向（倒序或正序）都是一样的。</li><li>关联多张表的查询，只有当<code>order by</code>子句中的字段全部都在执行时的第一个表中时，才能用索引进行排序。</li></ol><p>根据这些限制条件，我们可以判断在一个索引中是否有必要加入排序所使用的字段。如果索引筛选后的结果不多或者无法满足使用索引进行排序的限制规则，那么就不用将排序字段加入到索引中了。</p><h2>4. 合并查询条件</h2><p>虽然索引可以加快查询的效率，但是索引越多就会导致插入和更新数据的成本变高，因为索引是分开存储的，所有数据的插入和更新操作都要对相关的索引进行修改。所以设计索引时还需要控制索引的数量，不能盲目地增加索引。</p><p>一般我们会根据<b>最左匹配原则</b>来合并查询条件，尽可能让不同的查询条件使用同一个索引。例如有两个查询条件<code>where a = 1 and b = 1</code>和<code>where b = 1</code>，那么我们就可以创建一个索引<code>idx_eg(b, a)</code>来同时服务两个查询条件。</p><p>同时，因为范围条件会终止使用索引中后续的字段，所以对于使用范围条件查询的字段我们也会尽可能放在索引的后面。</p><h2>5. 考虑是否需要使用全覆盖索引</h2><p>最后，我们会考虑是否需要使用全覆盖索引，因为<b>全覆盖索引</b>没有<b>回表</b>的开销，效率会更高。所以一般我们会在回表成本特别高的情况下考虑是否使用全覆盖索引，例如根据索引字段筛选后的结果需要返回其他字段或者使用其他字段做进一步筛选的情况。</p><p>例如，我们有一张用户表，其中有年龄、姓名、手机号三个字段。我们需要查询在指定年龄的所有用户的姓名，已有索引<code>idx_age_name(年龄, 姓名)</code>，目前我们使用下面这样的查询语句进行查询：</p><div class=\"highlight\"><pre><code class=\"language-text\">SELECT *\nFROM 用户表\nWHERE 年龄 = ?;</code></pre></div><p>一般情况下，将一个索引优化为全覆盖索引有两种方式： 1. 增加索引中的字段，让索引字段覆盖SQL语句中使用的所有字段     - 在这个例子中，我们可以创建一个同时包含所有字段的索引<code>idx_all(年龄, 姓名, 手机号)</code>，以此提高查询的效率。 2. 减少SQL语句中使用的字段，使SQL需要的字段都包含在现有索引中     - 在这个例子中，其实更好的方法是将<code>SELECT</code>子句修改为<code>SELECT 姓名</code>，因为我们的需求只是查询用户的姓名，并不需要手机号字段，去掉<code>SELECT</code>子句多余的字段不仅能够满足我们的需求，而且也不用对索引做修改。</p>", 
            "topic": [
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "数据库设计", 
                    "tagLink": "https://api.zhihu.com/topics/19614808"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/58316557", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 16, 
            "title": "当我们在说“并发、多线程”，说的是什么？", 
            "content": "<p>这篇文章的目的并不是想教你如何造火箭（面试造火箭，工作拧螺丝），而是想通过对原理和应用案例的有限度剖析来协助你构建起并发的思维，并将操作系统的理论知识与工程实践结合起来，贯穿从学到会的全过程。当然，虽然我们是从实用角度出发，但具有实践意义的深层次知识点永远会是面试中的杀手锏，这可比只能口头造火箭的理论知识更吸引面试官。</p><p>本文适合谁： </p><ol><li>希望能了解并发概念的初学者 </li><li>需要理清并发概念与技术的工程师 </li><li>对并发在工作中的应用与其底层实现原理感兴趣的读者</li></ol><p class=\"ztext-empty-paragraph\"><br/></p><p>在这篇文章中，你将了解到并发与多线程相关的一系列概念，通过一些例子我们可以在<b>不纠结于具体的技术细节</b>的情况下形成对并发与多线程相关的各种概念的抽象理解。有了这些概念以后，我们再去学习具体的理论和技术细节就是手到擒来的事了。</p><h2>什么是并发？</h2><p>最近几年淘宝发展得如火如荼，涌现出了一大批白手起家的卖家。想象一下你是一个刚刚起步的小卖家，自己运营一个服装网店，每天都要自己打包发货。刚开始时生意一般，每天自己一个人一个小时就能干完。</p><p>随着生意的蓬勃发展，发货时间慢慢地从一个小时涨到了两个小时、四个小时，一次因为延迟发货导致被投诉之后，你终于觉得该招更多的人了。很快，两个小伙伴加入了你的事业，打包速度开始有了质的提高。这就是最基本的并发了，每个人都可以看成是一个线程，同样的工作量，干得人多了自然就快了。</p><p>所以<code>并发</code>就是通过多个执行器同时执行一个大任务来缩短执行时间、提高执行效率的方法。</p><h2>数据竞争</h2><p>但是好景不长，周末一盘货，你发现少了不少。这办公室里也没遭贼，怎么就会少货呢？细细一查快递单，你发现竟然有几单发重了。之后的几天你都细细留意了一下发货的过程，最后发现是因为每个人都会拿着一张发货清单去备货，如果有一些订单不小心打印重复了，就有可能会被不同的人重复发货。虽然数量不多，但是也很心痛啊。这个问题产生的原因就是因为每个人在备货之前拿到的订单状态（未发货）在实际备货时发生了变化（已由其他人发货）。这种对一个共享数据（订单的发货状态）本应独占的读取、检查、修改过程，如果发生了并发，这种情况就被称为<code>数据竞争</code>。而这个读取、检查、修改的过程就被称为<code>临界区</code>，<code>临界区</code>指的就是一个存在<code>数据竞争</code>的代码片段。</p><p>数据竞争出现的根本原因是一个数据本来应该只能由一个执行器完整地执行读取、检查、修改过程，但是如果出现了并发，那么就没办法保证到了“修改”这一步时的数据还保持了“读取”时的值了。</p><p>确定原因后，有人想到了一个好办法，可以打印一张总的发货清单，这样所有人都必须以这个清单上的订单是否发货来确定是否要对订单进行备货并发货了。因为清单只有一份，所以每次只能由一个人来修改订单的发货状态。这种只能由一个执行器进行数据修改操作来避免发生<code>数据竞争</code>问题的做法就被称为<code>互斥</code>，也就是我们常说的<code>锁</code>了。</p><h2>分布式并发概念</h2><h2>分布式</h2><p>因为你管理得当，生意发展得很快，现在的办公室里已经堆不下所有衣服了。所以你又租了一个仓库来同样进行发货。两个地方都会进行发货，那么就可以把每一个仓库理解为一台独立的计算机，这样通过多台计算机完成同一任务的方式就可以被称为<code>分布式</code>，这样的一组计算机的集合就被称为<code>集群</code>。</p><p>这时候之前用一张纸质的总发货清单的<code>数据竞争</code>解决方式就行不通了，所以我们需要把这张总发货清单放到云端，让大家可以通过网络进行编辑，但是每次只能一个人编辑。在这种情况下，我们可以把两个仓库各自看成一台计算机/进程，而每个仓库里的人就是这个进程中的线程。这样的话这张总发货清单就成为了一个<code>分布式锁</code>，因为它每次只能有一个人编辑，所以是一个<code>互斥锁</code>，或者简称为<code>锁</code>；而因为它可以被两个进程/计算机（仓库）共同使用，所以被称为是<code>分布式锁</code>。</p><p><b>什么是进程/线程？</b></p><p>可以简单地将进程理解为我们电脑/手机上的一个应用，同一台手机上的每个App都是一个进程，同一个App在每个手机上也是一个进程。进程和进程之间可以理解为是两个仓库，互相之间物理隔离；而线程就是仓库里的每一个人，他们共享同一个办公空间。这里的办公空间就可以理解为操作系统中的虚拟内存空间，但是本文主要讨论并发相关的概念，就不继续展开了。</p><h2>分布式数据不一致</h2><p>因为生意比较好，所以所有人都很忙。有时候就会因为有一些人虽然在云端表格上已经勾上了一个订单，但是一忙就给忙忘了。其他人怕重复发货又不会再去处理已经勾上的订单了，因为这样导致的未发货订单让店铺被投诉了好多次，影响非常大。这种在并发过程中修改了数据状态但是没有完成后续执行的情况就会出现<code>数据不一致</code>，即订单已经被勾上，但实际并没有发货。</p><p>但是作为聪明的老板，你又想到了解决的方法。每隔一小时两个仓库就会各派一个人检查一下已经勾上的订单是否已经都打包完贴上快递单了。这种每隔一段时间就检查并处理遗漏的<code>数据不一致</code>订单的任务就被称为<code>兜底任务</code>。而通过<code>兜底任务</code>实现的在最后所有订单都会达到数据一致状态的情况就被称为<code>最终一致性</code>。</p><h2>优化方式</h2><p>大家可能早就觉得前面介绍的总发货清单的方法太傻了，只要每个订单都只打印一张发货清单，由单独一个人去负责分发清单就可以了，其他人只要处理好自己被分配到的订单就可以了。最后再加上一个兜底任务对订单的发货情况进行二次校验基本上就不会发生漏发或者重发的情况了。这种由一个执行器进行任务拆分，再由一组执行器进行处理，最后再由一个或一组执行器进行结果汇总的处理方式就是现在非常流行的<code>map-reduce</code>方法了。这种方法在大数据或者程序语言标准库里都有大量的应用，比如大数据领域赫赫有名的Hadoop和Java语言中的<code>ForkJoinPool</code>都使用了这种思想。</p><h2>回顾</h2><p>在这篇文章中，我们涉及到了以下的技术名词： </p><ol><li>并发，通过多个执行器同时执行一个大任务来缩短执行时间、提高执行效率的方法。 </li><li>数据竞争，对一个共享数据本应独占的读取、检查、修改过程发生了并发的情况。 </li><li>临界区，存在<code>数据竞争</code>的代码片段。 </li><li>互斥锁（也可以简称为“锁”），同一时间只能由一个执行器获取的实体，用于实现对临界区的互斥（只有一个）访问。 </li><li>分布式，通过多台计算机完成同一任务的方式。 </li><li>集群，一组完成同一任务的机器。 </li><li>分布式锁，在不同机器/进程上提供互斥能力的锁。 </li><li>数据不一致，一系列操作不具有原子性，一部分执行成功而另一部分没有，导致不同数据之间存在矛盾，例如订单已经是发货状态，但是实际没有发货。 </li><li>兜底任务，处理<code>数据不一致</code>状态的任务。 </li><li>最终一致性，通过<code>兜底任务</code>或其他方式保证<code>数据不一致</code>的情况最终会消失。</li><li>map-reduce，一种任务拆分-执行-再合并的任务执行方式，可以有效地利用多台机器、多核CPU的性能。</li></ol><h2>后记</h2><p>因为并发的知识范围很大，而且对于一些抽象概念的传递必然会需要花费一些篇幅，所以这个主题将会包含一系列文章，主要覆盖以下主题： </p><ol><li>什么是并发？抛开冗长繁杂的技术点，直接理解并发相关的各种概念。 </li><li>什么是多线程？多线程是并发的一种重要形式。通过具体的多线程问题引出多线程编程中的关键点和对应的工具与知识点，轻松学会多线程编程。 </li><li>常用工具中的并发实现。通过解析知名开源工具中的并发方案实现来深入理解并发编程实践。</li></ol><p>有兴趣的读者可以继续关注后续的文章，在之后的文章中会有对并发编程、操作系统原语、硬件原语等等理论与实践知识的详细介绍与案例。</p><p>对数据库索引感兴趣的读者可以了解一下我之前的一系列文章：</p><a href=\"https://zhuanlan.zhihu.com/p/57359378\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-fa3b421b420fa633f27836dae2cc4203_180x120.jpg\" data-image-width=\"720\" data-image-height=\"450\" class=\"internal\">兜里有辣条：数据库索引是什么？新华字典来帮你</a><a href=\"https://zhuanlan.zhihu.com/p/57359413\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-fa60c318588922640dbacb9b7d56af98_180x120.jpg\" data-image-width=\"1351\" data-image-height=\"493\" class=\"internal\">兜里有辣条：数据库索引融会贯通</a><a href=\"https://zhuanlan.zhihu.com/p/57359450\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-8013866f00afa5e3f0354549084cd8cf_180x120.jpg\" data-image-width=\"1220\" data-image-height=\"357\" class=\"internal\">兜里有辣条：20分钟数据库索引设计实战</a><p></p>", 
            "topic": [
                {
                    "tag": "多线程", 
                    "tagLink": "https://api.zhihu.com/topics/19619463"
                }, 
                {
                    "tag": "并发", 
                    "tagLink": "https://api.zhihu.com/topics/19757794"
                }, 
                {
                    "tag": "Java", 
                    "tagLink": "https://api.zhihu.com/topics/19561132"
                }
            ], 
            "comments": [
                {
                    "userName": "blackpig", 
                    "userLink": "https://www.zhihu.com/people/6909ee5ec5e27de0d1078d8bb9938c0f", 
                    "content": "<p>按照我的理解，一个项目开发人员不够，请两个全栈是集群，请一个前端一个后端是分布式。您认为呢？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>按我的理解集群和分布式应该指的都是功能相同的一个整体，可以理解为一个项目同时有N个后端。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "blackpig"
                        }
                    ]
                }, 
                {
                    "userName": "意想不到", 
                    "userLink": "https://www.zhihu.com/people/80dc6bbfe239f545de955faf18aab206", 
                    "content": "<p>想问一个问题 多个线程去操作统一数据，这是并行+并发吧，只有在操作统一数据的时候是并发？</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>并行和并发针对的是操作的时间关系，共享数据是出现并发问题的主要原因，这是两个不同的概念。</p>", 
                            "likes": 0, 
                            "replyToAuthor": "意想不到"
                        }
                    ]
                }, 
                {
                    "userName": "pretty kernel", 
                    "userLink": "https://www.zhihu.com/people/ccfa9c351a7ca65cce2631e186444b06", 
                    "content": "<p>你是不是混淆了并发和并行？</p><p>一个处理器上跑两个线程，轮流占用时间片，这叫并发，相当于分时复用。并发主要是为了在单个线程阻塞时，切换到其它线程，充分利用 CPU 资源，如果其它线程也会执行 io，也可以变相提升 io 资源的利用率。并发不一定能缩短单个任务的执行时间。</p><p>两个处理器上各跑一个线程，这叫并行。并行主要用于提高计算任务的吞吐量，也不一定能缩短单个任务的执行时间。</p><p>现实中，往往是并发与并行混合，即 N 个处理器上跑 M 个进程或线程。至于协程，主要用于减少内核态与用户态的上下文切换。</p>", 
                    "likes": 0, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>这篇文章中并没有讨论并行（parallelism）和并发（concurrency）的区别，这里用的是任务维度上的“并发”的含义，也就是一个任务可以被拆分为多个子任务独立执行并得到预期结果的能力。这些任务可以是在单核CPU上分时执行的，也可以是在多核CPU甚至是多台机器上并行执行的。<br><br><br>参考维基百科：<a href=\"http://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Concurrency_%28computer_science%29\" class=\" external\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">https://</span><span class=\"visible\">en.wikipedia.org/wiki/C</span><span class=\"invisible\">oncurrency_(computer_science)</span><span class=\"ellipsis\"></span></a></p>", 
                            "likes": 0, 
                            "replyToAuthor": "pretty kernel"
                        }
                    ]
                }
            ]
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57359296", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 9, 
            "title": "技术面试老是有劲使不出，该怎么办？", 
            "content": "<p>又到了一年金三银四，回想到很多年前我刚参加工作时的面试经历，那时都是呆呆地等着面试官问问题，被问到一些自己并不熟悉的问题时要不就是思考半天也切不中要点，要不就只能无奈地回答并不清楚了。其实不管是经验不足的初级开发，还是面临更高要求的资深开发，在面试上都会有一样的困扰：如何在掌握的知识有限的情况下，完成好一场高质量的面试呢？</p><p>本文最适合以下几种情况的同学参考： 1. 知识面有限的初学者 2. 希望首次加入大公司的开发同学 3. 面临技术深度要求的开发同学</p><p>虽然文中主要以后端开发为例介绍技术面试的准备方法，但是和其他岗位的面试也有相似之处，其他朋友也可以作为参考。</p><h2>两个悲剧的面试故事</h2><p>小黄去年刚从计算机专业毕业，但是感觉对技术掌握得还不够，就又报名参加了一个培训班，年底刚从培训班毕业，怀揣着精心准备的简历，想到杭州闯一闯。今天上午到了一家装修还不错的公司面试，感觉这家公司窗明桌净，办公桌前都是Mac笔记本加双屏显示器，比昨天面的那家外包公司可好多了，心想一定要好好发挥抓住这个机会。</p><p>老王工作五六年了，今年刚从一家不小的公司出来，公司效益不好，年底裁员了，不幸老王在年前的最后一次裁员名单中中奖了。虽然短期内也没什么太大的经济问题，但是之前拿到offer的都是一些没上轨道的小公司，跟之前待过的公司比总感觉是明珠暗投不太甘心。这次面试的公司看上去还满正规的，如果能进去，就算不涨薪，但是心理上落差总是小一点。</p><p>小黄按部就班地说完了自己准备的项目介绍，然后面试官就照着简历问了起来。“你熟悉MySQL数据库？”，“对”，“唔...那你能说说MySQL常用的有哪几种存储引擎吗？”，“啊？什么是存储引擎？”。小黄心想，昨天复习了面试宝典里的数据库索引，老师说这个是要点，面试官怎么不按常理出牌呢。“你简历上写了使用过Kafka消息中间件？”，“嗯，对的”，“那你能说说Kafka的拉模型和其他推模型消息中间件的区别吗？”，“...”，“今天面试就到这里，有后续的话HR在一周内会联系你的”。</p><p>老王在隔壁的会议室里坐了下来，面试官让老王先介绍一下自己最近比较有代表性的项目，老王大概说了说自己这两年做的一个平台的功能。面试官问：“在这个项目过程中你有碰到什么印象比较深的技术难点或者业务难点吗？”，老王想了一想，感觉一下子有点想不起来。面试官继续问：“刚才你介绍的项目里有说到XXX功能，那在YYY异常情况下如果处理ZZZ问题呢？”。老王心想以前也没考虑过这个，那我就直接现场推敲一下吧，“这里要先这样，对了，那里要那样，不对，这里还有一种情况”。十分钟过去了，老王还在原地兜着圈子，而且丝毫没有停下来的意思。面试官只能打断老王换了一个问题：“那你能介绍一个你有过深入了解的技术吗？”，老王：“我好像这几个都了解一点”。“那关系型数据库中的聚集索引和非聚集索引有什么区别呢？”，“好像这两个的存储方式有点不同，非聚集索引开销会大一点”，“那么为什么非聚集索引开销会比较大呢？”，“这个问题好像要涉及操作系统之类的知识，有点太深了”。40分钟后，老王也结束了面试。</p><h2>程序员何苦为难程序员？</h2><p>为什么面试官老是会问一些莫名其妙的问题？我怎么可能了解计算机方面的所有问题呢？为什么他问得这么深，写代码的时候能有什么用？</p><p>之前我在一次失败的面试之后总是感觉有点不舒服，我感觉我的水平也是挺不错的，为什么到了面试就总感觉发挥不出，而且老是被“虐”呢？下面我们一起来想想办法。</p><h2>该怎么办？不打无准备之仗！</h2><p>如何完成好一场高质量的面试？这是我们在文章一开头提出的问题。首先我们要知道，我们掌握的知识一定是有限的，不管学到了多少，仍然还会有不知道的知识。特别是对技术深度有要求的资深开发岗位，想要面面俱到几乎是一个不可能的任务。但是为什么有些人就能很轻易地拿到offer呢？</p><p>首先，我们分析一下一场面试的结构。</p><h2>面试的结构</h2><p>一般技术面试都会分为四个部分：项目介绍/自我介绍、技术能力问答、综合能力问答、反向提问环节。而其中前三个部分对面试的成败影响最大。首先，面试一般都会以项目介绍/自我介绍来进行切入，其实技术面试的自我介绍主要也是介绍自己的项目经验。然后会穿插着对技术能力和综合能力的评估，一般这一步都会由之前的项目介绍引申出来。</p><p>一般来说，面试官在每个环节希望了解的主要是： 1. 项目介绍——基本背景、擅长的业务领域、解决问题的能力、技术层级 2. 技术能力问答——技术深度、分析能力、抽象能力、学习能力 3. 综合能力问答——工作素养、协作能力、学习素养</p><p>虽然看上去眼花缭乱的非常多，其实核心关注的就是几点：<b>技术好、好合作、主动性强</b>。</p><p>对于大部分面试官来说，一般也不会做太多事前准备和细密的事后分析，大多都是靠一个大概的印象来做出判断的。所以面试的一个诀窍就是：<b>突出亮点</b>。一旦面试中有让人印象深刻的亮点，其他方面只要不是太差一般面试就十拿九稳了。</p><h2>单点突破</h2><p>但是很多读者应该和我以前一样，觉得自己好像也没什么亮点啊，总感觉没什么特别的可说。但是通过<b>总结</b>和<b>准备</b>，我相信每一个人都可以有自己的亮点，而且是很多个亮点。</p><p>首先，我们可以通过<b>总结</b>来得到一份优秀的项目介绍。关键点就在于不能光介绍项目完成的需求，因为这些对于面试官来说并没有什么价值，毕竟我们面的是开发岗位不是产品岗位：）在项目介绍中，我们应该明确描述我们在项目中解决的问题，包括技术难题和业务难题。如何表述可以参考一下现在流行的STAR法则，即在什么情况下(Situation)，面临一项什么样的任务(Task)，采取了什么样的行动(Action)，达到了怎样的结果(Result)。这样的表述可以很好地展示自己的解决问题能力，充分显示了自己在工作中的主动性。</p><p>然后，我们还可以通过<b>准备</b>来深挖几个在工作中比较重要的技术点作为“技术亮点”展示，这指的不是仅仅通过“面试宝典”来准备的肤浅的理论知识，而应该是能做到真正的言之有物、切中工作要点的<b>实践性的深入知识点</b>。这一步是本文所有面试准备技巧中唯一对技术水平有要求而且是要求很高的步骤，技术水平不够的朋友可能发愁怎么准备，技术水平比较高的朋友可能又会疑惑到底什么是<b>实践性的深入知识点</b>。大家不用担心，我已经为大家准备好了学习材料或者说是参考样例。通过学习或参考工作经验较丰富者的总结文章我们可以更容易地获得自己的技术亮点。</p><p><b>实践性的深入知识点</b>的最大特点就是：工作中会使用且可以层层深入形成问题链条。关系型数据库是后端开发离不开的技术，而数据库索引又是程序中的SQL语句执行效率的关键，大家可以通过我之前编写的一系列数据库索引相关的文章来了解一个<b>实践性的深入知识点</b>到底长什么样。后续我也会不断更新更多浅显易懂的高阶技术，有兴趣的朋友可以持续关注一下。下面的文章主要以知识点讲解为主，需要具体的一系列相关面试题的朋友可以在文后留言，如果人数比较多我会考虑另外写一篇文章讲解具体的面试题并链接到对应的知识点。</p><a href=\"https://zhuanlan.zhihu.com/p/57359378\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-fa3b421b420fa633f27836dae2cc4203_180x120.jpg\" data-image-width=\"720\" data-image-height=\"450\" class=\"internal\">兜里有辣条：数据库索引是什么？新华字典来帮你</a><a href=\"https://zhuanlan.zhihu.com/p/57359413\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-fa60c318588922640dbacb9b7d56af98_180x120.jpg\" data-image-width=\"1351\" data-image-height=\"493\" class=\"internal\">兜里有辣条：数据库索引融会贯通</a><a href=\"https://zhuanlan.zhihu.com/p/57359450\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-8013866f00afa5e3f0354549084cd8cf_180x120.jpg\" data-image-width=\"1220\" data-image-height=\"357\" class=\"internal\">兜里有辣条：20分钟数据库索引设计实战</a><h2>连点成面</h2><p>但是有了准备之后，我们怎么能防止面试官问出很多超出我们准备范围的“奇怪”的问题呢？这就需要我们有效地引导和填充整个面试的过程。一般一场技术面试会在40分钟到60分钟，如何完成好一场技术面试的关键就在于如何用亮点来充满这40到60分钟。</p><p>一般一个技术亮点会包含一系列层层递进的内容，所以可以问出大概三到五个问题。如果发现面试官不知道应该如何追问，那么你可以简短一些地把后续知识点一次性介绍完。一般这些问题都说完时间就过去了十到十五分钟，而项目介绍和相关的问答会占用大概10分钟。如果我们准备了两个技术亮点，加上前后的一些非技术性问题和反向提问，那么基本上一场面试就圆满地结束了。</p><p>那么如何让面试官问出自己想问的问题呢？这就需要我们准备好一个“剧本”了。</p><p>首先，面试的开场一定是项目介绍，可以将我们准备好的技术亮点与项目介绍中解决的技术难题结合起来，这样面试官基本都会根据这个点继续往下追问。</p><p>其次，我们还可以对简历内容进行特意的编排来诱导面试官主动提出我们准备好的问题。例如在简历中把擅长的技术放在更靠上的位置突出显示，并且增加更多的深入解释。这样不仅可以引起面试官的注意，还能使简历显得更有技术含量，更容易通过筛选。</p><p>最后，还可以厚着脸皮主动提出自己对某一个领域比较了解，尝试询问面试官对这一部分有没有兴趣。</p><p>通过上述这三点，基本上80%以上的面试就能够顺顺利利地圆满完成了。</p><h2>问题总结</h2><p>在掌握了面试的技巧之后，我们再来看看之前小黄和老王到底犯了什么错误，我们也能避免踩坑。</p><p>初级开发小黄的问题： 1. 惜字如金，没有充分回答问题；     - 对于面试官提出的“是否用过”“是否了解”这样的问题，应该补充上能够证明自己是内行的解释。 2. 等着面试官提问，没有主动地引导。     - 我们应该主动将问题引导向自己擅长的方面。</p><p>资深开发老王的问题： 1. 项目经历没有准备；     - 只讲了项目的功能，而不讲过程中遇到的业务难点和技术难点。 2. 过分纠结细节，但是表述又不流畅； 3. 问题抓不住重点，从细节开始推敲，反反复复。     - 表述复杂问题时应该从宏观到微观。先从比较高的层次入手，划分大的模块，确定模块间的交互，然后再逐个模块地细化细节。这样不仅自己能够更容易地解决问题，而且面试官也更容易理解，避免发生即使回答了正确答案但是面试官也不认同的情况。</p>", 
            "topic": [
                {
                    "tag": "面试技巧", 
                    "tagLink": "https://api.zhihu.com/topics/19591490"
                }, 
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "后端工程师", 
                    "tagLink": "https://api.zhihu.com/topics/19686604"
                }
            ], 
            "comments": []
        }, 
        {
            "url": "https://zhuanlan.zhihu.com/p/57359378", 
            "userName": "兜里有辣条", 
            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
            "upvote": 119, 
            "title": "数据库索引是什么？新华字典来帮你", 
            "content": "<p>学过服务器端开发的朋友一定知道，程序没有数据库索引也可以运行。但是所有学习数据库的资料、教程，一定会有大量的篇幅在介绍数据库索引，各种后端开发工作的面试也一定绕不开索引，甚至可以说数据库索引是从后端初级开发跨越到高级开发的屠龙宝刀，那么索引到底在服务端程序中起着怎样的作用呢？</p><p>这篇文章是一系列数据库索引文章中的第一篇，这个系列包括了下面四篇文章：</p><a href=\"https://zhuanlan.zhihu.com/p/57359378\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-fa3b421b420fa633f27836dae2cc4203_180x120.jpg\" data-image-width=\"720\" data-image-height=\"450\" class=\"internal\">兜里有辣条：数据库索引是什么？新华字典来帮你</a><a href=\"https://zhuanlan.zhihu.com/p/57359413\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic1.zhimg.com/v2-fa60c318588922640dbacb9b7d56af98_180x120.jpg\" data-image-width=\"1351\" data-image-height=\"493\" class=\"internal\">兜里有辣条：数据库索引融会贯通</a><a href=\"https://zhuanlan.zhihu.com/p/57359450\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-8013866f00afa5e3f0354549084cd8cf_180x120.jpg\" data-image-width=\"1220\" data-image-height=\"357\" class=\"internal\">兜里有辣条：20分钟数据库索引设计实战</a><a href=\"https://zhuanlan.zhihu.com/p/57359459\" data-draft-node=\"block\" data-draft-type=\"link-card\" data-image=\"https://pic4.zhimg.com/v2-8013866f00afa5e3f0354549084cd8cf_180x120.jpg\" data-image-width=\"1220\" data-image-height=\"357\" class=\"internal\">兜里有辣条：数据库索引为什么用B+树实现？</a><p><br/> 这一系列涵盖了数据库索引从理论到实践的一系列知识，一站式解决了从理解到融会贯通的全过程，相信每一篇文章都可以给你带来更深入的体验。</p><h2>什么是数据库索引？</h2><p>用一句话来描述：<b>数据库索引就是一种加快海量数据查询的关键技术</b>。现在还不理解这句话？不要紧，往下看，20分钟以后你就能自己做出这样的总结来了。</p><p>首先给大家看一张图片</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-5d5e06b51c316184a91d48b46b56054e_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"312\" class=\"content_image\" width=\"256\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;256&#39; height=&#39;312&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"256\" data-rawheight=\"312\" class=\"content_image lazy\" width=\"256\" data-actualsrc=\"https://pic3.zhimg.com/v2-5d5e06b51c316184a91d48b46b56054e_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>这本书大家一定都很熟悉，小学入门第一课一定就是教小朋友们学习如何使用这本书。那这和我们的数据库索引有啥关系呢？别着急，我们翻开第一页看看。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic4.zhimg.com/v2-52b7de5d1e73df95beea665f3061d42b_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"668\" class=\"origin_image zh-lightbox-thumb\" width=\"481\" data-original=\"https://pic4.zhimg.com/v2-52b7de5d1e73df95beea665f3061d42b_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;481&#39; height=&#39;668&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"481\" data-rawheight=\"668\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"481\" data-original=\"https://pic4.zhimg.com/v2-52b7de5d1e73df95beea665f3061d42b_r.jpg\" data-actualsrc=\"https://pic4.zhimg.com/v2-52b7de5d1e73df95beea665f3061d42b_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>请大家注意右上角的那一排文字，原来目录就是传说中的索引呀！从前面的“一句话描述”我们可以知道，索引的目的就是为了加快数据查询。那么我们查字典时翻的第一个地方是哪里呢，我相信大部分人都会先翻到拼音目录，毕竟现在很多人都是提笔忘字了😂。</p><p>数据库索引的作用和拼音目录是一样的，就是最快速的锁定目标数据所在的位置范围。比如我们在这里要查<code>险</code>这个字，那么我们找到了<code>Xx</code>部分之后就能按顺序找到<code>xian</code>这个拼音所在的页码，根据前后的页码我们可以知道这个字一定是在519页到523页之间的，范围一下子就缩小到只有4页了。这相比我们从头翻到尾可是快多了，这时候就出现了第一个专业术语——<b>全表扫描</b>，也就是我们说的从头找到尾了。</p><p>果然，我们在第521页找到了我们要找的“险”字。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic1.zhimg.com/v2-7970d2fc96a106827f7cba622c5e6e48_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"501\" data-rawheight=\"678\" class=\"origin_image zh-lightbox-thumb\" width=\"501\" data-original=\"https://pic1.zhimg.com/v2-7970d2fc96a106827f7cba622c5e6e48_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;501&#39; height=&#39;678&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"501\" data-rawheight=\"678\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"501\" data-original=\"https://pic1.zhimg.com/v2-7970d2fc96a106827f7cba622c5e6e48_r.jpg\" data-actualsrc=\"https://pic1.zhimg.com/v2-7970d2fc96a106827f7cba622c5e6e48_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>那么现在我们就知道数据库索引大概是一个什么东西了：数据库索引是一个类似于目录这样的用来加快数据查询的技术。</p><h2>什么是联合索引？</h2><p>相信大家都见过一些包含多个字段的数据库索引，比如<code>INDEX idx_test(col_a, col_b)</code>。这种包含多个字段的索引就被称为<b>“联合索引”</b>。那么在多个字段上建索引能起到什么样的作用呢？下面还是以新华字典为例，来看看到底什么是联合索引。</p><p>新华字典里还有一种目录被称为“部首目录”，下面可以看到，要使用这个目录我们首先会根据部首的笔画数找到对应该能的部分，然后可以在里面找到我们想找的部首。比如如果我们还是要找<code>险</code>字所在的位置：</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-48eb76ada630f89a2a2d642035cca3fe_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"685\" class=\"origin_image zh-lightbox-thumb\" width=\"492\" data-original=\"https://pic3.zhimg.com/v2-48eb76ada630f89a2a2d642035cca3fe_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;492&#39; height=&#39;685&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"492\" data-rawheight=\"685\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"492\" data-original=\"https://pic3.zhimg.com/v2-48eb76ada630f89a2a2d642035cca3fe_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-48eb76ada630f89a2a2d642035cca3fe_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>找到部首后，右边的页码还不是<code>险</code>字真正的页码，我们还需要根据右边的页码找到对应部首在检字表中的位置。找到第93页的检字表后我们就可以根据<code>险</code>字余下的笔画数（7画）在“6-8画”这一部分里找到<code>险</code>字真正的页码了。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic2.zhimg.com/v2-28ee824ee2a2e3a713734dc5bf412fe9_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"512\" data-rawheight=\"693\" class=\"origin_image zh-lightbox-thumb\" width=\"512\" data-original=\"https://pic2.zhimg.com/v2-28ee824ee2a2e3a713734dc5bf412fe9_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;512&#39; height=&#39;693&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"512\" data-rawheight=\"693\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"512\" data-original=\"https://pic2.zhimg.com/v2-28ee824ee2a2e3a713734dc5bf412fe9_r.jpg\" data-actualsrc=\"https://pic2.zhimg.com/v2-28ee824ee2a2e3a713734dc5bf412fe9_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>在这个过程中，我们<b>按顺序</b>使用了“两个目录”，一个叫做“部首目录”，一个叫做“检字表”。并且我们可以看到上图中检字表的内容都是按部首分门别类组织的。这两个部分合在一起就是我们在本节讨论的主题——<b>联合索引</b>。即通过第一个字段的值（部首）在第一级索引中找到对应的第二级索引位置（检字表页码），然后在第二级索引中根据第二个字段的值（笔画）找到符合条件的数据所在的位置（<code>险</code>字的真正页码）。</p><h2>最左前缀匹配</h2><p>从前面使用部首目录的例子中可以看出，如果我们不知道一个字的部首是什么的话，那基本是没办法使用这个目录的。这说明仅仅通过笔画数（第二个字段）是没办法使用部首目录的。</p><p>这就引申出了联合索引的一个规则：联合索引中的字段，只有某个字段（笔画）左边的所有字段（部首）都被使用了，才能使用该字段上的索引。例如，有索引<code>INDEX idx_i1(col_a, col_b)</code>，如果查询条件为<code>where col_b = 1</code>，则无法使用索引<code>idx_i1</code>。</p><p>但是如果我们知道部首但是不知道笔画数，比如不知道“横折竖弯勾”是算一笔还是两笔，那我们仍然可以使用“部首目录”部分的内容，只是要把“检字表”对应部首里的所有字都看一遍就能找到我们要找的字了。</p><p>这就引申出了联合索引的另一个规则：联合索引中的字段，即使某个字段（部首）右边的其他字段（笔画）没有被使用，该字段之前（含）的所有字段仍然可以正常使用索引。例如，有索引<code>INDEX idx_i2(col_a, col_b, col_c)</code>，则查询条件<code>where col_a = 1 and col_b = 2</code>在字段<code>col_a</code>和<code>col_b</code>上仍然可以走索引。</p><p>但是，如果我们在确定部首后，不知道一个字到底是两画还是三画，这种情况下我们只需要在对应部首的两画和三画部分中找就可以了，也就是说我们仍然使用了检字表中的内容。所以，使用范围条件查询时也是可以使用索引的。</p><p>最后，我们可以完整地表述一下<b>最左前缀匹配</b>原则的含义：对于一个联合索引，如果有一个SQL查询语句需要执行，则只有从索引最左边的第一个字段开始到<b>SQL语句查询条件</b>中不包含的字段（不含）或<b>范围条件</b>字段（含）为止的部分才会使用索引进行加速。</p><p>这里出现了一个之前没有提到的点，就是<b>范围条件字段也会结束对索引上后续字段的使用</b>，这是为什么呢？具体原因的解释涉及到了更深层次的知识，在接下来的第二篇文章的最后就可以找到答案。</p><h2>什么是聚集索引？</h2><p>从上文的部首目录和拼音目录同时存在但是实际的字典内容只有一份这一点上可以看出，在数据库中一张表上是可以有多个索引的。那么不同的索引之间有什么区别呢？</p><p>我们在新华字典的侧面可以看到一个V字形的一个个黑色小方块，有很多人都会在侧面写上<code>A, B, C, D</code>这样对应的拼音字母。因为字典中所有的字都是按照拼音顺序排列的，有时候直接使用首字母翻开对应的部分查也很快。</p><p class=\"ztext-empty-paragraph\"><br/></p><figure data-size=\"normal\"><noscript><img src=\"https://pic3.zhimg.com/v2-38542298d56abdd1371c29c3b4f270a2_b.jpg\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb\" width=\"480\" data-original=\"https://pic3.zhimg.com/v2-38542298d56abdd1371c29c3b4f270a2_r.jpg\"/></noscript><img src=\"data:image/svg+xml;utf8,&lt;svg xmlns=&#39;http://www.w3.org/2000/svg&#39; width=&#39;480&#39; height=&#39;640&#39;&gt;&lt;/svg&gt;\" data-caption=\"\" data-size=\"normal\" data-rawwidth=\"480\" data-rawheight=\"640\" class=\"origin_image zh-lightbox-thumb lazy\" width=\"480\" data-original=\"https://pic3.zhimg.com/v2-38542298d56abdd1371c29c3b4f270a2_r.jpg\" data-actualsrc=\"https://pic3.zhimg.com/v2-38542298d56abdd1371c29c3b4f270a2_b.jpg\"/></figure><p class=\"ztext-empty-paragraph\"><br/></p><p>像拼音目录这样的索引，数据会根据索引中的顺序进行排列和组织的，这样的索引就被称为<b>聚集索引</b>，而<b>非聚集索引</b>就是其他的一般索引。因为数据只能按照一种规则排序，所以一张表至多有一个聚集索引，但可以有多个非聚集索引。</p><p>在MySQL数据库的<code>InnoDB</code>存储引擎中，主键索引就是聚集索引，所有数据都会按照主键索引进行组织；而在<code>MyISAM</code>存储引擎中，就没有聚集索引了，因为MyISAM存储引擎中的数据不是按索引顺序进行存储的。</p>", 
            "topic": [
                {
                    "tag": "后端技术", 
                    "tagLink": "https://api.zhihu.com/topics/19553595"
                }, 
                {
                    "tag": "数据库", 
                    "tagLink": "https://api.zhihu.com/topics/19552067"
                }, 
                {
                    "tag": "数据库设计", 
                    "tagLink": "https://api.zhihu.com/topics/19614808"
                }
            ], 
            "comments": [
                {
                    "userName": "forPython", 
                    "userLink": "https://www.zhihu.com/people/1a7fd6a72d05bac07d9bbc1aa5038c4a", 
                    "content": "非常谢谢，很形象", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "小毛驴", 
                    "userLink": "https://www.zhihu.com/people/6a90db3c7268bff44927418e868777b9", 
                    "content": "感谢作者！对于索引入门来说，真的是很好很好了！建议出连载", 
                    "likes": 1, 
                    "childComments": [
                        {
                            "userName": "兜里有辣条", 
                            "userLink": "https://www.zhihu.com/people/d9cb18d90114e43520ab647b103be438", 
                            "content": "<p>文章顶部有其他三篇数据库索引相关的文章链接，以后也会持续更新其他技术知识相关的文章，欢迎持续关注哦~</p>", 
                            "likes": 0, 
                            "replyToAuthor": "小毛驴"
                        }
                    ]
                }, 
                {
                    "userName": "hello world", 
                    "userLink": "https://www.zhihu.com/people/35e57a5e5bbdbc5908e76c79d37daf8f", 
                    "content": "别说了，爱你", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "谢然", 
                    "userLink": "https://www.zhihu.com/people/8f5fef858fd685f8ce2bca33cef13a2d", 
                    "content": "第一次给学生讲数据库索引的时候就是拿字典做的例子", 
                    "likes": 2, 
                    "childComments": []
                }, 
                {
                    "userName": "开发者头条", 
                    "userLink": "https://www.zhihu.com/people/274db6a56fae2771a5a22377b0b083d0", 
                    "content": "<p>感谢您的分享！已推荐到《开发者头条》首页，欢迎点赞支持！使用开发者头条 App 搜索 394815 即可订阅《Java后端火箭班》。</p>", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "猫小妖", 
                    "userLink": "https://www.zhihu.com/people/92de380f72a835402637a64e506edf13", 
                    "content": "太优秀了[赞]", 
                    "likes": 0, 
                    "childComments": []
                }, 
                {
                    "userName": "「已注销」", 
                    "userLink": "https://www.zhihu.com/people/3c7bb142485e20a8cfc92100b3b1f81c", 
                    "content": "小心视觉中觉[微笑][大笑][大笑][大笑][大笑][大笑][大笑]", 
                    "likes": 0, 
                    "childComments": []
                }
            ]
        }
    ], 
    "url": "https://zhuanlan.zhihu.com/java-rocket"
}
